{"sha": "f078dc7d269d8afd2874476181ee61662a16a3d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA3OGRjN2QyNjlkOGFmZDI4NzQ0NzYxODFlZTYxNjYyYTE2YTNkMA==", "commit": {"author": {"name": "Andrew Sutton", "email": "andrew.n.sutton@gmail.com", "date": "2016-07-21T06:05:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-07-21T06:05:24Z"}, "message": "Improving concepts performance and diagnostics.\n\n\tPR c++/67565\n\tPR c++/67579\n\tPR c++/71843\ngcc/\n\t* timevar.def (TV_CONSTRAINT_SAT, TV_CONSTRAINT_SUB): New time vars\n\tfor constraint satisfaction and subsumption.\n\t* timevar.h (auto_timevar): New constructor that matches the push/pop\n\tpattern of usage in pt.c.\ngcc/cp/\n\t* cp-tree.def (CHECK_CONSTR): New.\n\t* cp-tree.h (CHECK_CONSTR_CONCEPT): New.\n\t(CHECK_CONSTR_ARGS): New.\n\t* constraint.cc (make_predicate_constraint): Remove in favor of\n\tnormalize_expression.\n\t(resolve_constraint_check): Actually return error_mark_node when\n\tresolution fails.\n\t(resolve_variable_concept_check): Perform coercion as if processing\n\ta template. Also return errors on resolution failure.\n\t(lift_*): Remove all of these functions. Don't unnecessarily inline\n\tconcepts.\n\t(learn_*): Add facilities to memoize implications for subsumption\n\tduring normalization.\n\t(expanding_concept): New.\n\t(expand_concept): New. Return the inlined and normalized definition\n\tof a concept when needed.\n\t(transform_*, xform_*): Rename to normalize_* to better reflect the\n\tresponsibility of those functions.\n\t(normalize_template_id_expression): Check for non-boolean operands\n\twhen possible. Generate check constraints instead of normal variable\n\treferences.\n\t(normalize_call_expression): Report errors when resolution fails.\n\t(check_for_logical_overloads): Rewrite this check to more accurately\n\treport the error.\n\t(normalize_atom): Check for overloaded calls and invalid types before\n\tdetermining if the expression refers to a concept.\n\t(build_constraints): Don't cache normalized constraints or decmposed\n\tassumptions.\n\t(finish_shorthand_constraint): Return a normalized expression instead\n\tof a predicate constraint.\n\t(finish_template_introduction): Same.\n\t(placeholder_extract_concept_and_args): Rewrite this since we only\n\tever get check constraints here.\n\t(equivalent_placeholder_constraints): Rewrite in terms of check\n\tconstraints, and handle error_mark_nodes correctly.\n\t(tsubst_check_constraint, tsubst_expr_constr, tsubst_type_constr)\n\t(tsubst_implicit_conversion_constr)\n\t(tsubst_argument_deduction_constr, tsubst_exception_constr)\n\t(tsubst_parameterized_constraint, tsubst_constraint): New.\n\t(tsbust_conjunection): Replace with tsubst_logical_operator and\n\tactually generate the right kind of constraint.\n\t(tsubst_requirement_body): Reverse the order of substituted arguments\n\tso that they appear in the order written (helps diagnostics).\n\t(satisfy_check_constraint): New.\n\t(satisfy_conjunction): Simplify.\n\t(satisfy_disjunction): Same.\n\t(satisfy_constraint_1): Handle check constraints.\n\t(eval_constr): New (private) global state.\n\t(evaluating_constraints_sentinel): New. Manages eval_constr.\n\t(satisfy_constraint): Add timing variables.\n\t(satisfy_associated_constraints): Add hooks for memoization.\n\t(evaluate_function_concept): Build a check constraint instead of\n\tnormalizing its definition.\n\t(evaluate_variable_concept): Same.\n\t(evaluate_constraint_expression): Normalize, but in the current\n\tdeclaration processing context.\n\t(evaluating_constraints_p): New.\n\t(elide_constraint_failure_p): Actually emit constraint_thresh errors.\n\t(diagnose_*): Remove artificial indentation. Add a new parameter to\n\teach that tracks the current (complete) constraint prior to any\n\tsubstitutions.\n\t(diagnose_expression): Removed.\n\t(diagnose_call_expression): Same.\n\t(diagnose_template_id): Same.\n\t(diagnose_template_id): New.\n\t(diagnose_logical_constraint): New.\n\t(diagnose_expression_constraint): Show the original expression.\n\t(diagnose_type_constraint): Show the original type.\n\t(diagnose_implicit_conversion_constraint): Be specific about\n\tfailures, don't re-diagnose a known-to-be-failed substitutions,\n\tand manage elisions properly.\n\t(diagnose_argument_deduction_constraint): Same.\n\t(diagnose_exception_constraint): Same.\n\t(diagnose_parameterized_constraint): Same.\n\t(constraint_p): Allow EXPR_PACK_EXPANSION.\n\t* logic.cc (next_by_distance): Removed. No longer used.\n\t(any_p): Renamed from any_of.\n\t(term_entry, term_hasher): New.\n\t(term_list): Rewrite to include a hash table for quick lookup.\n\tAlso, make less stateful.\n\t(proof_state): Extend to allow goals to be discharged once\n\tsatisfied.\n\t(non_atomic_constraint_p): New.\n\t(any_non_atomic_constraints_p): New.\n\t(...rest...): Previous implementation completely replaced with an\n\titerative algorithm that opportunistically prunes the search space\n\tbefore committing to using more memory.\n\t* parser.c: (cp_parser_type_parameter): Normalize constraints.\n\t(cp_parser_explicit_template_declaration): Same.\n\t* pt.c: (finish_template_variable): Be less redundant with this error\n\tmessage.\n\t(template_args_equal): No longer static.\n\t(tsubst_decl): Don't try to find specializations of variables that\n\thave already been instantiated.\n\t(build_non_dependent_expr): Avoid infinite recursion during concept\n\texpansion.\n\t(make_constrained_auto): Normalize constraints.\n\t(do_auto_deduction): When doing auto deduction from a\n\tpartial-concept-id, be sure to include the explicit args checking\n\tthe constraints.\n\t(constraint_sat_*): New. Memoize satisfied constraints.\n\t(concept_spec_*): New. Memoize expressions associated with a concept\n\tspecialization.\n\t(constraint_memos, concept_memos): New.\n\t(lookup_constraint_satisfaction, memoize_constraint_satisfaction): New.\n\t(lookup_concept_satisfaction, memoize_concept_satisfaction): New.\n\t(get_concept_expansion, save_concept_expansion): New.\n\t(hash_subsumption_args): New.\n\t(comp_subsumption_args): New.\n\t(subsumption_*): New. Memoize parts of the subsumption relation.\n\t(lookup_subsumption_result, save_subsumption_result): New.\n\t(init_constraint_processing): Initialize memo tables.\n\t(get_constraints): Shortcut if !flag_concepts.\n\t* decl.c (grokfndecl): Normalize constraints.\n\t* error.c (dump_simple_decl): Print \"concept\" when appropriate.\n\t(dump_function_decl): Same.\n\t(dump_template_decl): Don't write requirements when we're not\n\tprinting the header.\n\t(dump_expr): Handle fold expressions.\n\t* cxx-pretty-print.c (cxx_pretty_printer::expression): Handle\n\tfold expressions.\n\t(get_fold_operator): New.\n\t(pp_cxx_unary_left_fold_expression): New.\n\t(pp_cxx_unary_right_fold_expression): New.\n\t(pp_cxx_binary_fold_expression): New.\n\t(pp_cxx_check_constraint): New.\n\t(pp_cxx_*_constraint): Rewrite the grammar of internal constraints\n\tto make them easier to read when debugging.\n\t* search.c (accessible_p): Don't shortcut when evaluating constraints.\n\t* tree.c (cp_tree_equal): Handle CHECK_CONSTR.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r238558", "tree": {"sha": "10c98df92b0da558ae20e1acc6534e67f94de96b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10c98df92b0da558ae20e1acc6534e67f94de96b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f078dc7d269d8afd2874476181ee61662a16a3d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f078dc7d269d8afd2874476181ee61662a16a3d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f078dc7d269d8afd2874476181ee61662a16a3d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f078dc7d269d8afd2874476181ee61662a16a3d0/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e17def9a701a30fb646d9dca317abe9b8ce308fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e17def9a701a30fb646d9dca317abe9b8ce308fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e17def9a701a30fb646d9dca317abe9b8ce308fe"}], "stats": {"total": 3230, "additions": 2316, "deletions": 914}, "files": [{"sha": "23a54e2ed752a3d8e5881d1fbdd1f54afd72343c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -1,3 +1,11 @@\n+2016-07-21  Andrew Sutton  <andrew.n.sutton@gmail.com>\n+\n+\tImproving concepts performance and diagnostics.\n+\t* timevar.def (TV_CONSTRAINT_SAT, TV_CONSTRAINT_SUB): New time vars\n+\tfor constraint satisfaction and subsumption.\n+\t* timevar.h (auto_timevar): New constructor that matches the push/pop\n+\tpattern of usage in pt.c.\n+\n 2016-07-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* hwint.h (HOST_WIDE_INT_0): New define."}, {"sha": "87dcaa82616ea62525915119871511ec59783a37", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -1,3 +1,141 @@\n+2016-07-21  Andrew Sutton  <andrew.n.sutton@gmail.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tImproving concepts performance and diagnostics.\n+\tPR c++/67565\n+\tPR c++/67579\n+\tPR c++/71843\n+\t* cp-tree.def (CHECK_CONSTR): New.\n+\t* cp-tree.h (CHECK_CONSTR_CONCEPT): New.\n+\t(CHECK_CONSTR_ARGS): New.\n+\t* constraint.cc (make_predicate_constraint): Remove in favor of\n+\tnormalize_expression.\n+\t(resolve_constraint_check): Actually return error_mark_node when\n+\tresolution fails.\n+\t(resolve_variable_concept_check): Perform coercion as if processing\n+\ta template. Also return errors on resolution failure.\n+\t(lift_*): Remove all of these functions. Don't unnecessarily inline\n+\tconcepts.\n+\t(learn_*): Add facilities to memoize implications for subsumption\n+\tduring normalization.\n+\t(expanding_concept): New.\n+\t(expand_concept): New. Return the inlined and normalized definition\n+\tof a concept when needed.\n+\t(transform_*, xform_*): Rename to normalize_* to better reflect the\n+\tresponsibility of those functions.\n+\t(normalize_template_id_expression): Check for non-boolean operands\n+\twhen possible. Generate check constraints instead of normal variable\n+\treferences.\n+\t(normalize_call_expression): Report errors when resolution fails.\n+\t(check_for_logical_overloads): Rewrite this check to more accurately\n+\treport the error.\n+\t(normalize_atom): Check for overloaded calls and invalid types before\n+\tdetermining if the expression refers to a concept.\n+\t(build_constraints): Don't cache normalized constraints or decomposed\n+\tassumptions.\n+\t(finish_shorthand_constraint): Return a normalized expression instead\n+\tof a predicate constraint.\n+\t(finish_template_introduction): Same.\n+\t(placeholder_extract_concept_and_args): Rewrite this since we only\n+\tever get check constraints here.\n+\t(equivalent_placeholder_constraints): Rewrite in terms of check\n+\tconstraints, and handle error_mark_nodes correctly.\n+\t(tsubst_check_constraint, tsubst_expr_constr, tsubst_type_constr)\n+\t(tsubst_implicit_conversion_constr)\n+\t(tsubst_argument_deduction_constr, tsubst_exception_constr)\n+\t(tsubst_parameterized_constraint, tsubst_constraint): New.\n+\t(tsbust_conjunection): Replace with tsubst_logical_operator and\n+\tactually generate the right kind of constraint.\n+\t(tsubst_requirement_body): Reverse the order of substituted arguments\n+\tso that they appear in the order written (helps diagnostics).\n+\t(satisfy_check_constraint): New.\n+\t(satisfy_conjunction): Simplify.\n+\t(satisfy_disjunction): Same.\n+\t(satisfy_constraint_1): Handle check constraints.\n+\t(eval_constr): New (private) global state.\n+\t(evaluating_constraints_sentinel): New. Manages eval_constr.\n+\t(satisfy_constraint): Add timing variables.\n+\t(satisfy_associated_constraints): Add hooks for memoization.\n+\t(evaluate_function_concept): Build a check constraint instead of\n+\tnormalizing its definition.\n+\t(evaluate_variable_concept): Same.\n+\t(evaluate_constraint_expression): Normalize, but in the current\n+\tdeclaration processing context.\n+\t(evaluating_constraints_p): New.\n+\t(elide_constraint_failure_p): Actually emit constraint_thresh errors.\n+\t(diagnose_*): Remove artificial indentation. Add a new parameter to\n+\teach that tracks the current (complete) constraint prior to any\n+\tsubstitutions.\n+\t(diagnose_expression): Removed.\n+\t(diagnose_call_expression): Same.\n+\t(diagnose_template_id): Same.\n+\t(diagnose_template_id): New.\n+\t(diagnose_logical_constraint): New.\n+\t(diagnose_expression_constraint): Show the original expression.\n+\t(diagnose_type_constraint): Show the original type.\n+\t(diagnose_implicit_conversion_constraint): Be specific about\n+\tfailures, don't re-diagnose a known-to-be-failed substitutions,\n+\tand manage elisions properly.\n+\t(diagnose_argument_deduction_constraint): Same.\n+\t(diagnose_exception_constraint): Same.\n+\t(diagnose_parameterized_constraint): Same.\n+\t(constraint_p): Allow EXPR_PACK_EXPANSION.\n+\t* logic.cc (next_by_distance): Removed. No longer used.\n+\t(any_p): Renamed from any_of.\n+\t(term_entry, term_hasher): New.\n+\t(term_list): Rewrite to include a hash table for quick lookup.\n+\tAlso, make less stateful.\n+\t(proof_state): Extend to allow goals to be discharged once\n+\tsatisfied.\n+\t(non_atomic_constraint_p): New.\n+\t(any_non_atomic_constraints_p): New.\n+\t(...rest...): Previous implementation completely replaced with an\n+\titerative algorithm that opportunistically prunes the search space\n+\tbefore committing to using more memory.\n+\t* parser.c: (cp_parser_type_parameter): Normalize constraints.\n+\t(cp_parser_explicit_template_declaration): Same.\n+\t* pt.c: (finish_template_variable): Be less redundant with this error\n+\tmessage.\n+\t(template_args_equal): No longer static.\n+\t(tsubst_decl): Don't try to find specializations of variables that\n+\thave already been instantiated.\n+\t(build_non_dependent_expr): Avoid infinite recursion during concept\n+\texpansion.\n+\t(make_constrained_auto): Normalize constraints.\n+\t(do_auto_deduction): When doing auto deduction from a\n+\tpartial-concept-id, be sure to include the explicit args checking\n+\tthe constraints.\n+\t(constraint_sat_*): New. Memoize satisfied constraints.\n+\t(concept_spec_*): New. Memoize expressions associated with a concept\n+\tspecialization.\n+\t(constraint_memos, concept_memos): New.\n+\t(lookup_constraint_satisfaction, memoize_constraint_satisfaction): New.\n+\t(lookup_concept_satisfaction, memoize_concept_satisfaction): New.\n+\t(get_concept_expansion, save_concept_expansion): New.\n+\t(hash_subsumption_args): New.\n+\t(comp_subsumption_args): New.\n+\t(subsumption_*): New. Memoize parts of the subsumption relation.\n+\t(lookup_subsumption_result, save_subsumption_result): New.\n+\t(init_constraint_processing): Initialize memo tables.\n+\t(get_constraints): Shortcut if !flag_concepts.\n+\t* decl.c (grokfndecl): Normalize constraints.\n+\t* error.c (dump_simple_decl): Print \"concept\" when appropriate.\n+\t(dump_function_decl): Same.\n+\t(dump_template_decl): Don't write requirements when we're not\n+\tprinting the header.\n+\t(dump_expr): Handle fold expressions.\n+\t* cxx-pretty-print.c (cxx_pretty_printer::expression): Handle\n+\tfold expressions.\n+\t(get_fold_operator): New.\n+\t(pp_cxx_unary_left_fold_expression): New.\n+\t(pp_cxx_unary_right_fold_expression): New.\n+\t(pp_cxx_binary_fold_expression): New.\n+\t(pp_cxx_check_constraint): New.\n+\t(pp_cxx_*_constraint): Rewrite the grammar of internal constraints\n+\tto make them easier to read when debugging.\n+\t* search.c (accessible_p): Don't shortcut when evaluating constraints.\n+\t* tree.c (cp_tree_equal): Handle CHECK_CONSTR.\n+\n 2016-07-20  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/70339"}, {"sha": "311d0257125b1420134e9c9db3304dddb8a3567b", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 992, "deletions": 545, "changes": 1537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"timevar.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\"\n #include \"vec.h\"\n@@ -55,7 +56,9 @@ along with GCC; see the file COPYING3.  If not see\n static inline bool\n constraint_p (tree_code c)\n {\n-  return (PRED_CONSTR <= c && c <= DISJ_CONSTR) || c == ERROR_MARK;\n+  return ((PRED_CONSTR <= c && c <= DISJ_CONSTR)\n+          || c == EXPR_PACK_EXPANSION\n+          || c == ERROR_MARK);\n }\n \n /* Returns true if T is a constraint. Note that error_mark_node\n@@ -67,14 +70,6 @@ constraint_p (tree t)\n   return constraint_p (TREE_CODE (t));\n }\n \n-/* Make a predicate constraint from the given expression. */\n-\n-tree\n-make_predicate_constraint (tree expr)\n-{\n-  return build_nt (PRED_CONSTR, expr);\n-}\n-\n /* Returns the conjunction of two constraints A and B. Note that\n    conjoining a non-null constraint with NULL_TREE is an identity\n    operation. That is, for non-null A,\n@@ -132,6 +127,53 @@ function_concept_check_p (tree t)\n   return false;\n }\n \n+/* Returns true if any of the arguments in the template\n+   argument list is a wildcard or wildcard pack.  */\n+\n+bool\n+contains_wildcard_p (tree args)\n+{\n+  for (int i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+    {\n+      tree arg = TREE_VEC_ELT (args, i);\n+      if (TREE_CODE (arg) == WILDCARD_DECL)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Build a new call expression, but don't actually generate a\n+   new function call. We just want the tree, not the semantics.  */\n+\n+inline tree\n+build_call_check (tree id)\n+{\n+  ++processing_template_decl;\n+  vec<tree, va_gc> *fargs = make_tree_vector();\n+  tree call = finish_call_expr (id, &fargs, false, false, tf_none);\n+  release_tree_vector (fargs);\n+  --processing_template_decl;\n+  return call;\n+}\n+\n+/* Build an expression that will check a variable concept. If any\n+   argument contains a wildcard, don't try to finish the variable\n+   template because we can't substitute into a non-existent\n+   declaration.  */\n+\n+tree\n+build_variable_check (tree id)\n+{\n+  gcc_assert (TREE_CODE (id) == TEMPLATE_ID_EXPR);\n+  if (contains_wildcard_p (TREE_OPERAND (id, 1)))\n+    return id;\n+\n+  ++processing_template_decl;\n+  tree var = finish_template_variable (id);\n+  --processing_template_decl;\n+  return var;\n+}\n+\n /*---------------------------------------------------------------------------\n                     Resolution of qualified concept names\n ---------------------------------------------------------------------------*/\n@@ -160,6 +202,7 @@ function_concept_check_p (tree t)\n static tree\n resolve_constraint_check (tree ovl, tree args)\n {\n+  int nerrs = 0;\n   tree cands = NULL_TREE;\n   for (tree p = ovl; p != NULL_TREE; p = OVL_NEXT (p))\n     {\n@@ -185,15 +228,21 @@ resolve_constraint_check (tree ovl, tree args)\n       ++processing_template_decl;\n       tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (tmpl));\n       if (tree subst = coerce_template_parms (parms, args, tmpl))\n-        if (subst != error_mark_node)\n-          cands = tree_cons (subst, fn, cands);\n+        {\n+          if (subst == error_mark_node)\n+            ++nerrs;\n+          else\n+\t    cands = tree_cons (subst, fn, cands);\n+        }\n       --processing_template_decl;\n     }\n \n-  // If we didn't find a unique candidate, then this is\n-  // not a constraint check.\n-  if (!cands || TREE_CHAIN (cands))\n-    return NULL_TREE;\n+  if (!cands)\n+    /* We either had no candidates or failed deductions.  */\n+    return nerrs ? error_mark_node : NULL_TREE;\n+  else if (TREE_CHAIN (cands))\n+    /* There are multiple candidates.  */\n+    return error_mark_node;\n \n   return cands;\n }\n@@ -250,14 +299,16 @@ resolve_variable_concept_check (tree id)\n      assuming that it works.  Note that failing to deduce\n      will result in diagnostics.  */\n   tree parms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n+  ++processing_template_decl;\n   tree result = coerce_template_parms (parms, args, tmpl);\n+  --processing_template_decl;\n   if (result != error_mark_node)\n     {\n       tree decl = DECL_TEMPLATE_RESULT (tmpl);\n       return build_tree_list (result, decl);\n     }\n   else\n-    return NULL_TREE;\n+    return error_mark_node;\n }\n \n \n@@ -315,45 +366,119 @@ deduce_concept_introduction (tree expr)\n namespace {\n \n /*---------------------------------------------------------------------------\n-                       Lifting of concept definitions\n+                       Constraint implication learning\n ---------------------------------------------------------------------------*/\n \n-/* Part of constraint normalization.  Whenever we find a reference to\n-   a variable concept or a call to a function concept, we lift or\n-   inline that concept's definition into the constraint.  This ensures\n-   that constraints are always checked in the immediate instantiation\n-   context. */\n+/* The implication context determines how we memoize concept checks.\n+   Given two checks C1 and C2, the direction of implication depends\n+   on whether we are learning implications of a conjunction or disjunction.\n+   For example:\n \n-tree lift_expression (tree);\n+      template<typename T> concept bool C = ...;\n+      template<typenaem T> concept bool D = C<T> && true;\n \n-/* If the tree T has operands, then lift any concepts out of them.  */\n-tree\n-lift_operands (tree t)\n+   From this, we can learn that D<T> implies C<T>. We cannot learn,\n+   without further testing, that C<T> does not imply D<T>. If, for\n+   example, C<T> were defined as true, then these constraints would\n+   be logically equivalent.\n+\n+   In rare cases, we may start with a logical equivalence. For example:\n+\n+      template<typename T> concept bool C = ...;\n+      template<typename T> concept bool D = C<T>;\n+\n+   Here, we learn that C<T> implies D<T> and vice versa.   */\n+\n+enum implication_context\n+{\n+  conjunction_cxt, /* C1 implies C2. */\n+  disjunction_cxt, /* C2 implies C1. */\n+  equivalence_cxt  /* C1 implies C2, C2 implies C1. */\n+};\n+\n+void learn_implications(tree, tree, implication_context);\n+\n+void\n+learn_implication (tree parent, tree child, implication_context cxt)\n {\n-  if (int n = tree_operand_length (t))\n+  switch (cxt)\n     {\n-      t = copy_node (t);\n-      for (int i = 0; i < n; ++i)\n-        TREE_OPERAND (t, i) = lift_expression (TREE_OPERAND (t, i));\n+      case conjunction_cxt:\n+        save_subsumption_result (parent, child, true);\n+        break;\n+      case disjunction_cxt:\n+        save_subsumption_result (child, parent, true);\n+        break;\n+      case equivalence_cxt:\n+        save_subsumption_result (parent, child, true);\n+        save_subsumption_result (child, parent, true);\n+        break;\n     }\n-  return t;\n }\n \n-/* Recursively lift all operands of the function call. Also, check\n-   that the call target is not accidentally a variable concept\n-   since that's ill-formed.  */\n-tree\n-lift_function_call (tree t)\n+void\n+learn_logical_operation (tree parent, tree constr, implication_context cxt)\n {\n-  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n-  gcc_assert (!VAR_P (CALL_EXPR_FN (t)));\n-  return lift_operands (t);\n+  learn_implications (parent, TREE_OPERAND (constr, 0), cxt);\n+  learn_implications (parent, TREE_OPERAND (constr, 1), cxt);\n }\n \n-/* Inline a function (concept) definition by substituting\n-   ARGS into its body. */\n+void\n+learn_implications (tree parent, tree constr, implication_context cxt)\n+{\n+  switch (TREE_CODE (constr))\n+    {\n+      case CHECK_CONSTR:\n+        return learn_implication (parent, constr, cxt);\n+\n+      case CONJ_CONSTR:\n+        if (cxt == disjunction_cxt)\n+          return;\n+        return learn_logical_operation (parent, constr, cxt);\n+\n+      case DISJ_CONSTR:\n+        if (cxt == conjunction_cxt)\n+          return;\n+        return learn_logical_operation (parent, constr, cxt);\n+\n+      default:\n+        break;\n+    }\n+}\n+\n+/* Quickly scan the top-level constraints of CONSTR to learn and\n+   cache logical relations between concepts.  The search does not\n+   include conjunctions of disjunctions or vice versa.  */\n+\n+void\n+learn_implications (tree tmpl, tree args, tree constr)\n+{\n+  /* Don't memoize relations between non-dependent arguemnts. It's not\n+     helpful. */\n+  if (!uses_template_parms (args))\n+    return;\n+\n+  /* Build a check constraint for the purpose of caching. */\n+  tree parent = build_nt (CHECK_CONSTR, tmpl, args);\n+\n+  /* Start learning based on the kind of the top-level contraint. */\n+  if (TREE_CODE (constr) == CONJ_CONSTR)\n+    return learn_logical_operation (parent, constr, conjunction_cxt);\n+  else if (TREE_CODE (constr) == DISJ_CONSTR)\n+    return learn_logical_operation (parent, constr, disjunction_cxt);\n+  else if (TREE_CODE (constr) == CHECK_CONSTR)\n+    /* This is the rare concept alias case. */\n+    return learn_implication (parent, constr, equivalence_cxt);\n+}\n+\n+/*---------------------------------------------------------------------------\n+                       Expansion of concept definitions\n+---------------------------------------------------------------------------*/\n+\n+/* Returns the expression of a function concept. */\n+\n tree\n-lift_function_definition (tree fn, tree args)\n+get_returned_expression (tree fn)\n {\n   /* Extract the body of the function minus the return expression.  */\n   tree body = DECL_SAVED_TREE (fn);\n@@ -364,218 +489,123 @@ lift_function_definition (tree fn, tree args)\n   if (TREE_CODE (body) != RETURN_EXPR)\n     return error_mark_node;\n \n-  body = TREE_OPERAND (body, 0);\n-\n-  /* Substitute template arguments to produce our inline expression.  */\n-  tree result = tsubst_expr (body, args, tf_none, NULL_TREE, false);\n-  if (result == error_mark_node)\n-    return error_mark_node;\n-\n-  return lift_expression (result);\n+  return TREE_OPERAND (body, 0);\n }\n \n-/* Inline a reference to a function concept.  */\n-tree\n-lift_call_expression (tree t)\n-{\n-  /* Try to resolve this function call as a concept.  If not, then\n-     it can be returned as-is.  */\n-  tree check = resolve_constraint_check (t);\n-  if (!check)\n-    return lift_function_call (t);\n-  if (check == error_mark_node)\n-    return error_mark_node;\n-\n-  tree fn = TREE_VALUE (check);\n-  tree args = TREE_PURPOSE (check);\n-  return lift_function_definition (fn, args);\n-}\n+/* Returns the initializer of a variable concept. */\n \n tree\n-lift_variable_initializer (tree var, tree args)\n+get_variable_initializer (tree var)\n {\n-  /* Extract the body from the variable initializer.  */\n   tree init = DECL_INITIAL (var);\n   if (!init)\n     return error_mark_node;\n+  return init;\n+}\n \n-  /* Substitute the arguments to form our new inline expression.  */\n-  tree result = tsubst_expr (init, args, tf_none, NULL_TREE, false);\n-  if (result == error_mark_node)\n-    return error_mark_node;\n+/* Returns the definition of a variable or function concept.  */\n \n-  return lift_expression (result);\n+tree\n+get_concept_definition (tree decl)\n+{\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    return get_variable_initializer (decl);\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n+    return get_returned_expression (decl);\n+  gcc_unreachable ();\n }\n \n-/* Determine if a template-id is a variable concept and inline.  */\n+int expansion_level = 0;\n \n-tree\n-lift_template_id (tree t)\n+struct expanding_concept_sentinel\n {\n-  if (tree info = resolve_variable_concept_check (t))\n-    {\n-      tree decl = TREE_VALUE (info);\n-      tree args = TREE_PURPOSE (info);\n-      return lift_variable_initializer (decl, args);\n-    }\n+  expanding_concept_sentinel ()\n+  {\n+    ++expansion_level;\n+  }\n \n-  /* Check that we didn't refer to a function concept like\n-      a variable.\n+  ~expanding_concept_sentinel()\n+  {\n+    --expansion_level;\n+  }\n+};\n \n-     TODO: Add a note on how to fix this.  */\n-  tree tmpl = TREE_OPERAND (t, 0);\n-  if (TREE_CODE (tmpl) == OVERLOAD)\n-    {\n-      tree fn = OVL_FUNCTION (tmpl);\n-      if (TREE_CODE (fn) == TEMPLATE_DECL\n-          && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))\n-        {\n-          error_at (location_of (t),\n-\t\t    \"invalid reference to function concept %qD\", fn);\n-          return error_mark_node;\n-        }\n-    }\n \n-  return t;\n-}\n+} /* namespace */\n \n-/* Lift any constraints appearing in a nested requirement of\n-   a requires-expression. */\n-tree\n-lift_requires_expression (tree t)\n+/* Returns true when a concept is being expanded.  */\n+\n+bool\n+expanding_concept()\n {\n-  tree parms = TREE_OPERAND (t, 0);\n-  tree reqs = TREE_OPERAND (t, 1);\n-  tree result = NULL_TREE;\n-  for (; reqs != NULL_TREE; reqs = TREE_CHAIN (reqs))\n-    {\n-      tree req = TREE_VALUE (reqs);\n-      if (TREE_CODE (req) == NESTED_REQ)\n-        {\n-          tree expr = lift_expression (TREE_OPERAND (req, 0));\n-          req = finish_nested_requirement (expr);\n-        }\n-      result = tree_cons (NULL_TREE, req, result);\n-    }\n-  return finish_requires_expr (parms, result);\n+  return expansion_level > 0;\n }\n \n-/* Inline references to specializations of concepts.  */\n+/* Expand a concept declaration (not a template) and its arguments to\n+   a constraint defined by the concept's initializer or definition.  */\n+\n tree\n-lift_expression (tree t)\n+expand_concept (tree decl, tree args)\n {\n-  if (t == NULL_TREE)\n-    return NULL_TREE;\n+  expanding_concept_sentinel sentinel;\n \n-  if (t == error_mark_node)\n-    return error_mark_node;\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    decl = DECL_TEMPLATE_RESULT (decl);\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n \n-  /* Concepts can be referred to by call or variable. All other\n-     nodes are preserved.  */\n-  switch (TREE_CODE (t))\n-    {\n-    case CALL_EXPR:\n-      return lift_call_expression (t);\n+  /* Check for a previous specialization. */\n+  if (tree spec = get_concept_expansion (tmpl, args))\n+    return spec;\n \n-    case TEMPLATE_ID_EXPR:\n-      return lift_template_id (t);\n+  /* Substitute the arguments to form a new definition expression.  */\n+  tree def = get_concept_definition (decl);\n \n-    case REQUIRES_EXPR:\n-      return lift_requires_expression (t);\n-\n-    case EXPR_PACK_EXPANSION:\n-      /* Use copy_node rather than make_pack_expansion so that\n-\t PACK_EXPANSION_PARAMETER_PACKS stays the same.  */\n-      t = copy_node (t);\n-      SET_PACK_EXPANSION_PATTERN\n-\t(t, lift_expression (PACK_EXPANSION_PATTERN (t)));\n-      return t;\n-\n-    case TREE_LIST:\n-      {\n-        t = copy_node (t);\n-        TREE_VALUE (t) = lift_expression (TREE_VALUE (t));\n-        TREE_CHAIN (t) = lift_expression (TREE_CHAIN (t));\n-        return t;\n-      }\n+  ++processing_template_decl;\n+  tree result = tsubst_expr (def, args, tf_none, NULL_TREE, true);\n+  --processing_template_decl;\n+  if (result == error_mark_node)\n+    return error_mark_node;\n \n-    default:\n-      return lift_operands (t);\n-    }\n+  /* And lastly, normalize it, check for implications, and save\n+     the specialization for later.  */\n+  tree norm = normalize_expression (result);\n+  learn_implications (tmpl, args, norm);\n+  return save_concept_expansion (tmpl, args, norm);\n }\n \n-/*---------------------------------------------------------------------------\n-                Transformation of expressions into constraints\n----------------------------------------------------------------------------*/\n-\n-/* Part of constraint normalization. The following functions rewrite\n-   expressions as constraints.  */\n-\n-tree transform_expression (tree);\n-\n-/* Check that the logical-or or logical-and expression does\n-   not result in a call to a user-defined user-defined operator\n-   (temp.constr.op). Returns true if the logical operator is\n-   admissible and false otherwise. */\n \n-bool\n-check_logical_expr (tree t)\n-{\n-  /* We can't do much for type dependent expressions. */\n-  if (type_dependent_expression_p (t))\n-    return true;\n+/*---------------------------------------------------------------------------\n+                Stepwise normalization of expressions\n \n-  /* Resolve the logical operator. Note that template processing is\n-     disabled so we get the actual call or target expression back.\n-     not_processing_template_sentinel sentinel.\n-\n-     TODO: This check is actually subsumed by the requirement that\n-     constraint operands have type bool. I'm not sure we need it\n-     unless we allow conversions.  */\n-  tree arg1 = TREE_OPERAND (t, 0);\n-  tree arg2 = TREE_OPERAND (t, 1);\n-  tree ovl = NULL_TREE;\n-  tree expr = build_x_binary_op (EXPR_LOC_OR_LOC (arg2, input_location),\n-                                 TREE_CODE (t),\n-                                 arg1, TREE_CODE (arg1),\n-                                 arg2, TREE_CODE (arg2),\n-                                 &ovl,\n-                                 tf_none);\n-  if (TREE_CODE (expr) != TREE_CODE (t))\n-    {\n-      error (\"user-defined operator %qs in constraint %q+E\",\n-\t     operator_name_info[TREE_CODE (t)].name, t);\n-      return false;\n-    }\n-  return true;\n-}\n+This set of functions will transform an expression into a constraint\n+in a sequence of steps. Normalization does not not look into concept\n+definitions.\n+---------------------------------------------------------------------------*/\n \n /* Transform a logical-or or logical-and expression into either\n    a conjunction or disjunction. */\n \n tree\n-xform_logical (tree t, tree_code c)\n+normalize_logical_operation (tree t, tree_code c)\n {\n-  if (!check_logical_expr (t))\n-    return error_mark_node;\n-  tree t0 = transform_expression (TREE_OPERAND (t, 0));\n-  tree t1 = transform_expression (TREE_OPERAND (t, 1));\n+  tree t0 = normalize_expression (TREE_OPERAND (t, 0));\n+  tree t1 = normalize_expression (TREE_OPERAND (t, 1));\n   return build_nt (c, t0, t1);\n }\n \n /* A simple requirement T introduces an expression constraint\n    for its expression. */\n \n inline tree\n-xform_simple_requirement (tree t)\n+normalize_simple_requirement (tree t)\n {\n   return build_nt (EXPR_CONSTR, TREE_OPERAND (t, 0));\n }\n \n /* A type requirement T introduce a type constraint for its type.  */\n \n inline tree\n-xform_type_requirement (tree t)\n+normalize_type_requirement (tree t)\n {\n   return build_nt (TYPE_CONSTR, TREE_OPERAND (t, 0));\n }\n@@ -589,7 +619,7 @@ xform_type_requirement (tree t)\n    includes an exception constraint.  */\n \n tree\n-xform_compound_requirement (tree t)\n+normalize_compound_requirement (tree t)\n {\n   tree expr = TREE_OPERAND (t, 0);\n   tree constr = build_nt (EXPR_CONSTR, TREE_OPERAND (t, 0));\n@@ -627,29 +657,29 @@ xform_compound_requirement (tree t)\n    will guarantee that the constraint is never satisfied.  */\n \n inline tree\n-xform_nested_requirement (tree t)\n+normalize_nested_requirement (tree t)\n {\n-  return transform_expression (TREE_OPERAND (t, 0));\n+  return normalize_expression (TREE_OPERAND (t, 0));\n }\n \n /* Transform a requirement T into one or more constraints.  */\n \n tree\n-xform_requirement (tree t)\n+normalize_requirement (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case SIMPLE_REQ:\n-      return xform_simple_requirement (t);\n+      return normalize_simple_requirement (t);\n \n     case TYPE_REQ:\n-      return xform_type_requirement (t);\n+      return normalize_type_requirement (t);\n \n     case COMPOUND_REQ:\n-      return xform_compound_requirement (t);\n+      return normalize_compound_requirement (t);\n \n     case NESTED_REQ:\n-      return xform_nested_requirement (t);\n+      return normalize_nested_requirement (t);\n \n     default:\n       gcc_unreachable ();\n@@ -661,46 +691,165 @@ xform_requirement (tree t)\n    constraints. */\n \n tree\n-xform_requirements (tree t)\n+normalize_requirements (tree t)\n {\n   tree result = NULL_TREE;\n   for (; t; t = TREE_CHAIN (t))\n     {\n-      tree constr = xform_requirement (TREE_VALUE (t));\n+      tree constr = normalize_requirement (TREE_VALUE (t));\n       result = conjoin_constraints (result, constr);\n     }\n   return result;\n }\n \n-/* Transform a requires-expression into a parameterized constraint.  */\n+/* The normal form of a requires-expression is a parameterized\n+   constraint having the same parameters and a conjunction of\n+   constraints representing the normal form of requirements.  */\n \n tree\n-xform_requires_expr (tree t)\n+normalize_requires_expression (tree t)\n {\n-  tree operand = xform_requirements (TREE_OPERAND (t, 1));\n+  tree operand = normalize_requirements (TREE_OPERAND (t, 1));\n   if (tree parms = TREE_OPERAND (t, 0))\n     return build_nt (PARM_CONSTR, parms, operand);\n   else\n     return operand;\n }\n \n-/* Transform an expression into an atomic predicate constraint.\n-   After substitution, the expression of a predicate constraint\n-   shall have type bool (temp.constr.pred).  For non-type-dependent\n-   expressions, we can check that now.  */\n+/* For a template-id referring to a variable concept, returns\n+   a check constraint. Otherwise, returns a predicate constraint. */\n \n tree\n-xform_atomic (tree t)\n+normalize_template_id_expression (tree t)\n {\n-  if (TREE_TYPE (t) && !type_dependent_expression_p (t))\n-  {\n-    tree type = cv_unqualified (TREE_TYPE (t));\n-    if (!same_type_p (type, boolean_type_node))\n-      {\n-        error (\"predicate constraint %q+E does not have type %<bool%>\", t);\n+  if (tree info = resolve_variable_concept_check (t))\n+    {\n+      if (info == error_mark_node)\n+        {\n+          /* We get this when the template arguments don't match\n+             the variable concept. */\n+          error (\"invalid reference to concept %qE\", t);\n+          return error_mark_node;\n+        }\n+\n+      tree decl = TREE_VALUE (info);\n+      tree args = TREE_PURPOSE (info);\n+      return build_nt (CHECK_CONSTR, decl, args);\n+    }\n+\n+  /* Check that we didn't refer to a function concept like a variable.  */\n+  tree tmpl = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (tmpl) == OVERLOAD)\n+    {\n+      tree fn = OVL_FUNCTION (tmpl);\n+      if (TREE_CODE (fn) == TEMPLATE_DECL\n+          && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))\n+        {\n+          error_at (location_of (t),\n+                    \"invalid reference to function concept %qD\", fn);\n+          return error_mark_node;\n+        }\n+    }\n+\n+  return build_nt (PRED_CONSTR, t);\n+}\n+\n+/* For a call expression to a function concept, returns a check\n+   constraint. Otherwise, returns a predicate constraint. */\n+\n+tree\n+normalize_call_expression (tree t)\n+{\n+  /* Try to resolve this function call as a concept.  If not, then\n+     it can be returned as a predicate constraint.  */\n+  tree check = resolve_constraint_check (t);\n+  if (!check)\n+    return build_nt (PRED_CONSTR, t);\n+  if (check == error_mark_node)\n+    {\n+      /* TODO: Improve diagnostics. We could report why the reference\n+         is invalid. */\n+      error (\"invalid reference to concept %qE\", t);\n+      return error_mark_node;\n+    }\n+\n+  tree fn = TREE_VALUE (check);\n+  tree args = TREE_PURPOSE (check);\n+  return build_nt (CHECK_CONSTR, fn, args);\n+}\n+\n+/* If T is a call to an overloaded && or || operator, diagnose that\n+   as a non-SFINAEable error.  Returns true if an error is emitted.\n+\n+   TODO: It would be better to diagnose this at the point of definition,\n+   if possible. Perhaps we should immediately do a first-pass normalization\n+   of a concept definition to catch obvious non-dependent errors like\n+   this.  */\n+\n+bool\n+check_for_logical_overloads (tree t)\n+{\n+  if (TREE_CODE (t) != CALL_EXPR)\n+    return false;\n+\n+  tree fn = CALL_EXPR_FN (t);\n+\n+  /* For member calls, try extracting the function from the\n+     component ref.  */\n+  if (TREE_CODE (fn) == COMPONENT_REF)\n+    {\n+      fn = TREE_OPERAND (fn, 1);\n+      if (TREE_CODE (fn) == BASELINK)\n+        fn = BASELINK_FUNCTIONS (fn);\n+    }\n+\n+  if (TREE_CODE (fn) != FUNCTION_DECL)\n+    return false;\n+\n+  if (DECL_OVERLOADED_OPERATOR_P (fn))\n+    {\n+      location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+      error_at (loc, \"constraint %qE, uses overloaded operator\", t);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* The normal form of an atom depends on the expression. The normal\n+   form of a function call to a function concept is a check constraint\n+   for that concept. The normal form of a reference to a variable\n+   concept is a check constraint for that concept. Otherwise, the\n+   constraint is a predicate constraint.  */\n+\n+tree\n+normalize_atom (tree t)\n+{\n+  /* We can get constraints pushed down through pack expansions, so\n+     just return them. */\n+  if (constraint_p (t))\n+    return t;\n+\n+  tree type = TREE_TYPE (t);\n+  if (!type || type_unknown_p (t) || TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+    ;\n+  else if (!dependent_type_p (type))\n+    {\n+      if (check_for_logical_overloads (t))\n         return error_mark_node;\n-      }\n-  }\n+\n+      type = cv_unqualified (type);\n+      if (!same_type_p (type, boolean_type_node))\n+\t{\n+\t  error (\"predicate constraint %q+E does not have type %<bool%>\", t);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)\n+    return normalize_template_id_expression (t);\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    return normalize_call_expression (t);\n   return build_nt (PRED_CONSTR, t);\n }\n \n@@ -735,49 +884,48 @@ push_down_pack_expansion (tree exp, tree pat)\n    leaves of the constraint so that partial ordering will work.  */\n \n tree\n-xform_pack_expansion (tree t)\n+normalize_pack_expansion (tree t)\n {\n-  tree pat = transform_expression (PACK_EXPANSION_PATTERN (t));\n+  tree pat = normalize_expression (PACK_EXPANSION_PATTERN (t));\n   return push_down_pack_expansion (t, pat);\n }\n \n /* Transform an expression into a constraint.  */\n \n tree\n-xform_expr (tree t)\n+normalize_any_expression (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case TRUTH_ANDIF_EXPR:\n-      return xform_logical (t, CONJ_CONSTR);\n+      return normalize_logical_operation (t, CONJ_CONSTR);\n \n     case TRUTH_ORIF_EXPR:\n-      return xform_logical (t, DISJ_CONSTR);\n+      return normalize_logical_operation (t, DISJ_CONSTR);\n \n     case REQUIRES_EXPR:\n-      return xform_requires_expr (t);\n+      return normalize_requires_expression (t);\n \n     case BIND_EXPR:\n-      return transform_expression (BIND_EXPR_BODY (t));\n+      return normalize_expression (BIND_EXPR_BODY (t));\n \n     case EXPR_PACK_EXPANSION:\n-      return xform_pack_expansion (t);\n+      return normalize_pack_expansion (t);\n \n     default:\n       /* All other constraints are atomic. */\n-      return xform_atomic (t);\n+      return normalize_atom (t);\n     }\n }\n \n /* Transform a statement into an expression.  */\n-\n tree\n-xform_stmt (tree t)\n+normalize_any_statement (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case RETURN_EXPR:\n-      return transform_expression (TREE_OPERAND (t, 0));\n+      return normalize_expression (TREE_OPERAND (t, 0));\n     default:\n       gcc_unreachable ();\n     }\n@@ -787,24 +935,22 @@ xform_stmt (tree t)\n /* Reduction rules for the declaration T.  */\n \n tree\n-xform_decl (tree t)\n+normalize_any_declaration (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case VAR_DECL:\n-      return xform_atomic (t);\n+      return normalize_atom (t);\n     default:\n       gcc_unreachable ();\n     }\n   return error_mark_node;\n }\n \n-/* Transform a lifted expression into a constraint. This either\n-   returns a constraint, or it returns error_mark_node when\n-   a constraint cannot be formed.  */\n+/* Returns the normal form of a constraint expression. */\n \n tree\n-transform_expression (tree t)\n+normalize_expression (tree t)\n {\n   if (!t)\n     return NULL_TREE;\n@@ -818,20 +964,20 @@ transform_expression (tree t)\n     case tcc_binary:\n     case tcc_expression:\n     case tcc_vl_exp:\n-      return xform_expr (t);\n+      return normalize_any_expression (t);\n \n     case tcc_statement:\n-      return xform_stmt (t);\n+      return normalize_any_statement (t);\n \n     case tcc_declaration:\n-      return xform_decl (t);\n+      return normalize_any_declaration (t);\n \n     case tcc_exceptional:\n     case tcc_constant:\n     case tcc_reference:\n     case tcc_comparison:\n       /* These are all atomic predicate constraints. */\n-      return xform_atomic (t);\n+      return normalize_atom (t);\n \n     default:\n       /* Unhandled node kind. */\n@@ -840,6 +986,7 @@ transform_expression (tree t)\n   return error_mark_node;\n }\n \n+\n /*---------------------------------------------------------------------------\n                         Constraint normalization\n ---------------------------------------------------------------------------*/\n@@ -879,8 +1026,7 @@ normalize_predicate_constraint (tree t)\n {\n   ++processing_template_decl;\n   tree expr = PRED_CONSTR_EXPR (t);\n-  tree lifted = lift_expression (expr);\n-  tree constr = transform_expression (lifted);\n+  tree constr = normalize_expression (expr);\n   --processing_template_decl;\n   return constr;\n }\n@@ -938,7 +1084,6 @@ normalize_constraint (tree t)\n   return error_mark_node;\n }\n \n-} /* namespace */\n \n \n // -------------------------------------------------------------------------- //\n@@ -1028,61 +1173,11 @@ build_constraints (tree tmpl_reqs, tree decl_reqs)\n   ci->declarator_reqs = decl_reqs;\n   ci->associated_constr = conjoin_constraints (tmpl_reqs, decl_reqs);\n \n-  ++processing_template_decl;\n-  ci->normalized_constr = normalize_constraint (ci->associated_constr);\n-  --processing_template_decl;\n-\n-  ci->assumptions = decompose_assumptions (ci->normalized_constr);\n   return (tree)ci;\n }\n \n namespace {\n \n-/* Returns true if any of the arguments in the template\n-   argument list is a wildcard or wildcard pack. */\n-bool\n-contains_wildcard_p (tree args)\n-{\n-  for (int i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-    {\n-      tree arg = TREE_VEC_ELT (args, i);\n-      if (TREE_CODE (arg) == WILDCARD_DECL)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-/* Build a new call expression, but don't actually generate\n-   a new function call. We just want the tree, not the\n-   semantics. */\n-inline tree\n-build_call_check (tree id)\n-{\n-  ++processing_template_decl;\n-  vec<tree, va_gc> *fargs = make_tree_vector();\n-  tree call = finish_call_expr (id, &fargs, false, false, tf_none);\n-  release_tree_vector (fargs);\n-  --processing_template_decl;\n-  return call;\n-}\n-\n-/* Build an expression that will check a variable concept. If any\n-   argument contains a wildcard, don't try to finish the variable\n-   template because we can't substitute into a non-existent\n-   declaration.  */\n-tree\n-build_variable_check (tree id)\n-{\n-  gcc_assert (TREE_CODE (id) == TEMPLATE_ID_EXPR);\n-  if (contains_wildcard_p (TREE_OPERAND (id, 1)))\n-    return id;\n-\n-  ++processing_template_decl;\n-  tree var = finish_template_variable (id);\n-  --processing_template_decl;\n-  return var;\n-}\n-\n /* Construct a sequence of template arguments by prepending\n    ARG to REST. Either ARG or REST may be null. */\n tree\n@@ -1158,7 +1253,9 @@ build_constrained_parameter (tree cnc, tree proto, tree args)\n \n    Note that the constraints are neither reduced nor decomposed.\n    That is done only after the requires clause has been parsed\n-   (or not). */\n+   (or not).\n+\n+   This will always return a CHECK_CONSTR. */\n tree\n finish_shorthand_constraint (tree decl, tree constr)\n {\n@@ -1207,7 +1304,7 @@ finish_shorthand_constraint (tree decl, tree constr)\n       TREE_TYPE (check) = boolean_type_node;\n     }\n \n-  return make_predicate_constraint (check);\n+  return normalize_expression (check);\n }\n \n /* Returns a conjunction of shorthand requirements for the template\n@@ -1346,7 +1443,7 @@ finish_template_introduction (tree tmpl_decl, tree intro_list)\n \n   /* Associate the constraint. */\n   tree check = build_concept_check (tmpl_decl, NULL_TREE, check_args);\n-  tree constr = make_predicate_constraint (check);\n+  tree constr = normalize_expression (check);\n   TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = constr;\n \n   return parm_list;\n@@ -1362,41 +1459,28 @@ placeholder_extract_concept_and_args (tree t, tree &tmpl, tree &args)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n     {\n-      /* A constrained parameter.  */\n-      tmpl = DECL_TI_TEMPLATE (CONSTRAINED_PARM_CONCEPT (t));\n-      args = CONSTRAINED_PARM_EXTRA_ARGS (t);\n+      /* A constrained parameter.  Build a constraint check\n+         based on the prototype parameter and then extract the\n+         arguments from that.  */\n+      tree proto = CONSTRAINED_PARM_PROTOTYPE (t);\n+      tree check = finish_shorthand_constraint (proto, t);\n+      placeholder_extract_concept_and_args (check, tmpl, args);\n       return;\n     }\n \n-  gcc_assert (TREE_CODE (t) == PRED_CONSTR);\n-  t = PRED_CONSTR_EXPR (t);\n-  gcc_assert (TREE_CODE (t) == CALL_EXPR\n-              || TREE_CODE (t) == TEMPLATE_ID_EXPR\n-              || VAR_P (t));\n-\n-  if (TREE_CODE (t) == CALL_EXPR)\n-    t = CALL_EXPR_FN (t);\n-  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)\n+  if (TREE_CODE (t) == CHECK_CONSTR)\n     {\n-      tmpl = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (tmpl) == OVERLOAD)\n-\t{\n-\t  gcc_assert (OVL_CHAIN (tmpl) == NULL_TREE);\n-\t  tmpl = OVL_FUNCTION (tmpl);\n-\t}\n-      args = TREE_OPERAND (t, 1);\n-    }\n-  else if (DECL_P (t))\n-    {\n-      tmpl = DECL_TI_TEMPLATE (t);\n-      args = DECL_TI_ARGS (t);\n+      tree decl = CHECK_CONSTR_CONCEPT (t);\n+      tmpl = DECL_TI_TEMPLATE (decl);\n+      args = CHECK_CONSTR_ARGS (t);\n+      return;\n     }\n-  else\n+\n     gcc_unreachable ();\n }\n \n /* Returns true iff the placeholders C1 and C2 are equivalent.  C1\n-   and C2 can be either PRED_CONSTR_EXPR or TEMPLATE_TYPE_PARM.  */\n+   and C2 can be either CHECK_CONSTR or TEMPLATE_TYPE_PARM.  */\n \n bool\n equivalent_placeholder_constraints (tree c1, tree c2)\n@@ -1411,6 +1495,11 @@ equivalent_placeholder_constraints (tree c1, tree c2)\n     return true;\n   if (!c1 || !c2)\n     return false;\n+  if (c1 == error_mark_node || c2 == error_mark_node)\n+    /* We get here during satisfaction; when a deduction constraint\n+       fails, substitution can produce an error_mark_node for the\n+       placeholder constraints.  */\n+    return false;\n \n   tree t1, t2, a1, a2;\n   placeholder_extract_concept_and_args (c1, t1, a1);\n@@ -1419,21 +1508,20 @@ equivalent_placeholder_constraints (tree c1, tree c2)\n   if (t1 != t2)\n     return false;\n \n-  /* Skip the first argument to avoid infinite recursion on the\n-     placeholder auto itself.  */\n-  bool skip1 = (TREE_CODE (c1) == PRED_CONSTR);\n-  bool skip2 = (TREE_CODE (c2) == PRED_CONSTR);\n-\n-  int len1 = (a1 ? TREE_VEC_LENGTH (a1) : 0) - skip1;\n-  int len2 = (a2 ? TREE_VEC_LENGTH (a2) : 0) - skip2;\n-\n+  int len1 = TREE_VEC_LENGTH (a1);\n+  int len2 = TREE_VEC_LENGTH (a2);\n   if (len1 != len2)\n     return false;\n \n-  for (int i = 0; i < len1; ++i)\n-    if (!cp_tree_equal (TREE_VEC_ELT (a1, i + skip1),\n-\t\t\tTREE_VEC_ELT (a2, i + skip2)))\n+  /* Skip the first argument so we don't infinitely recurse.\n+     Also, they may differ in template parameter index.  */\n+  for (int i = 1; i < len1; ++i)\n+    {\n+      tree t1 = TREE_VEC_ELT (a1, i);\n+      tree t2 = TREE_VEC_ELT (a2, i);\n+      if (!template_args_equal (t1, t2))\n       return false;\n+    }\n   return true;\n }\n \n@@ -1492,40 +1580,139 @@ tsubst_predicate_constraint (tree t, tree args,\n   return build_nt (PRED_CONSTR, result);\n }\n \n+/* Substitute into a check constraint. */\n+\n+tree\n+tsubst_check_constraint (tree t, tree args,\n+                         tsubst_flags_t complain, tree in_decl)\n+{\n+  tree decl = CHECK_CONSTR_CONCEPT (t);\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n+  tree targs = CHECK_CONSTR_ARGS (t);\n+\n+  /* Substitute through by building an template-id expression\n+     and then substituting into that. */\n+  tree expr = build_nt(TEMPLATE_ID_EXPR, tmpl, targs);\n+  ++processing_template_decl;\n+  tree result = tsubst_expr (expr, args, complain, in_decl, false);\n+  --processing_template_decl;\n+\n+  if (result == error_mark_node)\n+    return error_mark_node;\n+\n+  /* Extract the results and rebuild the check constraint. */\n+  decl = DECL_TEMPLATE_RESULT (TREE_OPERAND (result, 0));\n+  args = TREE_OPERAND (result, 1);\n+\n+  return build_nt (CHECK_CONSTR, decl, args);\n+}\n+\n /* Substitute into the conjunction of constraints. Returns\n    error_mark_node if substitution into either operand fails. */\n+\n tree\n-tsubst_conjunction (tree t, tree args,\n-                    tsubst_flags_t complain, tree in_decl)\n+tsubst_logical_operator (tree t, tree args,\n+\t\t\t tsubst_flags_t complain, tree in_decl)\n {\n   tree t0 = TREE_OPERAND (t, 0);\n   tree r0 = tsubst_constraint (t0, args, complain, in_decl);\n+  if (r0 == error_mark_node)\n+    return error_mark_node;\n   tree t1 = TREE_OPERAND (t, 1);\n   tree r1 = tsubst_constraint (t1, args, complain, in_decl);\n-  return build_nt (CONJ_CONSTR, r0, r1);\n+  if (r1 == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (TREE_CODE (t), r0, r1);\n+}\n+\n+namespace {\n+\n+/* Substitute ARGS into the expression constraint T.  */\n+\n+tree\n+tsubst_expr_constr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  cp_unevaluated guard;\n+  tree expr = EXPR_CONSTR_EXPR (t);\n+  tree ret = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (EXPR_CONSTR, ret);\n+}\n+\n+/* Substitute ARGS into the type constraint T.  */\n+\n+tree\n+tsubst_type_constr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  tree type = TYPE_CONSTR_TYPE (t);\n+  tree ret = tsubst (type, args, complain, in_decl);\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (TYPE_CONSTR, ret);\n+}\n+\n+/* Substitute ARGS into the implicit conversion constraint T.  */\n+\n+tree\n+tsubst_implicit_conversion_constr (tree t, tree args, tsubst_flags_t complain,\n+                                   tree in_decl)\n+{\n+  cp_unevaluated guard;\n+  tree expr = ICONV_CONSTR_EXPR (t);\n+  tree type = ICONV_CONSTR_TYPE (t);\n+  tree new_expr = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (new_expr == error_mark_node)\n+    return error_mark_node;\n+  tree new_type = tsubst (type, args, complain, in_decl);\n+  if (new_type == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (ICONV_CONSTR, new_expr, new_type);\n+}\n+\n+/* Substitute ARGS into the argument deduction constraint T.  */\n+\n+tree\n+tsubst_argument_deduction_constr (tree t, tree args, tsubst_flags_t complain,\n+                                  tree in_decl)\n+{\n+  cp_unevaluated guard;\n+  tree expr = DEDUCT_CONSTR_EXPR (t);\n+  tree pattern = DEDUCT_CONSTR_PATTERN (t);\n+  tree autos = DEDUCT_CONSTR_PLACEHOLDER(t);\n+  tree new_expr = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (new_expr == error_mark_node)\n+    return error_mark_node;\n+  /* It seems like substituting through the pattern will not affect the\n+     placeholders.  We should (?) be able to reuse the existing list\n+     without any problems.  If not, then we probably want to create a\n+     new list of placeholders and then instantiate the pattern using\n+     those.  */\n+  tree new_pattern = tsubst (pattern, args, complain, in_decl);\n+  if (new_pattern == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (DEDUCT_CONSTR, new_expr, new_pattern, autos);\n }\n \n-/* Substitute ARGS into the constraint T. */\n+/* Substitute ARGS into the exception constraint T.  */\n+\n tree\n-tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+tsubst_exception_constr (tree t, tree args, tsubst_flags_t complain,\n+\t\t\t tree in_decl)\n {\n-  if (t == NULL_TREE)\n-    return t;\n-  if (TREE_CODE (t) == CONJ_CONSTR)\n-    return tsubst_conjunction (t, args, complain, in_decl);\n-  else if (TREE_CODE (t) == PRED_CONSTR)\n-    return tsubst_predicate_constraint (t, args, complain, in_decl);\n-  else\n-    gcc_unreachable ();\n-  return error_mark_node;\n+  cp_unevaluated guard;\n+  tree expr = EXCEPT_CONSTR_EXPR (t);\n+  tree ret = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (EXCEPT_CONSTR, ret);\n }\n \n-namespace {\n-\n /* A subroutine of tsubst_constraint_variables. Register local\n    specializations for each of parameter in PARMS and its\n    corresponding substituted constraint variable in VARS.\n    Returns VARS. */\n+\n tree\n declare_constraint_vars (tree parms, tree vars)\n {\n@@ -1553,6 +1740,7 @@ declare_constraint_vars (tree parms, tree vars)\n    Note that the caller must establish a local specialization stack\n    prior to calling this function since this substitution will\n    declare the substituted parameters. */\n+\n tree\n tsubst_constraint_variables (tree t, tree args,\n                              tsubst_flags_t complain, tree in_decl)\n@@ -1568,10 +1756,29 @@ tsubst_constraint_variables (tree t, tree args,\n   return declare_constraint_vars (t, vars);\n }\n \n+/* Substitute ARGS into the parameterized constraint T.  */\n+\n+tree\n+tsubst_parameterized_constraint (tree t, tree args,\n+\t\t\t\t tsubst_flags_t complain, tree in_decl)\n+{\n+  local_specialization_stack stack;\n+  tree vars = tsubst_constraint_variables (PARM_CONSTR_PARMS (t),\n+\t\t\t\t\t   args, complain, in_decl);\n+  if (vars == error_mark_node)\n+    return error_mark_node;\n+  tree expr = tsubst_constraint (PARM_CONSTR_OPERAND (t), args,\n+\t\t\t\t complain, in_decl);\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+  return build_nt (PARM_CONSTR, vars, expr);\n+}\n+\n /* Substitute ARGS into the simple requirement T. Note that\n    substitution may result in an ill-formed expression without\n    causing the program to be ill-formed. In such cases, the\n    requirement wraps an error_mark_node. */\n+\n inline tree\n tsubst_simple_requirement (tree t, tree args,\n                            tsubst_flags_t complain, tree in_decl)\n@@ -1627,6 +1834,8 @@ tsubst_nested_requirement (tree t, tree args,\n   return finish_nested_requirement (expr);\n }\n \n+/* Substitute ARGS into the requirement T.  */\n+\n inline tree\n tsubst_requirement (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n@@ -1662,7 +1871,8 @@ tsubst_requirement_body (tree t, tree args,\n       r = tree_cons (NULL_TREE, e, r);\n       t = TREE_CHAIN (t);\n     }\n-  return r;\n+  /* Ensure that the order of constraints is the same as the original.  */\n+  return nreverse (r);\n }\n \n } /* namespace */\n@@ -1696,6 +1906,7 @@ tsubst_requires_expr (tree t, tree args,\n \n /* Substitute ARGS into the constraint information CI, producing a new\n    constraint record. */\n+\n tree\n tsubst_constraint_info (tree t, tree args,\n                         tsubst_flags_t complain, tree in_decl)\n@@ -1714,6 +1925,39 @@ tsubst_constraint_info (tree t, tree args,\n   return build_constraints (tmpl_constr, decl_constr);\n }\n \n+/* Substitute ARGS into the constraint T. */\n+\n+tree\n+tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  if (t == NULL_TREE)\n+    return t;\n+  switch (TREE_CODE (t))\n+  {\n+  case PRED_CONSTR:\n+    return tsubst_predicate_constraint (t, args, complain, in_decl);\n+  case CHECK_CONSTR:\n+    return tsubst_check_constraint (t, args, complain, in_decl);\n+  case CONJ_CONSTR:\n+  case DISJ_CONSTR:\n+    return tsubst_logical_operator (t, args, complain, in_decl);\n+  case PARM_CONSTR:\n+    return tsubst_parameterized_constraint (t, args, complain, in_decl);\n+  case EXPR_CONSTR:\n+    return tsubst_expr_constr (t, args, complain, in_decl);\n+  case TYPE_CONSTR:\n+    return tsubst_type_constr (t, args, complain, in_decl);\n+  case ICONV_CONSTR:\n+    return tsubst_implicit_conversion_constr (t, args, complain, in_decl);\n+  case DEDUCT_CONSTR:\n+    return tsubst_argument_deduction_constr (t, args, complain, in_decl);\n+  case EXCEPT_CONSTR:\n+    return tsubst_exception_constr (t, args, complain, in_decl);\n+  default:\n+    gcc_unreachable ();\n+  }\n+  return error_mark_node;\n+}\n \n /*---------------------------------------------------------------------------\n                         Constraint satisfaction\n@@ -1738,11 +1982,14 @@ satisfy_pack_expansion (tree t, tree args,\n      gen_elem_of_pack_expansion_instantiation will check that each element of\n      the expansion is satisfied.  */\n   tree exprs = tsubst_pack_expansion (t, args, complain, in_decl);\n+\n   if (exprs == error_mark_node)\n     return boolean_false_node;\n-  int n = TREE_VEC_LENGTH (exprs);\n \n-  for (int i = 0; i < n; ++i)\n+  /* TODO: It might be better to normalize each expanded term\n+     and evaluate them separately. That would provide better\n+     opportunities for diagnostics.  */\n+  for (int i = 0; i < TREE_VEC_LENGTH (exprs); ++i)\n     if (TREE_VEC_ELT (exprs, i) != boolean_true_node)\n       return boolean_false_node;\n   return boolean_true_node;\n@@ -1760,12 +2007,14 @@ tree\n satisfy_predicate_constraint (tree t, tree args,\n                               tsubst_flags_t complain, tree in_decl)\n {\n-  tree original = TREE_OPERAND (t, 0);\n+  tree expr = TREE_OPERAND (t, 0);\n \n   /* We should never have a naked pack expansion in a predicate constraint.  */\n-  gcc_assert (TREE_CODE (original) != EXPR_PACK_EXPANSION);\n+  gcc_assert (TREE_CODE (expr) != EXPR_PACK_EXPANSION);\n \n-  tree expr = tsubst_expr (original, args, complain, in_decl, false);\n+  /* If substitution into the expression fails, the constraint\n+     is not satisfied.  */\n+  expr = tsubst_expr (expr, args, complain, in_decl, false);\n   if (expr == error_mark_node)\n     return boolean_false_node;\n \n@@ -1781,8 +2030,37 @@ satisfy_predicate_constraint (tree t, tree args,\n       return boolean_false_node;\n     }\n \n-  tree value = cxx_constant_value (expr);\n-  return value;\n+  return cxx_constant_value (expr);\n+}\n+\n+/* A concept check constraint like C<CARGS> is satisfied if substituting ARGS\n+   into CARGS succeeds and C is satisfied for the resulting arguments.  */\n+\n+tree\n+satisfy_check_constraint (tree t, tree args,\n+                          tsubst_flags_t complain, tree in_decl)\n+{\n+  tree decl = CHECK_CONSTR_CONCEPT (t);\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n+  tree cargs = CHECK_CONSTR_ARGS (t);\n+\n+  /* Instantiate the concept check arguments.  */\n+  tree targs = tsubst (cargs, args, tf_none, NULL_TREE);\n+  if (targs == error_mark_node)\n+    return boolean_false_node;\n+\n+  /* Search for a previous value.  */\n+  if (tree prev = lookup_concept_satisfaction (tmpl, targs))\n+    return prev;\n+\n+  /* Expand the concept; failure here implies non-satisfaction.  */\n+  tree def = expand_concept (decl, targs);\n+  if (def == error_mark_node)\n+    return memoize_concept_satisfaction (tmpl, args, boolean_false_node);\n+\n+  /* Recursively satisfy the constraint.  */\n+  tree result = satisfy_constraint_1 (def, targs, complain, in_decl);\n+  return memoize_concept_satisfaction (tmpl, targs, result);\n }\n \n /* Check an expression constraint. The constraint is satisfied if\n@@ -1803,7 +2081,6 @@ satisfy_expression_constraint (tree t, tree args,\n     return boolean_false_node;\n   if (!perform_deferred_access_checks (tf_none))\n     return boolean_false_node;\n-\n   return boolean_true_node;\n }\n \n@@ -1822,7 +2099,6 @@ satisfy_type_constraint (tree t, tree args,\n     return boolean_false_node;\n   if (!perform_deferred_access_checks (complain))\n     return boolean_false_node;\n-\n   return boolean_true_node;\n }\n \n@@ -1932,11 +2208,8 @@ satisfy_conjunction (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree t0 = satisfy_constraint_1 (TREE_OPERAND (t, 0), args, complain, in_decl);\n   if (t0 == boolean_false_node)\n-    return t0;\n-  tree t1 = satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);\n-  if (t1 == boolean_false_node)\n-    return t1;\n-  return boolean_true_node;\n+    return boolean_false_node;\n+  return satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);\n }\n \n /* Check that the disjunction of constraints is satisfied. Note\n@@ -1949,10 +2222,7 @@ satisfy_disjunction (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   tree t0 = satisfy_constraint_1 (TREE_OPERAND (t, 0), args, complain, in_decl);\n   if (t0 == boolean_true_node)\n     return boolean_true_node;\n-  tree t1 = satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);\n-  if (t1 == boolean_true_node)\n-    return boolean_true_node;\n-  return boolean_false_node;\n+  return satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);\n }\n \n /* Dispatch to an appropriate satisfaction routine depending on the\n@@ -1974,6 +2244,9 @@ satisfy_constraint_1 (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   case PRED_CONSTR:\n     return satisfy_predicate_constraint (t, args, complain, in_decl);\n \n+  case CHECK_CONSTR:\n+    return satisfy_check_constraint (t, args, complain, in_decl);\n+\n   case EXPR_CONSTR:\n     return satisfy_expression_constraint (t, args, complain, in_decl);\n \n@@ -2014,15 +2287,19 @@ satisfy_constraint_1 (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n tree\n satisfy_constraint (tree t, tree args)\n {\n+  auto_timevar time (TV_CONSTRAINT_SAT);\n+\n   /* Turn off template processing. Constraint satisfaction only applies\n-     to non-dependent terms, so we want full checking here.  */\n-  processing_template_decl_sentinel sentinel (true);\n+     to non-dependent terms, so we want to ensure full checking here.  */\n+  processing_template_decl_sentinel proc (true);\n+\n   /* Avoid early exit in tsubst and tsubst_copy from null args; since earlier\n      substitution was done with processing_template_decl forced on, there will\n      be expressions that still need semantic processing, possibly buried in\n      decltype or a template argument.  */\n   if (args == NULL_TREE)\n     args = make_tree_vec (1);\n+\n   return satisfy_constraint_1 (t, args, tf_none, NULL_TREE);\n }\n \n@@ -2042,11 +2319,13 @@ satisfy_associated_constraints (tree ci, tree args)\n   if (args && uses_template_parms (args))\n     return boolean_true_node;\n \n-  /* Invalid requirements cannot be satisfied. */\n-  if (!valid_constraints_p (ci))\n-    return boolean_false_node;\n+  /* Check if we've seen a previous result. */\n+  if (tree prev = lookup_constraint_satisfaction (ci, args))\n+    return prev;\n \n-  return satisfy_constraint (CI_NORMALIZED_CONSTRAINTS (ci), args);\n+  /* Actually test for satisfaction. */\n+  tree result = satisfy_constraint (CI_ASSOCIATED_CONSTRAINTS (ci), args);\n+  return memoize_constraint_satisfaction (ci, args, result);\n }\n \n } /* namespace */\n@@ -2059,7 +2338,7 @@ tree\n evaluate_constraints (tree constr, tree args)\n {\n   gcc_assert (constraint_p (constr));\n-  return satisfy_constraint (normalize_constraint (constr), args);\n+  return satisfy_constraint (constr, args);\n }\n \n /* Evaluate the function concept FN by substituting its own args\n@@ -2070,14 +2349,7 @@ evaluate_constraints (tree constr, tree args)\n tree\n evaluate_function_concept (tree fn, tree args)\n {\n-  ++processing_template_decl;\n-  /* We lift using DECL_TI_ARGS because we want to delay producing\n-     non-dependent expressions until we're doing satisfaction.  We can't just\n-     go without any substitution because we need to lower the level of 'auto's\n-     in type deduction constraints.  */\n-  tree constr = transform_expression (lift_function_definition\n-\t\t\t\t      (fn, DECL_TI_ARGS (fn)));\n-  --processing_template_decl;\n+  tree constr = build_nt (CHECK_CONSTR, fn, args);\n   return satisfy_constraint (constr, args);\n }\n \n@@ -2087,12 +2359,9 @@ evaluate_function_concept (tree fn, tree args)\n    boolean_false_node otherwise.  */\n \n tree\n-evaluate_variable_concept (tree decl, tree args)\n+evaluate_variable_concept (tree var, tree args)\n {\n-  ++processing_template_decl;\n-  tree constr = transform_expression (lift_variable_initializer\n-\t\t\t\t      (decl, DECL_TI_ARGS (decl)));\n-  --processing_template_decl;\n+  tree constr = build_nt (CHECK_CONSTR, var, args);\n   return satisfy_constraint (constr, args);\n }\n \n@@ -2103,9 +2372,7 @@ evaluate_variable_concept (tree decl, tree args)\n tree\n evaluate_constraint_expression (tree expr, tree args)\n {\n-  ++processing_template_decl;\n-  tree constr = transform_expression (lift_expression (expr));\n-  --processing_template_decl;\n+  tree constr = normalize_expression (expr);\n   return satisfy_constraint (constr, args);\n }\n \n@@ -2167,7 +2434,6 @@ constraint_expression_satisfied_p (tree expr, tree args)\n \n } /* namespace */\n \n-\n /*---------------------------------------------------------------------------\n                 Semantic analysis of requires-expressions\n ---------------------------------------------------------------------------*/\n@@ -2311,6 +2577,7 @@ equivalently_constrained (tree d1, tree d2)\n ---------------------------------------------------------------------------*/\n \n /* Returns true when the the constraints in A subsume those in B.  */\n+\n bool\n subsumes_constraints (tree a, tree b)\n {\n@@ -2334,6 +2601,7 @@ strictly_subsumes (tree a, tree b)\n \n    Returns 1 if A is more constrained than B, -1 if B is more constrained\n    than A, and 0 otherwise. */\n+\n int\n more_constrained (tree d1, tree d2)\n {\n@@ -2350,6 +2618,7 @@ more_constrained (tree d1, tree d2)\n /* Returns true if D1 is at least as constrained as D2. That is, the\n    associated constraints of D1 subsume those of D2, or both declarations\n    are unconstrained. */\n+\n bool\n at_least_as_constrained (tree d1, tree d2)\n {\n@@ -2361,49 +2630,71 @@ at_least_as_constrained (tree d1, tree d2)\n \n /*---------------------------------------------------------------------------\n                         Constraint diagnostics\n+\n+FIXME: Normalize expressions into constraints before evaluating them.\n+This should be the general pattern for all such diagnostics.\n ---------------------------------------------------------------------------*/\n \n-/* The diagnosis of constraints performs a combination of\n-   normalization and satisfaction testing. We recursively\n-   walk through the conjunction (or disjunctions) of associated\n-   constraints, testing each sub-expression in turn.\n+/* The number of detailed constraint failures.  */\n \n-   We currently restrict diagnostics to just the top-level\n-   conjunctions within the associated constraints. A fully\n-   recursive walk is possible, but it can generate a lot\n-   of errors. */\n+int constraint_errors = 0;\n \n+/* Do not generate errors after diagnosing this number of constraint\n+   failures.\n \n-namespace {\n+   FIXME: This is a really arbitrary number. Provide better control of\n+   constraint diagnostics with a command line option.  */\n \n-void diagnose_expression (location_t, tree, tree);\n-void diagnose_constraint (location_t, tree, tree);\n+int constraint_thresh = 20;\n \n-/* Diagnose a conjunction of constraints. */\n-void\n-diagnose_logical_operation (location_t loc, tree t, tree args)\n+\n+/* Returns true if we should elide the diagnostic for a constraint failure.\n+   This is the case when the number of errors has exceeded the pre-configured\n+   threshold.  */\n+\n+inline bool\n+elide_constraint_failure_p ()\n+{\n+  bool ret = constraint_thresh <= constraint_errors;\n+  ++constraint_errors;\n+  return ret;\n+}\n+\n+/* Returns the number of undiagnosed errors. */\n+\n+inline int\n+undiagnosed_constraint_failures ()\n {\n-  diagnose_expression (loc, TREE_OPERAND (t, 0), args);\n-  diagnose_expression (loc, TREE_OPERAND (t, 0), args);\n+  return constraint_errors - constraint_thresh;\n }\n \n-/* Determine if the trait expression T is satisfied by ARGS.\n-   Emit a precise diagnostic if it is not. */\n+/* The diagnosis of constraints performs a combination of normalization\n+   and satisfaction testing. We recursively walk through the conjunction or\n+   disjunction of associated constraints, testing each sub-constraint in\n+   turn.  */\n+\n+namespace {\n+\n+void diagnose_constraint (location_t, tree, tree, tree);\n+\n+/* Emit a specific diagnostics for a failed trait.  */\n+\n void\n-diagnose_trait_expression (location_t loc, tree t, tree args)\n+diagnose_trait_expression (location_t loc, tree, tree cur, tree args)\n {\n-  if (constraint_expression_satisfied_p (t, args))\n+  if (constraint_expression_satisfied_p (cur, args))\n+    return;\n+  if (elide_constraint_failure_p())\n     return;\n \n-  /* Rebuild the trait expression so we can diagnose the\n-     specific failure. */\n+  tree expr = PRED_CONSTR_EXPR (cur);\n   ++processing_template_decl;\n-  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);\n+  expr = tsubst_expr (expr, args, tf_none, NULL_TREE, false);\n   --processing_template_decl;\n \n   tree t1 = TRAIT_EXPR_TYPE1 (expr);\n   tree t2 = TRAIT_EXPR_TYPE2 (expr);\n-  switch (TRAIT_EXPR_KIND (t))\n+  switch (TRAIT_EXPR_KIND (expr))\n     {\n     case CPTK_HAS_NOTHROW_ASSIGN:\n       inform (loc, \"  %qT is not nothrow copy assignable\", t1);\n@@ -2473,93 +2764,52 @@ diagnose_trait_expression (location_t loc, tree t, tree args)\n     }\n }\n \n-/* Determine if the call expression T, when normalized as a constraint,\n-   is satisfied by ARGS.\n+/* Diagnose the expression of a predicate constraint.  */\n \n-   TODO: If T is refers to a concept, We could recursively analyze\n-   its definition to identify the exact failure, but that could\n-   emit a *lot* of error messages (defeating the purpose of\n-   improved diagnostics). Consider adding a flag to control the\n-   depth of diagnostics. */\n void\n-diagnose_call_expression (location_t loc, tree t, tree args)\n+diagnose_other_expression (location_t loc, tree, tree cur, tree args)\n {\n-  if (constraint_expression_satisfied_p (t, args))\n+  if (constraint_expression_satisfied_p (cur, args))\n     return;\n-\n-  /* Rebuild the expression for the purpose of diagnostics. */\n-  ++processing_template_decl;\n-  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);\n-  --processing_template_decl;\n-\n-  /* If the function call is known to be a concept check, then\n-     diagnose it differently (i.e., we may recurse). */\n-  if (resolve_constraint_check (t))\n-    inform (loc, \"  concept %qE was not satisfied\", expr);\n-  else\n-    inform (loc, \"  %qE evaluated to false\", expr);\n-}\n-\n-/* Determine if the template-id T, when normalized as a constraint\n-   is satisfied by ARGS. */\n-void\n-diagnose_template_id (location_t loc, tree t, tree args)\n-{\n-  /* Check for invalid template-ids. */\n-  if (!variable_template_p (TREE_OPERAND (t, 0)))\n-    {\n-      inform (loc, \"  invalid constraint %qE\", t);\n-      return;\n-    }\n-\n-  if (constraint_expression_satisfied_p (t, args))\n+  if (elide_constraint_failure_p())\n     return;\n+  inform (loc, \"%qE evaluated to false\", cur);\n+}\n \n-  /* Rebuild the expression for the purpose of diagnostics. */\n-  ++processing_template_decl;\n-  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);\n-  --processing_template_decl;\n+/* Do our best to infer meaning from predicates.  */\n \n-  tree var = DECL_TEMPLATE_RESULT (TREE_OPERAND (t, 0));\n-  if (DECL_DECLARED_CONCEPT_P (var))\n-    inform (loc, \"  concept %qE was not satisfied\", expr);\n+inline void\n+diagnose_predicate_constraint (location_t loc, tree orig, tree cur, tree args)\n+{\n+  if (TREE_CODE (PRED_CONSTR_EXPR (cur)) == TRAIT_EXPR)\n+    diagnose_trait_expression (loc, orig, cur, args);\n   else\n-    inform (loc, \"  %qE evaluated to false\", expr);\n+    diagnose_other_expression (loc, orig, cur, args);\n }\n \n-/* Determine if the requires-expression, when normalized as a\n-   constraint is satisfied by ARGS.\n+/* Diagnose a failed pack expansion, possibly containing constraints.  */\n \n-   TODO: Build sets of expressions, types, and constraints\n-   based on the requirements in T and emit specific diagnostics\n-   for those. */\n void\n-diagnose_requires_expression (location_t loc, tree t, tree args)\n+diagnose_pack_expansion (location_t loc, tree, tree cur, tree args)\n {\n-  if (constraint_expression_satisfied_p (t, args))\n+  if (constraint_expression_satisfied_p (cur, args))\n     return;\n-  inform (loc, \"requirements not satisfied\");\n-}\n-\n-void\n-diagnose_pack_expansion (location_t loc, tree t, tree args)\n-{\n-  if (constraint_expression_satisfied_p (t, args))\n+  if (elide_constraint_failure_p())\n     return;\n \n   /* Make sure that we don't have naked packs that we don't expect. */\n-  if (!same_type_p (TREE_TYPE (t), boolean_type_node))\n+  if (!same_type_p (TREE_TYPE (cur), boolean_type_node))\n     {\n-      inform (loc, \"invalid pack expansion in constraint %qE\", t);\n+      inform (loc, \"invalid pack expansion in constraint %qE\", cur);\n       return;\n     }\n \n-  inform (loc, \"  in the expansion of %qE\", t);\n+  inform (loc, \"in the expansion of %qE\", cur);\n \n   /* Get the vector of expanded arguments. Note that n must not\n      be 0 since this constraint is not satisfied.  */\n   ++processing_template_decl;\n-  tree exprs = tsubst_pack_expansion (t, args, tf_none, NULL_TREE);\n+  tree exprs = tsubst_pack_expansion (cur, args, tf_none, NULL_TREE);\n   --processing_template_decl;\n   if (exprs == error_mark_node)\n     {\n@@ -2578,82 +2828,276 @@ diagnose_pack_expansion (location_t loc, tree t, tree args)\n     }\n }\n \n-/* Diagnose an expression that would be characterized as\n-   a predicate constraint. */\n+/* Diagnose a potentially unsatisfied concept check constraint DECL<CARGS>.\n+   Parameters are as for diagnose_constraint.  */\n+\n void\n-diagnose_other_expression (location_t loc, tree t, tree args)\n+diagnose_check_constraint (location_t loc, tree orig, tree cur, tree args)\n {\n-  if (constraint_expression_satisfied_p (t, args))\n+  if (constraints_satisfied_p (cur, args))\n     return;\n-  inform (loc, \"  %qE evaluated to false\", t);\n+\n+  tree decl = CHECK_CONSTR_CONCEPT (cur);\n+  tree cargs = CHECK_CONSTR_ARGS (cur);\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n+  tree check = build_nt (CHECK_CONSTR, decl, cargs);\n+\n+  /* Instantiate the concept check arguments.  */\n+  tree targs = tsubst (cargs, args, tf_none, NULL_TREE);\n+  if (targs == error_mark_node)\n+    {\n+      if (elide_constraint_failure_p ())\n+        return;\n+      inform (loc, \"invalid use of the concept %qE\", check);\n+      tsubst (cargs, args, tf_warning_or_error, NULL_TREE);\n+      return;\n+    }\n+\n+  tree sub = build_tree_list (tmpl, targs);\n+  /* Update to the expanded definitions. */\n+  cur = expand_concept (decl, targs);\n+  if (cur == error_mark_node)\n+    {\n+      if (elide_constraint_failure_p ())\n+        return;\n+      inform (loc, \"in the expansion of concept %qE %S\", check, sub);\n+      cur = get_concept_definition (decl);\n+      tsubst_expr (cur, targs, tf_warning_or_error, NULL_TREE, false);\n+      return;\n+    }\n+\n+  orig = get_concept_definition (CHECK_CONSTR_CONCEPT (orig));\n+  orig = normalize_expression (orig);\n+\n+  location_t dloc = DECL_SOURCE_LOCATION (decl);\n+  inform (dloc, \"within %qS\", sub);\n+  diagnose_constraint (dloc, orig, cur, targs);\n }\n \n+/* Diagnose a potentially unsatisfied conjunction or disjunction.  Parameters\n+   are as for diagnose_constraint.  */\n+\n void\n-diagnose_expression (location_t loc, tree t, tree args)\n+diagnose_logical_constraint (location_t loc, tree orig, tree cur, tree args)\n {\n-  switch (TREE_CODE (t))\n-    {\n-    case TRUTH_ANDIF_EXPR:\n-      diagnose_logical_operation (loc, t, args);\n-      break;\n+  tree t0 = TREE_OPERAND (cur, 0);\n+  tree t1 = TREE_OPERAND (cur, 1);\n+  if (!constraints_satisfied_p (t0, args))\n+    diagnose_constraint (loc, TREE_OPERAND (orig, 0), t0, args);\n+  else if (TREE_CODE (orig) == TRUTH_ORIF_EXPR)\n+    return;\n+  if (!constraints_satisfied_p (t1, args))\n+    diagnose_constraint (loc, TREE_OPERAND (orig, 1), t1, args);\n+}\n \n-    case TRUTH_ORIF_EXPR:\n-      diagnose_logical_operation (loc, t, args);\n-      break;\n+/* Diagnose a potential expression constraint failure. */\n \n-    case CALL_EXPR:\n-      diagnose_call_expression (loc, t, args);\n-      break;\n+void\n+diagnose_expression_constraint (location_t loc, tree orig, tree cur, tree args)\n+{\n+  if (constraints_satisfied_p (cur, args))\n+    return;\n+  if (elide_constraint_failure_p())\n+    return;\n \n-    case TEMPLATE_ID_EXPR:\n-      diagnose_template_id (loc, t, args);\n-      break;\n+  tree expr = EXPR_CONSTR_EXPR (orig);\n+  inform (loc, \"the required expression %qE would be ill-formed\", expr);\n \n-    case REQUIRES_EXPR:\n-      diagnose_requires_expression (loc, t, args);\n-      break;\n+  // TODO: We should have a flag that controls this substitution.\n+  // I'm finding it very useful for resolving concept check errors.\n \n-    case TRAIT_EXPR:\n-      diagnose_trait_expression (loc, t, args);\n-      break;\n+  // inform (input_location, \"==== BEGIN DUMP ====\");\n+  // tsubst_expr (EXPR_CONSTR_EXPR (orig), args, tf_warning_or_error, NULL_TREE, false);\n+  // inform (input_location, \"==== END DUMP ====\");\n+}\n \n-    case EXPR_PACK_EXPANSION:\n-      diagnose_pack_expansion (loc, t, args);\n-      break;\n+/* Diagnose a potentially failed type constraint. */\n \n-    default:\n-      diagnose_other_expression (loc, t, args);\n-      break;\n+void\n+diagnose_type_constraint (location_t loc, tree orig, tree cur, tree args)\n+{\n+  if (constraints_satisfied_p (cur, args))\n+    return;\n+  if (elide_constraint_failure_p())\n+    return;\n+\n+  tree type = TYPE_CONSTR_TYPE (orig);\n+  inform (loc, \"the required type %qT would be ill-formed\", type);\n+}\n+\n+/* Diagnose a potentially unsatisfied conversion constraint. */\n+\n+void\n+diagnose_implicit_conversion_constraint (location_t loc, tree orig, tree cur,\n+\t\t\t\t\t tree args)\n+{\n+  if (constraints_satisfied_p (cur, args))\n+    return;\n+\n+  /* The expression and type will previously have been substituted into,\n+     and therefore may already be an error. Also, we will have already\n+     diagnosed substitution failures into an expression since this must be\n+     part of a compound requirement.  */\n+  tree expr = ICONV_CONSTR_EXPR (cur);\n+  if (error_operand_p (expr))\n+    return;\n+\n+  /* Don't elide a previously diagnosed failure.  */\n+  if (elide_constraint_failure_p())\n+    return;\n+\n+  tree type = ICONV_CONSTR_TYPE (cur);\n+  if (error_operand_p (type))\n+    {\n+      inform (loc, \"substitution into type %qT failed\",\n+\t      ICONV_CONSTR_TYPE (orig));\n+      return;\n     }\n+\n+  inform(loc, \"%qE is not implicitly convertible to %qT\", expr, type);\n }\n \n-inline void\n-diagnose_predicate_constraint (location_t loc, tree t, tree args)\n+/* Diagnose an argument deduction constraint. */\n+\n+void\n+diagnose_argument_deduction_constraint (location_t loc, tree orig, tree cur,\n+\t\t\t\t\ttree args)\n+{\n+  if (constraints_satisfied_p (cur, args))\n+    return;\n+\n+  /* The expression and type will previously have been substituted into,\n+     and therefore may already be an error. Also, we will have already\n+     diagnosed substution failures into an expression since this must be\n+     part of a compound requirement.  */\n+  tree expr = DEDUCT_CONSTR_EXPR (cur);\n+  if (error_operand_p (expr))\n+    return;\n+\n+  /* Don't elide a previously diagnosed failure.  */\n+  if (elide_constraint_failure_p ())\n+    return;\n+\n+  tree pattern = DEDUCT_CONSTR_PATTERN (cur);\n+  if (error_operand_p (pattern))\n+    {\n+      inform (loc, \"substitution into type %qT failed\",\n+\t      DEDUCT_CONSTR_PATTERN (orig));\n+      return;\n+    }\n+\n+  inform (loc, \"unable to deduce placeholder type %qT from %qE\",\n+\t  pattern, expr);\n+}\n+\n+/* Diagnose an exception constraint. */\n+\n+void\n+diagnose_exception_constraint (location_t loc, tree orig, tree cur, tree args)\n {\n-  diagnose_expression (loc, PRED_CONSTR_EXPR (t), args);\n+  if (constraints_satisfied_p (cur, args))\n+    return;\n+  if (elide_constraint_failure_p ())\n+    return;\n+\n+  /* Rebuild a noexcept expression. */\n+  tree expr = EXCEPT_CONSTR_EXPR (cur);\n+  if (error_operand_p (expr))\n+    return;\n+\n+  inform (loc, \"%qE evaluated to false\", EXCEPT_CONSTR_EXPR (orig));\n }\n \n-inline void\n-diagnose_conjunction (location_t loc, tree t, tree args)\n+/* Diagnose a potentially unsatisfied parameterized constraint.  */\n+\n+void\n+diagnose_parameterized_constraint (location_t loc, tree orig, tree cur,\n+\t\t\t\t   tree args)\n {\n-  diagnose_constraint (loc, TREE_OPERAND (t, 0), args);\n-  diagnose_constraint (loc, TREE_OPERAND (t, 1), args);\n+  if (constraints_satisfied_p (cur, args))\n+    return;\n+\n+  local_specialization_stack stack;\n+  tree parms = PARM_CONSTR_PARMS (cur);\n+  tree vars = tsubst_constraint_variables (parms, args, tf_warning_or_error,\n+\t\t\t\t\t   NULL_TREE);\n+  if (vars == error_mark_node)\n+    {\n+      if (elide_constraint_failure_p ())\n+        return;\n+\n+      /* TODO: Check which variable failed and use orig to diagnose\n+         that substitution error.  */\n+      inform (loc, \"failed to instantiate constraint variables\");\n+      return;\n+    }\n+\n+  /* TODO: It would be better write these in a list. */\n+  while (vars)\n+    {\n+      inform (loc, \"    with %q#D\", vars);\n+      vars = TREE_CHAIN (vars);\n+    }\n+  orig = PARM_CONSTR_OPERAND (orig);\n+  cur = PARM_CONSTR_OPERAND (cur);\n+  return diagnose_constraint (loc, orig, cur, args);\n }\n \n-/* Diagnose the constraint T for the given ARGS. This is only\n-   ever invoked on the associated constraints, so we can\n-   only have conjunctions of predicate constraints. */\n+/* Diagnose the constraint CUR for the given ARGS. This is only ever invoked\n+   on the associated constraints, so we can only have conjunctions of\n+   predicate constraints.  The ORIGinal (dependent) constructs follow\n+   the current constraints to enable better diagnostics.  Note that ORIG\n+   and CUR must be the same kinds of node, except when CUR is an error.  */\n+\n void\n-diagnose_constraint (location_t loc, tree t, tree args)\n+diagnose_constraint (location_t loc, tree orig, tree cur, tree args)\n {\n-  switch (TREE_CODE (t))\n+  switch (TREE_CODE (cur))\n     {\n+    case EXPR_CONSTR:\n+      diagnose_expression_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case TYPE_CONSTR:\n+      diagnose_type_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case ICONV_CONSTR:\n+      diagnose_implicit_conversion_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case DEDUCT_CONSTR:\n+      diagnose_argument_deduction_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case EXCEPT_CONSTR:\n+      diagnose_exception_constraint (loc, orig, cur, args);\n+      break;\n+\n     case CONJ_CONSTR:\n-      diagnose_conjunction (loc, t, args);\n+    case DISJ_CONSTR:\n+      diagnose_logical_constraint (loc, orig, cur, args);\n       break;\n \n     case PRED_CONSTR:\n-      diagnose_predicate_constraint (loc, t, args);\n+      diagnose_predicate_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case PARM_CONSTR:\n+      diagnose_parameterized_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case CHECK_CONSTR:\n+      diagnose_check_constraint (loc, orig, cur, args);\n+      break;\n+\n+    case EXPR_PACK_EXPANSION:\n+      diagnose_pack_expansion (loc, orig, cur, args);\n+      break;\n+\n+    case ERROR_MARK:\n+      /* TODO: Can we improve the diagnostic with the original?  */\n+      inform (input_location, \"ill-formed constraint\");\n       break;\n \n     default:\n@@ -2678,16 +3122,10 @@ diagnose_declaration_constraints (location_t loc, tree decl, tree args)\n \targs = TI_ARGS (ti);\n     }\n \n-  /* Check that the constraints are actually valid.  */\n-  tree ci = get_constraints (decl);\n-  if (!valid_constraints_p (ci))\n-    {\n-      inform (loc, \"    invalid constraints\");\n-      return;\n-    }\n-\n   /* Recursively diagnose the associated constraints.  */\n-  diagnose_constraint (loc, CI_ASSOCIATED_CONSTRAINTS (ci), args);\n+  tree ci = get_constraints (decl);\n+  tree t = CI_ASSOCIATED_CONSTRAINTS (ci);\n+  diagnose_constraint (loc, t, t, args);\n }\n \n } // namespace\n@@ -2699,8 +3137,17 @@ diagnose_declaration_constraints (location_t loc, tree decl, tree args)\n void\n diagnose_constraints (location_t loc, tree t, tree args)\n {\n+  constraint_errors = 0;\n+\n   if (constraint_p (t))\n-    diagnose_constraint (loc, t, args);\n-  else\n+    diagnose_constraint (loc, t, t, args);\n+  else if (DECL_P (t))\n     diagnose_declaration_constraints (loc, t, args);\n+  else\n+    gcc_unreachable ();\n+\n+  /* Note the number of elided failures. */\n+  int n = undiagnosed_constraint_failures ();\n+  if (n > 0)\n+    inform (loc, \"... and %d more constraint errors not shown\", n);\n }"}, {"sha": "6cb5a695ea50eeb1b1e1953650f770d1fc9e7816", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -536,6 +536,14 @@ DEFTREECODE (NESTED_REQ, \"nested_req\", tcc_expression, 1)\n    PRED_CONSTR_EXPR has the expression to be evaluated. */\n DEFTREECODE (PRED_CONSTR, \"pred_constr\", tcc_expression, 1)\n \n+/* A check constraint represents the checking of a concept\n+   C. It has two operands: the template defining the concept\n+   and a sequence of template arguments.\n+\n+   CHECK_CONSTR_CONCEPT has the concept definition\n+   CHECK_CONSTR_ARGUMENTS are the template arguments */\n+DEFTREECODE (CHECK_CONSTR, \"check_constr\", tcc_expression, 2)\n+\n /* An expression constraint determines the validity of a expression E.\n \n    EXPR_CONST_EXPR has the expression being validated. */\n@@ -560,7 +568,7 @@ DEFTREECODE (ICONV_CONSTR, \"iconv_constr\", tcc_expression, 2)\n    T must contain at least one place holder.\n \n    DEDUCT_CONSTR_EXPR has the expression E\n-   DEDUCT_CONSTR_PATTERN has the type patter T.\n+   DEDUCT_CONSTR_PATTERN has the type pattern T.\n    DEDUCT_CONSTR_PLACEHOLDERS has the list of placeholder nodes in T. */\n DEFTREECODE (DEDUCT_CONSTR, \"deduct_constr\", tcc_expression, 3)\n "}, {"sha": "76616c611d810650cc1d5ec3880320ff0804941a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -893,10 +893,6 @@ struct GTY(()) tree_template_info {\n // - a constraint expression introduced by a function declarator\n // - the associated constraints, which are the conjunction of those,\n //   and used for declaration matching\n-// - the cached normalized associated constraints which are used\n-//   to support satisfaction and subsumption.\n-// - assumptions which is the result of decomposing the normalized\n-//   constraints.\n //\n // The template and declarator requirements are kept to support pretty\n // printing constrained declarations.\n@@ -905,8 +901,6 @@ struct GTY(()) tree_constraint_info {\n   tree template_reqs;\n   tree declarator_reqs;\n   tree associated_constr;\n-  tree normalized_constr;\n-  tree assumptions;\n };\n \n // Require that pointer P is non-null before returning.\n@@ -945,14 +939,6 @@ check_constraint_info (tree t)\n #define CI_ASSOCIATED_CONSTRAINTS(NODE) \\\n   check_constraint_info (check_nonnull(NODE))->associated_constr\n \n-// The normalized associated constraints.\n-#define CI_NORMALIZED_CONSTRAINTS(NODE) \\\n-  check_constraint_info (check_nonnull(NODE))->normalized_constr\n-\n-// Get the set of assumptions associated with the constraint info node.\n-#define CI_ASSUMPTIONS(NODE) \\\n-  check_constraint_info (check_nonnull(NODE))->assumptions\n-\n // Access the logical constraints on the template parameters introduced\n // at a given template parameter list level indicated by NODE.\n #define TEMPLATE_PARMS_CONSTRAINTS(NODE) \\\n@@ -976,6 +962,14 @@ check_constraint_info (tree t)\n #define PRED_CONSTR_EXPR(NODE) \\\n   TREE_OPERAND (TREE_CHECK (NODE, PRED_CONSTR), 0)\n \n+/* The concept of a concept check. */\n+#define CHECK_CONSTR_CONCEPT(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, CHECK_CONSTR), 0)\n+\n+/* The template arguments of a concept check. */\n+#define CHECK_CONSTR_ARGS(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, CHECK_CONSTR), 1)\n+\n /* The expression validated by the predicate constraint. */\n #define EXPR_CONSTR_EXPR(NODE) \\\n   TREE_OPERAND (TREE_CHECK (NODE, EXPR_CONSTR), 0)\n@@ -6118,6 +6112,7 @@ extern bool is_specialization_of_friend\t\t(tree, tree);\n extern tree get_pattern_parm\t\t\t(tree, tree);\n extern int comp_template_args\t\t\t(tree, tree, tree * = NULL,\n \t\t\t\t\t\t tree * = NULL);\n+extern int template_args_equal                  (tree, tree);\n extern tree maybe_process_partial_specialization (tree);\n extern tree most_specialized_instantiation\t(tree);\n extern void print_candidates\t\t\t(tree);\n@@ -6848,10 +6843,8 @@ extern tree strip_using_decl                    (tree);\n /* in constraint.cc */\n extern void init_constraint_processing          ();\n extern bool constraint_p                        (tree);\n-extern tree make_predicate_constraint           (tree);\n extern tree conjoin_constraints                 (tree, tree);\n extern tree conjoin_constraints                 (tree);\n-extern bool valid_constraints_p                 (tree);\n extern tree get_constraints                     (tree);\n extern void set_constraints                     (tree, tree);\n extern void remove_constraints                  (tree);\n@@ -6882,13 +6875,23 @@ extern tree tsubst_requires_expr                (tree, tree, tsubst_flags_t, tre\n extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);\n extern bool function_concept_check_p            (tree);\n-\n+extern tree normalize_expression                (tree);\n+extern tree expand_concept                      (tree, tree);\n+extern bool expanding_concept                   ();\n extern tree evaluate_constraints                (tree, tree);\n extern tree evaluate_function_concept           (tree, tree);\n extern tree evaluate_variable_concept           (tree, tree);\n extern tree evaluate_constraint_expression      (tree, tree);\n extern bool constraints_satisfied_p             (tree);\n extern bool constraints_satisfied_p             (tree, tree);\n+extern tree lookup_constraint_satisfaction      (tree, tree);\n+extern tree memoize_constraint_satisfaction     (tree, tree, tree);\n+extern tree lookup_concept_satisfaction         (tree, tree);\n+extern tree memoize_concept_satisfaction        (tree, tree, tree);\n+extern tree get_concept_expansion               (tree, tree);\n+extern tree save_concept_expansion              (tree, tree, tree);\n+extern bool* lookup_subsumption_result          (tree, tree);\n+extern bool save_subsumption_result             (tree, tree, bool);\n \n extern bool equivalent_constraints              (tree, tree);\n extern bool equivalently_constrained            (tree, tree);\n@@ -6899,7 +6902,6 @@ extern int more_constrained                     (tree, tree);\n extern void diagnose_constraints                (location_t, tree, tree);\n \n /* in logic.cc */\n-extern tree decompose_assumptions               (tree);\n extern tree decompose_conclusions               (tree);\n extern bool subsumes                            (tree, tree);\n "}, {"sha": "192b26cf3d9311c1331d21f86b76c14ec564e8f0", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 170, "deletions": 23, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -35,6 +35,9 @@ static void pp_cxx_parameter_declaration_clause (cxx_pretty_printer *, tree);\n static void pp_cxx_template_parameter (cxx_pretty_printer *, tree);\n static void pp_cxx_cast_expression (cxx_pretty_printer *, tree);\n static void pp_cxx_typeid_expression (cxx_pretty_printer *, tree);\n+static void pp_cxx_unary_left_fold_expression (cxx_pretty_printer *, tree);\n+static void pp_cxx_unary_right_fold_expression (cxx_pretty_printer *, tree);\n+static void pp_cxx_binary_fold_expression (cxx_pretty_printer *, tree);\n \f\n \n static inline void\n@@ -1139,6 +1142,19 @@ cxx_pretty_printer::expression (tree t)\n       pp_cxx_ws_string (this, \"...\");\n       break;\n \n+    case UNARY_LEFT_FOLD_EXPR:\n+      pp_cxx_unary_left_fold_expression (this, t);\n+      break;\n+\n+    case UNARY_RIGHT_FOLD_EXPR:\n+      pp_cxx_unary_right_fold_expression (this, t);\n+    break;\n+\n+    case BINARY_LEFT_FOLD_EXPR:\n+    case BINARY_RIGHT_FOLD_EXPR:\n+      pp_cxx_binary_fold_expression (this, t);\n+      break;\n+\n     case TEMPLATE_ID_EXPR:\n       pp_cxx_template_id (this, t);\n       break;\n@@ -1165,6 +1181,7 @@ cxx_pretty_printer::expression (tree t)\n       break;\n \n     case PRED_CONSTR:\n+    case CHECK_CONSTR:\n     case EXPR_CONSTR:\n     case TYPE_CONSTR:\n     case ICONV_CONSTR:\n@@ -2198,6 +2215,11 @@ void\n pp_cxx_constrained_type_spec (cxx_pretty_printer *pp, tree c)\n {\n   tree t, a;\n+  if (c == error_mark_node)\n+    {\n+      pp_cxx_ws_string(pp, \"<unsatisfied-constrained-placeholder>\");\n+      return;\n+    }\n   placeholder_extract_concept_and_args (c, t, a);\n   pp->id_expression (t);\n   if (TREE_VEC_LENGTH (a) > 1)\n@@ -2407,6 +2429,102 @@ pp_cxx_offsetof_expression (cxx_pretty_printer *pp, tree t)\n   pp_cxx_right_paren (pp);\n }\n \n+static char const*\n+get_fold_operator (tree t)\n+{\n+  int op = int_cst_value (FOLD_EXPR_OP (t));\n+  if (FOLD_EXPR_MODIFY_P (t))\n+    {\n+      switch (op)\n+        {\n+        case NOP_EXPR: return \"=\";\n+        case PLUS_EXPR: return \"+=\";\n+        case MINUS_EXPR: return \"-=\";\n+        case MULT_EXPR: return \"*=\";\n+        case TRUNC_DIV_EXPR: return \"/=\";\n+        case TRUNC_MOD_EXPR: return \"%=\";\n+        case BIT_XOR_EXPR: return \"^=\";\n+        case BIT_AND_EXPR: return \"&=\";\n+        case BIT_IOR_EXPR: return \"|=\";\n+        case LSHIFT_EXPR: return \"<<=\";\n+        case RSHIFT_EXPR: return \">>=\";\n+        default: gcc_unreachable ();\n+        }\n+    }\n+  else\n+    {\n+      switch (op)\n+        {\n+        case PLUS_EXPR: return \"+\";\n+        case MINUS_EXPR: return \"-\";\n+        case MULT_EXPR: return \"*\";\n+        case TRUNC_DIV_EXPR: return \"/\";\n+        case TRUNC_MOD_EXPR: return \"%\";\n+        case BIT_XOR_EXPR: return \"^\";\n+        case BIT_AND_EXPR: return \"&\";\n+        case BIT_IOR_EXPR: return \"|\";\n+        case LSHIFT_EXPR: return \"<<\";\n+        case RSHIFT_EXPR: return \">>\";\n+        case EQ_EXPR: return \"==\";\n+        case NE_EXPR: return \"!=\";\n+        case LT_EXPR: return \"<\";\n+        case GT_EXPR: return \">\";\n+        case LE_EXPR: return \"<=\";\n+        case GE_EXPR: return \">=\";\n+        case TRUTH_ANDIF_EXPR: return \"&&\";\n+        case TRUTH_ORIF_EXPR: return \"||\";\n+        case MEMBER_REF: return \"->*\";\n+        case DOTSTAR_EXPR: return \".*\";\n+        case OFFSET_REF: return \".*\";\n+        default: return \",\"; /* FIXME: Not the right default.  */\n+        }\n+    }\n+}\n+\n+void\n+pp_cxx_unary_left_fold_expression (cxx_pretty_printer *pp, tree t)\n+{\n+  char const* op = get_fold_operator (t);\n+  tree expr = PACK_EXPANSION_PATTERN (FOLD_EXPR_PACK (t));\n+  pp_cxx_left_paren (pp);\n+  pp_cxx_ws_string (pp, \"...\");\n+  pp_cxx_ws_string (pp, op);\n+  pp->expression (expr);\n+  pp_cxx_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_unary_right_fold_expression (cxx_pretty_printer *pp, tree t)\n+{\n+  char const* op = get_fold_operator (t);\n+  tree expr = PACK_EXPANSION_PATTERN (FOLD_EXPR_PACK (t));\n+  pp_cxx_left_paren (pp);\n+  pp->expression (expr);\n+  pp_space (pp);\n+  pp_cxx_ws_string (pp, op);\n+  pp_cxx_ws_string (pp, \"...\");\n+  pp_cxx_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_binary_fold_expression (cxx_pretty_printer *pp, tree t)\n+{\n+  char const* op = get_fold_operator (t);\n+  tree t1 = TREE_OPERAND (t, 1);\n+  tree t2 = TREE_OPERAND (t, 2);\n+  if (t1 == FOLD_EXPR_PACK (t))\n+    t1 = PACK_EXPANSION_PATTERN (t1);\n+  else\n+    t2 = PACK_EXPANSION_PATTERN (t2);\n+  pp_cxx_left_paren (pp);\n+  pp->expression (t1);\n+  pp_cxx_ws_string (pp, op);\n+  pp_cxx_ws_string (pp, \"...\");\n+  pp_cxx_ws_string (pp, op);\n+  pp->expression (t2);\n+  pp_cxx_right_paren (pp);\n+}\n+\n void\n pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n {\n@@ -2617,6 +2735,7 @@ pp_cxx_compound_requirement (cxx_pretty_printer *pp, tree t)\n       pp_cxx_ws_string (pp, \"->\");\n       pp->type_id (type);\n     }\n+  pp_cxx_semicolon (pp);\n }\n \n /* nested requirement:\n@@ -2632,74 +2751,94 @@ pp_cxx_nested_requirement (cxx_pretty_printer *pp, tree t)\n void\n pp_cxx_predicate_constraint (cxx_pretty_printer *pp, tree t)\n {\n-  pp_string (pp, \"predicate\");\n-  pp_left_paren (pp);\n   pp->expression (TREE_OPERAND (t, 0));\n-  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_check_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  tree decl = CHECK_CONSTR_CONCEPT (t);\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n+  tree args = CHECK_CONSTR_ARGS (t);\n+  tree id = build_nt (TEMPLATE_ID_EXPR, tmpl, args);\n+\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    pp->expression (id);\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      tree call = build_vl_exp (CALL_EXPR, 2);\n+      TREE_OPERAND (call, 0) = integer_two_node;\n+      TREE_OPERAND (call, 1) = id;\n+      pp->expression (call);\n+    }\n+  else\n+    gcc_unreachable ();\n }\n \n void\n pp_cxx_expression_constraint (cxx_pretty_printer *pp, tree t)\n {\n-  pp_string (pp, \"valid_expr\");\n-  pp_left_paren (pp);\n+  pp_string (pp, \"<valid-expression \");\n+  pp_cxx_left_paren (pp);\n   pp->expression (TREE_OPERAND (t, 0));\n-  pp_right_paren (pp);\n+  pp_cxx_right_paren (pp);\n+  pp_string (pp, \">\");\n }\n \n void\n pp_cxx_type_constraint (cxx_pretty_printer *pp, tree t)\n {\n-  pp_string (pp, \"valid_type\");\n-  pp_left_paren (pp);\n+  pp_string (pp, \"<valid-type \");\n   pp->type_id (TREE_OPERAND (t, 0));\n-  pp_right_paren (pp);\n+  pp_string (pp, \">\");\n }\n \n void\n pp_cxx_implicit_conversion_constraint (cxx_pretty_printer *pp, tree t)\n {\n-  pp_string (pp, \"convertible\");\n-  pp_left_paren (pp);\n+  pp_string (pp, \"<implicitly-conversion \");\n+  pp_cxx_left_paren (pp);\n   pp->expression (ICONV_CONSTR_EXPR (t));\n-  pp_cxx_separate_with (pp, ',');\n-  pp->expression (ICONV_CONSTR_TYPE (t));\n-  pp_right_paren (pp);\n+  pp_cxx_right_paren (pp);\n+  pp_cxx_ws_string (pp, \"to\");\n+  pp->type_id (ICONV_CONSTR_TYPE (t));\n+  pp_string (pp, \">\");\n }\n \n void\n pp_cxx_argument_deduction_constraint (cxx_pretty_printer *pp, tree t)\n {\n-  pp_string (pp, \"deducible\");\n-  pp_left_paren (pp);\n+  pp_string (pp, \"<argument-deduction \");\n+  pp_cxx_left_paren (pp);\n   pp->expression (DEDUCT_CONSTR_EXPR (t));\n-  pp_cxx_separate_with (pp, ',');\n+  pp_cxx_right_paren (pp);\n+  pp_cxx_ws_string (pp, \"as\");\n   pp->expression (DEDUCT_CONSTR_PATTERN (t));\n-  pp_right_paren (pp);\n+  pp_string (pp, \">\");\n }\n \n void\n pp_cxx_exception_constraint (cxx_pretty_printer *pp, tree t)\n {\n   pp_cxx_ws_string (pp, \"noexcept\");\n-  pp_left_paren (pp);\n+  pp_cxx_whitespace (pp);\n+  pp_cxx_left_paren (pp);\n   pp->expression (TREE_OPERAND (t, 0));\n-  pp_right_paren (pp);\n+  pp_cxx_right_paren (pp);\n }\n \n void\n pp_cxx_parameterized_constraint (cxx_pretty_printer *pp, tree t)\n {\n   pp_left_paren (pp);\n-  pp_string (pp, \"forall\");\n+  pp_string (pp, \"<requires \");\n   if (tree parms = PARM_CONSTR_PARMS (t))\n     {\n-      if (parms)\n \tpp_cxx_parameter_declaration_clause (pp, parms);\n       pp_cxx_whitespace (pp);\n     }\n   pp_cxx_constraint (pp, PARM_CONSTR_OPERAND (t));\n-  pp_right_paren (pp);\n+  pp_string (pp, \">\");\n }\n \n void\n@@ -2730,6 +2869,10 @@ pp_cxx_constraint (cxx_pretty_printer *pp, tree t)\n       pp_cxx_predicate_constraint (pp, t);\n       break;\n \n+    case CHECK_CONSTR:\n+      pp_cxx_check_constraint (pp, t);\n+      break;\n+\n     case EXPR_CONSTR:\n       pp_cxx_expression_constraint (pp, t);\n       break;\n@@ -2762,6 +2905,10 @@ pp_cxx_constraint (cxx_pretty_printer *pp, tree t)\n       pp_cxx_disjunction (pp, t);\n       break;\n \n+    case EXPR_PACK_EXPANSION:\n+      pp->expression (TREE_OPERAND (t, 0));\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "e5e1121b1d425f9ea0107bfedbb082aacb1fcf29", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -7921,7 +7921,7 @@ grokfndecl (tree ctype,\n \n       /* Adjust the required expression into a constraint. */\n       if (decl_reqs)\n-        decl_reqs = make_predicate_constraint (decl_reqs);\n+        decl_reqs = normalize_expression (decl_reqs);\n \n       tree ci = build_constraints (tmpl_reqs, decl_reqs);\n       set_constraints (decl, ci);"}, {"sha": "69a40cc7950b81161fbfdf240f0c4658c667d809", "filename": "gcc/cp/error.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -961,7 +961,12 @@ dump_simple_decl (cxx_pretty_printer *pp, tree t, tree type, int flags)\n     {\n       if (VAR_P (t)\n \t  && DECL_DECLARED_CONSTEXPR_P (t))\n-\tpp_cxx_ws_string (pp, \"constexpr\");\n+            {\n+              if (DECL_DECLARED_CONCEPT_P (t))\n+                pp_cxx_ws_string (pp, \"concept\");\n+              else\n+\t\tpp_cxx_ws_string (pp, \"constexpr\");\n+            }\n       dump_type_prefix (pp, type, flags & ~TFF_UNQUALIFIED_NAME);\n       pp_maybe_space (pp);\n     }\n@@ -1334,16 +1339,19 @@ dump_template_decl (cxx_pretty_printer *pp, tree t, int flags)\n \t  if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (t)))\n \t    pp_cxx_ws_string (pp, \"...\");\n \t}\n+\n+      /* Only print the requirements if we're also printing\n+         the template header.  */\n+      if (flag_concepts)\n+\tif (tree ci = get_constraints (t))\n+\t  if (check_constraint_info (ci))\n+\t    if (tree reqs = CI_TEMPLATE_REQS (ci))\n+\t      {\n+\t\tpp_cxx_requires_clause (pp, reqs);\n+\t\tpp_cxx_whitespace (pp);\n+\t      }\n     }\n \n-  if (flag_concepts)\n-    if (tree ci = get_constraints (t))\n-      if (check_constraint_info (ci))\n-        if (tree reqs = CI_TEMPLATE_REQS (ci))\n-\t  {\n-\t    pp_cxx_requires_clause (pp, reqs);\n-\t    pp_cxx_whitespace (pp);\n-\t  }\n \n   if (DECL_CLASS_TEMPLATE_P (t))\n     dump_type (pp, TREE_TYPE (t),\n@@ -1534,7 +1542,12 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n \tpp_cxx_ws_string (pp, \"virtual\");\n \n       if (constexpr_p)\n-\tpp_cxx_ws_string (pp, \"constexpr\");\n+        {\n+          if (DECL_DECLARED_CONCEPT_P (t))\n+            pp_cxx_ws_string (pp, \"concept\");\n+          else\n+\t    pp_cxx_ws_string (pp, \"constexpr\");\n+\t}\n     }\n \n   /* Print the return type?  */\n@@ -2665,6 +2678,10 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       break;\n \n     case EXPR_PACK_EXPANSION:\n+    case UNARY_LEFT_FOLD_EXPR:\n+    case UNARY_RIGHT_FOLD_EXPR:\n+    case BINARY_LEFT_FOLD_EXPR:\n+    case BINARY_RIGHT_FOLD_EXPR:\n     case TYPEID_EXPR:\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n@@ -2737,6 +2754,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       break;\n \n     case PRED_CONSTR:\n+    case CHECK_CONSTR:\n     case EXPR_CONSTR:\n     case TYPE_CONSTR:\n     case ICONV_CONSTR:"}, {"sha": "dda98dfc310b4520e3facab77fb2ad1cea48aa3b", "filename": "gcc/cp/logic.cc", "status": "modified", "additions": 574, "deletions": 269, "changes": 843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"timevar.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\"\n #include \"vec.h\"\n@@ -50,129 +51,175 @@ namespace {\n \n // Helper algorithms\n \n-// Increment iter distance(first, last) times.\n-template<typename I1, typename I2, typename I3>\n-  I1 next_by_distance (I1 iter, I2 first, I3 last)\n-  {\n-    for ( ; first != last; ++first, ++iter)\n-      ;\n-    return iter;\n-  }\n+template<typename I>\n+inline I\n+next (I iter)\n+{\n+  return ++iter;\n+}\n+\n+template<typename I, typename P>\n+inline bool\n+any_p (I first, I last, P pred)\n+{\n+  while (first != last)\n+    {\n+      if (pred(*first))\n+        return true;\n+      ++first;\n+    }\n+  return false;\n+}\n+\n+bool prove_implication (tree, tree);\n \n /*---------------------------------------------------------------------------\n                            Proof state\n ---------------------------------------------------------------------------*/\n \n+struct term_entry\n+{\n+  tree t;\n+};\n+\n+/* Hashing function and equality for constraint entries.  */\n+\n+struct term_hasher : ggc_ptr_hash<term_entry>\n+{\n+  static hashval_t hash (term_entry *e)\n+  {\n+    return iterative_hash_template_arg (e->t, 0);\n+  }\n+\n+  static bool equal (term_entry *e1, term_entry *e2)\n+  {\n+    return cp_tree_equal (e1->t, e2->t);\n+  }\n+};\n+\n /* A term list is a list of atomic constraints. It is used\n    to maintain the lists of assumptions and conclusions in a\n    proof goal.\n \n    Each term list maintains an iterator that refers to the current\n    term. This can be used by various tactics to support iteration\n    and stateful manipulation of the list. */\n-struct term_list : std::list<tree>\n+struct term_list\n {\n-  term_list ();\n-  term_list (const term_list &x);\n-  term_list& operator= (const term_list &x);\n-\n-  tree       current_term ()       { return *current; }\n-  const_tree current_term () const { return *current; }\n+  typedef std::list<tree>::iterator iterator;\n \n+  term_list ();\n+  term_list (tree);\n \n-  void insert (tree t);\n-  tree erase ();\n+  bool includes (tree);\n+  iterator insert (iterator, tree);\n+  iterator push_back (tree);\n+  iterator erase (iterator);\n+  iterator replace (iterator, tree);\n+  iterator replace (iterator, tree, tree);\n \n-  void start ();\n-  void next ();\n-  bool done() const;\n+  iterator begin() { return seq.begin(); }\n+  iterator end() { return seq.end(); }\n \n-  iterator current;\n+  std::list<tree>         seq;\n+  hash_table<term_hasher> tab;\n };\n \n inline\n term_list::term_list ()\n-  : std::list<tree> (), current (end ())\n-{ }\n+  : seq(), tab (11)\n+{\n+}\n \n-inline\n-term_list::term_list (const term_list &x)\n-  : std::list<tree> (x)\n-  , current (next_by_distance (begin (), x.begin (), x.current))\n-{ }\n+/* Initialize a term list with an initial term. */\n \n-inline term_list&\n-term_list::operator= (const term_list &x)\n+inline\n+term_list::term_list (tree t)\n+  : seq (), tab (11)\n {\n-  std::list<tree>::operator=(x);\n-  current = next_by_distance (begin (), x.begin (), x.current);\n-  return *this;\n+  push_back (t);\n }\n \n-/* Try saving the term T into the list of terms. If\n-   T is already in the list of terms, then no action is\n-   performed. Otherwise, insert T before the current\n-   position, making this term current.\n+/* Returns true if T is the in the tree. */\n \n-   Note that not inserting terms is an optimization\n-   that corresponds to the structural rule of\n-   contraction.\n-\n-   NOTE: With the contraction rule, this data structure\n-   would be more efficiently represented as an ordered set\n-   or hash set.  */\n-void\n-term_list::insert (tree t)\n+inline bool\n+term_list::includes (tree t)\n {\n-  /* Search the current term list. If there is already\n-     a matching term, do not add the new one.  */\n-  for (iterator i = begin(); i != end(); ++i)\n-    if (cp_tree_equal (*i, t))\n-      return;\n+  term_entry ent = {t};\n+  return tab.find (&ent);\n+}\n \n-  current = std::list<tree>::insert (current, t);\n+/* Append a term to the list. */\n+inline term_list::iterator\n+term_list::push_back (tree t)\n+{\n+  return insert (end(), t);\n }\n \n-/* Remove the current term from the list, repositioning to\n-   the term following the removed term. Note that the new\n-   position could be past the end of the list.\n+/* Insert a new (unseen) term T into the list before the proposition\n+   indicated by ITER. Returns the iterator to the newly inserted\n+   element.  */\n \n-   The removed term is returned. */\n-inline tree\n-term_list::erase ()\n+term_list::iterator\n+term_list::insert (iterator iter, tree t)\n {\n-  tree t = *current;\n-  current = std::list<tree>::erase (current);\n-  return t;\n+  gcc_assert (!includes (t));\n+  iter = seq.insert (iter, t);\n+  term_entry ent = {t};\n+  term_entry** slot = tab.find_slot (&ent, INSERT);\n+  term_entry* ptr = ggc_alloc<term_entry> ();\n+  *ptr = ent;\n+  *slot = ptr;\n+  return iter;\n }\n \n-/* Initialize the current term to the first in the list. */\n-inline void\n-term_list::start ()\n+/* Remove an existing term from the list. Returns an iterator referring\n+   to the element after the removed term.  This may be end().  */\n+\n+term_list::iterator\n+term_list::erase (iterator iter)\n {\n-  current = begin ();\n+  gcc_assert (includes (*iter));\n+  term_entry ent = {*iter};\n+  tab.remove_elt (&ent);\n+  iter = seq.erase (iter);\n+  return iter;\n }\n \n-/* Advance to the next term in the list. */\n-inline void\n-term_list::next ()\n+/* Replace the given term with that specified. If the term has\n+   been previously seen, do not insert the term. Returns the\n+   first iterator past the current term.  */\n+\n+term_list::iterator\n+term_list::replace (iterator iter, tree t)\n {\n-  ++current;\n+  iter = erase (iter);\n+  if (!includes (t))\n+    insert (iter, t);\n+  return iter;\n }\n \n-/* Returns true when the current position is past the end. */\n-inline bool\n-term_list::done () const\n+\n+/* Replace the term at the given position by the supplied T1\n+   followed by t2. This is used in certain logical operators to\n+   load a list of assumptions or conclusions.  */\n+\n+term_list::iterator\n+term_list::replace (iterator iter, tree t1, tree t2)\n {\n-  return current == end ();\n+  iter = erase (iter);\n+  if (!includes (t1))\n+    insert (iter, t1);\n+  if (!includes (t2))\n+    insert (iter, t2);\n+  return iter;\n }\n \n-\n /* A goal (or subgoal) models a sequent of the form\n    'A |- C' where A and C are lists of assumptions and\n    conclusions written as propositions in the constraint\n-   language (i.e., lists of trees).\n-*/\n+   language (i.e., lists of trees). */\n+\n struct proof_goal\n {\n   term_list assumptions;\n@@ -182,27 +229,27 @@ struct proof_goal\n /* A proof state owns a list of goals and tracks the\n    current sub-goal. The class also provides facilities\n    for managing subgoals and constructing term lists. */\n+\n struct proof_state : std::list<proof_goal>\n {\n   proof_state ();\n \n   iterator branch (iterator i);\n+  iterator discharge (iterator i);\n };\n \n-/* An alias for proof state iterators. */\n-typedef proof_state::iterator goal_iterator;\n+/* Initialize the state with a single empty goal, and set that goal\n+   as the current subgoal.  */\n \n-/* Initialize the state with a single empty goal,\n-   and set that goal as the current subgoal. */\n inline\n proof_state::proof_state ()\n   : std::list<proof_goal> (1)\n { }\n \n \n-/* Branch the current goal by creating a new subgoal,\n-   returning a reference to // the new object. This does\n-   not update the current goal. */\n+/* Branch the current goal by creating a new subgoal, returning a\n+   reference to the new object. This does not update the current goal. */\n+\n inline proof_state::iterator\n proof_state::branch (iterator i)\n {\n@@ -211,278 +258,536 @@ proof_state::branch (iterator i)\n   return insert (++i, g);\n }\n \n+/* Discharge the current goal, setting it equal to the\n+   next non-satisfied goal. */\n+\n+inline proof_state::iterator\n+proof_state::discharge (iterator i)\n+{\n+  gcc_assert (i != end());\n+  return erase (i);\n+}\n+\n+\n /*---------------------------------------------------------------------------\n-                           Logical rules\n+                        Debugging\n ---------------------------------------------------------------------------*/\n \n-/*These functions modify the current state and goal by decomposing\n-  logical expressions using the logical rules of sequent calculus for\n-  first order logic.\n+// void\n+// debug (term_list& ts)\n+// {\n+//   for (term_list::iterator i = ts.begin(); i != ts.end(); ++i)\n+//     verbatim (\"  # %E\", *i);\n+// }\n+//\n+// void\n+// debug (proof_goal& g)\n+// {\n+//   debug (g.assumptions);\n+//   verbatim (\"       |-\");\n+//   debug (g.conclusions);\n+// }\n \n-  Note that in each decomposition rule, the term T has been erased\n-  from term list before the specific rule is applied. */\n+/*---------------------------------------------------------------------------\n+                        Atomicity of constraints\n+---------------------------------------------------------------------------*/\n \n-/* The left logical rule for conjunction adds both operands\n-   to the current set of constraints. */\n-void\n-left_conjunction (proof_state &, goal_iterator i, tree t)\n+/* Returns true if T is not an atomic constraint.  */\n+\n+bool\n+non_atomic_constraint_p (tree t)\n {\n-  gcc_assert (TREE_CODE (t) == CONJ_CONSTR);\n+  switch (TREE_CODE (t))\n+    {\n+    case PRED_CONSTR:\n+    case EXPR_CONSTR:\n+    case TYPE_CONSTR:\n+    case ICONV_CONSTR:\n+    case DEDUCT_CONSTR:\n+    case EXCEPT_CONSTR:\n+      return false;\n+    case CHECK_CONSTR:\n+    case PARM_CONSTR:\n+    case CONJ_CONSTR:\n+    case DISJ_CONSTR:\n+      return true;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n-  /* Insert the operands into the current branch. Note that the\n-     final order of insertion is left-to-right. */\n-  term_list &l = i->assumptions;\n-  l.insert (TREE_OPERAND (t, 1));\n-  l.insert (TREE_OPERAND (t, 0));\n+/* Returns true if any constraints in T are not atomic.  */\n+\n+bool\n+any_non_atomic_constraints_p (term_list& t)\n+{\n+  return any_p (t.begin(), t.end(), non_atomic_constraint_p);\n }\n \n-/* The left logical rule for disjunction creates a new goal,\n-   adding the first operand to the original set of\n-   constraints and the second operand to the new set\n-   of constraints. */\n-void\n-left_disjunction (proof_state &s, goal_iterator i, tree t)\n+/*---------------------------------------------------------------------------\n+                           Proof validations\n+---------------------------------------------------------------------------*/\n+\n+enum proof_result\n {\n-  gcc_assert (TREE_CODE (t) == DISJ_CONSTR);\n+  invalid,\n+  valid,\n+  undecided\n+};\n+\n+proof_result check_term (term_list&, tree);\n \n-  /* Branch the current subgoal. */\n-  goal_iterator j = s.branch (i);\n-  term_list &l1 = i->assumptions;\n-  term_list &l2 = j->assumptions;\n \n-  /* Insert operands into the different branches. */\n-  l1.insert (TREE_OPERAND (t, 0));\n-  l2.insert (TREE_OPERAND (t, 1));\n+proof_result\n+analyze_atom (term_list& ts, tree t)\n+{\n+  /* FIXME: Hook into special cases, if any. */\n+  /*\n+  term_list::iterator iter = ts.begin();\n+  term_list::iterator end = ts.end();\n+  while (iter != end)\n+    {\n+      ++iter;\n+    }\n+  */\n+\n+  if (non_atomic_constraint_p (t))\n+    return undecided;\n+  if (any_non_atomic_constraints_p (ts))\n+    return undecided;\n+  return invalid;\n }\n \n-/* The left logical rules for parameterized constraints\n-   adds its operand to the current goal. The list of\n-   parameters are effectively discarded. */\n-void\n-left_parameterized_constraint (proof_state &, goal_iterator i, tree t)\n+/* Search for a pack expansion in the list of assumptions that would\n+   make this expansion valid.  */\n+\n+proof_result\n+analyze_pack (term_list& ts, tree t)\n {\n-  gcc_assert (TREE_CODE (t) == PARM_CONSTR);\n-  term_list &l = i->assumptions;\n-  l.insert (PARM_CONSTR_OPERAND (t));\n+  tree c1 = normalize_expression (PACK_EXPANSION_PATTERN (t));\n+  term_list::iterator iter = ts.begin();\n+  term_list::iterator end = ts.end();\n+  while (iter != end)\n+    {\n+      if (TREE_CODE (*iter) == TREE_CODE (t))\n+        {\n+          tree c2 = normalize_expression (PACK_EXPANSION_PATTERN (*iter));\n+          if (prove_implication (c2, c1))\n+            return valid;\n+          else\n+            return invalid;\n+        }\n+      ++iter;\n+    }\n+  return invalid;\n }\n \n-/*---------------------------------------------------------------------------\n-                           Decomposition\n----------------------------------------------------------------------------*/\n+/* Search for concept checks in TS that we know subsume T. */\n \n-/* The following algorithms decompose expressions into sets of\n-   atomic propositions. In terms of the sequent calculus, these\n-   functions exercise the logical rules only.\n+proof_result\n+search_known_subsumptions (term_list& ts, tree t)\n+{\n+  for (term_list::iterator i = ts.begin(); i != ts.end(); ++i)\n+    if (TREE_CODE (*i) == CHECK_CONSTR)\n+      {\n+        if (bool* b = lookup_subsumption_result (*i, t))\n+          return *b ? valid : invalid;\n+      }\n+  return undecided;\n+}\n \n-   This is equivalent, for the purpose of determining subsumption,\n-   to rewriting a constraint in disjunctive normal form. It also\n-   allows the resulting assumptions to be used as declarations\n-   for the purpose of separate checking. */\n+/* Determine if the terms in TS provide sufficient support for proving\n+   the proposition T. If any term in TS is a concept check that is known\n+   to subsume T, then the proof is valid. Otherwise, we have to expand T\n+   and continue searching for support.  */\n \n-/* Apply the left logical rules to the proof state. */\n-void\n-decompose_left_term (proof_state &s, goal_iterator i)\n+proof_result\n+analyze_check (term_list& ts, tree t)\n+{\n+  proof_result r = search_known_subsumptions (ts, t);\n+  if (r != undecided)\n+    return r;\n+\n+  tree tmpl = CHECK_CONSTR_CONCEPT (t);\n+  tree args = CHECK_CONSTR_ARGS (t);\n+  tree c = expand_concept (tmpl, args);\n+  return check_term (ts, c);\n+}\n+\n+/* Recursively check constraints of the parameterized constraint. */\n+\n+proof_result\n+analyze_parameterized (term_list& ts, tree t)\n+{\n+  return check_term (ts, PARM_CONSTR_OPERAND (t));\n+}\n+\n+proof_result\n+analyze_conjunction (term_list& ts, tree t)\n+{\n+  proof_result r = check_term (ts, TREE_OPERAND (t, 0));\n+  if (r == invalid || r == undecided)\n+    return r;\n+  return check_term (ts, TREE_OPERAND (t, 1));\n+}\n+\n+proof_result\n+analyze_disjunction (term_list& ts, tree t)\n+{\n+  proof_result r = check_term (ts, TREE_OPERAND (t, 0));\n+  if (r == valid)\n+    return r;\n+  return check_term (ts, TREE_OPERAND (t, 1));\n+}\n+\n+proof_result\n+analyze_term (term_list& ts, tree t)\n {\n-  term_list &l = i->assumptions;\n-  tree t = l.current_term ();\n   switch (TREE_CODE (t))\n     {\n+    case CHECK_CONSTR:\n+      return analyze_check (ts, t);\n+\n+    case PARM_CONSTR:\n+      return analyze_parameterized (ts, t);\n+\n     case CONJ_CONSTR:\n-      left_conjunction (s, i, l.erase ());\n-      break;\n+      return analyze_conjunction (ts, t);\n     case DISJ_CONSTR:\n-      left_disjunction (s, i, l.erase ());\n-      break;\n-    case PARM_CONSTR:\n-      left_parameterized_constraint (s, i, l.erase ());\n-      break;\n+      return analyze_disjunction (ts, t);\n+\n+    case PRED_CONSTR:\n+    case EXPR_CONSTR:\n+    case TYPE_CONSTR:\n+    case ICONV_CONSTR:\n+    case DEDUCT_CONSTR:\n+    case EXCEPT_CONSTR:\n+      return analyze_atom (ts, t);\n+\n+    case EXPR_PACK_EXPANSION:\n+      return analyze_pack (ts, t);\n+\n+    case ERROR_MARK:\n+      /* Encountering an error anywhere in a constraint invalidates\n+         the proof, since the constraint is ill-formed.  */\n+      return invalid;\n     default:\n-      l.next ();\n-      break;\n+      gcc_unreachable ();\n     }\n }\n \n-/* Apply the left logical rules of the sequent calculus\n-   until the current goal is fully decomposed into atomic\n-   constraints. */\n-void\n-decompose_left_goal (proof_state &s, goal_iterator i)\n+/* Check if a single term can be proven from a set of assumptions.\n+   If the proof is not valid, then it is incomplete when either\n+   the given term is non-atomic or any term in the list of assumptions\n+   is not-atomic.  */\n+\n+proof_result\n+check_term (term_list& ts, tree t)\n {\n-  term_list& l = i->assumptions;\n-  l.start ();\n-  while (!l.done ())\n-    decompose_left_term (s, i);\n+  /* Try the easy way; search for an equivalent term.  */\n+  if (ts.includes (t))\n+    return valid;\n+\n+  /* The hard way; actually consider what the term means.  */\n+  return analyze_term (ts, t);\n }\n \n-/* Apply the left logical rules of the sequent calculus\n-   until the antecedents are fully decomposed into atomic\n-   constraints. */\n-void\n-decompose_left (proof_state& s)\n+/* Check to see if any term is proven by the assumptions in the\n+   proof goal. The proof is valid if the proof of any term is valid.\n+   If validity cannot be determined, but any particular\n+   check was undecided, then this goal is undecided.  */\n+\n+proof_result\n+check_goal (proof_goal& g)\n {\n-  goal_iterator iter = s.begin ();\n-  goal_iterator end = s.end ();\n-  for ( ; iter != end; ++iter)\n-    decompose_left_goal (s, iter);\n+  term_list::iterator iter = g.conclusions.begin ();\n+  term_list::iterator end = g.conclusions.end ();\n+  bool incomplete = false;\n+  while (iter != end)\n+    {\n+      proof_result r = check_term (g.assumptions, *iter);\n+      if (r == valid)\n+        return r;\n+      if (r == undecided)\n+        incomplete = true;\n+      ++iter;\n+    }\n+\n+    /* Was the proof complete? */\n+    if (incomplete)\n+      return undecided;\n+    else\n+      return invalid;\n }\n \n-/* Returns a vector of terms from the term list L. */\n-tree\n-extract_terms (term_list& l)\n+/* Check if the the proof is valid. This is the case when all\n+   goals can be discharged. If any goal is invalid, then the\n+   entire proof is invalid. Otherwise, the proof is undecided.  */\n+\n+proof_result\n+check_proof (proof_state& p)\n {\n-  tree result = make_tree_vec (l.size());\n-  term_list::iterator iter = l.begin();\n-  term_list::iterator end = l.end();\n-  for (int n = 0; iter != end; ++iter, ++n)\n-    TREE_VEC_ELT (result, n) = *iter;\n-  return result;\n+  proof_state::iterator iter = p.begin();\n+  proof_state::iterator end = p.end();\n+  while (iter != end)\n+    {\n+      proof_result r = check_goal (*iter);\n+      if (r == invalid)\n+        return r;\n+      if (r == valid)\n+        iter = p.discharge (iter);\n+      else\n+        ++iter;\n+    }\n+\n+  /* If all goals are discharged, then the proof is valid.  */\n+  if (p.empty())\n+    return valid;\n+  else\n+    return undecided;\n }\n \n-/* Extract the assumptions from the proof state S\n-   as a vector of vectors of atomic constraints. */\n-inline tree\n-extract_assumptions (proof_state& s)\n+/*---------------------------------------------------------------------------\n+                           Left logical rules\n+---------------------------------------------------------------------------*/\n+\n+term_list::iterator\n+load_check_assumption (term_list& ts, term_list::iterator i)\n {\n-  tree result = make_tree_vec (s.size ());\n-  goal_iterator iter = s.begin ();\n-  goal_iterator end = s.end ();\n-  for (int n = 0; iter != end; ++iter, ++n)\n-    TREE_VEC_ELT (result, n) = extract_terms (iter->assumptions);\n-  return result;\n+  tree decl = CHECK_CONSTR_CONCEPT (*i);\n+  tree tmpl = DECL_TI_TEMPLATE (decl);\n+  tree args = CHECK_CONSTR_ARGS (*i);\n+  return ts.replace(i, expand_concept (tmpl, args));\n }\n \n-} // namespace\n+term_list::iterator\n+load_parameterized_assumption (term_list& ts, term_list::iterator i)\n+{\n+  return ts.replace(i, PARM_CONSTR_OPERAND(*i));\n+}\n \n-/* Decompose the required expression T into a constraint set: a\n-   vector of vectors containing only atomic propositions. If T is\n-   invalid, return an error. */\n-tree\n-decompose_assumptions (tree t)\n+term_list::iterator\n+load_conjunction_assumption (term_list& ts, term_list::iterator i)\n {\n-  if (!t || t == error_mark_node)\n-    return t;\n+  tree t1 = TREE_OPERAND (*i, 0);\n+  tree t2 = TREE_OPERAND (*i, 1);\n+  return ts.replace(i, t1, t2);\n+}\n \n-  /* Create a proof state, and insert T as the sole assumption. */\n-  proof_state s;\n-  term_list &l = s.begin ()->assumptions;\n-  l.insert (t);\n+/* Examine the terms in the list, and apply left-logical rules to move\n+   terms into the set of assumptions. */\n \n-  /* Decompose the expression into a constraint set, and then\n-     extract the terms for the AST. */\n-  decompose_left (s);\n-  return extract_assumptions (s);\n+void\n+load_assumptions (proof_goal& g)\n+{\n+  term_list::iterator iter = g.assumptions.begin();\n+  term_list::iterator end = g.assumptions.end();\n+  while (iter != end)\n+    {\n+      switch (TREE_CODE (*iter))\n+        {\n+        case CHECK_CONSTR:\n+          iter = load_check_assumption (g.assumptions, iter);\n+          break;\n+        case PARM_CONSTR:\n+          iter = load_parameterized_assumption (g.assumptions, iter);\n+          break;\n+        case CONJ_CONSTR:\n+          iter = load_conjunction_assumption (g.assumptions, iter);\n+          break;\n+        default:\n+          ++iter;\n+          break;\n+        }\n+    }\n }\n \n+/* In each subgoal, load constraints into the assumption set.  */\n \n-/*---------------------------------------------------------------------------\n-                           Subsumption Rules\n----------------------------------------------------------------------------*/\n+void\n+load_assumptions(proof_state& p)\n+{\n+  proof_state::iterator iter = p.begin();\n+  while (iter != p.end())\n+    {\n+      load_assumptions (*iter);\n+      ++iter;\n+    }\n+}\n \n-namespace {\n+void\n+explode_disjunction (proof_state& p, proof_state::iterator gi, term_list::iterator ti1)\n+{\n+  tree t1 = TREE_OPERAND (*ti1, 0);\n+  tree t2 = TREE_OPERAND (*ti1, 1);\n \n-bool subsumes_constraint (tree, tree);\n-bool subsumes_conjunction (tree, tree);\n-bool subsumes_disjunction (tree, tree);\n-bool subsumes_parameterized_constraint (tree, tree);\n-bool subsumes_atomic_constraint (tree, tree);\n+  /* Erase the current term from the goal. */\n+  proof_goal& g1 = *gi;\n+  proof_goal& g2 = *p.branch (gi);\n \n-/* Returns true if the assumption A matches the conclusion C. This\n-   is generally the case when A and C have the same syntax.\n+  /* Get an iterator to the equivalent position in th enew goal. */\n+  int n = std::distance (g1.assumptions.begin (), ti1);\n+  term_list::iterator ti2 = g2.assumptions.begin ();\n+  std::advance (ti2, n);\n \n-   NOTE: There will be specialized matching rules to accommodate\n-   type equivalence, conversion, inheritance, etc. But this is not\n-   in the current concepts draft. */\n-inline bool\n-match_terms (tree a, tree c)\n-{\n-  return cp_tree_equal (a, c);\n+  /* Replace the disjunction in both branches. */\n+  g1.assumptions.replace (ti1, t1);\n+  g2.assumptions.replace (ti2, t2);\n }\n \n-/* Returns true if the list of assumptions AS subsumes the atomic\n-   proposition C. This is the case when we can find a proposition\n-  in AS that entails the conclusion C. */\n+\n+/* Search the assumptions of the goal for the first disjunction. */\n+\n bool\n-subsumes_atomic_constraint (tree as, tree c)\n+explode_goal (proof_state& p, proof_state::iterator gi)\n {\n-  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)\n-    if (match_terms (TREE_VEC_ELT (as, i), c))\n-      return true;\n+  term_list& ts = gi->assumptions;\n+  term_list::iterator ti = ts.begin();\n+  term_list::iterator end = ts.end();\n+  while (ti != end)\n+    {\n+      if (TREE_CODE (*ti) == DISJ_CONSTR)\n+        {\n+          explode_disjunction (p, gi, ti);\n+          return true;\n+        }\n+      else ++ti;\n+    }\n   return false;\n }\n \n-/* Returns true when both operands of C are subsumed by the\n-   assumptions AS. */\n-inline bool\n-subsumes_conjunction (tree as, tree c)\n+/* Search for the first goal with a disjunction, and then branch\n+   creating a clone of that subgoal. */\n+\n+void\n+explode_assumptions (proof_state& p)\n {\n-  tree l = TREE_OPERAND (c, 0);\n-  tree r = TREE_OPERAND (c, 1);\n-  return subsumes_constraint (as, l) && subsumes_constraint (as, r);\n+  proof_state::iterator iter = p.begin();\n+  proof_state::iterator end = p.end();\n+  while (iter != end)\n+    {\n+      if (explode_goal (p, iter))\n+        return;\n+      ++iter;\n+    }\n }\n \n-/* Returns true when either operand of C is subsumed by the\n-   assumptions AS. */\n-inline bool\n-subsumes_disjunction (tree as, tree c)\n+\n+/*---------------------------------------------------------------------------\n+                           Right logical rules\n+---------------------------------------------------------------------------*/\n+\n+term_list::iterator\n+load_disjunction_conclusion (term_list& g, term_list::iterator i)\n {\n-  tree l = TREE_OPERAND (c, 0);\n-  tree r = TREE_OPERAND (c, 1);\n-  return subsumes_constraint (as, l) || subsumes_constraint (as, r);\n+  tree t1 = TREE_OPERAND (*i, 0);\n+  tree t2 = TREE_OPERAND (*i, 1);\n+  return g.replace(i, t1, t2);\n }\n \n-/* Returns true when the operand of C is subsumed by the\n-   assumptions in AS. The parameters are not considered in\n-   the subsumption rules. */\n-bool\n-subsumes_parameterized_constraint (tree as, tree c)\n+/* Apply logical rules to the right hand side. This will load the\n+   conclusion set with all tpp-level disjunctions.  */\n+\n+void\n+load_conclusions (proof_goal& g)\n {\n-  tree t = PARM_CONSTR_OPERAND (c);\n-  return subsumes_constraint (as, t);\n+  term_list::iterator iter = g.conclusions.begin();\n+  term_list::iterator end = g.conclusions.end();\n+  while (iter != end)\n+    {\n+      if (TREE_CODE (*iter) == DISJ_CONSTR)\n+        iter = load_disjunction_conclusion (g.conclusions, iter);\n+      else\n+        ++iter;\n+    }\n }\n \n+void\n+load_conclusions (proof_state& p)\n+{\n+  proof_state::iterator iter = p.begin();\n+  while (iter != p.end())\n+    {\n+      load_conclusions (*iter);\n+      ++iter;\n+    }\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+                          High-level proof tactics\n+---------------------------------------------------------------------------*/\n+\n+/* Given two constraints A and C, try to derive a proof that\n+   A implies C.  */\n \n-/* Returns true when the list of assumptions AS subsumes the\n-   concluded proposition C. This is a simple recursive descent\n-   on C, matching against propositions in the assumption list AS. */\n bool\n-subsumes_constraint (tree as, tree c)\n+prove_implication (tree a, tree c)\n {\n-  switch (TREE_CODE (c))\n+  /* Quick accept. */\n+  if (cp_tree_equal (a, c))\n+    return true;\n+\n+  /* Build the initial proof state. */\n+  proof_state proof;\n+  proof_goal& goal = proof.front();\n+  goal.assumptions.push_back(a);\n+  goal.conclusions.push_back(c);\n+\n+  /* Perform an initial right-expansion in the off-chance that the right\n+     hand side contains disjunctions. */\n+  load_conclusions (proof);\n+\n+  int step_max = 1 << 10;\n+  int step_count = 0;              /* FIXME: We shouldn't have this. */\n+  std::size_t branch_limit = 1024; /* FIXME: This needs to be configurable. */\n+  while (step_count < step_max && proof.size() < branch_limit)\n     {\n-    case CONJ_CONSTR:\n-      return subsumes_conjunction (as, c);\n-    case DISJ_CONSTR:\n-      return subsumes_disjunction (as, c);\n-    case PARM_CONSTR:\n-      return subsumes_parameterized_constraint (as, c);\n-    default:\n-      return subsumes_atomic_constraint (as, c);\n+      /* Determine if we can prove that the assumptions entail the\n+         conclusions. If so, we're done. */\n+      load_assumptions (proof);\n+\n+      /* Can we solve the proof based on this? */\n+      proof_result r = check_proof (proof);\n+      if (r != undecided)\n+        return r == valid;\n+\n+      /* If not, then we need to dig into disjunctions.  */\n+      explode_assumptions (proof);\n+\n+      ++step_count;\n     }\n+\n+  if (step_count == step_max)\n+    error (\"subsumption failed to resolve\");\n+\n+  if (proof.size() == branch_limit)\n+    error (\"exceeded maximum number of branches\");\n+\n+  return false;\n }\n \n-/* Returns true if the LEFT constraints subsume the RIGHT constraints.\n-   This is done by checking that the RIGHT requirements follow from\n-   each of the LEFT subgoals. */\n+/* Returns true if the LEFT constraint subsume the RIGHT constraints.\n+   This is done by deriving a proof of the conclusions on the RIGHT\n+   from the assumptions on the LEFT assumptions.  */\n+\n bool\n subsumes_constraints_nonnull (tree left, tree right)\n {\n   gcc_assert (check_constraint_info (left));\n   gcc_assert (check_constraint_info (right));\n \n-  /* Check that the required expression in RIGHT is subsumed by each\n-     subgoal in the assumptions of LEFT. */\n-  tree as = CI_ASSUMPTIONS (left);\n-  tree c = CI_NORMALIZED_CONSTRAINTS (right);\n-  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)\n-    if (!subsumes_constraint (TREE_VEC_ELT (as, i), c))\n-      return false;\n-  return true;\n+  auto_timevar time (TV_CONSTRAINT_SUB);\n+  tree a = CI_ASSOCIATED_CONSTRAINTS (left);\n+  tree c = CI_ASSOCIATED_CONSTRAINTS (right);\n+  return prove_implication (a, c);\n }\n \n } /* namespace */\n \n /* Returns true if the LEFT constraints subsume the RIGHT\n-   constraints. */\n+   constraints.  */\n+\n bool\n subsumes (tree left, tree right)\n {"}, {"sha": "9bdb10894184bca9fa9eaacb605067ce05890bcd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -14728,10 +14728,13 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \tcp_parser_require (parser, CPP_GREATER, RT_GREATER);\n \n         // If template requirements are present, parse them.\n-\ttree reqs = get_shorthand_constraints (current_template_parms);\n-\tif (tree r = cp_parser_requires_clause_opt (parser))\n-\t  reqs = conjoin_constraints (reqs, make_predicate_constraint (r));\n-\tTEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+\tif (flag_concepts)\n+          {\n+\t    tree reqs = get_shorthand_constraints (current_template_parms);\n+\t    if (tree r = cp_parser_requires_clause_opt (parser))\n+              reqs = conjoin_constraints (reqs, normalize_expression (r));\n+\t    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+          }\n \n \t/* Look for the `class' or 'typename' keywords.  */\n \tcp_parser_type_parameter_key (parser);\n@@ -25754,10 +25757,13 @@ cp_parser_explicit_template_declaration (cp_parser* parser, bool member_p)\n   cp_parser_skip_to_end_of_template_parameter_list (parser);\n \n   /* Manage template requirements */\n-  tree reqs = get_shorthand_constraints (current_template_parms);\n-  if (tree r = cp_parser_requires_clause_opt (parser))\n-    reqs = conjoin_constraints (reqs, make_predicate_constraint (r));\n-  TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+  if (flag_concepts)\n+  {\n+    tree reqs = get_shorthand_constraints (current_template_parms);\n+    if (tree r = cp_parser_requires_clause_opt (parser))\n+      reqs = conjoin_constraints (reqs, normalize_expression (r));\n+    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+  }\n \n   cp_parser_template_declaration_after_parameters (parser, parameter_list,\n \t\t\t\t\t\t   member_p);\n@@ -37916,7 +37922,13 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n       implicit template scope, and we're trying to synthesize a\n       constrained parameter, try to find a previous parameter with\n       the same name.  This is the same-type rule for abbreviated\n-      function templates.  */\n+      function templates.\n+\n+      NOTE: We can generate implicit parameters when tentatively\n+      parsing a nested name specifier, only to reject that parse\n+      later. However, matching the same template-id as part of a\n+      direct-declarator should generate an identical template\n+      parameter, so this rule will merge them. */\n   if (parser->implicit_template_scope && constr)\n     {\n       tree t = parser->implicit_template_parms;"}, {"sha": "d7f380857bdc0e4f22b0921e9d0f192d8c4ab1fb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 261, "deletions": 22, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -195,7 +195,6 @@ static tree try_class_unification (tree, tree, tree, tree, bool);\n static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n \t\t\t\t\t   tree, tree);\n static bool template_template_parm_bindings_ok_p (tree, tree);\n-static int template_args_equal (tree, tree);\n static void tsubst_default_arguments (tree, tsubst_flags_t);\n static tree for_each_template_parm_r (tree *, int *, void *);\n static tree copy_default_args_to_explicit_spec_1 (tree, tree);\n@@ -7855,7 +7854,7 @@ coerce_innermost_template_parms (tree parms,\n \n /* Returns 1 if template args OT and NT are equivalent.  */\n \n-static int\n+int\n template_args_equal (tree ot, tree nt)\n {\n   if (nt == ot)\n@@ -8702,7 +8701,7 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n     {\n       if (complain & tf_error)\n \t{\n-\t  error (\"constraints for %qD not satisfied\", templ);\n+\t  error (\"use of invalid variable template %qE\", var);\n \t  diagnose_constraints (location_of (var), templ, arglist);\n \t}\n       return error_mark_node;\n@@ -9058,7 +9057,7 @@ uses_outer_template_parms (tree decl)\n     return true;\n   tree ci = get_constraints (decl);\n   if (ci)\n-    ci = CI_NORMALIZED_CONSTRAINTS (ci);\n+    ci = CI_ASSOCIATED_CONSTRAINTS (ci);\n   if (ci && for_each_template_parm (ci, template_parm_outer_level,\n \t\t\t\t    &depth, NULL, /*nondeduced*/true))\n     return true;\n@@ -23764,7 +23763,10 @@ build_non_dependent_expr (tree expr)\n       && cxx_dialect >= cxx11\n       /* Don't do this during nsdmi parsing as it can lead to\n \t unexpected recursive instantiations.  */\n-      && !parsing_nsdmi ())\n+      && !parsing_nsdmi ()\n+      /* Don't do this during concept expansion either and for\n+         the same reason.  */\n+      && !expanding_concept ())\n     fold_non_dependent_expr (expr);\n \n   /* Preserve OVERLOADs; the functions must be available to resolve\n@@ -23902,7 +23904,7 @@ make_constrained_auto (tree con, tree args)\n   else\n     expr = build_concept_check (build_overload (tmpl, NULL_TREE), type, args);\n \n-  tree constr = make_predicate_constraint (expr);\n+  tree constr = normalize_expression (expr);\n   PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;\n \n   /* Our canonical type depends on the constraint.  */\n@@ -24054,7 +24056,10 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.\n    The CONTEXT determines the context in which auto deduction is performed\n-   and is used to control error diagnostics.  */\n+   and is used to control error diagnostics.\n+\n+   For partial-concept-ids, extra args may be appended to the list of deduced\n+   template arguments prior to determining constraint satisfaction.  */\n \n tree\n do_auto_deduction (tree type, tree init, tree auto_node,\n@@ -24161,8 +24166,19 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n   if (flag_concepts && !processing_template_decl)\n     if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (auto_node))\n       {\n-        /* Use the deduced type to check the associated constraints. */\n-        if (!constraints_satisfied_p (constr, targs))\n+        /* Use the deduced type to check the associated constraints. If we\n+           have a partial-concept-id, rebuild the argument list so that\n+           we check using the extra arguments. */\n+        gcc_assert (TREE_CODE (constr) == CHECK_CONSTR);\n+        tree cargs = CHECK_CONSTR_ARGS (constr);\n+        if (TREE_VEC_LENGTH (cargs) > 1)\n+          {\n+            cargs = copy_node (cargs);\n+            TREE_VEC_ELT (cargs, 0) = TREE_VEC_ELT (targs, 0);\n+          }\n+        else\n+          cargs = targs;\n+        if (!constraints_satisfied_p (constr, cargs))\n           {\n             if (complain & tf_warning_or_error)\n               {\n@@ -24482,24 +24498,15 @@ struct constr_hasher : ggc_ptr_hash<constr_entry>\n \n static GTY (()) hash_table<constr_hasher> *decl_constraints;\n \n-/* Returns true iff cinfo contains a valid set of constraints.\n-   This is the case when the associated requirements have been\n-   successfully decomposed into lists of atomic constraints.\n-   That is, when the saved assumptions are not error_mark_node.  */\n-\n-bool\n-valid_constraints_p (tree cinfo)\n-{\n-  gcc_assert (cinfo);\n-  return CI_ASSUMPTIONS (cinfo) != error_mark_node;\n-}\n-\n /* Returns the template constraints of declaration T. If T is not\n    constrained, return NULL_TREE. Note that T must be non-null. */\n \n tree\n get_constraints (tree t)\n {\n+  if (!flag_concepts)\n+    return NULL_TREE;\n+\n   gcc_assert (DECL_P (t));\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n@@ -24521,7 +24528,7 @@ set_constraints (tree t, tree ci)\n {\n   if (!ci)\n     return;\n-  gcc_assert (t);\n+  gcc_assert (t && flag_concepts);\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n   gcc_assert (!get_constraints (t));\n@@ -24547,12 +24554,244 @@ remove_constraints (tree t)\n     decl_constraints->clear_slot (slot);\n }\n \n+/* Memoized satisfaction results for declarations. This\n+   maps the pair (constraint_info, arguments) to the result computed\n+   by constraints_satisfied_p.  */\n+\n+struct GTY((for_user)) constraint_sat_entry\n+{\n+  tree ci;\n+  tree args;\n+  tree result;\n+};\n+\n+/* Hashing function and equality for constraint entries. */\n+\n+struct constraint_sat_hasher : ggc_ptr_hash<constraint_sat_entry>\n+{\n+  static hashval_t hash (constraint_sat_entry *e)\n+  {\n+    hashval_t val = iterative_hash_object(e->ci, 0);\n+    return iterative_hash_template_arg (e->args, val);\n+  }\n+\n+  static bool equal (constraint_sat_entry *e1, constraint_sat_entry *e2)\n+  {\n+    return e1->ci == e2->ci && comp_template_args (e1->args, e2->args);\n+  }\n+};\n+\n+/* Memoized satisfaction results for concept checks. */\n+\n+struct GTY((for_user)) concept_spec_entry\n+{\n+  tree tmpl;\n+  tree args;\n+  tree result;\n+};\n+\n+/* Hashing function and equality for constraint entries.  */\n+\n+struct concept_spec_hasher : ggc_ptr_hash<concept_spec_entry>\n+{\n+  static hashval_t hash (concept_spec_entry *e)\n+  {\n+    return hash_tmpl_and_args (e->tmpl, e->args);\n+  }\n+\n+  static bool equal (concept_spec_entry *e1, concept_spec_entry *e2)\n+  {\n+    ++comparing_specializations;\n+    bool eq = e1->tmpl == e2->tmpl && comp_template_args (e1->args, e2->args);\n+    --comparing_specializations;\n+    return eq;\n+  }\n+};\n+\n+static GTY (()) hash_table<constraint_sat_hasher> *constraint_memos;\n+static GTY (()) hash_table<concept_spec_hasher> *concept_memos;\n+\n+/* Search for a memoized satisfaction result. Returns one of the\n+   truth value nodes if previously memoized, or NULL_TREE otherwise.   */\n+\n+tree\n+lookup_constraint_satisfaction (tree ci, tree args)\n+{\n+  constraint_sat_entry elt = { ci, args, NULL_TREE };\n+  constraint_sat_entry* found = constraint_memos->find (&elt);\n+  if (found)\n+    return found->result;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Memoize the result of a satisfication test. Returns the saved result.  */\n+\n+tree\n+memoize_constraint_satisfaction (tree ci, tree args, tree result)\n+{\n+  constraint_sat_entry elt = {ci, args, result};\n+  constraint_sat_entry** slot = constraint_memos->find_slot (&elt, INSERT);\n+  constraint_sat_entry* entry = ggc_alloc<constraint_sat_entry> ();\n+  *entry = elt;\n+  *slot = entry;\n+  return result;\n+}\n+\n+/* Search for a memoized satisfaction result for a concept. */\n+\n+tree\n+lookup_concept_satisfaction (tree tmpl, tree args)\n+{\n+  concept_spec_entry elt = { tmpl, args, NULL_TREE };\n+  concept_spec_entry* found = concept_memos->find (&elt);\n+  if (found)\n+    return found->result;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Memoize the result of a concept check. Returns the saved result.  */\n+\n+tree\n+memoize_concept_satisfaction (tree tmpl, tree args, tree result)\n+{\n+  concept_spec_entry elt = {tmpl, args, result};\n+  concept_spec_entry** slot = concept_memos->find_slot (&elt, INSERT);\n+  concept_spec_entry* entry = ggc_alloc<concept_spec_entry> ();\n+  *entry = elt;\n+  *slot = entry;\n+  return result;\n+}\n+\n+static GTY (()) hash_table<concept_spec_hasher> *concept_expansions;\n+\n+/* Returns a prior concept specialization. This returns the substituted\n+   and normalized constraints defined by the concept.  */\n+\n+tree\n+get_concept_expansion (tree tmpl, tree args)\n+{\n+  concept_spec_entry elt = { tmpl, args, NULL_TREE };\n+  concept_spec_entry* found = concept_expansions->find (&elt);\n+  if (found)\n+    return found->result;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Save a concept expansion for later.  */\n+\n+tree\n+save_concept_expansion (tree tmpl, tree args, tree def)\n+{\n+  concept_spec_entry elt = {tmpl, args, def};\n+  concept_spec_entry** slot = concept_expansions->find_slot (&elt, INSERT);\n+  concept_spec_entry* entry = ggc_alloc<concept_spec_entry> ();\n+  *entry = elt;\n+  *slot = entry;\n+  return def;\n+}\n+\n+static hashval_t\n+hash_subsumption_args (tree t1, tree t2)\n+{\n+  gcc_assert (TREE_CODE (t1) == CHECK_CONSTR);\n+  gcc_assert (TREE_CODE (t2) == CHECK_CONSTR);\n+  int val = 0;\n+  val = iterative_hash_object (CHECK_CONSTR_CONCEPT (t1), val);\n+  val = iterative_hash_template_arg (CHECK_CONSTR_ARGS (t1), val);\n+  val = iterative_hash_object (CHECK_CONSTR_CONCEPT (t2), val);\n+  val = iterative_hash_template_arg (CHECK_CONSTR_ARGS (t2), val);\n+  return val;\n+}\n+\n+/* Compare the constraints of two subsumption entries.  The LEFT1 and\n+   LEFT2 arguments comprise the first subsumption pair and the RIGHT1\n+   and RIGHT2 arguments comprise the second. These are all CHECK_CONSTRs. */\n+\n+static bool\n+comp_subsumption_args (tree left1, tree left2, tree right1, tree right2)\n+{\n+  if (CHECK_CONSTR_CONCEPT (left1) == CHECK_CONSTR_CONCEPT (right1))\n+    if (CHECK_CONSTR_CONCEPT (left2) == CHECK_CONSTR_CONCEPT (right2))\n+      if (comp_template_args (CHECK_CONSTR_ARGS (left1),\n+                             CHECK_CONSTR_ARGS (right1)))\n+        return comp_template_args (CHECK_CONSTR_ARGS (left2),\n+                                  CHECK_CONSTR_ARGS (right2));\n+  return false;\n+}\n+\n+/* Key/value pair for learning and memoizing subsumption results. This\n+   associates a pair of check constraints (including arguments) with\n+   a boolean value indicating the result.  */\n+\n+struct GTY((for_user)) subsumption_entry\n+{\n+  tree t1;\n+  tree t2;\n+  bool result;\n+};\n+\n+/* Hashing function and equality for constraint entries.  */\n+\n+struct subsumption_hasher : ggc_ptr_hash<subsumption_entry>\n+{\n+  static hashval_t hash (subsumption_entry *e)\n+  {\n+    return hash_subsumption_args (e->t1, e->t2);\n+  }\n+\n+  static bool equal (subsumption_entry *e1, subsumption_entry *e2)\n+  {\n+    ++comparing_specializations;\n+    bool eq = comp_subsumption_args(e1->t1, e1->t2, e2->t1, e2->t2);\n+    --comparing_specializations;\n+    return eq;\n+  }\n+};\n+\n+static GTY (()) hash_table<subsumption_hasher> *subsumption_table;\n+\n+/* Search for a previously cached subsumption result. */\n+\n+bool*\n+lookup_subsumption_result (tree t1, tree t2)\n+{\n+  subsumption_entry elt = { t1, t2, false };\n+  subsumption_entry* found = subsumption_table->find (&elt);\n+  if (found)\n+    return &found->result;\n+  else\n+    return 0;\n+}\n+\n+/* Save a subsumption result. */\n+\n+bool\n+save_subsumption_result (tree t1, tree t2, bool result)\n+{\n+  subsumption_entry elt = {t1, t2, result};\n+  subsumption_entry** slot = subsumption_table->find_slot (&elt, INSERT);\n+  subsumption_entry* entry = ggc_alloc<subsumption_entry> ();\n+  *entry = elt;\n+  *slot = entry;\n+  return result;\n+}\n+\n /* Set up the hash table for constraint association. */\n \n void\n init_constraint_processing (void)\n {\n+  if (!flag_concepts)\n+    return;\n+\n   decl_constraints = hash_table<constr_hasher>::create_ggc(37);\n+  constraint_memos = hash_table<constraint_sat_hasher>::create_ggc(37);\n+  concept_memos = hash_table<concept_spec_hasher>::create_ggc(37);\n+  concept_expansions = hash_table<concept_spec_hasher>::create_ggc(37);\n+  subsumption_table = hash_table<subsumption_hasher>::create_ggc(37);\n }\n \n /* Set up the hash tables for template instantiations.  */"}, {"sha": "5726f96b295aa0db0a58f1b7b1a6ddd7a58473ca", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -260,7 +260,6 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n \t\t      indent+4);\n         print_node (file, \"associated_constr\",\n                           cinfo->associated_constr, indent+4);\n-        print_node_brief (file, \"assumptions\", cinfo->assumptions, indent+4);\n         break;\n       }\n     case ARGUMENT_PACK_SELECT:"}, {"sha": "325ef98ea977372ff0628a5d024c91a924b6e889", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -947,6 +947,7 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n      in default arguments for template parameters), and access\n      checking should be performed in the outermost parameter list.  */\n   if (processing_template_decl\n+      && !expanding_concept ()\n       && (!processing_template_parmlist || processing_template_decl > 1))\n     return 1;\n "}, {"sha": "6adeb63dd06df52bd573685c116532cb4bb839df", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -3182,6 +3182,11 @@ cp_tree_equal (tree t1, tree t2)\n       return cp_tree_equal (CI_ASSOCIATED_CONSTRAINTS (t1),\n                             CI_ASSOCIATED_CONSTRAINTS (t2));\n \n+    case CHECK_CONSTR:\n+      return (CHECK_CONSTR_CONCEPT (t1) == CHECK_CONSTR_CONCEPT (t2)\n+              && comp_template_args (CHECK_CONSTR_ARGS (t1),\n+\t\t\t\t     CHECK_CONSTR_ARGS (t2)));\n+\n     case TREE_VEC:\n       {\n \tunsigned ix;"}, {"sha": "0552c4b06238489131b6c9bdd0aa8e05873fb389", "filename": "gcc/testsuite/g++.dg/concepts/diagnostic1.C", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic1.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -1,16 +1,30 @@\n // PR c++/67159\n // { dg-options \"-std=c++1z -fconcepts\" }\n \n+template <class T, class U>\n+concept bool SameAs = __is_same_as(T, U);\n+\n template <class T>\n-concept bool R = requires (T& t) {\n+concept bool R1 = requires (T& t) {\n   { t.begin() } -> T\n+  { t.end() } -> SameAs<T*>;\n+};\n+\n+template <class T>\n+concept bool R2 = requires (T& t) {\n+  { t.end() } -> SameAs<T*>;\n };\n \n struct foo {\n   int* begin();\n+  int* end();\n };\n \n-R{T}\n+R1{T}\n constexpr bool f() { return true; }\n \n+R2{T}\n+constexpr bool g() { return true; }\n+\n static_assert(f<foo>());\t// { dg-error \"\" }\n+static_assert(g<foo>());\t// { dg-error \"\" }"}, {"sha": "178467a16911c1ee50bbd295bbcf11f33ec91a52", "filename": "gcc/testsuite/g++.dg/concepts/dr1430.C", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -24,11 +24,19 @@ template <typename T, typename U, typename... Args>\n     return decltype(check<T, U, Args...>())::value;\n   }\n \n+template <typename T, typename U, typename... Args>\n+  concept bool Similar = true;\n+\n template <typename... Args>\n-requires Same<Args...>()\t// { dg-error \"concept\" }\n+requires Same<Args...>() // { dg-error \"invalid reference\" }\n   void foo( Args... args ) {}\n \n+template <typename... Args>\n+requires Similar<Args...> // { dg-error \"invalid reference\" }\n+  void bar( Args... args ) {}\n+\n int main()\n {\n-  foo(1, 2, 3);\t\t\t// { dg-error \"\" }\n+  foo(1, 2, 3); // { dg-error \"cannot call\" }\n+  bar(1, 2, 3); // { dg-error \"cannot call\" }\n }"}, {"sha": "32b79c8f32bb598a9a05aaca610e55684dfca994", "filename": "gcc/testsuite/g++.dg/concepts/expression2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -31,12 +31,12 @@ class S\n int main()\n {\n   f1(s); // { dg-error \"cannot call\" }\n-  f2(s); // { dg-error \"cannot call\" }\n+  f2(s); // { dg-error \"\" }\n \n   // When used in non-SFINAE contexts, make sure that we fail\n   // the constraint check before emitting the access check\n   // failures. The context is being presented constistently\n   // in both cases.\n   static_assert(C1<S>(), \"\"); // { dg-error \"failed\" }\n-  static_assert(C2<S>(), \"\"); // { dg-error \"failed\" }\n+  static_assert(C2<S>(), \"\"); // { dg-error \"\" }\n }"}, {"sha": "0564b0ce8b0641a687db7188ffd47774d9b20f31", "filename": "gcc/testsuite/g++.dg/concepts/req19.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq19.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z -fconcepts\" }\n+\n+struct B\n+{\n+  template <class T> void f(T t)\n+    requires requires (T tt) { tt; }\n+  { }\n+};\n+\n+int main()\n+{\n+  B().f(42);\n+}"}, {"sha": "e89e905a88f4b63ef3c1b9249f13cc1a8f20e778", "filename": "gcc/testsuite/g++.dg/concepts/req20.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq20.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-std=c++1z -fconcepts\" }\n+\n+template <class T> concept bool C = true;\n+\n+template <class T>\n+requires C<typename T::foo>\n+void f(T t) { }\n+\n+void f(...);\n+\n+template <class T>\n+requires C<T>\n+void g(T t) { }\n+\n+int main()\n+{\n+  f(42);\n+  g(42);\n+}\n+"}, {"sha": "2bd5f1552f91200a50ecb095e723725ed1e6757c", "filename": "gcc/testsuite/g++.dg/concepts/req4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -9,10 +9,10 @@ template<typename T> constexpr fool p1() { return {}; }\n template<typename T> constexpr fool p2() { return {}; }\n \n template<typename T>\n-  concept bool C() { return p1<T>() && p2<T>(); } // { dg-error \"does not have type\" }\n+  concept bool C() { return p1<T>() && p2<T>(); }\n \n template<C T> void f(T x) { }\n \n int main() {\n-  f(0); // { dg-error \"cannot call\" }\n+  f(0); // { dg-error \"cannot call|uses overloaded operator\" }\n }"}, {"sha": "7953869360f98ef9e6001112b46ce47cce0ecafe", "filename": "gcc/testsuite/g++.dg/concepts/req5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -9,10 +9,10 @@ template<typename T> constexpr fool p1() { return {}; }\n template<typename T> constexpr fool p2() { return {}; }\n \n template<typename T>\n-  concept bool C() { return p1<T>() && p2<T>(); } // { dg-error \"does not have type\" }\n+  concept bool C() { return p1<T>() && p2<T>(); }\n \n template<C T> void f(T x) { }\n \n int main() {\n-  f(0); // { dg-error \"cannot call\" }\n+  f(0); // { dg-error \"cannot call|uses overloaded operator\" }\n }"}, {"sha": "6e111b260ac94426ab6baa94632876228daad142", "filename": "gcc/testsuite/g++.dg/concepts/req6.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -7,7 +7,12 @@ template<typename T>\n   concept bool C1() { return X(); }\n \n template<C1 T>\n-  void h(T) { } // { dg-error \"not|bool\" }\n+  void h(T) { } // OK until used.\n+\n+void f()\n+{\n+  h(0); // { dg-error \"does not have|cannot call\" }\n+}\n \n template<typename T>\n   concept bool C2() { return X() == X(); } // OK"}, {"sha": "99ffdc0a4834eb32a52241f49d252b7a322a5991", "filename": "gcc/testsuite/g++.dg/concepts/var-templ1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -13,4 +13,4 @@ template <class T>\n constexpr bool f() { return false; }\n \n static_assert(f<void>());\n-static_assert(v<void>);\t\t// { dg-error \"constraints\" }\n+static_assert(v<void>);\t\t// { dg-error \"invalid\" }"}, {"sha": "e60e9ff40134f0e823b2961be4b4f0b3baab4271", "filename": "gcc/testsuite/g++.dg/concepts/variadic2.C", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -4,10 +4,13 @@ template <class T> concept bool Copyable = requires (T t) { T(t); };\n template <class T> concept bool Constructable = requires { T(); };\n template <class T> concept bool Both = Copyable<T> && Constructable<T>;\n \n-template <Copyable... Ts> void f(Ts...) { }\n-template <Both... Ts> void f(Ts...) { }\n+template <Copyable... Ts>\n+constexpr int f(Ts...) { return 0; } // #1\n+\n+template <Both... Ts>\n+constexpr int f(Ts...) { return 1; }     // #2\n \n int main()\n {\n-  f(42);\n+  static_assert(f(42) == 1);\n }"}, {"sha": "5f121182e14955218d4da63bcf664197e74731e3", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -137,6 +137,8 @@ DEFTIMEVAR (TV_PARSE_FUNC            , \"parser function body\")\n DEFTIMEVAR (TV_PARSE_INLINE          , \"parser inl. func. body\")\n DEFTIMEVAR (TV_PARSE_INMETH          , \"parser inl. meth. body\")\n DEFTIMEVAR (TV_TEMPLATE_INST         , \"template instantiation\")\n+DEFTIMEVAR (TV_CONSTRAINT_SAT        , \"constraint satisfaction\")\n+DEFTIMEVAR (TV_CONSTRAINT_SUB        , \"constraint subsumption\")\n DEFTIMEVAR (TV_FLATTEN_INLINING      , \"flatten inlining\")\n DEFTIMEVAR (TV_EARLY_INLINING        , \"early inlining heuristics\")\n DEFTIMEVAR (TV_INLINE_PARAMETERS     , \"inline parameters\")"}, {"sha": "34653044d6592d7115e7aa0d82915665cd8b9d98", "filename": "gcc/timevar.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f078dc7d269d8afd2874476181ee61662a16a3d0/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=f078dc7d269d8afd2874476181ee61662a16a3d0", "patch": "@@ -229,6 +229,14 @@ class auto_timevar\n       m_timer->push (m_tv);\n   }\n \n+  explicit auto_timevar (timevar_id_t tv)\n+    : m_timer (g_timer)\n+    , m_tv (tv)\n+  {\n+    if (m_timer)\n+      m_timer->push (m_tv);\n+  }\n+\n   ~auto_timevar ()\n   {\n     if (m_timer)"}]}