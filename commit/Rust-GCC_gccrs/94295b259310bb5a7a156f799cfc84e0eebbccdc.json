{"sha": "94295b259310bb5a7a156f799cfc84e0eebbccdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQyOTViMjU5MzEwYmI1YTdhMTU2Zjc5OWNmYzg0ZTBlZWJiY2NkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:26:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:26:52Z"}, "message": "[multiple changes]\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb, checks.adb, sem_prag.adb, eval_fat.adb: Minor\n\treformatting.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* binde.adb (Validate): Do not pass dynamic strings\n\tto pragma Assert, because older compilers do not support that.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* s-fileio.adb (Close): When a temp file is\n\tclosed, delete it and clean up its Temp_File_Record immediately,\n\trather than waiting until later.\n\t(Temp_File_Record): Add File\n\tcomponent, so Close can know which Temp_File_Record corresponds\n\tto the file being closed.\n\t(Delete): Don't delete temp files,\n\tbecause they are deleted by Close.\n\t(Open): Set the File component\n\tof Temp_File_Record. This requires moving the creation of the\n\tTemp_File_Record to the end, after the AFCB has been created.\n\nFrom-SVN: r247175", "tree": {"sha": "3f8a3173b3920001fd32468ae606c748bfda8a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f8a3173b3920001fd32468ae606c748bfda8a3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94295b259310bb5a7a156f799cfc84e0eebbccdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94295b259310bb5a7a156f799cfc84e0eebbccdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94295b259310bb5a7a156f799cfc84e0eebbccdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94295b259310bb5a7a156f799cfc84e0eebbccdc/comments", "author": null, "committer": null, "parents": [{"sha": "b0cd50fdc3c2c8a0221a1c7d8379f4c7e15e623f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cd50fdc3c2c8a0221a1c7d8379f4c7e15e623f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0cd50fdc3c2c8a0221a1c7d8379f4c7e15e623f"}], "stats": {"total": 206, "additions": 141, "deletions": 65}, "files": [{"sha": "d33d7b6ed0000113d5b84e41125c5bc43fa74ae2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -1,3 +1,27 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb, checks.adb, sem_prag.adb, eval_fat.adb: Minor\n+\treformatting.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* binde.adb (Validate): Do not pass dynamic strings\n+\tto pragma Assert, because older compilers do not support that.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* s-fileio.adb (Close): When a temp file is\n+\tclosed, delete it and clean up its Temp_File_Record immediately,\n+\trather than waiting until later.\n+\t(Temp_File_Record): Add File\n+\tcomponent, so Close can know which Temp_File_Record corresponds\n+\tto the file being closed.\n+\t(Delete): Don't delete temp files,\n+\tbecause they are deleted by Close.\n+\t(Open): Set the File component\n+\tof Temp_File_Record. This requires moving the creation of the\n+\tTemp_File_Record to the end, after the AFCB has been created.\n+\n 2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* checks.adb (Insert_Valid_Check): Do not generate"}, {"sha": "58bf4fa15e77a00a91ae1e0c4345cd2dfa7bd8d3", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -2234,10 +2234,13 @@ package body Binde is\n \n          begin\n             while S /= No_Successor loop\n-               pragma Assert\n-                 (UNR.Table (Succ.Table (S).After).Elab_Position >\n-                  UNR.Table (U).Elab_Position,\n-                  Msg & \" elab order failed\");\n+               if UNR.Table (Succ.Table (S).After).Elab_Position <=\n+                 UNR.Table (U).Elab_Position\n+               then\n+                  OK := False;\n+                  Write_Line (Msg & \" elab order failed\");\n+               end if;\n+\n                S := Succ.Table (S).Next;\n             end loop;\n          end;"}, {"sha": "b839863e5c28ccbcb72f58338f2d850abaf5625c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -2959,23 +2959,23 @@ package body Checks is\n         and then No (Source_Typ)\n       then\n          declare\n-            Tlo : constant Node_Id := Type_Low_Bound  (Target_Typ);\n             Thi : constant Node_Id := Type_High_Bound (Target_Typ);\n+            Tlo : constant Node_Id := Type_Low_Bound  (Target_Typ);\n \n          begin\n             if Compile_Time_Known_Value (Tlo)\n               and then Compile_Time_Known_Value (Thi)\n             then\n                declare\n-                  Lov : constant Uint := Expr_Value (Tlo);\n                   Hiv : constant Uint := Expr_Value (Thi);\n-                  Lo  : Uint;\n+                  Lov : constant Uint := Expr_Value (Tlo);\n                   Hi  : Uint;\n+                  Lo  : Uint;\n \n                begin\n-                  --  If range is null, we for sure have a constraint error\n-                  --  (we don't even need to look at the value involved,\n-                  --  since all possible values will raise CE).\n+                  --  If range is null, we for sure have a constraint error (we\n+                  --  don't even need to look at the value involved, since all\n+                  --  possible values will raise CE).\n \n                   if Lov > Hiv then\n \n@@ -2998,8 +2998,8 @@ package body Checks is\n                   --  Otherwise determine range of value\n \n                   if Is_Discrete_Type (Etype (Expr)) then\n-                     Determine_Range (Expr, OK, Lo, Hi,\n-                                      Assume_Valid => True);\n+                     Determine_Range\n+                       (Expr, OK, Lo, Hi, Assume_Valid => True);\n \n                   --  When converting a float to an integer type, determine the\n                   --  range in real first, and then convert the bounds using\n@@ -3013,11 +3013,12 @@ package body Checks is\n                     and then Is_Floating_Point_Type (Etype (Expr))\n                   then\n                      declare\n-                        Lor : Ureal;\n                         Hir : Ureal;\n+                        Lor : Ureal;\n+\n                      begin\n-                        Determine_Range_R (Expr, OK, Lor, Hir,\n-                                           Assume_Valid => True);\n+                        Determine_Range_R\n+                          (Expr, OK, Lor, Hir, Assume_Valid => True);\n \n                         if OK then\n                            Lo := UR_To_Uint (Lor);\n@@ -5111,6 +5112,7 @@ package body Checks is\n                   M2 : constant Ureal := Round_Machine (Lo_Left * Hi_Right);\n                   M3 : constant Ureal := Round_Machine (Hi_Left * Lo_Right);\n                   M4 : constant Ureal := Round_Machine (Hi_Left * Hi_Right);\n+\n                begin\n                   Lor := UR_Min (UR_Min (M1, M2), UR_Min (M3, M4));\n                   Hir := UR_Max (UR_Max (M1, M2), UR_Max (M3, M4));\n@@ -5195,10 +5197,12 @@ package body Checks is\n \n             elsif Is_Discrete_Type (Etype (Expression (N))) then\n                declare\n-                  Lor_Int, Hir_Int : Uint;\n+                  Hir_Int : Uint;\n+                  Lor_Int : Uint;\n+\n                begin\n-                  Determine_Range (Expression (N), OK1, Lor_Int, Hir_Int,\n-                                   Assume_Valid);\n+                  Determine_Range\n+                    (Expression (N), OK1, Lor_Int, Hir_Int, Assume_Valid);\n \n                   if OK1 then\n                      Lor := Round_Machine (UR_From_Uint (Lor_Int));"}, {"sha": "7cb3a3c005361f27cea1375e403c046dd736f69b", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -503,8 +503,9 @@ package body Eval_Fat is\n \n       if X_Exp < Emin then\n          declare\n-            Emin_Den : constant UI := Machine_Emin_Value (RT)\n-                                        - Machine_Mantissa_Value (RT) + Uint_1;\n+            Emin_Den : constant UI := Machine_Emin_Value (RT) -\n+                                        Machine_Mantissa_Value (RT) + Uint_1;\n+\n          begin\n             --  Do not issue warnings about underflows in GNATprove mode,\n             --  as calling Machine as part of interval checking may lead\n@@ -516,13 +517,15 @@ package body Eval_Fat is\n                      Error_Msg_N\n                        (\"floating-point value underflows to -0.0??\", Enode);\n                   end if;\n+\n                   return Ureal_M_0;\n \n                else\n                   if not GNATprove_Mode then\n                      Error_Msg_N\n                        (\"floating-point value underflows to 0.0??\", Enode);\n                   end if;\n+\n                   return Ureal_0;\n                end if;\n \n@@ -553,8 +556,8 @@ package body Eval_Fat is\n \n                begin\n                   --  Do not issue warnings about loss of precision in\n-                  --  GNATprove mode, as calling Machine as part of\n-                  --  interval checking may lead to spurious warnings.\n+                  --  GNATprove mode, as calling Machine as part of interval\n+                  --  checking may lead to spurious warnings.\n \n                   if X_Frac_Denorm /= X_Frac then\n                      if not GNATprove_Mode then"}, {"sha": "56414e00a623b4f448ddbd69e53b1204321a5cde", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -787,7 +787,7 @@ package body Exp_Ch7 is\n               Typ   => Typ,\n               Stmts => Make_Deep_Array_Body (Finalize_Case, Typ)));\n \n-         --  Create TSS primitive Finalize_Address (unless CodePeer_Mode).\n+         --  Create TSS primitive Finalize_Address (unless CodePeer_Mode)\n \n          if not CodePeer_Mode then\n             Set_TSS (Typ,\n@@ -3671,7 +3671,7 @@ package body Exp_Ch7 is\n               Typ   => Typ,\n               Stmts => Make_Deep_Record_Body (Finalize_Case, Typ)));\n \n-         --  Create TSS primitive Finalize_Address (unless CodePeer_Mode).\n+         --  Create TSS primitive Finalize_Address (unless CodePeer_Mode)\n \n          if not CodePeer_Mode then\n             Set_TSS (Typ,\n@@ -7801,7 +7801,8 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n-      --  Don't generate Finalize_Address routine for CodePeer\n+      --  Do not generate Finalize_Address routine for CodePeer\n+\n       if CodePeer_Mode then\n          return;\n       end if;"}, {"sha": "796b0b1d87d09847fd205a7cd53652970fd2d43c", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -64,19 +64,23 @@ package body System.File_IO is\n    type Temp_File_Record_Ptr is access all Temp_File_Record;\n \n    type Temp_File_Record is record\n+      File : AFCB_Ptr;\n       Name : String (1 .. max_path_len + 1);\n-      Next : Temp_File_Record_Ptr;\n+      Next : aliased Temp_File_Record_Ptr;\n    end record;\n    --  One of these is allocated for each temporary file created\n \n-   Temp_Files : Temp_File_Record_Ptr;\n+   Temp_Files : aliased Temp_File_Record_Ptr;\n    --  Points to list of names of temporary files. Note that this global\n    --  variable must be properly protected to provide thread safety.\n \n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Temp_File_Record, Temp_File_Record_Ptr);\n+\n    type File_IO_Clean_Up_Type is new Limited_Controlled with null record;\n    --  The closing of all open files and deletion of temporary files is an\n    --  action that takes place at the end of execution of the main program.\n-   --  This action is implemented using a library level object which gets\n+   --  This action is implemented using a library level object that gets\n    --  finalized at the end of program execution. Note that the type is\n    --  limited, in order to stop the compiler optimizing away the declaration\n    --  which would be allowed in the non-limited case.\n@@ -221,7 +225,8 @@ package body System.File_IO is\n       File : AFCB_Ptr renames File_Ptr.all;\n \n    begin\n-      --  Take a task lock, to protect the global data value Open_Files\n+      --  Take a task lock, to protect the global variables Open_Files and\n+      --  Temp_Files, and the chains they point to.\n \n       SSL.Lock_Task.all;\n \n@@ -279,6 +284,32 @@ package body System.File_IO is\n          File.Next.Prev := File.Prev;\n       end if;\n \n+      --  If it's a temp file, remove the corresponding record from Temp_Files,\n+      --  and delete the file. There are unlikely to be large numbers of temp\n+      --  files open, so a linear search is sufficiently efficient. Note that\n+      --  we don't need to check for end of list, because the file must be\n+      --  somewhere on the list. Note that as for Finalize, we ignore any\n+      --  errors while attempting the unlink operation.\n+\n+      if File.Is_Temporary_File then\n+         declare\n+            Temp : access Temp_File_Record_Ptr := Temp_Files'Access;\n+            --  Note the double indirection here\n+\n+            New_Temp : Temp_File_Record_Ptr;\n+            Discard : int;\n+         begin\n+            while Temp.all.all.File /= File loop\n+               Temp := Temp.all.all.Next'Access;\n+            end loop;\n+\n+            Discard := unlink (Temp.all.all.Name'Address);\n+            New_Temp := Temp.all.all.Next;\n+            Free (Temp.all);\n+            Temp.all := New_Temp;\n+         end;\n+      end if;\n+\n       --  Deallocate some parts of the file structure that were kept in heap\n       --  storage with the exception of system files (standard input, output\n       --  and error) since they had some information allocated in the stack.\n@@ -319,16 +350,20 @@ package body System.File_IO is\n \n       declare\n          Filename : aliased constant String := File.Name.all;\n+         Is_Temporary_File : constant Boolean := File.Is_Temporary_File;\n \n       begin\n          Close (File_Ptr);\n \n          --  Now unlink the external file. Note that we use the full name in\n          --  this unlink, because the working directory may have changed since\n-         --  we did the open, and we want to unlink the right file.\n+         --  we did the open, and we want to unlink the right file. However, if\n+         --  it's a temporary file, then closing it already unlinked it.\n \n-         if unlink (Filename'Address) = -1 then\n-            raise Use_Error with OS_Lib.Errno_Message;\n+         if not Is_Temporary_File then\n+            if unlink (Filename'Address) = -1 then\n+               raise Use_Error with OS_Lib.Errno_Message;\n+            end if;\n          end if;\n       end;\n    end Delete;\n@@ -386,7 +421,7 @@ package body System.File_IO is\n       SSL.Lock_Task.all;\n \n       --  First close all open files (the slightly complex form of this loop is\n-      --  required because Close as a side effect nulls out its argument).\n+      --  required because Close nulls out its argument).\n \n       Fptr1 := Open_Files;\n       while Fptr1 /= null loop\n@@ -766,8 +801,9 @@ package body System.File_IO is\n \n       Text_Encoding : Content_Encoding;\n \n-      Tempfile : constant Boolean := (Name'Length = 0);\n-      --  Indicates temporary file case\n+      Tempfile : constant Boolean := Name = \"\";\n+      --  Indicates temporary file case, which is indicated by an empty file\n+      --  name.\n \n       Namelen : constant Integer := max_path_len;\n       --  Length required for file name, not including final ASCII.NUL.\n@@ -936,21 +972,7 @@ package body System.File_IO is\n                raise Use_Error with \"invalid temp file name\";\n             end if;\n \n-            --  Chain to temp file list, ensuring thread safety with a lock\n-\n-            begin\n-               SSL.Lock_Task.all;\n-               Temp_Files :=\n-                 new Temp_File_Record'(Name => Namestr, Next => Temp_Files);\n-               SSL.Unlock_Task.all;\n-\n-            exception\n-               when others =>\n-                  SSL.Unlock_Task.all;\n-                  raise;\n-            end;\n-\n-         --  Normal case of non-null name given\n+         --  Normal case of non-empty name given (i.e. not a temp file)\n \n          else\n             if Name'Length > Namelen then\n@@ -1024,6 +1046,7 @@ package body System.File_IO is\n                         Stream := P.Stream;\n \n                         Record_AFCB;\n+                        pragma Assert (not Tempfile);\n \n                         exit;\n \n@@ -1124,6 +1147,23 @@ package body System.File_IO is\n       --  heap and fill in its fields.\n \n       Record_AFCB;\n+\n+      if Tempfile then\n+         --  Chain to temp file list, ensuring thread safety with a lock\n+\n+         begin\n+            SSL.Lock_Task.all;\n+            Temp_Files :=\n+              new Temp_File_Record'\n+                (File => File_Ptr, Name => Namestr, Next => Temp_Files);\n+            SSL.Unlock_Task.all;\n+\n+         exception\n+            when others =>\n+               SSL.Unlock_Task.all;\n+               raise;\n+         end;\n+      end if;\n    end Open;\n \n    ------------------------"}, {"sha": "f727c7a232b114597ec2efa015ae4ac4765c5338", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94295b259310bb5a7a156f799cfc84e0eebbccdc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=94295b259310bb5a7a156f799cfc84e0eebbccdc", "patch": "@@ -4243,35 +4243,34 @@ package body Sem_Prag is\n                Prev := Overridden_Operation (Prev);\n             end loop;\n \n-            --  If the controlling type of the subprogram has progenitors,\n-            --  an interface operation implemented by the current operation\n-            --  may have a class-wide precondition.\n+            --  If the controlling type of the subprogram has progenitors, an\n+            --  interface operation implemented by the current operation may\n+            --  have a class-wide precondition.\n \n             Typ := Find_Dispatching_Type (E);\n             if Has_Interfaces (Typ) then\n                declare\n-                  Ints      : Elist_Id;\n                   Elmt      : Elmt_Id;\n-                  Prim_List : Elist_Id;\n-                  Prim_Elmt : Elmt_Id;\n+                  Ints      : Elist_Id;\n                   Prim      : Entity_Id;\n+                  Prim_Elmt : Elmt_Id;\n+                  Prim_List : Elist_Id;\n+\n                begin\n                   Collect_Interfaces (Typ, Ints);\n                   Elmt := First_Elmt (Ints);\n \n-                  --  Iterate over the primitive operations of each\n-                  --  interface.\n+                  --  Iterate over the primitive operations of each interface\n \n                   while Present (Elmt) loop\n-                     Prim_List :=\n-                      (Direct_Primitive_Operations (Node (Elmt)));\n+                     Prim_List := Direct_Primitive_Operations (Node (Elmt));\n                      Prim_Elmt := First_Elmt (Prim_List);\n                      while Present (Prim_Elmt) loop\n                         Prim := Node (Prim_Elmt);\n                         if Chars (Prim) = Chars (E)\n                           and then Present (Contract (Prim))\n                           and then Class_Present\n-                            (Pre_Post_Conditions (Contract (Prim)))\n+                                     (Pre_Post_Conditions (Contract (Prim)))\n                         then\n                            return True;\n                         end if;\n@@ -4287,6 +4286,8 @@ package body Sem_Prag is\n             return False;\n          end Inherits_Class_Wide_Pre;\n \n+      --  Start of processing for Analyze_Pre_Post_Condition\n+\n       begin\n          --  Change the name of pragmas Pre, Pre_Class, Post and Post_Class to\n          --  offer uniformity among the various kinds of pre/postconditions by\n@@ -4422,11 +4423,11 @@ package body Sem_Prag is\n                  and then not Inherits_Class_Wide_Pre (E)\n                then\n                   Error_Msg_N\n-                    (\"illegal class-wide precondition on overriding \"\n-                      & \"operation\", Corresponding_Aspect (N));\n+                    (\"illegal class-wide precondition on overriding operation\",\n+                     Corresponding_Aspect (N));\n \n                --  If the operation is declared in the private part of an\n-               --  instance it may not override any visible operations,  but\n+               --  instance it may not override any visible operations, but\n                --  still have a parent operation that carries a precondition.\n \n                elsif In_Instance\n@@ -4439,7 +4440,7 @@ package body Sem_Prag is\n                then\n                   Error_Msg_N\n                     (\"illegal class-wide precondition on overriding \"\n-                      & \"operation in instance\", Corresponding_Aspect (N));\n+                     & \"operation in instance\", Corresponding_Aspect (N));\n                end if;\n             end;\n "}]}