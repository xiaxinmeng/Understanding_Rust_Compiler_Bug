{"sha": "5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "node_id": "C_kwDOANBUbNoAKDViYzRjYjA0MTI3YTQ4MDViNjIyOGIwYTZjYmZlYmRiZDYxMzE0ZDI", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-11-25T16:58:12Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-11-25T17:16:31Z"}, "message": "ipa: Teach IPA-CP transformation about IPA-SRA modifications (PR 103227)\n\nPR 103227 exposed an issue with ordering of transformations of IPA\npasses.  IPA-CP can create clones for constants passed by reference\nand at the same time IPA-SRA can also decide that the parameter does\nnot need to be a pointer (or an aggregate) and plan to convert it\ninto (a) simple scalar(s).  Because no intermediate clone is created\njust for the purpose of ordering the transformations and because\nIPA-SRA transformation is implemented as part of clone\nmaterialization, the IPA-CP transformation happens only afterwards,\nreversing the order of the transformations compared to the ordering of\nanalyses.\n\nIPA-CP transformation looks at planned substitutions for values passed\nby reference or in aggregates but finds that all the relevant\nparameters no longer exist.  Currently it subsequently simply gives\nup, leading to clones created for no good purpose (and huge regression\nof 548.exchange_r.  This patch teaches it recognize the situation,\nlook up the new scalarized parameter and perform value substitution on\nit.  On my desktop this has recovered the lost exchange2 run-time (and\nsome more).\n\nI have disabled IPA-SRA in a Fortran testcase so that the dumping from\nthe transformation phase can still be matched in order to verify that\nIPA-CP understands the IL after verifying that it does the right thing\nalso with IPA-SRA.\n\ngcc/ChangeLog:\n\n2021-11-23  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\t* ipa-prop.h (ipa_get_param): New overload.  Move bits of the existing\n\tone to the new one.\n\t* ipa-param-manipulation.h (ipa_param_adjustments): New member\n\tfunction get_updated_index_or_split.\n\t* ipa-param-manipulation.c\n\t(ipa_param_adjustments::get_updated_index_or_split): New function.\n\t* ipa-prop.c (adjust_agg_replacement_values): Reimplement, add\n\tcapability to identify scalarized parameters and perform substitution\n\ton them.\n\t(ipcp_transform_function): Create descriptors earlier, handle new\n\treturn values of adjust_agg_replacement_values.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-23  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\t* gcc.dg/ipa/pr103227-1.c: New test.\n\t* gcc.dg/ipa/pr103227-3.c: Likewise.\n\t* gcc.dg/ipa/pr103227-2.c: Likewise.\n\t* gfortran.dg/pr53787.f90: Disable IPA-SRA.", "tree": {"sha": "cd461b42f093859855f48562fd4279d11ace9bc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd461b42f093859855f48562fd4279d11ace9bc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmGfxO8ACgkQv2PBvD+k\nNUBJxQ/9EGyAm8Cudf6iNswMrUhnOQ4oe2qP8iqMHpKvtmP/tdk1YX8xQ6/4Uu3C\nb1Oy+bLGAiPX9R1CEhJqGGIp8LniYyEN4EmELqAhrMtqxuDIt5vmwx4PxT+DJRng\nawIfgaa/JWz97gd3LLrRbKjtenr+9cbNLLZ1t8mI7LdiDBKKRxmD3g3r0SXsayMZ\ntssRe8SCnmAwWi/+q4lCFjinx+4Rdp5ARtjBDmf8wtFXS6LglQvcIzkl6dzRJypI\nbCEp4J7ePCD3WVdxTw06xuSmIxmsqNBZ5X7JRrPFkSC2urTkbqmTXlM0EeSymkga\nu3jy5ZqnjwEqNf5ueaWY4iriQX6dZV1z7H4YdtVQNg+Y1BNujvgYJ1vlTJzhLFVG\nODEdfXLKIPa/WBXp3FMkAyRbBynFG5HXGPyYhvQ7xcvSIB5/WGss7Q1diTDc4bfB\nsgK2wK5W7FyAxFPIfy3gXAtaojNNepjaERCEdXkjDZwZG9yzpXc5w6L1YTgGuLgj\nJ7nK0AUFRfxB5wXqKezYVhACsj7Whyc+gFeYX5uGlr+9G1jj3rE6lfduoU9TsPJc\nnKwbJd+l0loVop/ZuOkWuTWZFGRtknU/QPUct/IpTuCWgCgTRCEbTm3BYuBnMkKS\nlhEe9trh7bAr0NWl20LCmU3dSZshBavm4d6vyLn2qchkU7op5RY=\n=EDYG\n-----END PGP SIGNATURE-----", "payload": "tree cd461b42f093859855f48562fd4279d11ace9bc4\nparent 415f9ee404dc9e8ae1cade160a33400b10abb18a\nauthor Martin Jambor <mjambor@suse.cz> 1637859492 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1637860591 +0100\n\nipa: Teach IPA-CP transformation about IPA-SRA modifications (PR 103227)\n\nPR 103227 exposed an issue with ordering of transformations of IPA\npasses.  IPA-CP can create clones for constants passed by reference\nand at the same time IPA-SRA can also decide that the parameter does\nnot need to be a pointer (or an aggregate) and plan to convert it\ninto (a) simple scalar(s).  Because no intermediate clone is created\njust for the purpose of ordering the transformations and because\nIPA-SRA transformation is implemented as part of clone\nmaterialization, the IPA-CP transformation happens only afterwards,\nreversing the order of the transformations compared to the ordering of\nanalyses.\n\nIPA-CP transformation looks at planned substitutions for values passed\nby reference or in aggregates but finds that all the relevant\nparameters no longer exist.  Currently it subsequently simply gives\nup, leading to clones created for no good purpose (and huge regression\nof 548.exchange_r.  This patch teaches it recognize the situation,\nlook up the new scalarized parameter and perform value substitution on\nit.  On my desktop this has recovered the lost exchange2 run-time (and\nsome more).\n\nI have disabled IPA-SRA in a Fortran testcase so that the dumping from\nthe transformation phase can still be matched in order to verify that\nIPA-CP understands the IL after verifying that it does the right thing\nalso with IPA-SRA.\n\ngcc/ChangeLog:\n\n2021-11-23  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\t* ipa-prop.h (ipa_get_param): New overload.  Move bits of the existing\n\tone to the new one.\n\t* ipa-param-manipulation.h (ipa_param_adjustments): New member\n\tfunction get_updated_index_or_split.\n\t* ipa-param-manipulation.c\n\t(ipa_param_adjustments::get_updated_index_or_split): New function.\n\t* ipa-prop.c (adjust_agg_replacement_values): Reimplement, add\n\tcapability to identify scalarized parameters and perform substitution\n\ton them.\n\t(ipcp_transform_function): Create descriptors earlier, handle new\n\treturn values of adjust_agg_replacement_values.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-23  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103227\n\t* gcc.dg/ipa/pr103227-1.c: New test.\n\t* gcc.dg/ipa/pr103227-3.c: Likewise.\n\t* gcc.dg/ipa/pr103227-2.c: Likewise.\n\t* gfortran.dg/pr53787.f90: Disable IPA-SRA.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "415f9ee404dc9e8ae1cade160a33400b10abb18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415f9ee404dc9e8ae1cade160a33400b10abb18a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415f9ee404dc9e8ae1cade160a33400b10abb18a"}], "stats": {"total": 240, "additions": 216, "deletions": 24}, "files": [{"sha": "479c20b3871e71cf6310266d77efbc245d0ba93d", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -449,6 +449,39 @@ ipa_param_adjustments::get_updated_indices (vec<int> *new_indices)\n     }\n }\n \n+/* If a parameter with original INDEX has survived intact, return its new\n+   index.  Otherwise return -1.  In that case, if it has been split and there\n+   is a new parameter representing a portion at unit OFFSET for which a value\n+   of a TYPE can be substituted, store its new index into SPLIT_INDEX,\n+   otherwise store -1 there.  */\n+int\n+ipa_param_adjustments::get_updated_index_or_split (int index,\n+\t\t\t\t\t\t   unsigned unit_offset,\n+\t\t\t\t\t\t   tree type, int *split_index)\n+{\n+  unsigned adj_len = vec_safe_length (m_adj_params);\n+  for (unsigned i = 0; i < adj_len ; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n+      if (apm->base_index != index)\n+\tcontinue;\n+      if (apm->op == IPA_PARAM_OP_COPY)\n+\treturn i;\n+      if (apm->op == IPA_PARAM_OP_SPLIT\n+\t  && apm->unit_offset == unit_offset)\n+\t{\n+\t  if (useless_type_conversion_p (apm->type, type))\n+\t    *split_index = i;\n+\t  else\n+\t    *split_index = -1;\n+\t  return -1;\n+\t}\n+    }\n+\n+  *split_index = -1;\n+  return -1;\n+}\n+\n /* Return the original index for the given new parameter index.  Return a\n    negative number if not available.  */\n "}, {"sha": "d1dad9fac736358a9b5082faac2804c030268810", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -236,6 +236,13 @@ class GTY(()) ipa_param_adjustments\n   void get_surviving_params (vec<bool> *surviving_params);\n   /* Fill a vector with new indices of surviving original parameters.  */\n   void get_updated_indices (vec<int> *new_indices);\n+  /* If a parameter with original INDEX has survived intact, return its new\n+     index.  Otherwise return -1.  In that case, if it has been split and there\n+     is a new parameter representing a portion at UNIT_OFFSET for which a value\n+     of a TYPE can be substituted, store its new index into SPLIT_INDEX,\n+     otherwise store -1 there.  */\n+  int get_updated_index_or_split (int index, unsigned unit_offset, tree type,\n+\t\t\t\t  int *split_index);\n   /* Return the original index for the given new parameter index.  Return a\n      negative number if not available.  */\n   int get_original_index (int newidx);"}, {"sha": "a297f50e9450a743f5c97a89b1f5df000f1a5731", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 53, "deletions": 20, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -5578,32 +5578,55 @@ ipcp_read_transformation_summaries (void)\n }\n \n /* Adjust the aggregate replacements in AGGVAL to reflect parameters skipped in\n-   NODE.  */\n+   NODE but also if any parameter was IPA-SRAed into a scalar go ahead with\n+   substitution of the default_definitions of that new param with the\n+   appropriate constant.\n \n-static void\n-adjust_agg_replacement_values (struct cgraph_node *node,\n-\t\t\t       struct ipa_agg_replacement_value *aggval)\n+   Return two bools.  the first it true if at least one item in AGGVAL still\n+   exists and function body walk should go ahead.  The second is true if any\n+   values were already substituted for scalarized parameters and update_cfg\n+   shuld be run after replace_uses_by.  */\n+\n+static std::pair<bool, bool>\n+adjust_agg_replacement_values (cgraph_node *node,\n+\t\t\t       ipa_agg_replacement_value *aggval,\n+\t\t\t       const vec<ipa_param_descriptor, va_gc>\n+\t\t\t         &descriptors)\n {\n   struct ipa_agg_replacement_value *v;\n   clone_info *cinfo = clone_info::get (node);\n-\n   if (!cinfo || !cinfo->param_adjustments)\n-    return;\n+    return std::pair<bool, bool> (true, false);\n \n-  auto_vec<int, 16> new_indices;\n-  cinfo->param_adjustments->get_updated_indices (&new_indices);\n+  bool anything_left = false;\n+  bool done_replacement = false;\n   for (v = aggval; v; v = v->next)\n     {\n       gcc_checking_assert (v->index >= 0);\n \n-      if ((unsigned) v->index < new_indices.length ())\n-\tv->index = new_indices[v->index];\n-      else\n-\t/* This can happen if we know about a constant passed by reference by\n-\t   an argument which is never actually used for anything, let alone\n-\t   loading that constant.  */\n-\tv->index = -1;\n+      unsigned unit_offset = v->offset / BITS_PER_UNIT;\n+      tree cst_type = TREE_TYPE (v->value);\n+      int split_idx;\n+      int new_idx\n+\t= cinfo->param_adjustments->get_updated_index_or_split (v->index,\n+\t\t\t\t\t\t\t\tunit_offset,\n+\t\t\t\t\t\t\t\tcst_type,\n+\t\t\t\t\t\t\t\t&split_idx);\n+      v->index = new_idx;\n+      if (new_idx >= 0)\n+\tanything_left = true;\n+      else if (split_idx >= 0)\n+\t{\n+\t  tree parm = ipa_get_param (descriptors, split_idx);\n+\t  tree ddef = ssa_default_def (cfun, parm);\n+\t  if (ddef)\n+\t    {\n+\t      replace_uses_by (ddef, v->value);\n+\t      done_replacement = true;\n+\t    }\n+\t}\n     }\n+   return std::pair<bool, bool> (anything_left, done_replacement);\n }\n \n /* Dominator walker driving the ipcp modification phase.  */\n@@ -5995,7 +6018,19 @@ ipcp_transform_function (struct cgraph_node *node)\n   param_count = count_formal_params (node->decl);\n   if (param_count == 0)\n     return 0;\n-  adjust_agg_replacement_values (node, aggval);\n+  vec_safe_grow_cleared (descriptors, param_count, true);\n+  ipa_populate_param_decls (node, *descriptors);\n+  std::pair<bool, bool> rr\n+    = adjust_agg_replacement_values (node, aggval, *descriptors);\n+  int retval = rr.second ? TODO_cleanup_cfg : 0;\n+  if (!rr.first)\n+    {\n+      vec_free (descriptors);\n+      if (dump_file)\n+\tfprintf (dump_file, \"  All affected aggregate parameters were either \"\n+\t\t \"removed or converted into scalars, phase done.\\n\");\n+      return retval;\n+    }\n   if (dump_file)\n     ipa_dump_agg_replacement_values (dump_file, aggval);\n \n@@ -6006,8 +6041,6 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.param_count = param_count;\n   fbi.aa_walk_budget = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \n-  vec_safe_grow_cleared (descriptors, param_count, true);\n-  ipa_populate_param_decls (node, *descriptors);\n   calculate_dominance_info (CDI_DOMINATORS);\n   ipcp_modif_dom_walker walker (&fbi, descriptors, aggval, &something_changed);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n@@ -6028,12 +6061,12 @@ ipcp_transform_function (struct cgraph_node *node)\n   vec_free (descriptors);\n \n   if (!something_changed)\n-    return 0;\n+    return retval;\n \n   if (cfg_changed)\n     delete_unreachable_blocks_update_callgraph (node, false);\n \n-  return TODO_update_ssa_only_virtuals;\n+  return retval | TODO_update_ssa_only_virtuals;\n }\n \n "}, {"sha": "ba49843a510f46778d89634be4026ec61c899aad", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -700,6 +700,17 @@ ipa_get_param_count (class ipa_node_params *info)\n   return vec_safe_length (info->descriptors);\n }\n \n+/* Return the parameter declaration in DESCRIPTORS at index I and assert it is\n+   indeed a PARM_DECL.  */\n+\n+static inline tree\n+ipa_get_param (const vec<ipa_param_descriptor, va_gc> &descriptors, int i)\n+{\n+  tree t = descriptors[i].decl_or_type;\n+  gcc_checking_assert (TREE_CODE (t) == PARM_DECL);\n+  return t;\n+}\n+\n /* Return the declaration of Ith formal parameter of the function corresponding\n    to INFO.  Note there is no setter function as this array is built just once\n    using ipa_initialize_node_params.  This function should not be called in\n@@ -709,9 +720,7 @@ static inline tree\n ipa_get_param (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n-  tree t = (*info->descriptors)[i].decl_or_type;\n-  gcc_checking_assert (TREE_CODE (t) == PARM_DECL);\n-  return t;\n+  return ipa_get_param (*info->descriptors, i);\n }\n \n /* Return the type of Ith formal parameter of the function corresponding"}, {"sha": "0f56eb12179100b402d9c57dfb1533cf9e080f92", "filename": "gcc/testsuite/gcc.dg/ipa/pr103227-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-1.c?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized-slim\"  } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+int ellide (int c);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  int c = p->c;\n+  if (c != 21)\n+    ellide (c);\n+}\n+\n+void\n+entry (void)\n+{\n+  struct S s;\n+  s.a = 1;\n+  s.b = 64;\n+  s.c = 21;\n+  foo (&s);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"ellide\" \"optimized\" } } */"}, {"sha": "e4f3c71533151a81b978f9e66f86f5d7728bf20d", "filename": "gcc/testsuite/gcc.dg/ipa/pr103227-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-2.c?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized-slim\"  } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+int ellide (int c);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S s)\n+{\n+  int c = s.c;\n+  if (c != 21)\n+    ellide (c);\n+}\n+\n+void\n+entry (void)\n+{\n+  struct S s;\n+  s.a = 1;\n+  s.b = 64;\n+  s.c = 21;\n+  foo (s);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"ellide\" \"optimized\" } } */"}, {"sha": "a48026d1b9589105128ad9acc32795a283db0a4d", "filename": "gcc/testsuite/gcc.dg/ipa/pr103227-3.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103227-3.c?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-fre -fno-tree-sra -fdump-tree-optimized-slim\"  } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+volatile int z1;\n+int z2 = 44;\n+\n+void  __attribute__((noipa))\n+use_int (int c)\n+{\n+  z1 = c;\n+}\n+\n+static void __attribute__ ((noinline))\n+bar (struct S s)\n+{\n+  use_int (s.c);\n+}\n+\n+\n+static void __attribute__ ((noinline))\n+foo (struct S s)\n+{\n+  int c = s.c;\n+  if (c != 21)\n+    use_int (c);\n+\n+  s.c = z2;\n+  bar (s);\n+  if (s.c != 44)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  struct S s;\n+  s.a = 1;\n+  s.b = 64;\n+  s.c = 21;\n+  foo (s);\n+  return 0;\n+}\n+\n+\n+\n+\n+/* { dg-final { scan-tree-dump-not \"ellide\" \"optimized\" } } */"}, {"sha": "412bbc7d7b019181221b3f4feb6cff16bbc00319", "filename": "gcc/testsuite/gfortran.dg/pr53787.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr53787.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr53787.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr53787.f90?ref=5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline -fwhole-program\" }\n+! { dg-options \"-O3 -fdump-ipa-cp-details -fno-ipa-sra -fno-inline -fwhole-program\" }\n \n   real x(10)\n   n = 10"}]}