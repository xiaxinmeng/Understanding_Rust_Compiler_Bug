{"sha": "fafa0521c924a5627daa0b63b538c32dca4b2dce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmYTA1MjFjOTI0YTU2MjdkYWEwYjYzYjUzOGMzMmRjYTRiMmRjZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-30T08:14:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-30T08:14:37Z"}, "message": "class.c (build_vtbl_initializer): Make __cxa_deleted_virtual ECF_NORETURN | ECF_LEAF\n\n\t* class.c (build_vtbl_initializer): Make __cxa_deleted_virtual\n\tECF_NORETURN | ECF_LEAF\n\t* cp-tree.h (build_library_fn_ptr, build_cp_library_fn_ptr,\n\tpush_library_fn, push_void_library_fn): Update prototype.\n\t* decl.c (build_library_fn_1): Remove.\n\t(push_cp_library_fn, build_cp_library_fn): Update to take ECF flags.\n\t(cxx_init_decl_processing): Update; global_delete_fndecl is ECF_NOTROW;\n\t__cxa_pure_virtual is ECF_NORETURN | ECF_NORETURN | ECF_LEAF.\n\t(build_library_fn_1): Add ecf_flags argument; rename to ...\n\t(build_library_fn): ... this one.\n\t(build_cp_library_fn): Take ecf_flags; do not copy NOTHROW flag.\n\t(build_library_fn_ptr): Take ecf_flags.\n\t(build_cp_library_fn_ptr): Likewise.\n\t(push_library_fn): Likewise.\n\t(push_cp_library_fn): Likewise.\n\t(push_void_library_fn): Likewise.\n\t(push_throw_library_fn): All throws are ECF_NORETURN.\n\t(__cxa_atexit, __cxa_thread_atexit): Add ECF_LEAF | ECF_NOTHROW attributes.\n\t(expand_static_init): __cxa_guard_acquire, __cxa_guard_release,\n\t__cxa_guard_abort are ECF_NOTHROW | ECF_LEAF.\n\t* except.c (init_exception_processing): terminate is\n\tECF_NOTHROW | ECF_NORETURN | ECF_LEAF.\n\t(declare_nothrow_library_fn): Add ecf_flags parameter.\n\t(__cxa_get_exception_ptr): Is ECF_NOTHROW | ECF_PURE | ECF_LEAF |\n\tECF_TM_PURE.\n\t(do_begin_catch): cxa_begin_catch and _ITM_cxa_begin_catch\n\tare ECF_NOTHROW | ECF_LEAF.\n\t(do_end_catch): __cxa_end_catch and _ITM_cxa_end_catch is\n\tECF_LEAF.\n\t(do_allocate_exception): _cxa_allocate_exception\n\tand _ITM_cxa_allocate_exception are ECF_NOTHROW | ECF_MALLOC\n\t| ECF_LEAF\n\t(do_free_exception): __cxa_free_exception is\n\tECF_NOTHROW | ECF_LEAF.\n\t* rtti.c (build_dynamic_cast_1): __dynamic_cast\n\tis ECF_LEAF | ECF_PURE | ECF_NOTHROW.\n\nFrom-SVN: r202099", "tree": {"sha": "613c30eed695568dc01f4f4b5dea6fa1f78649f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/613c30eed695568dc01f4f4b5dea6fa1f78649f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fafa0521c924a5627daa0b63b538c32dca4b2dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fafa0521c924a5627daa0b63b538c32dca4b2dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fafa0521c924a5627daa0b63b538c32dca4b2dce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fafa0521c924a5627daa0b63b538c32dca4b2dce/comments", "author": null, "committer": null, "parents": [{"sha": "47500756e5b5f8469ae0a323f03b613ac50e0bdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47500756e5b5f8469ae0a323f03b613ac50e0bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47500756e5b5f8469ae0a323f03b613ac50e0bdc"}], "stats": {"total": 181, "additions": 107, "deletions": 74}, "files": [{"sha": "2b2f45aab007d7ba831d520b9d07866903948c4a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fafa0521c924a5627daa0b63b538c32dca4b2dce", "patch": "@@ -1,3 +1,42 @@\n+2013-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* class.c (build_vtbl_initializer): Make __cxa_deleted_virtual\n+\tECF_NORETURN | ECF_LEAF\n+\t* cp-tree.h (build_library_fn_ptr, build_cp_library_fn_ptr,\n+\tpush_library_fn, push_void_library_fn): Update prototype.\n+\t* decl.c (build_library_fn_1): Remove.\n+\t(push_cp_library_fn, build_cp_library_fn): Update to take ECF flags.\n+\t(cxx_init_decl_processing): Update; global_delete_fndecl is ECF_NOTROW;\n+\t__cxa_pure_virtual is ECF_NORETURN | ECF_NORETURN | ECF_LEAF.\n+\t(build_library_fn_1): Add ecf_flags argument; rename to ...\n+\t(build_library_fn): ... this one.\n+\t(build_cp_library_fn): Take ecf_flags; do not copy NOTHROW flag.\n+\t(build_library_fn_ptr): Take ecf_flags.\n+\t(build_cp_library_fn_ptr): Likewise.\n+\t(push_library_fn): Likewise.\n+\t(push_cp_library_fn): Likewise.\n+\t(push_void_library_fn): Likewise.\n+\t(push_throw_library_fn): All throws are ECF_NORETURN.\n+\t(__cxa_atexit, __cxa_thread_atexit): Add ECF_LEAF | ECF_NOTHROW attributes.\n+\t(expand_static_init): __cxa_guard_acquire, __cxa_guard_release,\n+\t__cxa_guard_abort are ECF_NOTHROW | ECF_LEAF.\n+\t* except.c (init_exception_processing): terminate is\n+\tECF_NOTHROW | ECF_NORETURN | ECF_LEAF.\n+\t(declare_nothrow_library_fn): Add ecf_flags parameter.\n+\t(__cxa_get_exception_ptr): Is ECF_NOTHROW | ECF_PURE | ECF_LEAF |\n+\tECF_TM_PURE.\n+\t(do_begin_catch): cxa_begin_catch and _ITM_cxa_begin_catch\n+\tare ECF_NOTHROW | ECF_LEAF.\n+\t(do_end_catch): __cxa_end_catch and _ITM_cxa_end_catch is\n+\tECF_LEAF.\n+\t(do_allocate_exception): _cxa_allocate_exception\n+\tand _ITM_cxa_allocate_exception are ECF_NOTHROW | ECF_MALLOC\n+\t| ECF_LEAF\n+\t(do_free_exception): __cxa_free_exception is\n+\tECF_NOTHROW | ECF_LEAF.\n+\t* rtti.c (build_dynamic_cast_1): __dynamic_cast\n+\tis ECF_LEAF | ECF_PURE | ECF_NOTHROW.\n+\n 2013-08-29  Adam Butcher  <adam@jessamine.co.uk>\n \n \t* error.c (dump_lambda_function): New function, dependent on ..."}, {"sha": "3f77d22fcc9653daef7c2972e88fb2e902d6d146", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fafa0521c924a5627daa0b63b538c32dca4b2dce", "patch": "@@ -8873,7 +8873,7 @@ build_vtbl_initializer (tree binfo,\n \t      if (!get_global_value_if_present (fn, &fn))\n \t\tfn = push_library_fn (fn, (build_function_type_list\n \t\t\t\t\t   (void_type_node, NULL_TREE)),\n-\t\t\t\t      NULL_TREE);\n+\t\t\t\t      NULL_TREE, ECF_NORETURN | ECF_LEAF);\n \t      if (!TARGET_VTABLE_USES_DESCRIPTORS)\n \t\tinit = fold_convert (vfunc_ptr_type_node,\n \t\t\t\t     build_fold_addr_expr (fn));"}, {"sha": "73f6a6ad43b227f66f059256d2aa770bd61ef0ea", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fafa0521c924a5627daa0b63b538c32dca4b2dce", "patch": "@@ -5170,10 +5170,10 @@ extern void check_goto\t\t\t\t(tree);\n extern bool check_omp_return\t\t\t(void);\n extern tree make_typename_type\t\t\t(tree, tree, enum tag_types, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tree, tsubst_flags_t);\n-extern tree build_library_fn_ptr\t\t(const char *, tree);\n-extern tree build_cp_library_fn_ptr\t\t(const char *, tree);\n-extern tree push_library_fn\t\t\t(tree, tree, tree);\n-extern tree push_void_library_fn\t\t(tree, tree);\n+extern tree build_library_fn_ptr\t\t(const char *, tree, int);\n+extern tree build_cp_library_fn_ptr\t\t(const char *, tree, int);\n+extern tree push_library_fn\t\t\t(tree, tree, tree, int);\n+extern tree push_void_library_fn\t\t(tree, tree, int);\n extern tree push_throw_library_fn\t\t(tree, tree);\n extern void warn_misplaced_attr_for_class_type  (source_location location,\n \t\t\t\t\t\t tree class_type);"}, {"sha": "bead6e84183d7cc026f974fc9ad0753a22fcf461", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fafa0521c924a5627daa0b63b538c32dca4b2dce", "patch": "@@ -75,7 +75,6 @@ static tree grokvardecl (tree, tree, const cp_decl_specifier_seq *,\n static int check_static_variable_definition (tree, tree);\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (tree, tree, bool);\n-static tree build_library_fn_1 (tree, enum tree_code, tree);\n static int member_function_or_else (tree, tree, enum overload_flags);\n static void bad_specifiers (tree, enum bad_spec_place, int, int, int, int,\n \t\t\t    int);\n@@ -107,8 +106,8 @@ static tree cp_make_fname_decl (location_t, tree, int);\n static void initialize_predefined_identifiers (void);\n static tree check_special_function_return_type\n \t(special_function_kind, tree, tree);\n-static tree push_cp_library_fn (enum tree_code, tree);\n-static tree build_cp_library_fn (tree, enum tree_code, tree);\n+static tree push_cp_library_fn (enum tree_code, tree, int);\n+static tree build_cp_library_fn (tree, enum tree_code, tree, int);\n static void store_parm_decls (tree);\n static void initialize_local_var (tree, tree);\n static void expand_static_init (tree, tree);\n@@ -3800,10 +3799,10 @@ cxx_init_decl_processing (void)\n     newtype = build_exception_variant (newtype, new_eh_spec);\n     deltype = cp_build_type_attribute_variant (void_ftype_ptr, extvisattr);\n     deltype = build_exception_variant (deltype, empty_except_spec);\n-    push_cp_library_fn (NEW_EXPR, newtype);\n-    push_cp_library_fn (VEC_NEW_EXPR, newtype);\n-    global_delete_fndecl = push_cp_library_fn (DELETE_EXPR, deltype);\n-    push_cp_library_fn (VEC_DELETE_EXPR, deltype);\n+    push_cp_library_fn (NEW_EXPR, newtype, 0);\n+    push_cp_library_fn (VEC_NEW_EXPR, newtype, 0);\n+    global_delete_fndecl = push_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);\n+    push_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);\n \n     nullptr_type_node = make_node (NULLPTR_TYPE);\n     TYPE_SIZE (nullptr_type_node) = bitsize_int (GET_MODE_BITSIZE (ptr_mode));\n@@ -3816,7 +3815,8 @@ cxx_init_decl_processing (void)\n   }\n \n   abort_fndecl\n-    = build_library_fn_ptr (\"__cxa_pure_virtual\", void_ftype);\n+    = build_library_fn_ptr (\"__cxa_pure_virtual\", void_ftype,\n+\t\t\t    ECF_NORETURN | ECF_NOTHROW | ECF_LEAF);\n \n   /* Perform other language dependent initializations.  */\n   init_class_processing ();\n@@ -4007,7 +4007,8 @@ cxx_builtin_function_ext_scope (tree decl)\n    function.  Not called directly.  */\n \n static tree\n-build_library_fn_1 (tree name, enum tree_code operator_code, tree type)\n+build_library_fn (tree name, enum tree_code operator_code, tree type,\n+\t\t  int ecf_flags)\n {\n   tree fn = build_lang_decl (FUNCTION_DECL, name, type);\n   DECL_EXTERNAL (fn) = 1;\n@@ -4019,28 +4020,17 @@ build_library_fn_1 (tree name, enum tree_code operator_code, tree type)\n      external shared object.  */\n   DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;\n   DECL_VISIBILITY_SPECIFIED (fn) = 1;\n-  return fn;\n-}\n-\n-/* Returns the _DECL for a library function with C linkage.\n-   We assume that such functions never throw; if this is incorrect,\n-   callers should unset TREE_NOTHROW.  */\n-\n-static tree\n-build_library_fn (tree name, tree type)\n-{\n-  tree fn = build_library_fn_1 (name, ERROR_MARK, type);\n-  TREE_NOTHROW (fn) = 1;\n+  set_call_expr_flags (fn, ecf_flags);\n   return fn;\n }\n \n /* Returns the _DECL for a library function with C++ linkage.  */\n \n static tree\n-build_cp_library_fn (tree name, enum tree_code operator_code, tree type)\n+build_cp_library_fn (tree name, enum tree_code operator_code, tree type,\n+\t\t     int ecf_flags)\n {\n-  tree fn = build_library_fn_1 (name, operator_code, type);\n-  TREE_NOTHROW (fn) = TYPE_NOTHROW_P (type);\n+  tree fn = build_library_fn (name, operator_code, type, ecf_flags);\n   DECL_CONTEXT (fn) = FROB_CONTEXT (current_namespace);\n   SET_DECL_LANGUAGE (fn, lang_cplusplus);\n   return fn;\n@@ -4050,33 +4040,34 @@ build_cp_library_fn (tree name, enum tree_code operator_code, tree type)\n    IDENTIFIER_NODE.  */\n \n tree\n-build_library_fn_ptr (const char* name, tree type)\n+build_library_fn_ptr (const char* name, tree type, int ecf_flags)\n {\n-  return build_library_fn (get_identifier (name), type);\n+  return build_library_fn (get_identifier (name), ERROR_MARK, type, ecf_flags);\n }\n \n /* Like build_cp_library_fn, but takes a C string instead of an\n    IDENTIFIER_NODE.  */\n \n tree\n-build_cp_library_fn_ptr (const char* name, tree type)\n+build_cp_library_fn_ptr (const char* name, tree type, int ecf_flags)\n {\n-  return build_cp_library_fn (get_identifier (name), ERROR_MARK, type);\n+  return build_cp_library_fn (get_identifier (name), ERROR_MARK, type,\n+\t\t\t      ecf_flags);\n }\n \n /* Like build_library_fn, but also pushes the function so that we will\n    be able to find it via IDENTIFIER_GLOBAL_VALUE.  Also, the function\n    may throw exceptions listed in RAISES.  */\n \n tree\n-push_library_fn (tree name, tree type, tree raises)\n+push_library_fn (tree name, tree type, tree raises, int ecf_flags)\n {\n   tree fn;\n \n   if (raises)\n     type = build_exception_variant (type, raises);\n \n-  fn = build_library_fn (name, type);\n+  fn = build_library_fn (name, ERROR_MARK, type, ecf_flags);\n   pushdecl_top_level (fn);\n   return fn;\n }\n@@ -4085,11 +4076,12 @@ push_library_fn (tree name, tree type, tree raises)\n    will be found by normal lookup.  */\n \n static tree\n-push_cp_library_fn (enum tree_code operator_code, tree type)\n+push_cp_library_fn (enum tree_code operator_code, tree type,\n+\t\t    int ecf_flags)\n {\n   tree fn = build_cp_library_fn (ansi_opname (operator_code),\n \t\t\t\t operator_code,\n-\t\t\t\t type);\n+\t\t\t\t type, ecf_flags);\n   pushdecl (fn);\n   if (flag_tm)\n     apply_tm_attr (fn, get_identifier (\"transaction_safe\"));\n@@ -4100,10 +4092,10 @@ push_cp_library_fn (enum tree_code operator_code, tree type)\n    a FUNCTION_TYPE.  */\n \n tree\n-push_void_library_fn (tree name, tree parmtypes)\n+push_void_library_fn (tree name, tree parmtypes, int ecf_flags)\n {\n   tree type = build_function_type (void_type_node, parmtypes);\n-  return push_library_fn (name, type, NULL_TREE);\n+  return push_library_fn (name, type, NULL_TREE, ecf_flags);\n }\n \n /* Like push_library_fn, but also note that this function throws\n@@ -4112,9 +4104,7 @@ push_void_library_fn (tree name, tree parmtypes)\n tree\n push_throw_library_fn (tree name, tree type)\n {\n-  tree fn = push_library_fn (name, type, NULL_TREE);\n-  TREE_THIS_VOLATILE (fn) = 1;\n-  TREE_NOTHROW (fn) = 0;\n+  tree fn = push_library_fn (name, type, NULL_TREE, ECF_NORETURN | ECF_LEAF);\n   return fn;\n }\n \f\n@@ -6644,7 +6634,7 @@ get_atexit_node (void)\n \n   /* Now, build the function declaration.  */\n   push_lang_context (lang_name_c);\n-  atexit_fndecl = build_library_fn_ptr (name, fn_type);\n+  atexit_fndecl = build_library_fn_ptr (name, fn_type, ECF_LEAF | ECF_NOTHROW);\n   mark_used (atexit_fndecl);\n   pop_lang_context ();\n   atexit_node = decay_conversion (atexit_fndecl, tf_warning_or_error);\n@@ -6666,7 +6656,8 @@ get_thread_atexit_node (void)\n \t\t\t\t\t   NULL_TREE);\n \n   /* Now, build the function declaration.  */\n-  tree atexit_fndecl = build_library_fn_ptr (\"__cxa_thread_atexit\", fn_type);\n+  tree atexit_fndecl = build_library_fn_ptr (\"__cxa_thread_atexit\", fn_type,\n+\t\t\t\t\t     ECF_LEAF | ECF_NOTHROW);\n   return decay_conversion (atexit_fndecl, tf_warning_or_error);\n }\n \n@@ -6992,15 +6983,17 @@ expand_static_init (tree decl, tree init)\n \t      (acquire_name, build_function_type_list (integer_type_node,\n \t\t\t\t\t\t       TREE_TYPE (guard_addr),\n \t\t\t\t\t\t       NULL_TREE),\n-\t       NULL_TREE);\n+\t       NULL_TREE, ECF_NOTHROW | ECF_LEAF);\n \t  if (!release_fn || !abort_fn)\n \t    vfntype = build_function_type_list (void_type_node,\n \t\t\t\t\t\tTREE_TYPE (guard_addr),\n \t\t\t\t\t\tNULL_TREE);\n \t  if (!release_fn)\n-\t    release_fn = push_library_fn (release_name, vfntype, NULL_TREE);\n+\t    release_fn = push_library_fn (release_name, vfntype, NULL_TREE,\n+\t\t\t\t\t   ECF_NOTHROW | ECF_LEAF);\n \t  if (!abort_fn)\n-\t    abort_fn = push_library_fn (abort_name, vfntype, NULL_TREE);\n+\t    abort_fn = push_library_fn (abort_name, vfntype, NULL_TREE,\n+\t\t\t\t\tECF_NOTHROW | ECF_LEAF);\n \n \t  inner_if_stmt = begin_if_stmt ();\n \t  finish_if_stmt_cond (build_call_n (acquire_fn, 1, guard_addr),"}, {"sha": "164b35c3a73930fffcc16451031c59c2897ae620", "filename": "gcc/cp/except.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=fafa0521c924a5627daa0b63b538c32dca4b2dce", "patch": "@@ -57,7 +57,9 @@ init_exception_processing (void)\n   /* void std::terminate (); */\n   push_namespace (std_identifier);\n   tmp = build_function_type_list (void_type_node, NULL_TREE);\n-  terminate_node = build_cp_library_fn_ptr (\"terminate\", tmp);\n+  terminate_node = build_cp_library_fn_ptr (\"terminate\", tmp,\n+\t\t\t\t\t    ECF_NOTHROW | ECF_NORETURN\n+\t\t\t\t\t    | ECF_LEAF);\n   TREE_THIS_VOLATILE (terminate_node) = 1;\n   TREE_NOTHROW (terminate_node) = 1;\n   pop_namespace ();\n@@ -149,12 +151,13 @@ build_exc_ptr (void)\n    are consistent with the actual implementations in libsupc++.  */\n \n static tree\n-declare_nothrow_library_fn (tree name, tree return_type, tree parm_type)\n+declare_library_fn (tree name, tree return_type, tree parm_type, int ecf_flags)\n {\n   return push_library_fn (name, build_function_type_list (return_type,\n \t\t\t\t\t\t\t  parm_type,\n \t\t\t\t\t\t\t  NULL_TREE),\n-\t\t\t  empty_except_spec);\n+\t\t\t  empty_except_spec,\n+\t\t\t  ecf_flags);\n }\n \n /* Build up a call to __cxa_get_exception_ptr so that we can build a\n@@ -169,10 +172,8 @@ do_get_exception_ptr (void)\n   if (!get_global_value_if_present (fn, &fn))\n     {\n       /* Declare void* __cxa_get_exception_ptr (void *) throw().  */\n-      fn = declare_nothrow_library_fn (fn, ptr_type_node, ptr_type_node);\n-\n-      if (flag_tm)\n-\tapply_tm_attr (fn, get_identifier (\"transaction_pure\"));\n+      fn = declare_library_fn (fn, ptr_type_node, ptr_type_node,\n+\t\t\t       ECF_NOTHROW | ECF_PURE | ECF_LEAF | ECF_TM_PURE);\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error,\n@@ -191,16 +192,17 @@ do_begin_catch (void)\n   if (!get_global_value_if_present (fn, &fn))\n     {\n       /* Declare void* __cxa_begin_catch (void *) throw().  */\n-      fn = declare_nothrow_library_fn (fn, ptr_type_node, ptr_type_node);\n+      fn = declare_library_fn (fn, ptr_type_node, ptr_type_node,\n+\t\t\t       ECF_NOTHROW | ECF_LEAF);\n \n       /* Create its transactional-memory equivalent.  */\n       if (flag_tm)\n \t{\n \t  tree fn2 = get_identifier (\"_ITM_cxa_begin_catch\");\n \t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    fn2 = declare_nothrow_library_fn (fn2, ptr_type_node,\n-\t\t\t\t\t      ptr_type_node);\n-\t  apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t    fn2 = declare_library_fn (fn2, ptr_type_node,\n+\t\t\t\t      ptr_type_node,\n+\t\t\t\t      ECF_NOTHROW | ECF_TM_PURE | ECF_LEAF);\n \t  record_tm_replacement (fn, fn2);\n \t}\n     }\n@@ -238,21 +240,17 @@ do_end_catch (tree type)\n   fn = get_identifier (\"__cxa_end_catch\");\n   if (!get_global_value_if_present (fn, &fn))\n     {\n-      /* Declare void __cxa_end_catch ().  */\n-      fn = push_void_library_fn (fn, void_list_node);\n-      /* This can throw if the destructor for the exception throws.  */\n-      TREE_NOTHROW (fn) = 0;\n+      /* Declare void __cxa_end_catch ().\n+         This can throw if the destructor for the exception throws.  */\n+      fn = push_void_library_fn (fn, void_list_node, ECF_LEAF);\n \n       /* Create its transactional-memory equivalent.  */\n       if (flag_tm)\n \t{\n \t  tree fn2 = get_identifier (\"_ITM_cxa_end_catch\");\n \t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    {\n-\t      fn2 = push_void_library_fn (fn2, void_list_node);\n-\t      TREE_NOTHROW (fn2) = 0;\n-\t    }\n-\t  apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t    fn2 = push_void_library_fn (fn2, void_list_node,\n+\t\t\t\t\tECF_TM_PURE | ECF_LEAF);\n \t  record_tm_replacement (fn, fn2);\n \t}\n     }\n@@ -631,15 +629,17 @@ do_allocate_exception (tree type)\n   if (!get_global_value_if_present (fn, &fn))\n     {\n       /* Declare void *__cxa_allocate_exception(size_t) throw().  */\n-      fn = declare_nothrow_library_fn (fn, ptr_type_node, size_type_node);\n+      fn = declare_library_fn (fn, ptr_type_node, size_type_node,\n+\t\t\t        ECF_NOTHROW | ECF_MALLOC | ECF_LEAF);\n \n       if (flag_tm)\n \t{\n \t  tree fn2 = get_identifier (\"_ITM_cxa_allocate_exception\");\n \t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    fn2 = declare_nothrow_library_fn (fn2, ptr_type_node,\n-\t\t\t\t\t      size_type_node);\n-\t  apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t    fn2 = declare_library_fn (fn2, ptr_type_node,\n+\t\t\t\t      size_type_node, \n+\t\t\t\t      ECF_NOTHROW | ECF_MALLOC | ECF_TM_PURE \n+\t\t\t\t      | ECF_LEAF);\n \t  record_tm_replacement (fn, fn2);\n \t}\n     }\n@@ -660,7 +660,8 @@ do_free_exception (tree ptr)\n   if (!get_global_value_if_present (fn, &fn))\n     {\n       /* Declare void __cxa_free_exception (void *) throw().  */\n-      fn = declare_nothrow_library_fn (fn, void_type_node, ptr_type_node);\n+      fn = declare_library_fn (fn, void_type_node, ptr_type_node,\n+\t\t\t       ECF_NOTHROW | ECF_LEAF);\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error, ptr, NULL_TREE);"}, {"sha": "5827540c9b273c4c1a994b441943662c9b9aaf31", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fafa0521c924a5627daa0b63b538c32dca4b2dce/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=fafa0521c924a5627daa0b63b538c32dca4b2dce", "patch": "@@ -739,8 +739,8 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t\t\t\t\t      const_ptr_type_node,\n \t\t\t\t\t      tinfo_ptr, tinfo_ptr,\n \t\t\t\t\t      ptrdiff_type_node, NULL_TREE);\n-\t      dcast_fn = build_library_fn_ptr (name, tmp);\n-\t      DECL_PURE_P (dcast_fn) = 1;\n+\t      dcast_fn = build_library_fn_ptr (name, tmp,\n+\t\t\t\t\t       ECF_LEAF | ECF_PURE | ECF_NOTHROW);\n \t      pop_abi_namespace ();\n \t      dynamic_cast_node = dcast_fn;\n \t    }"}]}