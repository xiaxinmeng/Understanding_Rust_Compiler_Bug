{"sha": "5cb3843bca9a28c28dbc1fafd88c144a43e141df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNiMzg0M2JjYTlhMjhjMjhkYmMxZmFmZDg4YzE0NGE0M2UxNDFkZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-18T14:47:48Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-12T12:50:56Z"}, "message": "[Ada] Add DWARF 5 support to System.Dwarf_Line\n\ngcc/ada/\n\n\t* libgnat/s-dwalin.ads: Adjust a few comments left and right.\n\t(Line_Info_Register): Comment out unused components.\n\t(Line_Info_Header): Add DWARF 5 support.\n\t(Dwarf_Context): Likewise.  Rename \"prologue\" into \"header\".\n\t* libgnat/s-dwalin.adb: Alphabetize \"with\" clauses.\n\t(DWARF constants): Add DWARF 5 support and reorder.\n\t(For_Each_Row): Adjust.\n\t(Initialize_Pass): Likewise.\n\t(Initialize_State_Machine): Likewise and fix typo.\n\t(Open): Add DWARF 5 support.\n\t(Parse_Prologue): Rename into...\n\t(Parse_Header): ...this and add DWARF 5 support.\n\t(Read_And_Execute_Isn): Rename into...\n\t(Read_And_Execute_Insn): ...this and adjust.\n\t(To_File_Name): Change parameter name and add DWARF 5 support.\n\t(Read_Entry_Format_Array): New procedure.\n\t(Skip_Form): Add DWARF 5 support and reorder.\n\t(Seek_Abbrev): Do not count entries and add DWARF 5 support.\n\t(Debug_Info_Lookup): Add DWARF 5 support.\n\t(Symbolic_Address.Set_Result): Likewise.\n\t(Symbolic_Address): Adjust.", "tree": {"sha": "b65375d205ff00b12376e0c0d503c749f50d8e03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b65375d205ff00b12376e0c0d503c749f50d8e03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cb3843bca9a28c28dbc1fafd88c144a43e141df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb3843bca9a28c28dbc1fafd88c144a43e141df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cb3843bca9a28c28dbc1fafd88c144a43e141df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb3843bca9a28c28dbc1fafd88c144a43e141df/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b89dabfd851f0ee0e9f0c6e141f8e3fba08d1d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b89dabfd851f0ee0e9f0c6e141f8e3fba08d1d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b89dabfd851f0ee0e9f0c6e141f8e3fba08d1d7"}], "stats": {"total": 966, "additions": 653, "deletions": 313}, "files": [{"sha": "4a9d538c0e465d29d5f1da1208a6107ca0d28f18", "filename": "gcc/ada/libgnat/s-dwalin.adb", "status": "modified", "additions": 583, "deletions": 259, "changes": 842, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb3843bca9a28c28dbc1fafd88c144a43e141df/gcc%2Fada%2Flibgnat%2Fs-dwalin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb3843bca9a28c28dbc1fafd88c144a43e141df/gcc%2Fada%2Flibgnat%2Fs-dwalin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dwalin.adb?ref=5cb3843bca9a28c28dbc1fafd88c144a43e141df", "patch": "@@ -30,20 +30,20 @@\n ------------------------------------------------------------------------------\n \n with Ada.Characters.Handling;\n+with Ada.Containers.Generic_Array_Sort;\n with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n with Ada.Unchecked_Deallocation;\n-with Ada.Containers.Generic_Array_Sort;\n \n with Interfaces; use Interfaces;\n \n with System;                   use System;\n-with System.Storage_Elements;  use System.Storage_Elements;\n with System.Address_Image;\n+with System.Bounded_Strings;   use System.Bounded_Strings;\n with System.IO;                use System.IO;\n+with System.Mmap;              use System.Mmap;\n with System.Object_Reader;     use System.Object_Reader;\n with System.Traceback_Entries; use System.Traceback_Entries;\n-with System.Mmap;              use System.Mmap;\n-with System.Bounded_Strings;   use System.Bounded_Strings;\n+with System.Storage_Elements;  use System.Storage_Elements;\n \n package body System.Dwarf_Lines is\n \n@@ -60,13 +60,19 @@ package body System.Dwarf_Lines is\n      (S    : in out Mapped_Stream;\n       Len  :    out Offset;\n       Is64 :    out Boolean);\n-   --  Read initial length as specified by Dwarf-4 7.2.2\n+   --  Read initial length as specified by 7.2.2\n \n    procedure Read_Section_Offset\n      (S    : in out Mapped_Stream;\n       Len  :    out Offset;\n       Is64 :        Boolean);\n-   --  Read a section offset, as specified by Dwarf-4 7.4\n+   --  Read a section offset, as specified by 7.4\n+\n+   procedure Read_Entry_Format_Array\n+     (S    : in out Mapped_Stream;\n+      A    :    out Entry_Format_Array;\n+      Len  :        uint8);\n+   --  Read an entry format array, as specified by 6.2.4.1\n \n    procedure Read_Aranges_Entry\n      (C     : in out Dwarf_Context;\n@@ -111,24 +117,24 @@ package body System.Dwarf_Lines is\n    --  a compilation unit.\n \n    procedure Initialize_Pass (C : in out Dwarf_Context);\n-   --  Seek to the first byte of the first prologue and prepare to make a pass\n+   --  Seek to the first byte of the first header and prepare to make a pass\n    --  over the line number entries.\n \n    procedure Initialize_State_Machine (C : in out Dwarf_Context);\n    --  Set all state machine registers to their specified initial values\n \n-   procedure Parse_Prologue (C : in out Dwarf_Context);\n-   --  Decode a DWARF statement program prologue\n+   procedure Parse_Header (C : in out Dwarf_Context);\n+   --  Decode a DWARF statement program header\n \n-   procedure Read_And_Execute_Isn\n+   procedure Read_And_Execute_Insn\n      (C    : in out Dwarf_Context;\n       Done :    out Boolean);\n    --  Read an execute a statement program instruction\n \n    function To_File_Name\n      (C    : in out Dwarf_Context;\n-      Code :        uint32) return String;\n-   --  Extract a file name from the prologue\n+      File :        uint32) return String;\n+   --  Extract a file name from the header\n \n    type Callback is not null access procedure (C : in out Dwarf_Context);\n    procedure For_Each_Row (C : in out Dwarf_Context; F : Callback);\n@@ -158,8 +164,25 @@ package body System.Dwarf_Lines is\n    --  DWARF constants  --\n    -----------------------\n \n+   --  3.1.1 Full and Partial Compilation Unit Entries\n+\n+   DW_TAG_Compile_Unit : constant := 16#11#;\n+\n+   DW_AT_Stmt_List : constant := 16#10#;\n+\n+   --  6.2.4.1 Standard Content Descriptions (DWARF 5)\n+\n+   DW_LNCT_path            : constant := 1;\n+   DW_LNCT_directory_index : constant := 2;\n+   --  DW_LNCT_timestamp   : constant := 3;\n+   --  DW_LNCT_size        : constant := 4;\n+   DW_LNCT_MD5             : constant := 5;\n+   DW_LNCT_lo_user         : constant := 16#2000#;\n+   DW_LNCT_hi_user         : constant := 16#3fff#;\n+\n    --  6.2.5.2 Standard Opcodes\n \n+   DW_LNS_extended_op        : constant := 0;\n    DW_LNS_copy               : constant := 1;\n    DW_LNS_advance_pc         : constant := 2;\n    DW_LNS_advance_line       : constant := 3;\n@@ -175,45 +198,56 @@ package body System.Dwarf_Lines is\n \n    --  6.2.5.3 Extended Opcodes\n \n-   DW_LNE_end_sequence : constant := 1;\n-   DW_LNE_set_address  : constant := 2;\n-   DW_LNE_define_file  : constant := 3;\n-\n-   --  From the DWARF version 4 public review draft\n-\n+   DW_LNE_end_sequence      : constant := 1;\n+   DW_LNE_set_address       : constant := 2;\n+   DW_LNE_define_file       : constant := 3;\n    DW_LNE_set_discriminator : constant := 4;\n \n-   --  Attribute encodings\n-\n-   DW_TAG_Compile_Unit : constant := 16#11#;\n-\n-   DW_AT_Stmt_List : constant := 16#10#;\n-\n-   DW_FORM_addr         : constant := 16#01#;\n-   DW_FORM_block2       : constant := 16#03#;\n-   DW_FORM_block4       : constant := 16#04#;\n-   DW_FORM_data2        : constant := 16#05#;\n-   DW_FORM_data4        : constant := 16#06#;\n-   DW_FORM_data8        : constant := 16#07#;\n-   DW_FORM_string       : constant := 16#08#;\n-   DW_FORM_block        : constant := 16#09#;\n-   DW_FORM_block1       : constant := 16#0a#;\n-   DW_FORM_data1        : constant := 16#0b#;\n-   DW_FORM_flag         : constant := 16#0c#;\n-   DW_FORM_sdata        : constant := 16#0d#;\n-   DW_FORM_strp         : constant := 16#0e#;\n-   DW_FORM_udata        : constant := 16#0f#;\n-   DW_FORM_ref_addr     : constant := 16#10#;\n-   DW_FORM_ref1         : constant := 16#11#;\n-   DW_FORM_ref2         : constant := 16#12#;\n-   DW_FORM_ref4         : constant := 16#13#;\n-   DW_FORM_ref8         : constant := 16#14#;\n-   DW_FORM_ref_udata    : constant := 16#15#;\n-   DW_FORM_indirect     : constant := 16#16#;\n-   DW_FORM_sec_offset   : constant := 16#17#;\n-   DW_FORM_exprloc      : constant := 16#18#;\n-   DW_FORM_flag_present : constant := 16#19#;\n-   DW_FORM_ref_sig8     : constant := 16#20#;\n+   --  7.5.5 Classes and Forms\n+\n+   DW_FORM_addr           : constant := 16#01#;\n+   DW_FORM_block2         : constant := 16#03#;\n+   DW_FORM_block4         : constant := 16#04#;\n+   DW_FORM_data2          : constant := 16#05#;\n+   DW_FORM_data4          : constant := 16#06#;\n+   DW_FORM_data8          : constant := 16#07#;\n+   DW_FORM_string         : constant := 16#08#;\n+   DW_FORM_block          : constant := 16#09#;\n+   DW_FORM_block1         : constant := 16#0a#;\n+   DW_FORM_data1          : constant := 16#0b#;\n+   DW_FORM_flag           : constant := 16#0c#;\n+   DW_FORM_sdata          : constant := 16#0d#;\n+   DW_FORM_strp           : constant := 16#0e#;\n+   DW_FORM_udata          : constant := 16#0f#;\n+   DW_FORM_ref_addr       : constant := 16#10#;\n+   DW_FORM_ref1           : constant := 16#11#;\n+   DW_FORM_ref2           : constant := 16#12#;\n+   DW_FORM_ref4           : constant := 16#13#;\n+   DW_FORM_ref8           : constant := 16#14#;\n+   DW_FORM_ref_udata      : constant := 16#15#;\n+   DW_FORM_indirect       : constant := 16#16#;\n+   DW_FORM_sec_offset     : constant := 16#17#;\n+   DW_FORM_exprloc        : constant := 16#18#;\n+   DW_FORM_flag_present   : constant := 16#19#;\n+   DW_FORM_strx           : constant := 16#1a#;\n+   DW_FORM_addrx          : constant := 16#1b#;\n+   DW_FORM_ref_sup4       : constant := 16#1c#;\n+   DW_FORM_strp_sup       : constant := 16#1d#;\n+   DW_FORM_data16         : constant := 16#1e#;\n+   DW_FORM_line_strp      : constant := 16#1f#;\n+   DW_FORM_ref_sig8       : constant := 16#20#;\n+   DW_FORM_implicit_const : constant := 16#21#;\n+   DW_FORM_loclistx       : constant := 16#22#;\n+   DW_FORM_rnglistx       : constant := 16#23#;\n+   DW_FORM_ref_sup8       : constant := 16#24#;\n+   DW_FORM_strx1          : constant := 16#25#;\n+   DW_FORM_strx2          : constant := 16#26#;\n+   DW_FORM_strx3          : constant := 16#27#;\n+   DW_FORM_strx4          : constant := 16#28#;\n+   DW_FORM_addrx1         : constant := 16#29#;\n+   DW_FORM_addrx2         : constant := 16#2a#;\n+   DW_FORM_addrx3         : constant := 16#2b#;\n+   DW_FORM_addrx4         : constant := 16#2c#;\n \n    ---------\n    -- \"<\" --\n@@ -235,6 +269,7 @@ package body System.Dwarf_Lines is\n       procedure Unchecked_Deallocation is new Ada.Unchecked_Deallocation\n         (Search_Array,\n          Search_Array_Access);\n+\n    begin\n       if C.Has_Debug then\n          Close (C.Lines);\n@@ -265,6 +300,7 @@ package body System.Dwarf_Lines is\n    procedure Dump_Row (C : in out Dwarf_Context) is\n       PC  : constant Integer_Address := Integer_Address (C.Registers.Address);\n       Off : Offset;\n+\n    begin\n       Tell (C.Lines, Off);\n \n@@ -286,11 +322,13 @@ package body System.Dwarf_Lines is\n       Cache : constant Search_Array_Access := C.Cache;\n       S     : Object_Symbol;\n       Name  : String_Ptr_Len;\n+\n    begin\n       if Cache = null then\n          Put_Line (\"No cache\");\n          return;\n       end if;\n+\n       for I in Cache'Range loop\n          declare\n             E : Search_Entry renames Cache (I);\n@@ -322,7 +360,7 @@ package body System.Dwarf_Lines is\n       Initialize_Pass (C);\n \n       loop\n-         Read_And_Execute_Isn (C, Done);\n+         Read_And_Execute_Insn (C, Done);\n \n          if C.Registers.Is_Row then\n             F.all (C);\n@@ -339,8 +377,7 @@ package body System.Dwarf_Lines is\n    procedure Initialize_Pass (C : in out Dwarf_Context) is\n    begin\n       Seek (C.Lines, 0);\n-      C.Next_Prologue := 0;\n-\n+      C.Next_Header := 0;\n       Initialize_State_Machine (C);\n    end Initialize_Pass;\n \n@@ -350,17 +387,16 @@ package body System.Dwarf_Lines is\n \n    procedure Initialize_State_Machine (C : in out Dwarf_Context) is\n    begin\n+      --  Table 6.4: Line number program initial state\n+\n       C.Registers :=\n         (Address        => 0,\n          File           => 1,\n          Line           => 1,\n          Column         => 0,\n-         Is_Stmt        => C.Prologue.Default_Is_Stmt = 0,\n+         Is_Stmt        => C.Header.Default_Is_Stmt /= 0,\n          Basic_Block    => False,\n          End_Sequence   => False,\n-         Prologue_End   => False,\n-         Epilogue_Begin => False,\n-         ISA            => 0,\n          Is_Row         => False);\n    end Initialize_State_Machine;\n \n@@ -378,8 +414,7 @@ package body System.Dwarf_Lines is\n    -- Low_Address --\n    -----------------\n \n-   function Low_Address (C : Dwarf_Context)\n-      return System.Address is\n+   function Low_Address (C : Dwarf_Context) return System.Address is\n    begin\n       return C.Load_Address + C.Low;\n    end Low_Address;\n@@ -393,19 +428,24 @@ package body System.Dwarf_Lines is\n       C         : out Dwarf_Context;\n       Success   : out Boolean)\n    is\n-      Line_Sec, Info_Sec, Abbrev_Sec, Aranges_Sec : Object_Section;\n-      Hi, Lo                                      : uint64;\n+      Abbrev, Aranges, Lines, Info, Line_Str : Object_Section;\n+      Hi, Lo                                 : uint64;\n+\n    begin\n       --  Not a success by default\n \n       Success := False;\n \n-      --  Open file\n+      --  Open file with In_Exception set so we can control the failure mode\n \n-      C.Obj := Open (File_Name, C.In_Exception);\n+      C.Obj := Open (File_Name, In_Exception => True);\n \n       if C.Obj = null then\n-         return;\n+         if C.In_Exception then\n+            return;\n+         else\n+            raise Dwarf_Error with \"could not open file\";\n+         end if;\n       end if;\n \n       Success := True;\n@@ -420,21 +460,23 @@ package body System.Dwarf_Lines is\n       --  Create a stream for debug sections\n \n       if Format (C.Obj.all) = XCOFF32 then\n-         Line_Sec    := Get_Section (C.Obj.all, \".dwline\");\n-         Abbrev_Sec  := Get_Section (C.Obj.all, \".dwabrev\");\n-         Info_Sec    := Get_Section (C.Obj.all, \".dwinfo\");\n-         Aranges_Sec := Get_Section (C.Obj.all, \".dwarnge\");\n+         Abbrev   := Get_Section (C.Obj.all, \".dwabrev\");\n+         Aranges  := Get_Section (C.Obj.all, \".dwarnge\");\n+         Info     := Get_Section (C.Obj.all, \".dwinfo\");\n+         Lines    := Get_Section (C.Obj.all, \".dwline\");\n+         Line_Str := Get_Section (C.Obj.all, \".dwlistr\");\n       else\n-         Line_Sec    := Get_Section (C.Obj.all, \".debug_line\");\n-         Abbrev_Sec  := Get_Section (C.Obj.all, \".debug_abbrev\");\n-         Info_Sec    := Get_Section (C.Obj.all, \".debug_info\");\n-         Aranges_Sec := Get_Section (C.Obj.all, \".debug_aranges\");\n+         Abbrev   := Get_Section (C.Obj.all, \".debug_abbrev\");\n+         Aranges  := Get_Section (C.Obj.all, \".debug_aranges\");\n+         Info     := Get_Section (C.Obj.all, \".debug_info\");\n+         Lines    := Get_Section (C.Obj.all, \".debug_line\");\n+         Line_Str := Get_Section (C.Obj.all, \".debug_line_str\");\n       end if;\n \n-      if Line_Sec = Null_Section\n-        or else Abbrev_Sec = Null_Section\n-        or else Info_Sec = Null_Section\n-        or else Aranges_Sec = Null_Section\n+      if Abbrev = Null_Section\n+        or else Aranges = Null_Section\n+        or else Info = Null_Section\n+        or else Lines = Null_Section\n       then\n          pragma Annotate\n            (CodePeer, False_Positive,\n@@ -444,21 +486,29 @@ package body System.Dwarf_Lines is\n          return;\n       end if;\n \n-      C.Lines   := Create_Stream (C.Obj.all, Line_Sec);\n-      C.Abbrev  := Create_Stream (C.Obj.all, Abbrev_Sec);\n-      C.Info    := Create_Stream (C.Obj.all, Info_Sec);\n-      C.Aranges := Create_Stream (C.Obj.all, Aranges_Sec);\n+      C.Abbrev  := Create_Stream (C.Obj.all, Abbrev);\n+      C.Aranges := Create_Stream (C.Obj.all, Aranges);\n+      C.Info    := Create_Stream (C.Obj.all, Info);\n+      C.Lines   := Create_Stream (C.Obj.all, Lines);\n+\n+      --  The .debug_line_str section may be available in DWARF 5\n+\n+      if Line_Str /= Null_Section then\n+         C.Line_Str := Create_Stream (C.Obj.all, Line_Str);\n+      end if;\n \n       --  All operations are successful, context is valid\n \n       C.Has_Debug := True;\n    end Open;\n \n-   --------------------\n-   -- Parse_Prologue --\n-   --------------------\n+   ------------------\n+   -- Parse_Header --\n+   ------------------\n+\n+   procedure Parse_Header (C : in out Dwarf_Context) is\n+      Header : Line_Info_Header renames C.Header;\n \n-   procedure Parse_Prologue (C : in out Dwarf_Context) is\n       Char : uint8;\n       Prev : uint8;\n       --  The most recently read character and the one preceding it\n@@ -469,94 +519,147 @@ package body System.Dwarf_Lines is\n       Buf : Buffer;\n       Off : Offset;\n \n-      First_Byte_Of_Prologue : Offset;\n-      Last_Byte_Of_Prologue  : Offset;\n-\n-      Max_Op_Per_Insn : uint8;\n-      pragma Unreferenced (Max_Op_Per_Insn);\n+      First_Byte_Of_Header : Offset;\n+      Last_Byte_Of_Header  : Offset;\n \n-      Prologue : Line_Info_Prologue renames C.Prologue;\n+      Standard_Opcode_Lengths : Opcode_Length_Array;\n+      pragma Unreferenced (Standard_Opcode_Lengths);\n \n    begin\n-      Tell (C.Lines, First_Byte_Of_Prologue);\n-      Prologue.Unit_Length := Read (C.Lines);\n+      Tell (C.Lines, First_Byte_Of_Header);\n+\n+      Read_Initial_Length (C.Lines, Header.Unit_Length, Header.Is64);\n+\n       Tell (C.Lines, Off);\n-      C.Next_Prologue := Off + Offset (Prologue.Unit_Length);\n+      C.Next_Header := Off + Header.Unit_Length;\n+\n+      Header.Version := Read (C.Lines);\n+\n+      if Header.Version >= 5 then\n+         Header.Address_Size          := Read (C.Lines);\n+         Header.Segment_Selector_Size := Read (C.Lines);\n+      else\n+         Header.Address_Size          := 0;\n+         Header.Segment_Selector_Size := 0;\n+      end if;\n \n-      Prologue.Version         := Read (C.Lines);\n-      Prologue.Prologue_Length := Read (C.Lines);\n-      Tell (C.Lines, Last_Byte_Of_Prologue);\n-      Last_Byte_Of_Prologue :=\n-        Last_Byte_Of_Prologue + Offset (Prologue.Prologue_Length) - 1;\n+      Header.Header_Length := Read (C.Lines);\n+      Tell (C.Lines, Last_Byte_Of_Header);\n+      Last_Byte_Of_Header :=\n+        Last_Byte_Of_Header + Offset (Header.Header_Length) - 1;\n \n-      Prologue.Min_Isn_Length := Read (C.Lines);\n+      Header.Minimum_Insn_Length := Read (C.Lines);\n \n-      if Prologue.Version >= 4 then\n-         Max_Op_Per_Insn := Read (C.Lines);\n+      if Header.Version >= 4 then\n+         Header.Maximum_Op_Per_Insn := Read (C.Lines);\n+      else\n+         Header.Maximum_Op_Per_Insn := 0;\n       end if;\n \n-      Prologue.Default_Is_Stmt := Read (C.Lines);\n-      Prologue.Line_Base       := Read (C.Lines);\n-      Prologue.Line_Range      := Read (C.Lines);\n-      Prologue.Opcode_Base     := Read (C.Lines);\n+      Header.Default_Is_Stmt := Read (C.Lines);\n+      Header.Line_Base       := Read (C.Lines);\n+      Header.Line_Range      := Read (C.Lines);\n+      Header.Opcode_Base     := Read (C.Lines);\n \n-      --  Opcode_Lengths is an array of Opcode_Base bytes specifying the number\n-      --  of LEB128 operands for each of the standard opcodes.\n+      --  Standard_Opcode_Lengths is an array of Opcode_Base bytes specifying\n+      --  the number of LEB128 operands for each of the standard opcodes.\n \n-      for J in 1 .. uint32 (Prologue.Opcode_Base - 1) loop\n-         Prologue.Opcode_Lengths (J) := Read (C.Lines);\n+      for J in 1 .. Integer (Header.Opcode_Base - 1) loop\n+         Standard_Opcode_Lengths (J) := Read (C.Lines);\n       end loop;\n \n-      --  The include directories table follows. This is a list of null\n-      --  terminated strings terminated by a double null. We only store\n-      --  its offset for later decoding.\n+      --  The directories table follows. Up to DWARF 4, this is a list of null\n+      --  terminated strings terminated by a null byte. In DWARF 5, this is a\n+      --  sequence of Directories_Count entries encoded as described by the\n+      --  Directory_Entry_Format field. We store its offset for later decoding.\n \n-      Tell (C.Lines, Prologue.Includes_Offset);\n-      Char := Read (C.Lines);\n+      if Header.Version <= 4 then\n+         Tell (C.Lines, Header.Directories);\n+         Char := Read (C.Lines);\n \n-      if Char /= 0 then\n-         loop\n-            Prev := Char;\n-            Char := Read (C.Lines);\n-            exit when Char = 0 and Prev = 0;\n+         if Char /= 0 then\n+            loop\n+               Prev := Char;\n+               Char := Read (C.Lines);\n+               exit when Char = 0 and Prev = 0;\n+            end loop;\n+         end if;\n+\n+      else\n+         Header.Directory_Entry_Format_Count := Read (C.Lines);\n+         Read_Entry_Format_Array (C.Lines,\n+           Header.Directory_Entry_Format,\n+           Header.Directory_Entry_Format_Count);\n+\n+         Header.Directories_Count := Read_LEB128 (C.Lines);\n+         Tell (C.Lines, Header.Directories);\n+         for J in 1 .. Header.Directories_Count loop\n+            for K in 1 .. Integer (Header.Directory_Entry_Format_Count) loop\n+               Skip_Form (C.Lines,\n+                 Header.Directory_Entry_Format (K).Form,\n+                 Header.Is64,\n+                 Header.Address_Size);\n+            end loop;\n          end loop;\n       end if;\n \n-      --  The file_names table is next. Each record is a null terminated string\n-      --  for the file name, an unsigned LEB128 directory index, an unsigned\n-      --  LEB128 modification time, and an LEB128 file length. The table is\n-      --  terminated by a null byte.\n+      --  The file_names table is next. Up to DWARF 4, this is a list of record\n+      --  containing a null terminated string for the file name, an unsigned\n+      --  LEB128 directory index in the Directories table, an unsigned LEB128\n+      --  modification time, and an unsigned LEB128 for the file length; the\n+      --  table is terminated by a null byte. In DWARF 5, this is a sequence\n+      --  of File_Names_Count entries encoded as described by the\n+      --  File_Name_Entry_Format field. We store its offset for later decoding.\n \n-      Tell (C.Lines, Prologue.File_Names_Offset);\n+      if Header.Version <= 4 then\n+         Tell (C.Lines, Header.File_Names);\n \n-      loop\n-         --  Read the filename\n+         --  Read the file names\n \n-         Read_C_String (C.Lines, Buf);\n-         exit when Buf (0) = 0;\n-         Dummy := Read_LEB128 (C.Lines); --  Skip the directory index.\n-         Dummy := Read_LEB128 (C.Lines); --  Skip the modification time.\n-         Dummy := Read_LEB128 (C.Lines); --  Skip the file length.\n-      end loop;\n+         loop\n+            Read_C_String (C.Lines, Buf);\n+            exit when Buf (0) = 0;\n+            Dummy := Read_LEB128 (C.Lines); --  Skip the directory index.\n+            Dummy := Read_LEB128 (C.Lines); --  Skip the modification time.\n+            Dummy := Read_LEB128 (C.Lines); --  Skip the file length.\n+         end loop;\n+\n+      else\n+         Header.File_Name_Entry_Format_Count := Read (C.Lines);\n+         Read_Entry_Format_Array (C.Lines,\n+           Header.File_Name_Entry_Format,\n+           Header.File_Name_Entry_Format_Count);\n+\n+         Header.File_Names_Count := Read_LEB128 (C.Lines);\n+         Tell (C.Lines, Header.File_Names);\n+         for J in 1 .. Header.File_Names_Count loop\n+            for K in 1 .. Integer (Header.File_Name_Entry_Format_Count) loop\n+               Skip_Form (C.Lines,\n+                 Header.File_Name_Entry_Format (K).Form,\n+                 Header.Is64,\n+                 Header.Address_Size);\n+            end loop;\n+         end loop;\n+      end if;\n \n       --  Check we're where we think we are. This sanity check ensures we think\n-      --  the prologue ends where the prologue says it does. It we aren't then\n-      --  we've probably gotten out of sync somewhere.\n+      --  the header ends where the header says it does. It we aren't, then we\n+      --  have probably gotten out of sync somewhere.\n \n       Tell (C.Lines, Off);\n \n-      if Prologue.Unit_Length /= 0\n-        and then Off /= Last_Byte_Of_Prologue + 1\n+      if Header.Unit_Length /= 0\n+        and then Off /= Last_Byte_Of_Header + 1\n       then\n-         raise Dwarf_Error with \"Parse error reading DWARF information\";\n+         raise Dwarf_Error with \"parse error reading DWARF information\";\n       end if;\n-   end Parse_Prologue;\n+   end Parse_Header;\n \n-   --------------------------\n-   -- Read_And_Execute_Isn --\n-   --------------------------\n+   ---------------------------\n+   -- Read_And_Execute_Insn --\n+   ---------------------------\n \n-   procedure Read_And_Execute_Isn\n+   procedure Read_And_Execute_Insn\n      (C    : in out Dwarf_Context;\n       Done :    out Boolean)\n    is\n@@ -572,7 +675,7 @@ package body System.Dwarf_Lines is\n \n       Obj : Object_File renames C.Obj.all;\n       Registers : Line_Info_Registers renames C.Registers;\n-      Prologue : Line_Info_Prologue renames C.Prologue;\n+      Header : Line_Info_Header renames C.Header;\n \n    begin\n       Done             := False;\n@@ -582,8 +685,8 @@ package body System.Dwarf_Lines is\n          Initialize_State_Machine (C);\n       end if;\n \n-      --  If we have reached the next prologue, read it. Beware of possibly\n-      --  empty blocks.\n+      --  If we have reached the next header, read it. Beware of possibly empty\n+      --  blocks.\n \n       --  When testing for the end of section, beware of possible zero padding\n       --  at the end. Bail out as soon as there's not even room for at least a\n@@ -592,9 +695,9 @@ package body System.Dwarf_Lines is\n       --  or Off+3 > Section_Length.\n \n       Tell (C.Lines, Off);\n-      while Off = C.Next_Prologue loop\n+      while Off = C.Next_Header loop\n          Initialize_State_Machine (C);\n-         Parse_Prologue (C);\n+         Parse_Header (C);\n          Tell (C.Lines, Off);\n          exit when Off + 3 > Length (C.Lines);\n       end loop;\n@@ -606,7 +709,7 @@ package body System.Dwarf_Lines is\n       --  We are finished when we either reach the end of the section, or we\n       --  have reached zero padding at the end of the section.\n \n-      if Prologue.Unit_Length = 0 or else Off + 3 > Length (C.Lines) then\n+      if Header.Unit_Length = 0 or else Off + 3 > Length (C.Lines) then\n          Done := True;\n          return;\n       end if;\n@@ -617,7 +720,7 @@ package body System.Dwarf_Lines is\n \n       --  Extended opcodes\n \n-      if Opcode = 0 then\n+      if Opcode = DW_LNS_extended_op then\n          Extended_Length := Read_LEB128 (C.Lines);\n          Extended_Opcode := Read (C.Lines);\n \n@@ -656,7 +759,7 @@ package body System.Dwarf_Lines is\n \n       --  Standard opcodes\n \n-      elsif Opcode < Prologue.Opcode_Base then\n+      elsif Opcode < Header.Opcode_Base then\n          case Opcode is\n \n             --  Append a row to the line info matrix\n@@ -671,7 +774,7 @@ package body System.Dwarf_Lines is\n                uint32_Operand    := Read_LEB128 (C.Lines);\n                Registers.Address :=\n                  Registers.Address +\n-                 uint64 (uint32_Operand * uint32 (Prologue.Min_Isn_Length));\n+                 uint64 (uint32_Operand * uint32 (Header.Minimum_Insn_Length));\n \n             --  Add a signed word to the current source line\n \n@@ -708,8 +811,8 @@ package body System.Dwarf_Lines is\n                Registers.Address :=\n                  Registers.Address +\n                  uint64\n-                   (((255 - Prologue.Opcode_Base) / Prologue.Line_Range) *\n-                    Prologue.Min_Isn_Length);\n+                   (((255 - Header.Opcode_Base) / Header.Line_Range) *\n+                    Header.Minimum_Insn_Length);\n \n             --  Advance the program counter by a constant\n \n@@ -744,26 +847,24 @@ package body System.Dwarf_Lines is\n             Line_Increment    : int32;\n \n          begin\n-            Opcode := Opcode - Prologue.Opcode_Base;\n+            Opcode := Opcode - Header.Opcode_Base;\n \n             --  The adjusted opcode is a uint8 encoding an address increment\n             --  and a signed line increment. The upperbound is allowed to be\n             --  greater than int8'last so we decode using int32 directly to\n             --  prevent overflows.\n \n             Address_Increment :=\n-              int32 (Opcode / Prologue.Line_Range) *\n-              int32 (Prologue.Min_Isn_Length);\n+              int32 (Opcode / Header.Line_Range) *\n+              int32 (Header.Minimum_Insn_Length);\n             Line_Increment :=\n-              int32 (Prologue.Line_Base) +\n-              int32 (Opcode mod Prologue.Line_Range);\n+              int32 (Header.Line_Base) +\n+              int32 (Opcode mod Header.Line_Range);\n \n             Registers.Address :=\n               Registers.Address + uint64 (Address_Increment);\n             Registers.Line := uint32 (int32 (Registers.Line) + Line_Increment);\n             Registers.Basic_Block    := False;\n-            Registers.Prologue_End   := False;\n-            Registers.Epilogue_Begin := False;\n             Registers.Is_Row         := True;\n          end;\n       end if;\n@@ -775,7 +876,7 @@ package body System.Dwarf_Lines is\n \n          Registers.Is_Row := False;\n          Done             := True;\n-   end Read_And_Execute_Isn;\n+   end Read_And_Execute_Insn;\n \n    ----------------------\n    -- Set_Load_Address --\n@@ -792,10 +893,10 @@ package body System.Dwarf_Lines is\n \n    function To_File_Name\n      (C    : in out Dwarf_Context;\n-      Code :        uint32) return String\n+      File :        uint32) return String\n    is\n       Buf : Buffer;\n-      J   : uint32;\n+      Off : Offset;\n \n       Dir_Idx : uint32;\n       pragma Unreferenced (Dir_Idx);\n@@ -806,25 +907,56 @@ package body System.Dwarf_Lines is\n       Length : uint32;\n       pragma Unreferenced (Length);\n \n+      File_Entry_Format : Entry_Format_Array\n+        renames C.Header.File_Name_Entry_Format;\n+\n    begin\n-      Seek (C.Lines, C.Prologue.File_Names_Offset);\n+      Seek (C.Lines, C.Header.File_Names);\n \n-      --  Find the entry\n+      --  Find the entry. Note that, up to DWARF 4, the index is 1-based\n+      --  whereas, in DWARF 5, it is 0-based.\n \n-      J := 0;\n-      loop\n-         J := J + 1;\n-         Read_C_String (C.Lines, Buf);\n+      if C.Header.Version <= 4 then\n+         for J in 1 .. File loop\n+            Read_C_String (C.Lines, Buf);\n \n-         if Buf (Buf'First) = 0 then\n-            return \"???\";\n-         end if;\n+            if Buf (Buf'First) = 0 then\n+               return \"???\";\n+            end if;\n \n-         Dir_Idx  := Read_LEB128 (C.Lines);\n-         Mod_Time := Read_LEB128 (C.Lines);\n-         Length   := Read_LEB128 (C.Lines);\n-         exit when J = Code;\n-      end loop;\n+            Dir_Idx  := Read_LEB128 (C.Lines);\n+            Mod_Time := Read_LEB128 (C.Lines);\n+            Length   := Read_LEB128 (C.Lines);\n+         end loop;\n+\n+      --  DWARF 5\n+\n+      else\n+         for J in 0 .. File loop\n+            for K in 1 .. Integer (C.Header.File_Name_Entry_Format_Count) loop\n+               if File_Entry_Format (K).C_Type = DW_LNCT_path then\n+                  case File_Entry_Format (K).Form is\n+                     when DW_FORM_string =>\n+                        Read_C_String (C.Lines, Buf);\n+\n+                     when DW_FORM_line_strp =>\n+                        Read_Section_Offset (C.Lines, Off, C.Header.Is64);\n+                        Seek (C.Line_Str, Off);\n+                        Read_C_String (C.Line_Str, Buf);\n+\n+                     when others =>\n+                        raise Dwarf_Error with \"DWARF form not implemented\";\n+                  end case;\n+\n+               else\n+                  Skip_Form (C.Lines,\n+                    File_Entry_Format (K).Form,\n+                    C.Header.Is64,\n+                    C.Header.Address_Size);\n+               end if;\n+            end loop;\n+         end loop;\n+      end if;\n \n       return To_String (Buf);\n    end To_File_Name;\n@@ -840,6 +972,7 @@ package body System.Dwarf_Lines is\n    is\n       Len32 : uint32;\n       Len64 : uint64;\n+\n    begin\n       Len32 := Read (S);\n       if Len32 < 16#ffff_fff0# then\n@@ -872,6 +1005,43 @@ package body System.Dwarf_Lines is\n       end if;\n    end Read_Section_Offset;\n \n+   -----------------------------\n+   -- Read_Entry_Format_Array --\n+   -----------------------------\n+\n+   procedure Read_Entry_Format_Array\n+     (S    : in out Mapped_Stream;\n+      A    :    out Entry_Format_Array;\n+      Len  :        uint8)\n+   is\n+      C_Type, Form : uint32;\n+      N            : Integer;\n+\n+   begin\n+      N := A'First;\n+\n+      for J in 1 .. Len loop\n+         C_Type := Read_LEB128 (S);\n+         Form   := Read_LEB128 (S);\n+\n+         case C_Type is\n+            when DW_LNCT_path .. DW_LNCT_MD5 =>\n+               if N not in A'Range then\n+                  raise Dwarf_Error with \"DWARF duplicate content type\";\n+               end if;\n+\n+               A (N) := (C_Type, Form);\n+               N := N + 1;\n+\n+            when DW_LNCT_lo_user .. DW_LNCT_hi_user =>\n+               null;\n+\n+            when others =>\n+               raise Dwarf_Error with \"DWARF content type not implemented\";\n+         end case;\n+      end loop;\n+   end Read_Entry_Format_Array;\n+\n    --------------------\n    -- Aranges_Lookup --\n    --------------------\n@@ -921,41 +1091,66 @@ package body System.Dwarf_Lines is\n       Ptr_Sz :        uint8)\n    is\n       Skip : Offset;\n+\n    begin\n+      --  7.5.5 Classes and Forms\n+\n       case Form is\n          when DW_FORM_addr =>\n             Skip := Offset (Ptr_Sz);\n+         when DW_FORM_addrx =>\n+            Skip := Offset (uint32'(Read_LEB128 (S)));\n+         when DW_FORM_block1 =>\n+            Skip := Offset (uint8'(Read (S)));\n          when DW_FORM_block2 =>\n             Skip := Offset (uint16'(Read (S)));\n          when DW_FORM_block4 =>\n             Skip := Offset (uint32'(Read (S)));\n-         when DW_FORM_data2 | DW_FORM_ref2 =>\n-            Skip := 2;\n-         when DW_FORM_data4 | DW_FORM_ref4 =>\n-            Skip := 4;\n-         when DW_FORM_data8 | DW_FORM_ref8 | DW_FORM_ref_sig8 =>\n-            Skip := 8;\n-         when DW_FORM_string =>\n-            while uint8'(Read (S)) /= 0 loop\n-               null;\n-            end loop;\n-            return;\n          when DW_FORM_block | DW_FORM_exprloc =>\n             Skip := Offset (uint32'(Read_LEB128 (S)));\n-         when DW_FORM_block1 | DW_FORM_ref1 =>\n-            Skip := Offset (uint8'(Read (S)));\n-         when DW_FORM_data1 | DW_FORM_flag =>\n+         when DW_FORM_addrx1\n+            | DW_FORM_data1\n+            | DW_FORM_flag\n+            | DW_FORM_ref1\n+            | DW_FORM_strx1\n+           =>\n             Skip := 1;\n+         when DW_FORM_addrx2\n+            | DW_FORM_data2\n+            | DW_FORM_ref2\n+            | DW_FORM_strx2\n+           =>\n+            Skip := 2;\n+         when DW_FORM_addrx3 | DW_FORM_strx3 =>\n+            Skip := 3;\n+         when DW_FORM_addrx4\n+            | DW_FORM_data4\n+            | DW_FORM_ref4\n+            | DW_FORM_ref_sup4\n+            | DW_FORM_strx4\n+           =>\n+            Skip := 4;\n+         when DW_FORM_data8\n+            | DW_FORM_ref8\n+            | DW_FORM_ref_sup8\n+            | DW_FORM_ref_sig8\n+           =>\n+            Skip := 8;\n+         when DW_FORM_data16 =>\n+            Skip := 16;\n          when DW_FORM_sdata =>\n             declare\n                Val : constant int32 := Read_LEB128 (S);\n                pragma Unreferenced (Val);\n             begin\n                return;\n             end;\n-         when DW_FORM_strp | DW_FORM_ref_addr | DW_FORM_sec_offset =>\n-            Skip := (if Is64 then 8 else 4);\n-         when DW_FORM_udata | DW_FORM_ref_udata =>\n+         when DW_FORM_udata\n+            | DW_FORM_ref_udata\n+            | DW_FORM_loclistx\n+            | DW_FORM_rnglistx\n+            | DW_FORM_strx\n+           =>\n             declare\n                Val : constant uint32 := Read_LEB128 (S);\n                pragma Unreferenced (Val);\n@@ -964,11 +1159,24 @@ package body System.Dwarf_Lines is\n             end;\n          when DW_FORM_flag_present =>\n             return;\n-         when DW_FORM_indirect =>\n+         when DW_FORM_ref_addr\n+            | DW_FORM_sec_offset\n+            | DW_FORM_strp\n+            | DW_FORM_line_strp\n+            | DW_FORM_strp_sup\n+           =>\n+            Skip := (if Is64 then 8 else 4);\n+         when DW_FORM_string =>\n+            while uint8'(Read (S)) /= 0 loop\n+               null;\n+            end loop;\n+            return;\n+         when DW_FORM_implicit_const | DW_FORM_indirect =>\n             raise Constraint_Error;\n          when others =>\n             raise Constraint_Error;\n       end case;\n+\n       Seek (S, Tell (S) + Skip);\n    end Skip_Form;\n \n@@ -981,33 +1189,41 @@ package body System.Dwarf_Lines is\n       Abbrev_Offset :        Offset;\n       Abbrev_Num    :        uint32)\n    is\n-      Num       : uint32;\n       Abbrev    : uint32;\n       Tag       : uint32;\n       Has_Child : uint8;\n-      pragma Unreferenced (Abbrev, Tag, Has_Child);\n+      pragma Unreferenced (Tag, Has_Child);\n+\n    begin\n       Seek (C.Abbrev, Abbrev_Offset);\n \n-      Num := 1;\n+      --  7.5.3 Abbreviations Tables\n \n       loop\n-         exit when Num = Abbrev_Num;\n+         Abbrev := Read_LEB128 (C.Abbrev);\n+\n+         exit when Abbrev = Abbrev_Num;\n \n-         Abbrev    := Read_LEB128 (C.Abbrev);\n          Tag       := Read_LEB128 (C.Abbrev);\n          Has_Child := Read (C.Abbrev);\n \n          loop\n             declare\n                Name : constant uint32 := Read_LEB128 (C.Abbrev);\n                Form : constant uint32 := Read_LEB128 (C.Abbrev);\n+               Cst  : int32;\n+               pragma Unreferenced (Cst);\n+\n             begin\n-               exit when Name = 0 and Form = 0;\n+               --  DW_FORM_implicit_const takes its value from the table\n+\n+               if Form = DW_FORM_implicit_const then\n+                  Cst := Read_LEB128 (C.Abbrev);\n+               end if;\n+\n+               exit when Name = 0 and then Form = 0;\n             end;\n          end loop;\n-\n-         Num := Num + 1;\n       end loop;\n    end Seek_Abbrev;\n \n@@ -1029,23 +1245,40 @@ package body System.Dwarf_Lines is\n       Abbrev        : uint32;\n       Has_Child     : uint8;\n       pragma Unreferenced (Has_Child);\n+      Unit_Type     : uint8;\n+      pragma Unreferenced (Unit_Type);\n+\n    begin\n       Line_Offset := 0;\n       Success := False;\n \n       Seek (C.Info, Info_Offset);\n \n+      --  7.5.1.1 Compilation Unit Header\n+\n       Read_Initial_Length (C.Info, Unit_Length, Is64);\n \n       Version := Read (C.Info);\n-      if Version not in 2 .. 4 then\n-         return;\n-      end if;\n \n-      Read_Section_Offset (C.Info, Abbrev_Offset, Is64);\n+      if Version >= 5 then\n+         Unit_Type := Read (C.Info);\n+\n+         Addr_Sz := Read (C.Info);\n+         if Addr_Sz /= (Address'Size / SSU) then\n+            return;\n+         end if;\n+\n+         Read_Section_Offset (C.Info, Abbrev_Offset, Is64);\n+\n+      elsif Version >= 2 then\n+         Read_Section_Offset (C.Info, Abbrev_Offset, Is64);\n+\n+         Addr_Sz := Read (C.Info);\n+         if Addr_Sz /= (Address'Size / SSU) then\n+            return;\n+         end if;\n \n-      Addr_Sz := Read (C.Info);\n-      if Addr_Sz /= (Address'Size / SSU) then\n+      else\n          return;\n       end if;\n \n@@ -1060,17 +1293,9 @@ package body System.Dwarf_Lines is\n \n       Seek_Abbrev (C, Abbrev_Offset, Abbrev);\n \n-      --  First ULEB128 is the abbrev code\n-\n-      if Read_LEB128 (C.Abbrev) /= Abbrev then\n-         --  Ill formed abbrev table\n-         return;\n-      end if;\n-\n       --  Then the tag\n \n       if Read_LEB128 (C.Abbrev) /= uint32'(DW_TAG_Compile_Unit) then\n-         --  Expect compile unit\n          return;\n       end if;\n \n@@ -1104,8 +1329,6 @@ package body System.Dwarf_Lines is\n             end if;\n          end;\n       end loop;\n-\n-      return;\n    end Debug_Info_Lookup;\n \n    -------------------------\n@@ -1121,6 +1344,7 @@ package body System.Dwarf_Lines is\n       Is64        : Boolean;\n       Version     : uint16;\n       Sz          : uint8;\n+\n    begin\n       Success     := False;\n       Info_Offset := 0;\n@@ -1149,6 +1373,7 @@ package body System.Dwarf_Lines is\n       end if;\n \n       --  Handle alignment on twice the address size\n+\n       declare\n          Cur_Off : constant Offset := Tell (C.Aranges);\n          Align   : constant Offset := 2 * Address'Size / SSU;\n@@ -1173,6 +1398,7 @@ package body System.Dwarf_Lines is\n    is\n    begin\n       --  Read table\n+\n       if Address'Size = 32 then\n          declare\n             S, L : uint32;\n@@ -1182,6 +1408,7 @@ package body System.Dwarf_Lines is\n             Start := Storage_Offset (S);\n             Len   := Storage_Count (L);\n          end;\n+\n       elsif Address'Size = 64 then\n          declare\n             S, L : uint64;\n@@ -1191,6 +1418,7 @@ package body System.Dwarf_Lines is\n             Start := Storage_Offset (S);\n             Len   := Storage_Count (L);\n          end;\n+\n       else\n          raise Constraint_Error;\n       end if;\n@@ -1202,8 +1430,11 @@ package body System.Dwarf_Lines is\n \n    procedure Enable_Cache (C : in out Dwarf_Context) is\n       Cache : Search_Array_Access;\n+\n    begin\n-      --  Phase 1: count number of symbols. Phase 2: fill the cache.\n+      --  Phase 1: count number of symbols.\n+      --  Phase 2: fill the cache.\n+\n       declare\n          S               : Object_Symbol;\n          Val             : uint64;\n@@ -1220,18 +1451,19 @@ package body System.Dwarf_Lines is\n             while S /= Null_Symbol loop\n                --  Discard symbols of length 0 or located outside of the\n                --  execution code section outer boundaries.\n+\n                Sz := uint32 (Size (S));\n                Val := Value (S);\n \n                if Sz > 0\n                  and then Val >= Xcode_Low\n                  and then Val <= Xcode_High\n                then\n-\n                   Addr := uint32 (Val - Xcode_Low);\n \n                   --  Try to filter symbols at the same address. This is a best\n                   --  effort as they might not be consecutive.\n+\n                   if Addr /= Prev_Addr then\n                      Nbr_Symbols := Nbr_Symbols + 1;\n                      Prev_Addr   := Addr;\n@@ -1251,20 +1483,24 @@ package body System.Dwarf_Lines is\n \n             if Phase = 1 then\n                --  Allocate the cache\n+\n                Cache   := new Search_Array (1 .. Nbr_Symbols);\n                C.Cache := Cache;\n             end if;\n          end loop;\n          pragma Assert (Nbr_Symbols = C.Cache'Last);\n       end;\n \n-      --  Sort the cache.\n+      --  Sort the cache\n+\n       Sort_Search_Array (C.Cache.all);\n \n       --  Set line offsets\n+\n       if not C.Has_Debug then\n          return;\n       end if;\n+\n       declare\n          Info_Offset : Offset;\n          Line_Offset : Offset;\n@@ -1285,6 +1521,7 @@ package body System.Dwarf_Lines is\n             exit when not Success;\n \n             --  Read table\n+\n             loop\n                Read_Aranges_Entry (C, Ar_Start, Ar_Len);\n                exit when Ar_Start = 0 and Ar_Len = 0;\n@@ -1293,6 +1530,7 @@ package body System.Dwarf_Lines is\n                Start := uint32 (Ar_Start - C.Low);\n \n                --  Search START in the array\n+\n                First := Cache'First;\n                Last  := Cache'Last;\n                Mid := First;  --  In case of array with one element\n@@ -1307,9 +1545,10 @@ package body System.Dwarf_Lines is\n                   end if;\n                end loop;\n \n-               --  Fill info.\n+               --  Fill info\n \n                --  There can be overlapping symbols\n+\n                while Mid > Cache'First\n                  and then Cache (Mid - 1).First <= Start\n                  and then Cache (Mid - 1).First + Cache (Mid - 1).Size > Start\n@@ -1321,9 +1560,11 @@ package body System.Dwarf_Lines is\n                     and then Start + Len > Cache (Mid).First\n                   then\n                      --  MID is within the bounds\n+\n                      Cache (Mid).Line := uint32 (Line_Offset);\n                   elsif Start + Len <= Cache (Mid).First then\n                      --  Over\n+\n                      exit;\n                   end if;\n                   Mid := Mid + 1;\n@@ -1350,54 +1591,131 @@ package body System.Dwarf_Lines is\n \n       procedure Set_Result (Match : Line_Info_Registers) is\n          Dir_Idx : uint32;\n-         J       : uint32;\n+         Off     : Offset;\n \n          Mod_Time : uint32;\n          pragma Unreferenced (Mod_Time);\n \n          Length : uint32;\n          pragma Unreferenced (Length);\n \n+         Directory_Entry_Format : Entry_Format_Array\n+           renames C.Header.Directory_Entry_Format;\n+\n+         File_Entry_Format : Entry_Format_Array\n+           renames C.Header.File_Name_Entry_Format;\n+\n       begin\n-         Seek (C.Lines, C.Prologue.File_Names_Offset);\n+         Seek (C.Lines, C.Header.File_Names);\n+         Dir_Idx := 0;\n \n-         --  Find the entry\n+         --  Find the entry. Note that, up to DWARF 4, the index is 1-based\n+         --  whereas, in DWARF 5, it is 0-based.\n \n-         J := 0;\n-         loop\n-            J         := J + 1;\n-            File_Name := Read_C_String (C.Lines);\n+         if C.Header.Version <= 4 then\n+            for J in 1 .. Match.File loop\n+               File_Name := Read_C_String (C.Lines);\n \n-            if File_Name (File_Name'First) = ASCII.NUL then\n-               --  End of file list, so incorrect entry\n-               return;\n-            end if;\n+               if File_Name (File_Name'First) = ASCII.NUL then\n+                  --  End of file list, so incorrect entry\n+                  return;\n+               end if;\n \n-            Dir_Idx  := Read_LEB128 (C.Lines);\n-            Mod_Time := Read_LEB128 (C.Lines);\n-            Length   := Read_LEB128 (C.Lines);\n-            exit when J = Match.File;\n-         end loop;\n+               Dir_Idx  := Read_LEB128 (C.Lines);\n+               Mod_Time := Read_LEB128 (C.Lines);\n+               Length   := Read_LEB128 (C.Lines);\n+            end loop;\n+\n+            if Dir_Idx = 0 then\n+               --  No directory\n+\n+               Dir_Name := null;\n+\n+            else\n+               Seek (C.Lines, C.Header.Directories);\n+\n+               for J in 1 .. Dir_Idx loop\n+                  Dir_Name := Read_C_String (C.Lines);\n \n-         if Dir_Idx = 0 then\n-            --  No directory\n-            Dir_Name := null;\n+                  if Dir_Name (Dir_Name'First) = ASCII.NUL then\n+                     --  End of directory list, so ill-formed table\n+\n+                     return;\n+                  end if;\n+               end loop;\n+            end if;\n+\n+         --  DWARF 5\n \n          else\n-            Seek (C.Lines, C.Prologue.Includes_Offset);\n+            for J in 0 .. Match.File loop\n+               for K in 1 .. Integer (C.Header.File_Name_Entry_Format_Count)\n+               loop\n+                  if File_Entry_Format (K).C_Type = DW_LNCT_path then\n+                     case File_Entry_Format (K).Form is\n+                        when DW_FORM_string =>\n+                           File_Name := Read_C_String (C.Lines);\n \n-            J := 0;\n-            loop\n-               J        := J + 1;\n-               Dir_Name := Read_C_String (C.Lines);\n+                        when DW_FORM_line_strp =>\n+                           Read_Section_Offset (C.Lines, Off, C.Header.Is64);\n+                           Seek (C.Line_Str, Off);\n+                           File_Name := Read_C_String (C.Line_Str);\n \n-               if Dir_Name (Dir_Name'First) = ASCII.NUL then\n-                  --  End of directory list, so ill-formed table\n-                  return;\n-               end if;\n+                        when others =>\n+                           raise Dwarf_Error with \"DWARF form not implemented\";\n+                     end case;\n+\n+                  elsif File_Entry_Format (K).C_Type = DW_LNCT_directory_index\n+                  then\n+                     case File_Entry_Format (K).Form is\n+                        when DW_FORM_data1 =>\n+                           Dir_Idx := uint32 (uint8'(Read (C.Lines)));\n+\n+                        when DW_FORM_data2 =>\n+                           Dir_Idx := uint32 (uint16'(Read (C.Lines)));\n+\n+                        when DW_FORM_udata =>\n+                           Dir_Idx := Read_LEB128 (C.Lines);\n \n-               exit when J = Dir_Idx;\n+                        when others =>\n+                           raise Dwarf_Error with \"invalid DWARF\";\n+                     end case;\n \n+                  else\n+                     Skip_Form (C.Lines,\n+                       File_Entry_Format (K).Form,\n+                       C.Header.Is64,\n+                       C.Header.Address_Size);\n+                  end if;\n+               end loop;\n+            end loop;\n+\n+            Seek (C.Lines, C.Header.Directories);\n+\n+            for J in 0 .. Dir_Idx loop\n+               for K in 1 .. Integer (C.Header.Directory_Entry_Format_Count)\n+               loop\n+                  if Directory_Entry_Format (K).C_Type = DW_LNCT_path then\n+                     case Directory_Entry_Format (K).Form is\n+                        when DW_FORM_string =>\n+                           Dir_Name := Read_C_String (C.Lines);\n+\n+                        when DW_FORM_line_strp =>\n+                           Read_Section_Offset (C.Lines, Off, C.Header.Is64);\n+                           Seek (C.Line_Str, Off);\n+                           Dir_Name := Read_C_String (C.Line_Str);\n+\n+                        when others =>\n+                           raise Dwarf_Error with \"DWARF form not implemented\";\n+                     end case;\n+\n+                  else\n+                     Skip_Form (C.Lines,\n+                       Directory_Entry_Format (K).Form,\n+                       C.Header.Is64,\n+                       C.Header.Address_Size);\n+                  end if;\n+               end loop;\n             end loop;\n          end if;\n \n@@ -1414,13 +1732,15 @@ package body System.Dwarf_Lines is\n \n    begin\n       --  Initialize result\n+\n       Dir_Name    := null;\n       File_Name   := null;\n       Subprg_Name := (null, 0);\n       Line_Num    := 0;\n \n+      --  Look up the symbol in the cache\n+\n       if C.Cache /= null then\n-         --  Look in the cache\n          declare\n             Addr_Off         : constant uint32 := uint32 (Addr - C.Low);\n             First, Last, Mid : Natural;\n@@ -1447,12 +1767,13 @@ package body System.Dwarf_Lines is\n                S := Read_Symbol (C.Obj.all, Offset (C.Cache (Mid).Sym));\n                Subprg_Name := Object_Reader.Name (C.Obj.all, S);\n             else\n-               --  Not found\n                return;\n             end if;\n          end;\n+\n+      --  Search for the symbol in the binary\n+\n       else\n-         --  Search symbol\n          S := First_Symbol (C.Obj.all);\n          while S /= Null_Symbol loop\n             if Spans (S, Addr_Int) then\n@@ -1479,15 +1800,15 @@ package body System.Dwarf_Lines is\n       end if;\n \n       Seek (C.Lines, Line_Offset);\n-      C.Next_Prologue := 0;\n+      C.Next_Header := 0;\n       Initialize_State_Machine (C);\n-      Parse_Prologue (C);\n+      Parse_Header (C);\n       Previous_Row.Line := 0;\n \n       --  Advance to the first entry\n \n       loop\n-         Read_And_Execute_Isn (C, Done);\n+         Read_And_Execute_Insn (C, Done);\n \n          if C.Registers.Is_Row then\n             Previous_Row := C.Registers;\n@@ -1499,8 +1820,8 @@ package body System.Dwarf_Lines is\n \n       --  Read the rest of the entries\n \n-      while Tell (C.Lines) < C.Next_Prologue loop\n-         Read_And_Execute_Isn (C, Done);\n+      while Tell (C.Lines) < C.Next_Header loop\n+         Read_And_Execute_Insn (C, Done);\n \n          if C.Registers.Is_Row then\n             if not Previous_Row.End_Sequence\n@@ -1533,6 +1854,7 @@ package body System.Dwarf_Lines is\n             return I - Str'First;\n          end if;\n       end loop;\n+\n       return Str'Last;\n    end String_Length;\n \n@@ -1558,6 +1880,7 @@ package body System.Dwarf_Lines is\n       Subprg_Name : String_Ptr_Len;\n       Line_Num    : Natural;\n       Off         : Natural;\n+\n    begin\n       if not C.Has_Debug then\n          Symbol_Found := False;\n@@ -1657,4 +1980,5 @@ package body System.Dwarf_Lines is\n          Append (Res, ASCII.LF);\n       end loop;\n    end Symbolic_Traceback;\n+\n end System.Dwarf_Lines;"}, {"sha": "132d3e1affacf837db5d5c721b5a443791a9962c", "filename": "gcc/ada/libgnat/s-dwalin.ads", "status": "modified", "additions": 70, "deletions": 54, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb3843bca9a28c28dbc1fafd88c144a43e141df/gcc%2Fada%2Flibgnat%2Fs-dwalin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb3843bca9a28c28dbc1fafd88c144a43e141df/gcc%2Fada%2Flibgnat%2Fs-dwalin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-dwalin.ads?ref=5cb3843bca9a28c28dbc1fafd88c144a43e141df", "patch": "@@ -30,13 +30,10 @@\n ------------------------------------------------------------------------------\n \n --  This package provides routines to read DWARF line number information from\n---  a generic object file with as little overhead as possible. This allows\n---  conversions from PC addresses to human readable source locations.\n+--  a binary file with as little overhead as possible. This allows conversions\n+--  from PC addresses to human-readable source locations.\n --\n---  Objects must be built with debugging information, however only the\n---  .debug_line section of the object file is referenced. In cases where object\n---  size is a consideration it's possible to strip all other .debug sections,\n---  which will decrease the size of the object significantly.\n+--  Files must be compiled with at least minimal debugging information (-g1).\n \n with Ada.Exceptions.Traceback;\n \n@@ -50,11 +47,11 @@ package System.Dwarf_Lines is\n    package SOR renames System.Object_Reader;\n \n    type Dwarf_Context (In_Exception : Boolean := False) is private;\n-   --  Type encapsulation the state of the Dwarf reader. When In_Exception\n-   --  is True we are parsing as part of a exception handler decorator, we do\n-   --  not want an exception to be raised, the parsing is done safely skipping\n-   --  DWARF file that cannot be read or with stripped debug section for\n-   --  example.\n+   --  Type encapsulating the state of the DWARF reader. When In_Exception is\n+   --  True, we are parsing as part of an exception handler decorator so we do\n+   --  not want another exception to be raised and the parsing is done safely,\n+   --  skipping binary files that cannot be read or have been stripped from\n+   --  their debug sections for example.\n \n    procedure Open\n      (File_Name :     String;\n@@ -65,14 +62,13 @@ package System.Dwarf_Lines is\n \n    procedure Set_Load_Address (C : in out Dwarf_Context; Addr : Address);\n    --  Set the load address of a file. This is used to rebase PIE (Position\n-   --  Independant Executable) binaries.\n+   --  Independent Executable) binaries.\n \n    function Is_Inside (C : Dwarf_Context; Addr : Address) return Boolean;\n    pragma Inline (Is_Inside);\n    --  Return true iff a run-time address Addr is within the module\n \n-   function Low_Address (C : Dwarf_Context)\n-      return System.Address;\n+   function Low_Address (C : Dwarf_Context) return System.Address;\n    pragma Inline (Low_Address);\n    --  Return the lowest address of C, accounting for the module load address\n \n@@ -83,7 +79,7 @@ package System.Dwarf_Lines is\n    --  Dump the cache (if present)\n \n    procedure Enable_Cache (C : in out Dwarf_Context);\n-   --  Read symbols information to speed up Symbolic_Traceback.\n+   --  Read symbol information to speed up Symbolic_Traceback.\n \n    procedure Symbolic_Traceback\n      (Cin          :        Dwarf_Context;\n@@ -102,45 +98,64 @@ package System.Dwarf_Lines is\n private\n    --  The following section numbers reference\n \n-   --    \"DWARF Debugging Information Format, Version 3\"\n+   --    \"DWARF Debugging Information Format, Version 5\"\n \n    --  published by the Standards Group, http://freestandards.org.\n \n    --  6.2.2 State Machine Registers\n \n    type Line_Info_Registers is record\n-      Address        : SOR.uint64;\n-      File           : SOR.uint32;\n-      Line           : SOR.uint32;\n-      Column         : SOR.uint32;\n-      Is_Stmt        : Boolean;\n-      Basic_Block    : Boolean;\n-      End_Sequence   : Boolean;\n-      Prologue_End   : Boolean;\n-      Epilogue_Begin : Boolean;\n-      ISA            : SOR.uint32;\n-      Is_Row         : Boolean;\n+      Address            : SOR.uint64;\n+      File               : SOR.uint32;\n+      Line               : SOR.uint32;\n+      Column             : SOR.uint32;\n+      Is_Stmt            : Boolean;\n+      Basic_Block        : Boolean;\n+      End_Sequence       : Boolean;\n+      --  Prologue_End   : Boolean;\n+      --  Epilogue_Begin : Boolean;\n+      --  ISA            : SOR.uint32;\n+      --  Discriminator  : SOR.uint32;  -- DWARF 4/5\n+      Is_Row             : Boolean;     -- local\n    end record;\n \n-   --  6.2.4 The Line Number Program Prologue\n-\n-   MAX_OPCODE_LENGTHS : constant := 256;\n-\n-   type Opcodes_Lengths_Array is\n-     array (SOR.uint32 range 1 .. MAX_OPCODE_LENGTHS) of SOR.uint8;\n-\n-   type Line_Info_Prologue is record\n-      Unit_Length       : SOR.uint32;\n-      Version           : SOR.uint16;\n-      Prologue_Length   : SOR.uint32;\n-      Min_Isn_Length    : SOR.uint8;\n-      Default_Is_Stmt   : SOR.uint8;\n-      Line_Base         : SOR.int8;\n-      Line_Range        : SOR.uint8;\n-      Opcode_Base       : SOR.uint8;\n-      Opcode_Lengths    : Opcodes_Lengths_Array;\n-      Includes_Offset   : SOR.Offset;\n-      File_Names_Offset : SOR.Offset;\n+   --  6.2.4 The Line Number Program Header\n+\n+   MAX_OPCODE : constant := 256;\n+\n+   type Opcode_Length_Array is array (1 .. MAX_OPCODE) of SOR.uint8;\n+\n+   MAX_ENTRY : constant := 5;\n+\n+   type Entry_Format_Pair is record\n+      C_Type : SOR.uint32;\n+      Form   : SOR.uint32;\n+   end record;\n+\n+   type Entry_Format_Array is array (1 .. MAX_ENTRY) of Entry_Format_Pair;\n+\n+   type Line_Info_Header is record\n+      Unit_Length                  : SOR.Offset;\n+      Version                      : SOR.uint16;\n+      Address_Size                 : SOR.uint8;           -- DWARF 5\n+      Segment_Selector_Size        : SOR.uint8;           -- DWARF 5\n+      Header_Length                : SOR.uint32;\n+      Minimum_Insn_Length          : SOR.uint8;\n+      Maximum_Op_Per_Insn          : SOR.uint8;           -- DWARF 4/5\n+      Default_Is_Stmt              : SOR.uint8;\n+      Line_Base                    : SOR.int8;\n+      Line_Range                   : SOR.uint8;\n+      Opcode_Base                  : SOR.uint8;\n+      --  Standard_Opcode_Lengths  : Opcode_Length_Array;\n+      Directory_Entry_Format_Count : SOR.uint8;           -- DWARF 5\n+      Directory_Entry_Format       : Entry_Format_Array;  -- DWARF 5\n+      Directories_Count            : SOR.uint32;          -- DWARF 5\n+      Directories                  : SOR.Offset;\n+      File_Name_Entry_Format_Count : SOR.uint8;           -- DWARF 5\n+      File_Name_Entry_Format       : Entry_Format_Array;  -- DWARF 5\n+      File_Names_Count             : SOR.uint32;          -- DWARF 5\n+      File_Names                   : SOR.Offset;\n+      Is64                         : Boolean;             -- local\n    end record;\n \n    type Search_Entry is record\n@@ -175,15 +190,16 @@ private\n       Cache : Search_Array_Access;\n       --  Quick access to symbol and debug info (when present).\n \n-      Lines   : SOR.Mapped_Stream;\n-      Aranges : SOR.Mapped_Stream;\n-      Info    : SOR.Mapped_Stream;\n-      Abbrev  : SOR.Mapped_Stream;\n-      --  Dwarf line, aranges, info and abbrev sections\n+      Abbrev   : SOR.Mapped_Stream;\n+      Aranges  : SOR.Mapped_Stream;\n+      Info     : SOR.Mapped_Stream;\n+      Lines    : SOR.Mapped_Stream;\n+      Line_Str : SOR.Mapped_Stream;  -- DWARF 5\n+      --  DWARF sections\n \n-      Prologue      : Line_Info_Prologue;\n-      Registers     : Line_Info_Registers;\n-      Next_Prologue : SOR.Offset;\n+      Header      : Line_Info_Header;\n+      Registers   : Line_Info_Registers;\n+      Next_Header : SOR.Offset;\n       --  State for lines\n    end record;\n "}]}