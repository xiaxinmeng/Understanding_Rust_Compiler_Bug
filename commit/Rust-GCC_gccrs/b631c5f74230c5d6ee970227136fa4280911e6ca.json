{"sha": "b631c5f74230c5d6ee970227136fa4280911e6ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYzMWM1Zjc0MjMwYzVkNmVlOTcwMjI3MTM2ZmE0MjgwOTExZTZjYQ==", "commit": {"author": {"name": "Seongbae Park", "email": "seongbae.park@gmail.com", "date": "2007-06-20T18:22:28Z"}, "committer": {"name": "Seongbae Park", "email": "spark@gcc.gnu.org", "date": "2007-06-20T18:22:28Z"}, "message": "dbgcnt.def (global_alloc_at_func, [...]): New counters.\n\n2007-06-20  Seongbae Park  <seongbae.park@gmail.com>\n            Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n\n\t* dbgcnt.def (global_alloc_at_func, global_alloc_at_reg):\n\tNew counters.\n\t* haifa-sched.c (queue_to_ready): Don't requeue next insn\n\tif dbg_cnt (sched_insn) reaches the limit.\n\t(choose_ready): New parameter INSN_PTR and new return value.\n\t(schedule_block): Handle dbg_cnt (sched_insn). Handle\n\tthe new return value from choose_ready.\n\t* global.c (global_aloc): New dbgcnt global_alloc_at_reg.\n\t(rest_of_handle_global_alloc): New global_alloc_at_func.\n\n\n\nCo-Authored-By: Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n\nFrom-SVN: r125891", "tree": {"sha": "e9c9e2e49d61ced79471427422a71dae451a75d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9c9e2e49d61ced79471427422a71dae451a75d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b631c5f74230c5d6ee970227136fa4280911e6ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b631c5f74230c5d6ee970227136fa4280911e6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b631c5f74230c5d6ee970227136fa4280911e6ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b631c5f74230c5d6ee970227136fa4280911e6ca/comments", "author": null, "committer": null, "parents": [{"sha": "3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d9b47dc431c0e8b967f390f28a68fe371d47eb4"}], "stats": {"total": 144, "additions": 108, "deletions": 36}, "files": [{"sha": "e4086f2b0a94daea28a593e9391d76b8623316d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b631c5f74230c5d6ee970227136fa4280911e6ca", "patch": "@@ -1,3 +1,16 @@\n+2007-06-20  Seongbae Park  <seongbae.park@gmail.com>\n+            Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n+\n+\t* dbgcnt.def (global_alloc_at_func, global_alloc_at_reg):\n+\tNew counters.\n+\t* haifa-sched.c (queue_to_ready): Don't requeue next insn\n+\tif dbg_cnt (sched_insn) reaches the limit.\n+\t(choose_ready): New parameter INSN_PTR and new return value.\n+\t(schedule_block): Handle dbg_cnt (sched_insn). Handle\n+\tthe new return value from choose_ready.\n+\t* global.c (global_aloc): New dbgcnt global_alloc_at_reg.\n+\t(rest_of_handle_global_alloc): New global_alloc_at_func.\n+\n 2007-06-20  Adam Nemet  <anemet@caviumnetworks.com>\n \n \tPR tree-optimization/25737"}, {"sha": "ee9e32066ade20d4126bebe1093a0a4c5aba2c8e", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=b631c5f74230c5d6ee970227136fa4280911e6ca", "patch": "@@ -82,3 +82,5 @@ DEBUG_COUNTER (sched_insn)\n DEBUG_COUNTER (sched_region)\n DEBUG_COUNTER (split_for_sched2)\n DEBUG_COUNTER (tail_call)\n+DEBUG_COUNTER (global_alloc_at_func)\n+DEBUG_COUNTER (global_alloc_at_reg)"}, {"sha": "fc2a4543f79958df8e77f4d3bd929e57e10bd11c", "filename": "gcc/global.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b631c5f74230c5d6ee970227136fa4280911e6ca", "patch": "@@ -41,6 +41,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"vecprim.h\"\n+#include \"dbgcnt.h\"\n \n /* This pass of the compiler performs global register allocation.\n    It assigns hard register numbers to all the pseudo registers\n@@ -653,6 +654,8 @@ global_alloc (void)\n \tif (reg_renumber[allocno[allocno_order[i]].reg] < 0\n \t    && REG_LIVE_LENGTH (allocno[allocno_order[i]].reg) >= 0)\n \t  {\n+            if (!dbg_cnt (global_alloc_at_reg))\n+              break;\n \t    /* If we have more than one register class,\n \t       first try allocating in the class that is cheapest\n \t       for this pseudo-reg.  If that fails, try any reg.  */\n@@ -2049,7 +2052,7 @@ rest_of_handle_global_alloc (void)\n \n   /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n      pass fixing up any insns that are invalid.  */\n-  if (optimize)\n+  if (optimize && dbg_cnt (global_alloc_at_func))\n     failure = global_alloc ();\n   else\n     {"}, {"sha": "bf017e8849548d15989e619176b37d73354bb1d0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 89, "deletions": 35, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631c5f74230c5d6ee970227136fa4280911e6ca/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b631c5f74230c5d6ee970227136fa4280911e6ca", "patch": "@@ -539,7 +539,7 @@ static rtx ready_remove (struct ready_list *, int);\n static void ready_remove_insn (rtx);\n static int max_issue (struct ready_list *, int *, int);\n \n-static rtx choose_ready (struct ready_list *);\n+static int choose_ready (struct ready_list *, rtx *);\n \n static void fix_inter_tick (rtx, rtx);\n static int fix_tick_ready (rtx);\n@@ -1483,9 +1483,17 @@ queue_to_ready (struct ready_list *ready)\n {\n   rtx insn;\n   rtx link;\n+  rtx skip_insn;\n \n   q_ptr = NEXT_Q (q_ptr);\n \n+  if (dbg_cnt (sched_insn) == false)\n+    /* If debug counter is activated do not requeue insn next after\n+       last_scheduled_insn.  */\n+    skip_insn = next_nonnote_insn (last_scheduled_insn);\n+  else\n+    skip_insn = NULL_RTX;\n+\n   /* Add all pending insns that can be scheduled without stalls to the\n      ready list.  */\n   for (link = insn_queue[q_ptr]; link; link = XEXP (link, 1))\n@@ -1501,7 +1509,8 @@ queue_to_ready (struct ready_list *ready)\n \t See the comment in schedule_block for the rationale.  */\n       if (!reload_completed\n \t  && ready->n_ready > MAX_SCHED_READY_INSNS\n-\t  && !SCHED_GROUP_P (insn))\n+\t  && !SCHED_GROUP_P (insn)\n+\t  && insn != skip_insn)\n \t{\n \t  if (sched_verbose >= 2)\n \t    fprintf (sched_dump, \"requeued because ready full\\n\");\n@@ -1980,17 +1989,43 @@ max_issue (struct ready_list *ready, int *index, int max_points)\n \n /* The following function chooses insn from READY and modifies\n    *N_READY and READY.  The following function is used only for first\n-   cycle multipass scheduling.  */\n-\n-static rtx\n-choose_ready (struct ready_list *ready)\n+   cycle multipass scheduling.\n+   Return:\n+   -1 if cycle should be advanced,\n+   0 if INSN_PTR is set to point to the desirable insn,\n+   1 if choose_ready () should be restarted without advancing the cycle.  */\n+static int\n+choose_ready (struct ready_list *ready, rtx *insn_ptr)\n {\n-  int lookahead = 0;\n+  int lookahead;\n+\n+  if (dbg_cnt (sched_insn) == false)\n+    {\n+      rtx insn;\n+\n+      insn = next_nonnote_insn (last_scheduled_insn);\n+\n+      if (QUEUE_INDEX (insn) == QUEUE_READY)\n+\t/* INSN is in the ready_list.  */\n+\t{\n+\t  ready_remove_insn (insn);\n+\t  *insn_ptr = insn;\n+\t  return 0;\n+\t}\n+\n+      /* INSN is in the queue.  Advance cycle to move it to the ready list.  */\n+      return -1;\n+    }\n+\n+  lookahead = 0;\n \n   if (targetm.sched.first_cycle_multipass_dfa_lookahead)\n     lookahead = targetm.sched.first_cycle_multipass_dfa_lookahead ();\n   if (lookahead <= 0 || SCHED_GROUP_P (ready_element (ready, 0)))\n-    return ready_remove_first (ready);\n+    {\n+      *insn_ptr = ready_remove_first (ready);\n+      return 0;\n+    }\n   else\n     {\n       /* Try to choose the better insn.  */\n@@ -2007,7 +2042,10 @@ choose_ready (struct ready_list *ready)\n \t}\n       insn = ready_element (ready, 0);\n       if (INSN_CODE (insn) < 0)\n-\treturn ready_remove_first (ready);\n+\t{\n+\t  *insn_ptr = ready_remove_first (ready);\n+\t  return 0;\n+\t}\n \n       if (spec_info\n \t  && spec_info->flags & (PREFER_NON_DATA_SPEC\n@@ -2049,7 +2087,7 @@ choose_ready (struct ready_list *ready)\n \t   list.  */\n \t{\n \t  change_queue_index (insn, 1);\n-\t  return 0;\n+\t  return 1;\n \t}\n \n       max_points = ISSUE_POINTS (insn);\n@@ -2071,9 +2109,15 @@ choose_ready (struct ready_list *ready)\n \t}\n \n       if (max_issue (ready, &index, max_points) == 0)\n-\treturn ready_remove_first (ready);\n+\t{\n+\t  *insn_ptr = ready_remove_first (ready);\n+\t  return 0;\n+\t}\n       else\n-\treturn ready_remove (ready, index);\n+\t{\n+\t  *insn_ptr = ready_remove (ready, index);\n+\t  return 0;\n+\t}\n     }\n }\n \n@@ -2172,9 +2216,27 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n \t\t   \";;\\t\\t before reload => truncated to %d insns\\n\", i);\n \t}\n \n-      /* Delay all insns past it for 1 cycle.  */\n-      while (i < ready.n_ready)\n-\tqueue_insn (ready_remove (&ready, i), 1);\n+      /* Delay all insns past it for 1 cycle.  If debug counter is\n+\t activated make an exception for the insn right after\n+\t last_scheduled_insn.  */\n+      {\n+\trtx skip_insn;\n+\n+\tif (dbg_cnt (sched_insn) == false)\n+\t  skip_insn = next_nonnote_insn (last_scheduled_insn);\n+\telse\n+\t  skip_insn = NULL_RTX;\n+\n+\twhile (i < ready.n_ready)\n+\t  {\n+\t    rtx insn;\n+\n+\t    insn = ready_remove (&ready, i);\n+\n+\t    if (insn != skip_insn)\n+\t      queue_insn (insn, 1);\n+\t  }\n+      }\n     }\n \n   /* Now we can restore basic block notes and maintain precise cfg.  */\n@@ -2271,29 +2333,22 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n \t      || !(*current_sched_info->schedule_more_p) ())\n \t    break;\n \n-          if (dbg_cnt (sched_insn) == false)\n-            {\n-              insn = NEXT_INSN (last_scheduled_insn); \n-              while ((*current_sched_info->schedule_more_p) ())\n-                {\n-                  (*current_sched_info->begin_schedule_ready) (insn,\n-                                                               last_scheduled_insn);\n-                  if (QUEUE_INDEX (insn) >= 0)\n-                    queue_remove (insn);\n-                  last_scheduled_insn = insn;\n-                  insn = NEXT_INSN (insn);\n-                }\n-              while (ready.n_ready)\n-                ready_remove_first (&ready);\n-              goto bail_out;\n-            }\n-\n \t  /* Select and remove the insn from the ready list.  */\n \t  if (sort_p)\n \t    {\n-\t      insn = choose_ready (&ready);\n-\t      if (!insn)\n+\t      int res;\n+\n+\t      insn = NULL_RTX;\n+\t      res = choose_ready (&ready, &insn);\n+\n+\t      if (res < 0)\n+\t\t/* Finish cycle.  */\n+\t\tbreak;\n+\t      if (res > 0)\n+\t\t/* Restart choose_ready ().  */\n \t\tcontinue;\n+\n+\t      gcc_assert (insn != NULL_RTX);\n \t    }\n \t  else\n \t    insn = ready_remove_first (&ready);\n@@ -2445,7 +2500,6 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n \t}\n     }\n \n-bail_out:\n   /* Debug info.  */\n   if (sched_verbose)\n     {"}]}