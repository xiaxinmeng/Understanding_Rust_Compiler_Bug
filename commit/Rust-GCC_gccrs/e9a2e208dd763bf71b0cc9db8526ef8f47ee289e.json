{"sha": "e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlhMmUyMDhkZDc2M2JmNzFiMGNjOWRiODUyNmVmOGY0N2VlMjg5ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-02T16:29:58Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-02T16:56:38Z"}, "message": "cpplib:  Macro use location and comparison\n\nOur macro use hook passes a location, but doesn't recieve it from the\nusing location.  This patch adds the extra location_t parameter and\npasses it though.\n\nA second cleanup is breaking out the macro comparison code from the\nredefinition warning.  That;ll turn out useful for modules.\n\nFinally, there's a filename comparison needed for the location\noptimization of rewinding from line 2 (occurs during the emission of\nbuiltin macros).\n\n\tlibcpp/\n\t* internal.h (_cpp_notify_macro_use): Add location parm.\n\t(_cpp_maybe_notify_macro_use): Likewise.\n\t* directives.c (_cpp_do_file_change): Check we've not changed file\n\twhen optimizing a rewind.\n\t(do_ifdef): Pass location to _cpp_maybe_notify_macro_use.\n\t(do_ifndef): Likewise.  Delete obsolete comment about powerpc.\n\t* expr.c (parse_defined): Pass location to\n\t_cpp_maybe_notify_macro_use.\n\t* macro.c (enter_macro_context): Likewise.\n\t(warn_of_redefinition): Break out helper function.  Call it.\n\t(compare_macros): New function broken out of warn_of_redefinition.\n\t(_cpp_new_macro): Zero all fields.\n\t(_cpp_notify_macro_use): Add location parameter.", "tree": {"sha": "0d5f2dd77fcc92b927b3b4bbfb97f8cac4cb9a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d5f2dd77fcc92b927b3b4bbfb97f8cac4cb9a92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c689b827c6a0a5e164f22865696a94e6d7ec308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c689b827c6a0a5e164f22865696a94e6d7ec308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c689b827c6a0a5e164f22865696a94e6d7ec308"}], "stats": {"total": 45, "additions": 30, "deletions": 15}, "files": [{"sha": "d7b59aae90149e10843f6f2f8bc3d9e8eb87ed56", "filename": "libcpp/directives.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "patch": "@@ -1134,6 +1134,7 @@ _cpp_do_file_change (cpp_reader *pfile, enum lc_reason reason,\n          preprocessed source.  */\n       line_map_ordinary *last = LINEMAPS_LAST_ORDINARY_MAP (pfile->line_table);\n       if (!ORDINARY_MAP_STARTING_LINE_NUMBER (last)\n+\t  && 0 == filename_cmp (to_file, ORDINARY_MAP_FILE_NAME (last))\n \t  && SOURCE_LINE (last, pfile->line_table->highest_line) == 2)\n \t{\n \t  ord_map = last;\n@@ -1981,7 +1982,7 @@ do_ifdef (cpp_reader *pfile)\n \t{\n \t  skip = !_cpp_defined_macro_p (node);\n \t  _cpp_mark_macro_used (node);\n-\t  _cpp_maybe_notify_macro_use (pfile, node);\n+\t  _cpp_maybe_notify_macro_use (pfile, node, pfile->directive_line);\n \t  if (pfile->cb.used)\n \t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t  check_eol (pfile, false);\n@@ -2004,13 +2005,9 @@ do_ifndef (cpp_reader *pfile)\n \n       if (node)\n \t{\n-\t  /* Do not treat conditional macros as being defined.  This is due to\n-\t     the powerpc port using conditional macros for 'vector', 'bool',\n-\t     and 'pixel' to act as conditional keywords.  This messes up tests\n-\t     like #ifndef bool.  */\n \t  skip = _cpp_defined_macro_p (node);\n \t  _cpp_mark_macro_used (node);\n-\t  _cpp_maybe_notify_macro_use (pfile, node);\n+\t  _cpp_maybe_notify_macro_use (pfile, node, pfile->directive_line);\n \t  if (pfile->cb.used)\n \t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t  check_eol (pfile, false);"}, {"sha": "e01a47a8c34cb58dda56183f528844112a534cf1", "filename": "libcpp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "patch": "@@ -1070,7 +1070,7 @@ parse_defined (cpp_reader *pfile)\n \t\t        \"this use of \\\"defined\\\" may not be portable\");\n \n       _cpp_mark_macro_used (node);\n-      _cpp_maybe_notify_macro_use (pfile, node);\n+      _cpp_maybe_notify_macro_use (pfile, node, token->src_loc);\n \n       /* A possible controlling macro of the form #if !defined ().\n \t _cpp_parse_expr checks there was no other junk on the line.  */"}, {"sha": "4759961a33a57f2d76573688653950dff87e3a6e", "filename": "libcpp/internal.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "patch": "@@ -649,11 +649,13 @@ inline bool _cpp_defined_macro_p (cpp_hashnode *node)\n }\n \n /* In macro.c */\n-extern void _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node);\n-inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n+extern void _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t\t\t   location_t loc);\n+inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t\t\t\t location_t loc)\n {\n   if (!(node->flags & NODE_USED))\n-    _cpp_notify_macro_use (pfile, node);\n+    _cpp_notify_macro_use (pfile, node, loc);\n }\n extern cpp_macro *_cpp_new_macro (cpp_reader *, cpp_macro_kind, void *);\n extern void _cpp_free_definition (cpp_hashnode *);"}, {"sha": "e304f67c2e06f5b1c9f192861038ad200090d980", "filename": "libcpp/macro.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9a2e208dd763bf71b0cc9db8526ef8f47ee289e/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=e9a2e208dd763bf71b0cc9db8526ef8f47ee289e", "patch": "@@ -340,6 +340,8 @@ static cpp_macro *create_iso_definition (cpp_reader *);\n static cpp_macro *lex_expansion_token (cpp_reader *, cpp_macro *);\n static bool warn_of_redefinition (cpp_reader *, cpp_hashnode *,\n \t\t\t\t  const cpp_macro *);\n+static bool compare_macros (const cpp_macro *, const cpp_macro *);\n+\n static bool parse_params (cpp_reader *, unsigned *, bool *);\n static void check_trad_stringification (cpp_reader *, const cpp_macro *,\n \t\t\t\t\tconst cpp_string *);\n@@ -1433,7 +1435,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \n       /* Laziness can only affect the expansion tokens of the macro,\n \t not its fun-likeness or parameters.  */\n-      _cpp_maybe_notify_macro_use (pfile, node);\n+      _cpp_maybe_notify_macro_use (pfile, node, location);\n       if (pfile->cb.used)\n \tpfile->cb.used (pfile, location, node);\n \n@@ -3111,6 +3113,14 @@ warn_of_redefinition (cpp_reader *pfile, cpp_hashnode *node,\n       macro1->lazy = 0;\n     }\n \n+  return compare_macros (macro1, macro2);\n+}\n+\n+/* Return TRUE if MACRO1 and MACRO2 differ.  */\n+\n+static bool\n+compare_macros (const cpp_macro *macro1, const cpp_macro *macro2)\n+{\n   /* Redefinition of a macro is allowed if and only if the old and new\n      definitions are the same.  (6.10.3 paragraph 2).  */\n \n@@ -3579,6 +3589,10 @@ _cpp_new_macro (cpp_reader *pfile, cpp_macro_kind kind, void *placement)\n {\n   cpp_macro *macro = (cpp_macro *) placement;\n \n+  /* Zero init all the fields.  This'll tell the compiler know all the\n+     following inits are writing a virgin object.  */\n+  memset (macro, 0, offsetof (cpp_macro, exp));\n+\n   macro->line = pfile->directive_line;\n   macro->parm.params = 0;\n   macro->lazy = 0;\n@@ -3665,10 +3679,12 @@ cpp_define_lazily (cpp_reader *pfile, cpp_hashnode *node, unsigned num)\n }\n \n /* Notify the use of NODE in a macro-aware context (i.e. expanding it,\n-   or testing its existance).  Also applies any lazy definition.  */\n+   or testing its existance).  Also applies any lazy definition.\n+   Return FALSE if the macro isn't really there.  */\n \n extern void\n-_cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n+_cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t       location_t loc)\n {\n   node->flags |= NODE_USED;\n   switch (node->type)\n@@ -3686,12 +3702,12 @@ _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n \n     case NT_BUILTIN_MACRO:\n       if (pfile->cb.used_define)\n-\tpfile->cb.used_define (pfile, pfile->directive_line, node);\n+\tpfile->cb.used_define (pfile, loc, node);\n       break;\n \n     case NT_VOID:\n       if (pfile->cb.used_undef)\n-\tpfile->cb.used_undef (pfile, pfile->directive_line, node);\n+\tpfile->cb.used_undef (pfile, loc, node);\n       break;\n \n     default:"}]}