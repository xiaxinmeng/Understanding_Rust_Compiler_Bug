{"sha": "d36dba07390dd63b6ac1a8b531cc6864605c56eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM2ZGJhMDczOTBkZDYzYjZhYzFhOGI1MzFjYzY4NjQ2MDVjNTZlYg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-08T22:38:04Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-08T22:38:04Z"}, "message": "In gcc/objc/: 2010-11-08 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_add_dynamic_declaration_for_property): Do not\n        search for the @property declation only in the current context,\n        but also in inherited properties.  Do not mark the original\n        PROPERTY_DECL in the @interface or @protocol with\n        PROPERTY_DYNAMIC.\n        (check_methods): To check if a method is associated with a\n        @dynamic property, search for the property in IMPL_PROPERTY_DECL.\n        (check_accessible_methods): Same change.\n        * objc-act.h: Updated comment.\n\nIn gcc/testsuite/:\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/dynamic-4.m: New.\n        * objc.dg/property/dynamic-5.m: New.\n        * objc.dg/property/dynamic-6.m: New.    \n        * obj-c++.dg/property/dynamic-4.mm: New.\n        * obj-c++.dg/property/dynamic-5.mm: New.\n        * obj-c++.dg/property/dynamic-6.mm: New.\n\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/dotsyntax-13.m: New.\n        * objc.dg/property/dotsyntax-14.m: New.\n        * objc.dg/property/dotsyntax-15.m: New. \n        * objc.dg/property/synthesize-7.m: New.\n        * obj-c++.dg/property/dotsyntax-13.mm: New.\n        * obj-c++.dg/property/dotsyntax-14.mm: New.\n        * obj-c++.dg/property/dotsyntax-15.mm: New.     \n        * obj-c++.dg/property/synthesize-7.mm: New.\n\nFrom-SVN: r166457", "tree": {"sha": "6d9394924935e5c8e58b7b3ad2e852031f2886e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d9394924935e5c8e58b7b3ad2e852031f2886e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d36dba07390dd63b6ac1a8b531cc6864605c56eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d36dba07390dd63b6ac1a8b531cc6864605c56eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d36dba07390dd63b6ac1a8b531cc6864605c56eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d36dba07390dd63b6ac1a8b531cc6864605c56eb/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4741888d0321172ac91ee71c6a035d1048b49f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4741888d0321172ac91ee71c6a035d1048b49f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4741888d0321172ac91ee71c6a035d1048b49f39"}], "stats": {"total": 927, "additions": 902, "deletions": 25}, "files": [{"sha": "8fec03f9fc7a71cc7fa1dd985abf15fe040a5766", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -1,3 +1,15 @@\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_add_dynamic_declaration_for_property): Do not\n+\tsearch for the @property declation only in the current context,\n+\tbut also in inherited properties.  Do not mark the original\n+\tPROPERTY_DECL in the @interface or @protocol with\n+\tPROPERTY_DYNAMIC.\n+\t(check_methods): To check if a method is associated with a\n+\t@dynamic property, search for the property in IMPL_PROPERTY_DECL.\n+\t(check_accessible_methods): Same change.\n+\t* objc-act.h: Updated comment.\n+\n 2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_add_synthesize_declaration_for_property):"}, {"sha": "eee98e40ac64b09253cb5c91d96197baf9219689", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -8738,9 +8738,19 @@ check_methods (tree chain, tree implementation, int mtype)\n     {\n       /* If the method is associated with a dynamic property, then it\n \t is Ok not to have the method implementation, as it will be\n-\t generated dynamically at runtime.  */\n-      tree property = METHOD_PROPERTY_CONTEXT (chain);\n-      if (property != NULL_TREE && PROPERTY_DYNAMIC (property))\n+\t generated dynamically at runtime.  To decide if the method is\n+\t associated with a @dynamic property, we search the list of\n+\t @synthesize and @dynamic for this implementation, and look\n+\t for any @dynamic property with the same setter or getter name\n+\t as this method.  */\n+      tree x;\n+      for (x = IMPL_PROPERTY_DECL (implementation); x; x = TREE_CHAIN (x))\n+\tif (PROPERTY_DYNAMIC (x)\n+\t    && (PROPERTY_GETTER_NAME (x) == METHOD_SEL_NAME (chain)\n+\t\t|| PROPERTY_SETTER_NAME (x) == METHOD_SEL_NAME (chain)))\n+\t  break;\n+      \n+      if (x != NULL_TREE)\n \t{\n \t  chain = TREE_CHAIN (chain); /* next method...  */\n \t  continue;\n@@ -8751,6 +8761,7 @@ check_methods (tree chain, tree implementation, int mtype)\n \t  /* If the method is a property setter/getter, we'll still\n \t     allow it to be missing if it is implemented by\n \t     'interface' or any of its superclasses.  */\n+\t  tree property = METHOD_PROPERTY_CONTEXT (chain);\n \t  if (property)\n \t    {\n \t      /* Note that since this is a property getter/setter, it\n@@ -8864,13 +8875,21 @@ check_methods_accessible (tree chain, tree context, int mtype)\n     {\n       /* If the method is associated with a dynamic property, then it\n \t is Ok not to have the method implementation, as it will be\n-\t generated dynamically at runtime.  */\n-      tree property = METHOD_PROPERTY_CONTEXT (chain);\n-      if (property != NULL_TREE  &&  PROPERTY_DYNAMIC (property))\n+\t generated dynamically at runtime.  Search for any @dynamic\n+\t property with the same setter or getter name as this\n+\t method.  TODO: Use a hashtable lookup.  */\n+      tree x;\n+      for (x = IMPL_PROPERTY_DECL (base_context); x; x = TREE_CHAIN (x))\n+\tif (PROPERTY_DYNAMIC (x)\n+\t    && (PROPERTY_GETTER_NAME (x) == METHOD_SEL_NAME (chain)\n+\t\t|| PROPERTY_SETTER_NAME (x) == METHOD_SEL_NAME (chain)))\n+\t  break;\n+      \n+      if (x != NULL_TREE)\n \t{\n \t  chain = TREE_CHAIN (chain); /* next method...  */\n \t  continue;\n-\t}\n+\t}\t\n \n       context = base_context;\n       while (context)\n@@ -9910,11 +9929,9 @@ objc_add_dynamic_declaration_for_property (location_t location, tree interface,\n \treturn;\n       }\n \n-  /* Check that the property is declared in the corresponding\n-     interface.  */\n-  for (property = CLASS_PROPERTY_DECL (interface); property; property = TREE_CHAIN (property))\n-    if (PROPERTY_NAME (property) == property_name)\n-      break;\n+  /* Check that the property is declared in the interface.  It could\n+     also be declared in a superclass or protocol.  */\n+  property = lookup_property (interface, property_name);\n \n   if (!property)\n     {\n@@ -9924,17 +9941,6 @@ objc_add_dynamic_declaration_for_property (location_t location, tree interface,\n     }\n   else\n     {\n-      /* Mark the original PROPERTY_DECL as dynamic.  The reason is\n-\t that the setter and getter methods in the interface have a\n-\t METHOD_PROPERTY_CONTEXT that points to the original\n-\t PROPERTY_DECL; when we check that these methods have been\n-\t implemented, we need to easily find that they are associated\n-\t with a dynamic property.  TODO: Remove this hack; it will not\n-\t work with properties in a protocol that may be implemented by\n-\t different classes and be @dynamic in some, and non-@dynamic\n-\t in other ones.  */\n-      PROPERTY_DYNAMIC (property) = 1;\n-\n       /* We have to copy the property, because we want to chain it to\n \t the implementation context, and we want to store the source\n \t location of the @synthesize, not of the original"}, {"sha": "276b33f5ec3c4c93b45d975c11fda6f0aad39a95", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -100,8 +100,7 @@ typedef enum objc_property_assign_semantics {\n #define PROPERTY_IVAR_NAME(DECL) ((DECL)->decl_common.initial)\n \n /* PROPERTY_DYNAMIC can be 0 or 1.  This is 1 if the PROPERTY_DECL\n-   represents a @dynamic (or if it is a @property for which a @dynamic\n-   declaration has been parsed); otherwise, it is set to 0.  */\n+   represents a @dynamic; otherwise, it is set to 0.  */\n #define PROPERTY_DYNAMIC(DECL) DECL_LANG_FLAG_2 (DECL)\n \n /* PROPERTY_HAS_NO_GETTER can be 0 or 1.  Normally it is 0, but if"}, {"sha": "c9be34d42f51c50218deeb9c41618dd2064e4f65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -1,3 +1,23 @@\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/dotsyntax-13.m: New.\n+\t* objc.dg/property/dotsyntax-14.m: New.\n+\t* objc.dg/property/dotsyntax-15.m: New.\t\n+\t* objc.dg/property/synthesize-7.m: New.\n+\t* obj-c++.dg/property/dotsyntax-13.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-14.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-15.mm: New.\t\n+\t* obj-c++.dg/property/synthesize-7.mm: New.\n+\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/dynamic-4.m: New.\n+\t* objc.dg/property/dynamic-5.m: New.\n+\t* objc.dg/property/dynamic-6.m: New.\t\n+\t* obj-c++.dg/property/dynamic-4.mm: New.\n+\t* obj-c++.dg/property/dynamic-5.mm: New.\n+\t* obj-c++.dg/property/dynamic-6.mm: New.\n+\n 2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/property/synthesize-3.m: New."}, {"sha": "c5a4b3301e3d95429f5d2762bc7154ce9cc6636d", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-13.mm", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-13.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-13.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-13.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,53 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with a local variable.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    {\n+      object.count = i;\n+      \n+      if (object.count != i)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "efa60ed99c18024845f6eae0918a1e3eb6083b6a", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-14.mm", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-14.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-14.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-14.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,77 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test dot-syntax with accessors to be looked up in protocol @properties.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@protocol ProtocolA\n+@property int countA;\n+@end\n+\n+@protocol ProtocolB\n+@property int countB;\n+@end\n+\n+@protocol ProtocolC\n+@property int countC;\n+@end\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@interface MySubClass <ProtocolA, ProtocolB, ProtocolC>\n+@end\n+\n+int function (MySubClass *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function2 (MyRootClass <ProtocolA, ProtocolB, ProtocolC> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function3 (MyRootClass <ProtocolA, ProtocolB> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in\" } */\n+}\n+\n+int function4 (id <ProtocolA, ProtocolB, ProtocolC> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function5 (id <ProtocolA, ProtocolB> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in\" } */\n+}"}, {"sha": "7ddf5300c535e2f2b9c750c8705db4b1edf164b2", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-15.mm", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-15.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-15.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-15.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,80 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test dot-syntax with accessors to be looked up in protocols.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@protocol ProtocolA\n+- (int) countA;\n+- (void) setCountA: (int)aNumber;\n+@end\n+\n+@protocol ProtocolB\n+- (int) countB;\n+- (void) setCountB: (int)aNumber;\n+@end\n+\n+@protocol ProtocolC\n+- (int) countC;\n+- (void) setCountC: (int)aNumber;\n+@end\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@interface MySubClass <ProtocolA, ProtocolB, ProtocolC>\n+@end\n+\n+int function (MySubClass *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function2 (MyRootClass <ProtocolA, ProtocolB, ProtocolC> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function3 (MyRootClass <ProtocolA, ProtocolB> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in\" } */\n+}\n+\n+int function4 (id <ProtocolA, ProtocolB, ProtocolC> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function5 (id <ProtocolA, ProtocolB> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in\" } */\n+}"}, {"sha": "84998d6b407656751f0cc93c091c1fc636d5e563", "filename": "gcc/testsuite/obj-c++.dg/property/dynamic-4.mm", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-4.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,45 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyRootClass\n+@end\n+\n+/* Test @property/@dynamic with protocols.  */\n+\n+@protocol MyProtocol\n+@property int a;\n+@end\n+\n+\n+/* This class is declared to conform to the protocol, but because of\n+   @dynamic, no warnings are issued even if the getter/setter for the\n+   @property are missing.  */\n+@interface MyClass1 : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MyClass1\n+@dynamic a;\n+@end\n+\n+\n+/* This class is declared to conform to the protocol and warnings are\n+   issued because the setter for the @property is missing.  */\n+@interface MyClass2 : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MyClass2\n+- (int) a\n+{\n+  return 0;\n+}\n+@end /* { dg-warning \"incomplete implementation\" } */\n+/* { dg-warning \"method definition for .-setA:. not found\" \"\" { target *-*-* } 43 } */\n+/* { dg-warning \"class .MyClass2. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 43 } */"}, {"sha": "77e81411aae4843d097eab8e2fed086cd936672b", "filename": "gcc/testsuite/obj-c++.dg/property/dynamic-5.mm", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-5.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,53 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @dynamic in the real scenario where a class declares a\n+   @property, uses @dynamic to avoid implementing it, then subclasses\n+   implement it.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@dynamic a;\n+@end\n+\n+@interface Test : MyRootClass\n+{\n+  int v1;\n+}\n+@end\n+\n+@implementation Test\n+@synthesize a = v1;\n+@end\n+\n+int main (void)\n+{\n+  /* Note how 'object' is declared to be of class 'MyRootClass', but\n+     actually is of the subclass which implements the property for\n+     real.  */\n+  MyRootClass *object = [[Test alloc] init];\n+\n+  object.a = 40;\n+\n+  if (object.a != 40)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "23a7a890582dc43154d369dcb23bdfe8218ade88", "filename": "gcc/testsuite/obj-c++.dg/property/dynamic-6.mm", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-6.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-6.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdynamic-6.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,26 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test case when an accessor from a @property matches a method\n+   required by a protocol.  If the @property is @dynamic, then no\n+   warning should be generated.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@protocol Count\n+- (int) count;\n+@end\n+\n+@interface MyRootClass <Count>\n+{\n+  Class isa;\n+}\n+@property int count;\n+@end\n+\n+@implementation MyRootClass\n+/* This @dynamic turns off any warnings for -count and -setCount:.  */\n+@dynamic count;\n+@end"}, {"sha": "929e3803bf95215853eb29e481e1f8e0003104cc", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-7.mm", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-7.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-7.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-7.mm?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,86 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @synthesize with protocols of protocols.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@protocol ProtocolA\n+@property int countA;\n+@end\n+\n+@protocol ProtocolB <ProtocolA>\n+@property int countB;\n+@end\n+\n+@protocol ProtocolC <ProtocolB>\n+@property int countC;\n+@end\n+\n+@protocol ProtocolD\n+@property int countD;\n+@end\n+\n+@interface MyRootClass <ProtocolC>\n+{\n+  Class isa;\n+  int countA;\n+  int countB;\n+  int countC;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize countA;\n+@synthesize countB;\n+@synthesize countC;\n+@end\n+\n+@interface MySubClass : MyRootClass <ProtocolD>\n+{\n+  int countD;\n+}\n+@end\n+\n+@implementation MySubClass\n+@synthesize countD;\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    {\n+      object.countA += i;\n+      object.countB += i + 1;\n+      object.countC += i + 2;\n+      object.countD += i + 3;\n+    }\n+\n+  if (object.countA != 45)\n+    abort ();\n+\n+  if (object.countB != 55)\n+    abort ();\n+\n+  if (object.countC != 65)\n+    abort ();\n+\n+  if (object.countD != 75)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "c5a4b3301e3d95429f5d2762bc7154ce9cc6636d", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-13.m", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-13.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-13.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-13.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,53 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test dot-syntax with a local variable.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    {\n+      object.count = i;\n+      \n+      if (object.count != i)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "0606ec4a2bbaf01a200f61170f31c339cf23ad49", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-14.m", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-14.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-14.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-14.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,77 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test dot-syntax with accessors to be looked up in protocol @properties.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@protocol ProtocolA\n+@property int countA;\n+@end\n+\n+@protocol ProtocolB\n+@property int countB;\n+@end\n+\n+@protocol ProtocolC\n+@property int countC;\n+@end\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@interface MySubClass <ProtocolA, ProtocolB, ProtocolC>\n+@end\n+\n+int function (MySubClass *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function2 (MyRootClass <ProtocolA, ProtocolB, ProtocolC> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function3 (MyRootClass <ProtocolA, ProtocolB> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+}\n+\n+int function4 (id <ProtocolA, ProtocolB, ProtocolC> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function5 (id <ProtocolA, ProtocolB> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+}"}, {"sha": "767f6a2b88099526f13e6dfbb707da831920b15b", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-15.m", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-15.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-15.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-15.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,80 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test dot-syntax with accessors to be looked up in protocols.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@protocol ProtocolA\n+- (int) countA;\n+- (void) setCountA: (int)aNumber;\n+@end\n+\n+@protocol ProtocolB\n+- (int) countB;\n+- (void) setCountB: (int)aNumber;\n+@end\n+\n+@protocol ProtocolC\n+- (int) countC;\n+- (void) setCountC: (int)aNumber;\n+@end\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@interface MySubClass <ProtocolA, ProtocolB, ProtocolC>\n+@end\n+\n+int function (MySubClass *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function2 (MyRootClass <ProtocolA, ProtocolB, ProtocolC> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function3 (MyRootClass <ProtocolA, ProtocolB> *object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+}\n+\n+int function4 (id <ProtocolA, ProtocolB, ProtocolC> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB;\n+\n+  return object.countC;\n+}\n+\n+int function5 (id <ProtocolA, ProtocolB> object, int x)\n+{\n+  object.countA = x;\n+  object.countB = x;\n+  object.countC = object.countB; /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+\n+  return object.countC;          /* { dg-error \"request for member .countC. in something not a structure or union\" } */\n+}"}, {"sha": "84998d6b407656751f0cc93c091c1fc636d5e563", "filename": "gcc/testsuite/objc.dg/property/dynamic-4.m", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-4.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,45 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@implementation MyRootClass\n+@end\n+\n+/* Test @property/@dynamic with protocols.  */\n+\n+@protocol MyProtocol\n+@property int a;\n+@end\n+\n+\n+/* This class is declared to conform to the protocol, but because of\n+   @dynamic, no warnings are issued even if the getter/setter for the\n+   @property are missing.  */\n+@interface MyClass1 : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MyClass1\n+@dynamic a;\n+@end\n+\n+\n+/* This class is declared to conform to the protocol and warnings are\n+   issued because the setter for the @property is missing.  */\n+@interface MyClass2 : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MyClass2\n+- (int) a\n+{\n+  return 0;\n+}\n+@end /* { dg-warning \"incomplete implementation\" } */\n+/* { dg-warning \"method definition for .-setA:. not found\" \"\" { target *-*-* } 43 } */\n+/* { dg-warning \"class .MyClass2. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 43 } */"}, {"sha": "77e81411aae4843d097eab8e2fed086cd936672b", "filename": "gcc/testsuite/objc.dg/property/dynamic-5.m", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-5.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,53 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @dynamic in the real scenario where a class declares a\n+   @property, uses @dynamic to avoid implementing it, then subclasses\n+   implement it.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property int a;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@dynamic a;\n+@end\n+\n+@interface Test : MyRootClass\n+{\n+  int v1;\n+}\n+@end\n+\n+@implementation Test\n+@synthesize a = v1;\n+@end\n+\n+int main (void)\n+{\n+  /* Note how 'object' is declared to be of class 'MyRootClass', but\n+     actually is of the subclass which implements the property for\n+     real.  */\n+  MyRootClass *object = [[Test alloc] init];\n+\n+  object.a = 40;\n+\n+  if (object.a != 40)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "23a7a890582dc43154d369dcb23bdfe8218ade88", "filename": "gcc/testsuite/objc.dg/property/dynamic-6.m", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdynamic-6.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,26 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test case when an accessor from a @property matches a method\n+   required by a protocol.  If the @property is @dynamic, then no\n+   warning should be generated.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@protocol Count\n+- (int) count;\n+@end\n+\n+@interface MyRootClass <Count>\n+{\n+  Class isa;\n+}\n+@property int count;\n+@end\n+\n+@implementation MyRootClass\n+/* This @dynamic turns off any warnings for -count and -setCount:.  */\n+@dynamic count;\n+@end"}, {"sha": "929e3803bf95215853eb29e481e1f8e0003104cc", "filename": "gcc/testsuite/objc.dg/property/synthesize-7.m", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d36dba07390dd63b6ac1a8b531cc6864605c56eb/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-7.m?ref=d36dba07390dd63b6ac1a8b531cc6864605c56eb", "patch": "@@ -0,0 +1,86 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @synthesize with protocols of protocols.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@protocol ProtocolA\n+@property int countA;\n+@end\n+\n+@protocol ProtocolB <ProtocolA>\n+@property int countB;\n+@end\n+\n+@protocol ProtocolC <ProtocolB>\n+@property int countC;\n+@end\n+\n+@protocol ProtocolD\n+@property int countD;\n+@end\n+\n+@interface MyRootClass <ProtocolC>\n+{\n+  Class isa;\n+  int countA;\n+  int countB;\n+  int countC;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize countA;\n+@synthesize countB;\n+@synthesize countC;\n+@end\n+\n+@interface MySubClass : MyRootClass <ProtocolD>\n+{\n+  int countD;\n+}\n+@end\n+\n+@implementation MySubClass\n+@synthesize countD;\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    {\n+      object.countA += i;\n+      object.countB += i + 1;\n+      object.countC += i + 2;\n+      object.countD += i + 3;\n+    }\n+\n+  if (object.countA != 45)\n+    abort ();\n+\n+  if (object.countB != 55)\n+    abort ();\n+\n+  if (object.countC != 65)\n+    abort ();\n+\n+  if (object.countD != 75)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}]}