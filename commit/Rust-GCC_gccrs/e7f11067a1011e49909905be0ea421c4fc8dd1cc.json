{"sha": "e7f11067a1011e49909905be0ea421c4fc8dd1cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmMTEwNjdhMTAxMWU0OTkwOTkwNWJlMGVhNDIxYzRmYzhkZDFjYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:53:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:53:52Z"}, "message": "[multiple changes]\n\n2013-04-11  Johannes Kanig  <kanig@adacore.com>\n\n\t* debug.adb: Document usage of -gnatd.Q switch.\n\n2013-04-11  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-crbtgk.adb (Ceiling, Find, Floor): Adjust locks\n\tbefore element comparisons.\n\t(Generic_Conditional_Insert, Generic_Conditional_Insert_With_Hint):\n\tDitto.\n\t* a-crbtgo.adb, a-rbtgbo.adb (Generic_Equal): Adjust locks before\n\telement comparisons.\n\t* a-rbtgso.adb (Difference, Intersection): Adjust locks\n\tbefore element comparisons.\n\t(Is_Subset, Overlap): Ditto\n\t(Symmetric_Difference, Union): Ditto\n\t* a-btgbso.adb (Set_Difference, Set_Intersection): Adjust locks\n\tbefore element comparisons.\n\t(Set_Subset, Set_Overlap): Ditto\n\t(Set_Symmetric_Difference, Set_Union): Ditto\n\t* a-coorse.adb, a-ciorse.adb, a-cborse.adb\n\t(Update_Element_Preserving_Key): Adjust locks before element\n\tcomparisons (Replace_Element): Ditto\n\n2013-04-11  Pascal Obry  <obry@adacore.com>\n\n\t* prj-attr.adb, projects.texi, snames.ads-tmpl: Remove Build_Slaves\n\tattribute.\n\n2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Build_Equivalent_Aggregate): Subsidiary of\n\tExpand_N_Object_Declaration, used to construct an aggregate\n\twith static components whenever possible, so that objects of a\n\tdiscriminated type can be initialized without calling the init.\n\tproc for the type.\n\n2013-04-11  Vincent Celier  <celier@adacore.com>\n\n\t* prj-makr.adb (Process_Directory): On VMS, always delete,\n\tthen recreate the temporary file with Create_Output_Text_File,\n\totherwise the output redirection does not work properly.\n\n2013-04-11  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* urealp.ads: Fix minor typo.\n\n2013-04-11  Fabien Chouteau  <chouteau@adacore.com>\n\n\t* cio.c (mktemp): Don't use tmpnam function from the\n\tsystem on VxWorks in kernel mode.\n\nFrom-SVN: r197784", "tree": {"sha": "a26ebfc6e4caf0177dd7ef55f130557b48b5a867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a26ebfc6e4caf0177dd7ef55f130557b48b5a867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f11067a1011e49909905be0ea421c4fc8dd1cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f11067a1011e49909905be0ea421c4fc8dd1cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f11067a1011e49909905be0ea421c4fc8dd1cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f11067a1011e49909905be0ea421c4fc8dd1cc/comments", "author": null, "committer": null, "parents": [{"sha": "e03c52533a83e71475c4975ade1fc5ae96b4be53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03c52533a83e71475c4975ade1fc5ae96b4be53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e03c52533a83e71475c4975ade1fc5ae96b4be53"}], "stats": {"total": 2406, "additions": 1911, "deletions": 495}, "files": [{"sha": "19a47005d3f365fe7c32bc947583aa8b62b16d70", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -1,3 +1,55 @@\n+2013-04-11  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* debug.adb: Document usage of -gnatd.Q switch.\n+\n+2013-04-11  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-crbtgk.adb (Ceiling, Find, Floor): Adjust locks\n+\tbefore element comparisons.\n+\t(Generic_Conditional_Insert, Generic_Conditional_Insert_With_Hint):\n+\tDitto.\n+\t* a-crbtgo.adb, a-rbtgbo.adb (Generic_Equal): Adjust locks before\n+\telement comparisons.\n+\t* a-rbtgso.adb (Difference, Intersection): Adjust locks\n+\tbefore element comparisons.\n+\t(Is_Subset, Overlap): Ditto\n+\t(Symmetric_Difference, Union): Ditto\n+\t* a-btgbso.adb (Set_Difference, Set_Intersection): Adjust locks\n+\tbefore element comparisons.\n+\t(Set_Subset, Set_Overlap): Ditto\n+\t(Set_Symmetric_Difference, Set_Union): Ditto\n+\t* a-coorse.adb, a-ciorse.adb, a-cborse.adb\n+\t(Update_Element_Preserving_Key): Adjust locks before element\n+\tcomparisons (Replace_Element): Ditto\n+\n+2013-04-11  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj-attr.adb, projects.texi, snames.ads-tmpl: Remove Build_Slaves\n+\tattribute.\n+\n+2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Equivalent_Aggregate): Subsidiary of\n+\tExpand_N_Object_Declaration, used to construct an aggregate\n+\twith static components whenever possible, so that objects of a\n+\tdiscriminated type can be initialized without calling the init.\n+\tproc for the type.\n+\n+2013-04-11  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-makr.adb (Process_Directory): On VMS, always delete,\n+\tthen recreate the temporary file with Create_Output_Text_File,\n+\totherwise the output redirection does not work properly.\n+\n+2013-04-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* urealp.ads: Fix minor typo.\n+\n+2013-04-11  Fabien Chouteau  <chouteau@adacore.com>\n+\n+\t* cio.c (mktemp): Don't use tmpnam function from the\n+\tsystem on VxWorks in kernel mode.\n+\n 2013-04-11  Vincent Celier  <celier@adacore.com>\n \n \t* make.adb (Compile): Clarify the error message reported"}, {"sha": "2aef270f64d08bee9e40f03a605ee3f17aa5f0c6", "filename": "gcc/ada/a-btgbso.adb", "status": "modified", "additions": 541, "deletions": 189, "changes": 730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-btgbso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-btgbso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-btgbso.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,11 +53,19 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n    ----------------\n \n    procedure Set_Difference (Target : in out Set_Type; Source : Set_Type) is\n+      BT : Natural renames Target.Busy;\n+      LT : Natural renames Target.Lock;\n+\n+      BS : Natural renames Source'Unrestricted_Access.Busy;\n+      LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n       Tgt, Src : Count_Type;\n \n       TN : Nodes_Type renames Target.Nodes;\n       SN : Nodes_Type renames Source.Nodes;\n \n+      Compare : Integer;\n+\n    begin\n       if Target'Address = Source'Address then\n          if Target.Busy > 0 then\n@@ -82,17 +90,51 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       Src := Source.First;\n       loop\n          if Tgt = 0 then\n-            return;\n+            exit;\n          end if;\n \n          if Src = 0 then\n-            return;\n+            exit;\n          end if;\n \n-         if Is_Less (TN (Tgt), SN (Src)) then\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         begin\n+            BT := BT + 1;\n+            LT := LT + 1;\n+\n+            BS := BS + 1;\n+            LS := LS + 1;\n+\n+            if Is_Less (TN (Tgt), SN (Src)) then\n+               Compare := -1;\n+            elsif Is_Less (SN (Src), TN (Tgt)) then\n+               Compare := 1;\n+            else\n+               Compare := 0;\n+            end if;\n+\n+            BT := BT - 1;\n+            LT := LT - 1;\n+\n+            BS := BS - 1;\n+            LS := LS - 1;\n+         exception\n+            when others =>\n+               BT := BT - 1;\n+               LT := LT - 1;\n+\n+               BS := BS - 1;\n+               LS := LS - 1;\n+\n+               raise;\n+         end;\n+\n+         if Compare < 0 then\n             Tgt := Tree_Operations.Next (Target, Tgt);\n \n-         elsif Is_Less (SN (Src), TN (Tgt)) then\n+         elsif Compare > 0 then\n             Src := Tree_Operations.Next (Source, Src);\n \n          else\n@@ -111,12 +153,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n    end Set_Difference;\n \n    function Set_Difference (Left, Right : Set_Type) return Set_Type is\n-      L_Node : Count_Type;\n-      R_Node : Count_Type;\n-\n-      Dst_Node : Count_Type;\n-      pragma Warnings (Off, Dst_Node);\n-\n    begin\n       if Left'Address = Right'Address then\n          return S : Set_Type (0);  -- Empty set\n@@ -131,44 +167,83 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       end if;\n \n       return Result : Set_Type (Left.Length) do\n-         L_Node := Left.First;\n-         R_Node := Right.First;\n-         loop\n-            if L_Node = 0 then\n-               return;\n-            end if;\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-            if R_Node = 0 then\n-               while L_Node /= 0 loop\n+         declare\n+            BL : Natural renames Left'Unrestricted_Access.Busy;\n+            LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+            BR : Natural renames Right'Unrestricted_Access.Busy;\n+            LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+            L_Node : Count_Type;\n+            R_Node : Count_Type;\n+\n+            Dst_Node : Count_Type;\n+            pragma Warnings (Off, Dst_Node);\n+\n+         begin\n+            BL := BL + 1;\n+            LL := LL + 1;\n+\n+            BR := BR + 1;\n+            LR := LR + 1;\n+\n+            L_Node := Left.First;\n+            R_Node := Right.First;\n+            loop\n+               if L_Node = 0 then\n+                  exit;\n+               end if;\n+\n+               if R_Node = 0 then\n+                  while L_Node /= 0 loop\n+                     Insert_With_Hint\n+                       (Dst_Set  => Result,\n+                        Dst_Hint => 0,\n+                        Src_Node => Left.Nodes (L_Node),\n+                        Dst_Node => Dst_Node);\n+\n+                     L_Node := Tree_Operations.Next (Left, L_Node);\n+                  end loop;\n+\n+                  exit;\n+               end if;\n+\n+               if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n                   Insert_With_Hint\n                     (Dst_Set  => Result,\n                      Dst_Hint => 0,\n                      Src_Node => Left.Nodes (L_Node),\n                      Dst_Node => Dst_Node);\n \n                   L_Node := Tree_Operations.Next (Left, L_Node);\n-               end loop;\n \n-               return;\n-            end if;\n+               elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n \n-            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n-               Insert_With_Hint\n-                 (Dst_Set  => Result,\n-                  Dst_Hint => 0,\n-                  Src_Node => Left.Nodes (L_Node),\n-                  Dst_Node => Dst_Node);\n+               else\n+                  L_Node := Tree_Operations.Next (Left, L_Node);\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n+               end if;\n+            end loop;\n \n-               L_Node := Tree_Operations.Next (Left, L_Node);\n+            BL := BL - 1;\n+            LL := LL - 1;\n \n-            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n-               R_Node := Tree_Operations.Next (Right, R_Node);\n+            BR := BR - 1;\n+            LR := LR - 1;\n+         exception\n+            when others =>\n+               BL := BL - 1;\n+               LL := LL - 1;\n \n-            else\n-               L_Node := Tree_Operations.Next (Left, L_Node);\n-               R_Node := Tree_Operations.Next (Right, R_Node);\n-            end if;\n-         end loop;\n+               BR := BR - 1;\n+               LR := LR - 1;\n+\n+               raise;\n+         end;\n       end return;\n    end Set_Difference;\n \n@@ -180,9 +255,17 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n      (Target : in out Set_Type;\n       Source : Set_Type)\n    is\n+      BT : Natural renames Target.Busy;\n+      LT : Natural renames Target.Lock;\n+\n+      BS : Natural renames Source'Unrestricted_Access.Busy;\n+      LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n       Tgt : Count_Type;\n       Src : Count_Type;\n \n+      Compare : Integer;\n+\n    begin\n       if Target'Address = Source'Address then\n          return;\n@@ -203,7 +286,41 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       while Tgt /= 0\n         and then Src /= 0\n       loop\n-         if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         begin\n+            BT := BT + 1;\n+            LT := LT + 1;\n+\n+            BS := BS + 1;\n+            LS := LS + 1;\n+\n+            if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n+               Compare := -1;\n+            elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n+               Compare := 1;\n+            else\n+               Compare := 0;\n+            end if;\n+\n+            BT := BT - 1;\n+            LT := LT - 1;\n+\n+            BS := BS - 1;\n+            LS := LS - 1;\n+         exception\n+            when others =>\n+               BT := BT - 1;\n+               LT := LT - 1;\n+\n+               BS := BS - 1;\n+               LS := LS - 1;\n+\n+               raise;\n+         end;\n+\n+         if Compare < 0 then\n             declare\n                X : constant Count_Type := Tgt;\n             begin\n@@ -213,7 +330,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n                Tree_Operations.Free (Target, X);\n             end;\n \n-         elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n+         elsif Compare > 0 then\n             Src := Tree_Operations.Next (Source, Src);\n \n          else\n@@ -235,46 +352,80 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n    end Set_Intersection;\n \n    function Set_Intersection (Left, Right : Set_Type) return Set_Type is\n-      L_Node : Count_Type;\n-      R_Node : Count_Type;\n-\n-      Dst_Node : Count_Type;\n-      pragma Warnings (Off, Dst_Node);\n-\n    begin\n       if Left'Address = Right'Address then\n          return Copy (Left);\n       end if;\n \n       return Result : Set_Type (Count_Type'Min (Left.Length, Right.Length)) do\n-         L_Node := Left.First;\n-         R_Node := Right.First;\n-         loop\n-            if L_Node = 0 then\n-               return;\n-            end if;\n \n-            if R_Node = 0 then\n-               return;\n-            end if;\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n-               L_Node := Tree_Operations.Next (Left, L_Node);\n+         declare\n+            BL : Natural renames Left'Unrestricted_Access.Busy;\n+            LL : Natural renames Left'Unrestricted_Access.Lock;\n \n-            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n-               R_Node := Tree_Operations.Next (Right, R_Node);\n+            BR : Natural renames Right'Unrestricted_Access.Busy;\n+            LR : Natural renames Right'Unrestricted_Access.Lock;\n \n-            else\n-               Insert_With_Hint\n-                 (Dst_Set  => Result,\n-                  Dst_Hint => 0,\n-                  Src_Node => Left.Nodes (L_Node),\n-                  Dst_Node => Dst_Node);\n+            L_Node : Count_Type;\n+            R_Node : Count_Type;\n \n-               L_Node := Tree_Operations.Next (Left, L_Node);\n-               R_Node := Tree_Operations.Next (Right, R_Node);\n-            end if;\n-         end loop;\n+            Dst_Node : Count_Type;\n+            pragma Warnings (Off, Dst_Node);\n+\n+         begin\n+            BL := BL + 1;\n+            LL := LL + 1;\n+\n+            BR := BR + 1;\n+            LR := LR + 1;\n+\n+            L_Node := Left.First;\n+            R_Node := Right.First;\n+            loop\n+               if L_Node = 0 then\n+                  exit;\n+               end if;\n+\n+               if R_Node = 0 then\n+                  exit;\n+               end if;\n+\n+               if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+                  L_Node := Tree_Operations.Next (Left, L_Node);\n+\n+               elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n+\n+               else\n+                  Insert_With_Hint\n+                    (Dst_Set  => Result,\n+                     Dst_Hint => 0,\n+                     Src_Node => Left.Nodes (L_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Tree_Operations.Next (Left, L_Node);\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n+               end if;\n+            end loop;\n+\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+         exception\n+            when others =>\n+               BL := BL - 1;\n+               LL := LL - 1;\n+\n+               BR := BR - 1;\n+               LR := LR - 1;\n+\n+               raise;\n+         end;\n       end return;\n    end Set_Intersection;\n \n@@ -286,9 +437,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n      (Subset : Set_Type;\n       Of_Set : Set_Type) return Boolean\n    is\n-      Subset_Node : Count_Type;\n-      Set_Node    : Count_Type;\n-\n    begin\n       if Subset'Address = Of_Set'Address then\n          return True;\n@@ -298,62 +446,148 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          return False;\n       end if;\n \n-      Subset_Node := Subset.First;\n-      Set_Node    := Of_Set.First;\n-      loop\n-         if Set_Node = 0 then\n-            return Subset_Node = 0;\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         if Subset_Node = 0 then\n-            return True;\n-         end if;\n+      declare\n+         BL : Natural renames Subset'Unrestricted_Access.Busy;\n+         LL : Natural renames Subset'Unrestricted_Access.Lock;\n \n-         if Is_Less (Subset.Nodes (Subset_Node), Of_Set.Nodes (Set_Node)) then\n-            return False;\n-         end if;\n+         BR : Natural renames Of_Set'Unrestricted_Access.Busy;\n+         LR : Natural renames Of_Set'Unrestricted_Access.Lock;\n \n-         if Is_Less (Of_Set.Nodes (Set_Node), Subset.Nodes (Subset_Node)) then\n-            Set_Node := Tree_Operations.Next (Of_Set, Set_Node);\n-         else\n-            Set_Node := Tree_Operations.Next (Of_Set, Set_Node);\n-            Subset_Node := Tree_Operations.Next (Subset, Subset_Node);\n-         end if;\n-      end loop;\n+         Subset_Node : Count_Type;\n+         Set_Node    : Count_Type;\n+\n+         Result : Boolean;\n+\n+      begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         Subset_Node := Subset.First;\n+         Set_Node    := Of_Set.First;\n+         loop\n+            if Set_Node = 0 then\n+               Result := Subset_Node = 0;\n+               exit;\n+            end if;\n+\n+            if Subset_Node = 0 then\n+               Result := True;\n+               exit;\n+            end if;\n+\n+            if Is_Less (Subset.Nodes (Subset_Node),\n+                        Of_Set.Nodes (Set_Node))\n+            then\n+               Result := False;\n+               exit;\n+            end if;\n+\n+            if Is_Less (Of_Set.Nodes (Set_Node),\n+                        Subset.Nodes (Subset_Node))\n+            then\n+               Set_Node := Tree_Operations.Next (Of_Set, Set_Node);\n+            else\n+               Set_Node := Tree_Operations.Next (Of_Set, Set_Node);\n+               Subset_Node := Tree_Operations.Next (Subset, Subset_Node);\n+            end if;\n+         end loop;\n+\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+\n+            raise;\n+      end;\n    end Set_Subset;\n \n    -------------\n    -- Overlap --\n    -------------\n \n    function Set_Overlap (Left, Right : Set_Type) return Boolean is\n-      L_Node : Count_Type;\n-      R_Node : Count_Type;\n-\n    begin\n       if Left'Address = Right'Address then\n          return Left.Length /= 0;\n       end if;\n \n-      L_Node := Left.First;\n-      R_Node := Right.First;\n-      loop\n-         if L_Node = 0\n-           or else R_Node = 0\n-         then\n-            return False;\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n-            L_Node := Tree_Operations.Next (Left, L_Node);\n+      declare\n+         BL : Natural renames Left'Unrestricted_Access.Busy;\n+         LL : Natural renames Left'Unrestricted_Access.Lock;\n \n-         elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n-            R_Node := Tree_Operations.Next (Right, R_Node);\n+         BR : Natural renames Right'Unrestricted_Access.Busy;\n+         LR : Natural renames Right'Unrestricted_Access.Lock;\n \n-         else\n-            return True;\n-         end if;\n-      end loop;\n+         L_Node : Count_Type;\n+         R_Node : Count_Type;\n+\n+         Result : Boolean;\n+\n+      begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = 0\n+              or else R_Node = 0\n+            then\n+               Result := False;\n+               exit;\n+            end if;\n+\n+            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+\n+            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+\n+            else\n+               Result := True;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+\n+            raise;\n+      end;\n    end Set_Overlap;\n \n    --------------------------\n@@ -364,18 +598,21 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n      (Target : in out Set_Type;\n       Source : Set_Type)\n    is\n+      BT : Natural renames Target.Busy;\n+      LT : Natural renames Target.Lock;\n+\n+      BS : Natural renames Source'Unrestricted_Access.Busy;\n+      LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n       Tgt : Count_Type;\n       Src : Count_Type;\n \n       New_Tgt_Node : Count_Type;\n       pragma Warnings (Off, New_Tgt_Node);\n \n-   begin\n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      Compare : Integer;\n \n+   begin\n       if Target'Address = Source'Address then\n          Tree_Operations.Clear_Tree (Target);\n          return;\n@@ -402,10 +639,44 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n             return;\n          end if;\n \n-         if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         begin\n+            BT := BT + 1;\n+            LT := LT + 1;\n+\n+            BS := BS + 1;\n+            LS := LS + 1;\n+\n+            if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n+               Compare := -1;\n+            elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n+               Compare := 1;\n+            else\n+               Compare := 0;\n+            end if;\n+\n+            BT := BT - 1;\n+            LT := LT - 1;\n+\n+            BS := BS - 1;\n+            LS := LS - 1;\n+         exception\n+            when others =>\n+               BT := BT - 1;\n+               LT := LT - 1;\n+\n+               BS := BS - 1;\n+               LS := LS - 1;\n+\n+               raise;\n+         end;\n+\n+         if Compare < 0 then\n             Tgt := Tree_Operations.Next (Target, Tgt);\n \n-         elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n+         elsif Compare > 0 then\n             Insert_With_Hint\n               (Dst_Set  => Target,\n                Dst_Hint => Tgt,\n@@ -432,12 +703,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n    function Set_Symmetric_Difference\n      (Left, Right : Set_Type) return Set_Type\n    is\n-      L_Node : Count_Type;\n-      R_Node : Count_Type;\n-\n-      Dst_Node : Count_Type;\n-      pragma Warnings (Off, Dst_Node);\n-\n    begin\n       if Left'Address = Right'Address then\n          return S : Set_Type (0);  -- Empty set\n@@ -452,60 +717,100 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       end if;\n \n       return Result : Set_Type (Left.Length + Right.Length) do\n-         L_Node := Left.First;\n-         R_Node := Right.First;\n-         loop\n-            if L_Node = 0 then\n-               while R_Node /= 0 loop\n-                  Insert_With_Hint\n-                    (Dst_Set  => Result,\n-                     Dst_Hint => 0,\n-                     Src_Node => Right.Nodes (R_Node),\n-                     Dst_Node => Dst_Node);\n \n-                  R_Node := Tree_Operations.Next (Right, R_Node);\n-               end loop;\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-               return;\n-            end if;\n+         declare\n+            BL : Natural renames Left'Unrestricted_Access.Busy;\n+            LL : Natural renames Left'Unrestricted_Access.Lock;\n \n-            if R_Node = 0 then\n-               while L_Node /= 0 loop\n+            BR : Natural renames Right'Unrestricted_Access.Busy;\n+            LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+            L_Node : Count_Type;\n+            R_Node : Count_Type;\n+\n+            Dst_Node : Count_Type;\n+            pragma Warnings (Off, Dst_Node);\n+\n+         begin\n+            BL := BL + 1;\n+            LL := LL + 1;\n+\n+            BR := BR + 1;\n+            LR := LR + 1;\n+\n+            L_Node := Left.First;\n+            R_Node := Right.First;\n+            loop\n+               if L_Node = 0 then\n+                  while R_Node /= 0 loop\n+                     Insert_With_Hint\n+                       (Dst_Set  => Result,\n+                        Dst_Hint => 0,\n+                        Src_Node => Right.Nodes (R_Node),\n+                        Dst_Node => Dst_Node);\n+\n+                     R_Node := Tree_Operations.Next (Right, R_Node);\n+                  end loop;\n+\n+                  exit;\n+               end if;\n+\n+               if R_Node = 0 then\n+                  while L_Node /= 0 loop\n+                     Insert_With_Hint\n+                       (Dst_Set  => Result,\n+                        Dst_Hint => 0,\n+                        Src_Node => Left.Nodes (L_Node),\n+                        Dst_Node => Dst_Node);\n+\n+                     L_Node := Tree_Operations.Next (Left, L_Node);\n+                  end loop;\n+\n+                  exit;\n+               end if;\n+\n+               if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n                   Insert_With_Hint\n                     (Dst_Set  => Result,\n                      Dst_Hint => 0,\n                      Src_Node => Left.Nodes (L_Node),\n                      Dst_Node => Dst_Node);\n \n                   L_Node := Tree_Operations.Next (Left, L_Node);\n-               end loop;\n \n-               return;\n-            end if;\n+               elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+                  Insert_With_Hint\n+                    (Dst_Set  => Result,\n+                     Dst_Hint => 0,\n+                     Src_Node => Right.Nodes (R_Node),\n+                     Dst_Node => Dst_Node);\n \n-            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n-               Insert_With_Hint\n-                 (Dst_Set  => Result,\n-                  Dst_Hint => 0,\n-                  Src_Node => Left.Nodes (L_Node),\n-                  Dst_Node => Dst_Node);\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n \n-               L_Node := Tree_Operations.Next (Left, L_Node);\n+               else\n+                  L_Node := Tree_Operations.Next (Left, L_Node);\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n+               end if;\n+            end loop;\n \n-            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n-               Insert_With_Hint\n-                 (Dst_Set  => Result,\n-                  Dst_Hint => 0,\n-                  Src_Node => Right.Nodes (R_Node),\n-                  Dst_Node => Dst_Node);\n+            BL := BL - 1;\n+            LL := LL - 1;\n \n-               R_Node := Tree_Operations.Next (Right, R_Node);\n+            BR := BR - 1;\n+            LR := LR - 1;\n+         exception\n+            when others =>\n+               BL := BL - 1;\n+               LL := LL - 1;\n \n-            else\n-               L_Node := Tree_Operations.Next (Left, L_Node);\n-               R_Node := Tree_Operations.Next (Right, R_Node);\n-            end if;\n-         end loop;\n+               BR := BR - 1;\n+               LR := LR - 1;\n+\n+               raise;\n+         end;\n       end return;\n    end Set_Symmetric_Difference;\n \n@@ -541,17 +846,34 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-      --  Note that there's no way to decide a priori whether the target has\n-      --  enough capacity for the union with source. We cannot simply compare\n-      --  the sum of the existing lengths to the capacity of the target,\n-      --  because equivalent items from source are not included in the union.\n+      declare\n+         BS : Natural renames Source'Unrestricted_Access.Busy;\n+         LS : Natural renames Source'Unrestricted_Access.Lock;\n \n-      Iterate (Source);\n+      begin\n+         BS := BS + 1;\n+         LS := LS + 1;\n+\n+         --  Note that there's no way to decide a priori whether the target has\n+         --  enough capacity for the union with source. We cannot simply\n+         --  compare the sum of the existing lengths to the capacity of the\n+         --  target, because equivalent items from source are not included in\n+         --  the union.\n+\n+         Iterate (Source);\n+\n+         BS := BS - 1;\n+         LS := LS - 1;\n+      exception\n+         when others =>\n+            BS := BS - 1;\n+            LS := LS - 1;\n+\n+            raise;\n+      end;\n    end Set_Union;\n \n    function Set_Union (Left, Right : Set_Type) return Set_Type is\n@@ -569,35 +891,65 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n       end if;\n \n       return Result : Set_Type (Left.Length + Right.Length) do\n-         Assign (Target => Result, Source => Left);\n+         declare\n+            BL : Natural renames Left'Unrestricted_Access.Busy;\n+            LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+            BR : Natural renames Right'Unrestricted_Access.Busy;\n+            LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+         begin\n+            BL := BL + 1;\n+            LL := LL + 1;\n \n-         Insert_Right : declare\n-            Hint : Count_Type := 0;\n+            BR := BR + 1;\n+            LR := LR + 1;\n \n-            procedure Process (Node : Count_Type);\n-            pragma Inline (Process);\n+            Assign (Target => Result, Source => Left);\n \n-            procedure Iterate is\n-              new Tree_Operations.Generic_Iteration (Process);\n+            Insert_Right : declare\n+               Hint : Count_Type := 0;\n \n-            -------------\n-            -- Process --\n-            -------------\n+               procedure Process (Node : Count_Type);\n+               pragma Inline (Process);\n+\n+               procedure Iterate is\n+                 new Tree_Operations.Generic_Iteration (Process);\n+\n+               -------------\n+               -- Process --\n+               -------------\n+\n+               procedure Process (Node : Count_Type) is\n+               begin\n+                  Insert_With_Hint\n+                    (Dst_Set  => Result,\n+                     Dst_Hint => Hint,\n+                     Src_Node => Right.Nodes (Node),\n+                     Dst_Node => Hint);\n+               end Process;\n+\n+            --  Start of processing for Insert_Right\n \n-            procedure Process (Node : Count_Type) is\n             begin\n-               Insert_With_Hint\n-                 (Dst_Set  => Result,\n-                  Dst_Hint => Hint,\n-                  Src_Node => Right.Nodes (Node),\n-                  Dst_Node => Hint);\n-            end Process;\n+               Iterate (Right);\n+            end Insert_Right;\n \n-         --  Start of processing for Insert_Right\n+            BL := BL - 1;\n+            LL := LL - 1;\n \n-         begin\n-            Iterate (Right);\n-         end Insert_Right;\n+            BR := BR - 1;\n+            LR := LR - 1;\n+         exception\n+            when others =>\n+               BL := BL - 1;\n+               LL := LL - 1;\n+\n+               BR := BR - 1;\n+               LR := LR - 1;\n+\n+               raise;\n+         end;\n       end return;\n    end Set_Union;\n "}, {"sha": "ed34b69195a6d02d0f77c558d751f80516d17100", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 109, "deletions": 14, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -979,6 +979,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          pragma Assert (Vet (Container, Position.Node),\n                         \"bad cursor in Update_Element_Preserving_Key\");\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n             E : Element_Type renames N.Element;\n@@ -987,12 +990,15 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n             B : Natural renames Container.Busy;\n             L : Natural renames Container.Lock;\n \n+            Eq : Boolean;\n+\n          begin\n             B := B + 1;\n             L := L + 1;\n \n             begin\n                Process (E);\n+               Eq := Equivalent_Keys (K, Key (E));\n             exception\n                when others =>\n                   L := L - 1;\n@@ -1003,7 +1009,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, Key (E)) then\n+            if Eq then\n                return;\n             end if;\n          end;\n@@ -1727,16 +1733,52 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Hint      : Count_Type;\n       Result    : Count_Type;\n       Inserted  : Boolean;\n+      Compare   : Boolean;\n+\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B : Natural renames Container.Busy;\n+      L : Natural renames Container.Lock;\n \n    --  Start of processing for Replace_Element\n \n    begin\n-      if Item < Node.Element\n-        or else Node.Element < Item\n-      then\n-         null;\n+      --  Replace_Element assigns value Item to the element designated by Node,\n+      --  per certain semantic constraints, described as follows.\n+\n+      --  If Item is equivalent to the element, then element is replaced and\n+      --  there's nothing else to do. This is the easy case.\n+\n+      --  If Item is not equivalent, then the node will (possibly) have to move\n+      --  to some other place in the tree. This is slighly more complicated,\n+      --  because we must ensure that Item is not equivalent to some other\n+      --  element in the tree (in which case, the replacement is not allowed).\n+\n+      --  Determine whether Item is equivalent to element on the specified\n+      --  node.\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Compare := (if Item < Node.Element then False\n+                     elsif Node.Element < Item then False\n+                     else True);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      if Compare then\n+         --  Item is equivalent to the node's element, so we will not have to\n+         --  move the node.\n \n-      else\n          if Container.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with elements (set is locked)\";\n@@ -1746,12 +1788,63 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          return;\n       end if;\n \n+      --  The replacement Item is not equivalent to the element on the\n+      --  specified node, which means that it will need to be re-inserted in a\n+      --  different position in the tree. We must now determine whether Item is\n+      --  equivalent to some other element in the tree (which would prohibit\n+      --  the assignment and hence the move).\n+\n+      --  Ceiling returns the smallest element equivalent or greater than the\n+      --  specified Item; if there is no such element, then it returns 0.\n+\n       Hint := Element_Keys.Ceiling (Container, Item);\n \n-      if Hint = 0 then\n-         null;\n+      if Hint /= 0 then  -- Item <= Nodes (Hint).Element\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Compare := Item < Nodes (Hint).Element;\n+\n+            L := L - 1;\n+            B := B - 1;\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         if not Compare then  -- Item is equivalent to Nodes (Hint).Element\n+            --  Ceiling returns an element that is equivalent or greater than\n+            --  Item. If Item is \"not less than\" the element, then by\n+            --  elimination we know that Item is equivalent to the element.\n+\n+            --  But this means that it is not possible to assign the value of\n+            --  Item to the specified element (on Node), because a different\n+            --  element (on Hint) equivalent to Item already exsits. (Were we\n+            --  to change Node's element value, we would have to move Node, but\n+            --  we would be unable to move the Node, because its new position\n+            --  in the tree is already occupied by an equivalent element.)\n+\n+            raise Program_Error with \"attempt to replace existing element\";\n+         end if;\n+\n+         --  Item is not equivalent to any other element in the tree\n+         --  (specifically, it is less then Nodes (Hint).Element), so it is\n+         --  safe to assign the value of Item to Node.Element. This means that\n+         --  the node will have to move to a different position in the tree\n+         --  (because its element will have a different value).\n+\n+         --  The nearest (greater) neighbor of Item is Hint. This will be the\n+         --  insertion position of Node (because its element will have Item as\n+         --  its new value).\n+\n+         --  If Node equals Hint, the relative position of Node does not\n+         --  change. This allows us to perform an optimization: we need not\n+         --  remove Node from the tree and then reinsert it with its new value,\n+         --  because it would only be placed in the exact same position.\n \n-      elsif Item < Nodes (Hint).Element then\n          if Hint = Index then\n             if Container.Lock > 0 then\n                raise Program_Error with\n@@ -1761,12 +1854,14 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n             Node.Element := Item;\n             return;\n          end if;\n-\n-      else\n-         pragma Assert (not (Nodes (Hint).Element < Item));\n-         raise Program_Error with \"attempt to replace existing element\";\n       end if;\n \n+      --  If we get here, it is because Item was greater than all elements in\n+      --  the tree (Hint = 0), or because Item was less than some element at a\n+      --  different place in the tree (Item < Nodes (Hint).Element and Hint /=\n+      --  Index). In either case, we remove Node from the tree and then insert\n+      --  Item into the tree, onto the same Node.\n+\n       Tree_Operations.Delete_Node_Sans_Free (Container, Index);\n \n       Local_Insert_With_Hint"}, {"sha": "4d918a5b45d8a3a431f870c67e40debdab61e922", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 107, "deletions": 13, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1088,12 +1088,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             B : Natural renames Tree.Busy;\n             L : Natural renames Tree.Lock;\n \n+            Eq : Boolean;\n+\n          begin\n             B := B + 1;\n             L := L + 1;\n \n             begin\n                Process (E);\n+               Eq := Equivalent_Keys (K, Key (E));\n             exception\n                when others =>\n                   L := L - 1;\n@@ -1104,7 +1107,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, Key (E)) then\n+            if Eq then\n                return;\n             end if;\n          end;\n@@ -1884,16 +1887,54 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Hint     : Node_Access;\n       Result   : Node_Access;\n       Inserted : Boolean;\n+      Compare  : Boolean;\n \n       X : Element_Access := Node.Element;\n \n-      --  Start of processing for Replace_Element\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B : Natural renames Tree.Busy;\n+      L : Natural renames Tree.Lock;\n+\n+   --  Start of processing for Replace_Element\n \n    begin\n-      if Item < Node.Element.all or else Node.Element.all < Item then\n-         null;\n+      --  Replace_Element assigns value Item to the element designated by Node,\n+      --  per certain semantic constraints, described as follows.\n+\n+      --  If Item is equivalent to the element, then element is replaced and\n+      --  there's nothing else to do. This is the easy case.\n+\n+      --  If Item is not equivalent, then the node will (possibly) have to move\n+      --  to some other place in the tree. This is slighly more complicated,\n+      --  because we must ensure that Item is not equivalent to some other\n+      --  element in the tree (in which case, the replacement is not allowed).\n+\n+      --  Determine whether Item is equivalent to element on the specified\n+      --  node.\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Compare := (if Item < Node.Element.all then False\n+                     elsif Node.Element.all < Item then False\n+                     else True);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      if Compare then\n+         --  Item is equivalent to the node's element, so we will not have to\n+         --  move the node.\n \n-      else\n          if Tree.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with elements (set is locked)\";\n@@ -1914,12 +1955,62 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return;\n       end if;\n \n+      --  The replacement Item is not equivalent to the element on the\n+      --  specified node, which means that it will need to be re-inserted in a\n+      --  different position in the tree. We must now determine whether Item is\n+      --  equivalent to some other element in the tree (which would prohibit\n+      --  the assignment and hence the move).\n+\n+      --  Ceiling returns the smallest element equivalent or greater than the\n+      --  specified Item; if there is no such element, then it returns null.\n+\n       Hint := Element_Keys.Ceiling (Tree, Item);\n \n-      if Hint = null then\n-         null;\n+      if Hint /= null then\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Compare := Item < Hint.Element.all;\n+\n+            L := L - 1;\n+            B := B - 1;\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         if not Compare then  -- Item >= Hint.Element\n+            --  Ceiling returns an element that is equivalent or greater than\n+            --  Item. If Item is \"not less than\" the element, then by\n+            --  elimination we know that Item is equivalent to the element.\n+\n+            --  But this means that it is not possible to assign the value of\n+            --  Item to the specified element (on Node), because a different\n+            --  element (on Hint) equivalent to Item already exsits. (Were we\n+            --  to change Node's element value, we would have to move Node, but\n+            --  we would be unable to move the Node, because its new position\n+            --  in the tree is already occupied by an equivalent element.)\n+\n+            raise Program_Error with \"attempt to replace existing element\";\n+         end if;\n+\n+         --  Item is not equivalent to any other element in the tree, so it is\n+         --  safe to assign the value of Item to Node.Element. This means that\n+         --  the node will have to move to a different position in the tree\n+         --  (because its element will have a different value).\n+\n+         --  The nearest (greater) neighbor of Item is Hint. This will be the\n+         --  insertion position of Node (because its element will have Item as\n+         --  its new value).\n+\n+         --  If Node equals Hint, the relative position of Node does not\n+         --  change. This allows us to perform an optimization: we need not\n+         --  remove Node from the tree and then reinsert it with its new value,\n+         --  because it would only be placed in the exact same position.\n \n-      elsif Item < Hint.Element.all then\n          if Hint = Node then\n             if Tree.Lock > 0 then\n                raise Program_Error with\n@@ -1940,12 +2031,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n             return;\n          end if;\n-\n-      else\n-         pragma Assert (not (Hint.Element.all < Item));\n-         raise Program_Error with \"attempt to replace existing element\";\n       end if;\n \n+      --  If we get here, it is because Item was greater than all elements in\n+      --  the tree (Hint = null), or because Item was less than some element at\n+      --  a different place in the tree (Item < Hint.Element.all). In either\n+      --  case, we remove Node from the tree (without actually deallocating\n+      --  it), and then insert Item into the tree, onto the same Node (so no\n+      --  new node is actually allocated).\n+\n       Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n \n       Local_Insert_With_Hint"}, {"sha": "3f2537367bb6dae2300768b011142c150f1c2f61", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 111, "deletions": 17, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -987,12 +987,15 @@ package body Ada.Containers.Ordered_Sets is\n             B : Natural renames Tree.Busy;\n             L : Natural renames Tree.Lock;\n \n+            Eq : Boolean;\n+\n          begin\n             B := B + 1;\n             L := L + 1;\n \n             begin\n                Process (E);\n+               Eq := Equivalent_Keys (K, Key (E));\n             exception\n                when others =>\n                   L := L - 1;\n@@ -1003,7 +1006,7 @@ package body Ada.Containers.Ordered_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, Key (E)) then\n+            if Eq then\n                return;\n             end if;\n          end;\n@@ -1716,17 +1719,55 @@ package body Ada.Containers.Ordered_Sets is\n          return Node;\n       end New_Node;\n \n-      Hint      : Node_Access;\n-      Result    : Node_Access;\n-      Inserted  : Boolean;\n+      Hint     : Node_Access;\n+      Result   : Node_Access;\n+      Inserted : Boolean;\n+      Compare  : Boolean;\n+\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B : Natural renames Tree.Busy;\n+      L : Natural renames Tree.Lock;\n \n-      --  Start of processing for Replace_Element\n+   --  Start of processing for Replace_Element\n \n    begin\n-      if Item < Node.Element or else Node.Element < Item then\n-         null;\n+      --  Replace_Element assigns value Item to the element designated by Node,\n+      --  per certain semantic constraints.\n+\n+      --  If Item is equivalent to the element, then element is replaced and\n+      --  there's nothing else to do. This is the easy case.\n+\n+      --  If Item is not equivalent, then the node will (possibly) have to move\n+      --  to some other place in the tree. This is slighly more complicated,\n+      --  because we must ensure that Item is not equivalent to some other\n+      --  element in the tree (in which case, the replacement is not allowed).\n+\n+      --  Determine whether Item is equivalent to element on the specified\n+      --  node.\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Compare := (if Item < Node.Element then False\n+                     elsif Node.Element < Item then False\n+                     else True);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      if Compare then\n+         --  Item is equivalent to the node's element, so we will not have to\n+         --  move the node.\n \n-      else\n          if Tree.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with elements (set is locked)\";\n@@ -1736,12 +1777,62 @@ package body Ada.Containers.Ordered_Sets is\n          return;\n       end if;\n \n+      --  The replacement Item is not equivalent to the element on the\n+      --  specified node, which means that it will need to be re-inserted in a\n+      --  different position in the tree. We must now determine whether Item is\n+      --  equivalent to some other element in the tree (which would prohibit\n+      --  the assignment and hence the move).\n+\n+      --  Ceiling returns the smallest element equivalent or greater than the\n+      --  specified Item; if there is no such element, then it returns null.\n+\n       Hint := Element_Keys.Ceiling (Tree, Item);\n \n-      if Hint = null then\n-         null;\n+      if Hint /= null then\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Compare := Item < Hint.Element;\n+\n+            L := L - 1;\n+            B := B - 1;\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         if not Compare then  -- Item >= Hint.Element\n+            --  Ceiling returns an element that is equivalent or greater than\n+            --  Item. If Item is \"not less than\" the element, then by\n+            --  elimination we know that Item is equivalent to the element.\n+\n+            --  But this means that it is not possible to assign the value of\n+            --  Item to the specified element (on Node), because a different\n+            --  element (on Hint) equivalent to Item already exsits. (Were we\n+            --  to change Node's element value, we would have to move Node, but\n+            --  we would be unable to move the Node, because its new position\n+            --  in the tree is already occupied by an equivalent element.)\n+\n+            raise Program_Error with \"attempt to replace existing element\";\n+         end if;\n+\n+         --  Item is not equivalent to any other element in the tree, so it is\n+         --  safe to assign the value of Item to Node.Element. This means that\n+         --  the node will have to move to a different position in the tree\n+         --  (because its element will have a different value).\n+\n+         --  The nearest (greater) neighbor of Item is Hint. This will be the\n+         --  insertion position of Node (because its element will have Item as\n+         --  its new value).\n+\n+         --  If Node equals Hint, the relative position of Node does not\n+         --  change. This allows us to perform an optimization: we need not\n+         --  remove Node from the tree and then reinsert it with its new value,\n+         --  because it would only be placed in the exact same position.\n \n-      elsif Item < Hint.Element then\n          if Hint = Node then\n             if Tree.Lock > 0 then\n                raise Program_Error with\n@@ -1751,15 +1842,18 @@ package body Ada.Containers.Ordered_Sets is\n             Node.Element := Item;\n             return;\n          end if;\n-\n-      else\n-         pragma Assert (not (Hint.Element < Item));\n-         raise Program_Error with \"attempt to replace existing element\";\n       end if;\n \n+      --  If we get here, it is because Item was greater than all elements in\n+      --  the tree (Hint = null), or because Item was less than some element at\n+      --  a different place in the tree (Item < Hint.Element). In either case,\n+      --  we remove Node from the tree (without actually deallocating it), and\n+      --  then insert Item into the tree, onto the same Node (so no new node is\n+      --  actually allocated).\n+\n       Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n \n-      Local_Insert_With_Hint\n+      Local_Insert_With_Hint  -- use unconditional insert here instead???\n         (Tree     => Tree,\n          Position => Hint,\n          Key      => Item,"}, {"sha": "0e27e0a46defd78a1d7c00bb6773a7c3e1bf69bb", "filename": "gcc/ada/a-crbtgk.adb", "status": "modified", "additions": 228, "deletions": 52, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,10 +38,19 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n    --  AKA Lower_Bound\n \n    function Ceiling (Tree : Tree_Type; Key : Key_Type) return Node_Access is\n+      B : Natural renames Tree'Unrestricted_Access.Busy;\n+      L : Natural renames Tree'Unrestricted_Access.Lock;\n+\n       Y : Node_Access;\n       X : Node_Access;\n \n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n       X := Tree.Root;\n       while X /= null loop\n          if Is_Greater_Key_Node (Key, X) then\n@@ -52,18 +61,37 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n          end if;\n       end loop;\n \n+      B := B - 1;\n+      L := L - 1;\n+\n       return Y;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Ceiling;\n \n    ----------\n    -- Find --\n    ----------\n \n-   function Find (Tree : Tree_Type; Key  : Key_Type) return Node_Access is\n+   function Find (Tree : Tree_Type; Key : Key_Type) return Node_Access is\n+      B : Natural renames Tree'Unrestricted_Access.Busy;\n+      L : Natural renames Tree'Unrestricted_Access.Lock;\n+\n       Y : Node_Access;\n       X : Node_Access;\n \n+      Result : Node_Access;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n       X := Tree.Root;\n       while X /= null loop\n          if Is_Greater_Key_Node (Key, X) then\n@@ -75,25 +103,44 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       end loop;\n \n       if Y = null then\n-         return null;\n-      end if;\n+         Result := null;\n+\n+      elsif Is_Less_Key_Node (Key, Y) then\n+         Result := null;\n \n-      if Is_Less_Key_Node (Key, Y) then\n-         return null;\n+      else\n+         Result := Y;\n       end if;\n \n-      return Y;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Find;\n \n    -----------\n    -- Floor --\n    -----------\n \n-   function Floor (Tree : Tree_Type; Key  : Key_Type) return Node_Access is\n+   function Floor (Tree : Tree_Type; Key : Key_Type) return Node_Access is\n+      B : Natural renames Tree'Unrestricted_Access.Busy;\n+      L : Natural renames Tree'Unrestricted_Access.Lock;\n+\n       Y : Node_Access;\n       X : Node_Access;\n \n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n       X := Tree.Root;\n       while X /= null loop\n          if Is_Less_Key_Node (Key, X) then\n@@ -104,7 +151,15 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n          end if;\n       end loop;\n \n+      B := B - 1;\n+      L := L - 1;\n+\n       return Y;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Floor;\n \n    --------------------------------\n@@ -117,8 +172,16 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Node     : out Node_Access;\n       Inserted : out Boolean)\n    is\n-      Y : Node_Access := null;\n-      X : Node_Access := Tree.Root;\n+      X : Node_Access;\n+      Y : Node_Access;\n+\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B : Natural renames Tree.Busy;\n+      L : Natural renames Tree.Lock;\n+\n+      Compare : Boolean;\n \n    begin\n       --  This is a \"conditional\" insertion, meaning that the insertion request\n@@ -136,12 +199,27 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       --  either the smallest node greater than Key (Inserted is True), or the\n       --  largest node less or equivalent to Key (Inserted is False).\n \n-      Inserted := True;\n-      while X /= null loop\n-         Y := X;\n-         Inserted := Is_Less_Key_Node (Key, X);\n-         X := (if Inserted then Ops.Left (X) else Ops.Right (X));\n-      end loop;\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         X := Tree.Root;\n+         Y := null;\n+         Inserted := True;\n+         while X /= null loop\n+            Y := X;\n+            Inserted := Is_Less_Key_Node (Key, X);\n+            X := (if Inserted then Ops.Left (X) else Ops.Right (X));\n+         end loop;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n \n       if Inserted then\n \n@@ -172,7 +250,22 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       --  Key is equivalent to or greater than Node. We must resolve which is\n       --  the case, to determine whether the conditional insertion succeeds.\n \n-      if Is_Greater_Key_Node (Key, Node) then\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Compare := Is_Greater_Key_Node (Key, Node);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      if Compare then\n \n          --  Key is strictly greater than Node, which means that Key is not\n          --  equivalent to Node. In this case, the insertion succeeds, and we\n@@ -201,6 +294,15 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Node      : out Node_Access;\n       Inserted  : out Boolean)\n    is\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B : Natural renames Tree.Busy;\n+      L : Natural renames Tree.Lock;\n+\n+      Test    : Node_Access;\n+      Compare : Boolean;\n+\n    begin\n       --  The purpose of a hint is to avoid a search from the root of\n       --  tree. If we have it hint it means we only need to traverse the\n@@ -215,9 +317,23 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       --  done; otherwise the hint was \"wrong\" and we must search.\n \n       if Position = null then  -- largest\n-         if Tree.Last = null\n-           or else Is_Greater_Key_Node (Key, Tree.Last)\n-         then\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Compare := Tree.Last = null\n+                         or else Is_Greater_Key_Node (Key, Tree.Last);\n+\n+            L := L - 1;\n+            B := B - 1;\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         if Compare then\n             Insert_Post (Tree, Tree.Last, False, Node);\n             Inserted := True;\n          else\n@@ -246,28 +362,58 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       --  then its neighbor must be anterior and so we insert before the\n       --  hint.\n \n-      if Is_Less_Key_Node (Key, Position) then\n-         declare\n-            Before : constant Node_Access := Ops.Previous (Position);\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Compare := Is_Less_Key_Node (Key, Position);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n \n-         begin\n-            if Before = null then\n-               Insert_Post (Tree, Tree.First, True, Node);\n-               Inserted := True;\n+      if Compare then\n+         Test := Ops.Previous (Position);  -- \"before\"\n \n-            elsif Is_Greater_Key_Node (Key, Before) then\n-               if Ops.Right (Before) = null then\n-                  Insert_Post (Tree, Before, False, Node);\n-               else\n-                  Insert_Post (Tree, Position, True, Node);\n-               end if;\n+         if Test = null then  -- new first node\n+            Insert_Post (Tree, Tree.First, True, Node);\n \n-               Inserted := True;\n+            Inserted := True;\n+            return;\n+         end if;\n \n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Compare := Is_Greater_Key_Node (Key, Test);\n+\n+            L := L - 1;\n+            B := B - 1;\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         if Compare then\n+            if Ops.Right (Test) = null then\n+               Insert_Post (Tree, Test, False, Node);\n             else\n-               Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+               Insert_Post (Tree, Position, True, Node);\n             end if;\n-         end;\n+\n+            Inserted := True;\n+\n+         else\n+            Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+         end if;\n \n          return;\n       end if;\n@@ -278,28 +424,58 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       --  greater than the hint and less than the hint's next neighbor,\n       --  then we're done; otherwise we must search.\n \n-      if Is_Greater_Key_Node (Key, Position) then\n-         declare\n-            After : constant Node_Access := Ops.Next (Position);\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Compare := Is_Greater_Key_Node (Key, Position);\n+\n+         L := L - 1;\n+         B := B - 1;\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n \n-         begin\n-            if After = null then\n-               Insert_Post (Tree, Tree.Last, False, Node);\n-               Inserted := True;\n+      if Compare then\n+         Test := Ops.Next (Position);  -- \"after\"\n \n-            elsif Is_Less_Key_Node (Key, After) then\n-               if Ops.Right (Position) = null then\n-                  Insert_Post (Tree, Position, False, Node);\n-               else\n-                  Insert_Post (Tree, After, True, Node);\n-               end if;\n+         if Test = null then  -- new last node\n+            Insert_Post (Tree, Tree.Last, False, Node);\n \n-               Inserted := True;\n+            Inserted := True;\n+            return;\n+         end if;\n \n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Compare := Is_Less_Key_Node (Key, Test);\n+\n+            L := L - 1;\n+            B := B - 1;\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         if Compare then\n+            if Ops.Right (Position) = null then\n+               Insert_Post (Tree, Position, False, Node);\n             else\n-               Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+               Insert_Post (Tree, Test, True, Node);\n             end if;\n-         end;\n+\n+            Inserted := True;\n+\n+         else\n+            Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+         end if;\n \n          return;\n       end if;"}, {"sha": "adc9ab279660dbcce8f2248fca92085d342cafd1", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -626,9 +626,17 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n    -------------------\n \n    function Generic_Equal (Left, Right : Tree_Type) return Boolean is\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n       L_Node : Node_Access;\n       R_Node : Node_Access;\n \n+      Result : Boolean;\n+\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -638,18 +646,44 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n       L_Node := Left.First;\n       R_Node := Right.First;\n+      Result := True;\n       while L_Node /= null loop\n          if not Is_Equal (L_Node, R_Node) then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          L_Node := Next (L_Node);\n          R_Node := Next (R_Node);\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end Generic_Equal;\n \n    -----------------------"}, {"sha": "27106205fba04047e3250bfeb2899591bf48c377", "filename": "gcc/ada/a-rbtgbo.adb", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-rbtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-rbtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbo.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -606,9 +606,17 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations is\n    -------------------\n \n    function Generic_Equal (Left, Right : Tree_Type'Class) return Boolean is\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n       L_Node : Count_Type;\n       R_Node : Count_Type;\n \n+      Result : Boolean;\n+\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -618,18 +626,43 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n       L_Node := Left.First;\n       R_Node := Right.First;\n       while L_Node /= 0 loop\n          if not Is_Equal (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          L_Node := Next (Left, L_Node);\n          R_Node := Next (Right, R_Node);\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end Generic_Equal;\n \n    -----------------------"}, {"sha": "700832e710eac76e05070bc4297eb747503da13a", "filename": "gcc/ada/a-rbtgso.adb", "status": "modified", "additions": 514, "deletions": 171, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-rbtgso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fa-rbtgso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -84,8 +84,16 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n    ----------------\n \n    procedure Difference (Target : in out Tree_Type; Source : Tree_Type) is\n-      Tgt : Node_Access := Target.First;\n-      Src : Node_Access := Source.First;\n+      BT : Natural renames Target.Busy;\n+      LT : Natural renames Target.Lock;\n+\n+      BS : Natural renames Source'Unrestricted_Access.Busy;\n+      LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n+      Tgt : Node_Access;\n+      Src : Node_Access;\n+\n+      Compare : Integer;\n \n    begin\n       if Target'Address = Source'Address then\n@@ -107,19 +115,55 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n            \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n+      Tgt := Target.First;\n+      Src := Source.First;\n       loop\n          if Tgt = null then\n-            return;\n+            exit;\n          end if;\n \n          if Src = null then\n-            return;\n+            exit;\n          end if;\n \n-         if Is_Less (Tgt, Src) then\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         begin\n+            BT := BT + 1;\n+            LT := LT + 1;\n+\n+            BS := BS + 1;\n+            LS := LS + 1;\n+\n+            if Is_Less (Tgt, Src) then\n+               Compare := -1;\n+            elsif Is_Less (Src, Tgt) then\n+               Compare := 1;\n+            else\n+               Compare := 0;\n+            end if;\n+\n+            BT := BT - 1;\n+            LT := LT - 1;\n+\n+            BS := BS - 1;\n+            LS := LS - 1;\n+         exception\n+            when others =>\n+               BT := BT - 1;\n+               LT := LT - 1;\n+\n+               BS := BS - 1;\n+               LS := LS - 1;\n+\n+               raise;\n+         end;\n+\n+         if Compare < 0 then\n             Tgt := Tree_Operations.Next (Tgt);\n \n-         elsif Is_Less (Src, Tgt) then\n+         elsif Compare > 0 then\n             Src := Tree_Operations.Next (Src);\n \n          else\n@@ -137,34 +181,66 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n    end Difference;\n \n    function Difference (Left, Right : Tree_Type) return Tree_Type is\n-      Tree : Tree_Type;\n-\n-      L_Node : Node_Access := Left.First;\n-      R_Node : Node_Access := Right.First;\n-\n-      Dst_Node : Node_Access;\n-      pragma Warnings (Off, Dst_Node);\n-\n    begin\n       if Left'Address = Right'Address then\n-         return Tree;  -- Empty set\n+         return Tree_Type'(others => <>);  -- Empty set\n       end if;\n \n       if Left.Length = 0 then\n-         return Tree;  -- Empty set\n+         return Tree_Type'(others => <>);  -- Empty set\n       end if;\n \n       if Right.Length = 0 then\n          return Copy (Left);\n       end if;\n \n-      loop\n-         if L_Node = null then\n-            return Tree;\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         BL : Natural renames Left'Unrestricted_Access.Busy;\n+         LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+         BR : Natural renames Right'Unrestricted_Access.Busy;\n+         LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+         Tree : Tree_Type;\n+\n+         L_Node : Node_Access;\n+         R_Node : Node_Access;\n+\n+         Dst_Node : Node_Access;\n+         pragma Warnings (Off, Dst_Node);\n+\n+      begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = null then\n+               exit;\n+            end if;\n+\n+            if R_Node = null then\n+               while L_Node /= null loop\n+                  Insert_With_Hint\n+                    (Dst_Tree => Tree,\n+                     Dst_Hint => null,\n+                     Src_Node => L_Node,\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Tree_Operations.Next (L_Node);\n+               end loop;\n+\n+               exit;\n+            end if;\n \n-         if R_Node = null then\n-            while L_Node /= null loop\n+            if Is_Less (L_Node, R_Node) then\n                Insert_With_Hint\n                  (Dst_Tree => Tree,\n                   Dst_Hint => null,\n@@ -173,33 +249,33 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n \n                L_Node := Tree_Operations.Next (L_Node);\n \n-            end loop;\n+            elsif Is_Less (R_Node, L_Node) then\n+               R_Node := Tree_Operations.Next (R_Node);\n \n-            return Tree;\n-         end if;\n+            else\n+               L_Node := Tree_Operations.Next (L_Node);\n+               R_Node := Tree_Operations.Next (R_Node);\n+            end if;\n+         end loop;\n \n-         if Is_Less (L_Node, R_Node) then\n-            Insert_With_Hint\n-              (Dst_Tree => Tree,\n-               Dst_Hint => null,\n-               Src_Node => L_Node,\n-               Dst_Node => Dst_Node);\n+         BL := BL - 1;\n+         LL := LL - 1;\n \n-            L_Node := Tree_Operations.Next (L_Node);\n+         BR := BR - 1;\n+         LR := LR - 1;\n \n-         elsif Is_Less (R_Node, L_Node) then\n-            R_Node := Tree_Operations.Next (R_Node);\n+         return Tree;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n \n-         else\n-            L_Node := Tree_Operations.Next (L_Node);\n-            R_Node := Tree_Operations.Next (R_Node);\n-         end if;\n-      end loop;\n+            BR := BR - 1;\n+            LR := LR - 1;\n \n-   exception\n-      when others =>\n-         Delete_Tree (Tree.Root);\n-         raise;\n+            Delete_Tree (Tree.Root);\n+            raise;\n+      end;\n    end Difference;\n \n    ------------------\n@@ -210,8 +286,16 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n      (Target : in out Tree_Type;\n       Source : Tree_Type)\n    is\n-      Tgt : Node_Access := Target.First;\n-      Src : Node_Access := Source.First;\n+      BT : Natural renames Target.Busy;\n+      LT : Natural renames Target.Lock;\n+\n+      BS : Natural renames Source'Unrestricted_Access.Busy;\n+      LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n+      Tgt : Node_Access;\n+      Src : Node_Access;\n+\n+      Compare : Integer;\n \n    begin\n       if Target'Address = Source'Address then\n@@ -228,10 +312,46 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n          return;\n       end if;\n \n+      Tgt := Target.First;\n+      Src := Source.First;\n       while Tgt /= null\n         and then Src /= null\n       loop\n-         if Is_Less (Tgt, Src) then\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         begin\n+            BT := BT + 1;\n+            LT := LT + 1;\n+\n+            BS := BS + 1;\n+            LS := LS + 1;\n+\n+            if Is_Less (Tgt, Src) then\n+               Compare := -1;\n+            elsif Is_Less (Src, Tgt) then\n+               Compare := 1;\n+            else\n+               Compare := 0;\n+            end if;\n+\n+            BT := BT - 1;\n+            LT := LT - 1;\n+\n+            BS := BS - 1;\n+            LS := LS - 1;\n+         exception\n+            when others =>\n+               BT := BT - 1;\n+               LT := LT - 1;\n+\n+               BS := BS - 1;\n+               LS := LS - 1;\n+\n+               raise;\n+         end;\n+\n+         if Compare < 0 then\n             declare\n                X : Node_Access := Tgt;\n             begin\n@@ -240,7 +360,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n                Free (X);\n             end;\n \n-         elsif Is_Less (Src, Tgt) then\n+         elsif Compare > 0 then\n             Src := Tree_Operations.Next (Src);\n \n          else\n@@ -261,50 +381,83 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n    end Intersection;\n \n    function Intersection (Left, Right : Tree_Type) return Tree_Type is\n-      Tree : Tree_Type;\n-\n-      L_Node : Node_Access := Left.First;\n-      R_Node : Node_Access := Right.First;\n-\n-      Dst_Node : Node_Access;\n-      pragma Warnings (Off, Dst_Node);\n-\n    begin\n       if Left'Address = Right'Address then\n          return Copy (Left);\n       end if;\n \n-      loop\n-         if L_Node = null then\n-            return Tree;\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         if R_Node = null then\n-            return Tree;\n-         end if;\n+      declare\n+         BL : Natural renames Left'Unrestricted_Access.Busy;\n+         LL : Natural renames Left'Unrestricted_Access.Lock;\n \n-         if Is_Less (L_Node, R_Node) then\n-            L_Node := Tree_Operations.Next (L_Node);\n+         BR : Natural renames Right'Unrestricted_Access.Busy;\n+         LR : Natural renames Right'Unrestricted_Access.Lock;\n \n-         elsif Is_Less (R_Node, L_Node) then\n-            R_Node := Tree_Operations.Next (R_Node);\n+         Tree : Tree_Type;\n \n-         else\n-            Insert_With_Hint\n-              (Dst_Tree => Tree,\n-               Dst_Hint => null,\n-               Src_Node => L_Node,\n-               Dst_Node => Dst_Node);\n+         L_Node : Node_Access;\n+         R_Node : Node_Access;\n \n-            L_Node := Tree_Operations.Next (L_Node);\n-            R_Node := Tree_Operations.Next (R_Node);\n-         end if;\n-      end loop;\n+         Dst_Node : Node_Access;\n+         pragma Warnings (Off, Dst_Node);\n+\n+      begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = null then\n+               exit;\n+            end if;\n+\n+            if R_Node = null then\n+               exit;\n+            end if;\n+\n+            if Is_Less (L_Node, R_Node) then\n+               L_Node := Tree_Operations.Next (L_Node);\n+\n+            elsif Is_Less (R_Node, L_Node) then\n+               R_Node := Tree_Operations.Next (R_Node);\n \n-   exception\n-      when others =>\n-         Delete_Tree (Tree.Root);\n-         raise;\n+            else\n+               Insert_With_Hint\n+                 (Dst_Tree => Tree,\n+                  Dst_Hint => null,\n+                  Src_Node => L_Node,\n+                  Dst_Node => Dst_Node);\n+\n+               L_Node := Tree_Operations.Next (L_Node);\n+               R_Node := Tree_Operations.Next (R_Node);\n+            end if;\n+         end loop;\n+\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         return Tree;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+\n+            Delete_Tree (Tree.Root);\n+            raise;\n+      end;\n    end Intersection;\n \n    ---------------\n@@ -324,22 +477,44 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n       declare\n-         Subset_Node : Node_Access := Subset.First;\n-         Set_Node    : Node_Access := Of_Set.First;\n+         BL : Natural renames Subset'Unrestricted_Access.Busy;\n+         LL : Natural renames Subset'Unrestricted_Access.Lock;\n+\n+         BR : Natural renames Of_Set'Unrestricted_Access.Busy;\n+         LR : Natural renames Of_Set'Unrestricted_Access.Lock;\n+\n+         Subset_Node : Node_Access;\n+         Set_Node    : Node_Access;\n+\n+         Result : Boolean;\n \n       begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         Subset_Node := Subset.First;\n+         Set_Node    := Of_Set.First;\n          loop\n             if Set_Node = null then\n-               return Subset_Node = null;\n+               Result := Subset_Node = null;\n+               exit;\n             end if;\n \n             if Subset_Node = null then\n-               return True;\n+               Result := True;\n+               exit;\n             end if;\n \n             if Is_Less (Subset_Node, Set_Node) then\n-               return False;\n+               Result := False;\n+               exit;\n             end if;\n \n             if Is_Less (Set_Node, Subset_Node) then\n@@ -349,6 +524,23 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n                Subset_Node := Tree_Operations.Next (Subset_Node);\n             end if;\n          end loop;\n+\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+\n+            raise;\n       end;\n    end Is_Subset;\n \n@@ -357,31 +549,72 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n    -------------\n \n    function Overlap (Left, Right : Tree_Type) return Boolean is\n-      L_Node : Node_Access := Left.First;\n-      R_Node : Node_Access := Right.First;\n-\n    begin\n       if Left'Address = Right'Address then\n          return Left.Length /= 0;\n       end if;\n \n-      loop\n-         if L_Node = null\n-           or else R_Node = null\n-         then\n-            return False;\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         if Is_Less (L_Node, R_Node) then\n-            L_Node := Tree_Operations.Next (L_Node);\n+      declare\n+         BL : Natural renames Left'Unrestricted_Access.Busy;\n+         LL : Natural renames Left'Unrestricted_Access.Lock;\n \n-         elsif Is_Less (R_Node, L_Node) then\n-            R_Node := Tree_Operations.Next (R_Node);\n+         BR : Natural renames Right'Unrestricted_Access.Busy;\n+         LR : Natural renames Right'Unrestricted_Access.Lock;\n \n-         else\n-            return True;\n-         end if;\n-      end loop;\n+         L_Node : Node_Access;\n+         R_Node : Node_Access;\n+\n+         Result : Boolean;\n+\n+      begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = null\n+              or else R_Node = null\n+            then\n+               Result := False;\n+               exit;\n+            end if;\n+\n+            if Is_Less (L_Node, R_Node) then\n+               L_Node := Tree_Operations.Next (L_Node);\n+\n+            elsif Is_Less (R_Node, L_Node) then\n+               R_Node := Tree_Operations.Next (R_Node);\n+\n+            else\n+               Result := True;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+\n+            raise;\n+      end;\n    end Overlap;\n \n    --------------------------\n@@ -392,23 +625,28 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n      (Target : in out Tree_Type;\n       Source : Tree_Type)\n    is\n-      Tgt : Node_Access := Target.First;\n-      Src : Node_Access := Source.First;\n+      BT : Natural renames Target.Busy;\n+      LT : Natural renames Target.Lock;\n+\n+      BS : Natural renames Source'Unrestricted_Access.Busy;\n+      LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n+      Tgt : Node_Access;\n+      Src : Node_Access;\n \n       New_Tgt_Node : Node_Access;\n       pragma Warnings (Off, New_Tgt_Node);\n \n-   begin\n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      Compare : Integer;\n \n+   begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n+      Tgt := Target.First;\n+      Src := Source.First;\n       loop\n          if Tgt = null then\n             while Src /= null loop\n@@ -428,10 +666,44 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n             return;\n          end if;\n \n-         if Is_Less (Tgt, Src) then\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         begin\n+            BT := BT + 1;\n+            LT := LT + 1;\n+\n+            BS := BS + 1;\n+            LS := LS + 1;\n+\n+            if Is_Less (Tgt, Src) then\n+               Compare := -1;\n+            elsif Is_Less (Src, Tgt) then\n+               Compare := 1;\n+            else\n+               Compare := 0;\n+            end if;\n+\n+            BT := BT - 1;\n+            LT := LT - 1;\n+\n+            BS := BS - 1;\n+            LS := LS - 1;\n+         exception\n+            when others =>\n+               BT := BT - 1;\n+               LT := LT - 1;\n+\n+               BS := BS - 1;\n+               LS := LS - 1;\n+\n+               raise;\n+         end;\n+\n+         if Compare < 0 then\n             Tgt := Tree_Operations.Next (Tgt);\n \n-         elsif Is_Less (Src, Tgt) then\n+         elsif Compare > 0 then\n             Insert_With_Hint\n               (Dst_Tree => Target,\n                Dst_Hint => Tgt,\n@@ -455,17 +727,9 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Tree_Type) return Tree_Type is\n-      Tree : Tree_Type;\n-\n-      L_Node : Node_Access := Left.First;\n-      R_Node : Node_Access := Right.First;\n-\n-      Dst_Node : Node_Access;\n-      pragma Warnings (Off, Dst_Node);\n-\n    begin\n       if Left'Address = Right'Address then\n-         return Tree;  -- Empty set\n+         return Tree_Type'(others => <>);  -- Empty set\n       end if;\n \n       if Right.Length = 0 then\n@@ -476,70 +740,110 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n          return Copy (Right);\n       end if;\n \n-      loop\n-         if L_Node = null then\n-            while R_Node /= null loop\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         BL : Natural renames Left'Unrestricted_Access.Busy;\n+         LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+         BR : Natural renames Right'Unrestricted_Access.Busy;\n+         LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+         Tree : Tree_Type;\n+\n+         L_Node : Node_Access;\n+         R_Node : Node_Access;\n+\n+         Dst_Node : Node_Access;\n+         pragma Warnings (Off, Dst_Node);\n+\n+      begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = null then\n+               while R_Node /= null loop\n+                  Insert_With_Hint\n+                    (Dst_Tree => Tree,\n+                     Dst_Hint => null,\n+                     Src_Node => R_Node,\n+                     Dst_Node => Dst_Node);\n+                  R_Node := Tree_Operations.Next (R_Node);\n+               end loop;\n+\n+               exit;\n+            end if;\n+\n+            if R_Node = null then\n+               while L_Node /= null loop\n+                  Insert_With_Hint\n+                    (Dst_Tree => Tree,\n+                     Dst_Hint => null,\n+                     Src_Node => L_Node,\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Tree_Operations.Next (L_Node);\n+               end loop;\n+\n+               exit;\n+            end if;\n+\n+            if Is_Less (L_Node, R_Node) then\n                Insert_With_Hint\n                  (Dst_Tree => Tree,\n                   Dst_Hint => null,\n-                  Src_Node => R_Node,\n+                  Src_Node => L_Node,\n                   Dst_Node => Dst_Node);\n-               R_Node := Tree_Operations.Next (R_Node);\n-            end loop;\n \n-            return Tree;\n-         end if;\n+               L_Node := Tree_Operations.Next (L_Node);\n \n-         if R_Node = null then\n-            while L_Node /= null loop\n+            elsif Is_Less (R_Node, L_Node) then\n                Insert_With_Hint\n                  (Dst_Tree => Tree,\n                   Dst_Hint => null,\n-                  Src_Node => L_Node,\n+                  Src_Node => R_Node,\n                   Dst_Node => Dst_Node);\n \n-               L_Node := Tree_Operations.Next (L_Node);\n-            end loop;\n+               R_Node := Tree_Operations.Next (R_Node);\n \n-            return Tree;\n-         end if;\n+            else\n+               L_Node := Tree_Operations.Next (L_Node);\n+               R_Node := Tree_Operations.Next (R_Node);\n+            end if;\n+         end loop;\n \n-         if Is_Less (L_Node, R_Node) then\n-            Insert_With_Hint\n-              (Dst_Tree => Tree,\n-               Dst_Hint => null,\n-               Src_Node => L_Node,\n-               Dst_Node => Dst_Node);\n+         BL := BL - 1;\n+         LL := LL - 1;\n \n-            L_Node := Tree_Operations.Next (L_Node);\n+         BR := BR - 1;\n+         LR := LR - 1;\n \n-         elsif Is_Less (R_Node, L_Node) then\n-            Insert_With_Hint\n-              (Dst_Tree => Tree,\n-               Dst_Hint => null,\n-               Src_Node => R_Node,\n-               Dst_Node => Dst_Node);\n+         return Tree;\n+      exception\n+         when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n \n-            R_Node := Tree_Operations.Next (R_Node);\n+            BR := BR - 1;\n+            LR := LR - 1;\n \n-         else\n-            L_Node := Tree_Operations.Next (L_Node);\n-            R_Node := Tree_Operations.Next (R_Node);\n-         end if;\n-      end loop;\n-\n-   exception\n-      when others =>\n-         Delete_Tree (Tree.Root);\n-         raise;\n+            Delete_Tree (Tree.Root);\n+            raise;\n+      end;\n    end Symmetric_Difference;\n \n    -----------\n    -- Union --\n    -----------\n \n-   procedure Union (Target : in out Tree_Type; Source : Tree_Type)\n-   is\n+   procedure Union (Target : in out Tree_Type; Source : Tree_Type) is\n       Hint : Node_Access;\n \n       procedure Process (Node : Node_Access);\n@@ -555,7 +859,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n       begin\n          Insert_With_Hint\n            (Dst_Tree => Target,\n-            Dst_Hint => Hint,\n+            Dst_Hint => Hint,  -- use node most recently inserted as hint\n             Src_Node => Node,\n             Dst_Node => Hint);\n       end Process;\n@@ -567,12 +871,28 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         BS : Natural renames Source'Unrestricted_Access.Busy;\n+         LS : Natural renames Source'Unrestricted_Access.Lock;\n+\n+      begin\n+         BS := BS + 1;\n+         LS := LS + 1;\n+\n+         Iterate (Source);\n \n-      Iterate (Source);\n+         BS := BS - 1;\n+         LS := LS - 1;\n+      exception\n+         when others =>\n+            BS := BS - 1;\n+            LS := LS - 1;\n+\n+            raise;\n+      end;\n    end Union;\n \n    function Union (Left, Right : Tree_Type) return Tree_Type is\n@@ -590,6 +910,12 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n       end if;\n \n       declare\n+         BL : Natural renames Left'Unrestricted_Access.Busy;\n+         LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+         BR : Natural renames Right'Unrestricted_Access.Busy;\n+         LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n          Tree : Tree_Type := Copy (Left);\n \n          Hint : Node_Access;\n@@ -608,23 +934,40 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n          begin\n             Insert_With_Hint\n               (Dst_Tree => Tree,\n-               Dst_Hint => Hint,\n+               Dst_Hint => Hint,  -- use node most recently inserted as hint\n                Src_Node => Node,\n                Dst_Node => Hint);\n          end Process;\n \n       --  Start of processing for Union\n \n       begin\n+         BL := BL + 1;\n+         LL := LL + 1;\n+\n+         BR := BR + 1;\n+         LR := LR + 1;\n+\n          Iterate (Right);\n-         return Tree;\n \n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         return Tree;\n       exception\n          when others =>\n+            BL := BL - 1;\n+            LL := LL - 1;\n+\n+            BR := BR - 1;\n+            LR := LR - 1;\n+\n             Delete_Tree (Tree.Root);\n             raise;\n       end;\n-\n    end Union;\n \n end Ada.Containers.Red_Black_Trees.Generic_Set_Operations;"}, {"sha": "fd85df969231a57ec2c9c84d5402f6e7bf4bca3d", "filename": "gcc/ada/cio.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fcio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fcio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcio.c?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -40,6 +40,9 @@\n \n #include \"adaint.h\"\n \n+/* We need L_tmpnam definition */\n+#include <stdio.h>\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -135,7 +138,18 @@ put_char_stderr (int c)\n char *\n mktemp (char *template)\n {\n+#if !(defined (__RTP__) || defined (VTHREADS))\n+  static char buf[L_tmpnam]; /* Internal buffer for name */\n+\n+  /* If parameter is NULL use internal buffer */\n+  if (template == NULL)\n+    template = buf;\n+\n+  __gnat_tmp_name (template);\n+  return template;\n+#else\n   return tmpnam (NULL);\n+#endif\n }\n #endif\n "}, {"sha": "18095508a0c9ce00b4d186d1f3e68c8417529fd7", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -134,7 +134,7 @@ package body Debug is\n    --  d.N  Add node to all entities\n    --  d.O  Dump internal SCO tables\n    --  d.P  Previous (non-optimized) handling of length comparisons\n-   --  d.Q\n+   --  d.Q  Flow Analysis mode for gnat2why\n    --  d.R  Restrictions in ali files in positional form\n    --  d.S  Force Optimize_Alignment (Space)\n    --  d.T  Force Optimize_Alignment (Time)\n@@ -648,6 +648,9 @@ package body Debug is\n    --       This is there in case we find a situation where the optimization\n    --       malfunctions, to provide a work around.\n \n+   --  d.Q  Flow Analysis mode for gnat2why. When this flag is given,\n+   --       gnat2why will do flow analysis, and no translation to Why is done.\n+\n    --  d.R  As documented in lib-writ.ads, restrictions in the ali file can\n    --       have two forms, positional and named. The named notation is the\n    --       current preferred form, but the use of this debug switch will force"}, {"sha": "35d7a9f3029c72203a13f07e767b1147ff86e249", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -4825,10 +4825,146 @@ package body Exp_Ch3 is\n       --  which case the init proc call must be inserted only after the bodies\n       --  of the shared variable procedures have been seen.\n \n+      function Build_Equivalent_Aggregate return Boolean;\n+      --  If the object has a constrained discriminated type and no initial\n+      --  value, it may be possible to build an equivalent aggregate instead,\n+      --  and prevent an actual call to the initialization procedure.\n+\n       function Rewrite_As_Renaming return Boolean;\n       --  Indicate whether to rewrite a declaration with initialization into an\n       --  object renaming declaration (see below).\n \n+      --------------------------------\n+      -- Build_Equivalent_Aggregate --\n+      --------------------------------\n+\n+      function Build_Equivalent_Aggregate return Boolean is\n+         Aggr      : Node_Id;\n+         Comp      : Entity_Id;\n+         Discr     : Elmt_Id;\n+         Full_Type : Entity_Id;\n+\n+      begin\n+         Full_Type := Typ;\n+         if Is_Private_Type (Typ)\n+           and then Present (Full_View (Typ))\n+         then\n+            Full_Type := Full_View (Typ);\n+         end if;\n+\n+         --  Only perform this transformation if Elaboration_Code is forbidden\n+         --  or undesirable, and if this is a global entity of a constrained\n+         --  record type.\n+\n+         --  If Initialize_Scalars might be active this  transformation cannot\n+         --  be performed either, because it will lead to different semantics\n+         --  or because elaboration code will in fact be created.\n+\n+         if Ekind (Full_Type) /= E_Record_Subtype\n+           or else not Has_Discriminants (Full_Type)\n+           or else not Is_Constrained (Full_Type)\n+           or else Is_Controlled (Full_Type)\n+           or else Is_Limited_Type (Full_Type)\n+           or else not Restriction_Active (No_Initialize_Scalars)\n+         then\n+            return False;\n+         end if;\n+\n+         if Ekind (Current_Scope) = E_Package\n+          and then\n+            (Restriction_Active (No_Elaboration_Code)\n+              or else Is_Preelaborated (Current_Scope))\n+         then\n+\n+            --  Building a static aggregate is possible if the discriminants\n+            --  have static values and the other components have static\n+            --  defaults or none.\n+\n+            Discr := First_Elmt (Discriminant_Constraint (Full_Type));\n+            while Present (Discr) loop\n+               if not Is_OK_Static_Expression (Node (Discr)) then\n+                  return False;\n+               end if;\n+\n+               Next_Elmt (Discr);\n+            end loop;\n+\n+            --  Check that initialized components are OK, and that non-\n+            --  initialized components do not require a call to their own\n+            --  initialization procedure.\n+\n+            Comp := First_Component (Full_Type);\n+            while Present (Comp) loop\n+               if Ekind (Comp) = E_Component\n+                 and then Present (Expression (Parent (Comp)))\n+                 and then\n+                   not Is_OK_Static_Expression (Expression (Parent (Comp)))\n+               then\n+                  return False;\n+\n+               elsif Has_Non_Null_Base_Init_Proc (Etype (Comp)) then\n+                  return False;\n+\n+               end if;\n+\n+               Next_Component (Comp);\n+            end loop;\n+\n+            --  Everything is static, assemble the aggregate, discriminant\n+            --  values first.\n+\n+            Aggr :=\n+               Make_Aggregate (Loc,\n+                Expressions            => New_List,\n+                Component_Associations => New_List);\n+\n+            Discr := First_Elmt (Discriminant_Constraint (Full_Type));\n+            while Present (Discr) loop\n+               Append_To (Expressions (Aggr), New_Copy (Node (Discr)));\n+               Next_Elmt (Discr);\n+            end loop;\n+\n+            --  Now collect values of initialized components.\n+\n+            Comp := First_Component (Full_Type);\n+            while Present (Comp) loop\n+               if Ekind (Comp) = E_Component\n+                 and then Present (Expression (Parent (Comp)))\n+               then\n+                  Append_To (Component_Associations (Aggr),\n+                    Make_Component_Association (Loc,\n+                      Choices    => New_List (New_Occurrence_Of (Comp, Loc)),\n+                      Expression => New_Copy_Tree\n+                                      (Expression (Parent (Comp)))));\n+               end if;\n+\n+               Next_Component (Comp);\n+            end loop;\n+\n+            --  Finally, box-initialize remaining components.\n+\n+            Append_To (Component_Associations (Aggr),\n+              Make_Component_Association (Loc,\n+                Choices => New_List (Make_Others_Choice (Loc)),\n+                Expression => Empty));\n+            Set_Box_Present (Last (Component_Associations (Aggr)));\n+            Set_Expression (N, Aggr);\n+\n+            if Typ /= Full_Type then\n+               Analyze_And_Resolve (Aggr, Full_View (Base_Type (Full_Type)));\n+               Rewrite (Aggr, Unchecked_Convert_To (Typ, Aggr));\n+               Analyze_And_Resolve (Aggr, Typ);\n+            else\n+               Analyze_And_Resolve (Aggr, Full_Type);\n+            end if;\n+\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Build_Equivalent_Aggregate;\n+\n       -------------------------\n       -- Rewrite_As_Renaming --\n       -------------------------\n@@ -5033,6 +5169,14 @@ package body Exp_Ch3 is\n                     (N, New_Copy_Tree (Init_Expr, New_Scope => Current_Scope));\n                   return;\n \n+               --  If type has discriminants, try to build equivalent\n+               --  aggregate using discriminant values from the declaration.\n+               --  This is a useful optimization, in particular if restriction\n+               --  No_Elaboration_Code is active.\n+\n+               elsif Build_Equivalent_Aggregate then\n+                  return;\n+\n                else\n                   Initialization_Warning (Id_Ref);\n "}, {"sha": "a69281130ddfd2837b2f37af9909eecedbe4a700", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -365,7 +365,6 @@ package body Prj.Attr is\n    --  package Remote\n \n    \"Premote#\" &\n-   \"LVbuild_slaves#\" &\n    \"SVroot_dir#\" &\n \n    --  package Stack"}, {"sha": "9572d6882ca90eb8a41b1df9562ac78d049823bc", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -1271,6 +1271,15 @@ package body Prj.Makr is\n                              new String'(Get_Name_String (Tmp_File));\n                         end if;\n \n+                        --  On VMS, a file created with Create_Temp_File cannot\n+                        --  be used to redirect output.\n+\n+                        if Hostparm.OpenVMS then\n+                           Close (FD);\n+                           Delete_File (Temp_File_Name.all, Success);\n+                           FD := Create_Output_Text_File (Temp_File_Name.all);\n+                        end if;\n+\n                         Args (Args'Last) := new String'\n                           (Dir_Name &\n                            Directory_Separator &"}, {"sha": "dee9b9019629c40ab71d09f67f11be24aa2d2037", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -1101,31 +1101,6 @@ The following attributes can be defined in package @code{Remote}:\n \n @table @asis\n \n-@item @b{Build_Slaves}\n-@cindex @code{Build_Slaves}\n-\n-A list of string referencing the remote build slaves to use for the\n-compilation phase. The format is:\n-@code{[protocol://]name.domain[:port]}.\n-\n-Where @code{protocol} is one of:\n-\n-@table @asis\n-\n-@item rsync\n-@cindex @code{rsync}\n-\n-The sources are copied using the external @code{rsync} tool.\n-\n-@item file\n-\n-The sources are accessed via a shared directory or mount point.\n-\n-@end table\n-\n-The default port used to communicate with @command{gprslave} is\n-@code{8484}.\n-\n @item @b{Root_Dir}:\n @cindex @code{Root_Dir}\n "}, {"sha": "0f0053ffeaaf7e1edd93e7439ec1aa60a18ba911", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -1205,7 +1205,6 @@ package Snames is\n    Name_Archive_Suffix                     : constant Name_Id := N + $;\n    Name_Binder                             : constant Name_Id := N + $;\n    Name_Body_Suffix                        : constant Name_Id := N + $;\n-   Name_Build_Slaves                       : constant Name_Id := N + $;\n    Name_Builder                            : constant Name_Id := N + $;\n    Name_Clean                              : constant Name_Id := N + $;\n    Name_Compiler                           : constant Name_Id := N + $;"}, {"sha": "d9d63eaeca5709aab1cb19bb5ffc9f98421b9f5d", "filename": "gcc/ada/urealp.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Furealp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f11067a1011e49909905be0ea421c4fc8dd1cc/gcc%2Fada%2Furealp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.ads?ref=e7f11067a1011e49909905be0ea421c4fc8dd1cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,7 +46,7 @@ package Urealp is\n    --  use the UR_Eq function).\n \n    --  A Ureal value represents an arbitrary precision universal real value,\n-   --  stored internally using four components\n+   --  stored internally using four components:\n \n    --    the numerator (Uint, always non-negative)\n    --    the denominator (Uint, always non-zero, always positive if base = 0)\n@@ -125,7 +125,7 @@ package Urealp is\n    --  Returns value 10.0 ** 36\n \n    function Ureal_M_10_36 return Ureal;\n-   --  Returns value -(10.0\n+   --  Returns value -10.0 ** 36\n \n    -----------------\n    -- Subprograms --"}]}