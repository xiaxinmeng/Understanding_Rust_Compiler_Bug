{"sha": "408e8b906632f215f6652b8851bba612cde07c25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA4ZThiOTA2NjMyZjIxNWY2NjUyYjg4NTFiYmE2MTJjZGUwN2MyNQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-09-09T09:56:01Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-09-13T10:26:47Z"}, "message": "rtl: directly handle MEM in gen_highpart [PR102125]\n\ngen_lowpart_general handles forming a lowpart of a MEM by using\nadjust_address to rework and validate a new version of the MEM.\nDo the same for gen_highpart rather than calling simplify_gen_subreg\nfor this case.\n\ngcc/ChangeLog:\n\n\tPR target/102125\n\t* emit-rtl.c (gen_highpart): Use adjust_address to handle\n\tMEM rather than calling simplify_gen_subreg.", "tree": {"sha": "81192ff3c414005b02b317432a5409fcfe80a852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81192ff3c414005b02b317432a5409fcfe80a852"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/408e8b906632f215f6652b8851bba612cde07c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408e8b906632f215f6652b8851bba612cde07c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408e8b906632f215f6652b8851bba612cde07c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408e8b906632f215f6652b8851bba612cde07c25/comments", "author": null, "committer": null, "parents": [{"sha": "c012297c9d5dfb177adf1423bdd05e5f4b87e5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c012297c9d5dfb177adf1423bdd05e5f4b87e5ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c012297c9d5dfb177adf1423bdd05e5f4b87e5ec"}], "stats": {"total": 23, "additions": 13, "deletions": 10}, "files": [{"sha": "e6158f243c00676dbfd3c1a578966f1a0b6b4b42", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408e8b906632f215f6652b8851bba612cde07c25/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408e8b906632f215f6652b8851bba612cde07c25/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=408e8b906632f215f6652b8851bba612cde07c25", "patch": "@@ -1625,19 +1625,22 @@ gen_highpart (machine_mode mode, rtx x)\n   gcc_assert (known_le (msize, (unsigned int) UNITS_PER_WORD)\n \t      || known_eq (msize, GET_MODE_UNIT_SIZE (GET_MODE (x))));\n \n-  result = simplify_gen_subreg (mode, x, GET_MODE (x),\n-\t\t\t\tsubreg_highpart_offset (mode, GET_MODE (x)));\n-  gcc_assert (result);\n-\n-  /* simplify_gen_subreg is not guaranteed to return a valid operand for\n-     the target if we have a MEM.  gen_highpart must return a valid operand,\n-     emitting code if necessary to do so.  */\n-  if (MEM_P (result))\n+  /* gen_lowpart_common handles a lot of special cases due to needing to handle\n+     paradoxical subregs; it only calls simplify_gen_subreg when certain that\n+     it will produce something meaningful.  The only case we need to handle\n+     specially here is MEM.  */\n+  if (MEM_P (x))\n     {\n-      result = validize_mem (result);\n-      gcc_assert (result);\n+      poly_int64 offset = subreg_highpart_offset (mode, GET_MODE (x));\n+      return adjust_address (x, mode, offset);\n     }\n \n+  result = simplify_gen_subreg (mode, x, GET_MODE (x),\n+\t\t\t\tsubreg_highpart_offset (mode, GET_MODE (x)));\n+  /* Since we handle MEM directly above, we should never get a MEM back\n+     from simplify_gen_subreg.  */\n+  gcc_assert (result && !MEM_P (result));\n+\n   return result;\n }\n "}]}