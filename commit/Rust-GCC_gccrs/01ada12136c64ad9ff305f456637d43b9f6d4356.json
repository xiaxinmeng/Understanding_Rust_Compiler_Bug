{"sha": "01ada12136c64ad9ff305f456637d43b9f6d4356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFhZGExMjEzNmM2NGFkOWZmMzA1ZjQ1NjYzN2Q0M2I5ZjZkNDM1Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-11-21T00:40:53Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-11-21T00:40:53Z"}, "message": "C++: provide macro used-before-defined hint (PR c++/72786)\n\nThis patch uses the name_hint/deferred_diagnostic to provide\na message in the C++ frontend if a macro is used before it is defined\ne.g.:\n\ntest.c:6:24: error: expected ';' at end of member declaration\n   virtual void clone() const OVERRIDE { }\n                        ^~~~~\n                             ;\ntest.c:6:30: error: 'OVERRIDE' does not name a type\n   virtual void clone() const OVERRIDE { }\n                              ^~~~~~~~\ntest.c:6:30: note: the macro 'OVERRIDE' had not yet been defined\ntest.c:15:0: note: it was later defined here\n #define OVERRIDE override\n\nIt's possible to do it from the C++ frontend as tokenization happens\nup-front (and hence the macro already exists when the above is parsed);\nI attempted to do it from the C frontend, but because the C frontend only\ntokenizes on-demand during parsing, the macro isn't known about until\nlater.\n\ngcc/cp/ChangeLog:\n\tPR c++/72786\n\t* name-lookup.c (class macro_use_before_def): New class.\n\t(lookup_name_fuzzy): Detect macro that were used before being\n\tdefined, and report them as such.\n\ngcc/ChangeLog:\n\tPR c++/72786\n\t* spellcheck.h (best_match::blithely_get_best_candidate): New\n\taccessor.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/72786\n\t* g++.dg/spellcheck-macro-ordering-2.C: New test case.\n\t* g++.dg/spellcheck-macro-ordering.C: Add dg-message directives\n\tfor macro used-before-defined.\n\nlibcpp/ChangeLog:\n\tPR c++/72786\n\t* include/cpplib.h (cpp_macro_definition_location): New decl.\n\t* macro.c (cpp_macro_definition): New function.\n\nFrom-SVN: r254978", "tree": {"sha": "2fd6c86557307e928d7444794521945cbde6d559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fd6c86557307e928d7444794521945cbde6d559"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01ada12136c64ad9ff305f456637d43b9f6d4356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ada12136c64ad9ff305f456637d43b9f6d4356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ada12136c64ad9ff305f456637d43b9f6d4356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ada12136c64ad9ff305f456637d43b9f6d4356/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "874b8068f6c4cab53b14b7d2db117abd71f7da95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874b8068f6c4cab53b14b7d2db117abd71f7da95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874b8068f6c4cab53b14b7d2db117abd71f7da95"}], "stats": {"total": 112, "additions": 109, "deletions": 3}, "files": [{"sha": "0255d8a3744bbde2f1a031b002d8d4627c845076", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -1,3 +1,9 @@\n+2017-11-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/72786\n+\t* spellcheck.h (best_match::blithely_get_best_candidate): New\n+\taccessor.\n+\n 2017-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (parse_mtune_ctrl_str): Start diagnostics"}, {"sha": "908b48ef09bc5ab788c444e1491194cf9c72b2bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -1,3 +1,10 @@\n+2017-11-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/72786\n+\t* name-lookup.c (class macro_use_before_def): New class.\n+\t(lookup_name_fuzzy): Detect macro that were used before being\n+\tdefined, and report them as such.\n+\n 2017-11-20  Jason Merrill  <jason@redhat.com>\n \n \t* decl2.c (constrain_class_visibility): Don't warn about artificial"}, {"sha": "fc317b175fb0fa09644396c3c9da75850393a1bf", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -5636,12 +5636,49 @@ consider_binding_level (tree name, best_match <tree, const char *> &bm,\n     }\n }\n \n+/* Subclass of deferred_diagnostic.  Notify the user that the\n+   given macro was used before it was defined.\n+   This can be done in the C++ frontend since tokenization happens\n+   upfront.  */\n+\n+class macro_use_before_def : public deferred_diagnostic\n+{\n+ public:\n+  /* Ctor.  LOC is the location of the usage.  MACRO is the\n+     macro that was used.  */\n+  macro_use_before_def (location_t loc, cpp_hashnode *macro)\n+  : deferred_diagnostic (loc), m_macro (macro)\n+  {\n+    gcc_assert (macro);\n+  }\n+\n+  ~macro_use_before_def ()\n+  {\n+    if (is_suppressed_p ())\n+      return;\n+\n+    source_location def_loc = cpp_macro_definition_location (m_macro);\n+    if (def_loc != UNKNOWN_LOCATION)\n+      {\n+\tinform (get_location (), \"the macro %qs had not yet been defined\",\n+\t\t(const char *)m_macro->ident.str);\n+\tinform (def_loc, \"it was later defined here\");\n+      }\n+  }\n+\n+ private:\n+  cpp_hashnode *m_macro;\n+};\n+\n+\n /* Search for near-matches for NAME within the current bindings, and within\n    macro names, returning the best match as a const char *, or NULL if\n-   no reasonable match is found.  */\n+   no reasonable match is found.\n+\n+   Use LOC for any deferred diagnostics.  */\n \n name_hint\n-lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind, location_t)\n+lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind, location_t loc)\n {\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n@@ -5671,6 +5708,15 @@ lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind, location_t)\n   /* If a macro is the closest so far to NAME, consider it.  */\n   if (best_macro)\n     bm.consider ((const char *)best_macro->ident.str);\n+  else if (bmm.get_best_distance () == 0)\n+    {\n+      /* If we have an exact match for a macro name, then the\n+\t macro has been used before it was defined.  */\n+      cpp_hashnode *macro = bmm.blithely_get_best_candidate ();\n+      if (macro)\n+\treturn name_hint (NULL,\n+\t\t\t  new macro_use_before_def (loc, macro));\n+    }\n \n   /* Try the \"starts_decl_specifier_p\" keywords to detect\n      \"singed\" vs \"signed\" typos.  */"}, {"sha": "bad3c1e2c3778b1a826700d62b44f7e416cf23e0", "filename": "gcc/spellcheck.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -178,6 +178,13 @@ class best_match\n     return m_best_candidate;\n   }\n \n+  /* Get the closest candidate so far, without applying any filtering.  */\n+\n+  candidate_t blithely_get_best_candidate () const\n+  {\n+    return m_best_candidate;\n+  }\n+\n   edit_distance_t get_best_distance () const { return m_best_distance; }\n   size_t get_best_candidate_length () const { return m_best_candidate_len; }\n "}, {"sha": "4c9569f13a94d4fe5149c1b62d81b829149ff901", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -1,3 +1,10 @@\n+2017-11-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/72786\n+\t* g++.dg/spellcheck-macro-ordering-2.C: New test case.\n+\t* g++.dg/spellcheck-macro-ordering.C: Add dg-message directives\n+\tfor macro used-before-defined.\n+\n 2017-11-20  Steve Ellcey  <sellcey@cavium.com>\n \n \tPR target/81356"}, {"sha": "73c0f21ee458989d1f8af901c5529a0acdf183e8", "filename": "gcc/testsuite/g++.dg/spellcheck-macro-ordering-2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-macro-ordering-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-macro-ordering-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-macro-ordering-2.C?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/72786\n+\n+/* Example of undeffed macro.  */\n+\n+#define OVERRIDE override\n+\n+#undef OVERRIDE\n+\n+class DocTargetDriver {\n+  virtual void clone() const OVERRIDE { } // { dg-line usage }\n+  /* Offering \"OVERRIDE\" as a spelling suggestion for \"OVERRIDE\" would be\n+     nonsensical.  */\n+  // { dg-bogus \"did you mean\" \"\" { target *-*-* } usage }\n+  // { dg-error \"expected .;. at end of member declaration\" \"\" { target *-*-* } usage }\n+  // { dg-error \".OVERRIDE. does not name a type\" \"\" { target *-*-* } usage }\n+  // { dg-bogus \"macro\" \"\" { target *-*-* } usage }\n+};"}, {"sha": "bbd41f48e09ff638b9c37b15afb7aacc8dba6d99", "filename": "gcc/testsuite/g++.dg/spellcheck-macro-ordering.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-macro-ordering.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-macro-ordering.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-macro-ordering.C?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -9,7 +9,8 @@ class DocTargetDriver {\n   // { dg-bogus \"did you mean\" \"\" { target *-*-* } .-3 }\n   // { dg-error \"expected .;. at end of member declaration\" \"\" { target *-*-* } .-4 }\n   // { dg-error \".OVERRIDE. does not name a type\" \"\" { target *-*-* } .-5 }\n+  // { dg-message \"the macro 'OVERRIDE' had not yet been defined\" \"\" { target *-*-* } .-6 }\n };\n \n #define OVERRIDE override\n-\n+// { dg-message \"-:it was later defined here\" \"\" { target *-*-* } .-1 }"}, {"sha": "cc5d4d392c0a7ff0b2b9559d86c038cbfc43f669", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -1,3 +1,9 @@\n+2017-11-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/72786\n+\t* include/cpplib.h (cpp_macro_definition_location): New decl.\n+\t* macro.c (cpp_macro_definition): New function.\n+\n 2017-11-13  Tom Tromey  <tom@tromey.com>\n \n \t* pch.c (cpp_read_state): Set n__VA_OPT__."}, {"sha": "4d04a48a0e4782287f662adcbaf33b09d1c40989", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -889,6 +889,7 @@ extern const cpp_token *cpp_get_token_with_location (cpp_reader *,\n extern bool cpp_fun_like_macro_p (cpp_hashnode *);\n extern const unsigned char *cpp_macro_definition (cpp_reader *,\n \t\t\t\t\t\t  cpp_hashnode *);\n+extern source_location cpp_macro_definition_location (cpp_hashnode *);\n extern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n extern const cpp_token *cpp_peek_token (cpp_reader *, int);\n "}, {"sha": "43f2baa67b37643ffd24df36ebb081e3fd841381", "filename": "libcpp/macro.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01ada12136c64ad9ff305f456637d43b9f6d4356/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01ada12136c64ad9ff305f456637d43b9f6d4356/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=01ada12136c64ad9ff305f456637d43b9f6d4356", "patch": "@@ -3646,3 +3646,11 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n   *buffer = '\\0';\n   return pfile->macro_buffer;\n }\n+\n+/* Get the line at which the macro was defined.  */\n+\n+source_location\n+cpp_macro_definition_location (cpp_hashnode *node)\n+{\n+  return node->value.macro->line;\n+}"}]}