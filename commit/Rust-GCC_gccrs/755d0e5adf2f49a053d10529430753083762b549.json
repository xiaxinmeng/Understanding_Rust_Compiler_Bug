{"sha": "755d0e5adf2f49a053d10529430753083762b549", "node_id": "C_kwDOANBUbNoAKDc1NWQwZTVhZGYyZjQ5YTA1M2QxMDUyOTQzMDc1MzA4Mzc2MmI1NDk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-18T13:07:13Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-18T13:07:13Z"}, "message": "Refactor AST::ResolveExpr into its own cc file", "tree": {"sha": "492c8799b783ddcc47f38768b88c582e28cc491c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/492c8799b783ddcc47f38768b88c582e28cc491c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/755d0e5adf2f49a053d10529430753083762b549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/755d0e5adf2f49a053d10529430753083762b549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/755d0e5adf2f49a053d10529430753083762b549", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/755d0e5adf2f49a053d10529430753083762b549/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de08987dc79dabed17b5e287e76f8d623cbfa34e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de08987dc79dabed17b5e287e76f8d623cbfa34e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de08987dc79dabed17b5e287e76f8d623cbfa34e"}], "stats": {"total": 901, "additions": 518, "deletions": 383}, "files": [{"sha": "65c9bbabc14534d145dfb6aaf9e1a085a01ef123", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=755d0e5adf2f49a053d10529430753083762b549", "patch": "@@ -81,6 +81,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-resolve.o \\\n     rust/rust-ast-resolve-pattern.o \\\n+    rust/rust-ast-resolve-expr.o \\\n     rust/rust-ast-resolve-type.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\"}, {"sha": "84fcb42170f860f51c5db2344300f558480dd8d5", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=755d0e5adf2f49a053d10529430753083762b549", "patch": "@@ -0,0 +1,481 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n+#include \"rust-ast-verify-assignee.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveExpr::go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n+\t\t const CanonicalPath &canonical_prefix)\n+{\n+  ResolveExpr resolver (parent, prefix, canonical_prefix);\n+  expr->accept_vis (resolver);\n+}\n+\n+void\n+ResolveExpr::visit (AST::MacroInvocation &expr)\n+{\n+  AST::ASTFragment &fragment = expr.get_fragment ();\n+  for (auto &node : fragment.get_nodes ())\n+    node.accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::TupleIndexExpr &expr)\n+{\n+  resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    return;\n+\n+  for (auto &elem : expr.get_tuple_elems ())\n+    resolve_expr (elem.get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::PathInExpression &expr)\n+{\n+  ResolvePath::go (&expr, parent);\n+}\n+\n+void\n+ResolveExpr::visit (AST::QualifiedPathInExpression &expr)\n+{\n+  ResolvePath::go (&expr, parent);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ReturnExpr &expr)\n+{\n+  if (expr.has_returned_expr ())\n+    resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::CallExpr &expr)\n+{\n+  resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n+  auto const &in_params = expr.get_params ();\n+  for (auto &param : in_params)\n+    resolve_expr (param.get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::MethodCallExpr &expr)\n+{\n+  resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+\n+  if (expr.get_method_name ().has_generic_args ())\n+    {\n+      AST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+      ResolveTypeToCanonicalPath::type_resolve_generic_args (args);\n+    }\n+\n+  auto const &in_params = expr.get_params ();\n+  for (auto &param : in_params)\n+    resolve_expr (param.get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::AssignmentExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+\n+  // need to verify the assignee\n+  VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IdentifierExpr &expr)\n+{\n+  if (resolver->get_name_scope ().lookup (\n+\tCanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t&resolved_node))\n+    {\n+      resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+      resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t       Definition{expr.get_node_id (), parent});\n+    }\n+  else if (resolver->get_type_scope ().lookup (\n+\t     CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t     &resolved_node))\n+    {\n+      resolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n+      resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t       Definition{expr.get_node_id (), parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to find name: %s\",\n+\t\t     expr.as_string ().c_str ());\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::CompoundAssignmentExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+\n+  // need to verify the assignee\n+  VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ComparisonExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::LazyBooleanExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::NegationExpr &expr)\n+{\n+  resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::TypeCastExpr &expr)\n+{\n+  ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExpr &expr)\n+{\n+  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExprConseqElse &expr)\n+{\n+  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExprConseqIf &expr)\n+{\n+  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::BlockExpr &expr)\n+{\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (s->is_item ())\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n+    }\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (!s->is_item ())\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n+    }\n+\n+  if (expr.has_tail_expr ())\n+    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::visit (AST::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayElemsValues &elems)\n+{\n+  for (auto &elem : elems.get_values ())\n+    resolve_expr (elem.get (), elems.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayExpr &expr)\n+{\n+  expr.get_array_elems ()->accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayIndexExpr &expr)\n+{\n+  resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayElemsCopied &elems)\n+{\n+  resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n+  resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n+}\n+\n+// this this an empty struct constructor like 'S {}'\n+void\n+ResolveExpr::visit (AST::StructExprStruct &struct_expr)\n+{\n+  resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n+}\n+\n+// this this a struct constructor with fields\n+void\n+ResolveExpr::visit (AST::StructExprStructFields &struct_expr)\n+{\n+  resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n+\n+  if (struct_expr.has_struct_base ())\n+    {\n+      AST::StructBase &base = struct_expr.get_struct_base ();\n+      resolve_expr (base.get_base_struct ().get (), struct_expr.get_node_id ());\n+    }\n+\n+  auto const &struct_fields = struct_expr.get_fields ();\n+  for (auto &struct_field : struct_fields)\n+    {\n+      ResolveStructExprField::go (struct_field.get (),\n+\t\t\t\t  struct_expr.get_node_id (), prefix,\n+\t\t\t\t  canonical_prefix);\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::GroupedExpr &expr)\n+{\n+  resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::FieldAccessExpr &expr)\n+{\n+  resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::LoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (expr.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+      resolver->insert_new_definition (label_lifetime_node_id,\n+\t\t\t\t       Definition{label_lifetime_node_id,\n+\t\t\t\t\t\t  label.get_node_id ()});\n+    }\n+  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::BreakExpr &expr)\n+{\n+  if (expr.has_label ())\n+    {\n+      auto label = expr.get_label ();\n+      if (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      NodeId resolved_node = UNKNOWN_NODEID;\n+      if (!resolver->get_label_scope ().lookup (\n+\t    CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t    label.get_lifetime_name ()),\n+\t    &resolved_node))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to resolve label\");\n+\t  return;\n+\t}\n+      resolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+    }\n+\n+  if (expr.has_break_expr ())\n+    resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::WhileLoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (label.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+      resolver->insert_new_definition (label_lifetime_node_id,\n+\t\t\t\t       Definition{label_lifetime_node_id,\n+\t\t\t\t\t\t  label.get_node_id ()});\n+    }\n+  resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ContinueExpr &expr)\n+{\n+  if (expr.has_label ())\n+    {\n+      auto label = expr.get_label ();\n+      if (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      NodeId resolved_node = UNKNOWN_NODEID;\n+      if (!resolver->get_label_scope ().lookup (\n+\t    CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t    label.get_lifetime_name ()),\n+\t    &resolved_node))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to resolve label\");\n+\t  return;\n+\t}\n+      resolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::BorrowExpr &expr)\n+{\n+  resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::DereferenceExpr &expr)\n+{\n+  resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::MatchExpr &expr)\n+{\n+  resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      // each arm is in its own scope\n+      NodeId scope_node_id = match_case.get_node_id ();\n+      resolver->get_name_scope ().push (scope_node_id);\n+      resolver->get_type_scope ().push (scope_node_id);\n+      resolver->get_label_scope ().push (scope_node_id);\n+      resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+      resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+      resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+      // resolve\n+      AST::MatchArm &arm = match_case.get_arm ();\n+      if (arm.has_match_arm_guard ())\n+\tresolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\n+      // insert any possible new patterns\n+      for (auto &pattern : arm.get_patterns ())\n+\t{\n+\t  PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n+\t}\n+\n+      // resolve the body\n+      resolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n+\n+      // done\n+      resolver->get_name_scope ().pop ();\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_label_scope ().pop ();\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "80811338d2d5a720d1614bc16b9bf332c5302264", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 36, "deletions": 348, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=755d0e5adf2f49a053d10529430753083762b549", "patch": "@@ -64,393 +64,81 @@ class ResolveExpr : public ResolverBase\n \n public:\n   static void go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    ResolveExpr resolver (parent, prefix, canonical_prefix);\n-    expr->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::MacroInvocation &expr) override\n-  {\n-    AST::ASTFragment &fragment = expr.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n-  void visit (AST::TupleIndexExpr &expr) override\n-  {\n-    resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n-  }\n+\t\t  const CanonicalPath &canonical_prefix);\n \n-  void visit (AST::TupleExpr &expr) override\n-  {\n-    if (expr.is_unit ())\n-      return;\n+  void visit (AST::MacroInvocation &expr) override;\n \n-    for (auto &elem : expr.get_tuple_elems ())\n-      resolve_expr (elem.get (), expr.get_node_id ());\n-  }\n+  void visit (AST::TupleIndexExpr &expr) override;\n \n-  void visit (AST::PathInExpression &expr) override\n-  {\n-    ResolvePath::go (&expr, parent);\n-  }\n-\n-  void visit (AST::QualifiedPathInExpression &expr) override\n-  {\n-    ResolvePath::go (&expr, parent);\n-  }\n-\n-  void visit (AST::ReturnExpr &expr) override\n-  {\n-    if (expr.has_returned_expr ())\n-      resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n-  }\n-\n-  void visit (AST::CallExpr &expr) override\n-  {\n-    resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n-    auto const &in_params = expr.get_params ();\n-    for (auto &param : in_params)\n-      resolve_expr (param.get (), expr.get_node_id ());\n-  }\n+  void visit (AST::TupleExpr &expr) override;\n \n-  void visit (AST::MethodCallExpr &expr) override\n-  {\n-    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+  void visit (AST::PathInExpression &expr) override;\n \n-    if (expr.get_method_name ().has_generic_args ())\n-      {\n-\tAST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-\tResolveTypeToCanonicalPath::type_resolve_generic_args (args);\n-      }\n+  void visit (AST::QualifiedPathInExpression &expr) override;\n \n-    auto const &in_params = expr.get_params ();\n-    for (auto &param : in_params)\n-      resolve_expr (param.get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ReturnExpr &expr) override;\n \n-  void visit (AST::AssignmentExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  void visit (AST::CallExpr &expr) override;\n \n-    // need to verify the assignee\n-    VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::MethodCallExpr &expr) override;\n \n-  void visit (AST::IdentifierExpr &expr) override\n-  {\n-    if (resolver->get_name_scope ().lookup (\n-\t  CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n-\t  &resolved_node))\n-      {\n-\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-      }\n-    else if (resolver->get_type_scope ().lookup (\n-\t       CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n-\t       &resolved_node))\n-      {\n-\tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-      }\n-    else\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to find name: %s\",\n-\t\t       expr.as_string ().c_str ());\n-      }\n-  }\n+  void visit (AST::AssignmentExpr &expr) override;\n \n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IdentifierExpr &expr) override;\n \n-  void visit (AST::CompoundAssignmentExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n \n-    // need to verify the assignee\n-    VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::CompoundAssignmentExpr &expr) override;\n \n-  void visit (AST::ComparisonExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ComparisonExpr &expr) override;\n \n-  void visit (AST::LazyBooleanExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::LazyBooleanExpr &expr) override;\n \n-  void visit (AST::NegationExpr &expr) override\n-  {\n-    resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::NegationExpr &expr) override;\n \n-  void visit (AST::TypeCastExpr &expr) override\n-  {\n-    ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::TypeCastExpr &expr) override;\n \n-  void visit (AST::IfExpr &expr) override\n-  {\n-    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IfExpr &expr) override;\n \n-  void visit (AST::IfExprConseqElse &expr) override\n-  {\n-    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IfExprConseqElse &expr) override;\n \n-  void visit (AST::IfExprConseqIf &expr) override\n-  {\n-    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IfExprConseqIf &expr) override;\n \n   void visit (AST::BlockExpr &expr) override;\n \n-  void visit (AST::UnsafeBlockExpr &expr) override\n-  {\n-    expr.get_block_expr ()->accept_vis (*this);\n-  }\n+  void visit (AST::UnsafeBlockExpr &expr) override;\n \n-  void visit (AST::ArrayElemsValues &elems) override\n-  {\n-    for (auto &elem : elems.get_values ())\n-      resolve_expr (elem.get (), elems.get_node_id ());\n-  }\n+  void visit (AST::ArrayElemsValues &elems) override;\n \n-  void visit (AST::ArrayExpr &expr) override\n-  {\n-    expr.get_array_elems ()->accept_vis (*this);\n-  }\n+  void visit (AST::ArrayExpr &expr) override;\n \n-  void visit (AST::ArrayIndexExpr &expr) override\n-  {\n-    resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ArrayIndexExpr &expr) override;\n \n-  void visit (AST::ArrayElemsCopied &elems) override\n-  {\n-    resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n-    resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n-  }\n+  void visit (AST::ArrayElemsCopied &elems) override;\n \n   // this this an empty struct constructor like 'S {}'\n-  void visit (AST::StructExprStruct &struct_expr) override\n-  {\n-    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n-  }\n+  void visit (AST::StructExprStruct &struct_expr) override;\n \n   // this this a struct constructor with fields\n-  void visit (AST::StructExprStructFields &struct_expr) override\n-  {\n-    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n-\n-    if (struct_expr.has_struct_base ())\n-      {\n-\tAST::StructBase &base = struct_expr.get_struct_base ();\n-\tresolve_expr (base.get_base_struct ().get (),\n-\t\t      struct_expr.get_node_id ());\n-      }\n-\n-    auto const &struct_fields = struct_expr.get_fields ();\n-    for (auto &struct_field : struct_fields)\n-      {\n-\tResolveStructExprField::go (struct_field.get (),\n-\t\t\t\t    struct_expr.get_node_id (), prefix,\n-\t\t\t\t    canonical_prefix);\n-      }\n-  }\n+  void visit (AST::StructExprStructFields &struct_expr) override;\n \n-  void visit (AST::GroupedExpr &expr) override\n-  {\n-    resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::GroupedExpr &expr) override;\n \n-  void visit (AST::FieldAccessExpr &expr) override\n-  {\n-    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::FieldAccessExpr &expr) override;\n \n-  void visit (AST::LoopExpr &expr) override\n-  {\n-    if (expr.has_loop_label ())\n-      {\n-\tauto label = expr.get_loop_label ();\n-\tif (label.get_lifetime ().get_lifetime_type ()\n-\t    != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tauto label_name = label.get_lifetime ().get_lifetime_name ();\n-\tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n-\tresolver->get_label_scope ().insert (\n-\t  CanonicalPath::new_seg (expr.get_node_id (), label_name),\n-\t  label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"label redefined multiple times\");\n-\t    rust_error_at (locus, \"was defined here\");\n-\t  });\n-\tresolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t\t Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t    label.get_node_id ()});\n-      }\n-    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::LoopExpr &expr) override;\n \n-  void visit (AST::BreakExpr &expr) override\n-  {\n-    if (expr.has_label ())\n-      {\n-\tauto label = expr.get_label ();\n-\tif (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (\n-\t      CanonicalPath::new_seg (label.get_node_id (),\n-\t\t\t\t      label.get_lifetime_name ()),\n-\t      &resolved_node))\n-\t  {\n-\t    rust_error_at (expr.get_label ().get_locus (),\n-\t\t\t   \"failed to resolve label\");\n-\t    return;\n-\t  }\n-\tresolver->insert_resolved_label (label.get_node_id (), resolved_node);\n-      }\n-\n-    if (expr.has_break_expr ())\n-      resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::BreakExpr &expr) override;\n \n-  void visit (AST::WhileLoopExpr &expr) override\n-  {\n-    if (expr.has_loop_label ())\n-      {\n-\tauto label = expr.get_loop_label ();\n-\tif (label.get_lifetime ().get_lifetime_type ()\n-\t    != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tauto label_name = label.get_lifetime ().get_lifetime_name ();\n-\tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n-\tresolver->get_label_scope ().insert (\n-\t  CanonicalPath::new_seg (label.get_node_id (), label_name),\n-\t  label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"label redefined multiple times\");\n-\t    rust_error_at (locus, \"was defined here\");\n-\t  });\n-\tresolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t\t Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t    label.get_node_id ()});\n-      }\n-    resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::WhileLoopExpr &expr) override;\n \n-  void visit (AST::ContinueExpr &expr) override\n-  {\n-    if (expr.has_label ())\n-      {\n-\tauto label = expr.get_label ();\n-\tif (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (\n-\t      CanonicalPath::new_seg (label.get_node_id (),\n-\t\t\t\t      label.get_lifetime_name ()),\n-\t      &resolved_node))\n-\t  {\n-\t    rust_error_at (expr.get_label ().get_locus (),\n-\t\t\t   \"failed to resolve label\");\n-\t    return;\n-\t  }\n-\tresolver->insert_resolved_label (label.get_node_id (), resolved_node);\n-      }\n-  }\n+  void visit (AST::ContinueExpr &expr) override;\n \n-  void visit (AST::BorrowExpr &expr) override\n-  {\n-    resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::BorrowExpr &expr) override;\n \n-  void visit (AST::DereferenceExpr &expr) override\n-  {\n-    resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::DereferenceExpr &expr) override;\n \n-  void visit (AST::MatchExpr &expr) override\n-  {\n-    resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n-    for (auto &match_case : expr.get_match_cases ())\n-      {\n-\t// each arm is in its own scope\n-\tNodeId scope_node_id = match_case.get_node_id ();\n-\tresolver->get_name_scope ().push (scope_node_id);\n-\tresolver->get_type_scope ().push (scope_node_id);\n-\tresolver->get_label_scope ().push (scope_node_id);\n-\tresolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-\tresolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\tresolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-\t// resolve\n-\tAST::MatchArm &arm = match_case.get_arm ();\n-\tif (arm.has_match_arm_guard ())\n-\t  resolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n-\n-\t// insert any possible new patterns\n-\tfor (auto &pattern : arm.get_patterns ())\n-\t  {\n-\t    PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n-\t  }\n-\n-\t// resolve the body\n-\tresolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n-\n-\t// done\n-\tresolver->get_name_scope ().pop ();\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_label_scope ().pop ();\n-      }\n-  }\n+  void visit (AST::MatchExpr &expr) override;\n \n protected:\n   void resolve_expr (AST::Expr *e, NodeId parent)"}, {"sha": "0346988cc043d492e7053c15e2327f76f286ecf3", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/755d0e5adf2f49a053d10529430753083762b549/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=755d0e5adf2f49a053d10529430753083762b549", "patch": "@@ -388,41 +388,6 @@ NameResolution::go (AST::Crate &crate)\n     ResolveItem::go (it->get (), CanonicalPath::create_empty (), crate_prefix);\n }\n \n-// rust-ast-resolve-expr.h\n-\n-void\n-ResolveExpr::visit (AST::BlockExpr &expr)\n-{\n-  NodeId scope_node_id = expr.get_node_id ();\n-  resolver->get_name_scope ().push (scope_node_id);\n-  resolver->get_type_scope ().push (scope_node_id);\n-  resolver->get_label_scope ().push (scope_node_id);\n-  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-  for (auto &s : expr.get_statements ())\n-    {\n-      if (s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n-\t\t\t CanonicalPath::create_empty ());\n-    }\n-\n-  for (auto &s : expr.get_statements ())\n-    {\n-      if (!s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n-\t\t\t CanonicalPath::create_empty ());\n-    }\n-\n-  if (expr.has_tail_expr ())\n-    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n-\n-  resolver->get_name_scope ().pop ();\n-  resolver->get_type_scope ().pop ();\n-  resolver->get_label_scope ().pop ();\n-}\n-\n // rust-ast-resolve-struct-expr-field.h\n \n void"}]}