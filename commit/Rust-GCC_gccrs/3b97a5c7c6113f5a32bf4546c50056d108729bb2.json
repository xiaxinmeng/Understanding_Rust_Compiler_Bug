{"sha": "3b97a5c7c6113f5a32bf4546c50056d108729bb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I5N2E1YzdjNjExM2Y1YTMyYmY0NTQ2YzUwMDU2ZDEwODcyOWJiMg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-11-14T20:07:39Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-11-14T20:07:39Z"}, "message": "ipa-prop.h (jump_func_type): Removed value IPA_JF_KNOWN_TYPE.\n\n2014-11-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (jump_func_type): Removed value IPA_JF_KNOWN_TYPE.\n\t(ipa_pass_through_data): Removed field type_preserved.\n\t(ipa_ancestor_jf_data): removed fields type and type_preserved.\n\t(ipa_jump_func): Removed field known_type.\n\t(ipa_get_jf_known_type_offset): Removed.\n\t(ipa_get_jf_known_type_base_type): Likewise.\n\t(ipa_get_jf_known_type_component_type): Likewise.\n\t(ipa_get_jf_ancestor_type): Likewise.\n\t* ipa-cp.c (print_ipcp_constant_value): Removed BINFO handling.\n\t(ipa_get_jf_pass_through_result): Likewise.\n\t(ipa_get_jf_ancestor_result): Always build ptr_node_type accesses.\n\t(values_equal_for_ipcp_p): Removed BINFO handling.\n\t(ipa_get_indirect_edge_target_1): Updated comment.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Removed handling\n\tof IPA_JF_KNOWN_TYPE jump functions.  Do not print removed fields.\n\t(ipa_set_jf_known_type): Removed.\n\t(ipa_set_jf_simple_pass_through): Do not set removed fields.  Update\n\tall callers.\n\t(ipa_set_jf_arith_pass_through): Likewise.\n\t(ipa_set_ancestor_jf): Likewise.\n\t(ipa_binfo_from_known_type_jfunc): Removed.\n\t(prop_type_change_info): Removed fields known_current_type and\n\tmultiple_types_encountered.\n\t(extr_type_from_vtbl_ptr_store): Removed.\n\t(check_stmt_for_type_change): Do not attempt to identify changed type.\n\t(detect_type_change_from_memory_writes): Do not set the removed fields,\n\talways set jfunc to unknown.\n\t(compute_complex_assign_jump_func): Do not detect dynamic type change.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(compute_known_type_jump_func): Removed.\n\t(ipa_compute_jump_functions_for_edge): Do not detect dynamic type\n\tchange.  Do not comute known type jump functions.\n\t(combine_known_type_and_ancestor_jfs): Removed.\n\t(update_jump_functions_after_inlining): Removed handling of\n\tIPA_JF_KNOWN_TYPE jump functions.  Do not set removed fields.\n\t(ipa_write_jump_function): Do not stream removed fields or known type\n\tjump functions.\n\t(ipa_read_jump_function): Likewise.\n\nFrom-SVN: r217589", "tree": {"sha": "7f3633f2cd764032721afc634a140441d4e8be7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f3633f2cd764032721afc634a140441d4e8be7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b97a5c7c6113f5a32bf4546c50056d108729bb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b97a5c7c6113f5a32bf4546c50056d108729bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b97a5c7c6113f5a32bf4546c50056d108729bb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b97a5c7c6113f5a32bf4546c50056d108729bb2/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ab74a01477d4089a3474d52479ed372c9b5ae29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab74a01477d4089a3474d52479ed372c9b5ae29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab74a01477d4089a3474d52479ed372c9b5ae29"}], "stats": {"total": 481, "additions": 71, "deletions": 410}, "files": [{"sha": "70a7c0587c7a97adcd0ae4264ae686e9bb71d5f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b97a5c7c6113f5a32bf4546c50056d108729bb2", "patch": "@@ -1,3 +1,44 @@\n+2014-11-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (jump_func_type): Removed value IPA_JF_KNOWN_TYPE.\n+\t(ipa_pass_through_data): Removed field type_preserved.\n+\t(ipa_ancestor_jf_data): removed fields type and type_preserved.\n+\t(ipa_jump_func): Removed field known_type.\n+\t(ipa_get_jf_known_type_offset): Removed.\n+\t(ipa_get_jf_known_type_base_type): Likewise.\n+\t(ipa_get_jf_known_type_component_type): Likewise.\n+\t(ipa_get_jf_ancestor_type): Likewise.\n+\t* ipa-cp.c (print_ipcp_constant_value): Removed BINFO handling.\n+\t(ipa_get_jf_pass_through_result): Likewise.\n+\t(ipa_get_jf_ancestor_result): Always build ptr_node_type accesses.\n+\t(values_equal_for_ipcp_p): Removed BINFO handling.\n+\t(ipa_get_indirect_edge_target_1): Updated comment.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Removed handling\n+\tof IPA_JF_KNOWN_TYPE jump functions.  Do not print removed fields.\n+\t(ipa_set_jf_known_type): Removed.\n+\t(ipa_set_jf_simple_pass_through): Do not set removed fields.  Update\n+\tall callers.\n+\t(ipa_set_jf_arith_pass_through): Likewise.\n+\t(ipa_set_ancestor_jf): Likewise.\n+\t(ipa_binfo_from_known_type_jfunc): Removed.\n+\t(prop_type_change_info): Removed fields known_current_type and\n+\tmultiple_types_encountered.\n+\t(extr_type_from_vtbl_ptr_store): Removed.\n+\t(check_stmt_for_type_change): Do not attempt to identify changed type.\n+\t(detect_type_change_from_memory_writes): Do not set the removed fields,\n+\talways set jfunc to unknown.\n+\t(compute_complex_assign_jump_func): Do not detect dynamic type change.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(compute_known_type_jump_func): Removed.\n+\t(ipa_compute_jump_functions_for_edge): Do not detect dynamic type\n+\tchange.  Do not comute known type jump functions.\n+\t(combine_known_type_and_ancestor_jfs): Removed.\n+\t(update_jump_functions_after_inlining): Removed handling of\n+\tIPA_JF_KNOWN_TYPE jump functions.  Do not set removed fields.\n+\t(ipa_write_jump_function): Do not stream removed fields or known type\n+\tjump functions.\n+\t(ipa_read_jump_function): Likewise.\n+\n 2014-11-14  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra-int.h (lra_create_live_ranges): Add parameter."}, {"sha": "0529f174615e3404e0f14ac49de636d2a077ad09", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3b97a5c7c6113f5a32bf4546c50056d108729bb2", "patch": "@@ -340,12 +340,7 @@ ipcp_lattice<valtype>::is_single_const ()\n static void\n print_ipcp_constant_value (FILE * f, tree v)\n {\n-  if (TREE_CODE (v) == TREE_BINFO)\n-    {\n-      fprintf (f, \"BINFO \");\n-      print_generic_expr (f, BINFO_TYPE (v), 0);\n-    }\n-  else if (TREE_CODE (v) == ADDR_EXPR\n+  if (TREE_CODE (v) == ADDR_EXPR\n \t   && TREE_CODE (TREE_OPERAND (v, 0)) == CONST_DECL)\n     {\n       fprintf (f, \"& \");\n@@ -842,21 +837,10 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n {\n   tree restype, res;\n \n-  if (TREE_CODE (input) == TREE_BINFO)\n-    {\n-      if (ipa_get_jf_pass_through_type_preserved (jfunc))\n-\t{\n-\t  gcc_checking_assert (ipa_get_jf_pass_through_operation (jfunc)\n-\t\t\t       == NOP_EXPR);\n-\t  return input;\n-\t}\n-      return NULL_TREE;\n-    }\n-\n+  gcc_checking_assert (is_gimple_ip_invariant (input));\n   if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     return input;\n \n-  gcc_checking_assert (is_gimple_ip_invariant (input));\n   if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n       == tcc_comparison)\n     restype = boolean_type_node;\n@@ -883,9 +867,7 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n       tree t = TREE_OPERAND (input, 0);\n       t = build_ref_for_offset (EXPR_LOCATION (t), t,\n \t\t\t\tipa_get_jf_ancestor_offset (jfunc),\n-\t\t\t\tipa_get_jf_ancestor_type (jfunc)\n-\t\t\t\t? ipa_get_jf_ancestor_type (jfunc)\n-\t\t\t\t: ptr_type_node, NULL, false);\n+\t\t\t\tptr_type_node, NULL, false);\n       return build_fold_addr_expr (t);\n     }\n   else\n@@ -1051,9 +1033,6 @@ values_equal_for_ipcp_p (tree x, tree y)\n   if (x == y)\n     return true;\n \n-  if (TREE_CODE (x) == TREE_BINFO || TREE_CODE (y) == TREE_BINFO)\n-    return false;\n-\n   if (TREE_CODE (x) ==  ADDR_EXPR\n       && TREE_CODE (y) ==  ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n@@ -1740,9 +1719,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n }\n \n /* If an indirect edge IE can be turned into a direct one based on KNOWN_VALS\n-   (which can contain both constants and binfos), KNOWN_CONTEXTS, KNOWN_AGGS or\n-   AGG_REPS return the destination.  The latter three can be NULL.  If AGG_REPS\n-   is not NULL, KNOWN_AGGS is ignored.  */\n+   KNOWN_CONTEXTS, KNOWN_AGGS or AGG_REPS return the destination.  The latter\n+   three can be NULL.  If AGG_REPS is not NULL, KNOWN_AGGS is ignored.  */\n \n static tree\n ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,"}, {"sha": "f87243ce9398564f47fa6c8970ad759a0387b9c3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 25, "deletions": 326, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3b97a5c7c6113f5a32bf4546c50056d108729bb2", "patch": "@@ -303,15 +303,6 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n       fprintf (f, \"       param %d: \", i);\n       if (type == IPA_JF_UNKNOWN)\n \tfprintf (f, \"UNKNOWN\\n\");\n-      else if (type == IPA_JF_KNOWN_TYPE)\n-\t{\n-\t  fprintf (f, \"KNOWN TYPE: base  \");\n-\t  print_generic_expr (f, jump_func->value.known_type.base_type, 0);\n-\t  fprintf (f, \", offset \"HOST_WIDE_INT_PRINT_DEC\", component \",\n-\t\t   jump_func->value.known_type.offset);\n-\t  print_generic_expr (f, jump_func->value.known_type.component_type, 0);\n-\t  fprintf (f, \"\\n\");\n-\t}\n       else if (type == IPA_JF_CONST)\n \t{\n \t  tree val = jump_func->value.constant.value;\n@@ -340,21 +331,16 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t    }\n \t  if (jump_func->value.pass_through.agg_preserved)\n \t    fprintf (f, \", agg_preserved\");\n-\t  if (jump_func->value.pass_through.type_preserved)\n-\t    fprintf (f, \", type_preserved\");\n \t  fprintf (f, \"\\n\");\n \t}\n       else if (type == IPA_JF_ANCESTOR)\n \t{\n \t  fprintf (f, \"ANCESTOR: \");\n-\t  fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC\", \",\n+\t  fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC,\n \t\t   jump_func->value.ancestor.formal_id,\n \t\t   jump_func->value.ancestor.offset);\n-\t  print_generic_expr (f, jump_func->value.ancestor.type, 0);\n \t  if (jump_func->value.ancestor.agg_preserved)\n \t    fprintf (f, \", agg_preserved\");\n-\t  if (jump_func->value.ancestor.type_preserved)\n-\t    fprintf (f, \", type_preserved\");\n \t  fprintf (f, \"\\n\");\n \t}\n \n@@ -460,28 +446,6 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n-/* Set JFUNC to be a known type jump function.  */\n-\n-static void\n-ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n-\t\t       tree base_type, tree component_type)\n-{\n-  /* Recording and propagating main variants increases change that types\n-     will match.  */\n-  base_type = TYPE_MAIN_VARIANT (base_type);\n-  component_type = TYPE_MAIN_VARIANT (component_type);\n-\n-  gcc_assert (contains_polymorphic_type_p (base_type)\n-\t      && contains_polymorphic_type_p (component_type));\n-  if (!flag_devirtualize)\n-    return;\n-  jfunc->type = IPA_JF_KNOWN_TYPE;\n-  jfunc->value.known_type.offset = offset,\n-  jfunc->value.known_type.base_type = base_type;\n-  jfunc->value.known_type.component_type = component_type;\n-  gcc_assert (component_type);\n-}\n-\n /* Set JFUNC to be a copy of another jmp (to be used by jump function\n    combination code).  The two functions will share their rdesc.  */\n \n@@ -528,14 +492,13 @@ ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant,\n /* Set JFUNC to be a simple pass-through jump function.  */\n static void\n ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n-\t\t\t\tbool agg_preserved, bool type_preserved)\n+\t\t\t\tbool agg_preserved)\n {\n   jfunc->type = IPA_JF_PASS_THROUGH;\n   jfunc->value.pass_through.operand = NULL_TREE;\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = NOP_EXPR;\n   jfunc->value.pass_through.agg_preserved = agg_preserved;\n-  jfunc->value.pass_through.type_preserved = type_preserved;\n }\n \n /* Set JFUNC to be an arithmetic pass through jump function.  */\n@@ -549,61 +512,18 @@ ipa_set_jf_arith_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = operation;\n   jfunc->value.pass_through.agg_preserved = false;\n-  jfunc->value.pass_through.type_preserved = false;\n }\n \n /* Set JFUNC to be an ancestor jump function.  */\n \n static void\n ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n-\t\t     tree type, int formal_id, bool agg_preserved,\n-\t\t     bool type_preserved)\n+\t\t     int formal_id, bool agg_preserved)\n {\n-  if (!flag_devirtualize)\n-    type_preserved = false;\n-  if (!type_preserved)\n-    type = NULL_TREE;\n-  if (type)\n-    type = TYPE_MAIN_VARIANT (type);\n-  if (!type || !contains_polymorphic_type_p (type))\n-    type_preserved = false;\n   jfunc->type = IPA_JF_ANCESTOR;\n   jfunc->value.ancestor.formal_id = formal_id;\n   jfunc->value.ancestor.offset = offset;\n-  jfunc->value.ancestor.type = type_preserved ? type : NULL;\n   jfunc->value.ancestor.agg_preserved = agg_preserved;\n-  jfunc->value.ancestor.type_preserved = type_preserved;\n-}\n-\n-/* Extract the acual BINFO being described by JFUNC which must be a known type\n-   jump function.  */\n-\n-tree\n-ipa_binfo_from_known_type_jfunc (struct ipa_jump_func *jfunc)\n-{\n-  if (!RECORD_OR_UNION_TYPE_P (jfunc->value.known_type.base_type))\n-    return NULL_TREE;\n-\n-  tree base_binfo = TYPE_BINFO (jfunc->value.known_type.base_type);\n-\n-  if (!base_binfo)\n-    return NULL_TREE;\n-  /* FIXME: At LTO we can't propagate to non-polymorphic type, because\n-     we have no ODR equivalency on those.  This should be fixed by\n-     propagating on types rather than binfos that would make type\n-     matching here unnecesary.  */\n-  if (in_lto_p\n-      && (TREE_CODE (jfunc->value.known_type.component_type) != RECORD_TYPE\n-\t  || !TYPE_BINFO (jfunc->value.known_type.component_type)\n-\t  || !BINFO_VTABLE (TYPE_BINFO (jfunc->value.known_type.component_type))))\n-    {\n-      if (!jfunc->value.known_type.offset)\n-\treturn base_binfo;\n-      return NULL;\n-    }\n-  return get_binfo_at_offset (base_binfo,\n-\t\t\t      jfunc->value.known_type.offset,\n-\t\t\t      jfunc->value.known_type.component_type);\n }\n \n /* Get IPA BB information about the given BB.  FBI is the context of analyzis\n@@ -627,14 +547,8 @@ struct prop_type_change_info\n   /* The declaration or SSA_NAME pointer of the base that we are checking for\n      type change.  */\n   tree object;\n-  /* If we actually can tell the type that the object has changed to, it is\n-     stored in this field.  Otherwise it remains NULL_TREE.  */\n-  tree known_current_type;\n   /* Set to true if dynamic type change has been detected.  */\n   bool type_maybe_changed;\n-  /* Set to true if multiple types have been encountered.  known_current_type\n-     must be disregarded in that case.  */\n-  bool multiple_types_encountered;\n };\n \n /* Return true if STMT can modify a virtual method table pointer.\n@@ -702,57 +616,9 @@ stmt_may_be_vtbl_ptr_store (gimple stmt)\n   return true;\n }\n \n-/* If STMT can be proved to be an assignment to the virtual method table\n-   pointer of ANALYZED_OBJ and the type associated with the new table\n-   identified, return the type.  Otherwise return NULL_TREE.  */\n-\n-static tree\n-extr_type_from_vtbl_ptr_store (gimple stmt, struct prop_type_change_info *tci)\n-{\n-  HOST_WIDE_INT offset, size, max_size;\n-  tree lhs, rhs, base, binfo;\n-\n-  if (!gimple_assign_single_p (stmt))\n-    return NULL_TREE;\n-\n-  lhs = gimple_assign_lhs (stmt);\n-  rhs = gimple_assign_rhs1 (stmt);\n-  if (TREE_CODE (lhs) != COMPONENT_REF\n-      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n-    return NULL_TREE;\n-\n-  base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n-  if (offset != tci->offset\n-      || size != POINTER_SIZE\n-      || max_size != POINTER_SIZE)\n-    return NULL_TREE;\n-  if (TREE_CODE (base) == MEM_REF)\n-    {\n-      if (TREE_CODE (tci->object) != MEM_REF\n-\t  || TREE_OPERAND (tci->object, 0) != TREE_OPERAND (base, 0)\n-\t  || !tree_int_cst_equal (TREE_OPERAND (tci->object, 1),\n-\t\t\t\t  TREE_OPERAND (base, 1)))\n-\treturn NULL_TREE;\n-    }\n-  else if (tci->object != base)\n-    return NULL_TREE;\n-\n-  binfo = vtable_pointer_value_to_binfo (rhs);\n-\n-  /* FIXME: vtable_pointer_value_to_binfo may return BINFO of a\n-     base of outer type.  In this case we would need to either\n-     work on binfos or translate it back to outer type and offset.\n-     KNOWN_TYPE jump functions are not ready for that, yet.  */\n-  if (!binfo || TYPE_BINFO (BINFO_TYPE (binfo)) != binfo)\n-   return NULL;\n-\n-  return BINFO_TYPE (binfo);\n-}\n-\n-/* Callback of walk_aliased_vdefs and a helper function for\n-   detect_type_change to check whether a particular statement may modify\n-   the virtual table pointer, and if possible also determine the new type of\n-   the (sub-)object.  It stores its result into DATA, which points to a\n+/* Callback of walk_aliased_vdefs and a helper function for detect_type_change\n+   to check whether a particular statement may modify the virtual table\n+   pointerIt stores its result into DATA, which points to a\n    prop_type_change_info structure.  */\n \n static bool\n@@ -763,14 +629,6 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \n   if (stmt_may_be_vtbl_ptr_store (stmt))\n     {\n-      tree type;\n-\n-      type = extr_type_from_vtbl_ptr_store (stmt, tci);\n-      gcc_assert (!type || TYPE_MAIN_VARIANT (type) == type);\n-      if (tci->type_maybe_changed\n-\t  && type != tci->known_current_type)\n-\ttci->multiple_types_encountered = true;\n-      tci->known_current_type = type;\n       tci->type_maybe_changed = true;\n       return true;\n     }\n@@ -885,25 +743,14 @@ detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n \n   tci.offset = offset;\n   tci.object = get_base_address (arg);\n-  tci.known_current_type = NULL_TREE;\n   tci.type_maybe_changed = false;\n-  tci.multiple_types_encountered = false;\n \n   walk_aliased_vdefs (&ao, gimple_vuse (call), check_stmt_for_type_change,\n \t\t      &tci, NULL, &entry_reached);\n   if (!tci.type_maybe_changed)\n     return false;\n \n-  if (!tci.known_current_type\n-      || tci.multiple_types_encountered\n-      || offset != 0\n-      /* When the walk reached function entry, it means that type\n-\t is set along some paths but not along others.  */\n-      || entry_reached)\n-    jfunc->type = IPA_JF_UNKNOWN;\n-  else\n-    ipa_set_jf_known_type (jfunc, 0, tci.known_current_type, comp_type);\n-\n+  jfunc->type = IPA_JF_UNKNOWN;\n   return true;\n }\n \n@@ -1354,13 +1201,7 @@ compute_complex_assign_jump_func (struct func_body_info *fbi,\n       else if (gimple_assign_single_p (stmt))\n \t{\n \t  bool agg_p = parm_ref_data_pass_through_p (fbi, index, call, tc_ssa);\n-\t  bool type_p = false;\n-\n-\t  if (param_type && POINTER_TYPE_P (param_type))\n-\t    type_p = !detect_type_change_ssa (tc_ssa, TREE_TYPE (param_type),\n-\t\t\t\t\t      call, jfunc);\n-\t  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n-\t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p, type_p);\n+\t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n \t}\n       return;\n     }\n@@ -1386,16 +1227,8 @@ compute_complex_assign_jump_func (struct func_body_info *fbi,\n   /* Dynamic types are changed in constructors and destructors.  */\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n   if (index >= 0 && param_type && POINTER_TYPE_P (param_type))\n-    {\n-      bool type_p = (contains_polymorphic_type_p (TREE_TYPE (param_type))\n-\t\t     && !detect_type_change (op1, base, TREE_TYPE (param_type),\n-\t\t\t\t\t     call, jfunc, offset));\n-      if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n-\tipa_set_ancestor_jf (jfunc, offset,\n-\t\t\t     type_p ? TREE_TYPE (param_type) : NULL, index,\n-\t\t\t     parm_ref_data_pass_through_p (fbi, index,\n-\t\t\t\t\t\t\t   call, ssa), type_p);\n-    }\n+    ipa_set_ancestor_jf (jfunc, offset,  index,\n+\t\t\t parm_ref_data_pass_through_p (fbi, index, call, ssa));\n }\n \n /* Extract the base, offset and MEM_REF expression from a statement ASSIGN if\n@@ -1468,7 +1301,7 @@ static void\n compute_complex_ancestor_jump_func (struct func_body_info *fbi,\n \t\t\t\t    struct ipa_node_params *info,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n-\t\t\t\t    gimple call, gimple phi, tree param_type)\n+\t\t\t\t    gimple call, gimple phi)\n {\n   HOST_WIDE_INT offset;\n   gimple assign, cond;\n@@ -1520,56 +1353,8 @@ compute_complex_ancestor_jump_func (struct func_body_info *fbi,\n \treturn;\n     }\n \n-  bool type_p = false;\n-  if (param_type && POINTER_TYPE_P (param_type)\n-      && contains_polymorphic_type_p (TREE_TYPE (param_type)))\n-    type_p = !detect_type_change (obj, expr, TREE_TYPE (param_type),\n-\t\t\t\t  call, jfunc, offset);\n-  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n-    ipa_set_ancestor_jf (jfunc, offset, type_p ? TREE_TYPE (param_type) : NULL,\n-\t\t\t index,\n-\t\t\t parm_ref_data_pass_through_p (fbi, index, call, parm),\n-\t\t\t type_p);\n-}\n-\n-/* Given OP which is passed as an actual argument to a called function,\n-   determine if it is possible to construct a KNOWN_TYPE jump function for it\n-   and if so, create one and store it to JFUNC.\n-   EXPECTED_TYPE represents a type the argument should be in  */\n-\n-static void\n-compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n-\t\t\t      gimple call, tree expected_type)\n-{\n-  HOST_WIDE_INT offset, size, max_size;\n-  tree base;\n-\n-  if (!flag_devirtualize\n-      || TREE_CODE (op) != ADDR_EXPR\n-      || !contains_polymorphic_type_p (TREE_TYPE (TREE_TYPE (op)))\n-      /* Be sure expected_type is polymorphic.  */\n-      || !expected_type\n-      || !contains_polymorphic_type_p (expected_type))\n-    return;\n-\n-  op = TREE_OPERAND (op, 0);\n-  base = get_ref_base_and_extent (op, &offset, &size, &max_size);\n-  if (!DECL_P (base)\n-      || max_size == -1\n-      || max_size != size\n-      || !contains_polymorphic_type_p (TREE_TYPE (base)))\n-    return;\n-\n-  if (decl_maybe_in_construction_p (base, TREE_TYPE (base),\n-\t\t\t\t    call, current_function_decl)\n-      /* Even if the var seems to be in construction by inline call stack,\n-\t we may work out the actual type by walking memory writes.  */\n-      && (is_global_var (base)\n-\t  || detect_type_change (op, base, expected_type, call, jfunc, offset)))\n-    return;\n-\n-  ipa_set_jf_known_type (jfunc, offset, TREE_TYPE (base),\n-\t\t\t expected_type);\n+  ipa_set_ancestor_jf (jfunc, offset, index,\n+\t\t       parm_ref_data_pass_through_p (fbi, index, call, parm));\n }\n \n /* Inspect the given TYPE and return true iff it has the same structure (the\n@@ -1944,7 +1729,7 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t     for cycle.  */\n \t  if (parm_preserved_before_stmt_p (fbi, index, call, arg))\n \t    {\n-\t      ipa_set_jf_simple_pass_through (jfunc, index, false, false);\n+\t      ipa_set_jf_simple_pass_through (jfunc, index, false);\n \t      continue;\n \t    }\n \t}\n@@ -1955,16 +1740,9 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n \t      if (index >= 0)\n \t\t{\n-\t\t  bool agg_p, type_p;\n+\t\t  bool agg_p;\n \t\t  agg_p = parm_ref_data_pass_through_p (fbi, index, call, arg);\n-\t\t  if (param_type && POINTER_TYPE_P (param_type))\n-\t\t    type_p = !detect_type_change_ssa (arg, TREE_TYPE (param_type),\n-\t\t\t\t\t\t      call, jfunc);\n-\t\t  else\n-\t\t    type_p = false;\n-\t\t  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n-\t\t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p,\n-\t\t\t\t\t\t    type_p);\n+\t\t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n \t\t}\n \t    }\n \t  else\n@@ -1975,15 +1753,9 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t\t\t\t\t\t  call, stmt, arg, param_type);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tcompute_complex_ancestor_jump_func (fbi, info, jfunc,\n-\t\t\t\t\t\t    call, stmt, param_type);\n+\t\t\t\t\t\t    call, stmt);\n \t    }\n \t}\n-      else\n-\tcompute_known_type_jump_func (arg, jfunc, call,\n-\t\t\t\t      param_type\n-\t\t\t\t      && POINTER_TYPE_P (param_type)\n-\t\t\t\t      ? TREE_TYPE (param_type)\n-\t\t\t\t      : NULL);\n \n       /* If ARG is pointer, we can not use its type to determine the type of aggregate\n \t passed (because type conversions are ignored in gimple).  Usually we can\n@@ -2608,35 +2380,6 @@ ipa_analyze_node (struct cgraph_node *node)\n   pop_cfun ();\n }\n \n-/* Update the jump function DST when the call graph edge corresponding to SRC is\n-   is being inlined, knowing that DST is of type ancestor and src of known\n-   type.  */\n-\n-static void\n-combine_known_type_and_ancestor_jfs (struct ipa_jump_func *src,\n-\t\t\t\t     struct ipa_jump_func *dst)\n-{\n-  HOST_WIDE_INT combined_offset;\n-  tree combined_type;\n-\n-  if (!ipa_get_jf_ancestor_type_preserved (dst))\n-    {\n-      dst->type = IPA_JF_UNKNOWN;\n-      return;\n-    }\n-\n-  combined_offset = ipa_get_jf_known_type_offset (src)\n-    + ipa_get_jf_ancestor_offset (dst);\n-  combined_type = ipa_get_jf_ancestor_type (dst);\n-\n-  if (combined_type)\n-    ipa_set_jf_known_type (dst, combined_offset,\n-\t\t\t   ipa_get_jf_known_type_base_type (src),\n-\t\t\t   combined_type);\n-  else\n-    dst->type = IPA_JF_UNKNOWN;\n-}\n-\n /* Update the jump functions associated with call graph edge E when the call\n    graph edge CS is being inlined, assuming that E->caller is already (possibly\n    indirectly) inlined into CS->callee and that E has not been inlined.  */\n@@ -2707,25 +2450,19 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\titem->offset -= dst->value.ancestor.offset;\n \t    }\n \n-\t  if (src->type == IPA_JF_KNOWN_TYPE)\n-\t    combine_known_type_and_ancestor_jfs (src, dst);\n-\t  else if (src->type == IPA_JF_PASS_THROUGH\n-\t\t   && src->value.pass_through.operation == NOP_EXPR)\n+\t  if (src->type == IPA_JF_PASS_THROUGH\n+\t      && src->value.pass_through.operation == NOP_EXPR)\n \t    {\n \t      dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n \t      dst->value.ancestor.agg_preserved &=\n \t\tsrc->value.pass_through.agg_preserved;\n-\t      dst->value.ancestor.type_preserved &=\n-\t\tsrc->value.pass_through.type_preserved;\n \t    }\n \t  else if (src->type == IPA_JF_ANCESTOR)\n \t    {\n \t      dst->value.ancestor.formal_id = src->value.ancestor.formal_id;\n \t      dst->value.ancestor.offset += src->value.ancestor.offset;\n \t      dst->value.ancestor.agg_preserved &=\n \t\tsrc->value.ancestor.agg_preserved;\n-\t      dst->value.ancestor.type_preserved &=\n-\t\tsrc->value.ancestor.type_preserved;\n \t    }\n \t  else\n \t    dst->type = IPA_JF_UNKNOWN;\n@@ -2768,15 +2505,6 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\tcase IPA_JF_UNKNOWN:\n \t\t  dst->type = IPA_JF_UNKNOWN;\n \t\t  break;\n-\t\tcase IPA_JF_KNOWN_TYPE:\n-\t\t  if (ipa_get_jf_pass_through_type_preserved (dst))\n-\t\t    ipa_set_jf_known_type (dst,\n-\t\t\t\t\t   ipa_get_jf_known_type_offset (src),\n-\t\t\t\t\t   ipa_get_jf_known_type_base_type (src),\n-\t\t\t\t\t   ipa_get_jf_known_type_component_type (src));\n-\t\t  else\n-\t\t    dst->type = IPA_JF_UNKNOWN;\n-\t\t  break;\n \t\tcase IPA_JF_CONST:\n \t\t  ipa_set_jf_cst_copy (dst, src);\n \t\t  break;\n@@ -2789,13 +2517,10 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \n \t\t    if (operation == NOP_EXPR)\n \t\t      {\n-\t\t\tbool agg_p, type_p;\n+\t\t\tbool agg_p;\n \t\t\tagg_p = dst_agg_p\n \t\t\t  && ipa_get_jf_pass_through_agg_preserved (src);\n-\t\t\ttype_p = ipa_get_jf_pass_through_type_preserved (src)\n-\t\t\t  && ipa_get_jf_pass_through_type_preserved (dst);\n-\t\t\tipa_set_jf_simple_pass_through (dst, formal_id,\n-\t\t\t\t\t\t\tagg_p, type_p);\n+\t\t\tipa_set_jf_simple_pass_through (dst, formal_id, agg_p);\n \t\t      }\n \t\t    else\n \t\t      {\n@@ -2807,16 +2532,13 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t  }\n \t\tcase IPA_JF_ANCESTOR:\n \t\t  {\n-\t\t    bool agg_p, type_p;\n+\t\t    bool agg_p;\n \t\t    agg_p = dst_agg_p\n \t\t      && ipa_get_jf_ancestor_agg_preserved (src);\n-\t\t    type_p = ipa_get_jf_ancestor_type_preserved (src)\n-\t\t      && ipa_get_jf_pass_through_type_preserved (dst);\n \t\t    ipa_set_ancestor_jf (dst,\n \t\t\t\t\t ipa_get_jf_ancestor_offset (src),\n-\t\t\t\t\t ipa_get_jf_ancestor_type (src),\n \t\t\t\t\t ipa_get_jf_ancestor_formal_id (src),\n-\t\t\t\t\t agg_p, type_p);\n+\t\t\t\t\t agg_p);\n \t\t    break;\n \t\t  }\n \t\tdefault:\n@@ -4685,11 +4407,6 @@ ipa_write_jump_function (struct output_block *ob,\n     {\n     case IPA_JF_UNKNOWN:\n       break;\n-    case IPA_JF_KNOWN_TYPE:\n-      streamer_write_uhwi (ob, jump_func->value.known_type.offset);\n-      stream_write_tree (ob, jump_func->value.known_type.base_type, true);\n-      stream_write_tree (ob, jump_func->value.known_type.component_type, true);\n-      break;\n     case IPA_JF_CONST:\n       gcc_assert (\n \t  EXPR_LOCATION (jump_func->value.constant.value) == UNKNOWN_LOCATION);\n@@ -4702,7 +4419,6 @@ ipa_write_jump_function (struct output_block *ob,\n \t  streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n-\t  bp_pack_value (&bp, jump_func->value.pass_through.type_preserved, 1);\n \t  streamer_write_bitpack (&bp);\n \t}\n       else\n@@ -4713,11 +4429,9 @@ ipa_write_jump_function (struct output_block *ob,\n       break;\n     case IPA_JF_ANCESTOR:\n       streamer_write_uhwi (ob, jump_func->value.ancestor.offset);\n-      stream_write_tree (ob, jump_func->value.ancestor.type, true);\n       streamer_write_uhwi (ob, jump_func->value.ancestor.formal_id);\n       bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, jump_func->value.ancestor.agg_preserved, 1);\n-      bp_pack_value (&bp, jump_func->value.ancestor.type_preserved, 1);\n       streamer_write_bitpack (&bp);\n       break;\n     }\n@@ -4756,15 +4470,6 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     case IPA_JF_UNKNOWN:\n       jump_func->type = IPA_JF_UNKNOWN;\n       break;\n-    case IPA_JF_KNOWN_TYPE:\n-      {\n-\tHOST_WIDE_INT offset = streamer_read_uhwi (ib);\n-\ttree base_type = stream_read_tree (ib, data_in);\n-\ttree component_type = stream_read_tree (ib, data_in);\n-\n-\tipa_set_jf_known_type (jump_func, offset, base_type, component_type);\n-\tbreak;\n-      }\n     case IPA_JF_CONST:\n       ipa_set_jf_constant (jump_func, stream_read_tree (ib, data_in), cs);\n       break;\n@@ -4775,9 +4480,7 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t  int formal_id =  streamer_read_uhwi (ib);\n \t  struct bitpack_d bp = streamer_read_bitpack (ib);\n \t  bool agg_preserved = bp_unpack_value (&bp, 1);\n-\t  bool type_preserved = bp_unpack_value (&bp, 1);\n-\t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved,\n-\t\t\t\t\t  type_preserved);\n+\t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved);\n \t}\n       else\n \t{\n@@ -4790,14 +4493,10 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     case IPA_JF_ANCESTOR:\n       {\n \tHOST_WIDE_INT offset = streamer_read_uhwi (ib);\n-\ttree type = stream_read_tree (ib, data_in);\n \tint formal_id = streamer_read_uhwi (ib);\n \tstruct bitpack_d bp = streamer_read_bitpack (ib);\n \tbool agg_preserved = bp_unpack_value (&bp, 1);\n-\tbool type_preserved = bp_unpack_value (&bp, 1);\n-\n-\tipa_set_ancestor_jf (jump_func, offset, type, formal_id, agg_preserved,\n-\t\t\t     type_preserved);\n+\tipa_set_ancestor_jf (jump_func, offset, formal_id, agg_preserved);\n \tbreak;\n       }\n     }"}, {"sha": "ed991108363d9538c321d41d99ecd62fbd152fd5", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b97a5c7c6113f5a32bf4546c50056d108729bb2/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3b97a5c7c6113f5a32bf4546c50056d108729bb2", "patch": "@@ -51,11 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n    parameter or can apply one simple binary operation to it (such jump\n    functions are called polynomial).\n \n-   IPA_JF_KNOWN_TYPE is a special type of an \"unknown\" function that applies\n-   only to pointer parameters.  It means that even though we cannot prove that\n-   the passed value is an interprocedural constant, we still know the exact\n-   type of the containing object which may be valuable for devirtualization.\n-\n    Jump functions are computed in ipa-prop.c by function\n    update_call_notes_after_inlining.  Some information can be lost and jump\n    functions degraded accordingly when inlining, see\n@@ -64,7 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n enum jump_func_type\n {\n   IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */\n-  IPA_JF_KNOWN_TYPE,        /* represented by field known_type */\n   IPA_JF_CONST,             /* represented by field costant */\n   IPA_JF_PASS_THROUGH,\t    /* represented by field pass_through */\n   IPA_JF_ANCESTOR\t    /* represented by field ancestor */\n@@ -113,11 +107,6 @@ struct GTY(()) ipa_pass_through_data\n      ipa_agg_jump_function).  The flag is used only when the operation is\n      NOP_EXPR.  */\n   unsigned agg_preserved : 1;\n-\n-  /* When set to true, we guarantee that, if there is a C++ object pointed to\n-     by this object, it does not undergo dynamic type change in the course of\n-     functions decribed by this jump function.  */\n-  unsigned type_preserved : 1;\n };\n \n /* Structure holding data required to describe an ancestor pass-through\n@@ -127,18 +116,10 @@ struct GTY(()) ipa_ancestor_jf_data\n {\n   /* Offset of the field representing the ancestor.  */\n   HOST_WIDE_INT offset;\n-  /* Type of the result.\n-     When TYPE_PRESERVED is false, TYPE is NULL, since it is only\n-     relevant for the devirtualization machinery.  */\n-  tree type;\n   /* Number of the caller's formal parameter being passed.  */\n   int formal_id;\n   /* Flag with the same meaning like agg_preserve in ipa_pass_through_data.  */\n   unsigned agg_preserved : 1;\n-  /* When set to true, we guarantee that, if there is a C++ object pointed to\n-     by this object, it does not undergo dynamic type change in the course of\n-     functions decribed by this jump function.  */\n-  unsigned type_preserved : 1;\n };\n \n /* An element in an aggegate part of a jump function describing a known value\n@@ -189,42 +170,13 @@ struct GTY (()) ipa_jump_func\n      functions and member_cst holds constant c++ member functions.  */\n   union jump_func_value\n   {\n-    struct ipa_known_type_data GTY ((tag (\"IPA_JF_KNOWN_TYPE\"))) known_type;\n     struct ipa_constant_data GTY ((tag (\"IPA_JF_CONST\"))) constant;\n     struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n     struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n   } GTY ((desc (\"%1.type\"))) value;\n };\n \n \n-/* Return the offset of the component that is described by a known type jump\n-   function JFUNC.  */\n-\n-static inline HOST_WIDE_INT\n-ipa_get_jf_known_type_offset (struct ipa_jump_func *jfunc)\n-{\n-  gcc_checking_assert (jfunc->type == IPA_JF_KNOWN_TYPE);\n-  return jfunc->value.known_type.offset;\n-}\n-\n-/* Return the base type of a known type jump function JFUNC.  */\n-\n-static inline tree\n-ipa_get_jf_known_type_base_type (struct ipa_jump_func *jfunc)\n-{\n-  gcc_checking_assert (jfunc->type == IPA_JF_KNOWN_TYPE);\n-  return jfunc->value.known_type.base_type;\n-}\n-\n-/* Return the component type of a known type jump function JFUNC.  */\n-\n-static inline tree\n-ipa_get_jf_known_type_component_type (struct ipa_jump_func *jfunc)\n-{\n-  gcc_checking_assert (jfunc->type == IPA_JF_KNOWN_TYPE);\n-  return jfunc->value.known_type.component_type;\n-}\n-\n /* Return the constant stored in a constant jump functin JFUNC.  */\n \n static inline tree\n@@ -297,15 +249,6 @@ ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.offset;\n }\n \n-/* Return the result type of an ancestor jump function JFUNC.  */\n-\n-static inline tree\n-ipa_get_jf_ancestor_type (struct ipa_jump_func *jfunc)\n-{\n-  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n-  return jfunc->value.ancestor.type;\n-}\n-\n /* Return the number of the caller's formal parameter that an ancestor jump\n    function JFUNC refers to.  */\n "}]}