{"sha": "d5fa5335e2171cbfd732a9acba9f22f0df784913", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmYTUzMzVlMjE3MWNiZmQ3MzJhOWFjYmE5ZjIyZjBkZjc4NDkxMw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-04-28T13:29:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-28T13:29:34Z"}, "message": "exp_ch6.adb (Expand_N_Extended_Return_Statement): Use New_Copy_Tree instead of Relocate_Node as any subsequent copies of the...\n\n2017-04-28  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Use\n\tNew_Copy_Tree instead of Relocate_Node as any subsequent copies\n\tof the relocated node will have mangled Parent pointers.\n\t* sem_util.adb (Build_NCT_Hash_Tables): Reset both hash\n\ttables used in conjunction with entity and itype replication.\n\t(Visit_Entity): Rewrite the restriction on which entities\n\trequire duplication.  The restriction now includes all types.\n\n2017-04-28  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-cofuse.ads, a-cfdlli.ads, a-cfhase.adb, a-cfhase.ads, a-cfinve.adb,\n\ta-cfinve.ads, a-cforma.adb, a-cforma.ads, a-cofuma.adb, a-cofuma.ads,\n\ta-cfhama.adb, a-cfhama.ads, a-cforse.adb: Minor reformatting and code\n\tcleanups.\n\nFrom-SVN: r247384", "tree": {"sha": "6cf1125d55a0caf562a9bd8cb67dafbdf27ec95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cf1125d55a0caf562a9bd8cb67dafbdf27ec95c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5fa5335e2171cbfd732a9acba9f22f0df784913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fa5335e2171cbfd732a9acba9f22f0df784913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fa5335e2171cbfd732a9acba9f22f0df784913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fa5335e2171cbfd732a9acba9f22f0df784913/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef952fd5e9cfb61e2be7be053fc0d26f87c75040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef952fd5e9cfb61e2be7be053fc0d26f87c75040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef952fd5e9cfb61e2be7be053fc0d26f87c75040"}], "stats": {"total": 739, "additions": 368, "deletions": 371}, "files": [{"sha": "209e16e50d9b6572b5e2c9bfbf4ee084527fe605", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -1,3 +1,20 @@\n+2017-04-28  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Use\n+\tNew_Copy_Tree instead of Relocate_Node as any subsequent copies\n+\tof the relocated node will have mangled Parent pointers.\n+\t* sem_util.adb (Build_NCT_Hash_Tables): Reset both hash\n+\ttables used in conjunction with entity and itype replication.\n+\t(Visit_Entity): Rewrite the restriction on which entities\n+\trequire duplication.  The restriction now includes all types.\n+\n+2017-04-28  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-cofuse.ads, a-cfdlli.ads, a-cfhase.adb, a-cfhase.ads, a-cfinve.adb,\n+\ta-cfinve.ads, a-cforma.adb, a-cforma.ads, a-cofuma.adb, a-cofuma.ads,\n+\ta-cfhama.adb, a-cfhama.ads, a-cforse.adb: Minor reformatting and code\n+\tcleanups.\n+\n 2017-04-28  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb, g-dyntab.adb, par-ch4.adb, sem_util.adb, sem_attr.adb,"}, {"sha": "f6638cbb18b8c85e506c49e05c8e6cf309520918", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -1541,9 +1541,9 @@ is\n            Post   =>\n              M_Elements_Sorted'Result =\n                (for all I in 1 .. M.Length (Container) =>\n-                  (for all J in I .. M.Length (Container) =>\n-                       Element (Container, I) = Element (Container, J)\n-                         or Element (Container, I) < Element (Container, J)));\n+                 (for all J in I .. M.Length (Container) =>\n+                   Element (Container, I) = Element (Container, J)\n+                     or Element (Container, I) < Element (Container, J)));\n          pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       end Formal_Model;"}, {"sha": "bf782c6c8df698572191aa194ca2fc8297f9d986", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -370,7 +370,9 @@ is\n       -- Find --\n       ----------\n \n-      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n+      function Find\n+        (Container : K.Sequence;\n+         Key       : Key_Type) return Count_Type\n       is\n       begin\n          for I in 1 .. K.Length (Container) loop\n@@ -385,8 +387,9 @@ is\n       -- K_Keys_Included --\n       ---------------------\n \n-      function K_Keys_Included (Left  : K.Sequence;\n-                               Right : K.Sequence) return Boolean\n+      function K_Keys_Included\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean\n       is\n       begin\n          for I in 1 .. K.Length (Left) loop"}, {"sha": "e02accc3f52f96cd149022bde8ec4d0da194ef53", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -126,8 +126,8 @@ is\n         Global => null,\n         Post =>\n           (if Find'Result > 0 then\n-             Find'Result <= K.Length (Container)\n-               and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n+              Find'Result <= K.Length (Container)\n+                and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n \n       function K_Keys_Included\n         (Left  : K.Sequence;\n@@ -139,9 +139,9 @@ is\n         Post   =>\n           K_Keys_Included'Result =\n             (for all I in 1 .. K.Length (Left) =>\n-               Find (Right, K.Get (Left, I)) > 0\n-                 and then K.Get (Right, Find (Right, K.Get (Left, I))) =\n-                     K.Get (Left, I));\n+              Find (Right, K.Get (Left, I)) > 0\n+                and then K.Get (Right, Find (Right, K.Get (Left, I))) =\n+                         K.Get (Left, I));\n \n       package P is new Ada.Containers.Functional_Maps\n         (Key_Type                       => Cursor,\n@@ -203,14 +203,15 @@ is\n             --  It only contains keys contained in Model\n \n             and (for all Key of Keys'Result =>\n-                   M.Has_Key (Model (Container), Key))\n+                  M.Has_Key (Model (Container), Key))\n \n             --  It contains all the keys contained in Model\n \n             and (for all Key of Model (Container) =>\n                   (Find (Keys'Result, Key) > 0\n-                     and then Equivalent_Keys\n-                      (K.Get (Keys'Result, Find (Keys'Result, Key)), Key)))\n+                    and then Equivalent_Keys\n+                               (K.Get (Keys'Result, Find (Keys'Result, Key)),\n+                                Key)))\n \n             --  It has no duplicate\n \n@@ -221,7 +222,8 @@ is\n                   (for all J in 1 .. Length (Container) =>\n                     (if Equivalent_Keys\n                           (K.Get (Keys'Result, I), K.Get (Keys'Result, J))\n-                     then I = J)));\n+                     then\n+                        I = J)));\n       pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n \n       function Positions (Container : Map) return P.Map with\n@@ -246,7 +248,7 @@ is\n             and then\n               (for all J of Positions'Result =>\n                 (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                  then I = J)));\n+                 then I = J)));\n \n       procedure Lift_Abstraction_Level (Container : Map) with\n         --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n@@ -547,9 +549,9 @@ is\n \n             --  Key is inserted in Container\n \n-            and K.Get (Keys (Container),\n-                       P.Get (Positions (Container), Find (Container, Key))) =\n-                Key\n+            and K.Get\n+                  (Keys (Container),\n+                   P.Get (Positions (Container), Find (Container, Key))) = Key\n \n             --  Mapping from cursors to keys is preserved\n "}, {"sha": "9b2c9a4bf0691d7b95702ce99712d05d7972af9e", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 64, "deletions": 115, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -38,16 +38,13 @@ with System; use type System.Address;\n package body Ada.Containers.Formal_Hashed_Sets with\n   SPARK_Mode => Off\n is\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    --  All need comments ???\n \n-   procedure Difference\n-     (Left, Right : Set;\n-      Target      : in out Set);\n+   procedure Difference (Left : Set; Right : Set; Target : in out Set);\n \n    function Equivalent_Keys\n      (Key  : Element_Type;\n@@ -68,10 +65,10 @@ is\n    pragma Inline (Hash_Node);\n \n    procedure Insert\n-     (Container       : in out Set;\n-      New_Item : Element_Type;\n-      Node     : out Count_Type;\n-      Inserted : out Boolean);\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean);\n \n    procedure Intersection\n      (Left   : Set;\n@@ -136,10 +133,13 @@ is\n       begin\n          Node  := First (Left).Node;\n          while Node /= 0 loop\n-            ENode := Find (Container => Right,\n-                           Item      => Left.Nodes (Node).Element).Node;\n-            if ENode = 0 or else\n-              Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n+            ENode :=\n+              Find\n+                (Container => Right,\n+                 Item      => Left.Nodes (Node).Element).Node;\n+\n+            if ENode = 0\n+              or else Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n             then\n                return False;\n             end if;\n@@ -148,9 +148,7 @@ is\n          end loop;\n \n          return True;\n-\n       end;\n-\n    end \"=\";\n \n    ------------\n@@ -228,11 +226,11 @@ is\n       Capacity : Count_Type := 0) return Set\n    is\n       C      : constant Count_Type :=\n-        Count_Type'Max (Capacity, Source.Capacity);\n+                 Count_Type'Max (Capacity, Source.Capacity);\n+      Cu     : Cursor;\n       H      : Hash_Type;\n       N      : Count_Type;\n       Target : Set (C, Source.Modulus);\n-      Cu     : Cursor;\n \n    begin\n       if 0 < Capacity and then Capacity < Source.Capacity then\n@@ -276,10 +274,7 @@ is\n    -- Delete --\n    ------------\n \n-   procedure Delete\n-     (Container : in out Set;\n-      Item      : Element_Type)\n-   is\n+   procedure Delete (Container : in out Set; Item : Element_Type) is\n       X : Count_Type;\n \n    begin\n@@ -292,10 +287,7 @@ is\n       Free (Container, X);\n    end Delete;\n \n-   procedure Delete\n-     (Container : in out Set;\n-      Position  : in out Cursor)\n-   is\n+   procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n@@ -313,11 +305,11 @@ is\n    -- Difference --\n    ----------------\n \n-   procedure Difference\n-     (Target : in out Set;\n-      Source : Set)\n-   is\n-      Tgt_Node, Src_Node, Src_Last, Src_Length : Count_Type;\n+   procedure Difference (Target : in out Set; Source : Set) is\n+      Src_Last   : Count_Type;\n+      Src_Length : Count_Type;\n+      Src_Node   : Count_Type;\n+      Tgt_Node   : Count_Type;\n \n       TN : Nodes_Type renames Target.Nodes;\n       SN : Nodes_Type renames Source.Nodes;\n@@ -369,10 +361,7 @@ is\n       end loop;\n    end Difference;\n \n-   procedure Difference\n-     (Left, Right : Set;\n-      Target      : in out Set)\n-   is\n+   procedure Difference (Left : Set; Right : Set; Target : in out Set) is\n       procedure Process (L_Node : Count_Type);\n \n       procedure Iterate is\n@@ -383,9 +372,10 @@ is\n       -------------\n \n       procedure Process (L_Node : Count_Type) is\n+         B : Boolean;\n          E : Element_Type renames Left.Nodes (L_Node).Element;\n          X : Count_Type;\n-         B : Boolean;\n+\n       begin\n          if Find (Right, E).Node = 0 then\n             Insert (Target, E, X, B);\n@@ -399,7 +389,7 @@ is\n       Iterate (Left);\n    end Difference;\n \n-   function Difference (Left, Right : Set) return Set is\n+   function Difference (Left : Set; Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n \n@@ -437,8 +427,8 @@ is\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in function Element\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in function Element\");\n \n       return Container.Nodes (Position.Node).Element;\n    end Element;\n@@ -466,7 +456,7 @@ is\n          L_Node : Node_Type) return Boolean\n       is\n          R_Index : constant Hash_Type :=\n-           Element_Keys.Index (R_HT, L_Node.Element);\n+                     Element_Keys.Index (R_HT, L_Node.Element);\n          R_Node  : Count_Type := R_HT.Buckets (R_Index);\n          RN      : Nodes_Type renames R_HT.Nodes;\n \n@@ -508,10 +498,7 @@ is\n    -- Exclude --\n    -------------\n \n-   procedure Exclude\n-     (Container : in out Set;\n-      Item      : Element_Type)\n-   is\n+   procedure Exclude (Container : in out Set; Item : Element_Type) is\n       X : Count_Type;\n    begin\n       Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n@@ -771,10 +758,7 @@ is\n    -- Free --\n    ----------\n \n-   procedure Free\n-     (HT : in out Set;\n-      X  : Count_Type)\n-   is\n+   procedure Free (HT : in out Set; X : Count_Type) is\n    begin\n       HT.Nodes (X).Has_Element := False;\n       HT_Ops.Free (HT, X);\n@@ -784,10 +768,7 @@ is\n    -- Generic_Allocate --\n    ----------------------\n \n-   procedure Generic_Allocate\n-     (HT   : in out Set;\n-      Node : out Count_Type)\n-   is\n+   procedure Generic_Allocate (HT : in out Set; Node : out Count_Type) is\n       procedure Allocate is new HT_Ops.Generic_Allocate (Set_Element);\n    begin\n       Allocate (HT, Node);\n@@ -809,14 +790,13 @@ is\n       -- Local Instantiations --\n       --------------------------\n \n-      package Key_Keys is\n-        new Hash_Tables.Generic_Bounded_Keys\n-          (HT_Types        => HT_Types,\n-           Next            => Next,\n-           Set_Next        => Set_Next,\n-           Key_Type        => Key_Type,\n-           Hash            => Hash,\n-           Equivalent_Keys => Equivalent_Key_Node);\n+      package Key_Keys is new Hash_Tables.Generic_Bounded_Keys\n+        (HT_Types        => HT_Types,\n+         Next            => Next,\n+         Set_Next        => Set_Next,\n+         Key_Type        => Key_Type,\n+         Hash            => Hash,\n+         Equivalent_Keys => Equivalent_Key_Node);\n \n       --------------\n       -- Contains --\n@@ -834,10 +814,7 @@ is\n       -- Delete --\n       ------------\n \n-      procedure Delete\n-        (Container : in out Set;\n-         Key       : Key_Type)\n-      is\n+      procedure Delete (Container : in out Set; Key : Key_Type) is\n          X : Count_Type;\n \n       begin\n@@ -884,10 +861,7 @@ is\n       -- Exclude --\n       -------------\n \n-      procedure Exclude\n-        (Container : in out Set;\n-         Key       : Key_Type)\n-      is\n+      procedure Exclude (Container : in out Set; Key : Key_Type) is\n          X : Count_Type;\n       begin\n          Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n@@ -930,6 +904,7 @@ is\n                   return False;\n                end if;\n             end loop;\n+\n             return True;\n          end M_Included_Except;\n \n@@ -942,8 +917,7 @@ is\n       function Key (Container : Set; Position : Cursor) return Key_Type is\n       begin\n          if not Has_Element (Container, Position) then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n+            raise Constraint_Error with \"Position cursor has no element\";\n          end if;\n \n          pragma Assert\n@@ -969,8 +943,7 @@ is\n \n       begin\n          if Node = 0 then\n-            raise Constraint_Error with\n-              \"attempt to replace key not in set\";\n+            raise Constraint_Error with \"attempt to replace key not in set\";\n          end if;\n \n          Replace_Element (Container, Node, New_Item);\n@@ -1006,12 +979,9 @@ is\n    -- Include --\n    -------------\n \n-   procedure Include\n-     (Container : in out Set;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n+   procedure Include (Container : in out Set; New_Item : Element_Type) is\n       Inserted : Boolean;\n+      Position : Cursor;\n \n    begin\n       Insert (Container, New_Item, Position, Inserted);\n@@ -1035,12 +1005,9 @@ is\n       Insert (Container, New_Item, Position.Node, Inserted);\n    end Insert;\n \n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n+   procedure Insert (Container : in out Set; New_Item : Element_Type) is\n       Inserted : Boolean;\n+      Position : Cursor;\n \n    begin\n       Insert (Container, New_Item, Position, Inserted);\n@@ -1099,10 +1066,7 @@ is\n    -- Intersection --\n    ------------------\n \n-   procedure Intersection\n-     (Target : in out Set;\n-      Source : Set)\n-   is\n+   procedure Intersection (Target : in out Set; Source : Set) is\n       Tgt_Node : Count_Type;\n       TN       : Nodes_Type renames Target.Nodes;\n \n@@ -1133,11 +1097,7 @@ is\n       end loop;\n    end Intersection;\n \n-   procedure Intersection\n-     (Left   : Set;\n-      Right  : Set;\n-      Target : in out Set)\n-   is\n+   procedure Intersection (Left : Set; Right : Set; Target : in out Set) is\n       procedure Process (L_Node : Count_Type);\n \n       procedure Iterate is\n@@ -1165,7 +1125,7 @@ is\n       Iterate (Left);\n    end Intersection;\n \n-   function Intersection (Left, Right : Set) return Set is\n+   function Intersection (Left : Set; Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n \n@@ -1179,7 +1139,7 @@ is\n \n       return S : Set (C, H) do\n          if Length (Left) /= 0 and Length (Right) /= 0 then\n-               Intersection (Left, Right, Target => S);\n+            Intersection (Left, Right, Target => S);\n          end if;\n       end return;\n    end Intersection;\n@@ -1301,8 +1261,7 @@ is\n       end if;\n \n       if not Has_Element (Container, Position) then\n-         raise Constraint_Error\n-           with \"Position has no element\";\n+         raise Constraint_Error with \"Position has no element\";\n       end if;\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Next\");\n@@ -1353,16 +1312,12 @@ is\n    -- Replace --\n    -------------\n \n-   procedure Replace\n-     (Container : in out Set;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n       Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n       if Node = 0 then\n-         raise Constraint_Error with\n-           \"attempt to replace element not in set\";\n+         raise Constraint_Error with \"attempt to replace element not in set\";\n       end if;\n \n       Container.Nodes (Node).Element := New_Item;\n@@ -1379,12 +1334,11 @@ is\n    is\n    begin\n       if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor equals No_Element\";\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in Replace_Element\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n       Replace_Element (Container, Position.Node, New_Item);\n    end Replace_Element;\n@@ -1425,10 +1379,7 @@ is\n    -- Symmetric_Difference --\n    --------------------------\n \n-   procedure Symmetric_Difference\n-     (Target : in out Set;\n-      Source : Set)\n-   is\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n       procedure Process (Source_Node : Count_Type);\n       pragma Inline (Process);\n \n@@ -1439,9 +1390,10 @@ is\n       -------------\n \n       procedure Process (Source_Node : Count_Type) is\n+         B : Boolean;\n          N : Node_Type renames Source.Nodes (Source_Node);\n          X : Count_Type;\n-         B : Boolean;\n+\n       begin\n          if Is_In (Target, N) then\n             Delete (Target, N.Element);\n@@ -1467,7 +1419,7 @@ is\n       Iterate (Source);\n    end Symmetric_Difference;\n \n-   function Symmetric_Difference (Left, Right : Set) return Set is\n+   function Symmetric_Difference (Left : Set; Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n \n@@ -1512,10 +1464,7 @@ is\n    -- Union --\n    -----------\n \n-   procedure Union\n-     (Target : in out Set;\n-      Source : Set)\n-   is\n+   procedure Union (Target : in out Set; Source : Set) is\n       procedure Process (Src_Node : Count_Type);\n \n       procedure Iterate is\n@@ -1536,7 +1485,7 @@ is\n          Insert (Target, E, X, B);\n       end Process;\n \n-      --  Start of processing for Union\n+   --  Start of processing for Union\n \n    begin\n       if Target'Address = Source'Address then\n@@ -1546,7 +1495,7 @@ is\n       Iterate (Source);\n    end Union;\n \n-   function Union (Left, Right : Set) return Set is\n+   function Union (Left : Set; Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n "}, {"sha": "fd3d007facde5362b16e349c3fa5da95ad62884c", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 142, "deletions": 154, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -55,8 +55,10 @@ generic\n \n    with function Hash (Element : Element_Type) return Hash_Type;\n \n-   with function Equivalent_Elements (Left, Right : Element_Type)\n-                                      return Boolean is \"=\";\n+   with function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Element_Type) return Boolean is \"=\";\n+\n package Ada.Containers.Formal_Hashed_Sets with\n   SPARK_Mode\n is\n@@ -122,8 +124,9 @@ is\n         Global => null,\n         Post =>\n           (if Find'Result > 0 then\n-             Find'Result <= E.Length (Container)\n-               and Equivalent_Elements (Item, E.Get (Container, Find'Result)));\n+              Find'Result <= E.Length (Container)\n+                and Equivalent_Elements\n+                      (Item, E.Get (Container, Find'Result)));\n \n       function E_Elements_Included\n         (Left  : E.Sequence;\n@@ -135,9 +138,9 @@ is\n         Post   =>\n           E_Elements_Included'Result =\n             (for all I in 1 .. E.Length (Left) =>\n-               Find (Right, E.Get (Left, I)) > 0\n-                 and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n-                     E.Get (Left, I));\n+              Find (Right, E.Get (Left, I)) > 0\n+                and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n+                         E.Get (Left, I));\n       pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n \n       function E_Elements_Included\n@@ -152,9 +155,9 @@ is\n           E_Elements_Included'Result =\n             (for all I in 1 .. E.Length (Left) =>\n               (if M.Contains (Model, E.Get (Left, I)) then\n-                 Find (Right, E.Get (Left, I)) > 0\n-                   and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n-                       E.Get (Left, I)));\n+                  Find (Right, E.Get (Left, I)) > 0\n+                    and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n+                             E.Get (Left, I)));\n       pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n \n       function E_Elements_Included\n@@ -171,13 +174,14 @@ is\n           E_Elements_Included'Result =\n             (for all I in 1 .. E.Length (Container) =>\n               (if M.Contains (Model, E.Get (Container, I)) then\n-                 Find (Left, E.Get (Container, I)) > 0\n-                   and then E.Get (Left, Find (Left, E.Get (Container, I))) =\n-                       E.Get (Container, I)\n+                  Find (Left, E.Get (Container, I)) > 0\n+                    and then E.Get (Left, Find (Left, E.Get (Container, I))) =\n+                             E.Get (Container, I)\n                else\n-                 Find (Right, E.Get (Container, I)) > 0\n-                   and then E.Get (Right, Find (Right, E.Get (Container, I))) =\n-                       E.Get (Container, I)));\n+                  Find (Right, E.Get (Container, I)) > 0\n+                    and then E.Get\n+                               (Right, Find (Right, E.Get (Container, I))) =\n+                             E.Get (Container, I)));\n       pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n \n       package P is new Ada.Containers.Functional_Maps\n@@ -241,8 +245,8 @@ is\n \n                and (for all C of P_Left =>\n                      (if C /= Position then\n-                        E.Get (E_Left, P.Get (P_Left, C)) =\n-                        E.Get (E_Right, P.Get (P_Right, C)))));\n+                         E.Get (E_Left, P.Get (P_Left, C)) =\n+                         E.Get (E_Right, P.Get (P_Right, C)))));\n \n       function Model (Container : Set) return M.Set with\n       --  The high-level model of a set is a set of elements. Neither cursors\n@@ -266,15 +270,16 @@ is\n             --  It only contains keys contained in Model\n \n             and (for all Item of Elements'Result =>\n-                   M.Contains (Model (Container), Item))\n+                  M.Contains (Model (Container), Item))\n \n             --  It contains all the elements contained in Model\n \n             and (for all Item of Model (Container) =>\n                   (Find (Elements'Result, Item) > 0\n-                     and then Equivalent_Elements\n-                      (E.Get (Elements'Result, Find (Elements'Result, Item)),\n-                       Item)))\n+                    and then Equivalent_Elements\n+                               (E.Get (Elements'Result,\n+                                       Find (Elements'Result, Item)),\n+                                Item)))\n \n             --  It has no duplicate\n \n@@ -311,7 +316,7 @@ is\n             and then\n               (for all J of Positions'Result =>\n                 (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                  then I = J)));\n+                 then I = J)));\n \n       procedure Lift_Abstraction_Level (Container : Set) with\n         --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n@@ -343,13 +348,13 @@ is\n    function \"=\" (Left, Right : Set) return Boolean with\n      Global => null,\n      Post   =>\n-       \"=\"'Result =\n-         (Length (Left) = Length (Right)\n-            and E_Elements_Included (Elements (Left), Elements (Right)))\n+         \"=\"'Result =\n+           (Length (Left) = Length (Right)\n+             and E_Elements_Included (Elements (Left), Elements (Right)))\n        and\n          \"=\"'Result =\n            (E_Elements_Included (Elements (Left), Elements (Right))\n-              and E_Elements_Included (Elements (Right), Elements (Left)));\n+             and E_Elements_Included (Elements (Right), Elements (Left)));\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean with\n      Global => null,\n@@ -378,12 +383,10 @@ is\n \n          --  Actual elements are preserved\n \n-         and\n-           E_Elements_Included\n-             (Elements (Container), Elements (Container)'Old)\n-         and\n-           E_Elements_Included\n-             (Elements (Container)'Old, Elements (Container));\n+         and E_Elements_Included\n+              (Elements (Container), Elements (Container)'Old)\n+         and E_Elements_Included\n+              (Elements (Container)'Old, Elements (Container));\n \n    function Is_Empty (Container : Set) return Boolean with\n      Global => null,\n@@ -402,10 +405,8 @@ is\n \n          --  Actual elements are preserved\n \n-         and\n-           E_Elements_Included (Elements (Target), Elements (Source))\n-         and\n-           E_Elements_Included (Elements (Source), Elements (Target));\n+         and E_Elements_Included (Elements (Target), Elements (Source))\n+         and E_Elements_Included (Elements (Source), Elements (Target));\n \n    function Copy\n      (Source   : Set;\n@@ -482,10 +483,8 @@ is\n \n          --  Actual elements are preserved\n \n-         and\n-           E_Elements_Included (Elements (Target), Elements (Source)'Old)\n-         and\n-           E_Elements_Included (Elements (Source)'Old, Elements (Target));\n+         and E_Elements_Included (Elements (Target), Elements (Source)'Old)\n+         and E_Elements_Included (Elements (Source)'Old, Elements (Target));\n \n    procedure Insert\n      (Container : in out Set;\n@@ -769,27 +768,25 @@ is\n \n          --  Elements of Target come from either Source or Target\n \n-         and\n-           M.Included_In_Union\n-             (Model (Target), Model (Source), Model (Target)'Old)\n+         and M.Included_In_Union\n+               (Model (Target), Model (Source), Model (Target)'Old)\n \n          --  Actual value of elements come from either Left or Right\n \n-         and\n-           E_Elements_Included\n-             (Elements (Target),\n-              Model (Target)'Old,\n-              Elements (Target)'Old,\n-              Elements (Source))\n-         and\n-           E_Elements_Included\n-             (Elements (Target)'Old, Model (Target)'Old, Elements (Target))\n-         and\n-           E_Elements_Included\n-             (Elements (Source),\n-              Model (Target)'Old,\n-              Elements (Source),\n-              Elements (Target))\n+         and E_Elements_Included\n+               (Elements (Target),\n+                Model (Target)'Old,\n+                Elements (Target)'Old,\n+                Elements (Source))\n+\n+         and E_Elements_Included\n+               (Elements (Target)'Old, Model (Target)'Old, Elements (Target))\n+\n+         and E_Elements_Included\n+               (Elements (Source),\n+                Model (Target)'Old,\n+                Elements (Source),\n+                Elements (Target))\n \n          --  Mapping from cursors of Target to elements is preserved\n \n@@ -820,21 +817,20 @@ is\n \n          --  Actual value of elements come from either Left or Right\n \n-         and\n-           E_Elements_Included\n-             (Elements (Union'Result),\n-              Model (Left),\n-              Elements (Left),\n-              Elements (Right))\n-         and\n-           E_Elements_Included\n-             (Elements (Left), Model (Left), Elements (Union'Result))\n-         and\n-           E_Elements_Included\n-             (Elements (Right),\n-              Model (Left),\n-              Elements (Right),\n-              Elements (Union'Result));\n+         and E_Elements_Included\n+               (Elements (Union'Result),\n+                Model (Left),\n+                Elements (Left),\n+                Elements (Right))\n+\n+         and E_Elements_Included\n+               (Elements (Left), Model (Left), Elements (Union'Result))\n+\n+         and E_Elements_Included\n+               (Elements (Right),\n+                Model (Left),\n+                Elements (Right),\n+                Elements (Union'Result));\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n@@ -854,16 +850,14 @@ is\n \n          --  Elements both in Source and Target are in the intersection\n \n-         and\n-           M.Includes_Intersection\n-             (Model (Target), Model (Source), Model (Target)'Old)\n+         and M.Includes_Intersection\n+               (Model (Target), Model (Source), Model (Target)'Old)\n \n          --  Actual value of elements of Target is preserved\n \n          and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n-         and\n-           E_Elements_Included\n-             (Elements (Target)'Old, Model (Source), Elements (Target))\n+         and E_Elements_Included\n+               (Elements (Target)'Old, Model (Source), Elements (Target))\n \n          --  Mapping from cursors of Target to elements is preserved\n \n@@ -886,18 +880,17 @@ is\n \n          --  Elements both in Left and Right are in the result of Intersection\n \n-         and\n-           M.Includes_Intersection\n-             (Model (Intersection'Result), Model (Left), Model (Right))\n+         and M.Includes_Intersection\n+               (Model (Intersection'Result), Model (Left), Model (Right))\n \n          --  Actual value of elements come from Left\n \n-         and\n-           E_Elements_Included\n-             (Elements (Intersection'Result), Elements (Left))\n-         and\n-           E_Elements_Included\n-             (Elements (Left), Model (Right), Elements (Intersection'Result));\n+         and E_Elements_Included\n+               (Elements (Intersection'Result), Elements (Left))\n+\n+         and E_Elements_Included\n+               (Elements (Left), Model (Right),\n+                Elements (Intersection'Result));\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n@@ -917,16 +910,14 @@ is\n \n          --  Elements in Target but not in Source are in the difference\n \n-         and\n-           M.Included_In_Union\n-             (Model (Target)'Old, Model (Target), Model (Source))\n+         and M.Included_In_Union\n+               (Model (Target)'Old, Model (Target), Model (Source))\n \n          --  Actual value of elements of Target is preserved\n \n          and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n-         and\n-           E_Elements_Included\n-             (Elements (Target)'Old, Model (Target), Elements (Target))\n+         and E_Elements_Included\n+               (Elements (Target)'Old, Model (Target), Elements (Target))\n \n          --  Mapping from cursors of Target to elements is preserved\n \n@@ -952,19 +943,18 @@ is\n \n          --  Elements in Left but not in Right are in the difference\n \n-         and\n-           M.Included_In_Union\n-             (Model (Left), Model (Difference'Result), Model (Right))\n+         and M.Included_In_Union\n+               (Model (Left), Model (Difference'Result), Model (Right))\n \n          --  Actual value of elements come from Left\n \n-         and\n-           E_Elements_Included (Elements (Difference'Result), Elements (Left))\n-         and\n-           E_Elements_Included\n-             (Elements (Left),\n-              Model (Difference'Result),\n-              Elements (Difference'Result));\n+         and E_Elements_Included\n+               (Elements (Difference'Result), Elements (Left))\n+\n+         and E_Elements_Included\n+               (Elements (Left),\n+                Model (Difference'Result),\n+                Elements (Difference'Result));\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n@@ -984,30 +974,27 @@ is\n \n          --  Elements in Target but not in Source are in the difference\n \n-         and\n-           M.Included_In_Union\n-             (Model (Target)'Old, Model (Target), Model (Source))\n+         and M.Included_In_Union\n+               (Model (Target)'Old, Model (Target), Model (Source))\n \n          --  Elements in Source but not in Target are in the difference\n \n-         and\n-           M.Included_In_Union\n-             (Model (Source), Model (Target), Model (Target)'Old)\n+         and M.Included_In_Union\n+               (Model (Source), Model (Target), Model (Target)'Old)\n \n          --  Actual value of elements come from either Left or Right\n \n-         and\n-           E_Elements_Included\n-             (Elements (Target),\n-              Model (Target)'Old,\n-              Elements (Target)'Old,\n-              Elements (Source))\n-         and\n-           E_Elements_Included\n-             (Elements (Target)'Old, Model (Target), Elements (Target))\n-         and\n-           E_Elements_Included\n-             (Elements (Source), Model (Target), Elements (Target));\n+         and E_Elements_Included\n+               (Elements (Target),\n+                Model (Target)'Old,\n+                Elements (Target)'Old,\n+                Elements (Source))\n+\n+         and E_Elements_Included\n+               (Elements (Target)'Old, Model (Target), Elements (Target))\n+\n+         and E_Elements_Included\n+               (Elements (Source), Model (Target), Elements (Target));\n \n    function Symmetric_Difference (Left, Right : Set) return Set with\n      Global => null,\n@@ -1019,40 +1006,42 @@ is\n \n          --  Elements of the difference were not both in Left and Right\n \n-         and\n-           M.Not_In_Both\n-             (Model (Symmetric_Difference'Result), Model (Left), Model (Right))\n+         and M.Not_In_Both\n+               (Model (Symmetric_Difference'Result),\n+                Model (Left),\n+                Model (Right))\n \n          --  Elements in Left but not in Right are in the difference\n \n-         and\n-           M.Included_In_Union\n-             (Model (Left), Model (Symmetric_Difference'Result), Model (Right))\n+         and M.Included_In_Union\n+               (Model (Left),\n+                Model (Symmetric_Difference'Result),\n+                Model (Right))\n \n          --  Elements in Right but not in Left are in the difference\n \n-         and\n-           M.Included_In_Union\n-             (Model (Right), Model (Symmetric_Difference'Result), Model (Left))\n+         and M.Included_In_Union\n+               (Model (Right),\n+                Model (Symmetric_Difference'Result),\n+                Model (Left))\n \n          --  Actual value of elements come from either Left or Right\n \n-         and\n-           E_Elements_Included\n-             (Elements (Symmetric_Difference'Result),\n-              Model (Left),\n-              Elements (Left),\n-              Elements (Right))\n-         and\n-           E_Elements_Included\n-             (Elements (Left),\n-              Model (Symmetric_Difference'Result),\n-              Elements (Symmetric_Difference'Result))\n-         and\n-           E_Elements_Included\n-             (Elements (Right),\n-              Model (Symmetric_Difference'Result),\n-              Elements (Symmetric_Difference'Result));\n+         and E_Elements_Included\n+               (Elements (Symmetric_Difference'Result),\n+                Model (Left),\n+                Elements (Left),\n+                Elements (Right))\n+\n+         and E_Elements_Included\n+               (Elements (Left),\n+                Model (Symmetric_Difference'Result),\n+                Elements (Symmetric_Difference'Result))\n+\n+         and E_Elements_Included\n+               (Elements (Right),\n+                Model (Symmetric_Difference'Result),\n+                Elements (Symmetric_Difference'Result));\n \n    function \"xor\" (Left, Right : Set) return Set\n      renames Symmetric_Difference;\n@@ -1167,8 +1156,8 @@ is\n              Post   =>\n                M_Included_Except'Result =\n                  (for all E of Left =>\n-                    Contains (Right, E)\n-                      or Equivalent_Keys (Generic_Keys.Key (E), Key));\n+                   Contains (Right, E)\n+                     or Equivalent_Keys (Generic_Keys.Key (E), Key));\n \n       end Formal_Model;\n       use Formal_Model;\n@@ -1309,16 +1298,15 @@ is\n \n                --  The key designated by the result of Find is Key\n \n-               and\n-                 Equivalent_Keys\n-                   (Generic_Keys.Key (Container, Find'Result), Key));\n+               and Equivalent_Keys\n+                     (Generic_Keys.Key (Container, Find'Result), Key));\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean with\n         Global => null,\n         Post   =>\n           Contains'Result =\n             (for some E of Model (Container) =>\n-                Equivalent_Keys (Key, Generic_Keys.Key (E)));\n+              Equivalent_Keys (Key, Generic_Keys.Key (E)));\n \n    end Generic_Keys;\n "}, {"sha": "8a9d11dccc076db67929f87ac7dccda5fe250197", "filename": "gcc/ada/a-cfinve.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -705,12 +705,11 @@ is\n          function \"<\" (Left : Holder; Right : Holder) return Boolean is\n            (E (Left) < E (Right));\n \n-         procedure Sort is\n-           new Generic_Array_Sort\n-                 (Index_Type   => Array_Index,\n-                  Element_Type => Holder,\n-                  Array_Type   => Elements_Array,\n-                  \"<\"          => \"<\");\n+         procedure Sort is new Generic_Array_Sort\n+           (Index_Type   => Array_Index,\n+            Element_Type => Holder,\n+            Array_Type   => Elements_Array,\n+            \"<\"          => \"<\");\n \n          Len : constant Capacity_Range := Length (Container);\n \n@@ -1065,8 +1064,9 @@ is\n       then\n          Reserve_Capacity\n            (Container,\n-            Capacity_Range'Max (Current_Capacity (Container) * Growth_Factor,\n-                                Capacity_Range (New_Length)));\n+            Capacity_Range'Max\n+              (Current_Capacity (Container) * Growth_Factor,\n+               Capacity_Range (New_Length)));\n       end if;\n \n       declare\n@@ -1348,10 +1348,10 @@ is\n       --  hence we also know that\n       --    Index - Index_Type'First >= 0\n \n-      --  The issue is that even though 0 is guaranteed to be a value in\n-      --  the type Index_Type'Base, there's no guarantee that the difference\n-      --  is a value in that type. To prevent overflow we use the wider\n-      --  of Count_Type'Base and Index_Type'Base to perform intermediate\n+      --  The issue is that even though 0 is guaranteed to be a value in the\n+      --  type Index_Type'Base, there's no guarantee that the difference is a\n+      --  value in that type. To prevent overflow we use the wider of\n+      --  Count_Type'Base and Index_Type'Base to perform intermediate\n       --  calculations.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n@@ -1362,8 +1362,8 @@ is\n                      Count_Type'Base (Index_Type'First);\n       end if;\n \n-      --  The array index subtype for all container element arrays\n-      --  always starts with 1.\n+      --  The array index subtype for all container element arrays always\n+      --  starts with 1.\n \n       return 1 + Offset;\n    end To_Array_Index;"}, {"sha": "a7799e556a616f58e5eacfa83de287691dd83647", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -830,9 +830,9 @@ is\n            Post   =>\n              M_Elements_Sorted'Result =\n                (for all I in Index_Type'First .. M.Last (Container) =>\n-                  (for all J in I .. M.Last (Container) =>\n-                       Element (Container, I) = Element (Container, J)\n-                         or Element (Container, I) < Element (Container, J)));\n+                 (for all J in I .. M.Last (Container) =>\n+                   Element (Container, I) = Element (Container, J)\n+                     or Element (Container, I) < Element (Container, J)));\n          pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       end Formal_Model;"}, {"sha": "5967973b0fa75165ea0a22b88daecc3769a21f3e", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -518,7 +518,9 @@ is\n       -- Find --\n       ----------\n \n-      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n+      function Find\n+        (Container : K.Sequence;\n+         Key       : Key_Type) return Count_Type\n       is\n       begin\n          for I in 1 .. K.Length (Container) loop\n@@ -634,9 +636,12 @@ is\n          --  for their postconditions.\n \n          while Position /= 0 loop\n-            R := M.Add (Container => R,\n-                        New_Key   => Container.Nodes (Position).Key,\n-                        New_Item  => Container.Nodes (Position).Element);\n+            R :=\n+              M.Add\n+                (Container => R,\n+                 New_Key   => Container.Nodes (Position).Key,\n+                 New_Item  => Container.Nodes (Position).Element);\n+\n             Position := Tree_Operations.Next (Container, Position);\n          end loop;\n "}, {"sha": "ed4e872f159d62d7c27619d46e215b54bc321310", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -159,16 +159,16 @@ is\n         Pre    => Position - 1 <= K.Length (Container),\n         Post   =>\n           K_Is_Find'Result =\n+             ((if Position > 0 then\n+                  K_Bigger_Than_Range (Container, 1, Position - 1, Key))\n \n-            ((if Position > 0 then\n-                K_Bigger_Than_Range (Container, 1, Position - 1, Key))\n-\n-             and (if Position < K.Length (Container) then\n-                    K_Smaller_Than_Range\n-                      (Container,\n-                       Position + 1,\n-                       K.Length (Container),\n-                       Key)));\n+            and\n+              (if Position < K.Length (Container) then\n+                  K_Smaller_Than_Range\n+                    (Container,\n+                     Position + 1,\n+                     K.Length (Container),\n+                     Key)));\n       pragma Annotate (GNATprove, Inline_For_Proof, K_Is_Find);\n \n       function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n@@ -178,8 +178,8 @@ is\n         Global => null,\n         Post =>\n           (if Find'Result > 0 then\n-             Find'Result <= K.Length (Container)\n-               and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n+              Find'Result <= K.Length (Container)\n+                and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n \n       package P is new Ada.Containers.Functional_Maps\n         (Key_Type                       => Cursor,\n@@ -246,20 +246,21 @@ is\n             --  It only contains keys contained in Model\n \n             and (for all Key of Keys'Result =>\n-                   M.Has_Key (Model (Container), Key))\n+                  M.Has_Key (Model (Container), Key))\n \n             --  It contains all the keys contained in Model\n \n             and (for all Key of Model (Container) =>\n                   (Find (Keys'Result, Key) > 0\n-                     and then Equivalent_Keys\n-                      (K.Get (Keys'Result, Find (Keys'Result, Key)), Key)))\n+                    and then Equivalent_Keys\n+                               (K.Get (Keys'Result, Find (Keys'Result, Key)),\n+                                Key)))\n \n             --  It is sorted in increasing order\n \n             and (for all I in 1 .. Length (Container) =>\n                   Find (Keys'Result, K.Get (Keys'Result, I)) = I\n-                  and K_Is_Find (Keys'Result, K.Get (Keys'Result, I), I));\n+                    and K_Is_Find (Keys'Result, K.Get (Keys'Result, I), I));\n       pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n \n       function Positions (Container : Map) return P.Map with\n@@ -284,7 +285,7 @@ is\n             and then\n               (for all J of Positions'Result =>\n                 (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                  then I = J)));\n+                 then I = J)));\n \n       procedure Lift_Abstraction_Level (Container : Map) with\n         --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n@@ -942,7 +943,7 @@ is\n      Contract_Cases =>\n        (Position = No_Element\n           or else P.Get (Positions (Container), Position) = 1\n-         =>\n+        =>\n           Position = No_Element,\n \n         others =>\n@@ -983,6 +984,7 @@ is\n      Contract_Cases =>\n        (Length (Container) = 0 or else Key < First_Key (Container) =>\n           Floor'Result = No_Element,\n+\n         others =>\n           Has_Element (Container, Floor'Result)\n             and not (Key < K.Get (Keys (Container),\n@@ -999,9 +1001,9 @@ is\n           Ceiling'Result = No_Element,\n         others =>\n           Has_Element (Container, Ceiling'Result)\n-            and\n-              not (K.Get (Keys (Container),\n-                          P.Get (Positions (Container), Ceiling'Result)) < Key)\n+            and not (K.Get\n+                       (Keys (Container),\n+                        P.Get (Positions (Container), Ceiling'Result)) < Key)\n             and K_Is_Find\n                   (Keys (Container),\n                    Key,"}, {"sha": "b386c5243ba8455256e21dfefc8e3a95f679651c", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -608,6 +608,7 @@ is\n                return False;\n             end if;\n          end loop;\n+\n          return True;\n       end E_Bigger_Than_Range;\n \n@@ -700,6 +701,7 @@ is\n                end if;\n             end loop;\n          end if;\n+\n          return True;\n       end E_Is_Find;\n \n@@ -719,6 +721,7 @@ is\n                return False;\n             end if;\n          end loop;\n+\n          return True;\n       end E_Smaller_Than_Range;\n \n@@ -736,6 +739,7 @@ is\n                return I;\n             end if;\n          end loop;\n+\n          return 0;\n       end Find;\n "}, {"sha": "93a38b5134473bce4b451a4a79bf0922685c04b3", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -152,8 +152,11 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    -- Has_Witness --\n    -----------------\n \n-   function Has_Witness (Container : Map; Witness : Count_Type) return Boolean\n-   is (Witness in 1 .. Length (Container.Keys));\n+   function Has_Witness\n+     (Container : Map;\n+      Witness   : Count_Type) return Boolean\n+   is\n+     (Witness in 1 .. Length (Container.Keys));\n \n    --------------\n    -- Is_Empty --\n@@ -265,7 +268,9 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    -- W_Get --\n    -----------\n \n-   function W_Get (Container : Map; Witness : Count_Type) return Element_Type\n+   function W_Get\n+     (Container : Map;\n+      Witness   : Count_Type) return Element_Type\n    is\n      (Get (Container.Elements, Witness));\n "}, {"sha": "f98bfe7b4073c0230122afd1ae75971b1c8bf2d5", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -35,9 +35,11 @@ private with Ada.Containers.Functional_Base;\n generic\n    type Key_Type (<>) is private;\n    type Element_Type (<>)  is private;\n+\n    with function Equivalent_Keys\n      (Left  : Key_Type;\n       Right : Key_Type) return Boolean is \"=\";\n+\n    Enable_Handling_Of_Equivalence : Boolean := True;\n    --  This constant should only be set to False when no particular handling\n    --  of equivalence over keys is needed, that is, Equivalent_Keys defines a\n@@ -77,7 +79,7 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n           --  Has_Key returns the same result on all equivalent keys\n \n           (if (for some K of Container => Equivalent_Keys (K, Key)) then\n-             Has_Key'Result));\n+              Has_Key'Result));\n \n    function Get (Container : Map; Key : Key_Type) return Element_Type with\n    --  Return the element associated with Key in Container\n@@ -90,8 +92,8 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n           --  Get returns the same result on all equivalent keys\n \n           Get'Result = W_Get (Container, Witness (Container, Key))\n-          and (for all K of Container =>\n-                 (Equivalent_Keys (K, Key) =\n+            and (for all K of Container =>\n+                  (Equivalent_Keys (K, Key) =\n                     (Witness (Container, Key) = Witness (Container, K)))));\n \n    function Length (Container : Map) return Count_Type with"}, {"sha": "5eafbc40450a57740e8c155b52ea390d4c983cf1", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -34,9 +34,11 @@ private with Ada.Containers.Functional_Base;\n \n generic\n    type Element_Type (<>) is private;\n+\n    with function Equivalent_Elements\n      (Left  : Element_Type;\n       Right : Element_Type) return Boolean is \"=\";\n+\n    Enable_Handling_Of_Equivalence : Boolean := True;\n    --  This constant should only be set to False when no particular handling\n    --  of equivalence over elements is needed, that is, Equivalent_Elements\n@@ -75,7 +77,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n           --  Contains returns the same result on all equivalent elements\n \n           (if (for some E of Container => Equivalent_Elements (E, Item)) then\n-             Contains'Result));\n+              Contains'Result));\n \n    function Length (Container : Set) return Count_Type with\n      Global => null;\n@@ -89,8 +91,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    --  Set inclusion\n \n      Global => null,\n-     Post   => \"<=\"'Result = (for all Item of Left => Contains (Right, Item))\n-       and (if \"<=\"'Result then Length (Left) <= Length (Right));\n+     Post   => \"<=\"'Result = (for all Item of Left => Contains (Right, Item));\n \n    function \"=\" (Left : Set; Right : Set) return Boolean with\n    --  Extensional equality over sets\n@@ -187,7 +188,12 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n      Global => null,\n      Post   =>\n-       Num_Overlaps'Result = Length (Intersection (Left, Right));\n+       Num_Overlaps'Result = Length (Intersection (Left, Right))\n+         and (if Left <= Right then Num_Overlaps'Result = Length (Left)\n+              else Num_Overlaps'Result < Length (Left))\n+         and (if Right <= Left then Num_Overlaps'Result = Length (Right)\n+              else Num_Overlaps'Result < Length (Right))\n+         and (Num_Overlaps'Result = 0) = No_Overlap (Left, Right);\n \n    ----------------------------\n    -- Construction Functions --"}, {"sha": "36f43605fa22f239b10a5ff0dd0ef54848356112", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -4798,7 +4798,7 @@ package body Exp_Ch6 is\n                   Init_Assignment :=\n                     Make_Assignment_Statement (Loc,\n                       Name       => New_Occurrence_Of (Ret_Obj_Id, Loc),\n-                      Expression => Relocate_Node (Ret_Obj_Expr));\n+                      Expression => New_Copy_Tree (Ret_Obj_Expr));\n \n                   Set_Etype (Name (Init_Assignment), Etype (Ret_Obj_Id));\n                   Set_Assignment_OK (Name (Init_Assignment));"}, {"sha": "92b330708595925a3afa7bdb99d00a688e0ac2f3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fa5335e2171cbfd732a9acba9f22f0df784913/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d5fa5335e2171cbfd732a9acba9f22f0df784913", "patch": "@@ -17003,7 +17003,7 @@ package body Sem_Util is\n \n    package NCT_Itype_Assoc is new Simple_HTable (\n      Header_Num => NCT_Header_Num,\n-     Element    => Entity_Id,\n+     Element    => Node_Or_Entity_Id,\n      No_Element => Empty,\n      Key        => Entity_Id,\n      Hash       => New_Copy_Hash,\n@@ -17114,37 +17114,45 @@ package body Sem_Util is\n       ---------------------------\n \n       procedure Build_NCT_Hash_Tables is\n-         Elmt : Elmt_Id;\n-         Ent  : Entity_Id;\n+         Assoc : Entity_Id;\n+         Elmt  : Elmt_Id;\n+         Key   : Entity_Id;\n+         Value : Entity_Id;\n \n       begin\n          if No (Map) then\n             return;\n          end if;\n \n+         --  Clear both hash tables associated with entry replication since\n+         --  multiple calls to New_Copy_Tree could cause multiple collisions\n+         --  and produce long linked lists in individual buckets.\n+\n+         NCT_Assoc.Reset;\n+         NCT_Itype_Assoc.Reset;\n+\n          Elmt := First_Elmt (Map);\n          while Present (Elmt) loop\n-            Ent := Node (Elmt);\n \n-            --  Get new entity, and associate old and new\n+            --  Extract a (key, value) pair from the map\n \n+            Key := Node (Elmt);\n             Next_Elmt (Elmt);\n-            NCT_Assoc.Set (Ent, Node (Elmt));\n+            Value := Node (Elmt);\n \n-            if Is_Type (Ent) then\n-               declare\n-                  Anode : constant Entity_Id :=\n-                            Associated_Node_For_Itype (Ent);\n+            --  Add the pair in the association hash table\n \n-               begin\n-                  --  Enter the link between the associated node of the old\n-                  --  Itype and the new Itype, for updating later when node\n-                  --  is copied.\n+            NCT_Assoc.Set (Key, Value);\n \n-                  if Present (Anode) then\n-                     NCT_Itype_Assoc.Set (Anode, Node (Elmt));\n-                  end if;\n-               end;\n+            --  Add a link between the associated node of the old Itype and the\n+            --  new Itype, for updating later when node is copied.\n+\n+            if Is_Type (Key) then\n+               Assoc := Associated_Node_For_Itype (Key);\n+\n+               if Present (Assoc) then\n+                  NCT_Itype_Assoc.Set (Assoc, Value);\n+               end if;\n             end if;\n \n             Next_Elmt (Elmt);\n@@ -17540,23 +17548,29 @@ package body Sem_Util is\n          pragma Assert (not Is_Itype (Old_Entity));\n          pragma Assert (Nkind (Old_Entity) in N_Entity);\n \n-         --  Restrict entity creation to declarations of constants, variables\n-         --  and subtypes. There is no need to duplicate entities declared in\n-         --  inner scopes.\n+         --  Do not duplicate an entity when it is declared within an inner\n+         --  scope enclosed by an expression with actions.\n \n-         if (not Ekind_In (Old_Entity, E_Constant, E_Variable)\n-              and then Nkind (Parent (Old_Entity)) /= N_Subtype_Declaration)\n-           or else EWA_Inner_Scope_Level > 0\n-         then\n+         if EWA_Inner_Scope_Level > 0 then\n+            return;\n+\n+         --  Entity duplication is currently performed only for objects and\n+         --  types. Relaxing this restriction leads to a performance penalty.\n+\n+         elsif Ekind_In (Old_Entity, E_Constant, E_Variable) then\n+            null;\n+\n+         elsif Is_Type (Old_Entity) then\n+            null;\n+\n+         else\n             return;\n          end if;\n \n          New_E := New_Copy (Old_Entity);\n \n-         --  The new entity has all the attributes of the old one, and we\n-         --  just copy the contents of the entity. However, the back-end\n-         --  needs different names for debugging purposes, so we create a\n-         --  new internal name for it in all cases.\n+         --  The new entity has all the attributes of the old one, however it\n+         --  requires a new name for debugging purposes.\n \n          Set_Chars (New_E, New_Internal_Name ('T'));\n \n@@ -17830,8 +17844,8 @@ package body Sem_Util is\n             while Present (New_E) loop\n \n                --  Skip entities that were not created in the first phase\n-               --  (that is, old entities specified by the caller in the\n-               --  set of mappings to be applied to the tree).\n+               --  (that is, old entities specified by the caller in the set of\n+               --  mappings to be applied to the tree).\n \n                if Is_Itype (New_E)\n                  or else No (Map)"}]}