{"sha": "742855605950c43419bed950f7f0866cfbbc1c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyODU1NjA1OTUwYzQzNDE5YmVkOTUwZjdmMDg2NmNmYmJjMWM1ZA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-19T16:33:18Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-19T16:33:18Z"}, "message": "Force left-to-right evaluation of binary operations etc.\n\n \n\tForce left-to-right evaluation of binary operations etc.\n\t* expr.c (force_evaluation_order), java-tree.h:  New function.\n\t* parse.y (java_complete_lhs):  Pass binary operations, procedure\n\tcalls, and ARRAY_REFs to force_evaluation_order.\n\t(various):  Set TREE_SIDE_EFFECTS more carefully.\n\tTolerate random (non-UTF8) encoding in comments without complaining.\n\t* lex.c (java_read_char):  Return 0xFFFE if bad UTF8 encoding.\n\t(java_is_eol):  Handle '\\r' followed by '\\n' instead of vice versa.\n\t* parse.y (resolve_qualified_expression_name):  Handle error_mark.\n\t(java_complete_node case EXPR_WITH_FILE_LOCATION):  Likewise.\n\t* parse.y (java_complete_lhs):  Ignore an empty statement in a\n\tCOMPOUND_EXPR.  Don't complain about empty statement after return.\n\nFrom-SVN: r25326", "tree": {"sha": "f91030069f52afee0467bda834f76d3f91ecf256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f91030069f52afee0467bda834f76d3f91ecf256"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/742855605950c43419bed950f7f0866cfbbc1c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742855605950c43419bed950f7f0866cfbbc1c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742855605950c43419bed950f7f0866cfbbc1c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742855605950c43419bed950f7f0866cfbbc1c5d/comments", "author": null, "committer": null, "parents": [{"sha": "c60ca7db2a2b90250208144231af8928acaf8adb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c60ca7db2a2b90250208144231af8928acaf8adb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c60ca7db2a2b90250208144231af8928acaf8adb"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "0848806ac5b51803a52683d44426276fde9c2488", "filename": "gcc/java/expr.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742855605950c43419bed950f7f0866cfbbc1c5d/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742855605950c43419bed950f7f0866cfbbc1c5d/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=742855605950c43419bed950f7f0866cfbbc1c5d", "patch": "@@ -29,6 +29,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"tree.h\"\n #include \"real.h\"\n #include \"rtl.h\"\n+#include \"flags.h\"\n #include \"expr.h\"\n #include \"java-tree.h\"\n #include \"javaop.h\"\n@@ -2470,3 +2471,49 @@ process_jvm_instruction (PC, byte_ops, length)\n   }\n   return PC;\n }\n+\n+/* Force the (direct) sub-operands of NODE to be evaluated in left-to-right\n+   order, as specified by Java Language Specification.\n+\n+   The problem is that while expand_expr will evaluate its sub-operands in\n+   left-to-right order, for variables it will just return an rtx (i.e.\n+   an lvalue) for the variable (rather than an rvalue).  So it is possible\n+   that a later sub-operand will change the register, and when the\n+   actual operation is done, it will use the new value, when it should\n+   have used the original value.\n+\n+   We fix this by using save_expr.  This forces the sub-operand to be\n+   copied into a fresh virtual register,\n+*/\n+\n+tree\n+force_evaluation_order (node)\n+     tree  node;\n+{\n+  if (flag_syntax_only)\n+    return node;\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) == '2'\n+      && TREE_CODE (node) == ARRAY_REF)\n+    {\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (node, 1)))\n+\tTREE_OPERAND (node, 0) = save_expr (TREE_OPERAND (node, 0));\n+    }\n+  else if (TREE_CODE (node) == CALL_EXPR || TREE_CODE (node) == NEW_CLASS_EXPR)\n+    {\n+      tree last_side_effecting_arg = NULL_TREE;\n+      tree arg = TREE_OPERAND (node, 1);\n+      for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+\t{\n+\t  if (TREE_SIDE_EFFECTS (TREE_VALUE (arg)))\n+\t    last_side_effecting_arg = arg;\n+\t}\n+      arg = TREE_OPERAND (node, 1);\n+      for (; arg != NULL_TREE;  arg = TREE_CHAIN (arg))\n+\t{\n+\t  if (arg == last_side_effecting_arg)\n+\t    break;\n+\t  TREE_VALUE (arg) = save_expr (TREE_VALUE (arg)); \n+\t}\n+    }\n+  return node;\n+}"}]}