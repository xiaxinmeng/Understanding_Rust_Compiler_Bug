{"sha": "c389991432da2bcc335a2b4fb7e502d28a6b3346", "node_id": "C_kwDOANBUbNoAKGMzODk5OTE0MzJkYTJiY2MzMzVhMmI0ZmI3ZTUwMmQyOGE2YjMzNDY", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2023-01-10T13:18:22Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2023-01-10T13:20:30Z"}, "message": "ipa: Sort ipa_param_body_adjustments::m_replacements (PR 108110)\n\nThe problem in PR 108110 is that elements describing the same base\nparameter in ipa_param_body_adjustments::m_replacements are not\nadjacent to each other, which is something that\nipa_param_body_adjustments::modify_call_stmt when it gathers all\nreplacements for a parameter.\n\nOne option would be to simply always keep looking until the end of the\nvector (see bugzilla comment 15 for a one-line fix) but the correct\nthing to do is to keep the elements of the vector sorted and thus make\nsuch elements adjacent again.  This patch does that and then also\nmodifies the look-ups to take advantage of it.\n\nSince the one user of ipa_param_body_adjustments that is not\ntree-inline.cc, which is OpenMP declare SIMD cloning code, also\nregisters its own replacements and in theory pointers to elements of\nthe m_replacements vector can leak through public method\nget_expr_replacement, I decided that in those cases it is the\nresponsibility of the user of the class to call the sorting method\nbetween the replacement registrations and the first lookup.  That is\nwhy the patch also adds a line to omp-simd-clone.cc.\n\ngcc/ChangeLog:\n\n2023-01-09  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/108110\n\t* ipa-param-manipulation.h (ipa_param_body_adjustments): New members\n\tsort_replacements, lookup_first_base_replacement and\n\tm_sorted_replacements_p.\n\t* ipa-param-manipulation.cc: Define INCLUDE_ALGORITHM.\n\t(ipa_param_body_adjustments::register_replacement): Set\n\tm_sorted_replacements_p to false.\n\t(compare_param_body_replacement): New function.\n\t(ipa_param_body_adjustments::sort_replacements): Likewise.\n\t(ipa_param_body_adjustments::common_initialization): Call\n\tsort_replacements.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Initialize\n\tm_sorted_replacements_p.\n\t(ipa_param_body_adjustments::lookup_replacement_1): Rework to use\n\tstd::lower_bound.\n\t(ipa_param_body_adjustments::lookup_first_base_replacement): New\n\tfunction.\n\t(ipa_param_body_adjustments::modify_call_stmt): Use\n\tlookup_first_base_replacement.\n\t* omp-simd-clone.cc (ipa_simd_modify_function_body): Call\n\tadjustments->sort_replacements.\n\ngcc/testsuite/ChangeLog:\n\n2023-01-04  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/108110\n\t* g++.dg/ipa/pr108110.C: New test.", "tree": {"sha": "24c24f86607906614b589d165184f149626eba59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24c24f86607906614b589d165184f149626eba59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c389991432da2bcc335a2b4fb7e502d28a6b3346", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmO9Zh4ACgkQv2PBvD+k\nNUB57Q//Q2W2yMZcThGpEvOZ24Xe/PmpZvp6l6UDCqEAiElOrwzvqkw4/f2daHz8\nyu/NXmEgvQy3b6Yrb/S+aJcJBZXa+R10RE5+UtjyVpNGs4Yo81vmzPvcbtHGS3mj\nrtNDe0YZTZ0+ITAGoNPOIE/km4NNGDReTe54frKvWxVb6xDM0VgTxX9AaI+tpr0R\nTr2WWKq+4FHiBzfIY1fS47DuBJvif8Z5pMo4jMPwQzCkkzsRNsc1jgOKXu5Flb5f\nwU68/m48L2q0aOmseGY8VzK3hozljVRY4g8iH+pkfDpjrnMWDesIb06+8mw3lqOx\nWL4ey2YEhHYeVGkiDF5A33YueJUh1GGi+wPHl8VewmONZFaT3/AfhRDV8LVm5TUd\niKZJa29d2Ya5AfQR2leckkp3719axEx7ZE43MJxvh0+mgmN7Ftdd1TMLQoChk7n1\nDd8Ooo6GE+LjWbRtjoNCWWoi25liefIaa0lgGASNvfiGAgR7qv1alDpJT7Atf0Xl\nApXYq8EP3DEUKPHTLjaNSkvYugNiqmvz7wuQitiH6v/WOYr0hZf7E0NG5d9xzj5T\nut9BC9QKQxFutZZiuLPswSLUB8dTh3UI1tp/zFic1Ew1LFRD9vDpaZkAqPV/aFij\nuELoa/6GTFCdisSXM09uP/4dc30fjRhDwzvao9VZXI4rAb9v+4o=\n=9RbB\n-----END PGP SIGNATURE-----", "payload": "tree 24c24f86607906614b589d165184f149626eba59\nparent 554bb9b61e2b76d4ace16a3f766b98ea887b17f4\nauthor Martin Jambor <mjambor@suse.cz> 1673356702 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1673356830 +0100\n\nipa: Sort ipa_param_body_adjustments::m_replacements (PR 108110)\n\nThe problem in PR 108110 is that elements describing the same base\nparameter in ipa_param_body_adjustments::m_replacements are not\nadjacent to each other, which is something that\nipa_param_body_adjustments::modify_call_stmt when it gathers all\nreplacements for a parameter.\n\nOne option would be to simply always keep looking until the end of the\nvector (see bugzilla comment 15 for a one-line fix) but the correct\nthing to do is to keep the elements of the vector sorted and thus make\nsuch elements adjacent again.  This patch does that and then also\nmodifies the look-ups to take advantage of it.\n\nSince the one user of ipa_param_body_adjustments that is not\ntree-inline.cc, which is OpenMP declare SIMD cloning code, also\nregisters its own replacements and in theory pointers to elements of\nthe m_replacements vector can leak through public method\nget_expr_replacement, I decided that in those cases it is the\nresponsibility of the user of the class to call the sorting method\nbetween the replacement registrations and the first lookup.  That is\nwhy the patch also adds a line to omp-simd-clone.cc.\n\ngcc/ChangeLog:\n\n2023-01-09  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/108110\n\t* ipa-param-manipulation.h (ipa_param_body_adjustments): New members\n\tsort_replacements, lookup_first_base_replacement and\n\tm_sorted_replacements_p.\n\t* ipa-param-manipulation.cc: Define INCLUDE_ALGORITHM.\n\t(ipa_param_body_adjustments::register_replacement): Set\n\tm_sorted_replacements_p to false.\n\t(compare_param_body_replacement): New function.\n\t(ipa_param_body_adjustments::sort_replacements): Likewise.\n\t(ipa_param_body_adjustments::common_initialization): Call\n\tsort_replacements.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Initialize\n\tm_sorted_replacements_p.\n\t(ipa_param_body_adjustments::lookup_replacement_1): Rework to use\n\tstd::lower_bound.\n\t(ipa_param_body_adjustments::lookup_first_base_replacement): New\n\tfunction.\n\t(ipa_param_body_adjustments::modify_call_stmt): Use\n\tlookup_first_base_replacement.\n\t* omp-simd-clone.cc (ipa_simd_modify_function_body): Call\n\tadjustments->sort_replacements.\n\ngcc/testsuite/ChangeLog:\n\n2023-01-04  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/108110\n\t* g++.dg/ipa/pr108110.C: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c389991432da2bcc335a2b4fb7e502d28a6b3346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c389991432da2bcc335a2b4fb7e502d28a6b3346", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c389991432da2bcc335a2b4fb7e502d28a6b3346/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "554bb9b61e2b76d4ace16a3f766b98ea887b17f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554bb9b61e2b76d4ace16a3f766b98ea887b17f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554bb9b61e2b76d4ace16a3f766b98ea887b17f4"}], "stats": {"total": 154, "additions": 128, "deletions": 26}, "files": [{"sha": "1de9ca2ceb8e8fbce00aee6a2b7d128ecd9abb4b", "filename": "gcc/ipa-param-manipulation.cc", "status": "modified", "additions": 86, "deletions": 26, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Fipa-param-manipulation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Fipa-param-manipulation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.cc?ref=c389991432da2bcc335a2b4fb7e502d28a6b3346", "patch": "@@ -18,6 +18,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_ALGORITHM\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -1000,6 +1001,7 @@ ipa_param_body_adjustments::register_replacement (tree base,\n   psr.dummy = NULL_TREE;\n   psr.unit_offset = unit_offset;\n   m_replacements.safe_push (psr);\n+  m_sorted_replacements_p = false;\n }\n \n /* Register that REPLACEMENT should replace parameter described in APM.  */\n@@ -1015,6 +1017,37 @@ ipa_param_body_adjustments::register_replacement (ipa_adjusted_param *apm,\n \t\t\treplacement);\n }\n \n+/* Comparator for sorting and searching\n+   ipa_param_body_adjustments::m_replacements.  */\n+\n+static int\n+compare_param_body_replacement (const void *va, const void *vb)\n+{\n+  const ipa_param_body_replacement *a = (const ipa_param_body_replacement *) va;\n+  const ipa_param_body_replacement *b = (const ipa_param_body_replacement *) vb;\n+\n+  if (DECL_UID (a->base) < DECL_UID (b->base))\n+    return -1;\n+  if (DECL_UID (a->base) > DECL_UID (b->base))\n+    return 1;\n+  if (a->unit_offset < b->unit_offset)\n+    return -1;\n+  if (a->unit_offset > b->unit_offset)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Sort m_replacements and set m_sorted_replacements_p to true.  */\n+\n+void\n+ipa_param_body_adjustments::sort_replacements ()\n+{\n+  if (m_sorted_replacements_p)\n+    return;\n+  m_replacements.qsort (compare_param_body_replacement);\n+  m_sorted_replacements_p = true;\n+}\n+\n /* Copy or not, as appropriate given m_id and decl context, a pre-existing\n    PARM_DECL T so that it can be included in the parameters of the modified\n    function.  */\n@@ -1426,6 +1459,7 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t    }\n \t}\n     }\n+  sort_replacements ();\n \n   if (tree_map)\n     {\n@@ -1503,7 +1537,7 @@ ::ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n     m_dead_stmt_debug_equiv (), m_fndecl (fndecl), m_id (NULL), m_oparms (),\n     m_new_decls (), m_new_types (), m_replacements (),\n     m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n-    m_method2func (false)\n+    m_method2func (false), m_sorted_replacements_p (true)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1521,7 +1555,7 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n     m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n     m_id (NULL), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n     m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n-    m_method2func (false)\n+    m_method2func (false), m_sorted_replacements_p (true)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1545,7 +1579,7 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n     m_dead_ssa_debug_equiv (), m_dead_stmt_debug_equiv (), m_fndecl (fndecl),\n     m_id (id), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n     m_split_agg_csts_inits (), m_removed_decls (), m_removed_map (),\n-    m_method2func (false)\n+    m_method2func (false), m_sorted_replacements_p (true)\n {\n   common_initialization (old_fndecl, vars, tree_map);\n }\n@@ -1616,16 +1650,49 @@ ipa_param_body_replacement *\n ipa_param_body_adjustments::lookup_replacement_1 (tree base,\n \t\t\t\t\t\t  unsigned unit_offset)\n {\n-  unsigned int len = m_replacements.length ();\n-  for (unsigned i = 0; i < len; i++)\n-    {\n-      ipa_param_body_replacement *pbr = &m_replacements[i];\n+  gcc_assert (m_sorted_replacements_p);\n+  ipa_param_body_replacement key;\n+  key.base = base;\n+  key.unit_offset = unit_offset;\n+  ipa_param_body_replacement *res\n+    = std::lower_bound (m_replacements.begin (), m_replacements.end (), key,\n+\t\t\t[] (const ipa_param_body_replacement &elt,\n+\t\t\t    const ipa_param_body_replacement &val)\n+\t\t\t{\n+\t\t\t  return (compare_param_body_replacement (&elt, &val)\n+\t\t\t\t  < 0);\n+\t\t\t});\n+\n+  if (res == m_replacements.end ()\n+      || res->base != base\n+      || res->unit_offset != unit_offset)\n+    return NULL;\n+  return res;\n+}\n \n-      if (pbr->base == base\n-\t  && (pbr->unit_offset == unit_offset))\n-\treturn pbr;\n-    }\n-  return NULL;\n+/* Find the first replacement for BASE among m_replacements and return pointer\n+   to it, or NULL if there is none.  */\n+\n+ipa_param_body_replacement *\n+ipa_param_body_adjustments::lookup_first_base_replacement (tree base)\n+{\n+  gcc_assert (m_sorted_replacements_p);\n+  ipa_param_body_replacement key;\n+  key.base = base;\n+  ipa_param_body_replacement *res\n+    = std::lower_bound (m_replacements.begin (), m_replacements.end (), key,\n+\t\t\t[] (const ipa_param_body_replacement &elt,\n+\t\t\t    const ipa_param_body_replacement &val)\n+\t\t\t{\n+\t\t\t  if (DECL_UID (elt.base) < DECL_UID (val.base))\n+\t\t\t    return true;\n+\t\t\t  return false;\n+\t\t\t});\n+\n+  if (res == m_replacements.end ()\n+      || res->base != base)\n+    return NULL;\n+  return res;\n }\n \n /* Given BASE and UNIT_OFFSET, find the corresponding replacement expression\n@@ -1997,6 +2064,7 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n   gcall *stmt = *stmt_p;\n   unsigned nargs = gimple_call_num_args (stmt);\n   bool recreate = false;\n+  gcc_assert (m_sorted_replacements_p);\n \n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n@@ -2029,19 +2097,11 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n       if (TREE_CODE (base) != PARM_DECL)\n \tcontinue;\n \n-      bool base_among_replacements = false;\n-      unsigned j, repl_list_len = m_replacements.length ();\n-      for (j = 0; j < repl_list_len; j++)\n-\t{\n-\t  ipa_param_body_replacement *pbr = &m_replacements[j];\n-\t  if (pbr->base == base)\n-\t    {\n-\t      base_among_replacements = true;\n-\t      break;\n-\t    }\n-\t}\n-      if (!base_among_replacements)\n+      ipa_param_body_replacement *first_rep\n+\t= lookup_first_base_replacement (base);\n+      if (!first_rep)\n \tcontinue;\n+      unsigned first_rep_index = first_rep - m_replacements.begin ();\n \n       /* We still have to distinguish between an end-use that we have to\n \t transform now and a pass-through, which happens in the following\n@@ -2060,7 +2120,7 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n \t  recreate = true;\n \t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n \t  pass_through_args.safe_push (i);\n-\t  pass_through_pbr_indices.safe_push (j);\n+\t  pass_through_pbr_indices.safe_push (first_rep_index);\n \t  pass_through_offsets.safe_push (agg_arg_offset);\n \t}\n       else if (!by_ref && AGGREGATE_TYPE_P (TREE_TYPE (t)))\n@@ -2078,7 +2138,7 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n \t    {\n \t      recreate = true;\n \t      pass_through_args.safe_push (i);\n-\t      pass_through_pbr_indices.safe_push (j);\n+\t      pass_through_pbr_indices.safe_push (first_rep_index);\n \t      pass_through_offsets.safe_push (agg_arg_offset);\n \t    }\n \t}"}, {"sha": "9cc957ae7bb986ba6a215cb1a07c6e28b01ba951", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=c389991432da2bcc335a2b4fb7e502d28a6b3346", "patch": "@@ -318,6 +318,10 @@ class ipa_param_body_adjustments\n   void register_replacement (tree base, unsigned unit_offset, tree replacement);\n   /* Register a replacement decl for the transformation done in APM.  */\n   void register_replacement (ipa_adjusted_param *apm, tree replacement);\n+  /* Sort m_replacements and set m_sorted_replacements_p to true.  Users that\n+     call register_replacement themselves must call the method before any\n+     lookup and thus also any statement or expression modification.  */\n+  void sort_replacements ();\n   /* Lookup a replacement for a given offset within a given parameter.  */\n   tree lookup_replacement (tree base, unsigned unit_offset);\n   /* Lookup a replacement for an expression, if there is one.  */\n@@ -367,6 +371,7 @@ class ipa_param_body_adjustments\n   unsigned get_base_index (ipa_adjusted_param *apm);\n   ipa_param_body_replacement *lookup_replacement_1 (tree base,\n \t\t\t\t\t\t    unsigned unit_offset);\n+  ipa_param_body_replacement *lookup_first_base_replacement (tree base);\n   tree replace_removed_params_ssa_names (tree old_name, gimple *stmt);\n   bool modify_expression (tree *expr_p, bool convert);\n   bool modify_assignment (gimple *stmt, gimple_seq *extra_stmts);\n@@ -425,6 +430,10 @@ class ipa_param_body_adjustments\n      its this pointer and must be converted to a normal function.  */\n \n   bool m_method2func;\n+\n+  /* True if m_replacements have ben sorted since the last insertion.  */\n+\n+  bool m_sorted_replacements_p;\n };\n \n void push_function_arg_decls (vec<tree> *args, tree fndecl);"}, {"sha": "0949b8ba288dfc7e7692403bfc600983faddf5dd", "filename": "gcc/omp-simd-clone.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Fomp-simd-clone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Fomp-simd-clone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.cc?ref=c389991432da2bcc335a2b4fb7e502d28a6b3346", "patch": "@@ -1229,6 +1229,7 @@ ipa_simd_modify_function_body (struct cgraph_node *node,\n \tj += vector_unroll_factor (node->simdclone->simdlen,\n \t\t\t\t   simd_clone_subparts (vectype)) - 1;\n     }\n+  adjustments->sort_replacements ();\n \n   tree name;\n   FOR_EACH_SSA_NAME (i, name, cfun)"}, {"sha": "e9f3b5efc0410b091663c2c1215a44ed472be688", "filename": "gcc/testsuite/g++.dg/ipa/pr108110.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr108110.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c389991432da2bcc335a2b4fb7e502d28a6b3346/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr108110.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr108110.C?ref=c389991432da2bcc335a2b4fb7e502d28a6b3346", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+void __throw_out_of_range_fmt(...);\n+char *_M_p;\n+struct Trans_NS___cxx11_basic_string {\n+  long _M_string_length;\n+  long _M_check___pos;\n+  Trans_NS___cxx11_basic_string() {\n+    long __length = 0;\n+    _M_string_length = __length;\n+  }\n+  long size() { return _M_string_length; }\n+  long foo___pos;\n+  char foo() { return _M_p[foo___pos]; }\n+  int compare() { __throw_out_of_range_fmt(_M_check___pos, _M_string_length); __builtin_trap(); }\n+};\n+bool str_starts_with(Trans_NS___cxx11_basic_string &str,\n+                     Trans_NS___cxx11_basic_string prefix) {\n+  if (str.size() < prefix.size())\n+    str.compare();\n+  for (; prefix.size();) {\n+    char __trans_tmp_2 = prefix.foo();\n+    if (__trans_tmp_2)\n+      return false;\n+  }\n+  __builtin_trap();\n+}\n+void testStartsWith() {\n+  Trans_NS___cxx11_basic_string s1, s2;\n+  str_starts_with(s1, s2);\n+}"}]}