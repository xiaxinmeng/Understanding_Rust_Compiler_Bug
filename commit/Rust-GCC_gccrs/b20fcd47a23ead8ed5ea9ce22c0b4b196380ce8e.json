{"sha": "b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwZmNkNDdhMjNlYWQ4ZWQ1ZWE5Y2UyMmMwYjRiMTk2MzgwY2U4ZQ==", "commit": {"author": {"name": "Stephen Crawley", "email": "crawley@dstc.edu.au", "date": "2003-02-07T20:19:53Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-02-07T20:19:53Z"}, "message": "Stephen Crawley  <crawley@dstc.edu.au>\n\n       * java/beans/PropertyDescriptor.java\n       (PropertyDescriptor(String, Class)): Sanity check getter and setter\n       methods.\n       (PropertyDescriptor(String, Class, String, String)): Likewise.\n       (PropertyDescriptor(String, Method, Method): Factor out getter and\n       setter method sanity checks into new method.\n       (findMethods): Don't do parameter sanity checking of get method here.\n       (checkMethods): New method.\n\n2003-02-07  Stephen Crawley  <crawley@dstc.edu.au>\n\n       * java/beans/PropertyDescriptor.java: Reformat.\n\nFrom-SVN: r62537", "tree": {"sha": "5ba867c6dfed9c3a71e924ab93866436f2e9ea98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba867c6dfed9c3a71e924ab93866436f2e9ea98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e/comments", "author": null, "committer": null, "parents": [{"sha": "7bf0a5935361a7af3bf7823d6733c2f691a7529f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf0a5935361a7af3bf7823d6733c2f691a7529f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf0a5935361a7af3bf7823d6733c2f691a7529f"}], "stats": {"total": 581, "additions": 314, "deletions": 267}, "files": [{"sha": "32167d5425e17d85666814895799e385ac1d4eeb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e", "patch": "@@ -1,3 +1,18 @@\n+2003-02-07  Stephen Crawley  <crawley@dstc.edu.au>\n+\n+\t* java/beans/PropertyDescriptor.java\n+\t(PropertyDescriptor(String, Class)): Sanity check getter and setter\n+\tmethods.\n+\t(PropertyDescriptor(String, Class, String, String)): Likewise.\n+\t(PropertyDescriptor(String, Method, Method): Factor out getter and\n+\tsetter method sanity checks into new method.\n+\t(findMethods): Don't do parameter sanity checking of get method here.\n+\t(checkMethods): New method.\n+\n+2003-02-07  Stephen Crawley  <crawley@dstc.edu.au>\n+\n+\t* java/beans/PropertyDescriptor.java: Reformat.\n+\n 2003-02-04  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/PipedOutputStream.java (flush): Declare as throwing"}, {"sha": "00db4166ced79289bc713ec01f4e4b3a7e4b239e", "filename": "libjava/java/beans/PropertyDescriptor.java", "status": "modified", "additions": 299, "deletions": 267, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyDescriptor.java?ref=b20fcd47a23ead8ed5ea9ce22c0b4b196380ce8e", "patch": "@@ -65,280 +65,312 @@\n  **/\n \n public class PropertyDescriptor extends FeatureDescriptor {\n-\tClass propertyType;\n-\tMethod getMethod;\n-\tMethod setMethod;\n-\n-\tClass propertyEditorClass;\n-\tboolean bound;\n-\tboolean constrained;\n-\n-\tPropertyDescriptor(String name) {\n-\t\tsetName(name);\n-\t}\n-\n-\t/** Create a new PropertyDescriptor by introspection.\n-\t ** This form of constructor creates the PropertyDescriptor by\n-\t ** looking for a getter method named <CODE>get&lt;name&gt;()</CODE>\n-\t ** (or, optionally, if the property is boolean,\n-\t ** <CODE>is&lt;name&gt;()</CODE>) and\n-\t ** <CODE>set&lt;name&gt;()</CODE> in class\n-\t ** <CODE>&lt;beanClass&gt;</CODE>, where &lt;name&gt; has its\n-\t ** first letter capitalized by the constructor.<P>\n-\t **\n-\t ** <B>Implementation note:</B> If there is a get method (or\n-\t ** boolean isXXX() method), then the return type of that method\n-\t ** is used to find the set method.  If there is no get method,\n-\t ** then the set method is searched for exhaustively.<P>\n-\t **\n-\t ** <B>Spec note:</B>\n-\t ** If there is no get method and multiple set methods with\n-\t ** the same name and a single parameter (different type of course),\n-\t ** then an IntrospectionException is thrown.  While Sun's spec\n-\t ** does not state this, it can make Bean behavior different on\n-\t ** different systems (since method order is not guaranteed) and as\n-\t ** such, can be treated as a bug in the spec.  I am not aware of\n-\t ** whether Sun's implementation catches this.\n-\t **\n-\t ** @param name the programmatic name of the property, usually\n-\t **             starting with a lowercase letter (e.g. fooManChu\n-\t **             instead of FooManChu).\n-\t ** @param beanClass the class the get and set methods live in.\n-\t ** @exception IntrospectionException if the methods are not found or invalid.\n-\t **/\n-\tpublic PropertyDescriptor(String name, Class beanClass) throws IntrospectionException {\n-\t\tsetName(name);\n-\t\tString capitalized;\n-\t\ttry {\n-\t\t\tcapitalized = Character.toUpperCase(name.charAt(0)) + name.substring(1);\n-\t\t} catch(StringIndexOutOfBoundsException e) {\n-\t\t\tcapitalized = \"\";\n-\t\t}\n-\t\tfindMethods(beanClass, \"is\" + capitalized, \"get\" + capitalized, \"set\" + capitalized);\n-\t}\n-\n-\t/** Create a new PropertyDescriptor by introspection.\n-\t ** This form of constructor allows you to specify the\n-\t ** names of the get and set methods to search for.<P>\n-\t **\n-\t ** <B>Implementation note:</B> If there is a get method (or\n-\t ** boolean isXXX() method), then the return type of that method\n-\t ** is used to find the set method.  If there is no get method,\n-\t ** then the set method is searched for exhaustively.<P>\n-\t **\n-\t ** <B>Spec note:</B>\n-\t ** If there is no get method and multiple set methods with\n-\t ** the same name and a single parameter (different type of course),\n-\t ** then an IntrospectionException is thrown.  While Sun's spec\n-\t ** does not state this, it can make Bean behavior different on\n-\t ** different systems (since method order is not guaranteed) and as\n-\t ** such, can be treated as a bug in the spec.  I am not aware of\n-\t ** whether Sun's implementation catches this.\n-\t **\n-\t ** @param name the programmatic name of the property, usually\n-\t **             starting with a lowercase letter (e.g. fooManChu\n-\t **             instead of FooManChu).\n-\t ** @param beanClass the class the get and set methods live in.\n-\t ** @param getMethodName the name of the get method.\n-\t ** @param setMethodName the name of the set method.\n-\t ** @exception IntrospectionException if the methods are not found or invalid.\n-\t **/\n-\tpublic PropertyDescriptor(String name, Class beanClass, String getMethodName, String setMethodName) throws IntrospectionException {\n-\t\tsetName(name);\n-\t\tfindMethods(beanClass, getMethodName, null, setMethodName);\n-\t}\n-\n-\t/** Create a new PropertyDescriptor using explicit Methods.\n-\t ** Note that the methods will be checked for conformance to standard\n-\t ** Property method rules, as described above at the top of this class.\n-\t ** \n-\t ** @param name the programmatic name of the property, usually\n-\t **             starting with a lowercase letter (e.g. fooManChu\n-\t **             instead of FooManChu).\n-\t ** @param getMethod the get method.\n-\t ** @param setMethod the set method.\n-\t ** @exception IntrospectionException if the methods are not found or invalid.\n-\t **/\n-\tpublic PropertyDescriptor(String name, Method getMethod, Method setMethod) throws IntrospectionException {\n-\t\tsetName(name);\n-\t\tif(getMethod != null && getMethod.getParameterTypes().length > 0) {\n-\t\t\tthrow new IntrospectionException(\"get method has parameters\");\n-\t\t}\n-\t\tif(setMethod != null && setMethod.getParameterTypes().length != 1) {\n-\t\t\tthrow new IntrospectionException(\"set method does not have exactly one parameter\");\n-\t\t}\n-\t\tif(getMethod != null && setMethod != null) {\n-\t\t\tif(!getMethod.getReturnType().equals(setMethod.getParameterTypes()[0])) {\n-\t\t\t\tthrow new IntrospectionException(\"set and get methods do not share the same type\");\n-\t\t\t}\n-\t\t\tif(!getMethod.getDeclaringClass().isAssignableFrom(setMethod.getDeclaringClass())\n-\t\t\t   && !setMethod.getDeclaringClass().isAssignableFrom(getMethod.getDeclaringClass())) {\n-\t\t\t\tthrow new IntrospectionException(\"set and get methods are not in the same class.\");\n-\t\t\t}\n-\t\t}\n-\t\tthis.getMethod = getMethod;\n-\t\tthis.setMethod = setMethod;\n-\t\tif(getMethod != null) {\n-\t\t\tthis.propertyType = getMethod.getReturnType();\n-\t\t} else {\n-\t\t\tthis.propertyType = setMethod.getParameterTypes()[0];\n-\t\t}\n-\t}\n-\n-\t/** Get the property type.\n-\t ** This is the type the get method returns and the set method\n-\t ** takes in.\n-\t **/\n-\tpublic Class getPropertyType() {\n-\t\treturn propertyType;\n-\t}\n-\n-\t/** Get the get method.  Why they call it readMethod here and\n-\t ** get everywhere else is beyond me.\n-\t **/\n-\tpublic Method getReadMethod() {\n-\t\treturn getMethod;\n-\t}\n-\n-\t/** Get the set method.  Why they call it writeMethod here and\n-\t ** set everywhere else is beyond me.\n-\t **/\n-\tpublic Method getWriteMethod() {\n-\t\treturn setMethod;\n+  Class propertyType;\n+  Method getMethod;\n+  Method setMethod;\n+  \n+  Class propertyEditorClass;\n+  boolean bound;\n+  boolean constrained;\n+  \n+  PropertyDescriptor(String name) {\n+    setName(name);\n+  }\n+  \n+  /** Create a new PropertyDescriptor by introspection.\n+   ** This form of constructor creates the PropertyDescriptor by\n+   ** looking for a getter method named <CODE>get&lt;name&gt;()</CODE>\n+   ** (or, optionally, if the property is boolean,\n+   ** <CODE>is&lt;name&gt;()</CODE>) and\n+   ** <CODE>set&lt;name&gt;()</CODE> in class\n+   ** <CODE>&lt;beanClass&gt;</CODE>, where &lt;name&gt; has its\n+   ** first letter capitalized by the constructor.<P>\n+   **\n+   ** <B>Implementation note:</B> If there is both are both isXXX and\n+   ** getXXX methods, the former is used in preference to the latter.\n+   ** We do not check that an isXXX method returns a boolean. In both\n+   ** cases, this matches the behaviour of JDK 1.4<P>\n+   **\n+   ** @param name the programmatic name of the property, usually\n+   **             starting with a lowercase letter (e.g. fooManChu\n+   **             instead of FooManChu).\n+   ** @param beanClass the class the get and set methods live in.\n+   ** @exception IntrospectionException if the methods are not found \n+   **            or invalid.\n+   **/\n+  public PropertyDescriptor(String name, Class beanClass) \n+    throws IntrospectionException \n+  {\n+    setName(name);\n+    if (name.length() == 0) {\n+      throw new IntrospectionException(\"empty property name\");\n+    }\n+    String caps = Character.toUpperCase(name.charAt(0)) + name.substring(1);\n+    findMethods(beanClass, \"is\" + caps, \"get\" + caps, \"set\" + caps);\n+    if (getMethod == null) {\n+      throw new IntrospectionException(\"Cannot find an is\" + caps + \n+\t\t\t\t       \" or get\" + caps + \" method\");\n+    }\n+    if (setMethod == null) {\n+      throw new IntrospectionException(\"Cannot find a \" + caps + \" method\");\n+    }\n+    checkMethods();\n+  }\n+  \n+  /** Create a new PropertyDescriptor by introspection.\n+   ** This form of constructor allows you to specify the\n+   ** names of the get and set methods to search for.<P>\n+   **\n+   ** <B>Implementation note:</B> If there is a get method (or\n+   ** boolean isXXX() method), then the return type of that method\n+   ** is used to find the set method.  If there is no get method,\n+   ** then the set method is searched for exhaustively.<P>\n+   **\n+   ** <B>Spec note:</B>\n+   ** If there is no get method and multiple set methods with\n+   ** the same name and a single parameter (different type of course),\n+   ** then an IntrospectionException is thrown.  While Sun's spec\n+   ** does not state this, it can make Bean behavior different on\n+   ** different systems (since method order is not guaranteed) and as\n+   ** such, can be treated as a bug in the spec.  I am not aware of\n+   ** whether Sun's implementation catches this.\n+   **\n+   ** @param name the programmatic name of the property, usually\n+   **             starting with a lowercase letter (e.g. fooManChu\n+   **             instead of FooManChu).\n+   ** @param beanClass the class the get and set methods live in.\n+   ** @param getMethodName the name of the get method.\n+   ** @param setMethodName the name of the set method.\n+   ** @exception IntrospectionException if the methods are not found \n+   **            or invalid.\n+   **/\n+  public PropertyDescriptor(String name, Class beanClass, \n+\t\t\t    String getMethodName, String setMethodName) \n+    throws IntrospectionException \n+  {\n+    setName(name);\n+    findMethods(beanClass, getMethodName, null, setMethodName);\n+    if (getMethod == null && getMethodName != null) {\n+      throw new IntrospectionException(\"Cannot find a getter method called \" + \n+\t\t\t\t       getMethodName);\n+    }\n+    if (setMethod == null && setMethodName != null) {\n+      throw new IntrospectionException(\"Cannot find a setter method called \" + \n+\t\t\t\t       setMethodName);\n+    }\n+    checkMethods();\n+  }\n+  \n+  /** Create a new PropertyDescriptor using explicit Methods.\n+   ** Note that the methods will be checked for conformance to standard\n+   ** Property method rules, as described above at the top of this class.\n+   ** \n+   ** @param name the programmatic name of the property, usually\n+   **             starting with a lowercase letter (e.g. fooManChu\n+   **             instead of FooManChu).\n+   ** @param getMethod the get method.\n+   ** @param setMethod the set method.\n+   ** @exception IntrospectionException if the methods are not found \n+   **            or invalid.\n+   **/\n+  public PropertyDescriptor(String name, Method getMethod, Method setMethod)\n+    throws IntrospectionException \n+  {\n+    setName(name);\n+    this.getMethod = getMethod;\n+    this.setMethod = setMethod;\n+    if (getMethod != null) {\n+      this.propertyType = getMethod.getReturnType();\n+    } \n+    else if (setMethod != null) {\n+      this.propertyType = setMethod.getParameterTypes()[0];\n+    }\n+    checkMethods();\n+  }\n+  \n+  /** Get the property type.\n+   ** This is the type the get method returns and the set method\n+   ** takes in.\n+   **/\n+  public Class getPropertyType() {\n+    return propertyType;\n+  }\n+  \n+  /** Get the get method.  Why they call it readMethod here and\n+   ** get everywhere else is beyond me.\n+   **/\n+  public Method getReadMethod() {\n+    return getMethod;\n+  }\n+  \n+  /** Get the set method.  Why they call it writeMethod here and\n+   ** set everywhere else is beyond me.\n+   **/\n+  public Method getWriteMethod() {\n+    return setMethod;\n+  }\n+  \n+  /** Get whether the property is bound.  Defaults to false. **/\n+  public boolean isBound() {\n+    return bound;\n+  }\n+  \n+  /** Set whether the property is bound.\n+   ** As long as the the bean implements addPropertyChangeListener() and\n+   ** removePropertyChangeListener(), setBound(true) may safely be called.<P>\n+   ** If these things are not true, then the behavior of the system\n+   ** will be undefined.<P>\n+   **\n+   ** When a property is bound, its set method is required to fire the\n+   ** <CODE>PropertyChangeListener.propertyChange())</CODE> event\n+   ** after the value has changed.\n+   ** @param bound whether the property is bound or not.\n+   **/\n+  public void setBound(boolean bound) {\n+    this.bound = bound;\n+  }\n+  \n+  /** Get whether the property is constrained.  Defaults to false. **/\n+  public boolean isConstrained() {\n+    return constrained;\n+  }\n+  \n+  /** Set whether the property is constrained.\n+   ** If the set method throws <CODE>java.beans.PropertyVetoException</CODE>\n+   ** (or subclass thereof) and the bean implements addVetoableChangeListener()\n+   ** and removeVetoableChangeListener(), then setConstrained(true) may safely\n+   ** be called.  Otherwise, the system behavior is undefined.\n+   ** <B>Spec note:</B> given those strict parameters, it would be nice if it\n+   ** got set automatically by detection, but oh well.<P>\n+   ** When a property is constrained, its set method is required to:<P>\n+   ** <OL>\n+   ** <LI>Fire the <CODE>VetoableChangeListener.vetoableChange()</CODE>\n+   **     event notifying others of the change and allowing them a chance to\n+   **     say it is a bad thing.</LI>\n+   ** <LI>If any of the listeners throws a PropertyVetoException, then\n+   **     it must fire another vetoableChange() event notifying the others\n+   **     of a reversion to the old value (though, of course, the change\n+   **     was never made).  Then it rethrows the PropertyVetoException and\n+   **     exits.</LI>\n+   ** <LI>If all has gone well to this point, the value may be changed.</LI>\n+   ** </OL>\n+   ** @param constrained whether the property is constrained or not.\n+   **/\n+  public void setConstrained(boolean constrained) {\n+    this.constrained = constrained;\n+  }\n+  \n+  /** Get the PropertyEditor class.  Defaults to null. **/\n+  public Class getPropertyEditorClass() {\n+    return propertyEditorClass;\n+  }\n+  \n+  /** Set the PropertyEditor class.  If the class does not implement\n+   ** the PropertyEditor interface, you will likely get an exception\n+   ** late in the game.\n+   ** @param propertyEditorClass the PropertyEditor class for this \n+   **        class to use.\n+   **/\n+  public void setPropertyEditorClass(Class propertyEditorClass) {\n+    this.propertyEditorClass = propertyEditorClass;\n+  }\n+  \n+  private void findMethods(Class beanClass, String getMethodName1, \n+\t\t\t   String getMethodName2, String setMethodName) \n+    throws IntrospectionException \n+  {\n+    try {\n+      // Try the first get method name\n+      if (getMethodName1 != null) {\n+\ttry {\n+\t  getMethod = beanClass.getMethod(getMethodName1, new Class[0]);\n+\t} \n+\tcatch (NoSuchMethodException e) {\n \t}\n+      }\n \n-\t/** Get whether the property is bound.  Defaults to false. **/\n-\tpublic boolean isBound() {\n-\t\treturn bound;\n+      // Fall back to the second get method name\n+      if (getMethod == null && getMethodName2 != null) {\n+\ttry {\n+\t  getMethod = beanClass.getMethod(getMethodName2, new Class[0]);\n+\t} \n+\tcatch (NoSuchMethodException e) {\n \t}\n+      }\n \n-\t/** Set whether the property is bound.\n-\t ** As long as the the bean implements addPropertyChangeListener() and\n-\t ** removePropertyChangeListener(), setBound(true) may safely be called.<P>\n-\t ** If these things are not true, then the behavior of the system\n-\t ** will be undefined.<P>\n-\t **\n-\t ** When a property is bound, its set method is required to fire the\n-\t ** <CODE>PropertyChangeListener.propertyChange())</CODE> event\n-\t ** after the value has changed.\n-\t ** @param bound whether the property is bound or not.\n-\t **/\n-\tpublic void setBound(boolean bound) {\n-\t\tthis.bound = bound;\n+      // Try the set method name\n+      if (setMethodName != null) {\n+\tif (getMethod != null) {\n+\t  // If there is a get method, use its return type to help\n+\t  // select the corresponding set method.\n+\t  Class propertyType = getMethod.getReturnType();\n+\t  if (propertyType == Void.TYPE) {\n+\t    String msg = \"The property's read method has return type 'void'\";\n+\t    throw new IntrospectionException(msg);\n+\t  }\n+\t  \n+\t  Class[] setArgs = new Class[]{propertyType};\n+\t  try {\n+\t    setMethod = beanClass.getMethod(setMethodName, setArgs);\n+\t  } \n+\t  catch (NoSuchMethodException e) {\n+\t  }\n \t}\n-\n-\t/** Get whether the property is constrained.  Defaults to false. **/\n-\tpublic boolean isConstrained() {\n-\t\treturn constrained;\n-\t}\n-\n-\t/** Set whether the property is constrained.\n-\t ** If the set method throws <CODE>java.beans.PropertyVetoException</CODE>\n-\t ** (or subclass thereof) and the bean implements addVetoableChangeListener()\n-\t ** and removeVetoableChangeListener(), then setConstrained(true) may safely\n-\t ** be called.  Otherwise, the system behavior is undefined.\n-\t ** <B>Spec note:</B> given those strict parameters, it would be nice if it\n-\t ** got set automatically by detection, but oh well.<P>\n-\t ** When a property is constrained, its set method is required to:<P>\n-\t ** <OL>\n-\t ** <LI>Fire the <CODE>VetoableChangeListener.vetoableChange()</CODE>\n-\t **     event notifying others of the change and allowing them a chance to\n-\t **     say it is a bad thing.</LI>\n-\t ** <LI>If any of the listeners throws a PropertyVetoException, then\n-\t **     it must fire another vetoableChange() event notifying the others\n-\t **     of a reversion to the old value (though, of course, the change\n-\t **     was never made).  Then it rethrows the PropertyVetoException and\n-\t **     exits.</LI>\n-\t ** <LI>If all has gone well to this point, the value may be changed.</LI>\n-\t ** </OL>\n-\t ** @param constrained whether the property is constrained or not.\n-\t **/\n-\tpublic void setConstrained(boolean constrained) {\n-\t\tthis.constrained = constrained;\n+\telse if (getMethodName1 == null && getMethodName2 == null) {\n+\t  // If this is a write-only property, choose the first set method\n+\t  // with the required name, one parameter and return type 'void'\n+\t  Method[] methods = beanClass.getMethods();\n+\t  for (int i = 0; i < methods.length; i++) {\n+\t    if (methods[i].getName().equals(setMethodName) &&\n+\t\tmethods[i].getParameterTypes().length == 1 &&\n+\t\tmethods[i].getReturnType() == Void.TYPE) {\n+\t      setMethod = methods[i];\n+\t      break;\n+\t    }\n+\t  }\n \t}\n+      }\n+    } \n+    catch (SecurityException e) {\n+      // FIXME -- shouldn't we just allow SecurityException to propagate?\n+      String msg = \"SecurityException thrown on attempt to access methods.\";\n+      throw new IntrospectionException(msg);\n+    }\n+  }\n \n-\t/** Get the PropertyEditor class.  Defaults to null. **/\n-\tpublic Class getPropertyEditorClass() {\n-\t\treturn propertyEditorClass;\n+  private void checkMethods() \n+    throws IntrospectionException\n+  {\n+    if (getMethod != null) {\n+      if (getMethod.getParameterTypes().length > 0) {\n+\tthrow new IntrospectionException(\"get method has parameters\");\n+      }\n+      this.propertyType = getMethod.getReturnType();\n+      if (propertyType == Void.TYPE) {\n+\tthrow new IntrospectionException(\"get method has void return type\");\n+      }\n+    }\n+    if (setMethod != null) {\n+      if (setMethod.getParameterTypes().length != 1) {\n+\tString msg = \"set method does not have exactly one parameter\"; \n+\tthrow new IntrospectionException(msg);\n+      }\n+      if (getMethod == null) {\n+\tpropertyType = setMethod.getParameterTypes()[0];\n+      }\n+      else {\n+\tif (!propertyType.equals(setMethod.getParameterTypes()[0])) {\n+\t  String msg = \"set and get methods do not share the same type\";\n+\t  throw new IntrospectionException(msg);\n \t}\n-\n-\t/** Set the PropertyEditor class.  If the class does not implement\n-\t ** the PropertyEditor interface, you will likely get an exception\n-\t ** late in the game.\n-\t ** @param propertyEditorClass the PropertyEditor class for this class to use.\n-\t **/\n-\tpublic void setPropertyEditorClass(Class propertyEditorClass) {\n-\t\tthis.propertyEditorClass = propertyEditorClass;\n-\t}\n-\n-\tprivate void findMethods(Class beanClass, String getMethodName1, String getMethodName2, String setMethodName) throws IntrospectionException {\n-\t\ttry {\n-\t\t\tif(getMethodName1 != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tgetMethod = beanClass.getMethod(getMethodName1, new Class[0]);\n-\t\t\t\t} catch(NoSuchMethodException E) {\n-\t\t\t\t}\n-\t\t\t\tif(getMethodName2 != null) {\n-\t\t\t\t\tif(getMethod != null && !getMethod.getReturnType().equals(java.lang.Boolean.TYPE)) {\n-\t\t\t\t\t\t// If the is() method exists but isn't boolean, we'll just go on and look for\n-\t\t\t\t\t\t// an ordinary get() method.\n-\t\t\t\t\t\tgetMethod = null;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tMethod getMethod2;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetMethod2 = beanClass.getMethod(getMethodName2, new Class[0]);\n-\t\t\t\t\t} catch(NoSuchMethodException E) {\n-\t\t\t\t\t\tgetMethod2 = null;\n-\t\t\t\t\t}\n-\t\t\t\t\tif(getMethod2 != null) {\n-\t\t\t\t\t\tif(getMethod != null) {\n-\t\t\t\t\t\t\tif(!getMethod.getReturnType().equals(getMethod2.getReturnType())) {\n-\t\t\t\t\t\t\t\tthrow new IntrospectionException(\"Both \" + getMethodName1 + \" and \" + getMethodName2 + \" exist, and have contradictory return types.\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tgetMethod = getMethod2;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif(getMethod != null) {\n-\t\t\t\tpropertyType = getMethod.getReturnType();\n-\t\t\t\tif(setMethodName != null) {\n-\t\t\t\t\tClass[] setArgs = new Class[1];\n-\t\t\t\t\tsetArgs[0] = propertyType;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tsetMethod = beanClass.getMethod(setMethodName, setArgs);\n-\t\t\t\t\t\tif(!setMethod.getReturnType().equals(java.lang.Void.TYPE)) {\n-\t\t\t\t\t\t\tthrow new IntrospectionException(setMethodName + \" has non-void return type\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch(NoSuchMethodException E) {\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else if(setMethodName != null) {\n-\t\t\t\tMethod[] m = beanClass.getMethods();\n-\t\t\t\tfor(int i=0;i<m.length;i++) {\n-\t\t\t\t\tMethod current = m[i];\n-\t\t\t\t\tif(current.getName().equals(setMethodName)\n-\t\t\t\t\t   && current.getParameterTypes().length == 1\n-\t\t\t\t\t   && current.getReturnType().equals(java.lang.Void.TYPE)) {\n-\t\t\t\t\t\tif(setMethod != null) {\n-\t\t\t\t\t\t\tthrow new IntrospectionException(\"Multiple, different set methods found that fit the bill!\");\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tsetMethod = current;\n-\t\t\t\t\t\t\tpropertyType = current.getParameterTypes()[0];\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(setMethod == null) {\n-\t\t\t\t\tthrow new IntrospectionException(\"Cannot find get or set methods.\");\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tthrow new IntrospectionException(\"Cannot find get or set methods.\");\n-\t\t\t}\n-\t\t} catch(SecurityException E) {\n-\t\t\tthrow new IntrospectionException(\"SecurityException thrown on attempt to access methods.\");\n-\t\t}\n+\tif ((!getMethod.getDeclaringClass().\n+\t     isAssignableFrom(setMethod.getDeclaringClass())) &&\n+\t    (!setMethod.getDeclaringClass().\n+\t     isAssignableFrom(getMethod.getDeclaringClass()))) {\n+\t  String msg = \"set and get methods are not in the same class.\";\n+\t  throw new IntrospectionException(msg);\n \t}\n+      }\n+    }\n+  }\n }"}]}