{"sha": "81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE0MDhkNDkyOGZlNDA1YjI3YzViMWNmZTBiM2Q2NWFlNGEzNTUyMw==", "commit": {"author": {"name": "Doug Rupp", "email": "rupp@adacore.com", "date": "2005-12-09T17:10:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:10:03Z"}, "message": "mlib-tgt-vms-ia64.adb, [...] (Is_Interface): Change Ada bind file prefix on VMS from b$ to b__.\n\n2005-12-05  Doug Rupp  <rupp@adacore.com>\n\n\t* mlib-tgt-vms-ia64.adb, mlib-tgt-vms-alpha.adb (Is_Interface): Change\n\tAda bind file prefix on VMS from b$ to b__.\n\t(Build_Dynamic_Library): Change Init file suffix on VMS from $init to\n\t__init.\n\n\t* prj-nmsc.adb: Change some Hostparm.OpenVMS checks to\n\tTargparm.OpenVMS_On_Target.\n\t(Object_Suffix): Initialize with target object suffix.\n\t(Get_Unit): Change Ada bind file prefix on VMS from b$ to b__.\n\n\t* butil.adb: Change some Hostparm.OpenVMS checks to\n\tTargparm.OpenVMS_On_Target.\n\n\t* clean.adb: Change some Hostparm.OpenVMS checks to\n\tTargparm.OpenVMS_On_Target.\n\t(Object_Suffix): Initialize with call to Get_Target_Object_Suffix.\n\t({declaraction},Delete_Binder_Generated_Files,{initialization}): Change\n\tAda bind file prefix on VMS from b$ to b__.\n\n\t* gnatlink.adb (Process_Args): Call Add_Src_Search_Dir for -I in\n\t--GCC so that Get_Target_Parameters can find system.ads.\n\t(Gnatlink): Call Get_Target_Parameters in mainline.\n\tInitialize standard packages for Targparm.\n\tChange some Hostparm.OpenVMS checks to Targparm.OpenVMS_On_Target.\n\t(Process_Args): Also Check for object files with target object\n\textension.\n\t(Make_Binder_File_Names): Create with target object extension.\n\t(Make_Binder_File_Names): Change Ada bind file prefix on VMS from b$\n\tto b__.\n\n\t* mlib-prj.adb: Change some Hostparm.OpenVMS checks to\n\tTargparm.OpenVMS_On_Target.\n\t({declaration},Build_Library,Check_Library): Change Ada bind file\n\tprefix on VMS from b$ to b__.\n\n\t* osint-b.adb: Change some Hostparm.OpenVMS checks to\n\tTargparm.OpenVMS_On_Target.\n\t(Create_Binder_Output): Change Ada bind file prefix on VMS from b$ to\n\tb__.\n\n\t* targext.c: New file.\n\n\t* Makefile.in: add support for vxworks653 builds\n\t(../../vxaddr2line): gnatlink with targext.o.\n\t(TOOLS_LIBS): Move targext.o to precede libgnat.\n\t(init.o, initialize.o): Minor clean up in dependencies.\n\t(GNATLINK_OBJS): Add targparm.o, snames.o\n\tAdd rules fo building targext.o and linking it explicitly with all\n\ttools.\n\tAlso add targext.o to gnatlib.\n\n\t* Make-lang.in: Add rules for building targext.o and linking it in\n\twith gnat1 and gnatbind.\n\tAdd entry for exp_sel.o.\n\n\t* osint.adb Change some Hostparm.OpenVMS checks to\n\tTargparm.OpenVMS_On_Target.\n\t(Object_File_Name): Use target object suffix.\n\n\t* osint.ads (Object_Suffix): Remove, no longer used.\n\t(Target_Object_Suffix): Initialize with target object suffix.\n\n\t* rident.ads: Add special exception to license.\n\n\t* targparm.adb (Get_Target_Parameters): Set the value of\n\tMulti_Unit_Index_Character after OpenVMS_On_Target gets its definitive\n\tvalue.\n\t(Get_Target_Parameters): Set OpenVMS_On_Target if openvms.\n\t\n\t* targparm.ads: Add special exception to license.\n\n\t* g-os_lib.ads, g-os_lib.adb (Get_Target_Debuggable_Suffix): New\n\tfunction.\n\t(Copy_File): Make sure from file is closed if error on to file\n\t(Get_Target_Executable_Suffix, Get_Target_Object_Suffix): New functions.\n\n\t* make.adb (Object_Suffix): Intialize with Get_Target_Object_Suffix.\n\t(Executable_Suffix): Intialize with Get_Target_Executable_Suffix.\n\n\t* osint-c.adb (Set_Output_Object_File_Name): Initialize extension with\n\ttarget object suffix.\n\nFrom-SVN: r108282", "tree": {"sha": "8d0ebcc73d5b00e238ee100be97600475908b083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d0ebcc73d5b00e238ee100be97600475908b083"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/comments", "author": {"login": "Cementitious", "id": 115579865, "node_id": "U_kgDOBuOb2Q", "avatar_url": "https://avatars.githubusercontent.com/u/115579865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cementitious", "html_url": "https://github.com/Cementitious", "followers_url": "https://api.github.com/users/Cementitious/followers", "following_url": "https://api.github.com/users/Cementitious/following{/other_user}", "gists_url": "https://api.github.com/users/Cementitious/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cementitious/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cementitious/subscriptions", "organizations_url": "https://api.github.com/users/Cementitious/orgs", "repos_url": "https://api.github.com/users/Cementitious/repos", "events_url": "https://api.github.com/users/Cementitious/events{/privacy}", "received_events_url": "https://api.github.com/users/Cementitious/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d0aa6abaf82678d69c0b3876c3d2752edd1a0cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d0aa6abaf82678d69c0b3876c3d2752edd1a0cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d0aa6abaf82678d69c0b3876c3d2752edd1a0cd"}], "stats": {"total": 27382, "additions": 27105, "deletions": 277}, "files": [{"sha": "def747deebdee083afab9159251bacf84c9c0d0a", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -1,5 +1,5 @@\n # Makefile.rtl for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+#   Copyright (C) 2003-2005, Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -35,6 +35,7 @@ GNATRTL_TASKING_OBJS= \\\n   a-sytaco$(objext) \\\n   a-tasatt$(objext) \\\n   a-taside$(objext) \\\n+  a-taster$(objext) \\\n   g-boubuf$(objext) \\\n   g-boumai$(objext) \\\n   g-semaph$(objext) \\\n@@ -279,6 +280,13 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-zzunio$(objext) \\\n   ada$(objext) \\\n   calendar$(objext) \\\n+  g-allein$(objext) \\\n+  g-alleve$(objext) \\\n+  g-altcon$(objext) \\\n+  g-altive$(objext) \\\n+  g-alveop$(objext) \\\n+  g-alvety$(objext) \\\n+  g-alvevi$(objext) \\\n   g-arrspl$(objext) \\\n   g-awk$(objext) \\\n   g-bubsor$(objext) \\\n@@ -497,6 +505,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-sopco4$(objext) \\\n   s-sopco5$(objext) \\\n   s-stache$(objext) \\\n+  s-stausa$(objext) \\\n   s-stchop$(objext) \\\n   s-stalib$(objext) \\\n   s-stoele$(objext) \\"}, {"sha": "135daf50f7f2d3d9c83f9cacfe5c2f13d8bc669f", "filename": "gcc/ada/a-elchha.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-elchha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-elchha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-elchha.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -38,6 +38,11 @@\n --  Default version for most targets\n \n with System.Standard_Library; use System.Standard_Library;\n+--  Used for Adafinal\n+\n+with System.Soft_Links;\n+--  Used for Task_Termination_Handler\n+--           Task_Termination_NT\n \n procedure Ada.Exceptions.Last_Chance_Handler\n   (Except : Exception_Occurrence)\n@@ -72,6 +77,14 @@ is\n    --  Convenient shortcut\n \n begin\n+   --  Do not execute any task termination code when shutting down the system.\n+   --  The Adafinal procedure would execute the task termination routine for\n+   --  normal termination, but we have already executed the task termination\n+   --  procedure because of an unhandled exception.\n+\n+   System.Soft_Links.Task_Termination_Handler :=\n+     System.Soft_Links.Task_Termination_NT'Access;\n+\n    --  Let's shutdown the runtime now. The rest of the procedure needs to be\n    --  careful not to use anything that would require runtime support. In\n    --  particular, functions returning strings are banned since the sec stack"}, {"sha": "bb7e5ad616c8f20606cf310f3bc7834d60ff2dfa", "filename": "gcc/ada/a-exextr.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-exextr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-exextr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exextr.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -88,7 +88,7 @@ package body Exception_Traces is\n    --  Hook for GDB to support \"break exception unhandled\"\n \n    --  For \"break exception\", GDB uses __gnat_raise_nodefer_with_msg, which\n-   --  is not in this section because it fullfills other purposes than a mere\n+   --  is not in this section because it functions as more than simply a\n    --  debugger interface.\n \n    --------------------------------\n@@ -161,8 +161,18 @@ package body Exception_Traces is\n    --------------------------------\n \n    procedure Notify_Unhandled_Exception is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n    begin\n-      Notify_Exception (Get_Current_Excep.all, Is_Unhandled => True);\n+      --  Check whether there is any termination handler to be executed for\n+      --  the environment task, and execute it if needed. Here we handle both\n+      --  the Abnormal and Unhandled_Exception task termination. Normal\n+      --  task termination routine is executed elsewhere (either in the\n+      --  Task_Wrapper or in the Adafinal routine for the environment task).\n+\n+      Task_Termination_Handler.all (Excep.all);\n+\n+      Notify_Exception (Excep, Is_Unhandled => True);\n       Unhandled_Exception;\n    end Notify_Unhandled_Exception;\n "}, {"sha": "8599af7fbe39cd89de27c9375559d0ed6731a776", "filename": "gcc/ada/a-taside.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-taside.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-taside.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taside.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -44,7 +44,8 @@ pragma Warnings (Off);\n --  package will be categorized as Preelaborate. See AI-362 for details.\n --  It is safe in the context of the run-time to violate the rules!\n \n-with System.Tasking.Stages;\n+with System.Tasking.Utilities;\n+--  Used for Abort_Tasks\n \n pragma Warnings (On);\n \n@@ -81,7 +82,7 @@ package body Ada.Task_Identification is\n       if T = Null_Task_Id then\n          raise Program_Error;\n       else\n-         System.Tasking.Stages.Abort_Tasks\n+         System.Tasking.Utilities.Abort_Tasks\n            (System.Tasking.Task_List'(1 => Convert_Ids (T)));\n       end if;\n    end Abort_Task;"}, {"sha": "93374b269a37199c3fda575f2b436615663917b9", "filename": "gcc/ada/a-taster.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-taster.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-taster.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taster.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . T A S K _ T E R M I N A T I O N                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Tasking;\n+--  used for Task_Id\n+\n+with System.Task_Primitives.Operations;\n+--  used for Self\n+\n+with Unchecked_Conversion;\n+\n+package body Ada.Task_Termination is\n+\n+   use type Ada.Task_Identification.Task_Id;\n+\n+   package STPO renames System.Task_Primitives.Operations;\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function To_TT is new Unchecked_Conversion\n+     (System.Tasking.Termination_Handler, Termination_Handler);\n+\n+   function To_ST is new Unchecked_Conversion\n+     (Termination_Handler, System.Tasking.Termination_Handler);\n+\n+   function To_Task_Id is new Unchecked_Conversion\n+     (Ada.Task_Identification.Task_Id, System.Tasking.Task_Id);\n+\n+   -----------------------------------\n+   -- Current_Task_Fallback_Handler --\n+   -----------------------------------\n+\n+   function Current_Task_Fallback_Handler return Termination_Handler is\n+   begin\n+      return To_TT (System.Tasking.Self.Common.Fall_Back_Handler);\n+   end Current_Task_Fallback_Handler;\n+\n+   -------------------------------------\n+   -- Set_Dependents_Fallback_Handler --\n+   -------------------------------------\n+\n+   procedure Set_Dependents_Fallback_Handler\n+     (Handler : Termination_Handler)\n+   is\n+   begin\n+      STPO.Self.Common.Fall_Back_Handler := To_ST (Handler);\n+   end Set_Dependents_Fallback_Handler;\n+\n+   --------------------------\n+   -- Set_Specific_Handler --\n+   --------------------------\n+\n+   procedure Set_Specific_Handler\n+     (T       : Ada.Task_Identification.Task_Id;\n+      Handler : Termination_Handler)\n+   is\n+   begin\n+      --  Tasking_Error is raised if the task identified by T has already\n+      --  terminated. Program_Error is raised if the value of T is\n+      --  Null_Task_Id.\n+\n+      if T = Ada.Task_Identification.Null_Task_Id then\n+         raise Program_Error;\n+      elsif Ada.Task_Identification.Is_Terminated (T) then\n+         raise Tasking_Error;\n+      else\n+         To_Task_Id (T).Common.Specific_Handler := To_ST (Handler);\n+      end if;\n+   end Set_Specific_Handler;\n+\n+   ----------------------\n+   -- Specific_Handler --\n+   ----------------------\n+\n+   function Specific_Handler\n+     (T : Ada.Task_Identification.Task_Id) return Termination_Handler\n+   is\n+   begin\n+      --  Tasking_Error is raised if the task identified by T has already\n+      --  terminated. Program_Error is raised if the value of T is\n+      --  Null_Task_Id.\n+\n+      if T = Ada.Task_Identification.Null_Task_Id then\n+         raise Program_Error;\n+      elsif Ada.Task_Identification.Is_Terminated (T) then\n+         raise Tasking_Error;\n+      else\n+         return To_TT (To_Task_Id (T).Common.Specific_Handler);\n+      end if;\n+   end Specific_Handler;\n+\n+end Ada.Task_Termination;"}, {"sha": "5a496a83e5bb0351f2296b892355dd7e7cc28f87", "filename": "gcc/ada/a-taster.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-taster.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fa-taster.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taster.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,43 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . T A S K _ T E R M I N A T I O N                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Task_Identification;\n+with Ada.Exceptions;\n+\n+package Ada.Task_Termination is\n+   pragma Preelaborate (Task_Termination);\n+\n+   type Cause_Of_Termination is (Normal, Abnormal, Unhandled_Exception);\n+\n+   type Termination_Handler is access protected procedure\n+     (Cause : Cause_Of_Termination;\n+      T     : Ada.Task_Identification.Task_Id;\n+      X     : Ada.Exceptions.Exception_Occurrence);\n+\n+   procedure Set_Dependents_Fallback_Handler\n+     (Handler : Termination_Handler);\n+   function Current_Task_Fallback_Handler return Termination_Handler;\n+\n+   procedure Set_Specific_Handler\n+     (T       : Ada.Task_Identification.Task_Id;\n+      Handler : Termination_Handler);\n+   function Specific_Handler\n+     (T : Ada.Task_Identification.Task_Id) return Termination_Handler;\n+\n+end Ada.Task_Termination;"}, {"sha": "b64798f486af8d61405add4caf9d97310c8a2302", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -1268,6 +1268,22 @@ package body Bindgen is\n          WBI (\"      pragma Import (C, finalize, \"\"__gnat_finalize\"\");\");\n       end if;\n \n+      --  If we want to analyze the stack, we have to import corresponding\n+      --  symbols\n+\n+      if Dynamic_Stack_Measurement then\n+         WBI (\"\");\n+         WBI (\"      procedure Output_Results;\");\n+         WBI (\"      pragma Import (C, Output_Results, \" &\n+              \"\"\"__gnat_stack_usage_output_results\"\");\");\n+\n+         WBI (\"\");\n+         WBI (\"      \" &\n+              \"procedure Initialize_Stack_Analysis (Buffer_Size : Natural);\");\n+         WBI (\"      pragma Import (C, Initialize_Stack_Analysis, \" &\n+              \"\"\"__gnat_stack_usage_initialize\"\");\");\n+      end if;\n+\n       --  Deal with declarations for main program case\n \n       if not No_Main_Subprogram then\n@@ -1360,6 +1376,13 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n+      if Dynamic_Stack_Measurement then\n+         Set_String (\"      Initialize_Stack_Analysis (\");\n+         Set_Int (Dynamic_Stack_Measurement_Array_Size);\n+         Set_String (\");\");\n+         Write_Statement_Buffer;\n+      end if;\n+\n       if not Cumulative_Restrictions.Set (No_Finalization) then\n \n          if not No_Main_Subprogram\n@@ -1398,6 +1421,12 @@ package body Bindgen is\n          end if;\n       end if;\n \n+      --  Prints the result of static stack analysis\n+\n+      if Dynamic_Stack_Measurement then\n+         WBI (\"      Output_Results;\");\n+      end if;\n+\n       --  Finalize is only called if we have a run time\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n@@ -1506,6 +1535,15 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n+      --  Initializes dynamic stack measurement if needed\n+\n+      if Dynamic_Stack_Measurement then\n+         Set_String (\"   __gnat_stack_usage_initialize (\");\n+         Set_Int (Dynamic_Stack_Measurement_Array_Size);\n+         Set_String (\");\");\n+         Write_Statement_Buffer;\n+      end if;\n+\n       --  The __gnat_initialize routine is used only if we have a run-time\n \n       if not Suppress_Standard_Library_On_Target then\n@@ -1552,6 +1590,12 @@ package body Bindgen is\n          WBI (\"   system__standard_library__adafinal ();\");\n       end if;\n \n+      --  Outputs the dynamic stack measurement if needed\n+\n+      if Dynamic_Stack_Measurement then\n+         WBI (\"   __gnat_stack_usage_output_results ();\");\n+      end if;\n+\n       --  The finalize routine is used only if we have a run-time\n \n       if not Suppress_Standard_Library_On_Target then\n@@ -1681,7 +1725,7 @@ package body Bindgen is\n                --  filename object is seen. Multiply defined symbols will\n                --  result.\n \n-               if Hostparm.OpenVMS\n+               if OpenVMS_On_Target\n                  and then Is_Internal_File_Name\n                   (ALIs.Table\n                    (Units.Table (Elab_Order.Table (E)).My_ALI).Sfile)\n@@ -2244,6 +2288,12 @@ package body Bindgen is\n          WBI (\"extern void __gnat_install_handler (void);\");\n       end if;\n \n+      if Dynamic_Stack_Measurement then\n+         WBI (\"\");\n+         WBI (\"extern void __gnat_stack_usage_output_results (void);\");\n+         WBI (\"extern void __gnat_stack_usage_initialize (int size);\");\n+      end if;\n+\n       WBI (\"\");\n \n       Gen_Elab_Defs_C;\n@@ -2780,7 +2830,7 @@ package body Bindgen is\n             With_GNARL := True;\n          end if;\n \n-         if Hostparm.OpenVMS and then Name_Buffer (1 .. 5) = \"dec%s\" then\n+         if OpenVMS_On_Target and then Name_Buffer (1 .. 5) = \"dec%s\" then\n             With_DECGNAT := True;\n          end if;\n       end loop;"}, {"sha": "046b6aa142bd83be5c206c479f7489e8f05c6ca6", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -214,6 +214,12 @@ begin\n    Write_Str (\"  -Tn       Set time slice value to n milliseconds (n >= 0)\");\n    Write_Eol;\n \n+   --  Line for -u switch\n+\n+   Write_Str (\"  -un       Enable dynamic stack analysis, with n results \");\n+   Write_Str (\"stored\");\n+   Write_Eol;\n+\n    --  Line for -v switch\n \n    Write_Str (\"  -v        Verbose mode. Error messages, \");"}, {"sha": "6721fedd58b74ae1faede95b3373935106bc29c9", "filename": "gcc/ada/g-allein.ads", "status": "added", "additions": 1356, "deletions": 0, "changes": 1356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-allein.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-allein.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-allein.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,1356 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     G N A T . A L T I V E C . L O W _ L E V E L _ I N T E R F A C E      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit provides entities to be used internally by the units common to\n+--  both bindings (Hard or Soft), and relevant to the interfacing with the\n+--  underlying Low Level support.\n+\n+--  The set of \"services\" includes:\n+--\n+--  o Imports to the low level routines for which a direct binding is\n+--    mandatory (or just possible when analyzed as such).\n+--\n+--  o Conversion routines (unchecked) between low level types, or between\n+--    various pointer representations.\n+\n+with GNAT.Altivec.Vector_Types;\n+with GNAT.Altivec.Low_Level_Vectors;\n+\n+with Ada.Unchecked_Conversion;\n+\n+package GNAT.Altivec.Low_Level_Interface is\n+\n+   ----------------------------------------------------------------------------\n+   -- Imports for \"argument must be literal\" constraints in the Hard binding --\n+   ----------------------------------------------------------------------------\n+\n+   use GNAT.Altivec.Vector_Types;\n+\n+   -- vec_ctf --\n+\n+   function vec_ctf_vui_cint_r_vf\n+     (A : vector_unsigned_int;\n+      B : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_ctf_vui_cint_r_vf, \"__builtin_altivec_vcfux\");\n+\n+   function vec_ctf_vsi_cint_r_vf\n+     (A : vector_signed_int;\n+      B : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_ctf_vsi_cint_r_vf, \"__builtin_altivec_vcfsx\");\n+\n+   -- vec_vcfsx --\n+\n+   function vec_vcfsx_vsi_cint_r_vf\n+     (A : vector_signed_int;\n+      B : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vcfsx_vsi_cint_r_vf, \"__builtin_altivec_vcfsx\");\n+\n+   -- vec_vcfux --\n+\n+   function vec_vcfux_vui_cint_r_vf\n+     (A : vector_unsigned_int;\n+      B : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vcfux_vui_cint_r_vf, \"__builtin_altivec_vcfux\");\n+\n+   -- vec_cts --\n+\n+   function vec_cts_vf_cint_r_vsi\n+     (A : vector_float;\n+      B : c_int) return vector_signed_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_cts_vf_cint_r_vsi, \"__builtin_altivec_vctsxs\");\n+\n+   -- vec_ctu --\n+\n+   function vec_ctu_vf_cint_r_vui\n+     (A : vector_float;\n+      B : c_int) return vector_unsigned_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_ctu_vf_cint_r_vui, \"__builtin_altivec_vctuxs\");\n+\n+   -- vec_dss --\n+\n+   procedure vec_dss_cint\n+     (A : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dss_cint, \"__builtin_altivec_dss\");\n+\n+   -- vec_dst --\n+\n+   procedure vec_dst_kvucp_cint_cint\n+     (A : const_vector_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvucp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvscp_cint_cint\n+     (A : const_vector_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvscp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvbcp_cint_cint\n+     (A : const_vector_bool_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvbcp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvusp_cint_cint\n+     (A : const_vector_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvusp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvssp_cint_cint\n+     (A : const_vector_signed_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvssp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvbsp_cint_cint\n+     (A : const_vector_bool_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvbsp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvxp_cint_cint\n+     (A : const_vector_pixel_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvxp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvuip_cint_cint\n+     (A : const_vector_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvuip_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvsip_cint_cint\n+     (A : const_vector_signed_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvsip_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvbip_cint_cint\n+     (A : const_vector_bool_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvbip_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kvfp_cint_cint\n+     (A : const_vector_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kvfp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kucp_cint_cint\n+     (A : const_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kucp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kscp_cint_cint\n+     (A : const_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kscp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kusp_cint_cint\n+     (A : const_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kusp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_ksp_cint_cint\n+     (A : const_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_ksp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kuip_cint_cint\n+     (A : const_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kuip_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kip_cint_cint\n+     (A : const_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kip_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kulongp_cint_cint\n+     (A : const_unsigned_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kulongp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_klongp_cint_cint\n+     (A : const_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_klongp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   procedure vec_dst_kfp_cint_cint\n+     (A : const_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dst_kfp_cint_cint, \"__builtin_altivec_dst\");\n+\n+   -- vec_dstst --\n+\n+   procedure vec_dstst_kvucp_cint_cint\n+     (A : const_vector_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvucp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvscp_cint_cint\n+     (A : const_vector_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvscp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvbcp_cint_cint\n+     (A : const_vector_bool_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvbcp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvusp_cint_cint\n+     (A : const_vector_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvusp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvssp_cint_cint\n+     (A : const_vector_signed_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvssp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvbsp_cint_cint\n+     (A : const_vector_bool_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvbsp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvxp_cint_cint\n+     (A : const_vector_pixel_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvxp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvuip_cint_cint\n+     (A : const_vector_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvuip_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvsip_cint_cint\n+     (A : const_vector_signed_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvsip_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvbip_cint_cint\n+     (A : const_vector_bool_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvbip_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kvfp_cint_cint\n+     (A : const_vector_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kvfp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kucp_cint_cint\n+     (A : const_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kucp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kscp_cint_cint\n+     (A : const_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kscp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kusp_cint_cint\n+     (A : const_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kusp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_ksp_cint_cint\n+     (A : const_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_ksp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kuip_cint_cint\n+     (A : const_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kuip_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kip_cint_cint\n+     (A : const_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kip_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kulongp_cint_cint\n+     (A : const_unsigned_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kulongp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_klongp_cint_cint\n+     (A : const_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_klongp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   procedure vec_dstst_kfp_cint_cint\n+     (A : const_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstst_kfp_cint_cint, \"__builtin_altivec_dstst\");\n+\n+   -- vec_dststt --\n+\n+   procedure vec_dststt_kvucp_cint_cint\n+     (A : const_vector_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvucp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvscp_cint_cint\n+     (A : const_vector_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvscp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvbcp_cint_cint\n+     (A : const_vector_bool_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvbcp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvusp_cint_cint\n+     (A : const_vector_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvusp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvssp_cint_cint\n+     (A : const_vector_signed_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvssp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvbsp_cint_cint\n+     (A : const_vector_bool_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvbsp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvxp_cint_cint\n+     (A : const_vector_pixel_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvxp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvuip_cint_cint\n+     (A : const_vector_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvuip_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvsip_cint_cint\n+     (A : const_vector_signed_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvsip_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvbip_cint_cint\n+     (A : const_vector_bool_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvbip_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kvfp_cint_cint\n+     (A : const_vector_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kvfp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kucp_cint_cint\n+     (A : const_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kucp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kscp_cint_cint\n+     (A : const_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kscp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kusp_cint_cint\n+     (A : const_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kusp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_ksp_cint_cint\n+     (A : const_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_ksp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kuip_cint_cint\n+     (A : const_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kuip_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kip_cint_cint\n+     (A : const_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kip_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kulongp_cint_cint\n+     (A : const_unsigned_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kulongp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_klongp_cint_cint\n+     (A : const_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_klongp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   procedure vec_dststt_kfp_cint_cint\n+     (A : const_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dststt_kfp_cint_cint, \"__builtin_altivec_dststt\");\n+\n+   -- vec_dstt --\n+\n+   procedure vec_dstt_kvucp_cint_cint\n+     (A : const_vector_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvucp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvscp_cint_cint\n+     (A : const_vector_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvscp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvbcp_cint_cint\n+     (A : const_vector_bool_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvbcp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvusp_cint_cint\n+     (A : const_vector_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvusp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvssp_cint_cint\n+     (A : const_vector_signed_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvssp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvbsp_cint_cint\n+     (A : const_vector_bool_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvbsp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvxp_cint_cint\n+     (A : const_vector_pixel_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvxp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvuip_cint_cint\n+     (A : const_vector_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvuip_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvsip_cint_cint\n+     (A : const_vector_signed_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvsip_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvbip_cint_cint\n+     (A : const_vector_bool_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvbip_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kvfp_cint_cint\n+     (A : const_vector_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kvfp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kucp_cint_cint\n+     (A : const_unsigned_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kucp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kscp_cint_cint\n+     (A : const_signed_char_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kscp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kusp_cint_cint\n+     (A : const_unsigned_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kusp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_ksp_cint_cint\n+     (A : const_short_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_ksp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kuip_cint_cint\n+     (A : const_unsigned_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kuip_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kip_cint_cint\n+     (A : const_int_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kip_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kulongp_cint_cint\n+     (A : const_unsigned_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kulongp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_klongp_cint_cint\n+     (A : const_long_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_klongp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   procedure vec_dstt_kfp_cint_cint\n+     (A : const_float_ptr;\n+      B : c_int;\n+      C : c_int);\n+\n+   pragma Import\n+     (LL_Altivec, vec_dstt_kfp_cint_cint, \"__builtin_altivec_dstt\");\n+\n+   -- vec_sld --\n+\n+   --  ??? The base GCC implementation maps everything to vsldoi_4si, while\n+   --  it defines builtin variants for all the modes. Adjust here, to avoid\n+   --  the infamous argument mode mismatch.\n+\n+   function vec_sld_vf_vf_cint_r_vf\n+     (A : vector_float;\n+      B : vector_float;\n+      C : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vf_vf_cint_r_vf, \"__builtin_altivec_vsldoi_4sf\");\n+\n+   function vec_sld_vsi_vsi_cint_r_vsi\n+     (A : vector_signed_int;\n+      B : vector_signed_int;\n+      C : c_int) return vector_signed_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vsi_vsi_cint_r_vsi, \"__builtin_altivec_vsldoi_4si\");\n+\n+   function vec_sld_vui_vui_cint_r_vui\n+     (A : vector_unsigned_int;\n+      B : vector_unsigned_int;\n+      C : c_int) return vector_unsigned_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vui_vui_cint_r_vui, \"__builtin_altivec_vsldoi_4si\");\n+\n+   function vec_sld_vbi_vbi_cint_r_vbi\n+     (A : vector_bool_int;\n+      B : vector_bool_int;\n+      C : c_int) return vector_bool_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vbi_vbi_cint_r_vbi, \"__builtin_altivec_vsldoi_4si\");\n+\n+   function vec_sld_vss_vss_cint_r_vss\n+     (A : vector_signed_short;\n+      B : vector_signed_short;\n+      C : c_int) return vector_signed_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vss_vss_cint_r_vss, \"__builtin_altivec_vsldoi_8hi\");\n+\n+   function vec_sld_vus_vus_cint_r_vus\n+     (A : vector_unsigned_short;\n+      B : vector_unsigned_short;\n+      C : c_int) return vector_unsigned_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vus_vus_cint_r_vus, \"__builtin_altivec_vsldoi_8hi\");\n+\n+   function vec_sld_vbs_vbs_cint_r_vbs\n+     (A : vector_bool_short;\n+      B : vector_bool_short;\n+      C : c_int) return vector_bool_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vbs_vbs_cint_r_vbs, \"__builtin_altivec_vsldoi_8hi\");\n+\n+   function vec_sld_vx_vx_cint_r_vx\n+     (A : vector_pixel;\n+      B : vector_pixel;\n+      C : c_int) return vector_pixel;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vx_vx_cint_r_vx, \"__builtin_altivec_vsldoi_4si\");\n+\n+   function vec_sld_vsc_vsc_cint_r_vsc\n+     (A : vector_signed_char;\n+      B : vector_signed_char;\n+      C : c_int) return vector_signed_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vsc_vsc_cint_r_vsc, \"__builtin_altivec_vsldoi_16qi\");\n+\n+   function vec_sld_vuc_vuc_cint_r_vuc\n+     (A : vector_unsigned_char;\n+      B : vector_unsigned_char;\n+      C : c_int) return vector_unsigned_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vuc_vuc_cint_r_vuc, \"__builtin_altivec_vsldoi_16qi\");\n+\n+   function vec_sld_vbc_vbc_cint_r_vbc\n+     (A : vector_bool_char;\n+      B : vector_bool_char;\n+      C : c_int) return vector_bool_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_sld_vbc_vbc_cint_r_vbc, \"__builtin_altivec_vsldoi_16qi\");\n+\n+   -- vec_splat --\n+\n+   function vec_splat_vsc_cint_r_vsc\n+     (A : vector_signed_char;\n+      B : c_int) return vector_signed_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vsc_cint_r_vsc, \"__builtin_altivec_vspltb\");\n+\n+   function vec_splat_vuc_cint_r_vuc\n+     (A : vector_unsigned_char;\n+      B : c_int) return vector_unsigned_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vuc_cint_r_vuc, \"__builtin_altivec_vspltb\");\n+\n+   function vec_splat_vbc_cint_r_vbc\n+     (A : vector_bool_char;\n+      B : c_int) return vector_bool_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vbc_cint_r_vbc, \"__builtin_altivec_vspltb\");\n+\n+   function vec_splat_vss_cint_r_vss\n+     (A : vector_signed_short;\n+      B : c_int) return vector_signed_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vss_cint_r_vss, \"__builtin_altivec_vsplth\");\n+\n+   function vec_splat_vus_cint_r_vus\n+     (A : vector_unsigned_short;\n+      B : c_int) return vector_unsigned_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vus_cint_r_vus, \"__builtin_altivec_vsplth\");\n+\n+   function vec_splat_vbs_cint_r_vbs\n+     (A : vector_bool_short;\n+      B : c_int) return vector_bool_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vbs_cint_r_vbs, \"__builtin_altivec_vsplth\");\n+\n+   function vec_splat_vx_cint_r_vx\n+     (A : vector_pixel;\n+      B : c_int) return vector_pixel;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vx_cint_r_vx, \"__builtin_altivec_vsplth\");\n+\n+   function vec_splat_vf_cint_r_vf\n+     (A : vector_float;\n+      B : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vf_cint_r_vf, \"__builtin_altivec_vspltw\");\n+\n+   function vec_splat_vsi_cint_r_vsi\n+     (A : vector_signed_int;\n+      B : c_int) return vector_signed_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vsi_cint_r_vsi, \"__builtin_altivec_vspltw\");\n+\n+   function vec_splat_vui_cint_r_vui\n+     (A : vector_unsigned_int;\n+      B : c_int) return vector_unsigned_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vui_cint_r_vui, \"__builtin_altivec_vspltw\");\n+\n+   function vec_splat_vbi_cint_r_vbi\n+     (A : vector_bool_int;\n+      B : c_int) return vector_bool_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_vbi_cint_r_vbi, \"__builtin_altivec_vspltw\");\n+\n+   -- vec_vspltw --\n+\n+   function vec_vspltw_vf_cint_r_vf\n+     (A : vector_float;\n+      B : c_int) return vector_float;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltw_vf_cint_r_vf, \"__builtin_altivec_vspltw\");\n+\n+   function vec_vspltw_vsi_cint_r_vsi\n+     (A : vector_signed_int;\n+      B : c_int) return vector_signed_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltw_vsi_cint_r_vsi, \"__builtin_altivec_vspltw\");\n+\n+   function vec_vspltw_vui_cint_r_vui\n+     (A : vector_unsigned_int;\n+      B : c_int) return vector_unsigned_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltw_vui_cint_r_vui, \"__builtin_altivec_vspltw\");\n+\n+   function vec_vspltw_vbi_cint_r_vbi\n+     (A : vector_bool_int;\n+      B : c_int) return vector_bool_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltw_vbi_cint_r_vbi, \"__builtin_altivec_vspltw\");\n+\n+   -- vec_vsplth --\n+\n+   function vec_vsplth_vbs_cint_r_vbs\n+     (A : vector_bool_short;\n+      B : c_int) return vector_bool_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vsplth_vbs_cint_r_vbs, \"__builtin_altivec_vsplth\");\n+\n+   function vec_vsplth_vss_cint_r_vss\n+     (A : vector_signed_short;\n+      B : c_int) return vector_signed_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vsplth_vss_cint_r_vss, \"__builtin_altivec_vsplth\");\n+\n+   function vec_vsplth_vus_cint_r_vus\n+     (A : vector_unsigned_short;\n+      B : c_int) return vector_unsigned_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vsplth_vus_cint_r_vus, \"__builtin_altivec_vsplth\");\n+\n+   function vec_vsplth_vx_cint_r_vx\n+     (A : vector_pixel;\n+      B : c_int) return vector_pixel;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vsplth_vx_cint_r_vx, \"__builtin_altivec_vsplth\");\n+\n+   -- vec_vspltb --\n+\n+   function vec_vspltb_vsc_cint_r_vsc\n+     (A : vector_signed_char;\n+      B : c_int) return vector_signed_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltb_vsc_cint_r_vsc, \"__builtin_altivec_vspltb\");\n+\n+   function vec_vspltb_vuc_cint_r_vuc\n+     (A : vector_unsigned_char;\n+      B : c_int) return vector_unsigned_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltb_vuc_cint_r_vuc, \"__builtin_altivec_vspltb\");\n+\n+   function vec_vspltb_vbc_cint_r_vbc\n+     (A : vector_bool_char;\n+      B : c_int) return vector_bool_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_vspltb_vbc_cint_r_vbc, \"__builtin_altivec_vspltb\");\n+\n+   -- vec_splat_s8 --\n+\n+   function vec_splat_s8_cint_r_vsc\n+     (A : c_int) return vector_signed_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_s8_cint_r_vsc, \"__builtin_altivec_vspltisb\");\n+\n+   -- vec_splat_s16 --\n+\n+   function vec_splat_s16_cint_r_vss\n+     (A : c_int) return vector_signed_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_s16_cint_r_vss, \"__builtin_altivec_vspltish\");\n+\n+   -- vec_splat_s32 --\n+\n+   function vec_splat_s32_cint_r_vsi\n+     (A : c_int) return vector_signed_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_s32_cint_r_vsi, \"__builtin_altivec_vspltisw\");\n+\n+   -- vec_splat_u8 --\n+\n+   function vec_splat_u8_cint_r_vuc\n+     (A : c_int) return vector_unsigned_char;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_u8_cint_r_vuc, \"__builtin_altivec_vspltisb\");\n+\n+   -- vec_splat_u16 --\n+\n+   function vec_splat_u16_cint_r_vus\n+     (A : c_int) return vector_unsigned_short;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_u16_cint_r_vus, \"__builtin_altivec_vspltish\");\n+\n+   -- vec_splat_u32 --\n+\n+   function vec_splat_u32_cint_r_vui\n+     (A : c_int) return vector_unsigned_int;\n+\n+   pragma Import\n+     (LL_Altivec, vec_splat_u32_cint_r_vui, \"__builtin_altivec_vspltisw\");\n+\n+   ------------------------------------------------------------\n+   -- Imports for low-level signature consistent subprograms --\n+   ------------------------------------------------------------\n+\n+   -- vec_dssall --\n+\n+   procedure vec_dssall;\n+\n+   pragma Import\n+     (LL_Altivec, vec_dssall, \"__builtin_altivec_dssall\");\n+\n+   -----------------------------------------\n+   -- Conversions between low level types --\n+   -----------------------------------------\n+\n+   use GNAT.Altivec.Low_Level_Vectors;\n+\n+   --  Something like...\n+   --\n+   --  TYPES=\"LL_VBC LL_VUC LL_VSC LL_VBS LL_VUS LL_VSS \\\n+   --         LL_VBI LL_VUI LL_VSI LL_VF LL_VP\"\n+   --  for TT in `echo $TYPES`; do\n+   --  for ST in `echo $TYPES`; do\n+   --  echo \"function To_$TT is new Ada.Unchecked_Conversion ($ST, $TT);\"\n+   --  done\n+   --  echo \"\"\n+   --  done\n+\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VBC, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VUC, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VSC, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VBS, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VUS, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VSS, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VBI, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VUI, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VSI, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VF, LL_VBC);\n+   function To_LL_VBC is new Ada.Unchecked_Conversion (LL_VP, LL_VBC);\n+\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VBC, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VUC, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VSC, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VBS, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VUS, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VSS, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VBI, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VUI, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VSI, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VF, LL_VUC);\n+   function To_LL_VUC is new Ada.Unchecked_Conversion (LL_VP, LL_VUC);\n+\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VBC, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VUC, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VSC, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VBS, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VUS, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VSS, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VBI, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VUI, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VSI, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VF, LL_VSC);\n+   function To_LL_VSC is new Ada.Unchecked_Conversion (LL_VP, LL_VSC);\n+\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VBC, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VUC, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VSC, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VBS, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VUS, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VSS, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VBI, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VUI, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VSI, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VF, LL_VBS);\n+   function To_LL_VBS is new Ada.Unchecked_Conversion (LL_VP, LL_VBS);\n+\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VBC, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VUC, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VSC, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VBS, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VUS, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VSS, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VBI, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VUI, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VSI, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VF, LL_VUS);\n+   function To_LL_VUS is new Ada.Unchecked_Conversion (LL_VP, LL_VUS);\n+\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VBC, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VUC, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VSC, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VBS, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VUS, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VSS, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VBI, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VUI, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VSI, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VF, LL_VSS);\n+   function To_LL_VSS is new Ada.Unchecked_Conversion (LL_VP, LL_VSS);\n+\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VBC, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VUC, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VSC, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VBS, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VUS, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VSS, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VBI, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VUI, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VSI, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VF, LL_VBI);\n+   function To_LL_VBI is new Ada.Unchecked_Conversion (LL_VP, LL_VBI);\n+\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VBC, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VUC, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VSC, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VBS, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VUS, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VSS, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VBI, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VUI, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VSI, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VF, LL_VUI);\n+   function To_LL_VUI is new Ada.Unchecked_Conversion (LL_VP, LL_VUI);\n+\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VBC, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VUC, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VSC, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VBS, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VUS, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VSS, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VBI, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VUI, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VSI, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VF, LL_VSI);\n+   function To_LL_VSI is new Ada.Unchecked_Conversion (LL_VP, LL_VSI);\n+\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VBC, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VUC, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VSC, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VBS, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VUS, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VSS, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VBI, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VUI, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VSI, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VF, LL_VF);\n+   function To_LL_VF is new Ada.Unchecked_Conversion (LL_VP, LL_VF);\n+\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VBC, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VUC, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VSC, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VBS, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VUS, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VSS, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VBI, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VUI, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VSI, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VF, LL_VP);\n+   function To_LL_VP is new Ada.Unchecked_Conversion (LL_VP, LL_VP);\n+\n+   ----------------------------------------------\n+   -- Conversions between pointer/access types --\n+   ----------------------------------------------\n+\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_unsigned_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_signed_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_bool_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_unsigned_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_signed_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_bool_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_unsigned_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_signed_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_bool_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_float_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (vector_pixel_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_bool_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_signed_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_unsigned_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_bool_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_signed_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_unsigned_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_bool_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_signed_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_unsigned_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_float_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_vector_pixel_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (c_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (signed_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (unsigned_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (signed_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (unsigned_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (signed_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (unsigned_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (signed_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (unsigned_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (float_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_signed_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_unsigned_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_signed_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_unsigned_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_signed_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_unsigned_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_signed_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_unsigned_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (const_float_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_signed_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_unsigned_char_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_signed_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_unsigned_short_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_signed_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_unsigned_int_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_signed_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_unsigned_long_ptr, c_ptr);\n+   function To_PTR is\n+      new Ada.Unchecked_Conversion (constv_float_ptr, c_ptr);\n+\n+end GNAT.Altivec.Low_Level_Interface;"}, {"sha": "2da86977c3f56b5532cc354b91ad5346265b5617", "filename": "gcc/ada/g-alleve.adb", "status": "added", "additions": 5035, "deletions": 0, "changes": 5035, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alleve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alleve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alleve.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523"}, {"sha": "8094b80ff735982b31e69d8173e0e2f054efb3ac", "filename": "gcc/ada/g-alleve.ads", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alleve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alleve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alleve.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,528 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--       G N A T . A L T I V E C . L O W _ L E V E L _ V E C T O R S        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                         (Soft Binding Version)                           --\n+--                                                                          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit exposes the low level vector support for the Soft binding,\n+--  intended for non AltiVec capable targets. See Altivec.Design for a\n+--  description of what is expected to be exposed.\n+\n+with GNAT.Altivec.Vector_Views; use GNAT.Altivec.Vector_Views;\n+\n+package GNAT.Altivec.Low_Level_Vectors is\n+\n+   ----------------------------------------\n+   -- Low level vector type declarations --\n+   ----------------------------------------\n+\n+   type LL_VUC is private;\n+   type LL_VSC is private;\n+   type LL_VBC is private;\n+\n+   type LL_VUS is private;\n+   type LL_VSS is private;\n+   type LL_VBS is private;\n+\n+   type LL_VUI is private;\n+   type LL_VSI is private;\n+   type LL_VBI is private;\n+\n+   type LL_VF  is private;\n+   type LL_VP  is private;\n+\n+   ------------------------------------\n+   -- Low level functional interface --\n+   ------------------------------------\n+\n+   function abs_v16qi (A : LL_VSC) return LL_VSC;\n+   function abs_v8hi  (A : LL_VSS) return LL_VSS;\n+   function abs_v4si  (A : LL_VSI) return LL_VSI;\n+   function abs_v4sf  (A : LL_VF)  return LL_VF;\n+\n+   function abss_v16qi (A : LL_VSC) return LL_VSC;\n+   function abss_v8hi  (A : LL_VSS) return LL_VSS;\n+   function abss_v4si  (A : LL_VSI) return LL_VSI;\n+\n+   function vaddubm (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vadduhm (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vadduwm (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vaddfp  (A : LL_VF;  B : LL_VF)  return LL_VF;\n+\n+   function vaddcuw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vaddubs (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vaddsbs (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vadduhs (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vaddshs (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vadduws (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vaddsws (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vand  (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vandc (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vavgub (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vavgsb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vavguh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vavgsh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vavguw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vavgsw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vcmpbfp (A : LL_VF; B : LL_VF) return LL_VSI;\n+\n+   function vcmpequb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vcmpequh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vcmpequw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vcmpeqfp (A : LL_VF; B : LL_VF) return LL_VSI;\n+\n+   function vcmpgefp (A : LL_VF; B : LL_VF) return LL_VSI;\n+\n+   function vcmpgtub (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vcmpgtsb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vcmpgtuh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vcmpgtsh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vcmpgtuw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vcmpgtsw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vcmpgtfp (A : LL_VF; B : LL_VF) return LL_VSI;\n+\n+   function vcfux (A : LL_VSI; B : c_int) return LL_VF;\n+   function vcfsx (A : LL_VSI; B : c_int) return LL_VF;\n+\n+   function vctsxs (A : LL_VF; B : c_int) return LL_VSI;\n+   function vctuxs (A : LL_VF; B : c_int) return LL_VSI;\n+\n+   procedure dss (A : c_int);\n+   procedure dssall;\n+\n+   procedure dst    (A : c_ptr; B : c_int; C : c_int);\n+   procedure dstst  (A : c_ptr; B : c_int; C : c_int);\n+   procedure dststt (A : c_ptr; B : c_int; C : c_int);\n+   procedure dstt   (A : c_ptr; B : c_int; C : c_int);\n+\n+   function vexptefp (A : LL_VF) return LL_VF;\n+\n+   function vrfim (A : LL_VF) return LL_VF;\n+\n+   function lvx   (A : c_long; B : c_ptr) return LL_VSI;\n+   function lvebx (A : c_long; B : c_ptr) return LL_VSC;\n+   function lvehx (A : c_long; B : c_ptr) return LL_VSS;\n+   function lvewx (A : c_long; B : c_ptr) return LL_VSI;\n+   function lvxl  (A : c_long; B : c_ptr) return LL_VSI;\n+\n+   function vlogefp (A : LL_VF) return LL_VF;\n+\n+   function lvsl  (A : c_long; B : c_ptr) return LL_VSC;\n+   function lvsr  (A : c_long; B : c_ptr) return LL_VSC;\n+\n+   function vmaddfp (A : LL_VF; B : LL_VF; C : LL_VF) return LL_VF;\n+\n+   function vmhaddshs  (A : LL_VSS; B : LL_VSS; C : LL_VSS) return LL_VSS;\n+\n+   function vmaxub (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vmaxsb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vmaxuh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vmaxsh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vmaxuw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vmaxsw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vmaxfp (A : LL_VF;  B : LL_VF)  return LL_VF;\n+\n+   function vmrghb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vmrghh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vmrghw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vmrglb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vmrglh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vmrglw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function mfvscr return LL_VSS;\n+\n+   function vminfp (A : LL_VF;  B : LL_VF)  return LL_VF;\n+   function vminsb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vminsh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vminsw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vminub (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vminuh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vminuw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vmladduhm (A : LL_VSS; B : LL_VSS; C : LL_VSS) return LL_VSS;\n+\n+   function vmhraddshs (A : LL_VSS; B : LL_VSS; C : LL_VSS) return LL_VSS;\n+\n+   function vmsumubm (A : LL_VSC; B : LL_VSC; C : LL_VSI) return LL_VSI;\n+   function vmsummbm (A : LL_VSC; B : LL_VSC; C : LL_VSI) return LL_VSI;\n+   function vmsumuhm (A : LL_VSS; B : LL_VSS; C : LL_VSI) return LL_VSI;\n+   function vmsumshm (A : LL_VSS; B : LL_VSS; C : LL_VSI) return LL_VSI;\n+   function vmsumuhs (A : LL_VSS; B : LL_VSS; C : LL_VSI) return LL_VSI;\n+   function vmsumshs (A : LL_VSS; B : LL_VSS; C : LL_VSI) return LL_VSI;\n+\n+   procedure mtvscr (A : LL_VSI);\n+\n+   function vmuleub (A : LL_VSC; B : LL_VSC) return LL_VSS;\n+   function vmuleuh (A : LL_VSS; B : LL_VSS) return LL_VSI;\n+   function vmulesb (A : LL_VSC; B : LL_VSC) return LL_VSS;\n+   function vmulesh (A : LL_VSS; B : LL_VSS) return LL_VSI;\n+\n+   function vmulosb (A : LL_VSC; B : LL_VSC) return LL_VSS;\n+   function vmulosh (A : LL_VSS; B : LL_VSS) return LL_VSI;\n+   function vmuloub (A : LL_VSC; B : LL_VSC) return LL_VSS;\n+   function vmulouh (A : LL_VSS; B : LL_VSS) return LL_VSI;\n+\n+   function vnmsubfp (A : LL_VF; B : LL_VF; C : LL_VF) return LL_VF;\n+\n+   function vxor (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vnor (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vor  (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vpkuhum (A : LL_VSS; B : LL_VSS) return LL_VSC;\n+   function vpkuwum (A : LL_VSI; B : LL_VSI) return LL_VSS;\n+   function vpkpx   (A : LL_VSI; B : LL_VSI) return LL_VSS;\n+   function vpkuhus (A : LL_VSS; B : LL_VSS) return LL_VSC;\n+   function vpkuwus (A : LL_VSI; B : LL_VSI) return LL_VSS;\n+   function vpkshss (A : LL_VSS; B : LL_VSS) return LL_VSC;\n+   function vpkswss (A : LL_VSI; B : LL_VSI) return LL_VSS;\n+   function vpkshus (A : LL_VSS; B : LL_VSS) return LL_VSC;\n+   function vpkswus (A : LL_VSI; B : LL_VSI) return LL_VSS;\n+\n+   function vperm_4si (A : LL_VSI; B : LL_VSI; C : LL_VSC) return LL_VSI;\n+\n+   function vrefp (A : LL_VF) return LL_VF;\n+\n+   function vrlb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vrlh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vrlw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vrfin (A : LL_VF) return LL_VF;\n+   function vrfip (A : LL_VF) return LL_VF;\n+   function vrfiz (A : LL_VF) return LL_VF;\n+\n+   function vrsqrtefp (A : LL_VF) return LL_VF;\n+\n+   function vsel_4si (A : LL_VSI; B : LL_VSI; C : LL_VSI) return LL_VSI;\n+\n+   function vslb (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vslh (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vslw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vsldoi_4si  (A : LL_VSI; B : LL_VSI; C : c_int) return LL_VSI;\n+   function vsldoi_8hi  (A : LL_VSS; B : LL_VSS; C : c_int) return LL_VSS;\n+   function vsldoi_16qi (A : LL_VSC; B : LL_VSC; C : c_int) return LL_VSC;\n+   function vsldoi_4sf  (A : LL_VF;  B : LL_VF;  C : c_int) return LL_VF;\n+\n+   function vsl  (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vslo (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vspltb (A : LL_VSC; B : c_int) return LL_VSC;\n+   function vsplth (A : LL_VSS; B : c_int) return LL_VSS;\n+   function vspltw (A : LL_VSI; B : c_int) return LL_VSI;\n+\n+   function vspltisb (A : c_int) return LL_VSC;\n+   function vspltish (A : c_int) return LL_VSS;\n+   function vspltisw (A : c_int) return LL_VSI;\n+\n+   function vsrb  (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vsrh  (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vsrw  (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vsrab (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vsrah (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vsraw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vsr   (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vsro  (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   procedure stvx   (A : LL_VSI; B : c_int; C : c_ptr);\n+   procedure stvebx (A : LL_VSC; B : c_int; C : c_ptr);\n+   procedure stvehx (A : LL_VSS; B : c_int; C : c_ptr);\n+   procedure stvewx (A : LL_VSI; B : c_int; C : c_ptr);\n+   procedure stvxl  (A : LL_VSI; B : c_int; C : c_ptr);\n+\n+   function vsububm (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vsubuhm (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vsubuwm (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vsubfp  (A : LL_VF;  B : LL_VF)  return LL_VF;\n+\n+   function vsubcuw (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vsububs (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vsubsbs (A : LL_VSC; B : LL_VSC) return LL_VSC;\n+   function vsubuhs (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vsubshs (A : LL_VSS; B : LL_VSS) return LL_VSS;\n+   function vsubuws (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vsubsws (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vsum4ubs (A : LL_VSC; B : LL_VSI) return LL_VSI;\n+   function vsum4sbs (A : LL_VSC; B : LL_VSI) return LL_VSI;\n+   function vsum4shs (A : LL_VSS; B : LL_VSI) return LL_VSI;\n+\n+   function vsum2sws (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+   function vsumsws  (A : LL_VSI; B : LL_VSI) return LL_VSI;\n+\n+   function vupkhsb (A : LL_VSC) return LL_VSS;\n+   function vupkhsh (A : LL_VSS) return LL_VSI;\n+   function vupkhpx (A : LL_VSS) return LL_VSI;\n+\n+   function vupklsb (A : LL_VSC) return LL_VSS;\n+   function vupklsh (A : LL_VSS) return LL_VSI;\n+   function vupklpx (A : LL_VSS) return LL_VSI;\n+\n+   function vcmpequb_p (A : c_int; B : LL_VSC; C : LL_VSC) return c_int;\n+   function vcmpequh_p (A : c_int; B : LL_VSS; C : LL_VSS) return c_int;\n+   function vcmpequw_p (A : c_int; B : LL_VSI; C : LL_VSI) return c_int;\n+   function vcmpeqfp_p (A : c_int; B : LL_VF; C : LL_VF) return c_int;\n+\n+   function vcmpgtub_p (A : c_int; B : LL_VSC; C : LL_VSC) return c_int;\n+   function vcmpgtuh_p (A : c_int; B : LL_VSS; C : LL_VSS) return c_int;\n+   function vcmpgtuw_p (A : c_int; B : LL_VSI; C : LL_VSI) return c_int;\n+   function vcmpgtsb_p (A : c_int; B : LL_VSC; C : LL_VSC) return c_int;\n+   function vcmpgtsh_p (A : c_int; B : LL_VSS; C : LL_VSS) return c_int;\n+   function vcmpgtsw_p (A : c_int; B : LL_VSI; C : LL_VSI) return c_int;\n+   function vcmpgtfp_p (A : c_int; B : LL_VF; C : LL_VF) return c_int;\n+\n+   function vcmpgefp_p (A : c_int; B : LL_VF; C : LL_VF) return c_int;\n+   function vcmpbfp_p  (A : c_int; B : LL_VF; C : LL_VF) return c_int;\n+\n+private\n+\n+   ---------------------------------------\n+   -- Low level vector type definitions --\n+   ---------------------------------------\n+\n+   --  We simply use the natural array definitions corresponding to each\n+   --  user-level vector type.\n+\n+   type LL_VUI is new VUC_View;\n+   type LL_VSI is new VUC_View;\n+\n+   type LL_VUS is new VUC_View;\n+   type LL_VSS is new VUC_View;\n+\n+   type LL_VUC is new VUC_View;\n+   type LL_VSC is new VUC_View;\n+\n+   type LL_VF is new VUC_View;\n+\n+   type LL_VBC is new VUC_View;\n+   type LL_VBS is new VUC_View;\n+   type LL_VBI is new VUC_View;\n+   type LL_VP is new VUC_View;\n+\n+   ------------------------------------\n+   -- Low level functional interface --\n+   ------------------------------------\n+\n+   pragma Convention_Identifier (LL_Altivec, C);\n+\n+   pragma Export (LL_Altivec, dss,         \"__builtin_altivec_dss\");\n+   pragma Export (LL_Altivec, dssall,      \"__builtin_altivec_dssall\");\n+   pragma Export (LL_Altivec, dst,         \"__builtin_altivec_dst\");\n+   pragma Export (LL_Altivec, dstst,       \"__builtin_altivec_dstst\");\n+   pragma Export (LL_Altivec, dststt,      \"__builtin_altivec_dststt\");\n+   pragma Export (LL_Altivec, dstt,        \"__builtin_altivec_dstt\");\n+   pragma Export (LL_Altivec, mtvscr,      \"__builtin_altivec_mtvscr\");\n+   pragma Export (LL_Altivec, mfvscr,      \"__builtin_altivec_mfvscr\");\n+   pragma Export (LL_Altivec, stvebx,      \"__builtin_altivec_stvebx\");\n+   pragma Export (LL_Altivec, stvehx,      \"__builtin_altivec_stvehx\");\n+   pragma Export (LL_Altivec, stvewx,      \"__builtin_altivec_stvewx\");\n+   pragma Export (LL_Altivec, stvx,        \"__builtin_altivec_stvx\");\n+   pragma Export (LL_Altivec, stvxl,       \"__builtin_altivec_stvxl\");\n+   pragma Export (LL_Altivec, lvebx,       \"__builtin_altivec_lvebx\");\n+   pragma Export (LL_Altivec, lvehx,       \"__builtin_altivec_lvehx\");\n+   pragma Export (LL_Altivec, lvewx,       \"__builtin_altivec_lvewx\");\n+   pragma Export (LL_Altivec, lvx,         \"__builtin_altivec_lvx\");\n+   pragma Export (LL_Altivec, lvxl,        \"__builtin_altivec_lvxl\");\n+   pragma Export (LL_Altivec, lvsl,        \"__builtin_altivec_lvsl\");\n+   pragma Export (LL_Altivec, lvsr,        \"__builtin_altivec_lvsr\");\n+   pragma Export (LL_Altivec, abs_v16qi,   \"__builtin_altivec_abs_v16qi\");\n+   pragma Export (LL_Altivec, abs_v8hi,    \"__builtin_altivec_abs_v8hi\");\n+   pragma Export (LL_Altivec, abs_v4si,    \"__builtin_altivec_abs_v4si\");\n+   pragma Export (LL_Altivec, abs_v4sf,    \"__builtin_altivec_abs_v4sf\");\n+   pragma Export (LL_Altivec, abss_v16qi,  \"__builtin_altivec_abss_v16qi\");\n+   pragma Export (LL_Altivec, abss_v8hi,   \"__builtin_altivec_abss_v8hi\");\n+   pragma Export (LL_Altivec, abss_v4si,   \"__builtin_altivec_abss_v4si\");\n+   pragma Export (LL_Altivec, vaddcuw,     \"__builtin_altivec_vaddcuw\");\n+   pragma Export (LL_Altivec, vaddfp,      \"__builtin_altivec_vaddfp\");\n+   pragma Export (LL_Altivec, vaddsbs,     \"__builtin_altivec_vaddsbs\");\n+   pragma Export (LL_Altivec, vaddshs,     \"__builtin_altivec_vaddshs\");\n+   pragma Export (LL_Altivec, vaddsws,     \"__builtin_altivec_vaddsws\");\n+   pragma Export (LL_Altivec, vaddubm,     \"__builtin_altivec_vaddubm\");\n+   pragma Export (LL_Altivec, vaddubs,     \"__builtin_altivec_vaddubs\");\n+   pragma Export (LL_Altivec, vadduhm,     \"__builtin_altivec_vadduhm\");\n+   pragma Export (LL_Altivec, vadduhs,     \"__builtin_altivec_vadduhs\");\n+   pragma Export (LL_Altivec, vadduwm,     \"__builtin_altivec_vadduwm\");\n+   pragma Export (LL_Altivec, vadduws,     \"__builtin_altivec_vadduws\");\n+   pragma Export (LL_Altivec, vand,        \"__builtin_altivec_vand\");\n+   pragma Export (LL_Altivec, vandc,       \"__builtin_altivec_vandc\");\n+   pragma Export (LL_Altivec, vavgsb,      \"__builtin_altivec_vavgsb\");\n+   pragma Export (LL_Altivec, vavgsh,      \"__builtin_altivec_vavgsh\");\n+   pragma Export (LL_Altivec, vavgsw,      \"__builtin_altivec_vavgsw\");\n+   pragma Export (LL_Altivec, vavgub,      \"__builtin_altivec_vavgub\");\n+   pragma Export (LL_Altivec, vavguh,      \"__builtin_altivec_vavguh\");\n+   pragma Export (LL_Altivec, vavguw,      \"__builtin_altivec_vavguw\");\n+   pragma Export (LL_Altivec, vcfsx,       \"__builtin_altivec_vcfsx\");\n+   pragma Export (LL_Altivec, vcfux,       \"__builtin_altivec_vcfux\");\n+   pragma Export (LL_Altivec, vcmpbfp,     \"__builtin_altivec_vcmpbfp\");\n+   pragma Export (LL_Altivec, vcmpeqfp,    \"__builtin_altivec_vcmpeqfp\");\n+   pragma Export (LL_Altivec, vcmpequb,    \"__builtin_altivec_vcmpequb\");\n+   pragma Export (LL_Altivec, vcmpequh,    \"__builtin_altivec_vcmpequh\");\n+   pragma Export (LL_Altivec, vcmpequw,    \"__builtin_altivec_vcmpequw\");\n+   pragma Export (LL_Altivec, vcmpgefp,    \"__builtin_altivec_vcmpgefp\");\n+   pragma Export (LL_Altivec, vcmpgtfp,    \"__builtin_altivec_vcmpgtfp\");\n+   pragma Export (LL_Altivec, vcmpgtsb,    \"__builtin_altivec_vcmpgtsb\");\n+   pragma Export (LL_Altivec, vcmpgtsh,    \"__builtin_altivec_vcmpgtsh\");\n+   pragma Export (LL_Altivec, vcmpgtsw,    \"__builtin_altivec_vcmpgtsw\");\n+   pragma Export (LL_Altivec, vcmpgtub,    \"__builtin_altivec_vcmpgtub\");\n+   pragma Export (LL_Altivec, vcmpgtuh,    \"__builtin_altivec_vcmpgtuh\");\n+   pragma Export (LL_Altivec, vcmpgtuw,    \"__builtin_altivec_vcmpgtuw\");\n+   pragma Export (LL_Altivec, vctsxs,      \"__builtin_altivec_vctsxs\");\n+   pragma Export (LL_Altivec, vctuxs,      \"__builtin_altivec_vctuxs\");\n+   pragma Export (LL_Altivec, vexptefp,    \"__builtin_altivec_vexptefp\");\n+   pragma Export (LL_Altivec, vlogefp,     \"__builtin_altivec_vlogefp\");\n+   pragma Export (LL_Altivec, vmaddfp,     \"__builtin_altivec_vmaddfp\");\n+   pragma Export (LL_Altivec, vmaxfp,      \"__builtin_altivec_vmaxfp\");\n+   pragma Export (LL_Altivec, vmaxsb,      \"__builtin_altivec_vmaxsb\");\n+   pragma Export (LL_Altivec, vmaxsh,      \"__builtin_altivec_vmaxsh\");\n+   pragma Export (LL_Altivec, vmaxsw,      \"__builtin_altivec_vmaxsw\");\n+   pragma Export (LL_Altivec, vmaxub,      \"__builtin_altivec_vmaxub\");\n+   pragma Export (LL_Altivec, vmaxuh,      \"__builtin_altivec_vmaxuh\");\n+   pragma Export (LL_Altivec, vmaxuw,      \"__builtin_altivec_vmaxuw\");\n+   pragma Export (LL_Altivec, vmhaddshs,   \"__builtin_altivec_vmhaddshs\");\n+   pragma Export (LL_Altivec, vmhraddshs,  \"__builtin_altivec_vmhraddshs\");\n+   pragma Export (LL_Altivec, vminfp,      \"__builtin_altivec_vminfp\");\n+   pragma Export (LL_Altivec, vminsb,      \"__builtin_altivec_vminsb\");\n+   pragma Export (LL_Altivec, vminsh,      \"__builtin_altivec_vminsh\");\n+   pragma Export (LL_Altivec, vminsw,      \"__builtin_altivec_vminsw\");\n+   pragma Export (LL_Altivec, vminub,      \"__builtin_altivec_vminub\");\n+   pragma Export (LL_Altivec, vminuh,      \"__builtin_altivec_vminuh\");\n+   pragma Export (LL_Altivec, vminuw,      \"__builtin_altivec_vminuw\");\n+   pragma Export (LL_Altivec, vmladduhm,   \"__builtin_altivec_vmladduhm\");\n+   pragma Export (LL_Altivec, vmrghb,      \"__builtin_altivec_vmrghb\");\n+   pragma Export (LL_Altivec, vmrghh,      \"__builtin_altivec_vmrghh\");\n+   pragma Export (LL_Altivec, vmrghw,      \"__builtin_altivec_vmrghw\");\n+   pragma Export (LL_Altivec, vmrglb,      \"__builtin_altivec_vmrglb\");\n+   pragma Export (LL_Altivec, vmrglh,      \"__builtin_altivec_vmrglh\");\n+   pragma Export (LL_Altivec, vmrglw,      \"__builtin_altivec_vmrglw\");\n+   pragma Export (LL_Altivec, vmsummbm,    \"__builtin_altivec_vmsummbm\");\n+   pragma Export (LL_Altivec, vmsumshm,    \"__builtin_altivec_vmsumshm\");\n+   pragma Export (LL_Altivec, vmsumshs,    \"__builtin_altivec_vmsumshs\");\n+   pragma Export (LL_Altivec, vmsumubm,    \"__builtin_altivec_vmsumubm\");\n+   pragma Export (LL_Altivec, vmsumuhm,    \"__builtin_altivec_vmsumuhm\");\n+   pragma Export (LL_Altivec, vmsumuhs,    \"__builtin_altivec_vmsumuhs\");\n+   pragma Export (LL_Altivec, vmulesb,     \"__builtin_altivec_vmulesb\");\n+   pragma Export (LL_Altivec, vmulesh,     \"__builtin_altivec_vmulesh\");\n+   pragma Export (LL_Altivec, vmuleub,     \"__builtin_altivec_vmuleub\");\n+   pragma Export (LL_Altivec, vmuleuh,     \"__builtin_altivec_vmuleuh\");\n+   pragma Export (LL_Altivec, vmulosb,     \"__builtin_altivec_vmulosb\");\n+   pragma Export (LL_Altivec, vmulosh,     \"__builtin_altivec_vmulosh\");\n+   pragma Export (LL_Altivec, vmuloub,     \"__builtin_altivec_vmuloub\");\n+   pragma Export (LL_Altivec, vmulouh,     \"__builtin_altivec_vmulouh\");\n+   pragma Export (LL_Altivec, vnmsubfp,    \"__builtin_altivec_vnmsubfp\");\n+   pragma Export (LL_Altivec, vnor,        \"__builtin_altivec_vnor\");\n+   pragma Export (LL_Altivec, vxor,        \"__builtin_altivec_vxor\");\n+   pragma Export (LL_Altivec, vor,         \"__builtin_altivec_vor\");\n+   pragma Export (LL_Altivec, vperm_4si,   \"__builtin_altivec_vperm_4si\");\n+   pragma Export (LL_Altivec, vpkpx,       \"__builtin_altivec_vpkpx\");\n+   pragma Export (LL_Altivec, vpkshss,     \"__builtin_altivec_vpkshss\");\n+   pragma Export (LL_Altivec, vpkshus,     \"__builtin_altivec_vpkshus\");\n+   pragma Export (LL_Altivec, vpkswss,     \"__builtin_altivec_vpkswss\");\n+   pragma Export (LL_Altivec, vpkswus,     \"__builtin_altivec_vpkswus\");\n+   pragma Export (LL_Altivec, vpkuhum,     \"__builtin_altivec_vpkuhum\");\n+   pragma Export (LL_Altivec, vpkuhus,     \"__builtin_altivec_vpkuhus\");\n+   pragma Export (LL_Altivec, vpkuwum,     \"__builtin_altivec_vpkuwum\");\n+   pragma Export (LL_Altivec, vpkuwus,     \"__builtin_altivec_vpkuwus\");\n+   pragma Export (LL_Altivec, vrefp,       \"__builtin_altivec_vrefp\");\n+   pragma Export (LL_Altivec, vrfim,       \"__builtin_altivec_vrfim\");\n+   pragma Export (LL_Altivec, vrfin,       \"__builtin_altivec_vrfin\");\n+   pragma Export (LL_Altivec, vrfip,       \"__builtin_altivec_vrfip\");\n+   pragma Export (LL_Altivec, vrfiz,       \"__builtin_altivec_vrfiz\");\n+   pragma Export (LL_Altivec, vrlb,        \"__builtin_altivec_vrlb\");\n+   pragma Export (LL_Altivec, vrlh,        \"__builtin_altivec_vrlh\");\n+   pragma Export (LL_Altivec, vrlw,        \"__builtin_altivec_vrlw\");\n+   pragma Export (LL_Altivec, vrsqrtefp,   \"__builtin_altivec_vrsqrtefp\");\n+   pragma Export (LL_Altivec, vsel_4si,    \"__builtin_altivec_vsel_4si\");\n+   pragma Export (LL_Altivec, vsldoi_4si,  \"__builtin_altivec_vsldoi_4si\");\n+   pragma Export (LL_Altivec, vsldoi_8hi,  \"__builtin_altivec_vsldoi_8hi\");\n+   pragma Export (LL_Altivec, vsldoi_16qi, \"__builtin_altivec_vsldoi_16qi\");\n+   pragma Export (LL_Altivec, vsldoi_4sf,  \"__builtin_altivec_vsldoi_4sf\");\n+   pragma Export (LL_Altivec, vsl,         \"__builtin_altivec_vsl\");\n+   pragma Export (LL_Altivec, vslb,        \"__builtin_altivec_vslb\");\n+   pragma Export (LL_Altivec, vslh,        \"__builtin_altivec_vslh\");\n+   pragma Export (LL_Altivec, vslo,        \"__builtin_altivec_vslo\");\n+   pragma Export (LL_Altivec, vslw,        \"__builtin_altivec_vslw\");\n+   pragma Export (LL_Altivec, vspltb,      \"__builtin_altivec_vspltb\");\n+   pragma Export (LL_Altivec, vsplth,      \"__builtin_altivec_vsplth\");\n+   pragma Export (LL_Altivec, vspltisb,    \"__builtin_altivec_vspltisb\");\n+   pragma Export (LL_Altivec, vspltish,    \"__builtin_altivec_vspltish\");\n+   pragma Export (LL_Altivec, vspltisw,    \"__builtin_altivec_vspltisw\");\n+   pragma Export (LL_Altivec, vspltw,      \"__builtin_altivec_vspltw\");\n+   pragma Export (LL_Altivec, vsr,         \"__builtin_altivec_vsr\");\n+   pragma Export (LL_Altivec, vsrab,       \"__builtin_altivec_vsrab\");\n+   pragma Export (LL_Altivec, vsrah,       \"__builtin_altivec_vsrah\");\n+   pragma Export (LL_Altivec, vsraw,       \"__builtin_altivec_vsraw\");\n+   pragma Export (LL_Altivec, vsrb,        \"__builtin_altivec_vsrb\");\n+   pragma Export (LL_Altivec, vsrh,        \"__builtin_altivec_vsrh\");\n+   pragma Export (LL_Altivec, vsro,        \"__builtin_altivec_vsro\");\n+   pragma Export (LL_Altivec, vsrw,        \"__builtin_altivec_vsrw\");\n+   pragma Export (LL_Altivec, vsubcuw,     \"__builtin_altivec_vsubcuw\");\n+   pragma Export (LL_Altivec, vsubfp,      \"__builtin_altivec_vsubfp\");\n+   pragma Export (LL_Altivec, vsubsbs,     \"__builtin_altivec_vsubsbs\");\n+   pragma Export (LL_Altivec, vsubshs,     \"__builtin_altivec_vsubshs\");\n+   pragma Export (LL_Altivec, vsubsws,     \"__builtin_altivec_vsubsws\");\n+   pragma Export (LL_Altivec, vsububm,     \"__builtin_altivec_vsububm\");\n+   pragma Export (LL_Altivec, vsububs,     \"__builtin_altivec_vsububs\");\n+   pragma Export (LL_Altivec, vsubuhm,     \"__builtin_altivec_vsubuhm\");\n+   pragma Export (LL_Altivec, vsubuhs,     \"__builtin_altivec_vsubuhs\");\n+   pragma Export (LL_Altivec, vsubuwm,     \"__builtin_altivec_vsubuwm\");\n+   pragma Export (LL_Altivec, vsubuws,     \"__builtin_altivec_vsubuws\");\n+   pragma Export (LL_Altivec, vsum2sws,    \"__builtin_altivec_vsum2sws\");\n+   pragma Export (LL_Altivec, vsum4sbs,    \"__builtin_altivec_vsum4sbs\");\n+   pragma Export (LL_Altivec, vsum4shs,    \"__builtin_altivec_vsum4shs\");\n+   pragma Export (LL_Altivec, vsum4ubs,    \"__builtin_altivec_vsum4ubs\");\n+   pragma Export (LL_Altivec, vsumsws,     \"__builtin_altivec_vsumsws\");\n+   pragma Export (LL_Altivec, vupkhpx,     \"__builtin_altivec_vupkhpx\");\n+   pragma Export (LL_Altivec, vupkhsb,     \"__builtin_altivec_vupkhsb\");\n+   pragma Export (LL_Altivec, vupkhsh,     \"__builtin_altivec_vupkhsh\");\n+   pragma Export (LL_Altivec, vupklpx,     \"__builtin_altivec_vupklpx\");\n+   pragma Export (LL_Altivec, vupklsb,     \"__builtin_altivec_vupklsb\");\n+   pragma Export (LL_Altivec, vupklsh,     \"__builtin_altivec_vupklsh\");\n+   pragma Export (LL_Altivec, vcmpbfp_p,   \"__builtin_altivec_vcmpbfp_p\");\n+   pragma Export (LL_Altivec, vcmpeqfp_p,  \"__builtin_altivec_vcmpeqfp_p\");\n+   pragma Export (LL_Altivec, vcmpgefp_p,  \"__builtin_altivec_vcmpgefp_p\");\n+   pragma Export (LL_Altivec, vcmpgtfp_p,  \"__builtin_altivec_vcmpgtfp_p\");\n+   pragma Export (LL_Altivec, vcmpequw_p,  \"__builtin_altivec_vcmpequw_p\");\n+   pragma Export (LL_Altivec, vcmpgtsw_p,  \"__builtin_altivec_vcmpgtsw_p\");\n+   pragma Export (LL_Altivec, vcmpgtuw_p,  \"__builtin_altivec_vcmpgtuw_p\");\n+   pragma Export (LL_Altivec, vcmpgtuh_p,  \"__builtin_altivec_vcmpgtuh_p\");\n+   pragma Export (LL_Altivec, vcmpgtsh_p,  \"__builtin_altivec_vcmpgtsh_p\");\n+   pragma Export (LL_Altivec, vcmpequh_p,  \"__builtin_altivec_vcmpequh_p\");\n+   pragma Export (LL_Altivec, vcmpequb_p,  \"__builtin_altivec_vcmpequb_p\");\n+   pragma Export (LL_Altivec, vcmpgtsb_p,  \"__builtin_altivec_vcmpgtsb_p\");\n+   pragma Export (LL_Altivec, vcmpgtub_p,  \"__builtin_altivec_vcmpgtub_p\");\n+\n+end GNAT.Altivec.Low_Level_Vectors;"}, {"sha": "2969ba24755459d33b69f9246ce4678eeafba2a7", "filename": "gcc/ada/g-altcon.adb", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-altcon.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-altcon.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-altcon.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,486 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--             G N A T . A L T I V E C . C O N V E R S I O N S              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+\n+with System; use System;\n+\n+with GNAT.Altivec.Low_Level_Interface; use GNAT.Altivec.Low_Level_Interface;\n+with GNAT.Altivec.Low_Level_Vectors;   use GNAT.Altivec.Low_Level_Vectors;\n+\n+package body GNAT.Altivec.Conversions is\n+\n+   function To_Varray_unsigned_char is\n+     new Ada.Unchecked_Conversion (Varray_signed_char,\n+                                   Varray_unsigned_char);\n+\n+   function To_Varray_unsigned_char is\n+     new Ada.Unchecked_Conversion (Varray_bool_char,\n+                                   Varray_unsigned_char);\n+\n+   function To_Varray_unsigned_short is\n+     new Ada.Unchecked_Conversion (Varray_signed_short,\n+                                   Varray_unsigned_short);\n+\n+   function To_Varray_unsigned_short is\n+     new Ada.Unchecked_Conversion (Varray_bool_short,\n+                                   Varray_unsigned_short);\n+\n+   function To_Varray_unsigned_short is\n+      new Ada.Unchecked_Conversion (Varray_pixel,\n+                                    Varray_unsigned_short);\n+\n+   function To_Varray_unsigned_int is\n+     new Ada.Unchecked_Conversion (Varray_signed_int,\n+                                   Varray_unsigned_int);\n+\n+   function To_Varray_unsigned_int is\n+     new Ada.Unchecked_Conversion (Varray_bool_int,\n+                                   Varray_unsigned_int);\n+\n+   function To_Varray_unsigned_int is\n+      new Ada.Unchecked_Conversion (Varray_float,\n+                                    Varray_unsigned_int);\n+\n+   function To_Varray_signed_char is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_char,\n+                                   Varray_signed_char);\n+\n+   function To_Varray_bool_char is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_char,\n+                                   Varray_bool_char);\n+\n+   function To_Varray_signed_short is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_short,\n+                                   Varray_signed_short);\n+\n+   function To_Varray_bool_short is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_short,\n+                                   Varray_bool_short);\n+\n+   function To_Varray_pixel is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_short,\n+                                   Varray_pixel);\n+\n+   function To_Varray_signed_int is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_int,\n+                                   Varray_signed_int);\n+\n+   function To_Varray_bool_int is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_int,\n+                                   Varray_bool_int);\n+\n+   function To_Varray_float is\n+     new Ada.Unchecked_Conversion (Varray_unsigned_int,\n+                                   Varray_float);\n+\n+   function To_VUC is new Ada.Unchecked_Conversion (VUC_View, VUC);\n+   function To_VSC is new Ada.Unchecked_Conversion (VSC_View, VSC);\n+   function To_VBC is new Ada.Unchecked_Conversion (VBC_View, VBC);\n+   function To_VUS is new Ada.Unchecked_Conversion (VUS_View, VUS);\n+   function To_VSS is new Ada.Unchecked_Conversion (VSS_View, VSS);\n+   function To_VBS is new Ada.Unchecked_Conversion (VBS_View, VBS);\n+   function To_VUI is new Ada.Unchecked_Conversion (VUI_View, VUI);\n+   function To_VSI is new Ada.Unchecked_Conversion (VSI_View, VSI);\n+   function To_VBI is new Ada.Unchecked_Conversion (VBI_View, VBI);\n+   function To_VF  is new Ada.Unchecked_Conversion (VF_View,  VF);\n+   function To_VP  is new Ada.Unchecked_Conversion (VP_View,  VP);\n+\n+   function To_VUC_View is new Ada.Unchecked_Conversion (VUC, VUC_View);\n+   function To_VSC_View is new Ada.Unchecked_Conversion (VSC, VSC_View);\n+   function To_VBC_View is new Ada.Unchecked_Conversion (VBC, VBC_View);\n+   function To_VUS_View is new Ada.Unchecked_Conversion (VUS, VUS_View);\n+   function To_VSS_View is new Ada.Unchecked_Conversion (VSS, VSS_View);\n+   function To_VBS_View is new Ada.Unchecked_Conversion (VBS, VBS_View);\n+   function To_VUI_View is new Ada.Unchecked_Conversion (VUI, VUI_View);\n+   function To_VSI_View is new Ada.Unchecked_Conversion (VSI, VSI_View);\n+   function To_VBI_View is new Ada.Unchecked_Conversion (VBI, VBI_View);\n+   function To_VF_View  is new Ada.Unchecked_Conversion (VF,  VF_View);\n+   function To_VP_View  is new Ada.Unchecked_Conversion (VP,  VP_View);\n+\n+   pragma Warnings (Off, Default_Bit_Order);\n+\n+   ---------------\n+   -- To_Vector --\n+   ---------------\n+\n+   function To_Vector (S : VSC_View) return VSC is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VSC (S);\n+      else\n+         declare\n+            Result : LL_VUC;\n+            VS     : constant VUC_View :=\n+                       (Values => To_Varray_unsigned_char (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VSC (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VBC_View) return VBC is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VBC (S);\n+      else\n+         declare\n+            Result : LL_VUC;\n+            VS     : constant VUC_View :=\n+                       (Values => To_Varray_unsigned_char (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VBC (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VSS_View) return VSS is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VSS (S);\n+      else\n+         declare\n+            Result : LL_VUS;\n+            VS     : constant VUS_View :=\n+                       (Values => To_Varray_unsigned_short (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return VSS (To_LL_VSS (Result));\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VBS_View) return VBS is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VBS (S);\n+      else\n+         declare\n+            Result : LL_VUS;\n+            VS     : constant VUS_View :=\n+                       (Values => To_Varray_unsigned_short (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VBS (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VP_View) return VP is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VP (S);\n+      else\n+         declare\n+            Result : LL_VUS;\n+            VS     : constant VUS_View :=\n+                       (Values => To_Varray_unsigned_short (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VP (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VSI_View) return VSI is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VSI (S);\n+      else\n+         declare\n+            Result : LL_VUI;\n+            VS     : constant VUI_View :=\n+                       (Values => To_Varray_unsigned_int (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VSI (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VBI_View) return VBI is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VBI (S);\n+      else\n+         declare\n+            Result : LL_VUI;\n+            VS     : constant VUI_View :=\n+                       (Values => To_Varray_unsigned_int (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VBI (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VF_View) return VF is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VF (S);\n+      else\n+         declare\n+            Result : LL_VUI;\n+            VS     : constant VUI_View :=\n+                       (Values => To_Varray_unsigned_int (S.Values));\n+         begin\n+            Result := To_Vector (VS);\n+            return To_LL_VF (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VUC_View) return VUC is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VUC (S);\n+      else\n+         declare\n+            Result : VUC_View;\n+         begin\n+            for J in Vchar_Range'Range loop\n+               Result.Values (J) :=\n+                 S.Values (Vchar_Range'Last - J + Vchar_Range'First);\n+            end loop;\n+            return To_VUC (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VUS_View) return VUS is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VUS (S);\n+      else\n+         declare\n+            Result : VUS_View;\n+         begin\n+            for J in Vshort_Range'Range loop\n+               Result.Values (J) :=\n+                 S.Values (Vshort_Range'Last - J + Vshort_Range'First);\n+            end loop;\n+            return To_VUS (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   function To_Vector (S : VUI_View) return VUI is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VUI (S);\n+      else\n+         declare\n+            Result : VUI_View;\n+         begin\n+            for J in Vint_Range'Range loop\n+               Result.Values (J) :=\n+                 S.Values (Vint_Range'Last - J + Vint_Range'First);\n+            end loop;\n+            return To_VUI (Result);\n+         end;\n+      end if;\n+   end To_Vector;\n+\n+   --------------\n+   -- To_View --\n+   --------------\n+\n+   function To_View (S : VSC) return VSC_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VSC_View (S);\n+      else\n+         declare\n+            Result : VUC_View;\n+         begin\n+            Result := To_View (To_LL_VUC (S));\n+            return (Values => To_Varray_signed_char (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VBC) return VBC_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VBC_View (S);\n+      else\n+         declare\n+            Result : VUC_View;\n+         begin\n+            Result := To_View (To_LL_VUC (S));\n+            return (Values => To_Varray_bool_char (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VSS) return VSS_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VSS_View (S);\n+      else\n+         declare\n+            Result : VUS_View;\n+         begin\n+            Result := To_View (To_LL_VUS (S));\n+            return (Values => To_Varray_signed_short (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VBS) return VBS_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VBS_View (S);\n+      else\n+         declare\n+            Result : VUS_View;\n+         begin\n+            Result := To_View (To_LL_VUS (S));\n+            return (Values => To_Varray_bool_short (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VP) return VP_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VP_View (S);\n+      else\n+         declare\n+            Result : VUS_View;\n+         begin\n+            Result := To_View (To_LL_VUS (S));\n+            return (Values => To_Varray_pixel (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VSI) return VSI_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VSI_View (S);\n+      else\n+         declare\n+            Result : VUI_View;\n+         begin\n+            Result := To_View (To_LL_VUI (S));\n+            return (Values => To_Varray_signed_int (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VBI) return VBI_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VBI_View (S);\n+      else\n+         declare\n+            Result : VUI_View;\n+         begin\n+            Result := To_View (To_LL_VUI (S));\n+            return (Values => To_Varray_bool_int (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VF) return VF_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VF_View (S);\n+      else\n+         declare\n+            Result : VUI_View;\n+         begin\n+            Result := To_View (To_LL_VUI (S));\n+            return (Values => To_Varray_float (Result.Values));\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VUC) return VUC_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VUC_View (S);\n+      else\n+         declare\n+            VS     : constant VUC_View := To_VUC_View (S);\n+            Result : VUC_View;\n+         begin\n+            for J in Vchar_Range'Range loop\n+               Result.Values (J) :=\n+                 VS.Values (Vchar_Range'Last - J + Vchar_Range'First);\n+            end loop;\n+            return Result;\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VUS) return VUS_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VUS_View (S);\n+      else\n+         declare\n+            VS     : constant VUS_View := To_VUS_View (S);\n+            Result : VUS_View;\n+         begin\n+            for J in Vshort_Range'Range loop\n+               Result.Values (J) :=\n+                 VS.Values (Vshort_Range'Last - J + Vshort_Range'First);\n+            end loop;\n+            return Result;\n+         end;\n+      end if;\n+   end To_View;\n+\n+   function To_View (S : VUI) return VUI_View is\n+   begin\n+      if Default_Bit_Order = High_Order_First then\n+         return To_VUI_View (S);\n+      else\n+         declare\n+            VS     : constant VUI_View := To_VUI_View (S);\n+            Result : VUI_View;\n+         begin\n+            for J in Vint_Range'Range loop\n+               Result.Values (J) :=\n+                 VS.Values (Vint_Range'Last - J + Vint_Range'First);\n+            end loop;\n+            return Result;\n+         end;\n+      end if;\n+   end To_View;\n+\n+end GNAT.Altivec.Conversions;"}, {"sha": "d32ac8a904bf8cb62cdbfb73deb0e303d815c462", "filename": "gcc/ada/g-altcon.ads", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-altcon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-altcon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-altcon.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,103 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--             G N A T . A L T I V E C . C O N V E R S I O N S              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit provides the Vector/Views conversions\n+\n+with GNAT.Altivec.Vector_Types; use GNAT.Altivec.Vector_Types;\n+with GNAT.Altivec.Vector_Views; use GNAT.Altivec.Vector_Views;\n+\n+package GNAT.Altivec.Conversions is\n+\n+   ---------------------\n+   -- char components --\n+   ---------------------\n+\n+   function To_Vector (S : VUC_View) return VUC;\n+   function To_Vector (S : VSC_View) return VSC;\n+   function To_Vector (S : VBC_View) return VBC;\n+\n+   function To_View (S : VUC) return VUC_View;\n+   function To_View (S : VSC) return VSC_View;\n+   function To_View (S : VBC) return VBC_View;\n+\n+   ----------------------\n+   -- short components --\n+   ----------------------\n+\n+   function To_Vector (S : VUS_View) return VUS;\n+   function To_Vector (S : VSS_View) return VSS;\n+   function To_Vector (S : VBS_View) return VBS;\n+\n+   function To_View (S : VUS) return VUS_View;\n+   function To_View (S : VSS) return VSS_View;\n+   function To_View (S : VBS) return VBS_View;\n+\n+   --------------------\n+   -- int components --\n+   --------------------\n+\n+   function To_Vector (S : VUI_View) return VUI;\n+   function To_Vector (S : VSI_View) return VSI;\n+   function To_Vector (S : VBI_View) return VBI;\n+\n+   function To_View (S : VUI) return VUI_View;\n+   function To_View (S : VSI) return VSI_View;\n+   function To_View (S : VBI) return VBI_View;\n+\n+   ----------------------\n+   -- float components --\n+   ----------------------\n+\n+   function To_Vector (S : VF_View) return VF;\n+\n+   function To_View (S : VF) return VF_View;\n+\n+   ----------------------\n+   -- pixel components --\n+   ----------------------\n+\n+   function To_Vector (S : VP_View) return VP;\n+\n+   function To_View (S : VP) return VP_View;\n+\n+private\n+\n+   --  We want the above subprograms to always be inlined in the case of the\n+   --  hard PowerPC AltiVec support in order to avoid the unnecessary function\n+   --  call. On the other hand there is no problem with inlining these\n+   --  subprograms on little-endian targets.\n+\n+   pragma Inline_Always (To_Vector);\n+   pragma Inline_Always (To_View);\n+\n+end GNAT.Altivec.Conversions;"}, {"sha": "4cb82edc3dffc9b464a6d8357fe3bd8a49a984fa", "filename": "gcc/ada/g-altive.ads", "status": "added", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-altive.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-altive.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-altive.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,455 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         G N A T . A L T I V E C                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+-------------------------\n+-- General description --\n+-------------------------\n+\n+--  This is the root of a package hierarchy offering an Ada binding to the\n+--  PowerPC AltiVec extensions. These extensions basically consist in a set of\n+--  128bit vector types together with a set of subprograms operating on such\n+--  vectors. On a real Altivec capable target, vector objects map to hardware\n+--  vector registers and the subprograms map to a set of specific hardware\n+--  instructions.\n+\n+--  Relevant documents are:\n+\n+--  o AltiVec Technology, Programming Interface Manual (1999-06)\n+--    to which we will refer as [PIM], describes the data types, the\n+--    functional interface and the ABI conventions.\n+\n+--  o AltiVec Technology, Programming Environments Manual (2002-02)\n+--    to which we will refer as [PEM], describes the hardware architecture\n+--    and instruction set.\n+\n+--  These documents, as well as a number of others of general interest on the\n+--  AltiVec technology, are available from the Motorola/AltiVec Web site at\n+\n+--  http://www.motorola.com/altivec\n+\n+--  We offer two versions of this binding: one for real AltiVec capable\n+--  targets, and one for other targets. In the latter case, everything is\n+--  emulated in software. We will refer to the two bindings as:\n+\n+--  o The Hard binding for AltiVec capable targets (with the appropriate\n+--    hardware support and corresponding instruction set)\n+\n+--  o The Soft binding for other targets (with the low level primitives\n+--    emulated in software).\n+\n+--  The two versions of the binding are expected to be equivalent from the\n+--  functional standpoint. The same client application code should observe no\n+--  difference in operation results, even if the Soft version is used on a\n+--  non-powerpc target. The Hard binding is naturally expected to run faster\n+--  than the Soft version on the same target.\n+\n+--  We also offer interfaces not strictly part of the base AltiVec API, such\n+--  as vector conversions to/from array representations, which are of interest\n+--  for client applications (e.g. for vector initialization purposes) and may\n+--  also be used as implementation facilities.\n+\n+-----------------------------------------\n+-- General package architecture survey --\n+-----------------------------------------\n+\n+--  The various vector representations are all \"containers\" of elementary\n+--  values, the possible types of which are declared in this root package to\n+--  be generally accessible.\n+\n+--  From the user standpoint, the two versions of the binding are available\n+--  through a consistent hierarchy of units providing identical services:\n+\n+--                             GNAT.Altivec\n+--                           (component types)\n+--                                   |\n+--          o----------------o----------------o-------------o\n+--          |                |                |             |\n+--    Vector_Types   Vector_Operations   Vector_Views   Conversions\n+\n+--  The user can manipulate vectors through two families of types: Vector\n+--  types and View types.\n+\n+--  Vector types are defined in the GNAT.Altivec.Vector_Types package\n+\n+--  On these types, the user can apply the Altivec operations defined in\n+--  GNAT.Altivec.Vector_Operations. Their layout is opaque and may vary across\n+--  configurations, for it is typically target-endianness dependant.\n+\n+--  Vector_Types and Vector_Operations implement the core binding to the\n+--  AltiVec API, as described in [PIM-2.1 data types] and [PIM-4 AltiVec\n+--  operations and predicates].\n+\n+--  View types are defined in the GNAT.Altivec.Vector_Views package\n+\n+--  These types do not represent Altivec vectors per se, in the sense that the\n+--  Altivec_Operations are not available for them. They are intended to allow\n+--  Vector initializations as well as access to the Vector component values.\n+\n+--  The GNAT.Altivec.Conversions package is provided to convert a View to the\n+--  corresponding Vector and vice-versa.\n+\n+--  The two versions of the binding rely on a low level internal interface,\n+--  and switching from one version to the other amounts to select one low\n+--  level implementation instead of the other.\n+\n+--  The bindings are provided as a set of sources together with a project file\n+--  (altivec.gpr). The hard/soft binding selection is controlled by a project\n+--  variable on targets where switching makes sense. See the example usage\n+--  section below.\n+\n+---------------------------\n+-- Underlying principles --\n+---------------------------\n+\n+--  The general organization sketched above has been devised from a number\n+--  of driving ideas:\n+\n+--  o From the clients standpoint, the two versions of the binding should be\n+--    as easily exchangable as possible,\n+\n+--  o From the maintenance standpoint, we want to avoid as much code\n+--    duplication as possible.\n+\n+--  o From both standpoints above, we want to maintain a clear interface\n+--    separation between the base bindings to the Motorola API and the\n+--    additional facilities.\n+\n+--  The identification of the low level interface is directly inspired by the\n+--  the base API organization, basically consisting of a rich set of functions\n+--  around a core of low level primitives mapping to AltiVec instructions.\n+\n+--  See for instance \"vec_add\" in [PIM-4.4 Generic and Specific AltiVec\n+--  operations]: no less than six result/arguments combinations of byte vector\n+--  types map to \"vaddubm\".\n+\n+--  The \"hard\" version of the low level primitives map to real AltiVec\n+--  instructions via the corresponding GCC builtins. The \"soft\" version is\n+--  a software emulation of those.\n+\n+-------------------\n+-- Example usage --\n+-------------------\n+\n+--  Here is a sample program declaring and initializing two vectors, 'add'ing\n+--  them and displaying the result components:\n+\n+--  with GNAT.Altivec.Vector_Types;      use GNAT.Altivec.Vector_Types;\n+--  with GNAT.Altivec.Vector_Operations; use GNAT.Altivec.Vector_Operations;\n+--  with GNAT.Altivec.Vector_Views;      use GNAT.Altivec.Vector_Views;\n+--  with GNAT.Altivec.Conversions;       use GNAT.Altivec.Conversions;\n+\n+--  use GNAT.Altivec;\n+\n+--  procedure Sample is\n+--     Va : Vector_Unsigned_Int := To_Vector ((Values => (1, 2, 3, 4)));\n+--     Vb : Vector_Unsigned_Int := To_Vector ((Values => (1, 2, 3, 4)));\n+\n+--     Vs : Vector_Unsigned_Int;\n+--     Vs_View : VUI_View;\n+--  begin\n+--     Vs := Vec_Add (Va, Vb);\n+--     Vs_View := To_View (Vs);\n+\n+--     for I in Vs_View.Values'Range loop\n+--        Put_Line (Unsigned_Int'Image (Vs_View.Values (I)));\n+--     end loop;\n+--  end;\n+\n+--  This currently requires the GNAT project management facilities to compile,\n+--  to automatically retrieve the set of necessary sources and switches\n+--  depending on your configuration. For the example above, customizing the\n+--  switches to include -g also, this would be something like:\n+\n+--  sample.gpr\n+--\n+--  with \"altivec.gpr\";\n+--\n+--  project Sample is\n+\n+--    for Source_Dirs use (\".\");\n+--    for Main use (\"sample\");\n+\n+--    package Compiler is\n+--       for Default_Switches (\"Ada\") use\n+--           Altivec.Compiler'Default_Switches (\"Ada\") & \"-g\";\n+--    end Compiler;\n+\n+--  end Sample;\n+\n+--  $ gnatmake -Psample\n+--  [...]\n+--  $ ./sample\n+--  2\n+--  4\n+--  6\n+--  8\n+\n+------------------------------------------------------------------------------\n+\n+with System;\n+\n+package GNAT.Altivec is\n+\n+   --  Definitions of constants and vector/array component types common to all\n+   --  the versions of the binding.\n+\n+   --  All the vector types are 128bits\n+\n+   VECTOR_BIT : constant := 128;\n+\n+   -------------------------------------------\n+   -- [PIM-2.3.1 Alignment of vector types] --\n+   -------------------------------------------\n+\n+   --  \"A defined data item of any vector data type in memory is always\n+   --  aligned on a 16-byte boundary. A pointer to any vector data type always\n+   --  points to a 16-byte boundary. The compiler is responsible for aligning\n+   --  vector data types on 16-byte boundaries.\"\n+\n+   VECTOR_ALIGNMENT : constant := 16;\n+\n+   -------------------------------------------------------\n+   -- [PIM-2.1] Data Types - Interpretation of contents --\n+   -------------------------------------------------------\n+\n+   ---------------------\n+   -- char components --\n+   ---------------------\n+\n+   CHAR_BIT    : constant := 8;\n+   SCHAR_MIN   : constant := -2 ** (CHAR_BIT - 1);\n+   SCHAR_MAX   : constant := 2 ** (CHAR_BIT - 1) - 1;\n+   UCHAR_MAX   : constant := 2 ** CHAR_BIT - 1;\n+\n+   type unsigned_char is mod UCHAR_MAX + 1;\n+   for unsigned_char'Size use CHAR_BIT;\n+\n+   type signed_char is range SCHAR_MIN .. SCHAR_MAX;\n+   for signed_char'Size use CHAR_BIT;\n+\n+   subtype bool_char is unsigned_char;\n+   --  ??? There is a difference here between what the Altivec Technology\n+   --  Programming Interface Manual says and what GCC says. In the manual,\n+   --  vector_bool_char is a vector_unsigned_char, while in altivec.h it\n+   --  is a vector_signed_char.\n+\n+   bool_char_True  : constant bool_char := bool_char'Last;\n+   bool_char_False : constant bool_char := 0;\n+\n+   ----------------------\n+   -- short components --\n+   ----------------------\n+\n+   SHORT_BIT   : constant := 16;\n+   SSHORT_MIN  : constant := -2 ** (SHORT_BIT - 1);\n+   SSHORT_MAX  : constant := 2 ** (SHORT_BIT - 1) - 1;\n+   USHORT_MAX  : constant := 2 ** SHORT_BIT - 1;\n+\n+   type unsigned_short is mod USHORT_MAX + 1;\n+   for unsigned_short'Size use SHORT_BIT;\n+\n+   subtype unsigned_short_int is unsigned_short;\n+\n+   type signed_short is range SSHORT_MIN .. SSHORT_MAX;\n+   for signed_short'Size use SHORT_BIT;\n+\n+   subtype signed_short_int is signed_short;\n+\n+   subtype bool_short is unsigned_short;\n+   --  ??? See bool_char\n+\n+   bool_short_True  : constant bool_short := bool_short'Last;\n+   bool_short_False : constant bool_short := 0;\n+\n+   subtype bool_short_int is bool_short;\n+\n+   --------------------\n+   -- int components --\n+   --------------------\n+\n+   INT_BIT     : constant := 32;\n+   SINT_MIN    : constant := -2 ** (INT_BIT - 1);\n+   SINT_MAX    : constant := 2 ** (INT_BIT - 1) - 1;\n+   UINT_MAX    : constant := 2 ** INT_BIT - 1;\n+\n+   type unsigned_int is mod UINT_MAX + 1;\n+   for unsigned_int'Size use INT_BIT;\n+\n+   type signed_int is range SINT_MIN .. SINT_MAX;\n+   for signed_int'Size use INT_BIT;\n+\n+   subtype bool_int is unsigned_int;\n+   --  ??? See bool_char\n+\n+   bool_int_True  : constant bool_int := bool_int'Last;\n+   bool_int_False : constant bool_int := 0;\n+\n+   ----------------------\n+   -- float components --\n+   ----------------------\n+\n+   FLOAT_BIT   : constant := 32;\n+   FLOAT_DIGIT : constant := 6;\n+   FLOAT_MIN   : constant := -16#0.FFFF_FF#E+32;\n+   FLOAT_MAX   : constant := 16#0.FFFF_FF#E+32;\n+\n+   type C_float is digits FLOAT_DIGIT range FLOAT_MIN .. FLOAT_MAX;\n+   for C_float'Size use FLOAT_BIT;\n+\n+   ----------------------\n+   -- pixel components --\n+   ----------------------\n+\n+   subtype pixel is unsigned_short;\n+\n+   -----------------------------------------------------------\n+   -- Subtypes for variants found in the GCC implementation --\n+   -----------------------------------------------------------\n+\n+   subtype c_int is signed_int;\n+   subtype c_short is c_int;\n+\n+   LONG_BIT  : constant := 32;\n+   --  Some of the GCC builtins are built with \"long\" arguments and\n+   --  expect SImode to come in.\n+\n+   SLONG_MIN : constant := -2 ** (LONG_BIT - 1);\n+   SLONG_MAX : constant :=  2 ** (LONG_BIT - 1) - 1;\n+   ULONG_MAX : constant :=  2 ** LONG_BIT - 1;\n+\n+   type signed_long   is range SLONG_MIN .. SLONG_MAX;\n+   type unsigned_long is mod ULONG_MAX + 1;\n+\n+   subtype c_long is signed_long;\n+\n+   subtype c_ptr is System.Address;\n+\n+   ---------------------------------------------------------\n+   -- Access types, for the sake of some argument passing --\n+   ---------------------------------------------------------\n+\n+   type signed_char_ptr    is access all signed_char;\n+   type unsigned_char_ptr  is access all unsigned_char;\n+\n+   type short_ptr          is access all c_short;\n+   type signed_short_ptr   is access all signed_short;\n+   type unsigned_short_ptr is access all unsigned_short;\n+\n+   type int_ptr            is access all c_int;\n+   type signed_int_ptr     is access all signed_int;\n+   type unsigned_int_ptr   is access all unsigned_int;\n+\n+   type long_ptr           is access all c_long;\n+   type signed_long_ptr    is access all signed_long;\n+   type unsigned_long_ptr  is access all unsigned_long;\n+\n+   type float_ptr          is access all Float;\n+\n+   --\n+\n+   type const_signed_char_ptr    is access constant signed_char;\n+   type const_unsigned_char_ptr  is access constant unsigned_char;\n+\n+   type const_short_ptr          is access constant c_short;\n+   type const_signed_short_ptr   is access constant signed_short;\n+   type const_unsigned_short_ptr is access constant unsigned_short;\n+\n+   type const_int_ptr            is access constant c_int;\n+   type const_signed_int_ptr     is access constant signed_int;\n+   type const_unsigned_int_ptr   is access constant unsigned_int;\n+\n+   type const_long_ptr           is access constant c_long;\n+   type const_signed_long_ptr    is access constant signed_long;\n+   type const_unsigned_long_ptr  is access constant unsigned_long;\n+\n+   type const_float_ptr          is access constant Float;\n+\n+   --  Access to const volatile arguments need specialized types\n+\n+   type volatile_float is new Float;\n+   pragma Volatile (volatile_float);\n+\n+   type volatile_signed_char is new signed_char;\n+   pragma Volatile (volatile_signed_char);\n+\n+   type volatile_unsigned_char is new unsigned_char;\n+   pragma Volatile (volatile_unsigned_char);\n+\n+   type volatile_signed_short is new signed_short;\n+   pragma Volatile (volatile_signed_short);\n+\n+   type volatile_unsigned_short is new unsigned_short;\n+   pragma Volatile (volatile_unsigned_short);\n+\n+   type volatile_signed_int is new signed_int;\n+   pragma Volatile (volatile_signed_int);\n+\n+   type volatile_unsigned_int is new unsigned_int;\n+   pragma Volatile (volatile_unsigned_int);\n+\n+   type volatile_signed_long is new signed_long;\n+   pragma Volatile (volatile_signed_long);\n+\n+   type volatile_unsigned_long is new unsigned_long;\n+   pragma Volatile (volatile_unsigned_long);\n+\n+   type constv_char_ptr           is access constant volatile_signed_char;\n+   type constv_signed_char_ptr    is access constant volatile_signed_char;\n+   type constv_unsigned_char_ptr  is access constant volatile_unsigned_char;\n+\n+   type constv_short_ptr          is access constant volatile_signed_short;\n+   type constv_signed_short_ptr   is access constant volatile_signed_short;\n+   type constv_unsigned_short_ptr is access constant volatile_unsigned_short;\n+\n+   type constv_int_ptr            is access constant volatile_signed_int;\n+   type constv_signed_int_ptr     is access constant volatile_signed_int;\n+   type constv_unsigned_int_ptr   is access constant volatile_unsigned_int;\n+\n+   type constv_long_ptr           is access constant volatile_signed_long;\n+   type constv_signed_long_ptr    is access constant volatile_signed_long;\n+   type constv_unsigned_long_ptr  is access constant volatile_unsigned_long;\n+\n+   type constv_float_ptr  is access constant volatile_float;\n+\n+private\n+\n+   -----------------------\n+   -- Various constants --\n+   -----------------------\n+\n+   CR6_EQ     : constant := 0;\n+   CR6_EQ_REV : constant := 1;\n+   CR6_LT     : constant := 2;\n+   CR6_LT_REV : constant := 3;\n+\n+end GNAT.Altivec;"}, {"sha": "62e0b1712a62f4a9796d6a14affd88da2b023512", "filename": "gcc/ada/g-alveop.adb", "status": "added", "additions": 9704, "deletions": 0, "changes": 9704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alveop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alveop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alveop.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523"}, {"sha": "7e77d7f48f121bfccc9a45c8abf83b8b71428435", "filename": "gcc/ada/g-alveop.ads", "status": "added", "additions": 8105, "deletions": 0, "changes": 8105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alveop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alveop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alveop.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523"}, {"sha": "03b637e0da25b374af2c53e2b453bdba264ca40c", "filename": "gcc/ada/g-alvety.ads", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alvety.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alvety.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alvety.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,152 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . A L T I V E C . V E C T O R _ T Y P E S             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit exposes the various vector types part of the Ada binding to\n+--  Altivec facilities.\n+\n+with GNAT.Altivec.Low_Level_Vectors;\n+\n+package GNAT.Altivec.Vector_Types is\n+\n+   use GNAT.Altivec.Low_Level_Vectors;\n+\n+   ---------------------------------------------------\n+   -- Vector type declarations [PIM-2.1 Data Types] --\n+   ---------------------------------------------------\n+\n+   --  Except for assignments and pointer creation/dereference, operations\n+   --  on vectors are only performed via subprograms. The vector types are\n+   --  then private, and non-limited since assignments are allowed.\n+\n+   --  The Hard/Soft binding type-structure differentiation is achieved in\n+   --  Low_Level_Vectors. Each version only exposes private vector types, that\n+   --  we just sub-type here. This is fine from the design standpoint and\n+   --  reduces the amount of explicit conversion required in various places\n+   --  internally.\n+\n+   subtype vector_unsigned_char is Low_Level_Vectors.LL_VUC;\n+   subtype vector_signed_char is Low_Level_Vectors.LL_VSC;\n+   subtype vector_bool_char is Low_Level_Vectors.LL_VBC;\n+\n+   subtype vector_unsigned_short is Low_Level_Vectors.LL_VUS;\n+   subtype vector_signed_short is Low_Level_Vectors.LL_VSS;\n+   subtype vector_bool_short is Low_Level_Vectors.LL_VBS;\n+\n+   subtype vector_unsigned_int is Low_Level_Vectors.LL_VUI;\n+   subtype vector_signed_int is Low_Level_Vectors.LL_VSI;\n+   subtype vector_bool_int is Low_Level_Vectors.LL_VBI;\n+\n+   subtype vector_float is Low_Level_Vectors.LL_VF;\n+   subtype vector_pixel is Low_Level_Vectors.LL_VP;\n+\n+   --  [PIM-2.1] shows groups of declarations with exact same component types,\n+   --  e.g. vector unsigned short together with vector unsigned short int. It\n+   --  so appears tempting to define subtypes for those matches here.\n+   --\n+   --  [PIM-2.1] does not qualify items in those groups as \"the same types\",\n+   --  though, and [PIM-2.4.2 Assignments] reads: \"if either the left hand\n+   --  side or the right hand side of an expression has a vector type, then\n+   --  both sides of the expression must be of the same vector type\".\n+   --\n+   --  Not so clear what is exactly right, then. We go with subtypes for now\n+   --  and can adjust later if need be.\n+\n+   subtype vector_unsigned_short_int is vector_unsigned_short;\n+   subtype vector_signed_short_int is vector_signed_short;\n+\n+   subtype vector_char is vector_signed_char;\n+   subtype vector_short is vector_signed_short;\n+   subtype vector_int is vector_signed_int;\n+\n+   --------------------------------\n+   -- Corresponding access types --\n+   --------------------------------\n+\n+   type vector_unsigned_char_ptr is access all vector_unsigned_char;\n+   type vector_signed_char_ptr is access all vector_signed_char;\n+   type vector_bool_char_ptr is access all vector_bool_char;\n+\n+   type vector_unsigned_short_ptr is access all vector_unsigned_short;\n+   type vector_signed_short_ptr is access all vector_signed_short;\n+   type vector_bool_short_ptr is access all vector_bool_short;\n+\n+   type vector_unsigned_int_ptr is access all vector_unsigned_int;\n+   type vector_signed_int_ptr is access all vector_signed_int;\n+   type vector_bool_int_ptr is access all vector_bool_int;\n+\n+   type vector_float_ptr is access all vector_float;\n+   type vector_pixel_ptr is access all vector_pixel;\n+\n+   --------------------------------------------------------------------\n+   -- Additional access types, for the sake of some argument passing --\n+   --------------------------------------------------------------------\n+\n+   --  ... because some of the operations expect pointers to possibly\n+   --  constant objects.\n+\n+   type const_vector_bool_char_ptr     is access constant vector_bool_char;\n+   type const_vector_signed_char_ptr   is access constant vector_signed_char;\n+   type const_vector_unsigned_char_ptr is access constant vector_unsigned_char;\n+\n+   type const_vector_bool_short_ptr     is access constant vector_bool_short;\n+   type const_vector_signed_short_ptr   is access constant vector_signed_short;\n+   type const_vector_unsigned_short_ptr is access\n+     constant vector_unsigned_short;\n+\n+   type const_vector_bool_int_ptr     is access constant vector_bool_int;\n+   type const_vector_signed_int_ptr   is access constant vector_signed_int;\n+   type const_vector_unsigned_int_ptr is access constant vector_unsigned_int;\n+\n+   type const_vector_float_ptr is access constant vector_float;\n+   type const_vector_pixel_ptr is access constant vector_pixel;\n+\n+   ----------------------\n+   -- Useful shortcuts --\n+   ----------------------\n+\n+   subtype VUC is vector_unsigned_char;\n+   subtype VSC is vector_signed_char;\n+   subtype VBC is vector_bool_char;\n+\n+   subtype VUS is vector_unsigned_short;\n+   subtype VSS is vector_signed_short;\n+   subtype VBS is vector_bool_short;\n+\n+   subtype VUI is vector_unsigned_int;\n+   subtype VSI is vector_signed_int;\n+   subtype VBI is vector_bool_int;\n+\n+   subtype VP is vector_pixel;\n+   subtype VF is vector_float;\n+\n+end GNAT.Altivec.Vector_Types;"}, {"sha": "bd3a299e2f9a221e3c3d55ceb64a990dc3dad9a8", "filename": "gcc/ada/g-alvevi.ads", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alvevi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fg-alvevi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alvevi.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -0,0 +1,158 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--            G N A T . A L T I V E C . V E C T O R _ V I E W S             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit provides public 'View' data types from/to which private vector\n+--  representations can be converted via Altivec.Conversions. This allows\n+--  convenient access to individual vector elements and provides a simple way\n+--  to initialize vector objects.\n+\n+--  Accessing vector contents with direct memory overlays should be avoided\n+--  because actual vector representations may vary across configurations, for\n+--  instance to accomodate different target endianness.\n+\n+--  The natural representation of a vector is an array indexed by vector\n+--  component number, which is materialized by the Varray type definitions\n+--  below. The 16byte alignment constraint is unfortunately sometimes not\n+--  properly honored for constant array aggregates, so the View types are\n+--  actually records enclosing such arrays.\n+\n+package GNAT.Altivec.Vector_Views is\n+\n+   ---------------------\n+   -- char components --\n+   ---------------------\n+\n+   type Vchar_Range is range 1 .. 16;\n+\n+   type Varray_unsigned_char is array (Vchar_Range) of unsigned_char;\n+   for Varray_unsigned_char'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VUC_View is record\n+      Values : Varray_unsigned_char;\n+   end record;\n+\n+   type Varray_signed_char is array (Vchar_Range) of signed_char;\n+   for Varray_signed_char'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VSC_View is record\n+      Values : Varray_signed_char;\n+   end record;\n+\n+   type Varray_bool_char is array (Vchar_Range) of bool_char;\n+   for Varray_bool_char'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VBC_View is record\n+      Values : Varray_bool_char;\n+   end record;\n+\n+   ----------------------\n+   -- short components --\n+   ----------------------\n+\n+   type Vshort_Range is range 1 .. 8;\n+\n+   type Varray_unsigned_short is array (Vshort_Range) of unsigned_short;\n+   for Varray_unsigned_short'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VUS_View is record\n+      Values : Varray_unsigned_short;\n+   end record;\n+\n+   type Varray_signed_short is array (Vshort_Range) of signed_short;\n+   for Varray_signed_short'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VSS_View is record\n+      Values : Varray_signed_short;\n+   end record;\n+\n+   type Varray_bool_short is array (Vshort_Range) of bool_short;\n+   for Varray_bool_short'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VBS_View is record\n+      Values : Varray_bool_short;\n+   end record;\n+\n+   --------------------\n+   -- int components --\n+   --------------------\n+\n+   type Vint_Range is range 1 .. 4;\n+\n+   type Varray_unsigned_int is array (Vint_Range) of unsigned_int;\n+   for Varray_unsigned_int'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VUI_View is record\n+      Values : Varray_unsigned_int;\n+   end record;\n+\n+   type Varray_signed_int is array (Vint_Range) of signed_int;\n+   for Varray_signed_int'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VSI_View is record\n+      Values : Varray_signed_int;\n+   end record;\n+\n+   type Varray_bool_int is array (Vint_Range) of bool_int;\n+   for Varray_bool_int'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VBI_View is record\n+      Values : Varray_bool_int;\n+   end record;\n+\n+   ----------------------\n+   -- float components --\n+   ----------------------\n+\n+   type Vfloat_Range is range 1 .. 4;\n+\n+   type Varray_float is array (Vfloat_Range) of C_float;\n+   for Varray_float'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VF_View is record\n+      Values : Varray_float;\n+   end record;\n+\n+   ----------------------\n+   -- pixel components --\n+   ----------------------\n+\n+   type Vpixel_Range is range 1 .. 8;\n+\n+   type Varray_pixel is array (Vpixel_Range) of pixel;\n+   for Varray_pixel'Alignment use VECTOR_ALIGNMENT;\n+\n+   type VP_View is record\n+      Values : Varray_pixel;\n+   end record;\n+\n+end GNAT.Altivec.Vector_Views;"}, {"sha": "5fca8158a474d68a383f5194f3e0b63d61298390", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -195,6 +195,11 @@ package body Impunit is\n    -- GNAT Library Units --\n    ------------------------\n \n+     \"g-altive\",    -- GNAT.Altivec\n+     \"g-alvety\",    -- GNAT.Altivec.Vector_Types\n+     \"g-alvevi\",    -- GNAT.Altivec.Vector_Views\n+     \"g-alveop\",    -- GNAT.Altivec.Vector_Operations\n+     \"g-altcon\",    -- GNAT.Altivec.Conversions\n      \"g-arrspl\",    -- GNAT.Array_Split\n      \"g-awk   \",    -- GNAT.AWK\n      \"g-boubuf\",    -- GNAT.Bounded_Buffers\n@@ -359,12 +364,13 @@ package body Impunit is\n      \"a-stzmap\",    -- Ada.Strings.Wide_Wide_Maps\n      \"a-stzunb\",    -- Ada.Strings.Wide_Wide_Unbounded\n      \"a-swuwha\",    -- Ada.Strings.Wide_Unbounded.Wide_Hash\n-     \"a-szmzco\",    -- Ada.Strings.Wide_Wide_Maps.Wide_Wide_Constants;\n+     \"a-szmzco\",    -- Ada.Strings.Wide_Wide_Maps.Wide_Wide_Constants\n      \"a-szuzha\",    -- Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Hash\n-     \"a-tgdico\",    -- Ada.Tags.Generic_Dispatching_Constructor;\n-     \"a-tiunio\",    -- Ada.Text_IO.Unbounded_IO;\n+     \"a-taster\",    -- Ada.Task_Termination\n+     \"a-tgdico\",    -- Ada.Tags.Generic_Dispatching_Constructor\n+     \"a-tiunio\",    -- Ada.Text_IO.Unbounded_IO\n      \"a-wichun\",    -- Ada.Wide_Characters.Unicode\n-     \"a-wwunio\",    -- Ada.Wide_Text_IO.Wide_Unbounded_IO;\n+     \"a-wwunio\",    -- Ada.Wide_Text_IO.Wide_Unbounded_IO\n      \"a-zchara\",    -- Ada.Wide_Wide_Characters\n      \"a-zttest\",    -- Ada.Wide_Wide_Text_IO.Text_Streams\n      \"a-ztexio\",    -- Ada.Wide_Wide_Text_IO"}, {"sha": "f125939ddc2665feb32b02102d4297daf9fb8e89", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -344,6 +344,17 @@ package Opt is\n    --  Set True for dynamic elaboration checking mode, as set by the -gnatE\n    --  switch or by the use of pragma Elaboration_Checks (Dynamic).\n \n+   Dynamic_Stack_Measurement : Boolean := False;\n+   --  GNATBIND\n+   --  Set True to enable dynamic stack measurement (-u flag for gnatbind)\n+\n+   Dynamic_Stack_Measurement_Array_Size : Nat := 100;\n+   --  GNATBIND\n+   --  Number of measurements we want to store during dynamic stack analysis.\n+   --  When the buffer is full, non-storable results will be output on the fly.\n+   --  The value is relevant only if Dynamic_Stack_Measurement is set. Set\n+   --  by processing of -u flag for gnatbind.\n+\n    Elab_Dependency_Output : Boolean := False;\n    --  GNATBIND\n    --  Set to True to output complete list of elaboration constraints\n@@ -687,15 +698,6 @@ package Opt is\n    --  extension, as set by the appropriate switch. If no switch is given,\n    --  then this value is initialized by Osint to the appropriate value.\n \n-   Max_Line_Length : Int := Hostparm.Max_Line_Length;\n-   --  This is a copy of Max_Line_Length used by the scanner. It is usually\n-   --  set to be a copy of Hostparm.Max_Line_Length, and is used to check\n-   --  the maximum line length in the scanner when style checking is inactive.\n-   --  The only time it is set to a different value is during the scanning of\n-   --  configuration pragma files, where we want to turn off all checking and\n-   --  in particular we want to allow long lines. So we reset this value to\n-   --  Column_Number'Last during scanning of configuration pragma files.\n-\n    Maximum_Processes : Positive := 1;\n    --  GNATMAKE, GPRMAKE\n    --  Maximum number of processes that should be spawned to carry out"}, {"sha": "712bb127b685bcd988ce18d69024d36882ab3d9f", "filename": "gcc/ada/s-finimp.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-finimp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-finimp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -594,6 +594,6 @@ package body System.Finalization_Implementation is\n --  Initialization of package, set Adafinal soft link\n \n begin\n-   SSL.Adafinal := Finalize_Global_List'Access;\n+   SSL.Finalize_Global_List := Finalize_Global_List'Access;\n \n end System.Finalization_Implementation;"}, {"sha": "264976b45914fb26d1db187dea9bc64771abc66b", "filename": "gcc/ada/s-io.adb", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-io.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-io.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-io.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,10 @@\n \n package body System.IO is\n \n+   Current_Out : File_Type := Stdout;\n+   pragma Atomic (Current_Out);\n+   --  Current output file (modified by Set_Output)\n+\n    --------------\n    -- New_Line --\n    --------------\n@@ -49,21 +53,35 @@ package body System.IO is\n    ---------\n \n    procedure Put (X : Integer) is\n-\n       procedure Put_Int (X : Integer);\n       pragma Import (C, Put_Int, \"put_int\");\n \n+      procedure Put_Int_Err (X : Integer);\n+      pragma Import (C, Put_Int_Err, \"put_int_stderr\");\n+\n    begin\n-      Put_Int (X);\n+      case Current_Out is\n+         when Stdout =>\n+            Put_Int (X);\n+         when Stderr =>\n+            Put_Int_Err (X);\n+      end case;\n    end Put;\n \n    procedure Put (C : Character) is\n-\n       procedure Put_Char (C : Character);\n       pragma Import (C, Put_Char, \"put_char\");\n \n+      procedure Put_Char_Stderr (C : Character);\n+      pragma Import (C, Put_Char_Stderr, \"put_char_stderr\");\n+\n    begin\n-      Put_Char (C);\n+      case Current_Out is\n+         when Stdout =>\n+            Put_Char (C);\n+         when Stderr =>\n+            Put_Char_Stderr (C);\n+      end case;\n    end Put;\n \n    procedure Put (S : String) is\n@@ -83,4 +101,31 @@ package body System.IO is\n       New_Line;\n    end Put_Line;\n \n+   ---------------------\n+   -- Standard_Output --\n+   ---------------------\n+\n+   function Standard_Output return File_Type is\n+   begin\n+      return Stdout;\n+   end Standard_Output;\n+\n+   --------------------\n+   -- Standard_Error --\n+   --------------------\n+\n+   function Standard_Error return File_Type is\n+   begin\n+      return Stderr;\n+   end Standard_Error;\n+\n+   ----------------\n+   -- Set_Output --\n+   ----------------\n+\n+   procedure Set_Output (File : in File_Type) is\n+   begin\n+      Current_Out := File;\n+   end Set_Output;\n+\n end System.IO;"}, {"sha": "7ab099b847325adf908eb7e6862d554082365c98", "filename": "gcc/ada/s-io.ads", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-io.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,4 +48,19 @@ package System.IO is\n \n    procedure New_Line (Spacing : Positive := 1);\n \n+   type File_Type is limited private;\n+\n+   function Standard_Error return File_Type;\n+   function Standard_Output return File_Type;\n+\n+   procedure Set_Output (File : in File_Type);\n+\n+private\n+\n+   type File_Type is (Stdout, Stderr);\n+   --  Stdout = Standard_Output, Stderr = Standard_Error\n+\n+   pragma Inline (Standard_Error);\n+   pragma Inline (Standard_Output);\n+\n end System.IO;"}, {"sha": "8c32568a1253a9d34db17755d0a234454aab91c3", "filename": "gcc/ada/s-soflin.adb", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-soflin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-soflin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -83,6 +83,25 @@ package body System.Soft_Links is\n       null;\n    end Abort_Undefer_NT;\n \n+   -----------------\n+   -- Adafinal_NT --\n+   -----------------\n+\n+   procedure Adafinal_NT is\n+   begin\n+      --  Handle normal task termination by the environment task, but only\n+      --  for the normal task termination. In the case of Abnormal and\n+      --  Unhandled_Exception they must have been handled before, and the\n+      --  task termination soft link must have been changed so the task\n+      --  termination routine is not executed twice.\n+\n+      Task_Termination_Handler.all (Ada.Exceptions.Null_Occurrence);\n+\n+      --  Finalize the global list for controlled objects if needed\n+\n+      Finalize_Global_List.all;\n+   end Adafinal_NT;\n+\n    ---------------------------\n    -- Check_Abort_Status_NT --\n    ---------------------------\n@@ -226,14 +245,14 @@ package body System.Soft_Links is\n       return NT_TSD.Pri_Stack_Info'Access;\n    end Get_Stack_Info_NT;\n \n-   -------------------\n-   -- Null_Adafinal --\n-   -------------------\n+   -------------------------------\n+   -- Null_Finalize_Global_List --\n+   -------------------------------\n \n-   procedure Null_Adafinal is\n+   procedure Null_Finalize_Global_List is\n    begin\n       null;\n-   end Null_Adafinal;\n+   end Null_Finalize_Global_List;\n \n    ---------------------------\n    -- Set_Jmpbuf_Address_NT --\n@@ -285,6 +304,16 @@ package body System.Soft_Links is\n       null;\n    end Task_Unlock_NT;\n \n+   -------------------------\n+   -- Task_Termination_NT --\n+   -------------------------\n+\n+   procedure Task_Termination_NT (Excep : EO) is\n+      pragma Warnings (Off, Excep);\n+   begin\n+      null;\n+   end Task_Termination_NT;\n+\n    -------------------------\n    -- Update_Exception_NT --\n    -------------------------"}, {"sha": "2abe631a41823ae827dc49cc013c6a01f366d5d4", "filename": "gcc/ada/s-soflin.ads", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-soflin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-soflin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -62,6 +62,7 @@ package System.Soft_Links is\n \n    type No_Param_Proc     is access procedure;\n    type Addr_Param_Proc   is access procedure (Addr : Address);\n+   type EO_Param_Proc     is access procedure (Excep : EO);\n \n    type Get_Address_Call  is access function return Address;\n    type Set_Address_Call  is access procedure (Addr : Address);\n@@ -92,6 +93,7 @@ package System.Soft_Links is\n \n    pragma Suppress (Access_Check, No_Param_Proc);\n    pragma Suppress (Access_Check, Addr_Param_Proc);\n+   pragma Suppress (Access_Check, EO_Param_Proc);\n    pragma Suppress (Access_Check, Get_Address_Call);\n    pragma Suppress (Access_Check, Set_Address_Call);\n    pragma Suppress (Access_Check, Set_Address_Call2);\n@@ -139,9 +141,15 @@ package System.Soft_Links is\n    procedure Task_Unlock_NT;\n    --  Release lock set by Task_Lock (non-tasking case, does nothing)\n \n-   procedure Null_Adafinal;\n-   --  Shuts down the runtime system (non-tasking no-finalization case,\n-   --  does nothing)\n+   procedure Task_Termination_NT (Excep : EO);\n+   --  Handle task termination routines for the environment task (non-tasking\n+   --  case, does nothing).\n+\n+   procedure Null_Finalize_Global_List;\n+   --  Finalize global list for controlled objects (does nothing)\n+\n+   procedure Adafinal_NT;\n+   --  Shuts down the runtime system (non-tasking case)\n \n    Abort_Defer : No_Param_Proc := Abort_Defer_NT'Access;\n    pragma Suppress (Access_Check, Abort_Defer);\n@@ -197,7 +205,13 @@ package System.Soft_Links is\n    --  This ensures that the lock is not left set if an exception is raised\n    --  explicitly or implicitly during the critical locked region.\n \n-   Adafinal : No_Param_Proc := Null_Adafinal'Access;\n+   Task_Termination_Handler : EO_Param_Proc := Task_Termination_NT'Access;\n+   --  Handle task termination routines (task/non-task case as appropriate)\n+\n+   Finalize_Global_List : No_Param_Proc := Null_Finalize_Global_List'Access;\n+   --  Performs finalization of global list for controlled objects\n+\n+   Adafinal : No_Param_Proc := Adafinal_NT'Access;\n    --  Performs the finalization of the Ada Runtime\n \n    function  Get_Jmpbuf_Address_NT return  Address;"}, {"sha": "5c4b9ed6219017a7973521cf219abcc18a6afef9", "filename": "gcc/ada/s-solita.adb", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -46,12 +46,25 @@ with System.Task_Primitives.Operations;\n \n with System.Tasking;\n --  Used for Task_Id\n+--           Cause_Of_Termination\n+\n+with Ada.Exceptions;\n+--  Used for Exception_Id\n+--           Exception_Occurrence\n+--           Save_Occurrence\n+\n+with Ada.Exceptions.Is_Null_Occurrence;\n \n package body System.Soft_Links.Tasking is\n \n    package STPO renames System.Task_Primitives.Operations;\n    package SSL  renames System.Soft_Links;\n \n+   use Ada.Exceptions;\n+\n+   use type System.Tasking.Task_Id;\n+   use type System.Tasking.Termination_Handler;\n+\n    ----------------\n    -- Local Data --\n    ----------------\n@@ -78,6 +91,9 @@ package body System.Soft_Links.Tasking is\n    procedure Timed_Delay_T (Time : Duration; Mode : Integer);\n    --  Task-safe version of SSL.Timed_Delay\n \n+   procedure Task_Termination_Handler_T  (Excep : SSL.EO);\n+   --  Task-safe version of the task termination procedure\n+\n    --------------------------\n    -- Soft-Link Get Bodies --\n    --------------------------\n@@ -134,6 +150,48 @@ package body System.Soft_Links.Tasking is\n       end if;\n    end Timed_Delay_T;\n \n+   --------------------------------\n+   -- Task_Termination_Handler_T --\n+   --------------------------------\n+\n+   procedure Task_Termination_Handler_T (Excep : SSL.EO) is\n+      Self_Id : constant System.Tasking.Task_Id := STPO.Self;\n+      Cause   : System.Tasking.Cause_Of_Termination;\n+      EO      : Ada.Exceptions.Exception_Occurrence;\n+\n+   begin\n+      --  We can only be here because we are terminating the environment task.\n+      --  Task termination for the rest of the tasks is handled in the\n+      --  Task_Wrapper.\n+\n+      pragma Assert (Self_Id = STPO.Environment_Task);\n+\n+      --  Normal task termination\n+\n+      if Is_Null_Occurrence (Excep) then\n+         Cause := System.Tasking.Normal;\n+         Ada.Exceptions.Save_Occurrence (EO, Ada.Exceptions.Null_Occurrence);\n+\n+      --  Abnormal task termination\n+\n+      elsif Exception_Identity (Excep) = Standard'Abort_Signal'Identity then\n+         Cause := System.Tasking.Abnormal;\n+         Ada.Exceptions.Save_Occurrence (EO, Ada.Exceptions.Null_Occurrence);\n+\n+      --  Termination because of an unhandled exception\n+\n+      else\n+         Cause := System.Tasking.Unhandled_Exception;\n+         Ada.Exceptions.Save_Occurrence (EO, Excep);\n+      end if;\n+\n+      if Self_Id.Common.Specific_Handler /= null then\n+         Self_Id.Common.Specific_Handler.all (Cause, Self_Id, EO);\n+      elsif Self_Id.Common.Fall_Back_Handler /= null then\n+         Self_Id.Common.Fall_Back_Handler.all (Cause, Self_Id, EO);\n+      end if;\n+   end Task_Termination_Handler_T;\n+\n    -----------------------------\n    -- Init_Tasking_Soft_Links --\n    -----------------------------\n@@ -151,12 +209,13 @@ package body System.Soft_Links.Tasking is\n          --  The application being executed uses tasking so that the tasking\n          --  version of the following soft links need to be used.\n \n-         SSL.Get_Jmpbuf_Address     := Get_Jmpbuf_Address'Access;\n-         SSL.Set_Jmpbuf_Address     := Set_Jmpbuf_Address'Access;\n-         SSL.Get_Sec_Stack_Addr     := Get_Sec_Stack_Addr'Access;\n-         SSL.Set_Sec_Stack_Addr     := Set_Sec_Stack_Addr'Access;\n-         SSL.Get_Current_Excep      := Get_Current_Excep'Access;\n-         SSL.Timed_Delay            := Timed_Delay_T'Access;\n+         SSL.Get_Jmpbuf_Address       := Get_Jmpbuf_Address'Access;\n+         SSL.Set_Jmpbuf_Address       := Set_Jmpbuf_Address'Access;\n+         SSL.Get_Sec_Stack_Addr       := Get_Sec_Stack_Addr'Access;\n+         SSL.Set_Sec_Stack_Addr       := Set_Sec_Stack_Addr'Access;\n+         SSL.Get_Current_Excep        := Get_Current_Excep'Access;\n+         SSL.Timed_Delay              := Timed_Delay_T'Access;\n+         SSL.Task_Termination_Handler := Task_Termination_Handler_T'Access;\n \n          --  No need to create a new Secondary Stack, since we will use the\n          --  default one created in s-secsta.adb"}, {"sha": "72242c20677342ff5b17ec8ce4b031dd32f431c7", "filename": "gcc/ada/s-stausa.ads", "status": "modified", "additions": 195, "deletions": 141, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -36,6 +36,7 @@ with System.Storage_Elements;\n with System.Address_To_Access_Conversions;\n \n package System.Stack_Usage is\n+   pragma Preelaborate;\n \n    package SSE renames System.Storage_Elements;\n \n@@ -46,46 +47,43 @@ package System.Stack_Usage is\n    for Word_32'Alignment use 4;\n \n    subtype Stack_Address is SSE.Integer_Address;\n-   --  Address on the stack.\n+   --  Address on the stack\n    --\n-   --  NOTE:\n-   --  *****\n-   --\n-   --  in this package, when comparing two addresses on the\n-   --  stack, the comments use the terms \"outer\", \"inner\", \"outermost\"\n-   --  and \"innermost\" instead of the ambigous \"higher\", \"lower\",\n-   --  \"highest\" and \"lowest\". \"inner\" means \"closer to the bottom of\n-   --  stack\" and is the contrary of \"outer\". \"innermost\" means \"closest\n-   --  address to the bottom of stack\". The stack is growing from the\n-   --  innermost addresses to the outermost addresses.\n+   --  Note: in this package, when comparing two addresses on the stack, the\n+   --  comments use the terms \"outer\", \"inner\", \"outermost\" and \"innermost\"\n+   --  instead of the ambigous \"higher\", \"lower\", \"highest\" and \"lowest\".\n+   --  \"inner\" means \"closer to the bottom of stack\" and is the contrary of\n+   --  \"outer\". \"innermost\" means \"closest address to the bottom of stack\". The\n+   --  stack is growing from the inner to the outer.\n+\n+   --  Top/Bottom would be much better than inner and outer ???\n \n-   function To_Stack_Address (Value : Address) return Stack_Address\n-     renames System.Storage_Elements.To_Integer;\n+   function To_Stack_Address (Value : System.Address) return Stack_Address\n+                              renames System.Storage_Elements.To_Integer;\n \n    type Stack_Analyzer is private;\n    --  Type of the stack analyzer tool. It is used to fill a portion of\n    --  the stack with Pattern, and to compute the stack used after some\n    --  execution.\n-   --\n-   --  USAGE:\n-   --  ******\n-   --\n-   --  --  A typical use of the package is something like:\n-   --\n+\n+   --  Usage:\n+\n+   --  A typical use of the package is something like:\n+\n    --  A : Stack_Analyzer;\n-   --\n+\n    --  task T is\n    --     pragma Storage_Size (A_Storage_Size);\n    --  end T;\n-   --\n+\n    --  [...]\n-   --\n+\n    --     Bottom_Of_Stack : aliased Integer;\n    --     --  Bottom_Of_Stack'Address will be used as an approximation of\n    --     --  the bottom of stack. A good practise is to avoid allocating\n    --     --  other local variables on this stack, as it would degrade\n    --     --  the quality of this approximation.\n-   --\n+\n    --  begin\n    --     Initialize_Analyzer (A,\n    --                          \"Task t\",\n@@ -96,92 +94,112 @@ package System.Stack_Usage is\n    --     Compute_Result (A);\n    --     Report_Result (A);\n    --  end T;\n-   --\n-   --\n+\n    --  Errors:\n-   --  *******\n    --\n    --  We are instrumenting the code to measure the stack used by the user\n    --  code. This method has a number of systematic errors, but several\n    --  methods can be used to evaluate or reduce those errors. Here are\n    --  those errors and the strategy that we use to deal with them:\n-   --\n-   --  * Bottom offset:\n-   --   - Description: The procedure used to fill the stack with a given\n-   --   pattern will itself have a stack frame. The value of the stack pointer\n-   --   in this procedure is, therefore, different from the value before the\n-   --   call to the instrumentation procedure.\n-   --   - Strategy: The user of this package shall measure the bottom of stack\n-   --   before the call to Fill_Stack and pass it in parameter.\n-   --\n-   --  * Instrumentation threshold at writing:\n-   --   - Description: The procedure used to fill the stack with a given\n-   --   pattern will itself have a stack frame.  Therefore, it will\n-   --   fill the stack after this stack frame. This part of the stack will\n-   --   appear as used in the final measure.\n-   --   - Strategy: As the user pass the value of the bottom of stack to\n-   --   the instrumentation to deal with the bottom offset error, and as\n-   --   as the instrumentation procedure knows where the pattern filling\n-   --   start on the stack, the difference between the two values is the\n-   --   minimum stack usage that the method can measure. If, when the results\n-   --   are computed, the pattern zone has been left untouched, we conclude\n-   --   that the stack usage is inferior to this minimum stack usage.\n-   --\n-   --  * Instrumentation threshold at reading:\n-   --   - Description: The procedure used to read the stack at the end of the\n-   --   execution clobbers the stack by allocating its stack frame. If this\n-   --   stack frame is bigger than the total stack used by the user code at\n-   --   this point, it will increase the measured stack size.\n-   --   - Strategy: We could augment this stack frame and see if it changes the\n-   --   measure. However, this error should be negligeable.\n-   --\n-   --   * Pattern zone overflow:\n-   --    - Description: The stack grows outer than the outermost bound of the\n-   --    pattern zone. In that case, the outermost region modified in the\n-   --    pattern is not the maximum value of the stack pointer during the\n-   --    execution.\n-   --    - Strategy: At the end of the execution, the difference between the\n-   --    outermost memory region modified in the pattern zone and the\n-   --    outermost bound of the pattern zone can be understood as the\n-   --    biggest allocation that the method could have detect, provided\n-   --    that there is no \"Untouched allocated zone\" error and no \"Pattern\n-   --    usage in user code\" error. If no object in the user code is likely\n-   --    to have this size, this is not likely to happen.\n-   --\n-   --   * Pattern usage in user code:\n-   --    - Description: The pattern can be found in the object of the user\n-   --    code. Therefore, the address space where this object has been\n-   --    allocated will appear as untouched.\n-   --    - Strategy: Choose a pattern that is uncommon. 16#0000_0000# is the\n-   --    worst choice; 16#DEAD_BEEF# can be a good one. A good choice is an\n-   --    address which is not a multiple of 2, and which is not in the\n-   --    target address space. You can also change the pattern to see if\n-   --    it changes the measure. Note that this error *very* rarely influence\n-   --    the measure of the total stack usage: to have some influence, the\n-   --    pattern has to be used in the object that has been allocated on the\n-   --    outermost address of the used stack.\n-   --\n-   --   * Stack overflow:\n-   --    - Description: The pattern zone does not fit on the stack.\n-   --    This may lead to an erroneous execution.\n-   --    - Strategy: Specify a storage size that is bigger than the\n-   --    size of the pattern. 2 times bigger should be enough.\n-   --\n-   --   * Augmentation of the user stack frames:\n-   --    - Description: The use of instrumentation object or procedure may\n-   --    augment the stack frame of the caller.\n-   --    - Strategy: Do *not* inline the instrumentation procedures. Do *not*\n-   --    allocate the Stack_Analyzer object on the stack.\n-   --\n-   --   * Untouched allocated zone:\n-   --    - Description: The user code may allocate objects that it will never\n-   --    touch. In that case, the pattern will not be changed.\n-   --    - Strategy: There are no way to detect this error. Fortunately, this\n-   --    error is really rare, and it is most probably a bug in the user code,\n-   --    e.g. some uninitialized variable. It is (most of the time) harmless:\n-   --    it influences the measure only if the untouched allocated zone\n-   --    happens to be located at the outermost value of the stack pointer\n-   --    for the whole execution.\n+\n+   --  Bottom offset:\n+\n+   --     Description: The procedure used to fill the stack with a given\n+   --       pattern will itself have a stack frame. The value of the stack\n+   --       pointer in this procedure is, therefore, different from the value\n+   --       before the call to the instrumentation procedure.\n+\n+   --     Strategy: The user of this package should measure the bottom of stack\n+   --       before the call to Fill_Stack and pass it in parameter.\n+\n+   --  Instrumentation threshold at writing:\n+\n+   --     Description: The procedure used to fill the stack with a given\n+   --       pattern will itself have a stack frame.  Therefore, it will\n+   --       fill the stack after this stack frame. This part of the stack will\n+   --       appear as used in the final measure.\n+\n+   --     Strategy: As the user passes the value of the bottom of stack to\n+   --       the instrumentation to deal with the bottom offset error, and as as\n+   --       the instrumentation procedure knows where the pattern filling start\n+   --       on the stack, the difference between the two values is the minimum\n+   --       stack usage that the method can measure. If, when the results are\n+   --       computed, the pattern zone has been left untouched, we conclude\n+   --       that the stack usage is inferior to this minimum stack usage.\n+\n+   --  Instrumentation threshold at reading:\n+\n+   --    Description: The procedure used to read the stack at the end of the\n+   --      execution clobbers the stack by allocating its stack frame. If this\n+   --      stack frame is bigger than the total stack used by the user code at\n+   --      this point, it will increase the measured stack size.\n+\n+   --    Strategy: We could augment this stack frame and see if it changes the\n+   --      measure. However, this error should be negligeable.\n+\n+   --   Pattern zone overflow:\n+\n+   --     Description: The stack grows outer than the outermost bound of the\n+   --       pattern zone. In that case, the outermost region modified in the\n+   --       pattern is not the maximum value of the stack pointer during the\n+   --       execution.\n+\n+   --     Strategy: At the end of the execution, the difference between the\n+   --       outermost memory region modified in the pattern zone and the\n+   --       outermost bound of the pattern zone can be understood as the\n+   --       biggest allocation that the method could have detect, provided\n+   --       that there is no \"Untouched allocated zone\" error and no \"Pattern\n+   --       usage in user code\" error. If no object in the user code is likely\n+   --       to have this size, this is not likely to happen.\n+\n+   --   Pattern usage in user code:\n+\n+   --     Description: The pattern can be found in the object of the user code.\n+   --       Therefore, the address space where this object has been allocated\n+   --       will appear as untouched.\n+\n+   --     Strategy: Choose a pattern that is uncommon. 16#0000_0000# is the\n+   --       worst choice; 16#DEAD_BEEF# can be a good one. A good choice is an\n+   --       address which is not a multiple of 2, and which is not in the\n+   --       target address space. You can also change the pattern to see if it\n+   --       changes the measure. Note that this error *very* rarely influence\n+   --       the measure of the total stack usage: to have some influence, the\n+   --       pattern has to be used in the object that has been allocated on the\n+   --       outermost address of the used stack.\n+\n+   --   Stack overflow:\n+\n+   --     Description: The pattern zone does not fit on the stack. This may\n+   --       lead to an erroneous execution.\n+\n+   --    Strategy: Specify a storage size that is bigger than the size of the\n+   --      pattern. 2 times bigger should be enough.\n+\n+   --   Augmentation of the user stack frames:\n+\n+   --     Description: The use of instrumentation object or procedure may\n+   --       augment the stack frame of the caller.\n+\n+   --     Strategy: Do *not* inline the instrumentation procedures. Do *not*\n+   --       allocate the Stack_Analyzer object on the stack.\n+\n+   --   Untouched allocated zone:\n+\n+   --     Description: The user code may allocate objects that it will never\n+   --       touch. In that case, the pattern will not be changed.\n+\n+   --     Strategy: There are no way to detect this error. Fortunately, this\n+   --       error is really rare, and it is most probably a bug in the user\n+   --       code, e.g. some uninitialized variable. It is (most of the time)\n+   --       harmless: it influences the measure only if the untouched allocated\n+   --       zone happens to be located at the outermost value of the stack\n+   --       pointer for the whole execution.\n+\n+   procedure Initialize (Buffer_Size : Natural);\n+   pragma Export (C, Initialize, \"__gnat_stack_usage_initialize\");\n+   --  Initializes the size of the buffer that stores the results. Only the\n+   --  first Buffer_Size results are stored. Any results that do not fit in\n+   --  this buffer will be displayed on the fly.\n \n    procedure Fill_Stack (Analyzer : in out Stack_Analyzer);\n    --  Fill an area of the stack with the pattern Analyzer.Pattern. The size\n@@ -200,13 +218,26 @@ package System.Stack_Usage is\n    --                    Analyzer.Inner_Pattern_Mark                  ^\n    --                                            Analyzer.Outer_Pattern_Mark\n \n+   procedure Initialize_Analyzer\n+     (Analyzer  : in out Stack_Analyzer;\n+      Task_Name : String;\n+      Size      : Natural;\n+      Bottom    : Stack_Address;\n+      Pattern   : Word_32 := 16#DEAD_BEEF#);\n+   --  Should be called before any use of a Stack_Analyzer, to initialize it.\n+   --  Size is the size of the pattern zone. Bottom should be a close\n+   --  approximation of the caller base frame address.\n+\n+   Is_Enabled : Boolean := False;\n+   --  When this flag is true, then stack analysis is enabled\n+\n    procedure Compute_Result (Analyzer : in out Stack_Analyzer);\n-   --  Read the patern zone and deduce the stack usage. It should\n-   --  be called from the same frame as Fill_Stack. If Analyzer.Probe is not\n-   --  null, an array of Word_32 with Analyzer.Probe elements is allocated on\n-   --  Compute_Result's stack frame. Probe can be used to detect an\n-   --  \"instrumentation threshold at reading\" error; See above.\n-   --  After the call to this procedure, the memory will look like:\n+   --  Read the patern zone and deduce the stack usage. It should be called\n+   --  from the same frame as Fill_Stack. If Analyzer.Probe is not null, an\n+   --  array of Word_32 with Analyzer.Probe elements is allocated on\n+   --  Compute_Result's stack frame. Probe can be used to detect  the error:\n+   --  \"instrumentation threshold at reading\". See above. After the call\n+   --  to this procedure, the memory will look like:\n    --\n    --                                                             Stack growing\n    --  ----------------------------------------------------------------------->\n@@ -224,66 +255,89 @@ package System.Stack_Usage is\n \n    procedure Report_Result (Analyzer : Stack_Analyzer);\n    --  Store the results of the computation in memory, at the address\n-   --  corresponding to the symbol __gnat_stack_usage_results.\n-\n-   type Parameterless_Procedure is access procedure;\n-\n-   procedure Initialize_Analyzer\n-     (Analyzer  : in out Stack_Analyzer;\n-      Task_Name : String;\n-      Size      : Natural;\n-      Bottom    : Stack_Address;\n-      Pattern   : Word_32 := 16#DEAD_BEEF#);\n-   --  Should be called before any use of a Stack_Analyzer, to initialize it.\n-   --  Size is the size of the pattern zone.\n-   --  Bottom should be a close approximation of the caller base\n-   --  frame address.\n+   --  corresponding to the symbol __gnat_stack_usage_results. This is not\n+   --  done inside Compute_Resuls in order to use as less stack as possible\n+   --  within a task.\n \n    procedure Output_Results;\n    --  Print the results computed so far on the standard output. Should be\n    --  called when all tasks are dead.\n \n+   pragma Export (C, Output_Results, \"__gnat_stack_usage_output_results\");\n+\n private\n \n+   Task_Name_Length : constant := 32;\n+\n    package Word_32_Addr is\n-      new System.Address_To_Access_Conversions (Word_32);\n+     new System.Address_To_Access_Conversions (Word_32);\n \n-   type Result_Array_Id is range 0 .. 1_023;\n+   type Stack_Analyzer is record\n+      Task_Name : String (1 .. Task_Name_Length);\n+      --  Name of the task\n \n-   type Stack_Analyzer\n-   is record\n-      Size                   : Natural;\n-      --  Size of the pattern zone.\n+      Size : Natural;\n+      --  Size of the pattern zone\n \n-      Pattern                : Word_32 := 16#DEAD_BEEF#;\n-      --  Pattern used to recognize untouched memory.\n+      Pattern : Word_32;\n+      --  Pattern used to recognize untouched memory\n \n-      Inner_Pattern_Mark     : Stack_Address;\n-      --  Innermost bound of the pattern area on the stack.\n+      Inner_Pattern_Mark : Stack_Address;\n+      --  Innermost bound of the pattern area on the stack\n \n-      Outer_Pattern_Mark     : Stack_Address;\n-      --  Outermost bound of the pattern area on the stack.\n+      Outer_Pattern_Mark : Stack_Address;\n+      --  Outermost bound of the pattern area on the stack\n \n       Outermost_Touched_Mark : Stack_Address;\n       --  Outermost address of the pattern area whose value it is pointing\n       --  at has been modified during execution. If the systematic error are\n       --  compensated, it is the outermost value of the stack pointer during\n       --  the execution.\n \n-      Bottom_Of_Stack        : Stack_Address;\n+      Bottom_Of_Stack : Stack_Address;\n       --  Address of the bottom of the stack, as given by the caller of\n       --  Initialize_Analyzer.\n \n-      Array_Address          : Address;\n-      --  Address of the array of Word_32 that represents the pattern zone.\n+      Array_Address : System.Address;\n+      --  Address of the array of Word_32 that represents the pattern zone\n \n-      First_Is_Outermost     : Boolean;\n+      First_Is_Outermost : Boolean;\n       --  Set to true if the first element of the array of Word_32 that\n       --  represents the pattern zone is at the outermost address of the\n       --  pattern zone; false if it is the innermost address.\n \n-      Result_Id              : Result_Array_Id;\n-      --  Location in the result array of the result for the current task.\n+      Result_Id : Positive;\n+      --  Id of the result. If less than value given to gnatbind -u corresponds\n+      --  to the location in the result array of result for the current task.\n+   end record;\n+\n+   Environment_Task_Analyzer : Stack_Analyzer;\n+\n+   Compute_Environment_Task  : Boolean;\n+\n+   type Task_Result is record\n+      Task_Name : String (1 .. Task_Name_Length);\n+      Measure   : Natural;\n+      Max_Size  : Natural;\n    end record;\n \n+   type Result_Array_Type is array (Positive range <>) of Task_Result;\n+   type Result_Array_Ptr is access all Result_Array_Type;\n+\n+   Result_Array : Result_Array_Ptr;\n+   pragma Export (C, Result_Array, \"__gnat_stack_usage_results\");\n+   --  Exported in order to have an easy accessible symbol in when debugging\n+\n+   Next_Id : Positive := 1;\n+   --  Id of the next stack analyzer\n+\n+   function Stack_Size\n+     (SP_Low  : Stack_Address;\n+      SP_High : Stack_Address) return Natural;\n+   pragma Inline (Stack_Size);\n+   --  Return the size of a portion of stack delimeted by SP_High and SP_Low\n+   --  (), i.e. the difference between SP_High and SP_Low. The storage element\n+   --  pointed by SP_Low is not included in the size. Inlined to reduce the\n+   --  size of the stack used by the instrumentation code.\n+\n end System.Stack_Usage;"}, {"sha": "f0ac3b8de168e40b1c13d443fecdf20be72ba311", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 124, "deletions": 44, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -45,6 +45,9 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n --  tasking operations. It causes infinite loops and other problems.\n \n+with Ada.Exceptions;\n+--  used for Exception_Occurrence\n+\n with System.Parameters;\n --  used for Size_Type\n --           Single_Lock\n@@ -83,6 +86,8 @@ package body System.Tasking.Restricted.Stages is\n    package SSE  renames System.Storage_Elements;\n    package SST  renames System.Secondary_Stack;\n \n+   use Ada.Exceptions;\n+\n    use Parameters;\n    use Task_Primitives.Operations;\n    use Task_Info;\n@@ -133,17 +138,32 @@ package body System.Tasking.Restricted.Stages is\n    ---------------\n \n    procedure Task_Lock is\n+      Self_ID : constant Task_Id := STPO.Self;\n+\n    begin\n-      STPO.Write_Lock (Global_Task_Lock'Access, Global_Lock => True);\n+      Self_ID.Common.Global_Task_Lock_Nesting :=\n+        Self_ID.Common.Global_Task_Lock_Nesting + 1;\n+\n+      if Self_ID.Common.Global_Task_Lock_Nesting = 1 then\n+         STPO.Write_Lock (Global_Task_Lock'Access, Global_Lock => True);\n+      end if;\n    end Task_Lock;\n \n    -----------------\n    -- Task_Unlock --\n    -----------------\n \n    procedure Task_Unlock is\n+      Self_ID : constant Task_Id := STPO.Self;\n+\n    begin\n-      STPO.Unlock (Global_Task_Lock'Access, Global_Lock => True);\n+      pragma Assert (Self_ID.Common.Global_Task_Lock_Nesting > 0);\n+      Self_ID.Common.Global_Task_Lock_Nesting :=\n+        Self_ID.Common.Global_Task_Lock_Nesting - 1;\n+\n+      if Self_ID.Common.Global_Task_Lock_Nesting = 0 then\n+         STPO.Unlock (Global_Task_Lock'Access, Global_Lock => True);\n+      end if;\n    end Task_Unlock;\n \n    ------------------\n@@ -162,21 +182,40 @@ package body System.Tasking.Restricted.Stages is\n    procedure Task_Wrapper (Self_ID : Task_Id) is\n       ID : Task_Id := Self_ID;\n       pragma Volatile (ID);\n-\n       pragma Warnings (Off, ID);\n-      --  Turn off warnings (stand alone volatile constant has to be\n-      --  imported, so we cannot just make ID constant).\n-\n-      --  Do not delete this variable.\n-      --  In some targets, we need this variable to implement a fast Self.\n+      --  Variable used on some targets to implement a fast self. We turn off\n+      --  warnings because a stand alone volatile constant has to be imported,\n+      --  so we don't want warnings about ID not being referenced, and volatile\n+      --  having no effect.\n+      --\n+      --  DO NOT delete ID. As noted, it is needed on some targets.\n \n       use type System.Parameters.Size_Type;\n       use type SSE.Storage_Offset;\n \n       Secondary_Stack : aliased SSE.Storage_Array\n         (1 .. Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n-           SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100);\n+                SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100);\n+\n+      pragma Warnings (Off);\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n+      pragma Warnings (On);\n+      --  Address of secondary stack. In the fixed secondary stack case, this\n+      --  value is not modified, causing a warning, hence the bracketing with\n+      --  Warnings (Off/On).\n+\n+      Cause : Cause_Of_Termination := Normal;\n+      --  Indicates the reason why this task terminates. Normal corresponds to\n+      --  a task terminating due to completing the last statement of its body.\n+      --  If the task terminates because of an exception raised by the\n+      --  execution of its task body, then Cause is set to Unhandled_Exception.\n+      --  Aborts are not allowed in the restriced profile to which this file\n+      --  belongs.\n+\n+      EO : Exception_Occurrence;\n+      --  If the task terminates because of an exception raised by the\n+      --  execution of its task body, then EO will contain the associated\n+      --  exception occurrence. Otherwise, it will contain Null_Occurrence.\n \n    begin\n       if not Parameters.Sec_Stack_Dynamic then\n@@ -190,25 +229,53 @@ package body System.Tasking.Restricted.Stages is\n \n       Enter_Task (Self_ID);\n \n-      --  Call the task body procedure.\n+      --  Call the task body procedure\n \n       begin\n          --  We are separating the following portion of the code in order to\n-         --  place the exception handlers in a different block.\n-         --  In this way we do not call Set_Jmpbuf_Address (which needs\n-         --  Self) before we set Self in Enter_Task.\n+         --  place the exception handlers in a different block. In this way we\n+         --  do not call Set_Jmpbuf_Address (which needs Self) before we set\n+         --  Self in Enter_Task.\n+\n          --  Note that in the case of Ravenscar HI-E where there are no\n          --  exception handlers, the exception handler is suppressed.\n \n-         --  Call the task body procedure.\n+         --  Call the task body procedure\n \n          Self_ID.Common.Task_Entry_Point (Self_ID.Common.Task_Arg);\n-         Terminate_Task (Self_ID);\n+\n+         --  Normal task termination\n+\n+         Cause := Normal;\n+         Save_Occurrence (EO, Ada.Exceptions.Null_Occurrence);\n \n       exception\n-         when others =>\n-            Terminate_Task (Self_ID);\n+         when E : others =>\n+\n+            --  Task terminating because of an unhandled exception\n+\n+            Cause := Unhandled_Exception;\n+            Save_Occurrence (EO, E);\n       end;\n+\n+      --  Look for a fall-back handler. It can be either in the task itself\n+      --  or in the environment task. Note that this code is always executed\n+      --  by a task whose master is the environment task. The task termination\n+      --  code for the environment task is executed by\n+      --  SSL.Task_Termination_Handler.\n+\n+      --  This package is part of the restricted run time which supports\n+      --  neither task hierarchies (No_Task_Hierarchy) nor specific task\n+      --  termination handlers (No_Specific_Termination_Handlers).\n+\n+      if Self_ID.Common.Fall_Back_Handler /= null then\n+         Self_ID.Common.Fall_Back_Handler.all (Cause, Self_ID, EO);\n+      elsif Self_ID.Common.Parent.Common.Fall_Back_Handler /= null then\n+         Self_ID.Common.Parent.Common.Fall_Back_Handler.all\n+           (Cause, Self_ID, EO);\n+      end if;\n+\n+      Terminate_Task (Self_ID);\n    end Task_Wrapper;\n \n    -----------------------\n@@ -219,11 +286,11 @@ package body System.Tasking.Restricted.Stages is\n    -- Activate_Restricted_Tasks --\n    -------------------------------\n \n-   --  Note that locks of activator and activated task are both locked\n-   --  here. This is necessary because C.State and Self.Wait_Count\n-   --  have to be synchronized. This is safe from deadlock because\n-   --  the activator is always created before the activated task.\n-   --  That satisfies our in-order-of-creation ATCB locking policy.\n+   --  Note that locks of activator and activated task are both locked here.\n+   --  This is necessary because C.State and Self.Wait_Count have to be\n+   --  synchronized. This is safe from deadlock because the activator is always\n+   --  created before the activated task. That satisfies our\n+   --  in-order-of-creation ATCB locking policy.\n \n    procedure Activate_Restricted_Tasks\n      (Chain_Access : Activation_Chain_Access)\n@@ -241,14 +308,13 @@ package body System.Tasking.Restricted.Stages is\n          Lock_RTS;\n       end if;\n \n-      --  Lock self, to prevent activated tasks\n-      --  from racing ahead before we finish activating the chain.\n+      --  Lock self, to prevent activated tasks from racing ahead before we\n+      --  finish activating the chain.\n \n       Write_Lock (Self_ID);\n \n-      --  Activate all the tasks in the chain.\n-      --  Creation of the thread of control was deferred until\n-      --  activation. So create it now.\n+      --  Activate all the tasks in the chain. Creation of the thread of\n+      --  control was deferred until activation. So create it now.\n \n       C := Chain_Access.T_ID;\n \n@@ -286,9 +352,8 @@ package body System.Tasking.Restricted.Stages is\n \n       Self_ID.Common.State := Activator_Sleep;\n \n-      --  Wait for the activated tasks to complete activation.\n-      --  It is unsafe to abort any of these tasks until the count goes to\n-      --  zero.\n+      --  Wait for the activated tasks to complete activation. It is unsafe to\n+      --  abort any of these tasks until the count goes to zero.\n \n       loop\n          exit when Self_ID.Common.Wait_Count = 0;\n@@ -302,7 +367,7 @@ package body System.Tasking.Restricted.Stages is\n          Unlock_RTS;\n       end if;\n \n-      --  Remove the tasks from the chain.\n+      --  Remove the tasks from the chain\n \n       Chain_Access.T_ID := null;\n    end Activate_Restricted_Tasks;\n@@ -328,14 +393,13 @@ package body System.Tasking.Restricted.Stages is\n       Write_Lock (Activator);\n       Write_Lock (Self_ID);\n \n-      --  Remove dangling reference to Activator,\n-      --  since a task may outlive its activator.\n+      --  Remove dangling reference to Activator, since a task may outlive its\n+      --  activator.\n \n       Self_ID.Common.Activator := null;\n \n-      --  Wake up the activator, if it is waiting for a chain\n-      --  of tasks to activate, and we are the last in the chain\n-      --  to complete activation\n+      --  Wake up the activator, if it is waiting for a chain of tasks to\n+      --  activate, and we are the last in the chain to complete activation\n \n       if Activator.Common.State = Activator_Sleep then\n          Activator.Common.Wait_Count := Activator.Common.Wait_Count - 1;\n@@ -352,9 +416,9 @@ package body System.Tasking.Restricted.Stages is\n          Unlock_RTS;\n       end if;\n \n-      --  After the activation, active priority should be the same\n-      --  as base priority. We must unlock the Activator first,\n-      --  though, since it should not wait if we have lower priority.\n+      --  After the activation, active priority should be the same as base\n+      --  priority. We must unlock the Activator first, though, since it should\n+      --  not wait if we have lower priority.\n \n       if Get_Priority (Self_ID) /= Self_ID.Common.Base_Priority then\n          Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n@@ -391,8 +455,8 @@ package body System.Tasking.Restricted.Stages is\n       Success       : Boolean;\n \n    begin\n-      --  Stack is not preallocated on this target, so that\n-      --  Stack_Address must be null.\n+      --  Stack is not preallocated on this target, so that Stack_Address must\n+      --  be null.\n \n       pragma Assert (Stack_Address = Null_Address);\n \n@@ -415,9 +479,9 @@ package body System.Tasking.Restricted.Stages is\n         (Self_ID, State, Discriminants, Self_ID, Elaborated, Base_Priority,\n          Task_Info, Size, Created_Task, Success);\n \n-      --  If we do our job right then there should never be any failures,\n-      --  which was probably said about the Titanic; so just to be safe,\n-      --  let's retain this code for now\n+      --  If we do our job right then there should never be any failures, which\n+      --  was probably said about the Titanic; so just to be safe, let's retain\n+      --  this code for now\n \n       if not Success then\n          Unlock (Self_ID);\n@@ -468,6 +532,22 @@ package body System.Tasking.Restricted.Stages is\n          Lock_RTS;\n       end if;\n \n+      --  Handle normal task termination by the environment task, but only for\n+      --  the normal task termination. In the case of Abnormal and\n+      --  Unhandled_Exception they must have been handled before, and the task\n+      --  termination soft link must have been changed so the task termination\n+      --  routine is not executed twice.\n+\n+      --  Note that in the \"normal\" implementation in s-tassta.adb the task\n+      --  termination procedure for the environment task should be executed\n+      --  after termination of library-level tasks. However, this\n+      --  implementation is to be used when the Ravenscar restrictions are in\n+      --  effect, and AI-394 says that if there is a fall-back handler set for\n+      --  the partition it should be called when the first task (including the\n+      --  environment task) attempts to terminate.\n+\n+      SSL.Task_Termination_Handler.all (Ada.Exceptions.Null_Occurrence);\n+\n       Write_Lock (Self_ID);\n       Sleep (Self_ID, Master_Completion_Sleep);\n       Unlock (Self_ID);"}, {"sha": "318e4bdaaa8ca797d4addadb33c6fd441e0cb4ca", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -323,7 +323,7 @@ package body System.Tasking.Initialization is\n \n    procedure Final_Task_Unlock (Self_ID : Task_Id) is\n    begin\n-      pragma Assert (Self_ID.Global_Task_Lock_Nesting = 1);\n+      pragma Assert (Self_ID.Common.Global_Task_Lock_Nesting = 1);\n       Unlock (Global_Task_Lock'Access, Global_Lock => True);\n    end Final_Task_Unlock;\n \n@@ -624,9 +624,10 @@ package body System.Tasking.Initialization is\n \n    procedure Task_Lock (Self_ID : Task_Id) is\n    begin\n-      Self_ID.Global_Task_Lock_Nesting := Self_ID.Global_Task_Lock_Nesting + 1;\n+      Self_ID.Common.Global_Task_Lock_Nesting :=\n+        Self_ID.Common.Global_Task_Lock_Nesting + 1;\n \n-      if Self_ID.Global_Task_Lock_Nesting = 1 then\n+      if Self_ID.Common.Global_Task_Lock_Nesting = 1 then\n          Defer_Abort_Nestable (Self_ID);\n          Write_Lock (Global_Task_Lock'Access, Global_Lock => True);\n       end if;\n@@ -654,10 +655,11 @@ package body System.Tasking.Initialization is\n \n    procedure Task_Unlock (Self_ID : Task_Id) is\n    begin\n-      pragma Assert (Self_ID.Global_Task_Lock_Nesting > 0);\n-      Self_ID.Global_Task_Lock_Nesting := Self_ID.Global_Task_Lock_Nesting - 1;\n+      pragma Assert (Self_ID.Common.Global_Task_Lock_Nesting > 0);\n+      Self_ID.Common.Global_Task_Lock_Nesting :=\n+        Self_ID.Common.Global_Task_Lock_Nesting - 1;\n \n-      if Self_ID.Global_Task_Lock_Nesting = 0 then\n+      if Self_ID.Common.Global_Task_Lock_Nesting = 0 then\n          Unlock (Global_Task_Lock'Access, Global_Lock => True);\n          Undefer_Abort_Nestable (Self_ID);\n       end if;"}, {"sha": "6c0ef7a04e697071a7b63b7ea82d3e589690d63d", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -107,6 +107,9 @@ package body System.Tasking is\n       T.Common.Elaborated := Elaborated;\n       T.Common.Activation_Failed := False;\n       T.Common.Task_Info := Task_Info;\n+      T.Common.Global_Task_Lock_Nesting := 0;\n+      T.Common.Fall_Back_Handler := null;\n+      T.Common.Specific_Handler  := null;\n \n       if T.Common.Parent = null then\n          --  For the environment task, the adjusted stack size is"}, {"sha": "da8b8005003bc280933ddbe21cfa1f9e3d6c3b75", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -37,7 +37,8 @@\n --  Any changes to this interface may require corresponding compiler changes.\n \n with Ada.Exceptions;\n---  Used for:  Exception_Id\n+--  Used for Exception_Id\n+--           Exception_Occurrence\n \n with System.Parameters;\n --  used for Size_Type\n@@ -51,6 +52,9 @@ with System.Soft_Links;\n with System.Task_Primitives;\n --  used for Private_Data\n \n+with System.Stack_Usage;\n+--  used for Stack_Analyzer\n+\n with Unchecked_Conversion;\n \n package System.Tasking is\n@@ -329,6 +333,32 @@ package System.Tasking is\n    end record;\n    pragma Suppress_Initialization (Restricted_Entry_Call_Record);\n \n+   -------------------------------------------\n+   -- Task termination procedure definition --\n+   -------------------------------------------\n+\n+   --  We need to redefine here these types (already defined in\n+   --  Ada.Task_Termination) for avoiding circular dependencies.\n+\n+   type Cause_Of_Termination is (Normal, Abnormal, Unhandled_Exception);\n+   --  Possible causes for task termination:\n+   --\n+   --    Normal means that the task terminates due to completing the\n+   --    last sentence of its body, or as a result of waiting on a\n+   --    terminate alternative.\n+\n+   --    Abnormal means that the task terminates because it is being aborted\n+\n+   --    handled_Exception means that the task terminates because of exception\n+   --    raised by by the execution of its task_body.\n+\n+   type Termination_Handler is access protected procedure\n+     (Cause : in Cause_Of_Termination;\n+      T     : in Task_Id;\n+      X     : in Ada.Exceptions.Exception_Occurrence);\n+   --  Used to represent protected procedures to be executed when task\n+   --  terminates.\n+\n    ------------------------------------\n    -- Task related other definitions --\n    ------------------------------------\n@@ -539,6 +569,32 @@ package System.Tasking is\n       Task_Info : System.Task_Info.Task_Info_Type;\n       --  System-specific attributes of the task as specified by the\n       --  Task_Info pragma.\n+\n+      Analyzer  : System.Stack_Usage.Stack_Analyzer;\n+      --  For storing informations used to measure the stack usage.\n+\n+      Global_Task_Lock_Nesting : Natural;\n+      --  This is the current nesting level of calls to\n+      --  System.Tasking.Initialization.Lock_Task. This allows a task to call\n+      --  Lock_Task multiple times without deadlocking. A task only locks\n+      --  Global_Task_Lock when its Global_Task_Lock_Nesting goes from 0 to 1,\n+      --  and only unlocked when it goes from 1 to 0.\n+      --\n+      --  Protection: Only accessed by Self\n+\n+      Fall_Back_Handler : Termination_Handler;\n+      pragma Atomic (Fall_Back_Handler);\n+      --  This is the fall-back handler that applies to the dependent tasks of\n+      --  the task.\n+      --\n+      --  Protection: atomic access\n+\n+      Specific_Handler : Termination_Handler;\n+      pragma Atomic (Specific_Handler);\n+      --  This is the specific handler that applies only to this task, and not\n+      --  any of its dependent tasks.\n+      --\n+      --  Protection: atomic access\n    end record;\n \n    ---------------------------------------\n@@ -796,15 +852,6 @@ package System.Tasking is\n       --\n       --  Protection: Self.L\n \n-      Global_Task_Lock_Nesting : Natural := 0;\n-      --  This is the current nesting level of calls to\n-      --  System.Tasking.Stages.Lock_Task_T. This allows a task to call\n-      --  Lock_Task_T multiple times without deadlocking. A task only locks\n-      --  All_Task_Lock when its All_Tasks_Nesting goes from 0 to 1, and only\n-      --  unlocked when it goes from 1 to 0.\n-      --\n-      --  Protection: Only accessed by Self\n-\n       Open_Accepts : Accept_List_Access;\n       --  This points to the Open_Accepts array of accept alternatives passed\n       --  to the RTS by the compiler-generated code to Selective_Wait. It is"}, {"sha": "4ceea414a6d09391c609665e24864800ac791478", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 141, "deletions": 31, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -68,7 +68,7 @@ with System.Soft_Links;\n --  specific data. In the absence of tasking, these routines refer to global\n --  data. In the presense of tasking, they must be replaced with pointers to\n --  task-specific versions. Also used for Create_TSD, Destroy_TSD,\n---  Get_Current_Excep\n+--  Get_Current_Excep, Finalize_Global_List, Task_Termination, Handler.\n \n with System.Tasking.Initialization;\n --  Used for Remove_From_All_Tasks_List\n@@ -84,6 +84,7 @@ pragma Elaborate_All (System.Tasking.Initialization);\n with System.Tasking.Utilities;\n --  Used for Make_Passive\n --           Abort_One_Task\n+--           Abort_Tasks\n \n with System.Tasking.Queuing;\n --  Used for Dequeue_Head\n@@ -94,9 +95,6 @@ with System.Tasking.Rendezvous;\n with System.OS_Primitives;\n --  Used for Delay_Modes\n \n-with System.Finalization_Implementation;\n---  Used for System.Finalization_Implementation.Finalize_Global_List\n-\n with System.Secondary_Stack;\n --  Used for SS_Init\n \n@@ -115,6 +113,8 @@ with System.Traces.Tasking;\n with Unchecked_Deallocation;\n --  To recover from failure of ATCB initialization\n \n+with System.Stack_Usage;\n+\n package body System.Tasking.Stages is\n \n    package STPO renames System.Task_Primitives.Operations;\n@@ -232,17 +232,6 @@ package body System.Tasking.Stages is\n \n    procedure Abort_Tasks (Tasks : Task_List) is\n    begin\n-      --  If pragma Detect_Blocking is active then Program_Error must be\n-      --  raised if this potentially blocking operation is called from a\n-      --  protected action.\n-\n-      if System.Tasking.Detect_Blocking\n-        and then STPO.Self.Common.Protected_Action_Nesting > 0\n-      then\n-         Ada.Exceptions.Raise_Exception\n-           (Program_Error'Identity, \"potentially blocking operation\");\n-      end if;\n-\n       Utilities.Abort_Tasks (Tasks);\n    end Abort_Tasks;\n \n@@ -826,7 +815,19 @@ package body System.Tasking.Stages is\n \n       Vulnerable_Complete_Task (Self_ID);\n \n-      System.Finalization_Implementation.Finalize_Global_List;\n+      --  Handle normal task termination by the environment task, but only\n+      --  for the normal task termination. In the case of Abnormal and\n+      --  Unhandled_Exception they must have been handled before, and the\n+      --  task termination soft link must have been changed so the task\n+      --  termination routine is not executed twice.\n+\n+      SSL.Task_Termination_Handler.all (Ada.Exceptions.Null_Occurrence);\n+\n+      --  Finalize the global list for controlled objects if needed\n+\n+      SSL.Finalize_Global_List.all;\n+\n+      --  Reset the soft links to non-tasking\n \n       SSL.Abort_Defer        := SSL.Abort_Defer_NT'Access;\n       SSL.Abort_Undefer      := SSL.Abort_Undefer_NT'Access;\n@@ -890,32 +891,101 @@ package body System.Tasking.Stages is\n       use type System.Parameters.Size_Type;\n       use type SSE.Storage_Offset;\n       use System.Standard_Library;\n+      use System.Stack_Usage;\n+\n+      Bottom_Of_Stack : aliased Integer;\n+\n+      Secondary_Stack_Size :\n+        constant SSE.Storage_Offset :=\n+          Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n+          SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100;\n \n       Secondary_Stack :\n         aliased SSE.Storage_Array\n-          (1 .. Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n-                  SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100);\n+           (1 .. Secondary_Stack_Size);\n \n+      pragma Warnings (Off);\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n \n+      Overflow_Guard          : constant := 16#1_000#;\n+\n+      Size :\n+        Natural := Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n+\n+      pragma Warnings (On);\n+      --  Address of secondary stack. In the fixed secondary stack case, this\n+      --  value is not modified, causing a warning, hence the bracketing with\n+      --  Warnings (Off/On).\n+\n       SEH_Table : aliased SSE.Storage_Array (1 .. 8);\n       --  Structured Exception Registration table (2 words)\n \n       procedure Install_SEH_Handler (Addr : System.Address);\n       pragma Import (C, Install_SEH_Handler, \"__gnat_install_SEH_handler\");\n       --  Install the SEH (Structured Exception Handling) handler\n \n+      Cause : Cause_Of_Termination := Normal;\n+      --  Indicates the reason why this task terminates. Normal corresponds to\n+      --  a task terminating due to completing the last statement of its body,\n+      --  or as a result of waiting on a terminate alternative. If the task\n+      --  terminates because it is being aborted then Cause will be set to\n+      --  Abnormal. If the task terminates because of an exception raised by\n+      --  the execution of its task body, then Cause is set to\n+      --  Unhandled_Exception.\n+\n+      EO : Exception_Occurrence;\n+      --  If the task terminates because of an exception raised by the\n+      --  execution of its task body, then EO will contain the associated\n+      --  exception occurrence. Otherwise, it will contain Null_Occurrence.\n+\n+      procedure Search_Fall_Back_Handler (ID : Task_Id);\n+      --  Procedure that searches recursively a fall-back handler through the\n+      --  master relationship.\n+\n+      procedure Search_Fall_Back_Handler (ID : Task_Id) is\n+      begin\n+         --  If there is a fall back handler, execute it\n+\n+         if ID.Common.Fall_Back_Handler /= null then\n+            ID.Common.Fall_Back_Handler.all (Cause, Self_ID, EO);\n+\n+         --  Otherwise look for a fall back handler in the parent\n+\n+         elsif ID.Common.Parent /= null then\n+            Search_Fall_Back_Handler (ID.Common.Parent);\n+\n+         --  Otherwise, do nothing\n+\n+         else\n+            return;\n+         end if;\n+      end Search_Fall_Back_Handler;\n+\n    begin\n       pragma Assert (Self_ID.Deferral_Level = 1);\n \n       if not Parameters.Sec_Stack_Dynamic then\n          Self_ID.Common.Compiler_Data.Sec_Stack_Addr :=\n            Secondary_Stack'Address;\n          SST.SS_Init (Secondary_Stack_Address, Integer (Secondary_Stack'Last));\n+         Size := Size - Natural (Secondary_Stack_Size);\n+      end if;\n+\n+      Size := Size - Overflow_Guard;\n+\n+      if System.Stack_Usage.Is_Enabled then\n+         STPO.Lock_RTS;\n+         Initialize_Analyzer (Self_ID.Common.Analyzer,\n+                              Self_ID.Common.Task_Image\n+                                (1 .. Self_ID.Common.Task_Image_Len),\n+                              Size,\n+                              SSE.To_Integer (Bottom_Of_Stack'Address));\n+         STPO.Unlock_RTS;\n+         Fill_Stack (Self_ID.Common.Analyzer);\n       end if;\n \n-      --  Set the guard page at the bottom of the stack. The call to\n-      --  unprotect the page is done in Terminate_Task\n+      --  Set the guard page at the bottom of the stack. The call to unprotect\n+      --  the page is done in Terminate_Task\n \n       Stack_Guard (Self_ID, True);\n \n@@ -930,9 +1000,13 @@ package body System.Tasking.Stages is\n \n       Install_SEH_Handler (SEH_Table'Address);\n \n-      --  We lock RTS_Lock to wait for activator to finish activating\n-      --  the rest of the chain, so that everyone in the chain comes out\n-      --  in priority order.\n+      --  Initialize exception occurrence\n+\n+      Save_Occurrence (EO, Ada.Exceptions.Null_Occurrence);\n+\n+      --  We lock RTS_Lock to wait for activator to finish activating the rest\n+      --  of the chain, so that everyone in the chain comes out in priority\n+      --  order.\n \n       --  This also protects the value of\n       --    Self_ID.Common.Activator.Common.Wait_Count.\n@@ -980,6 +1054,17 @@ package body System.Tasking.Stages is\n          when Standard'Abort_Signal =>\n             Initialization.Defer_Abort_Nestable (Self_ID);\n \n+            --  Update the cause that motivated the task termination so that\n+            --  the appropriate information is passed to the task termination\n+            --  procedure. Task termination as a result of waiting on a\n+            --  terminate alternative is a normal termination, although it is\n+            --  implemented using the abort mechanisms.\n+\n+            if Self_ID.Terminate_Alternative then\n+               Cause := Normal;\n+            else\n+               Cause := Abnormal;\n+            end if;\n          when others =>\n             --  ??? Using an E : others here causes CD2C11A  to fail on\n             --      DEC Unix, see 7925-005.\n@@ -998,8 +1083,33 @@ package body System.Tasking.Stages is\n             if Exception_Trace = Unhandled_Raise then\n                Trace_Unhandled_Exception_In_Task (Self_ID);\n             end if;\n+\n+            --  Update the cause that motivated the task termination so that\n+            --  the appropriate information is passed to the task termination\n+            --  procedure, as well as the associated Exception_Occurrence.\n+\n+            Cause := Unhandled_Exception;\n+            Save_Occurrence (EO, SSL.Get_Current_Excep.all.all);\n       end;\n \n+      --  Look for a task termination handler. This code is for all tasks but\n+      --  the environment task. The task termination code for the environment\n+      --  task is executed by SSL.Task_Termination_Handler.\n+\n+      if Self_ID.Common.Specific_Handler /= null then\n+         Self_ID.Common.Specific_Handler.all (Cause, Self_ID, EO);\n+      else\n+         --  Look for a fall-back handler following the master relationship\n+         --  for the task.\n+\n+         Search_Fall_Back_Handler (Self_ID);\n+      end if;\n+\n+      if System.Stack_Usage.Is_Enabled then\n+         Compute_Result (Self_ID.Common.Analyzer);\n+         Report_Result (Self_ID.Common.Analyzer);\n+      end if;\n+\n       Terminate_Task (Self_ID);\n    end Task_Wrapper;\n \n@@ -1021,16 +1131,16 @@ package body System.Tasking.Stages is\n    --  We can't call Destroy_TSD while we are holding any other locks, because\n    --  it locks Global_Task_Lock, and our deadlock prevention rules require\n    --  that to be the outermost lock. Our first \"solution\" was to just lock\n-   --  Global_Task_Lock in addition to the other locks, and force the parent\n-   --  to also lock this lock between its wakeup and its freeing of the ATCB.\n-   --  See Complete_Task for the parent-side of the code that has the matching\n+   --  Global_Task_Lock in addition to the other locks, and force the parent to\n+   --  also lock this lock between its wakeup and its freeing of the ATCB. See\n+   --  Complete_Task for the parent-side of the code that has the matching\n    --  calls to Task_Lock and Task_Unlock. That was not really a solution,\n    --  since the operation Task_Unlock continued to access the ATCB after\n-   --  unlocking, after which the parent was observed to race ahead,\n-   --  deallocate the ATCB, and then reallocate it to another task. The\n-   --  call to Undefer_Abortion in Task_Unlock by the \"terminated\" task was\n-   --  overwriting the data of the new task that reused the ATCB! To solve\n-   --  this problem, we introduced the new operation Final_Task_Unlock.\n+   --  unlocking, after which the parent was observed to race ahead, deallocate\n+   --  the ATCB, and then reallocate it to another task. The call to\n+   --  Undefer_Abortion in Task_Unlock by the \"terminated\" task was overwriting\n+   --  the data of the new task that reused the ATCB! To solve this problem, we\n+   --  introduced the new operation Final_Task_Unlock.\n \n    procedure Terminate_Task (Self_ID : Task_Id) is\n       Environment_Task : constant Task_Id := STPO.Environment_Task;"}, {"sha": "ee68ebcec7ba6c94fc4dd38f74a1165d0ac6c4a2", "filename": "gcc/ada/s-tasuti.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tasuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fs-tasuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -117,9 +117,6 @@ package body System.Tasking.Utilities is\n    -- Abort_Tasks --\n    -----------------\n \n-   --  Compiler interface only: Do not call from within the RTS,\n-\n-   --  except in the implementation of Ada.Task_Identification.\n    --  This must be called to implement the abort statement.\n    --  Much of the actual work of the abort is done by the abortee,\n    --  via the Abort_Handler signal handler, and propagation of the\n@@ -131,6 +128,17 @@ package body System.Tasking.Utilities is\n       P       : Task_Id;\n \n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       Initialization.Defer_Abort_Nestable (Self_Id);\n \n       --  ?????"}, {"sha": "43be4d0b337238167039e2822785481237c3c90c", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81408d4928fe405b27c5b1cfe0b3d65ae4a35523/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=81408d4928fe405b27c5b1cfe0b3d65ae4a35523", "patch": "@@ -286,6 +286,18 @@ package body Switch.B is\n             Scan_Nat (Switch_Chars, Max, Ptr, Time_Slice_Value, C);\n             Time_Slice_Value := Time_Slice_Value * 1_000;\n \n+         --  Processing for u switch\n+\n+         when 'u' =>\n+            Ptr := Ptr + 1;\n+            Dynamic_Stack_Measurement := True;\n+            Scan_Nat\n+              (Switch_Chars,\n+               Max,\n+               Ptr,\n+               Dynamic_Stack_Measurement_Array_Size,\n+               C);\n+\n          --  Processing for v switch\n \n          when 'v' =>"}]}