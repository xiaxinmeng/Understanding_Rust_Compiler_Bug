{"sha": "adf4a335e37437dd870ed1fd9952d4014bd318af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRmNGEzMzVlMzc0MzdkZDg3MGVkMWZkOTk1MmQ0MDE0YmQzMThhZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-02T19:09:03Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-02T19:09:03Z"}, "message": "cfg.c (connect_src, [...]): New.\n\n\t* cfg.c (connect_src, connect_dest, disconnect_src,\n\tdisconnct_dest): New.\n\t(unchecked_make_edge, remove_edge, redirect_edge_succ,\n\tredirect_edge_pred): Use the new functions.\n\nFrom-SVN: r95790", "tree": {"sha": "b1167a1b882befa5f056b6a12ff5fd8f25e4aebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1167a1b882befa5f056b6a12ff5fd8f25e4aebc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adf4a335e37437dd870ed1fd9952d4014bd318af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf4a335e37437dd870ed1fd9952d4014bd318af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adf4a335e37437dd870ed1fd9952d4014bd318af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf4a335e37437dd870ed1fd9952d4014bd318af/comments", "author": null, "committer": null, "parents": [{"sha": "94dcded2d4dd7a05f81b05309685e89ea10520f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94dcded2d4dd7a05f81b05309685e89ea10520f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94dcded2d4dd7a05f81b05309685e89ea10520f2"}], "stats": {"total": 140, "additions": 76, "deletions": 64}, "files": [{"sha": "d65dd24b0b6f39cdbe51fcbc5d1ef7a7a13464ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf4a335e37437dd870ed1fd9952d4014bd318af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf4a335e37437dd870ed1fd9952d4014bd318af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adf4a335e37437dd870ed1fd9952d4014bd318af", "patch": "@@ -1,3 +1,10 @@\n+2005-03-02  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cfg.c (connect_src, connect_dest, disconnect_src,\n+\tdisconnct_dest): New.\n+\t(unchecked_make_edge, remove_edge, redirect_edge_succ,\n+\tredirect_edge_pred): Use the new functions.\n+\n 2005-03-02  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/20276"}, {"sha": "d180f3e8907e2c636be83796379599a5ce4a0135", "filename": "gcc/cfg.c", "status": "modified", "additions": 69, "deletions": 64, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adf4a335e37437dd870ed1fd9952d4014bd318af/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adf4a335e37437dd870ed1fd9952d4014bd318af/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=adf4a335e37437dd870ed1fd9952d4014bd318af", "patch": "@@ -243,6 +243,63 @@ expunge_block (basic_block b)\n      clear out BB pointer of dead statements consistently.  */\n }\n \f\n+/* Connect E to E->src.  */\n+\n+static inline void\n+connect_src (edge e)\n+{\n+  VEC_safe_push (edge, e->src->succs, e);\n+}\n+\n+/* Connect E to E->dest.  */\n+\n+static inline void\n+connect_dest (edge e)\n+{\n+  basic_block dest = e->dest;\n+  VEC_safe_push (edge, dest->preds, e);\n+  e->dest_idx = EDGE_COUNT (dest->preds) - 1;\n+}\n+\n+/* Disconnect edge E from E->src.  */\n+\n+static inline void\n+disconnect_src (edge e)\n+{\n+  basic_block src = e->src;\n+  edge_iterator ei;\n+  edge tmp;\n+\n+  for (ei = ei_start (src->succs); (tmp = ei_safe_edge (ei)); )\n+    {\n+      if (tmp == e)\n+\t{\n+\t  VEC_unordered_remove (edge, src->succs, ei.index);\n+\t  return;\n+\t}\n+      else\n+\tei_next (&ei);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Disconnect edge E from E->dest.  */\n+\n+static inline void\n+disconnect_dest (edge e)\n+{\n+  basic_block dest = e->dest;\n+  unsigned int dest_idx = e->dest_idx;\n+\n+  VEC_unordered_remove (edge, dest->preds, dest_idx);\n+\n+  /* If we removed an edge in the middle of the edge vector, we need\n+     to update dest_idx of the edge that moved into the \"hole\".  */\n+  if (dest_idx < EDGE_COUNT (dest->preds))\n+    EDGE_PRED (dest, dest_idx)->dest_idx = dest_idx;\n+}\n+\n /* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly\n    created edge.  Use this only if you are sure that this edge can't\n    possibly already exist.  */\n@@ -254,13 +311,12 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n   e = ggc_alloc_cleared (sizeof (*e));\n   n_edges++;\n \n-  VEC_safe_push (edge, src->succs, e);\n-  VEC_safe_push (edge, dst->preds, e);\n-\n   e->src = src;\n   e->dest = dst;\n   e->flags = flags;\n-  e->dest_idx = EDGE_COUNT (dst->preds) - 1;\n+\n+  connect_src (e);\n+  connect_dest (e);\n \n   execute_on_growing_pred (e);\n \n@@ -334,38 +390,10 @@ make_single_succ_edge (basic_block src, basic_block dest, int flags)\n void\n remove_edge (edge e)\n {\n-  edge tmp;\n-  basic_block src, dest;\n-  unsigned int dest_idx;\n-  bool found = false;\n-  edge_iterator ei;\n-\n   execute_on_shrinking_pred (e);\n \n-  src = e->src;\n-  dest = e->dest;\n-  dest_idx = e->dest_idx;\n-\n-  for (ei = ei_start (src->succs); (tmp = ei_safe_edge (ei)); )\n-    {\n-      if (tmp == e)\n-\t{\n-\t  VEC_unordered_remove (edge, src->succs, ei.index);\n-\t  found = true;\n-\t  break;\n-\t}\n-      else\n-\tei_next (&ei);\n-    }\n-\n-  gcc_assert (found);\n-\n-  VEC_unordered_remove (edge, dest->preds, dest_idx);\n-\n-  /* If we removed an edge in the middle of the edge vector, we need\n-     to update dest_idx of the edge that moved into the \"hole\".  */\n-  if (dest_idx < EDGE_COUNT (dest->preds))\n-    EDGE_PRED (dest, dest_idx)->dest_idx = dest_idx;\n+  disconnect_src (e);\n+  disconnect_dest (e);\n \n   free_edge (e);\n }\n@@ -375,22 +403,15 @@ remove_edge (edge e)\n void\n redirect_edge_succ (edge e, basic_block new_succ)\n {\n-  basic_block dest = e->dest;\n-  unsigned int dest_idx = e->dest_idx;\n-\n   execute_on_shrinking_pred (e);\n \n-  VEC_unordered_remove (edge, dest->preds, dest_idx);\n+  disconnect_dest (e);\n \n-  /* If we removed an edge in the middle of the edge vector, we need\n-     to update dest_idx of the edge that moved into the \"hole\".  */\n-  if (dest_idx < EDGE_COUNT (dest->preds))\n-    EDGE_PRED (dest, dest_idx)->dest_idx = dest_idx;\n+  e->dest = new_succ;\n \n   /* Reconnect the edge to the new successor block.  */\n-  VEC_safe_push (edge, new_succ->preds, e);\n-  e->dest = new_succ;\n-  e->dest_idx = EDGE_COUNT (new_succ->preds) - 1;\n+  connect_dest (e);\n+\n   execute_on_growing_pred (e);\n }\n \n@@ -423,28 +444,12 @@ redirect_edge_succ_nodup (edge e, basic_block new_succ)\n void\n redirect_edge_pred (edge e, basic_block new_pred)\n {\n-  edge tmp;\n-  edge_iterator ei;\n-  bool found = false;\n+  disconnect_src (e);\n \n-  /* Disconnect the edge from the old predecessor block.  */\n-  for (ei = ei_start (e->src->succs); (tmp = ei_safe_edge (ei)); )\n-    {\n-      if (tmp == e)\n-\t{\n-\t  VEC_unordered_remove (edge, e->src->succs, ei.index);\n-\t  found = true;\n-\t  break;\n-\t}\n-      else\n-\tei_next (&ei);\n-    }\n-\n-  gcc_assert (found);\n+  e->src = new_pred;\n \n   /* Reconnect the edge to the new predecessor block.  */\n-  VEC_safe_push (edge, new_pred->succs, e);\n-  e->src = new_pred;\n+  connect_src (e);\n }\n \n /* Clear all basic block flags, with the exception of partitioning.  */"}]}