{"sha": "65963943e9cd1d4b7a47493d076123efd7708a65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU5NjM5NDNlOWNkMWQ0YjdhNDc0OTNkMDc2MTIzZWZkNzcwOGE2NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-10-27T11:18:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-10-27T11:18:51Z"}, "message": "Initial revision\n\nFrom-SVN: r49", "tree": {"sha": "ebf2359445d27b992a5ff55940890fc2fb49f4d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebf2359445d27b992a5ff55940890fc2fb49f4d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65963943e9cd1d4b7a47493d076123efd7708a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65963943e9cd1d4b7a47493d076123efd7708a65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65963943e9cd1d4b7a47493d076123efd7708a65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65963943e9cd1d4b7a47493d076123efd7708a65/comments", "author": null, "committer": null, "parents": [{"sha": "32f30c531243494a3a15be961b278219ceb61d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32f30c531243494a3a15be961b278219ceb61d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32f30c531243494a3a15be961b278219ceb61d16"}], "stats": {"total": 743, "additions": 743, "deletions": 0}, "files": [{"sha": "86ed20d5805347227d5d01161973529ee6035c37", "filename": "gcc/genemit.c", "status": "added", "additions": 743, "deletions": 0, "changes": 743, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65963943e9cd1d4b7a47493d076123efd7708a65/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65963943e9cd1d4b7a47493d076123efd7708a65/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=65963943e9cd1d4b7a47493d076123efd7708a65", "patch": "@@ -0,0 +1,743 @@\n+/* Generate code from machine description to emit insns as rtl.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+static int max_opno;\n+static int max_dup_opno;\n+static int register_constraints;\n+static int insn_code_number;\n+static int insn_index_number;\n+\n+/* Data structure for recording the patterns of insns that have CLOBBERs.\n+   We use this to output a function that adds these CLOBBERs to a \n+   previously-allocated PARALLEL expression.  */\n+\n+struct clobber_pat\n+{\n+  int code_number;\t\t/* Counts only insns.  */\n+  rtx pattern;\n+  int first_clobber;\n+  struct clobber_pat *next;\n+} *clobber_list;\n+\n+static void\n+max_operand_1 (x)\n+     rtx x;\n+{\n+  register RTX_CODE code;\n+  register int i;\n+  register int len;\n+  register char *fmt;\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  if (code == MATCH_OPERAND && XSTR (x, 2) != 0 && *XSTR (x, 2) != '\\0')\n+    register_constraints = 1;\n+  if (code == MATCH_SCRATCH && XSTR (x, 1) != 0 && *XSTR (x, 1) != '\\0')\n+    register_constraints = 1;\n+  if (code == MATCH_OPERAND || code == MATCH_OPERATOR\n+      || code == MATCH_PARALLEL)\n+    max_opno = MAX (max_opno, XINT (x, 0));\n+  if (code == MATCH_DUP || code == MATCH_OP_DUP)\n+    max_dup_opno = MAX (max_dup_opno, XINT (x, 0));\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      if (fmt[i] == 'e' || fmt[i] == 'u')\n+\tmax_operand_1 (XEXP (x, i));\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    max_operand_1 (XVECEXP (x, i, j));\n+\t}\n+    }\n+}\n+\n+static int\n+max_operand_vec (insn, arg)\n+     rtx insn;\n+     int arg;\n+{\n+  register int len = XVECLEN (insn, arg);\n+  register int i;\n+\n+  max_opno = -1;\n+  max_dup_opno = -1;\n+\n+  for (i = 0; i < len; i++)\n+    max_operand_1 (XVECEXP (insn, arg, i));\n+\n+  return max_opno + 1;\n+}\n+\f\n+static void\n+print_code (code)\n+     RTX_CODE code;\n+{\n+  register char *p1;\n+  for (p1 = GET_RTX_NAME (code); *p1; p1++)\n+    {\n+      if (*p1 >= 'a' && *p1 <= 'z')\n+\tputchar (*p1 + 'A' - 'a');\n+      else\n+\tputchar (*p1);\n+    }\n+}\n+\n+/* Print a C expression to construct an RTX just like X,\n+   substituting any operand references appearing within.  */\n+\n+static void\n+gen_exp (x)\n+     rtx x;\n+{\n+  register RTX_CODE code;\n+  register int i;\n+  register int len;\n+  register char *fmt;\n+\n+  if (x == 0)\n+    {\n+      printf (\"0\");\n+      return;\n+    }\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case MATCH_OPERAND:\n+    case MATCH_DUP:\n+      printf (\"operand%d\", XINT (x, 0));\n+      return;\n+\n+    case MATCH_OP_DUP:\n+      printf (\"gen_rtx (GET_CODE (operand%d), GET_MODE (operand%d)\",\n+\t      XINT (x, 0), XINT (x, 0));\n+      for (i = 0; i < XVECLEN (x, 1); i++)\n+\t{\n+\t  printf (\",\\n\\t\\t\");\n+\t  gen_exp (XVECEXP (x, 1, i));\n+\t}\n+      printf (\")\");\n+      return;\n+\n+    case MATCH_OPERATOR:\n+      printf (\"gen_rtx (GET_CODE (operand%d)\", XINT (x, 0));\n+      printf (\", %smode\", GET_MODE_NAME (GET_MODE (x)));\n+      for (i = 0; i < XVECLEN (x, 2); i++)\n+\t{\n+\t  printf (\",\\n\\t\\t\");\n+\t  gen_exp (XVECEXP (x, 2, i));\n+\t}\n+      printf (\")\");\n+      return;\n+\n+    case MATCH_PARALLEL:\n+      printf (\"operand%d\", XINT (x, 0));\n+      return;\n+\n+    case MATCH_SCRATCH:\n+      printf (\"gen_rtx (SCRATCH, %smode, 0)\", GET_MODE_NAME (GET_MODE (x)));\n+      return;\n+\n+    case ADDRESS:\n+      fatal (\"ADDRESS expression code used in named instruction pattern\");\n+\n+    case PC:\n+      printf (\"pc_rtx\");\n+      return;\n+\n+    case CC0:\n+      printf (\"cc0_rtx\");\n+      return;\n+\n+    case CONST_INT:\n+      if (INTVAL (x) == 0)\n+\t{\n+\t  printf (\"const0_rtx\");\n+\t  return;\n+\t}\n+      if (INTVAL (x) == 1)\n+\t{\n+\t  printf (\"const1_rtx\");\n+\t  return;\n+\t}\n+      if (INTVAL (x) == -1)\n+\t{\n+\t  printf (\"constm1_rtx\");\n+\t  return;\n+\t}\n+      if (INTVAL (x) == STORE_FLAG_VALUE)\n+\t{\n+\t  printf (\"const_true_rtx\");\n+\t  return;\n+\t}\n+    }\n+\n+  printf (\"gen_rtx (\");\n+  print_code (code);\n+  printf (\", %smode\", GET_MODE_NAME (GET_MODE (x)));\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      if (fmt[i] == '0')\n+\tbreak;\n+      printf (\", \");\n+      if (fmt[i] == 'e' || fmt[i] == 'u')\n+\tgen_exp (XEXP (x, i));\n+      else if (fmt[i] == 'i')\n+\tprintf (\"%u\", (unsigned) XINT (x, i));\n+      else if (fmt[i] == 's')\n+\tprintf (\"\\\"%s\\\"\", XSTR (x, i));\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  printf (\"gen_rtvec (%d\", XVECLEN (x, i));\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    {\n+\t      printf (\",\\n\\t\\t\");\n+\t      gen_exp (XVECEXP (x, i, j));\n+\t    }\n+\t  printf (\")\");\n+\t}\n+      else\n+\tabort ();\n+    }\n+  printf (\")\");\n+}  \n+\f\n+/* Generate the `gen_...' function for a DEFINE_INSN.  */\n+\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  int operands;\n+  register int i;\n+\n+  /* See if the pattern for this insn ends with a group of CLOBBERs of (hard)\n+     registers or MATCH_SCRATCHes.  If so, store away the information for\n+     later. */\n+\n+  if (XVEC (insn, 1))\n+    {\n+      for (i = XVECLEN (insn, 1) - 1; i > 0; i--)\n+\tif (GET_CODE (XVECEXP (insn, 1, i)) != CLOBBER\n+\t    || (GET_CODE (XEXP (XVECEXP (insn, 1, i), 0)) != REG\n+\t\t&& GET_CODE (XEXP (XVECEXP (insn, 1, i), 0)) != MATCH_SCRATCH))\n+\t  break;\n+\n+      if (i != XVECLEN (insn, 1) - 1)\n+\t{\n+\t  register struct clobber_pat *new\n+\t    = (struct clobber_pat *) xmalloc (sizeof (struct clobber_pat));\n+\t  \n+\t  new->code_number = insn_code_number;\n+\t  new->pattern = insn;\n+\t  new->first_clobber = i + 1;\n+\t  new->next = clobber_list;\n+\t  clobber_list = new;\n+\t}\n+    }\n+\n+  /* Don't mention instructions whose names are the null string.\n+     They are in the machine description just to be recognized.  */\n+  if (strlen (XSTR (insn, 0)) == 0)\n+    return;\n+\n+  /* Find out how many operands this function has,\n+     and also whether any of them have register constraints.  */\n+  register_constraints = 0;\n+  operands = max_operand_vec (insn, 1);\n+  if (max_dup_opno >= operands)\n+    fatal (\"match_dup operand number has no match_operand\");\n+\n+  /* Output the function name and argument declarations.  */\n+  printf (\"rtx\\ngen_%s (\", XSTR (insn, 0));\n+  for (i = 0; i < operands; i++)\n+    printf (i ? \", operand%d\" : \"operand%d\", i);\n+  printf (\")\\n\");\n+  for (i = 0; i < operands; i++)\n+    printf (\"     rtx operand%d;\\n\", i);\n+  printf (\"{\\n\");\n+\n+  /* Output code to construct and return the rtl for the instruction body */\n+\n+  if (XVECLEN (insn, 1) == 1)\n+    {\n+      printf (\"  return \");\n+      gen_exp (XVECEXP (insn, 1, 0));\n+      printf (\";\\n}\\n\\n\");\n+    }\n+  else\n+    {\n+      printf (\"  return gen_rtx (PARALLEL, VOIDmode, gen_rtvec (%d\", XVECLEN (insn, 1));\n+      for (i = 0; i < XVECLEN (insn, 1); i++)\n+\t{\n+\t  printf (\",\\n\\t\\t\");\n+\t  gen_exp (XVECEXP (insn, 1, i));\n+\t}\n+      printf (\"));\\n}\\n\\n\");\n+    }\n+}\n+\f\n+/* Generate the `gen_...' function for a DEFINE_EXPAND.  */\n+\n+static void\n+gen_expand (expand)\n+     rtx expand;\n+{\n+  int operands;\n+  register int i;\n+\n+  if (strlen (XSTR (expand, 0)) == 0)\n+    fatal (\"define_expand lacks a name\");\n+  if (XVEC (expand, 1) == 0)\n+    fatal (\"define_expand for %s lacks a pattern\", XSTR (expand, 0));\n+\n+  /* Find out how many operands this function has,\n+     and also whether any of them have register constraints.  */\n+  register_constraints = 0;\n+\n+  operands = max_operand_vec (expand, 1);\n+\n+  /* Output the function name and argument declarations.  */\n+  printf (\"rtx\\ngen_%s (\", XSTR (expand, 0));\n+  for (i = 0; i < operands; i++)\n+    printf (i ? \", operand%d\" : \"operand%d\", i);\n+  printf (\")\\n\");\n+  for (i = 0; i < operands; i++)\n+    printf (\"     rtx operand%d;\\n\", i);\n+  printf (\"{\\n\");\n+\n+  /* If we don't have any C code to write, only one insn is being written,\n+     and no MATCH_DUPs are present, we can just return the desired insn\n+     like we do for a DEFINE_INSN.  This saves memory.  */\n+  if ((XSTR (expand, 3) == 0 || *XSTR (expand, 3) == '\\0')\n+      && operands > max_dup_opno\n+      && XVECLEN (expand, 1) == 1)\n+    {\n+      printf (\"  return \");\n+      gen_exp (XVECEXP (expand, 1, 0));\n+      printf (\";\\n}\\n\\n\");\n+      return;\n+    }\n+\n+  /* For each operand referred to only with MATCH_DUPs,\n+     make a local variable.  */\n+  for (i = operands; i <= max_dup_opno; i++)\n+    printf (\"  rtx operand%d;\\n\", i);\n+  if (operands > 0 || max_dup_opno >= 0)\n+    printf (\"  rtx operands[%d];\\n\", MAX (operands, max_dup_opno + 1));\n+  printf (\"  rtx _val = 0;\\n\");\n+  printf (\"  start_sequence ();\\n\");\n+\n+  /* The fourth operand of DEFINE_EXPAND is some code to be executed\n+     before the actual construction.\n+     This code expects to refer to `operands'\n+     just as the output-code in a DEFINE_INSN does,\n+     but here `operands' is an automatic array.\n+     So copy the operand values there before executing it.  */\n+  if (XSTR (expand, 3) && *XSTR (expand, 3))\n+    {\n+      /* Output code to copy the arguments into `operands'.  */\n+      for (i = 0; i < operands; i++)\n+\tprintf (\"  operands[%d] = operand%d;\\n\", i, i);\n+\n+      /* Output the special code to be executed before the sequence\n+\t is generated.  */\n+      printf (\"%s\\n\", XSTR (expand, 3));\n+\n+      /* Output code to copy the arguments back out of `operands'\n+\t (unless we aren't going to use them at all).  */\n+      if (XVEC (expand, 1) != 0)\n+\t{\n+\t  for (i = 0; i < operands; i++)\n+\t    printf (\"  operand%d = operands[%d];\\n\", i, i);\n+\t  for (; i <= max_dup_opno; i++)\n+\t    printf (\"  operand%d = operands[%d];\\n\", i, i);\n+\t}\n+    }\n+\n+  /* Output code to construct the rtl for the instruction bodies.\n+     Use emit_insn to add them to the sequence being accumulated.\n+     But don't do this if the user's code has set `no_more' nonzero.  */\n+\n+  for (i = 0; i < XVECLEN (expand, 1); i++)\n+    {\n+      rtx next = XVECEXP (expand, 1, i);\n+      if ((GET_CODE (next) == SET && GET_CODE (SET_DEST (next)) == PC)\n+\t  || (GET_CODE (next) == PARALLEL\n+\t      && GET_CODE (XVECEXP (next, 0, 0)) == SET\n+\t      && GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)\n+\t  || GET_CODE (next) == RETURN)\n+\tprintf (\"  emit_jump_insn (\");\n+      else if ((GET_CODE (next) == SET && GET_CODE (SET_SRC (next)) == CALL)\n+\t       || GET_CODE (next) == CALL\n+\t       || (GET_CODE (next) == PARALLEL\n+\t\t   && GET_CODE (XVECEXP (next, 0, 0)) == SET\n+\t\t   && GET_CODE (SET_SRC (XVECEXP (next, 0, 0))) == CALL)\n+\t       || (GET_CODE (next) == PARALLEL\n+\t\t   && GET_CODE (XVECEXP (next, 0, 0)) == CALL))\n+\tprintf (\"  emit_call_insn (\");\n+      else if (GET_CODE (next) == CODE_LABEL)\n+\tprintf (\"  emit_label (\");\n+      else if (GET_CODE (next) == MATCH_OPERAND\n+\t       || GET_CODE (next) == MATCH_OPERATOR\n+\t       || GET_CODE (next) == MATCH_PARALLEL\n+\t       || GET_CODE (next) == MATCH_OP_DUP\n+\t       || GET_CODE (next) == MATCH_DUP\n+\t       || GET_CODE (next) == PARALLEL)\n+\tprintf (\"  emit (\");\n+      else\n+\tprintf (\"  emit_insn (\");\n+      gen_exp (next);\n+      printf (\");\\n\");\n+      if (GET_CODE (next) == SET && GET_CODE (SET_DEST (next)) == PC\n+\t  && GET_CODE (SET_SRC (next)) == LABEL_REF)\n+\tprintf (\"  emit_barrier ();\");\n+    }\n+\n+  /* Call `gen_sequence' to make a SEQUENCE out of all the\n+     insns emitted within this gen_... function.  */\n+\n+  printf (\" _done:\\n\");\n+  printf (\"  _val = gen_sequence ();\\n\");\n+  printf (\" _fail:\\n\");\n+  printf (\"  end_sequence ();\\n\");\n+  printf (\"  return _val;\\n}\\n\\n\");\n+}\n+\n+/* Like gen_expand, but generates a SEQUENCE.  */\n+static void\n+gen_split (split)\n+     rtx split;\n+{\n+  register int i;\n+  int operands;\n+\n+  if (XVEC (split, 0) == 0)\n+    fatal (\"define_split %d lacks a pattern\", insn_index_number);\n+  else if (XVEC (split, 2) == 0)\n+    fatal (\"define_split %d lacks a replacement pattern\", insn_index_number);\n+\n+  /* Find out how many operands this function has.  */\n+\n+  max_operand_vec (split, 2);\n+  operands = MAX (max_opno, max_dup_opno) + 1;\n+\n+  /* Output the function name and argument declarations.  */\n+  printf (\"rtx\\ngen_split_%d (operands)\\n     rtx *operands;\\n\",\n+\t  insn_code_number);\n+  printf (\"{\\n\");\n+\n+  /* Declare all local variables.  */\n+  for (i = 0; i < operands; i++)\n+    printf (\"  rtx operand%d;\\n\", i);\n+  printf (\"  rtx _val;\\n\");\n+  printf (\"  start_sequence ();\\n\");\n+\n+  /* The fourth operand of DEFINE_SPLIT is some code to be executed\n+     before the actual construction.  */\n+\n+  if (XSTR (split, 3))\n+    printf (\"%s\\n\", XSTR (split, 3));\n+\n+  /* Output code to copy the arguments back out of `operands'  */\n+  for (i = 0; i < operands; i++)\n+    printf (\"  operand%d = operands[%d];\\n\", i, i);\n+\n+  /* Output code to construct the rtl for the instruction bodies.\n+     Use emit_insn to add them to the sequence being accumulated.\n+     But don't do this if the user's code has set `no_more' nonzero.  */\n+\n+  for (i = 0; i < XVECLEN (split, 2); i++)\n+    {\n+      rtx next = XVECEXP (split, 2, i);\n+      if ((GET_CODE (next) == SET && GET_CODE (SET_DEST (next)) == PC)\n+\t  || (GET_CODE (next) == PARALLEL\n+\t      && GET_CODE (XVECEXP (next, 0, 0)) == SET\n+\t      && GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)\n+\t  || GET_CODE (next) == RETURN)\n+\tprintf (\"  emit_jump_insn (\");\n+      else if ((GET_CODE (next) == SET && GET_CODE (SET_SRC (next)) == CALL)\n+\t       || GET_CODE (next) == CALL\n+\t       || (GET_CODE (next) == PARALLEL\n+\t\t   && GET_CODE (XVECEXP (next, 0, 0)) == SET\n+\t\t   && GET_CODE (SET_SRC (XVECEXP (next, 0, 0))) == CALL)\n+\t       || (GET_CODE (next) == PARALLEL\n+\t\t   && GET_CODE (XVECEXP (next, 0, 0)) == CALL))\n+\tprintf (\"  emit_call_insn (\");\n+      else if (GET_CODE (next) == CODE_LABEL)\n+\tprintf (\"  emit_label (\");\n+      else if (GET_CODE (next) == MATCH_OPERAND\n+\t       || GET_CODE (next) == MATCH_OPERATOR\n+\t       || GET_CODE (next) == MATCH_PARALLEL\n+\t       || GET_CODE (next) == MATCH_OP_DUP\n+\t       || GET_CODE (next) == MATCH_DUP\n+\t       || GET_CODE (next) == PARALLEL)\n+\tprintf (\"  emit (\");\n+      else\n+\tprintf (\"  emit_insn (\");\n+      gen_exp (next);\n+      printf (\");\\n\");\n+      if (GET_CODE (next) == SET && GET_CODE (SET_DEST (next)) == PC\n+\t  && GET_CODE (SET_SRC (next)) == LABEL_REF)\n+\tprintf (\"  emit_barrier ();\");\n+    }\n+\n+  /* Call `gen_sequence' to make a SEQUENCE out of all the\n+     insns emitted within this gen_... function.  */\n+\n+  printf (\" _done:\\n\");\n+  printf (\"  _val = gen_sequence ();\\n\");\n+  printf (\" _fail:\\n\");\n+  printf (\"  end_sequence ();\\n\");\n+  printf (\"  return _val;\\n}\\n\\n\");\n+}\n+\f\n+/* Write a function, `add_clobbers', that is given a PARALLEL of sufficient\n+   size for the insn and an INSN_CODE, and inserts the required CLOBBERs at\n+   the end of the vector.  */\n+\n+static void\n+output_add_clobbers ()\n+{\n+  struct clobber_pat *clobber;\n+  int i;\n+\n+  printf (\"\\n\\nvoid\\nadd_clobbers (pattern, insn_code_number)\\n\");\n+  printf (\"     rtx pattern;\\n     int insn_code_number;\\n\");\n+  printf (\"{\\n\");\n+  printf (\"  int i;\\n\\n\");\n+  printf (\"  switch (insn_code_number)\\n\");\n+  printf (\"    {\\n\");\n+\n+  for (clobber = clobber_list; clobber; clobber = clobber->next)\n+    {\n+      printf (\"    case %d:\\n\", clobber->code_number);\n+\n+      for (i = clobber->first_clobber; i < XVECLEN (clobber->pattern, 1); i++)\n+\t{\n+\t  printf (\"      XVECEXP (pattern, 0, %d) = \", i);\n+\t  gen_exp (XVECEXP (clobber->pattern, 1, i));\n+\t  printf (\";\\n\");\n+\t}\n+\n+      printf (\"      break;\\n\");\n+    }\n+\n+  printf (\"    default:\\n\");\n+  printf (\"      abort ();\\n\");\n+  printf (\"    }\\n\");\n+  printf (\"}\\n\");\n+}\n+\f\n+/* Write a function, init_mov_optab, that is called to set up entries\n+   in mov_optab for EXTRA_CC_MODES.  */\n+\n+static void\n+output_init_mov_optab ()\n+{\n+#ifdef EXTRA_CC_NAMES\n+  static char *cc_names[] = { EXTRA_CC_NAMES };\n+  char *p;\n+  int i;\n+\n+  printf (\"\\nvoid\\ninit_mov_optab ()\\n{\\n\");\n+\n+  for (i = 0; i < sizeof cc_names / sizeof cc_names[0]; i++)\n+    {\n+      printf (\"#ifdef HAVE_mov\");\n+      for (p = cc_names[i]; *p; p++)\n+\tprintf (\"%c\", *p >= 'A' && *p <= 'Z' ? *p - 'A' + 'a' : *p);\n+      printf (\"\\n\");\n+      printf (\"  if (HAVE_mov\");\n+      for (p = cc_names[i]; *p; p++)\n+\tprintf (\"%c\", *p >= 'A' && *p <= 'Z' ? *p - 'A' + 'a' : *p);\n+      printf (\")\\n\");\n+      printf (\"    mov_optab->handlers[(int) %smode].insn_code = CODE_FOR_mov\",\n+\t      cc_names[i]);\n+      for (p = cc_names[i]; *p; p++)\n+\tprintf (\"%c\", *p >= 'A' && *p <= 'Z' ? *p - 'A' + 'a' : *p);\n+      printf (\";\\n#endif\\n\");\n+    }\n+\n+  printf (\"}\\n\");\n+#endif\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genemit: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  /* Assign sequential codes to all entries in the machine description\n+     in parallel with the tables in insn-output.c.  */\n+\n+  insn_code_number = 0;\n+  insn_index_number = 0;\n+\n+  printf (\"/* Generated automatically by the program `genemit'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"expr.h\\\"\\n\");\n+  printf (\"#include \\\"real.h\\\"\\n\");\n+  printf (\"#include \\\"output.h\\\"\\n\");\n+  printf (\"#include \\\"insn-config.h\\\"\\n\\n\");\n+  printf (\"#include \\\"insn-flags.h\\\"\\n\\n\");\n+  printf (\"#include \\\"insn-codes.h\\\"\\n\\n\");\n+  printf (\"extern char *insn_operand_constraint[][MAX_RECOG_OPERANDS];\\n\\n\");\n+  printf (\"extern rtx recog_operand[];\\n\");\n+  printf (\"#define operands emit_operand\\n\\n\");\n+  printf (\"#define FAIL goto _fail\\n\\n\");\n+  printf (\"#define DONE goto _done\\n\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN)\n+\t{\n+\t  gen_insn (desc);\n+\t  ++insn_code_number;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_EXPAND)\n+\t{\n+\t  gen_expand (desc);\n+\t  ++insn_code_number;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_SPLIT)\n+\t{\n+\t  gen_split (desc);\n+\t  ++insn_code_number;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n+\t{\n+\t  ++insn_code_number;\n+\t}\n+      ++insn_index_number;\n+    }\n+\n+  /* Write out the routine to add CLOBBERs to a pattern.  */\n+  output_add_clobbers ();\n+\n+  /* Write the routine to initialize mov_optab for the EXTRA_CC_MODES.  */\n+  output_init_mov_optab ();\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}]}