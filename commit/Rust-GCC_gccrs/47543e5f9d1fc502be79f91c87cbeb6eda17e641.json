{"sha": "47543e5f9d1fc502be79f91c87cbeb6eda17e641", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc1NDNlNWY5ZDFmYzUwMmJlNzlmOTFjODdjYmViNmVkYTE3ZTY0MQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-09-03T15:33:41Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-09-03T15:33:41Z"}, "message": "c++: shortcut bad convs during overload resolution [PR101904]\n\nIn the context of overload resolution we have the notion of a \"bad\"\nargument conversion, which is a conversion that \"would be a permitted\nwith a bending of the language standards\", and we handle such bad\nconversions specially.  In particular, we rank a bad conversion as\nbetter than no conversion but worse than a good conversion, and a bad\nconversion doesn't necessarily make a candidate unviable.  With the\nflag -fpermissive, we permit the situation where overload resolution\nselects a candidate that contains a bad conversion (which we call a\nnon-strictly viable candidate).  And without the flag, the caller\nof overload resolution usually issues a distinct permerror in this\nsituation instead.\n\nOne consequence of this defacto behavior is that in order to distinguish\na non-strictly viable candidate from an unviable candidate, if we\nencounter a bad argument conversion during overload resolution we must\nkeep converting subsequent arguments because a subsequent conversion\ncould render the candidate unviable instead of just non-strictly viable.\nBut checking subsequent arguments can force template instantiations and\nresult in otherwise avoidable hard errors.  And in particular, all\n'this' conversions are at worst bad, so this means the const/ref-qualifiers\nof a member function can't be used to prune a candidate quickly, which\nis the subject of the mentioned PR.\n\nThis patch tries to improve the situation without changing the defacto\noutput of add_candidates.  Specifically, when considering a candidate\nduring overload resolution this patch makes us shortcut argument\nconversion checking upon encountering the first bad conversion\n(tentatively marking the candidate as non-strictly viable, though it\ncould ultimately be unviable) under the assumption that we'll eventually\nfind a strictly viable candidate anyway (which renders moot the\ndistinction between non-strictly viable and unviable, since both are\nworse than a strictly viable candidate).  If this assumption turns out\nto be false, we'll fully reconsider the candidate under the defacto\nbehavior (without the shortcutting) so that all its conversions are\ncomputed.\n\nSo in the best case (there's a strictly viable candidate), we avoid\nsome argument conversions and/or template argument deduction that may\ncause a hard error.  In the worst case (there's no such candidate), we\nhave to redundantly consider some candidates twice.  (In a previous\nversion of the patch, to avoid this redundant checking I created a new\n\"deferred\" conversion type that represents a conversion that is yet to\nbe computed, and instead of reconsidering a candidate I just realized\nits deferred conversions.  But it doesn't seem this redundancy is a\nsignificant performance issue to justify the added complexity of this\nother approach.)\n\n\tPR c++/101904\n\ngcc/cp/ChangeLog:\n\n\t* call.c (build_this_conversion): New function, split out from\n\tadd_function_candidate.\n\t(add_function_candidate): New parameter shortcut_bad_convs.\n\tDocument it.  Use build_this_conversion.  Stop at the first bad\n\targument conversion when shortcut_bad_convs is true.\n\t(add_template_candidate_real): New parameter shortcut_bad_convs.\n\tUse build_this_conversion to check the 'this' conversion before\n\tattempting deduction.  When the rejection reason code is\n\trr_bad_arg_conversion, pass -1 instead of 0 as the viable\n\tparameter to add_candidate.  Pass 'convs' to add_candidate.\n\t(add_template_candidate): New parameter shortcut_bad_convs.\n\t(add_template_conv_candidate): Pass false as shortcut_bad_convs\n\tto add_template_candidate_real.\n\t(add_candidates): Prefer to shortcut bad conversions during\n\toverload resolution under the assumption that we'll eventually\n\tsee a strictly viable candidate.  If this assumption turns out\n\tto be false, re-process the non-strictly viable candidates\n\twithout shortcutting those bad conversions.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/conv17.C: New test.", "tree": {"sha": "b3f5fe0f96b4266d9d2bb45ca8b866aeee859117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3f5fe0f96b4266d9d2bb45ca8b866aeee859117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47543e5f9d1fc502be79f91c87cbeb6eda17e641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47543e5f9d1fc502be79f91c87cbeb6eda17e641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47543e5f9d1fc502be79f91c87cbeb6eda17e641", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47543e5f9d1fc502be79f91c87cbeb6eda17e641/comments", "author": null, "committer": null, "parents": [{"sha": "3ccb523bdd78e6ba3c133064be90cdf19dcbf896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccb523bdd78e6ba3c133064be90cdf19dcbf896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccb523bdd78e6ba3c133064be90cdf19dcbf896"}], "stats": {"total": 306, "additions": 233, "deletions": 73}, "files": [{"sha": "b6011c1a2822ae2569df6284c8f20d718ddff03d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 177, "deletions": 73, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47543e5f9d1fc502be79f91c87cbeb6eda17e641/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47543e5f9d1fc502be79f91c87cbeb6eda17e641/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=47543e5f9d1fc502be79f91c87cbeb6eda17e641", "patch": "@@ -175,17 +175,17 @@ static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, const vec<tree, va_gc> *,\n-\t tree, tree, tree, int, unification_kind_t, tsubst_flags_t);\n+\t tree, tree, tree, int, unification_kind_t, bool, tsubst_flags_t);\n static struct z_candidate *add_template_candidate_real\n \t(struct z_candidate **, tree, tree, tree, tree, const vec<tree, va_gc> *,\n-\t tree, tree, tree, int, tree, unification_kind_t, tsubst_flags_t);\n+\t tree, tree, tree, int, tree, unification_kind_t, bool, tsubst_flags_t);\n static bool is_complete (tree);\n static struct z_candidate *add_conv_candidate\n \t(struct z_candidate **, tree, tree, const vec<tree, va_gc> *, tree,\n \t tree, tsubst_flags_t);\n static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, const vec<tree, va_gc> *, tree,\n-\t tree, int, conversion**, tsubst_flags_t);\n+\t tree, int, conversion**, bool, tsubst_flags_t);\n static conversion *implicit_conversion (tree, tree, tree, bool, int,\n \t\t\t\t\ttsubst_flags_t);\n static conversion *reference_binding (tree, tree, tree, bool, int,\n@@ -2242,21 +2242,79 @@ conv_flags (int i, int nargs, tree fn, tree arg, int flags)\n   return lflags;\n }\n \n+/* Build an appropriate 'this' conversion for the method FN and class\n+   type CTYPE from the value ARG (having type ARGTYPE) to the type PARMTYPE.\n+   This function modifies PARMTYPE, ARGTYPE and ARG.  */\n+\n+static conversion *\n+build_this_conversion (tree fn, tree ctype,\n+\t\t       tree& parmtype, tree& argtype, tree& arg,\n+\t\t       int flags, tsubst_flags_t complain)\n+{\n+  gcc_assert (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n+\t      && !DECL_CONSTRUCTOR_P (fn));\n+\n+  /* The type of the implicit object parameter ('this') for\n+     overload resolution is not always the same as for the\n+     function itself; conversion functions are considered to\n+     be members of the class being converted, and functions\n+     introduced by a using-declaration are considered to be\n+     members of the class that uses them.\n+\n+     Since build_over_call ignores the ICS for the `this'\n+     parameter, we can just change the parm type.  */\n+  parmtype = cp_build_qualified_type (ctype,\n+\t\t\t\t      cp_type_quals (TREE_TYPE (parmtype)));\n+  bool this_p = true;\n+  if (FUNCTION_REF_QUALIFIED (TREE_TYPE (fn)))\n+    {\n+      /* If the function has a ref-qualifier, the implicit\n+\t object parameter has reference type.  */\n+      bool rv = FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (fn));\n+      parmtype = cp_build_reference_type (parmtype, rv);\n+      /* The special handling of 'this' conversions in compare_ics\n+\t does not apply if there is a ref-qualifier.  */\n+      this_p = false;\n+    }\n+  else\n+    {\n+      parmtype = build_pointer_type (parmtype);\n+      /* We don't use build_this here because we don't want to\n+\t capture the object argument until we've chosen a\n+\t non-static member function.  */\n+      arg = build_address (arg);\n+      argtype = lvalue_type (arg);\n+    }\n+  flags |= LOOKUP_ONLYCONVERTING;\n+  conversion *t = implicit_conversion (parmtype, argtype, arg,\n+\t\t\t\t       /*c_cast_p=*/false, flags, complain);\n+  t->this_p = this_p;\n+  return t;\n+}\n+\n /* Create an overload candidate for the function or method FN called\n    with the argument list FIRST_ARG/ARGS and add it to CANDIDATES.\n    FLAGS is passed on to implicit_conversion.\n \n    This does not change ARGS.\n \n    CTYPE, if non-NULL, is the type we want to pretend this function\n-   comes from for purposes of overload resolution.  */\n+   comes from for purposes of overload resolution.\n+\n+   SHORTCUT_BAD_CONVS controls how we handle \"bad\" argument conversions.\n+   If true, we stop computing conversions upon seeing the first bad\n+   conversion.  This is used by add_candidates to avoid computing\n+   more conversions than necessary in the presence of a strictly viable\n+   candidate, while preserving the defacto behavior of overload resolution\n+   when it turns out there are only non-strictly viable candidates.  */\n \n static struct z_candidate *\n add_function_candidate (struct z_candidate **candidates,\n \t\t\ttree fn, tree ctype, tree first_arg,\n \t\t\tconst vec<tree, va_gc> *args, tree access_path,\n \t\t\ttree conversion_path, int flags,\n \t\t\tconversion **convs,\n+\t\t\tbool shortcut_bad_convs,\n \t\t\ttsubst_flags_t complain)\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n@@ -2378,8 +2436,6 @@ add_function_candidate (struct z_candidate **candidates,\n     {\n       tree argtype, to_type;\n       tree arg;\n-      conversion *t;\n-      int is_this;\n \n       if (parmnode == void_list_node)\n \tbreak;\n@@ -2398,54 +2454,23 @@ add_function_candidate (struct z_candidate **candidates,\n \t\t(*args)[i + skip - (first_arg != NULL_TREE ? 1 : 0)]);\n       argtype = lvalue_type (arg);\n \n-      is_this = (i == 0 && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n-\t\t && ! DECL_CONSTRUCTOR_P (fn));\n-\n+      conversion *t;\n       if (parmnode)\n \t{\n \t  tree parmtype = TREE_VALUE (parmnode);\n-\n-\t  parmnode = TREE_CHAIN (parmnode);\n-\n-\t  /* The type of the implicit object parameter ('this') for\n-\t     overload resolution is not always the same as for the\n-\t     function itself; conversion functions are considered to\n-\t     be members of the class being converted, and functions\n-\t     introduced by a using-declaration are considered to be\n-\t     members of the class that uses them.\n-\n-\t     Since build_over_call ignores the ICS for the `this'\n-\t     parameter, we can just change the parm type.  */\n-\t  if (ctype && is_this)\n+\t  if (i == 0\n+\t      && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n+\t      && !DECL_CONSTRUCTOR_P (fn))\n+\t    t = build_this_conversion (fn, ctype, parmtype, argtype, arg,\n+\t\t\t\t       flags, complain);\n+\t  else\n \t    {\n-\t      parmtype = cp_build_qualified_type\n-\t\t(ctype, cp_type_quals (TREE_TYPE (parmtype)));\n-\t      if (FUNCTION_REF_QUALIFIED (TREE_TYPE (fn)))\n-\t\t{\n-\t\t  /* If the function has a ref-qualifier, the implicit\n-\t\t     object parameter has reference type.  */\n-\t\t  bool rv = FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (fn));\n-\t\t  parmtype = cp_build_reference_type (parmtype, rv);\n-\t\t  /* The special handling of 'this' conversions in compare_ics\n-\t\t     does not apply if there is a ref-qualifier.  */\n-\t\t  is_this = false;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  parmtype = build_pointer_type (parmtype);\n-\t\t  /* We don't use build_this here because we don't want to\n-\t\t     capture the object argument until we've chosen a\n-\t\t     non-static member function.  */\n-\t\t  arg = build_address (arg);\n-\t\t  argtype = lvalue_type (arg);\n-\t\t}\n+\t      int lflags = conv_flags (i, len-skip, fn, arg, flags);\n+\t      t = implicit_conversion (parmtype, argtype, arg,\n+\t\t\t\t       /*c_cast_p=*/false, lflags, complain);\n \t    }\n-\n-\t  int lflags = conv_flags (i, len-skip, fn, arg, flags);\n-\n-\t  t = implicit_conversion (parmtype, argtype, arg,\n-\t\t\t\t   /*c_cast_p=*/false, lflags, complain);\n \t  to_type = parmtype;\n+\t  parmnode = TREE_CHAIN (parmnode);\n \t}\n       else\n \t{\n@@ -2454,9 +2479,6 @@ add_function_candidate (struct z_candidate **candidates,\n \t  to_type = argtype;\n \t}\n \n-      if (t && is_this)\n-\tt->this_p = true;\n-\n       convs[i] = t;\n       if (! t)\n \t{\n@@ -2471,7 +2493,8 @@ add_function_candidate (struct z_candidate **candidates,\n \t  viable = -1;\n \t  reason = bad_arg_conversion_rejection (first_arg, i, arg, to_type,\n \t\t\t\t\t\t EXPR_LOCATION (arg));\n-\n+\t  if (shortcut_bad_convs)\n+\t    break;\n \t}\n     }\n \n@@ -3355,15 +3378,17 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n    This does not change ARGLIST.  The RETURN_TYPE is the desired type\n    for conversion operators.  If OBJ is NULL_TREE, FLAGS and CTYPE are\n    as for add_function_candidate.  If an OBJ is supplied, FLAGS and\n-   CTYPE are ignored, and OBJ is as for add_conv_candidate.  */\n+   CTYPE are ignored, and OBJ is as for add_conv_candidate.\n+\n+   SHORTCUT_BAD_CONVS is as in add_function_candidate.  */\n \n static struct z_candidate*\n add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \t\t\t     tree ctype, tree explicit_targs, tree first_arg,\n \t\t\t     const vec<tree, va_gc> *arglist, tree return_type,\n \t\t\t     tree access_path, tree conversion_path,\n \t\t\t     int flags, tree obj, unification_kind_t strict,\n-\t\t\t     tsubst_flags_t complain)\n+\t\t\t     bool shortcut_bad_convs, tsubst_flags_t complain)\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n@@ -3493,7 +3518,33 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \n   errs = errorcount+sorrycount;\n   if (!obj)\n-    convs = alloc_conversions (nargs);\n+    {\n+      convs = alloc_conversions (nargs);\n+\n+      if (shortcut_bad_convs\n+\t  && DECL_NONSTATIC_MEMBER_FUNCTION_P (tmpl)\n+\t  && !DECL_CONSTRUCTOR_P (tmpl))\n+\t{\n+\t  /* Check the 'this' conversion before proceeding with deduction.\n+\t     This is effectively an extension of the DR 1391 resolution\n+\t     that we perform in check_non_deducible_conversions, though it's\n+\t     convenient to do this extra check here instead of there.  */\n+\t  tree parmtype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (tmpl)));\n+\t  tree argtype = lvalue_type (first_arg);\n+\t  tree arg = first_arg;\n+\t  conversion *t = build_this_conversion (tmpl, ctype,\n+\t\t\t\t\t\t parmtype, argtype, arg,\n+\t\t\t\t\t\t flags, complain);\n+\t  convs[0] = t;\n+\t  if (t->bad_p)\n+\t    {\n+\t      reason = bad_arg_conversion_rejection (first_arg, 0,\n+\t\t\t\t\t\t     arg, parmtype,\n+\t\t\t\t\t\t     EXPR_LOCATION (arg));\n+\t      goto fail;\n+\t    }\n+\t}\n+    }\n   fn = fn_type_unification (tmpl, explicit_targs, targs,\n \t\t\t    args_without_in_chrg,\n \t\t\t    nargs_without_in_chrg,\n@@ -3540,7 +3591,8 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   else\n     cand = add_function_candidate (candidates, fn, ctype,\n \t\t\t\t   first_arg, arglist, access_path,\n-\t\t\t\t   conversion_path, flags, convs, complain);\n+\t\t\t\t   conversion_path, flags, convs,\n+\t\t\t\t   shortcut_bad_convs, complain);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n        class is specialized.  Then, instantiate_template might return\n@@ -3566,8 +3618,9 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \n   return cand;\n  fail:\n-  return add_candidate (candidates, tmpl, first_arg, arglist, nargs, NULL,\n-\t\t\taccess_path, conversion_path, 0, reason, flags);\n+  int viable = (reason->code == rr_bad_arg_conversion ? -1 : 0);\n+  return add_candidate (candidates, tmpl, first_arg, arglist, nargs, convs,\n+\t\t\taccess_path, conversion_path, viable, reason, flags);\n }\n \n \n@@ -3576,13 +3629,15 @@ add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n \t\t\ttree explicit_targs, tree first_arg,\n \t\t\tconst vec<tree, va_gc> *arglist, tree return_type,\n \t\t\ttree access_path, tree conversion_path, int flags,\n-\t\t\tunification_kind_t strict, tsubst_flags_t complain)\n+\t\t\tunification_kind_t strict, bool shortcut_bad_convs,\n+\t\t\ttsubst_flags_t complain)\n {\n   return\n     add_template_candidate_real (candidates, tmpl, ctype,\n \t\t\t\t explicit_targs, first_arg, arglist,\n \t\t\t\t return_type, access_path, conversion_path,\n-\t\t\t\t flags, NULL_TREE, strict, complain);\n+\t\t\t\t flags, NULL_TREE, strict, shortcut_bad_convs,\n+\t\t\t\t complain);\n }\n \n /* Create an overload candidate for the conversion function template TMPL,\n@@ -3608,7 +3663,7 @@ add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n \t\t\t\t NULL_TREE, arglist, return_type, access_path,\n \t\t\t\t conversion_path, 0, obj, DEDUCE_CALL,\n-\t\t\t\t complain);\n+\t\t\t\t /*shortcut_bad_convs=*/false, complain);\n }\n \n /* The CANDS are the set of candidates that were considered for\n@@ -6060,6 +6115,7 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n     /* Delay creating the implicit this parameter until it is needed.  */\n     non_static_args = NULL;\n \n+  bool seen_strictly_viable = any_strictly_viable (*candidates);\n   /* If there's a non-template perfect match, we don't need to consider\n      templates.  So check non-templates first.  This optimization is only\n      really needed for the defaulted copy constructor of tuple and the like\n@@ -6071,6 +6127,19 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n   else /*if (flags & LOOKUP_DEFAULTED)*/\n     which = non_templates;\n \n+  /* During overload resolution, we first consider each function under the\n+     assumption that we'll eventually find a strictly viable candidate.\n+     This allows us to circumvent our defacto behavior when checking\n+     argument conversions and shortcut consideration of the candidate\n+     upon encountering the first bad conversion.  If this assumption\n+     turns out to be false, and all candidates end up being non-strictly\n+     viable, then we reconsider such candidates under the defacto behavior.\n+     This trick is important for pruning member function overloads according\n+     to their const/ref-qualifiers (since all 'this' conversions are at\n+     worst bad) without breaking -fpermissive.  */\n+  tree bad_fns = NULL_TREE;\n+  bool shortcut_bad_convs = true;\n+\n  again:\n   for (tree fn : lkp_range (fns))\n     {\n@@ -6117,18 +6186,22 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t}\n \n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\tadd_template_candidate (candidates,\n-\t\t\t\tfn,\n-\t\t\t\tctype,\n-\t\t\t\texplicit_targs,\n-\t\t\t\tfn_first_arg,\n-\t\t\t\tfn_args,\n-\t\t\t\treturn_type,\n-\t\t\t\taccess_path,\n-\t\t\t\tconversion_path,\n-\t\t\t\tflags,\n-\t\t\t\tstrict,\n-\t\t\t\tcomplain);\n+\t{\n+\t  if (!add_template_candidate (candidates,\n+\t\t\t\t       fn,\n+\t\t\t\t       ctype,\n+\t\t\t\t       explicit_targs,\n+\t\t\t\t       fn_first_arg,\n+\t\t\t\t       fn_args,\n+\t\t\t\t       return_type,\n+\t\t\t\t       access_path,\n+\t\t\t\t       conversion_path,\n+\t\t\t\t       flags,\n+\t\t\t\t       strict,\n+\t\t\t\t       shortcut_bad_convs,\n+\t\t\t\t       complain))\n+\t    continue;\n+\t}\n       else\n \t{\n \t  add_function_candidate (candidates,\n@@ -6140,16 +6213,47 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t\t\t\t  conversion_path,\n \t\t\t\t  flags,\n \t\t\t\t  NULL,\n+\t\t\t\t  shortcut_bad_convs,\n \t\t\t\t  complain);\n \t  if (perfect_candidate_p (*candidates))\n \t    seen_perfect = true;\n \t}\n+\n+      z_candidate *cand = *candidates;\n+      if (cand->viable == 1)\n+\tseen_strictly_viable = true;\n+\n+      if (cand->viable == -1\n+\t  && shortcut_bad_convs\n+\t  && !cand->convs[cand->reversed () ? 0 : cand->num_convs - 1])\n+\t{\n+\t  /* This candidate has been tentatively marked non-strictly viable,\n+\t     and we didn't compute all argument conversions for it (having\n+\t     stopped at the first bad conversion).  Add the function to BAD_FNS\n+\t     to fully reconsider later if we don't find any strictly viable\n+\t     candidates.  */\n+\t  bad_fns = lookup_add (fn, bad_fns);\n+\t  *candidates = (*candidates)->next;\n+\t}\n     }\n   if (which == non_templates && !seen_perfect)\n     {\n       which = templates;\n       goto again;\n     }\n+  else if (which == templates\n+\t   && !seen_strictly_viable\n+\t   && shortcut_bad_convs\n+\t   && bad_fns)\n+    {\n+      /* None of the candidates are strictly viable, so consider again those\n+\t functions in BAD_FNS, this time without shortcutting bad conversions\n+\t so that all their argument conversions are computed.  */\n+      which = either;\n+      fns = bad_fns;\n+      shortcut_bad_convs = false;\n+      goto again;\n+    }\n }\n \n /* Returns 1 if P0145R2 says that the LHS of operator CODE is evaluated first,"}, {"sha": "ba012c9d1fa2bb4157d8bca1751412eb6addec1c", "filename": "gcc/testsuite/g++.dg/template/conv17.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47543e5f9d1fc502be79f91c87cbeb6eda17e641/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47543e5f9d1fc502be79f91c87cbeb6eda17e641/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv17.C?ref=47543e5f9d1fc502be79f91c87cbeb6eda17e641", "patch": "@@ -0,0 +1,56 @@\n+// PR c++/101904\n+// Verify we stop at the first bad argument conversion when considering a\n+// candidate during overload resolution.\n+\n+template<class T>\n+struct A { typedef typename T::type type; };\n+\n+struct B {\n+  // A conversion function that always induces a hard error when instantiated.\n+  template<class T> B(T, typename A<T>::type = 0);\n+};\n+\n+struct C {\n+  template<class T> void f(T, typename A<T>::type); // #1\n+  template<class T> void f(T, T) const;             // #2\n+\n+  static void g(int*, B);                           // #3\n+  static void g(int, int);                          // #4\n+\n+#if __cpp_ref_qualifiers\n+  void h(B) &;                                      // #5\n+  void h(int) &&;                                   // #6\n+#endif\n+};\n+\n+int main() {\n+  const C c;\n+\n+  // The bad conversion for the 'this' argument should preclude us from further\n+  // considering the non-const #1 (which would have caused a hard error during\n+  // instantiation).  This behavior is essentially DR 1391 extended to the\n+  // 'this' argument.\n+  c.f(0, 0); // resolves to #2\n+  c.f<int>(0, 0);\n+\n+  // Likewise for the bad conversion for the 1st argument in #3.\n+  C::g(42, 42); // resolves to #4\n+\n+#if __cpp_ref_qualifiers\n+  // Likewise for the bad 'this' conversion in #5.\n+  C().h(0); // resolves to #6\n+#endif\n+}\n+\n+#if __cpp_concepts\n+// Test the same calls in a SFINAE context.\n+template<class T>\n+concept D = requires (const T t) {\n+  t.f(0, 0);\n+  t.template f<int>(0, 0);\n+  T::g(42, 42);\n+  T().h(0);\n+};\n+\n+static_assert(D<C>);\n+#endif"}]}