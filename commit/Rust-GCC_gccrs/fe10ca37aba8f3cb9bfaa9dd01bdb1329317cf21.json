{"sha": "fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "node_id": "C_kwDOANBUbNoAKGZlMTBjYTM3YWJhOGYzY2I5YmZhYTlkZDAxYmRiMTMyOTMxN2NmMjE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-21T11:13:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-21T11:13:33Z"}, "message": "Handle parsing match arms with no comma\n\nWhen parsing a match expression such as:\n\n```\n    match (f, g) {\n        (Foo::A, 1) => {}\n        (Foo::B, 2) => {}\n        _ => {}\n    }\n```\n\nThe first match arm here has an empty block expression of {}. This was\nbeing parsed into a CallExpr of {}(Foo::B, 2) which is wrong. The parsing\nof match arms are expression statements so they can be a block but must not\nconsume the semi-colon as it is valid to have a comma to delimit the match\narm or it can be ignored if this is a ExprWithBlock.\n\nAddresses #1081", "tree": {"sha": "c4d4611d59da5be0c9476f2d1a62eaeef666b402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4d4611d59da5be0c9476f2d1a62eaeef666b402"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c18257c7265470a071f7ed9fe29899ece839fcf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c18257c7265470a071f7ed9fe29899ece839fcf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c18257c7265470a071f7ed9fe29899ece839fcf4"}], "stats": {"total": 30, "additions": 27, "deletions": 3}, "files": [{"sha": "25979cec56018209b2c47cdb39c87f1270815de7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "patch": "@@ -8563,7 +8563,11 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n \t  return nullptr;\n \t}\n \n-      std::unique_ptr<AST::Expr> expr = parse_expr ();\n+      ParseRestrictions restrictions;\n+      restrictions.expr_can_be_stmt = true;\n+      restrictions.consume_semi = false;\n+\n+      std::unique_ptr<AST::ExprStmt> expr = parse_expr_stmt ({}, restrictions);\n       if (expr == nullptr)\n \t{\n \t  Error error (lexer.peek_token ()->get_locus (),\n@@ -8573,10 +8577,30 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n \t  // skip somewhere?\n \t  return nullptr;\n \t}\n-      bool is_expr_without_block = expr->is_expr_without_block ();\n+      bool is_expr_without_block\n+\t= expr->get_type () == AST::ExprStmt::ExprStmtType::WITHOUT_BLOCK;\n \n       // construct match case expr and add to cases\n-      match_arms.push_back (AST::MatchCase (std::move (arm), std::move (expr)));\n+      switch (expr->get_type ())\n+\t{\n+\t  case AST::ExprStmt::ExprStmtType::WITH_BLOCK: {\n+\t    AST::ExprStmtWithBlock *cast\n+\t      = static_cast<AST::ExprStmtWithBlock *> (expr.get ());\n+\t    std::unique_ptr<AST::Expr> e = cast->get_expr ()->clone_expr ();\n+\t    match_arms.push_back (\n+\t      AST::MatchCase (std::move (arm), std::move (e)));\n+\t  }\n+\t  break;\n+\n+\t  case AST::ExprStmt::ExprStmtType::WITHOUT_BLOCK: {\n+\t    AST::ExprStmtWithoutBlock *cast\n+\t      = static_cast<AST::ExprStmtWithoutBlock *> (expr.get ());\n+\t    std::unique_ptr<AST::Expr> e = cast->get_expr ()->clone_expr ();\n+\t    match_arms.push_back (\n+\t      AST::MatchCase (std::move (arm), std::move (e)));\n+\t  }\n+\t  break;\n+\t}\n \n       // handle comma presence\n       if (lexer.peek_token ()->get_id () != COMMA)"}]}