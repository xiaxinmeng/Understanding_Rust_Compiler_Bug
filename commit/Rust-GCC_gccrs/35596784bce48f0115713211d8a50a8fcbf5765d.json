{"sha": "35596784bce48f0115713211d8a50a8fcbf5765d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1OTY3ODRiY2U0OGYwMTE1NzEzMjExZDhhNTBhOGZjYmY1NzY1ZA==", "commit": {"author": {"name": "Andrew Jenner", "email": "andrew@codesourcery.com", "date": "2008-07-30T16:28:01Z"}, "committer": {"name": "Andrew Jenner", "email": "andrewjenner@gcc.gnu.org", "date": "2008-07-30T16:28:01Z"}, "message": "arm.c (arm_compute_static_chain_stack_bytes): New function.\n\n\t* config/arm/arm.c (arm_compute_static_chain_stack_bytes): New\n\tfunction.\n\t(arm_compute_initial_elimination_offset): Use it.\n\t(arm_compute_save_reg_mask): Include static chain save slot when\n\tcalculating alignment.\n\t(arm_get_frame_offsets): Ditto.\n\t(thumb1_compute_save_reg_mask): Ensure we have a low register saved\n\tthat we can use to decrement the stack when the stack decrement\n\tcould be too big for an immediate value in a single insn.\n\t(thumb1_expand_prologue): Avoid using r12 for stack decrement.\n\nFrom-SVN: r138327", "tree": {"sha": "6fba9d2332e924a4748f8bebafcd41d640341793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fba9d2332e924a4748f8bebafcd41d640341793"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35596784bce48f0115713211d8a50a8fcbf5765d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35596784bce48f0115713211d8a50a8fcbf5765d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35596784bce48f0115713211d8a50a8fcbf5765d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35596784bce48f0115713211d8a50a8fcbf5765d/comments", "author": {"login": "andrewjenner", "id": 35463391, "node_id": "MDQ6VXNlcjM1NDYzMzkx", "avatar_url": "https://avatars.githubusercontent.com/u/35463391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewjenner", "html_url": "https://github.com/andrewjenner", "followers_url": "https://api.github.com/users/andrewjenner/followers", "following_url": "https://api.github.com/users/andrewjenner/following{/other_user}", "gists_url": "https://api.github.com/users/andrewjenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewjenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewjenner/subscriptions", "organizations_url": "https://api.github.com/users/andrewjenner/orgs", "repos_url": "https://api.github.com/users/andrewjenner/repos", "events_url": "https://api.github.com/users/andrewjenner/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewjenner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5cc6fa4136cc864b40250c61bffda2f506249192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc6fa4136cc864b40250c61bffda2f506249192", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cc6fa4136cc864b40250c61bffda2f506249192"}], "stats": {"total": 141, "additions": 79, "deletions": 62}, "files": [{"sha": "2951220b6eb25cdf50fbd30d4e394b4ac1f6a58b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35596784bce48f0115713211d8a50a8fcbf5765d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35596784bce48f0115713211d8a50a8fcbf5765d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35596784bce48f0115713211d8a50a8fcbf5765d", "patch": "@@ -1,3 +1,16 @@\n+2008-07-30  Andrew Jenner  <andrew@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_compute_static_chain_stack_bytes): New\n+        function.\n+\t(arm_compute_initial_elimination_offset): Use it.\n+\t(arm_compute_save_reg_mask): Include static chain save slot when\n+\tcalculating alignment.\n+\t(arm_get_frame_offsets): Ditto.\n+\t(thumb1_compute_save_reg_mask): Ensure we have a low register saved\n+\tthat we can use to decrement the stack when the stack decrement\n+\tcould be too big for an immediate value in a single insn.\n+\t(thumb1_expand_prologue): Avoid using r12 for stack decrement.\n+\n 2008-07-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36967"}, {"sha": "a89229ec12ac99455170d01bd690ab9bbb3864ad", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35596784bce48f0115713211d8a50a8fcbf5765d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35596784bce48f0115713211d8a50a8fcbf5765d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=35596784bce48f0115713211d8a50a8fcbf5765d", "patch": "@@ -62,6 +62,7 @@ const struct attribute_spec arm_attribute_table[];\n void (*arm_lang_output_object_attributes_hook)(void);\n \n /* Forward function declarations.  */\n+static int arm_compute_static_chain_stack_bytes (void);\n static arm_stack_offsets *arm_get_frame_offsets (void);\n static void arm_add_gc_roots (void);\n static int arm_gen_constant (enum rtx_code, enum machine_mode, rtx,\n@@ -10792,6 +10793,24 @@ arm_compute_save_reg0_reg12_mask (void)\n }\n \n \n+/* Compute the number of bytes used to store the static chain register on the \n+   stack, above the stack frame. We need to know this accurately to get the\n+   alignment of the rest of the stack frame correct. */\n+\n+static int arm_compute_static_chain_stack_bytes (void)\n+{\n+  unsigned long func_type = arm_current_func_type ();\n+  int static_chain_stack_bytes = 0;\n+\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM &&\n+      IS_NESTED (func_type) &&\n+      df_regs_ever_live_p (3) && crtl->args.pretend_args_size == 0)\n+    static_chain_stack_bytes = 4;\n+\n+  return static_chain_stack_bytes;\n+}\n+\n+\n /* Compute a bit mask of which registers need to be\n    saved on the stack for the current function.\n    This is used by arm_get_frame_offsets, which may add extra registers.  */\n@@ -10844,7 +10863,9 @@ arm_compute_save_reg_mask (void)\n \n   if (TARGET_REALLY_IWMMXT\n       && ((bit_count (save_reg_mask)\n-\t   + ARM_NUM_INTS (crtl->args.pretend_args_size)) % 2) != 0)\n+\t   + ARM_NUM_INTS (crtl->args.pretend_args_size +\n+\t\t\t   arm_compute_static_chain_stack_bytes())\n+\t   ) % 2) != 0)\n     {\n       /* The total number of registers that are going to be pushed\n \t onto the stack is odd.  We need to ensure that the stack\n@@ -10929,6 +10950,26 @@ thumb1_compute_save_reg_mask (void)\n \tmask |= 1 << reg;\n     }\n \n+  /* The 504 below is 8 bytes less than 512 because there are two possible\n+     alignment words.  We can't tell here if they will be present or not so we\n+     have to play it safe and assume that they are. */\n+  if ((CALLER_INTERWORKING_SLOT_SIZE +\n+       ROUND_UP_WORD (get_frame_size ()) +\n+       crtl->outgoing_args_size) >= 504)\n+    {\n+      /* This is the same as the code in thumb1_expand_prologue() which\n+\t determines which register to use for stack decrement. */\n+      for (reg = LAST_ARG_REGNUM + 1; reg <= LAST_LO_REGNUM; reg++)\n+\tif (mask & (1 << reg))\n+\t  break;\n+\n+      if (reg > LAST_LO_REGNUM)\n+\t{\n+\t  /* Make sure we have a register available for stack decrement. */\n+\t  mask |= 1 << LAST_LO_REGNUM;\n+\t}\n+    }\n+\n   return mask;\n }\n \n@@ -12064,7 +12105,8 @@ arm_get_frame_offsets (void)\n   offsets->saved_args = crtl->args.pretend_args_size;\n \n   /* In Thumb mode this is incorrect, but never used.  */\n-  offsets->frame = offsets->saved_args + (frame_pointer_needed ? 4 : 0);\n+  offsets->frame = offsets->saved_args + (frame_pointer_needed ? 4 : 0) +\n+                   arm_compute_static_chain_stack_bytes();\n \n   if (TARGET_32BIT)\n     {\n@@ -12111,7 +12153,8 @@ arm_get_frame_offsets (void)\n     }\n \n   /* Saved registers include the stack frame.  */\n-  offsets->saved_regs = offsets->saved_args + saved;\n+  offsets->saved_regs = offsets->saved_args + saved +\n+                        arm_compute_static_chain_stack_bytes();\n   offsets->soft_frame = offsets->saved_regs + CALLER_INTERWORKING_SLOT_SIZE;\n   /* A leaf function does not need any stack alignment if it has nothing\n      on the stack.  */\n@@ -12203,14 +12246,9 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t  return offsets->soft_frame - offsets->saved_args;\n \n \tcase ARM_HARD_FRAME_POINTER_REGNUM:\n-\t  /* If there is no stack frame then the hard\n-\t     frame pointer and the arg pointer coincide.  */\n-\t  if (offsets->frame == offsets->saved_regs)\n-\t    return 0;\n-\t  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */\n-\t  return (frame_pointer_needed\n-\t\t  && cfun->static_chain_decl != NULL\n-\t\t  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;\n+\t  /* This is only non-zero in the case where the static chain register\n+\t     is stored above the frame.  */\n+\t  return offsets->frame - offsets->saved_args - 4;\n \n \tcase STACK_POINTER_REGNUM:\n \t  /* If nothing has been pushed on the stack at all\n@@ -12498,6 +12536,9 @@ arm_expand_prologue (void)\n \t    insn = emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n \t  else if (args_to_push == 0)\n \t    {\n+\t      gcc_assert(arm_compute_static_chain_stack_bytes() == 4);\n+\t      saved_regs += 4;\n+\n \t      rtx dwarf;\n \n \t      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);\n@@ -17008,62 +17049,25 @@ thumb1_expand_prologue (void)\n \t     been pushed at the start of the prologue and so we can corrupt\n \t     it now.  */\n \t  for (regno = LAST_ARG_REGNUM + 1; regno <= LAST_LO_REGNUM; regno++)\n-\t    if (live_regs_mask & (1 << regno)\n-\t\t&& !(frame_pointer_needed\n-\t\t     && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))\n+\t    if (live_regs_mask & (1 << regno))\n \t      break;\n \n-\t  if (regno > LAST_LO_REGNUM) /* Very unlikely.  */\n-\t    {\n-\t      rtx spare = gen_rtx_REG (SImode, IP_REGNUM);\n-\n-\t      /* Choose an arbitrary, non-argument low register.  */\n-\t      reg = gen_rtx_REG (SImode, LAST_LO_REGNUM);\n-\n-\t      /* Save it by copying it into a high, scratch register.  */\n-\t      emit_insn (gen_movsi (spare, reg));\n-\t      /* Add a USE to stop propagate_one_insn() from barfing.  */\n-\t      emit_insn (gen_prologue_use (spare));\n+\t  gcc_assert(regno <= LAST_LO_REGNUM);\n \n-\t      /* Decrement the stack.  */\n-\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n-\t      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t\t    stack_pointer_rtx, reg));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t   plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t  -amount));\n-\t      RTX_FRAME_RELATED_P (dwarf) = 1;\n-\t      REG_NOTES (insn)\n-\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t     REG_NOTES (insn));\n-\n-\t      /* Restore the low register's original value.  */\n-\t      emit_insn (gen_movsi (reg, spare));\n-\n-\t      /* Emit a USE of the restored scratch register, so that flow\n-\t\t analysis will not consider the restore redundant.  The\n-\t\t register won't be used again in this function and isn't\n-\t\t restored by the epilogue.  */\n-\t      emit_insn (gen_prologue_use (reg));\n-\t    }\n-\t  else\n-\t    {\n-\t      reg = gen_rtx_REG (SImode, regno);\n+\t  reg = gen_rtx_REG (SImode, regno);\n \n-\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n+\t  emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n \n-\t      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t\t    stack_pointer_rtx, reg));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t   plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t  -amount));\n-\t      RTX_FRAME_RELATED_P (dwarf) = 1;\n-\t      REG_NOTES (insn)\n-\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t     REG_NOTES (insn));\n-\t    }\n+\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx, reg));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t      -amount));\n+\t  RTX_FRAME_RELATED_P (dwarf) = 1;\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n+\t\t\t\t REG_NOTES (insn));\n \t}\n     }\n "}]}