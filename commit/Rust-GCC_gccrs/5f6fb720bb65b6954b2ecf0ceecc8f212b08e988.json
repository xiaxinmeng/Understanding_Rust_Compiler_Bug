{"sha": "5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY2ZmI3MjBiYjY1YjY5NTRiMmVjZjBjZWVjYzhmMjEyYjA4ZTk4OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T15:02:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T15:02:05Z"}, "message": "[multiple changes]\n\n2014-07-29  Vincent Celier  <celier@adacore.com>\n\n\t* gnat_ugn.texi: Document that configuration pragmas files are\n\tadded to the dependencies, unless they contain only pragmas\n\tSource_File_Name_Project.\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* frontend.adb: Minor reformatting.\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb (Add_Call_By_Copy_Code): Minor reformatting\n\t(Expand_Actuals): Make sure predicate checks are properly applied\n\tfor the case of OUT or IN OUT parameters.\n\t* sem_res.adb: Minor reformatting (Resolve_Actuals): Skip\n\tpredicate tests on arguments for Finalize\n\t* sem_util.adb (No_Predicate_Test_On_Arguments): Returns True\n\tif predicate tests on subprogram arguments should be skipped.\n\t* sem_util.ads (No_Predicate_Test_On_Arguments): New function\n\n2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): If there is an address\n\tclause for the object and the expression is an aggregate, defer\n\tresolution and expansion of the aggregate until the freeze point\n\tof the entity.\n\t* sem_aggr.adb (Resolve_Aggregate): An others_clause is legal if\n\tthe parent node is an N_Reference generated during expansion.\n\n2014-07-29  Vincent Celier  <celier@adacore.com>\n\n\t* prj.adb (Add_To_Buffer): Effectively double the size of the buffer.\n\nFrom-SVN: r213209", "tree": {"sha": "99975ce04ccdb2cf387b17ba7c150f907dd6b0a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99975ce04ccdb2cf387b17ba7c150f907dd6b0a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/comments", "author": null, "committer": null, "parents": [{"sha": "fc27e20e722d17c847d82062e70787388b6d6997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc27e20e722d17c847d82062e70787388b6d6997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc27e20e722d17c847d82062e70787388b6d6997"}], "stats": {"total": 230, "additions": 174, "deletions": 56}, "files": [{"sha": "eb218d687a3e91811339d481eeb54fd6237f407d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -1,3 +1,37 @@\n+2014-07-29  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnat_ugn.texi: Document that configuration pragmas files are\n+\tadded to the dependencies, unless they contain only pragmas\n+\tSource_File_Name_Project.\n+\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* frontend.adb: Minor reformatting.\n+\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb (Add_Call_By_Copy_Code): Minor reformatting\n+\t(Expand_Actuals): Make sure predicate checks are properly applied\n+\tfor the case of OUT or IN OUT parameters.\n+\t* sem_res.adb: Minor reformatting (Resolve_Actuals): Skip\n+\tpredicate tests on arguments for Finalize\n+\t* sem_util.adb (No_Predicate_Test_On_Arguments): Returns True\n+\tif predicate tests on subprogram arguments should be skipped.\n+\t* sem_util.ads (No_Predicate_Test_On_Arguments): New function\n+\n+2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): If there is an address\n+\tclause for the object and the expression is an aggregate, defer\n+\tresolution and expansion of the aggregate until the freeze point\n+\tof the entity.\n+\t* sem_aggr.adb (Resolve_Aggregate): An others_clause is legal if\n+\tthe parent node is an N_Reference generated during expansion.\n+\n+2014-07-29  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj.adb (Add_To_Buffer): Effectively double the size of the buffer.\n+\n 2014-07-29  Robert Dewar  <dewar@adacore.com>\n \n \t* frontend.adb, inline.adb, sem_util.adb, sem_res.adb,"}, {"sha": "610aa170205c5da096a9f95e7fdaa9e1c10632de", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -23,7 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -190,6 +189,9 @@ package body Exp_Ch6 is\n    --  For non-scalar objects that are possibly unaligned, add call by copy\n    --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n    --\n+   --  For OUT and IN OUT parameters, add predicate checks after the call\n+   --  based on the predicates of the actual type.\n+   --\n    --  The parameter N is IN OUT because in some cases, the expansion code\n    --  rewrites the call as an expression actions with the call inside. In\n    --  this case N is reset to point to the inside call so that the caller\n@@ -1082,19 +1084,18 @@ package body Exp_Ch6 is\n                Init := Empty;\n                Indic :=\n                  Make_Subtype_Indication (Loc,\n-                   Subtype_Mark =>\n-                     New_Occurrence_Of (F_Typ, Loc),\n+                   Subtype_Mark => New_Occurrence_Of (F_Typ, Loc),\n                    Constraint   =>\n                      Make_Index_Or_Discriminant_Constraint (Loc,\n                        Constraints => New_List (\n                          Make_Range (Loc,\n                            Low_Bound  =>\n                              Make_Attribute_Reference (Loc,\n-                               Prefix => New_Occurrence_Of (Var, Loc),\n+                               Prefix         => New_Occurrence_Of (Var, Loc),\n                                Attribute_Name => Name_First),\n                            High_Bound =>\n                              Make_Attribute_Reference (Loc,\n-                               Prefix => New_Occurrence_Of (Var, Loc),\n+                               Prefix         => New_Occurrence_Of (Var, Loc),\n                                Attribute_Name => Name_Last)))));\n \n             else\n@@ -1720,7 +1721,7 @@ package body Exp_Ch6 is\n                Add_Call_By_Copy_Code;\n             end if;\n \n-            --  RM 3.2.4 (23/3) : A predicate is checked on in-out and out\n+            --  RM 3.2.4 (23/3): A predicate is checked on in-out and out\n             --  by-reference parameters on exit from the call. If the actual\n             --  is a derived type and the operation is inherited, the body\n             --  of the operation will not contain a call to the predicate\n@@ -1732,28 +1733,33 @@ package body Exp_Ch6 is\n             --  for subtype conversion on assignment, but we can generate the\n             --  required check now.\n \n-            --  Note that this is needed only if the subtype of the actual has\n-            --  an explicit predicate aspect, not if it inherits them from a\n-            --  base type or ancestor. The check is also superfluous if the\n-            --  subtype is elaborated before the body of the subprogram, but\n-            --  this is harder to verify, and there may be a redundant check.\n-\n             --  Note also that Subp may be either a subprogram entity for\n             --  direct calls, or a type entity for indirect calls, which must\n             --  be handled separately because the name does not denote an\n             --  overloadable entity.\n \n-            if not Is_Init_Proc (Subp)\n-              and then (Has_Aspect (E_Actual, Aspect_Predicate)\n-                          or else\n-                        Has_Aspect (E_Actual, Aspect_Dynamic_Predicate)\n-                          or else\n-                        Has_Aspect (E_Actual, Aspect_Static_Predicate))\n-              and then Present (Predicate_Function (E_Actual))\n-            then\n-               Append_To (Post_Call,\n-                 Make_Predicate_Check (E_Actual, Actual));\n-            end if;\n+            declare\n+               Aund : constant Entity_Id := Underlying_Type (E_Actual);\n+               Atyp : Entity_Id;\n+\n+            begin\n+               if No (Aund) then\n+                  Atyp := E_Actual;\n+               else\n+                  Atyp := Aund;\n+               end if;\n+\n+               if Has_Predicates (Atyp)\n+                 and then Present (Predicate_Function (Atyp))\n+\n+                 --  Skip predicate checks for special cases\n+\n+                 and then not No_Predicate_Test_On_Arguments (Subp)\n+               then\n+                  Append_To (Post_Call,\n+                    Make_Predicate_Check (Atyp, Actual));\n+               end if;\n+            end;\n \n          --  Processing for IN parameters\n "}, {"sha": "020fab44682de14f66c77ccd0a68811c7c97f8e0", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -71,8 +71,8 @@ procedure Frontend is\n    Config_Pragmas : List_Id;\n    --  Gather configuration pragmas\n \n-   function Need_To_Be_In_The_Dependencies (Pragma_List : List_Id)\n-     return Boolean;\n+   function Need_To_Be_In_The_Dependencies\n+     (Pragma_List : List_Id) return Boolean;\n    --  Check if a configuration pragmas file that contains the Pragma_List\n    --  should be a dependency for the source being compiled. Returns\n    --  False if Pragma_List is Error_List or contains only pragmas\n@@ -82,11 +82,12 @@ procedure Frontend is\n    -- Need_To_Be_In_The_Dependencies --\n    ------------------------------------\n \n-   function Need_To_Be_In_The_Dependencies (Pragma_List : List_Id)\n-     return Boolean\n+   function Need_To_Be_In_The_Dependencies\n+     (Pragma_List : List_Id) return Boolean\n    is\n       Prag  : Node_Id;\n       Pname : Name_Id;\n+\n    begin\n       if Pragma_List /= Error_List then\n          Prag := First (Pragma_List);\n@@ -104,6 +105,8 @@ procedure Frontend is\n       return False;\n    end Need_To_Be_In_The_Dependencies;\n \n+--  Start of processing for Frontend\n+\n begin\n    --  Carry out package initializations. These are initializations which might\n    --  logically be performed at elaboration time, were it not for the fact\n@@ -272,7 +275,8 @@ begin\n \n                declare\n                   Pragma_List : constant List_Id :=\n-                    Par (Configuration_Pragmas => True);\n+                                  Par (Configuration_Pragmas => True);\n+\n                begin\n                   if Need_To_Be_In_The_Dependencies (Pragma_List) then\n                      Prepcomp.Add_Dependency (Source_Config_File);"}, {"sha": "8834bae5424891e77492cfc155a7eb64deb59984", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -12319,24 +12319,29 @@ directory is searched for a file whose name is @file{gnat.adc}. If\n this file is present, it is expected to contain one or more\n configuration pragmas that will be applied to the current compilation.\n However, if the switch @option{-gnatA} is used, @file{gnat.adc} is not\n-considered.\n+considered. When taken into account, @file{gnat.adc} is added to the\n+dependencies, so that if @file{gnat.adc} is modified later, an invocation of\n+@command{gnatmake} will recompile the source.\n \n Configuration pragmas may be entered into the @file{gnat.adc} file\n either by running @code{gnatchop} on a source file that consists only of\n-configuration pragmas, or more conveniently  by\n-direct editing of the @file{gnat.adc} file, which is a standard format\n-source file.\n+configuration pragmas, or more conveniently by direct editing of the\n+@file{gnat.adc} file, which is a standard format source file.\n \n In addition to @file{gnat.adc}, additional files containing configuration\n pragmas may be applied to the current compilation using the switch\n-@option{-gnatec}@var{path}. @var{path} must designate an existing file that\n+@option{-gnatec=}@var{path}. @var{path} must designate an existing file that\n contains only configuration pragmas. These configuration pragmas are\n in addition to those found in @file{gnat.adc} (provided @file{gnat.adc}\n is present and switch @option{-gnatA} is not used).\n \n-It is allowed to specify several switches @option{-gnatec}, all of which\n+It is allowable to specify several switches @option{-gnatec=}, all of which\n will be taken into account.\n \n+Files containing configuration pragmas specified with switches\n+@option{-gnatec=} are added to the dependencies, unless they contain\n+only pragmas Source_File_Name_Project.\n+\n If you are using project file, a separate mechanism is provided using\n project attributes, see @ref{Specifying Configuration Pragmas} for more\n details."}, {"sha": "becab3eb8c5d476ef2a375dee06aed722b488b00", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -141,7 +141,7 @@ package body Prj is\n       while Last + S'Length > To'Last loop\n          declare\n             New_Buffer : constant  String_Access :=\n-                           new String (1 .. 2 * Last);\n+                           new String (1 .. 2 * To'Length);\n \n          begin\n             New_Buffer (1 .. Last) := To (1 .. Last);"}, {"sha": "157b20241490242dfa1f733a8ad4e60d1aef7369", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -1055,6 +1055,10 @@ package body Sem_Aggr is\n             --  formal parameter. Consequently we also need to test for\n             --  N_Procedure_Call_Statement or N_Function_Call.\n \n+            --  The context may be an N_Reference node, created by expansion.\n+            --  Legality of the others clause was established in the source,\n+            --  so the context is legal.\n+\n             Set_Etype (N, Aggr_Typ);  --  May be overridden later on\n \n             if Pkind = N_Assignment_Statement\n@@ -1070,6 +1074,7 @@ package body Sem_Aggr is\n                            Pkind = N_Component_Declaration     or else\n                            Pkind = N_Parameter_Specification   or else\n                            Pkind = N_Qualified_Expression      or else\n+                           Pkind = N_Reference                 or else\n                            Pkind = N_Aggregate                 or else\n                            Pkind = N_Extension_Aggregate       or else\n                            Pkind = N_Component_Association))"}, {"sha": "b94a1f2f1f0ff13a8e2b179650824c26589f88a6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -3493,7 +3493,21 @@ package body Sem_Ch3 is\n          --  early usage within E is properly diagnosed.\n \n          Set_Etype (Id, T);\n-         Resolve (E, T);\n+\n+         --  If the expression is an aggregate we must look ahead to detect\n+         --  the possible presence of an address clause, and defer resolution\n+         --  and expansion of the aggregate to the freeze point of the entity.\n+\n+         if Comes_From_Source (N)\n+           and then Expander_Active\n+           and then Has_Following_Address_Clause (N)\n+           and then Nkind (E) = N_Aggregate\n+         then\n+            Set_Etype (E, T);\n+\n+         else\n+            Resolve (E, T);\n+         end if;\n \n          --  No further action needed if E is a call to an inlined function\n          --  which returns an unconstrained type and it has been expanded into"}, {"sha": "f559ec3b6d3bf900587a8aa0fd59fc02f1e410de", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -4044,35 +4044,29 @@ package body Sem_Res is\n                return;\n             end if;\n \n-            --  Apply appropriate range checks for in, out, and in-out\n-            --  parameters. Out and in-out parameters also need a separate\n-            --  check, if there is a type conversion, to make sure the return\n-            --  value meets the constraints of the variable before the\n-            --  conversion.\n-\n-            --  Gigi looks at the check flag and uses the appropriate types.\n-            --  For now since one flag is used there is an optimization which\n-            --  might not be done in the In Out case since Gigi does not do\n-            --  any analysis. More thought required about this ???\n+            --  Apply appropriate constraint/predicate checks for IN [OUT] case\n \n             if Ekind_In (F, E_In_Parameter, E_In_Out_Parameter) then\n \n-               --  Apply predicate checks, unless this is a call to the\n-               --  predicate check function itself, which would cause an\n-               --  infinite recursion, or it is a call to an initialization\n-               --  procedure whose operand is of course an unfinished object.\n+               --  Apply predicate tests except in certain special cases. Note\n+               --  that it might be more consistent to apply these only when\n+               --  expansion is active (in Exp_Ch6.Expand_Actuals), as we do\n+               --  for the outbound predicate tests.\n \n-               if not (Ekind (Nam) = E_Function\n-                        and then (Is_Predicate_Function (Nam)\n-                                    or else\n-                                  Is_Predicate_Function_M (Nam)))\n-                 and then not Is_Init_Proc (Nam)\n-               then\n+               if not No_Predicate_Test_On_Arguments (Nam) then\n                   Apply_Predicate_Check (A, F_Typ);\n                end if;\n \n                --  Apply required constraint checks\n \n+               --  Gigi looks at the check flag and uses the appropriate types.\n+               --  For now since one flag is used there is an optimization\n+               --  which might not be done in the IN OUT case since Gigi does\n+               --  not do any analysis. More thought required about this ???\n+\n+               --  In fact is this comment obsolete??? doesn't the expander now\n+               --  generate all these tests anyway???\n+\n                if Is_Scalar_Type (Etype (A)) then\n                   Apply_Scalar_Range_Check (A, F_Typ);\n \n@@ -4138,7 +4132,13 @@ package body Sem_Res is\n                end if;\n             end if;\n \n+            --  Checks for OUT parameters and IN OUT parameters\n+\n             if Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter) then\n+\n+               --  If there is a type conversion, to make sure the return value\n+               --  meets the constraints of the variable before the conversion.\n+\n                if Nkind (A) = N_Type_Conversion then\n                   if Is_Scalar_Type (A_Typ) then\n                      Apply_Scalar_Range_Check\n@@ -4148,6 +4148,9 @@ package body Sem_Res is\n                        (Expression (A), Etype (Expression (A)), A_Typ);\n                   end if;\n \n+               --  If no conversion apply scalar range checks and length checks\n+               --  base on the subtype of the actual (NOT that of the formal).\n+\n                else\n                   if Is_Scalar_Type (F_Typ) then\n                      Apply_Scalar_Range_Check (A, A_Typ, F_Typ);\n@@ -4159,6 +4162,10 @@ package body Sem_Res is\n                      Apply_Range_Check (A, A_Typ, F_Typ);\n                   end if;\n                end if;\n+\n+               --  Note: we do not apply the predicate checks for the case of\n+               --  OUT and IN OUT parameters. They are instead applied in the\n+               --  Expand_Actuals routine in Exp_Ch6.\n             end if;\n \n             --  An actual associated with an access parameter is implicitly"}, {"sha": "e8131cb4031d213ca108a7241cf1464162ba0ff5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -13785,6 +13785,44 @@ package body Sem_Util is\n       Actual_Id := Next_Actual (Actual_Id);\n    end Next_Actual;\n \n+   ------------------------------------\n+   -- No_Predicate_Test_On_Arguments --\n+   ------------------------------------\n+\n+   function No_Predicate_Test_On_Arguments (Subp : Entity_Id) return Boolean is\n+   begin\n+      --  Do not test predicates on call to generated default Finalize, since\n+      --  we are not interested in whether something we are finalizing (and\n+      --  typically destroying) satisfies its predicates.\n+\n+      if Chars (Subp) = Name_Finalize\n+        and then not Comes_From_Source (Subp)\n+      then\n+         return True;\n+\n+      --  Do not test predicates on call to Init_Proc, since if needed the\n+      --  predicate test will occur at some other point.\n+\n+      elsif Is_Init_Proc (Subp) then\n+         return True;\n+\n+      --  Do not test predicates on call to predicate function, since this\n+      --  would cause infinite recursion.\n+\n+      elsif Ekind (Subp) = E_Function\n+        and then (Is_Predicate_Function (Subp)\n+                    or else\n+                  Is_Predicate_Function_M (Subp))\n+      then\n+         return True;\n+\n+      --  For now, no other cases\n+\n+      else\n+         return False;\n+      end if;\n+   end No_Predicate_Test_On_Arguments;\n+\n    ---------------------\n    -- No_Scalar_Parts --\n    ---------------------"}, {"sha": "62d995e422da282f082b05e1ec0e9a6c7409b304", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6fb720bb65b6954b2ecf0ceecc8f212b08e988/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=5f6fb720bb65b6954b2ecf0ceecc8f212b08e988", "patch": "@@ -1582,6 +1582,11 @@ package Sem_Util is\n    --  Note that the result produced is always an expression, not a parameter\n    --  association node, even if named notation was used.\n \n+   function No_Predicate_Test_On_Arguments (Subp : Entity_Id) return Boolean;\n+   --  Subp is the entity for a subprogram call. This function returns True to\n+   --  eliminate predicate tests on the input or output arguments in a call to\n+   --  this subprogram. See body for exact cases currently covered.\n+\n    function No_Scalar_Parts (T : Entity_Id) return Boolean;\n    --  Tests if type T can be determined at compile time to have no scalar\n    --  parts in the sense of the Valid_Scalars attribute. Returns True if"}]}