{"sha": "a813c28053a824bcd404f2d3327abb7b96374ab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxM2MyODA1M2E4MjRiY2Q0MDRmMmQzMzI3YWJiN2I5NjM3NGFiNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-10-05T14:56:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-10-05T14:56:32Z"}, "message": "i386.c (ix86_size_cost, [...]): Set reassociation width to 1.\n\n\t* i386.c (ix86_size_cost, i386_cost, i486_cost, pentium_cost,\n\tlakemont_cost, pentiumpro_cost, geode_cost, k6_cost,\n\tathlon_cost, k8_cost, amdfam10_cost, btver1_cost, btver2_cost,\n\tpentium4_cost, nocona_cost): Set reassociation width to 1.\n\t(bdver1_cost, bdver2_cost, bdver3_cost, bdver4_cost): Set reassociation\n\twidth to 2 for fp operations and 1 otherwise.\n\t(znver1_cost): Set scalar reassoc width to 4 and vector to 3 and 6\n\tfor int and fp.\n\t(atom_cost): Set reassociation width to 2.\n\t(slm_cost, generic_cost): Set fp reassociation width to 2 and 1 otherwise.\n\t(intel_cost): Set fp reassociation width to 4 and 1 otherwise.\n\t(core_cost): Set fp reassociation width to 4 and vector to 2.\n\t(ix86_reassociation_width): Rewrite using cost table; special case\n\tplus/minus on Zen; honor X86_TUNE_SSE_SPLIT_REGS\n\tand TARGET_AVX128_OPTIMAL.\n\t* i386.h (processor_costs): Add\n\treassoc_int, reassoc_fp, reassoc_vec_int, reassoc_vec_fp.\n\t(TARGET_VECTOR_PARALLEL_EXECUTION, TARGET_REASSOC_INT_TO_PARALLEL,\n\tTARGET_REASSOC_FP_TO_PARALLEL): Remove.\n\t* x86-tune.def (X86_TUNE_REASSOC_INT_TO_PARALLEL): Remove.\n\t(X86_TUNE_REASSOC_FP_TO_PARALLEL): Remove.\n\t(X86_TUNE_VECTOR_PARALLEL_EXECUTION):  Remove.\n\nFrom-SVN: r253448", "tree": {"sha": "f9ef45af7b84e0e5efc9e559c28d9f3276737990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9ef45af7b84e0e5efc9e559c28d9f3276737990"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a813c28053a824bcd404f2d3327abb7b96374ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a813c28053a824bcd404f2d3327abb7b96374ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a813c28053a824bcd404f2d3327abb7b96374ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a813c28053a824bcd404f2d3327abb7b96374ab6/comments", "author": null, "committer": null, "parents": [{"sha": "807e3be2b82b3e15572ac6b0128e9b7dd306fdc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/807e3be2b82b3e15572ac6b0128e9b7dd306fdc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/807e3be2b82b3e15572ac6b0128e9b7dd306fdc4"}], "stats": {"total": 145, "additions": 97, "deletions": 48}, "files": [{"sha": "ef4a47cf0ad2a0c56e7c0c8d24ee28b398dbd73c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a813c28053a824bcd404f2d3327abb7b96374ab6", "patch": "@@ -1,3 +1,28 @@\n+2017-10-05  Jan Hubicka <hubicka@ucw.cz>\n+\n+\t* i386.c (ix86_size_cost, i386_cost, i486_cost, pentium_cost,\n+\tlakemont_cost, pentiumpro_cost, geode_cost, k6_cost,\n+\tathlon_cost, k8_cost, amdfam10_cost, btver1_cost, btver2_cost,\n+\tpentium4_cost, nocona_cost): Set reassociation width to 1.\n+\t(bdver1_cost, bdver2_cost, bdver3_cost, bdver4_cost): Set reassociation\n+\twidth to 2 for fp operations and 1 otherwise.\n+\t(znver1_cost): Set scalar reassoc width to 4 and vector to 3 and 6\n+\tfor int and fp.\n+\t(atom_cost): Set reassociation width to 2.\n+\t(slm_cost, generic_cost): Set fp reassociation width to 2 and 1 otherwise.\n+\t(intel_cost): Set fp reassociation width to 4 and 1 otherwise.\n+\t(core_cost): Set fp reassociation width to 4 and vector to 2.\n+\t(ix86_reassociation_width): Rewrite using cost table; special case\n+\tplus/minus on Zen; honor X86_TUNE_SSE_SPLIT_REGS\n+\tand TARGET_AVX128_OPTIMAL.\n+\t* i386.h (processor_costs): Add\n+\treassoc_int, reassoc_fp, reassoc_vec_int, reassoc_vec_fp.\n+\t(TARGET_VECTOR_PARALLEL_EXECUTION, TARGET_REASSOC_INT_TO_PARALLEL,\n+\tTARGET_REASSOC_FP_TO_PARALLEL): Remove.\n+\t* x86-tune.def (X86_TUNE_REASSOC_INT_TO_PARALLEL): Remove.\n+\t(X86_TUNE_REASSOC_FP_TO_PARALLEL): Remove.\n+\t(X86_TUNE_VECTOR_PARALLEL_EXECUTION):  Remove.\n+\n 2017-10-05  Nathan Sidwell  <nathan@acm.org>\n \n \t* doc/invoke.texi (Wparentheses): Document C++ MVP behaviour."}, {"sha": "b7c125c20ec870044024b5effd4b9704a48fef5a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 65, "deletions": 27, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a813c28053a824bcd404f2d3327abb7b96374ab6", "patch": "@@ -177,6 +177,7 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   ix86_size_memcpy,\n   ix86_size_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -253,6 +254,7 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (22),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   i386_memcpy,\n   i386_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -330,6 +332,7 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   i486_memcpy,\n   i486_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -405,6 +408,7 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   pentium_memcpy,\n   pentium_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -473,6 +477,7 @@ struct processor_costs lakemont_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   pentium_memcpy,\n   pentium_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -556,6 +561,7 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   pentiumpro_memcpy,\n   pentiumpro_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -631,6 +637,7 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   geode_memcpy,\n   geode_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -708,6 +715,7 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   k6_memcpy,\n   k6_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -785,6 +793,7 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   athlon_memcpy,\n   athlon_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -871,7 +880,7 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   k8_memcpy,\n   k8_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -965,7 +974,7 @@ struct processor_costs amdfam10_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   amdfam10_memcpy,\n   amdfam10_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1060,7 +1069,7 @@ const struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   bdver1_memcpy,\n   bdver1_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1156,7 +1165,7 @@ const struct processor_costs bdver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   bdver2_memcpy,\n   bdver2_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1243,7 +1252,7 @@ struct processor_costs bdver3_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   bdver3_memcpy,\n   bdver3_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1329,7 +1338,7 @@ struct processor_costs bdver4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   bdver4_memcpy,\n   bdver4_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1419,7 +1428,15 @@ struct processor_costs znver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  /* Zen can execute 4 integer operations per cycle. FP operations take 3 cycles\n+     and it can execute 2 integer additions and 2 multiplications thus\n+     reassociation may make sense up to with of 6.  SPEC2k6 bencharks suggests\n+     that 4 works better than 6 probably due to register pressure.\n+\n+     Integer vector operations are taken by FP unit and execute 3 vector\n+     plus/minus operations per cycle but only one multiply.  This is adjusted\n+     in ix86_reassociation_width.  */\n+  4, 4, 3, 6,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   znver1_memcpy,\n   znver1_memset,\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1508,7 +1525,7 @@ const struct processor_costs btver1_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   btver1_memcpy,\n   btver1_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1594,6 +1611,7 @@ const struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   btver2_memcpy,\n   btver2_memset,\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1670,6 +1688,7 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   pentium4_memcpy,\n   pentium4_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1749,6 +1768,7 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 1, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   nocona_memcpy,\n   nocona_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1826,6 +1846,7 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  2, 2, 2, 2,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   atom_memcpy,\n   atom_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1903,6 +1924,7 @@ struct processor_costs slm_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   slm_memcpy,\n   slm_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -1980,6 +2002,7 @@ struct processor_costs intel_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 4, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   intel_memcpy,\n   intel_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -2067,6 +2090,7 @@ struct processor_costs generic_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   generic_memcpy,\n   generic_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -2153,6 +2177,7 @@ struct processor_costs core_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  1, 4, 2, 2,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n   core_memcpy,\n   core_memset,\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n@@ -51830,34 +51855,47 @@ has_dispatch (rtx_insn *insn, int action)\n /* Implementation of reassociation_width target hook used by\n    reassoc phase to identify parallelism level in reassociated\n    tree.  Statements tree_code is passed in OPC.  Arguments type\n-   is passed in MODE.\n-\n-   Currently parallel reassociation is enabled for Atom\n-   processors only and we set reassociation width to be 2\n-   because Atom may issue up to 2 instructions per cycle.\n-\n-   Return value should be fixed if parallel reassociation is\n-   enabled for other processors.  */\n+   is passed in MODE.  */\n \n static int\n-ix86_reassociation_width (unsigned int, machine_mode mode)\n+ix86_reassociation_width (unsigned int op, machine_mode mode)\n {\n+  int width = 1;\n   /* Vector part.  */\n   if (VECTOR_MODE_P (mode))\n     {\n-      if (TARGET_VECTOR_PARALLEL_EXECUTION)\n-\treturn 2;\n-      else\n+      int div = 1;\n+      if (INTEGRAL_MODE_P (mode))\n+\twidth = ix86_cost->reassoc_vec_int;\n+      else if (FLOAT_MODE_P (mode))\n+\twidth = ix86_cost->reassoc_vec_fp;\n+\n+      if (width == 1)\n+\treturn 1;\n+\n+      /* Integer vector instructions execute in FP unit\n+\t and can execute 3 additions and one multiplication per cycle.  */\n+      if (ix86_tune == PROCESSOR_ZNVER1 && INTEGRAL_MODE_P (mode)\n+\t  && op != PLUS && op != MINUS)\n \treturn 1;\n-    }\n \n+      /* Account for targets that splits wide vectors into multiple parts.  */\n+      if (TARGET_AVX128_OPTIMAL && GET_MODE_BITSIZE (mode) > 128)\n+\tdiv = GET_MODE_BITSIZE (mode) / 128;\n+      else if (TARGET_SSE_SPLIT_REGS && GET_MODE_BITSIZE (mode) > 64)\n+\tdiv = GET_MODE_BITSIZE (mode) / 64;\n+      width = (width + div - 1) / div;\n+    }\n   /* Scalar part.  */\n-  if (INTEGRAL_MODE_P (mode) && TARGET_REASSOC_INT_TO_PARALLEL)\n-    return 2;\n-  else if (FLOAT_MODE_P (mode) && TARGET_REASSOC_FP_TO_PARALLEL)\n-    return ((TARGET_64BIT && ix86_tune == PROCESSOR_HASWELL)? 4 : 2);\n-  else\n-    return 1;\n+  else if (INTEGRAL_MODE_P (mode))\n+    width = ix86_cost->reassoc_int;\n+  else if (FLOAT_MODE_P (mode))\n+    width = ix86_cost->reassoc_fp;\n+\n+  /* Avoid using too many registers in 32bit mode.  */\n+  if (!TARGET_64BIT && width > 2)\n+    width = 2;\n+  return width;\n }\n \n /* ??? No autovectorization into MMX or 3DNOW until we can reliably"}, {"sha": "ef88d89cae2fb8c7b92217dd9535d59f7eab067d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a813c28053a824bcd404f2d3327abb7b96374ab6", "patch": "@@ -257,6 +257,13 @@ struct processor_costs {\n   const int fsqrt;\t\t/* cost of FSQRT instruction.  */\n \t\t\t\t/* Specify what algorithm\n \t\t\t\t   to use for stringops on unknown size.  */\n+  const int reassoc_int, reassoc_fp, reassoc_vec_int, reassoc_vec_fp;\n+\t\t\t\t/* Specify reassociation width for integer,\n+\t\t\t\t   fp, vector integer and vector fp\n+\t\t\t\t   operations.  Generally should correspond\n+\t\t\t\t   to number of instructions executed in\n+\t\t\t\t   parallel.  See also\n+\t\t\t\t   ix86_reassociation_width.  */\n   struct stringop_algs *memcpy, *memset;\n   const int scalar_stmt_cost;   /* Cost of any scalar operation, excluding\n \t\t\t\t   load and store.  */\n@@ -466,8 +473,6 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_USE_VECTOR_CONVERTS]\n #define TARGET_SLOW_PSHUFB \\\n \tix86_tune_features[X86_TUNE_SLOW_PSHUFB]\n-#define TARGET_VECTOR_PARALLEL_EXECUTION \\\n-\tix86_tune_features[X86_TUNE_VECTOR_PARALLEL_EXECUTION]\n #define TARGET_AVOID_4BYTE_PREFIXES \\\n \tix86_tune_features[X86_TUNE_AVOID_4BYTE_PREFIXES]\n #define TARGET_FUSE_CMP_AND_BRANCH_32 \\\n@@ -488,10 +493,6 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL]\n #define TARGET_AVX128_OPTIMAL \\\n \tix86_tune_features[X86_TUNE_AVX128_OPTIMAL]\n-#define TARGET_REASSOC_INT_TO_PARALLEL \\\n-\tix86_tune_features[X86_TUNE_REASSOC_INT_TO_PARALLEL]\n-#define TARGET_REASSOC_FP_TO_PARALLEL \\\n-\tix86_tune_features[X86_TUNE_REASSOC_FP_TO_PARALLEL]\n #define TARGET_GENERAL_REGS_SSE_SPILL \\\n \tix86_tune_features[X86_TUNE_GENERAL_REGS_SSE_SPILL]\n #define TARGET_AVOID_MEM_OPND_FOR_CMOVE \\"}, {"sha": "63f69b4b5038930d523f3ef7e1d54cc55084d481", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c28053a824bcd404f2d3327abb7b96374ab6/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=a813c28053a824bcd404f2d3327abb7b96374ab6", "patch": "@@ -117,16 +117,6 @@ DEF_TUNE (X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS, \"fuse_cmp_and_branch_soflags\",\n DEF_TUNE (X86_TUNE_FUSE_ALU_AND_BRANCH, \"fuse_alu_and_branch\",\n           m_SANDYBRIDGE | m_HASWELL)\n \n-/* X86_TUNE_REASSOC_INT_TO_PARALLEL: Try to produce parallel computations\n-   during reassociation of integer computation.  */\n-DEF_TUNE (X86_TUNE_REASSOC_INT_TO_PARALLEL, \"reassoc_int_to_parallel\",\n-          m_BONNELL)\n-\n-/* X86_TUNE_REASSOC_FP_TO_PARALLEL: Try to produce parallel computations\n-   during reassociation of fp computation.  */\n-DEF_TUNE (X86_TUNE_REASSOC_FP_TO_PARALLEL, \"reassoc_fp_to_parallel\",\n-          m_BONNELL | m_SILVERMONT | m_HASWELL | m_KNL | m_KNM |m_INTEL | m_BDVER1\n-\t  | m_BDVER2 | m_ZNVER1 | m_GENERIC)\n \n /*****************************************************************************/\n /* Function prologue, epilogue and function calling sequences.               */\n@@ -391,11 +381,6 @@ DEF_TUNE (X86_TUNE_USE_VECTOR_CONVERTS, \"use_vector_converts\", m_AMDFAM10)\n DEF_TUNE (X86_TUNE_SLOW_PSHUFB, \"slow_pshufb\",\n           m_BONNELL | m_SILVERMONT | m_KNL | m_KNM | m_INTEL)\n \n-/* X86_TUNE_VECTOR_PARALLEL_EXECUTION: Indicates tunings with ability to\n-   execute 2 or more vector instructions in parallel.  */\n-DEF_TUNE (X86_TUNE_VECTOR_PARALLEL_EXECUTION, \"vec_parallel\",\n-          m_NEHALEM | m_SANDYBRIDGE | m_HASWELL)\n-\n /* X86_TUNE_AVOID_4BYTE_PREFIXES: Avoid instructions requiring 4+ bytes of prefixes.  */\n DEF_TUNE (X86_TUNE_AVOID_4BYTE_PREFIXES, \"avoid_4byte_prefixes\",\n           m_SILVERMONT | m_INTEL)"}]}