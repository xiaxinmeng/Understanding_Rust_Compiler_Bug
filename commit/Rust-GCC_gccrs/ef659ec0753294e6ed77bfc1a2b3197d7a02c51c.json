{"sha": "ef659ec0753294e6ed77bfc1a2b3197d7a02c51c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY2NTllYzA3NTMyOTRlNmVkNzdiZmMxYTJiMzE5N2Q3YTAyYzUxYw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-06-26T16:36:45Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-06-26T16:36:45Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1301", "tree": {"sha": "04594b7ce9ee3603d1912d9a01ec6ac834848dba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04594b7ce9ee3603d1912d9a01ec6ac834848dba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef659ec0753294e6ed77bfc1a2b3197d7a02c51c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef659ec0753294e6ed77bfc1a2b3197d7a02c51c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef659ec0753294e6ed77bfc1a2b3197d7a02c51c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef659ec0753294e6ed77bfc1a2b3197d7a02c51c/comments", "author": null, "committer": null, "parents": [{"sha": "5a7ec9d91acb245ce5b46a002201f7a2ead8b940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a7ec9d91acb245ce5b46a002201f7a2ead8b940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a7ec9d91acb245ce5b46a002201f7a2ead8b940"}], "stats": {"total": 157, "additions": 152, "deletions": 5}, "files": [{"sha": "6c406f6254686301e9bae4498163a4e6ab8a74fe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 152, "deletions": 5, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef659ec0753294e6ed77bfc1a2b3197d7a02c51c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef659ec0753294e6ed77bfc1a2b3197d7a02c51c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ef659ec0753294e6ed77bfc1a2b3197d7a02c51c", "patch": "@@ -2304,7 +2304,125 @@ all_ones_mask_p (mask, size)\n \t\t\t\t  size_int (precision - size)), 0);\n }\n \f\n+/* Try to optimize a range test.\n+\n+   For example, \"i >= 2 && i =< 9\" can be done as \"(unsigned) (i - 2) <= 7\".\n+\n+   JCODE is the logical combination of the two terms.  It can be\n+   TRUTH_ANDIF_EXPR, TRUTH_AND_EXPR, TRUTH_ORIF_EXPR, or TRUTH_OR_EXPR.\n+   TYPE is the type of the result.\n+\n+   VAR is the value being tested.  LO_CODE and HI_CODE are the comparison\n+   operators comparing VAR to LO_CST and HI_CST.  LO_CST is known to be no\n+   larger than HI_CST (they may be equal).\n+\n+   We return the simplified tree or 0 if no optimization is possible.  */\n+\n+tree\n+range_test (jcode, type, lo_code, hi_code, var, lo_cst, hi_cst)\n+     enum tree_code jcode, lo_code, hi_code;\n+     tree type, var, lo_cst, hi_cst;\n+{\n+  tree utype;\n+  enum tree_code rcode;\n+\n+  /* See if this is a range test and normalize the constant terms.  */\n+\n+  if (jcode == TRUTH_ANDIF_EXPR || jcode == TRUTH_AND_EXPR)\n+    {\n+      switch (lo_code)\n+\t{\n+\tcase NE_EXPR:\n+\t  /* See if we have VAR != CST && VAR != CST+1.  */\n+\t  if (! (hi_code == NE_EXPR\n+\t\t && TREE_INT_CST_LOW (hi_cst) - TREE_INT_CST_LOW (lo_cst) == 1\n+\t\t && tree_int_cst_equal (integer_one_node,\n+\t\t\t\t\tconst_binop (MINUS_EXPR,\n+\t\t\t\t\t\t     hi_cst, lo_cst))))\n+\t    return 0;\n+\n+\t  rcode = GT_EXPR;\n+\t  break;\n+\n+\tcase GT_EXPR:\n+\tcase GE_EXPR:\n+\t  if (hi_code == LT_EXPR)\n+\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node);\n+\t  else if (hi_code != LE_EXPR)\n+\t    return 0;\n+\n+\t  if (lo_code == GT_EXPR)\n+\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node);\n+\n+\t  /* We now have VAR >= LO_CST && VAR <= HI_CST.  */\n+\t  rcode = LE_EXPR;\n+\t  break;\n+\n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+  else\n+    {\n+      switch (lo_code)\n+\t{\n+\tcase EQ_EXPR:\n+\t  /* See if we have VAR == CST || VAR == CST+1.  */\n+\t  if (! (hi_code == EQ_EXPR\n+\t\t && TREE_INT_CST_LOW (hi_cst) - TREE_INT_CST_LOW (lo_cst) == 1\n+\t\t && tree_int_cst_equal (integer_one_node,\n+\t\t\t\t\tconst_binop (MINUS_EXPR,\n+\t\t\t\t\t\t     hi_cst, lo_cst))))\n+\t    return 0;\n+\n+\t  rcode = LE_EXPR;\n+\t  break;\n+\n+\tcase LE_EXPR:\n+\tcase LT_EXPR:\n+\t  if (hi_code == GE_EXPR)\n+\t    hi_cst = const_binop (MINUS_EXPR, hi_cst, integer_one_node);\n+\t  else if (hi_code != GT_EXPR)\n+\t    return 0;\n+\n+\t  if (lo_code == LE_EXPR)\n+\t    lo_cst = const_binop (PLUS_EXPR, lo_cst, integer_one_node);\n+\n+\t  /* We now have VAR < LO_CST || VAR > HI_CST.  */\n+\t  rcode = GT_EXPR;\n+\t  break;\n+\n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* When normalizing, it is possible to both increment the smaller constant\n+     and decrement the larger constant.  See if they are still ordered.  */\n+  if (tree_int_cst_lt (lo_cst, hi_cst))\n+    return 0;\n+\n+  /* The range test is invalid if subtracting the two constants results\n+     in overflow.  This can happen in traditional mode.  */\n+  if (! int_fits_type_p (hi_cst, TREE_TYPE (var))\n+      || ! int_fits_type_p (lo_cst, TREE_TYPE (var)))\n+    return 0;\n+\n+  utype = TREE_TYPE (var);\n+  if (! TREE_UNSIGNED (utype))\n+    {\n+      utype = unsigned_type (utype);\n+      var = convert (utype, var);\n+    }\n+\n+  return fold (convert (type,\n+\t\t\tbuild (rcode, utype,\n+\t\t\t       build (MINUS_EXPR, utype, var, lo_cst),\n+\t\t\t       const_binop (MINUS_EXPR, hi_cst, lo_cst))));\n+}\n+\f\n /* Try to merge two comparisons to the same innermost item.\n+   Also look for range tests like \"ch >= '0' && ch <= '9'\".\n \n    For example, if we have p->a == 2 && p->b == 4 and we can make an\n    object large enough to span both A and B, we can do this with a comparison\n@@ -2355,15 +2473,44 @@ merge_component_references (code, truth_type, lhs, rhs)\n   int first_bit, end_bit;\n   int volatilep = 0;\n \n-  /* Start by getting the comparison codes and seeing if we may be able\n-     to do something.  Then get all the parameters for each side.  Fail\n-     if anything is volatile.  */\n+  /* Start by getting the comparison codes and seeing if this looks like\n+     a range test.  Fail if anything is volatile.  */\n \n   lcode = TREE_CODE (lhs);\n   rcode = TREE_CODE (rhs);\n+\n+  if (TREE_SIDE_EFFECTS (lhs)\n+      || TREE_SIDE_EFFECTS (rhs)\n+      || TREE_CODE_CLASS (lcode) != '<'\n+      || TREE_CODE_CLASS (rcode) != '<')\n+    return 0;\n+\n+  if (TREE_CODE (TREE_OPERAND (lhs, 1)) == INTEGER_CST\n+      && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n+      && operand_equal_p (TREE_OPERAND (lhs, 0),\n+\t\t\t  TREE_OPERAND (rhs, 0), 0))\n+    {\n+      if (tree_int_cst_lt (TREE_OPERAND (lhs, 1), TREE_OPERAND (rhs, 1)))\n+\tresult = range_test (code, truth_type, lcode, rcode,\n+\t\t\t     TREE_OPERAND (lhs, 0),\n+\t\t\t     TREE_OPERAND (lhs, 1),\n+\t\t\t     TREE_OPERAND (rhs, 1));\n+      else\n+\tresult = range_test (code, truth_type, rcode, lcode,\n+\t\t\t     TREE_OPERAND (lhs, 0),\n+\t\t\t     TREE_OPERAND (rhs, 1),\n+\t\t\t     TREE_OPERAND (lhs, 1));\n+\n+      /* If this isn't a range test, it also isn't a comparison that\n+\t can be merged.  */\n+      return result;\n+    }\n+\n+  /* See if the comparisons can be merged.  Then get all the parameters for\n+     each side.  */\n+\n   if ((lcode != EQ_EXPR && lcode != NE_EXPR)\n-      || (rcode != EQ_EXPR && rcode != NE_EXPR)\n-      || TREE_SIDE_EFFECTS (lhs) || TREE_SIDE_EFFECTS (rhs))\n+      || (rcode != EQ_EXPR && rcode != NE_EXPR))\n     return 0;\n \n   ll_inner = decode_field_reference (TREE_OPERAND (lhs, 0),"}]}