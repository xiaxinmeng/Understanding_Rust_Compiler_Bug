{"sha": "9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE3Mzg5MDg4ZmVhM2Q4YWMyYjJlYWM3M2E2MDhkYTZlMDZjN2QxNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-30T15:46:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-30T15:46:22Z"}, "message": "sparc: Convert to mem_thread_fence.\n\n        * config/sparc/predicates.md (zero_or_v7_operand): New.\n        * config/sparc/sparc.c (sparc_emit_membar_for_model): New.\n        * config/sparc/sparc-protos.h: Update.\n        * config/sparc/sync.md (mem_thread_fence): New.\n        (memory_barrier): Use sparc_emit_membar_for_model.\n        (membar, *membar_empty, *membar_storestore, *membar_storeload): New.\n        (*membar_v8): Accept and ignore the membar mask.\n        (*membar): Accept and print the membar mask.\n\nFrom-SVN: r181848", "tree": {"sha": "5675d3916d885c39f98ba22c9a6df16701097ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5675d3916d885c39f98ba22c9a6df16701097ce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/comments", "author": null, "committer": null, "parents": [{"sha": "ef5784915f07bf18222c76fb035e7ef4b2f90462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5784915f07bf18222c76fb035e7ef4b2f90462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef5784915f07bf18222c76fb035e7ef4b2f90462"}], "stats": {"total": 143, "additions": 129, "deletions": 14}, "files": [{"sha": "eee535f904798225ac4addd9efe8867fee478638", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "patch": "@@ -1,3 +1,14 @@\n+2011-11-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/sparc/predicates.md (zero_or_v7_operand): New.\n+\t* config/sparc/sparc.c (sparc_emit_membar_for_model): New.\n+\t* config/sparc/sparc-protos.h: Update.\n+\t* config/sparc/sync.md (mem_thread_fence): New.\n+\t(memory_barrier): Use sparc_emit_membar_for_model.\n+\t(membar, *membar_empty, *membar_storestore, *membar_storeload): New.\n+\t(*membar_v8): Accept and ignore the membar mask.\n+\t(*membar): Accept and print the membar mask.\n+\n 2011-11-30  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* config/arm/arm.c (arm_issue_rate): Cortex-A15 can triple issue."}, {"sha": "047b21786fcf8305abd69f9854063b9d5857562b", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "patch": "@@ -111,6 +111,10 @@\n (define_predicate \"const_double_or_vector_operand\"\n   (match_code \"const_double,const_vector\"))\n \n+;; Return true if OP is Zero, or if the target is V7.\n+(define_predicate \"zero_or_v7_operand\"\n+  (ior (match_test \"op == const0_rtx\")\n+       (match_test \"!TARGET_V8 && !TARGET_V9\")))\n \n ;; Predicates for symbolic constants.\n "}, {"sha": "b292024bc8700e8a608cf132c93aed6a63e36416", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "patch": "@@ -113,4 +113,6 @@ unsigned int sparc_regmode_natural_size (enum machine_mode);\n bool sparc_modes_tieable_p (enum machine_mode, enum machine_mode);\n #endif /* RTX_CODE */\n \n+extern void sparc_emit_membar_for_model (enum memmodel, int, int);\n+\n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "c5c48997d016a63c98b507668d699543060e31db", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "patch": "@@ -10849,6 +10849,53 @@ sparc_mangle_type (const_tree type)\n }\n #endif\n \n+/* Expand a membar instruction for various use cases.  Both the LOAD_STORE\n+   and BEFORE_AFTER arguments of the form X_Y.  They are two-bit masks where\n+   bit 0 indicates that X is true, and bit 1 indicates Y is true.  */\n+\n+void\n+sparc_emit_membar_for_model (enum memmodel model,\n+\t\t\t     int load_store, int before_after)\n+{\n+  /* Bits for the MEMBAR mmask field.  */\n+  const int LoadLoad = 1;\n+  const int StoreLoad = 2;\n+  const int LoadStore = 4;\n+  const int StoreStore = 8;\n+\n+  int mm = 0;\n+\n+  if (before_after & 1)\n+    {\n+      if (model == MEMMODEL_ACQUIRE\n+          || model == MEMMODEL_ACQ_REL\n+          || model == MEMMODEL_SEQ_CST)\n+\t{\n+\t  if (load_store & 1)\n+\t    mm |= LoadLoad | LoadStore;\n+\t  if (load_store & 2)\n+\t    mm |= StoreLoad | StoreStore;\n+\t}\n+    }\n+  if (before_after & 2)\n+    {\n+      if (model == MEMMODEL_RELEASE\n+\t  || model == MEMMODEL_ACQ_REL\n+\t  || model == MEMMODEL_SEQ_CST)\n+\t{\n+\t  if (load_store & 1)\n+\t    mm |= LoadLoad | StoreLoad;\n+\t  if (load_store & 2)\n+\t    mm |= LoadStore | StoreStore;\n+\t}\n+    }\n+\n+  /* For raw barriers (before+after), always emit a barrier.\n+     This will become a compile-time barrier if needed.  */\n+  if (mm || before_after == 3)\n+    emit_insn (gen_membar (GEN_INT (mm)));\n+}\n+\n /* Expand code to perform a 8 or 16-bit compare and swap by doing 32-bit\n    compare and swap on the word containing the byte or half-word.  */\n "}, {"sha": "e22f5167fecbe2ff1a898e244ae63b2a68e2438b", "filename": "gcc/config/sparc/sync.md", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7389088fea3d8ac2b2eac73a608da6e06c7d14/gcc%2Fconfig%2Fsparc%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsync.md?ref=9a7389088fea3d8ac2b2eac73a608da6e06c7d14", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for SPARC synchronization instructions.\n-;; Copyright (C) 2005, 2007, 2009, 2010\n+;; Copyright (C) 2005, 2007, 2009, 2010, 2011\n ;; Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n@@ -23,36 +23,87 @@\n (define_mode_iterator I48MODE [SI (DI \"TARGET_ARCH64 || TARGET_V8PLUS\")])\n (define_mode_attr modesuffix [(SI \"\") (DI \"x\")])\n \n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\")]\n+  \"TARGET_V8 || TARGET_V9\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[0]);\n+  sparc_emit_membar_for_model (model, 3, 3);\n+  DONE;\n+})\n+\n (define_expand \"memory_barrier\"\n-  [(set (match_dup 0)\n-\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMBAR))]\n+  [(const_int 0)]\n+  \"TARGET_V8 || TARGET_V9\"\n+{\n+  sparc_emit_membar_for_model (MEMMODEL_SEQ_CST, 3, 3);\n+  DONE;\n+})\n+\n+(define_expand \"membar\"\n+  [(set (match_dup 1)\n+\t(unspec:BLK [(match_dup 1)\n+\t\t     (match_operand:SI 0 \"const_int_operand\")]\n+\t\t    UNSPEC_MEMBAR))]\n   \"TARGET_V8 || TARGET_V9\"\n {\n-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n-  MEM_VOLATILE_P (operands[0]) = 1;\n+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[1]) = 1;\n })\n \n-;; In V8, loads are blocking and ordered wrt earlier loads, i.e. every load\n-;; is virtually followed by a load barrier (membar #LoadStore | #LoadLoad).\n-;; In PSO, stbar orders the stores (membar #StoreStore).\n-;; In TSO, ldstub orders the stores wrt subsequent loads (membar #StoreLoad).\n-;; The combination of the three yields a full memory barrier in all cases.\n+;; A compiler-only memory barrier.  Generic code, when checking for the\n+;; existance of various named patterns, uses asm(\"\":::\"memory\") when we\n+;; don't need an actual instruction.  Here, it's easiest to pretend that\n+;; membar 0 is such a barrier.  Further, this gives us a nice hook to \n+;; ignore all such barriers on Sparc V7.\n+(define_insn \"*membar_empty\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0) (match_operand:SI 1 \"zero_or_v7_operand\")]\n+\t\t    UNSPEC_MEMBAR))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"0\")])\n+\n+;; For V8, STBAR is exactly membar #StoreStore, by definition.\n+(define_insn \"*membar_storestore\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0) (const_int 8)] UNSPEC_MEMBAR))]\n+  \"TARGET_V8\"\n+  \"stbar\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; For V8, LDSTUB has the effect of membar #StoreLoad\n+(define_insn \"*membar_storeload\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0) (const_int 2)] UNSPEC_MEMBAR))]\n+  \"TARGET_V8\"\n+  \"ldstub\\t[%%sp-1], %%g0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; Put the two together, in combination with the fact that V8 implements PSO\n+;; as its weakest memory model, means a full barrier.  Match all remaining\n+;; instances of the membar pattern for Sparc V8.\n (define_insn \"*membar_v8\"\n   [(set (match_operand:BLK 0 \"\" \"\")\n-\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMBAR))]\n+\t(unspec:BLK [(match_dup 0) (match_operand:SI 1 \"const_int_operand\")]\n+\t\t    UNSPEC_MEMBAR))]\n   \"TARGET_V8\"\n   \"stbar\\n\\tldstub\\t[%%sp-1], %%g0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2\")])\n \n-;; membar #StoreStore | #LoadStore | #StoreLoad | #LoadLoad\n+;; For V9, we have the full membar instruction.\n (define_insn \"*membar\"\n   [(set (match_operand:BLK 0 \"\" \"\")\n-\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMBAR))]\n+\t(unspec:BLK [(match_dup 0) (match_operand:SI 1 \"const_int_operand\")]\n+\t\t    UNSPEC_MEMBAR))]\n   \"TARGET_V9\"\n-  \"membar\\t15\"\n+  \"membar\\t%1\"\n   [(set_attr \"type\" \"multi\")])\n \n+;;;;;;;;\n+\n (define_expand \"sync_compare_and_swap<mode>\"\n   [(match_operand:I12MODE 0 \"register_operand\" \"\")\n    (match_operand:I12MODE 1 \"memory_operand\" \"\")"}]}