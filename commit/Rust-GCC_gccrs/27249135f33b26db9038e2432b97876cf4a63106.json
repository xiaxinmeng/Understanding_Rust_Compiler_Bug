{"sha": "27249135f33b26db9038e2432b97876cf4a63106", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcyNDkxMzVmMzNiMjZkYjkwMzhlMjQzMmI5Nzg3NmNmNGE2MzEwNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-13T22:19:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-13T22:19:54Z"}, "message": "flow.c (find_basic_blocks): Emit NOPs after normal calls in this function.\n\nTue Oct 13 22:12:11 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n        * flow.c (find_basic_blocks): Emit NOPs after normal calls in this\n        function.\n        Compute max_uid_for_flow by calling get_max_uid after the scan.\n        (find_basic_blocks_1): Don't emit NOPs here.\n\nFrom-SVN: r23061", "tree": {"sha": "73791bdeddb145c619a0a1a6659971d4ea1b2417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73791bdeddb145c619a0a1a6659971d4ea1b2417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27249135f33b26db9038e2432b97876cf4a63106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27249135f33b26db9038e2432b97876cf4a63106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27249135f33b26db9038e2432b97876cf4a63106", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27249135f33b26db9038e2432b97876cf4a63106/comments", "author": null, "committer": null, "parents": [{"sha": "56ee928168998aec1d6b54e265686bd9dc179c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ee928168998aec1d6b54e265686bd9dc179c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56ee928168998aec1d6b54e265686bd9dc179c40"}], "stats": {"total": 82, "additions": 35, "deletions": 47}, "files": [{"sha": "3c21fd3ff9581a9d4e5a7bef38e266f02b4a688f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27249135f33b26db9038e2432b97876cf4a63106/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27249135f33b26db9038e2432b97876cf4a63106/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27249135f33b26db9038e2432b97876cf4a63106", "patch": "@@ -1,3 +1,10 @@\n+Tue Oct 13 22:12:11 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+        * flow.c (find_basic_blocks): Emit NOPs after normal calls in this\n+        function.\n+        Compute max_uid_for_flow by calling get_max_uid after the scan.\n+        (find_basic_blocks_1): Don't emit NOPs here.\n+\n Tue Oct 13 22:05:49 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* alias.c (base_alias_check): Accept new args for the modes of the"}, {"sha": "6d3bbd8dce7e7bc33915d7c92db5fc287e94f13b", "filename": "gcc/flow.c", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27249135f33b26db9038e2432b97876cf4a63106/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27249135f33b26db9038e2432b97876cf4a63106/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=27249135f33b26db9038e2432b97876cf4a63106", "patch": "@@ -311,18 +311,16 @@ find_basic_blocks (f, nregs, file)\n   register int i;\n   rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n   int in_libcall_block = 0;\n-  int extra_uids_for_flow = 0;\n \n   /* Count the basic blocks.  Also find maximum insn uid value used.  */\n \n   {\n+    rtx prev_call = 0;\n     register RTX_CODE prev_code = JUMP_INSN;\n     register RTX_CODE code;\n     int eh_region = 0;\n     int call_had_abnormal_edge = 0;\n \n-    max_uid_for_flow = 0;\n-\n     for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n       {\n \t/* Track when we are inside in LIBCALL block.  */\n@@ -331,44 +329,41 @@ find_basic_blocks (f, nregs, file)\n \t  in_libcall_block = 1;\n \n \tcode = GET_CODE (insn);\n-\tif (INSN_UID (insn) > max_uid_for_flow)\n-\t  max_uid_for_flow = INSN_UID (insn);\n-\tif (code == CODE_LABEL)\n-\t  i++;\n-\telse if (GET_RTX_CLASS (code) == 'i')\n+\n+\t/* A basic block starts at label, or after something that can jump.  */\n+\tif (code == CODE_LABEL\n+\t    || (GET_RTX_CLASS (code) == 'i'\n+\t\t&& (prev_code == JUMP_INSN\n+\t\t    || (prev_code == CALL_INSN && call_had_abnormal_edge)\n+\t\t    || prev_code == BARRIER)))\n \t  {\n-\t    if (prev_code == JUMP_INSN || prev_code == BARRIER)\n-\t      i++;\n-\t    else if (prev_code == CALL_INSN)\n+\t    i++;\n+\n+\t    /* If the previous insn was a call that did not create an\n+\t       abnormal edge, we want to add a nop so that the CALL_INSN\n+\t       itself is not at basic_block_end.  This allows us to easily\n+\t       distinguish between normal calls and those which create\n+\t       abnormal edges in the flow graph.  */\n+\n+\t    if (i > 0 && !call_had_abnormal_edge && prev_call != 0)\n \t      {\n-\t\tif (call_had_abnormal_edge)\n-\t\t  i++;\n-\t\telse\n-\t\t  {\n-\t\t    /* Else this call does not force a new block to be\n-\t\t       created.  However, it may still be the end of a basic\n-\t\t       block if it is followed by a CODE_LABEL or a BARRIER.\n-\n-\t\t       To disambiguate calls which force new blocks to be\n-\t\t       created from those which just happen to be at the end\n-\t\t       of a block we insert nops during find_basic_blocks_1\n-\t\t       after calls which are the last insn in a block by\n-\t\t       chance.  We must account for such insns in\n-\t\t       max_uid_for_flow.  */\n-\n-\t\t    extra_uids_for_flow++;\n-\t\t  }\n+\t\trtx nop = gen_rtx_USE (VOIDmode, const0_rtx);\n+\t\temit_insn_after (nop, prev_call);\n \t      }\n \t  }\n-\n \t/* We change the code of the CALL_INSN, so that it won't start a\n \t   new block.  */\n \tif (code == CALL_INSN && in_libcall_block)\n \t  code = INSN;\n \n-        /* Record whether this call created an edge.  */\n-        if (code == CALL_INSN)\n-\t  call_had_abnormal_edge = (nonlocal_label_list != 0 || eh_region);\n+\t/* Record whether this call created an edge.  */\n+\tif (code == CALL_INSN)\n+\t  {\n+\t    prev_call = insn;\n+\t    call_had_abnormal_edge = (nonlocal_label_list != 0 || eh_region);\n+\t  }\n+\telse if (code != NOTE && code != BARRIER)\n+\t  prev_call = 0;\n \n \tif (code != NOTE)\n \t  prev_code = code;\n@@ -385,12 +380,12 @@ find_basic_blocks (f, nregs, file)\n \n   n_basic_blocks = i;\n \n+  max_uid_for_flow = get_max_uid ();\n #ifdef AUTO_INC_DEC\n   /* Leave space for insns life_analysis makes in some cases for auto-inc.\n      These cases are rare, so we don't need too much space.  */\n   max_uid_for_flow += max_uid_for_flow / 10;\n #endif\n-  max_uid_for_flow += extra_uids_for_flow;\n \n   /* Allocate some tables that last till end of compiling this function\n      and some needed only in find_basic_blocks and life_analysis.  */\n@@ -513,20 +508,6 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \t      if (LABEL_PRESERVE_P (insn))\n \t\tblock_live[i] = 1;\n \t    }\n-\n-\t  /* If the previous insn was a call that did not create an\n-\t     abnormal edge, we want to add a nop so that the CALL_INSN\n-\t     itself is not at basic_block_end.  This allows us to easily\n-\t     distinguish between normal calls and those which create\n-\t     abnormal edges in the flow graph.  */\n-\n-\t  if (i > 0 && !call_had_abnormal_edge\n-\t      && GET_CODE (basic_block_end[i-1]) == CALL_INSN)\n-\t    {\n-\t      rtx nop = gen_rtx_USE (VOIDmode, const0_rtx);\n-\t      nop = emit_insn_after (nop, basic_block_end[i-1]);\n-\t      basic_block_end[i-1] = nop;\n-\t    }\n \t}\n \n       else if (GET_RTX_CLASS (code) == 'i')"}]}