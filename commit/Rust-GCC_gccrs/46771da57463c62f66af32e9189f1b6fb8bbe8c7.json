{"sha": "46771da57463c62f66af32e9189f1b6fb8bbe8c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY3NzFkYTU3NDYzYzYyZjY2YWYzMmU5MTg5ZjFiNmZiOGJiZThjNw==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-06-14T02:34:48Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-06-14T02:34:48Z"}, "message": "re PR ipa/90401 (Missed propagation of by-ref constant argument to callee function)\n\nPR ipa/90401\n\ngcc/ChangeLog:\n\n\t* ipa-prop.c (add_to_agg_contents_list): New function.\n\t(clobber_by_agg_contents_list_p): Likewise.\n\t(extract_mem_content): Likewise.\n\t(get_place_in_agg_contents_list): Delete.\n\t(determine_known_aggregate_parts): Renamed from\n\tdetermine_locally_known_aggregate_parts.  New parameter\n\taa_walk_budget_p.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/ipa/ipcp-agg-10.c: New test.\n\nFrom-SVN: r272282", "tree": {"sha": "b119402535c8830f1993af8346a9c4c901349e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b119402535c8830f1993af8346a9c4c901349e56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46771da57463c62f66af32e9189f1b6fb8bbe8c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46771da57463c62f66af32e9189f1b6fb8bbe8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46771da57463c62f66af32e9189f1b6fb8bbe8c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46771da57463c62f66af32e9189f1b6fb8bbe8c7/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc09939dad30f42d89f0ee90cad1033fb32edb85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc09939dad30f42d89f0ee90cad1033fb32edb85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc09939dad30f42d89f0ee90cad1033fb32edb85"}], "stats": {"total": 333, "additions": 234, "deletions": 99}, "files": [{"sha": "95b3d2270ea4b4d03f28912db0ddafbcf6d13652", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46771da57463c62f66af32e9189f1b6fb8bbe8c7", "patch": "@@ -1,3 +1,14 @@\n+2019-06-14  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/90401\n+\t* ipa-prop.c (add_to_agg_contents_list): New function.\n+\t(clobber_by_agg_contents_list_p): Likewise.\n+\t(extract_mem_content): Likewise.\n+\t(get_place_in_agg_contents_list): Delete.\n+\t(determine_known_aggregate_parts): Renamed from\n+\tdetermine_locally_known_aggregate_parts.  New parameter\n+\taa_walk_budget_p.\n+\n 2019-06-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90662"}, {"sha": "a53a6ec5f32d0365cdefa027b8d091adcb65f286", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 140, "deletions": 99, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=46771da57463c62f66af32e9189f1b6fb8bbe8c7", "patch": "@@ -1458,7 +1458,7 @@ get_ssa_def_if_simple_copy (tree rhs)\n   return rhs;\n }\n \n-/* Simple linked list, describing known contents of an aggregate beforere\n+/* Simple linked list, describing known contents of an aggregate before\n    call.  */\n \n struct ipa_known_agg_contents_list\n@@ -1471,41 +1471,48 @@ struct ipa_known_agg_contents_list\n   struct ipa_known_agg_contents_list *next;\n };\n \n-/* Find the proper place in linked list of ipa_known_agg_contents_list\n-   structures where to put a new one with the given LHS_OFFSET and LHS_SIZE,\n-   unless there is a partial overlap, in which case return NULL, or such\n-   element is already there, in which case set *ALREADY_THERE to true.  */\n+/* Add a known content item into a linked list of ipa_known_agg_contents_list\n+   structure, in which all elements are sorted ascendingly by offset.  */\n \n-static struct ipa_known_agg_contents_list **\n-get_place_in_agg_contents_list (struct ipa_known_agg_contents_list **list,\n-\t\t\t\tHOST_WIDE_INT lhs_offset,\n-\t\t\t\tHOST_WIDE_INT lhs_size,\n-\t\t\t\tbool *already_there)\n+static inline void\n+add_to_agg_contents_list (struct ipa_known_agg_contents_list **plist,\n+\t\t\t  struct ipa_known_agg_contents_list *item)\n {\n-  struct ipa_known_agg_contents_list **p = list;\n-  while (*p && (*p)->offset < lhs_offset)\n+  struct ipa_known_agg_contents_list *list = *plist;\n+\n+  for (; list; list = list->next)\n     {\n-      if ((*p)->offset + (*p)->size > lhs_offset)\n-\treturn NULL;\n-      p = &(*p)->next;\n+      if (list->offset >= item->offset)\n+\tbreak;\n+\n+      plist = &list->next;\n     }\n \n-  if (*p && (*p)->offset < lhs_offset + lhs_size)\n+  item->next = list;\n+  *plist = item;\n+}\n+\n+/* Check whether a given known content is clobbered by certain element in\n+   a linked list of ipa_known_agg_contents_list.  */\n+\n+static inline bool\n+clobber_by_agg_contents_list_p (struct ipa_known_agg_contents_list *list,\n+\t\t\t\tstruct ipa_known_agg_contents_list *item)\n+{\n+  for (; list; list = list->next)\n     {\n-      if ((*p)->offset == lhs_offset && (*p)->size == lhs_size)\n-\t/* We already know this value is subsequently overwritten with\n-\t   something else.  */\n-\t*already_there = true;\n-      else\n-\t/* Otherwise this is a partial overlap which we cannot\n-\t   represent.  */\n-\treturn NULL;\n+      if (list->offset >= item->offset)\n+\treturn list->offset < item->offset + item->size;\n+\n+      if (list->offset + list->size > item->offset)\n+\treturn true;\n     }\n-  return p;\n+\n+  return false;\n }\n \n /* Build aggregate jump function from LIST, assuming there are exactly\n-   CONST_COUNT constant entries there and that th offset of the passed argument\n+   CONST_COUNT constant entries there and that offset of the passed argument\n    is ARG_OFFSET and store it into JFUNC.  */\n \n static void\n@@ -1528,26 +1535,79 @@ build_agg_jump_func_from_list (struct ipa_known_agg_contents_list *list,\n     }\n }\n \n+/* If STMT is a memory store to the object whose address is BASE, extract\n+   information (offset, size, and value) into CONTENT, and return true,\n+   otherwise we conservatively assume the whole object is modified with\n+   unknown content, and return false.  CHECK_REF means that access to object\n+   is expected to be in form of MEM_REF expression.  */\n+\n+static bool\n+extract_mem_content (gimple *stmt, tree base, bool check_ref,\n+\t\t     struct ipa_known_agg_contents_list *content)\n+{\n+  HOST_WIDE_INT lhs_offset, lhs_size;\n+  tree lhs, rhs, lhs_base;\n+  bool reverse;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return false;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  rhs = gimple_assign_rhs1 (stmt);\n+\n+  if (!is_gimple_reg_type (TREE_TYPE (rhs))\n+      || TREE_CODE (lhs) == BIT_FIELD_REF\n+      || contains_bitfld_component_ref_p (lhs))\n+    return false;\n+\n+  lhs_base = get_ref_base_and_extent_hwi (lhs, &lhs_offset,\n+\t\t\t\t\t  &lhs_size, &reverse);\n+  if (!lhs_base)\n+    return false;\n+\n+  if (check_ref)\n+    {\n+      if (TREE_CODE (lhs_base) != MEM_REF\n+\t  || TREE_OPERAND (lhs_base, 0) != base\n+\t  || !integer_zerop (TREE_OPERAND (lhs_base, 1)))\n+\treturn false;\n+    }\n+  else if (lhs_base != base)\n+    return false;\n+\n+  rhs = get_ssa_def_if_simple_copy (rhs);\n+\n+  content->size = lhs_size;\n+  content->offset = lhs_offset;\n+  content->constant = is_gimple_ip_invariant (rhs) ? rhs : NULL_TREE;\n+  content->next = NULL;\n+\n+  return true;\n+}\n+\n /* Traverse statements from CALL backwards, scanning whether an aggregate given\n    in ARG is filled in with constant values.  ARG can either be an aggregate\n    expression or a pointer to an aggregate.  ARG_TYPE is the type of the\n    aggregate.  JFUNC is the jump function into which the constants are\n-   subsequently stored.  */\n+   subsequently stored.  AA_WALK_BUDGET_P points to limit on number of\n+   statements we allow get_continuation_for_phi to examine.  */\n \n static void\n-determine_locally_known_aggregate_parts (gcall *call, tree arg,\n-\t\t\t\t\t tree arg_type,\n-\t\t\t\t\t struct ipa_jump_func *jfunc)\n+determine_known_aggregate_parts (gcall *call, tree arg,\n+\t\t\t\t tree arg_type,\n+\t\t\t\t struct ipa_jump_func *jfunc,\n+\t\t\t\t unsigned *aa_walk_budget_p)\n {\n-  struct ipa_known_agg_contents_list *list = NULL;\n+  struct ipa_known_agg_contents_list *list = NULL, *all_list = NULL;\n+  bitmap visited = NULL;\n   int item_count = 0, const_count = 0;\n+  int ipa_max_agg_items = PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS);\n   HOST_WIDE_INT arg_offset, arg_size;\n-  gimple_stmt_iterator gsi;\n   tree arg_base;\n   bool check_ref, by_ref;\n   ao_ref r;\n \n-  if (PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS) == 0)\n+  if (ipa_max_agg_items == 0)\n     return;\n \n   /* The function operates in three stages.  First, we prepare check_ref, r,\n@@ -1606,82 +1666,61 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n       ao_ref_init (&r, arg);\n     }\n \n-  /* Second stage walks back the BB, looks at individual statements and as long\n-     as it is confident of how the statements affect contents of the\n-     aggregates, it builds a sorted linked list of ipa_agg_jf_list structures\n-     describing it.  */\n-  gsi = gsi_for_stmt (call);\n-  gsi_prev (&gsi);\n-  for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n-    {\n-      struct ipa_known_agg_contents_list *n, **p;\n-      gimple *stmt = gsi_stmt (gsi);\n-      HOST_WIDE_INT lhs_offset, lhs_size;\n-      tree lhs, rhs, lhs_base;\n-      bool reverse;\n-\n-      if (!stmt_may_clobber_ref_p_1 (stmt, &r))\n-\tcontinue;\n-      if (!gimple_assign_single_p (stmt))\n-\tbreak;\n+  /* Second stage traverses virtual SSA web backwards starting from the call\n+     statement, only looks at individual dominating virtual operand (its\n+     definition dominates the call), as long as it is confident that content\n+     of the aggregate is affected by definition of the virtual operand, it\n+     builds a sorted linked list of ipa_agg_jf_list describing that.  */\n \n-      lhs = gimple_assign_lhs (stmt);\n-      rhs = gimple_assign_rhs1 (stmt);\n-      if (!is_gimple_reg_type (TREE_TYPE (rhs))\n-\t  || TREE_CODE (lhs) == BIT_FIELD_REF\n-\t  || contains_bitfld_component_ref_p (lhs))\n-\tbreak;\n-\n-      lhs_base = get_ref_base_and_extent_hwi (lhs, &lhs_offset,\n-\t\t\t\t\t      &lhs_size, &reverse);\n-      if (!lhs_base)\n-\tbreak;\n+  for (tree dom_vuse = gimple_vuse (call); dom_vuse;)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (dom_vuse);\n \n-      if (check_ref)\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n-\t  if (TREE_CODE (lhs_base) != MEM_REF\n-\t      || TREE_OPERAND (lhs_base, 0) != arg_base\n-\t      || !integer_zerop (TREE_OPERAND (lhs_base, 1)))\n-\t    break;\n+\t  dom_vuse = get_continuation_for_phi (stmt, &r, *aa_walk_budget_p,\n+\t\t\t\t\t       &visited, false, NULL, NULL);\n+\t  continue;\n \t}\n-      else if (lhs_base != arg_base)\n+\n+      if (stmt_may_clobber_ref_p_1 (stmt, &r))\n \t{\n-\t  if (DECL_P (lhs_base))\n-\t    continue;\n-\t  else\n+\t  struct ipa_known_agg_contents_list *content\n+\t\t\t= XALLOCA (struct ipa_known_agg_contents_list);\n+\n+\t  if (!extract_mem_content (stmt, arg_base, check_ref, content))\n \t    break;\n-\t}\n \n-      bool already_there = false;\n-      p = get_place_in_agg_contents_list (&list, lhs_offset, lhs_size,\n-\t\t\t\t\t  &already_there);\n-      if (!p)\n-\tbreak;\n-      if (already_there)\n-\tcontinue;\n+\t  /* Now we get a dominating virtual operand, and need to check\n+\t     whether its value is clobbered any other dominating one.  */\n+\t  if (content->constant\n+\t      && !clobber_by_agg_contents_list_p (all_list, content))\n+\t    {\n+\t      struct ipa_known_agg_contents_list *copy\n+\t\t\t= XALLOCA (struct ipa_known_agg_contents_list);\n \n-      rhs = get_ssa_def_if_simple_copy (rhs);\n-      n = XALLOCA (struct ipa_known_agg_contents_list);\n-      n->size = lhs_size;\n-      n->offset = lhs_offset;\n-      if (is_gimple_ip_invariant (rhs))\n-\t{\n-\t  n->constant = rhs;\n-\t  const_count++;\n+\t      /* Add to the list consisting of only dominating virtual\n+\t\t operands, whose definitions can finally reach the call.  */\n+\t      add_to_agg_contents_list (&list, (*copy = *content, copy));\n+\n+\t      if (++const_count == ipa_max_agg_items)\n+\t\tbreak;\n+\t    }\n+\n+\t  /* Add to the list consisting of all dominating virtual operands.  */\n+\t  add_to_agg_contents_list (&all_list, content);\n+\n+\t  if (++item_count == 2 * ipa_max_agg_items)\n+\t    break;\n \t}\n-      else\n-\tn->constant = NULL_TREE;\n-      n->next = *p;\n-      *p = n;\n+      dom_vuse = gimple_vuse (stmt);\n+   }\n \n-      item_count++;\n-      if (const_count == PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS)\n-\t  || item_count == 2 * PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS))\n-\tbreak;\n-    }\n+  if (visited)\n+    BITMAP_FREE (visited);\n \n   /* Third stage just goes over the list and creates an appropriate vector of\n-     ipa_agg_jf_item structures out of it, of sourse only if there are\n+     ipa_agg_jf_item structures out of it, of course only if there are\n      any known constants to begin with.  */\n \n   if (const_count)\n@@ -1691,6 +1730,7 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n     }\n }\n \n+\n /* Return the Ith param type of callee associated with call graph\n    edge E.  */\n \n@@ -1797,7 +1837,7 @@ ipa_set_jfunc_vr (ipa_jump_func *jf, enum value_range_kind type,\n   jf->m_vr = ipa_get_value_range (type, min, max);\n }\n \n-/* Assign to JF a pointer to a value_range just liek TMP but either fetch a\n+/* Assign to JF a pointer to a value_range just like TMP but either fetch a\n    copy from ipa_vr_hash_table or allocate a new on in GC memory.  */\n \n static void\n@@ -1978,7 +2018,8 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      || !ipa_get_jf_ancestor_agg_preserved (jfunc))\n \t  && (AGGREGATE_TYPE_P (TREE_TYPE (arg))\n \t      || POINTER_TYPE_P (param_type)))\n-\tdetermine_locally_known_aggregate_parts (call, arg, param_type, jfunc);\n+\tdetermine_known_aggregate_parts (call, arg, param_type, jfunc,\n+\t\t\t\t\t &fbi->aa_walk_budget);\n     }\n   if (!useful_context)\n     vec_free (args->polymorphic_call_contexts);"}, {"sha": "2f070382b0443f2441bb0874f51e2d91e0cfd807", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46771da57463c62f66af32e9189f1b6fb8bbe8c7", "patch": "@@ -1,3 +1,8 @@\n+2019-06-14  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/90401\n+\t* gcc.dg/ipa/ipcp-agg-10.c: New test.\n+\n 2019-06-13  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90662"}, {"sha": "16d62e72c9a9b3a58231995fd27e302494aa15cb", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-10.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46771da57463c62f66af32e9189f1b6fb8bbe8c7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-10.c?ref=46771da57463c62f66af32e9189f1b6fb8bbe8c7", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline\" } */\n+\n+int data1;\n+\n+int callee1(int *v)\n+{\n+  if (*v < 2)\n+    return 0;\n+  else \n+    {\n+      int t = data1;\n+\n+      data1 = *v;\n+      *v = t;\n+\n+      return 1;\n+    }\n+}\n+\n+int __attribute__((pure)) callee2(int *v)\n+{\n+  if (*v < 2)\n+    return 0;\n+  else \n+    {\n+      data1 = v[0] + v[2];\n+\n+      return 1;\n+    }\n+}\n+\n+int caller1(int c, int *r)\n+{\n+  int a = 1;\n+\n+  if (c)\n+    return callee1(&a);\n+  else\n+    {\n+      *r = 2;\n+      return callee1(r);\n+    }\n+}\n+\n+int data2[200];\n+int data3;\n+\n+int __attribute__((const)) gen_cond(int);\n+\n+int caller2(void)\n+{\n+  int i, j;\n+  int sum = 0;\n+  int a[8];\n+\n+  a[0] = 3;\n+  for (i = 0; i < 100; i++)\n+    {\n+      if (gen_cond (i))\n+        continue;\n+\n+      a[2] = 4;\n+      for (j = 0; j < 100; j++)\n+        {\n+          data2[i + j] = (i ^ j) + data3;\n+\n+          sum += callee2(a);\n+        }\n+    }\n+\n+  return sum;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"offset: 0, cst: 1\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 0, cst: 2\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 0, cst: 3\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"offset: 64, cst: 4\" 1 \"cp\" } } */"}]}