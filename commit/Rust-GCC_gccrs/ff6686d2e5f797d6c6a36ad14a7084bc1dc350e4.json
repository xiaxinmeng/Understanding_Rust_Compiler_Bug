{"sha": "ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2Njg2ZDJlNWY3OTdkNmM2YTM2YWQxNGE3MDg0YmMxZGMzNTBlNA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-09-19T22:25:04Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-09-19T22:25:04Z"}, "message": "New IPA-SRA\n\n2019-09-20  Martin Jambor  <mjambor@suse.cz>\n\n        * coretypes.h (cgraph_edge): Declare.\n        * ipa-param-manipulation.c: Rewrite.\n        * ipa-param-manipulation.h: Likewise.\n        * Makefile.in (GTFILES): Added ipa-param-manipulation.h and ipa-sra.c.\n        (OBJS): Added ipa-sra.o.\n        * cgraph.h (ipa_replace_map): Removed fields old_tree, replace_p\n        and ref_p, added fields param_adjustments and performed_splits.\n        (struct cgraph_clone_info): Remove ags_to_skip and\n        combined_args_to_skip, new field param_adjustments.\n        (cgraph_node::create_clone): Changed parameters to use\n        ipa_param_adjustments.\n        (cgraph_node::create_virtual_clone): Likewise.\n        (cgraph_node::create_virtual_clone_with_body): Likewise.\n        (tree_function_versioning): Likewise.\n        (cgraph_build_function_type_skip_args): Removed.\n        * cgraph.c (cgraph_edge::redirect_call_stmt_to_callee): Convert to\n        using ipa_param_adjustments.\n        (clone_of_p): Likewise.\n        * cgraphclones.c (cgraph_build_function_type_skip_args): Removed.\n        (build_function_decl_skip_args): Likewise.\n        (duplicate_thunk_for_node): Adjust parameters using\n        ipa_param_body_adjustments, copy param_adjustments instead of\n        args_to_skip.\n        (cgraph_node::create_clone): Convert to using ipa_param_adjustments.\n        (cgraph_node::create_virtual_clone): Likewise.\n        (cgraph_node::create_version_clone_with_body): Likewise.\n        (cgraph_materialize_clone): Likewise.\n        (symbol_table::materialize_all_clones): Likewise.\n        * ipa-fnsummary.c (ipa_fn_summary_t::duplicate): Simplify\n        ipa_replace_map check.\n        * ipa-cp.c (get_replacement_map): Do not initialize removed fields.\n        (initialize_node_lattices): Make aware that some parameters might have\n        already been removed.\n        (want_remove_some_param_p): New function.\n        (create_specialized_node): Convert to using ipa_param_adjustments and\n        deal with possibly pre-existing adjustments.\n        * lto-cgraph.c (output_cgraph_opt_summary_p): Likewise.\n        (output_node_opt_summary): Do not stream removed fields.  Stream\n        parameter adjustments instead of argumetns to skip.\n        (input_node_opt_summary): Likewise.\n        (input_node_opt_summary): Likewise.\n        * lto-section-in.c (lto_section_name): Added ipa-sra section.\n        * lto-streamer.h (lto_section_type): Likewise.\n        * tree-inline.h (copy_body_data): New fields killed_new_ssa_names and\n\tparam_body_adjs.\n        (copy_decl_to_var): Declare.\n        * tree-inline.c (update_clone_info): Do not remap old_tree.\n        (remap_gimple_stmt): Use ipa_param_body_adjustments to modify gimple\n        statements, walk all extra generated statements and remap their\n        operands.\n        (redirect_all_calls): Add killed SSA names to a hash set.\n        (remap_ssa_name): Do not remap killed SSA names.\n        (copy_arguments_for_versioning): Renames to copy_arguments_nochange,\n        half of functionality moved to ipa_param_body_adjustments.\n        (copy_decl_to_var): Make exported.\n        (copy_body): Destroy killed_new_ssa_names hash set.\n        (expand_call_inline): Remap performed splits.\n        (update_clone_info): Likewise.\n        (tree_function_versioning): Simplify tree_map processing.  Updated to\n        accept ipa_param_adjustments and use ipa_param_body_adjustments.\n        * omp-simd-clone.c (simd_clone_vector_of_formal_parm_types): Adjust\n        for the new interface.\n        (simd_clone_clauses_extract): Likewise, make args an auto_vec.\n        (simd_clone_compute_base_data_type): Likewise.\n        (simd_clone_init_simd_arrays): Adjust for the new interface.\n        (simd_clone_adjust_argument_types): Likewise.\n        (struct modify_stmt_info): Likewise.\n        (ipa_simd_modify_stmt_ops): Likewise.\n        (ipa_simd_modify_function_body): Likewise.\n        (simd_clone_adjust): Likewise.\n        * tree-sra.c: Removed IPA-SRA.  Include tree-sra.h.\n        (type_internals_preclude_sra_p): Make public.\n        * tree-sra.h: New file.\n        * ipa-inline-transform.c (save_inline_function_body): Update to\n        refelct new tree_function_versioning signature.\n        * ipa-prop.c (adjust_agg_replacement_values): Use a helper from\n        ipa_param_adjustments to get current parameter indices.\n        (ipcp_modif_dom_walker::before_dom_children): Likewise.\n        (ipcp_update_bits): Likewise.\n        (ipcp_update_vr): Likewise.\n        * ipa-split.c (split_function): Convert to using ipa_param_adjustments.\n        * ipa-sra.c: New file.\n        * multiple_target.c (create_target_clone): Update to reflet new type\n        of create_version_clone_with_body.\n        * trans-mem.c (ipa_tm_create_version): Update to reflect new type of\n        tree_function_versioning.\n\t(modify_function): Update to reflect new type of\n\ttree_function_versioning.\n        * params.def (PARAM_IPA_SRA_MAX_REPLACEMENTS): New.\n        * passes.def: Remove old IPA-SRA and add new one.\n        * tree-pass.h (make_pass_early_ipa_sra): Remove declaration.\n        (make_pass_ipa_sra): Declare.\n\t* dbgcnt.def: Remove eipa_sra.  Added ipa_sra_params and\n\tipa_sra_retvalues.\n\t* doc/invoke.texi (ipa-sra-max-replacements): New.\n\n        testsuite/\n        * g++.dg/ipa/pr81248.C: Adjust dg-options and dump-scan.\n        * gcc.dg/ipa/ipa-sra-1.c: Likewise.\n        * gcc.dg/ipa/ipa-sra-10.c: Likewise.\n        * gcc.dg/ipa/ipa-sra-11.c: Likewise.\n        * gcc.dg/ipa/ipa-sra-3.c: Likewise.\n        * gcc.dg/ipa/ipa-sra-4.c: Likewise.\n        * gcc.dg/ipa/ipa-sra-5.c: Likewise.\n        * gcc.dg/ipa/ipacost-2.c: Disable ipa-sra.\n        * gcc.dg/ipa/ipcp-agg-9.c: Likewise.\n        * gcc.dg/ipa/pr78121.c: Adjust scan pattern.\n        * gcc.dg/ipa/vrp1.c: Likewise.\n        * gcc.dg/ipa/vrp2.c: Likewise.\n        * gcc.dg/ipa/vrp3.c: Likewise.\n        * gcc.dg/ipa/vrp7.c: Likewise.\n        * gcc.dg/ipa/vrp8.c: Likewise.\n        * gcc.dg/noreorder.c: use noipa attribute instead of noinline.\n        * gcc.dg/ipa/20040703-wpa.c: New test.\n\t* gcc.dg/ipa/ipa-sra-12.c: New test.\n\t* gcc.dg/ipa/ipa-sra-13.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-14.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-15.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-16.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-17.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-18.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-19.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-20.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-21.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-22.c: Likewise.\n\t* gcc.dg/sso/ipa-sra-1.c: Likewise.\n\t* g++.dg/ipa/ipa-sra-2.C: Likewise.\n\t* g++.dg/ipa/ipa-sra-3.C: Likewise.\n\t* gcc.dg/tree-ssa/ipa-cp-1.c: Make return value used.\n\t* g++.dg/ipa/devirt-19.C: Add missing return, add -fipa-cp-clone\n\toption.\n\t* g++.dg/lto/devirt-19_0.C: Add -fipa-cp-clone option.\n\t* gcc.dg/ipa/ipa-sra-2.c: Removed.\n\t* gcc.dg/ipa/ipa-sra-6.c: Likewise.\n\nFrom-SVN: r275982", "tree": {"sha": "21de4e26dd766dab8b60b2be7190a6b86bad2b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21de4e26dd766dab8b60b2be7190a6b86bad2b38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6889a3acfeed47265886676c6d43b04ef799fb82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6889a3acfeed47265886676c6d43b04ef799fb82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6889a3acfeed47265886676c6d43b04ef799fb82"}], "stats": {"total": 11141, "additions": 7998, "deletions": 3143}, "files": [{"sha": "6f34d1a90c4a25cabfce78d26bc8d7276961b531", "filename": "gcc/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,3 +1,101 @@\n+2019-09-20  Martin Jambor  <mjambor@suse.cz>\n+\n+        * coretypes.h (cgraph_edge): Declare.\n+        * ipa-param-manipulation.c: Rewrite.\n+        * ipa-param-manipulation.h: Likewise.\n+        * Makefile.in (GTFILES): Added ipa-param-manipulation.h and ipa-sra.c.\n+        (OBJS): Added ipa-sra.o.\n+        * cgraph.h (ipa_replace_map): Removed fields old_tree, replace_p\n+        and ref_p, added fields param_adjustments and performed_splits.\n+        (struct cgraph_clone_info): Remove ags_to_skip and\n+        combined_args_to_skip, new field param_adjustments.\n+        (cgraph_node::create_clone): Changed parameters to use\n+        ipa_param_adjustments.\n+        (cgraph_node::create_virtual_clone): Likewise.\n+        (cgraph_node::create_virtual_clone_with_body): Likewise.\n+        (tree_function_versioning): Likewise.\n+        (cgraph_build_function_type_skip_args): Removed.\n+        * cgraph.c (cgraph_edge::redirect_call_stmt_to_callee): Convert to\n+        using ipa_param_adjustments.\n+        (clone_of_p): Likewise.\n+        * cgraphclones.c (cgraph_build_function_type_skip_args): Removed.\n+        (build_function_decl_skip_args): Likewise.\n+        (duplicate_thunk_for_node): Adjust parameters using\n+        ipa_param_body_adjustments, copy param_adjustments instead of\n+        args_to_skip.\n+        (cgraph_node::create_clone): Convert to using ipa_param_adjustments.\n+        (cgraph_node::create_virtual_clone): Likewise.\n+        (cgraph_node::create_version_clone_with_body): Likewise.\n+        (cgraph_materialize_clone): Likewise.\n+        (symbol_table::materialize_all_clones): Likewise.\n+        * ipa-fnsummary.c (ipa_fn_summary_t::duplicate): Simplify\n+        ipa_replace_map check.\n+        * ipa-cp.c (get_replacement_map): Do not initialize removed fields.\n+        (initialize_node_lattices): Make aware that some parameters might have\n+        already been removed.\n+        (want_remove_some_param_p): New function.\n+        (create_specialized_node): Convert to using ipa_param_adjustments and\n+        deal with possibly pre-existing adjustments.\n+        * lto-cgraph.c (output_cgraph_opt_summary_p): Likewise.\n+        (output_node_opt_summary): Do not stream removed fields.  Stream\n+        parameter adjustments instead of argumetns to skip.\n+        (input_node_opt_summary): Likewise.\n+        (input_node_opt_summary): Likewise.\n+        * lto-section-in.c (lto_section_name): Added ipa-sra section.\n+        * lto-streamer.h (lto_section_type): Likewise.\n+        * tree-inline.h (copy_body_data): New fields killed_new_ssa_names and\n+\tparam_body_adjs.\n+        (copy_decl_to_var): Declare.\n+        * tree-inline.c (update_clone_info): Do not remap old_tree.\n+        (remap_gimple_stmt): Use ipa_param_body_adjustments to modify gimple\n+        statements, walk all extra generated statements and remap their\n+        operands.\n+        (redirect_all_calls): Add killed SSA names to a hash set.\n+        (remap_ssa_name): Do not remap killed SSA names.\n+        (copy_arguments_for_versioning): Renames to copy_arguments_nochange,\n+        half of functionality moved to ipa_param_body_adjustments.\n+        (copy_decl_to_var): Make exported.\n+        (copy_body): Destroy killed_new_ssa_names hash set.\n+        (expand_call_inline): Remap performed splits.\n+        (update_clone_info): Likewise.\n+        (tree_function_versioning): Simplify tree_map processing.  Updated to\n+        accept ipa_param_adjustments and use ipa_param_body_adjustments.\n+        * omp-simd-clone.c (simd_clone_vector_of_formal_parm_types): Adjust\n+        for the new interface.\n+        (simd_clone_clauses_extract): Likewise, make args an auto_vec.\n+        (simd_clone_compute_base_data_type): Likewise.\n+        (simd_clone_init_simd_arrays): Adjust for the new interface.\n+        (simd_clone_adjust_argument_types): Likewise.\n+        (struct modify_stmt_info): Likewise.\n+        (ipa_simd_modify_stmt_ops): Likewise.\n+        (ipa_simd_modify_function_body): Likewise.\n+        (simd_clone_adjust): Likewise.\n+        * tree-sra.c: Removed IPA-SRA.  Include tree-sra.h.\n+        (type_internals_preclude_sra_p): Make public.\n+        * tree-sra.h: New file.\n+        * ipa-inline-transform.c (save_inline_function_body): Update to\n+        refelct new tree_function_versioning signature.\n+        * ipa-prop.c (adjust_agg_replacement_values): Use a helper from\n+        ipa_param_adjustments to get current parameter indices.\n+        (ipcp_modif_dom_walker::before_dom_children): Likewise.\n+        (ipcp_update_bits): Likewise.\n+        (ipcp_update_vr): Likewise.\n+        * ipa-split.c (split_function): Convert to using ipa_param_adjustments.\n+        * ipa-sra.c: New file.\n+        * multiple_target.c (create_target_clone): Update to reflet new type\n+        of create_version_clone_with_body.\n+        * trans-mem.c (ipa_tm_create_version): Update to reflect new type of\n+        tree_function_versioning.\n+\t(modify_function): Update to reflect new type of\n+\ttree_function_versioning.\n+        * params.def (PARAM_IPA_SRA_MAX_REPLACEMENTS): New.\n+        * passes.def: Remove old IPA-SRA and add new one.\n+        * tree-pass.h (make_pass_early_ipa_sra): Remove declaration.\n+        (make_pass_ipa_sra): Declare.\n+\t* dbgcnt.def: Remove eipa_sra.  Added ipa_sra_params and\n+\tipa_sra_retvalues.\n+\t* doc/invoke.texi (ipa-sra-max-replacements): New.\n+\n 2019-09-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/91631"}, {"sha": "2cf0c79c977fe7b083e86059fff4bac871b51ba5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1368,6 +1368,7 @@ OBJS = \\\n \tinit-regs.o \\\n \tinternal-fn.o \\\n \tipa-cp.o \\\n+\tipa-sra.o \\\n \tipa-devirt.o \\\n \tipa-fnsummary.o \\\n \tipa-polymorphic-call.o \\\n@@ -2527,7 +2528,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-utils.h \\\n-  $(srcdir)/dbxout.c \\\n+  $(srcdir)/ipa-param-manipulation.h $(srcdir)/ipa-sra.c $(srcdir)/dbxout.c \\\n   $(srcdir)/signop.h \\\n   $(srcdir)/dwarf2out.h \\\n   $(srcdir)/dwarf2asm.c \\"}, {"sha": "331b363c175d1b5fca8bdbc658c8dce8f93f6e92", "filename": "gcc/cgraph.c", "status": "modified", "additions": 29, "deletions": 98, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1342,33 +1342,44 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n   if (flag_checking && decl)\n     {\n       cgraph_node *node = cgraph_node::get (decl);\n-      gcc_assert (!node || !node->clone.combined_args_to_skip);\n+      gcc_assert (!node || !node->clone.param_adjustments);\n     }\n \n   if (symtab->dump_file)\n     {\n       fprintf (symtab->dump_file, \"updating call of %s -> %s: \",\n \t       e->caller->dump_name (), e->callee->dump_name ());\n       print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n-      if (e->callee->clone.combined_args_to_skip)\n+      if (e->callee->clone.param_adjustments)\n+\te->callee->clone.param_adjustments->dump (symtab->dump_file);\n+      unsigned performed_len\n+\t= vec_safe_length (e->caller->clone.performed_splits);\n+      if (performed_len > 0)\n+\tfprintf (symtab->dump_file, \"Performed splits records:\\n\");\n+      for (unsigned i = 0; i < performed_len; i++)\n \t{\n-\t  fprintf (symtab->dump_file, \" combined args to skip: \");\n-\t  dump_bitmap (symtab->dump_file,\n-\t\t       e->callee->clone.combined_args_to_skip);\n+\t  ipa_param_performed_split *sm\n+\t    = &(*e->caller->clone.performed_splits)[i];\n+\t  print_node_brief (symtab->dump_file, \"  dummy_decl: \", sm->dummy_decl,\n+\t\t\t    TDF_UID);\n+\t  fprintf (symtab->dump_file, \", unit_offset: %u\\n\", sm->unit_offset);\n \t}\n     }\n \n-  if (e->callee->clone.combined_args_to_skip)\n+  if (ipa_param_adjustments *padjs = e->callee->clone.param_adjustments)\n     {\n-      int lp_nr;\n+      /* We need to defer cleaning EH info on the new statement to\n+         fixup-cfg.  We may not have dominator information at this point\n+\t and thus would end up with unreachable blocks and have no way\n+\t to communicate that we need to run CFG cleanup then.  */\n+      int lp_nr = lookup_stmt_eh_lp (e->call_stmt);\n+      if (lp_nr != 0)\n+\tremove_stmt_from_eh_lp (e->call_stmt);\n \n-      new_stmt = e->call_stmt;\n-      if (e->callee->clone.combined_args_to_skip)\n-\tnew_stmt\n-\t  = gimple_call_copy_skip_args (new_stmt,\n-\t\t\t\t\te->callee->clone.combined_args_to_skip);\n       tree old_fntype = gimple_call_fntype (e->call_stmt);\n-      gimple_call_set_fndecl (new_stmt, e->callee->decl);\n+      new_stmt = padjs->modify_call (e->call_stmt,\n+\t\t\t\t     e->caller->clone.performed_splits,\n+\t\t\t\t     e->callee->decl, false);\n       cgraph_node *origin = e->callee;\n       while (origin->clone_of)\n \torigin = origin->clone_of;\n@@ -1379,92 +1390,12 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \tgimple_call_set_fntype (new_stmt, TREE_TYPE (e->callee->decl));\n       else\n \t{\n-\t  bitmap skip = e->callee->clone.combined_args_to_skip;\n-\t  tree t = cgraph_build_function_type_skip_args (old_fntype, skip,\n-\t\t\t\t\t\t\t false);\n-\t  gimple_call_set_fntype (new_stmt, t);\n-\t}\n-\n-      if (gimple_vdef (new_stmt)\n-\t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n-\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n-\n-      gsi = gsi_for_stmt (e->call_stmt);\n-\n-      /* For optimized away parameters, add on the caller side\n-\t before the call\n-\t DEBUG D#X => parm_Y(D)\n-\t stmts and associate D#X with parm in decl_debug_args_lookup\n-\t vector to say for debug info that if parameter parm had been passed,\n-\t it would have value parm_Y(D).  */\n-      if (e->callee->clone.combined_args_to_skip && MAY_HAVE_DEBUG_BIND_STMTS)\n-\t{\n-\t  vec<tree, va_gc> **debug_args\n-\t    = decl_debug_args_lookup (e->callee->decl);\n-\t  tree old_decl = gimple_call_fndecl (e->call_stmt);\n-\t  if (debug_args && old_decl)\n-\t    {\n-\t      tree parm;\n-\t      unsigned i = 0, num;\n-\t      unsigned len = vec_safe_length (*debug_args);\n-\t      unsigned nargs = gimple_call_num_args (e->call_stmt);\n-\t      for (parm = DECL_ARGUMENTS (old_decl), num = 0;\n-\t\t   parm && num < nargs;\n-\t\t   parm = DECL_CHAIN (parm), num++)\n-\t\tif (bitmap_bit_p (e->callee->clone.combined_args_to_skip, num)\n-\t\t    && is_gimple_reg (parm))\n-\t\t  {\n-\t\t    unsigned last = i;\n-\n-\t\t    while (i < len && (**debug_args)[i] != DECL_ORIGIN (parm))\n-\t\t      i += 2;\n-\t\t    if (i >= len)\n-\t\t      {\n-\t\t\ti = 0;\n-\t\t\twhile (i < last\n-\t\t\t       && (**debug_args)[i] != DECL_ORIGIN (parm))\n-\t\t\t  i += 2;\n-\t\t\tif (i >= last)\n-\t\t\t  continue;\n-\t\t      }\n-\t\t    tree ddecl = (**debug_args)[i + 1];\n-\t\t    tree arg = gimple_call_arg (e->call_stmt, num);\n-\t\t    if (!useless_type_conversion_p (TREE_TYPE (ddecl),\n-\t\t\t\t\t\t    TREE_TYPE (arg)))\n-\t\t      {\n-\t\t\ttree rhs1;\n-\t\t\tif (!fold_convertible_p (TREE_TYPE (ddecl), arg))\n-\t\t\t  continue;\n-\t\t\tif (TREE_CODE (arg) == SSA_NAME\n-\t\t\t    && gimple_assign_cast_p (SSA_NAME_DEF_STMT (arg))\n-\t\t\t    && (rhs1\n-\t\t\t\t= gimple_assign_rhs1 (SSA_NAME_DEF_STMT (arg)))\n-\t\t\t    && useless_type_conversion_p (TREE_TYPE (ddecl),\n-\t\t\t\t\t\t\t  TREE_TYPE (rhs1)))\n-\t\t\t  arg = rhs1;\n-\t\t\telse\n-\t\t\t  arg = fold_convert (TREE_TYPE (ddecl), arg);\n-\t\t      }\n-\n-\t\t    gimple *def_temp\n-\t\t      = gimple_build_debug_bind (ddecl, unshare_expr (arg),\n-\t\t\t\t\t\t e->call_stmt);\n-\t\t    gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n-\t\t  }\n-\t    }\n+\t  tree new_fntype = padjs->build_new_function_type (old_fntype, true);\n+\t  gimple_call_set_fntype (new_stmt, new_fntype);\n \t}\n \n-      gsi_replace (&gsi, new_stmt, false);\n-      /* We need to defer cleaning EH info on the new statement to\n-         fixup-cfg.  We may not have dominator information at this point\n-\t and thus would end up with unreachable blocks and have no way\n-\t to communicate that we need to run CFG cleanup then.  */\n-      lp_nr = lookup_stmt_eh_lp (e->call_stmt);\n       if (lp_nr != 0)\n-\t{\n-\t  remove_stmt_from_eh_lp (e->call_stmt);\n-\t  add_stmt_to_eh_lp (new_stmt, lp_nr);\n-\t}\n+\tadd_stmt_to_eh_lp (new_stmt, lp_nr);\n     }\n   else\n     {\n@@ -3014,8 +2945,8 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)\n \treturn true;\n       node = node->callees->callee->ultimate_alias_target ();\n \n-      if (!node2->clone.args_to_skip\n-\t  || !bitmap_bit_p (node2->clone.args_to_skip, 0))\n+      if (!node2->clone.param_adjustments\n+\t  || node2->clone.param_adjustments->first_param_intact_p ())\n \treturn false;\n       if (node2->former_clone_of == node->decl)\n \treturn true;"}, {"sha": "1da6cab54b03d32625e1140097c6516aae23f4bc", "filename": "gcc/cgraph.h", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"profile-count.h\"\n #include \"ipa-ref.h\"\n #include \"plugin-api.h\"\n+#include \"ipa-param-manipulation.h\"\n \n extern void debuginfo_early_init (void);\n extern void debuginfo_init (void);\n@@ -740,23 +741,31 @@ struct GTY(()) cgraph_global_info {\n    will be replaced by another tree while versioning.  */\n struct GTY(()) ipa_replace_map\n {\n-  /* The tree that will be replaced.  */\n-  tree old_tree;\n   /* The new (replacing) tree.  */\n   tree new_tree;\n   /* Parameter number to replace, when old_tree is NULL.  */\n   int parm_num;\n-  /* True when a substitution should be done, false otherwise.  */\n-  bool replace_p;\n-  /* True when we replace a reference to old_tree.  */\n-  bool ref_p;\n };\n \n struct GTY(()) cgraph_clone_info\n {\n+  /* Constants discovered by IPA-CP, i.e. which parameter should be replaced\n+     with what.  */\n   vec<ipa_replace_map *, va_gc> *tree_map;\n-  bitmap args_to_skip;\n-  bitmap combined_args_to_skip;\n+  /* Parameter modification that IPA-SRA decided to perform.  */\n+  ipa_param_adjustments *param_adjustments;\n+  /* Lists of dummy-decl and offset pairs representing split formal parameters\n+     in the caller.  Offsets of all new replacements are enumerated, those\n+     coming from the same original parameter have the same dummy decl stored\n+     along with them.\n+\n+     Dummy decls sit in call statement arguments followed by new parameter\n+     decls (or their SSA names) in between (caller) clone materialization and\n+     call redirection.  Redirection then recognizes the dummy variable and\n+     together with the stored offsets can reconstruct what exactly the new\n+     parameter decls represent and can leave in place only those that the\n+     callee expects.  */\n+  vec<ipa_param_performed_split, va_gc> *performed_splits;\n };\n \n enum cgraph_simd_clone_arg_type\n@@ -976,15 +985,16 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \t\t\t     vec<cgraph_edge *> redirect_callers,\n \t\t\t     bool call_duplication_hook,\n \t\t\t     cgraph_node *new_inlined_to,\n-\t\t\t     bitmap args_to_skip, const char *suffix = NULL);\n+\t\t\t     ipa_param_adjustments *param_adjustments,\n+\t\t\t     const char *suffix = NULL);\n \n   /* Create callgraph node clone with new declaration.  The actual body will be\n      copied later at compilation stage.  The name of the new clone will be\n      constructed from the name of the original node, SUFFIX and NUM_SUFFIX.  */\n   cgraph_node *create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n \t\t\t\t     vec<ipa_replace_map *, va_gc> *tree_map,\n-\t\t\t\t     bitmap args_to_skip, const char * suffix,\n-\t\t\t\t     unsigned num_suffix);\n+\t\t\t\t     ipa_param_adjustments *param_adjustments,\n+\t\t\t\t     const char * suffix, unsigned num_suffix);\n \n   /* cgraph node being removed from symbol table; see if its entry can be\n    replaced by other inline clone.  */\n@@ -1033,9 +1043,10 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n      Return the new version's cgraph node.  */\n   cgraph_node *create_version_clone_with_body\n     (vec<cgraph_edge *> redirect_callers,\n-     vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,\n-     bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,\n-     const char *clone_name, tree target_attributes = NULL_TREE);\n+     vec<ipa_replace_map *, va_gc> *tree_map,\n+     ipa_param_adjustments *param_adjustments,\n+     bitmap bbs_to_copy, basic_block new_entry_block, const char *clone_name,\n+     tree target_attributes = NULL_TREE);\n \n   /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n      corresponding to cgraph_node.  */\n@@ -2459,14 +2470,12 @@ tree clone_function_name (tree decl, const char *suffix,\n tree clone_function_name (tree decl, const char *suffix);\n \n void tree_function_versioning (tree, tree, vec<ipa_replace_map *, va_gc> *,\n-\t\t\t       bool, bitmap, bool, bitmap, basic_block);\n+\t\t\t       ipa_param_adjustments *,\n+\t\t\t       bool, bitmap, basic_block);\n \n void dump_callgraph_transformation (const cgraph_node *original,\n \t\t\t\t    const cgraph_node *clone,\n \t\t\t\t    const char *suffix);\n-tree cgraph_build_function_type_skip_args (tree orig_type, bitmap args_to_skip,\n-\t\t\t\t\t   bool skip_return);\n-\n /* In cgraphbuild.c  */\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n void record_references_in_initializer (tree, bool);"}, {"sha": "909407b9a71690fe7b6ce731e5ddaa06af6d4410", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 50, "deletions": 163, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -142,96 +142,6 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n   return new_edge;\n }\n \n-/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP and the\n-   return value if SKIP_RETURN is true.  */\n-\n-tree\n-cgraph_build_function_type_skip_args (tree orig_type, bitmap args_to_skip,\n-\t\t\t\t      bool skip_return)\n-{\n-  tree new_type = NULL;\n-  tree args, new_args = NULL;\n-  tree new_reversed;\n-  int i = 0;\n-\n-  for (args = TYPE_ARG_TYPES (orig_type); args && args != void_list_node;\n-       args = TREE_CHAIN (args), i++)\n-    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n-      new_args = tree_cons (NULL_TREE, TREE_VALUE (args), new_args);\n-\n-  new_reversed = nreverse (new_args);\n-  if (args)\n-    {\n-      if (new_reversed)\n-        TREE_CHAIN (new_args) = void_list_node;\n-      else\n-\tnew_reversed = void_list_node;\n-    }\n-\n-  /* Use copy_node to preserve as much as possible from original type\n-     (debug info, attribute lists etc.)\n-     Exception is METHOD_TYPEs must have THIS argument.\n-     When we are asked to remove it, we need to build new FUNCTION_TYPE\n-     instead.  */\n-  if (TREE_CODE (orig_type) != METHOD_TYPE\n-      || !args_to_skip\n-      || !bitmap_bit_p (args_to_skip, 0))\n-    {\n-      new_type = build_distinct_type_copy (orig_type);\n-      TYPE_ARG_TYPES (new_type) = new_reversed;\n-    }\n-  else\n-    {\n-      new_type\n-        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n-\t\t\t\t\t\t\t new_reversed));\n-      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n-    }\n-\n-  if (skip_return)\n-    TREE_TYPE (new_type) = void_type_node;\n-\n-  return new_type;\n-}\n-\n-/* Build variant of function decl ORIG_DECL skipping ARGS_TO_SKIP and the\n-   return value if SKIP_RETURN is true.\n-\n-   Arguments from DECL_ARGUMENTS list can't be removed now, since they are\n-   linked by TREE_CHAIN directly.  The caller is responsible for eliminating\n-   them when they are being duplicated (i.e. copy_arguments_for_versioning).  */\n-\n-static tree\n-build_function_decl_skip_args (tree orig_decl, bitmap args_to_skip,\n-\t\t\t       bool skip_return)\n-{\n-  tree new_decl = copy_node (orig_decl);\n-  tree new_type;\n-\n-  new_type = TREE_TYPE (orig_decl);\n-  if (prototype_p (new_type)\n-      || (skip_return && !VOID_TYPE_P (TREE_TYPE (new_type))))\n-    new_type\n-      = cgraph_build_function_type_skip_args (new_type, args_to_skip,\n-\t\t\t\t\t      skip_return);\n-  TREE_TYPE (new_decl) = new_type;\n-\n-  /* For declarations setting DECL_VINDEX (i.e. methods)\n-     we expect first argument to be THIS pointer.   */\n-  if (args_to_skip && bitmap_bit_p (args_to_skip, 0))\n-    DECL_VINDEX (new_decl) = NULL_TREE;\n-\n-  /* When signature changes, we need to clear builtin info.  */\n-  if (fndecl_built_in_p (new_decl)\n-      && args_to_skip\n-      && !bitmap_empty_p (args_to_skip))\n-    set_decl_built_in_function (new_decl, NOT_BUILT_IN, 0);\n-  /* The FE might have information and assumptions about the other\n-     arguments.  */\n-  DECL_LANG_SPECIFIC (new_decl) = NULL;\n-  return new_decl;\n-}\n-\n /* Set flags of NEW_NODE and its decl.  NEW_NODE is a newly created private\n    clone or its thunk.  */\n \n@@ -281,35 +191,21 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n       return cs->caller;\n \n   tree new_decl;\n-  if (!node->clone.args_to_skip)\n-    new_decl = copy_node (thunk->decl);\n-  else\n+  if (node->clone.param_adjustments)\n     {\n       /* We do not need to duplicate this_adjusting thunks if we have removed\n \t this.  */\n       if (thunk->thunk.this_adjusting\n-\t  && bitmap_bit_p (node->clone.args_to_skip, 0))\n+\t  && !node->clone.param_adjustments->first_param_intact_p ())\n \treturn node;\n \n-      new_decl = build_function_decl_skip_args (thunk->decl,\n-\t\t\t\t\t\tnode->clone.args_to_skip,\n-\t\t\t\t\t\tfalse);\n-    }\n-\n-  tree *link = &DECL_ARGUMENTS (new_decl);\n-  int i = 0;\n-  for (tree pd = DECL_ARGUMENTS (thunk->decl); pd; pd = DECL_CHAIN (pd), i++)\n-    {\n-      if (!node->clone.args_to_skip\n-\t  || !bitmap_bit_p (node->clone.args_to_skip, i))\n-\t{\n-\t  tree nd = copy_node (pd);\n-\t  DECL_CONTEXT (nd) = new_decl;\n-\t  *link = nd;\n-\t  link = &DECL_CHAIN (nd);\n-\t}\n+      new_decl = copy_node (thunk->decl);\n+      ipa_param_body_adjustments body_adj (node->clone.param_adjustments,\n+\t\t\t\t\t   new_decl);\n+      body_adj.modify_formal_parameters ();\n     }\n-  *link = NULL_TREE;\n+  else\n+    new_decl = copy_node (thunk->decl);\n \n   gcc_checking_assert (!DECL_STRUCT_FUNCTION (new_decl));\n   gcc_checking_assert (!DECL_INITIAL (new_decl));\n@@ -331,8 +227,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk->thunk = thunk->thunk;\n   new_thunk->unique_name = in_lto_p;\n   new_thunk->former_clone_of = thunk->decl;\n-  new_thunk->clone.args_to_skip = node->clone.args_to_skip;\n-  new_thunk->clone.combined_args_to_skip = node->clone.combined_args_to_skip;\n+  new_thunk->clone.param_adjustments = node->clone.param_adjustments;\n \n   cgraph_edge *e = new_thunk->create_edge (node, NULL, new_thunk->count);\n   symtab->call_edge_duplication_hooks (thunk->callees, e);\n@@ -415,15 +310,20 @@ dump_callgraph_transformation (const cgraph_node *original,\n    If the new node is being inlined into another one, NEW_INLINED_TO should be\n    the outline function the new one is (even indirectly) inlined to.  All hooks\n    will see this in node's global.inlined_to, when invoked.  Can be NULL if the\n-   node is not inlined.  */\n+   node is not inlined.\n+\n+   If PARAM_ADJUSTMENTS is non-NULL, the parameter manipulation information\n+   will be overwritten by the new structure.  Otherwise the new node will\n+   share parameter manipulation information with the original node.  */\n \n cgraph_node *\n cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n \t\t\t   bool update_original,\n \t\t\t   vec<cgraph_edge *> redirect_callers,\n \t\t\t   bool call_duplication_hook,\n \t\t\t   cgraph_node *new_inlined_to,\n-\t\t\t   bitmap args_to_skip, const char *suffix)\n+\t\t\t   ipa_param_adjustments *param_adjustments,\n+\t\t\t   const char *suffix)\n {\n   cgraph_node *new_node = symtab->create_empty ();\n   cgraph_edge *e;\n@@ -467,19 +367,13 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   new_node->merged_comdat = merged_comdat;\n   new_node->thunk = thunk;\n \n+  if (param_adjustments)\n+    new_node->clone.param_adjustments = param_adjustments;\n+  else\n+    new_node->clone.param_adjustments = clone.param_adjustments;\n   new_node->clone.tree_map = NULL;\n-  new_node->clone.args_to_skip = args_to_skip;\n+  new_node->clone.performed_splits = vec_safe_copy (clone.performed_splits);\n   new_node->split_part = split_part;\n-  if (!args_to_skip)\n-    new_node->clone.combined_args_to_skip = clone.combined_args_to_skip;\n-  else if (clone.combined_args_to_skip)\n-    {\n-      new_node->clone.combined_args_to_skip = BITMAP_GGC_ALLOC ();\n-      bitmap_ior (new_node->clone.combined_args_to_skip,\n-\t\t  clone.combined_args_to_skip, args_to_skip);\n-    }\n-  else\n-    new_node->clone.combined_args_to_skip = args_to_skip;\n \n   FOR_EACH_VEC_ELT (redirect_callers, i, e)\n     {\n@@ -621,8 +515,8 @@ clone_function_name (tree decl, const char *suffix)\n cgraph_node *\n cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n \t\t\t\t   vec<ipa_replace_map *, va_gc> *tree_map,\n-\t\t\t\t   bitmap args_to_skip, const char * suffix,\n-\t\t\t\t   unsigned num_suffix)\n+\t\t\t\t   ipa_param_adjustments *param_adjustments,\n+\t\t\t\t   const char * suffix, unsigned num_suffix)\n {\n   tree old_decl = decl;\n   cgraph_node *new_node = NULL;\n@@ -632,13 +526,16 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n   char *name;\n \n   gcc_checking_assert (local.versionable);\n-  gcc_assert (local.can_change_signature || !args_to_skip);\n+  /* TODO: It would be nice if we could recognize that param_adjustments do not\n+     actually perform any changes, but at the moment let's require it simply\n+     does not exist.  */\n+  gcc_assert (local.can_change_signature || !param_adjustments);\n \n   /* Make a new FUNCTION_DECL tree node */\n-  if (!args_to_skip)\n+  if (!param_adjustments)\n     new_decl = copy_node (old_decl);\n   else\n-    new_decl = build_function_decl_skip_args (old_decl, args_to_skip, false);\n+    new_decl = param_adjustments->adjust_decl (old_decl);\n \n   /* These pointers represent function body and will be populated only when clone\n      is materialized.  */\n@@ -662,7 +559,8 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n   SET_DECL_RTL (new_decl, NULL);\n \n   new_node = create_clone (new_decl, count, false,\n-\t\t\t   redirect_callers, false, NULL, args_to_skip, suffix);\n+\t\t\t   redirect_callers, false, NULL, param_adjustments,\n+\t\t\t   suffix);\n \n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n@@ -1021,9 +919,10 @@ cgraph_node::create_version_clone (tree new_decl,\n cgraph_node *\n cgraph_node::create_version_clone_with_body\n   (vec<cgraph_edge *> redirect_callers,\n-   vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,\n-   bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,\n-   const char *suffix, tree target_attributes)\n+   vec<ipa_replace_map *, va_gc> *tree_map,\n+   ipa_param_adjustments *param_adjustments,\n+   bitmap bbs_to_copy, basic_block new_entry_block, const char *suffix,\n+   tree target_attributes)\n {\n   tree old_decl = decl;\n   cgraph_node *new_version_node = NULL;\n@@ -1032,14 +931,16 @@ cgraph_node::create_version_clone_with_body\n   if (!tree_versionable_function_p (old_decl))\n     return NULL;\n \n-  gcc_assert (local.can_change_signature || !args_to_skip);\n+  /* TODO: Restore an assert that we do not change signature if\n+     local.can_change_signature is false.  We cannot just check that\n+     param_adjustments is NULL because unfortunately ipa-split removes return\n+     values from such functions.  */\n \n   /* Make a new FUNCTION_DECL tree node for the new version. */\n-  if (!args_to_skip && !skip_return)\n-    new_decl = copy_node (old_decl);\n+  if (param_adjustments)\n+    new_decl = param_adjustments->adjust_decl (old_decl);\n   else\n-    new_decl\n-      = build_function_decl_skip_args (old_decl, args_to_skip, skip_return);\n+    new_decl = copy_node (old_decl);\n \n   /* Generate a new name for the new version. */\n   DECL_NAME (new_decl) = clone_function_name_numbered (old_decl, suffix);\n@@ -1076,8 +977,8 @@ cgraph_node::create_version_clone_with_body\n     new_version_node->ipa_transforms_to_apply\n       = ipa_transforms_to_apply.copy ();\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip,\n-\t\t\t    skip_return, bbs_to_copy, new_entry_block);\n+  tree_function_versioning (old_decl, new_decl, tree_map, param_adjustments,\n+\t\t\t    false, bbs_to_copy, new_entry_block);\n \n   /* Update the new version's properties.\n      Make The new version visible only within this translation unit.  Make sure\n@@ -1117,9 +1018,8 @@ cgraph_materialize_clone (cgraph_node *node)\n     node->former_clone_of = node->clone_of->former_clone_of;\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (node->clone_of->decl, node->decl,\n-  \t\t\t    node->clone.tree_map, true,\n-\t\t\t    node->clone.args_to_skip, false,\n-\t\t\t    NULL, NULL);\n+\t\t\t    node->clone.tree_map, node->clone.param_adjustments,\n+\t\t\t    true, NULL, NULL);\n   if (symtab->dump_file)\n     {\n       dump_function_to_file (node->clone_of->decl, symtab->dump_file,\n@@ -1194,28 +1094,15 @@ symbol_table::materialize_all_clones (void)\n \t\t\t    {\n \t\t\t      ipa_replace_map *replace_info;\n \t\t\t      replace_info = (*node->clone.tree_map)[i];\n-\t\t\t      print_generic_expr (symtab->dump_file,\n-\t\t\t\t\t\t  replace_info->old_tree);\n-\t\t\t      fprintf (symtab->dump_file, \" -> \");\n+\t\t\t      fprintf (symtab->dump_file, \"%i -> \",\n+\t\t\t\t       (*node->clone.tree_map)[i]->parm_num);\n \t\t\t      print_generic_expr (symtab->dump_file,\n \t\t\t\t\t\t  replace_info->new_tree);\n-\t\t\t      fprintf (symtab->dump_file, \"%s%s;\",\n-\t\t\t      \t       replace_info->replace_p ? \"(replace)\":\"\",\n-\t\t\t\t       replace_info->ref_p ? \"(ref)\":\"\");\n \t\t\t    }\n \t\t\t  fprintf (symtab->dump_file, \"\\n\");\n \t\t\t}\n-\t\t      if (node->clone.args_to_skip)\n-\t\t\t{\n-\t\t\t  fprintf (symtab->dump_file, \"   args_to_skip: \");\n-\t\t\t  dump_bitmap (symtab->dump_file,\n-\t\t\t\t       node->clone.args_to_skip);\n-\t\t\t}\n-\t\t      if (node->clone.args_to_skip)\n-\t\t\t{\n-\t\t\t  fprintf (symtab->dump_file, \"   combined_args_to_skip:\");\n-\t\t\t  dump_bitmap (symtab->dump_file, node->clone.combined_args_to_skip);\n-\t\t\t}\n+\t\t      if (node->clone.param_adjustments)\n+\t\t\tnode->clone.param_adjustments->dump (symtab->dump_file);\n \t\t    }\n \t\t  cgraph_materialize_clone (node);\n \t\t  stabilized = false;"}, {"sha": "257de226326f23f34f95ebaeadcbc9b66f7b19b3", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -141,6 +141,7 @@ struct gomp_teams;\n struct symtab_node;\n   struct cgraph_node;\n   struct varpool_node;\n+struct cgraph_edge;\n \n union section;\n typedef union section section;"}, {"sha": "7c9daafe35d1c9b5aa0df09cca6bf9ab23067d5f", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -156,7 +156,6 @@ DEBUG_COUNTER (df_byte_scan)\n DEBUG_COUNTER (dse)\n DEBUG_COUNTER (dse1)\n DEBUG_COUNTER (dse2)\n-DEBUG_COUNTER (eipa_sra)\n DEBUG_COUNTER (gcse2_delete)\n DEBUG_COUNTER (global_alloc_at_func)\n DEBUG_COUNTER (global_alloc_at_reg)\n@@ -168,6 +167,8 @@ DEBUG_COUNTER (if_after_combine)\n DEBUG_COUNTER (if_after_reload)\n DEBUG_COUNTER (if_conversion)\n DEBUG_COUNTER (if_conversion_tree)\n+DEBUG_COUNTER (ipa_sra_params)\n+DEBUG_COUNTER (ipa_sra_retvalues)\n DEBUG_COUNTER (ira_move)\n DEBUG_COUNTER (local_alloc_for_sched)\n DEBUG_COUNTER (merged_ipa_icf)"}, {"sha": "83016a5a8eebcd5b044a088061afd1f58eed03e1", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -11870,6 +11870,11 @@ parameters only when their cumulative size is less or equal to\n @option{ipa-sra-ptr-growth-factor} times the size of the original\n pointer parameter.\n \n+@item ipa-sra-max-replacements\n+Maximum pieces of an aggregate that IPA-SRA tracks.  As a\n+consequence, it is also the maximum number of replacements of a formal\n+parameter.\n+\n @item sra-max-scalarization-size-Ospeed\n @itemx sra-max-scalarization-size-Osize\n The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to"}, {"sha": "b4fb74e097e2c9f80aa38f8e150be593200d9bdf", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 137, "deletions": 35, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1184,7 +1184,10 @@ initialize_node_lattices (struct cgraph_node *node)\n   int i;\n \n   gcc_checking_assert (node->has_gimple_body_p ());\n-  if (node->local.local)\n+\n+  if (!ipa_get_param_count (info))\n+    disable = true;\n+  else if (node->local.local)\n     {\n       int caller_count = 0;\n       node->call_for_symbol_thunks_and_aliases (count_callers, &caller_count,\n@@ -1206,32 +1209,72 @@ initialize_node_lattices (struct cgraph_node *node)\n \tdisable = true;\n     }\n \n-  for (i = 0; i < ipa_get_param_count (info); i++)\n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && !node->alias && !node->thunk.thunk_p)\n     {\n-      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      plats->m_value_range.init ();\n+      fprintf (dump_file, \"Initializing lattices of %s\\n\",\n+\t       node->dump_name ());\n+      if (disable || variable)\n+\tfprintf (dump_file, \"  Marking all lattices as %s\\n\",\n+\t\t disable ? \"BOTTOM\" : \"VARIABLE\");\n     }\n \n-  if (disable || variable)\n+  auto_vec<bool, 16> surviving_params;\n+  bool pre_modified = false;\n+  if (!disable && node->clone.param_adjustments)\n     {\n-      for (i = 0; i < ipa_get_param_count (info); i++)\n+      /* At the moment all IPA optimizations should use the number of\n+\t parameters of the prevailing decl as the m_always_copy_start.\n+\t Handling any other value would complicate the code below, so for the\n+\t time bing let's only assert it is so.  */\n+      gcc_assert ((node->clone.param_adjustments->m_always_copy_start\n+\t\t   == ipa_get_param_count (info))\n+\t\t  || node->clone.param_adjustments->m_always_copy_start < 0);\n+\n+      pre_modified = true;\n+      node->clone.param_adjustments->get_surviving_params (&surviving_params);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS)\n+\t  && !node->alias && !node->thunk.thunk_p)\n \t{\n-\t  class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-\t  if (disable)\n+\t  bool first = true;\n+\t  for (int j = 0; j < ipa_get_param_count (info); j++)\n \t    {\n-\t      plats->itself.set_to_bottom ();\n-\t      plats->ctxlat.set_to_bottom ();\n-\t      set_agg_lats_to_bottom (plats);\n-\t      plats->bits_lattice.set_to_bottom ();\n-\t      plats->m_value_range.set_to_bottom ();\n+\t      if (j < (int) surviving_params.length ()\n+\t\t  && surviving_params[j])\n+\t\tcontinue;\n+\t      if (first)\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"  The following parameters are dead on arrival:\");\n+\t\t  first = false;\n+\t\t}\n+\t      fprintf (dump_file, \" %u\", j);\n \t    }\n-\t  else\n+\t  if (!first)\n+\t      fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  for (i = 0; i < ipa_get_param_count (info); i++)\n+    {\n+      ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      if (disable\n+\t  || (pre_modified && (surviving_params.length () <= (unsigned) i\n+\t\t\t       || !surviving_params[i])))\n+\t{\n+\t  plats->itself.set_to_bottom ();\n+\t  plats->ctxlat.set_to_bottom ();\n+\t  set_agg_lats_to_bottom (plats);\n+\t  plats->bits_lattice.set_to_bottom ();\n+\t  plats->m_value_range.set_to_bottom ();\n+\t}\n+      else\n+\t{\n+\t  plats->m_value_range.init ();\n+\t  if (variable)\n \t    set_all_contains_variable (plats);\n \t}\n-      if (dump_file && (dump_flags & TDF_DETAILS)\n-\t  && !node->alias && !node->thunk.thunk_p)\n-\tfprintf (dump_file, \"Marking all lattices of %s as %s\\n\",\n-\t\t node->dump_name (), disable ? \"BOTTOM\" : \"VARIABLE\");\n     }\n \n   for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n@@ -3654,12 +3697,8 @@ get_replacement_map (class ipa_node_params *info, tree value, int parm_num)\n       print_generic_expr (dump_file, value);\n       fprintf (dump_file, \"\\n\");\n     }\n-  replace_map->old_tree = NULL;\n   replace_map->parm_num = parm_num;\n   replace_map->new_tree = value;\n-  replace_map->replace_p = true;\n-  replace_map->ref_p = false;\n-\n   return replace_map;\n }\n \n@@ -3797,6 +3836,35 @@ update_specialized_profile (struct cgraph_node *new_node,\n     dump_profile_updates (orig_node, new_node);\n }\n \n+/* Return true if we would like to remove a parameter from NODE when cloning it\n+   with KNOWN_CSTS scalar constants.  */\n+\n+static bool\n+want_remove_some_param_p (cgraph_node *node, vec<tree> known_csts)\n+{\n+  auto_vec<bool, 16> surviving;\n+  bool filled_vec = false;\n+  ipa_node_params *info = IPA_NODE_REF (node);\n+  int i, count = ipa_get_param_count (info);\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      if (!known_csts[i] && ipa_is_param_used (info, i))\n+       continue;\n+\n+      if (!filled_vec)\n+       {\n+         if (!node->clone.param_adjustments)\n+           return true;\n+         node->clone.param_adjustments->get_surviving_params (&surviving);\n+         filled_vec = true;\n+       }\n+      if (surviving.length() < (unsigned) i &&  surviving[i])\n+       return true;\n+    }\n+  return false;\n+}\n+\n /* Create a specialized version of NODE with known constants in KNOWN_CSTS,\n    known contexts in KNOWN_CONTEXTS and known aggregate values in AGGVALS and\n    redirect all edges in CALLERS to it.  */\n@@ -3810,31 +3878,65 @@ create_specialized_node (struct cgraph_node *node,\n {\n   class ipa_node_params *new_info, *info = IPA_NODE_REF (node);\n   vec<ipa_replace_map *, va_gc> *replace_trees = NULL;\n+  vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n   struct ipa_agg_replacement_value *av;\n   struct cgraph_node *new_node;\n   int i, count = ipa_get_param_count (info);\n-  bitmap args_to_skip;\n-\n+  ipa_param_adjustments *old_adjustments = node->clone.param_adjustments;\n+  ipa_param_adjustments *new_adjustments;\n   gcc_assert (!info->ipcp_orig_node);\n+  gcc_assert (node->local.can_change_signature\n+\t      || !old_adjustments);\n \n-  if (node->local.can_change_signature)\n+  if (old_adjustments)\n     {\n-      args_to_skip = BITMAP_GGC_ALLOC ();\n-      for (i = 0; i < count; i++)\n+      /* At the moment all IPA optimizations should use the number of\n+\t parameters of the prevailing decl as the m_always_copy_start.\n+\t Handling any other value would complicate the code below, so for the\n+\t time bing let's only assert it is so.  */\n+      gcc_assert (old_adjustments->m_always_copy_start == count\n+\t\t  || old_adjustments->m_always_copy_start < 0);\n+      int old_adj_count = vec_safe_length (old_adjustments->m_adj_params);\n+      for (i = 0; i < old_adj_count; i++)\n \t{\n-\t  tree t = known_csts[i];\n+\t  ipa_adjusted_param *old_adj = &(*old_adjustments->m_adj_params)[i];\n+\t  if (!node->local.can_change_signature\n+\t      || old_adj->op != IPA_PARAM_OP_COPY\n+\t      || (!known_csts[old_adj->base_index]\n+\t\t  && ipa_is_param_used (info, old_adj->base_index)))\n+\t    {\n+\t      ipa_adjusted_param new_adj = *old_adj;\n \n-\t  if (t || !ipa_is_param_used (info, i))\n-\t    bitmap_set_bit (args_to_skip, i);\n+\t      new_adj.prev_clone_adjustment = true;\n+\t      new_adj.prev_clone_index = i;\n+\t      vec_safe_push (new_params, new_adj);\n+\t    }\n \t}\n+      bool skip_return = old_adjustments->m_skip_return;\n+      new_adjustments = (new (ggc_alloc <ipa_param_adjustments> ())\n+\t\t\t ipa_param_adjustments (new_params, count,\n+\t\t\t\t\t\tskip_return));\n     }\n-  else\n+  else if (node->local.can_change_signature\n+\t   && want_remove_some_param_p (node, known_csts))\n     {\n-      args_to_skip = NULL;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"      cannot change function signature\\n\");\n+      ipa_adjusted_param adj;\n+      memset (&adj, 0, sizeof (adj));\n+      adj.op = IPA_PARAM_OP_COPY;\n+      for (i = 0; i < count; i++)\n+\tif (!known_csts[i] && ipa_is_param_used (info, i))\n+\t  {\n+\t    adj.base_index = i;\n+\t    adj.prev_clone_index = i;\n+\t    vec_safe_push (new_params, adj);\n+\t  }\n+      new_adjustments = (new (ggc_alloc <ipa_param_adjustments> ())\n+\t\t\t ipa_param_adjustments (new_params, count, false));\n     }\n+  else\n+    new_adjustments = NULL;\n \n+  replace_trees = vec_safe_copy (node->clone.tree_map);\n   for (i = 0; i < count; i++)\n     {\n       tree t = known_csts[i];\n@@ -3863,7 +3965,7 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (\n \t\t\t\t node->decl)));\n   new_node = node->create_virtual_clone (callers, replace_trees,\n-\t\t\t\t\t args_to_skip, \"constprop\",\n+\t\t\t\t\t new_adjustments, \"constprop\",\n \t\t\t\t\t suffix_counter);\n   suffix_counter++;\n "}, {"sha": "a43867937bda7fe68eabd980df1327ddb4e2b731", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -616,9 +616,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \n \t  for (j = 0; vec_safe_iterate (dst->clone.tree_map, j, &r); j++)\n \t    {\n-\t      if (((!r->old_tree && r->parm_num == i)\n-\t\t   || (r->old_tree && r->old_tree == ipa_get_param (parms_info, i)))\n-\t\t   && r->replace_p && !r->ref_p)\n+\t      if (r->parm_num == i)\n \t\t{\n \t\t  known_vals[i] = r->new_tree;\n \t\t  break;"}, {"sha": "d2299601edd606d1b94f1f3792c9d91124f71f85", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -617,8 +617,7 @@ save_inline_function_body (struct cgraph_node *node)\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (node->decl, first_clone->decl,\n-\t\t\t    NULL, true, NULL, false,\n-\t\t\t    NULL, NULL);\n+\t\t\t    NULL, NULL, true, NULL, NULL);\n \n   /* The function will be short lived and removed after we inline all the clones,\n      but make it internal so we won't confuse ourself.  */"}, {"sha": "7f52e9c250650233feb06094521f85131fe59656", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 1620, "deletions": 473, "changes": 2093, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -22,395 +22,770 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n-#include \"rtl.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"ssa.h\"\n #include \"cgraph.h\"\n #include \"fold-const.h\"\n+#include \"tree-eh.h\"\n #include \"stor-layout.h\"\n #include \"gimplify.h\"\n #include \"gimple-iterator.h\"\n #include \"gimplify-me.h\"\n+#include \"tree-cfg.h\"\n #include \"tree-dfa.h\"\n #include \"ipa-param-manipulation.h\"\n #include \"print-tree.h\"\n #include \"gimple-pretty-print.h\"\n #include \"builtins.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-inline.h\"\n \n-/* Return a heap allocated vector containing formal parameters of FNDECL.  */\n \n-vec<tree>\n-ipa_get_vector_of_formal_parms (tree fndecl)\n+/* Actual prefixes of different newly synthetized parameters.  Keep in sync\n+   with IPA_PARAM_PREFIX_* defines.  */\n+\n+static const char *ipa_param_prefixes[IPA_PARAM_PREFIX_COUNT]\n+  = {\"SYNTH\",\n+     \"ISRA\",\n+     \"simd\",\n+     \"mask\"};\n+\n+/* Names of parameters for dumping.  Keep in sync with enum ipa_parm_op.  */\n+\n+static const char *ipa_param_op_names[IPA_PARAM_PREFIX_COUNT]\n+  = {\"IPA_PARAM_OP_UNDEFINED\",\n+     \"IPA_PARAM_OP_COPY\",\n+     \"IPA_PARAM_OP_NEW\",\n+     \"IPA_PARAM_OP_SPLIT\"};\n+\n+/* Fill an empty vector ARGS with PARM_DECLs representing formal parameters of\n+   FNDECL.  The function should not be called during LTO WPA phase except for\n+   thunks (or functions with bodies streamed in). */\n+\n+void\n+push_function_arg_decls (vec<tree> *args, tree fndecl)\n {\n-  vec<tree> args;\n   int count;\n   tree parm;\n \n-  gcc_assert (!flag_wpa);\n+  /* Safety check that we do not attempt to use the function in WPA, except\n+     when the function is a thunk and then we have DECL_ARGUMENTS or when we\n+     have already explicitely loaded its body.  */\n+  gcc_assert (!flag_wpa\n+\t      || DECL_ARGUMENTS (fndecl)\n+\t      || gimple_has_body_p (fndecl));\n   count = 0;\n   for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n     count++;\n \n-  args.create (count);\n+  args->reserve_exact (count);\n   for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n-    args.quick_push (parm);\n-\n-  return args;\n+    args->quick_push (parm);\n }\n \n-/* Return a heap allocated vector containing types of formal parameters of\n+/* Fill an empty vector TYPES with trees representing formal parameters of\n    function type FNTYPE.  */\n \n-vec<tree>\n-ipa_get_vector_of_formal_parm_types (tree fntype)\n+void\n+push_function_arg_types (vec<tree> *types, tree fntype)\n {\n-  vec<tree> types;\n   int count = 0;\n   tree t;\n \n   for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n     count++;\n \n-  types.create (count);\n+  types->reserve_exact (count);\n   for (t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n-    types.quick_push (TREE_VALUE (t));\n-\n-  return types;\n+    types->quick_push (TREE_VALUE (t));\n }\n \n-/* Modify the function declaration FNDECL and its type according to the plan in\n-   ADJUSTMENTS.  It also sets base fields of individual adjustments structures\n-   to reflect the actual parameters being modified which are determined by the\n-   base_index field.  */\n+/* Dump the adjustments in the vector ADJUSTMENTS to dump_file in a human\n+   friendly way, assuming they are meant to be applied to FNDECL.  */\n \n void\n-ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments)\n-{\n-  vec<tree> oparms = ipa_get_vector_of_formal_parms (fndecl);\n-  tree orig_type = TREE_TYPE (fndecl);\n-  tree old_arg_types = TYPE_ARG_TYPES (orig_type);\n-\n-  /* The following test is an ugly hack, some functions simply don't have any\n-     arguments in their type.  This is probably a bug but well... */\n-  bool care_for_types = (old_arg_types != NULL_TREE);\n-  bool last_parm_void;\n-  vec<tree> otypes;\n-  if (care_for_types)\n-    {\n-      last_parm_void = (TREE_VALUE (tree_last (old_arg_types))\n-\t\t\t== void_type_node);\n-      otypes = ipa_get_vector_of_formal_parm_types (orig_type);\n-      if (last_parm_void)\n-\tgcc_assert (oparms.length () + 1 == otypes.length ());\n-      else\n-\tgcc_assert (oparms.length () == otypes.length ());\n-    }\n-  else\n-    {\n-      last_parm_void = false;\n-      otypes.create (0);\n-    }\n+ipa_dump_adjusted_parameters (FILE *f,\n+\t\t\t      vec<ipa_adjusted_param, va_gc> *adj_params)\n+{\n+  unsigned i, len = vec_safe_length (adj_params);\n+  bool first = true;\n \n-  int len = adjustments.length ();\n-  tree *link = &DECL_ARGUMENTS (fndecl);\n-  tree new_arg_types = NULL;\n-  for (int i = 0; i < len; i++)\n+  fprintf (f, \"    IPA adjusted parameters: \");\n+  for (i = 0; i < len; i++)\n     {\n-      struct ipa_parm_adjustment *adj;\n-      gcc_assert (link);\n+      struct ipa_adjusted_param *apm;\n+      apm = &(*adj_params)[i];\n \n-      adj = &adjustments[i];\n-      tree parm;\n-      if (adj->op == IPA_PARM_OP_NEW)\n-\tparm = NULL;\n+      if (!first)\n+\tfprintf (f, \"                             \");\n       else\n-\tparm = oparms[adj->base_index];\n-      adj->base = parm;\n+\tfirst = false;\n \n-      if (adj->op == IPA_PARM_OP_COPY)\n-\t{\n-\t  if (care_for_types)\n-\t    new_arg_types = tree_cons (NULL_TREE, otypes[adj->base_index],\n-\t\t\t\t       new_arg_types);\n-\t  *link = parm;\n-\t  link = &DECL_CHAIN (parm);\n-\t}\n-      else if (adj->op != IPA_PARM_OP_REMOVE)\n+      fprintf (f, \"%i. %s %s\", i, ipa_param_op_names[apm->op],\n+\t       apm->prev_clone_adjustment ? \"prev_clone_adjustment \" : \"\");\n+      switch (apm->op)\n \t{\n-\t  tree new_parm;\n-\t  tree ptype;\n-\n-\t  if (adj->by_ref)\n-\t    ptype = build_pointer_type (adj->type);\n-\t  else\n-\t    {\n-\t      ptype = adj->type;\n-\t      if (is_gimple_reg_type (ptype)\n-\t\t  && TYPE_MODE (ptype) != BLKmode)\n-\t\t{\n-\t\t  unsigned malign = GET_MODE_ALIGNMENT (TYPE_MODE (ptype));\n-\t\t  if (TYPE_ALIGN (ptype) != malign)\n-\t\t    ptype = build_aligned_type (ptype, malign);\n-\t\t}\n-\t    }\n+\tcase IPA_PARAM_OP_UNDEFINED:\n+\t  break;\n \n-\t  if (care_for_types)\n-\t    new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n+\tcase IPA_PARAM_OP_COPY:\n+\t  fprintf (f, \", base_index: %u\", apm->base_index);\n+\t  fprintf (f, \", prev_clone_index: %u\", apm->prev_clone_index);\n+\t  break;\n \n-\t  new_parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE,\n-\t\t\t\t ptype);\n-\t  const char *prefix = adj->arg_prefix ? adj->arg_prefix : \"SYNTH\";\n-\t  DECL_NAME (new_parm) = create_tmp_var_name (prefix);\n-\t  DECL_ARTIFICIAL (new_parm) = 1;\n-\t  DECL_ARG_TYPE (new_parm) = ptype;\n-\t  DECL_CONTEXT (new_parm) = fndecl;\n-\t  TREE_USED (new_parm) = 1;\n-\t  DECL_IGNORED_P (new_parm) = 1;\n-\t  layout_decl (new_parm, 0);\n+\tcase IPA_PARAM_OP_SPLIT:\n+\t  fprintf (f, \", offset: %u\", apm->unit_offset);\n+\t  /* fall-through */\n+\tcase IPA_PARAM_OP_NEW:\n+\t  fprintf (f, \", base_index: %u\", apm->base_index);\n+\t  fprintf (f, \", prev_clone_index: %u\", apm->prev_clone_index);\n+\t  print_node_brief (f, \", type: \", apm->type, 0);\n+\t  print_node_brief (f, \", alias type: \", apm->alias_ptr_type, 0);\n+\t  fprintf (f, \" prefix: %s\",\n+\t\t   ipa_param_prefixes[apm->param_prefix_index]);\n+\t  if (apm->reverse)\n+\t    fprintf (f, \", reverse-sso\");\n+\t  break;\n+\t}\n+      fprintf (f, \"\\n\");\n+    }\n+}\n \n-\t  if (adj->op == IPA_PARM_OP_NEW)\n-\t    adj->base = NULL;\n-\t  else\n-\t    adj->base = parm;\n-\t  adj->new_decl = new_parm;\n+/* Fill NEW_TYPES with types of a function after its current OTYPES have been\n+   modified as described in ADJ_PARAMS.  When USE_PREV_INDICES is true, use\n+   prev_clone_index from ADJ_PARAMS as opposed to base_index when the parameter\n+   is false.  */\n \n-\t  *link = new_parm;\n-\t  link = &DECL_CHAIN (new_parm);\n+static void\n+fill_vector_of_new_param_types (vec<tree> *new_types, vec<tree> *otypes,\n+\t\t\t\tvec<ipa_adjusted_param, va_gc> *adj_params,\n+\t\t\t\tbool use_prev_indices)\n+{\n+  unsigned adj_len = vec_safe_length (adj_params);\n+  new_types->reserve_exact (adj_len);\n+  for (unsigned i = 0; i < adj_len ; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*adj_params)[i];\n+      if (apm->op == IPA_PARAM_OP_COPY)\n+\t{\n+\t  unsigned index\n+\t    = use_prev_indices ? apm->prev_clone_index : apm->base_index;\n+\t  /* The following needs to be handled gracefully because of type\n+\t     mismatches.  This happens with LTO but apparently also in Fortran\n+\t     with -fcoarray=lib -O2 -lcaf_single -latomic.  */\n+\t  if (index >= otypes->length ())\n+\t    continue;\n+\t  new_types->quick_push ((*otypes)[index]);\n \t}\n+      else if (apm->op == IPA_PARAM_OP_NEW\n+\t       || apm->op == IPA_PARAM_OP_SPLIT)\n+\t{\n+\t  tree ntype = apm->type;\n+\t  if (is_gimple_reg_type (ntype)\n+\t      && TYPE_MODE (ntype) != BLKmode)\n+\t    {\n+\t      unsigned malign = GET_MODE_ALIGNMENT (TYPE_MODE (ntype));\n+\t      if (TYPE_ALIGN (ntype) != malign)\n+\t\tntype = build_aligned_type (ntype, malign);\n+\t    }\n+\t  new_types->quick_push (ntype);\n+\t}\n+      else\n+\tgcc_unreachable ();\n     }\n+}\n \n-  *link = NULL_TREE;\n+/* Build and return a function type just like ORIG_TYPE but with parameter\n+   types given in NEW_PARAM_TYPES - which can be NULL if, but only if,\n+   ORIG_TYPE itself has NULL TREE_ARG_TYPEs.  If METHOD2FUNC is true, also make\n+   it a FUNCTION_TYPE instead of FUNCTION_TYPE.  */\n \n-  tree new_reversed = NULL;\n-  if (care_for_types)\n+static tree\n+build_adjusted_function_type (tree orig_type, vec<tree> *new_param_types,\n+\t\t\t      bool method2func, bool skip_return)\n+{\n+  tree new_arg_types = NULL;\n+  if (TYPE_ARG_TYPES (orig_type))\n     {\n-      new_reversed = nreverse (new_arg_types);\n+      gcc_checking_assert (new_param_types);\n+      bool last_parm_void = (TREE_VALUE (tree_last (TYPE_ARG_TYPES (orig_type)))\n+\t\t\t     == void_type_node);\n+      unsigned len = new_param_types->length ();\n+      for (unsigned i = 0; i < len; i++)\n+\tnew_arg_types = tree_cons (NULL_TREE, (*new_param_types)[i],\n+\t\t\t\t   new_arg_types);\n+\n+      tree new_reversed = nreverse (new_arg_types);\n       if (last_parm_void)\n \t{\n \t  if (new_reversed)\n \t    TREE_CHAIN (new_arg_types) = void_list_node;\n \t  else\n \t    new_reversed = void_list_node;\n \t}\n+      new_arg_types = new_reversed;\n     }\n \n-  /* Use copy_node to preserve as much as possible from original type\n-     (debug info, attribute lists etc.)\n-     Exception is METHOD_TYPEs must have THIS argument.\n-     When we are asked to remove it, we need to build new FUNCTION_TYPE\n-     instead.  */\n+  /* Use build_distinct_type_copy to preserve as much as possible from original\n+     type (debug info, attribute lists etc.).  The one exception is\n+     METHOD_TYPEs which must have THIS argument and when we are asked to remove\n+     it, we need to build new FUNCTION_TYPE instead.  */\n   tree new_type = NULL;\n-  if (TREE_CODE (orig_type) != METHOD_TYPE\n-       || (adjustments[0].op == IPA_PARM_OP_COPY\n-\t  && adjustments[0].base_index == 0))\n+  if (method2func)\n+    {\n+      tree ret_type;\n+      if (skip_return)\n+\tret_type = void_type_node;\n+      else\n+\tret_type = TREE_TYPE (orig_type);\n+\n+      new_type\n+\t= build_distinct_type_copy (build_function_type (ret_type,\n+\t\t\t\t\t\t\t new_arg_types));\n+      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n+    }\n+  else\n     {\n       new_type = build_distinct_type_copy (orig_type);\n-      TYPE_ARG_TYPES (new_type) = new_reversed;\n+      TYPE_ARG_TYPES (new_type) = new_arg_types;\n+      if (skip_return)\n+\tTREE_TYPE (new_type) = void_type_node;\n+    }\n+\n+  return new_type;\n+}\n+\n+/* Return the maximum index in any IPA_PARAM_OP_COPY adjustment or -1 if there\n+   is none.  */\n+\n+int\n+ipa_param_adjustments::get_max_base_index ()\n+{\n+  unsigned adj_len = vec_safe_length (m_adj_params);\n+  int max_index = -1;\n+  for (unsigned i = 0; i < adj_len ; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n+      if (apm->op == IPA_PARAM_OP_COPY\n+\t  && max_index < apm->base_index)\n+\tmax_index = apm->base_index;\n+    }\n+  return max_index;\n+}\n+\n+\n+/* Fill SURVIVING_PARAMS with an array of bools where each one says whether a\n+   parameter that originally was at that position still survives in the given\n+   clone or is removed/replaced.  If the final array is smaller than an index\n+   of an original parameter, that parameter also did not survive.  That a\n+   parameter survives does not mean it has the same index as before.  */\n+\n+void\n+ipa_param_adjustments::get_surviving_params (vec<bool> *surviving_params)\n+{\n+  unsigned adj_len = vec_safe_length (m_adj_params);\n+  int max_index = get_max_base_index ();\n+\n+  if (max_index < 0)\n+    return;\n+  surviving_params->reserve_exact (max_index + 1);\n+  surviving_params->quick_grow_cleared (max_index + 1);\n+  for (unsigned i = 0; i < adj_len ; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n+      if (apm->op == IPA_PARAM_OP_COPY)\n+\t(*surviving_params)[apm->base_index] = true;\n+    }\n+}\n+\n+/* Fill NEW_INDICES with new indices of each surviving parameter or -1 for\n+   those which do not survive.  Any parameter outside of lenght of the vector\n+   does not survive.  There is currently no support for a parameter to be\n+   copied to two distinct new parameters.  */\n+\n+void\n+ipa_param_adjustments::get_updated_indices (vec<int> *new_indices)\n+{\n+  unsigned adj_len = vec_safe_length (m_adj_params);\n+  int max_index = get_max_base_index ();\n+\n+  if (max_index < 0)\n+    return;\n+  unsigned res_len = max_index + 1;\n+  new_indices->reserve_exact (res_len);\n+  for (unsigned i = 0; i < res_len ; i++)\n+    new_indices->quick_push (-1);\n+  for (unsigned i = 0; i < adj_len ; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n+      if (apm->op == IPA_PARAM_OP_COPY)\n+\t(*new_indices)[apm->base_index] = i;\n+    }\n+}\n+\n+/* Return true if the first parameter (assuming there was one) survives the\n+   transformation intact and remains the first one.  */\n+\n+bool\n+ipa_param_adjustments::first_param_intact_p ()\n+{\n+  return (!vec_safe_is_empty (m_adj_params)\n+\t  && (*m_adj_params)[0].op == IPA_PARAM_OP_COPY\n+\t  && (*m_adj_params)[0].base_index == 0);\n+}\n+\n+/* Return true if we have to change what has formerly been a method into a\n+   function.  */\n+\n+bool\n+ipa_param_adjustments::method2func_p (tree orig_type)\n+{\n+  return ((TREE_CODE (orig_type) == METHOD_TYPE) && !first_param_intact_p ());\n+}\n+\n+/* Given function type OLD_TYPE, return a new type derived from it after\n+   performing all atored modifications.  TYPE_ORIGINAL_P should be true when\n+   OLD_TYPE refers to the type before any IPA transformations, as opposed to a\n+   type that can be an intermediate one in between various IPA\n+   transformations.  */\n+\n+tree\n+ipa_param_adjustments::build_new_function_type (tree old_type,\n+\t\t\t\t\t\tbool type_original_p)\n+{\n+  auto_vec<tree,16> new_param_types, *new_param_types_p;\n+  if (prototype_p (old_type))\n+    {\n+      auto_vec<tree, 16> otypes;\n+      push_function_arg_types (&otypes, old_type);\n+      fill_vector_of_new_param_types (&new_param_types, &otypes, m_adj_params,\n+\t\t\t\t      !type_original_p);\n+      new_param_types_p = &new_param_types;\n     }\n   else\n+    new_param_types_p = NULL;\n+\n+  return build_adjusted_function_type (old_type, new_param_types_p,\n+\t\t\t\t       method2func_p (old_type), m_skip_return);\n+}\n+\n+/* Build variant of function decl ORIG_DECL which has no return value if\n+   M_SKIP_RETURN is true and, if ORIG_DECL's types or parameters is known, has\n+   this type adjusted as indicated in M_ADJ_PARAMS. Arguments from\n+   DECL_ARGUMENTS list are not processed now, since they are linked by\n+   TREE_CHAIN directly and not accessible in LTO during WPA.  The caller is\n+   responsible for eliminating them when clones are properly materialized.  */\n+\n+tree\n+ipa_param_adjustments::adjust_decl (tree orig_decl)\n+{\n+  tree new_decl = copy_node (orig_decl);\n+  tree orig_type = TREE_TYPE (orig_decl);\n+  if (prototype_p (orig_type)\n+      || (m_skip_return && !VOID_TYPE_P (TREE_TYPE (orig_type))))\n     {\n-      new_type\n-        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n-\t\t\t\t\t\t\t new_reversed));\n-      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n-      DECL_VINDEX (fndecl) = NULL_TREE;\n+      tree new_type = build_new_function_type (orig_type, false);\n+      TREE_TYPE (new_decl) = new_type;\n     }\n+  if (method2func_p (orig_type))\n+    DECL_VINDEX (new_decl) = NULL_TREE;\n \n   /* When signature changes, we need to clear builtin info.  */\n-  if (fndecl_built_in_p (fndecl))\n-    set_decl_built_in_function (fndecl, NOT_BUILT_IN, 0);\n+  if (fndecl_built_in_p (new_decl))\n+    set_decl_built_in_function (new_decl, NOT_BUILT_IN, 0);\n+\n+  DECL_VIRTUAL_P (new_decl) = 0;\n+  DECL_LANG_SPECIFIC (new_decl) = NULL;\n \n-  TREE_TYPE (fndecl) = new_type;\n-  DECL_VIRTUAL_P (fndecl) = 0;\n-  DECL_LANG_SPECIFIC (fndecl) = NULL;\n-  otypes.release ();\n-  oparms.release ();\n+  return new_decl;\n }\n \n-/* Modify actual arguments of a function call CS as indicated in ADJUSTMENTS.\n-   If this is a directly recursive call, CS must be NULL.  Otherwise it must\n-   contain the corresponding call graph edge.  */\n+/* Wrapper around get_base_ref_and_offset for cases interesting for IPA-SRA\n+   transformations.  Return true if EXPR has an interesting form and fill in\n+   *BASE_P and *UNIT_OFFSET_P with the appropriate info.  */\n \n-void\n-ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n-\t\t\t   ipa_parm_adjustment_vec adjustments)\n-{\n-  struct cgraph_node *current_node = cgraph_node::get (current_function_decl);\n-  vec<tree> vargs;\n-  vec<tree, va_gc> **debug_args = NULL;\n-  gcall *new_stmt;\n-  gimple_stmt_iterator gsi, prev_gsi;\n-  tree callee_decl;\n-  int i, len;\n+static bool\n+isra_get_ref_base_and_offset (tree expr, tree *base_p, unsigned *unit_offset_p)\n+{\n+  HOST_WIDE_INT offset, size;\n+  bool reverse;\n+  tree base\n+    = get_ref_base_and_extent_hwi (expr, &offset, &size, &reverse);\n+  if (!base || size < 0)\n+    return false;\n \n-  len = adjustments.length ();\n-  vargs.create (len);\n-  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n-  current_node->remove_stmt_references (stmt);\n+  if ((offset % BITS_PER_UNIT) != 0)\n+    return false;\n \n-  gsi = gsi_for_stmt (stmt);\n-  prev_gsi = gsi;\n-  gsi_prev (&prev_gsi);\n-  for (i = 0; i < len; i++)\n+  if (TREE_CODE (base) == MEM_REF)\n     {\n-      struct ipa_parm_adjustment *adj;\n+      poly_int64 plmoff = mem_ref_offset (base).force_shwi ();\n+      HOST_WIDE_INT moff;\n+      bool is_cst = plmoff.is_constant (&moff);\n+      if (!is_cst)\n+\treturn false;\n+      offset += moff * BITS_PER_UNIT;\n+      base = TREE_OPERAND (base, 0);\n+    }\n \n-      adj = &adjustments[i];\n+  if (offset < 0 || (offset / BITS_PER_UNIT) > UINT_MAX)\n+    return false;\n \n-      if (adj->op == IPA_PARM_OP_COPY)\n-\t{\n-\t  tree arg = gimple_call_arg (stmt, adj->base_index);\n+  *base_p = base;\n+  *unit_offset_p = offset / BITS_PER_UNIT;\n+  return true;\n+}\n \n-\t  vargs.quick_push (arg);\n+/* Return true if EXPR describes a transitive split (i.e. one that happened for\n+   both the caller and the callee) as recorded in PERFORMED_SPLITS.  In that\n+   case, store index of the respective record in PERFORMED_SPLITS into\n+   *SM_IDX_P and the unit offset from all handled components in EXPR into\n+   *UNIT_OFFSET_P.  */\n+\n+static bool\n+transitive_split_p (vec<ipa_param_performed_split, va_gc> *performed_splits,\n+\t\t    tree expr, unsigned *sm_idx_p, unsigned *unit_offset_p)\n+{\n+  tree base;\n+  if (!isra_get_ref_base_and_offset (expr, &base, unit_offset_p))\n+    return false;\n+\n+  if (TREE_CODE (base) == SSA_NAME)\n+    {\n+      base = SSA_NAME_VAR (base);\n+      if (!base)\n+\treturn false;\n+    }\n+\n+  unsigned len = vec_safe_length (performed_splits);\n+  for (unsigned i = 0 ; i < len; i++)\n+    {\n+      ipa_param_performed_split *sm = &(*performed_splits)[i];\n+      if (sm->dummy_decl == base)\n+\t{\n+\t  *sm_idx_p = i;\n+\t  return true;\n \t}\n-      else if (adj->op != IPA_PARM_OP_REMOVE)\n+    }\n+  return false;\n+}\n+\n+/* Structure to hold declarations representing transitive IPA-SRA splits.  In\n+   essence, if we need to pass UNIT_OFFSET of a parameter which originally has\n+   number BASE_INDEX, we should pass down REPL.  */\n+\n+struct transitive_split_map\n+{\n+  tree repl;\n+  unsigned base_index;\n+  unsigned unit_offset;\n+};\n+\n+/* If call STMT contains any parameters representing transitive splits as\n+   described by PERFORMED_SPLITS, return the number of extra parameters that\n+   were addded during clone materialization and fill in INDEX_MAP with adjusted\n+   indices of corresponding original parameters and TRANS_MAP with description\n+   of all transitive replacement descriptions.  Otherwise return zero. */\n+\n+static unsigned\n+init_transitive_splits (vec<ipa_param_performed_split, va_gc> *performed_splits,\n+\t\t\tgcall *stmt, vec <unsigned> *index_map,\n+\t\t\tauto_vec <transitive_split_map> *trans_map)\n+{\n+  unsigned phony_arguments = 0;\n+  unsigned stmt_idx = 0, base_index = 0;\n+  unsigned nargs = gimple_call_num_args (stmt);\n+  while (stmt_idx < nargs)\n+    {\n+      unsigned unit_offset_delta;\n+      tree base_arg = gimple_call_arg (stmt, stmt_idx);\n+\n+      if (phony_arguments > 0)\n+\tindex_map->safe_push (stmt_idx);\n+\n+      unsigned sm_idx;\n+      stmt_idx++;\n+      if (transitive_split_p (performed_splits, base_arg, &sm_idx,\n+\t\t\t      &unit_offset_delta))\n \t{\n-\t  tree expr, base, off;\n-\t  location_t loc;\n-\t  unsigned int deref_align = 0;\n-\t  bool deref_base = false;\n-\n-\t  /* We create a new parameter out of the value of the old one, we can\n-\t     do the following kind of transformations:\n-\n-\t     - A scalar passed by reference is converted to a scalar passed by\n-               value.  (adj->by_ref is false and the type of the original\n-               actual argument is a pointer to a scalar).\n-\n-             - A part of an aggregate is passed instead of the whole aggregate.\n-               The part can be passed either by value or by reference, this is\n-               determined by value of adj->by_ref.  Moreover, the code below\n-               handles both situations when the original aggregate is passed by\n-               value (its type is not a pointer) and when it is passed by\n-               reference (it is a pointer to an aggregate).\n-\n-\t     When the new argument is passed by reference (adj->by_ref is true)\n-\t     it must be a part of an aggregate and therefore we form it by\n-\t     simply taking the address of a reference inside the original\n-\t     aggregate.  */\n-\n-\t  poly_int64 byte_offset = exact_div (adj->offset, BITS_PER_UNIT);\n-\t  base = gimple_call_arg (stmt, adj->base_index);\n-\t  loc = gimple_location (stmt);\n-\n-\t  if (TREE_CODE (base) != ADDR_EXPR\n-\t      && POINTER_TYPE_P (TREE_TYPE (base)))\n-\t    off = build_int_cst (adj->alias_ptr_type, byte_offset);\n-\t  else\n+\t  if (phony_arguments == 0)\n+\t    /* We have optimistically avoided constructing index_map do far but\n+\t       now it is clear it will be necessary, so let's create the easy\n+\t       bit we skipped until now.  */\n+\t    for (unsigned k = 0; k < stmt_idx; k++)\n+\t      index_map->safe_push (k);\n+\n+\t  tree dummy = (*performed_splits)[sm_idx].dummy_decl;\n+\t  for (unsigned j = sm_idx; j < performed_splits->length (); j++)\n \t    {\n-\t      poly_int64 base_offset;\n-\t      tree prev_base;\n-\t      bool addrof;\n+\t      ipa_param_performed_split *caller_split\n+\t\t= &(*performed_splits)[j];\n+\t      if (caller_split->dummy_decl != dummy)\n+\t\tbreak;\n \n-\t      if (TREE_CODE (base) == ADDR_EXPR)\n-\t\t{\n-\t\t  base = TREE_OPERAND (base, 0);\n-\t\t  addrof = true;\n-\t\t}\n-\t      else\n-\t\taddrof = false;\n-\t      prev_base = base;\n-\t      base = get_addr_base_and_unit_offset (base, &base_offset);\n-\t      /* Aggregate arguments can have non-invariant addresses.  */\n-\t      if (!base)\n-\t\t{\n-\t\t  base = build_fold_addr_expr (prev_base);\n-\t\t  off = build_int_cst (adj->alias_ptr_type, byte_offset);\n-\t\t}\n-\t      else if (TREE_CODE (base) == MEM_REF)\n-\t\t{\n-\t\t  if (!addrof)\n-\t\t    {\n-\t\t      deref_base = true;\n-\t\t      deref_align = TYPE_ALIGN (TREE_TYPE (base));\n-\t\t    }\n-\t\t  off = build_int_cst (adj->alias_ptr_type,\n-\t\t\t\t       base_offset + byte_offset);\n-\t\t  off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1),\n-\t\t\t\t\t off);\n-\t\t  base = TREE_OPERAND (base, 0);\n-\t\t}\n-\t      else\n+\t      tree arg = gimple_call_arg (stmt, stmt_idx);\n+\t      struct transitive_split_map tsm;\n+\t      tsm.repl = arg;\n+\t      tsm.base_index = base_index;\n+\t      if (caller_split->unit_offset >= unit_offset_delta)\n \t\t{\n-\t\t  off = build_int_cst (adj->alias_ptr_type,\n-\t\t\t\t       base_offset + byte_offset);\n-\t\t  base = build_fold_addr_expr (base);\n+\t\t  tsm.unit_offset\n+\t\t    = (caller_split->unit_offset - unit_offset_delta);\n+\t\t  trans_map->safe_push (tsm);\n \t\t}\n+\n+\t      phony_arguments++;\n+\t      stmt_idx++;\n \t    }\n+\t}\n+      base_index++;\n+    }\n+  return phony_arguments;\n+}\n \n-\t  if (!adj->by_ref)\n+/* Modify actual arguments of a function call in statement STMT, assuming it\n+   calls CALLEE_DECL.  CALLER_ADJ must be the description of parameter\n+   adjustments of the caller or NULL if there are none.  Return the new\n+   statement that replaced the old one.  When invoked, cfun and\n+   current_function_decl have to be set to the caller.  */\n+\n+gcall *\n+ipa_param_adjustments::modify_call (gcall *stmt,\n+\t\t\t\t    vec<ipa_param_performed_split,\n+\t\t\t\t        va_gc> *performed_splits,\n+\t\t\t\t    tree callee_decl, bool update_references)\n+{\n+  unsigned len = vec_safe_length (m_adj_params);\n+  auto_vec<tree, 16> vargs (len);\n+  tree old_decl = gimple_call_fndecl (stmt);\n+  unsigned old_nargs = gimple_call_num_args (stmt);\n+  auto_vec<bool, 16> kept (old_nargs);\n+  kept.quick_grow_cleared (old_nargs);\n+\n+  auto_vec <unsigned, 16> index_map;\n+  auto_vec <transitive_split_map> trans_map;\n+  bool transitive_remapping = false;\n+\n+  if (performed_splits)\n+    {\n+      unsigned removed = init_transitive_splits (performed_splits,\n+\t\t\t\t\t\t stmt, &index_map, &trans_map);\n+      if (removed > 0)\n+\t{\n+\t  transitive_remapping = true;\n+\t  old_nargs -= removed;\n+\t}\n+    }\n+\n+  cgraph_node *current_node = cgraph_node::get (current_function_decl);\n+  if (update_references)\n+    current_node->remove_stmt_references (stmt);\n+\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gimple_stmt_iterator prev_gsi = gsi;\n+  gsi_prev (&prev_gsi);\n+  for (unsigned i = 0; i < len; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n+      if (apm->op == IPA_PARAM_OP_COPY)\n+\t{\n+\t  unsigned index = apm->base_index;\n+\t  if (index >= old_nargs)\n+\t    /* Can happen if the original call has argument mismatch,\n+\t       ignore.  */\n+\t    continue;\n+\t  if (transitive_remapping)\n+\t    index = index_map[apm->base_index];\n+\n+\t  tree arg = gimple_call_arg (stmt, index);\n+\n+\t  vargs.quick_push (arg);\n+\t  kept[index] = true;\n+\t  continue;\n+\t}\n+\n+      /* At the moment the only user of IPA_PARAM_OP_NEW modifies calls itself.\n+\t If we ever want to support it during WPA IPA stage, we'll need a\n+\t mechanism to call into the IPA passes that introduced them.  Currently\n+\t we simply mandate that IPA infrastructure understands all argument\n+\t modifications.  Remember, edge redirection/modification is done only\n+\t once, not in steps for each pass modifying the callee like clone\n+\t materialization.  */\n+      gcc_assert (apm->op == IPA_PARAM_OP_SPLIT);\n+\n+      /* We have to handle transitive changes differently using the maps we\n+\t have created before.  So look into them first.  */\n+      tree repl = NULL_TREE;\n+      for (unsigned j = 0; j < trans_map.length (); j++)\n+\tif (trans_map[j].base_index == apm->base_index\n+\t    && trans_map[j].unit_offset == apm->unit_offset)\n+\t  {\n+\t    repl = trans_map[j].repl;\n+\t    break;\n+\t  }\n+      if (repl)\n+\t{\n+\t  vargs.quick_push (repl);\n+\t  continue;\n+\t}\n+\n+      unsigned index = apm->base_index;\n+      if (index >= old_nargs)\n+\t/* Can happen if the original call has argument mismatch, ignore.  */\n+\tcontinue;\n+      if (transitive_remapping)\n+\tindex = index_map[apm->base_index];\n+      tree base = gimple_call_arg (stmt, index);\n+\n+      /* We create a new parameter out of the value of the old one, we can\n+\t do the following kind of transformations:\n+\n+\t - A scalar passed by reference, potentially as a part of a larger\n+\t aggregate, is converted to a scalar passed by value.\n+\n+\t - A part of an aggregate is passed instead of the whole aggregate.  */\n+\n+      location_t loc = gimple_location (stmt);\n+      tree off;\n+      bool deref_base = false;\n+      unsigned int deref_align = 0;\n+      if (TREE_CODE (base) != ADDR_EXPR\n+\t  && POINTER_TYPE_P (TREE_TYPE (base)))\n+\toff = build_int_cst (apm->alias_ptr_type, apm->unit_offset);\n+      else\n+\t{\n+\t  bool addrof;\n+\t  if (TREE_CODE (base) == ADDR_EXPR)\n \t    {\n-\t      tree type = adj->type;\n-\t      unsigned int align;\n-\t      unsigned HOST_WIDE_INT misalign;\n+\t      base = TREE_OPERAND (base, 0);\n+\t      addrof = true;\n+\t    }\n+\t  else\n+\t    addrof = false;\n \n-\t      if (deref_base)\n-\t\t{\n-\t\t  align = deref_align;\n-\t\t  misalign = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  get_pointer_alignment_1 (base, &align, &misalign);\n-\t\t  if (TYPE_ALIGN (type) > align)\n-\t\t    align = TYPE_ALIGN (type);\n-\t\t}\n-\t      misalign += (offset_int::from (wi::to_wide (off),\n-\t\t\t\t\t     SIGNED).to_short_addr ()\n-\t\t\t   * BITS_PER_UNIT);\n-\t      misalign = misalign & (align - 1);\n-\t      if (misalign != 0)\n-\t\talign = least_bit_hwi (misalign);\n-\t      if (align < TYPE_ALIGN (type))\n-\t\ttype = build_aligned_type (type, align);\n-\t      base = force_gimple_operand_gsi (&gsi, base,\n-\t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n-\t      expr = fold_build2_loc (loc, MEM_REF, type, base, off);\n-\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n-\t      /* If expr is not a valid gimple call argument emit\n-\t         a load into a temporary.  */\n-\t      if (is_gimple_reg_type (TREE_TYPE (expr)))\n+\t  tree prev_base = base;\n+\t  poly_int64 base_offset;\n+\t  base = get_addr_base_and_unit_offset (base, &base_offset);\n+\n+\t  /* Aggregate arguments can have non-invariant addresses.  */\n+\t  if (!base)\n+\t    {\n+\t      base = build_fold_addr_expr (prev_base);\n+\t      off = build_int_cst (apm->alias_ptr_type, apm->unit_offset);\n+\t    }\n+\t  else if (TREE_CODE (base) == MEM_REF)\n+\t    {\n+\t      if (!addrof)\n \t\t{\n-\t\t  gimple *tem = gimple_build_assign (NULL_TREE, expr);\n-\t\t  if (gimple_in_ssa_p (cfun))\n-\t\t    {\n-\t\t      gimple_set_vuse (tem, gimple_vuse (stmt));\n-\t\t      expr = make_ssa_name (TREE_TYPE (expr), tem);\n-\t\t    }\n-\t\t  else\n-\t\t    expr = create_tmp_reg (TREE_TYPE (expr));\n-\t\t  gimple_assign_set_lhs (tem, expr);\n-\t\t  gimple_set_location (tem, loc);\n-\t\t  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);\n+\t\t  deref_base = true;\n+\t\t  deref_align = TYPE_ALIGN (TREE_TYPE (base));\n \t\t}\n+\t      off = build_int_cst (apm->alias_ptr_type,\n+\t\t\t\t   base_offset + apm->unit_offset);\n+\t      off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1),\n+\t\t\t\t     off);\n+\t      base = TREE_OPERAND (base, 0);\n \t    }\n \t  else\n \t    {\n-\t      expr = fold_build2_loc (loc, MEM_REF, adj->type, base, off);\n-\t      REF_REVERSE_STORAGE_ORDER (expr) = adj->reverse;\n-\t      expr = build_fold_addr_expr (expr);\n-\t      expr = force_gimple_operand_gsi (&gsi, expr,\n-\t\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n+\t      off = build_int_cst (apm->alias_ptr_type,\n+\t\t\t\t   base_offset + apm->unit_offset);\n+\t      base = build_fold_addr_expr (base);\n \t    }\n-\t  vargs.quick_push (expr);\n \t}\n-      if (adj->op != IPA_PARM_OP_COPY && MAY_HAVE_DEBUG_BIND_STMTS)\n+\n+      tree type = apm->type;\n+      unsigned int align;\n+      unsigned HOST_WIDE_INT misalign;\n+\n+      if (deref_base)\n \t{\n-\t  unsigned int ix;\n-\t  tree ddecl = NULL_TREE, origin = DECL_ORIGIN (adj->base), arg;\n-\t  gimple *def_temp;\n+\t  align = deref_align;\n+\t  misalign = 0;\n+\t}\n+      else\n+\t{\n+\t  get_pointer_alignment_1 (base, &align, &misalign);\n+\t  /* All users must make sure that we can be optimistic when it\n+\t     comes to alignment in this case (by inspecting the final users\n+\t     of these new parameters).  */\n+\t  if (TYPE_ALIGN (type) > align)\n+\t    align = TYPE_ALIGN (type);\n+\t}\n+      misalign\n+\t+= (offset_int::from (wi::to_wide (off), SIGNED).to_short_addr ()\n+\t    * BITS_PER_UNIT);\n+      misalign = misalign & (align - 1);\n+      if (misalign != 0)\n+\talign = least_bit_hwi (misalign);\n+      if (align < TYPE_ALIGN (type))\n+\ttype = build_aligned_type (type, align);\n+      base = force_gimple_operand_gsi (&gsi, base,\n+\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n+      tree expr = fold_build2_loc (loc, MEM_REF, type, base, off);\n+      REF_REVERSE_STORAGE_ORDER (expr) = apm->reverse;\n+      /* If expr is not a valid gimple call argument emit\n+\t a load into a temporary.  */\n+      if (is_gimple_reg_type (TREE_TYPE (expr)))\n+\t{\n+\t  gimple *tem = gimple_build_assign (NULL_TREE, expr);\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    {\n+\t      gimple_set_vuse (tem, gimple_vuse (stmt));\n+\t      expr = make_ssa_name (TREE_TYPE (expr), tem);\n+\t    }\n+\t  else\n+\t    expr = create_tmp_reg (TREE_TYPE (expr));\n+\t  gimple_assign_set_lhs (tem, expr);\n+\t  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);\n+\t}\n+      vargs.quick_push (expr);\n+    }\n+\n+  if (m_always_copy_start >= 0)\n+    for (unsigned i = m_always_copy_start; i < old_nargs; i++)\n+      vargs.safe_push (gimple_call_arg (stmt, i));\n+\n+  /* For optimized away parameters, add on the caller side\n+     before the call\n+     DEBUG D#X => parm_Y(D)\n+     stmts and associate D#X with parm in decl_debug_args_lookup\n+     vector to say for debug info that if parameter parm had been passed,\n+     it would have value parm_Y(D).  */\n+  if (MAY_HAVE_DEBUG_BIND_STMTS && old_decl && callee_decl)\n+    {\n+      vec<tree, va_gc> **debug_args = NULL;\n+      unsigned i = 0;\n+      for (tree old_parm = DECL_ARGUMENTS (old_decl);\n+\t   old_parm && i < old_nargs && ((int) i) < m_always_copy_start;\n+\t   old_parm = DECL_CHAIN (old_parm), i++)\n+\t{\n+\t  if (!is_gimple_reg (old_parm) || kept[i])\n+\t    continue;\n+\t  tree origin = DECL_ORIGIN (old_parm);\n+\t  tree arg = gimple_call_arg (stmt, i);\n \n-\t  arg = gimple_call_arg (stmt, adj->base_index);\n \t  if (!useless_type_conversion_p (TREE_TYPE (origin), TREE_TYPE (arg)))\n \t    {\n \t      if (!fold_convertible_p (TREE_TYPE (origin), arg))\n \t\tcontinue;\n-\t      arg = fold_convert_loc (gimple_location (stmt),\n-\t\t\t\t      TREE_TYPE (origin), arg);\n+\t      tree rhs1;\n+\t      if (TREE_CODE (arg) == SSA_NAME\n+\t\t  && gimple_assign_cast_p (SSA_NAME_DEF_STMT (arg))\n+\t\t  && (rhs1\n+\t\t      = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (arg)))\n+\t\t  && useless_type_conversion_p (TREE_TYPE (origin),\n+\t\t\t\t\t\tTREE_TYPE (rhs1)))\n+\t\targ = rhs1;\n+\t      else\n+\t\targ = fold_convert_loc (gimple_location (stmt),\n+\t\t\t\t\tTREE_TYPE (origin), arg);\n \t    }\n \t  if (debug_args == NULL)\n \t    debug_args = decl_debug_args_insert (callee_decl);\n+\t  unsigned int ix;\n+\t  tree ddecl = NULL_TREE;\n \t  for (ix = 0; vec_safe_iterate (*debug_args, ix, &ddecl); ix += 2)\n \t    if (ddecl == origin)\n \t      {\n@@ -427,7 +802,8 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n \t      vec_safe_push (*debug_args, origin);\n \t      vec_safe_push (*debug_args, ddecl);\n \t    }\n-\t  def_temp = gimple_build_debug_bind (ddecl, unshare_expr (arg), stmt);\n+\t  gimple *def_temp = gimple_build_debug_bind (ddecl,\n+\t\t\t\t\t\t      unshare_expr (arg), stmt);\n \t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n \t}\n     }\n@@ -438,10 +814,34 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n       print_gimple_stmt (dump_file, gsi_stmt (gsi), 0);\n     }\n \n-  new_stmt = gimple_build_call_vec (callee_decl, vargs);\n-  vargs.release ();\n-  if (gimple_call_lhs (stmt))\n-    gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n+  gcall *new_stmt = gimple_build_call_vec (callee_decl, vargs);\n+\n+  if (tree lhs = gimple_call_lhs (stmt))\n+    {\n+      if (!m_skip_return)\n+\tgimple_call_set_lhs (new_stmt, lhs);\n+      else if (TREE_CODE (lhs) == SSA_NAME)\n+\t{\n+\t  /* LHS should now by a default-def SSA.  Unfortunately default-def\n+\t     SSA_NAMEs need a backing variable (or at least some code examining\n+\t     SSAs assumes it is non-NULL).  So we either have to re-use the\n+\t     decl we have at hand or introdice a new one.  */\n+\t  tree repl = create_tmp_var (TREE_TYPE (lhs), \"removed_return\");\n+\t  repl = get_or_create_ssa_default_def (cfun, repl);\n+\t  SSA_NAME_IS_DEFAULT_DEF (repl) = true;\n+\t  imm_use_iterator ui;\n+\t  use_operand_p use_p;\n+\t  gimple *using_stmt;\n+\t  FOR_EACH_IMM_USE_STMT (using_stmt, ui, lhs)\n+\t    {\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, ui)\n+\t\t{\n+\t\t  SET_USE (use_p, repl);\n+\t\t}\n+\t      update_stmt (using_stmt);\n+\t    }\n+\t}\n+    }\n \n   gimple_set_block (new_stmt, gimple_block (stmt));\n   if (gimple_has_location (stmt))\n@@ -458,120 +858,398 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,\n       fprintf (dump_file, \"\\n\");\n     }\n   gsi_replace (&gsi, new_stmt, true);\n-  if (cs)\n-    cs->set_call_stmt (new_stmt);\n-  do\n-    {\n-      current_node->record_stmt_references (gsi_stmt (gsi));\n-      gsi_prev (&gsi);\n-    }\n-  while (gsi_stmt (gsi) != gsi_stmt (prev_gsi));\n+  if (update_references)\n+    do\n+      {\n+\tcurrent_node->record_stmt_references (gsi_stmt (gsi));\n+\tgsi_prev (&gsi);\n+      }\n+    while (gsi_stmt (gsi) != gsi_stmt (prev_gsi));\n+  return new_stmt;\n }\n \n-/* Return true iff BASE_INDEX is in ADJUSTMENTS more than once.  */\n+/* Dump information contained in the object in textual form to F.  */\n \n-static bool\n-index_in_adjustments_multiple_times_p (int base_index,\n-\t\t\t\t       ipa_parm_adjustment_vec adjustments)\n+void\n+ipa_param_adjustments::dump (FILE *f)\n {\n-  int i, len = adjustments.length ();\n-  bool one = false;\n+  fprintf (f, \"    m_always_copy_start: %i\\n\", m_always_copy_start);\n+  ipa_dump_adjusted_parameters (f, m_adj_params);\n+  if (m_skip_return)\n+    fprintf (f, \"     Will SKIP return.\\n\");\n+}\n \n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-      adj = &adjustments[i];\n+/* Dump information contained in the object in textual form to stderr.  */\n \n-      if (adj->base_index == base_index)\n-\t{\n-\t  if (one)\n-\t    return true;\n-\t  else\n-\t    one = true;\n-\t}\n-    }\n-  return false;\n+void\n+ipa_param_adjustments::debug ()\n+{\n+  dump (stderr);\n }\n \n-/* Return adjustments that should have the same effect on function parameters\n-   and call arguments as if they were first changed according to adjustments in\n-   INNER and then by adjustments in OUTER.  */\n+/* Register that REPLACEMENT should replace parameter described in APM and\n+   optionally as DUMMY to mark transitive splits accross calls.  */\n \n-ipa_parm_adjustment_vec\n-ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n-\t\t\t ipa_parm_adjustment_vec outer)\n+void\n+ipa_param_body_adjustments::register_replacement (ipa_adjusted_param *apm,\n+\t\t\t\t\t\t  tree replacement,\n+\t\t\t\t\t\t  tree dummy)\n {\n-  int i, outlen = outer.length ();\n-  int inlen = inner.length ();\n-  int removals = 0;\n-  ipa_parm_adjustment_vec adjustments, tmp;\n+  gcc_checking_assert (apm->op == IPA_PARAM_OP_SPLIT\n+\t\t       || apm->op == IPA_PARAM_OP_NEW);\n+  gcc_checking_assert (!apm->prev_clone_adjustment);\n+  ipa_param_body_replacement psr;\n+  psr.base = m_oparms[apm->prev_clone_index];\n+  psr.repl = replacement;\n+  psr.dummy = dummy;\n+  psr.unit_offset = apm->unit_offset;\n+  m_replacements.safe_push (psr);\n+}\n+\n+/* Copy or not, as appropriate given ID, a pre-existing PARM_DECL T so that\n+   it can be included in the parameters of the modified function.  */\n \n-  tmp.create (inlen);\n-  for (i = 0; i < inlen; i++)\n+static tree\n+carry_over_param (tree t, struct copy_body_data *id)\n+{\n+  tree new_parm;\n+  if (id)\n     {\n-      struct ipa_parm_adjustment *n;\n-      n = &inner[i];\n+      new_parm = remap_decl (t, id);\n+      if (TREE_CODE (new_parm) != PARM_DECL)\n+\tnew_parm = id->copy_decl (t, id);\n+    }\n+  else\n+    new_parm = t;\n+  return new_parm;\n+}\n \n-      if (n->op == IPA_PARM_OP_REMOVE)\n-\tremovals++;\n-      else\n+/* Common initialization performed by all ipa_param_body_adjustments\n+   constructors.  OLD_FNDECL is the declaration we take original arguments\n+   from, (it may be the same as M_FNDECL).  VARS, if non-NULL, is a pointer to\n+   a chained list of new local variables.  TREE_MAP is the IPA-CP produced\n+   mapping of trees to constants.\n+\n+   The function is rather long but it really onlu initializes all data members\n+   of the class.  It creates new param DECLs, finds their new types,   */\n+\n+void\n+ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n+\t\t\t\t\t\t   tree *vars,\n+\t\t\t\t\t\t   vec<ipa_replace_map *,\n+\t\t\t\t\t\t       va_gc> *tree_map)\n+{\n+  push_function_arg_decls (&m_oparms, old_fndecl);\n+  auto_vec<tree,16> otypes;\n+  if (TYPE_ARG_TYPES (TREE_TYPE (old_fndecl)) != NULL_TREE)\n+    push_function_arg_types (&otypes, TREE_TYPE (old_fndecl));\n+  else\n+    {\n+      auto_vec<tree,16> oparms;\n+      push_function_arg_decls (&oparms, old_fndecl);\n+      unsigned ocount = oparms.length ();\n+      otypes.reserve_exact (ocount);\n+      for (unsigned i = 0; i < ocount; i++)\n+\totypes.quick_push (TREE_TYPE (oparms[i]));\n+    }\n+  fill_vector_of_new_param_types (&m_new_types, &otypes, m_adj_params, true);\n+\n+  auto_vec<bool, 16> kept;\n+  kept.reserve_exact (m_oparms.length ());\n+  kept.quick_grow_cleared (m_oparms.length ());\n+  auto_vec<tree, 16> isra_dummy_decls;\n+  isra_dummy_decls.reserve_exact (m_oparms.length ());\n+  isra_dummy_decls.quick_grow_cleared (m_oparms.length ());\n+\n+  unsigned adj_len = vec_safe_length (m_adj_params);\n+  m_method2func = ((TREE_CODE (TREE_TYPE (m_fndecl)) == METHOD_TYPE)\n+\t\t   && (adj_len == 0\n+\t\t       || (*m_adj_params)[0].op != IPA_PARAM_OP_COPY\n+\t\t       || (*m_adj_params)[0].base_index != 0));\n+\n+  /* The main job of the this function is to go over the vector of adjusted\n+     parameters and create declarations or find corresponding old ones and push\n+     them to m_new_decls.  For IPA-SRA replacements it also creates\n+     corresponding m_id->dst_node->clone.performed_splits entries.  */\n+\n+  m_new_decls.reserve_exact (adj_len);\n+  for (unsigned i = 0; i < adj_len ; i++)\n+    {\n+      ipa_adjusted_param *apm = &(*m_adj_params)[i];\n+      unsigned prev_index = apm->prev_clone_index;\n+      tree new_parm;\n+      if (apm->op == IPA_PARAM_OP_COPY\n+\t  || apm->prev_clone_adjustment)\n \t{\n-\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n-\t  gcc_assert (n->op != IPA_PARM_OP_NEW);\n-\t  tmp.quick_push (*n);\n+\t  kept[prev_index] = true;\n+\t  new_parm = carry_over_param (m_oparms[prev_index], m_id);\n+\t  m_new_decls.quick_push (new_parm);\n \t}\n+      else if (apm->op == IPA_PARAM_OP_NEW\n+\t       || apm->op == IPA_PARAM_OP_SPLIT)\n+\t{\n+\t  tree new_type = m_new_types[i];\n+\t  gcc_checking_assert (new_type);\n+\t  new_parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE,\n+\t\t\t\t new_type);\n+\t  const char *prefix = ipa_param_prefixes[apm->param_prefix_index];\n+\t  DECL_NAME (new_parm) = create_tmp_var_name (prefix);\n+\t  DECL_ARTIFICIAL (new_parm) = 1;\n+\t  DECL_ARG_TYPE (new_parm) = new_type;\n+\t  DECL_CONTEXT (new_parm) = m_fndecl;\n+\t  TREE_USED (new_parm) = 1;\n+\t  DECL_IGNORED_P (new_parm) = 1;\n+\t  /* We assume all newly created arguments are not addressable.  */\n+\t  if (TREE_CODE (new_type) == COMPLEX_TYPE\n+\t      || TREE_CODE (new_type) == VECTOR_TYPE)\n+\t    DECL_GIMPLE_REG_P (new_parm) = 1;\n+\t  layout_decl (new_parm, 0);\n+\t  m_new_decls.quick_push (new_parm);\n+\n+\t  if (apm->op == IPA_PARAM_OP_SPLIT)\n+\t    {\n+\t      m_split_modifications_p = true;\n+\n+\t      if (m_id)\n+\t\t{\n+\t\t  tree dummy_decl;\n+\t\t  if (!isra_dummy_decls[prev_index])\n+\t\t    {\n+\t\t      dummy_decl = copy_decl_to_var (m_oparms[prev_index],\n+\t\t\t\t\t\t     m_id);\n+\t\t      /* Any attempt to remap this dummy in this particular\n+\t\t\t instance of clone materialization should yield\n+\t\t\t itself.  */\n+\t\t      insert_decl_map (m_id, dummy_decl, dummy_decl);\n+\n+\t\t      DECL_CHAIN (dummy_decl) = *vars;\n+\t\t      *vars = dummy_decl;\n+\t\t      isra_dummy_decls[prev_index] = dummy_decl;\n+\t\t    }\n+\t\t  else\n+\t\t    dummy_decl = isra_dummy_decls[prev_index];\n+\n+\t\t  register_replacement (apm, new_parm, dummy_decl);\n+\t\t  ipa_param_performed_split ps;\n+\t\t  ps.dummy_decl = dummy_decl;\n+\t\t  ps.unit_offset = apm->unit_offset;\n+\t\t  vec_safe_push (m_id->dst_node->clone.performed_splits, ps);\n+\t\t}\n+\t      else\n+\t\tregister_replacement (apm, new_parm);\n+\t    }\n+        }\n+      else\n+\tgcc_unreachable ();\n     }\n \n-  adjustments.create (outlen + removals);\n-  for (i = 0; i < outlen; i++)\n+\n+  /* As part of body modifications, we will also have to replace remaining uses\n+     of remaining uses of removed PARM_DECLs (which do not however use the\n+     initial value) with their VAR_DECL copies.\n+\n+     We do this differently with and without m_id.  With m_id, we rely on its\n+     mapping and create a replacement straight away.  Without it, we have our\n+     own mechanism for which we have to populate m_removed_decls vector.  Just\n+     don't mix them, that is why you should not call\n+     replace_removed_params_ssa_names or perform_cfun_body_modifications when\n+     you construct with ID not equal to NULL.  */\n+\n+  unsigned op_len = m_oparms.length ();\n+  for (unsigned i = 0; i < op_len; i++)\n+    if (!kept[i])\n+      {\n+\tif (m_id)\n+\t  {\n+\t    if (!m_id->decl_map->get (m_oparms[i]))\n+\t      {\n+\t\t/* TODO: Perhaps at least aggregate-type params could re-use\n+\t\t   their isra_dummy_decl here?  */\n+\t\ttree var = copy_decl_to_var (m_oparms[i], m_id);\n+\t\tinsert_decl_map (m_id, m_oparms[i], var);\n+\t\t/* Declare this new variable.  */\n+\t\tDECL_CHAIN (var) = *vars;\n+\t\t*vars = var;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    m_removed_decls.safe_push (m_oparms[i]);\n+\t    m_removed_map.put (m_oparms[i], m_removed_decls.length () - 1);\n+\t  }\n+      }\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  /* Finally, when generating debug info, we fill vector m_reset_debug_decls\n+    with removed parameters declarations.  We do this in order to re-map their\n+    debug bind statements and create debug decls for them.  */\n+\n+  if (tree_map)\n     {\n-      struct ipa_parm_adjustment r;\n-      struct ipa_parm_adjustment *out = &outer[i];\n-      struct ipa_parm_adjustment *in = &tmp[out->base_index];\n+      /* Do not output debuginfo for parameter declarations as if they vanished\n+\t when they were in fact replaced by a constant.  */\n+      auto_vec <int, 16> index_mapping;\n+      bool need_remap = false;\n \n-      memset (&r, 0, sizeof (r));\n-      gcc_assert (in->op != IPA_PARM_OP_REMOVE);\n-      if (out->op == IPA_PARM_OP_REMOVE)\n+      if (m_id && m_id->src_node->clone.param_adjustments)\n \t{\n-\t  if (!index_in_adjustments_multiple_times_p (in->base_index, tmp))\n-\t    {\n-\t      r.op = IPA_PARM_OP_REMOVE;\n-\t      adjustments.quick_push (r);\n-\t    }\n-\t  continue;\n+\t  ipa_param_adjustments *prev_adjustments\n+\t    = m_id->src_node->clone.param_adjustments;\n+\t  prev_adjustments->get_updated_indices (&index_mapping);\n+\t  need_remap = true;\n \t}\n-      else\n+\n+      for (unsigned i = 0; i < tree_map->length (); i++)\n \t{\n-\t  /* FIXME: Handling of new arguments are not implemented yet.  */\n-\t  gcc_assert (out->op != IPA_PARM_OP_NEW);\n+\t  int parm_num = (*tree_map)[i]->parm_num;\n+\t  gcc_assert (parm_num >= 0);\n+\t  if (need_remap)\n+\t    parm_num = index_mapping[parm_num];\n+\t  kept[parm_num] = true;\n \t}\n+    }\n+\n+  for (unsigned i = 0; i < op_len; i++)\n+    if (!kept[i] && is_gimple_reg (m_oparms[i]))\n+      m_reset_debug_decls.safe_push (m_oparms[i]);\n+}\n \n-      r.base_index = in->base_index;\n-      r.type = out->type;\n+/* Constructor of ipa_param_body_adjustments from a simple list of\n+   modifications to parameters listed in ADJ_PARAMS which will prepare ground\n+   for modification of parameters of fndecl.  Return value of the function will\n+   not be removed and the object will assume it does not run as a part of\n+   tree-function_versioning.  */\n+\n+ipa_param_body_adjustments\n+::ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n+\t\t\t      tree fndecl)\n+  : m_adj_params (adj_params), m_adjustments (NULL), m_reset_debug_decls (),\n+    m_split_modifications_p (false), m_fndecl (fndecl), m_id (NULL),\n+    m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n+    m_removed_decls (), m_removed_map (), m_method2func (false)\n+{\n+  common_initialization (fndecl, NULL, NULL);\n+}\n \n-      /* FIXME:  Create nonlocal value too.  */\n+/* Constructor of ipa_param_body_adjustments from ipa_param_adjustments in\n+   ADJUSTMENTS which will prepare ground for modification of parameters of\n+   fndecl.  The object will assume it does not run as a part of\n+   tree-function_versioning.  */\n+\n+ipa_param_body_adjustments\n+::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n+\t\t\t      tree fndecl)\n+  : m_adj_params (adjustments->m_adj_params), m_adjustments (adjustments),\n+    m_reset_debug_decls (), m_split_modifications_p (false), m_fndecl (fndecl),\n+    m_id (NULL), m_oparms (), m_new_decls (), m_new_types (),\n+    m_replacements (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n+{\n+  common_initialization (fndecl, NULL, NULL);\n+}\n \n-      if (in->op == IPA_PARM_OP_COPY && out->op == IPA_PARM_OP_COPY)\n-\tr.op = IPA_PARM_OP_COPY;\n-      else if (in->op == IPA_PARM_OP_COPY)\n-\tr.offset = out->offset;\n-      else if (out->op == IPA_PARM_OP_COPY)\n-\tr.offset = in->offset;\n-      else\n-\tr.offset = in->offset + out->offset;\n-      adjustments.quick_push (r);\n+/* Constructor of ipa_param_body_adjustments which sets it up as a part of\n+   running tree_function_versioning.  Planned modifications to the function are\n+   in ADJUSTMENTS.  FNDECL designates the new function clone which is being\n+   modified.  OLD_FNDECL is the function of which FNDECL is a clone (and which\n+   at the time of invocation still share DECL_ARGUMENTS).  ID is the\n+   copy_body_data structure driving the wholy body copying process.  VARS is a\n+   pointer to the head of the list of new local variables, TREE_MAP is the map\n+   that drives tree substitution in the cloning process.  */\n+\n+ipa_param_body_adjustments\n+::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n+\t\t\t      tree fndecl, tree old_fndecl,\n+\t\t\t      copy_body_data *id, tree *vars,\n+\t\t\t      vec<ipa_replace_map *, va_gc> *tree_map)\n+  : m_adj_params (adjustments->m_adj_params), m_adjustments (adjustments),\n+    m_reset_debug_decls (), m_split_modifications_p (false), m_fndecl (fndecl),\n+    m_id (id), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n+    m_removed_decls (), m_removed_map (), m_method2func (false)\n+{\n+  common_initialization (old_fndecl, vars, tree_map);\n+}\n+\n+/* Chain new param decls up and return them.  */\n+\n+tree\n+ipa_param_body_adjustments::get_new_param_chain ()\n+{\n+  tree result;\n+  tree *link = &result;\n+\n+  unsigned len = vec_safe_length (m_adj_params);\n+  for (unsigned i = 0; i < len; i++)\n+    {\n+      tree new_decl = m_new_decls[i];\n+      *link = new_decl;\n+      link = &DECL_CHAIN (new_decl);\n     }\n+  *link = NULL_TREE;\n+  return result;\n+}\n+\n+/* Modify the function parameters FNDECL and its type according to the plan in\n+   ADJUSTMENTS.  This function needs to be called when the decl has not already\n+   been processed with ipa_param_adjustments::adjust_decl, otherwise just\n+   seting DECL_ARGUMENTS to whatever get_new_param_chain will do is enough.  */\n+\n+void\n+ipa_param_body_adjustments::modify_formal_parameters ()\n+{\n+  tree orig_type = TREE_TYPE (m_fndecl);\n+  DECL_ARGUMENTS (m_fndecl) = get_new_param_chain ();\n+\n+  /* When signature changes, we need to clear builtin info.  */\n+  if (fndecl_built_in_p (m_fndecl))\n+    set_decl_built_in_function (m_fndecl, NOT_BUILT_IN, 0);\n+\n+  /* At this point, removing return value is only implemented when going\n+     through tree_function_versioning, not when modifying function body\n+     directly.  */\n+  gcc_assert (!m_adjustments || !m_adjustments->m_skip_return);\n+  tree new_type = build_adjusted_function_type (orig_type, &m_new_types,\n+\t\t\t\t\t\tm_method2func, false);\n+\n+  TREE_TYPE (m_fndecl) = new_type;\n+  DECL_VIRTUAL_P (m_fndecl) = 0;\n+  DECL_LANG_SPECIFIC (m_fndecl) = NULL;\n+  if (m_method2func)\n+    DECL_VINDEX (m_fndecl) = NULL_TREE;\n+}\n \n-  for (i = 0; i < inlen; i++)\n+/* Given BASE and UNIT_OFFSET, find the corresponding record among replacement\n+   structures.  */\n+\n+ipa_param_body_replacement *\n+ipa_param_body_adjustments::lookup_replacement_1 (tree base,\n+\t\t\t\t\t\t  unsigned unit_offset)\n+{\n+  unsigned int len = m_replacements.length ();\n+  for (unsigned i = 0; i < len; i++)\n     {\n-      struct ipa_parm_adjustment *n = &inner[i];\n+      ipa_param_body_replacement *pbr = &m_replacements[i];\n \n-      if (n->op == IPA_PARM_OP_REMOVE)\n-\tadjustments.quick_push (*n);\n+      if (pbr->base == base\n+\t  && (pbr->unit_offset == unit_offset))\n+\treturn pbr;\n     }\n+  return NULL;\n+}\n \n-  tmp.release ();\n-  return adjustments;\n+/* Given BASE and UNIT_OFFSET, find the corresponding replacement expression\n+   and return it, assuming it is known it does not hold value by reference or\n+   in reverse storage order.  */\n+\n+tree\n+ipa_param_body_adjustments::lookup_replacement (tree base, unsigned unit_offset)\n+{\n+  ipa_param_body_replacement *pbr = lookup_replacement_1 (base, unit_offset);\n+  if (!pbr)\n+    return NULL;\n+  return pbr->repl;\n }\n \n /* If T is an SSA_NAME, return NULL if it is not a default def or\n@@ -592,165 +1270,634 @@ get_ssa_base_param (tree t, bool ignore_default_def)\n   return t;\n }\n \n-/* Given an expression, return an adjustment entry specifying the\n-   transformation to be done on EXPR.  If no suitable adjustment entry\n-   was found, returns NULL.\n+/* Given an expression, return the structure describing how it should be\n+   replaced if it accesses a part of a split parameter or NULL otherwise.\n \n-   If IGNORE_DEFAULT_DEF is set, consider SSA_NAMEs which are not a\n-   default def, otherwise bail on them.\n+   Do not free the result, it will be deallocated when the object is destroyed.\n \n-   If CONVERT is non-NULL, this function will set *CONVERT if the\n-   expression provided is a component reference.  ADJUSTMENTS is the\n-   adjustments vector.  */\n+   If IGNORE_DEFAULT_DEF is cleared, consider only SSA_NAMEs of PARM_DECLs\n+   which are default definitions, if set, consider all SSA_NAMEs of\n+   PARM_DECLs.  */\n \n-ipa_parm_adjustment *\n-ipa_get_adjustment_candidate (tree **expr, bool *convert,\n-\t\t\t      ipa_parm_adjustment_vec adjustments,\n-\t\t\t      bool ignore_default_def)\n+ipa_param_body_replacement *\n+ipa_param_body_adjustments::get_expr_replacement (tree expr,\n+\t\t\t\t\t\t  bool ignore_default_def)\n {\n-  if (TREE_CODE (**expr) == BIT_FIELD_REF\n-      || TREE_CODE (**expr) == IMAGPART_EXPR\n-      || TREE_CODE (**expr) == REALPART_EXPR)\n-    {\n-      *expr = &TREE_OPERAND (**expr, 0);\n-      if (convert)\n-\t*convert = true;\n-    }\n+  tree base;\n+  unsigned unit_offset;\n \n-  poly_int64 offset, size, max_size;\n-  bool reverse;\n-  tree base\n-    = get_ref_base_and_extent (**expr, &offset, &size, &max_size, &reverse);\n-  if (!base || !known_size_p (size) || !known_size_p (max_size))\n+  if (!isra_get_ref_base_and_offset (expr, &base, &unit_offset))\n     return NULL;\n \n-  if (TREE_CODE (base) == MEM_REF)\n-    {\n-      offset += mem_ref_offset (base).force_shwi () * BITS_PER_UNIT;\n-      base = TREE_OPERAND (base, 0);\n-    }\n-\n   base = get_ssa_base_param (base, ignore_default_def);\n   if (!base || TREE_CODE (base) != PARM_DECL)\n     return NULL;\n+  return lookup_replacement_1 (base, unit_offset);\n+}\n \n-  struct ipa_parm_adjustment *cand = NULL;\n-  unsigned int len = adjustments.length ();\n-  for (unsigned i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj = &adjustments[i];\n+/* Given OLD_DECL, which is a PARM_DECL of a parameter that is being removed\n+   (which includes it being split or replaced), return a new variable that\n+   should be used for any SSA names that will remain in the function that\n+   previously belonged to OLD_DECL.  */\n \n-      if (adj->base == base\n-\t  && (known_eq (adj->offset, offset) || adj->op == IPA_PARM_OP_REMOVE))\n-\t{\n-\t  cand = adj;\n-\t  break;\n-\t}\n+tree\n+ipa_param_body_adjustments::get_replacement_ssa_base (tree old_decl)\n+{\n+  unsigned *idx = m_removed_map.get (old_decl);\n+  if (!idx)\n+    return NULL;\n+\n+  tree repl;\n+  if (TREE_CODE (m_removed_decls[*idx]) == PARM_DECL)\n+    {\n+      gcc_assert (m_removed_decls[*idx] == old_decl);\n+      repl = copy_var_decl (old_decl, DECL_NAME (old_decl),\n+\t\t\t    TREE_TYPE (old_decl));\n+      m_removed_decls[*idx] = repl;\n     }\n+  else\n+    repl = m_removed_decls[*idx];\n+  return repl;\n+}\n+\n+/* If OLD_NAME, which is being defined by statement STMT, is an SSA_NAME of a\n+   parameter which is to be removed because its value is not used, create a new\n+   SSA_NAME relating to a replacement VAR_DECL, replace all uses of the\n+   original with it and return it.  If there is no need to re-map, return NULL.\n+   ADJUSTMENTS is a pointer to a vector of IPA-SRA adjustments.  */\n+\n+tree\n+ipa_param_body_adjustments::replace_removed_params_ssa_names (tree old_name,\n+\t\t\t\t\t\t\t      gimple *stmt)\n+{\n+  gcc_assert (!m_id);\n+  if (TREE_CODE (old_name) != SSA_NAME)\n+    return NULL;\n+\n+  tree decl = SSA_NAME_VAR (old_name);\n+  if (decl == NULL_TREE\n+      || TREE_CODE (decl) != PARM_DECL)\n+    return NULL;\n \n-  if (!cand || cand->op == IPA_PARM_OP_COPY || cand->op == IPA_PARM_OP_REMOVE)\n+  tree repl = get_replacement_ssa_base (decl);\n+  if (!repl)\n     return NULL;\n-  return cand;\n+\n+  tree new_name = make_ssa_name (repl, stmt);\n+  SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name)\n+    = SSA_NAME_OCCURS_IN_ABNORMAL_PHI (old_name);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"replacing an SSA name of a removed param \");\n+      print_generic_expr (dump_file, old_name);\n+      fprintf (dump_file, \" with \");\n+      print_generic_expr (dump_file, new_name);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  replace_uses_by (old_name, new_name);\n+  return new_name;\n }\n \n-/* If the expression *EXPR should be replaced by a reduction of a parameter, do\n-   so.  ADJUSTMENTS is a pointer to a vector of adjustments.  CONVERT\n-   specifies whether the function should care about type incompatibility the\n-   current and new expressions.  If it is false, the function will leave\n-   incompatibility issues to the caller.  Return true iff the expression\n-   was modified. */\n+/* If the expression *EXPR_P should be replaced, do so.  CONVERT specifies\n+   whether the function should care about type incompatibility of the current\n+   and new expressions.  If it is false, the function will leave\n+   incompatibility issues to the caller - note that when the function\n+   encounters a BIT_FIELD_REF, IMAGPART_EXPR or REALPART_EXPR, it will modify\n+   their bases instead of the expressions themselves and then also performs any\n+   necessary conversions.  */\n \n bool\n-ipa_modify_expr (tree *expr, bool convert,\n-\t\t ipa_parm_adjustment_vec adjustments)\n+ipa_param_body_adjustments::modify_expression (tree *expr_p, bool convert)\n {\n-  struct ipa_parm_adjustment *cand\n-    = ipa_get_adjustment_candidate (&expr, &convert, adjustments, false);\n-  if (!cand)\n-    return false;\n+  tree expr = *expr_p;\n \n-  tree src;\n-  if (cand->by_ref)\n+  if (TREE_CODE (expr) == BIT_FIELD_REF\n+      || TREE_CODE (expr) == IMAGPART_EXPR\n+      || TREE_CODE (expr) == REALPART_EXPR)\n     {\n-      src = build_simple_mem_ref (cand->new_decl);\n-      REF_REVERSE_STORAGE_ORDER (src) = cand->reverse;\n+      expr_p = &TREE_OPERAND (expr, 0);\n+      expr = *expr_p;\n+      convert = true;\n     }\n-  else\n-    src = cand->new_decl;\n \n+  ipa_param_body_replacement *pbr = get_expr_replacement (expr, false);\n+  if (!pbr)\n+    return false;\n+\n+  tree repl = pbr->repl;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"About to replace expr \");\n-      print_generic_expr (dump_file, *expr);\n+      print_generic_expr (dump_file, expr);\n       fprintf (dump_file, \" with \");\n-      print_generic_expr (dump_file, src);\n+      print_generic_expr (dump_file, repl);\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (convert && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n+  if (convert && !useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t\t     TREE_TYPE (repl)))\n     {\n-      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n-      *expr = vce;\n+      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expr), repl);\n+      *expr_p = vce;\n     }\n   else\n-    *expr = src;\n+    *expr_p = repl;\n   return true;\n }\n \n-/* Dump the adjustments in the vector ADJUSTMENTS to dump_file in a human\n-   friendly way, assuming they are meant to be applied to FNDECL.  */\n+/* If the assignment statement STMT contains any expressions that need to\n+   replaced with a different one as noted by ADJUSTMENTS, do so.  Handle any\n+   potential type incompatibilities.  If any conversion sttements have to be\n+   pre-pended to STMT, they will be added to EXTRA_STMTS.  Return true iff the\n+   statement was modified.  */\n \n-void\n-ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n-\t\t\t    tree fndecl)\n+bool\n+ipa_param_body_adjustments::modify_assignment (gimple *stmt,\n+\t\t\t\t\t       gimple_seq *extra_stmts)\n {\n-  int i, len = adjustments.length ();\n-  bool first = true;\n-  vec<tree> parms = ipa_get_vector_of_formal_parms (fndecl);\n+  tree *lhs_p, *rhs_p;\n+  bool any;\n \n-  fprintf (file, \"IPA param adjustments: \");\n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-      adj = &adjustments[i];\n+  if (!gimple_assign_single_p (stmt))\n+    return false;\n \n-      if (!first)\n-\tfprintf (file, \"                 \");\n+  rhs_p = gimple_assign_rhs1_ptr (stmt);\n+  lhs_p = gimple_assign_lhs_ptr (stmt);\n+\n+  any = modify_expression (lhs_p, false);\n+  any |= modify_expression (rhs_p, false);\n+  if (any\n+      && !useless_type_conversion_p (TREE_TYPE (*lhs_p), TREE_TYPE (*rhs_p)))\n+    {\n+      if (TREE_CODE (*rhs_p) == CONSTRUCTOR)\n+\t{\n+\t  /* V_C_Es of constructors can cause trouble (PR 42714).  */\n+\t  if (is_gimple_reg_type (TREE_TYPE (*lhs_p)))\n+\t    *rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));\n+\t  else\n+\t    *rhs_p = build_constructor (TREE_TYPE (*lhs_p),\n+\t\t\t\t\tNULL);\n+\t}\n       else\n-\tfirst = false;\n+\t{\n+\t  tree new_rhs = fold_build1_loc (gimple_location (stmt),\n+\t\t\t\t\t  VIEW_CONVERT_EXPR, TREE_TYPE (*lhs_p),\n+\t\t\t\t\t  *rhs_p);\n+\t  tree tmp = force_gimple_operand (new_rhs, extra_stmts, true,\n+\t\t\t\t\t   NULL_TREE);\n+\t  gimple_assign_set_rhs1 (stmt, tmp);\n+\t}\n+      return true;\n+    }\n+\n+  return any;\n+}\n+\n+/* Data passed to remap_split_decl_to_dummy through walk_tree.  */\n+\n+struct simple_tree_swap_info\n+{\n+  /* Change FROM to TO.  */\n+  tree from, to;\n+  /* And set DONE to true when doing so.  */\n+  bool done;\n+};\n+\n+/* Simple remapper to remap a split parameter to the same expression based on a\n+   special dummy decl so that edge redirections can detect transitive splitting\n+   and finish them.  */\n \n-      fprintf (file, \"%i. base_index: %i - \", i, adj->base_index);\n-      print_generic_expr (file, parms[adj->base_index]);\n-      if (adj->base)\n+static tree\n+remap_split_decl_to_dummy (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp;\n+\n+  if (DECL_P (t) || TREE_CODE (t) == SSA_NAME)\n+    {\n+      struct simple_tree_swap_info *swapinfo\n+\t= (struct simple_tree_swap_info *) data;\n+      if (t == swapinfo->from\n+\t  || (TREE_CODE (t) == SSA_NAME\n+\t      && SSA_NAME_VAR (t) == swapinfo->from))\n \t{\n-\t  fprintf (file, \", base: \");\n-\t  print_generic_expr (file, adj->base);\n+\t  *tp = swapinfo->to;\n+\t  swapinfo->done = true;\n+\t}\n+      *walk_subtrees = 0;\n+    }\n+  else if (TYPE_P (t))\n+      *walk_subtrees = 0;\n+  else\n+    *walk_subtrees = 1;\n+  return NULL_TREE;\n+}\n+\n+\n+/* If the call statement pointed at by STMT_P contains any expressions that\n+   need to replaced with a different one as noted by ADJUSTMENTS, do so.  f the\n+   statement needs to be rebuilt, do so.  Return true if any modifications have\n+   been performed.\n+\n+   If the method is invoked as a part of IPA clone materialization and if any\n+   parameter split is transitive, i.e. it applies to the functin that is being\n+   modified and also to the callee of the statement, replace the parameter\n+   passed to old callee with an equivalent expression based on a dummy decl\n+   followed by PARM_DECLs representing the actual replacements.  The actual\n+   replacements will be then converted into SSA_NAMEs and then\n+   ipa_param_adjustments::modify_call will find the appropriate ones and leave\n+   only those in the call.  */\n+\n+bool\n+ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p)\n+{\n+  gcall *stmt = *stmt_p;\n+  auto_vec <unsigned, 4> pass_through_args;\n+  auto_vec <unsigned, 4> pass_through_pbr_indices;\n+\n+  if (m_split_modifications_p && m_id)\n+    {\n+      for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n+\t{\n+\t  tree t = gimple_call_arg (stmt, i);\n+\t  gcc_assert (TREE_CODE (t) != BIT_FIELD_REF\n+\t\t      && TREE_CODE (t) != IMAGPART_EXPR\n+\t\t      && TREE_CODE (t) != REALPART_EXPR);\n+\n+\t  tree base;\n+\t  unsigned unit_offset;\n+\t  if (!isra_get_ref_base_and_offset (t, &base, &unit_offset))\n+\t    continue;\n+\n+\t  bool by_ref = false;\n+\t  if (TREE_CODE (base) == SSA_NAME)\n+\t    {\n+\t      if (!SSA_NAME_IS_DEFAULT_DEF (base))\n+\t\tcontinue;\n+\t      base = SSA_NAME_VAR (base);\n+\t      gcc_checking_assert (base);\n+\t      by_ref = true;\n+\t    }\n+\t  if (TREE_CODE (base) != PARM_DECL)\n+\t    continue;\n+\n+\t  bool base_among_replacements = false;\n+\t  unsigned j, repl_list_len = m_replacements.length ();\n+\t  for (j = 0; j < repl_list_len; j++)\n+\t    {\n+\t      ipa_param_body_replacement *pbr = &m_replacements[j];\n+\t      if (pbr->base == base)\n+\t\t{\n+\t\t  base_among_replacements = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (!base_among_replacements)\n+\t    continue;\n+\n+\t  /* We still have to distinguish between an end-use that we have to\n+\t     transform now and a pass-through, which happens in the following\n+\t     two cases.  */\n+\n+\t  /* TODO: After we adjust ptr_parm_has_nonarg_uses to also consider\n+\t     &MEM_REF[ssa_name + offset], we will also have to detect that case\n+\t     here.    */\n+\n+\t  if (TREE_CODE (t) == SSA_NAME\n+\t      && SSA_NAME_IS_DEFAULT_DEF (t)\n+\t      && SSA_NAME_VAR (t)\n+\t      && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL)\n+\t    {\n+\t      /* This must be a by_reference pass-through.  */\n+\t      gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n+\t      pass_through_args.safe_push (i);\n+\t      pass_through_pbr_indices.safe_push (j);\n+\t    }\n+\t  else if (!by_ref && AGGREGATE_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      /* Currently IPA-SRA guarantees the aggregate access type\n+\t\t exactly matches in this case.  So if it does not match, it is\n+\t\t a pass-through argument that will be sorted out at edge\n+\t\t redirection time.  */\n+\t      ipa_param_body_replacement *pbr\n+\t\t= lookup_replacement_1 (base, unit_offset);\n+\n+\t      if (!pbr\n+\t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (t))\n+\t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (pbr->repl))))\n+\t\t{\n+\t\t  pass_through_args.safe_push (i);\n+\t\t  pass_through_pbr_indices.safe_push (j);\n+\t\t}\n+\t    }\n \t}\n-      if (adj->new_decl)\n+    }\n+\n+  unsigned nargs = gimple_call_num_args (stmt);\n+  if (!pass_through_args.is_empty ())\n+    {\n+      auto_vec<tree, 16> vargs;\n+      unsigned pt_idx = 0;\n+      for (unsigned i = 0; i < nargs; i++)\n \t{\n-\t  fprintf (file, \", new_decl: \");\n-\t  print_generic_expr (file, adj->new_decl);\n+\t  if (pt_idx < pass_through_args.length ()\n+\t      && i == pass_through_args[pt_idx])\n+\t    {\n+\t      unsigned j = pass_through_pbr_indices[pt_idx];\n+\t      pt_idx++;\n+\t      tree base = m_replacements[j].base;\n+\n+\t      /* Map base will get mapped to the special transitive-isra marker\n+\t\t dummy decl. */\n+\t      struct simple_tree_swap_info swapinfo;\n+\t      swapinfo.from = base;\n+\t      swapinfo.to = m_replacements[j].dummy;\n+\t      swapinfo.done = false;\n+\t      tree arg = gimple_call_arg (stmt, i);\n+\t      walk_tree (&arg, remap_split_decl_to_dummy, &swapinfo, NULL);\n+\t      gcc_assert (swapinfo.done);\n+\t      vargs.safe_push (arg);\n+\t      /* Now let's push all replacements pertaining to this parameter\n+\t\t so that all gimple register ones get correct SSA_NAMES.  Edge\n+\t\t redirection will weed out the dummy argument as well as all\n+\t\t unused replacements later.  */\n+\t      unsigned int repl_list_len = m_replacements.length ();\n+\t      for (; j < repl_list_len; j++)\n+\t\t{\n+\t\t  if (m_replacements[j].base != base)\n+\t\t    break;\n+\t\t  vargs.safe_push (m_replacements[j].repl);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      tree t = gimple_call_arg (stmt, i);\n+\t      modify_expression (&t, true);\n+\t      vargs.safe_push (t);\n+\t    }\n \t}\n-      if (adj->new_ssa_base)\n+      gcall *new_stmt = gimple_build_call_vec (gimple_call_fn (stmt), vargs);\n+      gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n+      gimple_call_copy_flags (new_stmt, stmt);\n+      if (tree lhs = gimple_call_lhs (stmt))\n \t{\n-\t  fprintf (file, \", new_ssa_base: \");\n-\t  print_generic_expr (file, adj->new_ssa_base);\n+\t  modify_expression (&lhs, false);\n+\t  gimple_call_set_lhs (new_stmt, lhs);\n \t}\n+      *stmt_p = new_stmt;\n+      return true;\n+    }\n \n-      if (adj->op == IPA_PARM_OP_COPY)\n-\tfprintf (file, \", copy_param\");\n-      else if (adj->op == IPA_PARM_OP_REMOVE)\n-\tfprintf (file, \", remove_param\");\n-      else\n+  /* Otherwise, no need to rebuild the statement, let's just modify arguments\n+     and the LHS if/as appropriate.  */\n+  bool modified = false;\n+  for (unsigned i = 0; i < nargs; i++)\n+    {\n+      tree *t = gimple_call_arg_ptr (stmt, i);\n+      modified |= modify_expression (t, true);\n+    }\n+\n+  if (gimple_call_lhs (stmt))\n+    {\n+      tree *t = gimple_call_lhs_ptr (stmt);\n+      modified |= modify_expression (t, false);\n+    }\n+\n+  return modified;\n+}\n+\n+/* If the statement STMT contains any expressions that need to replaced with a\n+   different one as noted by ADJUSTMENTS, do so.  Handle any potential type\n+   incompatibilities.  If any conversion sttements have to be pre-pended to\n+   STMT, they will be added to EXTRA_STMTS.  Return true iff the statement was\n+   modified.  */\n+\n+bool\n+ipa_param_body_adjustments::modify_gimple_stmt (gimple **stmt,\n+\t\t\t\t\t\tgimple_seq *extra_stmts)\n+{\n+  bool modified = false;\n+  tree *t;\n+\n+  switch (gimple_code (*stmt))\n+    {\n+    case GIMPLE_RETURN:\n+      t = gimple_return_retval_ptr (as_a <greturn *> (*stmt));\n+      if (m_adjustments && m_adjustments->m_skip_return)\n+\t*t = NULL_TREE;\n+      else if (*t != NULL_TREE)\n+\tmodified |= modify_expression (t, true);\n+      break;\n+\n+    case GIMPLE_ASSIGN:\n+      modified |= modify_assignment (*stmt, extra_stmts);\n+      break;\n+\n+    case GIMPLE_CALL:\n+      modified |= modify_call_stmt ((gcall **) stmt);\n+      break;\n+\n+    case GIMPLE_ASM:\n+      {\n+\tgasm *asm_stmt = as_a <gasm *> (*stmt);\n+\tfor (unsigned i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n+\t  {\n+\t    t = &TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n+\t    modified |= modify_expression (t, true);\n+\t  }\n+\tfor (unsigned i = 0; i < gimple_asm_noutputs (asm_stmt); i++)\n+\t  {\n+\t    t = &TREE_VALUE (gimple_asm_output_op (asm_stmt, i));\n+\t    modified |= modify_expression (t, false);\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return modified;\n+}\n+\n+\n+/* Traverse body of the current function and perform the requested adjustments\n+   on its statements.  Return true iff the CFG has been changed.  */\n+\n+bool\n+ipa_param_body_adjustments::modify_cfun_body ()\n+{\n+  bool cfg_changed = false;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));\n+\t  tree new_lhs, old_lhs = gimple_phi_result (phi);\n+\t  new_lhs = replace_removed_params_ssa_names (old_lhs, phi);\n+\t  if (new_lhs)\n+\t    {\n+\t      gimple_phi_set_result (phi, new_lhs);\n+\t      release_ssa_name (old_lhs);\n+\t    }\n+\t}\n+\n+      gsi = gsi_start_bb (bb);\n+      while (!gsi_end_p (gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple *stmt_copy = stmt;\n+\t  gimple_seq extra_stmts = NULL;\n+\t  bool modified = modify_gimple_stmt (&stmt, &extra_stmts);\n+\t  if (stmt != stmt_copy)\n+\t    {\n+\t      gcc_checking_assert (modified);\n+\t      gsi_replace (&gsi, stmt, false);\n+\t    }\n+\t  if (!gimple_seq_empty_p (extra_stmts))\n+\t    gsi_insert_seq_before (&gsi, extra_stmts, GSI_SAME_STMT);\n+\n+\t  def_operand_p defp;\n+\t  ssa_op_iter iter;\n+\t  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)\n+\t    {\n+\t      tree old_def = DEF_FROM_PTR (defp);\n+\t      if (tree new_def = replace_removed_params_ssa_names (old_def,\n+\t\t\t\t\t\t\t\t   stmt))\n+\t\t{\n+\t\t  SET_DEF (defp, new_def);\n+\t\t  release_ssa_name (old_def);\n+\t\t  modified = true;\n+\t\t}\n+\t    }\n+\n+\t  if (modified)\n+\t    {\n+\t      update_stmt (stmt);\n+\t      if (maybe_clean_eh_stmt (stmt)\n+\t\t  && gimple_purge_dead_eh_edges (gimple_bb (stmt)))\n+\t\tcfg_changed = true;\n+\t    }\n+\t  gsi_next (&gsi);\n+\t}\n+    }\n+\n+  return cfg_changed;\n+}\n+\n+/* Call gimple_debug_bind_reset_value on all debug statements describing\n+   gimple register parameters that are being removed or replaced.  */\n+\n+void\n+ipa_param_body_adjustments::reset_debug_stmts ()\n+{\n+  int i, len;\n+  gimple_stmt_iterator *gsip = NULL, gsi;\n+\n+  if (MAY_HAVE_DEBUG_STMTS && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n+    {\n+      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+      gsip = &gsi;\n+    }\n+  len = m_reset_debug_decls.length ();\n+  for (i = 0; i < len; i++)\n+    {\n+      imm_use_iterator ui;\n+      gimple *stmt;\n+      gdebug *def_temp;\n+      tree name, vexpr, copy = NULL_TREE;\n+      use_operand_p use_p;\n+      tree decl = m_reset_debug_decls[i];\n+\n+      gcc_checking_assert (is_gimple_reg (decl));\n+      name = ssa_default_def (cfun, decl);\n+      vexpr = NULL;\n+      if (name)\n+\tFOR_EACH_IMM_USE_STMT (stmt, ui, name)\n+\t  {\n+\t    if (gimple_clobber_p (stmt))\n+\t      {\n+\t\tgimple_stmt_iterator cgsi = gsi_for_stmt (stmt);\n+\t\tunlink_stmt_vdef (stmt);\n+\t\tgsi_remove (&cgsi, true);\n+\t\trelease_defs (stmt);\n+\t\tcontinue;\n+\t      }\n+\t    /* All other users must have been removed by function body\n+\t       modification.  */\n+\t    gcc_assert (is_gimple_debug (stmt));\n+\t    if (vexpr == NULL && gsip != NULL)\n+\t      {\n+\t\tvexpr = make_node (DEBUG_EXPR_DECL);\n+\t\tdef_temp = gimple_build_debug_source_bind (vexpr, decl, NULL);\n+\t\tDECL_ARTIFICIAL (vexpr) = 1;\n+\t\tTREE_TYPE (vexpr) = TREE_TYPE (name);\n+\t\tSET_DECL_MODE (vexpr, DECL_MODE (decl));\n+\t\tgsi_insert_before (gsip, def_temp, GSI_SAME_STMT);\n+\t      }\n+\t    if (vexpr)\n+\t      {\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, ui)\n+\t\t  SET_USE (use_p, vexpr);\n+\t      }\n+\t    else\n+\t      gimple_debug_bind_reset_value (stmt);\n+\t    update_stmt (stmt);\n+\t  }\n+      /* Create a VAR_DECL for debug info purposes.  */\n+      if (!DECL_IGNORED_P (decl))\n \t{\n-\t  fprintf (file, \", offset \");\n-\t  print_dec (adj->offset, file);\n+\t  copy = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t     VAR_DECL, DECL_NAME (decl),\n+\t\t\t     TREE_TYPE (decl));\n+\t  if (DECL_PT_UID_SET_P (decl))\n+\t    SET_DECL_PT_UID (copy, DECL_PT_UID (decl));\n+\t  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n+\t  TREE_READONLY (copy) = TREE_READONLY (decl);\n+\t  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+\t  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n+\t  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (decl);\n+\t  DECL_IGNORED_P (copy) = DECL_IGNORED_P (decl);\n+\t  DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (decl);\n+\t  DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n+\t  SET_DECL_RTL (copy, 0);\n+\t  TREE_USED (copy) = 1;\n+\t  DECL_CONTEXT (copy) = current_function_decl;\n+\t  add_local_decl (cfun, copy);\n+\t  DECL_CHAIN (copy)\n+\t    = BLOCK_VARS (DECL_INITIAL (current_function_decl));\n+\t  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = copy;\n+\t}\n+      if (gsip != NULL && copy && target_for_debug_bind (decl))\n+\t{\n+\t  gcc_assert (TREE_CODE (decl) == PARM_DECL);\n+\t  if (vexpr)\n+\t    def_temp = gimple_build_debug_bind (copy, vexpr, NULL);\n+\t  else\n+\t    def_temp = gimple_build_debug_source_bind (copy, decl,\n+\t\t\t\t\t\t       NULL);\n+\t  gsi_insert_before (gsip, def_temp, GSI_SAME_STMT);\n \t}\n-      if (adj->by_ref)\n-\tfprintf (file, \", by_ref\");\n-      print_node_brief (file, \", type: \", adj->type, 0);\n-      fprintf (file, \"\\n\");\n     }\n-  parms.release ();\n+}\n+\n+/* Perform all necessary body changes to change signature, body and debug info\n+   of fun according to adjustments passed at construction.  Return true if CFG\n+   was changed in any way.  The main entry point for modification of standalone\n+   functions that is not part of IPA clone materialization.  */\n+\n+bool\n+ipa_param_body_adjustments::perform_cfun_body_modifications ()\n+{\n+  bool cfg_changed;\n+  modify_formal_parameters ();\n+  cfg_changed = modify_cfun_body ();\n+  reset_debug_stmts ();\n+\n+  return cfg_changed;\n }\n "}, {"sha": "34477da51b7a9d06230129791f0ffcc5e97cd0d8", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 382, "deletions": 67, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -16,101 +16,416 @@ for more details.\n \n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+<http://www.gnu.org/licenses/>.\n+\n+\n+\n+This file defines classes and other data structures that are used to manipulate\n+the prototype of a function, especially to create, remove or split its formal\n+parameters, but also to remove its return value, and also its call statements\n+correspondingly.\n+\n+The most basic one is a vector of structures ipa_adjusted_param.  It is simply\n+a description how the new parameters should look like after the transformation\n+in what way they relate to the previous ones (if in any).  Such relation to an\n+old parameter can be an outright copy or an IPA-SRA replacement. If an old\n+parameter is not listed or otherwise mentioned, it is removed as unused or at\n+least unnecessary.  Note that this most basic structure does not work for\n+modifying calls of functions with variable number of arguments.\n+\n+Class ipa_param_adjustments is only a little more than a thin encapsulation of\n+a vector of ipa_param_adjustments.  Along with this vector it contains an index\n+of the first potential vararg argument and a boolean flag whether the return\n+value should be removed or not.  Moreover, the class contains method\n+modify_call which can transform a call statement so that it correctly calls a\n+modified function.  These two data structures were designed to have a small\n+memory footprint because they are allocated for each clone of a call graph node\n+that has its prototype changed and live until the end of IPA clone\n+materialization and call redirection phase.\n+\n+On the other hand, class ipa_param_body_adjustments can afford to allocate more\n+data because its life span is much smaller, it is allocated and destroyed in\n+the course of materialization of each single clone that needs it or only when a\n+particular pass needs to change a function it is operating on.  This class has\n+various methods required to change function declaration and the body of the\n+function according to instructions given either by class ipa_param_adjustments\n+or only a vector of ipa_adjusted_params.\n+\n+When these classes are used in the context of call graph clone materialization\n+and subsequent call statement redirection - which is the point at which we\n+modify arguments in call statements - they need to cooperate with each other in\n+order to handle what we refer to as transitive (IPA-SRA) splits.  These are\n+situations when a formal parameter of one function is split into several\n+smaller ones and some of them are then passed on in a call to another function\n+because the formal parameter of this callee has also been split.\n+\n+Consider a simple example:\n+\n+struct S {int a, b, c;};\n+struct Z {int x; S s;};\n+\n+foo (S s)\n+{\n+  use (s.b);\n+}\n+\n+bar (Z z)\n+{\n+  use (z.s.a);\n+  foo (z.s);\n+}\n+\n+baz ()\n+{\n+  bar (*global);\n+}\n+\n+Both bar and foo would have their parameter split.  Foo would receive one\n+replacement representing s.b.  Function bar would see its parameter split into\n+one replacement representing z.s.a and another representing z.s.b which would\n+be passed on to foo.  It would be a so called transitive split IPA-SRA\n+replacement, one which is passed in a call as an actual argument to another\n+IPA-SRA replacement in another function.\n+\n+Note that the call chain the example can be arbitrarily long and recursive and\n+that any function in it can be cloned by another IPA pass and any number of\n+adjacent functions in the call chain can be inlined into each other.  Call\n+redirection takes place only after bodies of the function have been modified by\n+all of the above.\n+\n+Call redirection has to be able to find the right decl or SSA_NAME that\n+corresponds to the transitive split in the caller.  The SSA names are assigned\n+right after clone materialization/ modification and cannot be \"added\"\n+afterwards.  Moreover, if the caller has been inlined the SSA_NAMEs in question\n+no longer belong to PARM_DECLs but to VAR_DECLs, indistinguishable from any\n+others.\n+\n+Therefore, when clone materialization finds a call statement which it knows is\n+a part of a transitive split, it will modify it into:\n+\n+  foo (DUMMY_Z_VAR.s, repl_for_a, repl_for_b, <rest of original arguments>);\n+\n+It will also store {DUMMY_S_VAR, 32} and {DUMMY_S_VAR, 64} representing offsets\n+of z.s.a and z.s.b (assuming a 32-bit int) into foo's cgraph node\n+clone->performed_splits vector (which is storing structures of type\n+ipa_param_performed_split also defined in this header file).\n+\n+Call redirection will identify that expression DUMMY_Z_VAR.s is based on a\n+variable stored in performed_splits vector and learn that the following\n+arguments, already in SSA form, represent offsets 32 and 64 in a split original\n+parameter.  It subtracts offset of DUMMY_Z_VAR.s from 32 and 64 and arrives at\n+offsets 0 and 32 within callee's original parameter.  At this point it also\n+knows from the call graph that only the bit with offset 32 is needed and so\n+changes the call statement into final:\n+\n+bar (repl_for_b, <rest of original arguments>);  */\n \n #ifndef IPA_PARAM_MANIPULATION_H\n #define IPA_PARAM_MANIPULATION_H\n \n+/* Indices into ipa_param_prefixes to identify a human-readable prefix for newly\n+   synthesized parameters.  Keep in sync with the array.  */\n+enum ipa_param_name_prefix_indices\n+  {\n+   IPA_PARAM_PREFIX_SYNTH,\n+   IPA_PARAM_PREFIX_ISRA,\n+   IPA_PARAM_PREFIX_SIMD,\n+   IPA_PARAM_PREFIX_MASK,\n+   IPA_PARAM_PREFIX_COUNT\n+};\n+\n+/* We do not support manipulating functions with more than\n+   1<<IPA_PARAM_MAX_INDEX_BITS parameters.  */\n+#define IPA_PARAM_MAX_INDEX_BITS 16\n+\n /* Operation to be performed for the parameter in ipa_parm_adjustment\n    below.  */\n-enum ipa_parm_op {\n-  IPA_PARM_OP_NONE,\n-\n-  /* This describes a brand new parameter.\n \n-     The field `type' should be set to the new type, `arg_prefix'\n-     should be set to the string prefix for the new DECL_NAME, and\n-     `new_decl' will ultimately hold the newly created argument.  */\n-  IPA_PARM_OP_NEW,\n+enum ipa_parm_op\n+{\n+  /* Do not use or you will trigger an assert.  */\n+  IPA_PARAM_OP_UNDEFINED,\n \n   /* This new parameter is an unmodified parameter at index base_index. */\n-  IPA_PARM_OP_COPY,\n+  IPA_PARAM_OP_COPY,\n+\n+  /* This describes a brand new parameter.  If it somehow relates to any\n+     original parameters, the user needs to manage the transition itself.  */\n+  IPA_PARAM_OP_NEW,\n \n-  /* This adjustment describes a parameter that is about to be removed\n-     completely.  Most users will probably need to book keep those so that they\n-     don't leave behinfd any non default def ssa names belonging to them.  */\n-  IPA_PARM_OP_REMOVE\n+    /* Split parameter as indicated by fields base_index, offset and type.  */\n+  IPA_PARAM_OP_SPLIT\n };\n \n-/* Structure to describe transformations of formal parameters and actual\n-   arguments.  Each instance describes one new parameter and they are meant to\n-   be stored in a vector.  Additionally, most users will probably want to store\n-   adjustments about parameters that are being removed altogether so that SSA\n-   names belonging to them can be replaced by SSA names of an artificial\n-   variable.  */\n-struct ipa_parm_adjustment\n-{\n-  /* The original PARM_DECL itself, helpful for processing of the body of the\n-     function itself.  Intended for traversing function bodies.\n-     ipa_modify_formal_parameters, ipa_modify_call_arguments and\n-     ipa_combine_adjustments ignore this and use base_index.\n-     ipa_modify_formal_parameters actually sets this.  */\n-  tree base;\n+/* Structure that describes one parameter of a function after transformation.\n+   Omitted parameters will be removed.  */\n \n-  /* Type of the new parameter.  However, if by_ref is true, the real type will\n-     be a pointer to this type.  */\n+struct GTY(()) ipa_adjusted_param\n+{\n+  /* Type of the new parameter.  Required for all operations except\n+     IPA_PARM_OP_COPY when the original type will be preserved.  */\n   tree type;\n \n-  /* Alias refrerence type to be used in MEM_REFs when adjusting caller\n-     arguments.  */\n+  /* Alias reference type to be used in MEM_REFs when adjusting caller\n+     arguments.  Required for IPA_PARM_OP_SPLIT operation.  */\n   tree alias_ptr_type;\n \n-  /* The new declaration when creating/replacing a parameter.  Created\n-     by ipa_modify_formal_parameters, useful for functions modifying\n-     the body accordingly.  For brand new arguments, this is the newly\n-     created argument.  */\n-  tree new_decl;\n+  /* Offset into the original parameter (for the cases when the new parameter\n+     is a component of an original one).  Required for IPA_PARM_OP_SPLIT\n+     operation.  */\n+  unsigned unit_offset;\n \n-  /* New declaration of a substitute variable that we may use to replace all\n-     non-default-def ssa names when a parm decl is going away.  */\n-  tree new_ssa_base;\n+  /* Zero based index of the original parameter this one is based on.  Required\n+     for IPA_PARAM_OP_COPY and IPA_PARAM_OP_SPLIT, users of IPA_PARAM_OP_NEW\n+     only need to specify it if they use replacement lookup provided by\n+     ipa_param_body_adjustments.  */\n+  unsigned base_index : IPA_PARAM_MAX_INDEX_BITS;\n \n-  /* This holds the prefix to be used for the new DECL_NAME.  */\n-  const char *arg_prefix;\n+  /* Zero based index of the parameter this one is based on in the previous\n+     clone.  If there is no previous clone, it must be equal to base_index.  */\n+  unsigned prev_clone_index : IPA_PARAM_MAX_INDEX_BITS;\n \n-  /* Offset into the original parameter (for the cases when the new parameter\n-     is a component of an original one).  */\n-  poly_int64_pod offset;\n+  /* Specify the operation, if any, to be performed on the parameter.  */\n+  enum ipa_parm_op op : 2;\n \n-  /* Zero based index of the original parameter this one is based on.  */\n-  int base_index;\n+  /* If set, this structure describes a parameter copied over from a previous\n+     IPA clone, any transformations are thus not to be re-done.  */\n+  unsigned prev_clone_adjustment : 1;\n \n-  /* Whether this parameter is a new parameter, a copy of an old one,\n-     or one about to be removed.  */\n-  enum ipa_parm_op op;\n+  /* Index into ipa_param_prefixes specifying a prefix to be used with\n+     DECL_NAMEs of newly synthesized parameters.  */\n+  unsigned param_prefix_index : 2;\n \n   /* Storage order of the original parameter (for the cases when the new\n      parameter is a component of an original one).  */\n   unsigned reverse : 1;\n \n-  /* The parameter is to be passed by reference.  */\n-  unsigned by_ref : 1;\n+  /* A bit free for the user.  */\n+  unsigned user_flag : 1;\n+};\n+\n+void ipa_dump_adjusted_parameters (FILE *f,\n+\t\t\t\t   vec<ipa_adjusted_param, va_gc> *adj_params);\n+\n+/* Structure to remember the split performed on a node so that edge redirection\n+   (i.e. splitting arguments of call statements) know how split formal\n+   parameters of the caller are represented.  */\n+\n+struct GTY(()) ipa_param_performed_split\n+{\n+  /* The dummy VAR_DECL that was created instead of the split parameter that\n+     sits in the call in the meantime between clone materialization and call\n+     redirection.  All entries in a vector of performed splits that correspond\n+     to the same dumy decl must be grouped together.  */\n+  tree dummy_decl;\n+  /* Offset into the original parameter.  */\n+  unsigned unit_offset;\n+};\n+\n+/* Class used to record planned modifications to parameters of a function and\n+   also to perform necessary modifications at the caller side at the gimple\n+   level.  Used to describe all cgraph node clones that have their parameters\n+   changed, therefore the class should only have a small memory footprint.  */\n+\n+class GTY(()) ipa_param_adjustments\n+{\n+public:\n+  /* Constructor from NEW_PARAMS showing how new parameters should look like\n+      plus copying any pre-existing actual arguments starting from argument\n+      with index ALWAYS_COPY_START (if non-negative, negative means do not copy\n+      anything beyond what is described in NEW_PARAMS), and SKIP_RETURN, which\n+      indicates that the function should return void after transformation.  */\n+\n+  ipa_param_adjustments (vec<ipa_adjusted_param, va_gc> *new_params,\n+\t\t\t int always_copy_start, bool skip_return)\n+    : m_adj_params (new_params), m_always_copy_start (always_copy_start),\n+    m_skip_return (skip_return)\n+    {}\n+\n+  /* Modify a call statement arguments (and possibly remove the return value)\n+     as described in the data fields of this class.  */\n+  gcall *modify_call (gcall *stmt,\n+\t\t      vec<ipa_param_performed_split, va_gc> *performed_splits,\n+\t\t      tree callee_decl, bool update_references);\n+  /* Return if the first parameter is left intact.  */\n+  bool first_param_intact_p ();\n+  /* Build a function type corresponding to the modified call.  */\n+  tree build_new_function_type (tree old_type, bool type_is_original_p);\n+  /* Build a declaration corresponding to the target of the modified call.  */\n+  tree adjust_decl (tree orig_decl);\n+  /* Fill a vector marking which parameters are intact by the described\n+     modifications. */\n+  void get_surviving_params (vec<bool> *surviving_params);\n+  /* Fill a vector with new indices of surviving original parameters.  */\n+  void get_updated_indices (vec<int> *new_indices);\n+\n+  void dump (FILE *f);\n+  void debug ();\n+\n+  /* How the known part of arguments should look like.  */\n+  vec<ipa_adjusted_param, va_gc> *m_adj_params;\n+\n+  /* If non-negative, copy any arguments starting at this offset without any\n+     modifications so that functions with variable number of arguments can be\n+     modified. This number should be equal to the number of original forma\n+     parameters.  */\n+  int m_always_copy_start;\n+  /* If true, make the function not return any value.  */\n+  bool m_skip_return;\n+\n+private:\n+  ipa_param_adjustments () {}\n+\n+  void init (vec<tree> *cur_params);\n+  int get_max_base_index ();\n+  bool method2func_p (tree orig_type);\n+};\n+\n+/* Structure used to map expressions accessing split or replaced parameters to\n+   new PARM_DECLs.  */\n+\n+struct ipa_param_body_replacement\n+{\n+  /* The old decl of the original parameter.   */\n+  tree base;\n+  /* The new decl it should be replaced with.  */\n+  tree repl;\n+  /* When modifying clones during IPA clone materialization, this is a dummy\n+     decl used to mark calls in which we need to apply transitive splitting,\n+     these dummy delcls are inserted as arguments to such calls and then\n+     followed by all the replacements with offset info stored in\n+     ipa_param_performed_split.\n+\n+     Users of ipa_param_body_adjustments that modify standalone functions\n+     outside of IPA clone materialization can use this field for their internal\n+     purposes.  */\n+  tree dummy;\n+  /* The offset within BASE that REPL represents.  */\n+  unsigned unit_offset;\n+};\n+\n+struct ipa_replace_map;\n+\n+/* Class used when actually performing adjustments to formal parameters of a\n+   function to map accesses that need to be replaced to replacements.  The\n+   class attempts to work in two very different sets of circumstances: as a\n+   part of tree-inine.c's tree_function_versioning machinery to clone functions\n+   (when M_ID is not NULL) and in s standalone fashion, modifying an existing\n+   function in place (when M_ID is NULL).  While a lot of stuff handled in a\n+   unified way in both modes, there are many aspects of the processs that\n+   requires distinct paths.  */\n+\n+class ipa_param_body_adjustments\n+{\n+public:\n+  /* Constructor to use from within tree-inline.  */\n+  ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n+\t\t\t      tree fndecl, tree old_fndecl,\n+\t\t\t      struct copy_body_data *id, tree *vars,\n+\t\t\t      vec<ipa_replace_map *, va_gc> *tree_map);\n+  /* Constructor to use for modifying a function outside of tree-inline from an\n+     instance of ipa_param_adjustments.  */\n+  ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n+\t\t\t      tree fndecl);\n+  /* Constructor to use for modifying a function outside of tree-inline from a\n+     simple vector of desired parameter modification.  */\n+  ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n+\t\t\t      tree fndecl);\n+\n+  /* The do-it-all function for modifying a function outside of\n+     tree-inline.  */\n+  bool perform_cfun_body_modifications ();\n+\n+  /* Change the PARM_DECLs.  */\n+  void modify_formal_parameters ();\n+  /* Register a replacement decl for the transformation done in APM.  */\n+  void register_replacement (ipa_adjusted_param *apm, tree replacement,\n+\t\t\t     tree dummy = NULL_TREE);\n+  /* Lookup a replacement for a given offset within a given parameter.  */\n+  tree lookup_replacement (tree base, unsigned unit_offset);\n+  /* Lookup a replacement for an expression, if there is one.  */\n+  ipa_param_body_replacement *get_expr_replacement (tree expr,\n+\t\t\t\t\t\t    bool ignore_default_def);\n+  /* Lookup the new base for surviving names previously belonging to a\n+     parameter. */\n+  tree get_replacement_ssa_base (tree old_decl);\n+  /* Modify a statement.  */\n+  bool modify_gimple_stmt (gimple **stmt, gimple_seq *extra_stmts);\n+  /* Return the new chain of parameters.  */\n+  tree get_new_param_chain ();\n+\n+  /* Pointers to data structures defining how the function should be\n+     modified.  */\n+  vec<ipa_adjusted_param, va_gc> *m_adj_params;\n+  ipa_param_adjustments *m_adjustments;\n+\n+  /* Vector of old parameter declarations that must have their debug bind\n+     statements re-mapped and debug decls created.  */\n+\n+  auto_vec<tree, 16> m_reset_debug_decls;\n+\n+  /* Set to true if there are any IPA_PARAM_OP_SPLIT adjustments among stored\n+     adjustments.  */\n+  bool m_split_modifications_p;\n+private:\n+  void common_initialization (tree old_fndecl, tree *vars,\n+\t\t\t      vec<ipa_replace_map *, va_gc> *tree_map);\n+  unsigned get_base_index (ipa_adjusted_param *apm);\n+  ipa_param_body_replacement *lookup_replacement_1 (tree base,\n+\t\t\t\t\t\t    unsigned unit_offset);\n+  tree replace_removed_params_ssa_names (tree old_name, gimple *stmt);\n+  bool modify_expression (tree *expr_p, bool convert);\n+  bool modify_assignment (gimple *stmt, gimple_seq *extra_stmts);\n+  bool modify_call_stmt (gcall **stmt_p);\n+  bool modify_cfun_body ();\n+  void reset_debug_stmts ();\n+\n+  /* Declaration of the function that is being transformed.  */\n+\n+  tree m_fndecl;\n+\n+  /* If non-NULL, the tree-inline master data structure guiding materialization\n+     of the current clone.  */\n+  struct copy_body_data *m_id;\n+\n+  /* Vector of old parameter declarations (before changing them).  */\n+\n+  auto_vec<tree, 16> m_oparms;\n+\n+  /* Vector of parameter declarations the function will have after\n+     transformation.  */\n+\n+  auto_vec<tree, 16> m_new_decls;\n+\n+  /* If the function type has non-NULL TYPE_ARG_TYPES, this is the vector of\n+     these types after transformation, otherwise an empty one.  */\n+\n+  auto_vec<tree, 16> m_new_types;\n+\n+  /* Vector of structures telling how to replace old parameters in in the\n+     function body.  TODO: Even though there usually be only few, but should we\n+     use a hash?  */\n+\n+  auto_vec<ipa_param_body_replacement, 16> m_replacements;\n+\n+  /* Vector for remapping SSA_BASES from old parameter declarations that are\n+     being removed as a part of the transformation.  Before a new VAR_DECL is\n+     created, it holds the old PARM_DECL, once the variable is built it is\n+     stored here.  */\n+\n+  auto_vec<tree> m_removed_decls;\n+\n+  /* Hash to quickly lookup the item in m_removed_decls given the old decl.  */\n+\n+  hash_map<tree, unsigned> m_removed_map;\n+\n+  /* True iff the transformed function is a class method that is about to loose\n+     its this pointer and must be converted to a normal function.  */\n+\n+  bool m_method2func;\n };\n \n-typedef vec<ipa_parm_adjustment> ipa_parm_adjustment_vec;\n-\n-vec<tree> ipa_get_vector_of_formal_parms (tree fndecl);\n-vec<tree> ipa_get_vector_of_formal_parm_types (tree fntype);\n-void ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec);\n-void ipa_modify_call_arguments (struct cgraph_edge *, gcall *,\n-\t\t\t\tipa_parm_adjustment_vec);\n-ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n-\t\t\t\t\t\t ipa_parm_adjustment_vec);\n-void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n-\n-bool ipa_modify_expr (tree *, bool, ipa_parm_adjustment_vec);\n-ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,\n-\t\t\t\t\t\t   ipa_parm_adjustment_vec,\n-\t\t\t\t\t\t   bool);\n+void push_function_arg_decls (vec<tree> *args, tree fndecl);\n+void push_function_arg_types (vec<tree> *types, tree fntype);\n \n #endif\t/* IPA_PARAM_MANIPULATION_H */"}, {"sha": "2f2b0708cab393ed8951b2c2a5c8e6e58f12eb68", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 67, "deletions": 36, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -4851,31 +4851,24 @@ adjust_agg_replacement_values (struct cgraph_node *node,\n \t\t\t       struct ipa_agg_replacement_value *aggval)\n {\n   struct ipa_agg_replacement_value *v;\n-  int i, c = 0, d = 0, *adj;\n \n-  if (!node->clone.combined_args_to_skip)\n+  if (!node->clone.param_adjustments)\n     return;\n \n+  auto_vec<int, 16> new_indices;\n+  node->clone.param_adjustments->get_updated_indices (&new_indices);\n   for (v = aggval; v; v = v->next)\n     {\n-      gcc_assert (v->index >= 0);\n-      if (c < v->index)\n-\tc = v->index;\n-    }\n-  c++;\n-\n-  adj = XALLOCAVEC (int, c);\n-  for (i = 0; i < c; i++)\n-    if (bitmap_bit_p (node->clone.combined_args_to_skip, i))\n-      {\n-\tadj[i] = -1;\n-\td++;\n-      }\n-    else\n-      adj[i] = i - d;\n+      gcc_checking_assert (v->index >= 0);\n \n-  for (v = aggval; v; v = v->next)\n-    v->index = adj[v->index];\n+      if ((unsigned) v->index < new_indices.length ())\n+\tv->index = new_indices[v->index];\n+      else\n+\t/* This can happen if we know about a constant passed by reference by\n+\t   an argument which is never actually used for anything, let alone\n+\t   loading that constant.  */\n+\tv->index = -1;\n+    }\n }\n \n /* Dominator walker driving the ipcp modification phase.  */\n@@ -5001,24 +4994,41 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n static void\n ipcp_update_bits (struct cgraph_node *node)\n {\n-  tree parm = DECL_ARGUMENTS (node->decl);\n-  tree next_parm = parm;\n   ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n \n   if (!ts || vec_safe_length (ts->bits) == 0)\n     return;\n-\n   vec<ipa_bits *, va_gc> &bits = *ts->bits;\n   unsigned count = bits.length ();\n+  if (!count)\n+    return;\n \n-  for (unsigned i = 0; i < count; ++i, parm = next_parm)\n+  auto_vec<int, 16> new_indices;\n+  bool need_remapping = false;\n+  if (node->clone.param_adjustments)\n     {\n-      if (node->clone.combined_args_to_skip\n-\t  && bitmap_bit_p (node->clone.combined_args_to_skip, i))\n-\tcontinue;\n+      node->clone.param_adjustments->get_updated_indices (&new_indices);\n+      need_remapping = true;\n+    }\n+  auto_vec <tree, 16> parm_decls;\n+  push_function_arg_decls (&parm_decls, node->decl);\n \n+  for (unsigned i = 0; i < count; ++i)\n+    {\n+      tree parm;\n+      if (need_remapping)\n+\t{\n+\t  if (i >= new_indices.length ())\n+\t    continue;\n+\t  int idx = new_indices[i];\n+\t  if (idx < 0)\n+\t    continue;\n+\t  parm = parm_decls[idx];\n+\t}\n+      else\n+\tparm = parm_decls[i];\n       gcc_checking_assert (parm);\n-      next_parm = DECL_CHAIN (parm);\n+\n \n       if (!bits[i]\n \t  || !(INTEGRAL_TYPE_P (TREE_TYPE (parm))\n@@ -5093,22 +5103,42 @@ ipcp_update_bits (struct cgraph_node *node)\n static void\n ipcp_update_vr (struct cgraph_node *node)\n {\n-  tree fndecl = node->decl;\n-  tree parm = DECL_ARGUMENTS (fndecl);\n-  tree next_parm = parm;\n   ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n   if (!ts || vec_safe_length (ts->m_vr) == 0)\n     return;\n   const vec<ipa_vr, va_gc> &vr = *ts->m_vr;\n   unsigned count = vr.length ();\n+  if (!count)\n+    return;\n \n-  for (unsigned i = 0; i < count; ++i, parm = next_parm)\n+  auto_vec<int, 16> new_indices;\n+  bool need_remapping = false;\n+  if (node->clone.param_adjustments)\n     {\n-      if (node->clone.combined_args_to_skip\n-\t  && bitmap_bit_p (node->clone.combined_args_to_skip, i))\n-\tcontinue;\n+      node->clone.param_adjustments->get_updated_indices (&new_indices);\n+      need_remapping = true;\n+    }\n+  auto_vec <tree, 16> parm_decls;\n+  push_function_arg_decls (&parm_decls, node->decl);\n+\n+  for (unsigned i = 0; i < count; ++i)\n+    {\n+      tree parm;\n+      int remapped_idx;\n+      if (need_remapping)\n+\t{\n+\t  if (i >= new_indices.length ())\n+\t    continue;\n+\t  remapped_idx = new_indices[i];\n+\t  if (remapped_idx < 0)\n+\t    continue;\n+\t}\n+      else\n+\tremapped_idx = i;\n+\n+      parm = parm_decls[remapped_idx];\n+\n       gcc_checking_assert (parm);\n-      next_parm = DECL_CHAIN (parm);\n       tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->decl), parm);\n \n       if (!ddef || !is_gimple_reg (parm))\n@@ -5123,7 +5153,8 @@ ipcp_update_vr (struct cgraph_node *node)\n \t    {\n \t      if (dump_file)\n \t\t{\n-\t\t  fprintf (dump_file, \"Setting value range of param %u \", i);\n+\t\t  fprintf (dump_file, \"Setting value range of param %u \"\n+\t\t\t   \"(now %i) \", i, remapped_idx);\n \t\t  fprintf (dump_file, \"%s[\",\n \t\t\t   (vr[i].type == VR_ANTI_RANGE) ? \"~\" : \"\");\n \t\t  print_decs (vr[i].min, dump_file);"}, {"sha": "375a15c44b3089a011d1805111ae9f1ecaffc2b0", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1326,13 +1326,38 @@ split_function (basic_block return_bb, class split_point *split_point,\n \t  }\n     }\n \n+  ipa_param_adjustments *adjustments;\n+  bool skip_return = (!split_part_return_p\n+\t\t      || !split_point->split_part_set_retval);\n+  /* TODO: Perhaps get rid of args_to_skip entirely, after we make sure the\n+     debug info generation and discrepancy avoiding works well too.  */\n+  if ((args_to_skip && !bitmap_empty_p (args_to_skip))\n+      || skip_return)\n+    {\n+      vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n+      unsigned j;\n+      for (parm = DECL_ARGUMENTS (current_function_decl), j = 0;\n+\t   parm; parm = DECL_CHAIN (parm), j++)\n+\tif (!args_to_skip || !bitmap_bit_p (args_to_skip, j))\n+\t  {\n+\t    ipa_adjusted_param adj;\n+\t    memset (&adj, 0, sizeof (adj));\n+\t    adj.op = IPA_PARAM_OP_COPY;\n+\t    adj.base_index = j;\n+\t    adj.prev_clone_index = j;\n+\t    vec_safe_push (new_params, adj);\n+\t  }\n+      adjustments = new ipa_param_adjustments (new_params, j, skip_return);\n+    }\n+  else\n+    adjustments = NULL;\n+\n   /* Now create the actual clone.  */\n   cgraph_edge::rebuild_edges ();\n   node = cur_node->create_version_clone_with_body\n-    (vNULL, NULL, args_to_skip,\n-     !split_part_return_p || !split_point->split_part_set_retval,\n+    (vNULL, NULL, adjustments,\n      split_point->split_bbs, split_point->entry_bb, \"part\");\n-\n+  delete adjustments;\n   node->split_part = true;\n \n   if (cur_node->same_comdat_group)\n@@ -1469,6 +1494,7 @@ split_function (basic_block return_bb, class split_point *split_point,\n \t      = gimple_build_debug_bind (ddecl, unshare_expr (arg), call);\n \t    gsi_insert_after (&gsi, def_temp, GSI_NEW_STMT);\n \t  }\n+      BITMAP_FREE (args_to_skip);\n     }\n \n   /* We avoid address being taken on any variable used by split part,"}, {"sha": "a32defb59bdee7303390a8277768c6149fb2058f", "filename": "gcc/ipa-sra.c", "status": "added", "additions": 4049, "deletions": 0, "changes": 4049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4"}, {"sha": "147975ba869a2548418af70bc059926775f35a81", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 75, "deletions": 46, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1804,8 +1804,7 @@ output_cgraph_opt_summary_p (struct cgraph_node *node)\n {\n   return ((node->clone_of || node->former_clone_of)\n \t  && (node->clone.tree_map\n-\t      || node->clone.args_to_skip\n-\t      || node->clone.combined_args_to_skip));\n+\t      || node->clone.param_adjustments));\n }\n \n /* Output optimization summary for EDGE to OB.  */\n@@ -1822,42 +1821,53 @@ output_node_opt_summary (struct output_block *ob,\n \t\t\t struct cgraph_node *node,\n \t\t\t lto_symtab_encoder_t encoder)\n {\n-  unsigned int index;\n-  bitmap_iterator bi;\n   struct ipa_replace_map *map;\n-  struct bitpack_d bp;\n   int i;\n   struct cgraph_edge *e;\n \n-  if (node->clone.args_to_skip)\n-    {\n-      streamer_write_uhwi (ob, bitmap_count_bits (node->clone.args_to_skip));\n-      EXECUTE_IF_SET_IN_BITMAP (node->clone.args_to_skip, 0, index, bi)\n-\tstreamer_write_uhwi (ob, index);\n-    }\n-  else\n-    streamer_write_uhwi (ob, 0);\n-  if (node->clone.combined_args_to_skip)\n+  /* TODO: Should this code be moved to ipa-param-manipulation?  */\n+  struct bitpack_d bp;\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, (node->clone.param_adjustments != NULL), 1);\n+  streamer_write_bitpack (&bp);\n+  if (ipa_param_adjustments *adjustments = node->clone.param_adjustments)\n     {\n-      streamer_write_uhwi (ob, bitmap_count_bits (node->clone.combined_args_to_skip));\n-      EXECUTE_IF_SET_IN_BITMAP (node->clone.combined_args_to_skip, 0, index, bi)\n-\tstreamer_write_uhwi (ob, index);\n+      streamer_write_uhwi (ob, vec_safe_length (adjustments->m_adj_params));\n+      ipa_adjusted_param *adj;\n+      FOR_EACH_VEC_SAFE_ELT (adjustments->m_adj_params, i, adj)\n+\t{\n+\t  bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, adj->base_index, IPA_PARAM_MAX_INDEX_BITS);\n+\t  bp_pack_value (&bp, adj->prev_clone_index, IPA_PARAM_MAX_INDEX_BITS);\n+\t  bp_pack_value (&bp, adj->op, 2);\n+\t  bp_pack_value (&bp, adj->param_prefix_index, 2);\n+\t  bp_pack_value (&bp, adj->prev_clone_adjustment, 1);\n+\t  bp_pack_value (&bp, adj->reverse, 1);\n+\t  bp_pack_value (&bp, adj->user_flag, 1);\n+\t  streamer_write_bitpack (&bp);\n+\t  if (adj->op == IPA_PARAM_OP_SPLIT\n+\t      || adj->op == IPA_PARAM_OP_NEW)\n+\t    {\n+\t      stream_write_tree (ob, adj->type, true);\n+\t      if (adj->op == IPA_PARAM_OP_SPLIT)\n+\t\t{\n+\t\t  stream_write_tree (ob, adj->alias_ptr_type, true);\n+\t\t  streamer_write_uhwi (ob, adj->unit_offset);\n+\t\t}\n+\t    }\n+\t}\n+      streamer_write_hwi (ob, adjustments->m_always_copy_start);\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, node->clone.param_adjustments->m_skip_return, 1);\n+      streamer_write_bitpack (&bp);\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n+\n   streamer_write_uhwi (ob, vec_safe_length (node->clone.tree_map));\n   FOR_EACH_VEC_SAFE_ELT (node->clone.tree_map, i, map)\n     {\n-      /* At the moment we assume all old trees to be PARM_DECLs, because we have no\n-         mechanism to store function local declarations into summaries.  */\n-      gcc_assert (!map->old_tree);\n       streamer_write_uhwi (ob, map->parm_num);\n       gcc_assert (EXPR_LOCATION (map->new_tree) == UNKNOWN_LOCATION);\n       stream_write_tree (ob, map->new_tree, true);\n-      bp = bitpack_create (ob->main_stream);\n-      bp_pack_value (&bp, map->replace_p, 1);\n-      bp_pack_value (&bp, map->ref_p, 1);\n-      streamer_write_bitpack (&bp);\n     }\n \n   if (lto_symtab_encoder_in_partition_p (encoder, node))\n@@ -1922,38 +1932,57 @@ input_node_opt_summary (struct cgraph_node *node,\n {\n   int i;\n   int count;\n-  int bit;\n-  struct bitpack_d bp;\n   struct cgraph_edge *e;\n \n-  count = streamer_read_uhwi (ib_main);\n-  if (count)\n-    node->clone.args_to_skip = BITMAP_GGC_ALLOC ();\n-  for (i = 0; i < count; i++)\n-    {\n-      bit = streamer_read_uhwi (ib_main);\n-      bitmap_set_bit (node->clone.args_to_skip, bit);\n-    }\n-  count = streamer_read_uhwi (ib_main);\n-  if (count)\n-    node->clone.combined_args_to_skip = BITMAP_GGC_ALLOC ();\n-  for (i = 0; i < count; i++)\n+  /* TODO: Should this code be moved to ipa-param-manipulation?  */\n+  struct bitpack_d bp;\n+  bp = streamer_read_bitpack (ib_main);\n+  bool have_adjustments = bp_unpack_value (&bp, 1);\n+  if (have_adjustments)\n     {\n-      bit = streamer_read_uhwi (ib_main);\n-      bitmap_set_bit (node->clone.combined_args_to_skip, bit);\n+      count = streamer_read_uhwi (ib_main);\n+      vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  ipa_adjusted_param adj;\n+\t  memset (&adj, 0, sizeof (adj));\n+\t  bp = streamer_read_bitpack (ib_main);\n+\t  adj.base_index = bp_unpack_value (&bp, IPA_PARAM_MAX_INDEX_BITS);\n+\t  adj.prev_clone_index\n+\t    = bp_unpack_value (&bp, IPA_PARAM_MAX_INDEX_BITS);\n+\t  adj.op = (enum ipa_parm_op) bp_unpack_value (&bp, 2);\n+\t  adj.param_prefix_index = bp_unpack_value (&bp, 2);\n+\t  adj.prev_clone_adjustment = bp_unpack_value (&bp, 1);\n+\t  adj.reverse = bp_unpack_value (&bp, 1);\n+\t  adj.user_flag = bp_unpack_value (&bp, 1);\n+\t  if (adj.op == IPA_PARAM_OP_SPLIT\n+\t      || adj.op == IPA_PARAM_OP_NEW)\n+\t    {\n+\t      adj.type = stream_read_tree (ib_main, data_in);\n+\t      if (adj.op == IPA_PARAM_OP_SPLIT)\n+\t\t{\n+\t\t  adj.alias_ptr_type = stream_read_tree (ib_main, data_in);\n+\t\t  adj.unit_offset = streamer_read_uhwi (ib_main);\n+\t\t}\n+\t    }\n+\t  vec_safe_push (new_params, adj);\n+\t}\n+      int always_copy_start = streamer_read_hwi (ib_main);\n+      bp = streamer_read_bitpack (ib_main);\n+      bool skip_return = bp_unpack_value (&bp, 1);\n+      node->clone.param_adjustments\n+\t= (new (ggc_alloc <ipa_param_adjustments> ())\n+\t   ipa_param_adjustments (new_params, always_copy_start, skip_return));\n     }\n+\n   count = streamer_read_uhwi (ib_main);\n   for (i = 0; i < count; i++)\n     {\n       struct ipa_replace_map *map = ggc_alloc<ipa_replace_map> ();\n \n       vec_safe_push (node->clone.tree_map, map);\n       map->parm_num = streamer_read_uhwi (ib_main);\n-      map->old_tree = NULL;\n       map->new_tree = stream_read_tree (ib_main, data_in);\n-      bp = streamer_read_bitpack (ib_main);\n-      map->replace_p = bp_unpack_value (&bp, 1);\n-      map->ref_p = bp_unpack_value (&bp, 1);\n     }\n   for (e = node->callees; e; e = e->next_callee)\n     input_edge_opt_summary (e, ib_main);"}, {"sha": "d5feebfc18d9b540b75ebd126982f18801438845", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -53,7 +53,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"offload_table\",\n   \"mode_table\",\n   \"hsa\",\n-  \"lto\"\n+  \"lto\",\n+  \"ipa-sra\"\n };\n \n /* Hooks so that the ipa passes can call into the lto front end to get"}, {"sha": "ddf3de0708d49b8c5c501008cf8a1e6d37f85c8f", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -235,6 +235,7 @@ enum lto_section_type\n   LTO_section_mode_table,\n   LTO_section_ipa_hsa,\n   LTO_section_lto,\n+  LTO_section_ipa_sra,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "968c8cfb1ab3c7c8e4689b484287c49784fa9833", "filename": "gcc/multiple_target.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fmultiple_target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fmultiple_target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmultiple_target.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -311,9 +311,8 @@ create_target_clone (cgraph_node *node, bool definition, char *name,\n   if (definition)\n     {\n       new_node = node->create_version_clone_with_body (vNULL, NULL,\n-    \t\t\t\t\t\t       NULL, false,\n-\t\t\t\t\t\t       NULL, NULL,\n-\t\t\t\t\t\t       name, attributes);\n+    \t\t\t\t\t\t       NULL, NULL,\n+\t\t\t\t\t\t       NULL, name, attributes);\n       if (new_node == NULL)\n \treturn NULL;\n       new_node->force_output = true;"}, {"sha": "d71a963443b31d384848559a40e5c900bb9acf86", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 120, "deletions": 109, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -86,21 +86,23 @@ simd_clone_struct_copy (struct cgraph_simd_clone *to,\n \t\t\t* sizeof (struct cgraph_simd_clone_arg))));\n }\n \n-/* Return vector of parameter types of function FNDECL.  This uses\n-   TYPE_ARG_TYPES if available, otherwise falls back to types of\n+/* Fill an empty vector ARGS with parameter types of function FNDECL.  This\n+   uses TYPE_ARG_TYPES if available, otherwise falls back to types of\n    DECL_ARGUMENTS types.  */\n \n-static vec<tree>\n-simd_clone_vector_of_formal_parm_types (tree fndecl)\n+static void\n+simd_clone_vector_of_formal_parm_types (vec<tree> *args, tree fndecl)\n {\n   if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n-    return ipa_get_vector_of_formal_parm_types (TREE_TYPE (fndecl));\n-  vec<tree> args = ipa_get_vector_of_formal_parms (fndecl);\n+    {\n+      push_function_arg_types (args, TREE_TYPE (fndecl));\n+      return;\n+    }\n+  push_function_arg_decls (args, fndecl);\n   unsigned int i;\n   tree arg;\n-  FOR_EACH_VEC_ELT (args, i, arg)\n-    args[i] = TREE_TYPE (args[i]);\n-  return args;\n+  FOR_EACH_VEC_ELT (*args, i, arg)\n+    (*args)[i] = TREE_TYPE ((*args)[i]);\n }\n \n /* Given a simd function in NODE, extract the simd specific\n@@ -113,7 +115,8 @@ static struct cgraph_simd_clone *\n simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n \t\t\t    bool *inbranch_specified)\n {\n-  vec<tree> args = simd_clone_vector_of_formal_parm_types (node->decl);\n+  auto_vec<tree> args;\n+  simd_clone_vector_of_formal_parm_types (&args, node->decl);\n   tree t;\n   int n;\n   *inbranch_specified = false;\n@@ -192,14 +195,12 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n \t\t  {\n \t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n \t\t\t\t\"ignoring large linear step\");\n-\t\t    args.release ();\n \t\t    return NULL;\n \t\t  }\n \t\telse if (integer_zerop (step))\n \t\t  {\n \t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n \t\t\t\t\"ignoring zero linear step\");\n-\t\t    args.release ();\n \t\t    return NULL;\n \t\t  }\n \t\telse\n@@ -263,7 +264,6 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n       warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n \t\t  \"ignoring %<#pragma omp declare simd%> on function \"\n \t\t  \"with %<_Atomic%> qualified return type\");\n-      args.release ();\n       return NULL;\n     }\n \n@@ -278,7 +278,6 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n \treturn NULL;\n       }\n \n-  args.release ();\n   return clone_info;\n }\n \n@@ -303,14 +302,14 @@ simd_clone_compute_base_data_type (struct cgraph_node *node,\n         such parameter.  */\n   else\n     {\n-      vec<tree> map = simd_clone_vector_of_formal_parm_types (fndecl);\n+      auto_vec<tree> map;\n+      simd_clone_vector_of_formal_parm_types (&map, fndecl);\n       for (unsigned int i = 0; i < clone_info->nargs; ++i)\n \tif (clone_info->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n \t  {\n \t    type = map[i];\n \t    break;\n \t  }\n-      map.release ();\n     }\n \n   /* c) If the characteristic data type determined by a) or b) above\n@@ -441,7 +440,7 @@ simd_clone_create (struct cgraph_node *old_node)\n \treturn NULL;\n       old_node->get_body ();\n       new_node = old_node->create_version_clone_with_body (vNULL, NULL, NULL,\n-\t\t\t\t\t\t\t   false, NULL, NULL,\n+\t\t\t\t\t\t\t   NULL, NULL,\n \t\t\t\t\t\t\t   \"simdclone\");\n     }\n   else\n@@ -561,31 +560,33 @@ create_tmp_simd_array (const char *prefix, tree type, int simdlen)\n \n    NODE is the function whose arguments are to be adjusted.\n \n-   Returns an adjustment vector that will be filled describing how the\n-   argument types will be adjusted.  */\n+   If NODE does not represent function definition, returns NULL.  Otherwise\n+   returns an adjustment class that will be filled describing how the argument\n+   declarations will be remapped.  New arguments which are not to be remapped\n+   are marked with USER_FLAG.  */\n \n-static ipa_parm_adjustment_vec\n+static ipa_param_body_adjustments *\n simd_clone_adjust_argument_types (struct cgraph_node *node)\n {\n-  vec<tree> args;\n-  ipa_parm_adjustment_vec adjustments;\n+  auto_vec<tree> args;\n \n   if (node->definition)\n-    args = ipa_get_vector_of_formal_parms (node->decl);\n+    push_function_arg_decls (&args, node->decl);\n   else\n-    args = simd_clone_vector_of_formal_parm_types (node->decl);\n-  adjustments.create (args.length ());\n-  unsigned i, j, veclen;\n-  struct ipa_parm_adjustment adj;\n+    simd_clone_vector_of_formal_parm_types (&args, node->decl);\n   struct cgraph_simd_clone *sc = node->simdclone;\n+  vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n+  vec_safe_reserve (new_params, sc->nargs);\n+  unsigned i, j, veclen;\n \n   for (i = 0; i < sc->nargs; ++i)\n     {\n+      ipa_adjusted_param adj;\n       memset (&adj, 0, sizeof (adj));\n       tree parm = args[i];\n       tree parm_type = node->definition ? TREE_TYPE (parm) : parm;\n       adj.base_index = i;\n-      adj.base = parm;\n+      adj.prev_clone_index = i;\n \n       sc->args[i].orig_arg = node->definition ? parm : NULL_TREE;\n       sc->args[i].orig_type = parm_type;\n@@ -594,7 +595,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t{\n \tdefault:\n \t  /* No adjustment necessary for scalar arguments.  */\n-\t  adj.op = IPA_PARM_OP_COPY;\n+\t  adj.op = IPA_PARAM_OP_COPY;\n \t  break;\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n@@ -603,7 +604,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n \t\t\t\t       TREE_TYPE (parm_type),\n \t\t\t\t       sc->simdlen);\n-\t  adj.op = IPA_PARM_OP_COPY;\n+\t  adj.op = IPA_PARAM_OP_COPY;\n \t  break;\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n \tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n@@ -615,21 +616,24 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t  veclen /= GET_MODE_BITSIZE (SCALAR_TYPE_MODE (parm_type));\n \t  if (veclen > sc->simdlen)\n \t    veclen = sc->simdlen;\n-\t  adj.arg_prefix = \"simd\";\n+\t  adj.op = IPA_PARAM_OP_NEW;\n+\t  adj.param_prefix_index = IPA_PARAM_PREFIX_SIMD;\n \t  if (POINTER_TYPE_P (parm_type))\n \t    adj.type = build_vector_type (pointer_sized_int_node, veclen);\n \t  else\n \t    adj.type = build_vector_type (parm_type, veclen);\n \t  sc->args[i].vector_type = adj.type;\n \t  for (j = veclen; j < sc->simdlen; j += veclen)\n \t    {\n-\t      adjustments.safe_push (adj);\n+\t      vec_safe_push (new_params, adj);\n \t      if (j == veclen)\n \t\t{\n \t\t  memset (&adj, 0, sizeof (adj));\n-\t\t  adj.op = IPA_PARM_OP_NEW;\n-\t\t  adj.arg_prefix = \"simd\";\n+\t\t  adj.op = IPA_PARAM_OP_NEW;\n+\t\t  adj.user_flag = 1;\n+\t\t  adj.param_prefix_index = IPA_PARAM_PREFIX_SIMD;\n \t\t  adj.base_index = i;\n+\t\t  adj.prev_clone_index = i;\n \t\t  adj.type = sc->args[i].vector_type;\n \t\t}\n \t    }\n@@ -640,18 +644,20 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t\t\t\t       ? IDENTIFIER_POINTER (DECL_NAME (parm))\n \t\t\t\t       : NULL, parm_type, sc->simdlen);\n \t}\n-      adjustments.safe_push (adj);\n+      vec_safe_push (new_params, adj);\n     }\n \n   if (sc->inbranch)\n     {\n       tree base_type = simd_clone_compute_base_data_type (sc->origin, sc);\n-\n+      ipa_adjusted_param adj;\n       memset (&adj, 0, sizeof (adj));\n-      adj.op = IPA_PARM_OP_NEW;\n-      adj.arg_prefix = \"mask\";\n+      adj.op = IPA_PARAM_OP_NEW;\n+      adj.user_flag = 1;\n+      adj.param_prefix_index = IPA_PARAM_PREFIX_MASK;\n \n       adj.base_index = i;\n+      adj.prev_clone_index = i;\n       if (INTEGRAL_TYPE_P (base_type) || POINTER_TYPE_P (base_type))\n \tveclen = sc->vecsize_int;\n       else\n@@ -666,10 +672,10 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \tadj.type = build_vector_type (pointer_sized_int_node, veclen);\n       else\n \tadj.type = build_vector_type (base_type, veclen);\n-      adjustments.safe_push (adj);\n+      vec_safe_push (new_params, adj);\n \n       for (j = veclen; j < sc->simdlen; j += veclen)\n-\tadjustments.safe_push (adj);\n+\tvec_safe_push (new_params, adj);\n \n       /* We have previously allocated one extra entry for the mask.  Use\n \t it and fill it.  */\n@@ -694,7 +700,13 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n     }\n \n   if (node->definition)\n-    ipa_modify_formal_parameters (node->decl, adjustments);\n+    {\n+      ipa_param_body_adjustments *adjustments\n+\t= new ipa_param_body_adjustments (new_params, node->decl);\n+\n+      adjustments->modify_formal_parameters ();\n+      return adjustments;\n+    }\n   else\n     {\n       tree new_arg_types = NULL_TREE, new_reversed;\n@@ -703,12 +715,12 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \tlast_parm_void = true;\n \n       gcc_assert (TYPE_ARG_TYPES (TREE_TYPE (node->decl)));\n-      j = adjustments.length ();\n+      j = vec_safe_length (new_params);\n       for (i = 0; i < j; i++)\n \t{\n-\t  struct ipa_parm_adjustment *adj = &adjustments[i];\n+\t  struct ipa_adjusted_param *adj = &(*new_params)[i];\n \t  tree ptype;\n-\t  if (adj->op == IPA_PARM_OP_COPY)\n+\t  if (adj->op == IPA_PARAM_OP_COPY)\n \t    ptype = args[adj->base_index];\n \t  else\n \t    ptype = adj->type;\n@@ -723,10 +735,8 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t    new_reversed = void_list_node;\n \t}\n       TYPE_ARG_TYPES (TREE_TYPE (node->decl)) = new_reversed;\n-      adjustments.release ();\n+      return NULL;\n     }\n-  args.release ();\n-  return adjustments;\n }\n \n /* Initialize and copy the function arguments in NODE to their\n@@ -735,7 +745,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \n static gimple_seq\n simd_clone_init_simd_arrays (struct cgraph_node *node,\n-\t\t\t     ipa_parm_adjustment_vec adjustments)\n+\t\t\t     ipa_param_body_adjustments *adjustments)\n {\n   gimple_seq seq = NULL;\n   unsigned i = 0, j = 0, k;\n@@ -744,7 +754,7 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n        arg;\n        arg = DECL_CHAIN (arg), i++, j++)\n     {\n-      if (adjustments[j].op == IPA_PARM_OP_COPY\n+      if ((*adjustments->m_adj_params)[j].op == IPA_PARAM_OP_COPY\n \t  || POINTER_TYPE_P (TREE_TYPE (arg)))\n \tcontinue;\n \n@@ -809,7 +819,7 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n /* Callback info for ipa_simd_modify_stmt_ops below.  */\n \n struct modify_stmt_info {\n-  ipa_parm_adjustment_vec adjustments;\n+  ipa_param_body_adjustments *adjustments;\n   gimple *stmt;\n   /* True if the parent statement was modified by\n      ipa_simd_modify_stmt_ops.  */\n@@ -829,15 +839,26 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n   tree *orig_tp = tp;\n   if (TREE_CODE (*tp) == ADDR_EXPR)\n     tp = &TREE_OPERAND (*tp, 0);\n-  struct ipa_parm_adjustment *cand = NULL;\n+\n+  if (TREE_CODE (*tp) == BIT_FIELD_REF\n+      || TREE_CODE (*tp) == IMAGPART_EXPR\n+      || TREE_CODE (*tp) == REALPART_EXPR)\n+    tp = &TREE_OPERAND (*tp, 0);\n+\n+  tree repl = NULL_TREE;\n+  ipa_param_body_replacement *pbr = NULL;\n+\n   if (TREE_CODE (*tp) == PARM_DECL)\n-    cand = ipa_get_adjustment_candidate (&tp, NULL, info->adjustments, true);\n+    {\n+      pbr = info->adjustments->get_expr_replacement (*tp, true);\n+      if (pbr)\n+\trepl = pbr->repl;\n+    }\n   else if (TYPE_P (*tp))\n     *walk_subtrees = 0;\n \n-  tree repl = NULL_TREE;\n-  if (cand)\n-    repl = unshare_expr (cand->new_decl);\n+  if (repl)\n+    repl = unshare_expr (repl);\n   else\n     {\n       if (tp != orig_tp)\n@@ -861,13 +882,13 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n   if (tp != orig_tp)\n     {\n       if (gimple_code (info->stmt) == GIMPLE_PHI\n-\t  && cand\n+\t  && pbr\n \t  && TREE_CODE (*orig_tp) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL\n-\t  && cand->alias_ptr_type)\n+\t  && pbr->dummy)\n \t{\n-\t  gcc_assert (TREE_CODE (cand->alias_ptr_type) == SSA_NAME);\n-\t  *orig_tp = cand->alias_ptr_type;\n+\t  gcc_assert (TREE_CODE (pbr->dummy) == SSA_NAME);\n+\t  *orig_tp = pbr->dummy;\n \t  info->modified = true;\n \t  return NULL_TREE;\n \t}\n@@ -893,10 +914,13 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t  /* Cache SSA_NAME for next time.  */\n-\t  if (cand\n+\t  if (pbr\n \t      && TREE_CODE (*orig_tp) == ADDR_EXPR\n \t      && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL)\n-\t    cand->alias_ptr_type = repl;\n+\t    {\n+\t      gcc_assert (!pbr->dummy);\n+\t      pbr->dummy = repl;\n+\t    }\n \t}\n       else\n \tgsi = gsi_for_stmt (info->stmt);\n@@ -926,70 +950,56 @@ ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n \n static void\n ipa_simd_modify_function_body (struct cgraph_node *node,\n-\t\t\t       ipa_parm_adjustment_vec adjustments,\n+\t\t\t       ipa_param_body_adjustments *adjustments,\n \t\t\t       tree retval_array, tree iter)\n {\n   basic_block bb;\n-  unsigned int i, j, l;\n+  unsigned int i, j;\n \n-  /* Re-use the adjustments array, but this time use it to replace\n-     every function argument use to an offset into the corresponding\n-     simd_array.  */\n+\n+  /* Register replacements for every function argument use to an offset into\n+     the corresponding simd_array.  */\n   for (i = 0, j = 0; i < node->simdclone->nargs; ++i, ++j)\n     {\n-      if (!node->simdclone->args[i].vector_arg)\n+      if (!node->simdclone->args[i].vector_arg\n+\t  || (*adjustments->m_adj_params)[j].user_flag)\n \tcontinue;\n \n       tree basetype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n       tree vectype = TREE_TYPE (node->simdclone->args[i].vector_arg);\n-      adjustments[j].new_decl\n-\t= build4 (ARRAY_REF,\n-\t\t  basetype,\n-\t\t  node->simdclone->args[i].simd_array,\n-\t\t  iter,\n-\t\t  NULL_TREE, NULL_TREE);\n-      if (adjustments[j].op == IPA_PARM_OP_NONE\n-\t  && simd_clone_subparts (vectype) < node->simdclone->simdlen)\n+      tree r = build4 (ARRAY_REF, basetype, node->simdclone->args[i].simd_array,\n+\t\t  iter, NULL_TREE, NULL_TREE);\n+      adjustments->register_replacement (&(*adjustments->m_adj_params)[j], r);\n+\n+      if (simd_clone_subparts (vectype) < node->simdclone->simdlen)\n \tj += node->simdclone->simdlen / simd_clone_subparts (vectype) - 1;\n     }\n \n-  l = adjustments.length ();\n   tree name;\n-\n   FOR_EACH_SSA_NAME (i, name, cfun)\n     {\n+      tree base_var;\n       if (SSA_NAME_VAR (name)\n-\t  && TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL)\n+\t  && TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL\n+\t  && (base_var\n+\t      = adjustments->get_replacement_ssa_base (SSA_NAME_VAR (name))))\n \t{\n-\t  for (j = 0; j < l; j++)\n-\t    if (SSA_NAME_VAR (name) == adjustments[j].base\n-\t\t&& adjustments[j].new_decl)\n-\t      {\n-\t\ttree base_var;\n-\t\tif (adjustments[j].new_ssa_base == NULL_TREE)\n-\t\t  {\n-\t\t    base_var\n-\t\t      = copy_var_decl (adjustments[j].base,\n-\t\t\t\t       DECL_NAME (adjustments[j].base),\n-\t\t\t\t       TREE_TYPE (adjustments[j].base));\n-\t\t    adjustments[j].new_ssa_base = base_var;\n-\t\t  }\n-\t\telse\n-\t\t  base_var = adjustments[j].new_ssa_base;\n-\t\tif (SSA_NAME_IS_DEFAULT_DEF (name))\n-\t\t  {\n-\t\t    bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-\t\t    gimple_stmt_iterator gsi = gsi_after_labels (bb);\n-\t\t    tree new_decl = unshare_expr (adjustments[j].new_decl);\n-\t\t    set_ssa_default_def (cfun, adjustments[j].base, NULL_TREE);\n-\t\t    SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n-\t\t    SSA_NAME_IS_DEFAULT_DEF (name) = 0;\n-\t\t    gimple *stmt = gimple_build_assign (name, new_decl);\n-\t\t    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t\t  }\n-\t\telse\n-\t\t  SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n-\t      }\n+\t  if (SSA_NAME_IS_DEFAULT_DEF (name))\n+\t    {\n+\t      tree old_decl = SSA_NAME_VAR (name);\n+\t      bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\t      gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+\t      tree repl = adjustments->lookup_replacement (old_decl, 0);\n+\t      gcc_checking_assert (repl);\n+\t      repl = unshare_expr (repl);\n+\t      set_ssa_default_def (cfun, old_decl, NULL_TREE);\n+\t      SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n+\t      SSA_NAME_IS_DEFAULT_DEF (name) = 0;\n+\t      gimple *stmt = gimple_build_assign (name, repl);\n+\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t    }\n+\t  else\n+\t    SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n \t}\n     }\n \n@@ -1162,8 +1172,9 @@ simd_clone_adjust (struct cgraph_node *node)\n   targetm.simd_clone.adjust (node);\n \n   tree retval = simd_clone_adjust_return_type (node);\n-  ipa_parm_adjustment_vec adjustments\n+  ipa_param_body_adjustments *adjustments\n     = simd_clone_adjust_argument_types (node);\n+  gcc_assert (adjustments);\n \n   push_gimplify_context ();\n \n@@ -1175,7 +1186,7 @@ simd_clone_adjust (struct cgraph_node *node)\n   tree iter1 = make_ssa_name (iter);\n   tree iter2 = NULL_TREE;\n   ipa_simd_modify_function_body (node, adjustments, retval, iter1);\n-  adjustments.release ();\n+  delete adjustments;\n \n   /* Initialize the iteration variable.  */\n   basic_block entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));"}, {"sha": "d2d957fc6b1552df8785e1b91fef05407acd6e54", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1062,6 +1062,13 @@ DEFPARAM (PARAM_IPA_SRA_PTR_GROWTH_FACTOR,\n \t  \"that ipa-sra replaces a pointer to an aggregate with.\",\n \t  2, 0, 0)\n \n+DEFPARAM (PARAM_IPA_SRA_MAX_REPLACEMENTS,\n+\t  \"ipa-sra-max-replacements\",\n+\t  \"Maximum pieces that IPA-SRA tracks per formal parameter, as \"\n+\t  \"a consequence, also the maximum number of replacements of a formal \"\n+\t  \"parameter.\",\n+\t  8, 0, 16)\n+\n DEFPARAM (PARAM_TM_MAX_AGGREGATE_SIZE,\n \t  \"tm-max-aggregate-size\",\n \t  \"Size in bytes after which thread-local aggregates should be \""}, {"sha": "8999ceec6365752cf97074df570ae88623d6bd48", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -89,7 +89,6 @@ along with GCC; see the file COPYING3.  If not see\n           NEXT_PASS (pass_dse);\n \t  NEXT_PASS (pass_cd_dce);\n \t  NEXT_PASS (pass_phiopt, true /* early_p */);\n-\t  NEXT_PASS (pass_early_ipa_sra);\n \t  NEXT_PASS (pass_tail_recursion);\n \t  NEXT_PASS (pass_convert_switch);\n \t  NEXT_PASS (pass_cleanup_eh);\n@@ -148,6 +147,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_ipa_icf);\n   NEXT_PASS (pass_ipa_devirt);\n   NEXT_PASS (pass_ipa_cp);\n+  NEXT_PASS (pass_ipa_sra);\n   NEXT_PASS (pass_ipa_cdtor_merge);\n   NEXT_PASS (pass_ipa_hsa);\n   NEXT_PASS (pass_ipa_fn_summary);"}, {"sha": "a4323b4b2a7c23da99650a59244e5ae36ba1ed20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,3 +1,43 @@\n+2019-09-20  Martin Jambor  <mjambor@suse.cz>\n+\n+        * g++.dg/ipa/pr81248.C: Adjust dg-options and dump-scan.\n+        * gcc.dg/ipa/ipa-sra-1.c: Likewise.\n+        * gcc.dg/ipa/ipa-sra-10.c: Likewise.\n+        * gcc.dg/ipa/ipa-sra-11.c: Likewise.\n+        * gcc.dg/ipa/ipa-sra-3.c: Likewise.\n+        * gcc.dg/ipa/ipa-sra-4.c: Likewise.\n+        * gcc.dg/ipa/ipa-sra-5.c: Likewise.\n+        * gcc.dg/ipa/ipacost-2.c: Disable ipa-sra.\n+        * gcc.dg/ipa/ipcp-agg-9.c: Likewise.\n+        * gcc.dg/ipa/pr78121.c: Adjust scan pattern.\n+        * gcc.dg/ipa/vrp1.c: Likewise.\n+        * gcc.dg/ipa/vrp2.c: Likewise.\n+        * gcc.dg/ipa/vrp3.c: Likewise.\n+        * gcc.dg/ipa/vrp7.c: Likewise.\n+        * gcc.dg/ipa/vrp8.c: Likewise.\n+        * gcc.dg/noreorder.c: use noipa attribute instead of noinline.\n+        * gcc.dg/ipa/20040703-wpa.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-12.c: New test.\n+\t* gcc.dg/ipa/ipa-sra-13.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-14.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-15.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-16.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-17.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-18.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-19.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-20.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-21.c: Likewise.\n+\t* gcc.dg/ipa/ipa-sra-22.c: Likewise.\n+\t* gcc.dg/sso/ipa-sra-1.c: Likewise.\n+\t* g++.dg/ipa/ipa-sra-2.C: Likewise.\n+\t* g++.dg/ipa/ipa-sra-3.C: Likewise.\n+\t* gcc.dg/tree-ssa/ipa-cp-1.c: Make return value used.\n+\t* g++.dg/ipa/devirt-19.C: Add missing return, add -fipa-cp-clone\n+\toption.\n+\t* g++.dg/lto/devirt-19_0.C: Add -fipa-cp-clone option.\n+\t* gcc.dg/ipa/ipa-sra-2.c: Removed.\n+\t* gcc.dg/ipa/ipa-sra-6.c: Likewise.\n+\n 2019-09-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/91631"}, {"sha": "f35bc32f85b3e4826e294c8389ddd5625a1df092", "filename": "gcc/testsuite/g++.dg/ipa/devirt-19.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-19.C?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -2,7 +2,7 @@\n    Previously we were failing by considering CLOBBER statement to be\n    a type change.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-cp\"  } */\n+/* { dg-options \"-O2 -fdump-ipa-cp -fipa-cp-clone\"  } */\n /* { dg-additional-options \"-Wno-return-type\"  } */\n \n struct A {\n@@ -23,9 +23,12 @@ public:\n \n C<int, int> b;\n template <typename T, typename M> const M &C<T, M>::m_fn2(const T &) {\n+\n   A a = _map.m_fn2();\n   a == _map.m_fn1();\n   m_fn1();\n+  static M m;\n+  return m;\n }\n \n void fn1() { b.m_fn2(0); }"}, {"sha": "ef7d704b3f5d56a5854bf17adee4406b84f78d3b", "filename": "gcc/testsuite/g++.dg/ipa/ipa-sra-1.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-1.C?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fipa-sra\"  } */\n+\n+void fn1(int *, int *, double *, int *, double *);\n+int a, c, d, e, f, g, k;\n+double *b;\n+double h, i;\n+void fn2(int *p1, int *p2, double *p3) {\n+  int l = 0, j, q, r;\n+  double m, n, o, p, s, t, u;\n+  --p3;\n+  for (; a;) {\n+    if (c) {\n+      ++*p2;\n+      goto L170;\n+    }\n+    m = n = b[c];\n+    p = t = m;\n+    for (; j; ++j) {\n+      u = 1.;\n+      if (k) {\n+        s = o;\n+        u = -1.;\n+      }\n+    }\n+    i = u * p;\n+  L60:\n+    p3[1] = s;\n+    for (; d;)\n+      goto L60;\n+    fn1(&f, &g, &h, &l, &p3[1]);\n+    o = p3[1];\n+  L100:\n+    o *= i;\n+    if (e)\n+      goto L100;\n+  L170:;\n+  }\n+  if (*p1)\n+    for (;;) {\n+      if (r)\n+        q = *p2;\n+      d = q - j;\n+      r = j;\n+    }\n+}"}, {"sha": "17bd13ad5c7db79600f58eb072ee9484ef3f3b7a", "filename": "gcc/testsuite/g++.dg/ipa/ipa-sra-2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-2.C?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2 -fipa-sra\"  } */\n+\n+class a {\n+  void b();\n+  char16_t c;\n+  char16_t d;\n+};\n+void e(a);\n+void g();\n+void a::b() {\n+  char16_t f = d;\n+  e(*this);\n+  for (;;) {\n+    g();\n+    if (f)\n+      break;\n+  }\n+}"}, {"sha": "d15ae22cb98deaf933923fa50169a7f6f2e0bd2d", "filename": "gcc/testsuite/g++.dg/ipa/ipa-sra-3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-3.C?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-options \"-O2 -fipa-sra -fno-inline -fno-ipa-cp\"  } */\n+\n+\n+char *a() __attribute__((__malloc__));\n+static char *b() {\n+  char *c = a();\n+  return c;\n+}\n+int d() { b(); return 4; }"}, {"sha": "b79710fc0485e18091c243deae331db3760d32e2", "filename": "gcc/testsuite/g++.dg/ipa/pr81248.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr81248.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr81248.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr81248.C?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile { target c++17 } }\n-// { dg-options \"-O2 -fdump-tree-eipa_sra\" }\n+// { dg-options \"-O2 -fdump-ipa-sra\" }\n \n \n #include <type_traits>\n@@ -37,4 +37,4 @@ int main() {\n     f(n2);\n }\n \n-// { dg-final { scan-tree-dump-times \"Adjusting call\" 2 \"eipa_sra\" } }\n+// { dg-final { scan-ipa-dump \"Will split parameter 0\" \"sra\" } }"}, {"sha": "7d536515437f3c4a64362c188781206379ea2de6", "filename": "gcc/testsuite/g++.dg/lto/devirt-19_0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fdevirt-19_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fdevirt-19_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fdevirt-19_0.C?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-lto-do link } */\n-/* { dg-lto-options { \"-O2 -fdump-ipa-cp -Wno-return-type -flto -r -nostdlib\" } } */\n+/* { dg-lto-options { \"-O2 -fdump-ipa-cp -fipa-cp-clone -Wno-return-type -flto -r -nostdlib\" } } */\n /* { dg-extra-ld-options \"-flinker-output=nolto-rel -flto=auto\" } */\n #include \"../ipa/devirt-19.C\"\n /* { dg-final { scan-wpa-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"cp\"  } } */"}, {"sha": "b1a318be8865cb87cd0d1894299fc68d6fba6c17", "filename": "gcc/testsuite/gcc.dg/ipa/20040703-wpa.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2F20040703-wpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2F20040703-wpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2F20040703-wpa.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,151 @@\n+/* With -fwhole-program this is an excelent testcase for inlining IPA-SRAed\n+   functions into each other.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -w -fno-ipa-cp -fwhole-program\"  } */\n+/* { dg-require-effective-target int32plus } */\n+\n+#define PART_PRECISION (sizeof (cpp_num_part) * 8)\n+\n+typedef unsigned int cpp_num_part;\n+typedef struct cpp_num cpp_num;\n+struct cpp_num\n+{\n+   cpp_num_part high;\n+   cpp_num_part low;\n+   int unsignedp;  /* True if value should be treated as unsigned.  */\n+   int overflow;   /* True if the most recent calculation overflowed.  */\n+};\n+\n+static  int\n+num_positive (cpp_num num, unsigned int precision)\n+{\n+   if (precision > PART_PRECISION)\n+     {\n+       precision -= PART_PRECISION;\n+       return (num.high & (cpp_num_part) 1 << (precision - 1)) == 0;\n+     }\n+\n+   return (num.low & (cpp_num_part) 1 << (precision - 1)) == 0;\n+}\n+\n+static cpp_num\n+num_trim (cpp_num num, unsigned int precision)\n+{\n+   if (precision > PART_PRECISION)\n+     {\n+       precision -= PART_PRECISION;\n+       if (precision < PART_PRECISION)\n+         num.high &= ((cpp_num_part) 1 << precision) - 1;\n+     }\n+   else\n+     {\n+       if (precision < PART_PRECISION)\n+         num.low &= ((cpp_num_part) 1 << precision) - 1;\n+       num.high = 0;\n+     }\n+\n+   return num;\n+}\n+\n+/* Shift NUM, of width PRECISION, right by N bits.  */\n+static cpp_num\n+num_rshift (cpp_num num, unsigned int precision, unsigned int n)\n+{\n+   cpp_num_part sign_mask;\n+   int x = num_positive (num, precision);\n+\n+   if (num.unsignedp || x)\n+     sign_mask = 0;\n+   else\n+     sign_mask = ~(cpp_num_part) 0;\n+\n+   if (n >= precision)\n+     num.high = num.low = sign_mask;\n+   else\n+     {\n+       /* Sign-extend.  */\n+       if (precision < PART_PRECISION)\n+         num.high = sign_mask, num.low |= sign_mask << precision;\n+       else if (precision < 2 * PART_PRECISION)\n+         num.high |= sign_mask << (precision - PART_PRECISION);\n+\n+       if (n >= PART_PRECISION)\n+         {\n+           n -= PART_PRECISION;\n+           num.low = num.high;\n+           num.high = sign_mask;\n+         }\n+\n+       if (n)\n+         {\n+           num.low = (num.low >> n) | (num.high << (PART_PRECISION - n));\n+           num.high = (num.high >> n) | (sign_mask << (PART_PRECISION - n));\n+         }\n+     }\n+\n+   num = num_trim (num, precision);\n+   num.overflow = 0;\n+   return num;\n+}\n+                              #define num_zerop(num) ((num.low | num.high) == 0)\n+#define num_eq(num1, num2) (num1.low == num2.low && num1.high == num2.high)\n+\n+cpp_num\n+num_lshift (cpp_num num, unsigned int precision, unsigned int n)\n+{\n+   if (n >= precision)\n+     {\n+       num.overflow = !num.unsignedp && !num_zerop (num);\n+       num.high = num.low = 0;\n+     }\n+   else\n+     {\n+       cpp_num orig;\n+       unsigned int m = n;\n+\n+       orig = num;\n+       if (m >= PART_PRECISION)\n+         {\n+           m -= PART_PRECISION;\n+           num.high = num.low;\n+           num.low = 0;\n+         }\n+       if (m)\n+         {\n+           num.high = (num.high << m) | (num.low >> (PART_PRECISION - m));\n+           num.low <<= m;\n+         }\n+       num = num_trim (num, precision);\n+\n+       if (num.unsignedp)\n+         num.overflow = 0;\n+       else\n+         {\n+           cpp_num maybe_orig = num_rshift (num, precision, n);\n+           num.overflow = !num_eq (orig, maybe_orig);\n+         }\n+     }\n+\n+   return num;\n+}\n+\n+unsigned int precision = 64;\n+unsigned int n = 16;\n+\n+cpp_num num = { 0, 3, 0, 0 };\n+\n+int main()\n+{\n+   cpp_num res = num_lshift (num, 64, n);\n+\n+   if (res.low != 0x30000)\n+     abort ();\n+\n+   if (res.high != 0)\n+     abort ();\n+\n+   if (res.overflow != 0)\n+     abort ();\n+\n+   exit (0);\n+}"}, {"sha": "4a22e3978f9233ae6635de8cce3070846b5466a5", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\"  } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra-details\"  } */\n \n struct bovid\n {\n@@ -36,4 +36,4 @@ main (int argc, char *argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"About to replace expr\" 2 \"eipa_sra\" } } */\n+/* { dg-final { scan-ipa-dump \"Will split parameter\" \"sra\" } } */"}, {"sha": "b5535cfffffdf63166b5a873b0a440b3ca9d70f2", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-10.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\"  } */\n+/* { dg-options \"-O2 -fno-ipa-cp -fipa-sra -fdump-ipa-sra\"  } */\n \n extern void consume (int);\n extern int glob, glob1, glob2;\n@@ -31,4 +31,4 @@ bar (int a)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"replacing an SSA name of a removed param\" 4 \"eipa_sra\" } } */\n+/* { dg-final { scan-ipa-dump \"Will remove parameter 0\" \"sra\" } } */"}, {"sha": "61c02c1c47cebd5800e815be00c9560b06606e8d", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-11.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-11.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\"  } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra-details\"  } */\n \n struct bovid\n {\n@@ -36,4 +36,4 @@ main (int argc, char *argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-not \"About to replace expr\" \"eipa_sra\" } } */\n+/* { dg-final { scan-ipa-dump-not \"Will split parameter\" \"sra\" } } */"}, {"sha": "689071e566c4eada8f9ce1ddf53c9c7d1b93c8b1", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-12.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-12.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra\"  } */\n+\n+/* Check of a simple and transitive structure split. */\n+\n+struct S\n+{\n+  float red;\n+  void *blue;\n+  int green;\n+};\n+\n+\n+void __attribute__((noipa))\n+check (float r, int g, int g2)\n+{\n+  if (r < 7.39 || r > 7.41\n+      || g != 6 || g2 != 6)\n+    __builtin_abort ();\n+}\n+\n+static void\n+__attribute__((noinline))\n+foo (struct S s)\n+{\n+  check (s.red, s.green, s.green);\n+}\n+\n+static void\n+__attribute__((noinline))\n+bar (struct S s)\n+{\n+  foo (s);\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  struct S s;\n+\n+  s.red = 7.4;\n+  s.green = 6;\n+  s.blue = &s;\n+\n+  bar (s);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\" } } */\n+/* { dg-final { scan-ipa-dump-times \"component at byte offset\" 4 \"sra\" } } */"}, {"sha": "4d4ed74cfd6ac40dd982912e4bc7f4a3b64fddc1", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-13.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-13.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra\"  } */\n+\n+/* Check of a by-reference structure split. */\n+\n+struct S\n+{\n+  float red;\n+  void *blue;\n+  int green;\n+};\n+\n+void __attribute__((noipa))\n+check (float r, int g, int g2)\n+{\n+  if (r < 7.39 || r > 7.41\n+      || g != 6 || g2 != 6)\n+    __builtin_abort ();\n+}\n+\n+static void\n+__attribute__((noinline))\n+foo (struct S *s)\n+{\n+  check (s->red, s->green, s->green);\n+}\n+\n+static void\n+__attribute__((noinline))\n+bar (struct S *s)\n+{\n+  foo (s);\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  struct S s;\n+\n+  s.red = 7.4;\n+  s.green = 6;\n+  s.blue = &s;\n+\n+  bar (&s);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\" } } */\n+/* { dg-final { scan-ipa-dump-times \"component at byte offset\" 4 \"sra\" } } */"}, {"sha": "01881249d90cd925822fc12e17c9fad8649166f0", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-14.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-14.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra\"  } */\n+\n+/* Check of a transitive recursive structure split. */\n+\n+struct S\n+{\n+  float red;\n+  void *blue;\n+  int green;\n+};\n+\n+\n+static int done = 0;\n+\n+void __attribute__((noipa))\n+check (float r, int g, int g2)\n+{\n+  if (r < 7.39 || r > 7.41\n+      || g != 6 || g2 != 6)\n+    __builtin_abort ();\n+}\n+\n+static void __attribute__((noinline)) bar (struct S s);\n+\n+static void\n+__attribute__((noinline))\n+foo (struct S s)\n+{\n+  if (!done)\n+    {\n+      done = 1;\n+      bar (s);\n+    }\n+  check (s.red, s.green, s.green);\n+}\n+\n+static void\n+__attribute__((noinline))\n+bar (struct S s)\n+{\n+  foo (s);\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  struct S s;\n+\n+  s.red = 7.4;\n+  s.green = 6;\n+  s.blue = &s;\n+\n+  bar (s);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\" } } */\n+/* { dg-final { scan-ipa-dump-times \"component at byte offset\" 4 \"sra\" } } */"}, {"sha": "6c57c7bcebcb123c19791420e5bbca2d1685e999", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-15.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-15.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra\"  } */\n+\n+/* Check of a recursive by-reference structure split.  The recursive functions\n+   have to be pure right from the start, otherwise the current AA would detect\n+   possible modification of data.  */\n+\n+struct S\n+{\n+  float red;\n+  void *blue;\n+  int green;\n+};\n+\n+void __attribute__((noipa))\n+check (float r, int g, int g2)\n+{\n+  if (r < 7.39 || r > 7.41\n+      || g != 6 || g2 != 6)\n+    __builtin_abort ();\n+  return;\n+}\n+\n+static int __attribute__((noinline, pure)) bar (struct S *s, int rec);\n+\n+static int\n+__attribute__((noinline, pure))\n+foo (struct S *s , int rec)\n+{\n+  int t = 0;\n+  if (rec)\n+    t = bar (s, 0);\n+  check (s->red, s->green, s->green);\n+  return t;\n+}\n+\n+static int\n+__attribute__((noinline, pure))\n+bar (struct S *s, int rec)\n+{\n+  int t = foo (s, rec);\n+  return t + t;\n+}\n+\n+volatile int g;\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  struct S s;\n+\n+  s.red = 7.4;\n+  s.green = 6;\n+  s.blue = &s;\n+\n+  g = bar (&s, 1);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\" } } */\n+/* { dg-final { scan-ipa-dump-times \"component at byte offset\" 4 \"sra\" } } */"}, {"sha": "2bffe297c745603883ab685824857306a920d441", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-16.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-16.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra -fdump-tree-optimized\"  } */\n+\n+/* Testing removal of unused parameters in recursive calls.  */\n+\n+extern int work_1 (int);\n+extern int work_2 (int);\n+\n+static int __attribute__((noinline))\n+foo (int l, int w1, int w2, int useless, int useless2);\n+\n+\n+static int __attribute__((noinline))\n+bar_1 (int l, int w1, int w2, int useless, int useless2)\n+{\n+  return work_1 (w1) + foo (l, w1, w2, useless2, useless);\n+}\n+\n+static int __attribute__((noinline))\n+baz_1 (int useless, int useless2, int l, int w1, int w2)\n+{\n+  return bar_1 (l, w1, w2, useless, useless2);\n+}\n+\n+static int __attribute__((noinline))\n+bax_1 (int l, int w1, int w2, int useless, int useless2)\n+{\n+  return baz_1 (useless, useless2, l, w1, w2);\n+}\n+\n+\n+\n+static int __attribute__((noinline))\n+bar_2 (int l, int w1, int w2, int useless, int useless2)\n+{\n+  return foo (l, w1, w2, useless2 + 5, useless);\n+}\n+\n+static int __attribute__((noinline))\n+baz_2 (int useless, int useless2, int l, int w1, int w2)\n+{\n+  return bar_2 (l, w1, w2, useless, useless2);\n+}\n+\n+\n+static int __attribute__((noinline))\n+bax_2 (int l, int w1, int w2, int useless, int useless2)\n+{\n+  return work_2 (w2) + baz_2 (useless, useless2, l, w1, w2);\n+}\n+\n+\n+static int __attribute__((noinline))\n+ foo (int l, int w1, int w2, int useless, int useless2)\n+{\n+  int r = 0;\n+  if (!l)\n+    return r;\n+  if (l % 2)\n+    r = bax_1 (l - 1, w1, w2, useless, useless2);\n+  else\n+    r = bax_2 (l - 1, w1, w2, useless, useless2);\n+\n+  return r;\n+}\n+\n+int\n+entry (int l, int w1, int w2, int noneed, int noneed2)\n+{\n+  return foo (l, w2, w2, noneed2, noneed2 + 4);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will remove parameter\" 14 \"sra\" } } */\n+/* { dg-final { scan-tree-dump-not \"useless\" \"optimized\"} } */"}, {"sha": "9cb6367b37478f895d9c7f62cb3f1a369b7f4a79", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-17.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-17.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra -fdump-tree-optimized\"  } */\n+\n+#define DOIT\n+#define DONT\n+\n+\n+extern int extern_leaf (int);\n+\n+/* ----- 1 ----- */\n+#ifdef DOIT\n+static int __attribute__((noinline))\n+whee_1 (int i, int j)\n+{\n+  return extern_leaf (i * j) + 1;\n+}\n+\n+static int foo_1 (int i, int j);\n+\n+static int __attribute__((noinline))\n+baz_1 (int i, int j)\n+{\n+  int a = 5;\n+  if (j)\n+    a = foo_1 (i, j - 1);\n+  return whee_1 (i, j) + a + 1;\n+}\n+\n+static int __attribute__((noinline))\n+bar_1 (int i, int j)\n+{\n+  return baz_1 (i, j) + 1;\n+}\n+\n+static int __attribute__((noinline))\n+foo_1 (int i, int j)\n+{\n+  return bar_1 (i, j) + 1;\n+}\n+\n+static int __attribute__((noinline))\n+inter_1 (int i, int j)\n+{\n+  return foo_1 (i, j) + 1;\n+}\n+#endif\n+\n+/* ----- 2 ----- */\n+#ifdef DONT\n+static int __attribute__((noinline))\n+whee_2 (int i, int j)\n+{\n+  return extern_leaf (i * j) + 2;\n+}\n+\n+static int foo_2 (int i, int j);\n+\n+static int __attribute__((noinline))\n+baz_2 (int i, int j)\n+{\n+  int a = 6;\n+  if (j)\n+    a = foo_2 (i, j - 1);\n+  return whee_2 (i, j) + a + 2;\n+}\n+\n+static int __attribute__((noinline))\n+bar_2 (int i, int j)\n+{\n+  return baz_2 (i, j) + 2;\n+}\n+\n+static int __attribute__((noinline))\n+foo_2 (int i, int j)\n+{\n+  return bar_2 (i, j) + 2;\n+}\n+#endif\n+\n+/* ----- entries ----- */\n+#ifdef DOIT\n+int\n+entry_1 (int i, int j)\n+{\n+  inter_1 (i, j);\n+  return i + j + 1;\n+}\n+#endif\n+\n+#ifdef DONT\n+int\n+entry_2 (int i, int j)\n+{\n+#ifdef DOIT\n+  inter_1 (i, j);\n+#endif\n+  return i + j + bar_2 (i, j);\n+}\n+#endif\n+\n+/* { dg-final { scan-ipa-dump-times \"Will remove return value\" 5 \"sra\" } } */\n+/* { dg-final { scan-tree-dump-times \"return;\" 5 \"optimized\"} } */"}, {"sha": "3217b612231a2f10bded06a41adbea3f2d361c9c", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-18.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-18.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra\"  } */\n+\n+struct S\n+{\n+  long a, b;\n+};\n+\n+extern void leaf_a (int );\n+extern void leaf_b (int, int);\n+extern void leaf_c (int, int);\n+\n+extern void leaf_sa (struct S);\n+\n+static void baz (int i, int j, int k, int l, struct S a, struct S b);\n+\n+extern int gi;\n+\n+static void  __attribute__((noinline))\n+foo (int i, int j, int k, int l, struct S a, struct S b)\n+{\n+  gi += l;\n+  baz (i, j, k, l, a, b);\n+}\n+\n+static void __attribute__((noinline))\n+bar (int i, int j, int k, int l, struct S a, struct S b)\n+{\n+  foo (i, j, k, l, a, b);\n+  leaf_sa (b);\n+}\n+\n+\n+static void __attribute__((noinline))\n+baz (int i, int j, int k, int l, struct S a, struct S b)\n+{\n+  if (--k)\n+    bar (i, j, k, l, a, b);\n+  leaf_b (i, k);\n+}\n+\n+void\n+entry (int i, int j, int k, int l, struct S a, struct S b)\n+{\n+  foo (i, j, k, l, a, b);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will remove parameter 1\" 3 \"sra\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Will remove parameter 4\" 3 \"sra\" } } */"}, {"sha": "adebaa5f5e1820d1e89016bc5f12a18f30954a3b", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-19.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-19.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\"  } */\n+\n+typedef int __attribute__((__vector_size__(16))) vectype;\n+\n+vectype dk();\n+vectype k();\n+\n+int b;\n+vectype *j;\n+inline int c(vectype *d) {\n+  vectype e;\n+  vectype f;\n+  vectype g = *d;\n+  vectype h = g;\n+  vectype i = h;\n+  f = i == dk();\n+  e = f == b;\n+  k(e);\n+}\n+\n+static void m(vectype *d) {\n+  int l = c(d);\n+  if (l)\n+    c(j);\n+}\n+\n+void o(void) {\n+  vectype n;\n+  m(&n);\n+}"}, {"sha": "a31945c9c5259290e0b63d1e2aedea6f92fca71a", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-2.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-2.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -1,51 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\"  } */\n-\n-struct bovid\n-{\n-  float red;\n-  int green;\n-  void *blue;\n-};\n-\n-static int\n-__attribute__((noinline))\n-ox (struct bovid *cow)\n-{\n-  cow->red = cow->red + cow->green + cow->green;\n-  return 0;\n-}\n-\n-int something;\n-\n-static int\n-__attribute__((noinline))\n-ox_improved (struct bovid *calf)\n-{\n-  if (something > 0)\n-    calf->red = calf->red + calf->green;\n-  else\n-    calf->red = calf->green + 87;\n-  something = 77;\n-  return 0;\n-}\n-\n-\n-int main (int argc, char *argv[])\n-{\n-  struct bovid cow;\n-\n-  cow.red = 7.4;\n-  cow.green = 6;\n-  cow.blue = &cow;\n-\n-  ox (&cow);\n-\n-  ox_improved (&cow);\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump \"About to replace expr cow_.*D.->red with \\\\*ISRA\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump \"About to replace expr cow_.*D.->green with ISRA\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump \"About to replace expr calf_.*D.->red with \\\\*ISRA\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump \"About to replace expr calf_.*D.->green with ISRA\" \"eipa_sra\"  } } */"}, {"sha": "a47df4f5c85b059099cebe21bd7df7be90906df3", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-20.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-20.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fipa-sra\" } */\n+\n+typedef struct {\n+  int a;\n+} b;\n+typedef struct {\n+  double c;\n+  double a;\n+} d;\n+typedef struct {\n+  d e;\n+  d f;\n+} g;\n+g h;\n+b i, m;\n+int j, k, l, n, o;\n+static b q(d s) {\n+  int r = s.c ?: 0;\n+  if (r)\n+    if (j)\n+      l = j - 2;\n+  o = k;\n+  n = l;\n+  i = m;\n+  return m;\n+}\n+static void t(g s) {\n+  {\n+    d p = s.e;\n+    int r = p.c ?: 0;\n+    if (r) {\n+      l = j - 2;\n+    }\n+  }\n+  b f = q(s.f);\n+}\n+void main() { t(h); }"}, {"sha": "67806b866fee07374e289baf89af0746270bd9c2", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-21.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-21.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef int a;\n+typedef int b;\n+int c, e;\n+void i();\n+void n(d, ab, f, ae, af, action, ag, ah, ai, g, h, aj, ak, al, j, k, am, an, ao,\n+       l, m) int action,\n+    ag;\n+int f, ae, af;\n+int ah, ai;\n+int j, k;\n+int l, m;\n+a aj, am;\n+int ak, al, an, ao, g, h;\n+char d, ab;\n+{\n+  if (c)\n+    i(e);\n+}\n+void o(d, ab, action, at, ag, g, h, aj, ak, al, au, av, am, an, ao, aw, ax, ay,\n+       az, ba, bb, ai) int action,\n+    ag;\n+int at, ai;\n+int au, av, aw, ax;\n+b ay, ba;\n+int az, bb;\n+int g, h;\n+int ak, al, an, ao;\n+a aj, am;\n+char d, ab;\n+{ n(); }"}, {"sha": "0d6a35360670a4e7e9db81c72ca56c2599da3ecc", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-22.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-22.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fipa-sra\"  } */\n+\n+struct W\n+{\n+  int a, b;\n+};\n+\n+union U\n+{\n+  struct W w;\n+  long l;\n+};\n+\n+struct Z\n+{\n+  int k;\n+  union U u;\n+};\n+\n+struct S\n+{\n+  int i, j;\n+  struct Z z;\n+  char buf[64];\n+};\n+\n+struct W gw;\n+\n+\n+static long\n+__attribute__((noinline))\n+foo (struct Z z)\n+{\n+  return z.u.l;\n+}\n+\n+static long\n+__attribute__((noinline))\n+bar (struct S s)\n+{\n+  if (s.i > 100)\n+    return s.z.u.w.a;\n+  else\n+    return  foo (s.z);\n+}\n+\n+volatile long g;\n+\n+long\n+entry (struct S *p)\n+{\n+  struct S s = *p;\n+\n+  return bar (s) | 2;\n+}"}, {"sha": "203650cfb4050d342b335edcc287e7df97c814d4", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-3.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-3.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\" } */\n+/* { dg-options \"-O2 -fno-ipa-cp -fipa-sra -fdump-ipa-sra\" } */\n \n struct bovid\n {\n@@ -34,5 +34,6 @@ void caller (void)\n   return;\n }\n \n-/* { dg-final { scan-tree-dump \"base: z, remove_param\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump \"base: calf, remove_param\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-ipa-dump \"Will split parameter 0\" \"sra\"  } } */\n+/* { dg-final { scan-ipa-dump \"Will remove parameter 1\" \"sra\" } } */\n+/* { dg-final { scan-ipa-dump \"Will remove parameter 2\" \"sra\" } } */"}, {"sha": "fdbd5e5d72dd4b5f9bd35d3069ded39b7c4eed8e", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-4.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-4.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\" } */\n+/* { dg-options \"-O2 -fipa-sra -fno-ipa-pure-const -fdump-ipa-sra\" } */\n \n static int\n __attribute__((noinline))\n@@ -61,7 +61,5 @@ void caller (void)\n   return;\n }\n \n-/* { dg-final { scan-tree-dump \"About to replace expr \\\\*i_.*D. with ISRA\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump \"About to replace expr \\\\*l_.*D. with ISRA\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump-times \"About to replace expr \\*j_.*D. with ISRA\" 0 \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump-times \"About to replace expr \\*k_.*D. with ISRA\" 0 \"eipa_sra\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\"  } } */\n+"}, {"sha": "8a7568119b1907d72f02b7ab28f3369e11529ab5", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-5.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-details\" } */\n+/* { dg-options \"-O2 -fipa-sra -fdump-ipa-sra\" } */\n \n static int *\n __attribute__((noinline,used))\n@@ -16,4 +16,4 @@ int *caller (void)\n \n   return ox (&a, &b);\n }\n-/* { dg-final { scan-tree-dump-times \"base: j, remove_param\" 0 \"eipa_sra\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 0 \"sra\"  } } */"}, {"sha": "89909f03307e1da9d1a8e97e4703ef0b369aec90", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-6.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-6.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -1,33 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fipa-sra -fdump-tree-eipa_sra-slim\"  } */\n-/* { dg-require-effective-target non_strict_align } */\n-\n-struct bovid\n-{\n-  float a;\n-  int b;\n-  struct bovid *next;\n-};\n-\n-static int\n-__attribute__((noinline))\n-foo (struct bovid *cow, int i)\n-{\n-  i++;\n-  if (cow->next)\n-    foo (cow->next, i);\n-  return i;\n-}\n-\n-int main (int argc, char *argv[])\n-{\n-  struct bovid cow;\n-\n-  cow.a = 7.4;\n-  cow.b = 6;\n-  cow.next = (struct bovid *) 0;\n-\n-  return foo (&cow, 0);\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"foo \" 1 \"eipa_sra\"  } } */"}, {"sha": "e0501db1ae5501adb0edafd6728152e850fb5517", "filename": "gcc/testsuite/gcc.dg/ipa/ipacost-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining -fdump-tree-optimized -fno-ipa-icf\"  } */\n+/* { dg-options \"-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining -fno-ipa-sra -fdump-tree-optimized -fno-ipa-icf\"  } */\n /* { dg-add-options bind_pic_locally } */\n \n int array[100];\n@@ -72,7 +72,7 @@ main()\n }\n \n /* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully2\" 1 \"cp\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully/\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of i_can_be_propagated_fully\\[./\\]\" 1 \"cp\"  } } */\n /* { dg-final { scan-ipa-dump-not \"Creating a specialized node of i_can_not_be_propagated_fully2\" \"cp\"  } } */\n /* { dg-final { scan-ipa-dump-not \"Creating a specialized node of i_can_not_be_propagated_fully/\" \"cp\"  } } */\n /* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully \\\\(\" \"optimized\"  } } */"}, {"sha": "c69a285b287812ce4f1859db81bf4de73eaa7cf6", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-9.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -1,6 +1,6 @@\n /* Verify that IPA-CP can make edges direct based on aggregate contents.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fno-early-inlining -fdump-ipa-cp -fdump-ipa-inline\"  } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-ipa-sra -fdump-ipa-cp -fdump-ipa-inline\"  } */\n \n struct S\n {"}, {"sha": "19d6eda22f83c411c248dd08d6c01f348fa30f88", "filename": "gcc/testsuite/gcc.dg/ipa/pr78121.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr78121.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr78121.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr78121.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -13,4 +13,4 @@ static void fn1(c) unsigned char c;\n \n void fn3() { fn1 (267); }\n \n-/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\\\[11, 35\\\\\\]\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[11, 35\\\\\\]\" \"cp\" } } */"}, {"sha": "e32a13c3d6afb7754bddd29a4c26f4404d1fdadb", "filename": "gcc/testsuite/gcc.dg/ipa/vrp1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp1.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -28,5 +28,5 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\\\[6,\" \"cp\" } } */\n-/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\\\[0, 999\\\\\\]\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[6,\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[0, 999\\\\\\]\" \"cp\" } } */"}, {"sha": "31909bdbf2409566b0949bcda7fb58d46bcbffbc", "filename": "gcc/testsuite/gcc.dg/ipa/vrp2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp2.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -31,5 +31,5 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\\\[4,\" \"cp\" } } */\n-/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\\\[0, 11\\\\\\]\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[4,\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[0, 11\\\\\\]\" \"cp\" } } */"}, {"sha": "9b1dcf98b259649a86f4a9ea10330afe181c53c2", "filename": "gcc/testsuite/gcc.dg/ipa/vrp3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp3.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -27,4 +27,4 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\\\[0, 9\\\\\\]\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[0, 9\\\\\\]\" 2 \"cp\" } } */"}, {"sha": "ca5aa29e975c500ccced5b7b10e98a00437bd2cb", "filename": "gcc/testsuite/gcc.dg/ipa/vrp7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp7.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -29,4 +29,4 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\\\[-10, 9\\\\\\]\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[-10, 9\\\\\\]\" 1 \"cp\" } } */"}, {"sha": "0ac5fb5277d2c8a6b7821ecba3852963d8b84d6b", "filename": "gcc/testsuite/gcc.dg/ipa/vrp8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fvrp8.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -39,4 +39,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\\\[-10, 9\\\\\\]\" 1 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Setting value range of param 0 \\\\(now 0\\\\) \\\\\\[-10, 9\\\\\\]\" 1 \"cp\" } } */"}, {"sha": "e413b689dd61d64e1aa900a433347f3d913210ce", "filename": "gcc/testsuite/gcc.dg/noreorder.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreorder.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -13,22 +13,22 @@ static int func2(void);\n \n asm(\"firstasm\");\n \n-NOREORDER __attribute__((noinline)) int bozo(void)\n+NOREORDER __attribute__((noipa)) int bozo(void)\n {\n   f2(3);\n   func2();\n }\n \n asm(\"jukjuk\");\n \n-NOREORDER __attribute__((noinline)) static int func1(void)\n+NOREORDER __attribute__((noipa)) static int func1(void)\n {\n   f2(1);\n }\n \n asm(\"barbar\");\n \n-NOREORDER __attribute__((noinline)) static int func2(void)\n+NOREORDER __attribute__((noipa)) static int func2(void)\n {\n   func1();\n }"}, {"sha": "6712141dd163e486045ba1cb670e170fa39d2afd", "filename": "gcc/testsuite/gcc.dg/sso/ipa-sra-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fipa-sra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fipa-sra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fipa-sra-1.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-sra\" } */\n+\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) LE\n+{\n+  int i;\n+  int j;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) BE\n+{\n+  int i;\n+  int j;\n+};\n+\n+struct LE gle;\n+struct BE gbe;\n+\n+#define VAL 0x12345678\n+\n+void __attribute__((noipa))\n+fill (void)\n+{\n+  gle.i = VAL;\n+  gle.j = 0xdeadbeef;\n+  gbe.i = VAL;\n+  gbe.j = 0x11223344;\n+}\n+\n+static int __attribute__((noinline))\n+readLE (struct LE p)\n+{\n+  return p.i;\n+}\n+\n+static int __attribute__((noinline))\n+readBE (struct BE p)\n+{\n+  return p.i;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int r;\n+  fill ();\n+\n+  r = readLE (gle);\n+  if (r != VAL)\n+    __builtin_abort ();\n+  r = readBE (gbe);\n+  if (r != VAL)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "56b7f9fac90d3ebf3b0e87a297cb58aa61d1476d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-cp-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-cp-1.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -14,7 +14,7 @@ very_long_function(int a)\n int\n blah ()\n {\n-  very_long_function (1);\n+  return very_long_function (1);\n }\n /* One appearance for dump, one self recursive call and one call from main.  */\n /* { dg-final { scan-tree-dump-times \"very_long_function.constprop \\\\(\\\\)\" 3 \"optimized\"} } */"}, {"sha": "4a3f130e8761de484d9017c7b3467c9ef850f664", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -5009,8 +5009,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \t}\n \n       tree_function_versioning (old_decl, new_decl,\n-\t\t\t\tNULL, false, NULL,\n-\t\t\t\tfalse, NULL, NULL);\n+\t\t\t\tNULL,  NULL, false, NULL, NULL);\n     }\n \n   record_tm_clone_pair (old_decl, new_decl);"}, {"sha": "e4ae1b058fd7898ae12eb6af1c357c678f1c2834", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 247, "deletions": 138, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -130,7 +130,6 @@ static void copy_bind_expr (tree *, int *, copy_body_data *);\n static void declare_inline_vars (tree, tree);\n static void remap_save_expr (tree *, hash_map<tree, tree> *, int *);\n static void prepend_lexical_block (tree current_block, tree new_block);\n-static tree copy_decl_to_var (tree, copy_body_data *);\n static tree copy_result_decl_to_var (tree, copy_body_data *);\n static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n static gimple_seq remap_gimple_stmt (gimple *, copy_body_data *);\n@@ -192,7 +191,21 @@ remap_ssa_name (tree name, copy_body_data *id)\n \n   n = id->decl_map->get (name);\n   if (n)\n-    return unshare_expr (*n);\n+    {\n+      /* WHen we perform edge redirection as part of CFG copy, IPA-SRA can\n+\t remove an unused LHS from a call statement.  Such LHS can however\n+\t still appear in debug statements, but their value is lost in this\n+\t function and we do not want to map them.  */\n+      if (id->killed_new_ssa_names\n+\t  && id->killed_new_ssa_names->contains (*n))\n+\t{\n+\t  gcc_assert (processing_debug_stmt);\n+\t  processing_debug_stmt = -1;\n+\t  return name;\n+\t}\n+\n+      return unshare_expr (*n);\n+    }\n \n   if (processing_debug_stmt)\n     {\n@@ -1902,6 +1915,21 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n       gcc_assert (n);\n       gimple_set_block (copy, *n);\n     }\n+  if (id->param_body_adjs)\n+    {\n+      gimple_seq extra_stmts = NULL;\n+      id->param_body_adjs->modify_gimple_stmt (&copy, &extra_stmts);\n+      if (!gimple_seq_empty_p (extra_stmts))\n+\t{\n+\t  memset (&wi, 0, sizeof (wi));\n+\t  wi.info = id;\n+\t  for (gimple_stmt_iterator egsi = gsi_start (extra_stmts);\n+\t       !gsi_end_p (egsi);\n+\t       gsi_next (&egsi))\n+\t    walk_gimple_op (gsi_stmt (egsi), remap_gimple_op_r, &wi);\n+\t  gimple_seq_add_seq (&stmts, extra_stmts);\n+\t}\n+    }\n \n   if (id->reset_location)\n     gimple_set_location (copy, input_location);\n@@ -2865,10 +2893,24 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n       gimple *stmt = gsi_stmt (si);\n       if (is_gimple_call (stmt))\n \t{\n+\t  tree old_lhs = gimple_call_lhs (stmt);\n \t  struct cgraph_edge *edge = id->dst_node->get_edge (stmt);\n \t  if (edge)\n \t    {\n-\t      edge->redirect_call_stmt_to_callee ();\n+\t      gimple *new_stmt = edge->redirect_call_stmt_to_callee ();\n+\t      /* If IPA-SRA transformation, run as part of edge redirection,\n+\t\t removed the LHS because it is unused, save it to\n+\t\t killed_new_ssa_names so that we can prune it from debug\n+\t\t statements.  */\n+\t      if (old_lhs\n+\t\t  && TREE_CODE (old_lhs) == SSA_NAME\n+\t\t  && !gimple_call_lhs (new_stmt))\n+\t\t{\n+\t\t  if (!id->killed_new_ssa_names)\n+\t\t    id->killed_new_ssa_names = new hash_set<tree> (16);\n+\t\t  id->killed_new_ssa_names->add (old_lhs);\n+\t\t}\n+\n \t      if (stmt == last && id->call_stmt && maybe_clean_eh_stmt (stmt))\n \t\tgimple_purge_dead_eh_edges (bb);\n \t    }\n@@ -3189,6 +3231,8 @@ copy_body (copy_body_data *id,\n   body = copy_cfg_body (id, entry_block_map, exit_block_map,\n \t\t\tnew_entry);\n   copy_debug_stmts (id);\n+  delete id->killed_new_ssa_names;\n+  id->killed_new_ssa_names = NULL;\n \n   return body;\n }\n@@ -4908,6 +4952,38 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n   /* Add local vars in this inlined callee to caller.  */\n   add_local_variables (id->src_cfun, cfun, id);\n \n+  if (id->src_node->clone.performed_splits)\n+    {\n+      /* Any calls from the inlined function will be turned into calls from the\n+\t function we inline into.  We must preserve notes about how to split\n+\t parameters such calls should be redirected/updated.  */\n+      unsigned len = vec_safe_length (id->src_node->clone.performed_splits);\n+      for (unsigned i = 0; i < len; i++)\n+\t{\n+\t  ipa_param_performed_split ps\n+\t    = (*id->src_node->clone.performed_splits)[i];\n+\t  ps.dummy_decl = remap_decl (ps.dummy_decl, id);\n+\t  vec_safe_push (id->dst_node->clone.performed_splits, ps);\n+\t}\n+\n+      if (flag_checking)\n+\t{\n+\t  len = vec_safe_length (id->dst_node->clone.performed_splits);\n+\t  for (unsigned i = 0; i < len; i++)\n+\t    {\n+\t      ipa_param_performed_split *ps1\n+\t\t= &(*id->dst_node->clone.performed_splits)[i];\n+\t      for (unsigned j = i + 1; j < len; j++)\n+\t\t{\n+\t\t  ipa_param_performed_split *ps2\n+\t\t    = &(*id->dst_node->clone.performed_splits)[j];\n+\t\t  gcc_assert (ps1->dummy_decl != ps2->dummy_decl\n+\t\t\t      || ps1->unit_offset != ps2->unit_offset);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   if (dump_enabled_p ())\n     {\n       char buf[128];\n@@ -5733,7 +5809,11 @@ copy_decl_for_dup_finish (copy_body_data *id, tree decl, tree copy)\n   return copy;\n }\n \n-static tree\n+/* Create a new VAR_DECL that is indentical in all respect to DECL except that\n+   DECL can be either a VAR_DECL, a PARM_DECL or RESULT_DECL.  The original\n+   DECL must come from ID->src_fn and the copy will be part of ID->dst_fn.  */\n+\n+tree\n copy_decl_to_var (tree decl, copy_body_data *id)\n {\n   tree copy, type;\n@@ -5816,38 +5896,24 @@ copy_decl_maybe_to_var (tree decl, copy_body_data *id)\n     return copy_decl_no_change (decl, id);\n }\n \n-/* Return a copy of the function's argument tree.  */\n+/* Return a copy of the function's argument tree without any modifications.  */\n+\n static tree\n-copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n-\t\t\t       bitmap args_to_skip, tree *vars)\n+copy_arguments_nochange (tree orig_parm, copy_body_data * id)\n {\n   tree arg, *parg;\n   tree new_parm = NULL;\n-  int i = 0;\n \n   parg = &new_parm;\n-\n-  for (arg = orig_parm; arg; arg = DECL_CHAIN (arg), i++)\n-    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n-      {\n-        tree new_tree = remap_decl (arg, id);\n-\tif (TREE_CODE (new_tree) != PARM_DECL)\n-\t  new_tree = id->copy_decl (arg, id);\n-        lang_hooks.dup_lang_specific_decl (new_tree);\n-        *parg = new_tree;\n-\tparg = &DECL_CHAIN (new_tree);\n-      }\n-    else if (!id->decl_map->get (arg))\n-      {\n-\t/* Make an equivalent VAR_DECL.  If the argument was used\n-\t   as temporary variable later in function, the uses will be\n-\t   replaced by local variable.  */\n-\ttree var = copy_decl_to_var (arg, id);\n-\tinsert_decl_map (id, arg, var);\n-        /* Declare this new variable.  */\n-        DECL_CHAIN (var) = *vars;\n-        *vars = var;\n-      }\n+  for (arg = orig_parm; arg; arg = DECL_CHAIN (arg))\n+    {\n+      tree new_tree = remap_decl (arg, id);\n+      if (TREE_CODE (new_tree) != PARM_DECL)\n+\tnew_tree = id->copy_decl (arg, id);\n+      lang_hooks.dup_lang_specific_decl (new_tree);\n+      *parg = new_tree;\n+      parg = &DECL_CHAIN (new_tree);\n+    }\n   return new_parm;\n }\n \n@@ -5883,6 +5949,18 @@ tree_versionable_function_p (tree fndecl)\n static void\n update_clone_info (copy_body_data * id)\n {\n+  vec<ipa_param_performed_split, va_gc> *cur_performed_splits\n+    = id->dst_node->clone.performed_splits;\n+  if (cur_performed_splits)\n+    {\n+      unsigned len = cur_performed_splits->length ();\n+      for (unsigned i = 0; i < len; i++)\n+\t{\n+\t  ipa_param_performed_split *ps = &(*cur_performed_splits)[i];\n+\t  ps->dummy_decl = remap_decl (ps->dummy_decl, id);\n+\t}\n+    }\n+\n   struct cgraph_node *node;\n   if (!id->dst_node->clones)\n     return;\n@@ -5896,10 +5974,55 @@ update_clone_info (copy_body_data * id)\n \t    {\n \t      struct ipa_replace_map *replace_info;\n \t      replace_info = (*node->clone.tree_map)[i];\n-\t      walk_tree (&replace_info->old_tree, copy_tree_body_r, id, NULL);\n \t      walk_tree (&replace_info->new_tree, copy_tree_body_r, id, NULL);\n \t    }\n \t}\n+      if (node->clone.performed_splits)\n+\t{\n+\t  unsigned len = vec_safe_length (node->clone.performed_splits);\n+\t  for (unsigned i = 0; i < len; i++)\n+\t    {\n+\t      ipa_param_performed_split *ps\n+\t\t= &(*node->clone.performed_splits)[i];\n+\t      ps->dummy_decl = remap_decl (ps->dummy_decl, id);\n+\t    }\n+\t}\n+      if (unsigned len = vec_safe_length (cur_performed_splits))\n+\t{\n+\t  /* We do not want to add current performed splits when we are saving\n+\t     a copy of function body for later during inlining, that would just\n+\t     duplicate all entries.  So let's have a look whether anything\n+\t     referring to the first dummy_decl is present.  */\n+\t  unsigned dst_len = vec_safe_length (node->clone.performed_splits);\n+\t  ipa_param_performed_split *first = &(*cur_performed_splits)[0];\n+\t  for (unsigned i = 0; i < dst_len; i++)\n+\t    if ((*node->clone.performed_splits)[i].dummy_decl\n+\t\t== first->dummy_decl)\n+\t      {\n+\t\tlen = 0;\n+\t\tbreak;\n+\t      }\n+\n+\t  for (unsigned i = 0; i < len; i++)\n+\t    vec_safe_push (node->clone.performed_splits,\n+\t\t\t   (*cur_performed_splits)[i]);\n+\t  if (flag_checking)\n+\t    {\n+\t      for (unsigned i = 0; i < dst_len; i++)\n+\t\t{\n+\t\t  ipa_param_performed_split *ps1\n+\t\t    = &(*node->clone.performed_splits)[i];\n+\t\t  for (unsigned j = i + 1; j < dst_len; j++)\n+\t\t    {\n+\t\t      ipa_param_performed_split *ps2\n+\t\t\t= &(*node->clone.performed_splits)[j];\n+\t\t      gcc_assert (ps1->dummy_decl != ps2->dummy_decl\n+\t\t\t\t  || ps1->unit_offset != ps2->unit_offset);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n       if (node->clones)\n \tnode = node->clones;\n       else if (node->next_sibling_clone)\n@@ -5921,19 +6044,18 @@ update_clone_info (copy_body_data * id)\n    tree with another tree while duplicating the function's\n    body, TREE_MAP represents the mapping between these\n    trees. If UPDATE_CLONES is set, the call_stmt fields\n-   of edges of clones of the function will be updated.  \n+   of edges of clones of the function will be updated.\n \n-   If non-NULL ARGS_TO_SKIP determine function parameters to remove\n-   from new version.\n-   If SKIP_RETURN is true, the new version will return void.\n-   If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.\n+   If non-NULL PARAM_ADJUSTMENTS determines how function prototype (i.e. the\n+   function parameters and return value) should be modified).\n+   If non-NULL BLOCKS_TO_COPY determine what basic blocks to copy.\n    If non_NULL NEW_ENTRY determine new entry BB of the clone.\n */\n void\n tree_function_versioning (tree old_decl, tree new_decl,\n \t\t\t  vec<ipa_replace_map *, va_gc> *tree_map,\n-\t\t\t  bool update_clones, bitmap args_to_skip,\n-\t\t\t  bool skip_return, bitmap blocks_to_copy,\n+\t\t\t  ipa_param_adjustments *param_adjustments,\n+\t\t\t  bool update_clones, bitmap blocks_to_copy,\n \t\t\t  basic_block new_entry)\n {\n   struct cgraph_node *old_version_node;\n@@ -5945,7 +6067,6 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   basic_block old_entry_block, bb;\n   auto_vec<gimple *, 10> init_stmts;\n   tree vars = NULL_TREE;\n-  bitmap debug_args_to_skip = args_to_skip;\n \n   gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL\n \t      && TREE_CODE (new_decl) == FUNCTION_DECL);\n@@ -6021,96 +6142,78 @@ tree_function_versioning (tree old_decl, tree new_decl,\n     DECL_STRUCT_FUNCTION (new_decl)->static_chain_decl\n       = copy_static_chain (p, &id);\n \n+  auto_vec<int, 16> new_param_indices;\n+  ipa_param_adjustments *old_param_adjustments\n+    = old_version_node->clone.param_adjustments;\n+  if (old_param_adjustments)\n+    old_param_adjustments->get_updated_indices (&new_param_indices);\n+\n   /* If there's a tree_map, prepare for substitution.  */\n   if (tree_map)\n     for (i = 0; i < tree_map->length (); i++)\n       {\n \tgimple *init;\n \treplace_info = (*tree_map)[i];\n-\tif (replace_info->replace_p)\n+\n+\tint p = replace_info->parm_num;\n+\tif (old_param_adjustments)\n+\t  p = new_param_indices[p];\n+\n+\ttree parm;\n+\ttree req_type, new_type;\n+\n+\tfor (parm = DECL_ARGUMENTS (old_decl); p;\n+\t     parm = DECL_CHAIN (parm))\n+\t  p--;\n+\ttree old_tree = parm;\n+\treq_type = TREE_TYPE (parm);\n+\tnew_type = TREE_TYPE (replace_info->new_tree);\n+\tif (!useless_type_conversion_p (req_type, new_type))\n \t  {\n-\t    int parm_num = -1;\n-\t    if (!replace_info->old_tree)\n-\t      {\n-\t\tint p = replace_info->parm_num;\n-\t\ttree parm;\n-\t\ttree req_type, new_type;\n-\n-\t\tfor (parm = DECL_ARGUMENTS (old_decl); p;\n-\t\t     parm = DECL_CHAIN (parm))\n-\t\t  p--;\n-\t\treplace_info->old_tree = parm;\n-\t\tparm_num = replace_info->parm_num;\n-\t\treq_type = TREE_TYPE (parm);\n-\t\tnew_type = TREE_TYPE (replace_info->new_tree);\n-\t\tif (!useless_type_conversion_p (req_type, new_type))\n-\t\t  {\n-\t\t    if (fold_convertible_p (req_type, replace_info->new_tree))\n-\t\t      replace_info->new_tree\n-\t\t\t= fold_build1 (NOP_EXPR, req_type,\n-\t\t\t\t       replace_info->new_tree);\n-\t\t    else if (TYPE_SIZE (req_type) == TYPE_SIZE (new_type))\n-\t\t      replace_info->new_tree\n-\t\t\t= fold_build1 (VIEW_CONVERT_EXPR, req_type,\n-\t\t\t\t       replace_info->new_tree);\n-\t\t    else\n-\t\t      {\n-\t\t\tif (dump_file)\n-\t\t\t  {\n-\t\t\t    fprintf (dump_file, \"    const \");\n-\t\t\t    print_generic_expr (dump_file,\n-\t\t\t\t\t\treplace_info->new_tree);\n-\t\t\t    fprintf (dump_file,\n-\t\t\t\t     \"  can't be converted to param \");\n-\t\t\t    print_generic_expr (dump_file, parm);\n-\t\t\t    fprintf (dump_file, \"\\n\");\n-\t\t\t  }\n-\t\t\treplace_info->old_tree = NULL;\n-\t\t      }\n-\t\t  }\n-\t      }\n+\t    if (fold_convertible_p (req_type, replace_info->new_tree))\n+\t      replace_info->new_tree\n+\t\t= fold_build1 (NOP_EXPR, req_type, replace_info->new_tree);\n+\t    else if (TYPE_SIZE (req_type) == TYPE_SIZE (new_type))\n+\t      replace_info->new_tree\n+\t\t= fold_build1 (VIEW_CONVERT_EXPR, req_type,\n+\t\t\t       replace_info->new_tree);\n \t    else\n-\t      gcc_assert (TREE_CODE (replace_info->old_tree) == PARM_DECL);\n-\t    if (replace_info->old_tree)\n \t      {\n-\t\tinit = setup_one_parameter (&id, replace_info->old_tree,\n-\t\t\t\t\t    replace_info->new_tree, id.src_fn,\n-\t\t\t\t\t    NULL,\n-\t\t\t\t\t    &vars);\n-\t\tif (init)\n-\t\t  init_stmts.safe_push (init);\n-\t\tif (MAY_HAVE_DEBUG_BIND_STMTS && args_to_skip)\n+\t\tif (dump_file)\n \t\t  {\n-\t\t    if (parm_num == -1)\n-\t\t      {\n-\t\t\ttree parm;\n-\t\t\tint p;\n-\t\t\tfor (parm = DECL_ARGUMENTS (old_decl), p = 0; parm;\n-\t\t\t     parm = DECL_CHAIN (parm), p++)\n-\t\t\t  if (parm == replace_info->old_tree)\n-\t\t\t    {\n-\t\t\t      parm_num = p;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t      }\n-\t\t    if (parm_num != -1)\n-\t\t      {\n-\t\t\tif (debug_args_to_skip == args_to_skip)\n-\t\t\t  {\n-\t\t\t    debug_args_to_skip = BITMAP_ALLOC (NULL);\n-\t\t\t    bitmap_copy (debug_args_to_skip, args_to_skip);\n-\t\t\t  }\n-\t\t\tbitmap_clear_bit (debug_args_to_skip, parm_num);\n-\t\t      }\n+\t\t    fprintf (dump_file, \"    const \");\n+\t\t    print_generic_expr (dump_file,\n+\t\t\t\t\treplace_info->new_tree);\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"  can't be converted to param \");\n+\t\t    print_generic_expr (dump_file, parm);\n+\t\t    fprintf (dump_file, \"\\n\");\n \t\t  }\n+\t\told_tree = NULL;\n \t      }\n \t  }\n+\n+\tif (old_tree)\n+\t  {\n+\t    init = setup_one_parameter (&id, old_tree, replace_info->new_tree,\n+\t\t\t\t\tid.src_fn, NULL, &vars);\n+\t    if (init)\n+\t      init_stmts.safe_push (init);\n+\t  }\n       }\n-  /* Copy the function's arguments.  */\n-  if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n+\n+  ipa_param_body_adjustments *param_body_adjs = NULL;\n+  if (param_adjustments)\n+    {\n+      param_body_adjs = new ipa_param_body_adjustments (param_adjustments,\n+\t\t\t\t\t\t\tnew_decl, old_decl,\n+\t\t\t\t\t\t\t&id, &vars, tree_map);\n+      id.param_body_adjs = param_body_adjs;\n+      DECL_ARGUMENTS (new_decl) = param_body_adjs->get_new_param_chain ();\n+    }\n+  else if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n     DECL_ARGUMENTS (new_decl)\n-      = copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,\n-\t\t\t\t       args_to_skip, &vars);\n+      = copy_arguments_nochange (DECL_ARGUMENTS (old_decl), &id);\n \n   DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (new_decl)) = new_decl;\n@@ -6123,12 +6226,19 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   if (DECL_RESULT (old_decl) == NULL_TREE)\n     ;\n-  else if (skip_return && !VOID_TYPE_P (TREE_TYPE (DECL_RESULT (old_decl))))\n+  else if (param_adjustments && param_adjustments->m_skip_return\n+\t   && !VOID_TYPE_P (TREE_TYPE (DECL_RESULT (old_decl))))\n     {\n+      tree resdecl_repl = copy_result_decl_to_var (DECL_RESULT (old_decl),\n+\t\t\t\t\t\t   &id);\n+      declare_inline_vars (NULL, resdecl_repl);\n+      insert_decl_map (&id, DECL_RESULT (old_decl), resdecl_repl);\n+\n       DECL_RESULT (new_decl)\n \t= build_decl (DECL_SOURCE_LOCATION (DECL_RESULT (old_decl)),\n \t\t      RESULT_DECL, NULL_TREE, void_type_node);\n       DECL_CONTEXT (DECL_RESULT (new_decl)) = new_decl;\n+      DECL_IS_MALLOC (new_decl) = false;\n       cfun->returns_struct = 0;\n       cfun->returns_pcc_struct = 0;\n     }\n@@ -6221,29 +6331,30 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t}\n     }\n \n-  if (debug_args_to_skip && MAY_HAVE_DEBUG_BIND_STMTS)\n+  if (param_body_adjs && MAY_HAVE_DEBUG_BIND_STMTS)\n     {\n-      tree parm;\n       vec<tree, va_gc> **debug_args = NULL;\n       unsigned int len = 0;\n-      for (parm = DECL_ARGUMENTS (old_decl), i = 0;\n-\t   parm; parm = DECL_CHAIN (parm), i++)\n-\tif (bitmap_bit_p (debug_args_to_skip, i) && is_gimple_reg (parm))\n-\t  {\n-\t    tree ddecl;\n+      unsigned reset_len = param_body_adjs->m_reset_debug_decls.length ();\n \n-\t    if (debug_args == NULL)\n-\t      {\n-\t\tdebug_args = decl_debug_args_insert (new_decl);\n-\t\tlen = vec_safe_length (*debug_args);\n-\t      }\n-\t    ddecl = make_node (DEBUG_EXPR_DECL);\n-\t    DECL_ARTIFICIAL (ddecl) = 1;\n-\t    TREE_TYPE (ddecl) = TREE_TYPE (parm);\n-\t    SET_DECL_MODE (ddecl, DECL_MODE (parm));\n-\t    vec_safe_push (*debug_args, DECL_ORIGIN (parm));\n-\t    vec_safe_push (*debug_args, ddecl);\n-\t  }\n+      for (i = 0; i < reset_len; i++)\n+\t{\n+\t  tree parm = param_body_adjs->m_reset_debug_decls[i];\n+\t  gcc_assert (is_gimple_reg (parm));\n+\t  tree ddecl;\n+\n+\t  if (debug_args == NULL)\n+\t    {\n+\t      debug_args = decl_debug_args_insert (new_decl);\n+\t      len = vec_safe_length (*debug_args);\n+\t    }\n+\t  ddecl = make_node (DEBUG_EXPR_DECL);\n+\t  DECL_ARTIFICIAL (ddecl) = 1;\n+\t  TREE_TYPE (ddecl) = TREE_TYPE (parm);\n+\t  SET_DECL_MODE (ddecl, DECL_MODE (parm));\n+\t  vec_safe_push (*debug_args, DECL_ORIGIN (parm));\n+\t  vec_safe_push (*debug_args, ddecl);\n+\t}\n       if (debug_args != NULL)\n \t{\n \t  /* On the callee side, add\n@@ -6269,7 +6380,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t      if (var == NULL_TREE)\n \t\tbreak;\n \t      vexpr = make_node (DEBUG_EXPR_DECL);\n-\t      parm = (**debug_args)[i];\n+\t      tree parm = (**debug_args)[i];\n \t      DECL_ARTIFICIAL (vexpr) = 1;\n \t      TREE_TYPE (vexpr) = TREE_TYPE (parm);\n \t      SET_DECL_MODE (vexpr, DECL_MODE (parm));\n@@ -6281,9 +6392,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t  while (i > len);\n \t}\n     }\n-\n-  if (debug_args_to_skip && debug_args_to_skip != args_to_skip)\n-    BITMAP_FREE (debug_args_to_skip);\n+  delete param_body_adjs;\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n "}, {"sha": "87a149c357bb603c3cd4aba3a327a2a4f01e295a", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -172,6 +172,15 @@ struct copy_body_data\n      outside of the inlined function, this should be the number\n      of basic blocks in the caller before inlining.  Zero otherwise.  */\n   int add_clobbers_to_eh_landing_pads;\n+\n+  /* Class managing changes to function parameters and return value planned\n+     during IPA stage.  */\n+  class ipa_param_body_adjustments *param_body_adjs;\n+\n+  /* Hash set of SSA names that have been killed during call graph edge\n+   redirection and should not be introduced into debug statements or NULL if no\n+   SSA_NAME was deleted during redirections happened.  */\n+  hash_set <tree> *killed_new_ssa_names;\n };\n \n /* Weights of constructions for estimate_num_insns.  */\n@@ -240,6 +249,7 @@ extern bool debug_find_tree (tree, tree);\n extern tree copy_fn (tree, tree&, tree&);\n extern const char *copy_forbidden (struct function *fun);\n extern tree copy_decl_for_dup_finish (copy_body_data *id, tree decl, tree copy);\n+extern tree copy_decl_to_var (tree, copy_body_data *);\n \n /* This is in tree-inline.c since the routine uses\n    data structures from the inliner.  */"}, {"sha": "85b1c828f3a4391a3052fcc2051546574481becd", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -355,7 +355,6 @@ extern gimple_opt_pass *make_pass_early_tree_profile (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_cleanup_eh (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_sra (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_sra_early (gcc::context *ctxt);\n-extern gimple_opt_pass *make_pass_early_ipa_sra (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tail_recursion (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tail_calls (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fix_loops (gcc::context *ctxt);\n@@ -500,6 +499,7 @@ extern ipa_opt_pass_d *make_pass_ipa_inline (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_free_lang_data (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_free_fn_summary (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cp (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_sra (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_icf (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_devirt (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);"}, {"sha": "48589323a1e2b29c928e8c92f64168cfa235bfb0", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 37, "deletions": 1822, "changes": 1859, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -96,15 +96,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n-#include \"symbol-summary.h\"\n-#include \"ipa-param-manipulation.h\"\n-#include \"ipa-prop.h\"\n #include \"params.h\"\n #include \"dbgcnt.h\"\n-#include \"tree-inline.h\"\n-#include \"ipa-fnsummary.h\"\n-#include \"ipa-utils.h\"\n #include \"builtins.h\"\n+#include \"tree-sra.h\"\n \n \n /* Enumeration of all aggregate reductions we can do.  */\n@@ -169,8 +164,7 @@ struct access\n   struct access *first_child;\n \n   /* In intraprocedural SRA, pointer to the next sibling in the access tree as\n-     described above.  In IPA-SRA this is a pointer to the next access\n-     belonging to the same group (having the same representative).  */\n+     described above.  */\n   struct access *next_sibling;\n \n   /* Pointers to the first and last element in the linked list of assign\n@@ -185,9 +179,6 @@ struct access\n      when grp_to_be_replaced flag is set.  */\n   tree replacement_decl;\n \n-  /* Is this access an access to a non-addressable field? */\n-  unsigned non_addressable : 1;\n-\n   /* Is this access made in reverse storage order? */\n   unsigned reverse : 1;\n \n@@ -260,19 +251,6 @@ struct access\n \n   /* Should TREE_NO_WARNING of a replacement be set?  */\n   unsigned grp_no_warning : 1;\n-\n-  /* Is it possible that the group refers to data which might be (directly or\n-     otherwise) modified?  */\n-  unsigned grp_maybe_modified : 1;\n-\n-  /* Set when this is a representative of a pointer to scalar (i.e. by\n-     reference) parameter which we consider for turning into a plain scalar\n-     (i.e. a by value parameter).  */\n-  unsigned grp_scalar_ptr : 1;\n-\n-  /* Set when we discover that this pointer is not safe to dereference in the\n-     caller.  */\n-  unsigned grp_not_necessarilly_dereferenced : 1;\n };\n \n typedef struct access *access_p;\n@@ -349,29 +327,6 @@ static struct obstack name_obstack;\n    propagated to their assignment counterparts. */\n static struct access *work_queue_head;\n \n-/* Number of parameters of the analyzed function when doing early ipa SRA.  */\n-static int func_param_count;\n-\n-/* scan_function sets the following to true if it encounters a call to\n-   __builtin_apply_args.  */\n-static bool encountered_apply_args;\n-\n-/* Set by scan_function when it finds a recursive call.  */\n-static bool encountered_recursive_call;\n-\n-/* Set by scan_function when it finds a recursive call with less actual\n-   arguments than formal parameters..  */\n-static bool encountered_unchangable_recursive_call;\n-\n-/* This is a table in which for each basic block and parameter there is a\n-   distance (offset + size) in that parameter which is dereferenced and\n-   accessed in that BB.  */\n-static HOST_WIDE_INT *bb_dereferences;\n-/* Bitmap of BBs that can cause the function to \"stop\" progressing by\n-   returning, throwing externally, looping infinitely or calling a function\n-   which might abort etc.. */\n-static bitmap final_bbs;\n-\n /* Representative of no accesses at all. */\n static struct access  no_accesses_representant;\n \n@@ -440,27 +395,22 @@ dump_access (FILE *f, struct access *access, bool grp)\n   print_generic_expr (f, access->expr);\n   fprintf (f, \", type = \");\n   print_generic_expr (f, access->type);\n-  fprintf (f, \", non_addressable = %d, reverse = %d\",\n-\t   access->non_addressable, access->reverse);\n+  fprintf (f, \", reverse = %d\", access->reverse);\n   if (grp)\n     fprintf (f, \", grp_read = %d, grp_write = %d, grp_assignment_read = %d, \"\n \t     \"grp_assignment_write = %d, grp_scalar_read = %d, \"\n \t     \"grp_scalar_write = %d, grp_total_scalarization = %d, \"\n \t     \"grp_hint = %d, grp_covered = %d, \"\n \t     \"grp_unscalarizable_region = %d, grp_unscalarized_data = %d, \"\n \t     \"grp_same_access_path = %d, grp_partial_lhs = %d, \"\n-\t     \"grp_to_be_replaced = %d, grp_to_be_debug_replaced = %d, \"\n-\t     \"grp_maybe_modified = %d, \"\n-\t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n+\t     \"grp_to_be_replaced = %d, grp_to_be_debug_replaced = %d\\n\",\n \t     access->grp_read, access->grp_write, access->grp_assignment_read,\n \t     access->grp_assignment_write, access->grp_scalar_read,\n \t     access->grp_scalar_write, access->grp_total_scalarization,\n \t     access->grp_hint, access->grp_covered,\n \t     access->grp_unscalarizable_region, access->grp_unscalarized_data,\n \t     access->grp_same_access_path, access->grp_partial_lhs,\n-\t     access->grp_to_be_replaced, access->grp_to_be_debug_replaced,\n-\t     access->grp_maybe_modified,\n-\t     access->grp_not_necessarilly_dereferenced);\n+\t     access->grp_to_be_replaced, access->grp_to_be_debug_replaced);\n   else\n     fprintf (f, \", write = %d, grp_total_scalarization = %d, \"\n \t     \"grp_partial_lhs = %d\\n\",\n@@ -672,9 +622,6 @@ sra_initialize (void)\n   gcc_obstack_init (&name_obstack);\n   base_access_vec = new hash_map<tree, auto_vec<access_p> >;\n   memset (&sra_stats, 0, sizeof (sra_stats));\n-  encountered_apply_args = false;\n-  encountered_recursive_call = false;\n-  encountered_unchangable_recursive_call = false;\n }\n \n /* Deallocate all general structures.  */\n@@ -722,14 +669,20 @@ disqualify_candidate (tree decl, const char *reason)\n }\n \n /* Return true iff the type contains a field or an element which does not allow\n-   scalarization.  */\n+   scalarization.  Use VISITED_TYPES to avoid re-checking already checked\n+   (sub-)types.  */\n \n static bool\n-type_internals_preclude_sra_p (tree type, const char **msg)\n+type_internals_preclude_sra_p_1 (tree type, const char **msg,\n+\t\t\t\t hash_set<tree> *visited_types)\n {\n   tree fld;\n   tree et;\n \n+  if (visited_types->contains (type))\n+    return false;\n+  visited_types->add (type);\n+\n   switch (TREE_CODE (type))\n     {\n     case RECORD_TYPE:\n@@ -738,6 +691,8 @@ type_internals_preclude_sra_p (tree type, const char **msg)\n       for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \tif (TREE_CODE (fld) == FIELD_DECL)\n \t  {\n+\t    if (TREE_CODE (fld) == FUNCTION_DECL)\n+\t      continue;\n \t    tree ft = TREE_TYPE (fld);\n \n \t    if (TREE_THIS_VOLATILE (fld))\n@@ -777,7 +732,8 @@ type_internals_preclude_sra_p (tree type, const char **msg)\n \t        return true;\n \t      }\n \n-\t    if (AGGREGATE_TYPE_P (ft) && type_internals_preclude_sra_p (ft, msg))\n+\t    if (AGGREGATE_TYPE_P (ft)\n+\t      && type_internals_preclude_sra_p_1 (ft, msg, visited_types))\n \t      return true;\n \t  }\n \n@@ -792,7 +748,8 @@ type_internals_preclude_sra_p (tree type, const char **msg)\n \t  return true;\n \t}\n \n-      if (AGGREGATE_TYPE_P (et) && type_internals_preclude_sra_p (et, msg))\n+      if (AGGREGATE_TYPE_P (et)\n+\t  && type_internals_preclude_sra_p_1 (et, msg, visited_types))\n \treturn true;\n \n       return false;\n@@ -802,47 +759,16 @@ type_internals_preclude_sra_p (tree type, const char **msg)\n     }\n }\n \n-/* If T is an SSA_NAME, return NULL if it is not a default def or return its\n-   base variable if it is.  Return T if it is not an SSA_NAME.  */\n+/* Return true iff the type contains a field or an element which does not allow\n+   scalarization.  */\n \n-static tree\n-get_ssa_base_param (tree t)\n+bool\n+type_internals_preclude_sra_p (tree type, const char **msg)\n {\n-  if (TREE_CODE (t) == SSA_NAME)\n-    {\n-      if (SSA_NAME_IS_DEFAULT_DEF (t))\n-\treturn SSA_NAME_VAR (t);\n-      else\n-\treturn NULL_TREE;\n-    }\n-  return t;\n+  hash_set<tree> visited_types;\n+  return type_internals_preclude_sra_p_1 (type, msg, &visited_types);\n }\n \n-/* Mark a dereference of BASE of distance DIST in a basic block tht STMT\n-   belongs to, unless the BB has already been marked as a potentially\n-   final.  */\n-\n-static void\n-mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple *stmt)\n-{\n-  basic_block bb = gimple_bb (stmt);\n-  int idx, parm_index = 0;\n-  tree parm;\n-\n-  if (bitmap_bit_p (final_bbs, bb->index))\n-    return;\n-\n-  for (parm = DECL_ARGUMENTS (current_function_decl);\n-       parm && parm != base;\n-       parm = DECL_CHAIN (parm))\n-    parm_index++;\n-\n-  gcc_assert (parm_index < func_param_count);\n-\n-  idx = bb->index * func_param_count + parm_index;\n-  if (bb_dereferences[idx] < dist)\n-    bb_dereferences[idx] = dist;\n-}\n \n /* Allocate an access structure for BASE, OFFSET and SIZE, clear it, fill in\n    the three fields.  Also add it to the vector of accesses corresponding to\n@@ -876,7 +802,7 @@ create_access (tree expr, gimple *stmt, bool write)\n   poly_int64 poffset, psize, pmax_size;\n   HOST_WIDE_INT offset, size, max_size;\n   tree base = expr;\n-  bool reverse, ptr, unscalarizable_region = false;\n+  bool reverse, unscalarizable_region = false;\n \n   base = get_ref_base_and_extent (expr, &poffset, &psize, &pmax_size,\n \t\t\t\t  &reverse);\n@@ -888,20 +814,8 @@ create_access (tree expr, gimple *stmt, bool write)\n       return NULL;\n     }\n \n-  if (sra_mode == SRA_MODE_EARLY_IPA\n-      && TREE_CODE (base) == MEM_REF)\n-    {\n-      base = get_ssa_base_param (TREE_OPERAND (base, 0));\n-      if (!base)\n-\treturn NULL;\n-      ptr = true;\n-    }\n-  else\n-    ptr = false;\n-\n   /* For constant-pool entries, check we can substitute the constant value.  */\n-  if (constant_decl_p (base)\n-      && (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA))\n+  if (constant_decl_p (base))\n     {\n       gcc_assert (!bitmap_bit_p (disqualified_constants, DECL_UID (base)));\n       if (expr != base\n@@ -921,36 +835,15 @@ create_access (tree expr, gimple *stmt, bool write)\n   if (!DECL_P (base) || !bitmap_bit_p (candidate_bitmap, DECL_UID (base)))\n     return NULL;\n \n-  if (sra_mode == SRA_MODE_EARLY_IPA)\n+  if (size != max_size)\n     {\n-      if (size < 0 || size != max_size)\n-\t{\n-\t  disqualify_candidate (base, \"Encountered a variable sized access.\");\n-\t  return NULL;\n-\t}\n-      if (TREE_CODE (expr) == COMPONENT_REF\n-\t  && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))\n-\t{\n-\t  disqualify_candidate (base, \"Encountered a bit-field access.\");\n-\t  return NULL;\n-\t}\n-      gcc_checking_assert ((offset % BITS_PER_UNIT) == 0);\n-\n-      if (ptr)\n-\tmark_parm_dereference (base, offset + size, stmt);\n+      size = max_size;\n+      unscalarizable_region = true;\n     }\n-  else\n+  if (size < 0)\n     {\n-      if (size != max_size)\n-\t{\n-\t  size = max_size;\n-\t  unscalarizable_region = true;\n-\t}\n-      if (size < 0)\n-\t{\n-\t  disqualify_candidate (base, \"Encountered an unconstrained access.\");\n-\t  return NULL;\n-\t}\n+      disqualify_candidate (base, \"Encountered an unconstrained access.\");\n+      return NULL;\n     }\n \n   access = create_access_1 (base, offset, size);\n@@ -961,10 +854,6 @@ create_access (tree expr, gimple *stmt, bool write)\n   access->stmt = stmt;\n   access->reverse = reverse;\n \n-  if (TREE_CODE (expr) == COMPONENT_REF\n-      && DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1)))\n-    access->non_addressable = 1;\n-\n   return access;\n }\n \n@@ -1198,10 +1087,6 @@ static void\n disqualify_base_of_expr (tree t, const char *reason)\n {\n   t = get_base_address (t);\n-  if (sra_mode == SRA_MODE_EARLY_IPA\n-      && TREE_CODE (t) == MEM_REF)\n-    t = get_ssa_base_param (TREE_OPERAND (t, 0));\n-\n   if (t && DECL_P (t))\n     disqualify_candidate (t, reason);\n }\n@@ -1254,8 +1139,7 @@ build_access_from_expr_1 (tree expr, gimple *stmt, bool write)\n   switch (TREE_CODE (expr))\n     {\n     case MEM_REF:\n-      if (TREE_CODE (TREE_OPERAND (expr, 0)) != ADDR_EXPR\n-\t  && sra_mode != SRA_MODE_EARLY_IPA)\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) != ADDR_EXPR)\n \treturn NULL;\n       /* fall through */\n     case VAR_DECL:\n@@ -1329,8 +1213,7 @@ single_non_eh_succ (basic_block bb)\n static bool\n disqualify_if_bad_bb_terminating_stmt (gimple *stmt, tree lhs, tree rhs)\n {\n-  if ((sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n-      && stmt_ends_bb_p (stmt))\n+  if (stmt_ends_bb_p (stmt))\n     {\n       if (single_non_eh_succ (gimple_bb (stmt)))\n \treturn false;\n@@ -1454,29 +1337,6 @@ asm_visit_addr (gimple *, tree op, tree, void *)\n   return false;\n }\n \n-/* Return true iff callsite CALL has at least as many actual arguments as there\n-   are formal parameters of the function currently processed by IPA-SRA and\n-   that their types match.  */\n-\n-static inline bool\n-callsite_arguments_match_p (gimple *call)\n-{\n-  if (gimple_call_num_args (call) < (unsigned) func_param_count)\n-    return false;\n-\n-  tree parm;\n-  int i;\n-  for (parm = DECL_ARGUMENTS (current_function_decl), i = 0;\n-       parm;\n-       parm = DECL_CHAIN (parm), i++)\n-    {\n-      tree arg = gimple_call_arg (call, i);\n-      if (!useless_type_conversion_p (TREE_TYPE (parm), TREE_TYPE (arg)))\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n /* Scan function and look for interesting expressions and create access\n    structures for them.  Return true iff any access is created.  */\n \n@@ -1495,16 +1355,12 @@ scan_function (void)\n \t  tree t;\n \t  unsigned i;\n \n-\t  if (final_bbs && stmt_can_throw_external (cfun, stmt))\n-\t    bitmap_set_bit (final_bbs, bb->index);\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RETURN:\n \t      t = gimple_return_retval (as_a <greturn *> (stmt));\n \t      if (t != NULL_TREE)\n \t\tret |= build_access_from_expr (t, stmt, false);\n-\t      if (final_bbs)\n-\t\tbitmap_set_bit (final_bbs, bb->index);\n \t      break;\n \n \t    case GIMPLE_ASSIGN:\n@@ -1516,28 +1372,6 @@ scan_function (void)\n \t\tret |= build_access_from_expr (gimple_call_arg (stmt, i),\n \t\t\t\t\t       stmt, false);\n \n-\t      if (sra_mode == SRA_MODE_EARLY_IPA)\n-\t\t{\n-\t\t  tree dest = gimple_call_fndecl (stmt);\n-\t\t  int flags = gimple_call_flags (stmt);\n-\n-\t\t  if (dest)\n-\t\t    {\n-\t\t      if (fndecl_built_in_p (dest, BUILT_IN_APPLY_ARGS))\n-\t\t\tencountered_apply_args = true;\n-\t\t      if (recursive_call_p (current_function_decl, dest))\n-\t\t\t{\n-\t\t\t  encountered_recursive_call = true;\n-\t\t\t  if (!callsite_arguments_match_p (stmt))\n-\t\t\t    encountered_unchangable_recursive_call = true;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  if (final_bbs\n-\t\t      && (flags & (ECF_CONST | ECF_PURE)) == 0)\n-\t\t    bitmap_set_bit (final_bbs, bb->index);\n-\t\t}\n-\n \t      t = gimple_call_lhs (stmt);\n \t      if (t && !disqualify_if_bad_bb_terminating_stmt (stmt, t, NULL))\n \t\tret |= build_access_from_expr (t, stmt, true);\n@@ -1548,9 +1382,6 @@ scan_function (void)\n \t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \t\twalk_stmt_load_store_addr_ops (asm_stmt, NULL, NULL, NULL,\n \t\t\t\t\t       asm_visit_addr);\n-\t\tif (final_bbs)\n-\t\t  bitmap_set_bit (final_bbs, bb->index);\n-\n \t\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n \t\t  {\n \t\t    t = TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n@@ -2002,14 +1833,6 @@ build_user_friendly_ref_for_offset (tree *res, tree type, HOST_WIDE_INT offset,\n     }\n }\n \n-/* Return true iff TYPE is stdarg va_list type.  */\n-\n-static inline bool\n-is_va_list_type (tree type)\n-{\n-  return TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (va_list_type_node);\n-}\n-\n /* Print message to dump file why a variable was rejected. */\n \n static void\n@@ -2037,10 +1860,8 @@ maybe_add_sra_candidate (tree var)\n       reject (var, \"not aggregate\");\n       return false;\n     }\n-  /* Allow constant-pool entries (that \"need to live in memory\")\n-     unless we are doing IPA SRA.  */\n-  if (needs_to_live_in_memory (var)\n-      && (sra_mode == SRA_MODE_EARLY_IPA || !constant_decl_p (var)))\n+  /* Allow constant-pool entries that \"need to live in memory\".  */\n+  if (needs_to_live_in_memory (var) && !constant_decl_p (var))\n     {\n       reject (var, \"needs to live in memory\");\n       return false;\n@@ -4184,1609 +4005,3 @@ make_pass_sra (gcc::context *ctxt)\n {\n   return new pass_sra (ctxt);\n }\n-\n-\n-/* Return true iff PARM (which must be a parm_decl) is an unused scalar\n-   parameter.  */\n-\n-static bool\n-is_unused_scalar_param (tree parm)\n-{\n-  tree name;\n-  return (is_gimple_reg (parm)\n-\t  && (!(name = ssa_default_def (cfun, parm))\n-\t      || has_zero_uses (name)));\n-}\n-\n-/* Scan immediate uses of a default definition SSA name of a parameter PARM and\n-   examine whether there are any direct or otherwise infeasible ones.  If so,\n-   return true, otherwise return false.  PARM must be a gimple register with a\n-   non-NULL default definition.  */\n-\n-static bool\n-ptr_parm_has_direct_uses (tree parm)\n-{\n-  imm_use_iterator ui;\n-  gimple *stmt;\n-  tree name = ssa_default_def (cfun, parm);\n-  bool ret = false;\n-\n-  FOR_EACH_IMM_USE_STMT (stmt, ui, name)\n-    {\n-      int uses_ok = 0;\n-      use_operand_p use_p;\n-\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n-\n-      /* Valid uses include dereferences on the lhs and the rhs.  */\n-      if (gimple_has_lhs (stmt))\n-\t{\n-\t  tree lhs = gimple_get_lhs (stmt);\n-\t  while (handled_component_p (lhs))\n-\t    lhs = TREE_OPERAND (lhs, 0);\n-\t  if (TREE_CODE (lhs) == MEM_REF\n-\t      && TREE_OPERAND (lhs, 0) == name\n-\t      && integer_zerop (TREE_OPERAND (lhs, 1))\n-\t      && types_compatible_p (TREE_TYPE (lhs),\n-\t\t\t\t     TREE_TYPE (TREE_TYPE (name)))\n-\t      && !TREE_THIS_VOLATILE (lhs))\n-\t    uses_ok++;\n-\t}\n-      if (gimple_assign_single_p (stmt))\n-\t{\n-\t  tree rhs = gimple_assign_rhs1 (stmt);\n-\t  while (handled_component_p (rhs))\n-\t    rhs = TREE_OPERAND (rhs, 0);\n-\t  if (TREE_CODE (rhs) == MEM_REF\n-\t      && TREE_OPERAND (rhs, 0) == name\n-\t      && integer_zerop (TREE_OPERAND (rhs, 1))\n-\t      && types_compatible_p (TREE_TYPE (rhs),\n-\t\t\t\t     TREE_TYPE (TREE_TYPE (name)))\n-\t      && !TREE_THIS_VOLATILE (rhs))\n-\t    uses_ok++;\n-\t}\n-      else if (is_gimple_call (stmt))\n-\t{\n-\t  unsigned i;\n-\t  for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-\t    {\n-\t      tree arg = gimple_call_arg (stmt, i);\n-\t      while (handled_component_p (arg))\n-\t\targ = TREE_OPERAND (arg, 0);\n-\t      if (TREE_CODE (arg) == MEM_REF\n-\t\t  && TREE_OPERAND (arg, 0) == name\n-\t\t  && integer_zerop (TREE_OPERAND (arg, 1))\n-\t\t  && types_compatible_p (TREE_TYPE (arg),\n-\t\t\t\t\t TREE_TYPE (TREE_TYPE (name)))\n-\t\t  && !TREE_THIS_VOLATILE (arg))\n-\t\tuses_ok++;\n-\t    }\n-\t}\n-\n-      /* If the number of valid uses does not match the number of\n-         uses in this stmt there is an unhandled use.  */\n-      FOR_EACH_IMM_USE_ON_STMT (use_p, ui)\n-\t--uses_ok;\n-\n-      if (uses_ok != 0)\n-\tret = true;\n-\n-      if (ret)\n-\tBREAK_FROM_IMM_USE_STMT (ui);\n-    }\n-\n-  return ret;\n-}\n-\n-/* Identify candidates for reduction for IPA-SRA based on their type and mark\n-   them in candidate_bitmap.  Note that these do not necessarily include\n-   parameter which are unused and thus can be removed.  Return true iff any\n-   such candidate has been found.  */\n-\n-static bool\n-find_param_candidates (void)\n-{\n-  tree parm;\n-  int count = 0;\n-  bool ret = false;\n-  const char *msg;\n-\n-  for (parm = DECL_ARGUMENTS (current_function_decl);\n-       parm;\n-       parm = DECL_CHAIN (parm))\n-    {\n-      tree type = TREE_TYPE (parm);\n-      tree_node **slot;\n-\n-      count++;\n-\n-      if (TREE_THIS_VOLATILE (parm)\n-\t  || TREE_ADDRESSABLE (parm)\n-\t  || (!is_gimple_reg_type (type) && is_va_list_type (type)))\n-\tcontinue;\n-\n-      if (is_unused_scalar_param (parm))\n-\t{\n-\t  ret = true;\n-\t  continue;\n-\t}\n-\n-      if (POINTER_TYPE_P (type))\n-\t{\n-\t  type = TREE_TYPE (type);\n-\n-\t  if (TREE_CODE (type) == FUNCTION_TYPE\n-\t      || TYPE_VOLATILE (type)\n-\t      || (TREE_CODE (type) == ARRAY_TYPE\n-\t\t  && TYPE_NONALIASED_COMPONENT (type))\n-\t      || !is_gimple_reg (parm)\n-\t      || is_va_list_type (type)\n-\t      || ptr_parm_has_direct_uses (parm))\n-\t    continue;\n-\t}\n-      else if (!AGGREGATE_TYPE_P (type))\n-\tcontinue;\n-\n-      if (!COMPLETE_TYPE_P (type)\n-\t  || !tree_fits_uhwi_p (TYPE_SIZE (type))\n-          || tree_to_uhwi (TYPE_SIZE (type)) == 0\n-\t  || (AGGREGATE_TYPE_P (type)\n-\t      && type_internals_preclude_sra_p (type, &msg)))\n-\tcontinue;\n-\n-      bitmap_set_bit (candidate_bitmap, DECL_UID (parm));\n-      slot = candidates->find_slot_with_hash (parm, DECL_UID (parm), INSERT);\n-      *slot = parm;\n-\n-      ret = true;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Candidate (%d): \", DECL_UID (parm));\n-\t  print_generic_expr (dump_file, parm);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-    }\n-\n-  func_param_count = count;\n-  return ret;\n-}\n-\n-/* Callback of walk_aliased_vdefs, marks the access passed as DATA as\n-   maybe_modified. */\n-\n-static bool\n-mark_maybe_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n-\t\t     void *data)\n-{\n-  struct access *repr = (struct access *) data;\n-\n-  repr->grp_maybe_modified = 1;\n-  return true;\n-}\n-\n-/* Analyze what representatives (in linked lists accessible from\n-   REPRESENTATIVES) can be modified by side effects of statements in the\n-   current function.  */\n-\n-static void\n-analyze_modified_params (vec<access_p> representatives)\n-{\n-  int i;\n-\n-  for (i = 0; i < func_param_count; i++)\n-    {\n-      struct access *repr;\n-\n-      for (repr = representatives[i];\n-\t   repr;\n-\t   repr = repr->next_grp)\n-\t{\n-\t  struct access *access;\n-\t  bitmap visited;\n-\t  ao_ref ar;\n-\n-\t  if (no_accesses_p (repr))\n-\t    continue;\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (repr->base))\n-\t      || repr->grp_maybe_modified)\n-\t    continue;\n-\n-\t  ao_ref_init (&ar, repr->expr);\n-\t  visited = BITMAP_ALLOC (NULL);\n-\t  for (access = repr; access; access = access->next_sibling)\n-\t    {\n-\t      /* All accesses are read ones, otherwise grp_maybe_modified would\n-\t\t be trivially set.  */\n-\t      walk_aliased_vdefs (&ar, gimple_vuse (access->stmt),\n-\t\t\t\t  mark_maybe_modified, repr, &visited);\n-\t      if (repr->grp_maybe_modified)\n-\t\tbreak;\n-\t    }\n-\t  BITMAP_FREE (visited);\n-\t}\n-    }\n-}\n-\n-/* Propagate distances in bb_dereferences in the opposite direction than the\n-   control flow edges, in each step storing the maximum of the current value\n-   and the minimum of all successors.  These steps are repeated until the table\n-   stabilizes.  Note that BBs which might terminate the functions (according to\n-   final_bbs bitmap) never updated in this way.  */\n-\n-static void\n-propagate_dereference_distances (void)\n-{\n-  basic_block bb;\n-\n-  auto_vec<basic_block> queue (last_basic_block_for_fn (cfun));\n-  queue.quick_push (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      queue.quick_push (bb);\n-      bb->aux = bb;\n-    }\n-\n-  while (!queue.is_empty ())\n-    {\n-      edge_iterator ei;\n-      edge e;\n-      bool change = false;\n-      int i;\n-\n-      bb = queue.pop ();\n-      bb->aux = NULL;\n-\n-      if (bitmap_bit_p (final_bbs, bb->index))\n-\tcontinue;\n-\n-      for (i = 0; i < func_param_count; i++)\n-\t{\n-\t  int idx = bb->index * func_param_count + i;\n-\t  bool first = true;\n-\t  HOST_WIDE_INT inh = 0;\n-\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t  {\n-\t    int succ_idx = e->dest->index * func_param_count + i;\n-\n-\t    if (e->src == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t      continue;\n-\n-\t    if (first)\n-\t      {\n-\t\tfirst = false;\n-\t\tinh = bb_dereferences [succ_idx];\n-\t      }\n-\t    else if (bb_dereferences [succ_idx] < inh)\n-\t      inh = bb_dereferences [succ_idx];\n-\t  }\n-\n-\t  if (!first && bb_dereferences[idx] < inh)\n-\t    {\n-\t      bb_dereferences[idx] = inh;\n-\t      change = true;\n-\t    }\n-\t}\n-\n-      if (change && !bitmap_bit_p (final_bbs, bb->index))\n-\tFOR_EACH_EDGE (e, ei, bb->preds)\n-\t  {\n-\t    if (e->src->aux)\n-\t      continue;\n-\n-\t    e->src->aux = e->src;\n-\t    queue.quick_push (e->src);\n-\t  }\n-    }\n-}\n-\n-/* Dump a dereferences TABLE with heading STR to file F.  */\n-\n-static void\n-dump_dereferences_table (FILE *f, const char *str, HOST_WIDE_INT *table)\n-{\n-  basic_block bb;\n-\n-  fprintf (dump_file, \"%s\", str);\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n-\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n-    {\n-      fprintf (f, \"%4i  %i   \", bb->index, bitmap_bit_p (final_bbs, bb->index));\n-      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < func_param_count; i++)\n-\t    {\n-\t      int idx = bb->index * func_param_count + i;\n-\t      fprintf (f, \" %4\" HOST_WIDE_INT_PRINT \"d\", table[idx]);\n-\t    }\n-\t}\n-      fprintf (f, \"\\n\");\n-    }\n-  fprintf (dump_file, \"\\n\");\n-}\n-\n-/* Determine what (parts of) parameters passed by reference that are not\n-   assigned to are not certainly dereferenced in this function and thus the\n-   dereferencing cannot be safely moved to the caller without potentially\n-   introducing a segfault.  Mark such REPRESENTATIVES as\n-   grp_not_necessarilly_dereferenced.\n-\n-   The dereferenced maximum \"distance,\" i.e. the offset + size of the accessed\n-   part is calculated rather than simple booleans are calculated for each\n-   pointer parameter to handle cases when only a fraction of the whole\n-   aggregate is allocated (see testsuite/gcc.c-torture/execute/ipa-sra-2.c for\n-   an example).\n-\n-   The maximum dereference distances for each pointer parameter and BB are\n-   already stored in bb_dereference.  This routine simply propagates these\n-   values upwards by propagate_dereference_distances and then compares the\n-   distances of individual parameters in the ENTRY BB to the equivalent\n-   distances of each representative of a (fraction of a) parameter.  */\n-\n-static void\n-analyze_caller_dereference_legality (vec<access_p> representatives)\n-{\n-  int i;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_dereferences_table (dump_file,\n-\t\t\t     \"Dereference table before propagation:\\n\",\n-\t\t\t     bb_dereferences);\n-\n-  propagate_dereference_distances ();\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_dereferences_table (dump_file,\n-\t\t\t     \"Dereference table after propagation:\\n\",\n-\t\t\t     bb_dereferences);\n-\n-  for (i = 0; i < func_param_count; i++)\n-    {\n-      struct access *repr = representatives[i];\n-      int idx = ENTRY_BLOCK_PTR_FOR_FN (cfun)->index * func_param_count + i;\n-\n-      if (!repr || no_accesses_p (repr))\n-\tcontinue;\n-\n-      do\n-\t{\n-\t  if ((repr->offset + repr->size) > bb_dereferences[idx])\n-\t    repr->grp_not_necessarilly_dereferenced = 1;\n-\t  repr = repr->next_grp;\n-\t}\n-      while (repr);\n-    }\n-}\n-\n-/* Return the representative access for the parameter declaration PARM if it is\n-   a scalar passed by reference which is not written to and the pointer value\n-   is not used directly.  Thus, if it is legal to dereference it in the caller\n-   and we can rule out modifications through aliases, such parameter should be\n-   turned into one passed by value.  Return NULL otherwise.  */\n-\n-static struct access *\n-unmodified_by_ref_scalar_representative (tree parm)\n-{\n-  int i, access_count;\n-  struct access *repr;\n-  vec<access_p> *access_vec;\n-\n-  access_vec = get_base_access_vector (parm);\n-  gcc_assert (access_vec);\n-  repr = (*access_vec)[0];\n-  if (repr->write)\n-    return NULL;\n-  repr->group_representative = repr;\n-\n-  access_count = access_vec->length ();\n-  for (i = 1; i < access_count; i++)\n-    {\n-      struct access *access = (*access_vec)[i];\n-      if (access->write)\n-\treturn NULL;\n-      access->group_representative = repr;\n-      access->next_sibling = repr->next_sibling;\n-      repr->next_sibling = access;\n-    }\n-\n-  repr->grp_read = 1;\n-  repr->grp_scalar_ptr = 1;\n-  return repr;\n-}\n-\n-/* Return true iff this ACCESS precludes IPA-SRA of the parameter it is\n-   associated with.  REQ_ALIGN is the minimum required alignment.  */\n-\n-static bool\n-access_precludes_ipa_sra_p (struct access *access, unsigned int req_align)\n-{\n-  unsigned int exp_align;\n-  /* Avoid issues such as the second simple testcase in PR 42025.  The problem\n-     is incompatible assign in a call statement (and possibly even in asm\n-     statements).  This can be relaxed by using a new temporary but only for\n-     non-TREE_ADDRESSABLE types and is probably not worth the complexity. (In\n-     intraprocedural SRA we deal with this by keeping the old aggregate around,\n-     something we cannot do in IPA-SRA.)  */\n-  if (access->write\n-      && (is_gimple_call (access->stmt)\n-\t  || gimple_code (access->stmt) == GIMPLE_ASM))\n-    return true;\n-\n-  exp_align = get_object_alignment (access->expr);\n-  if (exp_align < req_align)\n-    return true;\n-\n-  return false;\n-}\n-\n-\n-/* Sort collected accesses for parameter PARM, identify representatives for\n-   each accessed region and link them together.  Return NULL if there are\n-   different but overlapping accesses, return the special ptr value meaning\n-   there are no accesses for this parameter if that is the case and return the\n-   first representative otherwise.  Set *RO_GRP if there is a group of accesses\n-   with only read (i.e. no write) accesses.  */\n-\n-static struct access *\n-splice_param_accesses (tree parm, bool *ro_grp)\n-{\n-  int i, j, access_count, group_count;\n-  int total_size = 0;\n-  struct access *access, *res, **prev_acc_ptr = &res;\n-  vec<access_p> *access_vec;\n-\n-  access_vec = get_base_access_vector (parm);\n-  if (!access_vec)\n-    return &no_accesses_representant;\n-  access_count = access_vec->length ();\n-\n-  access_vec->qsort (compare_access_positions);\n-\n-  i = 0;\n-  total_size = 0;\n-  group_count = 0;\n-  while (i < access_count)\n-    {\n-      bool modification;\n-      tree a1_alias_type;\n-      access = (*access_vec)[i];\n-      modification = access->write;\n-      if (access_precludes_ipa_sra_p (access, TYPE_ALIGN (access->type)))\n-\treturn NULL;\n-      a1_alias_type = reference_alias_ptr_type (access->expr);\n-\n-      /* Access is about to become group representative unless we find some\n-\t nasty overlap which would preclude us from breaking this parameter\n-\t apart. */\n-\n-      j = i + 1;\n-      while (j < access_count)\n-\t{\n-\t  struct access *ac2 = (*access_vec)[j];\n-\t  if (ac2->offset != access->offset)\n-\t    {\n-\t      /* All or nothing law for parameters. */\n-\t      if (access->offset + access->size > ac2->offset)\n-\t\treturn NULL;\n-\t      else\n-\t\tbreak;\n-\t    }\n-\t  else if (ac2->size != access->size)\n-\t    return NULL;\n-\n-\t  if (access_precludes_ipa_sra_p (ac2, TYPE_ALIGN (access->type))\n-\t      || (ac2->type != access->type\n-\t\t  && (TREE_ADDRESSABLE (ac2->type)\n-\t\t      || TREE_ADDRESSABLE (access->type)))\n-\t      || (reference_alias_ptr_type (ac2->expr) != a1_alias_type))\n-\t    return NULL;\n-\n-\t  modification |= ac2->write;\n-\t  ac2->group_representative = access;\n-\t  ac2->next_sibling = access->next_sibling;\n-\t  access->next_sibling = ac2;\n-\t  j++;\n-\t}\n-\n-      group_count++;\n-      access->grp_maybe_modified = modification;\n-      if (!modification)\n-\t*ro_grp = true;\n-      *prev_acc_ptr = access;\n-      prev_acc_ptr = &access->next_grp;\n-      total_size += access->size;\n-      i = j;\n-    }\n-\n-  gcc_assert (group_count > 0);\n-  return res;\n-}\n-\n-/* Decide whether parameters with representative accesses given by REPR should\n-   be reduced into components.  */\n-\n-static int\n-decide_one_param_reduction (struct access *repr)\n-{\n-  HOST_WIDE_INT total_size, cur_parm_size;\n-  bool by_ref;\n-  tree parm;\n-\n-  parm = repr->base;\n-  cur_parm_size = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (parm)));\n-  gcc_assert (cur_parm_size > 0);\n-\n-  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n-    by_ref = true;\n-  else\n-    by_ref = false;\n-\n-  if (dump_file)\n-    {\n-      struct access *acc;\n-      fprintf (dump_file, \"Evaluating PARAM group sizes for \");\n-      print_generic_expr (dump_file, parm);\n-      fprintf (dump_file, \" (UID: %u): \\n\", DECL_UID (parm));\n-      for (acc = repr; acc; acc = acc->next_grp)\n-\tdump_access (dump_file, acc, true);\n-    }\n-\n-  total_size = 0;\n-  int new_param_count = 0;\n-\n-  for (; repr; repr = repr->next_grp)\n-    {\n-      gcc_assert (parm == repr->base);\n-\n-      /* Taking the address of a non-addressable field is verboten.  */\n-      if (by_ref && repr->non_addressable)\n-\treturn 0;\n-\n-      /* Do not decompose a non-BLKmode param in a way that would\n-         create BLKmode params.  Especially for by-reference passing\n-\t (thus, pointer-type param) this is hardly worthwhile.  */\n-      if (DECL_MODE (parm) != BLKmode\n-\t  && TYPE_MODE (repr->type) == BLKmode)\n-\treturn 0;\n-\n-      if (!by_ref || (!repr->grp_maybe_modified\n-\t\t      && !repr->grp_not_necessarilly_dereferenced))\n-\ttotal_size += repr->size;\n-      else\n-\ttotal_size += cur_parm_size;\n-\n-      new_param_count++;\n-    }\n-\n-  gcc_assert (new_param_count > 0);\n-\n-  if (!by_ref)\n-    {\n-      if (total_size >= cur_parm_size)\n-\treturn 0;\n-    }\n-  else\n-    {\n-      int parm_num_limit;\n-      if (optimize_function_for_size_p (cfun))\n-\tparm_num_limit = 1;\n-      else\n-\tparm_num_limit = PARAM_VALUE (PARAM_IPA_SRA_PTR_GROWTH_FACTOR);\n-\n-      if (new_param_count > parm_num_limit\n-\t  || total_size > (parm_num_limit * cur_parm_size))\n-\treturn 0;\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"    ....will be split into %i components\\n\",\n-\t     new_param_count);\n-  return new_param_count;\n-}\n-\n-/* The order of the following enums is important, we need to do extra work for\n-   UNUSED_PARAMS, BY_VAL_ACCESSES and UNMODIF_BY_REF_ACCESSES.  */\n-enum ipa_splicing_result { NO_GOOD_ACCESS, UNUSED_PARAMS, BY_VAL_ACCESSES,\n-\t\t\t  MODIF_BY_REF_ACCESSES, UNMODIF_BY_REF_ACCESSES };\n-\n-/* Identify representatives of all accesses to all candidate parameters for\n-   IPA-SRA.  Return result based on what representatives have been found. */\n-\n-static enum ipa_splicing_result\n-splice_all_param_accesses (vec<access_p> &representatives)\n-{\n-  enum ipa_splicing_result result = NO_GOOD_ACCESS;\n-  tree parm;\n-  struct access *repr;\n-\n-  representatives.create (func_param_count);\n-\n-  for (parm = DECL_ARGUMENTS (current_function_decl);\n-       parm;\n-       parm = DECL_CHAIN (parm))\n-    {\n-      if (is_unused_scalar_param (parm))\n-\t{\n-\t  representatives.quick_push (&no_accesses_representant);\n-\t  if (result == NO_GOOD_ACCESS)\n-\t    result = UNUSED_PARAMS;\n-\t}\n-      else if (POINTER_TYPE_P (TREE_TYPE (parm))\n-\t       && is_gimple_reg_type (TREE_TYPE (TREE_TYPE (parm)))\n-\t       && bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))\n-\t{\n-\t  repr = unmodified_by_ref_scalar_representative (parm);\n-\t  representatives.quick_push (repr);\n-\t  if (repr)\n-\t    result = UNMODIF_BY_REF_ACCESSES;\n-\t}\n-      else if (bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))\n-\t{\n-\t  bool ro_grp = false;\n-\t  repr = splice_param_accesses (parm, &ro_grp);\n-\t  representatives.quick_push (repr);\n-\n-\t  if (repr && !no_accesses_p (repr))\n-\t    {\n-\t      if (POINTER_TYPE_P (TREE_TYPE (parm)))\n-\t\t{\n-\t\t  if (ro_grp)\n-\t\t    result = UNMODIF_BY_REF_ACCESSES;\n-\t\t  else if (result < MODIF_BY_REF_ACCESSES)\n-\t\t    result = MODIF_BY_REF_ACCESSES;\n-\t\t}\n-\t      else if (result < BY_VAL_ACCESSES)\n-\t\tresult = BY_VAL_ACCESSES;\n-\t    }\n-\t  else if (no_accesses_p (repr) && (result == NO_GOOD_ACCESS))\n-\t    result = UNUSED_PARAMS;\n-\t}\n-      else\n-\trepresentatives.quick_push (NULL);\n-    }\n-\n-  if (result == NO_GOOD_ACCESS)\n-    {\n-      representatives.release ();\n-      return NO_GOOD_ACCESS;\n-    }\n-\n-  return result;\n-}\n-\n-/* Return the index of BASE in PARMS.  Abort if it is not found.  */\n-\n-static inline int\n-get_param_index (tree base, vec<tree> parms)\n-{\n-  int i, len;\n-\n-  len = parms.length ();\n-  for (i = 0; i < len; i++)\n-    if (parms[i] == base)\n-      return i;\n-  gcc_unreachable ();\n-}\n-\n-/* Convert the decisions made at the representative level into compact\n-   parameter adjustments.  REPRESENTATIVES are pointers to first\n-   representatives of each param accesses, ADJUSTMENTS_COUNT is the expected\n-   final number of adjustments.  */\n-\n-static ipa_parm_adjustment_vec\n-turn_representatives_into_adjustments (vec<access_p> representatives,\n-\t\t\t\t       int adjustments_count)\n-{\n-  vec<tree> parms;\n-  ipa_parm_adjustment_vec adjustments;\n-  tree parm;\n-  int i;\n-\n-  gcc_assert (adjustments_count > 0);\n-  parms = ipa_get_vector_of_formal_parms (current_function_decl);\n-  adjustments.create (adjustments_count);\n-  parm = DECL_ARGUMENTS (current_function_decl);\n-  for (i = 0; i < func_param_count; i++, parm = DECL_CHAIN (parm))\n-    {\n-      struct access *repr = representatives[i];\n-\n-      if (!repr || no_accesses_p (repr))\n-\t{\n-\t  struct ipa_parm_adjustment adj;\n-\n-\t  memset (&adj, 0, sizeof (adj));\n-\t  adj.base_index = get_param_index (parm, parms);\n-\t  adj.base = parm;\n-\t  if (!repr)\n-\t    adj.op = IPA_PARM_OP_COPY;\n-\t  else\n-\t    adj.op = IPA_PARM_OP_REMOVE;\n-\t  adj.arg_prefix = \"ISRA\";\n-\t  adjustments.quick_push (adj);\n-\t}\n-      else\n-\t{\n-\t  struct ipa_parm_adjustment adj;\n-\t  int index = get_param_index (parm, parms);\n-\n-\t  for (; repr; repr = repr->next_grp)\n-\t    {\n-\t      memset (&adj, 0, sizeof (adj));\n-\t      gcc_assert (repr->base == parm);\n-\t      adj.base_index = index;\n-\t      adj.base = repr->base;\n-\t      adj.type = repr->type;\n-\t      adj.alias_ptr_type = reference_alias_ptr_type (repr->expr);\n-\t      adj.offset = repr->offset;\n-\t      adj.reverse = repr->reverse;\n-\t      adj.by_ref = (POINTER_TYPE_P (TREE_TYPE (repr->base))\n-\t\t\t    && (repr->grp_maybe_modified\n-\t\t\t\t|| repr->grp_not_necessarilly_dereferenced));\n-\t      adj.arg_prefix = \"ISRA\";\n-\t      adjustments.quick_push (adj);\n-\t    }\n-\t}\n-    }\n-  parms.release ();\n-  return adjustments;\n-}\n-\n-/* Analyze the collected accesses and produce a plan what to do with the\n-   parameters in the form of adjustments, NULL meaning nothing.  */\n-\n-static ipa_parm_adjustment_vec\n-analyze_all_param_acesses (void)\n-{\n-  enum ipa_splicing_result repr_state;\n-  bool proceed = false;\n-  int i, adjustments_count = 0;\n-  vec<access_p> representatives;\n-  ipa_parm_adjustment_vec adjustments;\n-\n-  repr_state = splice_all_param_accesses (representatives);\n-  if (repr_state == NO_GOOD_ACCESS)\n-    return ipa_parm_adjustment_vec ();\n-\n-  /* If there are any parameters passed by reference which are not modified\n-     directly, we need to check whether they can be modified indirectly.  */\n-  if (repr_state == UNMODIF_BY_REF_ACCESSES)\n-    {\n-      analyze_caller_dereference_legality (representatives);\n-      analyze_modified_params (representatives);\n-    }\n-\n-  for (i = 0; i < func_param_count; i++)\n-    {\n-      struct access *repr = representatives[i];\n-\n-      if (repr && !no_accesses_p (repr))\n-\t{\n-\t  if (repr->grp_scalar_ptr)\n-\t    {\n-\t      adjustments_count++;\n-\t      if (repr->grp_not_necessarilly_dereferenced\n-\t\t  || repr->grp_maybe_modified)\n-\t\trepresentatives[i] = NULL;\n-\t      else\n-\t\t{\n-\t\t  proceed = true;\n-\t\t  sra_stats.scalar_by_ref_to_by_val++;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      int new_components = decide_one_param_reduction (repr);\n-\n-\t      if (new_components == 0)\n-\t\t{\n-\t\t  representatives[i] = NULL;\n-\t\t  adjustments_count++;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  adjustments_count += new_components;\n-\t\t  sra_stats.aggregate_params_reduced++;\n-\t\t  sra_stats.param_reductions_created += new_components;\n-\t\t  proceed = true;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (no_accesses_p (repr))\n-\t    {\n-\t      proceed = true;\n-\t      sra_stats.deleted_unused_parameters++;\n-\t    }\n-\t  adjustments_count++;\n-\t}\n-    }\n-\n-  if (!proceed && dump_file)\n-    fprintf (dump_file, \"NOT proceeding to change params.\\n\");\n-\n-  if (proceed)\n-    adjustments = turn_representatives_into_adjustments (representatives,\n-\t\t\t\t\t\t\t adjustments_count);\n-  else\n-    adjustments = ipa_parm_adjustment_vec ();\n-\n-  representatives.release ();\n-  return adjustments;\n-}\n-\n-/* If a parameter replacement identified by ADJ does not yet exist in the form\n-   of declaration, create it and record it, otherwise return the previously\n-   created one.  */\n-\n-static tree\n-get_replaced_param_substitute (struct ipa_parm_adjustment *adj)\n-{\n-  tree repl;\n-  if (!adj->new_ssa_base)\n-    {\n-      char *pretty_name = make_fancy_name (adj->base);\n-\n-      repl = create_tmp_reg (TREE_TYPE (adj->base), \"ISR\");\n-      DECL_NAME (repl) = get_identifier (pretty_name);\n-      DECL_NAMELESS (repl) = 1;\n-      obstack_free (&name_obstack, pretty_name);\n-\n-      adj->new_ssa_base = repl;\n-    }\n-  else\n-    repl = adj->new_ssa_base;\n-  return repl;\n-}\n-\n-/* Find the first adjustment for a particular parameter BASE in a vector of\n-   ADJUSTMENTS which is not a copy_param.  Return NULL if there is no such\n-   adjustment. */\n-\n-static struct ipa_parm_adjustment *\n-get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)\n-{\n-  int i, len;\n-\n-  len = adjustments.length ();\n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-\n-      adj = &adjustments[i];\n-      if (adj->op != IPA_PARM_OP_COPY && adj->base == base)\n-\treturn adj;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* If OLD_NAME, which is being defined by statement STMT, is an SSA_NAME of a\n-   parameter which is to be removed because its value is not used, create a new\n-   SSA_NAME relating to a replacement VAR_DECL, replace all uses of the\n-   original with it and return it.  If there is no need to re-map, return NULL.\n-   ADJUSTMENTS is a pointer to a vector of IPA-SRA adjustments.  */\n-\n-static tree\n-replace_removed_params_ssa_names (tree old_name, gimple *stmt,\n-\t\t\t\t  ipa_parm_adjustment_vec adjustments)\n-{\n-  struct ipa_parm_adjustment *adj;\n-  tree decl, repl, new_name;\n-\n-  if (TREE_CODE (old_name) != SSA_NAME)\n-    return NULL;\n-\n-  decl = SSA_NAME_VAR (old_name);\n-  if (decl == NULL_TREE\n-      || TREE_CODE (decl) != PARM_DECL)\n-    return NULL;\n-\n-  adj = get_adjustment_for_base (adjustments, decl);\n-  if (!adj)\n-    return NULL;\n-\n-  repl = get_replaced_param_substitute (adj);\n-  new_name = make_ssa_name (repl, stmt);\n-  SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name)\n-    = SSA_NAME_OCCURS_IN_ABNORMAL_PHI (old_name);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"replacing an SSA name of a removed param \");\n-      print_generic_expr (dump_file, old_name);\n-      fprintf (dump_file, \" with \");\n-      print_generic_expr (dump_file, new_name);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  replace_uses_by (old_name, new_name);\n-  return new_name;\n-}\n-\n-/* If the statement STMT contains any expressions that need to replaced with a\n-   different one as noted by ADJUSTMENTS, do so.  Handle any potential type\n-   incompatibilities (GSI is used to accommodate conversion statements and must\n-   point to the statement).  Return true iff the statement was modified.  */\n-\n-static bool\n-sra_ipa_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t       ipa_parm_adjustment_vec adjustments)\n-{\n-  tree *lhs_p, *rhs_p;\n-  bool any;\n-\n-  if (!gimple_assign_single_p (stmt))\n-    return false;\n-\n-  rhs_p = gimple_assign_rhs1_ptr (stmt);\n-  lhs_p = gimple_assign_lhs_ptr (stmt);\n-\n-  any = ipa_modify_expr (rhs_p, false, adjustments);\n-  any |= ipa_modify_expr (lhs_p, false, adjustments);\n-  if (any)\n-    {\n-      tree new_rhs = NULL_TREE;\n-\n-      if (!useless_type_conversion_p (TREE_TYPE (*lhs_p), TREE_TYPE (*rhs_p)))\n-\t{\n-\t  if (TREE_CODE (*rhs_p) == CONSTRUCTOR)\n-\t    {\n-\t      /* V_C_Es of constructors can cause trouble (PR 42714).  */\n-\t      if (is_gimple_reg_type (TREE_TYPE (*lhs_p)))\n-\t\t*rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));\n-\t      else\n-\t\t*rhs_p = build_constructor (TREE_TYPE (*lhs_p),\n-\t\t\t\t\t    NULL);\n-\t    }\n-\t  else\n-\t    new_rhs = fold_build1_loc (gimple_location (stmt),\n-\t\t\t\t       VIEW_CONVERT_EXPR, TREE_TYPE (*lhs_p),\n-\t\t\t\t       *rhs_p);\n-\t}\n-      else if (REFERENCE_CLASS_P (*rhs_p)\n-\t       && is_gimple_reg_type (TREE_TYPE (*lhs_p))\n-\t       && !is_gimple_reg (*lhs_p))\n-\t/* This can happen when an assignment in between two single field\n-\t   structures is turned into an assignment in between two pointers to\n-\t   scalars (PR 42237).  */\n-\tnew_rhs = *rhs_p;\n-\n-      if (new_rhs)\n-\t{\n-\t  tree tmp = force_gimple_operand_gsi (gsi, new_rhs, true, NULL_TREE,\n-\t\t\t\t\t       true, GSI_SAME_STMT);\n-\n-\t  gimple_assign_set_rhs_from_tree (gsi, tmp);\n-\t}\n-\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Traverse the function body and all modifications as described in\n-   ADJUSTMENTS.  Return true iff the CFG has been changed.  */\n-\n-bool\n-ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n-{\n-  bool cfg_changed = false;\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));\n-\t  tree new_lhs, old_lhs = gimple_phi_result (phi);\n-\t  new_lhs = replace_removed_params_ssa_names (old_lhs, phi, adjustments);\n-\t  if (new_lhs)\n-\t    {\n-\t      gimple_phi_set_result (phi, new_lhs);\n-\t      release_ssa_name (old_lhs);\n-\t    }\n-\t}\n-\n-      gsi = gsi_start_bb (bb);\n-      while (!gsi_end_p (gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  bool modified = false;\n-\t  tree *t;\n-\t  unsigned i;\n-\n-\t  switch (gimple_code (stmt))\n-\t    {\n-\t    case GIMPLE_RETURN:\n-\t      t = gimple_return_retval_ptr (as_a <greturn *> (stmt));\n-\t      if (*t != NULL_TREE)\n-\t\tmodified |= ipa_modify_expr (t, true, adjustments);\n-\t      break;\n-\n-\t    case GIMPLE_ASSIGN:\n-\t      modified |= sra_ipa_modify_assign (stmt, &gsi, adjustments);\n-\t      break;\n-\n-\t    case GIMPLE_CALL:\n-\t      /* Operands must be processed before the lhs.  */\n-\t      for (i = 0; i < gimple_call_num_args (stmt); i++)\n-\t\t{\n-\t\t  t = gimple_call_arg_ptr (stmt, i);\n-\t\t  modified |= ipa_modify_expr (t, true, adjustments);\n-\t\t}\n-\n-\t      if (gimple_call_lhs (stmt))\n-\t\t{\n-\t\t  t = gimple_call_lhs_ptr (stmt);\n-\t\t  modified |= ipa_modify_expr (t, false, adjustments);\n-\t\t}\n-\t      break;\n-\n-\t    case GIMPLE_ASM:\n-\t      {\n-\t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n-\t\tfor (i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n-\t\t  {\n-\t\t    t = &TREE_VALUE (gimple_asm_input_op (asm_stmt, i));\n-\t\t    modified |= ipa_modify_expr (t, true, adjustments);\n-\t\t  }\n-\t\tfor (i = 0; i < gimple_asm_noutputs (asm_stmt); i++)\n-\t\t  {\n-\t\t    t = &TREE_VALUE (gimple_asm_output_op (asm_stmt, i));\n-\t\t    modified |= ipa_modify_expr (t, false, adjustments);\n-\t\t  }\n-\t      }\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\n-\t  def_operand_p defp;\n-\t  ssa_op_iter iter;\n-\t  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)\n-\t    {\n-\t      tree old_def = DEF_FROM_PTR (defp);\n-\t      if (tree new_def = replace_removed_params_ssa_names (old_def, stmt,\n-\t\t\t\t\t\t\t\t   adjustments))\n-\t\t{\n-\t\t  SET_DEF (defp, new_def);\n-\t\t  release_ssa_name (old_def);\n-\t\t  modified = true;\n-\t\t}\n-\t    }\n-\n-\t  if (modified)\n-\t    {\n-\t      update_stmt (stmt);\n-\t      if (maybe_clean_eh_stmt (stmt)\n-\t\t  && gimple_purge_dead_eh_edges (gimple_bb (stmt)))\n-\t\tcfg_changed = true;\n-\t    }\n-\t  gsi_next (&gsi);\n-\t}\n-    }\n-\n-  return cfg_changed;\n-}\n-\n-/* Call gimple_debug_bind_reset_value on all debug statements describing\n-   gimple register parameters that are being removed or replaced.  */\n-\n-static void\n-sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n-{\n-  int i, len;\n-  gimple_stmt_iterator *gsip = NULL, gsi;\n-\n-  if (MAY_HAVE_DEBUG_STMTS && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n-    {\n-      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n-      gsip = &gsi;\n-    }\n-  len = adjustments.length ();\n-  for (i = 0; i < len; i++)\n-    {\n-      struct ipa_parm_adjustment *adj;\n-      imm_use_iterator ui;\n-      gimple *stmt;\n-      gdebug *def_temp;\n-      tree name, vexpr, copy = NULL_TREE;\n-      use_operand_p use_p;\n-\n-      adj = &adjustments[i];\n-      if (adj->op == IPA_PARM_OP_COPY || !is_gimple_reg (adj->base))\n-\tcontinue;\n-      name = ssa_default_def (cfun, adj->base);\n-      vexpr = NULL;\n-      if (name)\n-\tFOR_EACH_IMM_USE_STMT (stmt, ui, name)\n-\t  {\n-\t    if (gimple_clobber_p (stmt))\n-\t      {\n-\t\tgimple_stmt_iterator cgsi = gsi_for_stmt (stmt);\n-\t\tunlink_stmt_vdef (stmt);\n-\t\tgsi_remove (&cgsi, true);\n-\t\trelease_defs (stmt);\n-\t\tcontinue;\n-\t      }\n-\t    /* All other users must have been removed by\n-\t       ipa_sra_modify_function_body.  */\n-\t    gcc_assert (is_gimple_debug (stmt));\n-\t    if (vexpr == NULL && gsip != NULL)\n-\t      {\n-\t\tgcc_assert (TREE_CODE (adj->base) == PARM_DECL);\n-\t\tvexpr = make_node (DEBUG_EXPR_DECL);\n-\t\tdef_temp = gimple_build_debug_source_bind (vexpr, adj->base,\n-\t\t\t\t\t\t\t   NULL);\n-\t\tDECL_ARTIFICIAL (vexpr) = 1;\n-\t\tTREE_TYPE (vexpr) = TREE_TYPE (name);\n-\t\tSET_DECL_MODE (vexpr, DECL_MODE (adj->base));\n-\t\tgsi_insert_before (gsip, def_temp, GSI_SAME_STMT);\n-\t      }\n-\t    if (vexpr)\n-\t      {\n-\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, ui)\n-\t\t  SET_USE (use_p, vexpr);\n-\t      }\n-\t    else\n-\t      gimple_debug_bind_reset_value (stmt);\n-\t    update_stmt (stmt);\n-\t  }\n-      /* Create a VAR_DECL for debug info purposes.  */\n-      if (!DECL_IGNORED_P (adj->base))\n-\t{\n-\t  copy = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n-\t\t\t     VAR_DECL, DECL_NAME (adj->base),\n-\t\t\t     TREE_TYPE (adj->base));\n-\t  if (DECL_PT_UID_SET_P (adj->base))\n-\t    SET_DECL_PT_UID (copy, DECL_PT_UID (adj->base));\n-\t  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (adj->base);\n-\t  TREE_READONLY (copy) = TREE_READONLY (adj->base);\n-\t  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (adj->base);\n-\t  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (adj->base);\n-\t  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (adj->base);\n-\t  DECL_IGNORED_P (copy) = DECL_IGNORED_P (adj->base);\n-\t  DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (adj->base);\n-\t  DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n-\t  SET_DECL_RTL (copy, 0);\n-\t  TREE_USED (copy) = 1;\n-\t  DECL_CONTEXT (copy) = current_function_decl;\n-\t  add_local_decl (cfun, copy);\n-\t  DECL_CHAIN (copy) =\n-\t    BLOCK_VARS (DECL_INITIAL (current_function_decl));\n-\t  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = copy;\n-\t}\n-      if (gsip != NULL && copy && target_for_debug_bind (adj->base))\n-\t{\n-\t  gcc_assert (TREE_CODE (adj->base) == PARM_DECL);\n-\t  if (vexpr)\n-\t    def_temp = gimple_build_debug_bind (copy, vexpr, NULL);\n-\t  else\n-\t    def_temp = gimple_build_debug_source_bind (copy, adj->base,\n-\t\t\t\t\t\t       NULL);\n-\t  gsi_insert_before (gsip, def_temp, GSI_SAME_STMT);\n-\t}\n-    }\n-}\n-\n-/* Return false if all callers have at least as many actual arguments as there\n-   are formal parameters in the current function and that their types\n-   match.  */\n-\n-static bool\n-some_callers_have_mismatched_arguments_p (struct cgraph_node *node,\n-\t\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n-{\n-  struct cgraph_edge *cs;\n-  for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (!cs->call_stmt || !callsite_arguments_match_p (cs->call_stmt))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Return false if all callers have vuse attached to a call statement.  */\n-\n-static bool\n-some_callers_have_no_vuse_p (struct cgraph_node *node,\n-\t\t\t     void *data ATTRIBUTE_UNUSED)\n-{\n-  struct cgraph_edge *cs;\n-  for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (!cs->call_stmt || !gimple_vuse (cs->call_stmt))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Convert all callers of NODE.  */\n-\n-static bool\n-convert_callers_for_node (struct cgraph_node *node,\n-\t\t          void *data)\n-{\n-  ipa_parm_adjustment_vec *adjustments = (ipa_parm_adjustment_vec *) data;\n-  bitmap recomputed_callers = BITMAP_ALLOC (NULL);\n-  struct cgraph_edge *cs;\n-\n-  for (cs = node->callers; cs; cs = cs->next_caller)\n-    {\n-      push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"Adjusting call %s -> %s\\n\",\n-\t\t cs->caller->dump_name (), cs->callee->dump_name ());\n-\n-      ipa_modify_call_arguments (cs, cs->call_stmt, *adjustments);\n-\n-      pop_cfun ();\n-    }\n-\n-  for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (bitmap_set_bit (recomputed_callers, cs->caller->get_uid ())\n-\t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n-      compute_fn_summary (cs->caller, true);\n-  BITMAP_FREE (recomputed_callers);\n-\n-  return true;\n-}\n-\n-/* Convert all callers of NODE to pass parameters as given in ADJUSTMENTS.  */\n-\n-static void\n-convert_callers (struct cgraph_node *node, tree old_decl,\n-\t\t ipa_parm_adjustment_vec adjustments)\n-{\n-  basic_block this_block;\n-\n-  node->call_for_symbol_and_aliases (convert_callers_for_node,\n-\t\t\t\t     &adjustments, false);\n-\n-  if (!encountered_recursive_call)\n-    return;\n-\n-  FOR_EACH_BB_FN (this_block, cfun)\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n-        {\n-\t  gcall *stmt;\n-\t  tree call_fndecl;\n-\t  stmt = dyn_cast <gcall *> (gsi_stmt (gsi));\n-\t  if (!stmt)\n-\t    continue;\n-\t  call_fndecl = gimple_call_fndecl (stmt);\n-\t  if (call_fndecl == old_decl)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Adjusting recursive call\");\n-\t      gimple_call_set_fndecl (stmt, node->decl);\n-\t      ipa_modify_call_arguments (NULL, stmt, adjustments);\n-\t    }\n-\t}\n-    }\n-\n-  return;\n-}\n-\n-/* Perform all the modification required in IPA-SRA for NODE to have parameters\n-   as given in ADJUSTMENTS.  Return true iff the CFG has been changed.  */\n-\n-static bool\n-modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n-{\n-  struct cgraph_node *new_node;\n-  bool cfg_changed;\n-\n-  cgraph_edge::rebuild_edges ();\n-  free_dominance_info (CDI_DOMINATORS);\n-  pop_cfun ();\n-\n-  /* This must be done after rebuilding cgraph edges for node above.\n-     Otherwise any recursive calls to node that are recorded in\n-     redirect_callers will be corrupted.  */\n-  vec<cgraph_edge *> redirect_callers = node->collect_callers ();\n-  new_node = node->create_version_clone_with_body (redirect_callers, NULL,\n-\t\t\t\t\t\t   NULL, false, NULL, NULL,\n-\t\t\t\t\t\t   \"isra\");\n-  redirect_callers.release ();\n-\n-  push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n-  ipa_modify_formal_parameters (current_function_decl, adjustments);\n-  cfg_changed = ipa_sra_modify_function_body (adjustments);\n-  sra_ipa_reset_debug_stmts (adjustments);\n-  convert_callers (new_node, node->decl, adjustments);\n-  new_node->make_local ();\n-  return cfg_changed;\n-}\n-\n-/* Means of communication between ipa_sra_check_caller and\n-   ipa_sra_preliminary_function_checks.  */\n-\n-struct ipa_sra_check_caller_data\n-{\n-  bool has_callers;\n-  bool bad_arg_alignment;\n-  bool has_thunk;\n-};\n-\n-/* If NODE has a caller, mark that fact in DATA which is pointer to\n-   ipa_sra_check_caller_data.  Also check all aggregate arguments in all known\n-   calls if they are unit aligned and if not, set the appropriate flag in DATA\n-   too. */\n-\n-static bool\n-ipa_sra_check_caller (struct cgraph_node *node, void *data)\n-{\n-  if (!node->callers)\n-    return false;\n-\n-  struct ipa_sra_check_caller_data *iscc;\n-  iscc = (struct ipa_sra_check_caller_data *) data;\n-  iscc->has_callers = true;\n-\n-  for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n-    {\n-      if (cs->caller->thunk.thunk_p)\n-\t{\n-\t  iscc->has_thunk = true;\n-\t  return true;\n-\t}\n-      gimple *call_stmt = cs->call_stmt;\n-      unsigned count = gimple_call_num_args (call_stmt);\n-      for (unsigned i = 0; i < count; i++)\n-\t{\n-\t  tree arg = gimple_call_arg (call_stmt, i);\n-\t  if (is_gimple_reg (arg))\n-\t      continue;\n-\n-\t  tree offset;\n-\t  poly_int64 bitsize, bitpos;\n-\t  machine_mode mode;\n-\t  int unsignedp, reversep, volatilep = 0;\n-\t  get_inner_reference (arg, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t       &unsignedp, &reversep, &volatilep);\n-\t  if (!multiple_p (bitpos, BITS_PER_UNIT))\n-\t    {\n-\t      iscc->bad_arg_alignment = true;\n-\t      return true;\n-\t    }\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n-/* Return false the function is apparently unsuitable for IPA-SRA based on it's\n-   attributes, return true otherwise.  NODE is the cgraph node of the current\n-   function.  */\n-\n-static bool\n-ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n-{\n-  if (!node->can_be_local_p ())\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function not local to this compilation unit.\\n\");\n-      return false;\n-    }\n-\n-  if (!node->local.can_change_signature)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function cannot change signature.\\n\");\n-      return false;\n-    }\n-\n-  if (!tree_versionable_function_p (node->decl))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function is not versionable.\\n\");\n-      return false;\n-    }\n-\n-  if (!opt_for_fn (node->decl, optimize)\n-      || !opt_for_fn (node->decl, flag_ipa_sra))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function not optimized.\\n\");\n-      return false;\n-    }\n-\n-  if (DECL_VIRTUAL_P (current_function_decl))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function is a virtual method.\\n\");\n-      return false;\n-    }\n-\n-  if ((DECL_ONE_ONLY (node->decl) || DECL_EXTERNAL (node->decl))\n-      && ipa_fn_summaries->get (node)\n-      && ipa_fn_summaries->get (node)->size >= MAX_INLINE_INSNS_AUTO)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function too big to be made truly local.\\n\");\n-      return false;\n-    }\n-\n-  if (cfun->stdarg)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function uses stdarg. \\n\");\n-      return false;\n-    }\n-\n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n-    return false;\n-\n-  if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Always inline function will be inlined \"\n-\t\t \"anyway. \\n\");\n-      return false;\n-    }\n-\n-  struct ipa_sra_check_caller_data iscc;\n-  memset (&iscc, 0, sizeof(iscc));\n-  node->call_for_symbol_and_aliases (ipa_sra_check_caller, &iscc, true);\n-  if (!iscc.has_callers)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"Function has no callers in this compilation unit.\\n\");\n-      return false;\n-    }\n-\n-  if (iscc.bad_arg_alignment)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"A function call has an argument with non-unit alignment.\\n\");\n-      return false;\n-    }\n-\n-  if (iscc.has_thunk)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"A has thunk.\\n\");\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Perform early interprocedural SRA.  */\n-\n-static unsigned int\n-ipa_early_sra (void)\n-{\n-  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n-  ipa_parm_adjustment_vec adjustments;\n-  int ret = 0;\n-\n-  if (!ipa_sra_preliminary_function_checks (node))\n-    return 0;\n-\n-  sra_initialize ();\n-  sra_mode = SRA_MODE_EARLY_IPA;\n-\n-  if (!find_param_candidates ())\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function has no IPA-SRA candidates.\\n\");\n-      goto simple_out;\n-    }\n-\n-  if (node->call_for_symbol_and_aliases\n-       (some_callers_have_mismatched_arguments_p, NULL, true))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"There are callers with insufficient number of \"\n-\t\t \"arguments or arguments with type mismatches.\\n\");\n-      goto simple_out;\n-    }\n-\n-  if (node->call_for_symbol_and_aliases\n-       (some_callers_have_no_vuse_p, NULL, true))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"There are callers with no VUSE attached \"\n-\t\t \"to a call stmt.\\n\");\n-      goto simple_out;\n-    }\n-\n-  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n-\t\t\t\t func_param_count\n-\t\t\t\t * last_basic_block_for_fn (cfun));\n-  final_bbs = BITMAP_ALLOC (NULL);\n-\n-  scan_function ();\n-  if (encountered_apply_args)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function calls  __builtin_apply_args().\\n\");\n-      goto out;\n-    }\n-\n-  if (encountered_unchangable_recursive_call)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Function calls itself with insufficient \"\n-\t\t \"number of arguments.\\n\");\n-      goto out;\n-    }\n-\n-  adjustments = analyze_all_param_acesses ();\n-  if (!adjustments.exists ())\n-    goto out;\n-  if (dump_file)\n-    ipa_dump_param_adjustments (dump_file, adjustments, current_function_decl);\n-\n-  if (modify_function (node, adjustments))\n-    ret = TODO_update_ssa | TODO_cleanup_cfg;\n-  else\n-    ret = TODO_update_ssa;\n-  adjustments.release ();\n-\n-  statistics_counter_event (cfun, \"Unused parameters deleted\",\n-\t\t\t    sra_stats.deleted_unused_parameters);\n-  statistics_counter_event (cfun, \"Scalar parameters converted to by-value\",\n-\t\t\t    sra_stats.scalar_by_ref_to_by_val);\n-  statistics_counter_event (cfun, \"Aggregate parameters broken up\",\n-\t\t\t    sra_stats.aggregate_params_reduced);\n-  statistics_counter_event (cfun, \"Aggregate parameter components created\",\n-\t\t\t    sra_stats.param_reductions_created);\n-\n- out:\n-  BITMAP_FREE (final_bbs);\n-  free (bb_dereferences);\n- simple_out:\n-  sra_deinitialize ();\n-  return ret;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_early_ipa_sra =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"eipa_sra\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_IPA_SRA, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_dump_symtab, /* todo_flags_finish */\n-};\n-\n-class pass_early_ipa_sra : public gimple_opt_pass\n-{\n-public:\n-  pass_early_ipa_sra (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_early_ipa_sra, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_ipa_sra && dbg_cnt (eipa_sra); }\n-  virtual unsigned int execute (function *) { return ipa_early_sra (); }\n-\n-}; // class pass_early_ipa_sra\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_early_ipa_sra (gcc::context *ctxt)\n-{\n-  return new pass_early_ipa_sra (ctxt);\n-}"}, {"sha": "8baf09fa0a43abc26033b9328c89ece7e69661b4", "filename": "gcc/tree-sra.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-sra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4/gcc%2Ftree-sra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.h?ref=ff6686d2e5f797d6c6a36ad14a7084bc1dc350e4", "patch": "@@ -0,0 +1,31 @@\n+/* Scalar Replacement of Aggregates (SRA) converts some structure\n+   references into scalar references, exposing them to the scalar\n+   optimizers.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+bool type_internals_preclude_sra_p (tree type, const char **msg);\n+\n+/* Return true iff TYPE is stdarg va_list type (which early SRA and IPA-SRA\n+   should leave alone).  */\n+\n+static inline bool\n+is_va_list_type (tree type)\n+{\n+  return TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (va_list_type_node);\n+}"}]}