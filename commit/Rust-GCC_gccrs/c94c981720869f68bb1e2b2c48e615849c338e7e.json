{"sha": "c94c981720869f68bb1e2b2c48e615849c338e7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0Yzk4MTcyMDg2OWY2OGJiMWUyYjJjNDhlNjE1ODQ5YzMzOGU3ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-16T21:47:17Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-16T21:47:17Z"}, "message": "mips-protos.h (mips_legitimate_address_p): New function.\n\n\t* config/mips/mips-protos.h (mips_legitimate_address_p): New\n\tfunction.\n\t(mips_reg_mode_ok_for_base_p): Likewise.\n\t* config/mips/mips.h (REG_OK_STRICT_P): Don't define.\n\t(REG_OK_FOR_INDEX_P): Define unconditionally.\n\t(REG_MODE_OK_FOR_BASE_P): Use mips_reg_mode_ok_for_base_p.\n\t(GO_IF_LEGITIMATE_ADDRESS): Use mips_legitimate_address_p.\n\t* config/mips/mips.c (mips16_simple_memory_operand): Adjust now\n\tthat GET_MODE_SIZE is unsigned.\n\t(mips_reg_mode_ok_for_base_p): Define.\n\t(mips_legitimate_address_p): Likewise.  Adjust now\n\tthat GET_MODE_SIZE is unsigned.\n\t(block_move_loop): Make the number of bytes unsigned.\n\t(expand_block_move): Likewise.\n\t(function_arg): Make the loop counter unsigned to match the\n\tboundary condition.\n\nFrom-SVN: r33188", "tree": {"sha": "8102cb69f67414484bfae05a563bafc66216daa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8102cb69f67414484bfae05a563bafc66216daa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c94c981720869f68bb1e2b2c48e615849c338e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94c981720869f68bb1e2b2c48e615849c338e7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94c981720869f68bb1e2b2c48e615849c338e7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94c981720869f68bb1e2b2c48e615849c338e7e/comments", "author": null, "committer": null, "parents": [{"sha": "d636c18c54181f8bf09f5c75bb9b517bba3efb69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d636c18c54181f8bf09f5c75bb9b517bba3efb69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d636c18c54181f8bf09f5c75bb9b517bba3efb69"}], "stats": {"total": 301, "additions": 178, "deletions": 123}, "files": [{"sha": "9f8908778afa043bdf0e3aab8039afb9b0a41056", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c94c981720869f68bb1e2b2c48e615849c338e7e", "patch": "@@ -1,3 +1,22 @@\n+2000-04-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* config/mips/mips-protos.h (mips_legitimate_address_p): New\n+\tfunction.\n+\t(mips_reg_mode_ok_for_base_p): Likewise.\n+\t* config/mips/mips.h (REG_OK_STRICT_P): Don't define.\n+\t(REG_OK_FOR_INDEX_P): Define unconditionally.\n+\t(REG_MODE_OK_FOR_BASE_P): Use mips_reg_mode_ok_for_base_p.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use mips_legitimate_address_p.\n+\t* config/mips/mips.c (mips16_simple_memory_operand): Adjust now\n+\tthat GET_MODE_SIZE is unsigned.\n+\t(mips_reg_mode_ok_for_base_p): Define.\n+\t(mips_legitimate_address_p): Likewise.  Adjust now\n+\tthat GET_MODE_SIZE is unsigned.\n+\t(block_move_loop): Make the number of bytes unsigned.\n+\t(expand_block_move): Likewise.\n+\t(function_arg): Make the loop counter unsigned to match the\n+\tboundary condition.\n+\n 2000-04-16  Richard Henderson  <rth@cygnus.com>\n \n \t* rtl.h (enum insn_note): New enumeration.  Subsume"}, {"sha": "6f9f59b221f4122246d6b4497d3a8bcf0baa2504", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=c94c981720869f68bb1e2b2c48e615849c338e7e", "patch": "@@ -130,6 +130,8 @@ extern int\t\tse_uns_arith_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tse_arith_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tse_nonmemory_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tse_nonimmediate_operand PARAMS ((rtx, enum machine_mode));\n+extern int              mips_legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n+extern int              mips_reg_mode_ok_for_base_p PARAMS ((rtx, enum machine_mode, int));\n extern int              extend_operator PARAMS ((rtx, enum machine_mode));\n extern int              highpart_shift_operator PARAMS ((rtx, enum machine_mode));\n extern int\t\tm16_uimm3_b PARAMS ((rtx, enum machine_mode));"}, {"sha": "c19f35f57e6f0d90ff41984b6f2ac5ae458946d0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 141, "deletions": 8, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c94c981720869f68bb1e2b2c48e615849c338e7e", "patch": "@@ -91,8 +91,10 @@ static enum internal_test map_test_to_internal_test\tPARAMS ((enum rtx_code));\n static int mips16_simple_memory_operand\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\tenum machine_mode));\n static int m16_check_op\t\t\t\tPARAMS ((rtx, int, int, int));\n-static void block_move_loop\t\t\tPARAMS ((rtx, rtx, int, int,\n-\t\t\t\t\t\t\trtx, rtx));\n+static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t unsigned int, \n+\t\t\t\t\t\t\t int,\n+\t\t\t\t\t\t\t rtx, rtx));\n static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n static FILE *mips_make_temp_file\t\tPARAMS ((void));\n static void save_restore_insns\t\t\tPARAMS ((int, rtx,\n@@ -671,7 +673,8 @@ mips16_simple_memory_operand (reg, offset, mode)\n      rtx offset;\n      enum machine_mode mode;\n {\n-  int size, off;\n+  unsigned int size;\n+  int off;\n \n   if (mode == BLKmode)\n     {\n@@ -1208,6 +1211,136 @@ mips_check_split (address, mode)\n \n   return 0;\n }\n+\n+/* This function is used to implement REG_MODE_OK_FOR_BASE_P.  */\n+\n+int\n+mips_reg_mode_ok_for_base_p (reg, mode, strict)\n+     rtx reg;\n+     enum machine_mode mode;\n+     int strict;\n+{\n+  return (strict \n+\t  ? REGNO_MODE_OK_FOR_BASE_P (REGNO (reg), mode)\n+\t  : GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (reg), mode));\n+}\n+\n+/* This function is used to implement GO_IF_LEGITIMATE_ADDRESS.  It\n+   returns a nonzero value if XINSN is a legitimate address for a\n+   memory operand of the indicated MODE.  STRICT is non-zero if this\n+   function is called during reload.  */\n+\n+int\n+mips_legitimate_address_p (mode, xinsn, strict)\n+     enum machine_mode mode;\n+     rtx xinsn;\n+     int strict;\n+{\n+  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\n+    {\t\t\t\t\t\t\t\t\t\n+      GO_PRINTF2 (\"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\t\n+\t\t  strict ? \"\" : \"not \");\t\t\t\n+      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\n+    }\t\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+  /* Check for constant before stripping off SUBREG, so that we don't\t\n+     accept (subreg (const_int)) which will fail to reload. */   \t\n+  if (CONSTANT_ADDRESS_P (xinsn)\t\t\t\t\t\n+      && ! (mips_split_addresses && mips_check_split (xinsn, mode))\t\n+      && (! TARGET_MIPS16 || mips16_constant (xinsn, mode, 1, 0)))\t\n+    return 1;\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+  while (GET_CODE (xinsn) == SUBREG)\t\t\t\t\t\n+    xinsn = SUBREG_REG (xinsn);\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+  /* The mips16 can only use the stack pointer as a base register when\t\n+     loading SImode or DImode values.  */\t\t\t\t\n+  if (GET_CODE (xinsn) == REG \n+      && mips_reg_mode_ok_for_base_p (xinsn, mode, strict))\t\n+    return 1;\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+  if (GET_CODE (xinsn) == LO_SUM && mips_split_addresses)\t\t\n+    {\t\t\t\t\t\t\t\t\t\n+      register rtx xlow0 = XEXP (xinsn, 0);\t\t\t\t\n+      register rtx xlow1 = XEXP (xinsn, 1);\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+      while (GET_CODE (xlow0) == SUBREG)\t\t\t\t\n+\txlow0 = SUBREG_REG (xlow0);\t\t\t\t\t\n+      if (GET_CODE (xlow0) == REG\t\t\t\t\t\n+\t  && mips_reg_mode_ok_for_base_p (xlow0, mode, strict)\n+\t  && mips_check_split (xlow1, mode))\n+\treturn 1;\t\t\t\t\t\t\t\n+    }\t\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+  if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\n+    {\t\t\t\t\t\t\t\t\t\n+      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\n+      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\n+      register enum rtx_code code0;\t\t\t\t\t\n+      register enum rtx_code code1;\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+      while (GET_CODE (xplus0) == SUBREG)\t\t\t\t\n+\txplus0 = SUBREG_REG (xplus0);\t\t\t\t\t\n+      code0 = GET_CODE (xplus0);\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+      while (GET_CODE (xplus1) == SUBREG)\t\t\t\t\n+\txplus1 = SUBREG_REG (xplus1);\t\t\t\t\t\n+      code1 = GET_CODE (xplus1);\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+      /* The mips16 can only use the stack pointer as a base register\t\n+         when loading SImode or DImode values.  */\t\t\t\n+      if (code0 == REG \n+\t  && mips_reg_mode_ok_for_base_p (xplus0, mode, strict))\t\n+\t{\t\t\t\t\t\t\t\t\n+\t  if (code1 == CONST_INT && SMALL_INT (xplus1))\n+\t    return 1;\n+\t\t\t\t\t\t\t\t\t\n+\t  /* On the mips16, we represent GP relative offsets in RTL.\t\n+             These are 16 bit signed values, and can serve as register\t\n+             offsets.  */\t\t\t\t\t\t\n+\t  if (TARGET_MIPS16\t\t\t\t\t\t\n+\t      && mips16_gp_offset_p (xplus1))\t\t\t\t\n+\t    return 1;\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+\t  /* For some code sequences, you actually get better code by\t\n+\t     pretending that the MIPS supports an address mode of a\t\n+\t     constant address + a register, even though the real\t\n+\t     machine doesn't support it.  This is because the\t\t\n+\t     assembler can use $r1 to load just the high 16 bits, add\t\n+\t     in the register, and fold the low 16 bits into the memory\t\n+\t     reference, whereas the compiler generates a 4 instruction\t\n+\t     sequence.  On the other hand, CSE is not as effective.\t\n+\t     It would be a win to generate the lui directly, but the\t\n+\t     MIPS assembler does not have syntax to generate the\t\n+\t     appropriate relocation.  */\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+\t  /* Also accept CONST_INT addresses here, so no else.  */\t\n+\t  /* Reject combining an embedded PIC text segment reference\t\n+\t     with a register.  That requires an additional\t\t\n+\t     instruction.  */\t\t\t\t\t\t\n+          /* ??? Reject combining an address with a register for the MIPS  \n+\t     64 bit ABI, because the SGI assembler can not handle this.  */ \n+\t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\n+\t      && (mips_abi == ABI_32\t\t\t\t\t\n+\t\t  || mips_abi == ABI_O64\t\t\t\t\n+\t\t  || mips_abi == ABI_EABI)\t\t\t\t\n+\t      && CONSTANT_ADDRESS_P (xplus1)\t\t\t\t\n+\t      && ! mips_split_addresses\t\t\t\t\t\n+\t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\n+\t\t  || code1 != CONST\t\t\t\t\t\n+\t\t  || GET_CODE (XEXP (xplus1, 0)) != MINUS)\t\t\n+\t      && !TARGET_MIPS16)\t\t\t\t\t\n+\t    return 1;\t\t\t\t\t\t\t\n+\t}\t\t\t\t\t\t\t\t\n+    }\t\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\t\n+  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\n+    GO_PRINTF (\"Not a legitimate address\\n\");\n+  \n+  /* The address was not legitimate.  */\n+  return 0;\n+}\n+\n \f\n /* We need a lot of little routines to check constant values on the\n    mips16.  These are used to figure out how long the instruction will\n@@ -3033,7 +3166,7 @@ static void\n block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src)\n      rtx dest_reg;\t\t/* register holding destination address */\n      rtx src_reg;\t\t/* register holding source address */\n-     int bytes;\t\t\t/* # bytes to move */\n+     unsigned int bytes;\t/* # bytes to move */\n      int align;\t\t\t/* alignment */\n      rtx orig_dest;\t\t/* original dest for change_address */\n      rtx orig_src;\t\t/* original source for making a reg note */\n@@ -3145,14 +3278,14 @@ expand_block_move (operands)\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n   int constp = GET_CODE (bytes_rtx) == CONST_INT;\n-  HOST_WIDE_INT bytes = constp ? INTVAL (bytes_rtx) : 0;\n-  int align = INTVAL (align_rtx);\n+  unsigned HOST_WIDE_INT bytes = constp ? INTVAL (bytes_rtx) : 0;\n+  unsigned int align = INTVAL (align_rtx);\n   rtx orig_src\t= operands[1];\n   rtx orig_dest\t= operands[0];\n   rtx src_reg;\n   rtx dest_reg;\n \n-  if (constp && bytes <= 0)\n+  if (constp && bytes == 0)\n     return;\n \n   if (align > UNITS_PER_WORD)\n@@ -3863,7 +3996,7 @@ function_arg (cum, mode, type, named)\n \t      unsigned int chunks;\n \t      HOST_WIDE_INT bitpos;\n \t      unsigned int regno;\n-\t      int i;\n+\t      unsigned int i;\n \n \t      /* ??? If this is a packed structure, then the last hunk won't\n \t\t be 64 bits.  */"}, {"sha": "d455d9e3059ed602145fa2431eba4b4e99438f4e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 16, "deletions": 115, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c981720869f68bb1e2b2c48e615849c338e7e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c94c981720869f68bb1e2b2c48e615849c338e7e", "patch": "@@ -2725,21 +2725,15 @@ typedef struct mips_args {\n    need to be strict.  */\n \n #ifndef REG_OK_STRICT\n-\n-#define REG_OK_STRICT_P 0\n-#define REG_OK_FOR_INDEX_P(X) 0\n #define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n-  GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (X), (MODE))\n-\n+  mips_reg_mode_ok_for_base_p (X, MODE, 0)\n #else\n-\n-#define REG_OK_STRICT_P 1\n-#define REG_OK_FOR_INDEX_P(X) 0\n #define REG_MODE_OK_FOR_BASE_P(X, MODE) \\\n-  REGNO_MODE_OK_FOR_BASE_P (REGNO (X), (MODE))\n-\n+  mips_reg_mode_ok_for_base_p (X, MODE, 1)\n #endif\n \n+#define REG_OK_FOR_INDEX_P(X) 0\n+\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -2806,112 +2800,19 @@ typedef struct mips_args {\n #define GO_DEBUG_RTX(x)\n #endif\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  register rtx xinsn = (X);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      GO_PRINTF2 (\"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\t\\\n-\t\t  (REG_OK_STRICT_P) ? \"\" : \"not \");\t\t\t\\\n-      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Check for constant before stripping off SUBREG, so that we don't\t\\\n-     accept (subreg (const_int)) which will fail to reload. */   \t\\\n-  if (CONSTANT_ADDRESS_P (xinsn)\t\t\t\t\t\\\n-      && ! (mips_split_addresses && mips_check_split (xinsn, MODE))\t\\\n-      && (! TARGET_MIPS16 || mips16_constant (xinsn, MODE, 1, 0)))\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  while (GET_CODE (xinsn) == SUBREG)\t\t\t\t\t\\\n-    xinsn = SUBREG_REG (xinsn);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* The mips16 can only use the stack pointer as a base register when\t\\\n-     loading SImode or DImode values.  */\t\t\t\t\\\n-  if (GET_CODE (xinsn) == REG && REG_MODE_OK_FOR_BASE_P (xinsn, MODE))\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xinsn) == LO_SUM && mips_split_addresses)\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register rtx xlow0 = XEXP (xinsn, 0);\t\t\t\t\\\n-      register rtx xlow1 = XEXP (xinsn, 1);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      while (GET_CODE (xlow0) == SUBREG)\t\t\t\t\\\n-\txlow0 = SUBREG_REG (xlow0);\t\t\t\t\t\\\n-      if (GET_CODE (xlow0) == REG\t\t\t\t\t\\\n-\t  && REG_MODE_OK_FOR_BASE_P (xlow0, MODE)\t\t\t\\\n-\t  && mips_check_split (xlow1, MODE))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\\\n-      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\\\n-      register enum rtx_code code0;\t\t\t\t\t\\\n-      register enum rtx_code code1;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      while (GET_CODE (xplus0) == SUBREG)\t\t\t\t\\\n-\txplus0 = SUBREG_REG (xplus0);\t\t\t\t\t\\\n-      code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      while (GET_CODE (xplus1) == SUBREG)\t\t\t\t\\\n-\txplus1 = SUBREG_REG (xplus1);\t\t\t\t\t\\\n-      code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* The mips16 can only use the stack pointer as a base register\t\\\n-         when loading SImode or DImode values.  */\t\t\t\\\n-      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, MODE))\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (code1 == CONST_INT\t\t\t\t\t\\\n-\t      && INTVAL (xplus1) >= -32768\t\t\t\t\\\n-\t      && INTVAL (xplus1) + GET_MODE_SIZE (MODE) - 1 <= 32767)\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  /* On the mips16, we represent GP relative offsets in RTL.\t\\\n-             These are 16 bit signed values, and can serve as register\t\\\n-             offsets.  */\t\t\t\t\t\t\\\n-\t  if (TARGET_MIPS16\t\t\t\t\t\t\\\n-\t      && mips16_gp_offset_p (xplus1))\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  /* For some code sequences, you actually get better code by\t\\\n-\t     pretending that the MIPS supports an address mode of a\t\\\n-\t     constant address + a register, even though the real\t\\\n-\t     machine doesn't support it.  This is because the\t\t\\\n-\t     assembler can use $r1 to load just the high 16 bits, add\t\\\n-\t     in the register, and fold the low 16 bits into the memory\t\\\n-\t     reference, whereas the compiler generates a 4 instruction\t\\\n-\t     sequence.  On the other hand, CSE is not as effective.\t\\\n-\t     It would be a win to generate the lui directly, but the\t\\\n-\t     MIPS assembler does not have syntax to generate the\t\\\n-\t     appropriate relocation.  */\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  /* Also accept CONST_INT addresses here, so no else.  */\t\\\n-\t  /* Reject combining an embedded PIC text segment reference\t\\\n-\t     with a register.  That requires an additional\t\t\\\n-\t     instruction.  */\t\t\t\t\t\t\\\n-          /* ??? Reject combining an address with a register for the MIPS  \\\n-\t     64 bit ABI, because the SGI assembler can not handle this.  */ \\\n-\t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n-\t      && (mips_abi == ABI_32\t\t\t\t\t\\\n-\t\t  || mips_abi == ABI_O64\t\t\t\t\\\n-\t\t  || mips_abi == ABI_EABI)\t\t\t\t\\\n-\t      && CONSTANT_ADDRESS_P (xplus1)\t\t\t\t\\\n-\t      && ! mips_split_addresses\t\t\t\t\t\\\n-\t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\\\n-\t\t  || code1 != CONST\t\t\t\t\t\\\n-\t\t  || GET_CODE (XEXP (xplus1, 0)) != MINUS)\t\t\\\n-\t      && !TARGET_MIPS16)\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n-    GO_PRINTF (\"Not a legitimate address\\n\");\t\t\t\t\\\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\\\n+  if (mips_legitimate_address_p (MODE, X, 1))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n }\n-\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\\\n+  if (mips_legitimate_address_p (MODE, X, 0))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+#endif\n \n /* A C expression that is 1 if the RTX X is a constant which is a\n    valid address.  This is defined to be the same as `CONSTANT_P (X)',"}]}