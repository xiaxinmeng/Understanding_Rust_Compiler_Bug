{"sha": "d7463e5b31fdabbd5dea5a9d62d26049538119d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NjNlNWIzMWZkYWJiZDVkZWE1YTlkNjJkMjYwNDk1MzgxMTlkNQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-07-04T20:25:28Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-07-04T20:25:28Z"}, "message": "resolve.c (resolve_assoc_var): Fix corank setting.\n\n2014-07-04  Tobias Burnus  <burnus@net-b.de>\n\n        * resolve.c (resolve_assoc_var): Fix corank setting.\n        * trans-array.c (gfc_conv_descriptor_token): Change assert.\n        for select-type temporaries.\n        * trans-decl.c (generate_coarray_sym_init): Skip for\n        attr.select_type_temporary. \n        * trans-expr.c (gfc_conv_procedure_call): Fix for\n        select-type temporaries.\n        * trans-intrinsic.c (get_caf_token_offset): Ditto.\n        (gfc_conv_intrinsic_caf_get, gfc_conv_intrinsic_caf_send): Set\n        the correct dtype.\n        * trans-types.h (gfc_get_dtype_rank_type): New.\n        * trans-types.c (gfc_get_dtype_rank_type): Ditto.\n\n2014-07-04  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray/coindexed_3.f90: New.\n\nFrom-SVN: r212299", "tree": {"sha": "9b639f2bcc6747c5eb2d446c0a24b47efea7b0e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b639f2bcc6747c5eb2d446c0a24b47efea7b0e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7463e5b31fdabbd5dea5a9d62d26049538119d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7463e5b31fdabbd5dea5a9d62d26049538119d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7463e5b31fdabbd5dea5a9d62d26049538119d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7463e5b31fdabbd5dea5a9d62d26049538119d5/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a908485ae78349d22fc353a64563c0ab5e3eb16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a908485ae78349d22fc353a64563c0ab5e3eb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a908485ae78349d22fc353a64563c0ab5e3eb16"}], "stats": {"total": 157, "additions": 136, "deletions": 21}, "files": [{"sha": "b3764b8ea17782f09c061c731445a02b4a89fb4e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -1,3 +1,18 @@\n+2014-07-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* resolve.c (resolve_assoc_var): Fix corank setting.\n+\t* trans-array.c (gfc_conv_descriptor_token): Change assert.\n+\tfor select-type temporaries.\n+\t* trans-decl.c (generate_coarray_sym_init): Skip for\n+\tattr.select_type_temporary. \n+\t* trans-expr.c (gfc_conv_procedure_call): Fix for\n+\tselect-type temporaries.\n+\t* trans-intrinsic.c (get_caf_token_offset): Ditto.\n+\t(gfc_conv_intrinsic_caf_get, gfc_conv_intrinsic_caf_send): Set\n+\tthe correct dtype.\n+\t* trans-types.h (gfc_get_dtype_rank_type): New.\n+\t* trans-types.c (gfc_get_dtype_rank_type): Ditto.\n+\n 2014-07-03  Tobias Burnus  <burnus@net-b.de>\n \t\n \t* scanner.c (skip_free_comments): Fix indentation."}, {"sha": "15d8dab0efff7cdac4272cd7c4b7511a3626bbb3", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -7912,10 +7912,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       sym->as = gfc_get_array_spec ();\n       sym->as->rank = target->rank;\n       sym->as->type = AS_DEFERRED;\n-\n-      /* Target must not be coindexed, thus the associate-variable\n-\t has no corank.  */\n-      sym->as->corank = 0;\n+      sym->as->corank = gfc_get_corank (target);\n     }\n \n   /* Mark this as an associate variable.  */"}, {"sha": "0e018991c0a0801c8313301acb32605bf2d3facb", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -298,7 +298,6 @@ gfc_conv_descriptor_token (tree desc)\n \n   type = TREE_TYPE (desc);\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n-  gcc_assert (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE);\n   gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n   field = gfc_advance_chain (TYPE_FIELDS (type), CAF_TOKEN_FIELD);\n "}, {"sha": "93c59b11b669f900efa8a52f92a3baf2899187a0", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -4670,7 +4670,8 @@ generate_coarray_sym_init (gfc_symbol *sym)\n   tree tmp, size, decl, token;\n \n   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension\n-      || sym->attr.use_assoc || !sym->attr.referenced)\n+      || sym->attr.use_assoc || !sym->attr.referenced\n+      || sym->attr.select_type_temporary)\n     return;\n \n   decl = sym->backend_decl;"}, {"sha": "dba51b081f476d023b71a821f3aa7d7628aa41bf", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -4813,7 +4813,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  caf_type = TREE_TYPE (caf_decl);\n \n \t  if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n-\t      && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n+\t      && (GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE\n+\t\t  || GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_POINTER))\n \t    tmp = gfc_conv_descriptor_token (caf_decl);\n \t  else if (DECL_LANG_SPECIFIC (caf_decl)\n \t\t   && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)"}, {"sha": "5aa56838ae7f3c237154de8eed1d865ed486f885", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -1179,7 +1179,8 @@ get_caf_token_offset (tree *token, tree *offset, tree caf_decl, tree se_expr,\n \n   /* Offset between the coarray base address and the address wanted.  */\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl))\n-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_ALLOCATABLE)\n+      && (GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_ALLOCATABLE\n+\t  || GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_POINTER))\n     *offset = build_int_cst (gfc_array_index_type, 0);\n   else if (DECL_LANG_SPECIFIC (caf_decl)\n \t   && GFC_DECL_CAF_OFFSET (caf_decl) != NULL_TREE)\n@@ -1285,7 +1286,10 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind)\n \t  ar->type = AR_FULL;\n \t}\n       gfc_conv_expr_descriptor (&argse, array_expr);\n-\n+      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n+         has the wrong type if component references are done.  */\n+      gfc_add_modify (&argse.pre, gfc_conv_descriptor_dtype (argse.expr),\n+                      gfc_get_dtype_rank_type (array_expr->rank, type));\n       if (has_vector)\n \t{\n \t  vec = conv_caf_vector_subscript (&argse.pre, argse.expr, ar);\n@@ -1387,7 +1391,12 @@ conv_caf_send (gfc_code *code) {\n \t}\n       lhs_se.want_pointer = 1;\n       gfc_conv_expr_descriptor (&lhs_se, lhs_expr);\n-      lhs_type = gfc_get_element_type (TREE_TYPE (TREE_TYPE (lhs_se.expr)));\n+      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n+         has the wrong type if component references are done.  */\n+      lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);\n+      tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);\n+      gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),\n+                      gfc_get_dtype_rank_type (lhs_expr->rank, lhs_type));\n       if (has_vector)\n \t{\n \t  vec = conv_caf_vector_subscript (&block, lhs_se.expr, ar);\n@@ -1440,6 +1449,7 @@ conv_caf_send (gfc_code *code) {\n          vector bounds separately.  */\n       gfc_array_ref *ar, ar2;\n       bool has_vector = false;\n+      tree tmp2;\n \n       if (gfc_is_coindexed (rhs_expr) && gfc_has_vector_subscript (rhs_expr))\n \t{\n@@ -1452,6 +1462,12 @@ conv_caf_send (gfc_code *code) {\n \t}\n       rhs_se.want_pointer = 1;\n       gfc_conv_expr_descriptor (&rhs_se, rhs_expr);\n+      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n+         has the wrong type if component references are done.  */\n+      tmp = build_fold_indirect_ref_loc (input_location, rhs_se.expr);\n+      tmp2 = gfc_typenode_for_spec (&rhs_expr->ts);\n+      gfc_add_modify (&rhs_se.pre, gfc_conv_descriptor_dtype (tmp),\n+                      gfc_get_dtype_rank_type (rhs_expr->rank, tmp2));\n       if (has_vector)\n \t{\n \t  rhs_vec = conv_caf_vector_subscript (&block, rhs_se.expr, ar);"}, {"sha": "e55e2d9c1f5e8248644a3a8629a29eacadc18b2f", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -1395,23 +1395,13 @@ gfc_get_desc_dim_type (void)\n    unknown cases abort.  */\n \n tree\n-gfc_get_dtype (tree type)\n+gfc_get_dtype_rank_type (int rank, tree etype)\n {\n   tree size;\n   int n;\n   HOST_WIDE_INT i;\n   tree tmp;\n   tree dtype;\n-  tree etype;\n-  int rank;\n-\n-  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type) || GFC_ARRAY_TYPE_P (type));\n-\n-  if (GFC_TYPE_ARRAY_DTYPE (type))\n-    return GFC_TYPE_ARRAY_DTYPE (type);\n-\n-  rank = GFC_TYPE_ARRAY_RANK (type);\n-  etype = gfc_get_element_type (type);\n \n   switch (TREE_CODE (etype))\n     {\n@@ -1477,6 +1467,26 @@ gfc_get_dtype (tree type)\n   /* TODO: Check this is actually true, particularly when repacking\n      assumed size parameters.  */\n \n+  return dtype;\n+}\n+\n+\n+tree\n+gfc_get_dtype (tree type)\n+{\n+  tree dtype;\n+  tree etype;\n+  int rank;\n+\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type) || GFC_ARRAY_TYPE_P (type));\n+\n+  if (GFC_TYPE_ARRAY_DTYPE (type))\n+    return GFC_TYPE_ARRAY_DTYPE (type);\n+\n+  rank = GFC_TYPE_ARRAY_RANK (type);\n+  etype = gfc_get_element_type (type);\n+  dtype = gfc_get_dtype_rank_type (rank, etype);\n+\n   GFC_TYPE_ARRAY_DTYPE (type) = dtype;\n   return dtype;\n }"}, {"sha": "bd3e69c2bab8365c382ac647526ae1a57d9eac7d", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -97,6 +97,7 @@ int gfc_return_by_reference (gfc_symbol *);\n int gfc_is_nodesc_array (gfc_symbol *);\n \n /* Return the DTYPE for an array.  */\n+tree gfc_get_dtype_rank_type (int, tree);\n tree gfc_get_dtype (tree);\n \n tree gfc_get_ppc_type (gfc_component *);"}, {"sha": "93f9d35f71a6ea6f5f13268cfc9195149108dee6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -1,3 +1,7 @@\n+2014-07-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray/coindexed_3.f90: New.\n+\n 2014-07-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/61654"}, {"sha": "46488f3855d001c27786469e1e66fa500ea7062e", "filename": "gcc/testsuite/gfortran.dg/coarray/coindexed_3.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoindexed_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7463e5b31fdabbd5dea5a9d62d26049538119d5/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoindexed_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoindexed_3.f90?ref=d7463e5b31fdabbd5dea5a9d62d26049538119d5", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+!\n+! Contributed by Reinhold Bader\n+!\n+\n+program pmup\n+  implicit none\n+  type t\n+    integer :: b, a\n+  end type t\n+\n+  CLASS(*), allocatable :: a(:)[:]\n+  integer :: ii\n+\n+  !! --- ONE --- \n+  allocate(real :: a(3)[*])\n+  IF (this_image() == num_images()) THEN\n+    SELECT TYPE (a)\n+      TYPE IS (real)\n+      a(:)[1] = 2.0\n+    END SELECT\n+  END IF\n+  SYNC ALL\n+\n+  IF (this_image() == 1) THEN\n+    SELECT TYPE (a)\n+      TYPE IS (real)\n+        IF (ALL(A(:)[1] == 2.0)) THEN\n+          !WRITE(*,*) 'OK'\n+        ELSE\n+          WRITE(*,*) 'FAIL'\n+          call abort()\n+        END IF\n+      TYPE IS (t)\n+        ii = a(1)[1]%a\n+        call abort()\n+      CLASS IS (t)\n+        ii = a(1)[1]%a\n+        call abort()\n+    END SELECT\n+  END IF\n+\n+  !! --- TWO --- \n+  deallocate(a)\n+  allocate(t :: a(3)[*])\n+  IF (this_image() == num_images()) THEN\n+    SELECT TYPE (a)\n+      TYPE IS (t)\n+      a(:)[1]%a = 4.0\n+    END SELECT\n+  END IF\n+  SYNC ALL\n+\n+  IF (this_image() == 1) THEN\n+    SELECT TYPE (a)\n+   TYPE IS (real)\n+      ii = a(1)[1]\n+      call abort()\n+    TYPE IS (t)\n+      IF (ALL(A(:)[1]%a == 4.0)) THEN\n+        !WRITE(*,*) 'OK'\n+      ELSE\n+        WRITE(*,*) 'FAIL'\n+        call abort()\n+      END IF\n+    CLASS IS (t)\n+      ii = a(1)[1]%a\n+      call abort()\n+    END SELECT\n+  END IF\n+end program"}]}