{"sha": "92724e1d707ea2821c9a94517ba3b830f84eb296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3MjRlMWQ3MDdlYTI4MjFjOWE5NDUxN2JhM2I4MzBmODRlYjI5Ng==", "commit": {"author": {"name": "Basile Starynkevitch", "email": "basile@starynkevitch.net", "date": "2010-11-25T19:03:27Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-11-25T19:03:27Z"}, "message": "gentype-state.c: Add new file.\n\n2010-11-25  Basile Starynkevitch  <basile@starynkevitch.net>\n\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n\n\t* gentype-state.c: Add new file.\n\n\t* gengtype.c (type count): New variable.\n\t(new_structure, find_param_structure, create_pointer)\n\t(create_array): Use it to set state_number in types.\n\t(dump_everything): Improve comment.\n\t(main): Call read_state and write_state. Print type_count.\n\n\t* gengtype.h (type_lineloc): New function.\n\t(read_state, write_state): New declarations.\n\n\t* Makefile.in (GENGTYPE_FLAGS): New variable.\n\t(s-gtype): Run gengtype twice and generate gtype.state.\n\t(build/gengtype-state.o): New rule.\n\t(build/gengtype$(build_exeext)): Link gengtype-state.o.\n\t(mostlyclean): Update comment.  Remove gtype.state.\n\n\nCo-Authored-By: Jeremie Salvucci <jeremie.salvucci@free.fr>\n\nFrom-SVN: r167150", "tree": {"sha": "e0e8eaea81b8a2157370fd1822a8fd68c29a5a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0e8eaea81b8a2157370fd1822a8fd68c29a5a3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92724e1d707ea2821c9a94517ba3b830f84eb296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92724e1d707ea2821c9a94517ba3b830f84eb296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92724e1d707ea2821c9a94517ba3b830f84eb296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92724e1d707ea2821c9a94517ba3b830f84eb296/comments", "author": {"login": "bstarynk", "id": 90412, "node_id": "MDQ6VXNlcjkwNDEy", "avatar_url": "https://avatars.githubusercontent.com/u/90412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstarynk", "html_url": "https://github.com/bstarynk", "followers_url": "https://api.github.com/users/bstarynk/followers", "following_url": "https://api.github.com/users/bstarynk/following{/other_user}", "gists_url": "https://api.github.com/users/bstarynk/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstarynk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstarynk/subscriptions", "organizations_url": "https://api.github.com/users/bstarynk/orgs", "repos_url": "https://api.github.com/users/bstarynk/repos", "events_url": "https://api.github.com/users/bstarynk/events{/privacy}", "received_events_url": "https://api.github.com/users/bstarynk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f759884521f40179bd1296c5a4f30fd3b6a378ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f759884521f40179bd1296c5a4f30fd3b6a378ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f759884521f40179bd1296c5a4f30fd3b6a378ce"}], "stats": {"total": 2544, "additions": 2533, "deletions": 11}, "files": [{"sha": "c7b2ab4ad924b01654bb7d6b3ec2d5b8e12b9825", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92724e1d707ea2821c9a94517ba3b830f84eb296", "patch": "@@ -1,3 +1,23 @@\n+2010-11-25  Basile Starynkevitch  <basile@starynkevitch.net>\n+\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\n+\t* gentype-state.c: Add new file.\n+\n+\t* gengtype.c (type count): New variable.\n+\t(new_structure, find_param_structure, create_pointer)\n+\t(create_array): Use it to set state_number in types.\n+\t(dump_everything): Improve comment.\n+\t(main): Call read_state and write_state. Print type_count.\n+\n+\t* gengtype.h (type_lineloc): New function.\n+\t(read_state, write_state): New declarations.\n+\n+\t* Makefile.in (GENGTYPE_FLAGS): New variable.\n+\t(s-gtype): Run gengtype twice and generate gtype.state.\n+\t(build/gengtype-state.o): New rule.\n+\t(build/gengtype$(build_exeext)): Link gengtype-state.o.\n+\t(mostlyclean): Update comment.  Remove gtype.state.\n+\n 2010-11-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/46637"}, {"sha": "20e01aa0b57ac5cbfc9ace4453d3c622a0a06590", "filename": "gcc/Makefile.in", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=92724e1d707ea2821c9a94517ba3b830f84eb296", "patch": "@@ -3819,6 +3819,9 @@ ALL_GTFILES_H := $(sort $(GTFILES_H) $(GTFILES_LANG_H))\n \n $(ALL_GTFILES_H) gtype-desc.c gtype-desc.h : s-gtype ; @true\n \n+### Common flags to gengtype [e.g. -v or -B backupdir]\n+GENGTYPE_FLAGS= \n+\n gtyp-input.list: s-gtyp-input ; @true\n s-gtyp-input: Makefile\n \t@: $(call write_entries_to_file,$(GTFILES),tmp-gi.list)\n@@ -3827,7 +3830,13 @@ s-gtyp-input: Makefile\n \n s-gtype: build/gengtype$(build_exeext) $(filter-out [%], $(GTFILES)) \\\n \t gtyp-input.list\n-\t$(RUN_GEN) build/gengtype$(build_exeext) -S $(srcdir) -I gtyp-input.list\n+# First, parse all files and save a state file.\n+\t$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \\\n+                    -S $(srcdir) -I gtyp-input.list -w gtype.state\n+# Second, read the state file and generate all files.  This ensure that\n+# gtype.state is correctly read:\n+\t$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \\\n+                    -r gtype.state\n \t$(STAMP) s-gtype\n \n generated_files = config.h tm.h $(TM_P_H) $(TM_H) multilib.h \\\n@@ -3923,6 +3932,8 @@ build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n build/gengtype-lex.o : gengtype-lex.c gengtype.h $(BCONFIG_H) $(SYSTEM_H)\n build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)\t\\\n   $(SYSTEM_H)\n+build/gengtype-state.o: gengtype-state.c gengtype.h $(BCONFIG_H)\t\\\n+  $(SYSTEM_H) errors.h\n build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h \t\\\n   rtl.def insn-notes.def errors.h double-int.h $(HASHTAB_H)             \\\n   $(OBSTACK_H) $(XREGEX_H)\n@@ -3968,7 +3979,7 @@ build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n # These programs are not linked with the MD reader.\n build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o \\\n-              build/version.o\n+              build/gengtype-state.o build/version.o\n \n # Rule for the generator programs:\n $(genprog:%=build/gen%$(build_exeext)): build/gen%$(build_exeext): build/gen%.o $(BUILD_LIBDEPS)\n@@ -4441,9 +4452,10 @@ mostlyclean: lang.mostlyclean\n \t-rm -f core */core\n # Delete file generated for gengtype\n \t-rm -f gtyp-input.list\n-# Delete files generated by gengtype.c\n+# Delete files generated by gengtype\n \t-rm -f gtype-*\n \t-rm -f gt-*\n+\t-rm -f gtype.state\n # Delete genchecksum outputs\n \t-rm -f *-checksum.c\n "}, {"sha": "e6909f2e765fc5fdd748a5c40f2f094e5a8d2478", "filename": "gcc/gengtype-state.c", "status": "added", "additions": 2439, "deletions": 0, "changes": 2439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=92724e1d707ea2821c9a94517ba3b830f84eb296", "patch": "@@ -0,0 +1,2439 @@\n+/* Gengtype persistent state serialization & de-serialization.\n+   Useful for gengtype in plugin mode.\n+\n+   Copyright (C) 2010  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.\n+\n+   Contributed by Jeremie Salvucci <jeremie.salvucci@free.fr>\n+   and Basile Starynkevitch <basile@starynkevitch.net>\n+*/\n+\n+#include \"bconfig.h\"\n+#include \"system.h\"\n+#include \"errors.h\"\t/* For fatal.  */\n+#include \"double-int.h\"\n+#include \"hashtab.h\"\n+#include \"version.h\"\t/* For version_string & pkgversion_string.  */\n+#include \"obstack.h\"\n+#include \"gengtype.h\"\n+\n+\n+\n+/* Gives the file location of a type, if any.  */\n+static inline struct fileloc*\n+type_lineloc (const_type_p ty)\n+{\n+  if (!ty)\n+    return NULL;\n+  switch (ty->kind)\n+    {\n+    case TYPE_NONE:\n+      gcc_unreachable ();\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+      return CONST_CAST (struct fileloc*, &ty->u.s.line);\n+    case TYPE_PARAM_STRUCT:\n+      return CONST_CAST (struct fileloc*, &ty->u.param_struct.line);\n+    case TYPE_SCALAR:\n+    case TYPE_STRING:\n+    case TYPE_POINTER:\n+    case TYPE_ARRAY:\n+      return NULL;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* The state file has simplistic lispy lexical tokens.  Its lexer gives\n+   a linked list of struct state_token_st, thru the peek_state_token\n+   function.  Lexical tokens are consumed with next_state_tokens.  */\n+\n+\n+/* The lexical kind of each lispy token.  */\n+enum state_token_en\n+{\n+  STOK_NONE,                    /* Never used.  */\n+  STOK_INTEGER,                 /* Integer token.  */\n+  STOK_STRING,                  /* String token.  */\n+  STOK_LEFTPAR,                 /* Left opening parenthesis.  */\n+  STOK_RIGHTPAR,                /* Right closing parenthesis.  */\n+  STOK_NAME                     /* hash-consed name or identifier.  */\n+};\n+\n+\n+/* Structure and hash-table used to share identifiers or names.  */\n+struct state_ident_st\n+{\n+  /* TODO: We could improve the parser by reserving identifiers for\n+     state keywords and adding a keyword number for them.  That would\n+     mean adding another field in this state_ident_st struct.  */\n+  char stid_name[1];\t\t/* actually bigger & null terminated */\n+};\n+static htab_t state_ident_tab;\n+\n+\n+/* The state_token_st structure is for lexical tokens in the read\n+   state file.  The stok_kind field discriminates the union.  Tokens\n+   are allocated by peek_state_token which calls read_a_state_token\n+   which allocate them.  Tokens are freed by calls to\n+   next_state_tokens.  Token are organized in a FIFO look-ahead queue\n+   filled by peek_state_token.  */\n+struct state_token_st\n+{\n+  enum state_token_en stok_kind;\t/* the lexical kind\n+\t\t\t\t\t   discriminates the stok_un\n+\t\t\t\t\t   union  */\n+  int stok_line;\t\t\t/* the line number */\n+  int stok_col;\t\t\t\t/* the column number */\n+  const char *stok_file;\t\t/* the file path */\n+  struct state_token_st *stok_next;\t/* the next token in the\n+\t\t\t\t\t   queue, when peeked */\n+  union\t\t                        /* discriminated by stok_kind! */\n+  {\n+    int stok_num;\t\t\t/* when STOK_INTEGER */\n+    char stok_string[1];\t\t/* when STOK_STRING, actual size is\n+\t\t\t\t\t   bigger and null terminated */\n+    struct state_ident_st *stok_ident;\t/* when STOK_IDENT */\n+    void *stok_ptr;\t\t        /* null otherwise */\n+  }\n+  stok_un;\n+};\n+\n+\n+\n+\n+#define NULL_STATE_TOKEN (struct state_token_st*)0\n+\n+/* the state_token pointer contains the leftmost current token.  The\n+   tokens are organized in a linked queue, using stok_next, for token\n+   look-ahead.  */\n+struct state_token_st *state_token = NULL_STATE_TOKEN;\n+\n+/* Used by the reading lexer.  */\n+static FILE *state_file;\n+static const char *state_path = NULL;\n+static int state_line = 0;\n+static long state_bol = 0;\t/* offset of beginning of line */\n+\n+\n+/* Counter of written types.  */\n+static int state_written_type_count = 0;\n+\n+\n+/* Fatal error messages when reading the state.  They are extremely\n+   unlikely, and only appear when this gengtype-state.c file is buggy,\n+   or when reading a gengtype state which was not generated by the\n+   same version of gengtype or GCC.  */\n+\n+\n+/* Fatal message while reading state.  */\n+static inline void \n+fatal_reading_state (struct state_token_st* tok, const char*msg)\n+{\n+  if (tok)\n+    fatal (\"%s:%d:%d: Invalid state file; %s\",\n+\t   tok->stok_file, tok->stok_line, tok->stok_col, \n+\t   msg); \n+  else\n+    fatal (\"%s:%d: Invalid state file; %s\", \n+\t   state_path, state_line, msg);\n+}\n+\n+\n+/* Fatal printf-like message while reading state.  This can't be a\n+   function, because there is no way to pass a va_arg to a variant of\n+   fatal.  */\n+#define fatal_reading_state_printf(Tok,Fmt,...) do {\t\\\n+    struct state_token_st* badtok = Tok;\t\t\\\n+    if (badtok)\t\t\t\t\t\t\\\n+      fatal (\"%s:%d:%d: Invalid state file; \" Fmt,\t\\\n+\t      badtok->stok_file,\t\t\t\\\n+\t      badtok->stok_line,\t\t\t\\\n+\t      badtok->stok_col, __VA_ARGS__);\t\t\\\n+    else\t\t\t\t\t\t\\\n+      fatal (\"%s:%d: Invalid state file; \" Fmt,\t\t\\\n+\t     state_path, state_line, __VA_ARGS__);\t\\\n+  } while(0)\n+\n+\n+/* Find or allocate an identifier in our name hash table.  */\n+static struct state_ident_st *\n+state_ident_by_name (const char *name, enum insert_option optins)\n+{\n+  PTR *slot = NULL;\n+  int namlen = 0;\n+  struct state_ident_st *stid = NULL;\n+\n+  if (!name || !name[0])\n+    return NULL;\n+\n+  slot = htab_find_slot (state_ident_tab, name, optins);\n+  if (!slot)\n+    return NULL;\n+\n+  namlen = strlen (name);\n+  stid =\n+    (struct state_ident_st *) xmalloc (sizeof (struct state_ident_st) +\n+\t\t\t\t       namlen);\n+  memset (stid, 0, sizeof (struct state_ident_st) + namlen);\n+  strcpy (stid->stid_name, name);\n+  *slot = stid;\n+\n+  return stid;\n+}\n+\n+/* Our token lexer is heavily inspired by MELT's lexer, and share some\n+   code with the file gcc/melt-runtime.c of the GCC MELT branch!  We\n+   really want the gengtype state to be easily parsable by MELT.  This\n+   is a usual lispy lexing routine, dealing with spaces and comments,\n+   numbers, parenthesis, names, strings.  */\n+static struct state_token_st *\n+read_a_state_token (void)\n+{\n+  int c = 0;\n+  long curoff = 0;\n+  struct state_token_st *tk = NULL;\n+\n+ again: /* Read again, e.g. after a comment or spaces.  */\n+  c = getc (state_file);\n+  if (c == EOF)\n+    return NULL;\n+\n+  /* Handle spaces, count lines.  */\n+  if (c == '\\n')\n+    {\n+      state_line++;\n+      state_bol = curoff = ftell (state_file);\n+      goto again;\n+    };\n+  if (ISSPACE (c))\n+    goto again;\n+  /* Skip comments starting with semi-colon.  */\n+  if (c == ';')\n+    {\t\n+      do\n+\t{\n+\t  c = getc (state_file);\n+\t}\n+      while (c > 0 && c != '\\n');\n+      if (c == '\\n')\n+\t{\n+\t  state_line++;\n+\t  state_bol = curoff = ftell (state_file);\n+\t}\n+      goto again;\n+    };\n+  /* Read signed numbers.  */\n+  if (ISDIGIT (c) || c == '-' || c == '+')\n+    {\t\t\t\t/* number */\n+      int n = 0;\n+      ungetc (c, state_file);\n+      curoff = ftell (state_file);\n+      if (fscanf (state_file, \"%d\", &n) <= 0)\n+\tfatal_reading_state (NULL_STATE_TOKEN, \"Lexical error in number\");\n+      tk = XCNEW (struct state_token_st);\n+      tk->stok_kind = STOK_INTEGER;\n+      tk->stok_line = state_line;\n+      tk->stok_col = curoff - state_bol;\n+      tk->stok_file = state_path;\n+      tk->stok_next = NULL;\n+      tk->stok_un.stok_num = n;\n+\n+      return tk;\n+    }\n+  /* Read an opening left parenthesis.  */\n+  else if (c == '(')\n+    {\n+      curoff = ftell (state_file);\n+      tk = XCNEW (struct state_token_st);\n+      tk->stok_kind = STOK_LEFTPAR;\n+      tk->stok_line = state_line;\n+      tk->stok_col = curoff - state_bol;\n+      tk->stok_file = state_path;\n+      tk->stok_next = NULL;\n+\n+      return tk;\n+    }\n+  /* Read an closing right parenthesis.  */\n+  else if (c == ')')\n+    {\n+      curoff = ftell (state_file);\n+      tk = XCNEW (struct state_token_st);\n+      tk->stok_kind = STOK_RIGHTPAR;\n+      tk->stok_line = state_line;\n+      tk->stok_col = curoff - state_bol;\n+      tk->stok_file = state_path;\n+      tk->stok_next = NULL;\n+\n+      return tk;\n+    }\n+  /* Read identifiers, using an obstack.  */\n+  else if (ISALPHA (c) || c == '_' || c == '$' || c == '!' || c == '#')\n+    {\n+      struct obstack id_obstack;\n+      struct state_ident_st *sid = NULL;\n+      char *ids = NULL;\n+      obstack_init (&id_obstack);\n+      curoff = ftell (state_file);\n+      while (ISALNUM (c) || c == '_' || c == '$' || c == '!' || c == '#')\n+\t{\n+\t  obstack_1grow (&id_obstack, c);\n+\t  c = getc (state_file);\n+\t  if (c < 0)\n+\t    break;\n+\t};\n+      if (c >= 0)\n+\tungetc (c, state_file);\n+      obstack_1grow (&id_obstack, (char) 0);\n+      ids = XOBFINISH (&id_obstack, char *);\n+      sid = state_ident_by_name (ids, INSERT);\n+      obstack_free (&id_obstack, ids);\n+      ids = NULL;\n+      tk = XCNEW (struct state_token_st);\n+      tk->stok_kind = STOK_NAME;\n+      tk->stok_line = state_line;\n+      tk->stok_col = curoff - state_bol;\n+      tk->stok_file = state_path;\n+      tk->stok_next = NULL;\n+      tk->stok_un.stok_ident = sid;\n+\n+      return tk;\n+    }\n+  /* Read a string, dealing with escape sequences a la C! */\n+  else if (c == '\"')\n+    {\n+      char *cstr = NULL;\n+      int cslen = 0;\n+      struct obstack bstring_obstack;\n+      obstack_init (&bstring_obstack);\n+      curoff = ftell (state_file);\n+      while ((c = getc (state_file)) != '\"' && c >= 0)\n+\t{\n+\t  if (ISPRINT (c) && c != '\\\\')\n+\t    obstack_1grow (&bstring_obstack, (char) c);\n+\t  else if (ISSPACE (c) && c != '\\n')\n+\t    obstack_1grow (&bstring_obstack, (char) c);\n+\t  else if (c == '\\\\')\n+\t    {\n+\t      c = getc (state_file);\n+\t      switch (c)\n+\t\t{\n+\t\tcase 'a':\n+\t\t  obstack_1grow (&bstring_obstack, '\\a');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 'b':\n+\t\t  obstack_1grow (&bstring_obstack, '\\b');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 't':\n+\t\t  obstack_1grow (&bstring_obstack, '\\t');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 'n':\n+\t\t  obstack_1grow (&bstring_obstack, '\\n');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 'v':\n+\t\t  obstack_1grow (&bstring_obstack, '\\v');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 'f':\n+\t\t  obstack_1grow (&bstring_obstack, '\\f');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 'r':\n+\t\t  obstack_1grow (&bstring_obstack, '\\r');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase '\"':\n+\t\t  obstack_1grow (&bstring_obstack, '\\\"');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase '\\\\':\n+\t\t  obstack_1grow (&bstring_obstack, '\\\\');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase ' ':\n+\t\t  obstack_1grow (&bstring_obstack, ' ');\n+\t\t  c = getc (state_file);\n+\t\t  break;\n+\t\tcase 'x':\n+\t\t  {\n+\t\t    unsigned int cx = 0;\n+\t\t    if (fscanf (state_file, \"%02x\", &cx) > 0 && cx > 0)\n+\t\t      obstack_1grow (&bstring_obstack, cx);\n+\t\t    else\n+\t\t      fatal_reading_state\n+\t\t\t(NULL_STATE_TOKEN,\n+\t\t\t \"Lexical error in string hex escape\");\n+\t\t    c = getc (state_file);\n+\t\t    break;\n+\t\t  }\n+\t\tdefault:\n+\t\t  fatal_reading_state\n+\t\t    (NULL_STATE_TOKEN,\n+\t\t     \"Lexical error - unknown string escape\");\n+\t\t}\n+\t    }\n+\t  else\n+\t    fatal_reading_state (NULL_STATE_TOKEN, \"Lexical error...\");\n+\t};\n+      if (c != '\"')\n+\tfatal_reading_state (NULL_STATE_TOKEN, \"Unterminated string\");\n+      obstack_1grow (&bstring_obstack, '\\0');\n+      cstr = XOBFINISH (&bstring_obstack, char *);\n+      cslen = strlen (cstr);\n+      tk = (struct state_token_st *)\n+\txcalloc (sizeof (struct state_token_st) + cslen, 1);\n+      tk->stok_kind = STOK_STRING;\n+      tk->stok_line = state_line;\n+      tk->stok_col = curoff - state_bol;\n+      tk->stok_file = state_path;\n+      tk->stok_next = NULL;\n+      strcpy (tk->stok_un.stok_string, cstr);\n+      obstack_free (&bstring_obstack, cstr);\n+\n+      return tk;\n+    }\n+  /* Got an unexpected character.  */\n+  fatal_reading_state_printf\n+    (NULL_STATE_TOKEN,\n+     \"Lexical error at offset %ld - bad character \\\\%03o = '%c'\",\n+     ftell (state_file), c, c);\n+}\n+\n+/* Used for lexical look-ahead.  Retrieves the lexical token of rank\n+   DEPTH, starting with 0 when reading the state file.  Gives null on\n+   end of file.  */\n+static struct state_token_st *\n+peek_state_token (int depth)\n+{\n+  int remdepth = depth;\n+  struct state_token_st **ptoken = &state_token;\n+  struct state_token_st *tok = NULL;\n+\n+  while (remdepth >= 0)\n+    {\n+      if (*ptoken == NULL)\n+\t{\n+\t  *ptoken = tok = read_a_state_token ();\n+\t  if (tok == NULL)\n+\t    return NULL;\n+\t}\n+      tok = *ptoken;\n+      ptoken = &((*ptoken)->stok_next);\n+      remdepth--;\n+    }\n+\n+  return tok;\n+}\n+\n+/* Consume the next DEPTH tokens and free them.  */\n+static void\n+next_state_tokens (int depth)\n+{\n+  struct state_token_st *n;\n+\n+  while (depth > 0)\n+    {\n+      if (state_token != NULL)\n+\t{\n+\t  n = state_token->stok_next;\n+\t  free (state_token);\n+\t  state_token = n;\n+\t}\n+      else\n+\tfatal_reading_state (NULL_STATE_TOKEN, \"Tokens stack empty\");\n+\n+      depth--;\n+    }\n+}\n+\n+/* Safely retrieve the lexical kind of a token.  */\n+static inline enum state_token_en\n+state_token_kind (struct state_token_st *p)\n+{\n+  if (p == NULL)\n+    return STOK_NONE;\n+  else\n+    return p->stok_kind;\n+}\n+\n+/* Test if a token is a given name i.e. an identifier.  */\n+static inline bool\n+state_token_is_name (struct state_token_st *p, const char *name)\n+{\n+  if (p == NULL)\n+    return false;\n+\n+  if (p->stok_kind != STOK_NAME)\n+    return false;\n+\n+  return !strcmp (p->stok_un.stok_ident->stid_name, name);\n+}\n+\n+\n+/* Following routines are useful for serializing datas.\n+ *\n+ * We want to serialize :\n+ *          - typedefs list\n+ *          - structures list\n+ *          - param_structs list\n+ *          - variables list\n+ *\n+ * So, we have one routine for each kind of data.  The main writing\n+ * routine is write_state.  The main reading routine is\n+ * read_state.  Most writing routines write_state_FOO have a\n+ * corresponding reading routine read_state_FOO.  Reading is done in a\n+ * recursive descending way, and any read error is fatal.\n+ */\n+\n+/* When reading the state, we need to remember the previously seen\n+   types by their state_number, since GTY-ed types are usually\n+   shared.  */\n+static htab_t state_seen_types;\n+\n+/* Return the length of a linked list made of pairs.  */\n+static int pair_list_length (pair_p list);\n+\n+/* Write a pair */\n+static void write_state_pair (pair_p);\n+\n+/* return the number of pairs written.  Should match the length given\n+   by pair_list_length.  */\n+static int write_state_pair_list (pair_p list);\n+\n+/* Write a type.  When a type is written, its state_number is updated,\n+   to ensure that a \"reference\" to a seen type is written on next\n+   occurrences.  */\n+static void write_state_type (type_p);\n+\n+/* Write a null-terminatel string using our Lispy lexical conventions,\n+   similar to those of C or MELT.  */\n+static void write_state_a_string (const char *s);\n+\n+/* Compute the length of a list of pairs, starting from the first\n+   one.  */\n+static int\n+pair_list_length (pair_p list)\n+{\n+  int nbpair = 0;\n+  pair_p l = NULL;\n+  for (l = list; l; l = l->next)\n+    nbpair++;\n+  return nbpair;\n+}\n+\n+/* Write a file location.  Files relative to $(srcdir) are quite\n+   frequent and are handled specially.  This ensures that two gengtype\n+   state file-s produced by gengtype on the same GCC source tree are\n+   very similar and can be reasonably compared with diff, even if the\n+   two GCC source trees have different absolute paths.  */\n+static void\n+write_state_fileloc (struct fileloc *floc)\n+{\n+\n+  if (floc != NULL && floc->line > 0)\n+    {\n+      const char *srcrelpath = NULL;\n+      gcc_assert (floc->file != NULL);\n+      /* Most of the files are inside $(srcdir) so it is worth to\n+         handle them specially.  */\n+      srcrelpath = get_file_srcdir_relative_path (floc->file);\n+      if (srcrelpath != NULL)\n+\t{\n+\t  fprintf (state_file, \"\\n(!srcfileloc \");\n+\t  write_state_a_string (srcrelpath);\n+\t}\n+      else\n+\t{\n+\t  fprintf (state_file, \"\\n(!fileloc \");\n+\t  write_state_a_string (get_input_file_name (floc->file));\n+\t}\n+      fprintf (state_file, \" %d\", floc->line);\n+      fprintf (state_file, \")\\n\");\n+    }\n+  else\n+    fprintf (state_file, \"nil \");\n+}\n+\n+/* Write a list of fields.  */\n+static void\n+write_state_fields (pair_p fields)\n+{\n+  int nbfields = pair_list_length (fields);\n+  int nbpairs = 0;\n+  fprintf (state_file, \"\\n(!fields %d \", nbfields);\n+  nbpairs = write_state_pair_list (fields);\n+  gcc_assert (nbpairs == nbfields);\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Write a null-terminated string in our lexical convention, very\n+   similar to the convention of C.  */\n+static void\n+write_state_a_string (const char *s)\n+{\n+  char c;\n+\n+  fputs (\" \\\"\", state_file);\n+  for (; *s != 0; s++)\n+    {\n+      c = *s;\n+      switch (c)\n+\t{\n+\tcase '\\a':\n+\t  fputs (\"\\\\a\", state_file);\n+\t  break;\n+\tcase '\\b':\n+\t  fputs (\"\\\\b\", state_file);\n+\t  break;\n+\tcase '\\t':\n+\t  fputs (\"\\\\t\", state_file);\n+\t  break;\n+\tcase '\\n':\n+\t  fputs (\"\\\\n\", state_file);\n+\t  break;\n+\tcase '\\v':\n+\t  fputs (\"\\\\v\", state_file);\n+\t  break;\n+\tcase '\\f':\n+\t  fputs (\"\\\\f\", state_file);\n+\t  break;\n+\tcase '\\r':\n+\t  fputs (\"\\\\r\", state_file);\n+\t  break;\n+\tcase '\\\"':\n+\t  fputs (\"\\\\\\\"\", state_file);\n+\t  break;\n+\tcase '\\\\':\n+\t  fputs (\"\\\\\\\\\", state_file);\n+\t  break;\n+\tdefault:\n+\t  if (ISPRINT (c))\n+\t    putc (c, state_file);\n+\t  else\n+\t    fprintf (state_file, \"\\\\x%02x\", (unsigned) c);\n+\t}\n+    }\n+  fputs (\"\\\"\", state_file);\n+}\n+\n+/* Our option-s have three kinds, each with its writer.  */\n+static void\n+write_state_string_option (options_p current)\n+{\n+  fprintf (state_file, \"string \");\n+  if (current->info.string != NULL)\n+    write_state_a_string (current->info.string);\n+  else\n+    fprintf (state_file, \" nil \");\n+}\n+\n+static void\n+write_state_type_option (options_p current)\n+{\n+  fprintf (state_file, \"type \");\n+  write_state_type (current->info.type);\n+}\n+\n+static void\n+write_state_nested_option (options_p current)\n+{\n+  fprintf (state_file, \"nested \");\n+  write_state_type (current->info.nested->type);\n+  if (current->info.nested->convert_from != NULL)\n+    write_state_a_string (current->info.nested->convert_from);\n+  else\n+    fprintf (state_file, \" nil \");\n+\n+  if (current->info.nested->convert_to != NULL)\n+    write_state_a_string (current->info.nested->convert_to);\n+  else\n+    fprintf (state_file, \" nil \");\n+}\n+\n+static void\n+write_state_option (options_p current)\n+{\n+  fprintf (state_file, \"\\n(!option \");\n+\n+  if (current->name != NULL)\n+    fprintf (state_file, \"%s \", current->name);\n+  else\n+    fprintf (state_file, \"nil \");\n+\n+  switch (current->kind)\n+    {\n+    case OPTION_STRING:\n+      write_state_string_option (current);\n+      break;\n+    case OPTION_TYPE:\n+      write_state_type_option (current);\n+      break;\n+    case OPTION_NESTED:\n+      write_state_nested_option (current);\n+      break;\n+    default:\n+      fatal (\"Option tag unknown\");\n+    }\n+\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+\n+\n+/* Write a list of GTY options.  */\n+static void\n+write_state_options (options_p opt)\n+{\n+  options_p current;\n+\n+  if (opt == NULL)\n+    {\n+      fprintf (state_file, \"nil \");\n+      return;\n+    }\n+\n+  fprintf (state_file, \"\\n(!options \");\n+  for (current = opt; current != NULL; current = current->next)\n+      write_state_option (current);\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+\n+/* Write a bitmap representing a set of GCC front-end languages.  */\n+static void\n+write_state_lang_bitmap (lang_bitmap bitmap)\n+{\n+  fprintf (state_file, \"%d \", (int) bitmap);\n+}\n+\n+/* Write version information.  */\n+static void\n+write_state_version (const char *version)\n+{\n+  fprintf (state_file, \"\\n(!version \");\n+  write_state_a_string (version);\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Common routine to write the common content of all types.  */\n+static void write_state_common_type_content (type_p current);\n+\n+/* Write a scalar type.  We have only two of these.  */\n+static void\n+write_state_scalar_type (type_p current)\n+{\n+  if (current == &scalar_nonchar)\n+    fprintf (state_file, \"scalar_nonchar \");\n+  else if (current == &scalar_char)\n+    fprintf (state_file, \"scalar_char \");\n+  else\n+    fatal (\"Unexpected type in write_state_scalar_type\");\n+\n+  write_state_common_type_content (current);\n+}\n+\n+/* Write the string type.  There is only one such thing! */\n+static void\n+write_state_string_type (type_p current)\n+{\n+  if (current == &string_type)\n+    {\n+      fprintf (state_file, \"string \");\n+      write_state_common_type_content (current);\n+    }\n+  else\n+    fatal (\"Unexpected type in write_state_string_type\");\n+}\n+\n+\n+/* Common code to write structure like types.  */\n+static void\n+write_state_struct_union_type (type_p current, const char *kindstr)\n+{\n+  DBGPRINTF (\"%s type @ %p #%d '%s'\", kindstr, (void *) current,\n+\t     current->state_number, current->u.s.tag);\n+  fprintf (state_file, \"%s \", kindstr);\n+  write_state_common_type_content (current);\n+  if (current->u.s.tag != NULL)\n+    write_state_a_string (current->u.s.tag);\n+  else\n+    fprintf (state_file, \"nil\");\n+\n+  write_state_fileloc (type_lineloc (current));\n+  write_state_fields (current->u.s.fields);\n+  write_state_options (current->u.s.opt);\n+  write_state_lang_bitmap (current->u.s.bitmap);\n+}\n+\n+\n+/* Write a GTY struct type.  */\n+static void\n+write_state_struct_type (type_p current)\n+{\n+  write_state_struct_union_type (current, \"struct\");\n+  write_state_type (current->u.s.lang_struct);\n+}\n+\n+/* write a GTY union type.  */\n+static void\n+write_state_union_type (type_p current)\n+{\n+  write_state_struct_union_type (current, \"union\");\n+  write_state_type (current->u.s.lang_struct);\n+}\n+\n+/* Write a lang_struct type.  This is tricky and was painful to debug,\n+   we deal with the next field specifically within their lang_struct\n+   subfield, which points to a linked list of homonumous types.\n+   Change this function with extreme care, see also\n+   read_state_lang_struct_type.  */\n+static void\n+write_state_lang_struct_type (type_p current)\n+{\n+  int nbhomontype = 0;\n+  type_p hty = NULL;\n+  const char *homoname = 0;\n+  write_state_struct_union_type (current, \"lang_struct\");\n+  /* lang_struct-ures are particularily tricky, since their\n+     u.s.lang_struct field gives a list of homonymous struct-s or\n+     union-s! */\n+  DBGPRINTF (\"lang_struct @ %p #%d\", (void *) current, current->state_number);\n+  for (hty = current->u.s.lang_struct; hty != NULL; hty = hty->next)\n+    {\n+      nbhomontype++;\n+      DBGPRINTF (\"homonymous #%d hty @ %p #%d '%s'\", nbhomontype,\n+\t\t (void *) hty, hty->state_number, hty->u.s.tag);\n+      /* Every member of the homonymous list should have the same tag.  */\n+      gcc_assert (UNION_OR_STRUCT_P (hty));\n+      gcc_assert (hty->u.s.lang_struct == current);\n+      if (!homoname)\n+\thomoname = hty->u.s.tag;\n+      gcc_assert (strcmp (homoname, hty->u.s.tag) == 0);\n+    }\n+  fprintf (state_file, \"(!homotypes %d\\n\", nbhomontype);\n+  for (hty = current->u.s.lang_struct; hty != NULL; hty = hty->next)\n+    write_state_type (hty);\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Write a parametrized structure GTY type.  */\n+static void\n+write_state_param_struct_type (type_p current)\n+{\n+  int i;\n+\n+  fprintf (state_file, \"param_struct \");\n+  write_state_common_type_content (current);\n+  write_state_type (current->u.param_struct.stru);\n+  for (i = 0; i < NUM_PARAM; i++)\n+    {\n+      if (current->u.param_struct.param[i] != NULL)\n+\twrite_state_type (current->u.param_struct.param[i]);\n+      else\n+\tfprintf (state_file, \"nil \");\n+    }\n+  write_state_fileloc (&current->u.param_struct.line);\n+}\n+\n+/* Write a pointer type.  */\n+static void\n+write_state_pointer_type (type_p current)\n+{\n+  fprintf (state_file, \"pointer \");\n+  write_state_common_type_content (current);\n+  write_state_type (current->u.p);\n+}\n+\n+/* Write an array type.  */\n+static void\n+write_state_array_type (type_p current)\n+{\n+  fprintf (state_file, \"array \");\n+  write_state_common_type_content (current);\n+  if (current->u.a.len != NULL)\n+    write_state_a_string (current->u.a.len);\n+  else\n+    fprintf (state_file, \" nil\");\n+\n+  fprintf (state_file, \" \");\n+  write_state_type (current->u.a.p);\n+}\n+\n+/* Write the gc_used information.  */\n+static void\n+write_state_gc_used (enum gc_used_enum gus)\n+{\n+  switch (gus)\n+    {\n+    case GC_UNUSED:\n+      fprintf (state_file, \" gc_unused\");\n+      break;\n+    case GC_USED:\n+      fprintf (state_file, \" gc_used\");\n+      break;\n+    case GC_MAYBE_POINTED_TO:\n+      fprintf (state_file, \" gc_maybe_pointed_to\");\n+      break;\n+    case GC_POINTED_TO:\n+      fprintf (state_file, \" gc_pointed_to\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Utility routine to write the common content of all types.  Notice\n+   that the next field is *not* written on purpose.  */\n+static void\n+write_state_common_type_content (type_p current)\n+{\n+  fprintf (state_file, \"%d \", current->state_number);\n+  /* We do not write the next type, because list of types are\n+     explicitly written.  However, lang_struct are special in that\n+     respect.  See function write_state_lang_struct_type for more.  */\n+  write_state_type (current->pointer_to);\n+  write_state_gc_used (current->gc_used);\n+}\n+\n+\n+/* The important and recursive routine writing GTY types as understood\n+   by gengtype.  Types which have a positive state_number have already\n+   been seen and written.  */\n+static void\n+write_state_type (type_p current)\n+{\n+  if (current == NULL)\n+    {\n+      fprintf (state_file, \"nil \");\n+      return;\n+    }\n+\n+  fprintf (state_file, \"\\n(!type \");\n+\n+  if (current->state_number > 0)\n+    fprintf (state_file, \"already_seen %d\", current->state_number);\n+  else\n+    {\n+      state_written_type_count++;\n+      DBGPRINTF (\"writing type #%d @%p old number %d\", state_written_type_count,\n+\t\t (void *) current, current->state_number);\n+      current->state_number = state_written_type_count;\n+      switch (current->kind)\n+\t{\n+\tcase TYPE_STRUCT:\n+\t  write_state_struct_type (current);\n+\t  break;\n+\tcase TYPE_UNION:\n+\t  write_state_union_type (current);\n+\t  break;\n+\tcase TYPE_POINTER:\n+\t  write_state_pointer_type (current);\n+\t  break;\n+\tcase TYPE_ARRAY:\n+\t  write_state_array_type (current);\n+\t  break;\n+\tcase TYPE_LANG_STRUCT:\n+\t  write_state_lang_struct_type (current);\n+\t  break;\n+\tcase TYPE_PARAM_STRUCT:\n+\t  write_state_param_struct_type (current);\n+\t  break;\n+\tcase TYPE_SCALAR:\n+\t  write_state_scalar_type (current);\n+\t  break;\n+\tcase TYPE_STRING:\n+\t  write_state_string_type (current);\n+\t  break;\n+\n+\tdefault:\n+\t  fatal (\"Unexpected type...\");\n+\t}\n+    }\n+\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+\n+/* Write a pair.  */\n+static void\n+write_state_pair (pair_p current)\n+{\n+  if (current == NULL)\n+    {\n+      fprintf (state_file, \"nil)\");\n+      return;\n+    }\n+\n+  fprintf (state_file, \"\\n(!pair \");\n+\n+  if (current->name != NULL)\n+    write_state_a_string (current->name);\n+  else\n+    write_state_a_string (\"nil\");\n+\n+  write_state_type (current->type);\n+  write_state_fileloc (&(current->line));\n+  write_state_options (current->opt);\n+\n+  fprintf (state_file, \")\");\n+}\n+\n+/* Write a pair list and return the number of pairs written.  */\n+static int\n+write_state_pair_list (pair_p list)\n+{\n+  int nbpair = 0;\n+  pair_p current;\n+\n+  for (current = list; current != NULL; current = current->next)\n+    {\n+      write_state_pair (current);\n+      nbpair++;\n+    }\n+  return nbpair;\n+\n+}\n+\n+/* When writing imported linked lists, like typedefs, structures,\n+   param_structs, ... we count their length first and write it.  These\n+   eases the reading, and enables an extra verification on the number\n+   of actually read items.  */\n+\n+/* Write our typedefs.  */\n+static void\n+write_state_typedefs (void)\n+{\n+  int nbtypedefs = pair_list_length (typedefs);\n+  int nbpairs = 0;\n+  fprintf (state_file, \"\\n(!typedefs %d\\n\", nbtypedefs);\n+  nbpairs = write_state_pair_list (typedefs);\n+  gcc_assert (nbpairs == nbtypedefs);\n+  fprintf (state_file, \")\\n\");\n+  if (verbosity_level >= 2)\n+    printf (\"%s wrote %d typedefs\\n\", progname, nbtypedefs);\n+}\n+\n+/* Write our structures.  */\n+static void\n+write_state_structures (void)\n+{\n+  int nbstruct = 0;\n+  type_p current;\n+\n+  for (current = structures; current != NULL; current = current->next)\n+    nbstruct++;\n+\n+  fprintf (state_file, \"\\n(!structures %d\\n\", nbstruct);\n+\n+  for (current = structures; current != NULL; current = current->next)\n+    write_state_type (current);\n+\n+  fprintf (state_file, \")\\n\");\n+  if (verbosity_level >= 2)\n+    printf (\"%s wrote %d structures in state\\n\", progname, nbstruct);\n+}\n+\n+/* Write our param_struct-s.  */\n+static void\n+write_state_param_structs (void)\n+{\n+  int nbparamstruct = 0;\n+  type_p current;\n+\n+  for (current = param_structs; current != NULL; current = current->next)\n+    nbparamstruct++;\n+\n+  fprintf (state_file, \"\\n(!param_structs %d\\n\", nbparamstruct);\n+\n+  for (current = param_structs; current != NULL; current = current->next)\n+    write_state_type (current);\n+\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Write our variables.  */\n+static void\n+write_state_variables (void)\n+{\n+  int nbvars = pair_list_length (variables);\n+  int nbpairs = 0;\n+  fprintf (state_file, \"\\n(!variables %d\\n\", nbvars);\n+  nbpairs = write_state_pair_list (variables);\n+  gcc_assert (nbpairs == nbvars);\n+  fprintf (state_file, \")\\n\");\n+  if (verbosity_level >= 2)\n+    printf (\"%s wrote %d variables.\\n\", progname, nbvars);\n+}\n+\n+/* Write the source directory.  File locations within the source\n+   directory have been written specifically.  */\n+static void\n+write_state_srcdir (void)\n+{\n+  fprintf (state_file, \"\\n(!srcdir \");\n+  write_state_a_string (srcdir);\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Count and write the list of our files.  */\n+static void\n+write_state_files_list (void)\n+{\n+  int i = 0;\n+  /* Write the list of files with their lang_bitmap.  */\n+  fprintf (state_file, \"\\n(!fileslist %d\\n\", (int) num_gt_files);\n+  for (i = 0; i < (int) num_gt_files; i++)\n+    {\n+      const char *cursrcrelpath = NULL;\n+      const input_file *curfil = gt_files[i];\n+      /* Most of the files are inside $(srcdir) so it is worth to\n+         handle them specially.  */\n+      cursrcrelpath = get_file_srcdir_relative_path (curfil);\n+      if (cursrcrelpath)\n+\t{\n+\t  fprintf (state_file, \"(!srcfile %d \", get_lang_bitmap (curfil));\n+\t  write_state_a_string (cursrcrelpath);\n+\t}\n+      else\n+\t{\n+\t  fprintf (state_file, \"(!file %d \", get_lang_bitmap (curfil));\n+\t  write_state_a_string (get_input_file_name (curfil));\n+\t}\n+      fprintf (state_file, \")\\n\");\n+    }\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Write the list of GCC front-end languages.  */\n+static void\n+write_state_languages (void)\n+{\n+  int i = 0;\n+  fprintf (state_file, \"\\n(!languages %d\", (int) num_lang_dirs);\n+  for (i = 0; i < (int) num_lang_dirs; i++)\n+    {\n+      /* Languages names are identifiers, we expect only letters or\n+         underscores or digits in them.  In particular, C++ is not a\n+         valid language name, but cp is valid.  */\n+      fprintf (state_file, \" %s\", lang_dir_names[i]);\n+    }\n+  fprintf (state_file, \")\\n\");\n+}\n+\n+/* Write the trailer.  */\n+static void\n+write_state_trailer (void)\n+{\n+  /* This test should probably catch IO errors like disk full...  */\n+  if (fputs (\"\\n(!endfile)\\n\", state_file) == EOF)\n+    fatal (\"failed to write state trailer [%s]\", xstrerror (errno));\n+}\n+\n+/* The write_state routine is the only writing routine called by main\n+   in gengtype.c.  To avoid messing the state if gengtype is\n+   interrupted or aborted, we write a temporary file and rename it\n+   after having written it in totality.  */\n+void\n+write_state (const char *state_path)\n+{\n+  long statelen = 0;\n+  time_t now = 0;\n+  char *temp_state_path = NULL;\n+  char tempsuffix[40];\n+  time (&now);\n+\n+  /* We write a unique temporary file which is renamed when complete\n+   * only.  So even if gengtype is interrupted, the written state file\n+   * won't be partially written, since the temporary file is not yet\n+   * renamed in that case.  */\n+  memset (tempsuffix, 0, sizeof (tempsuffix));\n+  snprintf (tempsuffix, sizeof (tempsuffix) - 1, \"-%ld-%d.tmp\", (long) now,\n+\t    (int) getpid ());\n+  temp_state_path = concat (state_path, tempsuffix, NULL);\n+  state_file = fopen (temp_state_path, \"w\");\n+  if (state_file == NULL)\n+    fatal (\"Failed to open file %s for writing state: %s\",\n+\t   temp_state_path, xstrerror (errno));\n+  if (verbosity_level >= 3)\n+    printf (\"%s writing state file %s temporarily in %s\\n\",\n+\t    progname, state_path, temp_state_path);\n+  /* This is the first line of the state.  Perhaps the file utility\n+     could know about that, so don't change it often.  */\n+  fprintf (state_file, \";;;;@@@@ GCC gengtype state\\n\");\n+  /* Output a few comments for humans. */\n+  fprintf (state_file,\n+\t   \";;; DON'T EDIT THIS FILE, since generated by GCC's gengtype\\n\");\n+  fprintf (state_file,\n+\t   \";;; The format of this file is tied to a particular version of GCC.\\n\");\n+  fprintf (state_file,\n+\t   \";;; Don't parse this file wihout knowing GCC gengtype internals.\\n\");\n+  fprintf (state_file,\n+\t   \";;; This file should be parsed by the same %s which wrote it.\\n\",\n+\t   progname);\n+  fprintf (state_file, \";;; file %s generated on %s\\n\", state_path,\n+\t   ctime (&now));\n+  /* The first non-comment significant line gives the version string.  */\n+  write_state_version (version_string);\n+  write_state_srcdir ();\n+  write_state_languages ();\n+  write_state_files_list ();\n+  write_state_structures ();\n+  write_state_typedefs ();\n+  write_state_param_structs ();\n+  write_state_variables ();\n+  write_state_trailer ();\n+  statelen = ftell (state_file);\n+  if (ferror (state_file))\n+    fatal (\"output error when writing state file %s [%s]\",\n+\t   temp_state_path, xstrerror (errno));\n+  if (fclose (state_file))\n+    fatal (\"failed to close state file %s [%s]\",\n+\t   temp_state_path, xstrerror (errno));\n+  if (rename (temp_state_path, state_path))\n+    fatal (\"failed to rename %s to state file %s [%s]\", temp_state_path,\n+\t   state_path, xstrerror (errno));\n+  free (temp_state_path);\n+\n+  if (verbosity_level >= 1)\n+    printf (\"%s wrote state file %s of %ld bytes with %d GTY-ed types\\n\",\n+\t    progname, state_path, statelen, state_written_type_count);\n+\n+}\n+\f\n+/** End of writing routines!  The corresponding reading routines follow.  **/\n+\n+\n+\n+/* Forward declarations, since some read_state_* functions are\n+   recursive! */\n+static void read_state_fileloc (struct fileloc *line);\n+static void read_state_options (options_p *opt);\n+static void read_state_type (type_p *current);\n+static void read_state_pair (pair_p *pair);\n+/* Return the number of pairs actually read.  */\n+static int read_state_pair_list (pair_p *list);\n+static void read_state_fields (pair_p *fields);\n+static void read_state_common_type_content (type_p current);\n+\n+\n+\n+\n+/* Record into the state_seen_types hash-table a type which we are\n+   reading, to enable recursive or circular references to it.  */\n+static void\n+record_type (type_p type)\n+{\n+  PTR *slot;\n+\n+  slot = htab_find_slot (state_seen_types, type, INSERT);\n+  gcc_assert (slot);\n+\n+  *slot = type;\n+}\n+\n+/* Read an already seen type.  */\n+static void\n+read_state_already_seen_type (type_p *type)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+\n+  if (state_token_kind (t0) == STOK_INTEGER)\n+    {\n+      PTR *slot = NULL;\n+      struct type loctype = { TYPE_SCALAR, 0, 0, 0, GC_UNUSED, {0} };\n+\n+      loctype.state_number = t0->stok_un.stok_num;\n+      slot = htab_find_slot (state_seen_types, &loctype, NO_INSERT);\n+      if (slot == NULL)\n+\t{\n+\t  fatal_reading_state (t0, \"Unknown type\");\n+\t}\n+\n+      next_state_tokens (1);\n+      *type = (type_p) *slot;\n+    }\n+  else\n+    {\n+      fatal_reading_state (t0, \"Bad seen type\");\n+    }\n+}\n+\n+\n+/* Read the scalar_nonchar type.  */\n+static void\n+read_state_scalar_nonchar_type (type_p *type)\n+{\n+  *type = &scalar_nonchar;\n+  read_state_common_type_content (*type);\n+}\n+\n+\n+/* Read the scalar_char type.  */\n+static void\n+read_state_scalar_char_type (type_p *type)\n+{\n+  *type = &scalar_char;\n+  read_state_common_type_content (*type);\n+}\n+\n+\n+/* Read the string_type.  */\n+static void\n+read_state_string_type (type_p *type)\n+{\n+  *type = &string_type;\n+  read_state_common_type_content (*type);\n+}\n+\n+\n+/* Read a lang_bitmap representing a set of GCC front-end languages.  */\n+static void\n+read_state_lang_bitmap (lang_bitmap *bitmap)\n+{\n+  struct state_token_st *t;\n+\n+  t = peek_state_token (0);\n+  if (state_token_kind (t) == STOK_INTEGER)\n+    {\n+      *bitmap = t->stok_un.stok_num;\n+      next_state_tokens (1);\n+    }\n+  else\n+    {\n+      fatal_reading_state (t, \"Bad syntax for bitmap\");\n+    }\n+}\n+\n+\n+/* Read a GTY-ed struct type.  */\n+static void\n+read_state_struct_type (type_p type)\n+{\n+  struct state_token_st *t0;\n+\n+  type->kind = TYPE_STRUCT;\n+  read_state_common_type_content (type);\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      if (state_token_is_name (t0, \"nil\"))\n+\t{\n+\t  type->u.s.tag = NULL;\n+\t  DBGPRINTF (\"read anonymous struct type @%p #%d\",\n+\t\t     (void *) type, type->state_number);\n+\t}\n+      else\n+\t{\n+\t  type->u.s.tag = xstrdup (t0->stok_un.stok_string);\n+\t  DBGPRINTF (\"read struct type @%p #%d '%s'\",\n+\t\t     (void *) type, type->state_number, type->u.s.tag);\n+\t}\n+\n+      next_state_tokens (1);\n+      read_state_fileloc (&(type->u.s.line));\n+      read_state_fields (&(type->u.s.fields));\n+      read_state_options (&(type->u.s.opt));\n+      read_state_lang_bitmap (&(type->u.s.bitmap));\n+      read_state_type (&(type->u.s.lang_struct));\n+    }\n+  else\n+    {\n+      fatal_reading_state (t0, \"Bad tag in struct type\");\n+    }\n+}\n+\n+\n+/* Read a GTY-ed union type.  */\n+static void\n+read_state_union_type (type_p type)\n+{\n+  struct state_token_st *t0;\n+\n+  type->kind = TYPE_UNION;\n+  read_state_common_type_content (type);\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      if (state_token_is_name (t0, \"nil\"))\n+\t{\n+\t  type->u.s.tag = NULL;\n+\t  DBGPRINTF (\"read anonymous union type @%p #%d\",\n+\t\t     (void *) type, type->state_number);\n+\t}\n+      else\n+\t{\n+\t  type->u.s.tag = xstrdup (t0->stok_un.stok_string);\n+\t  DBGPRINTF (\"read union type @%p #%d '%s'\",\n+\t\t     (void *) type, type->state_number, type->u.s.tag);\n+\t}\n+      next_state_tokens (1);\n+      read_state_fileloc (&(type->u.s.line));\n+      read_state_fields (&(type->u.s.fields));\n+      read_state_options (&(type->u.s.opt));\n+      read_state_lang_bitmap (&(type->u.s.bitmap));\n+      read_state_type (&(type->u.s.lang_struct));\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad tag in union type\");\n+}\n+\n+\n+/* Read a GTY-ed pointer type.  */\n+static void\n+read_state_pointer_type (type_p type)\n+{\n+  type->kind = TYPE_POINTER;\n+  read_state_common_type_content (type);\n+  DBGPRINTF (\"read pointer type @%p #%d\", (void *) type, type->state_number);\n+  read_state_type (&(type->u.p));\n+}\n+\n+\n+/* Read a GTY-ed array type.  */\n+static void\n+read_state_array_type (type_p type)\n+{\n+  struct state_token_st *t0;\n+\n+  type->kind = TYPE_ARRAY;\n+  read_state_common_type_content (type);\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      type->u.a.len = xstrdup (t0->stok_un.stok_string);\n+      DBGPRINTF (\"read array type @%p #%d length '%s'\",\n+\t\t (void *) type, type->state_number, type->u.a.len);\n+      next_state_tokens (1);\n+    }\n+\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      type->u.a.len = NULL;\n+      DBGPRINTF (\"read array type @%p #%d without length\",\n+\t\t (void *) type, type->state_number);\n+      next_state_tokens (1);\n+    }\n+\n+  else\n+    fatal_reading_state (t0, \"Bad array name type\");\n+  read_state_type (&(type->u.a.p));\n+}\n+\n+\n+\n+/* Read a lang_struct type for GTY-ed struct-s which depends upon GCC\n+   front-end languages.  This is a tricky function and it was painful\n+   to debug.  Change it with extreme care.  See also\n+   write_state_lang_struct_type.  */\n+static void\n+read_state_lang_struct_type (type_p type)\n+{\n+  struct state_token_st *t0 = NULL;\n+  struct state_token_st *t1 = NULL;\n+  struct state_token_st *t2 = NULL;\n+\n+  type->kind = TYPE_LANG_STRUCT;\n+  read_state_common_type_content (type);\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      if (state_token_is_name (t0, \"nil\"))\n+\t{\n+\t  DBGPRINTF (\"read anonymous lang_struct type @%p #%d\",\n+\t\t     (void *) type, type->state_number);\n+\t  type->u.s.tag = NULL;\n+\t}\n+      else\n+\t{\n+\t  type->u.s.tag = xstrdup (t0->stok_un.stok_string);\n+\t  DBGPRINTF (\"read lang_struct type @%p #%d '%s'\",\n+\t\t     (void *) type, type->state_number, type->u.s.tag);\n+\t}\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad tag in lang struct type\");\n+  read_state_fileloc (&(type->u.s.line));\n+  read_state_fields (&(type->u.s.fields));\n+  read_state_options (&(type->u.s.opt));\n+  read_state_lang_bitmap (&(type->u.s.bitmap));\n+  /* Within lang_struct-ures, the lang_struct field is a linked list\n+     of homonymous types! */\n+  t0 = peek_state_token (0);\n+  t1 = peek_state_token (1);\n+  t2 = peek_state_token (2);\n+  /* Parse (!homotypes <number-types> <type-1> .... <type-n>) */\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!homotypes\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      type_p *prevty = &type->u.s.lang_struct;\n+      int nbhomotype = t2->stok_un.stok_num;\n+      int i = 0;\n+      t0 = t1 = t2 = NULL;\n+      next_state_tokens (3);\n+      for (i = 0; i < nbhomotype; i++)\n+\t{\n+\t  read_state_type (prevty);\n+\t  t0 = peek_state_token (0);\n+\t  if (*prevty)\n+\t    prevty = &(*prevty)->next;\n+\t  else\n+\t      fatal_reading_state (t0,\n+\t\t\t\t   \"expecting type in homotype list for lang_struct\");\n+\t};\n+      if (state_token_kind (t0) != STOK_RIGHTPAR)\n+\tfatal_reading_state (t0,\n+\t\t\t     \"expecting ) in homotype list for lang_struct\");\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"expecting !homotypes for lang_struct\");\n+}\n+\n+\n+/* Read a param_struct type for GTY parametrized structures.  */\n+static void\n+read_state_param_struct_type (type_p type)\n+{\n+  int i;\n+  struct state_token_st *t0;\n+\n+  type->kind = TYPE_PARAM_STRUCT;\n+  read_state_common_type_content (type);\n+  DBGPRINTF (\"read param_struct type @%p #%d\",\n+\t     (void *) type, type->state_number);\n+  read_state_type (&(type->u.param_struct.stru));\n+\n+  for (i = 0; i < NUM_PARAM; i++)\n+    {\n+      t0 = peek_state_token (0);\n+      if (state_token_is_name (t0, \"nil\"))\n+\t{\n+\t  type->u.param_struct.param[i] = NULL;\n+\t  next_state_tokens (1);\n+\t}\n+      else\n+\tread_state_type (&(type->u.param_struct.param[i]));\n+    }\n+  read_state_fileloc (&(type->u.param_struct.line));\n+}\n+\n+\n+/* Read the gc used information.  */\n+static void\n+read_state_gc_used (enum gc_used_enum *pgus)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  if (state_token_is_name (t0, \"gc_unused\"))\n+    *pgus = GC_UNUSED;\n+  else if (state_token_is_name (t0, \"gc_used\"))\n+    *pgus = GC_USED;\n+  else if (state_token_is_name (t0, \"gc_maybe_pointed_to\"))\n+    *pgus = GC_MAYBE_POINTED_TO;\n+  else if (state_token_is_name (t0, \"gc_pointed_to\"))\n+    *pgus = GC_POINTED_TO;\n+  else\n+    fatal_reading_state (t0, \"invalid gc_used information\");\n+  next_state_tokens (1);\n+}\n+\n+\n+/* Utility function to read the common content of types.  */\n+static void\n+read_state_common_type_content (type_p current)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+\n+  if (state_token_kind (t0) == STOK_INTEGER)\n+    {\n+      current->state_number = t0->stok_un.stok_num;\n+      next_state_tokens (1);\n+      record_type (current);\n+    }\n+  else\n+      fatal_reading_state_printf (t0,\n+\t\t\t\t  \"Expected integer for state_number line %d\",\n+\t\t\t\t  state_line);\n+  /* We don't read the next field of the type.  */\n+  read_state_type (&current->pointer_to);\n+  read_state_gc_used (&current->gc_used);\n+}\n+\n+\n+/* Read a GTY-ed type.  */\n+void\n+read_state_type (type_p *current)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      state_token_is_name (t1, \"!type\"))\n+    {\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      if (state_token_is_name (t0, \"already_seen\"))\n+\t{\n+\t  next_state_tokens (1);\n+\t  read_state_already_seen_type (current);\n+\t}\n+      else\n+\t{\n+\t  t0 = peek_state_token (0);\n+\n+\t  if (state_token_is_name (t0, \"scalar_nonchar\"))\n+\t    {\n+\t      next_state_tokens (1);\n+\t      read_state_scalar_nonchar_type (current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"scalar_char\"))\n+\t    {\n+\t      next_state_tokens (1);\n+\t      read_state_scalar_char_type (current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"string\"))\n+\t    {\n+\t      next_state_tokens (1);\n+\t      read_state_string_type (current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"struct\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_struct_type (*current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"union\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_union_type (*current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"lang_struct\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_lang_struct_type (*current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"param_struct\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_param_struct_type (*current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"pointer\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_pointer_type (*current);\n+\t    }\n+\t  else if (state_token_is_name (t0, \"array\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_array_type (*current);\n+\t    }\n+\t  else\n+\t    fatal_reading_state (t0, \"bad type in (!type\");\n+\t}\n+      t0 = peek_state_token (0);\n+      if (state_token_kind (t0) != STOK_RIGHTPAR)\n+\tfatal_reading_state (t0, \"missing ) in type\");\n+      next_state_tokens (1);\n+    }\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      next_state_tokens (1);\n+      *current = NULL;\n+    }\n+  else\n+    fatal_reading_state (t0, \"bad type syntax\");\n+}\n+\n+\n+/* Read a file location.  Files within the source directory are dealt\n+   with specifically.  */\n+void\n+read_state_fileloc (struct fileloc *floc)\n+{\n+  bool issrcfile = false;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+\n+  gcc_assert (floc != NULL);\n+  gcc_assert (srcdir != NULL);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      (state_token_is_name (t1, \"!fileloc\")\n+       || (issrcfile = state_token_is_name (t1, \"!srcfileloc\"))))\n+    {\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      t1 = peek_state_token (1);\n+      if (state_token_kind (t0) == STOK_STRING &&\n+\t  state_token_kind (t1) == STOK_INTEGER)\n+\t{\n+\t  char *path = t0->stok_un.stok_string;\n+\t  if (issrcfile)\n+\t    {\n+\t      static const char dirsepstr[2] = { DIR_SEPARATOR, (char) 0 };\n+\t      char *fullpath = concat (srcdir, dirsepstr, path, NULL);\n+\t      floc->file = input_file_by_name (fullpath);\n+\t      free (fullpath);\n+\t    }\n+\t  else\n+\t    floc->file = input_file_by_name (path);\n+\t  floc->line = t1->stok_un.stok_num;\n+\t  next_state_tokens (2);\n+\t}\n+      else\n+\tfatal_reading_state (t0,\n+\t\t\t     \"Bad fileloc syntax, expected path string and line\");\n+      t0 = peek_state_token (0);\n+      if (state_token_kind (t0) != STOK_RIGHTPAR)\n+\tfatal_reading_state (t0, \"Bad fileloc syntax, expected )\");\n+      next_state_tokens (1);\n+    }\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      next_state_tokens (1);\n+      floc->file = NULL;\n+      floc->line = 0;\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad fileloc syntax\");\n+}\n+\n+\n+/* Read the fields of a GTY-ed type.  */\n+void\n+read_state_fields (pair_p *fields)\n+{\n+  pair_p tmp = NULL;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!fields\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      int nbfields = t2->stok_un.stok_num;\n+      int nbpairs = 0;\n+      next_state_tokens (3);\n+      nbpairs = read_state_pair_list (&tmp);\n+      t0 = peek_state_token (0);\n+      if (nbpairs != nbfields)\n+\tfatal_reading_state_printf\n+\t  (t0,\n+\t   \"Mismatched fields number, expected %d got %d\", nbpairs, nbfields);\n+      if (state_token_kind (t0) == STOK_RIGHTPAR)\n+\tnext_state_tokens (1);\n+      else\n+\tfatal_reading_state (t0, \"Bad fields expecting )\");\n+    }\n+\n+  *fields = tmp;\n+}\n+\n+\n+/* Read a string option.  */\n+static void\n+read_state_string_option (options_p opt)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  opt->kind = OPTION_STRING;\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      opt->info.string = xstrdup (t0->stok_un.stok_string);\n+      next_state_tokens (1);\n+    }\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      opt->info.string = NULL;\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Missing name in string option\");\n+}\n+\n+\n+/* Read a type option.  */\n+static void\n+read_state_type_option (options_p opt)\n+{\n+  opt->kind = OPTION_TYPE;\n+  read_state_type (&(opt->info.type));\n+}\n+\n+\n+/* Read a nested option.  */\n+static void\n+read_state_nested_option (options_p opt)\n+{\n+  struct state_token_st *t0;\n+\n+  opt->info.nested = XCNEW (struct nested_ptr_data);\n+  opt->kind = OPTION_NESTED;\n+  read_state_type (&(opt->info.nested->type));\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      opt->info.nested->convert_from = xstrdup (t0->stok_un.stok_string);\n+      next_state_tokens (1);\n+    }\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      opt->info.nested->convert_from = NULL;\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad nested convert_from option\");\n+\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      opt->info.nested->convert_to = xstrdup (t0->stok_un.stok_string);\n+      next_state_tokens (1);\n+    }\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      opt->info.nested->convert_to = NULL;\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad nested convert_from option\");\n+}\n+\n+\n+/* Read an GTY option.  */\n+static void\n+read_state_option (options_p *opt)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      state_token_is_name (t1, \"!option\"))\n+    {\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      if (state_token_kind (t0) == STOK_NAME)\n+\t{\n+\t  *opt = XCNEW (struct options);\n+\t  if (state_token_is_name (t0, \"nil\"))\n+\t    (*opt)->name = NULL;\n+\t  else\n+\t    (*opt)->name = t0->stok_un.stok_ident->stid_name;\n+\t  next_state_tokens (1);\n+\t  t0 = peek_state_token (0);\n+\t  if (state_token_kind (t0) == STOK_NAME)\n+\t    {\n+\t      if (state_token_is_name (t0, \"string\"))\n+\t\t{\n+\t\t  next_state_tokens (1);\n+\t\t  read_state_string_option (*opt);\n+\t\t}\n+\t      else if (state_token_is_name (t0, \"type\"))\n+\t\t{\n+\t\t  next_state_tokens (1);\n+\t\t  read_state_type_option (*opt);\n+\t\t}\n+\t      else if (state_token_is_name (t0, \"nested\"))\n+\t\t{\n+\t\t  next_state_tokens (1);\n+\t\t  read_state_nested_option (*opt);\n+\t\t}\n+\t      else\n+\t\tfatal_reading_state (t0, \"Bad option type\");\n+\t      t0 = peek_state_token (0);\n+\t      if (state_token_kind (t0) != STOK_RIGHTPAR)\n+\t\tfatal_reading_state (t0, \"Bad syntax in option, expecting )\");\n+\n+\t      next_state_tokens (1);\n+\t    }\n+\t  else\n+\t    fatal_reading_state (t0, \"Missing option type\");\n+\t}\n+      else\n+\tfatal_reading_state (t0, \"Bad name for option\");\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad option, waiting for )\");\n+}\n+\n+/* Read a list of options.  */\n+void\n+read_state_options (options_p *opt)\n+{\n+  options_p head = NULL;\n+  options_p previous = NULL;\n+  options_p current_option = NULL;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      state_token_is_name (t1, \"!options\"))\n+    {\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      while (state_token_kind (t0) != STOK_RIGHTPAR)\n+\t{\n+\t  read_state_option (&current_option);\n+\t  if (head == NULL)\n+\t    {\n+\t      head = current_option;\n+\t      previous = head;\n+\t    }\n+\t  else\n+\t    {\n+\t      previous->next = current_option;\n+\t      previous = current_option;\n+\t    }\n+\t  t0 = peek_state_token (0);\n+\t}\n+      next_state_tokens (1);\n+    }\n+  else if (state_token_is_name (t0, \"nil\"))\n+    {\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad options syntax\");\n+\n+  *opt = head;\n+}\n+\n+\n+/* Read a version, and check against the version of the gengtype.  */\n+static void\n+read_state_version (const char *version_string)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      state_token_is_name (t1, \"!version\"))\n+    {\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      t1 = peek_state_token (1);\n+      if (state_token_kind (t0) == STOK_STRING &&\n+\t  state_token_kind (t1) == STOK_RIGHTPAR)\n+\t{\n+\t  /* Check that the read version string is the same as current\n+\t     version.  */\n+\t  if (strcmp (version_string, t0->stok_un.stok_string))\n+\t    fatal_reading_state_printf (t0,\n+\t\t\t\t\t\"version string mismatch; expecting %s but got %s\",\n+\t\t\t\t\tversion_string,\n+\t\t\t\t\tt0->stok_un.stok_string);\n+\t  next_state_tokens (2);\n+\t}\n+      else\n+\tfatal_reading_state (t0, \"Missing version or right parenthesis\");\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad version syntax\");\n+}\n+\n+\n+/* Read a pair.  */\n+void\n+read_state_pair (pair_p *current)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      state_token_is_name (t1, \"!pair\"))\n+    {\n+      *current = XCNEW (struct pair);\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      if (state_token_kind (t0) == STOK_STRING)\n+\t{\n+\t  if (strcmp (t0->stok_un.stok_string, \"nil\") == 0)\n+\t    {\n+\t      (*current)->name = NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      (*current)->name = xstrdup (t0->stok_un.stok_string);\n+\t    }\n+\t  next_state_tokens (1);\n+\t  read_state_type (&((*current)->type));\n+\t  read_state_fileloc (&((*current)->line));\n+\t  read_state_options (&((*current)->opt));;\n+\t  t0 = peek_state_token (0);\n+\t  if (state_token_kind (t0) == STOK_RIGHTPAR)\n+\t    {\n+\t      next_state_tokens (1);\n+\t    }\n+\t  else\n+\t    {\n+\t      fatal_reading_state (t0, \"Bad syntax for pair, )\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  fatal_reading_state (t0, \"Bad name for pair\");\n+\t}\n+    }\n+  else if (state_token_kind (t0) == STOK_NAME &&\n+\t   state_token_is_name (t0, \"nil\"))\n+    {\n+      next_state_tokens (1);\n+      *current = NULL;\n+    }\n+  else\n+    fatal_reading_state_printf (t0, \"Bad syntax for pair, (!pair %d\",\n+\t\t\t\tstate_token->stok_kind);\n+}\n+\n+\n+/* Return the number of pairs actually read.  */\n+int\n+read_state_pair_list (pair_p *list)\n+{\n+  int nbpair = 0;\n+  pair_p head = NULL;\n+  pair_p previous = NULL;\n+  pair_p tmp = NULL;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  while (t0 && state_token_kind (t0) != STOK_RIGHTPAR)\n+    {\n+      read_state_pair (&tmp);\n+      if (head == NULL)\n+\t{\n+\t  head = tmp;\n+\t  previous = head;\n+\t}\n+      else\n+\t{\n+\t  previous->next = tmp;\n+\t  previous = tmp;\n+\t}\n+      t0 = peek_state_token (0);\n+      nbpair++;\n+    }\n+\n+  /* don't consume the ); the caller will eat it.  */\n+  *list = head;\n+  return nbpair;\n+}\n+\n+/* Read the typedefs.  */\n+static void\n+read_state_typedefs (pair_p *typedefs)\n+{\n+  int nbtypedefs = 0;\n+  pair_p list = NULL;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!typedefs\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      int nbpairs = 0;\n+      nbtypedefs = t2->stok_un.stok_num;\n+      next_state_tokens (3);\n+      nbpairs = read_state_pair_list (&list);\n+      t0 = peek_state_token (0);\n+      if (nbpairs != nbtypedefs)\n+\tfatal_reading_state_printf\n+\t  (t0,\n+\t   \"invalid number of typedefs, expected %d but got %d\",\n+\t   nbtypedefs, nbpairs);\n+      if (state_token_kind (t0) == STOK_RIGHTPAR)\n+\tnext_state_tokens (1);\n+      else\n+\tfatal_reading_state (t0, \"Bad typedefs syntax )\");\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad typedefs syntax (!typedefs\");\n+\n+  if (verbosity_level >= 2)\n+    printf (\"%s read %d typedefs from state\\n\", progname, nbtypedefs);\n+  *typedefs = list;\n+}\n+\n+\n+/* Read the structures.  */\n+static void\n+read_state_structures (type_p *structures)\n+{\n+  type_p head = NULL;\n+  type_p previous;\n+  type_p tmp;\n+  int nbstruct = 0, countstruct = 0;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!structures\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      nbstruct = t2->stok_un.stok_num;\n+      next_state_tokens (3);\n+      t0 = peek_state_token (0);\n+      while (t0 && state_token_kind (t0) != STOK_RIGHTPAR)\n+\t{\n+\t  tmp = NULL;\n+\t  read_state_type (&tmp);\n+\t  countstruct++;\n+\t  if (head == NULL)\n+\t    {\n+\t      head = tmp;\n+\t      previous = head;\n+\t    }\n+\t  else\n+\t    {\n+\t      previous->next = tmp;\n+\t      previous = tmp;\n+\t    }\n+\t  t0 = peek_state_token (0);\n+\t}\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad structures syntax\");\n+  if (countstruct != nbstruct)\n+    fatal_reading_state_printf (NULL_STATE_TOKEN, \n+\t\t\t\t\"expected %d structures but got %d\",\n+\t\t\t\tnbstruct, countstruct);\n+  if (verbosity_level >= 2)\n+    printf (\"%s read %d structures from state\\n\", progname, nbstruct);\n+  *structures = head;\n+}\n+\n+\n+/* Read the param_struct-s.  */\n+static void\n+read_state_param_structs (type_p *param_structs)\n+{\n+  int nbparamstructs = 0;\n+  int countparamstructs = 0;\n+  type_p head = NULL;\n+  type_p previous;\n+  type_p tmp;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!param_structs\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      nbparamstructs = t2->stok_un.stok_num;\n+      next_state_tokens (3);\n+      t0 = t1 = t2 = NULL;\n+      t0 = peek_state_token (0);\n+      while (state_token_kind (t0) != STOK_RIGHTPAR)\n+\t{\n+\t  tmp = NULL;\n+\t  read_state_type (&tmp);\n+\t  if (head == NULL)\n+\t    {\n+\t      head = tmp;\n+\t      previous = head;\n+\t    }\n+\t  else\n+\t    {\n+\t      previous->next = tmp;\n+\t      previous = tmp;\n+\t    }\n+\t  t0 = peek_state_token (0);\n+\t  countparamstructs++;\n+\t}\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad param_structs syntax\");\n+  t0 = peek_state_token (0);\n+  if (countparamstructs != nbparamstructs)\n+    fatal_reading_state_printf\n+      (t0,\n+       \"invalid number of param_structs expected %d got %d\",\n+       nbparamstructs, countparamstructs);\n+  *param_structs = head;\n+}\n+\n+\n+/* Read the variables.  */\n+static void\n+read_state_variables (pair_p *variables)\n+{\n+  pair_p list = NULL;\n+  int nbvars = 0;\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!variables\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      int nbpairs = 0;\n+      nbvars = t2->stok_un.stok_num;\n+      next_state_tokens (3);\n+      nbpairs = read_state_pair_list (&list);\n+      t0 = peek_state_token (0);\n+      if (nbpairs != nbvars)\n+\tfatal_reading_state_printf\n+\t  (t0, \"Invalid number of variables, expected %d but got %d\",\n+\t   nbvars, nbpairs);\n+      if (state_token_kind (t0) == STOK_RIGHTPAR)\n+\tnext_state_tokens (1);\n+      else\n+\tfatal_reading_state (t0, \"Waiting for ) in variables\");\n+    }\n+  else\n+    fatal_reading_state (t0, \"Bad variables syntax\");\n+  *variables = list;\n+  if (verbosity_level >= 2)\n+    printf (\"%s read %d variables from state\\n\", progname, nbvars);\n+}\n+\n+\n+/* Read the source directory.  */\n+static void\n+read_state_srcdir (void)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  if (state_token_kind (t0) == STOK_LEFTPAR &&\n+      state_token_is_name (t1, \"!srcdir\"))\n+    {\n+      next_state_tokens (2);\n+      t0 = peek_state_token (0);\n+      t1 = peek_state_token (1);\n+      if (state_token_kind (t0) == STOK_STRING &&\n+\t  state_token_kind (t1) == STOK_RIGHTPAR)\n+\t{\n+\t  srcdir = xstrdup (t0->stok_un.stok_string);\n+\t  srcdir_len = strlen (srcdir);\n+\t  next_state_tokens (2);\n+\t  return;\n+\t}\n+    }\n+\n+  fatal_reading_state (t0, \"Bad srcdir in state_file\");\n+}\n+\n+\n+/* Read the sequence of GCC front-end languages.  */\n+static void\n+read_state_languages (void)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!languages\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      int i = 0;\n+      num_lang_dirs = t2->stok_un.stok_num;\n+      lang_dir_names = XCNEWVEC (const char *, num_lang_dirs);\n+      next_state_tokens (3);\n+      t0 = t1 = t2 = NULL;\n+      for (i = 0; i < (int) num_lang_dirs; i++)\n+\t{\n+\t  t0 = peek_state_token (0);\n+\t  if (state_token_kind (t0) != STOK_NAME)\n+\t    fatal_reading_state (t0, \"expecting language name in state file\");\n+\t  lang_dir_names[i] = t0->stok_un.stok_ident->stid_name;\n+\t  next_state_tokens (1);\n+\t}\n+      t0 = peek_state_token (0);\n+      if (state_token_kind (t0) != STOK_RIGHTPAR)\n+\tfatal_reading_state (t0, \"missing ) in languages list of state file\");\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"expecting languages list in state file\");\n+\n+}\n+\n+/* Read the sequence of files.  */\n+static void\n+read_state_files_list (void)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!fileslist\")\n+      && state_token_kind (t2) == STOK_INTEGER)\n+    {\n+      int i = 0;\n+      num_gt_files = t2->stok_un.stok_num;\n+      next_state_tokens (3);\n+      t0 = t1 = t2 = NULL;\n+      gt_files = XCNEWVEC (const input_file *, num_gt_files);\n+      for (i = 0; i < (int) num_gt_files; i++)\n+\t{\n+\t  bool issrcfile = FALSE;\n+\t  t0 = t1 = t2 = NULL;\n+\t  t0 = peek_state_token (0);\n+\t  t1 = peek_state_token (1);\n+\t  t2 = peek_state_token (2);\n+\t  if (state_token_kind (t0) == STOK_LEFTPAR\n+\t      && (state_token_is_name (t1, \"!file\")\n+\t\t  || (issrcfile = state_token_is_name (t1, \"!srcfile\")))\n+\t      && state_token_kind (t2) == STOK_INTEGER)\n+\t    {\n+\t      lang_bitmap bmap = t2->stok_un.stok_num;\n+\t      next_state_tokens (3);\n+\t      t0 = t1 = t2 = NULL;\n+\t      t0 = peek_state_token (0);\n+\t      t1 = peek_state_token (1);\n+\t      if (state_token_kind (t0) == STOK_STRING\n+\t\t  && state_token_kind (t1) == STOK_RIGHTPAR)\n+\t\t{\n+\t\t  const char *fnam = t0->stok_un.stok_string;\n+\t\t  /* Allocate & fill a gt_file entry with space for the lang_bitmap before! */\n+\t\t  input_file *curgt = NULL;\n+\t\t  if (issrcfile)\n+\t\t    {\n+\t\t      static const char dirsepstr[2] =\n+\t\t\t{ DIR_SEPARATOR, (char) 0 };\n+\t\t      char *fullpath = concat (srcdir, dirsepstr, fnam, NULL);\n+\t\t      curgt = input_file_by_name (fullpath);\n+\t\t      free (fullpath);\n+\t\t    }\n+\t\t  else\n+\t\t    curgt = input_file_by_name (fnam);\n+\t\t  set_lang_bitmap (curgt, bmap);\n+\t\t  gt_files[i] = curgt;\n+\t\t  next_state_tokens (2);\n+\t\t}\n+\t      else\n+\t\tfatal_reading_state (t0,\n+\t\t\t\t     \"bad file in !fileslist of state file\");\n+\t    }\n+\t  else\n+\t    fatal_reading_state (t0,\n+\t\t\t\t \"expecting file in !fileslist of state file\");\n+\t};\n+      t0 = peek_state_token (0);\n+      if (!state_token_kind (t0) == STOK_RIGHTPAR)\n+\tfatal_reading_state (t0, \"missing ) for !fileslist in state file\");\n+      next_state_tokens (1);\n+    }\n+  else\n+    fatal_reading_state (t0, \"missing !fileslist in state file\");\n+}\n+\n+\n+/* Read the trailer.  */\n+static void\n+read_state_trailer (void)\n+{\n+  struct state_token_st *t0 = peek_state_token (0);\n+  struct state_token_st *t1 = peek_state_token (1);\n+  struct state_token_st *t2 = peek_state_token (2);\n+\n+  if (state_token_kind (t0) == STOK_LEFTPAR\n+      && state_token_is_name (t1, \"!endfile\")\n+      && state_token_kind (t2) == STOK_RIGHTPAR)\n+    next_state_tokens (3);\n+  else\n+    fatal_reading_state (t0, \"missing !endfile in state file\");\n+}\n+\n+\n+/* Utility functions for the state_seen_types hash table.  */\n+static unsigned\n+hash_type_number (const void *ty)\n+{\n+  const struct type *type = (const struct type *) ty;\n+\n+  return type->state_number;\n+}\n+\n+static int\n+equals_type_number (const void *ty1, const void *ty2)\n+{\n+  const struct type *type1 = (const struct type *) ty1;\n+  const struct type *type2 = (const struct type *) ty2;\n+\n+  return type1->state_number == type2->state_number;\n+}\n+\n+\n+/* The function reading the state, called by main from gengtype.c.  */\n+void\n+read_state (const char *path)\n+{\n+  state_file = fopen (path, \"r\");\n+  if (state_file == NULL)\n+    fatal (\"Failed to open state file %s for reading [%s]\", path,\n+\t   xstrerror (errno));\n+  state_path = path;\n+  state_line = 1;\n+\n+  if (verbosity_level >= 1)\n+    {\n+      printf (\"%s reading state file %s;\", progname, state_path);\n+      if (verbosity_level >= 2)\n+\tputchar ('\\n');\n+      fflush (stdout);\n+    }\n+\n+  state_seen_types =\n+    htab_create (2017, hash_type_number, equals_type_number, NULL);\n+  state_ident_tab =\n+    htab_create (4027, htab_hash_string, (htab_eq) strcmp, NULL);\n+  read_state_version (version_string);\n+  read_state_srcdir ();\n+  read_state_languages ();\n+  read_state_files_list ();\n+  read_state_structures (&structures);\n+  if (ferror (state_file))\n+    fatal_reading_state_printf\n+      (NULL_STATE_TOKEN, \"input error while reading state [%s]\",\n+       xstrerror (errno));\n+  read_state_typedefs (&typedefs);\n+  read_state_param_structs (&param_structs);\n+  read_state_variables (&variables);\n+  read_state_trailer ();\n+\n+  if (verbosity_level >= 1)\n+    {\n+      printf (\"%s read %ld bytes.\\n\", progname, ftell (state_file));\n+      fflush (stdout);\n+    };\n+\n+  if (fclose (state_file))\n+    fatal (\"failed to close read state file %s [%s]\",\n+\t   path, xstrerror (errno));\n+  state_file = NULL;\n+  state_path = NULL;\n+}\n+\n+/* End of file gengtype-state.c.  */"}, {"sha": "abf17f8e7f2a38ae8f2d1323ab7e8b32597d684c", "filename": "gcc/gengtype.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=92724e1d707ea2821c9a94517ba3b830f84eb296", "patch": "@@ -67,6 +67,10 @@ int do_debug;\n /* Level for verbose messages.  */\n int verbosity_level;\n \n+/* We have a type count and use it to set the state_number of newly\n+   allocated types to some unique negative number.  */\n+static int type_count;\n+\n /* The backup directory should be in the same file system as the\n    generated files, otherwise the rename(2) system call would fail.\n    If NULL, no backup is made when overwriting a generated file.  */\n@@ -563,12 +567,14 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n \telse if (si->u.s.line.file != NULL && si->u.s.bitmap != bitmap)\n \t  {\n \t    ls = si;\n+\t    type_count++;\n \t    si = XCNEW (struct type);\n \t    memcpy (si, ls, sizeof (struct type));\n \t    ls->kind = TYPE_LANG_STRUCT;\n \t    ls->u.s.lang_struct = si;\n \t    ls->u.s.fields = NULL;\n \t    si->next = NULL;\n+\t    si->state_number = -type_count;\n \t    si->pointer_to = NULL;\n \t    si->u.s.lang_struct = ls;\n \t  }\n@@ -577,7 +583,9 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n \n \tif (ls != NULL && s == NULL)\n \t  {\n+\t    type_count++;\n \t    s = XCNEW (struct type);\n+\t    s->state_number = -type_count;\n \t    s->next = ls->u.s.lang_struct;\n \t    ls->u.s.lang_struct = s;\n \t    s->u.s.lang_struct = ls;\n@@ -587,7 +595,9 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n \n   if (s == NULL)\n     {\n+      type_count++;\n       s = XCNEW (struct type);\n+      s->state_number = -type_count;\n       s->next = structures;\n       structures = s;\n     }\n@@ -625,8 +635,10 @@ find_structure (const char *name, int isunion)\n     if (strcmp (name, s->u.s.tag) == 0 && UNION_P (s) == isunion)\n       return s;\n \n+  type_count++;\n   s = XCNEW (struct type);\n   s->next = structures;\n+  s->state_number = -type_count;\n   structures = s;\n   s->kind = isunion ? TYPE_UNION : TYPE_STRUCT;\n   s->u.s.tag = name;\n@@ -650,9 +662,11 @@ find_param_structure (type_p t, type_p param[NUM_PARAM])\n       break;\n   if (res == NULL)\n     {\n+      type_count++;\n       res = XCNEW (struct type);\n       res->kind = TYPE_PARAM_STRUCT;\n       res->next = param_structs;\n+      res->state_number = -type_count;\n       param_structs = res;\n       res->u.param_struct.stru = t;\n       memcpy (res->u.param_struct.param, param, sizeof (type_p) * NUM_PARAM);\n@@ -679,6 +693,8 @@ create_pointer (type_p t)\n   if (!t->pointer_to)\n     {\n       type_p r = XCNEW (struct type);\n+      type_count++;\n+      r->state_number = -type_count;\n       r->kind = TYPE_POINTER;\n       r->u.p = t;\n       t->pointer_to = r;\n@@ -693,8 +709,10 @@ create_array (type_p t, const char *len)\n {\n   type_p v;\n \n+  type_count++;\n   v = XCNEW (struct type);\n   v->kind = TYPE_ARRAY;\n+  v->state_number = -type_count;\n   v->u.a.p = t;\n   v->u.a.len = len;\n   return v;\n@@ -4600,7 +4618,9 @@ dump_structures (const char *name, type_p structures)\n   printf (\"End of %s\\n\\n\", name);\n }\n \n-/* Dumps the internal structures of gengtype.  */\n+/* Dumps the internal structures of gengtype.  This is useful to debug\n+   gengtype itself, or to understand what it does, e.g. for plugin\n+   developers.  */\n \n static void\n dump_everything (void)\n@@ -4836,8 +4856,12 @@ main (int argc, char **argv)\n   DBGPRINTF (\"inputlist %s\", inputlist);\n   if (read_state_filename)\n     {\n-      fatal (\"read state %s not implemented yet\", read_state_filename);\n-      /* TODO: implement read state.  */\n+      if (inputlist)\n+\tfatal (\"input list %s cannot be given with a read state file %s\",\n+\t       inputlist, read_state_filename);\n+      read_state (read_state_filename);\n+      DBGPRINT_COUNT_TYPE (\"structures after read_state\", structures);\n+      DBGPRINT_COUNT_TYPE (\"param_structs after read_state\", param_structs);\n     }\n   else if (inputlist)\n     {\n@@ -4867,7 +4891,8 @@ main (int argc, char **argv)\n \t\t     (int) i, get_input_file_name (gt_files[i]));\n \t}\n       if (verbosity_level >= 1)\n-\tprintf (\"%s parsed %d files\\n\", progname, (int) num_gt_files);\n+\tprintf (\"%s parsed %d files with %d GTY types\\n\", \n+\t\tprogname, (int) num_gt_files, type_count);\n \n       DBGPRINT_COUNT_TYPE (\"structures after parsing\", structures);\n       DBGPRINT_COUNT_TYPE (\"param_structs after parsing\", param_structs);\n@@ -4892,7 +4917,7 @@ main (int argc, char **argv)\n \tfatal (\"No plugin files given in plugin mode for %s\",\n \t       plugin_output_filename);\n \n-      /* Parse our plugin files.  */\n+      /* Parse our plugin files and augment the state.  */\n       for (ix = 0; ix < nb_plugin_files; ix++)\n \tparse_file (get_input_file_name (plugin_files[ix]));\n \n@@ -4917,11 +4942,30 @@ main (int argc, char **argv)\n      hence enlarge the param_structs list of types.  */\n   set_gc_used (variables);\n \n-  /* We should write the state here, but it is not yet implemented.  */\n+ /* The state at this point is read from the state input file or by\n+    parsing source files and optionally augmented by parsing plugin\n+    source files.  Write it now.  */\n   if (write_state_filename)\n     {\n-      fatal (\"write state %s in not yet implemented\", write_state_filename);\n-      /* TODO: implement write state.  */\n+      DBGPRINT_COUNT_TYPE (\"structures before write_state\", structures);\n+      DBGPRINT_COUNT_TYPE (\"param_structs before write_state\", param_structs);\n+\n+      if (hit_error)\n+\tfatal (\"didn't write state file %s after errors\", \n+\t       write_state_filename);\n+\n+      DBGPRINTF (\"before write_state %s\", write_state_filename);\n+      write_state (write_state_filename);\n+\n+      if (do_dump)\n+\tdump_everything ();\n+\n+      /* After having written the state file we return immediately to\n+\t avoid generating any output file.  */\n+      if (hit_error)\n+\treturn 1;\n+      else\n+\treturn 0;\n     }\n \n "}, {"sha": "136ab61fe75ed1a269df787fcd77ea7460829402", "filename": "gcc/gengtype.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92724e1d707ea2821c9a94517ba3b830f84eb296/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=92724e1d707ea2821c9a94517ba3b830f84eb296", "patch": "@@ -374,6 +374,13 @@ extern size_t srcdir_len;\n extern const char *read_state_filename; /* (-r) program argument. */\n extern const char *write_state_filename; /* (-w) program argument. */\n \n+/* Functions reading and writing the entire gengtype state, called from\n+   main, and implemented in file gengtype-state.c.  */\n+void read_state (const char* path);\n+/* Write the state, and update the state_number field in types.  */\n+void write_state (const char* path);\n+\n+\n /* Print an error message.  */\n extern void error_at_line\n (const struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;"}]}