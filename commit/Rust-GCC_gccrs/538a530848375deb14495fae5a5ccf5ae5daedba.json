{"sha": "538a530848375deb14495fae5a5ccf5ae5daedba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM4YTUzMDg0ODM3NWRlYjE0NDk1ZmFlNWE1Y2NmNWFlNWRhZWRiYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-01-30T02:43:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-01-30T02:43:04Z"}, "message": "PR c++/86943 - wrong code converting lambda to function pointer.\n\nIn this PR, instantiating the static thunk returned from the generic lambda\nconversion function template was using normal overload resolution, which\nmeant calling an extra constructor when forwarding its argument.  Fixed by\nspecial-casing thunk calls significantly more.\n\n\t* lambda.c (maybe_add_lambda_conv_op): Use a template-id in the\n\tcall.  Only forward parms for decltype.\n\t* pt.c (tsubst_copy_and_build) [CALL_EXPR]: Handle CALL_FROM_THUNK_P\n\tspecially.\n\t* typeck.c (check_return_expr): Don't mess with a thunk call.\n\nFrom-SVN: r268377", "tree": {"sha": "2014ffc7cf9d736a2f0e7a17bddbaa3c9087d660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2014ffc7cf9d736a2f0e7a17bddbaa3c9087d660"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/538a530848375deb14495fae5a5ccf5ae5daedba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538a530848375deb14495fae5a5ccf5ae5daedba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/538a530848375deb14495fae5a5ccf5ae5daedba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538a530848375deb14495fae5a5ccf5ae5daedba/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dca2770bc073353e621e426d4803b8ea16382b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dca2770bc073353e621e426d4803b8ea16382b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dca2770bc073353e621e426d4803b8ea16382b5a"}], "stats": {"total": 134, "additions": 111, "deletions": 23}, "files": [{"sha": "af4d9c2635efd84874d3035d8d39ccf556d22e5f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=538a530848375deb14495fae5a5ccf5ae5daedba", "patch": "@@ -1,3 +1,12 @@\n+2019-01-29  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/86943 - wrong code converting lambda to function pointer.\n+\t* lambda.c (maybe_add_lambda_conv_op): Use a template-id in the\n+\tcall.  Only forward parms for decltype.\n+\t* pt.c (tsubst_copy_and_build) [CALL_EXPR]: Handle CALL_FROM_THUNK_P\n+\tspecially.\n+\t* typeck.c (check_return_expr): Don't mess with a thunk call.\n+\n 2019-01-28  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/89089 - ICE with [[no_unique_address]]."}, {"sha": "bc64a4173f931786ce98d687e127ce822421b955", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=538a530848375deb14495fae5a5ccf5ae5daedba", "patch": "@@ -1095,8 +1095,10 @@ maybe_add_lambda_conv_op (tree type)\n \t implementation of the conversion operator.  */\n \n       tree instance = cp_build_fold_indirect_ref (thisarg);\n-      tree objfn = build_min (COMPONENT_REF, NULL_TREE,\n-\t\t\t      instance, DECL_NAME (callop), NULL_TREE);\n+      tree objfn = lookup_template_function (DECL_NAME (callop),\n+\t\t\t\t\t     DECL_TI_ARGS (callop));\n+      objfn = build_min (COMPONENT_REF, NULL_TREE,\n+\t\t\t instance, objfn, NULL_TREE);\n       int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;\n \n       call = prepare_op_call (objfn, nargs);\n@@ -1137,18 +1139,21 @@ maybe_add_lambda_conv_op (tree type)\n \n \tif (generic_lambda_p)\n \t  {\n-\t    /* Avoid capturing variables in this context.  */\n-\t    ++cp_unevaluated_operand;\n-\t    tree a = forward_parm (tgt);\n-\t    --cp_unevaluated_operand;\n-\n+\t    tree a = tgt;\n+\t    if (DECL_PACK_P (tgt))\n+\t      {\n+\t\ta = make_pack_expansion (a);\n+\t\tPACK_EXPANSION_LOCAL_P (a) = true;\n+\t      }\n \t    CALL_EXPR_ARG (call, ix) = a;\n-\t    if (decltype_call)\n-\t      CALL_EXPR_ARG (decltype_call, ix) = unshare_expr (a);\n \n-\t    if (PACK_EXPANSION_P (a))\n-\t      /* Set this after unsharing so it's not in decltype_call.  */\n-\t      PACK_EXPANSION_LOCAL_P (a) = true;\n+\t    if (decltype_call)\n+\t      {\n+\t\t/* Avoid capturing variables in this context.  */\n+\t\t++cp_unevaluated_operand;\n+\t\tCALL_EXPR_ARG (decltype_call, ix) = forward_parm (tgt);\n+\t\t--cp_unevaluated_operand;\n+\t      }\n \n \t    ++ix;\n \t  }"}, {"sha": "cb06a570d48c3c35c226b46e88aedaccb8952fc8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=538a530848375deb14495fae5a5ccf5ae5daedba", "patch": "@@ -18680,6 +18680,52 @@ tsubst_copy_and_build (tree t,\n \t      }\n \t  }\n \n+\t/* Stripped-down processing for a call in a thunk.  Specifically, in\n+\t   the thunk template for a generic lambda.  */\n+\tif (CALL_FROM_THUNK_P (t))\n+\t  {\n+\t    tree thisarg = NULL_TREE;\n+\t    if (TREE_CODE (function) == COMPONENT_REF)\n+\t      {\n+\t\tthisarg = TREE_OPERAND (function, 0);\n+\t\tif (TREE_CODE (thisarg) == INDIRECT_REF)\n+\t\t  thisarg = TREE_OPERAND (thisarg, 0);\n+\t\tfunction = TREE_OPERAND (function, 1);\n+\t\tif (TREE_CODE (function) == BASELINK)\n+\t\t  function = BASELINK_FUNCTIONS (function);\n+\t      }\n+\t    /* We aren't going to do normal overload resolution, so force the\n+\t       template-id to resolve.  */\n+\t    function = resolve_nondeduced_context (function, complain);\n+\t    for (unsigned i = 0; i < nargs; ++i)\n+\t      {\n+\t\t/* In a thunk, pass through args directly, without any\n+\t\t   conversions.  */\n+\t\ttree arg = (*call_args)[i];\n+\t\twhile (TREE_CODE (arg) != PARM_DECL)\n+\t\t  arg = TREE_OPERAND (arg, 0);\n+\t\t(*call_args)[i] = arg;\n+\t      }\n+\t    if (thisarg)\n+\t      {\n+\t\t/* Shift the other args over to make room.  */\n+\t\tvec_safe_push (call_args, (*call_args)[nargs-1]);\n+\t\tfor (int i = nargs-1; i > 0; --i)\n+\t\t  (*call_args)[i] = (*call_args)[i-1];\n+\t\t(*call_args)[0] = thisarg;\n+\t      }\n+\t    ret = build_call_a (function, call_args->length (),\n+\t\t\t\tcall_args->address ());\n+\t    /* The thunk location is not interesting.  */\n+\t    SET_EXPR_LOCATION (ret, UNKNOWN_LOCATION);\n+\t    CALL_FROM_THUNK_P (ret) = true;\n+\t    if (CLASS_TYPE_P (TREE_TYPE (ret)))\n+\t      CALL_EXPR_RETURN_SLOT_OPT (ret) = true;\n+\n+\t    release_tree_vector (call_args);\n+\t    RETURN (ret);\n+\t  }\n+\n \t/* We do not perform argument-dependent lookup if normal\n \t   lookup finds a non-function, in accordance with the\n \t   expected resolution of DR 218.  */\n@@ -18883,22 +18929,12 @@ tsubst_copy_and_build (tree t,\n \t    bool op = CALL_EXPR_OPERATOR_SYNTAX (t);\n \t    bool ord = CALL_EXPR_ORDERED_ARGS (t);\n \t    bool rev = CALL_EXPR_REVERSE_ARGS (t);\n-\t    bool thk = CALL_FROM_THUNK_P (t);\n-\t    if (op || ord || rev || thk)\n+\t    if (op || ord || rev)\n \t      {\n \t\tfunction = extract_call_expr (ret);\n \t\tCALL_EXPR_OPERATOR_SYNTAX (function) = op;\n \t\tCALL_EXPR_ORDERED_ARGS (function) = ord;\n \t\tCALL_EXPR_REVERSE_ARGS (function) = rev;\n-\t\tif (thk)\n-\t\t  {\n-\t\t    if (TREE_CODE (function) == CALL_EXPR)\n-\t\t      CALL_FROM_THUNK_P (function) = true;\n-\t\t    else\n-\t\t      AGGR_INIT_FROM_THUNK_P (function) = true;\n-\t\t    /* The thunk location is not interesting.  */\n-\t\t    SET_EXPR_LOCATION (function, UNKNOWN_LOCATION);\n-\t\t  }\n \t      }\n \t  }\n "}, {"sha": "7045284552975fd3c4ff9216f88d4b9974945a83", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=538a530848375deb14495fae5a5ccf5ae5daedba", "patch": "@@ -9728,6 +9728,11 @@ check_return_expr (tree retval, bool *no_warning)\n \t    }\n \t}\n \n+      /* The call in a (lambda) thunk needs no conversions.  */\n+      if (TREE_CODE (retval) == CALL_EXPR\n+\t  && CALL_FROM_THUNK_P (retval))\n+\tconverted = true;\n+\n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n \t case that functype is smaller than the valtype.  */"}, {"sha": "159c4ccd5258d7d35aa4c72f9502bc2387b27a32", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv13.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538a530848375deb14495fae5a5ccf5ae5daedba/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv13.C?ref=538a530848375deb14495fae5a5ccf5ae5daedba", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/86943\n+// { dg-do run { target c++14 } }\n+\n+int c[3];\n+\n+struct S\n+{\n+  S () : s (1234) { c[0]++; }\n+  S (const S &) { __builtin_abort (); }\n+  S (S &&x) noexcept { if (x.s != 1234) __builtin_abort (); s = 1234; x.s = 2345; c[1]++; }\n+  ~S () { if (s != 1234 && s != 2345) __builtin_abort (); c[2]++; }\n+  int s;\n+};\n+\n+using F = S (*) (S);\n+\n+F\n+foo ()\n+{\n+  return [] (auto val)->S { if (val.s != 1234) __builtin_abort (); return {}; };\n+}\n+\n+int\n+main ()\n+{\n+  {\n+    volatile F f = foo ();\n+    S s = f ({});\n+    if (s.s != 1234) __builtin_abort ();\n+  }\n+  if (c[0] + c[1] != c[2])\n+    __builtin_abort ();\n+}"}]}