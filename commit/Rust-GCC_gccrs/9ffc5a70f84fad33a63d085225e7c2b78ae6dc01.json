{"sha": "9ffc5a70f84fad33a63d085225e7c2b78ae6dc01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZmYzVhNzBmODRmYWQzM2E2M2QwODUyMjVlN2MyYjc4YWU2ZGMwMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-22T13:43:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-22T13:43:39Z"}, "message": "regclass.c (reg_pref): New structure and static variable\n\n\t* regclass.c (reg_pref): New structure and static variable\n\t(prefclass): Delete.\n\t(altclass): Delete.\n\t(all uses of prefclass and altclass): Use reg_pref instead.\n\nFrom-SVN: r30610", "tree": {"sha": "f0f4785018e4f027524558ab84ffbff065f6c578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0f4785018e4f027524558ab84ffbff065f6c578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01/comments", "author": null, "committer": null, "parents": [{"sha": "28a22acb45d47ca56525d40046e6d7cbb293a4f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28a22acb45d47ca56525d40046e6d7cbb293a4f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28a22acb45d47ca56525d40046e6d7cbb293a4f2"}], "stats": {"total": 116, "additions": 58, "deletions": 58}, "files": [{"sha": "fed88121ae4082201fc2ee17da8b268e2441135e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ffc5a70f84fad33a63d085225e7c2b78ae6dc01", "patch": "@@ -1,3 +1,10 @@\n+Mon Nov 22 14:42:22 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* regclass.c (reg_pref): New structure and static variable\n+\t(prefclass): Delete.\n+\t(altclass): Delete.\n+\t(all uses of prefclass and altclass): Use reg_pref instead.\n+\n 1999-11-21  Nick Clifton  <nickc@cygnus.com>\n \n \t* invoke.texi (ARM Options): Replace -mshort-load-bytes with"}, {"sha": "544159bc6248134d7787e71ebf91c771b2ef69ff", "filename": "gcc/regclass.c", "status": "modified", "additions": 51, "deletions": 58, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ffc5a70f84fad33a63d085225e7c2b78ae6dc01/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=9ffc5a70f84fad33a63d085225e7c2b78ae6dc01", "patch": "@@ -661,6 +661,22 @@ struct costs\n   int mem_cost;\n };\n \n+/* Structure used to record preferrences of given pseudo.  */\n+struct reg_pref\n+{\n+  /* (enum reg_class) prefclass is the preferred class.  */\n+  char prefclass;\n+\n+  /* altclass is a register class that we should use for allocating\n+     pseudo if no register in the preferred class is available.\n+     If no register in this class is available, memory is preferred.\n+\n+     It might appear to be more general to have a bitmask of classes here,\n+     but since it is recommended that there be a class corresponding to the\n+     union of most major pair of classes, that generality is not required.  */\n+  char altclass;\n+};\n+\n /* Record the cost of each class for each pseudo.  */\n \n static struct costs *costs;\n@@ -675,26 +691,14 @@ static struct costs init_cost;\n \n static struct costs op_costs[MAX_RECOG_OPERANDS];\n \n-/* (enum reg_class) prefclass[R] is the preferred class for pseudo number R.\n+/* Record preferrences of each pseudo.\n    This is available after `regclass' is run.  */\n \n-static char *prefclass;\n-\n-/* altclass[R] is a register class that we should use for allocating\n-   pseudo number R if no register in the preferred class is available.\n-   If no register in this class is available, memory is preferred.\n-\n-   It might appear to be more general to have a bitmask of classes here,\n-   but since it is recommended that there be a class corresponding to the\n-   union of most major pair of classes, that generality is not required. \n+static struct reg_pref *reg_pref;\n \n-   This is available after `regclass' is run.  */\n-\n-static char *altclass;\n+/* Allocated buffers for reg_pref. */\n \n-/* Allocated buffers for prefclass and altclass. */\n-static char *prefclass_buffer;\n-static char *altclass_buffer;\n+static struct reg_pref *reg_pref_buffer;\n \n /* Record the depth of loops that we are in.  */\n \n@@ -725,19 +729,19 @@ enum reg_class\n reg_preferred_class (regno)\n      int regno;\n {\n-  if (prefclass == 0)\n+  if (reg_pref == 0)\n     return GENERAL_REGS;\n-  return (enum reg_class) prefclass[regno];\n+  return (enum reg_class) reg_pref[regno].prefclass;\n }\n \n enum reg_class\n reg_alternate_class (regno)\n      int regno;\n {\n-  if (prefclass == 0)\n+  if (reg_pref == 0)\n     return ALL_REGS;\n \n-  return (enum reg_class) altclass[regno];\n+  return (enum reg_class) reg_pref[regno].altclass;\n }\n \n /* Initialize some global data for this pass.  */\n@@ -753,7 +757,7 @@ regclass_init ()\n \n   /* This prevents dump_flow_info from losing if called\n      before regclass is run.  */\n-  prefclass = 0;\n+  reg_pref = NULL;\n }\n \f\n /* Dump register costs.  */\n@@ -1077,14 +1081,11 @@ regclass (f, nregs, dump)\n       \n       /* Now for each register look at how desirable each class is\n \t and find which class is preferred.  Store that in\n-\t `prefclass[REGNO]'.  Record in `altclass[REGNO]' the largest register\n+\t `prefclass'.  Record in `altclass' the largest register\n \t class any of whose registers is better than memory.  */\n     \n       if (pass == 0)\n-\t{\n-\t  prefclass = prefclass_buffer;\n-\t  altclass = altclass_buffer;\n-\t}\n+\treg_pref = reg_pref_buffer;\n \n       for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n \t{\n@@ -1138,8 +1139,8 @@ regclass (f, nregs, dump)\n \t    alt = NO_REGS;\n \n \t  /* We cast to (int) because (char) hits bugs in some compilers.  */\n-\t  prefclass[i] = (int) best;\n-\t  altclass[i] = (int) alt;\n+\t  reg_pref[i].prefclass = (int) best;\n+\t  reg_pref[i].altclass = (int) alt;\n \t}\n     }\n \n@@ -1304,9 +1305,9 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t     to what we would add if this register were not in the\n \t\t     appropriate class.  */\n \n-\t\t  if (prefclass)\n+\t\t  if (reg_pref)\n \t\t    alt_cost\n-\t\t      += (may_move_in_cost[(unsigned char) prefclass[REGNO (op)]]\n+\t\t      += (may_move_in_cost[(unsigned char) reg_pref[REGNO (op)].prefclass]\n \t\t\t  [(int) classes[i]]);\n \n \t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n@@ -1525,9 +1526,9 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t     to what we would add if this register were not in the\n \t\t     appropriate class.  */\n \n-\t\t  if (prefclass)\n+\t\t  if (reg_pref)\n \t\t    alt_cost\n-\t\t      += (may_move_in_cost[(unsigned char) prefclass[REGNO (op)]]\n+\t\t      += (may_move_in_cost[(unsigned char) reg_pref[REGNO (op)].prefclass]\n \t\t\t  [(int) classes[i]]);\n \t\t}\n \t    }\n@@ -1599,10 +1600,10 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t  int class;\n \t  int nr;\n \n-\t  if (regno >= FIRST_PSEUDO_REGISTER && prefclass != 0\n-\t      && (reg_class_size[(unsigned char) prefclass[regno]]\n-\t\t  == CLASS_MAX_NREGS (prefclass[regno], mode)))\n-\t    op_costs[i].cost[(unsigned char) prefclass[regno]] = -1;\n+\t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0\n+\t      && (reg_class_size[(unsigned char) reg_pref[regno].prefclass]\n+\t\t  == CLASS_MAX_NREGS (reg_pref[regno].prefclass, mode)))\n+\t    op_costs[i].cost[(unsigned char) reg_pref[regno].prefclass] = -1;\n \t  else if (regno < FIRST_PSEUDO_REGISTER)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n@@ -1923,8 +1924,8 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \t{\n \t  VARRAY_REG_INIT (reg_n_info, regno_allocated, \"reg_n_info\");\n \t  renumber = (short *) xmalloc (size_renumber);\n-\t  prefclass_buffer = (char *) xmalloc (regno_allocated);\n-\t  altclass_buffer = (char *) xmalloc (regno_allocated);\n+\t  reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated \n+\t\t\t\t\t      * sizeof (struct reg_pref));\n \t}\n \n       else\n@@ -1934,21 +1935,18 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \t  if (new_p)\t\t/* if we're zapping everything, no need to realloc */\n \t    {\n \t      free ((char *)renumber);\n-\t      free ((char *)prefclass_buffer);\n-\t      free ((char *)altclass_buffer);\n+\t      free ((char *)reg_pref);\n \t      renumber = (short *) xmalloc (size_renumber);\n-\t      prefclass_buffer = (char *) xmalloc (regno_allocated);\n-\t      altclass_buffer = (char *) xmalloc (regno_allocated);\n+\t      reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated \n+\t\t\t\t\t\t  * sizeof (struct reg_pref));\n \t    }\n \n \t  else\n \t    {\n \t      renumber = (short *) xrealloc ((char *)renumber, size_renumber);\n-\t      prefclass_buffer = (char *) xrealloc ((char *)prefclass_buffer,\n-\t\t\t\t\t\t    regno_allocated);\n-\n-\t      altclass_buffer = (char *) xrealloc ((char *)altclass_buffer,\n-\t\t\t\t\t\t   regno_allocated);\n+\t      reg_pref_buffer = (struct reg_pref *) xrealloc ((char *)reg_pref_buffer,\n+\t\t\t\t\t\t   regno_allocated \n+\t\t\t\t\t\t   * sizeof (struct reg_pref));\n \t    }\n \t}\n \n@@ -1991,20 +1989,17 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \t\t  VARRAY_REG (reg_n_info, i) = &reg_data->data[i-min_index];\n \t\t  REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n \t\t  renumber[i] = -1;\n-\t\t  prefclass_buffer[i] = (char) NO_REGS;\n-\t\t  altclass_buffer[i] = (char) NO_REGS;\n+\t\t  reg_pref_buffer[i].prefclass = (char) NO_REGS;\n+\t\t  reg_pref_buffer[i].altclass = (char) NO_REGS;\n \t\t}\n \t    }\n \t}\n     }\n \n   /* If {pref,alt}class have already been allocated, update the pointers to\n      the newly realloced ones.  */\n-  if (prefclass)\n-    {\n-      prefclass = prefclass_buffer;\n-      altclass = altclass_buffer;\n-    }\n+  if (reg_pref)\n+    reg_pref = reg_pref_buffer;\n \n   if (renumber_p)\n     reg_renumber = renumber;\n@@ -2029,10 +2024,8 @@ free_reg_info ()\n \t  free ((char *)reg_data);\n \t}\n \n-      free (prefclass_buffer);\n-      free (altclass_buffer);\n-      prefclass_buffer = (char *)0;\n-      altclass_buffer = (char *)0;\n+      free (reg_pref_buffer);\n+      reg_pref_buffer = (struct reg_pref *)0;\n       reg_info_head = (struct reg_info_data *)0;\n       renumber = (short *)0;\n     }"}]}