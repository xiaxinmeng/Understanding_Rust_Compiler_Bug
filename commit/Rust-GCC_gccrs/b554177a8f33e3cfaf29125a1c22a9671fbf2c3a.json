{"sha": "b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU1NDE3N2E4ZjMzZTNjZmFmMjkxMjVhMWMyMmE5NjcxZmJmMmMzYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T12:07:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T12:07:59Z"}, "message": "[multiple changes]\n\n2017-04-25  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_ch3.adb (Freeze_Type): Add condition to always treat\n\tinterface types as a partial view of a private type for the\n\tgeneration of invariant procedure bodies.\n\t* exp_util.adb, exp_util.ads (Add_Inherited_Invariants):\n\tAdd a condition to get the Corresponding_Record_Type for\n\tconcurrent types, add condition to return in the absence of a\n\tclass in the pragma, remove call to Replace_Type_References,\n\tand add call to Replace_References.\n\t(Add_Interface_Invariatns),\n\t(Add_Parent_Invariants): Modify call to Add_Inherited_Invariants\n\tto including the working type T.\n\t(Add_Own_Invariants): Remove\n\tlegacy condition for separate units, remove dispatching for ASIS\n\tand save a copy of the expression in the pragma expression.\n\t(Build_Invariant_Procedure_Body): Default initalize vars,\n\tremove return condition on interfaces, always use the\n\tprivate type for interfaces, and move the processing of types\n\tuntil after the processing of invariants for the full view.\n\t(Build_Invariant_Procedure_Declaration): Remove condition\n\tto return if an interface type is encountered and add\n\tcondition to convert the formal parameter to its class-wide\n\tcounterpart if Work_Typ is abstract.\n\t(Replace_Type): Add call to Remove_Controlling_Arguments.\n\t(Replace_Type_Ref): Remove class-wide dispatching for the current\n\tinstance of the type.\n\t(Replace_Type_References): Remove parameter \"Derived\"\n\t(Remove_Controlling_Arguments): Created in order to removing\n\tthe controlliong argument from calls to primitives in the case\n\tof the formal parameter being an class-wide abstract type.\n\t* sem_ch3.adb (Build_Assertion_Bodies_For_Type): Almost identical\n\tto the change made to Freeze_Type in exp_ch3. Add a condition\n\tto treat interface types as a partial view.\n\t* sem_prag.adb (Analyze_Pragma): Modify parameters in the call\n\tto Build_Invariant_Procedure_Declaration to properly generate a\n\t\"partial\" invariant procedure when Typ is an interface.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* a-numeri.ads: Go back to using brackets encoding for the Greek\n\tletter pi.\n\nFrom-SVN: r247204", "tree": {"sha": "4c3289f10c84ec05f3b344b968a4c6037edc35b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c3289f10c84ec05f3b344b968a4c6037edc35b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/comments", "author": null, "committer": null, "parents": [{"sha": "c9e9c3ac4d6554fc26f540b95ad3f1ef9eccfc26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e9c3ac4d6554fc26f540b95ad3f1ef9eccfc26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e9c3ac4d6554fc26f540b95ad3f1ef9eccfc26"}], "stats": {"total": 561, "additions": 357, "deletions": 204}, "files": [{"sha": "93ace03de42b9b808e1a8e97bf70048d15c68cc7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -1,3 +1,46 @@\n+2017-04-25  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_ch3.adb (Freeze_Type): Add condition to always treat\n+\tinterface types as a partial view of a private type for the\n+\tgeneration of invariant procedure bodies.\n+\t* exp_util.adb, exp_util.ads (Add_Inherited_Invariants):\n+\tAdd a condition to get the Corresponding_Record_Type for\n+\tconcurrent types, add condition to return in the absence of a\n+\tclass in the pragma, remove call to Replace_Type_References,\n+\tand add call to Replace_References.\n+\t(Add_Interface_Invariatns),\n+\t(Add_Parent_Invariants): Modify call to Add_Inherited_Invariants\n+\tto including the working type T.\n+\t(Add_Own_Invariants): Remove\n+\tlegacy condition for separate units, remove dispatching for ASIS\n+\tand save a copy of the expression in the pragma expression.\n+\t(Build_Invariant_Procedure_Body): Default initalize vars,\n+\tremove return condition on interfaces, always use the\n+\tprivate type for interfaces, and move the processing of types\n+\tuntil after the processing of invariants for the full view.\n+\t(Build_Invariant_Procedure_Declaration): Remove condition\n+\tto return if an interface type is encountered and add\n+\tcondition to convert the formal parameter to its class-wide\n+\tcounterpart if Work_Typ is abstract.\n+\t(Replace_Type): Add call to Remove_Controlling_Arguments.\n+\t(Replace_Type_Ref): Remove class-wide dispatching for the current\n+\tinstance of the type.\n+\t(Replace_Type_References): Remove parameter \"Derived\"\n+\t(Remove_Controlling_Arguments): Created in order to removing\n+\tthe controlliong argument from calls to primitives in the case\n+\tof the formal parameter being an class-wide abstract type.\n+\t* sem_ch3.adb (Build_Assertion_Bodies_For_Type): Almost identical\n+\tto the change made to Freeze_Type in exp_ch3. Add a condition\n+\tto treat interface types as a partial view.\n+\t* sem_prag.adb (Analyze_Pragma): Modify parameters in the call\n+\tto Build_Invariant_Procedure_Declaration to properly generate a\n+\t\"partial\" invariant procedure when Typ is an interface.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* a-numeri.ads: Go back to using brackets encoding for the Greek\n+\tletter pi.\n+\n 2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Derive_Subprogram): Implement rule in RM 6.1.1"}, {"sha": "805fa5670ba78d0501e3020d38e8c975f6a3bc23", "filename": "gcc/ada/a-numeri.ads", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fa-numeri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fa-numeri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-numeri.ads?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -18,20 +18,14 @@ package Ada.Numerics is\n \n    Argument_Error : exception;\n \n-   pragma Wide_Character_Encoding (UTF8);\n-   --  For the Greek letter Pi below. Note that this pragma cannot immediately\n-   --  precede that character, because then the encoding gets set too late.\n-\n    Pi : constant :=\n           3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;\n \n-   \u03c0 : constant := Pi;\n+   [\"03C0\"] : constant := Pi;\n    --  This is the Greek letter Pi (for Ada 2005 AI-388). Note that it is\n    --  conforming to have this constant present even in Ada 95 mode, as there\n    --  is no way for a normal mode Ada 95 program to reference this identifier.\n \n-   pragma Wide_Character_Encoding (BRACKETS);\n-\n    e : constant :=\n          2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996;\n "}, {"sha": "b67ee2d4254e36cba33184caf8adc5536e0c37a2", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -7529,7 +7529,22 @@ package body Exp_Ch3 is\n       --  class-wide invariants from parent types or interfaces, and invariants\n       --  on array elements or record components.\n \n-      if Has_Invariants (Def_Id) then\n+      if Is_Interface (Def_Id) then\n+\n+         --  Interfaces are treated as the partial view of a private type in\n+         --  order to achieve uniformity with the general case. As a result, an\n+         --  interface receives only a \"partial\" invariant procedure which is\n+         --  never called.\n+\n+         if Has_Own_Invariants (Def_Id) then\n+            Build_Invariant_Procedure_Body\n+              (Typ               => Def_Id,\n+               Partial_Invariant => Is_Interface (Def_Id));\n+         end if;\n+\n+      --  Non-interface types\n+\n+      elsif Has_Invariants (Def_Id) then\n          Build_Invariant_Procedure_Body (Def_Id);\n       end if;\n "}, {"sha": "3a79f61444c6372dd026564541bdc8a66fab15f3", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 262, "deletions": 183, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -1989,7 +1989,7 @@ package body Exp_Util is\n       --  NOTE: all Add_xxx_Invariants routines are reactive. In other words\n       --  they emit checks, loops (for arrays) and case statements (for record\n       --  variant parts) only when there are invariants to verify. This keeps\n-      --  the body of the invariant procedure free from useless code.\n+      --  the body of the invariant procedure free of useless code.\n \n       procedure Add_Array_Component_Invariants\n         (T      : Entity_Id;\n@@ -2000,14 +2000,16 @@ package body Exp_Util is\n       --  invariant procedure. All created checks are added to list Checks.\n \n       procedure Add_Inherited_Invariants\n-        (Full_Typ : Entity_Id;\n-         Priv_Typ : Entity_Id;\n-         Obj_Id   : Entity_Id;\n-         Checks   : in out List_Id);\n+        (T         : Entity_Id;\n+         Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id);\n       --  Generate an invariant check for each inherited class-wide invariant\n-      --  coming from all parent types of type T. Obj_Id denotes the entity of\n-      --  the _object formal parameter of the invariant procedure. All created\n-      --  checks are added to list Checks.\n+      --  coming from all parent types of type T. Priv_Typ and Full_Typ denote\n+      --  the partial and full view of the parent type. Obj_Id denotes the\n+      --  entity of the _object formal parameter of the invariant procedure.\n+      --  All created checks are added to list Checks.\n \n       procedure Add_Interface_Invariants\n         (T      : Entity_Id;\n@@ -2196,7 +2198,6 @@ package body Exp_Util is\n                                   Attribute_Name => Name_Range,\n                                   Expressions    => New_List (\n                                     Make_Integer_Literal (Loc, Dim))))),\n-\n                       Statements       => Comp_Checks));\n                end if;\n             end if;\n@@ -2216,25 +2217,36 @@ package body Exp_Util is\n       ------------------------------\n \n       procedure Add_Inherited_Invariants\n-        (Full_Typ : Entity_Id;\n-         Priv_Typ : Entity_Id;\n-         Obj_Id   : Entity_Id;\n-         Checks   : in out List_Id)\n+        (T         : Entity_Id;\n+         Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id)\n       is\n-         Arg1 : Node_Id;\n-         Arg2 : Node_Id;\n-         Expr : Node_Id;\n-         Prag : Node_Id;\n+         Deriv_Typ     : Entity_Id;\n+         Expr          : Node_Id;\n+         Prag          : Node_Id;\n+         Prag_Expr     : Node_Id;\n+         Prag_Expr_Arg : Node_Id;\n+         Prag_Typ      : Node_Id;\n+         Prag_Typ_Arg  : Node_Id;\n+\n+         Par_Proc : Entity_Id;\n+         --  The \"partial\" invariant procedure of Par_Typ\n \n-         Rep_Typ : Entity_Id;\n-         --  The replacement type used in the substitution of the current\n-         --  instance of a type with the _object formal parameter\n+         Par_Typ : Entity_Id;\n+         --  The suitable view of the parent type used in the substitution of\n+         --  type attributes.\n \n       begin\n          if not Present (Priv_Typ) and then not Present (Full_Typ) then\n             return;\n          end if;\n \n+         --  Determine which rep item chain to use. Precedence is given to that\n+         --  of the parent type's partial view since it usually carries all the\n+         --  class-wide invariants.\n+\n          if Present (Priv_Typ) then\n             Prag := First_Rep_Item (Priv_Typ);\n          else\n@@ -2249,49 +2261,89 @@ package body Exp_Util is\n \n                if Contains (Pragmas_Seen, Prag) then\n                   return;\n+\n+               --  Nothing to do when the caller requests the processing of all\n+               --  inherited class-wide invariants, but the pragma does not\n+               --  fall in this category.\n+\n+               elsif not Class_Present (Prag) then\n+                  return;\n                end if;\n \n                --  Extract the arguments of the invariant pragma\n \n-               Arg1 := First (Pragma_Argument_Associations (Prag));\n-               Arg2 := Get_Pragma_Arg (Next (Arg1));\n-               Arg1 := Get_Pragma_Arg (Arg1);\n+               Prag_Typ_Arg  := First (Pragma_Argument_Associations (Prag));\n+               Prag_Expr_Arg := Next (Prag_Typ_Arg);\n+               Prag_Expr     := Expression_Copy (Prag_Expr_Arg);\n+               Prag_Typ      := Get_Pragma_Arg (Prag_Typ_Arg);\n \n-               --  The pragma applies to the partial view\n+               --  The pragma applies to the partial view of the parent type\n \n-               if Present (Priv_Typ) and then Entity (Arg1) = Priv_Typ then\n-                  Rep_Typ := Priv_Typ;\n+               if Present (Priv_Typ)\n+                 and then Entity (Prag_Typ) = Priv_Typ\n+               then\n+                  Par_Typ := Priv_Typ;\n \n-               --  The pragma applies to the full view\n+               --  The pragma applies to the full view of the parent type\n \n-               elsif Present (Full_Typ) and then Entity (Arg1) = Full_Typ then\n-                  Rep_Typ := Full_Typ;\n+               elsif Present (Full_Typ)\n+                 and then Entity (Prag_Typ) = Full_Typ\n+               then\n+                  Par_Typ := Full_Typ;\n \n-               --  Otherwise the pragma applies to a parent type and will be\n-               --  processed at a later step by routine Add_Parent_Invariants\n-               --  or Add_Interface_Invariants.\n+               --  Otherwise the pragma does not belong to the parent type and\n+               --  should not be considered.\n \n                else\n                   return;\n                end if;\n \n-               --  Nothing to do when the caller requests the processing of all\n-               --  inherited class-wide invariants, but the pragma does not\n-               --  fall in this category.\n+               --  Perform the following substitutions:\n \n-               if not Class_Present (Prag) then\n-                  return;\n+               --    * Replace a reference to the _object parameter of the\n+               --      parent type's partial invariant procedure with a\n+               --      reference to the _object parameter of the derived\n+               --      type's full invariant procedure.\n+\n+               --    * Replace a reference to a discriminant of the parent type\n+               --      with a suitable value from the point of view of the\n+               --      derived type.\n+\n+               --    * Replace a call to an overridden parent primitive with a\n+               --      call to the overriding derived type primitive.\n+\n+               --    * Replace a call to an inherited parent primitive with a\n+               --      call to the internally-generated inherited derived type\n+               --      primitive.\n+\n+               Expr := New_Copy_Tree (Prag_Expr);\n+\n+               --  When the type inheriting the class-wide invariant is a task\n+               --  or protected type, use the corresponding record type because\n+               --  it contains all primitive operations of the concurren type\n+               --  and allows for proper substitution.\n+\n+               if Is_Concurrent_Type (T) then\n+                  Deriv_Typ := Corresponding_Record_Type (T);\n+               else\n+                  Deriv_Typ := T;\n                end if;\n \n-               Expr := New_Copy_Tree (Arg2);\n+               pragma Assert (Present (Deriv_Typ));\n \n-               --  Substitute all references to type T with references to the\n-               --  _object formal parameter.\n+               --  The parent type must have a \"partial\" invariant procedure\n+               --  because class-wide invariants are captured exclusively by\n+               --  it.\n \n-               --  ??? Dispatching must be removed due to AI12-0150-1\n+               Par_Proc := Partial_Invariant_Procedure (Par_Typ);\n+               pragma Assert (Present (Par_Proc));\n \n-               Replace_Type_References\n-                 (Expr, Rep_Typ, Obj_Id, Dispatch => Class_Present (Prag));\n+               Replace_References\n+                 (Expr      => Expr,\n+                  Par_Typ   => Par_Typ,\n+                  Deriv_Typ => Deriv_Typ,\n+                  Par_Obj   => First_Formal (Par_Proc),\n+                  Deriv_Obj => Obj_Id);\n \n                Add_Invariant_Check (Prag, Expr, Checks, Inherited => True);\n             end if;\n@@ -2323,11 +2375,17 @@ package body Exp_Util is\n \n             Iface_Elmt := First_Elmt (Ifaces);\n             while Present (Iface_Elmt) loop\n+\n+               --  The Full_Typ parameter is intentionally left Empty because\n+               --  interfaces are treated as the partial view of a private type\n+               --  in order to achieve uniformity with the general case.\n+\n                Add_Inherited_Invariants\n-                 (Full_Typ => Node (Iface_Elmt),\n-                  Priv_Typ => Empty,\n-                  Obj_Id   => Obj_Id,\n-                  Checks   => Checks);\n+                 (T         => T,\n+                  Priv_Typ  => Node (Iface_Elmt),\n+                  Full_Typ  => Empty,\n+                  Obj_Id    => Obj_Id,\n+                  Checks    => Checks);\n \n                Next_Elmt (Iface_Elmt);\n             end loop;\n@@ -2358,7 +2416,7 @@ package body Exp_Util is\n          if Is_Ignored (Prag) then\n             null;\n \n-         --  Otherwise the invariant is checked. Build a Check pragma to verify\n+         --  Otherwise the invariant is checked. Build a pragma Check to verify\n          --  the expression at runtime.\n \n          else\n@@ -2479,10 +2537,11 @@ package body Exp_Util is\n             end if;\n \n             Add_Inherited_Invariants\n-              (Full_Typ => Full_Typ,\n-               Priv_Typ => Priv_Typ,\n-               Obj_Id   => Obj_Id,\n-               Checks   => Checks);\n+              (T         => T,\n+               Priv_Typ  => Priv_Typ,\n+               Full_Typ  => Full_Typ,\n+               Obj_Id    => Obj_Id,\n+               Checks    => Checks);\n \n             Curr_Typ := Par_Typ;\n          end loop;\n@@ -2498,13 +2557,14 @@ package body Exp_Util is\n          Checks    : in out List_Id;\n          Priv_Item : Node_Id := Empty)\n       is\n-         Arg1      : Node_Id;\n-         Arg2      : Node_Id;\n-         ASIS_Expr : Node_Id;\n-         Asp       : Node_Id;\n-         Expr      : Node_Id;\n-         Ploc      : Source_Ptr;\n-         Prag      : Node_Id;\n+         ASIS_Expr     : Node_Id;\n+         Expr          : Node_Id;\n+         Prag          : Node_Id;\n+         Prag_Asp      : Node_Id;\n+         Prag_Expr     : Node_Id;\n+         Prag_Expr_Arg : Node_Id;\n+         Prag_Typ      : Node_Id;\n+         Prag_Typ_Arg  : Node_Id;\n \n       begin\n          if not Present (T) then\n@@ -2531,49 +2591,49 @@ package body Exp_Util is\n \n                --  Extract the arguments of the invariant pragma\n \n-               Arg1 := First (Pragma_Argument_Associations (Prag));\n-               Arg2 := Get_Pragma_Arg (Next (Arg1));\n-               Arg1 := Get_Pragma_Arg (Arg1);\n-               Asp  := Corresponding_Aspect (Prag);\n-               Ploc := Sloc (Prag);\n+               Prag_Typ_Arg  := First (Pragma_Argument_Associations (Prag));\n+               Prag_Expr_Arg := Next (Prag_Typ_Arg);\n+               Prag_Expr     := Get_Pragma_Arg (Prag_Expr_Arg);\n+               Prag_Typ      := Get_Pragma_Arg (Prag_Typ_Arg);\n+               Prag_Asp      := Corresponding_Aspect (Prag);\n \n                --  Verify the pragma belongs to T, otherwise the pragma applies\n                --  to a parent type in which case it will be processed later by\n                --  Add_Parent_Invariants or Add_Interface_Invariants.\n \n-               if Entity (Arg1) /= T then\n+               if Entity (Prag_Typ) /= T then\n                   return;\n                end if;\n \n-               Expr := New_Copy_Tree (Arg2);\n+               Expr := New_Copy_Tree (Prag_Expr);\n \n                --  Substitute all references to type T with references to the\n                --  _object formal parameter.\n \n-               Replace_Type_References\n-                 (Expr     => Expr,\n-                  Typ      => T,\n-                  Obj_Id   => Obj_Id,\n-                  Dispatch => Class_Present (Prag));\n+               Replace_Type_References (Expr, T, Obj_Id);\n \n                --  Preanalyze the invariant expression to detect errors and at\n                --  the same time capture the visibility of the proper package\n                --  part.\n \n-               --  Historical note: the old implementation of invariants used\n-               --  node N as the parent, but a package specification as parent\n-               --  of an expression is bizarre.\n-\n-               Set_Parent (Expr, Parent (Arg2));\n+               Set_Parent (Expr, Parent (Prag_Expr));\n                Preanalyze_Assert_Expression (Expr, Any_Boolean);\n \n+               --  Save a copy of the expression when T is tagged to detect\n+               --  errors and capture the visibility of the proper package part\n+               --  for the generation of inherited type invariants.\n+\n+               if Is_Tagged_Type (T) then\n+                  Set_Expression_Copy (Prag_Expr_Arg, New_Copy_Tree (Expr));\n+               end if;\n+\n                --  If the pragma comes from an aspect specification, replace\n                --  the saved expression because all type references must be\n                --  substituted for the call to Preanalyze_Spec_Expression in\n                --  Check_Aspect_At_xxx routines.\n \n-               if Present (Asp) then\n-                  Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n+               if Present (Prag_Asp) then\n+                  Set_Entity (Identifier (Prag_Asp), New_Copy_Tree (Expr));\n                end if;\n \n                --  Analyze the original invariant expression for ASIS\n@@ -2582,43 +2642,17 @@ package body Exp_Util is\n                   ASIS_Expr := Empty;\n \n                   if Comes_From_Source (Prag) then\n-                     ASIS_Expr := Arg2;\n-                  elsif Present (Asp) then\n-                     ASIS_Expr := Expression (Asp);\n+                     ASIS_Expr := Prag_Expr;\n+                  elsif Present (Prag_Asp) then\n+                     ASIS_Expr := Expression (Prag_Asp);\n                   end if;\n \n                   if Present (ASIS_Expr) then\n-                     Replace_Type_References\n-                       (Expr     => ASIS_Expr,\n-                        Typ      => T,\n-                        Obj_Id   => Obj_Id,\n-                        Dispatch => Class_Present (Prag));\n-\n+                     Replace_Type_References (ASIS_Expr, T, Obj_Id);\n                      Preanalyze_Assert_Expression (ASIS_Expr, Any_Boolean);\n                   end if;\n                end if;\n \n-               --  A class-wide invariant may be inherited in a separate unit,\n-               --  where the corresponding expression cannot be resolved by\n-               --  visibility, because it refers to a local function. Propagate\n-               --  semantic information to the original representation item, to\n-               --  be used when an invariant procedure for a derived type is\n-               --  constructed.\n-\n-               --  ??? Unclear how to handle class-wide invariants that are not\n-               --  function calls.\n-\n-               if Class_Present (Prag)\n-                 and then Nkind (Expr) = N_Function_Call\n-                 and then Nkind (Arg2) = N_Indexed_Component\n-               then\n-                  Rewrite (Arg2,\n-                    Make_Function_Call (Ploc,\n-                      Name                   =>\n-                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n-                      Parameter_Associations => Expressions (Arg2)));\n-               end if;\n-\n                Add_Invariant_Check (Prag, Expr, Checks);\n             end if;\n \n@@ -2863,25 +2897,25 @@ package body Exp_Util is\n       Proc_Id      : Entity_Id;\n       Stmts        : List_Id := No_List;\n \n-      CRec_Typ : Entity_Id;\n+      CRec_Typ : Entity_Id := Empty;\n       --  The corresponding record type of Full_Typ\n \n-      Full_Proc : Entity_Id;\n+      Full_Proc : Entity_Id := Empty;\n       --  The entity of the \"full\" invariant procedure\n \n-      Full_Typ : Entity_Id;\n+      Full_Typ : Entity_Id := Empty;\n       --  The full view of the working type\n \n-      Obj_Id : Entity_Id;\n+      Obj_Id : Entity_Id := Empty;\n       --  The _object formal parameter of the invariant procedure\n \n-      Part_Proc : Entity_Id;\n+      Part_Proc : Entity_Id := Empty;\n       --  The entity of the \"partial\" invariant procedure\n \n-      Priv_Typ : Entity_Id;\n+      Priv_Typ : Entity_Id := Empty;\n       --  The partial view of the working type\n \n-      Work_Typ : Entity_Id;\n+      Work_Typ : Entity_Id := Empty;\n       --  The working type\n \n    --  Start of processing for Build_Invariant_Procedure_Body\n@@ -2917,16 +2951,17 @@ package body Exp_Util is\n \n       pragma Assert (Has_Invariants (Work_Typ));\n \n-      --  Nothing to do for interface types as their class-wide invariants are\n-      --  inherited by implementing types.\n+      --  Interfaces are treated as the partial view of a private type in order\n+      --  to achieve uniformity with the general case.\n \n       if Is_Interface (Work_Typ) then\n-         goto Leave;\n-      end if;\n+         Priv_Typ := Work_Typ;\n \n-      --  Obtain both views of the type\n+      --  Otherwise obtain both views of the type\n \n-      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy, CRec_Typ);\n+      else\n+         Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy, CRec_Typ);\n+      end if;\n \n       --  The caller requests a body for the partial invariant procedure\n \n@@ -2990,10 +3025,10 @@ package body Exp_Util is\n          goto Leave;\n       end if;\n \n-      --  Emulate the environment of the invariant procedure by installing\n-      --  its scope and formal parameters. Note that this is not needed, but\n-      --  having the scope of the invariant procedure installed helps with\n-      --  the detection of invariant-related errors.\n+      --  Emulate the environment of the invariant procedure by installing its\n+      --  scope and formal parameters. Note that this is not needed, but having\n+      --  the scope installed helps with the detection of invariant-related\n+      --  errors.\n \n       Push_Scope (Proc_Id);\n       Install_Formals (Proc_Id);\n@@ -3084,17 +3119,6 @@ package body Exp_Util is\n             end if;\n          end if;\n \n-         --  Process the elements of an array type\n-\n-         if Is_Array_Type (Full_Typ) then\n-            Add_Array_Component_Invariants (Full_Typ, Obj_Id, Stmts);\n-\n-         --  Process the components of a record type\n-\n-         elsif Ekind (Full_Typ) = E_Record_Type then\n-            Add_Record_Component_Invariants (Full_Typ, Obj_Id, Stmts);\n-         end if;\n-\n          --  Process the invariants of the full view and in certain cases those\n          --  of the partial view. This also handles any invariants on array or\n          --  record components.\n@@ -3111,7 +3135,19 @@ package body Exp_Util is\n             Checks    => Stmts,\n             Priv_Item => Priv_Item);\n \n-         if Present (CRec_Typ) then\n+         --  Process the elements of an array type\n+\n+         if Is_Array_Type (Full_Typ) then\n+            Add_Array_Component_Invariants (Full_Typ, Obj_Id, Stmts);\n+\n+         --  Process the components of a record type\n+\n+         elsif Ekind (Full_Typ) = E_Record_Type then\n+            Add_Record_Component_Invariants (Full_Typ, Obj_Id, Stmts);\n+\n+         --  Process the components of a corresponding record\n+\n+         elsif Present (CRec_Typ) then\n             Add_Record_Component_Invariants (CRec_Typ, Obj_Id, Stmts);\n          end if;\n \n@@ -3144,7 +3180,7 @@ package body Exp_Util is\n       end if;\n \n       --  Generate:\n-      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>) is\n+      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Obj_Typ>) is\n       --    begin\n       --       <Stmts>\n       --    end <Work_Typ>[Partial_]Invariant;\n@@ -3226,6 +3262,9 @@ package body Exp_Util is\n       Obj_Id : Entity_Id;\n       --  The _object formal parameter of the invariant procedure\n \n+      Obj_Typ : Entity_Id;\n+      --  The type of the _object formal parameter\n+\n       Priv_Typ : Entity_Id;\n       --  The partial view of working type\n \n@@ -3263,15 +3302,9 @@ package body Exp_Util is\n \n       pragma Assert (Has_Invariants (Work_Typ));\n \n-      --  Nothing to do for interface types as their class-wide invariants are\n-      --  inherited by implementing types.\n-\n-      if Is_Interface (Work_Typ) then\n-         goto Leave;\n-\n       --  Nothing to do if the type already has a \"partial\" invariant procedure\n \n-      elsif Partial_Invariant then\n+      if Partial_Invariant then\n          if Present (Partial_Invariant_Procedure (Work_Typ)) then\n             goto Leave;\n          end if;\n@@ -3352,16 +3385,41 @@ package body Exp_Util is\n \n       Obj_Id := Make_Defining_Identifier (Loc, Chars => Name_uObject);\n \n+      --  When generating an invariant procedure declaration for an abstract\n+      --  type (including interfaces), use the class-wide type as the _object\n+      --  type. This has several desirable effects:\n+\n+      --    * The invariant procedure does not become a primitive of the type.\n+      --      This eliminates the need to either special case the treatment of\n+      --      invariant procedures, or to make it a predefined primitive and\n+      --      force every derived type to potentially provide an empty body.\n+\n+      --    * The invariant procedure does not need to be declared as abstract.\n+      --      This allows for a proper body which in turn avoids redundant\n+      --      processing of the same invariants for types with multiple views.\n+\n+      --    * The class-wide type allows for calls to abstract primitives\n+      --      within a non-abstract subprogram. The calls are treated as\n+      --      dispatching and require additional processing when they are\n+      --      remapped to call primitives of derived types. See routine\n+      --      Replace_References for details.\n+\n+      if Is_Abstract_Type (Work_Typ) then\n+         Obj_Typ := Class_Wide_Type (Work_Typ);\n+      else\n+         Obj_Typ := Work_Typ;\n+      end if;\n+\n       --  Perform minor decoration in case the declaration is not analyzed\n \n       Set_Ekind (Obj_Id, E_In_Parameter);\n-      Set_Etype (Obj_Id, Work_Typ);\n+      Set_Etype (Obj_Id, Obj_Typ);\n       Set_Scope (Obj_Id, Proc_Id);\n \n       Set_First_Entity (Proc_Id, Obj_Id);\n \n       --  Generate:\n-      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>);\n+      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Obj_Typ>);\n \n       Proc_Decl :=\n         Make_Subprogram_Declaration (Loc,\n@@ -3371,8 +3429,7 @@ package body Exp_Util is\n               Parameter_Specifications => New_List (\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier => Obj_Id,\n-                  Parameter_Type      =>\n-                    New_Occurrence_Of (Work_Typ, Loc)))));\n+                  Parameter_Type      => New_Occurrence_Of (Obj_Typ, Loc)))));\n \n       --  The declaration should not be inserted into the tree when the context\n       --  is ASIS or a generic unit because it is not part of the template.\n@@ -11448,6 +11505,37 @@ package body Exp_Util is\n       -----------------\n \n       function Replace_Ref (Ref : Node_Id) return Traverse_Result is\n+         procedure Remove_Controlling_Arguments (From_Arg : Node_Id);\n+         --  Reset the Controlling_Argument of all function calls which\n+         --  encapsulate node From_Arg.\n+\n+         ----------------------------------\n+         -- Remove_Controlling_Arguments --\n+         ----------------------------------\n+\n+         procedure Remove_Controlling_Arguments (From_Arg : Node_Id) is\n+            Par : Node_Id;\n+\n+         begin\n+            Par := From_Arg;\n+            while Present (Par) loop\n+               if Nkind (Par) = N_Function_Call\n+                 and then Present (Controlling_Argument (Par))\n+               then\n+                  Set_Controlling_Argument (Par, Empty);\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  exit;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+         end Remove_Controlling_Arguments;\n+\n+         --  Local variables\n+\n          Context : constant Node_Id    := Parent (Ref);\n          Loc     : constant Source_Ptr := Sloc (Ref);\n          Ref_Id  : Entity_Id;\n@@ -11463,6 +11551,8 @@ package body Exp_Util is\n          Val : Node_Or_Entity_Id;\n          --  The corresponding value of Ref from the type map\n \n+      --  Start of processing for Replace_Ref\n+\n       begin\n          --  Assume that the input reference is to be replaced and that the\n          --  traversal should examine the children of the reference.\n@@ -11529,7 +11619,7 @@ package body Exp_Util is\n                end if;\n \n             --  The reference mentions the _object parameter of the parent\n-            --  type's DIC procedure. Replace as follows:\n+            --  type's DIC or type invariant procedure. Replace as follows:\n \n             --    _object -> _object\n \n@@ -11539,6 +11629,23 @@ package body Exp_Util is\n             then\n                New_Ref := New_Occurrence_Of (Deriv_Obj, Loc);\n \n+               --  The type of the _object parameter is class-wide when the\n+               --  expression comes from an assertion pragma which applies to\n+               --  an abstract parent type or an interface. The class-wide type\n+               --  facilitates the preanalysis of the expression by treating\n+               --  calls to abstract primitives which mention the current\n+               --  instance of the type as dispatching. Once the calls are\n+               --  remapped to invoke overriding or inherited primitives, the\n+               --  calls no longer need to be dispatching. Examine all function\n+               --  calls which encapsule the _object parameter and reset their\n+               --  Controlling_Argument attribute.\n+\n+               if Is_Class_Wide_Type (Etype (Par_Obj))\n+                 and then Is_Abstract_Type (Root_Type (Etype (Par_Obj)))\n+               then\n+                  Remove_Controlling_Arguments (Old_Ref);\n+               end if;\n+\n                --  The reference to _object acts as an actual parameter in a\n                --  subprogram call which may be invoking a primitive of the\n                --  parent type:\n@@ -11659,10 +11766,9 @@ package body Exp_Util is\n    -----------------------------\n \n    procedure Replace_Type_References\n-     (Expr     : Node_Id;\n-      Typ      : Entity_Id;\n-      Obj_Id   : Entity_Id;\n-      Dispatch : Boolean := False)\n+     (Expr   : Node_Id;\n+      Typ    : Entity_Id;\n+      Obj_Id : Entity_Id)\n    is\n       procedure Replace_Type_Ref (N : Node_Id);\n       --  Substitute a single reference of the current instance of type Typ\n@@ -11673,9 +11779,6 @@ package body Exp_Util is\n       ----------------------\n \n       procedure Replace_Type_Ref (N : Node_Id) is\n-         Nloc : constant Source_Ptr := Sloc (N);\n-         Ref  : Node_Id;\n-\n       begin\n          --  Decorate the reference to Typ even though it may be rewritten\n          --  further down. This is done for two reasons:\n@@ -11698,33 +11801,9 @@ package body Exp_Util is\n \n          --  Perform the following substitution:\n \n-         --    Typ -> _object\n-\n-         Ref := Make_Identifier (Sloc (N), Chars (Obj_Id));\n-         Set_Entity (Ref, Obj_Id);\n-         Set_Etype  (Ref, Typ);\n-\n-         --  When the pragma denotes a class-wide and the Dispatch flag is set\n-         --  perform the following substitution. Note: dispatching in this\n-         --  fashion is illegal Ada according to AI12-0150-1 because class-wide\n-         --  aspects like type invariants and default initial conditions be\n-         --  evaluated statically. Currently it is used only for class-wide\n-         --  type invariants, but this will be fixed.\n-\n-         --    Rep_Typ  -->  Rep_Typ'Class (_object)\n-\n-         if Dispatch then\n-            Ref :=\n-              Make_Type_Conversion (Nloc,\n-                Subtype_Mark =>\n-                  Make_Attribute_Reference (Nloc,\n-                    Prefix         =>\n-                      New_Occurrence_Of (Typ, Nloc),\n-                    Attribute_Name => Name_Class),\n-                Expression   => Ref);\n-         end if;\n+         --    Typ --> _object\n \n-         Rewrite (N, Ref);\n+         Rewrite (N, New_Occurrence_Of (Obj_Id, Sloc (N)));\n          Set_Comes_From_Source (N, True);\n       end Replace_Type_Ref;\n "}, {"sha": "5b44d6929a2db04a2666b9a51d1fc2317a0e6d23", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -1062,10 +1062,9 @@ package Exp_Util is\n    --      the internally-generated inherited primitive of Deriv_Typ.\n \n    procedure Replace_Type_References\n-     (Expr     : Node_Id;\n-      Typ      : Entity_Id;\n-      Obj_Id   : Entity_Id;\n-      Dispatch : Boolean := False);\n+     (Expr   : Node_Id;\n+      Typ    : Entity_Id;\n+      Obj_Id : Entity_Id);\n    --  Substitute all references of the current instance of type Typ with\n    --  references to formal parameter Obj_Id within expression Expr.\n "}, {"sha": "f40d142ec747d827f922c0d13b203bda5670e107", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -2279,12 +2279,32 @@ package body Sem_Ch3 is\n \n             if Nkind (Context) = N_Package_Specification then\n \n+               --  Preanalyze and resolve the class-wide invariants of an\n+               --  interface at the end of whichever declarative part has the\n+               --  interface type. Note that an interface may be declared in\n+               --  any non-package declarative part, but reaching the end of\n+               --  such a declarative part will always freeze the type and\n+               --  generate the invariant procedure (see Freeze_Type).\n+\n+               if Is_Interface (Typ) then\n+\n+                  --  Interfaces are treated as the partial view of a private\n+                  --  type in order to achieve uniformity with the general\n+                  --  case. As a result, an interface receives only a \"partial\"\n+                  --  invariant procedure which is never called.\n+\n+                  if Has_Own_Invariants (Typ) then\n+                     Build_Invariant_Procedure_Body\n+                       (Typ               => Typ,\n+                        Partial_Invariant => True);\n+                  end if;\n+\n                --  Preanalyze and resolve the invariants of a private type\n                --  at the end of the visible declarations to catch potential\n                --  errors. Inherited class-wide invariants are not included\n                --  because they have already been resolved.\n \n-               if Decls = Visible_Declarations (Context)\n+               elsif Decls = Visible_Declarations (Context)\n                  and then Ekind_In (Typ, E_Limited_Private_Type,\n                                          E_Private_Type,\n                                          E_Record_Type_With_Private)\n@@ -15315,10 +15335,9 @@ package body Sem_Ch3 is\n \n       New_Overloaded_Entity (New_Subp, Derived_Type);\n \n-      --  Implement rule in 6.1.1 (15) : if subprogram inherits non-conforming\n-      --  classwide preconditions and the derived type is abstract, the\n-      --  derived operation is abstract as well if parent subprogram is not\n-      --  abstract or null.\n+      --  Ada RM 6.1.1 (15): If a subprogram inherits non-conforming class-wide\n+      --  preconditions and the derived type is abstract, the derived operation\n+      --  is abstract as well if parent subprogram is not abstract or null.\n \n       if Is_Abstract_Type (Derived_Type)\n         and then Has_Non_Trivial_Precondition (Parent_Subp)"}, {"sha": "d67beeb0b10edc463dc4f6e9a6c9b79d5ad6568b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b554177a8f33e3cfaf29125a1c22a9671fbf2c3a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b554177a8f33e3cfaf29125a1c22a9671fbf2c3a", "patch": "@@ -17113,10 +17113,14 @@ package body Sem_Prag is\n             Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n \n             --  Create the declaration of the invariant procedure which will\n-            --  verify the invariant at run-time. Note that interfaces do not\n-            --  carry such a declaration.\n-\n-            Build_Invariant_Procedure_Declaration (Typ);\n+            --  verify the invariant at run-time. Interfaces are treated as the\n+            --  partial view of a private type in order to achieve uniformity\n+            --  with the general case. As a result, an interface receives only\n+            --  a \"partial\" invariant procedure which is never called.\n+\n+            Build_Invariant_Procedure_Declaration\n+              (Typ               => Typ,\n+               Partial_Invariant => Is_Interface (Typ));\n          end Invariant;\n \n          ----------------"}]}