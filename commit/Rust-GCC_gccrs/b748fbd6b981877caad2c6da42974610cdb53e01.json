{"sha": "b748fbd6b981877caad2c6da42974610cdb53e01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0OGZiZDZiOTgxODc3Y2FhZDJjNmRhNDI5NzQ2MTBjZGI1M2UwMQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2010-05-24T12:24:00Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2010-05-24T12:24:00Z"}, "message": "gengtype-lex.l: Add HARD_REG_SET.\n\n2010-05-25  Paul Brook  <paul@codesourcery.com>\n\n\tgcc/\n\t* gengtype-lex.l: Add HARD_REG_SET.\n\t* expr.c (expand_expr_real_1): Record writes to hard registers.\n\t* function.c (rtl_data): Add asm_clobbers.\n\t* ira.c (compute_regs_asm_clobbered): Use crtl->asm_clobbers.\n\t(ira_setup_eliminable_regset): Remove regs_asm_clobbered.\n\tUse crtl->asm_clobbers.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/frame-pointer-1.c: New test.\n\t* gcc.target/i386/pr9771-1.c: Move code out of main to allow frame\n\tpointer elimination.\n\nFrom-SVN: r159776", "tree": {"sha": "a28ad2044f7bcf9c49f937d0bae49e03138a02f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a28ad2044f7bcf9c49f937d0bae49e03138a02f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b748fbd6b981877caad2c6da42974610cdb53e01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b748fbd6b981877caad2c6da42974610cdb53e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b748fbd6b981877caad2c6da42974610cdb53e01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b748fbd6b981877caad2c6da42974610cdb53e01/comments", "author": null, "committer": null, "parents": [{"sha": "9888e9cf854267265d6c59e3b01d15fe5cef5a35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9888e9cf854267265d6c59e3b01d15fe5cef5a35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9888e9cf854267265d6c59e3b01d15fe5cef5a35"}], "stats": {"total": 113, "additions": 96, "deletions": 17}, "files": [{"sha": "80c8ff63b7347c397644c89738fe388f26b1d88e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -1,3 +1,12 @@\n+2010-05-24  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gengtype-lex.l: Add HARD_REG_SET.\n+\t* expr.c (expand_expr_real_1): Record writes to hard registers.\n+\t* function.c (rtl_data): Add asm_clobbers.\n+\t* ira.c (compute_regs_asm_clobbered): Use crtl->asm_clobbers.\n+\t(ira_setup_eliminable_regset): Remove regs_asm_clobbered.\n+\tUse crtl->asm_clobbers.\n+\n 2010-05-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* doc/makefile.texi (Makefile): Mention stages 'profile'"}, {"sha": "82c037172095dc5b71ef9b409ceb0f44854fb412", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -8423,6 +8423,19 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     expand_decl_rtl:\n       gcc_assert (decl_rtl);\n       decl_rtl = copy_rtx (decl_rtl);\n+      /* Record writes to register variables.  */\n+      if (modifier == EXPAND_WRITE && REG_P (decl_rtl)\n+\t  && REGNO (decl_rtl) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t    int i = REGNO (decl_rtl);\n+\t    int nregs = hard_regno_nregs[i][GET_MODE (decl_rtl)];\n+\t    while (nregs)\n+\t      {\n+\t\tSET_HARD_REG_BIT (crtl->asm_clobbers, i);\n+\t\ti++;\n+\t\tnregs--;\n+\t      }\n+\t}\n \n       /* Ensure variable marked as used even if it doesn't go through\n \t a parser.  If it hasn't be used yet, write out an external"}, {"sha": "072da5805508c679fc8abcfaf2f7ec643a06bbf0", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"vecprim.h\"\n #include \"tm.h\"\t\t/* For CUMULATIVE_ARGS.  */\n+#include \"hard-reg-set.h\"\n \n /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n    Each element describes one pending sequence.\n@@ -437,6 +438,12 @@ struct GTY(()) rtl_data {\n      TREE_NOTHROW (current_function_decl) it is set even for overwritable\n      function where currently compiled version of it is nothrow.  */\n   bool nothrow;\n+\n+  /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n+     asm.  Unlike regs_ever_live, elements of this array corresponding\n+     to eliminable regs (like the frame pointer) are set if an asm\n+     sets them.  */\n+  HARD_REG_SET asm_clobbers;\n };\n \n #define return_label (crtl->x_return_label)"}, {"sha": "8159ef860f2940c68f299cb16f4db81257740b50", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -49,7 +49,7 @@ update_lineno (const char *l, size_t len)\n ID\t[[:alpha:]_][[:alnum:]_]*\n WS\t[[:space:]]+\n HWS\t[ \\t\\r\\v\\f]*\n-IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t\n+IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t|HARD_REG_SET\n ITYPE\t{IWORD}({WS}{IWORD})*\n EOID\t[^[:alnum:]_]\n "}, {"sha": "10be6da40543b6bb343e131739728a33778f2e56", "filename": "gcc/ira.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -1397,14 +1397,12 @@ insn_contains_asm (rtx insn)\n   return for_each_rtx (&insn, insn_contains_asm_1, NULL);\n }\n \n-/* Set up regs_asm_clobbered.  */\n+/* Add register clobbers from asm statements.  */\n static void\n-compute_regs_asm_clobbered (char *regs_asm_clobbered)\n+compute_regs_asm_clobbered (void)\n {\n   basic_block bb;\n \n-  memset (regs_asm_clobbered, 0, sizeof (char) * FIRST_PSEUDO_REGISTER);\n-\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n@@ -1425,7 +1423,7 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n \t\t      + hard_regno_nregs[dregno][mode] - 1;\n \n \t\t    for (i = dregno; i <= end; ++i)\n-\t\t      regs_asm_clobbered[i] = 1;\n+\t\t      SET_HARD_REG_BIT(crtl->asm_clobbers, i);\n \t\t  }\n \t      }\n \t}\n@@ -1437,12 +1435,6 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n void\n ira_setup_eliminable_regset (void)\n {\n-  /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n-     asm.  Unlike regs_ever_live, elements of this array corresponding\n-     to eliminable regs (like the frame pointer) are set if an asm\n-     sets them.  */\n-  char *regs_asm_clobbered\n-    = (char *) alloca (FIRST_PSEUDO_REGISTER * sizeof (char));\n #ifdef ELIMINABLE_REGS\n   int i;\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n@@ -1466,7 +1458,8 @@ ira_setup_eliminable_regset (void)\n   COPY_HARD_REG_SET (ira_no_alloc_regs, no_unit_alloc_regs);\n   CLEAR_HARD_REG_SET (eliminable_regset);\n \n-  compute_regs_asm_clobbered (regs_asm_clobbered);\n+  compute_regs_asm_clobbered ();\n+\n   /* Build the regset of all eliminable registers and show we can't\n      use those that we already know won't be eliminated.  */\n #ifdef ELIMINABLE_REGS\n@@ -1476,7 +1469,7 @@ ira_setup_eliminable_regset (void)\n \t= (! targetm.can_eliminate (eliminables[i].from, eliminables[i].to)\n \t   || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp));\n \n-      if (! regs_asm_clobbered[eliminables[i].from])\n+      if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, eliminables[i].from))\n \t{\n \t    SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);\n \n@@ -1490,7 +1483,7 @@ ira_setup_eliminable_regset (void)\n \tdf_set_regs_ever_live (eliminables[i].from, true);\n     }\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-  if (! regs_asm_clobbered[HARD_FRAME_POINTER_REGNUM])\n+  if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, HARD_FRAME_POINTER_REGNUM))\n     {\n       SET_HARD_REG_BIT (eliminable_regset, HARD_FRAME_POINTER_REGNUM);\n       if (need_fp)\n@@ -1504,7 +1497,7 @@ ira_setup_eliminable_regset (void)\n #endif\n \n #else\n-  if (! regs_asm_clobbered[FRAME_POINTER_REGNUM])\n+  if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, HARD_FRAME_POINTER_REGNUM))\n     {\n       SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);\n       if (need_fp)"}, {"sha": "a0b34c9454d7abfb97b8b92bf947925bf595b6ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -1,3 +1,9 @@\n+2010-05-24  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gcc.target/arm/frame-pointer-1.c: New test.\n+\t* gcc.target/i386/pr9771-1.c: Move code out of main to allow frame\n+\tpointer elimination.\n+\n 2010-05-23  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/44245"}, {"sha": "bb1888e389efedaa774fc9dc1c1986dec6143619", "filename": "gcc/testsuite/gcc.target/arm/frame-pointer-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fframe-pointer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fframe-pointer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fframe-pointer-1.c?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -0,0 +1,42 @@\n+/* Check local register variables using a register conventionally \n+   used as the frame pointer aren't clobbered under high register pressure.  */\n+/* { dg-do run } */\n+/* { dg-options \"-Os -mthumb -fomit-frame-pointer\" } */\n+\n+#include <stdlib.h>\n+\n+int global=5;\n+\n+void __attribute__((noinline)) foo(int p1, int p2, int p3, int p4)\n+{\n+  if (global != 5 || p1 != 1 || p2 != 2 || p3 != 3 || p4 != 4)\n+    abort();\n+}\n+\n+int __attribute__((noinline)) test(int a, int b, int c, int d)\n+{\n+  register unsigned long r __asm__(\"r7\") = 0xdeadbeef;\n+  int e;\n+\n+  /* ABCD are live after the call which should be enough\n+     to cause r7 to be used if it weren't for the register variable.  */\n+  foo(a,b,c,d);\n+\n+  e = 0;\n+  __asm__ __volatile__ (\"mov %0, %2\"\n+\t\t\t: \"=r\" (e)\n+\t\t\t: \"0\" (e), \"r\" (r));\n+\n+  global = a+b+c+d;\n+\n+  return e;\n+}\n+\n+int main()\n+{\n+  if (test(1, 2, 3, 4) != 0xdeadbeef)\n+    abort();\n+  if (global != 10)\n+    abort();\n+  return 0;\n+}"}, {"sha": "37ec4902201832aab67671192e4c15b54d045067", "filename": "gcc/testsuite/gcc.target/i386/pr9771-1.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr9771-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748fbd6b981877caad2c6da42974610cdb53e01/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr9771-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr9771-1.c?ref=b748fbd6b981877caad2c6da42974610cdb53e01", "patch": "@@ -28,7 +28,10 @@ void foo()\n   *adr = save;\n }\n \n-int main()\n+/* This must not be inlined becuase main() requires the frame pointer\n+   for stack alignment.  */\n+void test(void) __attribute__((noinline));\n+void test(void)\n {\n   B = &x;\n \n@@ -42,3 +45,9 @@ int main()\n   exit(0);\n }\n \n+int main()\n+{\n+  test();\n+  return 0;\n+\n+}"}]}