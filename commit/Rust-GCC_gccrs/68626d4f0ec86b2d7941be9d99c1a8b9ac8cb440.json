{"sha": "68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2MjZkNGYwZWM4NmIyZDc5NDFiZTlkOTljMWE4YjlhYzhjYjQ0MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-02-18T06:53:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-18T06:53:19Z"}, "message": "fold-const.c (fold_binary_op_with_conditional_arg): New function, split out from ...\n\n\t* fold-const.c (fold_binary_op_with_conditional_arg): New\n\tfunction, split out from ...\n\t(fold): ... here.\n\t* tree.def (COND_EXPR): Document the use of VOID_TYPE for\n\tconditional arms that throw exceptions.\n\nFrom-SVN: r39822", "tree": {"sha": "c25457418d139939fd0b964498eca1ff819ec8c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c25457418d139939fd0b964498eca1ff819ec8c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/comments", "author": null, "committer": null, "parents": [{"sha": "9c2c54dc94decb809d9c4c746ca0669b0a59696a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c2c54dc94decb809d9c4c746ca0669b0a59696a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c2c54dc94decb809d9c4c746ca0669b0a59696a"}], "stats": {"total": 276, "additions": 160, "deletions": 116}, "files": [{"sha": "8b52a3d4259f458621ad2ede016d7bca685ec0d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "patch": "@@ -1,5 +1,11 @@\n 2001-02-17  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* fold-const.c (fold_binary_op_with_conditional_arg): New\n+\tfunction, split out from ...\n+\t(fold): ... here.\n+\t* tree.def (COND_EXPR): Document the use of VOID_TYPE for\n+\tconditional arms that throw exceptions.\n+\n \t* print-tree.c (print_node): Do not use BLOCK_CHAIN when we're not\n \tlooking at a BLOCK.\n "}, {"sha": "1793f5556802d94388da04a9626c8e5bf4caa05a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 138, "deletions": 114, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "patch": "@@ -101,7 +101,9 @@ static tree strip_compound_expr PARAMS ((tree, tree));\n static int multiple_of_p\tPARAMS ((tree, tree, tree));\n static tree constant_boolean_node PARAMS ((int, tree));\n static int count_cond\t\tPARAMS ((tree, int));\n-\n+static tree fold_binary_op_with_conditional_arg \n+  PARAMS ((enum tree_code, tree, tree, tree, int));\n+\t\t\t\t\t\t\t \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n #endif\n@@ -4698,6 +4700,135 @@ count_cond (expr, lim)\n   false = count_cond (TREE_OPERAND (expr, 2), lim - 1 - true);\n   return MIN (lim, 1 + true + false);\n }\n+\n+/* Transform `a + (b ? x : y)' into `x ? (a + b) : (a + y)'.\n+   Transform, `a + (x < y)' into `(x < y) ? (a + 1) : (a + 0)'.  Here\n+   CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x < y)'\n+   expression, and ARG to `a'.  If COND_FIRST_P is non-zero, then the\n+   COND is the first argument to CODE; otherwise (as in the example\n+   given here), it is the second argument.  TYPE is the type of the\n+   original expression.  */\n+\n+static tree\n+fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n+     enum tree_code code;\n+     tree type;\n+     tree cond;\n+     tree arg;\n+     int cond_first_p;\n+{\n+  tree test, true_value, false_value;\n+  tree lhs = NULL_TREE;\n+  tree rhs = NULL_TREE;\n+  /* In the end, we'll produce a COND_EXPR.  Both arms of the\n+     conditional expression will be binary operations.  The left-hand\n+     side of the expression to be executed if the condition is true\n+     will be pointed to by TRUE_LHS.  Similarly, the right-hand side\n+     of the expression to be executed if the condition is true will be\n+     pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analagous --\n+     but apply to the expression to be executed if the conditional is\n+     false.  */\n+  tree *true_lhs;\n+  tree *true_rhs;\n+  tree *false_lhs;\n+  tree *false_rhs;\n+  /* These are the codes to use for the left-hand side and right-hand\n+     side of the COND_EXPR.  Normally, they are the same as CODE.  */\n+  enum tree_code lhs_code = code;\n+  enum tree_code rhs_code = code;\n+  /* And these are the types of the expressions.  */\n+  tree lhs_type = type;\n+  tree rhs_type = type;\n+\n+  if (cond_first_p)\n+    {\n+      true_rhs = false_rhs = &arg;\n+      true_lhs = &true_value;\n+      false_lhs = &false_value;\n+    }\n+  else\n+    {\n+      true_lhs = false_lhs = &arg;\n+      true_rhs = &true_value;\n+      false_rhs = &false_value;\n+    }\n+\n+  if (TREE_CODE (cond) == COND_EXPR)\n+    {\n+      test = TREE_OPERAND (cond, 0);\n+      true_value = TREE_OPERAND (cond, 1);\n+      false_value = TREE_OPERAND (cond, 2);\n+      /* If this operand throws an expression, then it does not make\n+\t sense to try to perform a logical or arithmetic operation\n+\t involving it.  Instead of building `a + throw 3' for example,\n+\t we simply build `a, throw 3'.  */\n+      if (VOID_TYPE_P (TREE_TYPE (true_value)))\n+\t{\n+\t  lhs_code = COMPOUND_EXPR;\n+\t  if (!cond_first_p)\n+\t    lhs_type = void_type_node;\n+\t}\n+      if (VOID_TYPE_P (TREE_TYPE (false_value)))\n+\t{\n+\t  rhs_code = COMPOUND_EXPR;\n+\t  if (!cond_first_p)\n+\t    rhs_type = void_type_node;\n+\t}\n+    }\n+  else\n+    {\n+      tree testtype = TREE_TYPE (cond);\n+      test = cond;\n+      true_value = convert (testtype, integer_one_node);\n+      false_value = convert (testtype, integer_zero_node);\n+    }\n+  \n+  /* If ARG is complex we want to make sure we only evaluate\n+     it once.  Though this is only required if it is volatile, it\n+     might be more efficient even if it is not.  However, if we\n+     succeed in folding one part to a constant, we do not need\n+     to make this SAVE_EXPR.  Since we do this optimization\n+     primarily to see if we do end up with constant and this\n+     SAVE_EXPR interferes with later optimizations, suppressing\n+     it when we can is important.\n+     \n+     If we are not in a function, we can't make a SAVE_EXPR, so don't\n+     try to do so.  Don't try to see if the result is a constant\n+     if an arm is a COND_EXPR since we get exponential behavior\n+     in that case.  */\n+  \n+  if (TREE_CODE (arg) != SAVE_EXPR && ! TREE_CONSTANT (arg)\n+      && global_bindings_p () == 0\n+      && ((TREE_CODE (arg) != VAR_DECL\n+\t   && TREE_CODE (arg) != PARM_DECL)\n+\t  || TREE_SIDE_EFFECTS (arg)))\n+    {\n+      if (TREE_CODE (true_value) != COND_EXPR)\n+\tlhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));\n+      \n+      if (TREE_CODE (false_value) != COND_EXPR)\n+\trhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));\n+      \n+      if ((lhs == 0 || ! TREE_CONSTANT (lhs))\n+\t  && (rhs == 0 || !TREE_CONSTANT (rhs)))\n+\targ = save_expr (arg), lhs = rhs = 0;\n+    }\n+  \n+  if (lhs == 0)\n+    lhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));\n+  if (rhs == 0)\n+    rhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));\n+  \n+  test = fold (build (COND_EXPR, type, test, lhs, rhs));\n+  \n+  if (TREE_CODE (arg) == SAVE_EXPR)\n+    return build (COMPOUND_EXPR, type,\n+\t\t  convert (void_type_node, arg),\n+\t\t  strip_compound_expr (test, arg));\n+  else\n+    return convert (type, test);\n+}\n+\n \f\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n@@ -4919,70 +5050,9 @@ fold (expr)\n \t       && (! TREE_SIDE_EFFECTS (arg0)\n \t\t   || (global_bindings_p () == 0\n \t\t       && ! contains_placeholder_p (arg0))))\n-\t{\n-\t  tree test, true_value, false_value;\n-\t  tree lhs = 0, rhs = 0;\n-\n-\t  if (TREE_CODE (arg1) == COND_EXPR)\n-\t    {\n-\t      test = TREE_OPERAND (arg1, 0);\n-\t      true_value = TREE_OPERAND (arg1, 1);\n-\t      false_value = TREE_OPERAND (arg1, 2);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree testtype = TREE_TYPE (arg1);\n-\t      test = arg1;\n-\t      true_value = convert (testtype, integer_one_node);\n-\t      false_value = convert (testtype, integer_zero_node);\n-\t    }\n-\n-\t  /* If ARG0 is complex we want to make sure we only evaluate\n-\t     it once.  Though this is only required if it is volatile, it\n-\t     might be more efficient even if it is not.  However, if we\n-\t     succeed in folding one part to a constant, we do not need\n-\t     to make this SAVE_EXPR.  Since we do this optimization\n-\t     primarily to see if we do end up with constant and this\n-\t     SAVE_EXPR interferes with later optimizations, suppressing\n-\t     it when we can is important.\n-\n-\t     If we are not in a function, we can't make a SAVE_EXPR, so don't\n-\t     try to do so.  Don't try to see if the result is a constant\n-\t     if an arm is a COND_EXPR since we get exponential behavior\n-\t     in that case.  */\n-\n-\t  if (TREE_CODE (arg0) != SAVE_EXPR && ! TREE_CONSTANT (arg0)\n-\t      && global_bindings_p () == 0\n-\t      && ((TREE_CODE (arg0) != VAR_DECL\n-\t\t   && TREE_CODE (arg0) != PARM_DECL)\n-\t\t  || TREE_SIDE_EFFECTS (arg0)))\n-\t    {\n-\t      if (TREE_CODE (true_value) != COND_EXPR)\n-\t\tlhs = fold (build (code, type, arg0, true_value));\n-\n-\t      if (TREE_CODE (false_value) != COND_EXPR)\n-\t\trhs = fold (build (code, type, arg0, false_value));\n-\n-\t      if ((lhs == 0 || ! TREE_CONSTANT (lhs))\n-\t\t  && (rhs == 0 || !TREE_CONSTANT (rhs)))\n-\t\targ0 = save_expr (arg0), lhs = rhs = 0;\n-\t    }\n-\n-\t  if (lhs == 0)\n-\t    lhs = fold (build (code, type, arg0, true_value));\n-\t  if (rhs == 0)\n-\t    rhs = fold (build (code, type, arg0, false_value));\n-\n-\t  test = fold (build (COND_EXPR, type, test, lhs, rhs));\n-\n-\t  if (TREE_CODE (arg0) == SAVE_EXPR)\n-\t    return build (COMPOUND_EXPR, type,\n-\t\t\t  convert (void_type_node, arg0),\n-\t\t\t  strip_compound_expr (test, arg0));\n-\t  else\n-\t    return convert (type, test);\n-\t}\n-\n+\treturn \n+\t  fold_binary_op_with_conditional_arg (code, type, arg1, arg0,\n+\t\t\t\t\t       /*cond_first_p=*/0);\n       else if (TREE_CODE (arg0) == COMPOUND_EXPR)\n \treturn build (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n \t\t      fold (build (code, type, TREE_OPERAND (arg0, 1), arg1)));\n@@ -4994,55 +5064,9 @@ fold (expr)\n \t       && (! TREE_SIDE_EFFECTS (arg1)\n \t\t   || (global_bindings_p () == 0\n \t\t       && ! contains_placeholder_p (arg1))))\n-\t{\n-\t  tree test, true_value, false_value;\n-\t  tree lhs = 0, rhs = 0;\n-\n-\t  if (TREE_CODE (arg0) == COND_EXPR)\n-\t    {\n-\t      test = TREE_OPERAND (arg0, 0);\n-\t      true_value = TREE_OPERAND (arg0, 1);\n-\t      false_value = TREE_OPERAND (arg0, 2);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree testtype = TREE_TYPE (arg0);\n-\t      test = arg0;\n-\t      true_value = convert (testtype, integer_one_node);\n-\t      false_value = convert (testtype, integer_zero_node);\n-\t    }\n-\n-\t  if (TREE_CODE (arg1) != SAVE_EXPR && ! TREE_CONSTANT (arg0)\n-\t      && global_bindings_p () == 0\n-\t      && ((TREE_CODE (arg1) != VAR_DECL\n-\t\t   && TREE_CODE (arg1) != PARM_DECL)\n-\t\t  || TREE_SIDE_EFFECTS (arg1)))\n-\t    {\n-\t      if (TREE_CODE (true_value) != COND_EXPR)\n-\t\tlhs = fold (build (code, type, true_value, arg1));\n-\n-\t      if (TREE_CODE (false_value) != COND_EXPR)\n-\t\trhs = fold (build (code, type, false_value, arg1));\n-\n-\t      if ((lhs == 0 || ! TREE_CONSTANT (lhs))\n-\t\t  && (rhs == 0 || !TREE_CONSTANT (rhs)))\n-\t\targ1 = save_expr (arg1), lhs = rhs = 0;\n-\t    }\n-\n-\t  if (lhs == 0)\n-\t    lhs = fold (build (code, type, true_value, arg1));\n-\n-\t  if (rhs == 0)\n-\t    rhs = fold (build (code, type, false_value, arg1));\n-\n-\t  test = fold (build (COND_EXPR, type, test, lhs, rhs));\n-\t  if (TREE_CODE (arg1) == SAVE_EXPR)\n-\t    return build (COMPOUND_EXPR, type,\n-\t\t\t  convert (void_type_node, arg1),\n-\t\t\t  strip_compound_expr (test, arg1));\n-\t  else\n-\t    return convert (type, test);\n-\t}\n+\treturn \n+\t  fold_binary_op_with_conditional_arg (code, type, arg0, arg1,\n+\t\t\t\t\t       /*cond_first_p=*/1);\n     }\n   else if (TREE_CODE_CLASS (code) == '<'\n \t   && TREE_CODE (arg0) == COMPOUND_EXPR)"}, {"sha": "ef476bf1d3f578c27f0312aeb2b1f948e781012e", "filename": "gcc/testsuite/g++.old-deja/g++.eh/crash5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcrash5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcrash5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcrash5.C?ref=68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int i;\n+int j;\n+\n+void\n+f ()\n+{\n+  j = j + (i ? 7 : throw 1);\n+}\n+ "}, {"sha": "4ccd6e38944597f73f57eb2d3ecdf6f6de14b54d", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=68626d4f0ec86b2d7941be9d99c1a8b9ac8cb440", "patch": "@@ -425,8 +425,10 @@ DEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n    Operand 0 is the condition.\n    Operand 1 is the then-value.\n    Operand 2 is the else-value.\n-   Operand 0 may be of any type, but the types of operands 1 and 2\n-   must be the same and the same as the type of this expression.  */\n+   Operand 0 may be of any type.\n+   Operand 1 must have the same type as the entire expression, unless\n+   it unconditionally throws an exception, in which case it should\n+   have VOID_TYPE.  The same constraints apply to operand 2.  */\n DEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n \n /* Declare local variables, including making RTL and allocating space."}]}