{"sha": "9696c52909efcdb631f5fd7e8a8261656a25cc1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY5NmM1MjkwOWVmY2RiNjMxZjVmZDdlOGE4MjYxNjU2YTI1Y2MxYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-23T09:24:21Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-23T09:24:21Z"}, "message": "opts.c (common_handle_option): Do not set flag_value_profile_transformations for -fprofile-generate.\n\n\t* opts.c (common_handle_option): Do not set \n\tflag_value_profile_transformations for -fprofile-generate.\n\t* profile.c (instrument_values): Use COUNTER_FOR_HIST_TYPE.\n\t(BB_TO_GCOV_INDEX): Remove.\n\t(output_location): Don't use it.\n\t(branch_prob): Likewise.  Don't fiddle with the index of\n\tENTRY_BLOCK_PTR and EXIT_BLOCK_PTR.  Use clear_aux_for_blocks.\n\t(find_spanning_tree):\n\t* gcov.c (struct function_info): Document that blocks 0 and 1\n\tare the entry resp. exit blocks in gcov, too, like in GCC itself.\n\t(solve_flow_graph): Use ENTRY_BLOCK and EXIT_BLOCK for special\n\tblocks identification.\n\t(output_lines): Likewise.\n\t* value-prof.c (gimple_value_profile_transformations): Do not\n\ttest flag_value_profile_transformations again.\n\t(gimple_ic_transform): Take a gimple_stmt_iterator like all other\n\ttransformation functions.\n\t(gimple_values_to_profile):\n\tDon't test flag_value_profile_transformations\n\t* tree-profile.c (tree_profiling): Assert that the cgraph is in\n\tthe CGRAPH_STATE_IPA_SSA state.\n\tDo not set, or look at, after_tree_profile.\n\t* function.h (struct function): Remove after_tree_profile bit.\n\t* omp-low.c (expand_omp_taskreg): Don't set after_tree_profile.\n\t* tree-inline.c (initialize_cfun): Don't copy it.\n\t* lto-streamer-out.c (output_struct_function_base): Don't stream it.\n\t* lto-streamer-in.c (input_struct_function_base): Likewise.\n\nFrom-SVN: r189778", "tree": {"sha": "5452a2b7de063eb5483f6c69af68f3b173a2adc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5452a2b7de063eb5483f6c69af68f3b173a2adc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9696c52909efcdb631f5fd7e8a8261656a25cc1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9696c52909efcdb631f5fd7e8a8261656a25cc1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9696c52909efcdb631f5fd7e8a8261656a25cc1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9696c52909efcdb631f5fd7e8a8261656a25cc1b/comments", "author": null, "committer": null, "parents": [{"sha": "678400b3589e37edc90647ce3744347301effbed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/678400b3589e37edc90647ce3744347301effbed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/678400b3589e37edc90647ce3744347301effbed"}], "stats": {"total": 279, "additions": 147, "deletions": 132}, "files": [{"sha": "68800a6640068927f89a720f475f1c3acb9c77d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -1,3 +1,33 @@\n+2012-07-22  Steven Bosscher <steven@gcc.gnu.org>\n+\n+\t* opts.c (common_handle_option): Do not set \n+\tflag_value_profile_transformations for -fprofile-generate.\n+\t* profile.c (instrument_values): Use COUNTER_FOR_HIST_TYPE.\n+\t(BB_TO_GCOV_INDEX): Remove.\n+\t(output_location): Don't use it.\n+\t(branch_prob): Likewise.  Don't fiddle with the index of\n+\tENTRY_BLOCK_PTR and EXIT_BLOCK_PTR.  Use clear_aux_for_blocks.\n+\t(find_spanning_tree):\n+\t* gcov.c (struct function_info): Document that blocks 0 and 1\n+\tare the entry resp. exit blocks in gcov, too, like in GCC itself.\n+\t(solve_flow_graph): Use ENTRY_BLOCK and EXIT_BLOCK for special\n+\tblocks identification.\n+\t(output_lines): Likewise.\n+\t* value-prof.c (gimple_value_profile_transformations): Do not\n+\ttest flag_value_profile_transformations again.\n+\t(gimple_ic_transform): Take a gimple_stmt_iterator like all other\n+\ttransformation functions.\n+\t(gimple_values_to_profile):\n+\tDon't test flag_value_profile_transformations\n+\t* tree-profile.c (tree_profiling): Assert that the cgraph is in\n+\tthe CGRAPH_STATE_IPA_SSA state.\n+\tDo not set, or look at, after_tree_profile.\n+\t* function.h (struct function): Remove after_tree_profile bit.\n+\t* omp-low.c (expand_omp_taskreg): Don't set after_tree_profile.\n+\t* tree-inline.c (initialize_cfun): Don't copy it.\n+\t* lto-streamer-out.c (output_struct_function_base): Don't stream it.\n+\t* lto-streamer-in.c (input_struct_function_base): Likewise.\n+\n 2012-07-22  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.h (TARGET_DYNSHIFT): New macro."}, {"sha": "3d3313fc9b3286d8b6e14f5b0bd9bb850bff0150", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -645,9 +645,6 @@ struct GTY(()) function {\n      return the address of where it has put a structure value.  */\n   unsigned int returns_pcc_struct : 1;\n \n-  /* Nonzero if pass_tree_profile was run on this function.  */\n-  unsigned int after_tree_profile : 1;\n-\n   /* Nonzero if this function has local DECL_HARD_REGISTER variables.\n      In this case code motion has to be done more carefully.  */\n   unsigned int has_local_explicit_reg_vars : 1;"}, {"sha": "318ce6046baefaea0e7f6ead5d6213e19a21da2f", "filename": "gcc/gcov.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -57,10 +57,10 @@ along with Gcov; see the file COPYING3.  If not see\n \n /* The code validates that the profile information read in corresponds\n    to the code currently being compiled.  Rather than checking for\n-   identical files, the code below computes a checksum on the CFG\n+   identical files, the code below compares a checksum on the CFG\n    (based on the order of basic blocks and the arcs in the CFG).  If\n-   the CFG checksum in the gcda file match the CFG checksum for the\n-   code currently being compiled, the profile data will be used.  */\n+   the CFG checksum in the gcda file match the CFG checksum in the\n+   gcno file, the profile data will be used.  */\n \n /* This is the size of the buffer used to read in source file lines.  */\n \n@@ -177,7 +177,10 @@ typedef struct function_info\n   /* The graph contains at least one fake incoming edge.  */\n   unsigned has_catch : 1;\n \n-  /* Array of basic blocks.  */\n+  /* Array of basic blocks.  Like in GCC, the entry block is\n+     at blocks[0] and the exit block is at blocks[1].  */\n+#define ENTRY_BLOCK (0)\n+#define EXIT_BLOCK (1)\n   block_t *blocks;\n   unsigned num_blocks;\n   unsigned blocks_executed;\n@@ -1363,21 +1366,21 @@ solve_flow_graph (function_t *fn)\n \t     bbg_file_name, fn->name);\n   else\n     {\n-      if (fn->blocks[0].num_pred)\n+      if (fn->blocks[ENTRY_BLOCK].num_pred)\n \tfnotice (stderr, \"%s:'%s' has arcs to entry block\\n\",\n \t\t bbg_file_name, fn->name);\n       else\n \t/* We can't deduce the entry block counts from the lack of\n \t   predecessors.  */\n-\tfn->blocks[0].num_pred = ~(unsigned)0;\n+\tfn->blocks[ENTRY_BLOCK].num_pred = ~(unsigned)0;\n \n-      if (fn->blocks[fn->num_blocks - 1].num_succ)\n+      if (fn->blocks[EXIT_BLOCK].num_succ)\n \tfnotice (stderr, \"%s:'%s' has arcs from exit block\\n\",\n \t\t bbg_file_name, fn->name);\n       else\n \t/* Likewise, we can't deduce exit block counts from the lack\n \t   of its successors.  */\n-\tfn->blocks[fn->num_blocks - 1].num_succ = ~(unsigned)0;\n+\tfn->blocks[EXIT_BLOCK].num_succ = ~(unsigned)0;\n     }\n \n   /* Propagate the measured counts, this must be done in the same\n@@ -1637,7 +1640,7 @@ add_branch_counts (coverage_t *coverage, const arc_t *arc)\n     }\n }\n \n-/* Format a HOST_WIDE_INT as either a percent ratio, or absolute\n+/* Format a GCOV_TYPE integer as either a percent ratio, or absolute\n    count.  If dp >= 0, format TOP/BOTTOM * 100 to DP decimal places.\n    If DP is zero, no decimal point is printed. Only print 100% when\n    TOP==BOTTOM and only print 0% when TOP=0.  If dp < 0, then simply\n@@ -2266,18 +2269,19 @@ output_lines (FILE *gcov_file, const source_t *src)\n     {\n       for (; fn && fn->line == line_num; fn = fn->line_next)\n \t{\n-\t  arc_t *arc = fn->blocks[fn->num_blocks - 1].pred;\n-\t  gcov_type return_count = fn->blocks[fn->num_blocks - 1].count;\n+\t  arc_t *arc = fn->blocks[EXIT_BLOCK].pred;\n+\t  gcov_type return_count = fn->blocks[EXIT_BLOCK].count;\n+\t  gcov_type called_count = fn->blocks[ENTRY_BLOCK].count;\n \n \t  for (; arc; arc = arc->pred_next)\n \t    if (arc->fake)\n \t      return_count -= arc->count;\n \n \t  fprintf (gcov_file, \"function %s\", fn->name);\n \t  fprintf (gcov_file, \" called %s\",\n-\t\t   format_gcov (fn->blocks[0].count, 0, -1));\n+\t\t   format_gcov (called_count, 0, -1));\n \t  fprintf (gcov_file, \" returned %s\",\n-\t\t   format_gcov (return_count, fn->blocks[0].count, 0));\n+\t\t   format_gcov (return_count, called_count, 0));\n \t  fprintf (gcov_file, \" blocks executed %s\",\n \t\t   format_gcov (fn->blocks_executed, fn->num_blocks - 2, 0));\n \t  fprintf (gcov_file, \"\\n\");"}, {"sha": "c7257d9be16a769337b7d53743304fddb1661443", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -798,7 +798,6 @@ input_struct_function_base (struct function *fn, struct data_in *data_in,\n   bp = streamer_read_bitpack (ib);\n   fn->is_thunk = bp_unpack_value (&bp, 1);\n   fn->has_local_explicit_reg_vars = bp_unpack_value (&bp, 1);\n-  fn->after_tree_profile = bp_unpack_value (&bp, 1);\n   fn->returns_pcc_struct = bp_unpack_value (&bp, 1);\n   fn->returns_struct = bp_unpack_value (&bp, 1);\n   fn->can_throw_non_call_exceptions = bp_unpack_value (&bp, 1);"}, {"sha": "cfcd3d0a570dbb11337f412ce6400cdcfe5d0b3f", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -757,7 +757,6 @@ output_struct_function_base (struct output_block *ob, struct function *fn)\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, fn->is_thunk, 1);\n   bp_pack_value (&bp, fn->has_local_explicit_reg_vars, 1);\n-  bp_pack_value (&bp, fn->after_tree_profile, 1);\n   bp_pack_value (&bp, fn->returns_pcc_struct, 1);\n   bp_pack_value (&bp, fn->returns_struct, 1);\n   bp_pack_value (&bp, fn->can_throw_non_call_exceptions, 1);"}, {"sha": "4d3b03239d4e03cae7a1698ba6cac2582a019c0f", "filename": "gcc/omp-low.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -3398,9 +3398,6 @@ expand_omp_taskreg (struct omp_region *region)\n   entry_stmt = last_stmt (region->entry);\n   child_fn = gimple_omp_taskreg_child_fn (entry_stmt);\n   child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n-  /* If this function has been already instrumented, make sure\n-     the child function isn't instrumented again.  */\n-  child_cfun->after_tree_profile = cfun->after_tree_profile;\n \n   entry_bb = region->entry;\n   exit_bb = region->exit;"}, {"sha": "0ddb1a0e582378542777b36cbb72de19b203e4bf", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -1593,8 +1593,6 @@ common_handle_option (struct gcc_options *opts,\n \topts->x_profile_arc_flag = value;\n       if (!opts_set->x_flag_profile_values)\n \topts->x_flag_profile_values = value;\n-      if (!opts_set->x_flag_value_profile_transformations)\n-\topts->x_flag_value_profile_transformations = value;\n       if (!opts_set->x_flag_inline_functions)\n \topts->x_flag_inline_functions = value;\n       /* FIXME: Instrumentation we insert makes ipa-reference bitmaps"}, {"sha": "3d0689afac31dca3d9d534d053a0e4ab9e13565c", "filename": "gcc/profile.c", "status": "modified", "additions": 18, "deletions": 62, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -143,46 +143,15 @@ instrument_edges (struct edge_list *el)\n static void\n instrument_values (histogram_values values)\n {\n-  unsigned i, t;\n+  unsigned i;\n \n   /* Emit code to generate the histograms before the insns.  */\n \n   for (i = 0; i < VEC_length (histogram_value, values); i++)\n     {\n       histogram_value hist = VEC_index (histogram_value, values, i);\n-      switch (hist->type)\n-\t{\n-\tcase HIST_TYPE_INTERVAL:\n-\t  t = GCOV_COUNTER_V_INTERVAL;\n-\t  break;\n-\n-\tcase HIST_TYPE_POW2:\n-\t  t = GCOV_COUNTER_V_POW2;\n-\t  break;\n-\n-\tcase HIST_TYPE_SINGLE_VALUE:\n-\t  t = GCOV_COUNTER_V_SINGLE;\n-\t  break;\n-\n-\tcase HIST_TYPE_CONST_DELTA:\n-\t  t = GCOV_COUNTER_V_DELTA;\n-\t  break;\n+      unsigned t = COUNTER_FOR_HIST_TYPE (hist->type);\n \n- \tcase HIST_TYPE_INDIR_CALL:\n- \t  t = GCOV_COUNTER_V_INDIR;\n- \t  break;\n-\n- \tcase HIST_TYPE_AVERAGE:\n- \t  t = GCOV_COUNTER_AVERAGE;\n- \t  break;\n-\n- \tcase HIST_TYPE_IOR:\n- \t  t = GCOV_COUNTER_IOR;\n- \t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n       if (!coverage_counter_alloc (t, hist->n_counters))\n \tcontinue;\n \n@@ -870,9 +839,6 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n     free (histogram_counts[t]);\n }\n \n-/* The entry basic block will be moved around so that it has index=1,\n-   there is nothing at index 0 and the exit is at n_basic_block.  */\n-#define BB_TO_GCOV_INDEX(bb)  ((bb)->index - 1)\n /* When passed NULL as file_name, initialize.\n    When passed something else, output the necessary commands to change\n    line to LINE and offset to FILE_NAME.  */\n@@ -899,7 +865,7 @@ output_location (char const *file_name, int line,\n       if (!*offset)\n \t{\n \t  *offset = gcov_write_tag (GCOV_TAG_LINES);\n-\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n+\t  gcov_write_unsigned (bb->index);\n \t  name_differs = line_differs=true;\n \t}\n \n@@ -919,19 +885,22 @@ output_location (char const *file_name, int line,\n      }\n }\n \n-/* Instrument and/or analyze program behavior based on program flow graph.\n-   In either case, this function builds a flow graph for the function being\n-   compiled.  The flow graph is stored in BB_GRAPH.\n+/* Instrument and/or analyze program behavior based on program the CFG.\n+\n+   This function creates a representation of the control flow graph (of\n+   the function being compiled) that is suitable for the instrumentation\n+   of edges and/or converting measured edge counts to counts on the\n+   complete CFG.\n \n    When FLAG_PROFILE_ARCS is nonzero, this function instruments the edges in\n    the flow graph that are needed to reconstruct the dynamic behavior of the\n-   flow graph.\n+   flow graph.  This data is written to the gcno file for gcov.\n \n    When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxiliary\n-   information from a data file containing edge count information from previous\n-   executions of the function being compiled.  In this case, the flow graph is\n-   annotated with actual execution counts, which are later propagated into the\n-   rtl for optimization purposes.\n+   information from the gcda file containing edge count information from\n+   previous executions of the function being compiled.  In this case, the\n+   control flow graph is annotated with actual execution counts by\n+   compute_branch_probabilities().\n \n    Main entry point of this file.  */\n \n@@ -1145,8 +1114,7 @@ branch_prob (void)\n   lineno_checksum = coverage_compute_lineno_checksum ();\n \n   /* Write the data from which gcov can reconstruct the basic block\n-     graph and function line numbers  */\n-\n+     graph and function line numbers (the gcno file).  */\n   if (coverage_begin_function (lineno_checksum, cfg_checksum))\n     {\n       gcov_position_t offset;\n@@ -1157,20 +1125,14 @@ branch_prob (void)\n \tgcov_write_unsigned (0);\n       gcov_write_length (offset);\n \n-      /* Keep all basic block indexes nonnegative in the gcov output.\n-\t Index 0 is used for entry block, last index is for exit\n-\t block.    */\n-      ENTRY_BLOCK_PTR->index = 1;\n-      EXIT_BLOCK_PTR->index = last_basic_block;\n-\n       /* Arcs */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n \n \t  offset = gcov_write_tag (GCOV_TAG_ARCS);\n-\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n+\t  gcov_write_unsigned (bb->index);\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n@@ -1191,17 +1153,14 @@ branch_prob (void)\n \t\t      && e->src->next_bb == e->dest)\n \t\t    flag_bits |= GCOV_ARC_FALLTHROUGH;\n \n-\t\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (e->dest));\n+\t\t  gcov_write_unsigned (e->dest->index);\n \t\t  gcov_write_unsigned (flag_bits);\n \t        }\n \t    }\n \n \t  gcov_write_length (offset);\n \t}\n \n-      ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n-      EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n-\n       /* Line numbers.  */\n       /* Initialize the output.  */\n       output_location (NULL, 0, NULL, NULL);\n@@ -1247,8 +1206,6 @@ branch_prob (void)\n \t}\n     }\n \n-#undef BB_TO_GCOV_INDEX\n-\n   if (flag_profile_values)\n     gimple_find_values_to_profile (&values);\n \n@@ -1391,8 +1348,7 @@ find_spanning_tree (struct edge_list *el)\n \t}\n     }\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    bb->aux = NULL;\n+  clear_aux_for_blocks ();\n }\n \f\n /* Perform file-level initialization for branch-prob processing.  */"}, {"sha": "78b4d94573d53de27fdb56eaba60b5047020ae46", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -2110,7 +2110,6 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   cfun->can_delete_dead_exceptions = src_cfun->can_delete_dead_exceptions;\n   cfun->returns_struct = src_cfun->returns_struct;\n   cfun->returns_pcc_struct = src_cfun->returns_pcc_struct;\n-  cfun->after_tree_profile = src_cfun->after_tree_profile;\n \n   init_empty_tree_cfg ();\n "}, {"sha": "41879530303dee631d02c8c2355c3ead2368e9c4", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -100,6 +100,8 @@ init_ic_make_global_vars (void)\n   varpool_finalize_decl (ic_gcov_type_ptr_var);\n }\n \n+/* Create the type and function decls for the interface with gcov.  */\n+\n void\n gimple_init_edge_profiler (void)\n {\n@@ -332,8 +334,9 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n \n   /* Insert code:\n \n-    __gcov_indirect_call_counters = get_relevant_counter_ptr ();\n-    __gcov_indirect_call_callee = (void *) indirect call argument;\n+    stmt1: __gcov_indirect_call_counters = get_relevant_counter_ptr ();\n+    stmt2: tmp1 = (void *) (indirect call argument value)\n+    stmt3: __gcov_indirect_call_callee = tmp1;\n    */\n \n   tmp1 = create_tmp_reg (ptr_void, \"PROF\");\n@@ -368,6 +371,13 @@ gimple_gen_ic_func_profiler (void)\n \n   gimple_init_edge_profiler ();\n \n+  /* Insert code:\n+\n+    stmt1: __gcov_indirect_call_profiler (__gcov_indirect_call_counters,\n+\t\t\t\t\t  current_function_funcdef_no,\n+\t\t\t\t\t  &current_function_decl,\n+\t\t\t\t\t  __gcov_indirect_call_callee);\n+   */\n   gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n \n   cur_func = force_gimple_operand_gsi (&gsi,\n@@ -461,12 +471,9 @@ tree_profiling (void)\n {\n   struct cgraph_node *node;\n \n-  /* Don't profile functions produced at destruction time, particularly\n-     the gcov datastructure initializer.  Don't profile if it has been\n-     already instrumented either (when OpenMP expansion creates\n-     child function from already instrumented body).  */\n-  if (cgraph_state == CGRAPH_STATE_FINISHED)\n-    return 0;\n+  /* This is a small-ipa pass that gets called only once, from\n+     cgraphunit.c:ipa_passes().  */\n+  gcc_assert (cgraph_state == CGRAPH_STATE_IPA_SSA);\n \n   init_node_map();\n \n@@ -476,8 +483,7 @@ tree_profiling (void)\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION\n-\t  || DECL_STRUCT_FUNCTION (node->symbol.decl)->after_tree_profile)\n+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n       push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n@@ -489,6 +495,7 @@ tree_profiling (void)\n       /* Local pure-const may imply need to fixup the cfg.  */\n       if (execute_fixup_cfg () & TODO_cleanup_cfg)\n \tcleanup_tree_cfg ();\n+\n       branch_prob ();\n \n       if (! flag_branch_probabilities\n@@ -519,8 +526,7 @@ tree_profiling (void)\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION\n-\t  || DECL_STRUCT_FUNCTION (node->symbol.decl)->after_tree_profile)\n+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n       cgraph_set_const_flag (node, false, false);\n@@ -538,8 +544,7 @@ tree_profiling (void)\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION\n-\t  || DECL_STRUCT_FUNCTION (node->symbol.decl)->after_tree_profile)\n+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n       push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n@@ -556,7 +561,6 @@ tree_profiling (void)\n \t    }\n \t}\n \n-      cfun->after_tree_profile = 1;\n       update_ssa (TODO_update_ssa);\n \n       rebuild_cgraph_edges ();"}, {"sha": "b75c36f87f7eeb6435babd8d946f2eccf34c80d5", "filename": "gcc/value-prof.c", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9696c52909efcdb631f5fd7e8a8261656a25cc1b/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=9696c52909efcdb631f5fd7e8a8261656a25cc1b", "patch": "@@ -53,28 +53,63 @@ along with GCC; see the file COPYING3.  If not see\n    1) Division/modulo specialization.  Provided that we can determine that the\n       operands of the division have some special properties, we may use it to\n       produce more effective code.\n-   2) Speculative prefetching.  If we are able to determine that the difference\n-      between addresses accessed by a memory reference is usually constant, we\n-      may add the prefetch instructions.\n-      FIXME: This transformation was removed together with RTL based value\n-      profiling.\n \n-   3) Indirect/virtual call specialization. If we can determine most\n+   2) Indirect/virtual call specialization. If we can determine most\n       common function callee in indirect/virtual call. We can use this\n       information to improve code effectiveness (especially info for\n-      inliner).\n+      the inliner).\n \n-   Every such optimization should add its requirements for profiled values to\n-   insn_values_to_profile function.  This function is called from branch_prob\n-   in profile.c and the requested values are instrumented by it in the first\n-   compilation with -fprofile-arcs.  The optimization may then read the\n-   gathered data in the second compilation with -fbranch-probabilities.\n+   3) Speculative prefetching.  If we are able to determine that the difference\n+      between addresses accessed by a memory reference is usually constant, we\n+      may add the prefetch instructions.\n+      FIXME: This transformation was removed together with RTL based value\n+      profiling.\n \n-   The measured data is pointed to from the histograms\n-   field of the statement annotation of the instrumented insns.  It is\n-   kept as a linked list of struct histogram_value_t's, which contain the\n-   same information as above.  */\n \n+   Value profiling internals\n+   ==========================\n+\n+   Every value profiling transformation starts with defining what values\n+   to profile.  There are different histogram types (see HIST_TYPE_* in\n+   value-prof.h) and each transformation can request one or more histogram\n+   types per GIMPLE statement.  The function gimple_find_values_to_profile()\n+   collects the values to profile in a VEC, and adds the number of counters\n+   required for the different histogram types.\n+\n+   For a -fprofile-generate run, the statements for which values should be\n+   recorded, are instrumented in instrument_values().  The instrumentation\n+   is done by helper functions that can be found in tree-profile.c, where\n+   new types of histograms can be added if necessary.\n+\n+   After a -fprofile-use, the value profiling data is read back in by\n+   compute_value_histograms() that translates the collected data to\n+   histograms and attaches them to the profiled statements via\n+   gimple_add_histogram_value().  Histograms are stored in a hash table\n+   that is attached to every intrumented function, see VALUE_HISTOGRAMS\n+   in function.h.\n+   \n+   The value-profile transformations driver is the function\n+   gimple_value_profile_transformations().  It traverses all statements in\n+   the to-be-transformed function, and looks for statements with one or\n+   more histograms attached to it.  If a statement has histograms, the\n+   transformation functions are called on the statement.\n+\n+   Limitations / FIXME / TODO:\n+   * Only one histogram of each type can be associated with a statement.\n+   * Currently, HIST_TYPE_CONST_DELTA is not implemented.\n+     (This type of histogram was originally used to implement a form of\n+     stride profiling based speculative prefetching to improve SPEC2000\n+     scores for memory-bound benchmarks, mcf and equake.  However, this\n+     was an RTL value-profiling transformation, and those have all been\n+     removed.)\n+   * Some value profile transformations are done in builtins.c (?!)\n+   * Updating of histograms needs some TLC.\n+   * The value profiling code could be used to record analysis results\n+     from non-profiling (e.g. VRP).\n+   * Adding new profilers should be simplified, starting with a cleanup\n+     of what-happens-where andwith making gimple_find_values_to_profile\n+     and gimple_value_profile_transformations table-driven, perhaps...\n+*/\n \n static tree gimple_divmod_fixed_value (gimple, tree, int, gcov_type, gcov_type);\n static tree gimple_mod_pow2 (gimple, int, gcov_type, gcov_type);\n@@ -84,7 +119,7 @@ static bool gimple_divmod_fixed_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_pow2_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_subtract_transform (gimple_stmt_iterator *);\n static bool gimple_stringops_transform (gimple_stmt_iterator *);\n-static bool gimple_ic_transform (gimple);\n+static bool gimple_ic_transform (gimple_stmt_iterator *);\n \n /* Allocate histogram value.  */\n \n@@ -309,7 +344,7 @@ dump_histograms_for_stmt (struct function *fun, FILE *dump_file, gimple stmt)\n {\n   histogram_value hist;\n   for (hist = gimple_histogram_value (fun, stmt); hist; hist = hist->hvalue.next)\n-   dump_histogram_value (dump_file, hist);\n+    dump_histogram_value (dump_file, hist);\n }\n \n /* Remove all histograms associated with STMT.  */\n@@ -519,12 +554,11 @@ gimple_value_profile_transformations (void)\n \t     will be added before the current statement, and that the\n \t     current statement remain valid (although possibly\n \t     modified) upon return.  */\n-\t  if (flag_value_profile_transformations\n-\t      && (gimple_mod_subtract_transform (&gsi)\n-\t\t  || gimple_divmod_fixed_value_transform (&gsi)\n-\t\t  || gimple_mod_pow2_value_transform (&gsi)\n-\t\t  || gimple_stringops_transform (&gsi)\n-\t\t  || gimple_ic_transform (stmt)))\n+\t  if (gimple_mod_subtract_transform (&gsi)\n+\t      || gimple_divmod_fixed_value_transform (&gsi)\n+\t      || gimple_mod_pow2_value_transform (&gsi)\n+\t      || gimple_stringops_transform (&gsi)\n+\t      || gimple_ic_transform (&gsi))\n \t    {\n \t      stmt = gsi_stmt (gsi);\n \t      changed = true;\n@@ -1283,8 +1317,9 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n  */\n \n static bool\n-gimple_ic_transform (gimple stmt)\n+gimple_ic_transform (gimple_stmt_iterator *gsi)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n   histogram_value histogram;\n   gcov_type val, count, all, bb_all;\n   gcov_type prob;\n@@ -1749,12 +1784,9 @@ gimple_stringops_values_to_profile (gimple stmt, histogram_values *values)\n static void\n gimple_values_to_profile (gimple stmt, histogram_values *values)\n {\n-  if (flag_value_profile_transformations)\n-    {\n-      gimple_divmod_values_to_profile (stmt, values);\n-      gimple_stringops_values_to_profile (stmt, values);\n-      gimple_indirect_call_to_profile (stmt, values);\n-    }\n+  gimple_divmod_values_to_profile (stmt, values);\n+  gimple_stringops_values_to_profile (stmt, values);\n+  gimple_indirect_call_to_profile (stmt, values);\n }\n \n void"}]}