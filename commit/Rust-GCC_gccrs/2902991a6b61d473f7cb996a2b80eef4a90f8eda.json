{"sha": "2902991a6b61d473f7cb996a2b80eef4a90f8eda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkwMjk5MWE2YjYxZDQ3M2Y3Y2I5OTZhMmI4MGVlZjRhOTBmOGVkYQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-06-28T16:20:00Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-06-28T16:24:54Z"}, "message": "ipa-sra: Introduce a mini-DCE to tree-inline.c (PR 93385)\n\nI was asked by Richi to split my fix for PR 93385 for easier review\ninto IPA-SRA materialization refactoring and the actual DCE addition.\nThis is the second part that actually contains the DCE of statements\nthat IPA-SRA should not leave behind because they can have problematic\nside effects, even if they are useless, so that we do not depend on\ntree-dce to remove them for correctness.\n\nThe patch fixes the problem by doing a def-use walk when materializing\nclones, marking which statements should not be copied and which\nSSA_NAMEs do not need to be computed because eventually they would be\nDCEd.  We do this on the original function body and tree-inline simply\ndoes not copy statements which are \"dead.\"\n\nThe only complication is removing dead argument calls because that\nneeds to be communicated to callee redirection code using the\ninfrastructure introduced by the previous patch.\n\nI added all testcases of the original patch to this one, although some\nprobably test behavior introduced in the previous patch.\n\ngcc/ChangeLog:\n\n2021-05-12  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* ipa-param-manipulation.h (class ipa_param_body_adjustments): New\n\tmembers m_dead_stmts and m_dead_ssas.\n\t* ipa-param-manipulation.c\n\t(ipa_param_body_adjustments::mark_dead_statements): New function.\n\t(ipa_param_body_adjustments::common_initialization): Call it on\n\tall removed but not split parameters.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Initialize\n\tnew mwmbers.\n\t(ipa_param_body_adjustments::modify_call_stmt): Remove arguments that\n\tare dead.\n\t* tree-inline.c (remap_gimple_stmt): Do not copy dead statements, reset\n\tdead debug statements.\n\t(copy_phis_for_bb): Do not copy dead PHI nodes.\n\ngcc/testsuite/ChangeLog:\n\n2021-03-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* gcc.dg/ipa/pr93385.c: New test.\n\t* gcc.dg/ipa/ipa-sra-23.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-24.c: Likewise.\n\t* g++.dg/ipa/ipa-sra-4.C: Likewise.", "tree": {"sha": "5bd9b5d3e2e57229b505509d6e054efd0f1a780a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bd9b5d3e2e57229b505509d6e054efd0f1a780a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2902991a6b61d473f7cb996a2b80eef4a90f8eda", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmDZ99YACgkQv2PBvD+k\nNUBxsxAAnHq5W1uk9UuYjks1Cc3Qnaxl4tN0n2jCqCl9zaYV78wJhYsWt9Ud08zU\nKS2IVJ4KnytNDh32GGivWrTVv7u2Ey586YnQcyg0SRRwU/U9jk68TBesoQIBh90S\nZP0wnF5qz4X/H2dhI/9MOVkjTu5EeMEnQnEPtThBDoDtOQwwXfRQ8KqceuOOpPx1\nxR58VuSwlO0jTvRMnye7qGoIAc39/lUub6vAmVV+gCaZVnhwu9lH/YebpsIaxQue\nuW/L/+lEinVCr7C2uX4GzkoKi0ESof+ta/9xUOAp4bzRZTzpMbbBeHiUhhFVhv50\nyxBs/WU5rTNpm6n5TuazT2T1fuNjsw9+Rw20vLze9R6dUD5q6RxgZrlkS4ul42hl\nn3C3/O7O3xFAP5WCssXJgZaUbTvUG832ru5XXAAw0gY5XDdISjDPMLC4Boq3oh4T\nVx/Pkj6jRvoAOpG9YCEUcbkaZB+l9o4RrZCeRD0p7JdM5VXpBKWE5G5cdTShNEaG\ntPc4x4hSf3xcCQdOpyYb0PU9yI6utMAPqJqWoxY4nAAUJqFYV51enlWDvv8QL2EK\nRMbWEMaWkmXPzWLKbl7G5jJE7x+ukNohAvOugNDnOFXMVKVNq013HRa7e637JkmA\nwTLmF5c8geonmXDcfo5nfYIc0lTJJQi+PdEj9ead0BdxZ9hSCwo=\n=UkEr\n-----END PGP SIGNATURE-----", "payload": "tree 5bd9b5d3e2e57229b505509d6e054efd0f1a780a\nparent 87467f45e831e8e943efdae8920453741986d355\nauthor Martin Jambor <mjambor@suse.cz> 1624897200 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1624897494 +0200\n\nipa-sra: Introduce a mini-DCE to tree-inline.c (PR 93385)\n\nI was asked by Richi to split my fix for PR 93385 for easier review\ninto IPA-SRA materialization refactoring and the actual DCE addition.\nThis is the second part that actually contains the DCE of statements\nthat IPA-SRA should not leave behind because they can have problematic\nside effects, even if they are useless, so that we do not depend on\ntree-dce to remove them for correctness.\n\nThe patch fixes the problem by doing a def-use walk when materializing\nclones, marking which statements should not be copied and which\nSSA_NAMEs do not need to be computed because eventually they would be\nDCEd.  We do this on the original function body and tree-inline simply\ndoes not copy statements which are \"dead.\"\n\nThe only complication is removing dead argument calls because that\nneeds to be communicated to callee redirection code using the\ninfrastructure introduced by the previous patch.\n\nI added all testcases of the original patch to this one, although some\nprobably test behavior introduced in the previous patch.\n\ngcc/ChangeLog:\n\n2021-05-12  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* ipa-param-manipulation.h (class ipa_param_body_adjustments): New\n\tmembers m_dead_stmts and m_dead_ssas.\n\t* ipa-param-manipulation.c\n\t(ipa_param_body_adjustments::mark_dead_statements): New function.\n\t(ipa_param_body_adjustments::common_initialization): Call it on\n\tall removed but not split parameters.\n\t(ipa_param_body_adjustments::ipa_param_body_adjustments): Initialize\n\tnew mwmbers.\n\t(ipa_param_body_adjustments::modify_call_stmt): Remove arguments that\n\tare dead.\n\t* tree-inline.c (remap_gimple_stmt): Do not copy dead statements, reset\n\tdead debug statements.\n\t(copy_phis_for_bb): Do not copy dead PHI nodes.\n\ngcc/testsuite/ChangeLog:\n\n2021-03-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/93385\n\t* gcc.dg/ipa/pr93385.c: New test.\n\t* gcc.dg/ipa/ipa-sra-23.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-24.c: Likewise.\n\t* g++.dg/ipa/ipa-sra-4.C: Likewise.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2902991a6b61d473f7cb996a2b80eef4a90f8eda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2902991a6b61d473f7cb996a2b80eef4a90f8eda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2902991a6b61d473f7cb996a2b80eef4a90f8eda/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87467f45e831e8e943efdae8920453741986d355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87467f45e831e8e943efdae8920453741986d355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87467f45e831e8e943efdae8920453741986d355"}], "stats": {"total": 261, "additions": 243, "deletions": 18}, "files": [{"sha": "26b02d7aa95c9fae31daf6797ee3bfa865ae4145", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 114, "deletions": 15, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -970,6 +970,84 @@ ipa_param_body_adjustments::carry_over_param (tree t)\n   return new_parm;\n }\n \n+/* Populate m_dead_stmts given that DEAD_PARAM is going to be removed without\n+   any replacement or splitting.  REPL is the replacement VAR_SECL to base any\n+   remaining uses of a removed parameter on.  */\n+\n+void\n+ipa_param_body_adjustments::mark_dead_statements (tree dead_param)\n+{\n+  /* Current IPA analyses which remove unused parameters never remove a\n+     non-gimple register ones which have any use except as parameters in other\n+     calls, so we can safely leve them as they are.  */\n+  if (!is_gimple_reg (dead_param))\n+    return;\n+  tree parm_ddef = ssa_default_def (m_id->src_cfun, dead_param);\n+  if (!parm_ddef || has_zero_uses (parm_ddef))\n+    return;\n+\n+  auto_vec<tree, 4> stack;\n+  m_dead_ssas.add (parm_ddef);\n+  stack.safe_push (parm_ddef);\n+  while (!stack.is_empty ())\n+    {\n+      imm_use_iterator imm_iter;\n+      use_operand_p use_p;\n+      tree t = stack.pop ();\n+\n+      insert_decl_map (m_id, t, error_mark_node);\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, t)\n+\t{\n+\t  gimple *stmt = USE_STMT (use_p);\n+\n+\t  /* Calls containing dead arguments cannot be deleted,\n+\t     modify_call_stmt will instead remove just the argument later on.\n+\t     If isra_track_scalar_value_uses in ipa-sra.c is extended to look\n+\t     through const functions, we will need to do so here too.  */\n+\t  if (is_gimple_call (stmt)\n+\t      || (m_id->blocks_to_copy\n+\t\t  && !bitmap_bit_p (m_id->blocks_to_copy,\n+\t\t\t\t    gimple_bb (stmt)->index)))\n+\t    continue;\n+\n+\t  if (is_gimple_debug (stmt))\n+\t    {\n+\t      m_dead_stmts.add (stmt);\n+\t      gcc_assert (gimple_debug_bind_p (stmt));\n+\t    }\n+\t  else if (gimple_code (stmt) == GIMPLE_PHI)\n+\t    {\n+\t      gphi *phi = as_a <gphi *> (stmt);\n+\t      int ix = PHI_ARG_INDEX_FROM_USE (use_p);\n+\n+\t      if (!m_id->blocks_to_copy\n+\t\t  || bitmap_bit_p (m_id->blocks_to_copy,\n+\t\t\t\t   gimple_phi_arg_edge (phi, ix)->src->index))\n+\t\t{\n+\t\t  m_dead_stmts.add (phi);\n+\t\t  tree res = gimple_phi_result (phi);\n+\t\t  if (!m_dead_ssas.add (res))\n+\t\t    stack.safe_push (res);\n+\t\t}\n+\t    }\n+\t  else if (is_gimple_assign (stmt))\n+\t    {\n+\t      m_dead_stmts.add (stmt);\n+\t      if (!gimple_clobber_p (stmt))\n+\t\t{\n+\t\t  tree lhs = gimple_assign_lhs (stmt);\n+\t\t  gcc_assert (TREE_CODE (lhs) == SSA_NAME);\n+\t\t  if (!m_dead_ssas.add (lhs))\n+\t\t    stack.safe_push (lhs);\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* IPA-SRA does not analyze other types of statements.  */\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n /* Common initialization performed by all ipa_param_body_adjustments\n    constructors.  OLD_FNDECL is the declaration we take original arguments\n    from, (it may be the same as M_FNDECL).  VARS, if non-NULL, is a pointer to\n@@ -1003,6 +1081,9 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n   auto_vec<bool, 16> kept;\n   kept.reserve_exact (m_oparms.length ());\n   kept.quick_grow_cleared (m_oparms.length ());\n+  auto_vec<bool, 16> split;\n+  split.reserve_exact (m_oparms.length ());\n+  split.quick_grow_cleared (m_oparms.length ());\n \n   unsigned adj_len = vec_safe_length (m_adj_params);\n   m_method2func = ((TREE_CODE (TREE_TYPE (m_fndecl)) == METHOD_TYPE)\n@@ -1048,6 +1129,7 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t  if (apm->op == IPA_PARAM_OP_SPLIT)\n \t    {\n \t      m_split_modifications_p = true;\n+\t      split[prev_index] = true;\n \t      register_replacement (apm, new_parm);\n \t    }\n         }\n@@ -1080,6 +1162,11 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t\t/* Declare this new variable.  */\n \t\tDECL_CHAIN (var) = *vars;\n \t\t*vars = var;\n+\n+\t\t/* If this is not a split but a real removal, init hash sets\n+\t\t   that will guide what not to copy to the new body.  */\n+\t\tif (!split[i])\n+\t\t  mark_dead_statements (m_oparms[i]);\n \t      }\n \t  }\n \telse\n@@ -1136,9 +1223,10 @@ ipa_param_body_adjustments\n ::ipa_param_body_adjustments (vec<ipa_adjusted_param, va_gc> *adj_params,\n \t\t\t      tree fndecl)\n   : m_adj_params (adj_params), m_adjustments (NULL), m_reset_debug_decls (),\n-    m_split_modifications_p (false), m_fndecl (fndecl), m_id (NULL),\n-    m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n-    m_removed_decls (), m_removed_map (), m_method2func (false)\n+    m_split_modifications_p (false), m_dead_stmts (), m_dead_ssas (),\n+    m_fndecl (fndecl), m_id (NULL), m_oparms (), m_new_decls (),\n+    m_new_types (), m_replacements (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n }\n@@ -1152,9 +1240,9 @@ ipa_param_body_adjustments\n ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n \t\t\t      tree fndecl)\n   : m_adj_params (adjustments->m_adj_params), m_adjustments (adjustments),\n-    m_reset_debug_decls (), m_split_modifications_p (false), m_fndecl (fndecl),\n-    m_id (NULL), m_oparms (), m_new_decls (), m_new_types (),\n-    m_replacements (), m_removed_decls (), m_removed_map (),\n+    m_reset_debug_decls (), m_split_modifications_p (false), m_dead_stmts (),\n+    m_dead_ssas (), m_fndecl (fndecl), m_id (NULL), m_oparms (), m_new_decls (),\n+    m_new_types (), m_replacements (), m_removed_decls (), m_removed_map (),\n     m_method2func (false)\n {\n   common_initialization (fndecl, NULL, NULL);\n@@ -1175,9 +1263,10 @@ ::ipa_param_body_adjustments (ipa_param_adjustments *adjustments,\n \t\t\t      copy_body_data *id, tree *vars,\n \t\t\t      vec<ipa_replace_map *, va_gc> *tree_map)\n   : m_adj_params (adjustments->m_adj_params), m_adjustments (adjustments),\n-    m_reset_debug_decls (), m_split_modifications_p (false), m_fndecl (fndecl),\n-    m_id (id), m_oparms (), m_new_decls (), m_new_types (), m_replacements (),\n-    m_removed_decls (), m_removed_map (), m_method2func (false)\n+    m_reset_debug_decls (), m_split_modifications_p (false), m_dead_stmts (),\n+    m_dead_ssas (),m_fndecl (fndecl), m_id (id), m_oparms (), m_new_decls (),\n+    m_new_types (), m_replacements (), m_removed_decls (), m_removed_map (),\n+    m_method2func (false)\n {\n   common_initialization (old_fndecl, vars, tree_map);\n }\n@@ -1624,8 +1713,9 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n \t\t  && TREE_CODE (t) != IMAGPART_EXPR\n \t\t  && TREE_CODE (t) != REALPART_EXPR);\n \n-      /* The follow-up patch will check whether t needs to be removed, that's\n-\t why this condition is in the loop.  */\n+      if (TREE_CODE (t) == SSA_NAME\n+\t  && m_dead_ssas.contains (t))\n+\trecreate = true;\n \n       if (!m_split_modifications_p)\n \tcontinue;\n@@ -1763,10 +1853,19 @@ ipa_param_body_adjustments::modify_call_stmt (gcall **stmt_p,\n       else\n \t{\n \t  tree t = gimple_call_arg (stmt, i);\n-\t  modify_expression (&t, true);\n-\t  vargs.safe_push (t);\n-\t  index_map.safe_push (new_arg_idx);\n-\t  new_arg_idx++;\n+\t  if (TREE_CODE (t) == SSA_NAME\n+\t      && m_dead_ssas.contains (t))\n+\t    {\n+\t      always_copy_delta--;\n+\t      index_map.safe_push (-1);\n+\t    }\n+\t  else\n+\t    {\n+\t      modify_expression (&t, true);\n+\t      vargs.safe_push (t);\n+\t      index_map.safe_push (new_arg_idx);\n+\t      new_arg_idx++;\n+\t    }\n \t}\n     }\n "}, {"sha": "afcbc09bf339914a7162c6c12b210c84273143fd", "filename": "gcc/ipa-param-manipulation.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Fipa-param-manipulation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Fipa-param-manipulation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.h?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -342,6 +342,12 @@ class ipa_param_body_adjustments\n   /* Set to true if there are any IPA_PARAM_OP_SPLIT adjustments among stored\n      adjustments.  */\n   bool m_split_modifications_p;\n+\n+  /* Sets of statements and SSA_NAMEs that only manipulate data from parameters\n+     removed because they are not necessary.  */\n+  hash_set<gimple *> m_dead_stmts;\n+  hash_set<tree> m_dead_ssas;\n+\n private:\n   void common_initialization (tree old_fndecl, tree *vars,\n \t\t\t      vec<ipa_replace_map *, va_gc> *tree_map);"}, {"sha": "56d59f9fd9a907bffa3f289e8efb7b9c949b02c6", "filename": "gcc/testsuite/g++.dg/ipa/ipa-sra-4.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-4.C?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2 -fipa-sra\"  } */\n+\n+void __throw_bad_alloc() __attribute__((__noreturn__));\n+void __throw_bad_array_new_length();\n+template <typename> class allocator {};\n+template <typename> struct allocator_traits;\n+int *allocate___trans_tmp_2;\n+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {\n+  using allocator_type = allocator<_Tp>;\n+  using pointer = _Tp *;\n+  using size_type = long;\n+  static pointer allocate(allocator_type &, size_type __n) {\n+    long __trans_tmp_3 = __n;\n+    if (__builtin_expect(__trans_tmp_3, false))\n+      if (__trans_tmp_3)\n+        __throw_bad_array_new_length();\n+    operator new(sizeof(int));\n+    return allocate___trans_tmp_2;\n+  }\n+};\n+class throw_allocator_base {\n+  allocator<int> _M_allocator;\n+public:\n+  int *allocate(long __n) {\n+    if (__n)\n+      __throw_bad_alloc();\n+    int *a = allocator_traits<allocator<int>>::allocate(_M_allocator, __n);\n+    return a;\n+  }\n+};\n+template <typename Alloc> void check_allocate_max_size() {\n+  Alloc a;\n+  long __trans_tmp_1 = 0;\n+  a.allocate(__trans_tmp_1 + 1);\n+}\n+int main() { check_allocate_max_size<throw_allocator_base>(); }"}, {"sha": "f438b5096147311879af6a16b670385059362533", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-23.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-23.c?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\"  } */\n+\n+extern int g;\n+\n+static int __attribute__((noinline))\n+bar (int i, int j)\n+{\n+  return 2*g + i;\n+}\n+\n+static int __attribute__((noinline))\n+foo (int i, int j)\n+{\n+  if (i > 5)\n+    j = 22;\n+  return bar (i, j) + 1;\n+}\n+\n+int\n+entry (int l, int k)\n+{\n+  return foo (l, k);\n+}"}, {"sha": "7b5bf0825fc0f278081f009e884f93c9aae0b08d", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-24.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-24.c?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wmaybe-uninitialized -Werror\"  } */\n+\n+int *ttmp_1;\n+_Bool pt_ins_tipdo, pq_ins_apd, pq_ins_tt2;\n+int gtrphdt;\n+\n+void pl_ins(int, _Bool, _Bool);\n+inline void pt_ins(int *, _Bool apdo) {\n+  int list = *ttmp_1;\n+  pl_ins(list, apdo, pt_ins_tipdo);\n+}\n+void pq_ins(int *t) {\n+  if (pq_ins_tt2)\n+    pt_ins(t, pq_ins_apd);\n+}\n+int gtr_post_hd() {\n+  pq_ins(&gtrphdt);\n+  return 0;\n+}"}, {"sha": "6d1d0d7cd27690695c6f8cd42161350194d5609a", "filename": "gcc/testsuite/gcc.dg/ipa/pr93385.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr93385.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr93385.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr93385.c?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-dce -fno-ipa-cp -fno-tree-dce\" } */\n+\n+char a, b;\n+\n+#ifdef __SIZEOF_INT128__\n+#define T unsigned __int128\n+#else\n+#define T unsigned\n+#endif\n+\n+static inline int\n+c (T d)\n+{\n+  char e = 0;\n+  d %= (unsigned) d;\n+  e -= 0;\n+  __builtin_strncpy (&a, &e, 1);\n+  return e + b;\n+}\n+\n+int\n+main (void)\n+{\n+  c (~0);\n+  return 0;\n+}"}, {"sha": "f605e763f4a611d6df4292ad19bdc411069aec32", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2902991a6b61d473f7cb996a2b80eef4a90f8eda/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=2902991a6b61d473f7cb996a2b80eef4a90f8eda", "patch": "@@ -1526,6 +1526,11 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t  : !opt_for_fn (id->dst_fn, flag_var_tracking_assignments)))\n     return NULL;\n \n+  if (!is_gimple_debug (stmt)\n+      && id->param_body_adjs\n+      && id->param_body_adjs->m_dead_stmts.contains (stmt))\n+    return NULL;\n+\n   /* Begin by recognizing trees that we'll completely rewrite for the\n      inlining context.  Our output for these trees is completely\n      different from our input (e.g. RETURN_EXPR is deleted and morphs\n@@ -1790,10 +1795,15 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \n       if (gimple_debug_bind_p (stmt))\n \t{\n+\t  tree value;\n+\t  if (id->param_body_adjs\n+\t      && id->param_body_adjs->m_dead_stmts.contains (stmt))\n+\t    value = NULL_TREE;\n+\t  else\n+\t    value = gimple_debug_bind_get_value (stmt);\n \t  gdebug *copy\n \t    = gimple_build_debug_bind (gimple_debug_bind_get_var (stmt),\n-\t\t\t\t       gimple_debug_bind_get_value (stmt),\n-\t\t\t\t       stmt);\n+\t\t\t\t       value, stmt);\n \t  if (id->reset_location)\n \t    gimple_set_location (copy, input_location);\n \t  id->debug_stmts.safe_push (copy);\n@@ -2675,7 +2685,9 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n       phi = si.phi ();\n       res = PHI_RESULT (phi);\n       new_res = res;\n-      if (!virtual_operand_p (res))\n+      if (!virtual_operand_p (res)\n+\t  && (!id->param_body_adjs\n+\t      || !id->param_body_adjs->m_dead_stmts.contains (phi)))\n \t{\n \t  walk_tree (&new_res, copy_tree_body_r, id, NULL);\n \t  if (EDGE_COUNT (new_bb->preds) == 0)"}]}