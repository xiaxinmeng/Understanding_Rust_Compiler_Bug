{"sha": "d3ae8277eb0e9bf19536a1b0916c23bb55edbc59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhZTgyNzdlYjBlOWJmMTk1MzZhMWIwOTE2YzIzYmI1NWVkYmM1OQ==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-04-20T19:17:23Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-04-20T19:17:23Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r7101", "tree": {"sha": "e21c7815a7e9c557867ba26fa464b38ad8edabad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e21c7815a7e9c557867ba26fa464b38ad8edabad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59/comments", "author": null, "committer": null, "parents": [{"sha": "6fcc9690b3dad9ecb8fd7233e96308342d9cdf5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fcc9690b3dad9ecb8fd7233e96308342d9cdf5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fcc9690b3dad9ecb8fd7233e96308342d9cdf5e"}], "stats": {"total": 435, "additions": 308, "deletions": 127}, "files": [{"sha": "5999f8a0137c53a9d8b78da675a924bc9b496235", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 247, "deletions": 92, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=d3ae8277eb0e9bf19536a1b0916c23bb55edbc59", "patch": "@@ -95,13 +95,13 @@ enum reg_class reg_class_from_letter[] =\n #define REG_ODD \\\n  (  (1 << (int) QImode)  | (1 << (int) HImode) | (1 << (int) SImode)\t\\\n   | (1 << (int) QFmode)  | (1 << (int) HFmode) | (1 << (int) SFmode)\t\\\n-  | (1 << (int) CQImode) | (1 << (int) CHImode))\n+  | (1 << (int) CQImode) | (1 << (int) CHImode)| (1<< (int)DFmode) | (1<<(int)DImode))\n \n #define REG_EVEN \\\n-  (REG_ODD | (1 << (int) DImode) | (1 << (int) DFmode)\t\\\n-           | (1 << (int) CSImode) | (1 << (int) SCmode))\n+  (REG_ODD | (1 << (int) CSImode) | (1 << (int) SCmode))\n \n #define SI_ONLY (1<<(int)SImode)\n+\n int hard_regno_mode_ok[] =\n {\n   REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n@@ -327,6 +327,7 @@ print_operand_address (stream, x)\n    '^'  increment the local label number\n    '!'  dump the constant table\n    '#'  output a nop if there is nothing to put in the delay slot\n+   '@'  print rte or rts depending upon pragma interruptness\n    'R'  print the next register or memory location along, ie the lsw in\n    a double word value\n    'O'  print a constant without the #\n@@ -351,11 +352,17 @@ print_operand (stream, x, code)\n     case '^':\n       lf++;\n       break;\n+    case '@':\n+      if (pragma_interrupt)\n+\tfprintf (stream,\"rte\");\n+      else\n+\tfprintf (stream,\"rts\");\n+      break;\n     case '#':\n       /* Output a nop if there's nothing in the delay slot */\n       if (dbr_sequence_length () == 0)\n \t{\n-\t  fprintf (stream, \"\\n\\tor\tr0,r0\\t!wasted slot\");\n+\t  fprintf (stream, \"\\n\\tnop\");\n \t}\n       break;\n     case 'O':\n@@ -445,10 +452,22 @@ synth_constant (operands, mode)\n   rtx dst;\n   int i = INTVAL (operands[1]) & 0xffffffff;\n \n-  if (CONST_OK_FOR_I (i))\n+  if (CONST_OK_FOR_I (i)) \n     return 0;\n \n-  dst = mode == SImode ? operands[0] : gen_reg_rtx (SImode);\n+  if (TARGET_CLEN0 && mode != QImode)\n+    return 0;\n+\n+  if (mode != SImode)\n+    {\n+      if (reload_in_progress) \n+\treturn 0;\n+      dst = gen_reg_rtx (SImode);\n+    }\n+  else \n+    {\n+      dst = operands[0];\n+    }\n \n   /*  00000000 00000000 11111111 1NNNNNNNN load and zero extend word      */\n   if ((i & 0xffffff80) == 0x0000ff80)\n@@ -531,10 +550,16 @@ expand_block_move (operands)\n   int constp = (GET_CODE (operands[2]) == CONST_INT);\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n   enum machine_mode mode;\n+\n   /* IF odd then fail */\n   if (!constp || bytes <= 0)\n     return 0;\n \n+  /* Don't expand if we'd make the code bigger and we don't want big code */\n+\n+  if (bytes > 8 && TARGET_SMALLCODE)\n+    return 0;\n+\n   switch (align)\n     {\n     case 1:\n@@ -547,6 +572,7 @@ expand_block_move (operands)\n       mode = SImode;\n       align = 4;\n     }\n+\n   if (mode == SImode && constp && bytes < 64 && (bytes % 4 == 0))\n     {\n       char entry[30];\n@@ -623,8 +649,8 @@ expand_block_move (operands)\n \treturn 1;\n       }\n     }\n-  return 0;\n \n+  return 0;\n }\n \n /* Prepare operands for a move define_expand; specifically, one of the\n@@ -669,7 +695,6 @@ prepare_move_operands (operands, mode)\n \t  REGNO (dst) >= FIRST_PSEUDO_REGISTER)\n \treturn 0;\n \n-\n       if (push_operand (dst, mode))\n \treturn 0;\n \n@@ -711,56 +736,6 @@ prepare_move_operands (operands, mode)\n   return 0;\n }\n \n-/* Work out the subword parts to split up a double move\n-   into two SI moves - take care to do it in the right order\n- */\n-\n-int\n-prepare_split_double_ops (operands, mode)\n-     rtx operands[];\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (operands[1]) == REG\n-      && REGNO (operands[1]) > FIRST_PSEUDO_REGISTER)\n-    return 0;\n-\n-  if (GET_CODE (operands[0]) == REG\n-      && REGNO (operands[0]) > FIRST_PSEUDO_REGISTER)\n-    return 0;\n-\n-  /* If we split move insns from memory, it confuses scheduling\n-     later on. */\n-  if (GET_CODE (operands[1]) == MEM)\n-    return 0;\n-  if (GET_CODE (operands[0]) == MEM)\n-    return 0;\n-\n-  if (GET_CODE (operands[0]) != REG\n-      || !refers_to_regno_p (REGNO (operands[0]),\n-\t\t\t     REGNO (operands[0]) + 1, operands[1], 0))\n-    {\n-      operands[2] = operand_subword (operands[0], 0, 0, mode);\n-      operands[3] = operand_subword (operands[1], 0, 0, mode);\n-      operands[4] = operand_subword (operands[0], 1, 0, mode);\n-      operands[5] = operand_subword (operands[1], 1, 0, mode);\n-    }\n-  else\n-    {\n-      operands[2] = operand_subword (operands[0], 1, 0, mode);\n-      operands[3] = operand_subword (operands[1], 1, 0, mode);\n-      operands[4] = operand_subword (operands[0], 0, 0, mode);\n-      operands[5] = operand_subword (operands[1], 0, 0, mode);\n-    }\n-\n-  if (operands[2] == 0 || operands[3] == 0\n-      || operands[4] == 0 || operands[5] == 0)\n-    return 0;\n-\n-  emit_move_insn (operands[2], operands[3]);\n-  emit_move_insn (operands[4], operands[5]);\n-  return 1;\n-}\n-\n /* Prepare the operands for an scc instruction; make sure that the\n    compare has been done.  */\n rtx\n@@ -824,8 +799,8 @@ output_movedouble (insn, operands, mode)\n   rtx dst = operands[0];\n   rtx src = operands[1];\n \n-  fprintf (asm_out_file, \"! move double \\n\");\n-  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);\n+/*   fprintf (asm_out_file, \"! move double \\n\");\n+  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);*/\n   if (GET_CODE (dst) == MEM\n       && GET_CODE (XEXP (dst, 0)) == POST_INC)\n     {\n@@ -1022,8 +997,7 @@ function_epilogue (stream, size)\n      FILE *stream;\n      int size;\n {\n-  fprintf (stream, \"\\trts\\n\");\n-  fprintf (stream, \"\\tor\tr0,r0\\n\");\n+  pragma_interrupt = pragma_trapa = 0;\n }\n \n \n@@ -1085,8 +1059,8 @@ output_far_jump (insn, op)\n       output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n     }\n \n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (thislab));\n   output_asm_insn (\".align\t2\", 0);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (thislab));\n   output_asm_insn (\".long\t%O0\", &op);\n   return \"\";\n }\n@@ -1100,7 +1074,7 @@ output_branch (logic, insn)\n   int label = lf++;\n   int rn = -1;\n   int need_save;\n-  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);\n+/*  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);*/\n \n   switch (get_attr_length (insn))\n     {\n@@ -1391,7 +1365,7 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n   data_section ();\n \n \n-  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) arguments:\", version_string);\n+  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) (release D-1) arguments:\", version_string);\n   output_options (file, f_options, f_len, W_options, W_len,\n \t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n }\n@@ -1416,7 +1390,7 @@ shiftcosts (RTX)\n   /* otherwise it will be several insns, but we pretend that it will be more than\n      just the components, so that combine doesn't glue together a load of shifts into\n      one shift which has to be emitted as a bunch anyway - breaking scheduling */\n-  return 100;\n+  return 1;\n }\n \n int \n@@ -1435,19 +1409,73 @@ andcosts (RTX)\n     return 3;\n   return 5;\n }\n+\n+int howshift (i)\n+int i;\n+{\n+  int total = 0;\n+  while (i > 0)\n+    {\n+      if (i >= 16) {\n+\ttotal++;\n+\ti -= 16;\n+      }\n+      else if (i >= 8) {\n+\ttotal++;\n+\ti -= 8;\n+      }\n+      else if (i >= 2) {\n+\ttotal++;\n+\ti -= 2;\n+      }\n+      else if (i>=1) {\n+\ttotal++;\n+\ti--;\n+      }\n+    }\n+  return total;\n+}\n+\n /* Return the cost of a multiply */\n int\n multcosts (RTX)\n      rtx RTX;\n {\n+  /* If mult by a power of 2 then work out how we'd shift to make it */\n+  int insn_cost;\n+  \n+  if (GET_CODE (XEXP (RTX, 1)) == CONST_INT)\n+    {\n+      int i = exact_log2 (INTVAL (XEXP (RTX, 1)));\n+      if (i >= 0) \n+\tinsn_cost = howshift (i);\n+      else \n+\tinsn_cost = 100000;\n+    }\n   if (TARGET_SH2)\n-    return 2;\n+    {\n+      /* We have a mul insn, so we can never take more than the mul and the\n+\t read of the mac reg, but count more because of the latency and extra reg\n+\t usage */\n+      if (TARGET_SMALLCODE)\n+\t  return 2;\n+      if (insn_cost > 5)\n+\treturn 5;\n+      return insn_cost;\n+    }\n+\n   /* If we we're aiming at small code, then just count the number of\n-     insns in a multiply call sequence, otherwise, count all the insnsn\n-     inside the call. */\n-  if (TARGET_SMALLCODE)\n-    return 3;\n-  return 30;\n+     insns in a multiply call sequence */\n+\n+  if (TARGET_SMALLCODE) \n+    {\n+      if (insn_cost > 6)\n+\treturn 6;\n+      return insn_cost;\n+    }\n+\n+  /* Otherwise count all the insns in the routine we'd be calling too */\n+  return 20;\n }\n \n /* Code to expand a shift */\n@@ -1498,7 +1526,7 @@ gen_shifty_op (code, operands)\n \t    }\n \n \t  /* Expand a short sequence inline, longer call a magic routine */\n-\t  if (value < 4)\n+\t  if (value <= 5)\n \t    {\n \t      emit_move_insn (wrk, operands[1]);\n \t      while (value--)\n@@ -1621,7 +1649,6 @@ dump_table (scan)\n     }\n   need_align = 1;\n \n-\n   for (i = 0; i < pool_size; i++)\n     {\n       pool_node *p = pool_vector + i;\n@@ -1634,6 +1661,7 @@ dump_table (scan)\n \t  if (need_align)\n \t    {\n \t      need_align = 0;\n+\t      scan = emit_label_after (gen_label_rtx (), scan);\n \t      scan = emit_insn_after (gen_align_4 (), scan);\n \t    }\n \t  scan = emit_label_after (p->label, scan);\n@@ -1643,6 +1671,7 @@ dump_table (scan)\n \t  if (need_align)\n \t    {\n \t      need_align = 0;\n+\t      scan = emit_label_after (gen_label_rtx (), scan);\n \t      scan = emit_insn_after (gen_align_4 (), scan);\n \t    }\n \t  scan = emit_label_after (p->label, scan);\n@@ -1694,6 +1723,15 @@ int\n hi_const (src)\n      rtx src;\n {\n+  if (GET_CODE (src) == CONST\n+      && GET_CODE (XEXP (src, 0)) == SIGN_EXTEND\n+      && GET_CODE (XEXP (XEXP (src, 0), 0)) == SYMBOL_REF)\n+    return 1;\n+\n+  if (TARGET_SHORTADDR\n+      && GET_CODE (src) == SYMBOL_REF)\n+    return 1;\n+\n   return (GET_CODE (src) == CONST_INT\n \t  && INTVAL (src) >= -32768\n \t  && INTVAL (src) <= 32767);\n@@ -1826,6 +1864,8 @@ machine_dependent_reorg (first)\n \t\t    {\n \t\t      /* This is an HI source, clobber the dest to get the mode right too */\n \t\t      mode = HImode;\n+\t\t      while (GET_CODE (dst) == SUBREG)\n+\t\t\tdst = SUBREG_REG (dst);\n \t\t      dst = gen_rtx (REG, HImode, REGNO (dst));\n \t\t    }\n \t\t  lab = add_constant (src, mode);\n@@ -1860,9 +1900,15 @@ from_compare (operands, code)\n      rtx *operands;\n      int code;\n {\n+  if (code != EQ && code != NE)\n+    {\n+      /* Force args into regs, since we can't use constants here */\n+      sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n+      if (sh_compare_op1 != const0_rtx)\n+\tsh_compare_op1 = force_reg (SImode, sh_compare_op1);\t\n+    }\n   operands[1] = sh_compare_op0;\n-  operands[2] = force_reg (SImode, sh_compare_op1);\n-  operands[1] = force_reg (SImode, operands[1]);\n+  operands[2] = sh_compare_op1;\n }\n \n /* Non-zero if x is EQ or NE */\n@@ -1973,6 +2019,7 @@ sh_expand_epilogue ()\n   current_function_anonymous_args = 0;\n   for (i = 0; i < 32; i++)\n     shiftsyms[i] = 0;\n+\n }\n \n /* Define the offset between two registers, one to be eliminated, and\n@@ -2041,7 +2088,8 @@ handle_pragma (file)\n \f\n /* insn expand helpers */\n \n-/* Emit insns to perform a call.  If TARGET_SMALLCALL, then load the\n+/* Emit insns to perform a call. \n+   If TARGET_SHORTADDR then use a bsr. If TARGET_SMALLCALL, then load the\n    target address into r1 and call __saveargs, otherwise\n    perform the standard call sequence */\n \n@@ -2055,23 +2103,29 @@ expand_acall (isa_retval, operands)\n   rtx call_target = operands[isa_retval + 0];\n   rtx numargs = operands[isa_retval + 1];\n \n-  if (GET_CODE (call_target) == MEM)\n-    {\n-      call_target = force_reg (Pmode,\n-\t\t\t       XEXP (call_target, 0));\n-    }\n-  if (TARGET_SMALLCALL)\n+  if (TARGET_BSR)\n     {\n-      rtx tmp = gen_reg_rtx (SImode);\n-      rtx r1 = gen_rtx (REG, SImode, 1);\n-      emit_move_insn (tmp, gen_rtx (SYMBOL_REF, SImode, \"__saveargs\"));\n-      emit_move_insn (r1, call_target);\n-      emit_insn (gen_rtx (USE, VOIDmode, r1));\n-      call_target = tmp;\n+      call = gen_rtx (CALL, VOIDmode, call_target, numargs);\n     }\n+  else {\n \n-  call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n+    if (GET_CODE (call_target) == MEM)\n+      {\n+\tcall_target = force_reg (Pmode,\n+\t\t\t\t XEXP (call_target, 0));\n+      }\n+    if (TARGET_SMALLCALL)\n+      {\n+\trtx tmp = gen_reg_rtx (SImode);\n+\trtx r1 = gen_rtx (REG, SImode, 1);\n+\temit_move_insn (tmp, gen_rtx (SYMBOL_REF, SImode, \"__saveargs\"));\n+\temit_move_insn (r1, call_target);\n+\temit_insn (gen_rtx (USE, VOIDmode, r1));\n+\tcall_target = tmp;\n+      }\n \n+    call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n+  }\n   if (isa_retval)\n     {\n       call = gen_rtx (SET, VOIDmode, ret, call);\n@@ -2080,7 +2134,7 @@ expand_acall (isa_retval, operands)\n   emit_call_insn (gen_rtx (PARALLEL, VOIDmode,\n \t\t\t   gen_rtvec (2,\n \t\t\t\t      call,\n-\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 17)))));\n+\t\t\t\t      gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 17)))));\n \n }\n \f\n@@ -2132,12 +2186,28 @@ general_movdst_operand (op, mode)\n      enum machine_mode mode;\n {\n   if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == PRE_INC)\n+      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t  || GET_CODE (XEXP (op, 0)) == POST_INC\n+\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n     return 0;\n+\n   return general_operand (op, mode);\n }\n \n \n+\n+/* Returns 1 if OP is valid destination for a bsr.  */\n+\n+int\n+bsr_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return 1;\n+  return 0;\n+}\n+\n /* Returns 1 if OP is an immediate ok for a byte index.  */\n \n int\n@@ -2247,3 +2317,88 @@ logical_operand (op, mode)\n   return 0;\n }\n \n+/* Returns 1 if OP is a valid operand for a MAC instruction,\n+   either a register or indirect memory.  For now we don't\n+   try and recognise a mac insn */\n+\n+int\n+mac_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (arith_reg_operand (op, mode))\n+    return 1;\n+#if 0\n+  Turned off till mac is understood \n+  if (GET_CODE (op) == MEM)\n+    return 1;\n+#endif\n+  return 0;\n+}\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+rtx \n+sh_function_arg (cum, mode, type, named)\n+CUMULATIVE_ARGS cum;\n+enum machine_mode mode;\n+tree type;\n+int named;\n+{\n+  if (named)\n+    {\n+      int rr =  (ROUND_REG ((cum), (mode)));\n+\n+      if (rr < NPARM_REGS)\n+\t{\n+\t  return ((((mode) != BLKmode \t\t\t\t\t\n+\t\t    && ((type)==0 || ! TREE_ADDRESSABLE ((tree)(type)))\t\n+\t\t    && ((type)==0 || (mode) != BLKmode\t\t\t\n+\t\t\t|| (TYPE_ALIGN ((type)) % PARM_BOUNDARY == 0))\t\n+\t\t    ? gen_rtx (REG, (mode),\t\t\t\t\n+\t\t\t       (FIRST_PARM_REG + rr)): 0)));\n+\n+\t}\t\t\n+    }\n+  return 0;\n+}\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.\n+   Any arg that starts in the first 4 regs but won't entirely fit in them\n+   needs partial registers on the SH.  */\n+\n+int\n+sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n+     CUMULATIVE_ARGS CUM;\n+     enum machine_mode MODE;\n+     tree TYPE;\n+     int NAMED;\n+{\n+  if ((CUM) < NPARM_REGS)\t\t\t\t\t\t\t\n+    {\n+      if (((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\n+\t  && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\n+\t      || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\n+\t  && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\n+\t\t       ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\n+\t\t       : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0))\n+\t{\n+\t  return NPARM_REGS - CUM;\n+\t}\n+    }\n+  return 0;\n+}\n+"}, {"sha": "23259cbfac74cfa265e5e87c6edae350c1e9b697", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 61, "deletions": 35, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ae8277eb0e9bf19536a1b0916c23bb55edbc59/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=d3ae8277eb0e9bf19536a1b0916c23bb55edbc59", "patch": "@@ -78,6 +78,11 @@ extern int target_flags;\n #define CONSTLEN_2_BIT  (1<<20)\n #define CONSTLEN_3_BIT  (1<<21)\n #define HITACHI_BIT     (1<<22)\n+#define PARANOID_BIT    (1<<23)\n+#define RETR2_BIT       (1<<24)\n+#define CONSTLEN_0_BIT  (1<<25)\n+#define BSR_BIT   \t(1<<26)\n+#define SHORTADDR_BIT   (1<<27)\n \n /* Nonzero if we should generate code using type 0 insns */\n #define TARGET_SH0 (target_flags & SH0_BIT)\n@@ -131,8 +136,16 @@ extern int target_flags;\n /* Select max size of computed constant code sequences to be 3 insns */\n #define TARGET_CLEN3 (target_flags & CONSTLEN_3_BIT)\n \n+/* Select max size of computed constant code sequences to be 0 insns - ie don't do it */\n+#define TARGET_CLEN0 (target_flags & CONSTLEN_0_BIT)\n+\n /* Nonzero if using Hitachi's calling convention */\n-#define TARGET_HITACHI (target_flags & HITACHI_BIT)\n+#define TARGET_HITACHI \t\t(target_flags & HITACHI_BIT)\n+#define TARGET_PARANOID \t(target_flags & PARANOID_BIT)\n+#define TARGET_RETR2 \t\t(target_flags & RETR2_BIT)\n+#define TARGET_SHORTADDR\t(target_flags & SHORTADDR_BIT)\n+#define TARGET_BSR\t\t(target_flags & BSR_BIT)\n+\n \n #define TARGET_SWITCHES  \t\t\\\n { {\"isize\", \t( ISIZE_BIT) },\t\t\\\n@@ -150,8 +163,13 @@ extern int target_flags;\n   {\"R\",  \t( R_BIT) },\t\t\\\n   {\"nosave\",  \t( NOSAVE_BIT) },\t\\\n   {\"clen3\",     ( CONSTLEN_3_BIT) },    \\\n+  {\"clen0\",     ( CONSTLEN_0_BIT) },    \\\n   {\"smallcall\",\t( SMALLCALL_BIT) },\t\\\n   {\"hitachi\",\t( HITACHI_BIT) },\t\\\n+  {\"paranoid\",\t( PARANOID_BIT) },\t\\\n+  {\"r2\",\t( RETR2_BIT) },\t\t\\\n+  {\"shortaddr\", ( SHORTADDR_BIT) },     \\\n+  {\"bsr\",       ( BSR_BIT) },    \t\\\n   {\"\",   \tTARGET_DEFAULT} \t\\\n }\n \n@@ -177,7 +195,10 @@ do {\t\t\t\t\t\t\t\t\\\n                                                                 \\\n   optimize = 1;                                                 \\\n   flag_delayed_branch = 1;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n+  /* But never run scheduling before reload, since than can     \\\n+     break global alloc, and generates slower code anyway due   \\\n+     to the pressure on R0. */                                  \\\n+  flag_schedule_insns = 0;            \t\t\t\t\\\n   if (max_si)\t\t\t\t\t\t\t\\\n     max_count_si = atoi (max_si);\t\t\t\t\\\n   else                                                          \\\n@@ -186,6 +207,8 @@ do {\t\t\t\t\t\t\t\t\\\n     max_count_hi = atoi (max_hi);\t\t\t\t\\\n   else      \t\t\t\t\t\t\t\\\n     max_count_hi = 505;\t\t\t\t                \\\n+  if (TARGET_BSR)                                               \\\n+     flag_no_function_cse = 1;                                  \\\n } while (0)\n \n \f\n@@ -296,7 +319,10 @@ do {\t\t\t\t\t\t\t\t\\\n #define FIRST_PSEUDO_REGISTER 22\n \n /* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.  */\n+   and are not available for the register allocator. \n+\n+   mach register is fixed 'cause it's only 10 bits wide */\n+\n  /*  r0  r1  r2  r3 \n      r4  r5  r6  r7\n      r8  r9  r10 r11\n@@ -312,6 +338,7 @@ do {\t\t\t\t\t\t\t\t\\\n     1,  1,  1,  1, \t\t\\\n     1,  1}\n \n+\n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n@@ -591,7 +618,7 @@ extern enum reg_class reg_class_from_letter[];\n    These two macros are used only in other macro definitions below.  */\n #define NPARM_REGS 4\n #define FIRST_PARM_REG 4\n-#define FIRST_RET_REG 0\n+#define FIRST_RET_REG  (TARGET_RETR2 ? 2 : 0)\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n@@ -671,7 +698,8 @@ extern enum reg_class reg_class_from_letter[];\n /* Round a register number up to a proper boundary for an arg of mode \n    MODE. \n    \n-   We round to an even reg for things larger than a word */\n+   The SH doesn't care about double alignment, so we only\n+   round doubles to even regs when asked to explicitly. */\n \n #define ROUND_REG(X, MODE) \t\t\t\t\t\\\n   ((TARGET_ALIGN_DOUBLE \t\t\t\t\t\\\n@@ -718,23 +746,20 @@ extern enum reg_class reg_class_from_letter[];\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  (NAMED && ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\\\n-   && (MODE) != BLKmode \t\t\t\t\t\\\n-   && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n-   && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\\\n-       || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\\\n-   ? gen_rtx (REG, (MODE),\t\t\t\t\t\\\n-  \t    (FIRST_PARM_REG + ROUND_REG ((CUM), (MODE))))\t\\\n-   : 0)\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+    sh_function_arg (CUM, MODE, TYPE, NAMED)\n+\n+extern struct rtx_def *sh_function_arg();\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.\n    \n-   We never split args */\n+   We sometimes split args */\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n \n extern int current_function_anonymous_args;\n \n@@ -809,10 +834,10 @@ extern int current_function_anonymous_args;\n \n \f\n /* Addressing modes, and classification of registers for them.  */\n-/*#define HAVE_POST_INCREMENT  1*/\n+#define HAVE_POST_INCREMENT  1\n /*#define HAVE_PRE_INCREMENT   1*/\n /*#define HAVE_POST_DECREMENT  1*/\n-/*#define HAVE_PRE_DECREMENT   1*/\n+#define HAVE_PRE_DECREMENT   1\n \n /* Macros to check register numbers against specific register classes.  */\n \n@@ -853,6 +878,7 @@ extern int current_function_anonymous_args;\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n \n #define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64))\n+#define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60))\n #define MODE_DISP_OK_2(X,MODE) ((GET_MODE_SIZE(MODE)==2) && ((unsigned)INTVAL(X)<32) && TARGET_TRYR0)\n #define MODE_DISP_OK_1(X,MODE) ((GET_MODE_SIZE(MODE)==1) && ((unsigned)INTVAL(X)<16) && TARGET_TRYR0)\n \n@@ -870,7 +896,7 @@ extern int current_function_anonymous_args;\n   (REGNO (X) == 0 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n \n #define REG_OK_FOR_PRE_POST_P(X) \\\n-  \t(REGNO (X) <= 16)\n+  \t(REG_OK_FOR_INDEX_P (X))\n \n #else\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n@@ -882,7 +908,7 @@ extern int current_function_anonymous_args;\n   \tREGNO_OK_FOR_INDEX_P (REGNO (X))\n \n #define REG_OK_FOR_PRE_POST_P(X)  \\\n-\t(REGNO (X) <= 16)\n+\t(REGNO_OK_FOR_INDEX_P (REGNO (X)))\n #endif\n \n /* The Q is a pc relative load operand */\n@@ -943,6 +969,7 @@ extern int current_function_anonymous_args;\n     if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tif (MODE_DISP_OK_4 (OP, MODE))  goto LABEL;\t\t      \t\\\n+\tif (MODE_DISP_OK_8 (OP, MODE))  goto LABEL;\t\t      \t\\\n \tif (MODE_DISP_OK_2 (OP, MODE))  goto LABEL;\t\t      \t\\\n \tif (MODE_DISP_OK_1 (OP, MODE))  goto LABEL;\t\t      \t\\\n       }\t\t\t\t\t\t\t\t\t\\\n@@ -961,11 +988,11 @@ extern int current_function_anonymous_args;\n     {\t\t\t\t\t\t\t\t  \\\n       rtx xop0 = XEXP(X,0);\t\t\t\t\t  \\\n       rtx xop1 = XEXP(X,1);\t\t\t\t\t  \\\n-      if (GET_MODE_SIZE(MODE) <= 4 && BASE_REGISTER_RTX_P (xop0)) \\\n+      if (GET_MODE_SIZE(MODE) <= 8 && BASE_REGISTER_RTX_P (xop0)) \\\n \tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL); \\\n-      if (GET_MODE_SIZE(MODE) <= 4 && BASE_REGISTER_RTX_P (xop1)) \\\n+      if (GET_MODE_SIZE(MODE) <= 8 && BASE_REGISTER_RTX_P (xop1)) \\\n \tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL); \\\n-      if (GET_MODE_SIZE(MODE)<=4) {\t\t\t\t  \\\n+      if (GET_MODE_SIZE(MODE)<= 4) {\t\t\t\t  \\\n \tif(BASE_REGISTER_RTX_P(xop1) &&\t\t\t \t  \\\n \t   INDEX_REGISTER_RTX_P(xop0)) goto LABEL;\t\t  \\\n \tif(INDEX_REGISTER_RTX_P(xop1) &&\t\t\t  \\\n@@ -992,9 +1019,9 @@ extern int current_function_anonymous_args;\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.\n \n-   On the SH we don't try anything */\n+  */\n \n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  ;\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) ;\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n@@ -1102,7 +1129,6 @@ extern int current_function_anonymous_args;\n     return COSTS_N_INSNS (multcosts (X));\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\\\n     return COSTS_N_INSNS (shiftcosts (X)) ;\t\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n@@ -1174,13 +1200,6 @@ extern int current_function_anonymous_args;\n #define CTORS_SECTION_ASM_OP \t\"\\t.section\\t.ctors\\n\"\n #define DTORS_SECTION_ASM_OP \t\"\\t.section\\t.dtors\\n\"\n #define INIT_SECTION_ASM_OP  \t\"\\t.section\\t.init\\n\"\n-\n-/* Assemble generic sections.\n-   This is currently only used to support section attributes.  */\n-\n-#define ASM_OUTPUT_SECTION_NAME(FILE, NAME) \\\n-   fprintf (FILE, \".section\\t%s\\n\", NAME)\n-\n #define EXTRA_SECTIONS \t\tin_ctors, in_dtors\n \n #define EXTRA_SECTION_FUNCTIONS                              \\\n@@ -1203,6 +1222,12 @@ dtors_section() \t\t\t\t\t     \\\n     }\t\t\t\t\t\t\t     \\\n }\t\t\t\t\t\t\t      \n \n+/* Assemble generic sections.\n+   This is currently only used to support section attributes.  */\n+\n+#define ASM_OUTPUT_SECTION_NAME(FILE, NAME) \\\n+   do { fprintf (FILE, \".section\\t%s\\n\", NAME); } while (0)\n+\n #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n    do { ctors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n \n@@ -1410,14 +1435,15 @@ do { char dstr[30];\t\t\t\t\t\\\n #define PRINT_OPERAND_ADDRESS(STREAM,X)  print_operand_address (STREAM, X)\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR)=='!')\n+  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR)=='!' || (CHAR)=='@')\n \n \f\n extern struct rtx_def *sh_compare_op0;\n extern struct rtx_def *sh_compare_op1;\n extern struct rtx_def *prepare_scc_operands();\n extern struct rtx_def *table_lab;\n \n+\n extern enum attr_cpu sh_cpu;\t/* target cpu */\n \n /* Declare functions defined in sh.c and used in templates. */\n@@ -1441,7 +1467,7 @@ extern char *output_far_jump();\n /* Set when processing a function with pragma interrupt turned on. */\n \n extern int pragma_interrupt;\n-#define MOVE_RATIO 16\n+#define MOVE_RATIO (TARGET_SMALLCODE ? 4 : 16)\n \n char *max_si;\n char *max_hi;"}]}