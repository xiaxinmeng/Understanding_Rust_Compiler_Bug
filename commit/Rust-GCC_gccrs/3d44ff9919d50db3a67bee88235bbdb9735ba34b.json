{"sha": "3d44ff9919d50db3a67bee88235bbdb9735ba34b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q0NGZmOTkxOWQ1MGRiM2E2N2JlZTg4MjM1YmJkYjk3MzViYTM0Yg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2015-07-24T11:28:06Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2015-07-24T11:28:06Z"}, "message": "[PATCH] S/390: Improve risbg usage\n\ngcc/ChangeLog:\n\n2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t    * config/s390/s390.c (s390_rtx_costs): Make risbg patterns\n\t    cheaper.\n\t    (s390_expand_insv): Don't generate risbg pattern for constant zero\n\t    sources.\n\t    * config/s390/s390.md (\"*insv<mode>_zEC12_appendbitsleft\")\n\t    (\"*insv<mode>_z10_appendbitsleft\"): New pattern definitions.  New\n\t    splitters.\n\ngcc/testsuite/ChangeLog:\n\n2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t    * gcc.target/s390/insv-1.c: New test.\n\t    * gcc.target/s390/insv-2.c: New test.\n\t    * gcc.target/s390/insv-3.c: New test.\n\nFrom-SVN: r226148", "tree": {"sha": "ebb22a10af14a6b8498dfe67c1ae6abb2122c957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebb22a10af14a6b8498dfe67c1ae6abb2122c957"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d44ff9919d50db3a67bee88235bbdb9735ba34b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d44ff9919d50db3a67bee88235bbdb9735ba34b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d44ff9919d50db3a67bee88235bbdb9735ba34b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d44ff9919d50db3a67bee88235bbdb9735ba34b/comments", "author": null, "committer": null, "parents": [{"sha": "bacf8ec3dff179036cbf31719087926e9036d898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bacf8ec3dff179036cbf31719087926e9036d898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bacf8ec3dff179036cbf31719087926e9036d898"}], "stats": {"total": 349, "additions": 346, "deletions": 3}, "files": [{"sha": "f375a3a594319a2554623e89c038b3c7dcebea6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -1,3 +1,13 @@\n+2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_rtx_costs): Make risbg patterns\n+\tcheaper.\n+\t(s390_expand_insv): Don't generate risbg pattern for constant zero\n+\tsources.\n+\t* config/s390/s390.md (\"*insv<mode>_zEC12_appendbitsleft\")\n+\t(\"*insv<mode>_z10_appendbitsleft\"): New pattern definitions.  New\n+\tsplitters.\n+\n 2015-07-24  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* config/s390/s390.c (s390_reorg): Clean up handling of processors"}, {"sha": "f421e884c66594a3f961b0aae408a4293af11ec8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -3321,13 +3321,26 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       *total = 0;\n       return true;\n \n+    case IOR:\n+      /* risbg */\n+      if (GET_CODE (XEXP (x, 0)) == AND\n+\t  && GET_CODE (XEXP (x, 1)) == ASHIFT\n+\t  && REG_P (XEXP (XEXP (x, 0), 0))\n+\t  && REG_P (XEXP (XEXP (x, 1), 0))\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+\t  && CONST_INT_P (XEXP (XEXP (x, 1), 1))\n+\t  && (UINTVAL (XEXP (XEXP (x, 0), 1)) ==\n+\t      (1UL << UINTVAL (XEXP (XEXP (x, 1), 1))) - 1))\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ROTATE:\n     case ROTATERT:\n     case AND:\n-    case IOR:\n     case XOR:\n     case NEG:\n     case NOT:\n@@ -5839,8 +5852,17 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n \n       if (mode_s == VOIDmode)\n \t{\n-\t  /* Assume const_int etc already in the proper mode.  */\n-\t  src = force_reg (mode, src);\n+\t  /* For constant zero values the representation with AND\n+\t     appears to be folded in more situations than the (set\n+\t     (zero_extract) ...).\n+\t     We only do this when the start and end of the bitfield\n+\t     remain in the same SImode chunk.  That way nihf or nilf\n+\t     can be used.\n+\t     The AND patterns might still generate a risbg for this.  */\n+\t  if (src == const0_rtx && bitpos / 32  == (bitpos + bitsize - 1) / 32)\n+\t    return false;\n+\t  else\n+\t    src = force_reg (mode, src);\n \t}\n       else if (mode_s != mode)\n \t{"}, {"sha": "b23973e4dd0e09448d17e354f21837d671c25c5f", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -3776,6 +3776,71 @@\n   [(set_attr \"op_type\" \"RIE\")\n    (set_attr \"z10prop\" \"z10_super_E1\")])\n \n+; Implement appending Y on the left of S bits of X\n+; x = (y << s) | (x & ((1 << s) - 1))\n+(define_insn \"*insv<mode>_zEC12_appendbitsleft\"\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t  (match_operand:GPR 2 \"immediate_operand\" \"\"))\n+\t\t (ashift:GPR (match_operand:GPR 3 \"nonimmediate_operand\" \"d\")\n+\t\t\t     (match_operand:GPR 4 \"nonzero_shift_count_operand\" \"\"))))]\n+  \"TARGET_ZEC12 && UINTVAL (operands[2]) == (1UL << UINTVAL (operands[4])) - 1\"\n+  \"risbgn\\t%0,%3,64-<bitsize>,64-%4-1,%4\"\n+  [(set_attr \"op_type\" \"RIE\")\n+   (set_attr \"z10prop\" \"z10_super_E1\")])\n+\n+(define_insn \"*insv<mode>_z10_appendbitsleft\"\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t  (match_operand:GPR 2 \"immediate_operand\" \"\"))\n+\t\t (ashift:GPR (match_operand:GPR 3 \"nonimmediate_operand\" \"d\")\n+\t\t\t     (match_operand:GPR 4 \"nonzero_shift_count_operand\" \"\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10 && !TARGET_ZEC12 && UINTVAL (operands[2]) == (1UL << UINTVAL (operands[4])) - 1\"\n+  \"risbg\\t%0,%3,64-<bitsize>,64-%4-1,%4\"\n+  [(set_attr \"op_type\" \"RIE\")\n+   (set_attr \"z10prop\" \"z10_super_E1\")])\n+\n+; z = (x << c) | (y >> d) with (x << c) and (y >> d) not overlapping after shifting\n+;  -> z = y >> d; z = (x << c) | (z & ((1 << c) - 1))\n+;  -> z = y >> d; z = risbg;\n+\n+(define_split\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"\")\n+\t(ior:GPR (lshiftrt:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"\")\n+\t\t\t       (match_operand:GPR 2 \"nonzero_shift_count_operand\" \"\"))\n+\t\t (ashift:GPR (match_operand:GPR 3 \"nonimmediate_operand\" \"\")\n+\t\t\t     (match_operand:GPR 4 \"nonzero_shift_count_operand\" \"\"))))]\n+  \"TARGET_ZEC12 && UINTVAL (operands[2]) + UINTVAL (operands[4]) >= <bitsize>\"\n+  [(set (match_dup 0)\n+\t(lshiftrt:GPR (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(ior:GPR (and:GPR (match_dup 0) (match_dup 5))\n+\t\t (ashift:GPR (match_dup 3) (match_dup 4))))]\n+{\n+  operands[5] = GEN_INT ((1UL << UINTVAL (operands[4])) - 1);\n+})\n+\n+(define_split\n+  [(parallel\n+    [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"\")\n+\t  (ior:GPR (lshiftrt:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"\")\n+\t\t\t\t (match_operand:GPR 2 \"nonzero_shift_count_operand\" \"\"))\n+\t\t   (ashift:GPR (match_operand:GPR 3 \"nonimmediate_operand\" \"\")\n+\t\t\t       (match_operand:GPR 4 \"nonzero_shift_count_operand\" \"\"))))\n+     (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_Z10 && !TARGET_ZEC12 && UINTVAL (operands[2]) + UINTVAL (operands[4]) >= <bitsize>\"\n+  [(set (match_dup 0)\n+\t(lshiftrt:GPR (match_dup 1) (match_dup 2)))\n+   (parallel\n+    [(set (match_dup 0)\n+\t  (ior:GPR (and:GPR (match_dup 0) (match_dup 5))\n+\t\t   (ashift:GPR (match_dup 3) (match_dup 4))))\n+     (clobber (reg:CC CC_REGNUM))])]\n+{\n+  operands[5] = GEN_INT ((1UL << UINTVAL (operands[4])) - 1);\n+})\n+\n (define_insn \"*r<noxa>sbg_<mode>_noshift\"\n   [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d\")\n \t(IXOR:GPR"}, {"sha": "27278a195d6e6bede7a5e809085d4df82c887af7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -1,3 +1,9 @@\n+2015-07-24  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/insv-1.c: New test.\n+\t* gcc.target/s390/insv-2.c: New test.\n+\t* gcc.target/s390/insv-3.c: New test.\n+\n 2015-07-24  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.dg/autopar/uns-outer-4.c: Remove loopfn xfail."}, {"sha": "e6c1b8bc544a101b2c3d47748a40eaf58e3c2fbd", "filename": "gcc/testsuite/gcc.target/s390/insv-1.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-1.c?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -0,0 +1,111 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z10 -mzarch\" } */\n+\n+unsigned long\n+foo1 (unsigned long a, unsigned long b)\n+{\n+  return (a << 5) | (b & (((1UL << 5) - 1)));\n+}\n+\n+/* This generates very different RTX than foo1.  The output reg (r2)\n+   matches the unshifted argument.  So it actually is a\n+   (set (zero_extract a 59 0) b) */\n+unsigned long\n+foo2 (unsigned long a, unsigned long b)\n+{\n+  return (b << 5) | (a & (((1UL << 5) - 1)));\n+}\n+\n+/* risbg cannot be used when less bits are removed with the mask.  */\n+\n+unsigned long\n+foo1b (unsigned long a, unsigned long b)\n+{\n+  return (a << 5) | (b & 1);\n+}\n+\n+unsigned long\n+foo2b (unsigned long a, unsigned long b)\n+{\n+  return (b << 5) | (a & 1);\n+}\n+\n+/* risbg cannot be used when the masked bits would end up in the\n+   result since a real OR is required then.  */\n+unsigned long\n+foo1c (unsigned long a, unsigned long b)\n+{\n+  return (a << 5) | (b & 127);\n+}\n+\n+unsigned long\n+foo2c (unsigned long a, unsigned long b)\n+{\n+  return (b << 5) | (a & 127);\n+}\n+\n+unsigned long\n+foo3 (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (a << 5) | (b >> 59);\n+#else\n+  return (a << 5) | (b >> 27);\n+#endif\n+}\n+\n+unsigned long\n+foo4 (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (b << 5) | (a >> 59);\n+#else\n+  return (b << 5) | (a >> 27);\n+#endif\n+}\n+\n+/* risbg can be used also if there are some bits spared in the middle\n+   of the two chunks.  */\n+unsigned long\n+foo3b (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (a << 6) | (b >> 59);\n+#else\n+  return (a << 6) | (b >> 27);\n+#endif\n+}\n+\n+unsigned long\n+foo4b (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (b << 6) | (a >> 59);\n+#else\n+  return (b << 6) | (a >> 27);\n+#endif\n+}\n+\n+/* One bit of overlap so better don't use risbg.  */\n+\n+unsigned long\n+foo3c (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (a << 4) | (b >> 59);\n+#else\n+  return (a << 4) | (b >> 27);\n+#endif\n+}\n+\n+unsigned long\n+foo4c (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (b << 4) | (a >> 59);\n+#else\n+  return (b << 4) | (a >> 27);\n+#endif\n+}\n+\n+/* { dg-final { scan-assembler-times \"risbg\" 6 } } */"}, {"sha": "2ba6d6c88acb31fe2dc11eca6cdf58cc3f32ff63", "filename": "gcc/testsuite/gcc.target/s390/insv-2.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-2.c?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -0,0 +1,111 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+unsigned long\n+foo1 (unsigned long a, unsigned long b)\n+{\n+  return (a << 5) | (b & (((1UL << 5) - 1)));\n+}\n+\n+/* This generates very different RTX than foo1.  The output reg (r2)\n+   matches the unshifted argument.  So it actually is a\n+   (set (zero_extract a 59 0) b) */\n+unsigned long\n+foo2 (unsigned long a, unsigned long b)\n+{\n+  return (b << 5) | (a & (((1UL << 5) - 1)));\n+}\n+\n+/* risbgn cannot be used when less bits are removed with the mask.  */\n+\n+unsigned long\n+foo1b (unsigned long a, unsigned long b)\n+{\n+  return (a << 5) | (b & 1);\n+}\n+\n+unsigned long\n+foo2b (unsigned long a, unsigned long b)\n+{\n+  return (b << 5) | (a & 1);\n+}\n+\n+/* risbgn cannot be used when the masked bits would end up in the\n+   result since a real OR is required then.  */\n+unsigned long\n+foo1c (unsigned long a, unsigned long b)\n+{\n+  return (a << 5) | (b & 127);\n+}\n+\n+unsigned long\n+foo2c (unsigned long a, unsigned long b)\n+{\n+  return (b << 5) | (a & 127);\n+}\n+\n+unsigned long\n+foo3 (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (a << 5) | (b >> 59);\n+#else\n+  return (a << 5) | (b >> 27);\n+#endif\n+}\n+\n+unsigned long\n+foo4 (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (b << 5) | (a >> 59);\n+#else\n+  return (b << 5) | (a >> 27);\n+#endif\n+}\n+\n+/* risbgn can be used also if there are some bits spared in the middle\n+   of the two chunks.  */\n+unsigned long\n+foo3b (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (a << 6) | (b >> 59);\n+#else\n+  return (a << 6) | (b >> 27);\n+#endif\n+}\n+\n+unsigned long\n+foo4b (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (b << 6) | (a >> 59);\n+#else\n+  return (b << 6) | (a >> 27);\n+#endif\n+}\n+\n+/* One bit of overlap so better don't use risbgn.  */\n+\n+unsigned long\n+foo3c (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (a << 4) | (b >> 59);\n+#else\n+  return (a << 4) | (b >> 27);\n+#endif\n+}\n+\n+unsigned long\n+foo4c (unsigned long a, unsigned long b)\n+{\n+#ifdef __s390x__\n+  return (b << 4) | (a >> 59);\n+#else\n+  return (b << 4) | (a >> 27);\n+#endif\n+}\n+\n+/* { dg-final { scan-assembler-times \"risbgn\" 6 } } */"}, {"sha": "0719750e12be5c4801b664cef6b03ffdb9f9199c", "filename": "gcc/testsuite/gcc.target/s390/insv-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d44ff9919d50db3a67bee88235bbdb9735ba34b/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Finsv-3.c?ref=3d44ff9919d50db3a67bee88235bbdb9735ba34b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z10 -mzarch\" } */\n+\n+/* risbg with z bit would work here but we rather want this to be a shift.  */\n+struct\n+{\n+  int a:31;\n+  int b:1;\n+} s;\n+\n+void\n+foo (int in)\n+{\n+  s.a = in;\n+  s.b = 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"risbg\" } } */"}]}