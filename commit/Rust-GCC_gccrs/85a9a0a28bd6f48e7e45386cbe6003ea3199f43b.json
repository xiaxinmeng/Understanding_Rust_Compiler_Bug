{"sha": "85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVhOWEwYTI4YmQ2ZjQ4ZTdlNDUzODZjYmU2MDAzZWEzMTk5ZjQzYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-06-08T11:10:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-06-08T11:10:29Z"}, "message": "re PR c++/3061 (kde2/artsd miscompilation (part 2))\n\n        PR c++/3061\n        * class.c (build_secondary_vtable): Use assert, rather than an error\n        message.\n        (dfs_fixup_binfo_vtbls): BINFO_VTABLE might be NULL.\n        (dfs_accumulate_vtbl_inits): A lost primary virtual base may\n        be between ORIG_BINFO and RTTI_BINFO, but neither of them.\n        Don't set BINFO_VTABLE for a primary virtual base.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r43006", "tree": {"sha": "ce04acf4b9d514f44b958d698c993174a3d3f80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce04acf4b9d514f44b958d698c993174a3d3f80f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/comments", "author": null, "committer": null, "parents": [{"sha": "6a1447333f0c219f0efb334a463991b2af168572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1447333f0c219f0efb334a463991b2af168572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a1447333f0c219f0efb334a463991b2af168572"}], "stats": {"total": 183, "additions": 125, "deletions": 58}, "files": [{"sha": "1fa95c8aad522435a62a0e4ced5bcc0f4df5ae7a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "patch": "@@ -1,3 +1,14 @@\n+2001-06-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Jason Merrill <jason_merrill@redhat.com>\n+\n+\tPR c++/3061\n+\t* class.c (build_secondary_vtable): Use assert, rather than an error\n+\tmessage.\n+\t(dfs_fixup_binfo_vtbls): BINFO_VTABLE might be NULL.\n+\t(dfs_accumulate_vtbl_inits): A lost primary virtual base may\n+\tbe between ORIG_BINFO and RTTI_BINFO, but neither of them.\n+\tDon't set BINFO_VTABLE for a primary virtual base.\n+\n 2001-06-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (duplicate_decls): Update source position information"}, {"sha": "499053c7db12ad2be69d51b9e753f3e48254ad7d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "patch": "@@ -768,7 +768,7 @@ copy_virtuals (binfo)\n \n   return copies;\n }\n-      \n+\n /* Build the primary virtual function table for TYPE.  If BINFO is\n    non-NULL, build the vtable starting with the initial approximation\n    that it is the same as the one which is the head of the association\n@@ -866,20 +866,8 @@ build_secondary_vtable (binfo, for_type)\n   /* Make fresh virtual list, so we can smash it later.  */\n   BINFO_VIRTUALS (binfo) = copy_virtuals (binfo);\n \n-  if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree binfo1 = binfo_for_vbase (BINFO_TYPE (binfo), for_type);\n-\n-      /* XXX - This should never happen, if it does, the caller should\n-\t ensure that the binfo is from for_type's binfos, not from any\n-\t base type's.  We can remove all this code after a while.  */\n-      if (binfo1 != binfo)\n-\twarning (\"internal inconsistency: binfo offset error for rtti\");\n-\n-      offset = BINFO_OFFSET (binfo1);\n-    }\n-  else\n-    offset = BINFO_OFFSET (binfo);\n+  my_friendly_assert (binfo == CANONICAL_BINFO (binfo, for_type), 20010605);\n+  offset = BINFO_OFFSET (binfo);\n \n   /* In the new ABI, secondary vtables are laid out as part of the\n      same structure as the primary vtable.  */\n@@ -6744,12 +6732,12 @@ dfs_get_primary_binfo (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Returns the binfo for the primary base of BINFO.  Note that in a\n-   complex hierarchy the resulting BINFO may not actually *be*\n-   primary.  In particular if the resulting BINFO is a virtual base,\n-   and it occurs elsewhere in the hierarchy, then this occurrence may\n-   not actually be a primary base in the complete object.  Check\n-   BINFO_PRIMARY_P to be sure.  */\n+/* Returns the unshared binfo for the primary base of BINFO.  Note\n+   that in a complex hierarchy the resulting BINFO may not actually\n+   *be* primary.  In particular if the resulting BINFO is a virtual\n+   base, and it occurs elsewhere in the hierarchy, then this\n+   occurrence may not actually be a primary base in the complete\n+   object.  Check BINFO_PRIMARY_P to be sure.  */\n \n tree\n get_primary_binfo (binfo)\n@@ -7397,7 +7385,8 @@ dfs_fixup_binfo_vtbls (binfo, data)\n \n   /* If we scribbled the construction vtable vptr into BINFO, clear it\n      out now.  */\n-  if (TREE_CODE (BINFO_VTABLE (binfo)) == TREE_LIST\n+  if (BINFO_VTABLE (binfo)\n+      && TREE_CODE (BINFO_VTABLE (binfo)) == TREE_LIST\n       && (TREE_PURPOSE (BINFO_VTABLE (binfo)) \n \t  == TREE_VALUE ((tree) data)))\n     BINFO_VTABLE (binfo) = TREE_CHAIN (BINFO_VTABLE (binfo));\n@@ -7543,41 +7532,80 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n          virtual base.  If it is not the same primary in the hierarchy of T,\n          we'll need to generate a ctor vtable for it, to place at its\n          location in T.  If it is the same primary, we still need a VTT\n-         entry for the vtable, but that must be the base it is a\n-         primary for within the sub-hierarchy of RTTI_BINFO.  */\n-      tree parent;\n-      tree best_primary = NULL;\n-      tree primary_for;\n-      \n-      my_friendly_assert (BINFO_PRIMARY_P (binfo), 20010131);\n+         entry for the vtable, but it should point to the ctor vtable for the\n+\t base it is a primary for within the sub-hierarchy of RTTI_BINFO.\n \n-      for (primary_for = BINFO_PRIMARY_BASE_OF (binfo);\n-           primary_for;\n-           primary_for = BINFO_PRIMARY_BASE_OF (primary_for))\n-        {\n-          for (parent = primary_for;\n-               parent;\n-               parent = BINFO_INHERITANCE_CHAIN (parent))\n-             {\n-               if (parent == rtti_binfo)\n-                 {\n-                   best_primary = primary_for;\n-                   break;\n-                 }\n-             }\n-           if (!parent)\n-             break;\n-        }\n-      if (best_primary)\n-        {\n-          vtbl = BINFO_VTABLE (best_primary);\n-          if (TREE_CODE (vtbl) == TREE_LIST)\n-            {\n-              my_friendly_assert (TREE_PURPOSE (vtbl) == rtti_binfo,\n-                                  20010126);\n-              vtbl = TREE_VALUE (vtbl);\n-            }\n+\t There are three possible cases:\n+\n+         1) We are in the same place.\n+\t 2) We are a primary base within a lost primary virtual base of\n+\t    RTTI_BINFO.\n+\t 3) We are not primary to anything else in RTTI_BINFO.  */\n+\n+      tree primary = NULL_TREE;\n+      if (tree_int_cst_equal (BINFO_OFFSET (orig_binfo),\n+\t\t\t      size_diffop (BINFO_OFFSET (binfo),\n+\t\t\t\t\t   BINFO_OFFSET (rtti_binfo))))\n+\t{\n+\t  /* Case 1: We're in the same place relative to RTTI_BINFO as we\n+\t     were in the complete type, so we are primary either to\n+\t     RTTI_BINFO or one of its secondary bases.  */\n+\n+\t  tree b = BINFO_PRIMARY_BASE_OF (binfo);\n+\n+\t  /* Walk down our until we either find the last primary base or\n+\t     rtti_binfo.  */\n+\t  for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n+\t    {\n+\t      primary = b;\n+\t      if (b == rtti_binfo)\n+\t\tbreak;\n+\t    }\n         }\n+      else\n+\t{\n+\t  /* Case 2 or 3: We're not in the same place.  We might still be\n+\t     primary to something within a lost primary virtual base of\n+\t     RTTI_BINFO.  */\n+\n+\t  tree b = BINFO_PRIMARY_BASE_OF (binfo);\n+\t  tree last;\n+\n+\t  /* First, look through the bases we are primary to for a virtual\n+\t     base.  */\n+\t  for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n+\t    {\n+\t      last = b;\n+\t      if (TREE_VIA_VIRTUAL (b))\n+\t\tbreak;\n+\t    }\n+\t  /* If we run out of primary links, keep looking down our\n+\t     inheritance chain; we might be an indirect primary of a\n+\t     virtual base.  */\n+\t  if (b == NULL_TREE)\n+\t    for (b = last; b; b = BINFO_INHERITANCE_CHAIN (b))\n+\t      if (TREE_VIA_VIRTUAL (b))\n+\t\tbreak;\n+\n+\t  /* If we found a virtual base B and it is a base of RTTI_BINFO, we\n+\t     share our vtable with LAST, i.e. the derived-most base within\n+\t     B of which we are a primary.  Otherwise, we get our own.  */\n+\t  if (b && binfo_for_vbase (BINFO_TYPE (b),\n+\t\t\t\t    BINFO_TYPE (rtti_binfo)))\n+\t    primary = last;\n+\t}\n+\n+      if (primary)\n+\t{\n+          vtbl = BINFO_VTABLE (primary);\n+\t  /* If we haven't already been here for our primary derivation,\n+\t     all bets are off.  Especially for case 2 above, we need\n+\t     the derived vtable to have been generated.  */\n+\t  my_friendly_assert (TREE_CODE (vtbl) == TREE_LIST\n+\t\t\t      && TREE_PURPOSE (vtbl) == rtti_binfo,\n+\t\t\t      20010126);\n+\t  vtbl = TREE_VALUE (vtbl);\n+\t}\n     }\n   else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo, BINFO_TYPE (rtti_binfo)))\n     return inits;\n@@ -7610,9 +7638,10 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n   if (!ctor_vtbl_p)\n     {\n       /* For an ordinary vtable, set BINFO_VTABLE.  */\n-      BINFO_VTABLE (binfo) = vtbl;\n       if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo))\n-        inits = NULL_TREE;\n+\tinits = NULL_TREE;\n+      else\n+\tBINFO_VTABLE (binfo) = vtbl;\n     }\n   else\n     /* For a construction vtable, we can't overwrite BINFO_VTABLE."}, {"sha": "ceb569c70d7f3615d2c82e4a4049e4caec5639d2", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "patch": "@@ -292,7 +292,7 @@ request for member `%D' is ambiguous in multiple inheritance lattice\",\n /* Return a thunk to FUNCTION.  For a virtual thunk, DELTA is the\n    offset to this used to locate the vptr, and VCALL_INDEX is used to\n    look up the eventual subobject location.  For a non-virtual thunk,\n-   DELTA is the offset to this and VCALL_INDEX is zero.  */\n+   DELTA is the offset to this and VCALL_INDEX is NULL.  */\n \n tree\n make_thunk (function, delta, vcall_index)"}, {"sha": "8190c0e9bdcbdefaedf0dfad655edb932b648180", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable4.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85a9a0a28bd6f48e7e45386cbe6003ea3199f43b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable4.C?ref=85a9a0a28bd6f48e7e45386cbe6003ea3199f43b", "patch": "@@ -0,0 +1,27 @@\n+// Test for proper handling of extreme virtual inheritance.\n+// Previously we failed to recognise that in the constructor vtable\n+// for B_skel in C_skel, A_base was still primary to B_base, even though\n+// not to B_skel.\n+\n+// From PR c++/3061.\n+\n+struct A_base {\n+  virtual void foo() { }\n+};\n+class A_skel : virtual public A_base { };\n+ \n+class B_base : virtual public A_base { };\n+class B_skel : virtual public B_base, virtual public A_skel { };\n+ \n+class C_base : virtual public B_base { };\n+class C_skel : virtual public C_base, virtual public B_skel { };\n+ \n+class D_base : virtual public C_base { };\n+class D_skel : virtual public D_base, virtual public C_skel { };\n+ \n+class D_impl : virtual public D_skel { };\n+ \n+int main()\n+{\n+  D_impl i;\n+}"}]}