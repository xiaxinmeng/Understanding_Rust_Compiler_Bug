{"sha": "7f17528ab58fa0a0f627b94bacbae686438b9bd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YxNzUyOGFiNThmYTBhMGY2MjdiOTRiYWNiYWU2ODY0MzhiOWJkNA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-01-14T12:29:06Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-01-14T12:29:06Z"}, "message": "tree-ssa-loop-niter.c (number_of_iterations_cond): Split into several functions.\n\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Split into several\n\tfunctions.\n\t(number_of_iterations_ne, number_of_iterations_lt_to_ne,\n\tassert_no_overflow_lt, assert_loop_rolls_lt, number_of_iterations_lt,\n\tnumber_of_iterations_le): New functions.\n\t(number_of_iterations_special): Removed.\n\t(number_of_iterations_exit): Do not use number_of_iterations_special.\n\t* tree.c (unsigned_type_for): Always return integer type.\n\n\t* gcc.dg/tree-ssa/pr19210-1.c: Update outcome.  Add new test loop.\n\t* gcc.dg/tree-ssa/pr19210-2.c: Ditto.\n\nFrom-SVN: r109702", "tree": {"sha": "22793cf18859c40c1d11f310d8c985db7f286d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22793cf18859c40c1d11f310d8c985db7f286d01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f17528ab58fa0a0f627b94bacbae686438b9bd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f17528ab58fa0a0f627b94bacbae686438b9bd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f17528ab58fa0a0f627b94bacbae686438b9bd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f17528ab58fa0a0f627b94bacbae686438b9bd4/comments", "author": null, "committer": null, "parents": [{"sha": "26fb114d1345224c2af762534482eb8ad117f622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fb114d1345224c2af762534482eb8ad117f622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26fb114d1345224c2af762534482eb8ad117f622"}], "stats": {"total": 883, "additions": 462, "deletions": 421}, "files": [{"sha": "24227042462bfd702f024a04487c8be291f3be26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f17528ab58fa0a0f627b94bacbae686438b9bd4", "patch": "@@ -1,3 +1,14 @@\n+2006-01-14  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Split into several\n+\tfunctions.\n+\t(number_of_iterations_ne, number_of_iterations_lt_to_ne,\n+\tassert_no_overflow_lt, assert_loop_rolls_lt, number_of_iterations_lt,\n+\tnumber_of_iterations_le): New functions.\n+\t(number_of_iterations_special): Removed.\n+\t(number_of_iterations_exit): Do not use number_of_iterations_special.\n+\t* tree.c (unsigned_type_for): Always return integer type.\n+\n 2006-01-14  Steven Bosscher  <stevenb.gcc@gmail.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "ffe0dc991b1960843962a998f3d3f6f8f0a035dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f17528ab58fa0a0f627b94bacbae686438b9bd4", "patch": "@@ -1,3 +1,8 @@\n+2005-01-14  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/pr19210-1.c: Update outcome.  Add new test loop.\n+\t* gcc.dg/tree-ssa/pr19210-2.c: Ditto.\n+\n 2006-01-14  Steven Bosscher  <stevenb.gcc@gmail.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "906132c6916c0fde5d936b0c8b2c9524c3870de5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19210-1.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19210-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19210-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19210-1.c?ref=7f17528ab58fa0a0f627b94bacbae686438b9bd4", "patch": "@@ -12,9 +12,18 @@ f (unsigned n)\n   for(k = 0;k <= n;k += 4) /* { dg-warning \"cannot optimize.*overflow\" } */\n     g();\n \n-  for(k = 5;k <= n;k += 5) /* { dg-warning \"cannot optimize.*overflow\" } */\n+  /* We used to get warning for this loop.  However, since then # of iterations\n+     analysis improved, and we can now prove that this loop does not verflow.\n+     This is because the only case when it would overflow is if n = ~0 (since\n+     ~0 is divisible by 5), and this cannot be the case, since when we got\n+     here, the previous loop exited, thus there exists k > n.  */\n+  for(k = 5;k <= n;k += 5)\n     g();\n \n+  /* So we need the following loop, instead.  */\n+  for(k = 4;k <= n;k += 5) /* { dg-warning \"cannot optimize.*overflow\" } */\n+    g();\n+  \n   for(k = 15;k >= n;k--) /* { dg-warning \"cannot optimize.*infinite\" } */\n     g();\n }"}, {"sha": "9116e97ec4f043b74967bc31445581d594073e6b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19210-2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19210-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19210-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19210-2.c?ref=7f17528ab58fa0a0f627b94bacbae686438b9bd4", "patch": "@@ -12,7 +12,15 @@ f (unsigned n)\n   for(k = 5;k <= n;k += 4) /* { dg-warning \"assuming.*not overflow\" } */\n     g();\n \n-  for(k = 5;k <= n;k += 5) /* { dg-warning \"assuming.*not overflow\" } */\n+  /* We used to get warning for this loop.  However, since then # of iterations\n+     analysis improved, and we can now prove that this loop does not verflow.\n+     This is because the only case when it would overflow is if n = ~0 (since\n+     ~0 is divisible by 5), and this cannot be the case, since when we got\n+     here, the previous loop exited, thus there exists k > n.  */\n+  for(k = 5;k <= n;k += 5)\n+    g();\n+\n+  for(k = 4;k <= n;k += 5) /* { dg-warning \"assuming.*not overflow\" } */\n     g();\n \n   for(k = 15;k >= n;k--) /* { dg-warning \"assuming.*not infinite\" } */"}, {"sha": "7566e7cad49b5be9379951bcc49adcf34c5c7a93", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 425, "deletions": 419, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=7f17528ab58fa0a0f627b94bacbae686438b9bd4", "patch": "@@ -126,490 +126,504 @@ inverse (tree x, tree mask)\n   return rslt;\n }\n \n-/* Determine the number of iterations according to condition (for staying\n-   inside loop) which compares two induction variables using comparison\n-   operator CODE.  The induction variable on left side of the comparison\n-   is IV0, the right-hand side is IV1.  Both induction variables must have\n-   type TYPE, which must be an integer or pointer type.  The steps of the\n-   ivs must be constants (or NULL_TREE, which is interpreted as constant zero).\n-   \n-   The results (number of iterations and assumptions as described in\n-   comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.\n-   In case we are unable to determine number of iterations, contents of\n-   this structure is unchanged.  */\n+/* Determines number of iterations of loop whose ending condition\n+   is IV <> FINAL.  TYPE is the type of the iv.  The number of\n+   iterations is stored to NITER.  NEVER_INFINITE is true if\n+   we know that the loop cannot be infinite (we derived this\n+   earlier, and possibly set NITER->assumptions to make sure this\n+   is the case.  */\n \n-static void\n-number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n-\t\t\t   affine_iv *iv1, struct tree_niter_desc *niter)\n+static bool\n+number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n+\t\t\t struct tree_niter_desc *niter, bool never_infinite)\n {\n-  tree step, delta, mmin, mmax;\n-  tree may_xform, bound, s, d, tmp;\n-  bool was_sharp = false, never_infinite;\n-  tree assumption;\n-  tree assumptions = boolean_true_node;\n-  tree noloop_assumptions = boolean_false_node;\n-  tree niter_type, signed_niter_type;\n-  tree bits;\n+  tree niter_type = unsigned_type_for (type);\n+  tree s, c, d, bits, assumption, tmp, bound;\n \n-  /* The meaning of these assumptions is this:\n-     if !assumptions\n-       then the rest of information does not have to be valid\n-     if noloop_assumptions then the loop does not have to roll\n-       (but it is only conservative approximation, i.e. it only says that\n-       if !noloop_assumptions, then the loop does not end before the computed\n-       number of iterations)  */\n-\n-  /* Make < comparison from > ones.  */\n-  if (code == GE_EXPR\n-      || code == GT_EXPR)\n+  /* Rearrange the terms so that we get inequality s * i <> c, with s\n+     positive.  Also cast everything to the unsigned type.  */\n+  if (tree_int_cst_sign_bit (iv->step))\n     {\n-      SWAP (iv0, iv1);\n-      code = swap_tree_comparison (code);\n+      s = fold_convert (niter_type,\n+\t\t\tfold_build1 (NEGATE_EXPR, type, iv->step));\n+      c = fold_build2 (MINUS_EXPR, niter_type,\n+\t\t       fold_convert (niter_type, iv->base),\n+\t\t       fold_convert (niter_type, final));\n     }\n-\n-  /* If the control induction variable does not overflow, the loop obviously\n-     cannot be infinite.  */\n-  if (!zero_p (iv0->step) && iv0->no_overflow)\n-    never_infinite = true;\n-  else if (!zero_p (iv1->step) && iv1->no_overflow)\n-    never_infinite = true;\n   else\n-    never_infinite = false;\n-\n-  /* We can handle the case when neither of the sides of the comparison is\n-     invariant, provided that the test is NE_EXPR.  This rarely occurs in\n-     practice, but it is simple enough to manage.  */\n-  if (!zero_p (iv0->step) && !zero_p (iv1->step))\n     {\n-      if (code != NE_EXPR)\n-\treturn;\n+      s = fold_convert (niter_type, iv->step);\n+      c = fold_build2 (MINUS_EXPR, niter_type,\n+\t\t       fold_convert (niter_type, final),\n+\t\t       fold_convert (niter_type, iv->base));\n+    }\n \n-      iv0->step = fold_binary_to_constant (MINUS_EXPR, type,\n-\t\t\t\t\t   iv0->step, iv1->step);\n-      iv0->no_overflow = false;\n-      iv1->step = NULL_TREE;\n-      iv1->no_overflow = true;\n+  /* First the trivial cases -- when the step is 1.  */\n+  if (integer_onep (s))\n+    {\n+      niter->niter = c;\n+      return true;\n     }\n \n-  /* If the result is a constant,  the loop is weird.  More precise handling\n-     would be possible, but the situation is not common enough to waste time\n-     on it.  */\n-  if (zero_p (iv0->step) && zero_p (iv1->step))\n-    return;\n+  /* Let nsd (step, size of mode) = d.  If d does not divide c, the loop\n+     is infinite.  Otherwise, the number of iterations is\n+     (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n+  bits = num_ending_zeros (s);\n+  bound = build_low_bits_mask (niter_type,\n+\t\t\t       (TYPE_PRECISION (niter_type)\n+\t\t\t\t- tree_low_cst (bits, 1)));\n \n-  /* Ignore loops of while (i-- < 10) type.  */\n-  if (code != NE_EXPR)\n-    {\n-      if (iv0->step && tree_int_cst_sign_bit (iv0->step))\n-\treturn;\n+  d = fold_binary_to_constant (LSHIFT_EXPR, niter_type,\n+\t\t\t       build_int_cst_type (niter_type, 1), bits);\n+  s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, s, bits);\n \n-      if (!zero_p (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n-\treturn;\n+  if (!never_infinite)\n+    {\n+      /* If we cannot assume that the loop is not infinite, record the\n+\t assumptions for divisibility of c.  */\n+      assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, c, d);\n+      assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\tassumption, build_int_cst (niter_type, 0));\n+      if (!nonzero_p (assumption))\n+\tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t  niter->assumptions, assumption);\n     }\n+      \n+  c = fold_build2 (EXACT_DIV_EXPR, niter_type, c, d);\n+  tmp = fold_build2 (MULT_EXPR, niter_type, c, inverse (s, bound));\n+  niter->niter = fold_build2 (BIT_AND_EXPR, niter_type, tmp, bound);\n+  return true;\n+}\n \n-  if (POINTER_TYPE_P (type))\n+/* Checks whether we can determine the final value of the control variable\n+   of the loop with ending condition IV0 < IV1 (computed in TYPE).\n+   DELTA is the difference IV1->base - IV0->base, STEP is the absolute value\n+   of the step.  The assumptions necessary to ensure that the computation\n+   of the final value does not overflow are recorded in NITER.  If we\n+   find the final value, we adjust DELTA and return TRUE.  Otherwise\n+   we return false.  */\n+\n+static bool\n+number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n+\t\t\t       struct tree_niter_desc *niter,\n+\t\t\t       tree *delta, tree step)\n+{\n+  tree niter_type = TREE_TYPE (step);\n+  tree mod = fold_build2 (FLOOR_MOD_EXPR, niter_type, *delta, step);\n+  tree tmod;\n+  tree assumption = boolean_true_node, bound, noloop;\n+\n+  if (TREE_CODE (mod) != INTEGER_CST)\n+    return false;\n+  if (nonzero_p (mod))\n+    mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n+  tmod = fold_convert (type, mod);\n+\n+  if (nonzero_p (iv0->step))\n     {\n-      /* We assume pointer arithmetic never overflows.  */\n-      mmin = mmax = NULL_TREE;\n+      /* The final value of the iv is iv1->base + MOD, assuming that this\n+\t computation does not overflow, and that\n+\t iv0->base <= iv1->base + MOD.  */\n+      if (!iv1->no_overflow && !zero_p (mod))\n+\t{\n+\t  bound = fold_build2 (MINUS_EXPR, type,\n+\t\t\t       TYPE_MAX_VALUE (type), tmod);\n+\t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t    iv1->base, bound);\n+\t  if (zero_p (assumption))\n+\t    return false;\n+\t}\n+      noloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t    iv0->base,\n+\t\t\t    fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t\t iv1->base, tmod));\n     }\n   else\n     {\n-      mmin = TYPE_MIN_VALUE (type);\n-      mmax = TYPE_MAX_VALUE (type);\n+      /* The final value of the iv is iv0->base - MOD, assuming that this\n+\t computation does not overflow, and that\n+\t iv0->base - MOD <= iv1->base. */\n+      if (!iv0->no_overflow && !zero_p (mod))\n+\t{\n+\t  bound = fold_build2 (PLUS_EXPR, type,\n+\t\t\t       TYPE_MIN_VALUE (type), tmod);\n+\t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t    iv0->base, bound);\n+\t  if (zero_p (assumption))\n+\t    return false;\n+\t}\n+      noloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t    fold_build2 (MINUS_EXPR, type,\n+\t\t\t\t\t iv0->base, tmod),\n+\t\t\t    iv1->base);\n     }\n \n-  /* Some more condition normalization.  We must record some assumptions\n-     due to overflows.  */\n+  if (!nonzero_p (assumption))\n+    niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      niter->assumptions,\n+\t\t\t\t      assumption);\n+  if (!zero_p (noloop))\n+    niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t      niter->may_be_zero,\n+\t\t\t\t      noloop);\n+  *delta = fold_build2 (PLUS_EXPR, niter_type, *delta, mod);\n+  return true;\n+}\n+\n+/* Add assertions to NITER that ensure that the control variable of the loop\n+   with ending condition IV0 < IV1 does not overflow.  Types of IV0 and IV1\n+   are TYPE.  Returns false if we can prove that there is an overflow, true\n+   otherwise.  STEP is the absolute value of the step.  */\n+\n+static bool\n+assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n+\t\t       struct tree_niter_desc *niter, tree step)\n+{\n+  tree bound, d, assumption, diff;\n+  tree niter_type = TREE_TYPE (step);\n \n-  if (code == LT_EXPR)\n+  if (nonzero_p (iv0->step))\n     {\n-      /* We want to take care only of <=; this is easy,\n-\t as in cases the overflow would make the transformation unsafe the loop\n-\t does not roll.  Seemingly it would make more sense to want to take\n-\t care of <, as NE is more similar to it, but the problem is that here\n-\t the transformation would be more difficult due to possibly infinite\n-\t loops.  */\n-      if (zero_p (iv0->step))\n+      /* for (i = iv0->base; i < iv1->base; i += iv0->step) */\n+      if (iv0->no_overflow)\n+\treturn true;\n+\n+      /* If iv0->base is a constant, we can determine the last value before\n+\t overflow precisely; otherwise we conservatively assume\n+\t MAX - STEP + 1.  */\n+\n+      if (TREE_CODE (iv0->base) == INTEGER_CST)\n \t{\n-\t  if (mmax)\n-\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t      iv0->base, mmax);\n-\t  else\n-\t    assumption = boolean_false_node;\n-\t  if (nonzero_p (assumption))\n-\t    goto zero_iter;\n-\t  iv0->base = fold_build2 (PLUS_EXPR, type, iv0->base,\n-\t\t\t\t   build_int_cst_type (type, 1));\n+\t  d = fold_build2 (MINUS_EXPR, niter_type,\n+\t\t\t   fold_convert (niter_type, TYPE_MAX_VALUE (type)),\n+\t\t\t   fold_convert (niter_type, iv0->base));\n+\t  diff = fold_build2 (FLOOR_MOD_EXPR, niter_type, d, step);\n \t}\n       else\n+\tdiff = fold_build2 (MINUS_EXPR, niter_type, step,\n+\t\t\t    build_int_cst_type (niter_type, 1));\n+      bound = fold_build2 (MINUS_EXPR, type,\n+\t\t\t   TYPE_MAX_VALUE (type), fold_convert (type, diff));\n+      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\tiv1->base, bound);\n+    }\n+  else\n+    {\n+      /* for (i = iv1->base; i > iv0->base; i += iv1->step) */\n+      if (iv1->no_overflow)\n+\treturn true;\n+\n+      if (TREE_CODE (iv1->base) == INTEGER_CST)\n \t{\n-\t  if (mmin)\n-\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t      iv1->base, mmin);\n-\t  else\n-\t    assumption = boolean_false_node;\n-\t  if (nonzero_p (assumption))\n-\t    goto zero_iter;\n-\t  iv1->base = fold_build2 (MINUS_EXPR, type, iv1->base,\n-\t\t\t\t   build_int_cst_type (type, 1));\n+\t  d = fold_build2 (MINUS_EXPR, niter_type,\n+\t\t\t   fold_convert (niter_type, iv1->base),\n+\t\t\t   fold_convert (niter_type, TYPE_MIN_VALUE (type)));\n+\t  diff = fold_build2 (FLOOR_MOD_EXPR, niter_type, d, step);\n \t}\n-      noloop_assumptions = assumption;\n-      code = LE_EXPR;\n-\n-      /* It will be useful to be able to tell the difference once more in\n-\t <= -> != reduction.  */\n-      was_sharp = true;\n+      else\n+\tdiff = fold_build2 (MINUS_EXPR, niter_type, step,\n+\t\t\t    build_int_cst_type (niter_type, 1));\n+      bound = fold_build2 (PLUS_EXPR, type,\n+\t\t\t   TYPE_MIN_VALUE (type), fold_convert (type, diff));\n+      assumption = fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\tiv0->base, bound);\n     }\n \n-  /* Take care of trivially infinite loops.  */\n-  if (code != NE_EXPR)\n-    {\n-      if (zero_p (iv0->step)\n-\t  && mmin\n-\t  && operand_equal_p (iv0->base, mmin, 0))\n-\treturn;\n-      if (zero_p (iv1->step)\n-\t  && mmax\n-\t  && operand_equal_p (iv1->base, mmax, 0))\n-\treturn;\n-    }\n+  if (zero_p (assumption))\n+    return false;\n+  if (!nonzero_p (assumption))\n+    niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      niter->assumptions, assumption);\n+    \n+  iv0->no_overflow = true;\n+  iv1->no_overflow = true;\n+  return true;\n+}\n \n-  /* If we can we want to take care of NE conditions instead of size\n-     comparisons, as they are much more friendly (most importantly\n-     this takes care of special handling of loops with step 1).  We can\n-     do it if we first check that upper bound is greater or equal to\n-     lower bound, their difference is constant c modulo step and that\n-     there is not an overflow.  */\n-  if (code != NE_EXPR)\n+/* Add an assumption to NITER that a loop whose ending condition\n+   is IV0 < IV1 rolls.  TYPE is the type of the control iv.  */\n+\n+static void\n+assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n+\t\t      struct tree_niter_desc *niter)\n+{\n+  tree assumption = boolean_true_node, bound, diff;\n+  tree mbz, mbzl, mbzr;\n+\n+  if (nonzero_p (iv0->step))\n     {\n-      if (zero_p (iv0->step))\n-\tstep = fold_unary_to_constant (NEGATE_EXPR, type, iv1->step);\n-      else\n-\tstep = iv0->step;\n-      delta = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n-      delta = fold_build2 (FLOOR_MOD_EXPR, type, delta, step);\n-      may_xform = boolean_false_node;\n+      diff = fold_build2 (MINUS_EXPR, type,\n+\t\t\t  iv0->step, build_int_cst_type (type, 1));\n \n-      if (TREE_CODE (delta) == INTEGER_CST)\n+      /* We need to know that iv0->base >= MIN + iv0->step - 1.  Since\n+\t 0 address never belongs to any object, we can assume this for\n+\t pointers.  */\n+      if (!POINTER_TYPE_P (type))\n \t{\n-\t  tmp = fold_binary_to_constant (MINUS_EXPR, type, step,\n-\t\t\t\t\t build_int_cst_type (type, 1));\n-\t  if (was_sharp\n-\t      && operand_equal_p (delta, tmp, 0))\n-\t    {\n-\t      /* A special case.  We have transformed condition of type\n-\t\t for (i = 0; i < 4; i += 4)\n-\t\t into\n-\t\t for (i = 0; i <= 3; i += 4)\n-\t\t obviously if the test for overflow during that transformation\n-\t\t passed, we cannot overflow here.  Most importantly any\n-\t\t loop with sharp end condition and step 1 falls into this\n-\t\t category, so handling this case specially is definitely\n-\t\t worth the troubles.  */\n-\t      may_xform = boolean_true_node;\n-\t    }\n-\t  else if (zero_p (iv0->step))\n-\t    {\n-\t      if (!mmin || iv1->no_overflow)\n-\t\tmay_xform = boolean_true_node;\n-\t      else\n-\t\t{\n-\t\t  bound = fold_binary_to_constant (PLUS_EXPR, type,\n-\t\t\t\t\t\t   mmin, step);\n-\t\t  bound = fold_binary_to_constant (MINUS_EXPR, type,\n-\t\t\t\t\t\t   bound, delta);\n-\t\t  may_xform = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t   bound, iv0->base);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!mmax || iv0->no_overflow)\n-\t\tmay_xform = boolean_true_node;\n-\t      else\n-\t\t{\n-\t\t  bound = fold_binary_to_constant (MINUS_EXPR, type,\n-\t\t\t\t\t\t   mmax, step);\n-\t\t  bound = fold_binary_to_constant (PLUS_EXPR, type,\n-\t\t\t\t\t\t   bound, delta);\n-\t\t  may_xform = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t   iv1->base, bound);\n-\t\t}\n-\t    }\n+\t  bound = fold_build2 (PLUS_EXPR, type,\n+\t\t\t       TYPE_MIN_VALUE (type), diff);\n+\t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t    iv0->base, bound);\n \t}\n \n-      if (!zero_p (may_xform))\n-\t{\n-\t  /* We perform the transformation always provided that it is not\n-\t     completely senseless.  This is OK, as we would need this assumption\n-\t     to determine the number of iterations anyway.  */\n-\t  if (!nonzero_p (may_xform))\n-\t    assumptions = may_xform;\n-\n-\t  if (zero_p (iv0->step))\n-\t    {\n-\t      iv0->base = fold_build2 (PLUS_EXPR, type, iv0->base, delta);\n-\t      iv0->base = fold_build2 (MINUS_EXPR, type, iv0->base, step);\n-\t    }\n-\t  else\n-\t    {\n-\t      iv1->base = fold_build2 (MINUS_EXPR, type, iv1->base, delta);\n-\t      iv1->base = fold_build2 (PLUS_EXPR, type, iv1->base, step);\n-\t    }\n-\n-\t  assumption = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t    iv0->base, iv1->base);\n-\t  noloop_assumptions = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t\t    noloop_assumptions, assumption);\n-\t  code = NE_EXPR;\n-\t}\n+      /* And then we can compute iv0->base - diff, and compare it with\n+\t iv1->base.  */      \n+      mbzl = fold_build2 (MINUS_EXPR, type, iv0->base, diff);\n+      mbzr = iv1->base;\n     }\n-\n-  /* Count the number of iterations.  */\n-  niter_type = unsigned_type_for (type);\n-  signed_niter_type = signed_type_for (type);\n-\n-  if (code == NE_EXPR)\n+  else\n     {\n-      /* Everything we do here is just arithmetics modulo size of mode.  This\n-\t makes us able to do more involved computations of number of iterations\n-\t than in other cases.  First transform the condition into shape\n-\t s * i <> c, with s positive.  */\n-      iv1->base = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n-      iv0->base = NULL_TREE;\n-      if (!zero_p (iv1->step))\n-  \tiv0->step = fold_unary_to_constant (NEGATE_EXPR, type, iv1->step);\n-      iv1->step = NULL_TREE;\n-      if (tree_int_cst_sign_bit (fold_convert (signed_niter_type, iv0->step)))\n+      diff = fold_build2 (PLUS_EXPR, type,\n+\t\t\t  iv1->step, build_int_cst_type (type, 1));\n+\n+      if (!POINTER_TYPE_P (type))\n \t{\n-\t  iv0->step = fold_unary_to_constant (NEGATE_EXPR, type, iv0->step);\n-\t  iv1->base = fold_build1 (NEGATE_EXPR, type, iv1->base);\n+\t  bound = fold_build2 (PLUS_EXPR, type,\n+\t\t\t       TYPE_MAX_VALUE (type), diff);\n+\t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t    iv1->base, bound);\n \t}\n \n-      iv1->base = fold_convert (niter_type, iv1->base);\n-      iv0->step = fold_convert (niter_type, iv0->step);\n+      mbzl = iv0->base;\n+      mbzr = fold_build2 (MINUS_EXPR, type, iv1->base, diff);\n+    }\n+\n+  mbz = fold_build2 (GT_EXPR, boolean_type_node, mbzl, mbzr);\n \n-      /* Let nsd (step, size of mode) = d.  If d does not divide c, the loop\n-\t is infinite.  Otherwise, the number of iterations is\n-\t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n-      bits = num_ending_zeros (iv0->step);\n-      d = fold_binary_to_constant (LSHIFT_EXPR, niter_type,\n-\t\t\t\t   build_int_cst_type (niter_type, 1), bits);\n-      s = fold_binary_to_constant (RSHIFT_EXPR, niter_type, iv0->step, bits);\n+  if (!nonzero_p (assumption))\n+    niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      niter->assumptions, assumption);\n+  if (!zero_p (mbz))\n+    niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t      niter->may_be_zero, mbz);\n+}\n \n-      bound = build_low_bits_mask (niter_type,\n-\t\t\t\t   (TYPE_PRECISION (niter_type)\n-\t\t\t\t    - tree_low_cst (bits, 1)));\n+/* Determines number of iterations of loop whose ending condition\n+   is IV0 < IV1.  TYPE is the type of the iv.  The number of\n+   iterations is stored to NITER.  */\n \n-      if (!never_infinite)\n-\t{\n-\t  /* If we cannot assume that the loop is not infinite, record the\n-\t     assumptions for divisibility of c.  */\n-\t  assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, iv1->base, d);\n-\t  assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t    assumption,\n-\t\t\t\t    build_int_cst (niter_type, 0));\n-\t  assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t     assumptions, assumption);\n-\t}\n+static bool\n+number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n+\t\t\t struct tree_niter_desc *niter,\n+\t\t\t bool never_infinite ATTRIBUTE_UNUSED)\n+{\n+  tree niter_type = unsigned_type_for (type);\n+  tree delta, step, s;\n+\n+  delta = fold_build2 (MINUS_EXPR, niter_type,\n+\t\t       fold_convert (niter_type, iv1->base),\n+\t\t       fold_convert (niter_type, iv0->base));\n+\n+  /* First handle the special case that the step is +-1.  */\n+  if ((iv0->step && integer_onep (iv0->step)\n+       && zero_p (iv1->step))\n+      || (iv1->step && integer_all_onesp (iv1->step)\n+\t  && zero_p (iv0->step)))\n+    {\n+      /* for (i = iv0->base; i < iv1->base; i++)\n+\n+\t or\n \n-      tmp = fold_build2 (EXACT_DIV_EXPR, niter_type, iv1->base, d);\n-      tmp = fold_build2 (MULT_EXPR, niter_type, tmp, inverse (s, bound));\n-      niter->niter = fold_build2 (BIT_AND_EXPR, niter_type, tmp, bound);\n+\t for (i = iv1->base; i > iv0->base; i--).\n+\t     \n+\t In both cases # of iterations is iv1->base - iv0->base, assuming that\n+\t iv1->base >= iv0->base.  */\n+      niter->may_be_zero = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\tiv1->base, iv0->base);\n+      niter->niter = delta;\n+      return true;\n     }\n+\n+  if (nonzero_p (iv0->step))\n+    step = fold_convert (niter_type, iv0->step);\n   else\n+    step = fold_convert (niter_type,\n+\t\t\t fold_build1 (NEGATE_EXPR, type, iv1->step));\n+\n+  /* If we can determine the final value of the control iv exactly, we can\n+     transform the condition to != comparison.  In particular, this will be\n+     the case if DELTA is constant.  */\n+  if (number_of_iterations_lt_to_ne (type, iv0, iv1, niter, &delta, step))\n     {\n-      if (zero_p (iv1->step))\n-\t/* Condition in shape a + s * i <= b\n-\t   We must know that b + s does not overflow and a <= b + s and then we\n-\t   can compute number of iterations as (b + s - a) / s.  (It might\n-\t   seem that we in fact could be more clever about testing the b + s\n-\t   overflow condition using some information about b - a mod s,\n-\t   but it was already taken into account during LE -> NE transform).  */\n-\t{\n-\t  if (mmax && !iv0->no_overflow)\n-\t    {\n-\t      bound = fold_binary_to_constant (MINUS_EXPR, type,\n-\t\t\t\t\t       mmax, iv0->step);\n-\t      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tiv1->base, bound);\n-\t      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\t assumptions, assumption);\n-\t    }\n+      affine_iv zps;\n \n-\t  step = iv0->step;\n-\t  tmp = fold_build2 (PLUS_EXPR, type, iv1->base, iv0->step);\n-\t  assumption = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t    iv0->base, tmp);\n-\t  delta = fold_build2 (PLUS_EXPR, type, iv1->base, step);\n-\t  delta = fold_build2 (MINUS_EXPR, type, delta, iv0->base);\n-\t  delta = fold_convert (niter_type, delta);\n-\t}\n-      else\n-\t{\n-\t  /* Condition in shape a <= b - s * i\n-\t     We must know that a - s does not overflow and a - s <= b and then\n-\t     we can again compute number of iterations as (b - (a - s)) / s.  */\n-\t  if (mmin && !iv1->no_overflow)\n-\t    {\n-\t      bound = fold_binary_to_constant (MINUS_EXPR, type,\n-\t\t\t\t\t       mmin, iv1->step);\n-\t      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tbound, iv0->base);\n-\t      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\t assumptions, assumption);\n-\t    }\n-\t  step = fold_build1 (NEGATE_EXPR, type, iv1->step);\n-\t  tmp = fold_build2 (PLUS_EXPR, type, iv0->base, iv1->step);\n-\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, tmp, iv1->base);\n-\t  delta = fold_build2 (MINUS_EXPR, type, iv0->base, step);\n-\t  delta = fold_build2 (MINUS_EXPR, type, iv1->base, delta);\n-\t  delta = fold_convert (niter_type, delta);\n-\t}\n-      noloop_assumptions = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t\tnoloop_assumptions, assumption);\n-      delta = fold_build2 (FLOOR_DIV_EXPR, niter_type, delta,\n-\t\t\t   fold_convert (niter_type, step));\n-      niter->niter = delta;\n+      zps.base = build_int_cst_type (niter_type, 0);\n+      zps.step = step;\n+      /* number_of_iterations_lt_to_ne will add assumptions that ensure that\n+\t zps does not overflow.  */\n+      zps.no_overflow = true;\n+\n+      return number_of_iterations_ne (type, &zps, delta, niter, true);\n     }\n \n-  niter->assumptions = assumptions;\n-  niter->may_be_zero = noloop_assumptions;\n-  return;\n+  /* Make sure that the control iv does not overflow.  */\n+  if (!assert_no_overflow_lt (type, iv0, iv1, niter, step))\n+    return false;\n \n-zero_iter:\n-  niter->assumptions = boolean_true_node;\n-  niter->may_be_zero = boolean_true_node;\n-  niter->niter = build_int_cst_type (type, 0);\n-  return;\n+  /* We determine the number of iterations as (delta + step - 1) / step.  For\n+     this to work, we must know that iv1->base >= iv0->base - step + 1,\n+     otherwise the loop does not roll.  */\n+  assert_loop_rolls_lt (type, iv0, iv1, niter);\n+\n+  s = fold_build2 (MINUS_EXPR, niter_type,\n+\t\t   step, build_int_cst_type (niter_type, 1));\n+  delta = fold_build2 (PLUS_EXPR, niter_type, delta, s);\n+  niter->niter = fold_build2 (FLOOR_DIV_EXPR, niter_type, delta, step);\n+  return true;\n }\n \n+/* Determines number of iterations of loop whose ending condition\n+   is IV0 <= IV1.  TYPE is the type of the iv.  The number of\n+   iterations is stored to NITER.  NEVER_INFINITE is true if\n+   we know that the loop cannot be infinite (we derived this\n+   earlier, and possibly set NITER->assumptions to make sure this\n+   is the case.  */\n+\n+static bool\n+number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n+\t\t\t struct tree_niter_desc *niter, bool never_infinite)\n+{\n+  tree assumption;\n \n-/* Similar to number_of_iterations_cond, but only handles the special\n-   case of loops with step 1 or -1.  The meaning of the arguments\n-   is the same as in number_of_iterations_cond.  The function\n-   returns true if the special case was recognized, false otherwise.  */\n+  /* Say that IV0 is the control variable.  Then IV0 <= IV1 iff\n+     IV0 < IV1 + 1, assuming that IV1 is not equal to the greatest\n+     value of the type.  This we must know anyway, since if it is\n+     equal to this value, the loop rolls forever.  */\n+\n+  if (!never_infinite)\n+    {\n+      if (nonzero_p (iv0->step))\n+\tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t  iv1->base, TYPE_MAX_VALUE (type));\n+      else\n+\tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t  iv0->base, TYPE_MIN_VALUE (type));\n+\n+      if (zero_p (assumption))\n+\treturn false;\n+      if (!nonzero_p (assumption))\n+\tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t  niter->assumptions, assumption);\n+    }\n+\n+  if (nonzero_p (iv0->step))\n+    iv1->base = fold_build2 (PLUS_EXPR, type,\n+\t\t\t     iv1->base, build_int_cst_type (type, 1));\n+  else\n+    iv0->base = fold_build2 (MINUS_EXPR, type,\n+\t\t\t     iv0->base, build_int_cst_type (type, 1));\n+  return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n+}\n+\n+/* Determine the number of iterations according to condition (for staying\n+   inside loop) which compares two induction variables using comparison\n+   operator CODE.  The induction variable on left side of the comparison\n+   is IV0, the right-hand side is IV1.  Both induction variables must have\n+   type TYPE, which must be an integer or pointer type.  The steps of the\n+   ivs must be constants (or NULL_TREE, which is interpreted as constant zero).\n+   \n+   The results (number of iterations and assumptions as described in\n+   comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.\n+   Returns false if it fails to determine number of iterations, true if it\n+   was determined (possibly with some assumptions).  */\n \n static bool\n-number_of_iterations_special (tree type, affine_iv *iv0, enum tree_code code,\n-\t\t\t      affine_iv *iv1, struct tree_niter_desc *niter)\n+number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n+\t\t\t   affine_iv *iv1, struct tree_niter_desc *niter)\n {\n-  tree niter_type = unsigned_type_for (type), mmax, mmin;\n+  bool never_infinite;\n+\n+  /* The meaning of these assumptions is this:\n+     if !assumptions\n+       then the rest of information does not have to be valid\n+     if may_be_zero then the loop does not roll, even if\n+       niter != 0.  */\n+  niter->assumptions = boolean_true_node;\n+  niter->may_be_zero = boolean_false_node;\n+  niter->niter = NULL_TREE;\n+  niter->additional_info = boolean_true_node;\n \n-  /* Make < comparison from > ones.  */\n-  if (code == GE_EXPR\n-      || code == GT_EXPR)\n+  /* Make < comparison from > ones, and for NE_EXPR comparisons, ensure that\n+     the control variable is on lhs.  */\n+  if (code == GE_EXPR || code == GT_EXPR\n+      || (code == NE_EXPR && zero_p (iv0->step)))\n     {\n       SWAP (iv0, iv1);\n       code = swap_tree_comparison (code);\n     }\n \n-  switch (code)\n+  if (POINTER_TYPE_P (type))\n     {\n-    case NE_EXPR:\n-      if (zero_p (iv0->step))\n-\t{\n-\t  if (zero_p (iv1->step))\n-\t    return false;\n-    \t  SWAP (iv0, iv1);\n-\t}\n-      else if (!zero_p (iv1->step))\n-\treturn false;\n+      /* Comparison of pointers is undefined unless both iv0 and iv1 point\n+\t to the same object.  If they do, the control variable cannot wrap\n+\t (as wrap around the bounds of memory will never return a pointer\n+\t that would be guaranteed to point to the same object, even if we\n+\t avoid undefined behavior by casting to size_t and back).  */\n+      iv0->no_overflow = true;\n+      iv1->no_overflow = true;\n+    }\n \n-      if (integer_onep (iv0->step))\n-\t{\n-\t  /* for (i = iv0->base; i != iv1->base; i++)  */\n-\t  niter->assumptions = boolean_true_node;\n-\t  niter->may_be_zero = boolean_false_node;\n-\t  niter->niter = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n-\t  niter->additional_info = boolean_true_node;\n-\t}\n-      else if (integer_all_onesp (iv0->step))\n-\t{\n-\t  /* for (i = iv0->base; i != iv1->base; i--)  */\n-\t  niter->assumptions = boolean_true_node;\n-\t  niter->may_be_zero = boolean_false_node;\n-\t  niter->niter = fold_build2 (MINUS_EXPR, type, iv0->base, iv1->base);\n-\t}\n-      else\n-\treturn false;\n+  /* If the control induction variable does not overflow, the loop obviously\n+     cannot be infinite.  */\n+  if (!zero_p (iv0->step) && iv0->no_overflow)\n+    never_infinite = true;\n+  else if (!zero_p (iv1->step) && iv1->no_overflow)\n+    never_infinite = true;\n+  else\n+    never_infinite = false;\n \n-      break;\n+  /* We can handle the case when neither of the sides of the comparison is\n+     invariant, provided that the test is NE_EXPR.  This rarely occurs in\n+     practice, but it is simple enough to manage.  */\n+  if (!zero_p (iv0->step) && !zero_p (iv1->step))\n+    {\n+      if (code != NE_EXPR)\n+\treturn false;\n \n-    case LT_EXPR:\n-      if ((iv0->step && integer_onep (iv0->step)\n-\t   && zero_p (iv1->step))\n-\t  || (iv1->step && integer_all_onesp (iv1->step)\n-\t      && zero_p (iv0->step)))\n-\t{\n-\t  /* for (i = iv0->base; i < iv1->base; i++)\n-\t     \n-\t     or\n+      iv0->step = fold_binary_to_constant (MINUS_EXPR, type,\n+\t\t\t\t\t   iv0->step, iv1->step);\n+      iv0->no_overflow = false;\n+      iv1->step = NULL_TREE;\n+      iv1->no_overflow = true;\n+    }\n \n-\t     for (i = iv1->base; i > iv0->base; i--).\n-\t     \n-\t     In both cases # of iterations is iv1->base - iv0->base.  */\n+  /* If the result of the comparison is a constant,  the loop is weird.  More\n+     precise handling would be possible, but the situation is not common enough\n+     to waste time on it.  */\n+  if (zero_p (iv0->step) && zero_p (iv1->step))\n+    return false;\n \n-\t  niter->assumptions = boolean_true_node;\n-\t  niter->may_be_zero = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\t    iv0->base, iv1->base);\n-\t  niter->niter = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n-\t}\n-      else\n+  /* Ignore loops of while (i-- < 10) type.  */\n+  if (code != NE_EXPR)\n+    {\n+      if (iv0->step && tree_int_cst_sign_bit (iv0->step))\n \treturn false;\n-      break;\n \n-    case LE_EXPR:\n-      if (POINTER_TYPE_P (type))\n-\t{\n-\t  /* We assume pointer arithmetic never overflows.  */\n-\t  mmin = mmax = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  mmin = TYPE_MIN_VALUE (type);\n-\t  mmax = TYPE_MAX_VALUE (type);\n-\t}\n-\n-      if (iv0->step && integer_onep (iv0->step)\n-\t  && zero_p (iv1->step))\n-\t{\n-\t  /* for (i = iv0->base; i <= iv1->base; i++)  */\n-\t  if (mmax && !iv0->no_overflow)\n-\t    niter->assumptions = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t      iv1->base, mmax);\n-\t  else\n-\t    niter->assumptions = boolean_true_node;\n-\t  iv1->base = fold_build2 (PLUS_EXPR, type, iv1->base,\n-\t\t\t\t   build_int_cst_type (type, 1));\n-\t}\n-      else if (iv1->step && integer_all_onesp (iv1->step)\n-\t       && zero_p (iv0->step))\n-\t{\n-\t  /* for (i = iv1->base; i >= iv0->base; i--)  */\n-\t  if (mmin && !iv1->no_overflow)\n-\t    niter->assumptions = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t      iv0->base, mmin);\n-\t  else\n-\t    niter->assumptions = boolean_true_node;\n-\t  iv0->base = fold_build2 (MINUS_EXPR, type, iv0->base,\n-\t\t\t\t   build_int_cst_type (type, 1));\n-\t}\n-      else\n+      if (!zero_p (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n \treturn false;\n+    }\n \n-      niter->may_be_zero = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\tiv0->base, iv1->base);\n-      niter->niter = fold_build2 (MINUS_EXPR, type, iv1->base, iv0->base);\n-      break;\n+  /* If the loop exits immediatelly, there is nothing to do.  */\n+  if (zero_p (fold_build2 (code, boolean_type_node, iv0->base, iv1->base)))\n+    {\n+      niter->niter = build_int_cst_type (unsigned_type_for (type), 0);\n+      return true;\n+    }\n \n+  /* OK, now we know we have a senseful loop.  Handle several cases, depending\n+     on what comparison operator is used.  */\n+  switch (code)\n+    {\n+    case NE_EXPR:\n+      gcc_assert (zero_p (iv1->step));\n+      return number_of_iterations_ne (type, iv0, iv1->base, niter, never_infinite);\n+    case LT_EXPR:\n+      return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n+    case LE_EXPR:\n+      return number_of_iterations_le (type, iv0, iv1, niter, never_infinite);\n     default:\n       gcc_unreachable ();\n     }\n-\n-  niter->niter = fold_convert (niter_type, niter->niter);\n-  niter->additional_info = boolean_true_node;\n-  return true;\n }\n \n /* Substitute NEW for OLD in EXPR and fold the result.  */\n@@ -987,18 +1001,10 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   if (!simple_iv (loop, stmt, op1, &iv1, false))\n     return false;\n \n-  niter->niter = NULL_TREE;\n-\n-  /* Handle common special cases first, so that we do not need to use\n-     generic (and slow) analysis very often.  */\n-  if (!number_of_iterations_special (type, &iv0, code, &iv1, niter))\n-    {\n-\n-      number_of_iterations_cond (type, &iv0, code, &iv1, niter);\n-\n-      if (!niter->niter)\n-\treturn false;\n-    }\n+  iv0.base = expand_simple_operations (iv0.base);\n+  iv1.base = expand_simple_operations (iv1.base);\n+  if (!number_of_iterations_cond (type, &iv0, code, &iv1, niter))\n+    return false;\n \n   if (optimize >= 3)\n     {"}, {"sha": "0cca7579ee1b26101a1db3bf7ac05446f9c32fed", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f17528ab58fa0a0f627b94bacbae686438b9bd4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7f17528ab58fa0a0f627b94bacbae686438b9bd4", "patch": "@@ -6809,6 +6809,8 @@ tree_fold_gcd (tree a, tree b)\n tree\n unsigned_type_for (tree type)\n {\n+  if (POINTER_TYPE_P (type))\n+    return size_type_node;\n   return lang_hooks.types.unsigned_type (type);\n }\n "}]}