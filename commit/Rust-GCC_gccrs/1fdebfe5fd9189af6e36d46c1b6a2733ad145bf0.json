{"sha": "1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZkZWJmZTVmZDkxODlhZjZlMzZkNDZjMWI2YTI3MzNhZDE0NWJmMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@gnat.com", "date": "2004-10-04T14:58:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-04T14:58:47Z"}, "message": "exp_ch3.adb (Needs_Simple_Initialization): Modular packed arrays no longer need to be initialized to zero.\n\n2004-10-04  Robert Dewar  <dewar@gnat.com>\n\n\t* exp_ch3.adb (Needs_Simple_Initialization): Modular packed arrays no\n\tlonger need to be initialized to zero.\n\t(Get_Simple_Init_Val): Modular packed arrays no longer need to be\n\tinitialized to zero.\n\n\t* checks.adb (Expr_Known_Valid): Packed arrays are now always\n\tconsidered valid, even if the representation is modular. That's correct\n\tnow that we no longer initialize packed modular arrays to zero.\n\n\t* exp_dbug.ads: Clarify documentation on handling of PAD and JM\n\tsuffixes. These are now documented as the only cases in which the\n\tdebugger ignores outer records.\n\tPreviously, the spec allowed arbitrary suffixes for this purpose.\n\tChange name of LJM to JM for packed array pad records\n\tCreate separate section on packed array handling, and add a whole new\n\tset of comments to this section describing the situation with packed\n\tmodular types and justification requirements depending on endianness.\n\nFrom-SVN: r88500", "tree": {"sha": "eee69f9476365cf2db06be3df66d76e53f8c8b30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eee69f9476365cf2db06be3df66d76e53f8c8b30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/comments", "author": null, "committer": null, "parents": [{"sha": "cd91501c62733d6bc51340cbbdcb6ca0b8015524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd91501c62733d6bc51340cbbdcb6ca0b8015524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd91501c62733d6bc51340cbbdcb6ca0b8015524"}], "stats": {"total": 144, "additions": 106, "deletions": 38}, "files": [{"sha": "043d3e120ad04bb2aabaf270bdb9a3d3afa51e61", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "patch": "@@ -1,3 +1,23 @@\n+2004-10-04  Robert Dewar  <dewar@gnat.com>\n+\n+\t* exp_ch3.adb (Needs_Simple_Initialization): Modular packed arrays no\n+\tlonger need to be initialized to zero.\n+\t(Get_Simple_Init_Val): Modular packed arrays no longer need to be\n+\tinitialized to zero.\n+\n+\t* checks.adb (Expr_Known_Valid): Packed arrays are now always\n+\tconsidered valid, even if the representation is modular. That's correct\n+\tnow that we no longer initialize packed modular arrays to zero.\n+\n+\t* exp_dbug.ads: Clarify documentation on handling of PAD and JM\n+\tsuffixes. These are now documented as the only cases in which the\n+\tdebugger ignores outer records.\n+\tPreviously, the spec allowed arbitrary suffixes for this purpose.\n+\tChange name of LJM to JM for packed array pad records\n+\tCreate separate section on packed array handling, and add a whole new\n+\tset of comments to this section describing the situation with packed\n+\tmodular types and justification requirements depending on endianness.\n+\n 2004-10-04  Robert Dewar  <dewar@gnat.com>\n \n \t* a-except.adb: Add a comment for last change"}, {"sha": "357d9f290ecfa37fc5bb34b94c4d9246e7c98c7c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "patch": "@@ -3724,12 +3724,16 @@ package body Checks is\n       Typ : constant Entity_Id := Etype (Expr);\n \n    begin\n-      --  Non-scalar types are always consdered valid, since they never\n+      --  Non-scalar types are always considered valid, since they never\n       --  give rise to the issues of erroneous or bounded error behavior\n       --  that are the concern. In formal reference manual terms the\n-      --  notion of validity only applies to scalar types.\n+      --  notion of validity only applies to scalar types. Note that\n+      --  even when packed arrays are represented using modular types,\n+      --  they are still arrays semantically, so they are also always\n+      --  valid (in particular, the unused bits can be random rubbish\n+      --  without affecting the validity of the array value).\n \n-      if not Is_Scalar_Type (Typ) then\n+      if not Is_Scalar_Type (Typ) or else Is_Packed_Array_Type (Typ) then\n          return True;\n \n       --  If no validity checking, then everything is considered valid"}, {"sha": "52394d376c2c1cd5052071952445e45611e6dc34", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "patch": "@@ -5046,29 +5046,6 @@ package body Exp_Ch3 is\n          return\n            Make_Null (Loc);\n \n-      --  We initialize modular packed bit arrays to zero, to make sure that\n-      --  unused bits are zero, as required (see spec of Exp_Pakd). Also note\n-      --  that this improves gigi code, since the value tracing knows that\n-      --  all bits of the variable start out at zero. The value of zero has\n-      --  to be unchecked converted to the proper array type.\n-\n-      elsif Is_Bit_Packed_Array (T) then\n-         declare\n-            PAT : constant Entity_Id := Packed_Array_Type (T);\n-            Nod : Node_Id;\n-\n-         begin\n-            pragma Assert (Is_Modular_Integer_Type (PAT));\n-\n-            Nod :=\n-              Make_Unchecked_Type_Conversion (Loc,\n-                Subtype_Mark => New_Occurrence_Of (T, Loc),\n-                Expression   => Make_Integer_Literal (Loc, 0));\n-\n-            Set_Etype (Expression (Nod), PAT);\n-            return Nod;\n-         end;\n-\n       --  No other possibilities should arise, since we should only be\n       --  calling Get_Simple_Init_Val if Needs_Simple_Initialization\n       --  returned True, indicating one of the above cases held.\n@@ -5586,8 +5563,6 @@ package body Exp_Ch3 is\n \n       elsif Is_Access_Type (T)\n         or else (Init_Or_Norm_Scalars and then (Is_Scalar_Type (T)))\n-        or else (Is_Bit_Packed_Array (T)\n-                   and then Is_Modular_Integer_Type (Packed_Array_Type (T)))\n       then\n          return True;\n "}, {"sha": "70bcf95af3e7b21a384c7fc5745692bd7ffb42dc", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=1fdebfe5fd9189af6e36d46c1b6a2733ad145bf0", "patch": "@@ -494,18 +494,26 @@ package Exp_Dbug is\n \n       --  In this case the compile generates a structure type y___PAD, which\n       --  has a single field whose name is F. This single field is 64 bits\n-      --  long and contains the actual value.\n+      --  long and contains the actual value. This kind of padding is used\n+      --  when the logical value to be stored is shorter than the object in\n+      --  which it is allocated. For example if a size clause is used to set\n+      --  a size of 256 for a signed integer value, then a typical choice is\n+      --  to wrap a 64-bit integer in a 256 bit PAD structure.\n \n       --  A similar encapsulation is done for some packed array types,\n-      --  in which case the structure type is y___LJM and the field name\n-      --  is OBJECT.\n+      --  in which case the structure type is y___JM and the field name\n+      --  is OBJECT. This is used in the case of a packed array stored\n+      --  in modular representation (see section on representation of\n+      --  packed array objects). In this case the JM wrapping is used to\n+      --  achieve correct positioning of the packed array value (left or\n+      --  right justified in its field depending on endianness.\n \n       --  When the debugger sees an object of a type whose name has a\n-      --  suffix not otherwise mentioned in this specification, the type\n-      --  is a record containing a single field, and the name of that field\n-      --  is all upper-case letters, it should look inside to get the value\n-      --  of the field, and neither the outer structure name, nor the\n-      --  field name should appear when the value is printed.\n+      --  suffix of ___PAD or ___JM, the type will be a record containing\n+      --  a single field, and the name of that field will be all upper case.\n+      --  In this case, it should look inside to get the value of the inner\n+      --  field, and neither the outer structure name, nor the field name\n+      --  should appear when the value is printed.\n \n       -----------------------\n       -- Fixed-Point Types --\n@@ -1074,6 +1082,10 @@ package Exp_Dbug is\n    --  in this manner, it can use the original type to determine the bounds,\n    --  and the component size to determine the packing details.\n \n+   -------------------------------------------\n+   -- Packed Array Representation in Memory --\n+   -------------------------------------------\n+\n    --  Packed arrays are represented in tightly packed form, with no extra\n    --  bits between components. This is true even when the component size\n    --  is not a factor of the storage unit size, so that as a result it is\n@@ -1100,7 +1112,7 @@ package Exp_Dbug is\n \n    --        BV'Address + 2   BV'Address + 1    BV'Address + 0\n    --     +-----------------+-----------------+-----------------+\n-   --     | 0 0 0 0 0 0 1 1 | 0 1 0 1 1 0 0 0 | 1 1 0 1 0 0 0 1 |\n+   --     | ? ? ? ? ? ? 1 1 | 0 1 0 1 1 0 0 0 | 1 1 0 1 0 0 0 1 |\n    --     +-----------------+-----------------+-----------------+\n    --       <---------> <-----> <---> <---> <-----> <---> <--->\n    --       unused bits  BV(5)  BV(4) BV(3)  BV(2)  BV(1) BV(0)\n@@ -1109,11 +1121,68 @@ package Exp_Dbug is\n    --\n    --        BV'Address + 0  BV'Address + 1    BV'Address + 2\n    --     +-----------------+-----------------+-----------------+\n-   --     | 0 0 1 0 1 0 0 1 | 1 1 0 0 1 0 1 1 | 1 0 0 0 0 0 0 0 |\n+   --     | 0 0 1 0 1 0 0 1 | 1 1 0 0 1 0 1 1 | 1 0 ? ? ? ? ? ? |\n    --     +-----------------+-----------------+-----------------+\n    --       <---> <---> <-----> <---> <---> <-----> <--------->\n    --       BV(0) BV(1)  BV(2)  BV(3) BV(4)  BV(5)  unused bits\n \n+   --  Note that if a modular type is used to represent the array, the\n+   --  allocation in memory is not the same as a normal modular type.\n+   --  The difference occurs when the allocated object is larger than\n+   --  the size of the array. For a normal modular type, we extend the\n+   --  value on the left with zeroes.\n+\n+   --  For example, in the normal modular case, if we have a 6-bit\n+   --  modular type, declared as mod 2**6, and we allocate an 8-bit\n+   --  object for this type, then we extend the value with two bits\n+   --  on the most significant end, and in either the little-endian\n+   --  or big-endian case, the value 63 is represented as 00111111\n+   --  in binary in memory.\n+\n+   --  For a modular type used to represent a packed array, the rule is\n+   --  different. In this case, if we have to extend the value, then we\n+   --  do it with undefined bits (which are not initialized and whose value\n+   --  is irrelevant to any generated code). Furthermore these bits are on\n+   --  the right (least significant bits) in the big-endian case, and on the\n+   --  left (most significant bits) in the little-endian case.\n+\n+   --  For example, if we have a packed boolean array of 6 bits, all set\n+   --  to True, stored in an 8-bit object, then the value in memory in\n+   --  binary is ??111111 in the little-endian case, and 111111?? in the\n+   --  big-endian case.\n+\n+   --  This is done so that the representation of packed arrays does not\n+   --  depend on whether we use a modular representation or array of bytes\n+   --  as previously described. This ensures that we can pass such values\n+   --  by reference in the case where a subprogram has to be able to handle\n+   --  values stored in either form.\n+\n+   --  Note that when we extract the value of such a modular packed array,\n+   --  we expect to retrieve only the relevant bits, so in this same example,\n+   --  when we extract the value, we get 111111 in both cases, and the code\n+   --  generated by the front end assumes this, although it does not assume\n+   --  that any high order bits are defined.\n+\n+   --  There are opportunities for optimization based on the knowledge that\n+   --  the unused bits are irrelevant for these type of packed arrays. For\n+   --  example if we have two such 6-bit-in-8-bit values and we do an\n+   --  assignment:\n+\n+   --     a := b;\n+\n+   --  Then logically, we extract the 6 bits and store only 6 bits in the\n+   --  result, but the back end is free to simply assign the entire 8-bits\n+   --  in this case, since we don't actually care about the undefined bits.\n+   --  However, in the equality case, it is important to ensure that the\n+   --  undefined bits do not participate in an equality test.\n+\n+   --  If a modular packed array value is assigned to a register, then\n+   --  logically it could always be held right justified, to avoid any\n+   --  need to shift, e.g. when doing comparisons. But probably this is\n+   --  a bad choice, as it would mean that an assignment such as a := b\n+   --  above would require shifts when one value is in a register and the\n+   --  other value is in memory.\n+\n    ------------------------------------------------------\n    -- Subprograms for Handling Packed Array Type Names --\n    ------------------------------------------------------"}]}