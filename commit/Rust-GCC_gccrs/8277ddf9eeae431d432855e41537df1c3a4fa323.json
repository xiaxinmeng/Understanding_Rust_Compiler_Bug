{"sha": "8277ddf9eeae431d432855e41537df1c3a4fa323", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI3N2RkZjllZWFlNDMxZDQzMjg1NWU0MTUzN2RmMWMzYTRmYTMyMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:59:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:59:15Z"}, "message": "Make ivopts handle calls to internal functions\n\nivopts previously treated pointer arguments to internal functions\nlike IFN_MASK_LOAD and IFN_MASK_STORE as normal gimple values.\nThis patch makes it treat them as addresses instead.  This makes\na significant difference to the code quality for SVE loops,\nsince we can then use loads and stores with scaled indices.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-ssa-loop-ivopts.c (USE_ADDRESS): Split into...\n\t(USE_REF_ADDRESS, USE_PTR_ADDRESS): ...these new use types.\n\t(dump_groups): Update accordingly.\n\t(iv_use::mem_type): New member variable.\n\t(address_p): New function.\n\t(record_use): Add a mem_type argument and initialize the new\n\tmem_type field.\n\t(record_group_use): Add a mem_type argument.  Use address_p.\n\tRemove obsolete null checks of base_object.  Update call to record_use.\n\t(find_interesting_uses_op): Update call to record_group_use.\n\t(find_interesting_uses_cond): Likewise.\n\t(find_interesting_uses_address): Likewise.\n\t(get_mem_type_for_internal_fn): New function.\n\t(find_address_like_use): Likewise.\n\t(find_interesting_uses_stmt): Try find_address_like_use before\n\tcalling find_interesting_uses_op.\n\t(addr_offset_valid_p): Use the iv mem_type field as the type\n\tof the addressed memory.\n\t(add_autoinc_candidates): Likewise.\n\t(get_address_cost): Likewise.\n\t(split_small_address_groups_p): Use address_p.\n\t(split_address_groups): Likewise.\n\t(add_iv_candidate_for_use): Likewise.\n\t(autoinc_possible_for_pair): Likewise.\n\t(rewrite_groups): Likewise.\n\t(get_use_type): Check for USE_REF_ADDRESS instead of USE_ADDRESS.\n\t(determine_group_iv_cost): Update after split of USE_ADDRESS.\n\t(get_alias_ptr_type_for_ptr_address): New function.\n\t(rewrite_use_address): Rewrite address uses in calls that were\n\tidentified by find_address_like_use.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/scev-9.c: Expected REFERENCE ADDRESS\n\tinstead of just ADDRESS.\n\t* gcc.dg/tree-ssa/scev-10.c: Likewise.\n\t* gcc.dg/tree-ssa/scev-11.c: Likewise.\n\t* gcc.dg/tree-ssa/scev-12.c: Likewise.\n\t* gcc.target/aarch64/sve/index_offset_1.c: New test.\n\t* gcc.target/aarch64/sve/index_offset_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/loop_add_2.c: Likewise.\n\t* gcc.target/aarch64/sve/loop_add_3.c: Likewise.\n\t* gcc.target/aarch64/sve/while_1.c: Check for indexed addressing modes.\n\t* gcc.target/aarch64/sve/while_2.c: Likewise.\n\t* gcc.target/aarch64/sve/while_3.c: Likewise.\n\t* gcc.target/aarch64/sve/while_4.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256628", "tree": {"sha": "bed0a4db94bbc95574d514405e02c949cbaf2cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed0a4db94bbc95574d514405e02c949cbaf2cf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8277ddf9eeae431d432855e41537df1c3a4fa323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8277ddf9eeae431d432855e41537df1c3a4fa323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8277ddf9eeae431d432855e41537df1c3a4fa323", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8277ddf9eeae431d432855e41537df1c3a4fa323/comments", "author": null, "committer": null, "parents": [{"sha": "65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65dd1346027bb5dd54d5bfea0c35a3d52f8af416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65dd1346027bb5dd54d5bfea0c35a3d52f8af416"}], "stats": {"total": 393, "additions": 354, "deletions": 39}, "files": [{"sha": "6d198be273f8ce6e6fec61f971174530d4043f11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -1,3 +1,38 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (USE_ADDRESS): Split into...\n+\t(USE_REF_ADDRESS, USE_PTR_ADDRESS): ...these new use types.\n+\t(dump_groups): Update accordingly.\n+\t(iv_use::mem_type): New member variable.\n+\t(address_p): New function.\n+\t(record_use): Add a mem_type argument and initialize the new\n+\tmem_type field.\n+\t(record_group_use): Add a mem_type argument.  Use address_p.\n+\tRemove obsolete null checks of base_object.  Update call to record_use.\n+\t(find_interesting_uses_op): Update call to record_group_use.\n+\t(find_interesting_uses_cond): Likewise.\n+\t(find_interesting_uses_address): Likewise.\n+\t(get_mem_type_for_internal_fn): New function.\n+\t(find_address_like_use): Likewise.\n+\t(find_interesting_uses_stmt): Try find_address_like_use before\n+\tcalling find_interesting_uses_op.\n+\t(addr_offset_valid_p): Use the iv mem_type field as the type\n+\tof the addressed memory.\n+\t(add_autoinc_candidates): Likewise.\n+\t(get_address_cost): Likewise.\n+\t(split_small_address_groups_p): Use address_p.\n+\t(split_address_groups): Likewise.\n+\t(add_iv_candidate_for_use): Likewise.\n+\t(autoinc_possible_for_pair): Likewise.\n+\t(rewrite_groups): Likewise.\n+\t(get_use_type): Check for USE_REF_ADDRESS instead of USE_ADDRESS.\n+\t(determine_group_iv_cost): Update after split of USE_ADDRESS.\n+\t(get_alias_ptr_type_for_ptr_address): New function.\n+\t(rewrite_use_address): Rewrite address uses in calls that were\n+\tidentified by find_address_like_use.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "c59919ab3c4238569c64db1fd117b219f21237ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -1,3 +1,21 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/tree-ssa/scev-9.c: Expected REFERENCE ADDRESS\n+\tinstead of just ADDRESS.\n+\t* gcc.dg/tree-ssa/scev-10.c: Likewise.\n+\t* gcc.dg/tree-ssa/scev-11.c: Likewise.\n+\t* gcc.dg/tree-ssa/scev-12.c: Likewise.\n+\t* gcc.target/aarch64/sve/index_offset_1.c: New test.\n+\t* gcc.target/aarch64/sve/index_offset_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/loop_add_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/loop_add_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_1.c: Check for indexed addressing modes.\n+\t* gcc.target/aarch64/sve/while_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_4.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "6c4fca79fa4ae389c045d63bc7c8c9687139e80e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -18,5 +18,5 @@ foo (signed char s, signed char l)\n }\n \n /* Address of array reference is scev.  */\n-/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tREFERENCE ADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n "}, {"sha": "c665fd7f20d241ac3441b7676f72b241c9eccc99", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-11.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -23,4 +23,4 @@ foo (int n)\n }\n \n /* Address of array reference to b is scev.  */\n-/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 2 \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tREFERENCE ADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 2 \"ivopts\" } } */"}, {"sha": "f598c7b2955e1c939050a2c134a23bed46f10bd9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-12.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -24,4 +24,4 @@ foo (int x, int n)\n }\n \n /* Address of array reference to b is not scev.  */\n-/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tREFERENCE ADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */"}, {"sha": "2863918a687fbf5639687f8b04bcc05b348395eb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -18,5 +18,5 @@ foo (unsigned char s, unsigned char l)\n }\n \n /* Address of array reference is scev.  */\n-/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tREFERENCE ADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n "}, {"sha": "31d46aab96077b3deb8bc074d1d542f11eb68aaf", "filename": "gcc/testsuite/gcc.target/aarch64/sve/index_offset_1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Findex_offset_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Findex_offset_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Findex_offset_1.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256\" } */\n+\n+#define SIZE (15 * 8 + 3)\n+\n+#define DEF_INDEX_OFFSET(SIGNED, TYPE, ITERTYPE)\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+set_##SIGNED##_##TYPE##_##ITERTYPE (SIGNED TYPE *restrict out,\t\t\\\n+\t\t\t\t    SIGNED TYPE *restrict in)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  SIGNED ITERTYPE i;\t\t\t\t\t\t\t\\\n+  for (i = 0; i < SIZE; i++)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    out[i] = in[i];\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+set_##SIGNED##_##TYPE##_##ITERTYPE##_var (SIGNED TYPE *restrict out,\t\\\n+\t\t\t\t\t  SIGNED TYPE *restrict in,\t\\\n+\t\t\t\t\t  SIGNED ITERTYPE n)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  SIGNED ITERTYPE i;\t\t\t\t\t\t\t\\\n+  for (i = 0; i < n; i++)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    out[i] = in[i];\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_TYPE(T, SIGNED, TYPE)\t\t\\\n+  T (SIGNED, TYPE, char)\t\t\t\\\n+  T (SIGNED, TYPE, short)\t\t\t\\\n+  T (SIGNED, TYPE, int)\t\t\t\t\\\n+  T (SIGNED, TYPE, long)\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  TEST_TYPE (T, signed, long)\t\t\t\\\n+  TEST_TYPE (T, unsigned, long)\t\t\t\\\n+  TEST_TYPE (T, signed, int)\t\t\t\\\n+  TEST_TYPE (T, unsigned, int)\t\t\t\\\n+  TEST_TYPE (T, signed, short)\t\t\t\\\n+  TEST_TYPE (T, unsigned, short)\t\t\\\n+  TEST_TYPE (T, signed, char)\t\t\t\\\n+  TEST_TYPE (T, unsigned, char)\n+\n+TEST_ALL (DEF_INDEX_OFFSET)\n+\n+/* { dg-final { scan-assembler-times \"ld1d\\\\tz\\[0-9\\]+.d, p\\[0-9\\]+/z, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+, lsl 3\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"st1d\\\\tz\\[0-9\\]+.d, p\\[0-9\\]+, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+, lsl 3\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"ld1w\\\\tz\\[0-9\\]+.s, p\\[0-9\\]+/z, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+, lsl 2\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"st1w\\\\tz\\[0-9\\]+.s, p\\[0-9\\]+, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+, lsl 2\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"ld1h\\\\tz\\[0-9\\]+.h, p\\[0-9\\]+/z, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+, lsl 1\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"st1h\\\\tz\\[0-9\\]+.h, p\\[0-9\\]+, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+, lsl 1\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"ld1b\\\\tz\\[0-9\\]+.b, p\\[0-9\\]+/z, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+\\\\\\]\" 16 } } */\n+/* { dg-final { scan-assembler-times \"st1b\\\\tz\\[0-9\\]+.b, p\\[0-9\\]+, \\\\\\[x\\[0-9\\]+, x\\[0-9\\]+\\\\\\]\" 16 } } */"}, {"sha": "00114acfe49e1181dead7e519bf23bd2c4e30882", "filename": "gcc/testsuite/gcc.target/aarch64/sve/index_offset_1_run.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Findex_offset_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Findex_offset_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Findex_offset_1_run.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256\" { target aarch64_sve256_hw } } */\n+\n+#include \"index_offset_1.c\"\n+\n+#define TEST_INDEX_OFFSET(SIGNED, TYPE, ITERTYPE)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  SIGNED TYPE out[SIZE + 1];\t\t\t\t\t\\\n+  SIGNED TYPE in1[SIZE + 1];\t\t\t\t\t\\\n+  SIGNED TYPE in2[SIZE + 1];\t\t\t\t\t\\\n+  for (int i = 0; i < SIZE + 1; ++i)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      in1[i] = (i * 4) ^ i;\t\t\t\t\t\\\n+      in2[i] = (i * 2) ^ i;\t\t\t\t\t\\\n+      asm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  out[SIZE] = 42;\t\t\t\t\t\t\\\n+  set_##SIGNED##_##TYPE##_##ITERTYPE (out, in1);\t\t\\\n+  if (0 != __builtin_memcmp (out, in1, SIZE * sizeof (TYPE)))\t\\\n+    __builtin_abort ();\t\t\t\t\t\t\\\n+  set_##SIGNED##_##TYPE##_##ITERTYPE##_var (out, in2, SIZE);\t\\\n+  if (0 != __builtin_memcmp (out, in2, SIZE * sizeof (TYPE)))\t\\\n+    __builtin_abort ();\t\t\t\t\t\t\\\n+  if (out[SIZE] != 42)\t\t\t\t\t\t\\\n+    __builtin_abort ();\t\t\t\t\t\t\\\n+}\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (TEST_INDEX_OFFSET);\n+  return 0;\n+}"}, {"sha": "a58ba0b5d5d536f41b2e30156b02d22015c2ef25", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_2.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -O3\" } */\n+\n+void\n+foo (int *__restrict a, int *__restrict b)\n+{\n+  for (int i = 0; i < 512; ++i)\n+    a[i] += b[i];\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+.s, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+.s, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 1 } } */"}, {"sha": "9d2c5981cd763a6266d4a762afc1fb4e03ae2e11", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_3.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -O3\" } */\n+\n+void\n+f (int *__restrict a,\n+   int *__restrict b,\n+   int *__restrict c,\n+   int *__restrict d,\n+   int *__restrict e,\n+   int *__restrict f,\n+   int *__restrict g,\n+   int *__restrict h,\n+   int count)\n+{\n+  for (int i = 0; i < count; ++i)\n+    a[i] = b[i] + c[i] + d[i] + e[i] + f[i] + g[i] + h[i];\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+.s, p[0-7]+/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 7 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+.s, p[0-7]+, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 1 } } */"}, {"sha": "a93a04baa3beb12c2822a0211d7bbe4cc9ccdb3b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_1.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -34,3 +34,11 @@ TEST_ALL (ADD_LOOP)\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7], \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7], \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */"}, {"sha": "69bb6cb0e1a4520f3dda3f776a2586a46189cfdb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_2.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_2.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -34,3 +34,11 @@ TEST_ALL (ADD_LOOP)\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7], \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7], \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */"}, {"sha": "f805c2fc57d63d2d1f9812ed433e5dd90e9da65d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_3.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_3.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -34,3 +34,11 @@ TEST_ALL (ADD_LOOP)\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7], \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7], \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */"}, {"sha": "e7aa99f3b87135635f21eb3cac7e51eff876e979", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_4.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_4.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -35,3 +35,11 @@ TEST_ALL (ADD_LOOP)\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7], \\[x0, x[0-9]+\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7], \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x0, x[0-9]+, lsl 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x0, x[0-9]+, lsl 3\\]\\n} 3 } } */"}, {"sha": "b3135717f22c7f71d9a066438647ef7d557df01a", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 145, "deletions": 35, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8277ddf9eeae431d432855e41537df1c3a4fa323/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8277ddf9eeae431d432855e41537df1c3a4fa323", "patch": "@@ -166,7 +166,11 @@ struct version_info\n enum use_type\n {\n   USE_NONLINEAR_EXPR,\t/* Use in a nonlinear expression.  */\n-  USE_ADDRESS,\t\t/* Use in an address.  */\n+  USE_REF_ADDRESS,\t/* Use is an address for an explicit memory\n+\t\t\t   reference.  */\n+  USE_PTR_ADDRESS,\t/* Use is a pointer argument to a function in\n+\t\t\t   cases where the expansion of the function\n+\t\t\t   will turn the argument into a normal address.  */\n   USE_COMPARE\t\t/* Use is a compare.  */\n };\n \n@@ -362,6 +366,9 @@ struct iv_use\n   unsigned id;\t\t/* The id of the use.  */\n   unsigned group_id;\t/* The group id the use belongs to.  */\n   enum use_type type;\t/* Type of the use.  */\n+  tree mem_type;\t/* The memory type to use when testing whether an\n+\t\t\t   address is legitimate, and what the address's\n+\t\t\t   cost is.  */\n   struct iv *iv;\t/* The induction variable it is based on.  */\n   gimple *stmt;\t\t/* Statement in that it occurs.  */\n   tree *op_p;\t\t/* The place where it occurs.  */\n@@ -506,6 +513,14 @@ struct iv_inv_expr_hasher : free_ptr_hash <iv_inv_expr_ent>\n   static inline bool equal (const iv_inv_expr_ent *, const iv_inv_expr_ent *);\n };\n \n+/* Return true if uses of type TYPE represent some form of address.  */\n+\n+inline bool\n+address_p (use_type type)\n+{\n+  return type == USE_REF_ADDRESS || type == USE_PTR_ADDRESS;\n+}\n+\n /* Hash function for loop invariant expressions.  */\n \n inline hashval_t\n@@ -768,8 +783,10 @@ dump_groups (FILE *file, struct ivopts_data *data)\n       fprintf (file, \"Group %d:\\n\", group->id);\n       if (group->type == USE_NONLINEAR_EXPR)\n \tfprintf (file, \"  Type:\\tGENERIC\\n\");\n-      else if (group->type == USE_ADDRESS)\n-\tfprintf (file, \"  Type:\\tADDRESS\\n\");\n+      else if (group->type == USE_REF_ADDRESS)\n+\tfprintf (file, \"  Type:\\tREFERENCE ADDRESS\\n\");\n+      else if (group->type == USE_PTR_ADDRESS)\n+\tfprintf (file, \"  Type:\\tPOINTER ARGUMENT ADDRESS\\n\");\n       else\n \t{\n \t  gcc_assert (group->type == USE_COMPARE);\n@@ -1502,19 +1519,21 @@ find_induction_variables (struct ivopts_data *data)\n \n /* Records a use of TYPE at *USE_P in STMT whose value is IV in GROUP.\n    For address type use, ADDR_BASE is the stripped IV base, ADDR_OFFSET\n-   is the const offset stripped from IV base; for other types use, both\n-   are zero by default.  */\n+   is the const offset stripped from IV base and MEM_TYPE is the type\n+   of the memory being addressed.  For uses of other types, ADDR_BASE\n+   and ADDR_OFFSET are zero by default and MEM_TYPE is NULL_TREE.  */\n \n static struct iv_use *\n record_use (struct iv_group *group, tree *use_p, struct iv *iv,\n-\t    gimple *stmt, enum use_type type, tree addr_base,\n-\t    poly_uint64 addr_offset)\n+\t    gimple *stmt, enum use_type type, tree mem_type,\n+\t    tree addr_base, poly_uint64 addr_offset)\n {\n   struct iv_use *use = XCNEW (struct iv_use);\n \n   use->id = group->vuses.length ();\n   use->group_id = group->id;\n   use->type = type;\n+  use->mem_type = mem_type;\n   use->iv = iv;\n   use->stmt = stmt;\n   use->op_p = use_p;\n@@ -1569,18 +1588,21 @@ record_group (struct ivopts_data *data, enum use_type type)\n }\n \n /* Record a use of TYPE at *USE_P in STMT whose value is IV in a group.\n-   New group will be created if there is no existing group for the use.  */\n+   New group will be created if there is no existing group for the use.\n+   MEM_TYPE is the type of memory being addressed, or NULL if this\n+   isn't an address reference.  */\n \n static struct iv_use *\n record_group_use (struct ivopts_data *data, tree *use_p,\n-\t\t  struct iv *iv, gimple *stmt, enum use_type type)\n+\t\t  struct iv *iv, gimple *stmt, enum use_type type,\n+\t\t  tree mem_type)\n {\n   tree addr_base = NULL;\n   struct iv_group *group = NULL;\n   poly_uint64 addr_offset = 0;\n \n   /* Record non address type use in a new group.  */\n-  if (type == USE_ADDRESS && iv->base_object)\n+  if (address_p (type))\n     {\n       unsigned int i;\n \n@@ -1591,7 +1613,7 @@ record_group_use (struct ivopts_data *data, tree *use_p,\n \n \t  group = data->vgroups[i];\n \t  use = group->vuses[0];\n-\t  if (use->type != USE_ADDRESS || !use->iv->base_object)\n+\t  if (!address_p (use->type))\n \t    continue;\n \n \t  /* Check if it has the same stripped base and step.  */\n@@ -1607,7 +1629,8 @@ record_group_use (struct ivopts_data *data, tree *use_p,\n   if (!group)\n     group = record_group (data, type);\n \n-  return record_use (group, use_p, iv, stmt, type, addr_base, addr_offset);\n+  return record_use (group, use_p, iv, stmt, type, mem_type,\n+\t\t     addr_base, addr_offset);\n }\n \n /* Checks whether the use OP is interesting and if so, records it.  */\n@@ -1641,7 +1664,7 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n   stmt = SSA_NAME_DEF_STMT (op);\n   gcc_assert (gimple_code (stmt) == GIMPLE_PHI || is_gimple_assign (stmt));\n \n-  use = record_group_use (data, NULL, iv, stmt, USE_NONLINEAR_EXPR);\n+  use = record_group_use (data, NULL, iv, stmt, USE_NONLINEAR_EXPR, NULL_TREE);\n   iv->nonlin_use = use;\n   return use;\n }\n@@ -1757,10 +1780,10 @@ find_interesting_uses_cond (struct ivopts_data *data, gimple *stmt)\n       return;\n     }\n \n-  record_group_use (data, var_p, var_iv, stmt, USE_COMPARE);\n+  record_group_use (data, var_p, var_iv, stmt, USE_COMPARE, NULL_TREE);\n   /* Record compare type iv_use for iv on the other side of comparison.  */\n   if (ret == COMP_IV_EXPR_2)\n-    record_group_use (data, bound_p, bound_iv, stmt, USE_COMPARE);\n+    record_group_use (data, bound_p, bound_iv, stmt, USE_COMPARE, NULL_TREE);\n }\n \n /* Returns the outermost loop EXPR is obviously invariant in\n@@ -2375,7 +2398,7 @@ find_interesting_uses_address (struct ivopts_data *data, gimple *stmt,\n   if (civ->base_object == NULL_TREE)\n     goto fail;\n \n-  record_group_use (data, op_p, civ, stmt, USE_ADDRESS);\n+  record_group_use (data, op_p, civ, stmt, USE_REF_ADDRESS, TREE_TYPE (*op_p));\n   return;\n \n fail:\n@@ -2398,6 +2421,55 @@ find_invariants_stmt (struct ivopts_data *data, gimple *stmt)\n     }\n }\n \n+/* CALL calls an internal function.  If operand *OP_P will become an\n+   address when the call is expanded, return the type of the memory\n+   being addressed, otherwise return null.  */\n+\n+static tree\n+get_mem_type_for_internal_fn (gcall *call, tree *op_p)\n+{\n+  switch (gimple_call_internal_fn (call))\n+    {\n+    case IFN_MASK_LOAD:\n+      if (op_p == gimple_call_arg_ptr (call, 0))\n+\treturn TREE_TYPE (gimple_call_lhs (call));\n+      return NULL_TREE;\n+\n+    case IFN_MASK_STORE:\n+      if (op_p == gimple_call_arg_ptr (call, 0))\n+\treturn TREE_TYPE (gimple_call_arg (call, 3));\n+      return NULL_TREE;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* IV is a (non-address) iv that describes operand *OP_P of STMT.\n+   Return true if the operand will become an address when STMT\n+   is expanded and record the associated address use if so.  */\n+\n+static bool\n+find_address_like_use (struct ivopts_data *data, gimple *stmt, tree *op_p,\n+\t\t       struct iv *iv)\n+{\n+  /* Fail if base object of this memory reference is unknown.  */\n+  if (iv->base_object == NULL_TREE)\n+    return false;\n+\n+  tree mem_type = NULL_TREE;\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    if (gimple_call_internal_p (call))\n+      mem_type = get_mem_type_for_internal_fn (call, op_p);\n+  if (mem_type)\n+    {\n+      iv = alloc_iv (data, iv->base, iv->step);\n+      record_group_use (data, op_p, iv, stmt, USE_PTR_ADDRESS, mem_type);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Finds interesting uses of induction variables in the statement STMT.  */\n \n static void\n@@ -2482,7 +2554,8 @@ find_interesting_uses_stmt (struct ivopts_data *data, gimple *stmt)\n       if (!iv)\n \tcontinue;\n \n-      find_interesting_uses_op (data, op);\n+      if (!find_address_like_use (data, stmt, use_p->use, iv))\n+\tfind_interesting_uses_op (data, op);\n     }\n }\n \n@@ -2516,7 +2589,7 @@ addr_offset_valid_p (struct iv_use *use, poly_int64 offset)\n   rtx reg, addr;\n   unsigned list_index;\n   addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n-  machine_mode addr_mode, mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+  machine_mode addr_mode, mem_mode = TYPE_MODE (use->mem_type);\n \n   list_index = (unsigned) as * MAX_MACHINE_MODE + (unsigned) mem_mode;\n   if (list_index >= vec_safe_length (addr_list))\n@@ -2573,7 +2646,7 @@ split_small_address_groups_p (struct ivopts_data *data)\n       if (group->vuses.length () == 1)\n \tcontinue;\n \n-      gcc_assert (group->type == USE_ADDRESS);\n+      gcc_assert (address_p (group->type));\n       if (group->vuses.length () == 2)\n \t{\n \t  if (compare_sizes_for_sort (group->vuses[0]->addr_offset,\n@@ -2625,7 +2698,7 @@ split_address_groups (struct ivopts_data *data)\n       if (group->vuses.length () == 1)\n \tcontinue;\n \n-      gcc_assert (group->type == USE_ADDRESS);\n+      gcc_assert (address_p (use->type));\n \n       for (j = 1; j < group->vuses.length ();)\n \t{\n@@ -3145,7 +3218,7 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n \n   cstepi = int_cst_value (step);\n \n-  mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+  mem_mode = TYPE_MODE (use->mem_type);\n   if (((USE_LOAD_PRE_INCREMENT (mem_mode)\n \t|| USE_STORE_PRE_INCREMENT (mem_mode))\n        && known_eq (GET_MODE_SIZE (mem_mode), cstepi))\n@@ -3436,7 +3509,7 @@ add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)\n   /* At last, add auto-incremental candidates.  Make such variables\n      important since other iv uses with same base object may be based\n      on it.  */\n-  if (use != NULL && use->type == USE_ADDRESS)\n+  if (use != NULL && address_p (use->type))\n     add_autoinc_candidates (data, iv->base, iv->step, true, use);\n }\n \n@@ -3903,7 +3976,7 @@ get_use_type (struct iv_use *use)\n   tree base_type = TREE_TYPE (use->iv->base);\n   tree type;\n \n-  if (use->type == USE_ADDRESS)\n+  if (use->type == USE_REF_ADDRESS)\n     {\n       /* The base_type may be a void pointer.  Create a pointer type based on\n \t the mem_ref instead.  */\n@@ -4331,7 +4404,7 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n   struct mem_address parts = {NULL_TREE, integer_one_node,\n \t\t\t      NULL_TREE, NULL_TREE, NULL_TREE};\n   machine_mode addr_mode = TYPE_MODE (type);\n-  machine_mode mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+  machine_mode mem_mode = TYPE_MODE (use->mem_type);\n   addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n   /* Only true if ratio != 1.  */\n   bool ok_with_ratio_p = false;\n@@ -5220,7 +5293,8 @@ determine_group_iv_cost (struct ivopts_data *data,\n     case USE_NONLINEAR_EXPR:\n       return determine_group_iv_cost_generic (data, group, cand);\n \n-    case USE_ADDRESS:\n+    case USE_REF_ADDRESS:\n+    case USE_PTR_ADDRESS:\n       return determine_group_iv_cost_address (data, group, cand);\n \n     case USE_COMPARE:\n@@ -5238,7 +5312,7 @@ static bool\n autoinc_possible_for_pair (struct ivopts_data *data, struct iv_use *use,\n \t\t\t   struct iv_cand *cand)\n {\n-  if (use->type != USE_ADDRESS)\n+  if (!address_p (use->type))\n     return false;\n \n   bool can_autoinc = false;\n@@ -6997,6 +7071,27 @@ adjust_iv_update_pos (struct iv_cand *cand, struct iv_use *use)\n   cand->incremented_at = use->stmt;\n }\n \n+/* Return the alias pointer type that should be used for a MEM_REF\n+   associated with USE, which has type USE_PTR_ADDRESS.  */\n+\n+static tree\n+get_alias_ptr_type_for_ptr_address (iv_use *use)\n+{\n+  gcall *call = as_a <gcall *> (use->stmt);\n+  switch (gimple_call_internal_fn (call))\n+    {\n+    case IFN_MASK_LOAD:\n+    case IFN_MASK_STORE:\n+      /* The second argument contains the correct alias type.  */\n+      gcc_assert (use->op_p = gimple_call_arg_ptr (call, 0));\n+      return TREE_TYPE (gimple_call_arg (call, 1));\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n /* Rewrites USE (address that is an iv) using candidate CAND.  */\n \n static void\n@@ -7025,16 +7120,31 @@ rewrite_use_address (struct ivopts_data *data,\n   tree iv = var_at_stmt (data->current_loop, cand, use->stmt);\n   tree base_hint = (cand->iv->base_object) ? iv : NULL_TREE;\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n-  tree type = TREE_TYPE (*use->op_p);\n-  unsigned int align = get_object_alignment (*use->op_p);\n-  if (align != TYPE_ALIGN (type))\n-    type = build_aligned_type (type, align);\n-\n-  tree ref = create_mem_ref (&bsi, type, &aff,\n-\t\t\t     reference_alias_ptr_type (*use->op_p),\n+  tree type = use->mem_type;\n+  tree alias_ptr_type;\n+  if (use->type == USE_PTR_ADDRESS)\n+    alias_ptr_type = get_alias_ptr_type_for_ptr_address (use);\n+  else\n+    {\n+      gcc_assert (type == TREE_TYPE (*use->op_p));\n+      unsigned int align = get_object_alignment (*use->op_p);\n+      if (align != TYPE_ALIGN (type))\n+\ttype = build_aligned_type (type, align);\n+      alias_ptr_type = reference_alias_ptr_type (*use->op_p);\n+    }\n+  tree ref = create_mem_ref (&bsi, type, &aff, alias_ptr_type,\n \t\t\t     iv, base_hint, data->speed);\n \n-  copy_ref_info (ref, *use->op_p);\n+  if (use->type == USE_PTR_ADDRESS)\n+    {\n+      ref = fold_build1 (ADDR_EXPR, build_pointer_type (use->mem_type), ref);\n+      ref = fold_convert (get_use_type (use), ref);\n+      ref = force_gimple_operand_gsi (&bsi, ref, true, NULL_TREE,\n+\t\t\t\t      true, GSI_SAME_STMT);\n+    }\n+  else\n+    copy_ref_info (ref, *use->op_p);\n+\n   *use->op_p = ref;\n }\n \n@@ -7110,7 +7220,7 @@ rewrite_groups (struct ivopts_data *data)\n \t      update_stmt (group->vuses[j]->stmt);\n \t    }\n \t}\n-      else if (group->type == USE_ADDRESS)\n+      else if (address_p (group->type))\n \t{\n \t  for (j = 0; j < group->vuses.length (); j++)\n \t    {"}]}