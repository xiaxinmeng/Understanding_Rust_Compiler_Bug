{"sha": "41bf2a8b17267a42615392ad9da37081f59e428c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFiZjJhOGIxNzI2N2E0MjYxNTM5MmFkOWRhMzcwODFmNTllNDI4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-09-24T19:47:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-24T19:47:05Z"}, "message": "re PR middle-end/17503 (quadratic behaviour in invalid_mode_change_p)\n\n        PR rtl-opt/17503\n        * regclass.c (subregs_of_mode): Turn into an htab.  Make static.\n        (som_hash, som_eq): New.\n        (init_subregs_of_mode, record_subregs_of_mode): New.\n        (cannot_change_mode_set_regs): Rewrite for htab implementation.\n        (invalid_mode_change_p): Likewise.\n        * combine.c (gen_lowpart_for_combine): Use record_subregs_of_mode.\n        * flow.c (mark_used_regs): Likewise.\n        (life_analysis): Use init_subregs_of_mode.\n        * regs.h (subregs_of_mode): Remove.\n        * rtl.h (init_subregs_of_mode, record_subregs_of_mode): Declare.\n\nFrom-SVN: r88067", "tree": {"sha": "8f489fcd2a7911641c9c974bdfda7d1ab77702cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f489fcd2a7911641c9c974bdfda7d1ab77702cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41bf2a8b17267a42615392ad9da37081f59e428c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bf2a8b17267a42615392ad9da37081f59e428c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41bf2a8b17267a42615392ad9da37081f59e428c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bf2a8b17267a42615392ad9da37081f59e428c/comments", "author": null, "committer": null, "parents": [{"sha": "84f7a28c9b3fe007dbbdd332643cb6858997ba8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f7a28c9b3fe007dbbdd332643cb6858997ba8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84f7a28c9b3fe007dbbdd332643cb6858997ba8f"}], "stats": {"total": 173, "additions": 120, "deletions": 53}, "files": [{"sha": "070d85c8254cc3a796a986961944107b631b8238", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41bf2a8b17267a42615392ad9da37081f59e428c", "patch": "@@ -1,3 +1,17 @@\n+2004-09-24  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/17503\n+\t* regclass.c (subregs_of_mode): Turn into an htab.  Make static.\n+\t(som_hash, som_eq): New.\n+\t(init_subregs_of_mode, record_subregs_of_mode): New.\n+\t(cannot_change_mode_set_regs): Rewrite for htab implementation.\n+\t(invalid_mode_change_p): Likewise.\n+\t* combine.c (gen_lowpart_for_combine): Use record_subregs_of_mode.\n+\t* flow.c (mark_used_regs): Likewise.\n+\t(life_analysis): Use init_subregs_of_mode.\n+\t* regs.h (subregs_of_mode): Remove.\n+\t* rtl.h (init_subregs_of_mode, record_subregs_of_mode): Declare.\n+\n 2004-09-24  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* tree-ssa-phiopt.c (conditional_replacement): Use the correct"}, {"sha": "f0b5b0698dd04c5274fbb3eadafc597e24097c93", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=41bf2a8b17267a42615392ad9da37081f59e428c", "patch": "@@ -9327,13 +9327,8 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n \n   result = gen_lowpart_common (mode, x);\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-  if (result != 0\n-      && GET_CODE (result) == SUBREG\n-      && REG_P (SUBREG_REG (result))\n-      && REGNO (SUBREG_REG (result)) >= FIRST_PSEUDO_REGISTER)\n-    bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (result))\n-\t\t\t\t      * MAX_MACHINE_MODE\n-\t\t\t\t      + GET_MODE (result));\n+  if (result != 0 && GET_CODE (result) == SUBREG)\n+    record_subregs_of_mode (result);\n #endif\n \n   if (result)"}, {"sha": "02f7ff215051b7d52f76ebb987d8658675ac589b", "filename": "gcc/flow.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=41bf2a8b17267a42615392ad9da37081f59e428c", "patch": "@@ -377,7 +377,7 @@ life_analysis (FILE *file, int flags)\n \n #ifdef CANNOT_CHANGE_MODE_CLASS\n   if (flags & PROP_REG_INFO)\n-    bitmap_initialize (&subregs_of_mode, 1);\n+    init_subregs_of_mode ();\n #endif\n \n   if (! optimize)\n@@ -3773,12 +3773,8 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \n     case SUBREG:\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-      if ((flags & PROP_REG_INFO)\n-\t  && REG_P (SUBREG_REG (x))\n-\t  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n-\tbitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (x))\n-\t\t\t\t\t  * MAX_MACHINE_MODE\n-\t\t\t\t\t  + GET_MODE (x));\n+      if (flags & PROP_REG_INFO)\n+\trecord_subregs_of_mode (x);\n #endif\n \n       /* While we're here, optimize this case.  */\n@@ -3823,13 +3819,8 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \t       || GET_CODE (testreg) == SUBREG)\n \t  {\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t    if ((flags & PROP_REG_INFO)\n-\t\t&& GET_CODE (testreg) == SUBREG\n-\t\t&& REG_P (SUBREG_REG (testreg))\n-\t\t&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER)\n-\t      bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (testreg))\n-\t\t\t\t\t\t* MAX_MACHINE_MODE\n-\t\t\t\t\t\t+ GET_MODE (testreg));\n+\t    if ((flags & PROP_REG_INFO) && GET_CODE (testreg) == SUBREG)\n+\t      record_subregs_of_mode (testreg);\n #endif\n \n \t    /* Modifying a single register in an alternate mode"}, {"sha": "6d1d975f093bfc893f4a236598aafb8d7800a733", "filename": "gcc/regclass.c", "status": "modified", "additions": 97, "deletions": 30, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=41bf2a8b17267a42615392ad9da37081f59e428c", "patch": "@@ -45,6 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"ggc.h\"\n #include \"timevar.h\"\n+#include \"hashtab.h\"\n \n static void init_reg_sets_1 (void);\n static void init_reg_autoinc (void);\n@@ -235,12 +236,6 @@ static char *in_inc_dec;\n \n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-/* All registers that have been subreged.  Indexed by regno * MAX_MACHINE_MODE\n-   + mode.  */\n-bitmap_head subregs_of_mode;\n-#endif\n-\n /* Sample MEM values for use by memory_move_secondary_cost.  */\n \n static GTY(()) rtx top_of_stack[MAX_MACHINE_MODE];\n@@ -2594,47 +2589,119 @@ regset_release_memory (void)\n }\n \n #ifdef CANNOT_CHANGE_MODE_CLASS\n+\n+struct subregs_of_mode_node\n+{\n+  unsigned int block;\n+  unsigned char modes[MAX_MACHINE_MODE];\n+};\n+\n+static htab_t subregs_of_mode;\n+\n+static hashval_t\n+som_hash (const void *x)\n+{\n+  const struct subregs_of_mode_node *a = x;\n+  return a->block;\n+}\n+\n+static int\n+som_eq (const void *x, const void *y)\n+{\n+  const struct subregs_of_mode_node *a = x;\n+  const struct subregs_of_mode_node *b = y;\n+  return a->block == b->block;\n+}\n+\n+void\n+init_subregs_of_mode (void)\n+{\n+  if (subregs_of_mode)\n+    htab_empty (subregs_of_mode);\n+  else\n+    subregs_of_mode = htab_create (100, som_hash, som_eq, free);\n+}\n+\n+void\n+record_subregs_of_mode (rtx subreg)\n+{\n+  struct subregs_of_mode_node dummy, *node;\n+  enum machine_mode mode;\n+  unsigned int regno;\n+  void **slot;\n+\n+  if (!REG_P (SUBREG_REG (subreg)))\n+    return;\n+\n+  regno = REGNO (SUBREG_REG (subreg));\n+  mode = GET_MODE (subreg);\n+\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  dummy.block = regno & -8;\n+  slot = htab_find_slot_with_hash (subregs_of_mode, &dummy,\n+\t\t\t\t   dummy.block, INSERT);\n+  node = *slot;\n+  if (node == NULL)\n+    {\n+      node = xcalloc (1, sizeof (*node));\n+      node->block = regno & -8;\n+      *slot = node;\n+    }\n+\n+  node->modes[mode] |= 1 << (regno & 7);\n+}\n+\n /* Set bits in *USED which correspond to registers which can't change\n    their mode from FROM to any mode in which REGNO was encountered.  */\n \n void\n cannot_change_mode_set_regs (HARD_REG_SET *used, enum machine_mode from,\n \t\t\t     unsigned int regno)\n {\n+  struct subregs_of_mode_node dummy, *node;\n   enum machine_mode to;\n-  int n, i;\n-  int start = regno * MAX_MACHINE_MODE;\n+  unsigned char mask;\n+  unsigned int i;\n \n-  EXECUTE_IF_SET_IN_BITMAP (&subregs_of_mode, start, n,\n-    if (n >= MAX_MACHINE_MODE + start)\n-      return;\n-    to = n - start;\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (! TEST_HARD_REG_BIT (*used, i)\n-\t  && REG_CANNOT_CHANGE_MODE_P (i, from, to))\n-\tSET_HARD_REG_BIT (*used, i);\n-  );\n+  dummy.block = regno & -8;\n+  node = htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n+  if (node == NULL)\n+    return;\n+\n+  mask = 1 << (regno & 7);\n+  for (to = VOIDmode; to < NUM_MACHINE_MODES; to++)\n+    if (node->modes[to] & mask)\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (!TEST_HARD_REG_BIT (*used, i)\n+\t    && REG_CANNOT_CHANGE_MODE_P (i, from, to))\n+\t  SET_HARD_REG_BIT (*used, i);\n }\n \n /* Return 1 if REGNO has had an invalid mode change in CLASS from FROM\n    mode.  */\n \n bool\n invalid_mode_change_p (unsigned int regno, enum reg_class class,\n-\t\t       enum machine_mode from_mode)\n+\t\t       enum machine_mode from)\n {\n-  enum machine_mode to_mode;\n-  int n;\n-  int start = regno * MAX_MACHINE_MODE;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (&subregs_of_mode, start, n,\n-    if (n >= MAX_MACHINE_MODE + start)\n-      return 0;\n-    to_mode = n - start;\n-    if (CANNOT_CHANGE_MODE_CLASS (from_mode, to_mode, class))\n-      return 1;\n-  );\n-  return 0;\n+  struct subregs_of_mode_node dummy, *node;\n+  enum machine_mode to;\n+  unsigned char mask;\n+\n+  dummy.block = regno & -8;\n+  node = htab_find_with_hash (subregs_of_mode, &dummy, dummy.block);\n+  if (node == NULL)\n+    return false;\n+\n+  mask = 1 << (regno & 7);\n+  for (to = VOIDmode; to < NUM_MACHINE_MODES; to++)\n+    if (node->modes[to] & mask)\n+      if (CANNOT_CHANGE_MODE_CLASS (from, to, class))\n+\treturn true;\n+\n+  return false;\n }\n #endif /* CANNOT_CHANGE_MODE_CLASS */\n "}, {"sha": "848c306a3ff35f97502bbc1f506f46de2a05974d", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=41bf2a8b17267a42615392ad9da37081f59e428c", "patch": "@@ -68,8 +68,6 @@ typedef struct reg_info_def\n \n extern varray_type reg_n_info;\n \n-extern bitmap_head subregs_of_mode;\n-\n /* Indexed by n, gives number of times (REG n) is used or set.  */\n \n #define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)"}, {"sha": "8f7274a3c1bbe61f3e8b2c6fd78047c6b59fbe53", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41bf2a8b17267a42615392ad9da37081f59e428c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=41bf2a8b17267a42615392ad9da37081f59e428c", "patch": "@@ -2092,6 +2092,8 @@ extern void regclass (rtx, int, FILE *);\n extern void reg_scan (rtx, unsigned int, int);\n extern void reg_scan_update (rtx, rtx, unsigned int);\n extern void fix_register (const char *, int, int);\n+extern void init_subregs_of_mode (void);\n+extern void record_subregs_of_mode (rtx);\n #ifdef HARD_CONST\n extern void cannot_change_mode_set_regs (HARD_REG_SET *,\n \t\t\t\t\t enum machine_mode, unsigned int);"}]}