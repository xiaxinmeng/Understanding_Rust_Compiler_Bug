{"sha": "aa16693981db4d4ef9e8420c639ade115c76b973", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWExNjY5Mzk4MWRiNGQ0ZWY5ZTg0MjBjNjM5YWRlMTE1Yzc2Yjk3Mw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-09-11T13:01:32Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-11T13:01:32Z"}, "message": "combine.c (combine_simplify_rtx): Move several NOT and NEG optimizations from here...\n\n\n\t* combine.c (combine_simplify_rtx): Move several NOT and NEG\n\toptimizations from here...\n\t* simplify-rtx.c (simplify_unary_operation): to here.  Recursively\n\tsimplify expressions using simplify_gen_*ary instead of gen_rtx_*.\n\nFrom-SVN: r71300", "tree": {"sha": "3516ba9797f7857f75fb34c6f849795688a48c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3516ba9797f7857f75fb34c6f849795688a48c04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa16693981db4d4ef9e8420c639ade115c76b973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa16693981db4d4ef9e8420c639ade115c76b973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa16693981db4d4ef9e8420c639ade115c76b973", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa16693981db4d4ef9e8420c639ade115c76b973/comments", "author": null, "committer": null, "parents": [{"sha": "cda85569ad54bf2c27f27524abc89d5096f03e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda85569ad54bf2c27f27524abc89d5096f03e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda85569ad54bf2c27f27524abc89d5096f03e4b"}], "stats": {"total": 211, "additions": 113, "deletions": 98}, "files": [{"sha": "be4c46b5b63dcaf9ebbbe8ef4d151a9a1c60b20c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa16693981db4d4ef9e8420c639ade115c76b973/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa16693981db4d4ef9e8420c639ade115c76b973/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa16693981db4d4ef9e8420c639ade115c76b973", "patch": "@@ -1,3 +1,10 @@\n+2003-09-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* combine.c (combine_simplify_rtx): Move several NOT and NEG\n+\toptimizations from here...\n+\t* simplify-rtx.c (simplify_unary_operation): to here.  Recursively\n+\tsimplify expressions using simplify_gen_*ary instead of gen_rtx_*.\n+\n 2003-09-11  Richard Henderson  <rth@redhat.com>\n \n \t* cgraphunit.c (cgraph_finalize_function): Add nested arg."}, {"sha": "2567ca9b2d719c9cfa18c9f14c705c4204e32dbf", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa16693981db4d4ef9e8420c639ade115c76b973/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa16693981db4d4ef9e8420c639ade115c76b973/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=aa16693981db4d4ef9e8420c639ade115c76b973", "patch": "@@ -3847,33 +3847,6 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n       break;\n \n     case NOT:\n-      /* (not (plus X -1)) can become (neg X).  */\n-      if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && XEXP (XEXP (x, 0), 1) == constm1_rtx)\n-\treturn gen_rtx_NEG (mode, XEXP (XEXP (x, 0), 0));\n-\n-      /* Similarly, (not (neg X)) is (plus X -1).  */\n-      if (GET_CODE (XEXP (x, 0)) == NEG)\n-\treturn gen_rtx_PLUS (mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n-\n-      /* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */\n-      if (GET_CODE (XEXP (x, 0)) == XOR\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && (temp = simplify_unary_operation (NOT, mode,\n-\t\t\t\t\t       XEXP (XEXP (x, 0), 1),\n-\t\t\t\t\t       mode)) != 0)\n-\treturn gen_binary (XOR, mode, XEXP (XEXP (x, 0), 0), temp);\n-\n-      /* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for operands\n-\t other than 1, but that is not valid.  We could do a similar\n-\t simplification for (not (lshiftrt C X)) where C is just the sign bit,\n-\t but this doesn't seem common enough to bother with.  */\n-      if (GET_CODE (XEXP (x, 0)) == ASHIFT\n-\t  && XEXP (XEXP (x, 0), 0) == const1_rtx)\n-\treturn gen_rtx_ROTATE (mode, simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t\t\t const1_rtx, mode),\n-\t\t\t       XEXP (XEXP (x, 0), 1));\n-\n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t  && subreg_lowpart_p (XEXP (x, 0))\n \t  && (GET_MODE_SIZE (GET_MODE (XEXP (x, 0)))\n@@ -3890,24 +3863,6 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t  return gen_lowpart_for_combine (mode, x);\n \t}\n \n-      /* If STORE_FLAG_VALUE is -1, (not (comparison foo bar)) can be done by\n-\t reversing the comparison code if valid.  */\n-      if (STORE_FLAG_VALUE == -1\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && (reversed = reversed_comparison (x, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t      XEXP (XEXP (x, 0), 1))))\n-\treturn reversed;\n-\n-      /* (not (ashiftrt foo C)) where C is the number of bits in FOO minus 1\n-\t is (ge foo (const_int 0)) if STORE_FLAG_VALUE is -1, so we can\n-\t perform the above simplification.  */\n-\n-      if (STORE_FLAG_VALUE == -1\n-\t  && GET_CODE (XEXP (x, 0)) == ASHIFTRT\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\treturn gen_rtx_GE (mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n-\n       /* Apply De Morgan's laws to reduce number of patterns for machines\n \t with negating logical insns (and-not, nand, etc.).  If result has\n \t only one NOT, put it first, since that is how the patterns are\n@@ -3938,63 +3893,12 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n       break;\n \n     case NEG:\n-      /* (neg (plus X 1)) can become (not X).  */\n-      if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && XEXP (XEXP (x, 0), 1) == const1_rtx)\n-\treturn gen_rtx_NOT (mode, XEXP (XEXP (x, 0), 0));\n-\n-      /* Similarly, (neg (not X)) is (plus X 1).  */\n-      if (GET_CODE (XEXP (x, 0)) == NOT)\n-\treturn plus_constant (XEXP (XEXP (x, 0), 0), 1);\n-\n-      /* (neg (minus X Y)) can become (minus Y X).  This transformation\n-\t isn't safe for modes with signed zeros, since if X and Y are\n-\t both +0, (minus Y X) is the same as (minus X Y).  If the rounding\n-\t mode is towards +infinity (or -infinity) then the two expressions\n-\t will be rounded differently.  */\n-      if (GET_CODE (XEXP (x, 0)) == MINUS\n-\t  && !HONOR_SIGNED_ZEROS (mode)\n-\t  && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n-\treturn gen_binary (MINUS, mode, XEXP (XEXP (x, 0), 1),\n-\t\t\t   XEXP (XEXP (x, 0), 0));\n-\n-      /* (neg (plus A B)) is canonicalized to (minus (neg A) B).  */\n-      if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && !HONOR_SIGNED_ZEROS (mode)\n-\t  && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n-\t{\n-\t  temp = simplify_gen_unary (NEG, mode, XEXP (XEXP (x, 0), 0), mode);\n-\t  temp = combine_simplify_rtx (temp, mode, last, in_dest);\n-\t  return gen_binary (MINUS, mode, temp, XEXP (XEXP (x, 0), 1));\n-\t}\n-\n-      /* (neg (mult A B)) becomes (mult (neg A) B).\n-         This works even for floating-point values.  */\n-      if (GET_CODE (XEXP (x, 0)) == MULT\n-\t  && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n-\t{\n-\t  temp = simplify_gen_unary (NEG, mode, XEXP (XEXP (x, 0), 0), mode);\n-\t  return gen_binary (MULT, mode, temp, XEXP (XEXP (x, 0), 1));\n-\t}\n-\n       /* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1.  */\n       if (GET_CODE (XEXP (x, 0)) == XOR\n \t  && XEXP (XEXP (x, 0), 1) == const1_rtx\n \t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n \treturn gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n \n-      /* NEG commutes with ASHIFT since it is multiplication.  Only do this\n-\t if we can then eliminate the NEG (e.g.,\n-\t if the operand is a constant).  */\n-\n-      if (GET_CODE (XEXP (x, 0)) == ASHIFT)\n-\t{\n-\t  temp = simplify_unary_operation (NEG, mode,\n-\t\t\t\t\t   XEXP (XEXP (x, 0), 0), mode);\n-\t  if (temp)\n-\t    return gen_binary (ASHIFT, mode, temp, XEXP (XEXP (x, 0), 1));\n-\t}\n-\n       temp = expand_compound_operation (XEXP (x, 0));\n \n       /* For C equal to the width of MODE minus 1, (neg (ashiftrt X C)) can be"}, {"sha": "aa16af820f9766f6581325b13336971937a4d9f3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa16693981db4d4ef9e8420c639ade115c76b973/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa16693981db4d4ef9e8420c639ade115c76b973/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=aa16693981db4d4ef9e8420c639ade115c76b973", "patch": "@@ -788,6 +788,8 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n   else\n     {\n       enum rtx_code reversed;\n+      rtx temp;\n+\n       /* There are some simplifications we can do even if the operands\n \t aren't constant.  */\n       switch (code)\n@@ -801,14 +803,116 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  if (mode == BImode && GET_RTX_CLASS (GET_CODE (op)) == '<'\n \t      && ((reversed = reversed_comparison_code (op, NULL_RTX))\n \t\t  != UNKNOWN))\n-\t    return gen_rtx_fmt_ee (reversed,\n-\t\t\t\t   op_mode, XEXP (op, 0), XEXP (op, 1));\n+\t    return simplify_gen_relational (reversed, op_mode, op_mode,\n+\t\t\t\t\t    XEXP (op, 0), XEXP (op, 1));\n+\n+          /* (not (plus X -1)) can become (neg X).  */\n+          if (GET_CODE (op) == PLUS\n+\t      && XEXP (op, 1) == constm1_rtx)\n+\t    return simplify_gen_unary (NEG, mode, XEXP (op, 0), mode);\n+\n+\t  /* Similarly, (not (neg X)) is (plus X -1).  */\n+\t  if (GET_CODE (op) == NEG)\n+\t    return plus_constant (XEXP (op, 0), -1);\n+\n+\t  /* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */\n+\t  if (GET_CODE (op) == XOR\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t      && (temp = simplify_unary_operation (NOT, mode,\n+\t\t\t\t\t\t   XEXP (op, 1),\n+\t\t\t\t\t\t   mode)) != 0)\n+\t    return simplify_gen_binary (XOR, mode, XEXP (op, 0), temp);\n+\n+\n+\t  /* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for\n+\t     operands other than 1, but that is not valid.  We could do a\n+\t     similar simplification for (not (lshiftrt C X)) where C is\n+\t     just the sign bit, but this doesn't seem common enough to\n+\t     bother with.  */\n+\t  if (GET_CODE (op) == ASHIFT\n+\t      && XEXP (op, 0) == const1_rtx)\n+\t    {\n+\t      temp = simplify_gen_unary (NOT, mode, const1_rtx, mode);\n+\t      return simplify_gen_binary (ROTATE, mode, temp, XEXP (op, 1));\n+\t    }\n+\n+\t  /* If STORE_FLAG_VALUE is -1, (not (comparison X Y)) can be done\n+\t     by reversing the comparison code if valid.  */\n+\t  if (STORE_FLAG_VALUE == -1\n+\t      && GET_RTX_CLASS (GET_CODE (op)) == '<'\n+\t      && (reversed = reversed_comparison_code (op, NULL_RTX))\n+\t\t != UNKNOWN)\n+\t    return simplify_gen_relational (reversed, op_mode, op_mode,\n+\t\t\t\t\t    XEXP (op, 0), XEXP (op, 1));\n+\n+\t  /* (not (ashiftrt foo C)) where C is the number of bits in FOO\n+\t     minus 1 is (ge foo (const_int 0)) if STORE_FLAG_VALUE is -1,\n+\t     so we can perform the above simplification.  */\n+\n+\t  if (STORE_FLAG_VALUE == -1\n+\t      && GET_CODE (op) == ASHIFTRT\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t      && INTVAL (XEXP (op, 1)) == GET_MODE_BITSIZE (mode) - 1)\n+\t    return simplify_gen_relational (GE, mode, mode, XEXP (op, 0),\n+\t\t\t\t\t    const0_rtx);\n+\n \t  break;\n \n \tcase NEG:\n \t  /* (neg (neg X)) == X.  */\n \t  if (GET_CODE (op) == NEG)\n \t    return XEXP (op, 0);\n+\n+\t  /* (neg (plus X 1)) can become (not X).  */\n+\t  if (GET_CODE (op) == PLUS\n+\t      && XEXP (op, 1) == const1_rtx)\n+\t    return simplify_gen_unary (NOT, mode, XEXP (op, 0), mode);\n+\n+\t  /* Similarly, (neg (not X)) is (plus X 1).  */\n+\t  if (GET_CODE (op) == NOT)\n+\t    return plus_constant (XEXP (op, 0), 1);\n+\n+\t  /* (neg (minus X Y)) can become (minus Y X).  This transformation\n+\t     isn't safe for modes with signed zeros, since if X and Y are\n+\t     both +0, (minus Y X) is the same as (minus X Y).  If the\n+\t     rounding mode is towards +infinity (or -infinity) then the two\n+\t     expressions will be rounded differently.  */\n+\t  if (GET_CODE (op) == MINUS\n+\t      && !HONOR_SIGNED_ZEROS (mode)\n+\t      && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n+\t    return simplify_gen_binary (MINUS, mode, XEXP (op, 1),\n+\t\t\t\t\tXEXP (op, 0));\n+\n+\t  /* (neg (plus A B)) is canonicalized to (minus (neg A) B).  */\n+\t  if (GET_CODE (op) == PLUS\n+\t      && !HONOR_SIGNED_ZEROS (mode)\n+\t      && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n+\t    {\n+\t      temp = simplify_gen_unary (NEG, mode, XEXP (op, 0), mode);\n+\t      return simplify_gen_binary (MINUS, mode, temp, XEXP (op, 1));\n+\t    }\n+\n+\t  /* (neg (mult A B)) becomes (mult (neg A) B).\n+\t     This works even for floating-point values.  */\n+\t  if (GET_CODE (op) == MULT\n+\t      && !HONOR_SIGN_DEPENDENT_ROUNDING (mode))\n+\t    {\n+\t      temp = simplify_gen_unary (NEG, mode, XEXP (op, 0), mode);\n+\t      return simplify_gen_binary (MULT, mode, temp, XEXP (op, 1));\n+\t    }\n+\n+\t  /* NEG commutes with ASHIFT since it is multiplication.  Only do\n+\t     this if we can then eliminate the NEG (e.g., if the operand\n+\t     is a constant).  */\n+\t  if (GET_CODE (op) == ASHIFT)\n+\t    {\n+\t      temp = simplify_unary_operation (NEG, mode, XEXP (op, 0),\n+\t\t\t\t\t       mode);\n+\t      if (temp)\n+\t\treturn simplify_gen_binary (ASHIFT, mode, temp,\n+\t\t\t\t\t    XEXP (op, 1));\n+\t    }\n+\n \t  break;\n \n \tcase SIGN_EXTEND:"}]}