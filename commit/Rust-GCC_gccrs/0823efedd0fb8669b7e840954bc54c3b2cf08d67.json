{"sha": "0823efedd0fb8669b7e840954bc54c3b2cf08d67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyM2VmZWRkMGZiODY2OWI3ZTg0MDk1NGJjNTRjM2IyY2YwOGQ2Nw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-08-15T01:56:07Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-08-15T01:56:07Z"}, "message": "backport: As described in http://gcc.gnu.org/ml/gcc/2012-08/msg00015.html...\n\n\nMerge from cxx-conversion branch (http://gcc.gnu.org/wiki/cxx-conversion).\n\nAs described in http://gcc.gnu.org/ml/gcc/2012-08/msg00015.html, this patch\nchanges the default bootstrap process so that stage 1 always builds with a C++\ncompiler.\n\nOther than the bootstrap change, the patch makes no functional changes to the\ncompiler.  Everything should build as it does now in trunk.  The main\nchanges in this patch are:\n\n1- Configuration changes.\n2- Re-write of VEC.\n3- Re-write of gengtype to support C++ templates and\n   user-provided marking functions.\n4- New hash table class.\n5- Re-write double_int.\n6- Implement tree macros as inline functions so they can be\n   called from gdb.\n\nAs discussed before, several of these changes do not fully change\nthe call sites to use the new APIs.\n\nThe bootstrap changes have already been tested on a wide range of\ntargets (http://gcc.gnu.org/wiki/CppBuildStatus).  Additionally,\nI have tested the merged trunk on: x86_64-unknown-linux-gnu,\nmips64el-unknown-linux-gnu, powerpc64-unknown-linux-gnu,\ni686-pc-linux-gnu, and ia64-unknown-linux-gnu.\n\nChangeLog\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.\n\n\t* Makefile.tpl (STAGE[+id+]_CXXFLAGS): Remove\n\tPOSTSTAGE1_CONFIGURE_FLAGS.\n\t* Makefile.in: Regenerate.\n\t* configure.ac (ENABLE_BUILD_WITH_CXX): Remove.  Update all users.\n\tForce C++ when bootstrapping.\n\t* configure: Regenerate.\n\n\nlibcpp/ChangeLog\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.  Configury.\n\n\t* Makefile.in: Remove all handlers of ENABLE_BUILD_WITH_CXX.\n\t* configure.ac: Likewise.\n\t* configure: Regenerate.\n\n2012-08-14   Lawrence Crowl  <crowl@google.com>\n\n\tMerge from cxx-conversion branch.  New C++ hash table.\n\n\t* include/symtab.h (typedef struct ht hash_table): Change the typedef\n\tname to cpp_hash_table.  Update all users of the typedef.\n\ngcc/ChangeLog\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.  Configury.\n\n\t* configure.ac (CXX_FOR_BUILD): Define and substitute.\n\t(BUILD_CXXFLAGS): Define.\n\tRemove all handlers of ENABLE_BUILD_WITH_CXX.\n\tForce all build to be with C++.\n\t* Makefile.in (BUILD_CXXFLAGS): Use it.\n\tRemove all handlers of ENABLE_BUILD_WITH_CXX.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\t* doc/install.texi: Remove documentation for --enable-build-with-cxx\n\tand --enable-build-poststage1-with-cxx.\n\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.  Re-implement VEC in C++.\n\n\t* vec.c (vec_heap_free): Convert into a template function.\n\t(vec_gc_o_reserve_1): Make extern.\n\t(vec_gc_p_reserve): Remove.\n\t(vec_gc_p_reserve_exact): Remove.\n\t(vec_gc_o_reserve): Remove.\n\t(vec_gc_o_reserve_exact): Remove.\n\t(vec_heap_o_reserve_1): Make extern.\n\t(vec_heap_p_reserve): Remove.\n\t(vec_heap_p_reserve_exact): Remove.\n\t(vec_heap_o_reserve): Remove.\n\t(vec_heap_o_reserve_exact): Remove.\n\t(vec_stack_p_reserve): Remove.\n\t(vec_stack_p_reserve_exact): Remove.\n\t* vec.h (VEC_CHECK_INFO, VEC_CHECK_DECL, VEC_CHECK_PASS,\n\tVEC_ASSERT, VEC_ASSERT_FAIL, vec_assert_fail): Move earlier\n\tin the file.\n\t(VEC): Define to vec_t<T>.\n\t(vec_allocation_t): Define.\n\t(struct vec_prefix): Move earlier in the file.\n\t(vec_t<T>): New template.\n\t(DEF_VEC_I, DEF_VECL_ALLOC_I, DEF_VEC_P, DEF_VEC_ALLOC_P,\n\tDEF_VEC_O, DEF_VEC_ALLOC_P, DEF_VEC_O, DEF_VEC_ALLOC_O,\n\tDEF_VEC_ALLOC_P_STACK, DEF_VEC_ALLOC_O_STACK,\n\tDEF_VEC_ALLOC_I_STACK): Expand to 'struct vec_swallow_trailing_semi'.\n\t(DEF_VEC_A): Provide template instantiations for\n\tGC/PCH markers that do not traverse the vector.\n\t(vec_stack_p_reserve): Remove.\n\t(vec_stack_p_reserve_exact): Remove.\n\t(vec_stack_p_reserve_exact_1): Remove.\n\t(vec_stack_o_reserve): Remove.\n\t(vec_stack_o_reserve_exact): Remove.\n\t(vec_stack_free): Re-write as a template function.\n\t(vec_reserve): New template function.\n\t(vec_reserve_exact): New template function.\n\t(vec_heap_free): New template function if GATHER_STATISTICS is\n\tdefined.  Otherwise, macro that expands to free().\n\t(VEC_length_1): New template function.\n\t(VEC_length): Call it.\n\t(VEC_empty_1): New template function.\n\t(VEC_empty): Call it.\n\t(VEC_address_1): New template function.\n\t(VEC_address): Call it.\n\t(VEC_last_1): New template function.\n\t(VEC_last): Call it.  Change return type to T&.\n\tChange all users that used VEC_Os.\n\t(VEC_index_1): New template function.\n\t(VEC_index): Call it.  Return a T& instead of a T*.\n\tUpdate all callers that were using VEC_O before.\n\t(VEC_iterate_1): New template function.\n\t(VEC_iterate): Call it.\n\t(VEC_embedded_size_1): New template function.\n\t(VEC_embedded_size): Call it.\n\t(VEC_embedded_init_1): New template function.\n\t(VEC_embedded_init): Call it.\n\t(VEC_alloc_1): New template function.\n\t(VEC_alloc): Call it.  If A is 'stack', call XALLOCAVAR to\n\tdo the allocation.\n\t(VEC_free_1): New template function.\n\t(VEC_free): Call it.\n\t(VEC_copy_1): New template function.\n\t(VEC_copy): Call it.\n\t(VEC_space_1): New template function\n\t(VEC_space): Call it.\n\t(VEC_reserve_1): New template function.\n\t(VEC_reserve): Call it.\n\t(VEC_reserve_exact_1): New template function.\n\t(VEC_reserve_exact): Call it.\n\t(VEC_splice_1): New template function.\n\t(VEC_splice): Call it.\n\t(VEC_safe_splice_1): New template function.\n\t(VEC_safe_splice): Call it.\n\t(VEC_quick_push_1): New template function.  Create two overloads, one\n\taccepting T, the other accepting T *.  Update all callers\n\twhere T and T * are ambiguous.\n\t(VEC_quick_push): Call it.\n\t(VEC_safe_push_1): New template function. Create two overloads, one\n\taccepting T, the other accepting T *.  Update all callers\n\twhere T and T * are ambiguous.\n\t(VEC_safe_push): Call it.\n\t(VEC_pop_1): New template function.\n\t(VEC_pop): Call it.\n\t(VEC_truncate_1): New template function.\n\t(VEC_truncate): Call it.\n\t(VEC_safe_grow_1): New template function.\n\t(VEC_safe_grow): Call it.\n\t(VEC_safe_grow_cleared_1): New template function.\n\t(VEC_safe_grow_cleared): Call it.\n\t(VEC_replace_1): New template function.\n\t(VEC_replace): Call it.  Always accept T instead of T*.\n\tUpdate all callers that used VEC_Os.\n\t(VEC_quick_insert_1): New template function.\n\t(VEC_quick_insert): Call it.\n\t(VEC_safe_insert_1): New template function.\n\t(VEC_safe_insert): Call it.\n\t(VEC_ordered_remove_1): New template function.\n\t(VEC_ordered_remove): Call it.\n\t(VEC_unordered_remove_1): New template function.\n\t(VEC_unordered_remove): Call it.\n\t(VEC_block_remove_1): New template function.\n\t(VEC_block_remove): Call it.\n\t(VEC_lower_bound_1): New template function.\n\t(VEC_lower_bound): Call it.\n\t(VEC_OP): Remove.\n\t(DEF_VEC_FUNC_P): Remove.\n\t(DEF_VEC_ALLOC_FUNC_P): Remove.\n\t(DEF_VEC_NONALLOC_FUNCS_P): Remove.\n\t(DEF_VEC_FUNC_O): Remove.\n\t(DEF_VEC_ALLOC_FUNC_O): Remove.\n\t(DEF_VEC_NONALLOC_FUNCS_O): Remove.\n\t(DEF_VEC_ALLOC_FUNC_I): Remove.\n\t(DEF_VEC_NONALLOC_FUNCS_I): Remove.\n\t(DEF_VEC_ALLOC_FUNC_P_STACK): Remove.\n\t(DEF_VEC_ALLOC_FUNC_O_STACK): Remove.\n\t(DEF_VEC_ALLOC_FUNC_I_STACK): Remove.\n\t(vec_reserve_exact): New template function.\n\n\t* gengtype-lex.l (DEF_VEC_ALLOC_[IOP]/{EOID}): Remove.\n\t* gengtype-parse.c (token_names): Remove DEF_VEC_ALLOC_[IOP].\n\t(typedef_name): Emit vec_t<C1> instead of VEC_C1_C2.\n\t(def_vec_alloc): Remove.  Update all callers.\n\t* gengtype.c (filter_type_name): New.\n\t(output_mangled_typename): Call it.\n\t(write_func_for_structure): Likewise.\n\t(write_types): Likewise.\n\t(write_root): Likewise.\n\t(write_typed_alloc_def): Likewise.\n\t(note_def_vec): Emit vec_t<TYPE_NAME> instead of VEC_TYPE_NAME_base.\n\t(note_def_vec_alloc): Remove.\n\t* gengtype.h (note_def_vec_alloc): Remove.\n\t(DEFVEC_ALLOC): Remove token code.\n\n\t* df-scan.c (df_bb_verify): Remove call to df_free_collection_rec\n\tinside the insn traversal loop.\n\t* gimplify.c (gimplify_compound_lval): Rename STACK to EXPR_STACK.\n\t* ipa-inline.c (inline_small_functions): Rename HEAP to EDGE_HEAP.\n\t* reg-stack.c (stack): Rename to STACK_PTR.  Update all users.\n\t* tree-vrp.c (stack): Rename to EQUIV_STACK.  Update all users.\n\n\t* config/bfin/bfin.c (hwloop_optimize): Update some calls to\n\tVEC_* for vectors of non-pointers.\n\t* config/c6x/c6x.c (try_rename_operands): Likewise.\n\t(reshuffle_units): Likewise.\n\t* config/mips/mips.c (mips_multi_start): Likewise.\n\t(mips_multi_add): Likewise.\n\t(mips_multi_copy_insn): Likewise.\n\t(mips_multi_set_operand): Likewise.\n\t* hw-doloop.c (discover_loop): Likewise.\n\t(discover_loops): Likewise.\n\t(reorg_loops): Likewise.\n\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.  C++ support in gengtype.\n\n\t* coretypes.h (gt_pointer_operator): Move from ...\n\t* ggc.h: ... here.\n\t* doc/gty.texi: Document support for C++ templates and\n\tuser-provided markers.\n\t* gcc/gengtype-lex.l: Update copyright year.\n\tRemove support for recognizing DEF_VEC_O, DEF_VEC_P and\n\tDEFVEC_I.\n\t* gengtype-parse.c: Update copyright year.\n\t(token_names): Remove DEF_VEC_O, DEF_VEC_P and DEF_VEC_I.\n\t(require_template_declaration): New.\n\t(typedef_name): Call it.\n\t(type): Replace IS_UNION with KIND. Replace all users.\n\t(def_vec): Remove.  Update all users.\n\t* gengtype-state.c (type_lineloc): Handle TYPE_USER_STRUCT.\n\t(write_state_user_struct_type): New.\n\t(write_state_type): Call it.\n\t(read_state_user_struct_type): New.\n\t(read_state_type): Call it.\n\t* gengtype.c: Update copyright year.\n\t(dump_pair): Move declaration to the top.\n\t(dump_type): Likewise.\n\t(dump_type_list): Likewise.\n\t(dbgprint_count_type_at): Handle TYPE_USER_STRUCT.\n\t(create_user_defined_type): New.\n\t(resolve_typedef): Call it.\n\t(new_structure): Replace argument ISUNION with KIND.\n\tChange users to refer to KIND directly.\n\tUpdate all callers.\n\t(find_structure): Likewise.\n\t(set_gc_used_type): Handle TYPE_USER_STRUCT.\n\t(create_file): Update HDR to include new copyright year.\n\t(struct walk_type_data): Add field IN_PTR_FIELD.\n\t(output_mangled_typename): Handle TYPE_USER_STRUCT.\n\t(walk_type): Set D->IN_PTR_FIELD when walking a TYPE_POINTER.\n\tClear it afterwards.\n\tHandle TYPE_USER_STRUCT.\n\t(write_types_process_field): Handle TYPE_USER_STRUCT.\n\t(get_type_specifier): Move earlier in the file.\n\t(write_type_decl): New.\n\t(write_marker_function_name): New.\n\t(write_user_func_for_structure_ptr): New.\n\t(write_user_func_for_structure_body): New.\n\t(write_user_marking_functions): New.\n\t(write_func_for_structure): Call write_marker_function_name\n\tand write_type_decl.\n\tDo not call walk_type for TYPE_USER_STRUCT. Emit a call to the user\n\tfunction directly.\n\tCall write_user_marking_functions on TYPE_USER_STRUCTs.\n\t(write_types_local_user_process_field): New.\n\t(write_pch_user_walking_for_structure_body): New.\n\t(write_pch_user_walking_functions): New.\n\t(write_types_local_process_field): Handle TYPE_USER_STRUCT.\n\t(write_local_func_for_structure): Do not call walk_type for\n\tTYPE_USER_STRUCT. Instead, emit the call to gt_pch_nx directly.\n\tCall write_pch_user_walking_functions for TYPE_USER_STRUCTs.\n\t(write_root): Handle TYPE_USER_STRUCT.\n\t(vec_prefix_type): Remove.  Update all users.\n\t(note_def_vec): Remove.  Update all users.\n\t(dump_typekind): Handle TYPE_USER_STRUCT.\n\t(dump_type): Initialize SEEN_TYPES, if needed.\n\tHandle TYPE_USER_STRUCT.\n\t(dump_everything): Do not initialize SEEN_TYPES.\n\t* gengtype.h: Update copyright year.\n\t(enum typekind): Add TYPE_USER_STRUCT.\n\t(union_or_struct_p): Rename from UNION_OR_STRUCT_P.\n\tConvert into function.\n\tAdd an overload taking const_type_p.\n\tUpdate all callers.\n\t(new_structure): Change second field to type enum typekind.\n\tUpdate all users.\n\t(find_structure): Likewise.\n\t(note_def_vec): Remove.\n\t(DEFVEC_OP): Remove.\n\t(DEFVEC_I): Remove.\n\t* ggc-page.c (gt_ggc_mx): Add entry points for marking\n\t'const char *&', 'unsigned char *&' and 'unsigned char&'.\n\t* ggc-zone.c (gt_ggc_mx): Add entry points for marking\n\t'const char *&' and 'unsigned char *&'.\n\t* stringpool.c (gt_pch_nx): Add entry points for marking\n\t'const char *&', 'unsigned char *&' and 'unsigned char&'.\n\tAdd an entry point for the overload taking arguments 'unsigned char\n\t*', 'gt_pointer_operator' and 'void *'.\n\t* vec.h (struct vec_prefix): Remove GTY marker.\n\t(struct vec_t): Remove GTY((length)) attribute from field 'vec'.\n\t(gt_ggc_mx (vec_t<T> *)): New template function.\n\t(gt_pch_nx (vec_t<T> *)): New template function.\n\t(gt_pch_nx (vec_t<T *> *, gt_pointer_operator, void *)): New template\n\tfunction.\n\t(gt_pch_nx (vec_t<T> *, gt_pointer_operator, void *)): New template\n\tfunction.\n\n\t* basic-block.h (struct edge_def): Mark GTY((user)).\n\tRemove all GTY markers from fields.\n\t(gt_ggc_mx): Declare.\n\t(gt_pch_nx): Declare.\n\t* tree-cfg.c (gt_ggc_mx): New.\n\t(gt_pch_nx): New.\n\n\t* gengtype-lex.l (USER_GTY): Add pattern for \"user\".\n\t* gengtype-parse.c (option): Handle USER_GTY.\n\t(opts_have): New.\n\t(type): Call it.\n\tIf the keyword 'user' is used, do not walk the fields\n\tof the structure.\n\t* gengtype.h (USER_GTY): Add.\n\t* doc/gty.texi: Update.\n\n2012-08-14   Lawrence Crowl  <crowl@google.com>\n\n\tMerge cxx-conversion branch.  Implement C++ hash table.\n\n\t* hash-table.h: New. Implementation borrowed from libiberty/hashtab.c.\n\t* hash-table.c: Likewise.\n\t* tree-ssa-tail-merge.c: Include hash-table.h instead of hashtab.h.\n\t(static htab_t same_succ_htab): Change type to hash_table;\n\tmove specification of helper functions from create call to declaration.\n\tChange users to invoke member functions.\n\t(same_succ_print_traverse): Make extern ssa_.... Change callers.\n\tRemove void* casting.\n\t(same_succ_hash): Likewise.\n\t(same_succ_equal): Likewise.\n\t(same_succ_delete): Likewise.\n\t* tree-ssa-threadupdate.c: Include hash-table.h.\n\t(struct local_info): Rename to ssa_local_info_t to avoid overloading\n\tthe type name local_info with the variable name local_info.\n\t(static htab_t redirection_data): Change type to hash_table.\n\tMove specification of helper functions from create call to declaration.\n\tChange users to invoke member functions.\n\t(redirection_data_hash): Make extern ssa_.... Change callers.\n\tRemove void* casting.\n\t(redirection_data_eq): Likewise.\n\t(fix_duplicate_block_edges): Likewise.\n\t(create_duplicates): Likewise.\n\t(fixup_template_block): Likewise.\n\t(redirect_edges): Likewise.\n\t(lookup_redirection_data): Change types associated with the hash table\n\tfrom void* to their actual type. Remove unnecessary casts.\n\t* tree-ssa-ccp.c: Include hash-table.h.\n\t(typedef gimple_htab): New.  Uses hash_table.  Replace specific uses\n\tof htab_t with gimple_htab.  Change users to invoke member functions.\n\tMove specification of helper functions from create call to declaration.\n\t* tree-ssa-coalesce.c: Include hash-table.h instead of hashtab.h.\n\t(hash_ssa_name_by_var): Make extern. Remove void* casting.\n\t(eq_ssa_name_by_var): Likewise.\n\t(coalesce_ssa_name): Change type of local static htab_t ssa_name_hash\n\tto hash_table. Change users to invoke member functions.\n\tMove specification of helper functions from create call to declaration.\n\t* coverage.c: Include hash-table.h instead of hashtab.h.\n\t(static htab_t counts_hash): Change type to hash_table;\n\tmove specification of helper functions from create call to declaration.\n\tChange users to invoke member functions.\n\t(htab_counts_entry_hash): Make extern. Rename with coverage_... instead\n\tof htab_... Remove void* casting.\n\t(htab_counts_entry_eq): Likewise.\n\t(htab_counts_entry_del): Likewise.\n\t* tree-ssa-pre.c: Include hash-table.h instead of hashtab.h.\n\t(static htab_t expression_to_id): Change type to hash_table.\n\tMove specification of helper functions from create call to declaration.\n\tChange users to invoke member functions.\n\t(static htab_t phi_translate_table): Likewise.\n\t(pre_expr_eq): Make extern ssa_.... Change callers.\n\tRemove void* casting.\n\t(pre_expr_hash): Likewise.\n\t(expr_pred_trans_hash): Likewise.\n\t(expr_pred_trans_eq): Likewise.\n\t(alloc_expression_id): Change types associated with the hash table\n\tfrom void* to their actual type. Remove unnecessary casts.\n\t(lookup_expression_id): Likewise.\n\t(phi_trans_lookup): Likewise.\n\t(phi_trans_add): Likewise.\n\t* stringpool.c: Rename uses of libcpp typedef hash_table to\n\tcpp_hash_table.\n\t* Makefile.in: Add hash-table.o to OBJS-libcommon-target.\n\tAdd $(HASH_TABLE_H). Add new dependences on $(HASH_TABLE_H).\n\n2012-08-14   Lawrence Crowl  <crowl@google.com>\n\n\tMerge from cxx-conversion branch.  Re-write double_int in C++.\n\n\t* hash-table.h\n\t(typedef double_int): Change to struct (POD).\n\t(double_int::make): New overloads for int to double-int conversion.\n\t(double_int::mask): New.\n\t(double_int::max_value): New.\n\t(double_int::min_value): New.\n\t(double_int::operator ++): New.\n\t(double_int::operator --): New.\n\t(double_int::operator *=): New.\n\t(double_int::operator +=): New.\n\t(double_int::operator -=): New.\n\t(double_int::to_signed): New.\n\t(double_int::to_unsigned): New.\n\t(double_int::fits_unsigned): New.\n\t(double_int::fits_signed): New.\n\t(double_int::fits): New.\n\t(double_int::trailing_zeros): New.\n\t(double_int::popcount): New.\n\t(double_int::multiple_of): New.\n\t(double_int::set_bit): New.\n\t(double_int::mul_with_sign): New.\n\t(double_int::operator * (binary)): New.\n\t(double_int::operator + (binary)): New.\n\t(double_int::operator - (binary)): New.\n\t(double_int::operator - (unary)): New.\n\t(double_int::operator ~ (unary)): New.\n\t(double_int::operator & (binary)): New.\n\t(double_int::operator | (binary)): New.\n\t(double_int::operator ^ (binary)): New.\n\t(double_int::and_not): New.\n\t(double_int::lshift): New.\n\t(double_int::rshift): New.\n\t(double_int::alshift): New.\n\t(double_int::arshift): New.\n\t(double_int::llshift): New.\n\t(double_int::lrshift): New.\n\t(double_int::lrotate): New.\n\t(double_int::rrotate): New.\n\t(double_int::div): New.\n\t(double_int::sdiv): New.\n\t(double_int::udiv): New.\n\t(double_int::mod): New.\n\t(double_int::smod): New.\n\t(double_int::umod): New.\n\t(double_int::divmod): New.\n\t(double_int::sdivmod): New.\n\t(double_int::udivmod): New.\n\t(double_int::ext): New.\n\t(double_int::zext): New.\n\t(double_int::sext): New.\n\t(double_int::is_zero): New.\n\t(double_int::is_one): New.\n\t(double_int::is_minus_one): New.\n\t(double_int::is_negative): New.\n\t(double_int::cmp): New.\n\t(double_int::ucmp): New.\n\t(double_int::scmp): New.\n\t(double_int::ult): New.\n\t(double_int::ugt): New.\n\t(double_int::slt): New.\n\t(double_int::sgt): New.\n\t(double_int::max): New.\n\t(double_int::smax): New.\n\t(double_int::umax): New.\n\t(double_int::min): New.\n\t(double_int::smin): New.\n\t(double_int::umin): New.\n\t(double_int::operator ==): New.\n\t(double_int::operator !=): New.\n\t(shwi_to_double_int): Change implementation to use member function.\n\t(double_int_minus_one): Likewise.\n\t(double_int_zero): Likewise.\n\t(double_int_one): Likewise.\n\t(double_int_two): Likewise.\n\t(double_int_ten): Likewise.\n\t(uhwi_to_double_int): Likewise.\n\t(double_int_to_shwi): Likewise.\n\t(double_int_to_uhwi): Likewise.\n\t(double_int_fits_in_uhwi_p): Likewise.\n\t(double_int_fits_in_shwi_p): Likewise.\n\t(double_int_fits_in_hwi_p): Likewise.\n\t(double_int_mul): Likewise.\n\t(double_int_mul_with_sign): Likewise.\n\t(double_int_add): Likewise.\n\t(double_int_sub): Likewise.\n\t(double_int_neg): Likewise.\n\t(double_int_div): Likewise.\n\t(double_int_sdiv): Likewise.\n\t(double_int_udiv): Likewise.\n\t(double_int_mod): Likewise.\n\t(double_int_smod): Likewise.\n\t(double_int_umod): Likewise.\n\t(double_int_divmod): Likewise.\n\t(double_int_sdivmod): Likewise.\n\t(double_int_udivmod): Likewise.\n\t(double_int_multiple_of): Likewise.\n\t(double_int_setbit): Likewise.\n\t(double_int_ctz): Likewise.\n\t(double_int_not): Likewise.\n\t(double_int_ior): Likewise.\n\t(double_int_and): Likewise.\n\t(double_int_and_not): Likewise.\n\t(double_int_xor): Likewise.\n\t(double_int_lshift): Likewise.\n\t(double_int_rshift): Likewise.\n\t(double_int_lrotate): Likewise.\n\t(double_int_rrotate): Likewise.\n\t(double_int_cmp): Likewise.\n\t(double_int_scmp): Likewise.\n\t(double_int_ucmp): Likewise.\n\t(double_int_max): Likewise.\n\t(double_int_smax): Likewise.\n\t(double_int_umax): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_smin): Likewise.\n\t(double_int_umin): Likewise.\n\t(double_int_ext): Likewise.\n\t(double_int_sext): Likewise.\n\t(double_int_zext): Likewise.\n\t(double_int_mask): Likewise.\n\t(double_int_max_value): Likewise.\n\t(double_int_min_value): Likewise.\n\t(double_int_zero_p): Likewise.\n\t(double_int_one_p): Likewise.\n\t(double_int_minus_one_p): Likewise.\n\t(double_int_equal_p): Likewise.\n\t(double_int_popcount): Likewise.\n\t* hash-table.c\n\t(double_int_mask): Reuse implementation for double_int::mask.\n\t(double_int_max_value): Likewise.\n\t(double_int_min_value): Likewise.\n\t(double_int_ext): Likewise.\n\t(double_int_zext): Likewise.\n\t(double_int_sext): Likewise.\n\t(double_int_mul_with_sign): Likewise.\n\t(double_int_divmod): Likewise.\n\t(double_int_sdivmod): Likewise.\n\t(double_int_udivmod): Likewise.\n\t(double_int_div): Likewise.\n\t(double_int_sdiv): Likewise.\n\t(double_int_udiv): Likewise.\n\t(double_int_mod): Likewise.\n\t(double_int_smod): Likewise.\n\t(double_int_umod): Likewise.\n\t(double_int_multiple_of): Likewise.\n\t(double_int_lshift): Likewise.\n\t(double_int_rshift): Likewise.\n\t(double_int_lrotate): Likewise.\n\t(double_int_rrotate): Likewise.\n\t(double_int_cmp): Likewise.\n\t(double_int_ucmp): Likewise.\n\t(double_int_scmp): Likewise.\n\t(double_int_max): Likewise.\n\t(double_int_smax): Likewise.\n\t(double_int_umax): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_smin): Likewise.\n\t(double_int_umin): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int_min): Likewise.\n\t(double_int::alshift): New.\n\t(double_int::arshift): New.\n\t(double_int::llshift): New.\n\t(double_int::lrshift): New.\n\t(double_int::ult): New.\n\t(double_int::ugt): New.\n\t(double_int::slt): New.\n\t(double_int::sgt): New.\n\t(double_int_setbit): Reuse implementation for double_int::set_bit,\n\twhich avoids a name conflict with a macro.\n\t(double_int_double_int_ctz): Reuse implementation for\n\tdouble_int::trailing_zeros.\n\t(double_int_fits_in_shwi_p): Reuse implementation for\n\tdouble_int::fits_signed.\n\t(double_int_fits_in_hwi_p): Reuse implementation for double_int::fits.\n\t(double_int_mul): Reuse implementation for binary\n\tdouble_int::operator *.\n\t(double_int_add): Likewise.\n\t(double_int_sub): Likewise.\n\t(double_int_neg): Reuse implementation for unary\n\tdouble_int::operator -.\n\t(double_int_max_value): Likewise.\n\t* fixed-value.c: Change to use member functions introduced above.\n\n2012-08-14   Lawrence Crowl  <crowl@google.com>\n\n\tMerge cxx-conversion branch.  Support tree macro calling\n\tfrom gdb.\n\n\t* tree.h (tree_check): New.\n\t(TREE_CHECK): Use inline function above instead of __extension__.\n\t(tree_not_check): New.\n\t(TREE_NOT_CHECK): Use inline function above instead of __extension__.\n\t(tree_check2): New.\n\t(TREE_CHECK2): Use inline function above instead of __extension__.\n\t(tree_not_check2): New.\n\t(TREE_NOT_CHECK2): Use inline function above instead of __extension__.\n\t(tree_check3): New.\n\t(TREE_CHECK3): Use inline function above instead of __extension__.\n\t(tree_not_check3): New.\n\t(TREE_NOT_CHECK3): Use inline function above instead of __extension__.\n\t(tree_check4): New.\n\t(TREE_CHECK4): Use inline function above instead of __extension__.\n\t(tree_not_check4): New.\n\t(TREE_NOT_CHECK4): Use inline function above instead of __extension__.\n\t(tree_check5): New.\n\t(TREE_CHECK5): Use inline function above instead of __extension__.\n\t(tree_not_check5): New.\n\t(TREE_NOT_CHECK5): Use inline function above instead of __extension__.\n\t(contains_struct_check): New.\n\t(CONTAINS_STRUCT_CHECK): Use inline function above instead of\n\t__extension__.\n\t(tree_class_check): New.\n\t(TREE_CLASS_CHECK): Use inline function above instead of __extension__.\n\t(tree_range_check): New.\n\t(TREE_RANGE_CHECK): Use inline function above instead of __extension__.\n\t(omp_clause_subcode_check): New.\n\t(OMP_CLAUSE_SUBCODE_CHECK): Use inline function above instead of\n\t__extension__.\n\t(omp_clause_range_check): New.\n\t(OMP_CLAUSE_RANGE_CHECK): Use inline function above instead of\n\t__extension__.\n\t(expr_check): New.\n\t(EXPR_CHECK): Use inline function above instead of __extension__.\n\t(non_type_check): New.\n\t(NON_TYPE_CHECK): Use inline function above instead of __extension__.\n\t(tree_vec_elt_check): New.\n\t(TREE_VEC_ELT_CHECK): Use inline function above instead of\n\t__extension__.\n\t(omp_clause_elt_check): New.\n\t(OMP_CLAUSE_ELT_CHECK): Use inline function above instead of\n\t__extension__.\n\t(tree_operand_check): New.\n\t(TREE_OPERAND_CHECK): Use inline function above instead of\n\t__extension__.\n\t(tree_operand_check_code): New.\n\t(TREE_OPERAND_CHECK_CODE): Use inline function above instead of\n\t__extension__.\n\t(TREE_CHAIN): Simplify implementation.\n\t(TREE_TYPE): Simplify implementation.\n\t(tree_operand_length): Move for compilation dependences.\n\t* gdbinit.in: (macro define __FILE__): New.\n\t(macro define __LINE__): New.\n\t(skip \"tree.h\"): New.\n\ngcc/cp/ChangeLog\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.  Re-write VEC in C++.\n\n\t* call.c (add_function_candidate): Remove const qualifier\n\tfrom call to VEC_index.\n\n2012-08-14   Diego Novillo  <dnovillo@google.com>\n\n\tMerge from cxx-conversion branch.  Configury.\n\n\t* go-c.h: Remove all handlers of ENABLE_BUILD_WITH_CXX.\n\t* go-gcc.cc: Likewise.\n\t* go-system.h: Likewise.\n\nFrom-SVN: r190402", "tree": {"sha": "e43578612b8b33743caa0788b5bb5bb5175b0ebe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e43578612b8b33743caa0788b5bb5bb5175b0ebe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0823efedd0fb8669b7e840954bc54c3b2cf08d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0823efedd0fb8669b7e840954bc54c3b2cf08d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0823efedd0fb8669b7e840954bc54c3b2cf08d67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0823efedd0fb8669b7e840954bc54c3b2cf08d67/comments", "author": null, "committer": null, "parents": [{"sha": "4ce8f1176c0e4bc675a72860e5e837e8d21652d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce8f1176c0e4bc675a72860e5e837e8d21652d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce8f1176c0e4bc675a72860e5e837e8d21652d9"}], "stats": {"total": 8949, "additions": 5518, "deletions": 3431}, "files": [{"sha": "ab275dd6414529c0fec72da69b4eb57aa5592a42", "filename": "ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,3 +1,14 @@\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.\n+\n+\t* Makefile.tpl (STAGE[+id+]_CXXFLAGS): Remove\n+\tPOSTSTAGE1_CONFIGURE_FLAGS.\n+\t* Makefile.in: Regenerate.\n+\t* configure.ac (ENABLE_BUILD_WITH_CXX): Remove.  Update all users.\n+\tForce C++ when bootstrapping.\n+\t* configure: Regenerate.\n+\n 2012-07-24  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "0d2566681757938ec13102d95a83cbf096678371", "filename": "Makefile.in", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -420,7 +420,6 @@ TFLAGS =\n STAGE_CFLAGS = $(BOOT_CFLAGS)\n STAGE_TFLAGS = $(TFLAGS)\n STAGE_CONFIGURE_FLAGS=@stage2_werror_flag@\n-POSTSTAGE1_CONFIGURE_FLAGS = @POSTSTAGE1_CONFIGURE_FLAGS@\n \n \n # Defaults for stage 1; some are overridden below.\n@@ -431,10 +430,7 @@ STAGE1_CXXFLAGS = $(CXXFLAGS)\n STAGE1_CXXFLAGS = $(STAGE1_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGE1_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGE1_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGE1_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n \n # Defaults for stage 2; some are overridden below.\n STAGE2_CFLAGS = $(STAGE_CFLAGS)\n@@ -444,10 +440,7 @@ STAGE2_CXXFLAGS = $(CXXFLAGS)\n STAGE2_CXXFLAGS = $(STAGE2_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGE2_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGE2_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGE2_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n \n # Defaults for stage 3; some are overridden below.\n STAGE3_CFLAGS = $(STAGE_CFLAGS)\n@@ -457,10 +450,7 @@ STAGE3_CXXFLAGS = $(CXXFLAGS)\n STAGE3_CXXFLAGS = $(STAGE3_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGE3_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGE3_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGE3_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n \n # Defaults for stage 4; some are overridden below.\n STAGE4_CFLAGS = $(STAGE_CFLAGS)\n@@ -470,10 +460,7 @@ STAGE4_CXXFLAGS = $(CXXFLAGS)\n STAGE4_CXXFLAGS = $(STAGE4_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGE4_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGE4_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGE4_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n \n # Defaults for stage profile; some are overridden below.\n STAGEprofile_CFLAGS = $(STAGE_CFLAGS)\n@@ -483,10 +470,7 @@ STAGEprofile_CXXFLAGS = $(CXXFLAGS)\n STAGEprofile_CXXFLAGS = $(STAGEprofile_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGEprofile_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGEprofile_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGEprofile_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n \n # Defaults for stage feedback; some are overridden below.\n STAGEfeedback_CFLAGS = $(STAGE_CFLAGS)\n@@ -496,10 +480,7 @@ STAGEfeedback_CXXFLAGS = $(CXXFLAGS)\n STAGEfeedback_CXXFLAGS = $(STAGEfeedback_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGEfeedback_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGEfeedback_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGEfeedback_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n \n \n # Only build the C compiler for stage1, because that is the only one that\n@@ -517,9 +498,6 @@ STAGE1_LANGUAGES = @stage1_languages@\n #   the last argument when conflicting --enable arguments are passed.\n # * Likewise, we force-disable coverage flags, since the installed\n #   compiler probably has never heard of them.\n-# * Don't remove this, because above we added\n-#   POSTSTAGE1_CONFIGURE_FLAGS to STAGE_CONFIGURE_FLAGS, which\n-#   we don't want for STAGE1_CONFIGURE_FLAGS.\n STAGE1_CONFIGURE_FLAGS = --disable-intermodule $(STAGE1_CHECKING) \\\n \t  --disable-coverage --enable-languages=\"$(STAGE1_LANGUAGES)\"\n "}, {"sha": "f2c3f48b7d22abfe1a957af1ab7fbc4fc06ccfc3", "filename": "Makefile.tpl", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -423,7 +423,6 @@ TFLAGS =\n STAGE_CFLAGS = $(BOOT_CFLAGS)\n STAGE_TFLAGS = $(TFLAGS)\n STAGE_CONFIGURE_FLAGS=@stage2_werror_flag@\n-POSTSTAGE1_CONFIGURE_FLAGS = @POSTSTAGE1_CONFIGURE_FLAGS@\n \n [+ FOR bootstrap-stage +]\n # Defaults for stage [+id+]; some are overridden below.\n@@ -434,10 +433,7 @@ STAGE[+id+]_CXXFLAGS = $(CXXFLAGS)\n STAGE[+id+]_CXXFLAGS = $(STAGE[+id+]_CFLAGS)\n @endif target-libstdc++-v3-bootstrap\n STAGE[+id+]_TFLAGS = $(STAGE_TFLAGS)\n-# STAGE1_CONFIGURE_FLAGS overridden below, so we can use\n-# POSTSTAGE1_CONFIGURE_FLAGS here.\n-STAGE[+id+]_CONFIGURE_FLAGS = \\\n-\t$(STAGE_CONFIGURE_FLAGS) $(POSTSTAGE1_CONFIGURE_FLAGS)\n+STAGE[+id+]_CONFIGURE_FLAGS = $(STAGE_CONFIGURE_FLAGS)\n [+ ENDFOR bootstrap-stage +]\n \n # Only build the C compiler for stage1, because that is the only one that\n@@ -455,9 +451,6 @@ STAGE1_LANGUAGES = @stage1_languages@\n #   the last argument when conflicting --enable arguments are passed.\n # * Likewise, we force-disable coverage flags, since the installed\n #   compiler probably has never heard of them.\n-# * Don't remove this, because above we added\n-#   POSTSTAGE1_CONFIGURE_FLAGS to STAGE[+id+]_CONFIGURE_FLAGS, which\n-#   we don't want for STAGE1_CONFIGURE_FLAGS.\n STAGE1_CONFIGURE_FLAGS = --disable-intermodule $(STAGE1_CHECKING) \\\n \t  --disable-coverage --enable-languages=\"$(STAGE1_LANGUAGES)\"\n "}, {"sha": "fd0e29c1ef6bff6727584c456e790095e5f9fbf6", "filename": "configure", "status": "modified", "additions": 7, "deletions": 81, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -556,7 +556,6 @@ enable_option_checking=no\n ac_subst_vars='LTLIBOBJS\n LIBOBJS\n compare_exclusions\n-POSTSTAGE1_CONFIGURE_FLAGS\n stage2_werror_flag\n stage1_checking\n stage1_cflags\n@@ -753,8 +752,6 @@ enable_libada\n enable_libssp\n enable_static_libjava\n enable_bootstrap\n-enable_build_with_cxx\n-enable_build_poststage1_with_cxx\n with_mpc\n with_mpc_include\n with_mpc_lib\n@@ -1471,9 +1468,6 @@ Optional Features:\n   --enable-static-libjava[=ARG]\n                           build static libjava [default=no]\n   --enable-bootstrap      enable bootstrapping [yes if native build]\n-  --enable-build-with-cxx build with C++ compiler instead of C compiler\n-  --enable-build-poststage1-with-cxx\n-                          build stages 2 and 3 with C++, not C\n   --disable-isl-version-check\n                           disable check for ISL version\n   --disable-cloog-version-check\n@@ -5109,24 +5103,6 @@ $as_echo \"$as_me: WARNING: trying to bootstrap a cross compiler\" >&2;}\n     ;;\n esac\n \n-# See if we are building gcc with C++.\n-# Check whether --enable-build-with-cxx was given.\n-if test \"${enable_build_with_cxx+set}\" = set; then :\n-  enableval=$enable_build_with_cxx; ENABLE_BUILD_WITH_CXX=$enableval\n-else\n-  ENABLE_BUILD_WITH_CXX=no\n-fi\n-\n-\n-# Build stage1 with C and build stages 2 and 3 with C++.\n-# Check whether --enable-build-poststage1-with-cxx was given.\n-if test \"${enable_build_poststage1_with_cxx+set}\" = set; then :\n-  enableval=$enable_build_poststage1_with_cxx; ENABLE_BUILD_POSTSTAGE1_WITH_CXX=$enableval\n-else\n-  ENABLE_BUILD_POSTSTAGE1_WITH_CXX=yes\n-fi\n-\n-\n # Used for setting $lt_cv_objdir\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for objdir\" >&5\n $as_echo_n \"checking for objdir... \" >&6; }\n@@ -5980,7 +5956,7 @@ fi\n \n \n \n-# By default, C is the only stage 1 language.\n+# By default, C and C++ are the only stage 1 languages.\n stage1_languages=,c,\n \n # Target libraries that we bootstrap.\n@@ -6018,15 +5994,14 @@ if test -d ${srcdir}/gcc; then\n       ;;\n   esac\n \n-  # If bootstrapping, then using --enable-build-with-cxx or\n-  # --enable-build-poststage1-with-cxx requires enabling C++.\n-  case \",$enable_languages,:,$ENABLE_BUILD_WITH_CXX,$ENABLE_BUILD_POSTSTAGE1_WITH_CXX,:$enable_bootstrap\" in\n-    *,c++,*:*:*) ;;\n-    *:*,yes,*:yes)\n+  # If bootstrapping, C++ must be enabled.\n+  case \",$enable_languages,:$enable_bootstrap\" in\n+    *,c++,*:*) ;;\n+    *:yes)\n       if test -f ${srcdir}/gcc/cp/config-lang.in; then\n         enable_languages=\"${enable_languages},c++\"\n       else\n-        as_fn_error \"bootstrapping with --enable-build-with-cxx or --enable-build-poststage1-with-cxx requires c++ sources\" \"$LINENO\" 5\n+        as_fn_error \"bootstrapping requires c++ sources\" \"$LINENO\" 5\n       fi\n       ;;\n   esac\n@@ -6121,10 +6096,7 @@ if test -d ${srcdir}/gcc; then\n         fi\n \n \tif test \"$language\" = \"c++\"; then\n-\t  if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\" \\\n-\t     || test \"$ENABLE_BUILD_POSTSTAGE1_WITH_CXX\" = \"yes\"; then\n-\t    boot_language=yes\n-\t  fi\n+\t  boot_language=yes\n \tfi\n \n         case ,${enable_languages}, in\n@@ -14215,43 +14187,6 @@ case $build in\n     esac ;;\n esac\n \n-# This is aimed to mimic bootstrap with a non-GCC compiler to catch problems.\n-if test \"$GCC\" = yes -a \"$ENABLE_BUILD_WITH_CXX\" != yes; then\n-  saved_CFLAGS=\"$CFLAGS\"\n-\n-  # Pass -fkeep-inline-functions for stage 1 if the GCC version supports it.\n-  CFLAGS=\"$CFLAGS -fkeep-inline-functions\"\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether -fkeep-inline-functions is supported\" >&5\n-$as_echo_n \"checking whether -fkeep-inline-functions is supported... \" >&6; }\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-#if (__GNUC__ < 3) \\\n-    || (__GNUC__ == 3 && (__GNUC_MINOR__ < 3 \\\n-\t\t\t  || (__GNUC_MINOR__ == 3 && __GNUC_PATCHLEVEL__ < 1)))\n-#error http://gcc.gnu.org/PR29382\n-#endif\n-\n-int\n-main ()\n-{\n-\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n-$as_echo \"yes\" >&6; }; stage1_cflags=\"$stage1_cflags -fkeep-inline-functions\"\n-else\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n-$as_echo \"no\" >&6; }\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-\n-  CFLAGS=\"$saved_CFLAGS\"\n-fi\n-\n \n \n # Enable --enable-checking in stage1 of the compiler.\n@@ -14286,15 +14221,6 @@ case ${enable_werror} in\n esac\n \n \n-# If using ENABLE_BUILD_POSTSTAGE1_WITH_CXX, pass\n-# --enable-build-with-cxx after stage1.\n-if test \"$ENABLE_BUILD_POSTSTAGE1_WITH_CXX\" = \"yes\"; then\n-  POSTSTAGE1_CONFIGURE_FLAGS=--enable-build-with-cxx\n-else\n-  POSTSTAGE1_CONFIGURE_FLAGS=\n-fi\n-\n-\n # Specify what files to not compare during bootstrap.\n \n compare_exclusions=\"gcc/cc*-checksum\\$(objext) | gcc/ada/*tools/*\""}, {"sha": "27692b45bf82c042a9d4d04dc4c3bb1804f2639e", "filename": "configure.ac", "status": "modified", "additions": 7, "deletions": 54, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1204,20 +1204,6 @@ case \"$have_compiler:$host:$target:$enable_bootstrap\" in\n     ;;\n esac\n \n-# See if we are building gcc with C++.\n-AC_ARG_ENABLE(build-with-cxx,\n-[AS_HELP_STRING([--enable-build-with-cxx],\n-\t\t[build with C++ compiler instead of C compiler])],\n-ENABLE_BUILD_WITH_CXX=$enableval,\n-ENABLE_BUILD_WITH_CXX=no)\n-\n-# Build stage1 with C and build stages 2 and 3 with C++.\n-AC_ARG_ENABLE(build-poststage1-with-cxx,\n-[AS_HELP_STRING([--enable-build-poststage1-with-cxx],\n-\t\t[build stages 2 and 3 with C++, not C])],\n-ENABLE_BUILD_POSTSTAGE1_WITH_CXX=$enableval,\n-ENABLE_BUILD_POSTSTAGE1_WITH_CXX=yes)\n-\n # Used for setting $lt_cv_objdir\n _LT_CHECK_OBJDIR\n \n@@ -1595,7 +1581,7 @@ ACX_ELF_TARGET_IFELSE([# ELF platforms build the lto-plugin always.\n ])\n \n \n-# By default, C is the only stage 1 language.\n+# By default, C and C++ are the only stage 1 languages.\n stage1_languages=,c,\n \n # Target libraries that we bootstrap.\n@@ -1633,15 +1619,14 @@ if test -d ${srcdir}/gcc; then\n       ;;\n   esac\n \n-  # If bootstrapping, then using --enable-build-with-cxx or\n-  # --enable-build-poststage1-with-cxx requires enabling C++.\n-  case \",$enable_languages,:,$ENABLE_BUILD_WITH_CXX,$ENABLE_BUILD_POSTSTAGE1_WITH_CXX,:$enable_bootstrap\" in\n-    *,c++,*:*:*) ;;\n-    *:*,yes,*:yes)\n+  # If bootstrapping, C++ must be enabled.\n+  case \",$enable_languages,:$enable_bootstrap\" in\n+    *,c++,*:*) ;;\n+    *:yes)\n       if test -f ${srcdir}/gcc/cp/config-lang.in; then\n         enable_languages=\"${enable_languages},c++\"\n       else\n-        AC_MSG_ERROR([bootstrapping with --enable-build-with-cxx or --enable-build-poststage1-with-cxx requires c++ sources])\n+        AC_MSG_ERROR([bootstrapping requires c++ sources])\n       fi\n       ;;\n   esac\n@@ -1736,10 +1721,7 @@ if test -d ${srcdir}/gcc; then\n         fi\n \n \tif test \"$language\" = \"c++\"; then\n-\t  if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\" \\\n-\t     || test \"$ENABLE_BUILD_POSTSTAGE1_WITH_CXX\" = \"yes\"; then\n-\t    boot_language=yes\n-\t  fi\n+\t  boot_language=yes\n \tfi\n \n         case ,${enable_languages}, in\n@@ -3129,26 +3111,6 @@ case $build in\n     esac ;;\n esac\n \n-# This is aimed to mimic bootstrap with a non-GCC compiler to catch problems.\n-if test \"$GCC\" = yes -a \"$ENABLE_BUILD_WITH_CXX\" != yes; then\n-  saved_CFLAGS=\"$CFLAGS\"\n-\n-  # Pass -fkeep-inline-functions for stage 1 if the GCC version supports it.\n-  CFLAGS=\"$CFLAGS -fkeep-inline-functions\"\n-  AC_MSG_CHECKING([whether -fkeep-inline-functions is supported])\n-  AC_TRY_COMPILE([\n-#if (__GNUC__ < 3) \\\n-    || (__GNUC__ == 3 && (__GNUC_MINOR__ < 3 \\\n-\t\t\t  || (__GNUC_MINOR__ == 3 && __GNUC_PATCHLEVEL__ < 1)))\n-#error http://gcc.gnu.org/PR29382\n-#endif\n-    ],,\n-    [AC_MSG_RESULT([yes]); stage1_cflags=\"$stage1_cflags -fkeep-inline-functions\"],\n-    [AC_MSG_RESULT([no])])\n-\n-  CFLAGS=\"$saved_CFLAGS\"\n-fi\n-\n AC_SUBST(stage1_cflags)\n \n # Enable --enable-checking in stage1 of the compiler.\n@@ -3178,15 +3140,6 @@ case ${enable_werror} in\n esac\n AC_SUBST(stage2_werror_flag)\n \n-# If using ENABLE_BUILD_POSTSTAGE1_WITH_CXX, pass\n-# --enable-build-with-cxx after stage1.\n-if test \"$ENABLE_BUILD_POSTSTAGE1_WITH_CXX\" = \"yes\"; then\n-  POSTSTAGE1_CONFIGURE_FLAGS=--enable-build-with-cxx\n-else\n-  POSTSTAGE1_CONFIGURE_FLAGS=\n-fi\n-AC_SUBST(POSTSTAGE1_CONFIGURE_FLAGS)\n-\n # Specify what files to not compare during bootstrap.\n \n compare_exclusions=\"gcc/cc*-checksum\\$(objext) | gcc/ada/*tools/*\""}, {"sha": "422903720967796685c714f50ee5d07dc33803c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,3 +1,604 @@\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.  Configury.\n+\n+\t* configure.ac (CXX_FOR_BUILD): Define and substitute.\n+\t(BUILD_CXXFLAGS): Define.\n+\tRemove all handlers of ENABLE_BUILD_WITH_CXX.\n+\tForce all build to be with C++.\n+\t* Makefile.in (BUILD_CXXFLAGS): Use it.\n+\tRemove all handlers of ENABLE_BUILD_WITH_CXX.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\t* doc/install.texi: Remove documentation for --enable-build-with-cxx\n+\tand --enable-build-poststage1-with-cxx.\n+\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.  Re-implement VEC in C++.\n+\n+\t* vec.c (vec_heap_free): Convert into a template function.\n+\t(vec_gc_o_reserve_1): Make extern.\n+\t(vec_gc_p_reserve): Remove.\n+\t(vec_gc_p_reserve_exact): Remove.\n+\t(vec_gc_o_reserve): Remove.\n+\t(vec_gc_o_reserve_exact): Remove.\n+\t(vec_heap_o_reserve_1): Make extern.\n+\t(vec_heap_p_reserve): Remove.\n+\t(vec_heap_p_reserve_exact): Remove.\n+\t(vec_heap_o_reserve): Remove.\n+\t(vec_heap_o_reserve_exact): Remove.\n+\t(vec_stack_p_reserve): Remove.\n+\t(vec_stack_p_reserve_exact): Remove.\n+\t* vec.h (VEC_CHECK_INFO, VEC_CHECK_DECL, VEC_CHECK_PASS,\n+\tVEC_ASSERT, VEC_ASSERT_FAIL, vec_assert_fail): Move earlier\n+\tin the file.\n+\t(VEC): Define to vec_t<T>.\n+\t(vec_allocation_t): Define.\n+\t(struct vec_prefix): Move earlier in the file.\n+\t(vec_t<T>): New template.\n+\t(DEF_VEC_I, DEF_VECL_ALLOC_I, DEF_VEC_P, DEF_VEC_ALLOC_P,\n+\tDEF_VEC_O, DEF_VEC_ALLOC_P, DEF_VEC_O, DEF_VEC_ALLOC_O,\n+\tDEF_VEC_ALLOC_P_STACK, DEF_VEC_ALLOC_O_STACK,\n+\tDEF_VEC_ALLOC_I_STACK): Expand to 'struct vec_swallow_trailing_semi'.\n+\t(DEF_VEC_A): Provide template instantiations for\n+\tGC/PCH markers that do not traverse the vector.\n+\t(vec_stack_p_reserve): Remove.\n+\t(vec_stack_p_reserve_exact): Remove.\n+\t(vec_stack_p_reserve_exact_1): Remove.\n+\t(vec_stack_o_reserve): Remove.\n+\t(vec_stack_o_reserve_exact): Remove.\n+\t(vec_stack_free): Re-write as a template function.\n+\t(vec_reserve): New template function.\n+\t(vec_reserve_exact): New template function.\n+\t(vec_heap_free): New template function if GATHER_STATISTICS is\n+\tdefined.  Otherwise, macro that expands to free().\n+\t(VEC_length_1): New template function.\n+\t(VEC_length): Call it.\n+\t(VEC_empty_1): New template function.\n+\t(VEC_empty): Call it.\n+\t(VEC_address_1): New template function.\n+\t(VEC_address): Call it.\n+\t(VEC_last_1): New template function.\n+\t(VEC_last): Call it.  Change return type to T&.\n+\tChange all users that used VEC_Os.\n+\t(VEC_index_1): New template function.\n+\t(VEC_index): Call it.  Return a T& instead of a T*.\n+\tUpdate all callers that were using VEC_O before.\n+\t(VEC_iterate_1): New template function.\n+\t(VEC_iterate): Call it.\n+\t(VEC_embedded_size_1): New template function.\n+\t(VEC_embedded_size): Call it.\n+\t(VEC_embedded_init_1): New template function.\n+\t(VEC_embedded_init): Call it.\n+\t(VEC_alloc_1): New template function.\n+\t(VEC_alloc): Call it.  If A is 'stack', call XALLOCAVAR to\n+\tdo the allocation.\n+\t(VEC_free_1): New template function.\n+\t(VEC_free): Call it.\n+\t(VEC_copy_1): New template function.\n+\t(VEC_copy): Call it.\n+\t(VEC_space_1): New template function\n+\t(VEC_space): Call it.\n+\t(VEC_reserve_1): New template function.\n+\t(VEC_reserve): Call it.\n+\t(VEC_reserve_exact_1): New template function.\n+\t(VEC_reserve_exact): Call it.\n+\t(VEC_splice_1): New template function.\n+\t(VEC_splice): Call it.\n+\t(VEC_safe_splice_1): New template function.\n+\t(VEC_safe_splice): Call it.\n+\t(VEC_quick_push_1): New template function.  Create two overloads, one\n+\taccepting T, the other accepting T *.  Update all callers\n+\twhere T and T * are ambiguous.\n+\t(VEC_quick_push): Call it.\n+\t(VEC_safe_push_1): New template function. Create two overloads, one\n+\taccepting T, the other accepting T *.  Update all callers\n+\twhere T and T * are ambiguous.\n+\t(VEC_safe_push): Call it.\n+\t(VEC_pop_1): New template function.\n+\t(VEC_pop): Call it.\n+\t(VEC_truncate_1): New template function.\n+\t(VEC_truncate): Call it.\n+\t(VEC_safe_grow_1): New template function.\n+\t(VEC_safe_grow): Call it.\n+\t(VEC_safe_grow_cleared_1): New template function.\n+\t(VEC_safe_grow_cleared): Call it.\n+\t(VEC_replace_1): New template function.\n+\t(VEC_replace): Call it.  Always accept T instead of T*.\n+\tUpdate all callers that used VEC_Os.\n+\t(VEC_quick_insert_1): New template function.\n+\t(VEC_quick_insert): Call it.\n+\t(VEC_safe_insert_1): New template function.\n+\t(VEC_safe_insert): Call it.\n+\t(VEC_ordered_remove_1): New template function.\n+\t(VEC_ordered_remove): Call it.\n+\t(VEC_unordered_remove_1): New template function.\n+\t(VEC_unordered_remove): Call it.\n+\t(VEC_block_remove_1): New template function.\n+\t(VEC_block_remove): Call it.\n+\t(VEC_lower_bound_1): New template function.\n+\t(VEC_lower_bound): Call it.\n+\t(VEC_OP): Remove.\n+\t(DEF_VEC_FUNC_P): Remove.\n+\t(DEF_VEC_ALLOC_FUNC_P): Remove.\n+\t(DEF_VEC_NONALLOC_FUNCS_P): Remove.\n+\t(DEF_VEC_FUNC_O): Remove.\n+\t(DEF_VEC_ALLOC_FUNC_O): Remove.\n+\t(DEF_VEC_NONALLOC_FUNCS_O): Remove.\n+\t(DEF_VEC_ALLOC_FUNC_I): Remove.\n+\t(DEF_VEC_NONALLOC_FUNCS_I): Remove.\n+\t(DEF_VEC_ALLOC_FUNC_P_STACK): Remove.\n+\t(DEF_VEC_ALLOC_FUNC_O_STACK): Remove.\n+\t(DEF_VEC_ALLOC_FUNC_I_STACK): Remove.\n+\t(vec_reserve_exact): New template function.\n+\n+\t* gengtype-lex.l (DEF_VEC_ALLOC_[IOP]/{EOID}): Remove.\n+\t* gengtype-parse.c (token_names): Remove DEF_VEC_ALLOC_[IOP].\n+\t(typedef_name): Emit vec_t<C1> instead of VEC_C1_C2.\n+\t(def_vec_alloc): Remove.  Update all callers.\n+\t* gengtype.c (filter_type_name): New.\n+\t(output_mangled_typename): Call it.\n+\t(write_func_for_structure): Likewise.\n+\t(write_types): Likewise.\n+\t(write_root): Likewise.\n+\t(write_typed_alloc_def): Likewise.\n+\t(note_def_vec): Emit vec_t<TYPE_NAME> instead of VEC_TYPE_NAME_base.\n+\t(note_def_vec_alloc): Remove.\n+\t* gengtype.h (note_def_vec_alloc): Remove.\n+\t(DEFVEC_ALLOC): Remove token code.\n+\n+\t* df-scan.c (df_bb_verify): Remove call to df_free_collection_rec\n+\tinside the insn traversal loop.\n+\t* gimplify.c (gimplify_compound_lval): Rename STACK to EXPR_STACK.\n+\t* ipa-inline.c (inline_small_functions): Rename HEAP to EDGE_HEAP.\n+\t* reg-stack.c (stack): Rename to STACK_PTR.  Update all users.\n+\t* tree-vrp.c (stack): Rename to EQUIV_STACK.  Update all users.\n+\n+\t* config/bfin/bfin.c (hwloop_optimize): Update some calls to\n+\tVEC_* for vectors of non-pointers.\n+\t* config/c6x/c6x.c (try_rename_operands): Likewise.\n+\t(reshuffle_units): Likewise.\n+\t* config/mips/mips.c (mips_multi_start): Likewise.\n+\t(mips_multi_add): Likewise.\n+\t(mips_multi_copy_insn): Likewise.\n+\t(mips_multi_set_operand): Likewise.\n+\t* hw-doloop.c (discover_loop): Likewise.\n+\t(discover_loops): Likewise.\n+\t(reorg_loops): Likewise.\n+\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.  C++ support in gengtype.\n+\n+\t* coretypes.h (gt_pointer_operator): Move from ...\n+\t* ggc.h: ... here.\n+\t* doc/gty.texi: Document support for C++ templates and\n+\tuser-provided markers.\n+\t* gcc/gengtype-lex.l: Update copyright year.\n+\tRemove support for recognizing DEF_VEC_O, DEF_VEC_P and\n+\tDEFVEC_I.\n+\t* gengtype-parse.c: Update copyright year.\n+\t(token_names): Remove DEF_VEC_O, DEF_VEC_P and DEF_VEC_I.\n+\t(require_template_declaration): New.\n+\t(typedef_name): Call it.\n+\t(type): Replace IS_UNION with KIND. Replace all users.\n+\t(def_vec): Remove.  Update all users.\n+\t* gengtype-state.c (type_lineloc): Handle TYPE_USER_STRUCT.\n+\t(write_state_user_struct_type): New.\n+\t(write_state_type): Call it.\n+\t(read_state_user_struct_type): New.\n+\t(read_state_type): Call it.\n+\t* gengtype.c: Update copyright year.\n+\t(dump_pair): Move declaration to the top.\n+\t(dump_type): Likewise.\n+\t(dump_type_list): Likewise.\n+\t(dbgprint_count_type_at): Handle TYPE_USER_STRUCT.\n+\t(create_user_defined_type): New.\n+\t(resolve_typedef): Call it.\n+\t(new_structure): Replace argument ISUNION with KIND.\n+\tChange users to refer to KIND directly.\n+\tUpdate all callers.\n+\t(find_structure): Likewise.\n+\t(set_gc_used_type): Handle TYPE_USER_STRUCT.\n+\t(create_file): Update HDR to include new copyright year.\n+\t(struct walk_type_data): Add field IN_PTR_FIELD.\n+\t(output_mangled_typename): Handle TYPE_USER_STRUCT.\n+\t(walk_type): Set D->IN_PTR_FIELD when walking a TYPE_POINTER.\n+\tClear it afterwards.\n+\tHandle TYPE_USER_STRUCT.\n+\t(write_types_process_field): Handle TYPE_USER_STRUCT.\n+\t(get_type_specifier): Move earlier in the file.\n+\t(write_type_decl): New.\n+\t(write_marker_function_name): New.\n+\t(write_user_func_for_structure_ptr): New.\n+\t(write_user_func_for_structure_body): New.\n+\t(write_user_marking_functions): New.\n+\t(write_func_for_structure): Call write_marker_function_name\n+\tand write_type_decl.\n+\tDo not call walk_type for TYPE_USER_STRUCT. Emit a call to the user\n+\tfunction directly.\n+\tCall write_user_marking_functions on TYPE_USER_STRUCTs.\n+\t(write_types_local_user_process_field): New.\n+\t(write_pch_user_walking_for_structure_body): New.\n+\t(write_pch_user_walking_functions): New.\n+\t(write_types_local_process_field): Handle TYPE_USER_STRUCT.\n+\t(write_local_func_for_structure): Do not call walk_type for\n+\tTYPE_USER_STRUCT. Instead, emit the call to gt_pch_nx directly.\n+\tCall write_pch_user_walking_functions for TYPE_USER_STRUCTs.\n+\t(write_root): Handle TYPE_USER_STRUCT.\n+\t(vec_prefix_type): Remove.  Update all users.\n+\t(note_def_vec): Remove.  Update all users.\n+\t(dump_typekind): Handle TYPE_USER_STRUCT.\n+\t(dump_type): Initialize SEEN_TYPES, if needed.\n+\tHandle TYPE_USER_STRUCT.\n+\t(dump_everything): Do not initialize SEEN_TYPES.\n+\t* gengtype.h: Update copyright year.\n+\t(enum typekind): Add TYPE_USER_STRUCT.\n+\t(union_or_struct_p): Rename from UNION_OR_STRUCT_P.\n+\tConvert into function.\n+\tAdd an overload taking const_type_p.\n+\tUpdate all callers.\n+\t(new_structure): Change second field to type enum typekind.\n+\tUpdate all users.\n+\t(find_structure): Likewise.\n+\t(note_def_vec): Remove.\n+\t(DEFVEC_OP): Remove.\n+\t(DEFVEC_I): Remove.\n+\t* ggc-page.c (gt_ggc_mx): Add entry points for marking\n+\t'const char *&', 'unsigned char *&' and 'unsigned char&'.\n+\t* ggc-zone.c (gt_ggc_mx): Add entry points for marking\n+\t'const char *&' and 'unsigned char *&'.\n+\t* stringpool.c (gt_pch_nx): Add entry points for marking\n+\t'const char *&', 'unsigned char *&' and 'unsigned char&'.\n+\tAdd an entry point for the overload taking arguments 'unsigned char\n+\t*', 'gt_pointer_operator' and 'void *'.\n+\t* vec.h (struct vec_prefix): Remove GTY marker.\n+\t(struct vec_t): Remove GTY((length)) attribute from field 'vec'.\n+\t(gt_ggc_mx (vec_t<T> *)): New template function.\n+\t(gt_pch_nx (vec_t<T> *)): New template function.\n+\t(gt_pch_nx (vec_t<T *> *, gt_pointer_operator, void *)): New template\n+\tfunction.\n+\t(gt_pch_nx (vec_t<T> *, gt_pointer_operator, void *)): New template\n+\tfunction.\n+\n+\t* basic-block.h (struct edge_def): Mark GTY((user)).\n+\tRemove all GTY markers from fields.\n+\t(gt_ggc_mx): Declare.\n+\t(gt_pch_nx): Declare.\n+\t* tree-cfg.c (gt_ggc_mx): New.\n+\t(gt_pch_nx): New.\n+\n+\t* gengtype-lex.l (USER_GTY): Add pattern for \"user\".\n+\t* gengtype-parse.c (option): Handle USER_GTY.\n+\t(opts_have): New.\n+\t(type): Call it.\n+\tIf the keyword 'user' is used, do not walk the fields\n+\tof the structure.\n+\t* gengtype.h (USER_GTY): Add.\n+\t* doc/gty.texi: Update.\n+\n+2012-08-14   Lawrence Crowl  <crowl@google.com>\n+\n+\tMerge cxx-conversion branch.  Implement C++ hash table.\n+\n+\t* hash-table.h: New. Implementation borrowed from libiberty/hashtab.c.\n+\t* hash-table.c: Likewise.\n+\t* tree-ssa-tail-merge.c: Include hash-table.h instead of hashtab.h.\n+\t(static htab_t same_succ_htab): Change type to hash_table;\n+\tmove specification of helper functions from create call to declaration.\n+\tChange users to invoke member functions.\n+\t(same_succ_print_traverse): Make extern ssa_.... Change callers.\n+\tRemove void* casting.\n+\t(same_succ_hash): Likewise.\n+\t(same_succ_equal): Likewise.\n+\t(same_succ_delete): Likewise.\n+\t* tree-ssa-threadupdate.c: Include hash-table.h.\n+\t(struct local_info): Rename to ssa_local_info_t to avoid overloading\n+\tthe type name local_info with the variable name local_info.\n+\t(static htab_t redirection_data): Change type to hash_table.\n+\tMove specification of helper functions from create call to declaration.\n+\tChange users to invoke member functions.\n+\t(redirection_data_hash): Make extern ssa_.... Change callers.\n+\tRemove void* casting.\n+\t(redirection_data_eq): Likewise.\n+\t(fix_duplicate_block_edges): Likewise.\n+\t(create_duplicates): Likewise.\n+\t(fixup_template_block): Likewise.\n+\t(redirect_edges): Likewise.\n+\t(lookup_redirection_data): Change types associated with the hash table\n+\tfrom void* to their actual type. Remove unnecessary casts.\n+\t* tree-ssa-ccp.c: Include hash-table.h.\n+\t(typedef gimple_htab): New.  Uses hash_table.  Replace specific uses\n+\tof htab_t with gimple_htab.  Change users to invoke member functions.\n+\tMove specification of helper functions from create call to declaration.\n+\t* tree-ssa-coalesce.c: Include hash-table.h instead of hashtab.h.\n+\t(hash_ssa_name_by_var): Make extern. Remove void* casting.\n+\t(eq_ssa_name_by_var): Likewise.\n+\t(coalesce_ssa_name): Change type of local static htab_t ssa_name_hash\n+\tto hash_table. Change users to invoke member functions.\n+\tMove specification of helper functions from create call to declaration.\n+\t* coverage.c: Include hash-table.h instead of hashtab.h.\n+\t(static htab_t counts_hash): Change type to hash_table;\n+\tmove specification of helper functions from create call to declaration.\n+\tChange users to invoke member functions.\n+\t(htab_counts_entry_hash): Make extern. Rename with coverage_... instead\n+\tof htab_... Remove void* casting.\n+\t(htab_counts_entry_eq): Likewise.\n+\t(htab_counts_entry_del): Likewise.\n+\t* tree-ssa-pre.c: Include hash-table.h instead of hashtab.h.\n+\t(static htab_t expression_to_id): Change type to hash_table.\n+\tMove specification of helper functions from create call to declaration.\n+\tChange users to invoke member functions.\n+\t(static htab_t phi_translate_table): Likewise.\n+\t(pre_expr_eq): Make extern ssa_.... Change callers.\n+\tRemove void* casting.\n+\t(pre_expr_hash): Likewise.\n+\t(expr_pred_trans_hash): Likewise.\n+\t(expr_pred_trans_eq): Likewise.\n+\t(alloc_expression_id): Change types associated with the hash table\n+\tfrom void* to their actual type. Remove unnecessary casts.\n+\t(lookup_expression_id): Likewise.\n+\t(phi_trans_lookup): Likewise.\n+\t(phi_trans_add): Likewise.\n+\t* stringpool.c: Rename uses of libcpp typedef hash_table to\n+\tcpp_hash_table.\n+\t* Makefile.in: Add hash-table.o to OBJS-libcommon-target.\n+\tAdd $(HASH_TABLE_H). Add new dependences on $(HASH_TABLE_H).\n+\n+2012-08-14   Lawrence Crowl  <crowl@google.com>\n+\n+\tMerge from cxx-conversion branch.  Re-write double_int in C++.\n+\n+\t* hash-table.h\n+\t(typedef double_int): Change to struct (POD).\n+\t(double_int::make): New overloads for int to double-int conversion.\n+\t(double_int::mask): New.\n+\t(double_int::max_value): New.\n+\t(double_int::min_value): New.\n+\t(double_int::operator ++): New.\n+\t(double_int::operator --): New.\n+\t(double_int::operator *=): New.\n+\t(double_int::operator +=): New.\n+\t(double_int::operator -=): New.\n+\t(double_int::to_signed): New.\n+\t(double_int::to_unsigned): New.\n+\t(double_int::fits_unsigned): New.\n+\t(double_int::fits_signed): New.\n+\t(double_int::fits): New.\n+\t(double_int::trailing_zeros): New.\n+\t(double_int::popcount): New.\n+\t(double_int::multiple_of): New.\n+\t(double_int::set_bit): New.\n+\t(double_int::mul_with_sign): New.\n+\t(double_int::operator * (binary)): New.\n+\t(double_int::operator + (binary)): New.\n+\t(double_int::operator - (binary)): New.\n+\t(double_int::operator - (unary)): New.\n+\t(double_int::operator ~ (unary)): New.\n+\t(double_int::operator & (binary)): New.\n+\t(double_int::operator | (binary)): New.\n+\t(double_int::operator ^ (binary)): New.\n+\t(double_int::and_not): New.\n+\t(double_int::lshift): New.\n+\t(double_int::rshift): New.\n+\t(double_int::alshift): New.\n+\t(double_int::arshift): New.\n+\t(double_int::llshift): New.\n+\t(double_int::lrshift): New.\n+\t(double_int::lrotate): New.\n+\t(double_int::rrotate): New.\n+\t(double_int::div): New.\n+\t(double_int::sdiv): New.\n+\t(double_int::udiv): New.\n+\t(double_int::mod): New.\n+\t(double_int::smod): New.\n+\t(double_int::umod): New.\n+\t(double_int::divmod): New.\n+\t(double_int::sdivmod): New.\n+\t(double_int::udivmod): New.\n+\t(double_int::ext): New.\n+\t(double_int::zext): New.\n+\t(double_int::sext): New.\n+\t(double_int::is_zero): New.\n+\t(double_int::is_one): New.\n+\t(double_int::is_minus_one): New.\n+\t(double_int::is_negative): New.\n+\t(double_int::cmp): New.\n+\t(double_int::ucmp): New.\n+\t(double_int::scmp): New.\n+\t(double_int::ult): New.\n+\t(double_int::ugt): New.\n+\t(double_int::slt): New.\n+\t(double_int::sgt): New.\n+\t(double_int::max): New.\n+\t(double_int::smax): New.\n+\t(double_int::umax): New.\n+\t(double_int::min): New.\n+\t(double_int::smin): New.\n+\t(double_int::umin): New.\n+\t(double_int::operator ==): New.\n+\t(double_int::operator !=): New.\n+\t(shwi_to_double_int): Change implementation to use member function.\n+\t(double_int_minus_one): Likewise.\n+\t(double_int_zero): Likewise.\n+\t(double_int_one): Likewise.\n+\t(double_int_two): Likewise.\n+\t(double_int_ten): Likewise.\n+\t(uhwi_to_double_int): Likewise.\n+\t(double_int_to_shwi): Likewise.\n+\t(double_int_to_uhwi): Likewise.\n+\t(double_int_fits_in_uhwi_p): Likewise.\n+\t(double_int_fits_in_shwi_p): Likewise.\n+\t(double_int_fits_in_hwi_p): Likewise.\n+\t(double_int_mul): Likewise.\n+\t(double_int_mul_with_sign): Likewise.\n+\t(double_int_add): Likewise.\n+\t(double_int_sub): Likewise.\n+\t(double_int_neg): Likewise.\n+\t(double_int_div): Likewise.\n+\t(double_int_sdiv): Likewise.\n+\t(double_int_udiv): Likewise.\n+\t(double_int_mod): Likewise.\n+\t(double_int_smod): Likewise.\n+\t(double_int_umod): Likewise.\n+\t(double_int_divmod): Likewise.\n+\t(double_int_sdivmod): Likewise.\n+\t(double_int_udivmod): Likewise.\n+\t(double_int_multiple_of): Likewise.\n+\t(double_int_setbit): Likewise.\n+\t(double_int_ctz): Likewise.\n+\t(double_int_not): Likewise.\n+\t(double_int_ior): Likewise.\n+\t(double_int_and): Likewise.\n+\t(double_int_and_not): Likewise.\n+\t(double_int_xor): Likewise.\n+\t(double_int_lshift): Likewise.\n+\t(double_int_rshift): Likewise.\n+\t(double_int_lrotate): Likewise.\n+\t(double_int_rrotate): Likewise.\n+\t(double_int_cmp): Likewise.\n+\t(double_int_scmp): Likewise.\n+\t(double_int_ucmp): Likewise.\n+\t(double_int_max): Likewise.\n+\t(double_int_smax): Likewise.\n+\t(double_int_umax): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_smin): Likewise.\n+\t(double_int_umin): Likewise.\n+\t(double_int_ext): Likewise.\n+\t(double_int_sext): Likewise.\n+\t(double_int_zext): Likewise.\n+\t(double_int_mask): Likewise.\n+\t(double_int_max_value): Likewise.\n+\t(double_int_min_value): Likewise.\n+\t(double_int_zero_p): Likewise.\n+\t(double_int_one_p): Likewise.\n+\t(double_int_minus_one_p): Likewise.\n+\t(double_int_equal_p): Likewise.\n+\t(double_int_popcount): Likewise.\n+\t* hash-table.c\n+\t(double_int_mask): Reuse implementation for double_int::mask.\n+\t(double_int_max_value): Likewise.\n+\t(double_int_min_value): Likewise.\n+\t(double_int_ext): Likewise.\n+\t(double_int_zext): Likewise.\n+\t(double_int_sext): Likewise.\n+\t(double_int_mul_with_sign): Likewise.\n+\t(double_int_divmod): Likewise.\n+\t(double_int_sdivmod): Likewise.\n+\t(double_int_udivmod): Likewise.\n+\t(double_int_div): Likewise.\n+\t(double_int_sdiv): Likewise.\n+\t(double_int_udiv): Likewise.\n+\t(double_int_mod): Likewise.\n+\t(double_int_smod): Likewise.\n+\t(double_int_umod): Likewise.\n+\t(double_int_multiple_of): Likewise.\n+\t(double_int_lshift): Likewise.\n+\t(double_int_rshift): Likewise.\n+\t(double_int_lrotate): Likewise.\n+\t(double_int_rrotate): Likewise.\n+\t(double_int_cmp): Likewise.\n+\t(double_int_ucmp): Likewise.\n+\t(double_int_scmp): Likewise.\n+\t(double_int_max): Likewise.\n+\t(double_int_smax): Likewise.\n+\t(double_int_umax): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_smin): Likewise.\n+\t(double_int_umin): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int_min): Likewise.\n+\t(double_int::alshift): New.\n+\t(double_int::arshift): New.\n+\t(double_int::llshift): New.\n+\t(double_int::lrshift): New.\n+\t(double_int::ult): New.\n+\t(double_int::ugt): New.\n+\t(double_int::slt): New.\n+\t(double_int::sgt): New.\n+\t(double_int_setbit): Reuse implementation for double_int::set_bit,\n+\twhich avoids a name conflict with a macro.\n+\t(double_int_double_int_ctz): Reuse implementation for\n+\tdouble_int::trailing_zeros.\n+\t(double_int_fits_in_shwi_p): Reuse implementation for\n+\tdouble_int::fits_signed.\n+\t(double_int_fits_in_hwi_p): Reuse implementation for double_int::fits.\n+\t(double_int_mul): Reuse implementation for binary\n+\tdouble_int::operator *.\n+\t(double_int_add): Likewise.\n+\t(double_int_sub): Likewise.\n+\t(double_int_neg): Reuse implementation for unary\n+\tdouble_int::operator -.\n+\t(double_int_max_value): Likewise.\n+\t* fixed-value.c: Change to use member functions introduced above.\n+\n+2012-08-14   Lawrence Crowl  <crowl@google.com>\n+\n+\tMerge cxx-conversion branch.  Support tree macro calling\n+\tfrom gdb.\n+\n+\t* tree.h (tree_check): New.\n+\t(TREE_CHECK): Use inline function above instead of __extension__.\n+\t(tree_not_check): New.\n+\t(TREE_NOT_CHECK): Use inline function above instead of __extension__.\n+\t(tree_check2): New.\n+\t(TREE_CHECK2): Use inline function above instead of __extension__.\n+\t(tree_not_check2): New.\n+\t(TREE_NOT_CHECK2): Use inline function above instead of __extension__.\n+\t(tree_check3): New.\n+\t(TREE_CHECK3): Use inline function above instead of __extension__.\n+\t(tree_not_check3): New.\n+\t(TREE_NOT_CHECK3): Use inline function above instead of __extension__.\n+\t(tree_check4): New.\n+\t(TREE_CHECK4): Use inline function above instead of __extension__.\n+\t(tree_not_check4): New.\n+\t(TREE_NOT_CHECK4): Use inline function above instead of __extension__.\n+\t(tree_check5): New.\n+\t(TREE_CHECK5): Use inline function above instead of __extension__.\n+\t(tree_not_check5): New.\n+\t(TREE_NOT_CHECK5): Use inline function above instead of __extension__.\n+\t(contains_struct_check): New.\n+\t(CONTAINS_STRUCT_CHECK): Use inline function above instead of\n+\t__extension__.\n+\t(tree_class_check): New.\n+\t(TREE_CLASS_CHECK): Use inline function above instead of __extension__.\n+\t(tree_range_check): New.\n+\t(TREE_RANGE_CHECK): Use inline function above instead of __extension__.\n+\t(omp_clause_subcode_check): New.\n+\t(OMP_CLAUSE_SUBCODE_CHECK): Use inline function above instead of\n+\t__extension__.\n+\t(omp_clause_range_check): New.\n+\t(OMP_CLAUSE_RANGE_CHECK): Use inline function above instead of\n+\t__extension__.\n+\t(expr_check): New.\n+\t(EXPR_CHECK): Use inline function above instead of __extension__.\n+\t(non_type_check): New.\n+\t(NON_TYPE_CHECK): Use inline function above instead of __extension__.\n+\t(tree_vec_elt_check): New.\n+\t(TREE_VEC_ELT_CHECK): Use inline function above instead of\n+\t__extension__.\n+\t(omp_clause_elt_check): New.\n+\t(OMP_CLAUSE_ELT_CHECK): Use inline function above instead of\n+\t__extension__.\n+\t(tree_operand_check): New.\n+\t(TREE_OPERAND_CHECK): Use inline function above instead of\n+\t__extension__.\n+\t(tree_operand_check_code): New.\n+\t(TREE_OPERAND_CHECK_CODE): Use inline function above instead of\n+\t__extension__.\n+\t(TREE_CHAIN): Simplify implementation.\n+\t(TREE_TYPE): Simplify implementation.\n+\t(tree_operand_length): Move for compilation dependences.\n+\t* gdbinit.in: (macro define __FILE__): New.\n+\t(macro define __LINE__): New.\n+\t(skip \"tree.h\"): New.\n+\n 2012-08-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (enabled): Add comment with explanation"}, {"sha": "54d4e56f0387039f5cb2da7b4f06feb79df7b7b7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -223,13 +223,6 @@ RANLIB_FLAGS = @ranlib_flags@\n HOST_LIBS = @HOST_LIBS@\n \n # The name of the compiler to use.\n-ENABLE_BUILD_WITH_CXX = @ENABLE_BUILD_WITH_CXX@\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-COMPILER = $(CC)\n-COMPILER_FLAGS = $(CFLAGS)\n-LINKER = $(CC)\n-LINKER_FLAGS = $(CFLAGS)\n-else\n COMPILER = $(CXX)\n COMPILER_FLAGS = $(CXXFLAGS)\n # If HOST_LIBS is set, then the user is controlling the libraries to\n@@ -243,7 +236,6 @@ else\n LINKER = $(CC)\n LINKER_FLAGS = $(CFLAGS)\n endif\n-endif\n \n # -------------------------------------------\n # Programs which operate on the build machine\n@@ -336,13 +328,8 @@ CLOOGINC = @CLOOGINC@\n enable_lto = @enable_lto@\n \n # Compiler and flags needed for plugin support\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-PLUGINCC = @CC@\n-PLUGINCFLAGS = @CFLAGS@\n-else\n PLUGINCC = @CXX@\n PLUGINCFLAGS = @CXXFLAGS@\n-endif\n \n # Libs and linker options needed for plugin support\n PLUGINLIBS = @pluginlibs@\n@@ -732,22 +719,12 @@ BUILD_CFLAGS= @BUILD_CFLAGS@ -DGENERATOR_FILE\n BUILD_CXXFLAGS = @BUILD_CXXFLAGS@ -DGENERATOR_FILE\n \n # Native compiler that we use.  This may be C++ some day.\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-COMPILER_FOR_BUILD = $(CC_FOR_BUILD)\n-BUILD_COMPILERFLAGS = $(BUILD_CFLAGS)\n-else\n COMPILER_FOR_BUILD = $(CXX_FOR_BUILD)\n BUILD_COMPILERFLAGS = $(BUILD_CXXFLAGS)\n-endif\n \n # Native linker that we use.\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-LINKER_FOR_BUILD = $(CC_FOR_BUILD)\n-BUILD_LINKERFLAGS = $(BUILD_CFLAGS)\n-else\n LINKER_FOR_BUILD = $(CXX_FOR_BUILD)\n BUILD_LINKERFLAGS = $(BUILD_CXXFLAGS)\n-endif\n \n # Native linker and preprocessor flags.  For x-fragment overrides.\n BUILD_LDFLAGS=@BUILD_LDFLAGS@\n@@ -839,6 +816,7 @@ endif\n \n # Shorthand variables for dependency lists.\n VEC_H = vec.h statistics.h\n+HASH_TABLE_H = $(HASHTAB_H) hash-table.h\n EXCEPT_H = except.h $(HASHTAB_H) vecprim.h vecir.h\n TARGET_DEF = target.def target-hooks-macros.h\n C_TARGET_DEF = c-family/c-target.def target-hooks-macros.h\n@@ -998,18 +976,10 @@ ALL_CXXFLAGS = $(T_CFLAGS) $(CFLAGS-$@) $(CXXFLAGS) $(INTERNAL_CFLAGS) \\\n ALL_CPPFLAGS = $(INCLUDES) $(CPPFLAGS)\n \n # This is the variable to use when using $(COMPILER).\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-ALL_COMPILERFLAGS = $(ALL_CFLAGS)\n-else\n ALL_COMPILERFLAGS = $(ALL_CXXFLAGS)\n-endif\n \n # This is the variable to use when using $(LINKER).\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-ALL_LINKERFLAGS = $(ALL_CFLAGS)\n-else\n ALL_LINKERFLAGS = $(ALL_CXXFLAGS)\n-endif\n \n # Build and host support libraries.\n LIBIBERTY = ../libiberty/libiberty.a\n@@ -1466,7 +1436,8 @@ OBJS-libcommon = diagnostic.o pretty-print.o intl.o input.o version.o\n # Objects in libcommon-target.a, used by drivers and by the core\n # compiler and containing target-dependent code.\n OBJS-libcommon-target = $(common_out_object_file) prefix.o params.o \\\n-\topts.o opts-common.o options.o vec.o hooks.o common/common-targhooks.o\n+\topts.o opts-common.o options.o vec.o hooks.o common/common-targhooks.o \\\n+\thash-table.o\n \n # This lists all host objects for the front ends.\n ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))\n@@ -2224,7 +2195,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n-   $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) $(TREE_DUMP_H) \\\n+   $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(HASH_TABLE_H) \\\n    $(GIMPLE_H) $(FUNCTION_H) tree-ssa-sccvn.h \\\n    $(CGRAPH_H) $(GIMPLE_PRETTY_PRINT_H) $(PARAMS_H)\n tree-ssa-structalias.o: tree-ssa-structalias.c \\\n@@ -2260,7 +2231,7 @@ tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa-coalesce.o : tree-ssa-coalesce.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h dumpfile.h \\\n-   $(TREE_SSA_LIVE_H) $(BITMAP_H) $(FLAGS_H) $(HASHTAB_H) \\\n+   $(TREE_SSA_LIVE_H) $(BITMAP_H) $(FLAGS_H) $(HASH_TABLE_H) \\\n    $(TREE_PRETTY_PRINT_H)\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h dumpfile.h \\\n@@ -2321,7 +2292,7 @@ tree-ssa-threadedge.o : tree-ssa-threadedge.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    tree-ssa-propagate.h langhooks.h \\\n    $(PARAMS_H)\n tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(HASH_TABLE_H) \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TM_H) coretypes.h dumpfile.h \\\n    $(BASIC_BLOCK_H) $(FLAGS_H) $(CFGLOOP_H)\n tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -2343,7 +2314,7 @@ tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(FLAGS_H) langhooks.h \\\n-   $(CFGLOOP_H) alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) \\\n+   $(CFGLOOP_H) alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASH_TABLE_H) \\\n    $(GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \\\n    $(DBGCNT_H) tree-scalar-evolution.h $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n@@ -2927,8 +2898,8 @@ ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) toplev.h $(DIAGNOSTIC_CORE_H) $(GGC_H) langhooks.h $(COVERAGE_H) \\\n-   $(HASHTAB_H) tree-iterator.h $(CGRAPH_H) gcov-io.c $(TM_P_H) \\\n-   $(DIAGNOSTIC_CORE_H) intl.h gt-coverage.h $(TARGET_H)\n+   tree-iterator.h $(CGRAPH_H) gcov-io.c $(TM_P_H) \\\n+   $(DIAGNOSTIC_CORE_H) intl.h gt-coverage.h $(TARGET_H) $(HASH_TABLE_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) \\\n    $(EMIT_RTL_H) $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) \\\n@@ -2999,7 +2970,8 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h  $(PARAMS_H) \\\n-   tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(DIAGNOSTIC_CORE_H) \\\n+   tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) \\\n+   $(DIAGNOSTIC_CORE_H) $(HASH_TABLE_H) \\\n    $(DBGCNT_H) $(GIMPLE_PRETTY_PRINT_H) gimple-fold.h\n tree-ssa-strlen.o : tree-ssa-strlen.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) domwalk.h alloc-pool.h tree-ssa-propagate.h \\\n@@ -3153,6 +3125,8 @@ bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h \\\n    $(GGC_H) gt-bitmap.h $(BITMAP_H) $(OBSTACK_H) $(HASHTAB_H)\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(VEC_H) $(GGC_H) \\\n    $(DIAGNOSTIC_CORE_H) $(HASHTAB_H)\n+hash-table.o : hash-table.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(HASHTAB_H)\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) \\\n    hard-reg-set.h insn-config.h $(REGS_H) $(FUNCTION_H) real.h \\"}, {"sha": "cd35cd1b123c15ac07baae4cdf0a99af190e6b58", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -2921,7 +2921,7 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n \t      = VEC_index (constructor_elt,\n \t\t\t   CONSTRUCTOR_ELTS\n \t\t\t   (TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1)),\n-\t\t\t    1)->value;\n+\t\t\t    1).value;\n \t  else\n \t    ret_val = TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1);\n \t}\n@@ -2980,7 +2980,7 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n \t\t      TREE_OPERAND (alloc, 0),\n \t\t      VEC_index (constructor_elt,\n \t\t\t\t CONSTRUCTOR_ELTS (TREE_OPERAND (alloc, 1)),\n-\t\t\t\t\t\t   0)->value);\n+\t\t\t\t\t\t   0).value);\n \n \t  /* Build a modified CONSTRUCTOR that references NEW_VAR.  */\n \t  p_array = TYPE_FIELDS (TREE_TYPE (alloc));\n@@ -2990,7 +2990,7 @@ finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n \t\t\t\t  VEC_index (constructor_elt,\n \t\t\t\t\t     CONSTRUCTOR_ELTS\n \t\t\t\t\t     (TREE_OPERAND (alloc, 1)),\n-\t\t\t\t\t      1)->value);\n+\t\t\t\t\t      1).value);\n \t  new_ret = build_constructor (TREE_TYPE (alloc), v);\n \t}\n       else"}, {"sha": "c9b29ad9d409685c2fb03a95815aa6688f7aec82", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -4491,10 +4491,10 @@ convert (tree type, tree expr)\n \t inner expression.  */\n       if (TREE_CODE (expr) == CONSTRUCTOR\n \t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (expr))\n-\t  && VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->index\n+\t  && VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0).index\n \t     == TYPE_FIELDS (etype))\n \tunpadded\n-\t  = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->value;\n+\t  = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0).value;\n \n       /* Otherwise, build an explicit component reference.  */\n       else\n@@ -5047,7 +5047,7 @@ remove_conversions (tree exp, bool true_address)\n \t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (exp)))\n \treturn\n \t  remove_conversions (VEC_index (constructor_elt,\n-\t\t\t\t\t CONSTRUCTOR_ELTS (exp), 0)->value,\n+\t\t\t\t\t CONSTRUCTOR_ELTS (exp), 0).value,\n \t\t\t      true);\n       break;\n "}, {"sha": "4578114f4a7c3debdde0d5c5cbc679b5930c8870", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -441,7 +441,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n \n   /* The constant folder doesn't fold fat pointer types so we do it here.  */\n   if (TREE_CODE (p1) == CONSTRUCTOR)\n-    p1_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 0)->value;\n+    p1_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 0).value;\n   else\n     p1_array = build_component_ref (p1, NULL_TREE,\n \t\t\t\t    TYPE_FIELDS (TREE_TYPE (p1)), true);\n@@ -452,7 +452,7 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n \t\t\t\t\t null_pointer_node));\n \n   if (TREE_CODE (p2) == CONSTRUCTOR)\n-    p2_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 0)->value;\n+    p2_array = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 0).value;\n   else\n     p2_array = build_component_ref (p2, NULL_TREE,\n \t\t\t\t    TYPE_FIELDS (TREE_TYPE (p2)), true);\n@@ -473,14 +473,14 @@ compare_fat_pointers (location_t loc, tree result_type, tree p1, tree p2)\n     = fold_build2_loc (loc, EQ_EXPR, result_type, p1_array, p2_array);\n \n   if (TREE_CODE (p1) == CONSTRUCTOR)\n-    p1_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 1)->value;\n+    p1_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p1), 1).value;\n   else\n     p1_bounds\n       = build_component_ref (p1, NULL_TREE,\n \t\t\t     DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (p1))), true);\n \n   if (TREE_CODE (p2) == CONSTRUCTOR)\n-    p2_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 1)->value;\n+    p2_bounds = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (p2), 1).value;\n   else\n     p2_bounds\n       = build_component_ref (p2, NULL_TREE,\n@@ -1336,7 +1336,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t    {\n \t      result = VEC_index (constructor_elt,\n \t\t\t\t  CONSTRUCTOR_ELTS (operand),\n-\t\t\t\t  0)->value;\n+\t\t\t\t  0).value;\n \t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n \t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n \t      break;\n@@ -2676,9 +2676,9 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n \t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ref)) == 1)\n \t{\n \t  tree index\n-\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->index;\n+\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0).index;\n \t  tree value\n-\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->value;\n+\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0).value;\n \t  result\n \t    = build_constructor_single (type, index,\n \t\t\t\t\tgnat_stabilize_reference_1 (value,"}, {"sha": "de7640f46f1dc0b5b5f45586724da4f28207c4c4", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -852,8 +852,8 @@ new_alias_set (void)\n   if (flag_strict_aliasing)\n     {\n       if (alias_sets == 0)\n-\tVEC_safe_push (alias_set_entry, gc, alias_sets, 0);\n-      VEC_safe_push (alias_set_entry, gc, alias_sets, 0);\n+\tVEC_safe_push (alias_set_entry, gc, alias_sets, (alias_set_entry) 0);\n+      VEC_safe_push (alias_set_entry, gc, alias_sets, (alias_set_entry) 0);\n       return VEC_length (alias_set_entry, alias_sets) - 1;\n     }\n   else"}, {"sha": "6e1d0911824b8796673632088ed1808e59b773a0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -33,19 +33,19 @@ along with GCC; see the file COPYING3.  If not see\n typedef HOST_WIDEST_INT gcov_type;\n \n /* Control flow edge information.  */\n-struct GTY(()) edge_def {\n+struct GTY((user)) edge_def {\n   /* The two blocks at the ends of the edge.  */\n   basic_block src;\n   basic_block dest;\n \n   /* Instructions queued on the edge.  */\n   union edge_def_insns {\n-    gimple_seq GTY ((tag (\"true\"))) g;\n-    rtx GTY ((tag (\"false\"))) r;\n-  } GTY ((desc (\"current_ir_type () == IR_GIMPLE\"))) insns;\n+    gimple_seq g;\n+    rtx r;\n+  } insns;\n \n   /* Auxiliary info specific to a pass.  */\n-  PTR GTY ((skip (\"\"))) aux;\n+  PTR aux;\n \n   /* Location of any goto implicit in the edge and associated BLOCK.  */\n   tree goto_block;\n@@ -65,6 +65,11 @@ DEF_VEC_P(edge);\n DEF_VEC_ALLOC_P(edge,gc);\n DEF_VEC_ALLOC_P(edge,heap);\n \n+/* Garbage collection and PCH support for edge_def.  */\n+extern void gt_ggc_mx (edge_def *e);\n+extern void gt_pch_nx (edge_def *e);\n+extern void gt_pch_nx (edge_def *e, gt_pointer_operator, void *);\n+\n /* Masks for edge.flags.  */\n #define DEF_EDGE_FLAG(NAME,IDX) EDGE_##NAME = 1 << IDX ,\n enum cfg_edge_flags {"}, {"sha": "ab3eb0a1ad38f8dc62f7775373cd8e0993d90bf9", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -8392,7 +8392,7 @@ parse_optimize_options (tree args, bool attr_p)\n   /* Build up argv vector.  Just in case the string is stored away, use garbage\n      collected strings.  */\n   VEC_truncate (const_char_p, optimize_args, 0);\n-  VEC_safe_push (const_char_p, gc, optimize_args, NULL);\n+  VEC_safe_push (const_char_p, gc, optimize_args, (const_char_p)NULL);\n \n   for (ap = args; ap != NULL_TREE; ap = TREE_CHAIN (ap))\n     {\n@@ -9390,10 +9390,10 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t      constructor_elt *ce;\n \t      bool fold_p = false;\n \n-\t      if (VEC_index (constructor_elt, v, 0)->index)\n+\t      if (VEC_index (constructor_elt, v, 0).index)\n \t\tmaxindex = fold_convert_loc (input_location, sizetype,\n \t\t\t\t\t     VEC_index (constructor_elt,\n-\t\t\t\t\t\t\tv, 0)->index);\n+\t\t\t\t\t\t\tv, 0).index);\n \t      curindex = maxindex;\n \n \t      for (cnt = 1;"}, {"sha": "77ed0f0332594e0d449e9d7284e873f9d69cdfd9", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1209,9 +1209,9 @@ c_pp_lookup_pragma (unsigned int id, const char **space, const char **name)\n \t  + VEC_length (pragma_ns_name, registered_pp_pragmas)))\n     {\n       *space = VEC_index (pragma_ns_name, registered_pp_pragmas,\n-\t\t\t  id - PRAGMA_FIRST_EXTERNAL)->space;\n+\t\t\t  id - PRAGMA_FIRST_EXTERNAL).space;\n       *name = VEC_index (pragma_ns_name, registered_pp_pragmas,\n-\t\t\t id - PRAGMA_FIRST_EXTERNAL)->name;\n+\t\t\t id - PRAGMA_FIRST_EXTERNAL).name;\n       return;\n     }\n \n@@ -1334,7 +1334,7 @@ c_invoke_pragma_handler (unsigned int id)\n   pragma_handler_2arg handler_2arg;\n \n   id -= PRAGMA_FIRST_EXTERNAL;\n-  ihandler = VEC_index (internal_pragma_handler, registered_pragmas, id);\n+  ihandler = &VEC_index (internal_pragma_handler, registered_pragmas, id);\n   if (ihandler->extra_data)\n     {\n       handler_2arg = ihandler->handler.handler_2arg;"}, {"sha": "e5d17b7ec99e136af83c23c62bb8959ede933a10", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -3932,7 +3932,7 @@ add_flexible_array_elts_to_size (tree decl, tree init)\n   if (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (init)))\n     return;\n \n-  elt = VEC_last (constructor_elt, CONSTRUCTOR_ELTS (init))->value;\n+  elt = VEC_last (constructor_elt, CONSTRUCTOR_ELTS (init)).value;\n   type = TREE_TYPE (elt);\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_SIZE (type) == NULL_TREE"}, {"sha": "34d5a34c8082b1f9fcae4289c3f6bef30251dfc3", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -6529,9 +6529,9 @@ c_parser_postfix_expression (c_parser *parser)\n \t\tbreak;\n \t      }\n \n-\t    e1_p = VEC_index (c_expr_t, cexpr_list, 0);\n-\t    e2_p = VEC_index (c_expr_t, cexpr_list, 1);\n-\t    e3_p = VEC_index (c_expr_t, cexpr_list, 2);\n+\t    e1_p = &VEC_index (c_expr_t, cexpr_list, 0);\n+\t    e2_p = &VEC_index (c_expr_t, cexpr_list, 1);\n+\t    e3_p = &VEC_index (c_expr_t, cexpr_list, 2);\n \n \t    c = e1_p->value;\n \t    mark_exp_read (e2_p->value);\n@@ -6611,8 +6611,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t\tbreak;\n \t      }\n \n-\t    e1_p = VEC_index (c_expr_t, cexpr_list, 0);\n-\t    e2_p = VEC_index (c_expr_t, cexpr_list, 1);\n+\t    e1_p = &VEC_index (c_expr_t, cexpr_list, 0);\n+\t    e2_p = &VEC_index (c_expr_t, cexpr_list, 1);\n \n \t    mark_exp_read (e1_p->value);\n \t    if (TREE_CODE (e1_p->value) == EXCESS_PRECISION_EXPR)\n@@ -6671,15 +6671,15 @@ c_parser_postfix_expression (c_parser *parser)\n \t    if (VEC_length (c_expr_t, cexpr_list) == 2)\n \t      expr.value =\n \t\tc_build_vec_perm_expr\n-\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0)->value,\n-\t\t   NULL_TREE, VEC_index (c_expr_t, cexpr_list, 1)->value);\n+\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0).value,\n+\t\t   NULL_TREE, VEC_index (c_expr_t, cexpr_list, 1).value);\n \n \t    else if (VEC_length (c_expr_t, cexpr_list) == 3)\n \t      expr.value =\n \t\tc_build_vec_perm_expr\n-\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0)->value,\n-\t\t   VEC_index (c_expr_t, cexpr_list, 1)->value,\n-\t\t   VEC_index (c_expr_t, cexpr_list, 2)->value);\n+\t\t  (loc, VEC_index (c_expr_t, cexpr_list, 0).value,\n+\t\t   VEC_index (c_expr_t, cexpr_list, 1).value,\n+\t\t   VEC_index (c_expr_t, cexpr_list, 2).value);\n \t    else\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \""}, {"sha": "5b710c32823c7497a39882afdf338a4578e5c7b5", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -6950,7 +6950,7 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n \tbool constructor_zeroinit =\n \t (VEC_length (constructor_elt, constructor_elements) == 1\n \t  && integer_zerop\n-\t      (VEC_index (constructor_elt, constructor_elements, 0)->value));\n+\t      (VEC_index (constructor_elt, constructor_elements, 0).value));\n \n \t/* Do not warn for flexible array members or zero-length arrays.  */\n \twhile (constructor_unfilled_fields\n@@ -6997,10 +6997,10 @@ pop_init_level (int implicit, struct obstack * braced_init_obstack)\n       else if (VEC_length (constructor_elt,constructor_elements) != 1)\n \t{\n \t  error_init (\"extra elements in scalar initializer\");\n-\t  ret.value = VEC_index (constructor_elt,constructor_elements,0)->value;\n+\t  ret.value = VEC_index (constructor_elt,constructor_elements,0).value;\n \t}\n       else\n-\tret.value = VEC_index (constructor_elt,constructor_elements,0)->value;\n+\tret.value = VEC_index (constructor_elt,constructor_elements,0).value;\n     }\n   else\n     {\n@@ -7671,9 +7671,9 @@ find_init_member (tree field, struct obstack * braced_init_obstack)\n   else if (TREE_CODE (constructor_type) == UNION_TYPE)\n     {\n       if (!VEC_empty (constructor_elt, constructor_elements)\n-\t  && (VEC_last (constructor_elt, constructor_elements)->index\n+\t  && (VEC_last (constructor_elt, constructor_elements).index\n \t      == field))\n-\treturn VEC_last (constructor_elt, constructor_elements)->value;\n+\treturn VEC_last (constructor_elt, constructor_elements).value;\n     }\n   return 0;\n }\n@@ -7856,7 +7856,7 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n       if (!implicit)\n \t{\n \t  if (TREE_SIDE_EFFECTS (VEC_last (constructor_elt,\n-\t\t\t\t\t   constructor_elements)->value))\n+\t\t\t\t\t   constructor_elements).value))\n \t    warning_init (0,\n \t\t\t  \"initialized field with side-effects overwritten\");\n \t  else if (warn_override_init)"}, {"sha": "3c4dee811e74974227ad88e00b0ffdbb2d923947", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1587,7 +1587,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n            (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x))\n       && HWI_COMPUTABLE_MODE_P (GET_MODE (x)))\n     {\n-      reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+      reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n \n       if (set == 0 || GET_CODE (set) == CLOBBER)\n \t{\n@@ -3635,21 +3635,21 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (REG_P (temp)\n \t\t  && VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\tREGNO (temp))->nonzero_bits != 0\n+\t\t\t\tREGNO (temp)).nonzero_bits != 0\n \t\t  && GET_MODE_PRECISION (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_PRECISION (GET_MODE (temp)) < HOST_BITS_PER_INT\n \t\t  && (VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\t REGNO (temp))->nonzero_bits\n+\t\t\t\t REGNO (temp)).nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (REG_P (temp)\n \t\t      && VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\t    REGNO (temp))->nonzero_bits != 0\n+\t\t\t\t    REGNO (temp)).nonzero_bits != 0\n \t\t      && GET_MODE_PRECISION (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_PRECISION (GET_MODE (temp)) < HOST_BITS_PER_INT\n \t\t      && (VEC_index (reg_stat_type, reg_stat,\n-\t\t\t\t     REGNO (temp))->nonzero_bits\n+\t\t\t\t     REGNO (temp)).nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -9425,7 +9425,7 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n      value.  Otherwise, use the previously-computed global nonzero bits\n      for this register.  */\n \n-  rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n   if (rsp->last_set_value != 0\n       && (rsp->last_set_mode == mode\n \t  || (GET_MODE_CLASS (rsp->last_set_mode) == MODE_INT\n@@ -9494,7 +9494,7 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n   rtx tem;\n   reg_stat_type *rsp;\n \n-  rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n   if (rsp->last_set_value != 0\n       && rsp->last_set_mode == mode\n       && ((rsp->last_set_label >= label_tick_ebb_start\n@@ -12033,7 +12033,7 @@ update_table_tick (rtx x)\n \n       for (r = regno; r < endregno; r++)\n \t{\n-\t  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, r);\n+\t  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, r);\n \t  rsp->last_set_table_tick = label_tick;\n \t}\n \n@@ -12135,7 +12135,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n      register.  */\n   for (i = regno; i < endregno; i++)\n     {\n-      rsp = VEC_index (reg_stat_type, reg_stat, i);\n+      rsp = &VEC_index (reg_stat_type, reg_stat, i);\n \n       if (insn)\n \trsp->last_set = insn;\n@@ -12161,7 +12161,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n   for (i = regno; i < endregno; i++)\n     {\n-      rsp = VEC_index (reg_stat_type, reg_stat, i);\n+      rsp = &VEC_index (reg_stat_type, reg_stat, i);\n       rsp->last_set_label = label_tick;\n       if (!insn\n \t  || (value && rsp->last_set_table_tick >= label_tick_ebb_start))\n@@ -12173,7 +12173,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n-  rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+  rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n   if (value && !get_last_value_validate (&value, insn, label_tick, 0))\n     {\n       value = copy_rtx (value);\n@@ -12271,7 +12271,7 @@ record_dead_and_set_regs (rtx insn)\n \t    {\n \t      reg_stat_type *rsp;\n \n-\t      rsp = VEC_index (reg_stat_type, reg_stat, i);\n+\t      rsp = &VEC_index (reg_stat_type, reg_stat, i);\n \t      rsp->last_death = insn;\n \t    }\n \t}\n@@ -12286,7 +12286,7 @@ record_dead_and_set_regs (rtx insn)\n \t  {\n \t    reg_stat_type *rsp;\n \n-\t    rsp = VEC_index (reg_stat_type, reg_stat, i);\n+\t    rsp = &VEC_index (reg_stat_type, reg_stat, i);\n \t    rsp->last_set_invalid = 1;\n \t    rsp->last_set = insn;\n \t    rsp->last_set_value = 0;\n@@ -12344,7 +12344,7 @@ record_promoted_value (rtx insn, rtx subreg)\n \t  continue;\n \t}\n \n-      rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+      rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n       if (rsp->last_set == insn)\n \t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n@@ -12369,7 +12369,7 @@ record_promoted_value (rtx insn, rtx subreg)\n static bool\n reg_truncated_to_mode (enum machine_mode mode, const_rtx x)\n {\n-  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n   enum machine_mode truncated = rsp->truncated_to_mode;\n \n   if (truncated == 0\n@@ -12414,7 +12414,7 @@ record_truncated_value (rtx *p, void *data ATTRIBUTE_UNUSED)\n   else\n     return 0;\n \n-  rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  rsp = &VEC_index (reg_stat_type, reg_stat, REGNO (x));\n   if (rsp->truncated_to_mode == 0\n       || rsp->truncation_label < label_tick_ebb_start\n       || (GET_MODE_SIZE (truncated_mode)\n@@ -12493,7 +12493,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \n       for (j = regno; j < endregno; j++)\n \t{\n-\t  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, j);\n+\t  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, j);\n \t  if (rsp->last_set_invalid\n \t      /* If this is a pseudo-register that was only set once and not\n \t\t live at the beginning of the function, it is always valid.  */\n@@ -12597,7 +12597,7 @@ get_last_value (const_rtx x)\n     return 0;\n \n   regno = REGNO (x);\n-  rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+  rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n   value = rsp->last_set_value;\n \n   /* If we don't have a value, or if it isn't for this basic block and\n@@ -12661,7 +12661,7 @@ use_crosses_set_p (const_rtx x, int from_luid)\n #endif\n       for (; regno < endreg; regno++)\n \t{\n-\t  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+\t  reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n \t  if (rsp->last_set\n \t      && rsp->last_set_label == label_tick\n \t      && DF_INSN_LUID (rsp->last_set) > from_luid)\n@@ -12909,7 +12909,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx to_insn,\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      rtx where_dead = VEC_index (reg_stat_type, reg_stat, regno)->last_death;\n+      rtx where_dead = VEC_index (reg_stat_type, reg_stat, regno).last_death;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n       if (maybe_kill_insn && reg_set_p (x, maybe_kill_insn)\n@@ -13524,7 +13524,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  if (place && REG_NOTE_KIND (note) == REG_DEAD)\n \t    {\n \t      unsigned int regno = REGNO (XEXP (note, 0));\n-\t      reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+\t      reg_stat_type *rsp = &VEC_index (reg_stat_type, reg_stat, regno);\n \n \t      if (dead_or_set_p (place, XEXP (note, 0))\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))"}, {"sha": "6d986bec56ae16810c84ac41f6db48c2d8f02088", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -45,12 +45,6 @@\n #endif\n \n \n-/* Define if building with C++. */\n-#ifndef USED_FOR_TARGET\n-#undef ENABLE_BUILD_WITH_CXX\n-#endif\n-\n-\n /* Define if you want more run-time sanity checks. This one gets a grab bag of\n    miscellaneous but relatively cheap checks. */\n #ifndef USED_FOR_TARGET"}, {"sha": "0a0d702f26ee09158423190518c83333715958c2", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -3478,7 +3478,7 @@ hwloop_optimize (hwloop_info loop)\n       /* If we have to insert the LSETUP before a jump, count that jump in the\n \t length.  */\n       if (VEC_length (edge, loop->incoming) > 1\n-\t  || !(VEC_last (edge, loop->incoming)->flags & EDGE_FALLTHRU))\n+\t  || !(VEC_last (edge, loop->incoming).flags & EDGE_FALLTHRU))\n \t{\n \t  gcc_assert (JUMP_P (insn));\n \t  insn = PREV_INSN (insn);\n@@ -3747,7 +3747,7 @@ hwloop_optimize (hwloop_info loop)\n     {\n       rtx prev = BB_END (loop->incoming_src);\n       if (VEC_length (edge, loop->incoming) > 1\n-\t  || !(VEC_last (edge, loop->incoming)->flags & EDGE_FALLTHRU))\n+\t  || !(VEC_last (edge, loop->incoming).flags & EDGE_FALLTHRU))\n \t{\n \t  gcc_assert (JUMP_P (prev));\n \t  prev = PREV_INSN (prev);"}, {"sha": "1905504f92314f276282595af72592ddc10f920f", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -126,7 +126,7 @@ DEF_VEC_ALLOC_O(c6x_sched_insn_info, heap);\n static VEC(c6x_sched_insn_info, heap) *insn_info;\n \n #define INSN_INFO_LENGTH (VEC_length (c6x_sched_insn_info, insn_info))\n-#define INSN_INFO_ENTRY(N) (*VEC_index (c6x_sched_insn_info, insn_info, (N)))\n+#define INSN_INFO_ENTRY(N) (VEC_index (c6x_sched_insn_info, insn_info, (N)))\n \n static bool done_cfi_sections;\n \n@@ -3448,8 +3448,8 @@ try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n     {\n       unsigned int mask1, mask2, mask_changed;\n       int count, side1, side2, req1, req2;\n-      insn_rr_info *this_rr = VEC_index (insn_rr_info, insn_rr,\n-\t\t\t\t\t INSN_UID (chain->insn));\n+      insn_rr_info *this_rr = &VEC_index (insn_rr_info, insn_rr,\n+\t\t\t\t\t  INSN_UID (chain->insn));\n \n       count = get_unit_reqs (chain->insn, &req1, &side1, &req2, &side2);\n \n@@ -3555,7 +3555,7 @@ reshuffle_units (basic_block loop)\n       if (!get_unit_operand_masks (insn, &mask1, &mask2))\n \tcontinue;\n \n-      info = VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n+      info = &VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n       if (info->op_info == NULL)\n \tcontinue;\n "}, {"sha": "3688136fb8460c162803af7737a09d1ab69529e4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -3971,7 +3971,8 @@ mips_multi_start (void)\n static struct mips_multi_member *\n mips_multi_add (void)\n {\n-  return VEC_safe_push (mips_multi_member, heap, mips_multi_members, 0);\n+  return VEC_safe_push (mips_multi_member, heap, mips_multi_members,\n+\t\t\t(struct mips_multi_member *) 0);\n }\n \n /* Add a normal insn with the given asm format to the current multi-insn\n@@ -4026,7 +4027,7 @@ mips_multi_copy_insn (unsigned int i)\n   struct mips_multi_member *member;\n \n   member = mips_multi_add ();\n-  memcpy (member, VEC_index (mips_multi_member, mips_multi_members, i),\n+  memcpy (member, &VEC_index (mips_multi_member, mips_multi_members, i),\n \t  sizeof (*member));\n   gcc_assert (!member->is_label_p);\n }\n@@ -4038,7 +4039,7 @@ mips_multi_copy_insn (unsigned int i)\n static void\n mips_multi_set_operand (unsigned int i, unsigned int op, rtx x)\n {\n-  VEC_index (mips_multi_member, mips_multi_members, i)->operands[op] = x;\n+  VEC_index (mips_multi_member, mips_multi_members, i).operands[op] = x;\n }\n \n /* Write out the asm code for the current multi-insn sequence.  */"}, {"sha": "1585bae34c89e2dcc526900b8819630a42097cdc", "filename": "gcc/configure", "status": "modified", "additions": 14, "deletions": 245, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -766,7 +766,6 @@ enable_shared\n enable_fixed_point\n enable_decimal_float\n enable_multilib\n-ENABLE_BUILD_WITH_CXX\n coverage_flags\n valgrind_command\n valgrind_path_defines\n@@ -873,7 +872,6 @@ enable_werror_always\n enable_checking\n enable_coverage\n enable_gather_detailed_mem_stats\n-enable_build_with_cxx\n with_stabs\n enable_multilib\n enable___cxa_atexit\n@@ -1575,7 +1573,6 @@ Optional Features:\n                           Values are opt, noopt, default is noopt\n   --enable-gather-detailed-mem-stats\n                           enable detailed memory allocation stats gathering\n-  --enable-build-with-cxx build with C++ compiler instead of C compiler\n   --enable-multilib       enable library support for multiple ABIs\n   --enable-__cxa_atexit   enable __cxa_atexit for C++\n   --enable-decimal-float={no,yes,bid,dpd}\n@@ -6997,21 +6994,6 @@ _ACEOF\n # Miscenalleous configure options\n # -------------------------------\n \n-# See if we are building gcc with C++.\n-# Check whether --enable-build-with-cxx was given.\n-if test \"${enable_build_with_cxx+set}\" = set; then :\n-  enableval=$enable_build_with_cxx; ENABLE_BUILD_WITH_CXX=$enableval\n-else\n-  ENABLE_BUILD_WITH_CXX=no\n-fi\n-\n-\n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"; then\n-\n-$as_echo \"#define ENABLE_BUILD_WITH_CXX 1\" >>confdefs.h\n-\n-fi\n-\n # With stabs\n \n # Check whether --with-stabs was given.\n@@ -9516,6 +9498,12 @@ fi\n \n # g++ on Solaris 10+ defines _XOPEN_SOURCE=600, which exposes a different\n # iconv() prototype.\n+ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n \n       if test \"X$prefix\" = \"XNONE\"; then\n     acl_final_prefix=\"$ac_default_prefix\"\n@@ -10057,13 +10045,6 @@ fi\n   fi\n \n \n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"; then :\n-  ac_ext=cpp\n-ac_cpp='$CXXCPP $CPPFLAGS'\n-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n-\n \n \n \n@@ -10219,169 +10200,12 @@ _ACEOF\n \n   fi\n \n-   ac_ext=c\n+ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n-else\n-\n-\n-\n-\n-\n-          am_save_CPPFLAGS=\"$CPPFLAGS\"\n-\n-  for element in $INCICONV; do\n-    haveit=\n-    for x in $CPPFLAGS; do\n-\n-  acl_save_prefix=\"$prefix\"\n-  prefix=\"$acl_final_prefix\"\n-  acl_save_exec_prefix=\"$exec_prefix\"\n-  exec_prefix=\"$acl_final_exec_prefix\"\n-  eval x=\\\"$x\\\"\n-  exec_prefix=\"$acl_save_exec_prefix\"\n-  prefix=\"$acl_save_prefix\"\n-\n-      if test \"X$x\" = \"X$element\"; then\n-        haveit=yes\n-        break\n-      fi\n-    done\n-    if test -z \"$haveit\"; then\n-      CPPFLAGS=\"${CPPFLAGS}${CPPFLAGS:+ }$element\"\n-    fi\n-  done\n-\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for iconv\" >&5\n-$as_echo_n \"checking for iconv... \" >&6; }\n-if test \"${am_cv_func_iconv+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-    am_cv_func_iconv=\"no, consider installing GNU libiconv\"\n-    am_cv_lib_iconv=no\n-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <stdlib.h>\n-#include <iconv.h>\n-int\n-main ()\n-{\n-iconv_t cd = iconv_open(\"\",\"\");\n-       iconv(cd,NULL,NULL,NULL,NULL);\n-       iconv_close(cd);\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  am_cv_func_iconv=yes\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-    if test \"$am_cv_func_iconv\" != yes; then\n-      am_save_LIBS=\"$LIBS\"\n-      LIBS=\"$LIBS $LIBICONV\"\n-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <stdlib.h>\n-#include <iconv.h>\n-int\n-main ()\n-{\n-iconv_t cd = iconv_open(\"\",\"\");\n-         iconv(cd,NULL,NULL,NULL,NULL);\n-         iconv_close(cd);\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  am_cv_lib_iconv=yes\n-        am_cv_func_iconv=yes\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-      LIBS=\"$am_save_LIBS\"\n-    fi\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $am_cv_func_iconv\" >&5\n-$as_echo \"$am_cv_func_iconv\" >&6; }\n-  if test \"$am_cv_func_iconv\" = yes; then\n-\n-$as_echo \"#define HAVE_ICONV 1\" >>confdefs.h\n-\n-  fi\n-  if test \"$am_cv_lib_iconv\" = yes; then\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking how to link with libiconv\" >&5\n-$as_echo_n \"checking how to link with libiconv... \" >&6; }\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $LIBICONV\" >&5\n-$as_echo \"$LIBICONV\" >&6; }\n-  else\n-            CPPFLAGS=\"$am_save_CPPFLAGS\"\n-    LIBICONV=\n-    LTLIBICONV=\n-  fi\n-\n-\n-\n-  if test \"$am_cv_func_iconv\" = yes; then\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for iconv declaration\" >&5\n-$as_echo_n \"checking for iconv declaration... \" >&6; }\n-    if test \"${am_cv_proto_iconv+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-#include <stdlib.h>\n-#include <iconv.h>\n-extern\n-#ifdef __cplusplus\n-\"C\"\n-#endif\n-#if defined(__STDC__) || defined(__cplusplus)\n-size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n-#else\n-size_t iconv();\n-#endif\n-\n-int\n-main ()\n-{\n-\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  am_cv_proto_iconv_arg1=\"\"\n-else\n-  am_cv_proto_iconv_arg1=\"const\"\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-      am_cv_proto_iconv=\"extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\"\n-fi\n-\n-    am_cv_proto_iconv=`echo \"$am_cv_proto_iconv\" | tr -s ' ' | sed -e 's/( /(/'`\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ${ac_t:-\n-         }$am_cv_proto_iconv\" >&5\n-$as_echo \"${ac_t:-\n-         }$am_cv_proto_iconv\" >&6; }\n-\n-cat >>confdefs.h <<_ACEOF\n-#define ICONV_CONST $am_cv_proto_iconv_arg1\n-_ACEOF\n-\n-  fi\n-\n-fi\n \n # Until we have in-tree GNU iconv:\n LIBICONV_DEP=\n@@ -10767,14 +10591,13 @@ done\n \n # g++ on Solaris 10+ defines _XOPEN_SOURCE=600, which hides the madvise()\n # prototype.\n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"; then :\n-  ac_ext=cpp\n+ac_ext=cpp\n ac_cpp='$CXXCPP $CPPFLAGS'\n ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n \n-   for ac_func in madvise\n+for ac_func in madvise\n do\n   ac_tr_decl=`$as_echo \"HAVE_DECL_$ac_func\" | $as_tr_cpp`\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $ac_func is declared\" >&5\n@@ -10787,8 +10610,8 @@ else\n #undef $ac_tr_decl\n #define $ac_tr_decl 1\n \n-     #include \"ansidecl.h\"\n-     #include \"system.h\"\n+  #include \"ansidecl.h\"\n+  #include \"system.h\"\n \n \n int\n@@ -10825,66 +10648,12 @@ fi\n \n done\n \n-   ac_ext=c\n+ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n-else\n-  for ac_func in madvise\n-do\n-  ac_tr_decl=`$as_echo \"HAVE_DECL_$ac_func\" | $as_tr_cpp`\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $ac_func is declared\" >&5\n-$as_echo_n \"checking whether $ac_func is declared... \" >&6; }\n-if { as_var=gcc_cv_have_decl_$ac_func; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#undef $ac_tr_decl\n-#define $ac_tr_decl 1\n-\n-     #include \"ansidecl.h\"\n-     #include \"system.h\"\n-\n-\n-int\n-main ()\n-{\n-#ifndef $ac_func\n-char *(*pfn) = (char *(*)) $ac_func ;\n-#endif\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  eval \"gcc_cv_have_decl_$ac_func=yes\"\n-else\n-  eval \"gcc_cv_have_decl_$ac_func=no\"\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-fi\n-\n-if eval \"test \\\"`echo '$gcc_cv_have_decl_'$ac_func`\\\" = yes\"; then\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n-$as_echo \"yes\" >&6; } ; cat >>confdefs.h <<_ACEOF\n-#define $ac_tr_decl 1\n-_ACEOF\n-\n-else\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n-$as_echo \"no\" >&6; } ; cat >>confdefs.h <<_ACEOF\n-#define $ac_tr_decl 0\n-_ACEOF\n-\n-fi\n-\n-done\n-\n-\n-fi\n \n # More time-related stuff.\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for struct tms\" >&5\n@@ -17973,7 +17742,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 17975 \"configure\"\n+#line 17744 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -18079,7 +17848,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18081 \"configure\"\n+#line 17850 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "579d9a803be64ea4809719c0e7743a24854d12cb", "filename": "gcc/configure.ac", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -596,18 +596,6 @@ AC_DEFINE_UNQUOTED(GATHER_STATISTICS, $gather_stats,\n # Miscenalleous configure options\n # -------------------------------\n \n-# See if we are building gcc with C++.\n-AC_ARG_ENABLE(build-with-cxx,\n-[AS_HELP_STRING([--enable-build-with-cxx],\n-\t\t[build with C++ compiler instead of C compiler])],\n-ENABLE_BUILD_WITH_CXX=$enableval,\n-ENABLE_BUILD_WITH_CXX=no)\n-AC_SUBST(ENABLE_BUILD_WITH_CXX)\n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"; then\n-  AC_DEFINE(ENABLE_BUILD_WITH_CXX, 1,\n-\t    [Define if building with C++.])\n-fi\n-\n # With stabs\n AC_ARG_WITH(stabs,\n [AS_HELP_STRING([--with-stabs],\n@@ -1067,11 +1055,9 @@ AC_FUNC_FORK\n \n # g++ on Solaris 10+ defines _XOPEN_SOURCE=600, which exposes a different\n # iconv() prototype.\n-AS_IF([test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"],\n-  [AC_LANG_PUSH([C++])\n-   AM_ICONV\n-   AC_LANG_POP([C++])],\n-  [AM_ICONV])\n+AC_LANG_PUSH([C++])\n+AM_ICONV\n+AC_LANG_POP([C++])\n \n # Until we have in-tree GNU iconv:\n LIBICONV_DEP=\n@@ -1140,18 +1126,12 @@ gcc_AC_CHECK_DECLS(sigaltstack, , ,[\n \n # g++ on Solaris 10+ defines _XOPEN_SOURCE=600, which hides the madvise()\n # prototype.\n-AS_IF([test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"],\n-  [AC_LANG_PUSH([C++])\n-   gcc_AC_CHECK_DECLS(madvise, , ,[\n-     #include \"ansidecl.h\"\n-     #include \"system.h\"\n-   ])\n-   AC_LANG_POP([C++])],\n-  [gcc_AC_CHECK_DECLS(madvise, , ,[\n-     #include \"ansidecl.h\"\n-     #include \"system.h\"\n-   ])\n+AC_LANG_PUSH([C++])\n+gcc_AC_CHECK_DECLS(madvise, , ,[\n+  #include \"ansidecl.h\"\n+  #include \"system.h\"\n ])\n+AC_LANG_POP([C++])\n \n # More time-related stuff.\n AC_CACHE_CHECK(for struct tms, ac_cv_struct_tms, ["}, {"sha": "a2ca9c8327f5a749379c4a4f2b10b13d304baf33", "filename": "gcc/coretypes.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -196,5 +196,9 @@ enum memmodel\n /* Suppose that higher bits are target dependant. */\n #define MEMMODEL_MASK ((1<<16)-1)\n \n+/* Support for user-provided GGC and PCH markers.  The first parameter\n+   is a pointer to a pointer, the second a cookie.  */\n+typedef void (*gt_pointer_operator) (void *, void *);\n+\n #endif /* coretypes.h */\n "}, {"sha": "3fea525a08d8b493a8b58003599e8a21fa3e1f2e", "filename": "gcc/coverage.c", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"coverage.h\"\n #include \"langhooks.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tree-iterator.h\"\n #include \"cgraph.h\"\n #include \"dumpfile.h\"\n@@ -109,17 +109,11 @@ static unsigned bbg_file_stamp;\n /* Name of the count data (gcda) file.  */\n static char *da_file_name;\n \n-/* Hash table of count data.  */\n-static htab_t counts_hash = NULL;\n-\n /* The names of merge functions for counters.  */\n static const char *const ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIONS;\n static const char *const ctr_names[GCOV_COUNTERS] = GCOV_COUNTER_NAMES;\n \n /* Forward declarations.  */\n-static hashval_t htab_counts_entry_hash (const void *);\n-static int htab_counts_entry_eq (const void *, const void *);\n-static void htab_counts_entry_del (void *);\n static void read_counts_file (void);\n static tree build_var (tree, tree, int);\n static void build_fn_info_type (tree, unsigned, tree);\n@@ -149,32 +143,31 @@ get_gcov_unsigned_t (void)\n   return lang_hooks.types.type_for_mode (mode, true);\n }\n \f\n-static hashval_t\n-htab_counts_entry_hash (const void *of)\n+inline hashval_t\n+coverage_counts_entry_hash (const counts_entry_t *entry)\n {\n-  const counts_entry_t *const entry = (const counts_entry_t *) of;\n-\n   return entry->ident * GCOV_COUNTERS + entry->ctr;\n }\n \n-static int\n-htab_counts_entry_eq (const void *of1, const void *of2)\n+inline int\n+coverage_counts_entry_eq (const counts_entry_t *entry1,\n+                          const counts_entry_t *entry2)\n {\n-  const counts_entry_t *const entry1 = (const counts_entry_t *) of1;\n-  const counts_entry_t *const entry2 = (const counts_entry_t *) of2;\n-\n   return entry1->ident == entry2->ident && entry1->ctr == entry2->ctr;\n }\n \n-static void\n-htab_counts_entry_del (void *of)\n+inline void\n+coverage_counts_entry_del (counts_entry_t *entry)\n {\n-  counts_entry_t *const entry = (counts_entry_t *) of;\n-\n   free (entry->counts);\n   free (entry);\n }\n \n+/* Hash table of count data.  */\n+static hash_table <counts_entry_t, coverage_counts_entry_hash,\n+\t\t   coverage_counts_entry_eq, coverage_counts_entry_del>\n+\t\t  counts_hash;\n+\n /* Read in the counts file, if available.  */\n \n static void\n@@ -214,9 +207,7 @@ read_counts_file (void)\n   tag = gcov_read_unsigned ();\n   bbg_file_stamp = crc32_unsigned (bbg_file_stamp, tag);\n \n-  counts_hash = htab_create (10,\n-\t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n-\t\t\t     htab_counts_entry_del);\n+  counts_hash.create (10);\n   while ((tag = gcov_read_unsigned ()))\n     {\n       gcov_unsigned_t length;\n@@ -264,8 +255,7 @@ read_counts_file (void)\n \t  elt.ident = fn_ident;\n \t  elt.ctr = GCOV_COUNTER_FOR_TAG (tag);\n \n-\t  slot = (counts_entry_t **) htab_find_slot\n-\t    (counts_hash, &elt, INSERT);\n+\t  slot = counts_hash.find_slot (&elt, INSERT);\n \t  entry = *slot;\n \t  if (!entry)\n \t    {\n@@ -285,14 +275,14 @@ read_counts_file (void)\n \t      error (\"checksum is (%x,%x) instead of (%x,%x)\",\n \t\t     entry->lineno_checksum, entry->cfg_checksum,\n \t\t     lineno_checksum, cfg_checksum);\n-\t      htab_delete (counts_hash);\n+\t      counts_hash.dispose ();\n \t      break;\n \t    }\n \t  else if (entry->summary.num != n_counts)\n \t    {\n \t      error (\"Profile data for function %u is corrupted\", fn_ident);\n \t      error (\"number of counters is %d instead of %d\", entry->summary.num, n_counts);\n-\t      htab_delete (counts_hash);\n+\t      counts_hash.dispose ();\n \t      break;\n \t    }\n \t  else if (elt.ctr >= GCOV_COUNTERS_SUMMABLE)\n@@ -318,7 +308,7 @@ read_counts_file (void)\n \t{\n \t  error (is_error < 0 ? \"%qs has overflowed\" : \"%qs is corrupted\",\n \t\t da_file_name);\n-\t  htab_delete (counts_hash);\n+\t  counts_hash.dispose ();\n \t  break;\n \t}\n     }\n@@ -336,7 +326,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n   counts_entry_t *entry, elt;\n \n   /* No hash table, no counts.  */\n-  if (!counts_hash)\n+  if (!counts_hash.is_created ())\n     {\n       static int warned = 0;\n \n@@ -350,7 +340,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \n   elt.ident = current_function_funcdef_no + 1;\n   elt.ctr = counter;\n-  entry = (counts_entry_t *) htab_find (counts_hash, &elt);\n+  entry = counts_hash.find (&elt);\n   if (!entry || !entry->summary.num)\n     /* The function was not emitted, or is weak and not chosen in the\n        final executable.  Silently fail, because there's nothing we"}, {"sha": "15bedb4a27dd508a7014d0870082fb7cf46de168", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,3 +1,10 @@\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.  Re-write VEC in C++.\n+\n+\t* call.c (add_function_candidate): Remove const qualifier\n+\tfrom call to VEC_index.\n+\n 2012-08-10  Richard Guenther  <rguenther@suse.de>\n \n \t* error.c (dump_expr): Handle anonymous SSA names."}, {"sha": "7a72666913c0b73036c80065e1727e09932af6c5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1924,7 +1924,8 @@ add_function_candidate (struct z_candidate **candidates,\n \n   for (i = 0; i < len; ++i)\n     {\n-      tree arg, argtype, to_type;\n+      tree argtype, to_type;\n+      tree arg;\n       conversion *t;\n       int is_this;\n \n@@ -1934,8 +1935,9 @@ add_function_candidate (struct z_candidate **candidates,\n       if (i == 0 && first_arg != NULL_TREE)\n \targ = first_arg;\n       else\n-\targ = VEC_index (tree, args,\n-\t\t\t i + skip - (first_arg != NULL_TREE ? 1 : 0));\n+\targ = CONST_CAST_TREE (\n+\t\tVEC_index (tree, args,\n+\t\t\t   i + skip - (first_arg != NULL_TREE ? 1 : 0)));\n       argtype = lvalue_type (arg);\n \n       is_this = (i == 0 && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)"}, {"sha": "dfa2b5241e323d2ce51736b623ead9db5bf20adf", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -8403,12 +8403,12 @@ build_vtbl_initializer (tree binfo,\n \t  int new_position = (TARGET_VTABLE_DATA_ENTRY_DISTANCE * ix\n \t\t\t      + (TARGET_VTABLE_DATA_ENTRY_DISTANCE - 1));\n \n-\t  VEC_replace (constructor_elt, vid.inits, new_position, e);\n+\t  VEC_replace (constructor_elt, vid.inits, new_position, *e);\n \n \t  for (j = 1; j < TARGET_VTABLE_DATA_ENTRY_DISTANCE; ++j)\n \t    {\n-\t      constructor_elt *f = VEC_index (constructor_elt, vid.inits,\n-\t\t\t\t\t      new_position - j);\n+\t      constructor_elt *f = &VEC_index (constructor_elt, vid.inits,\n+\t\t\t\t\t       new_position - j);\n \t      f->index = NULL_TREE;\n \t      f->value = build1 (NOP_EXPR, vtable_entry_type,\n \t\t\t\t null_pointer_node);\n@@ -8429,7 +8429,7 @@ build_vtbl_initializer (tree binfo,\n   for (ix = VEC_length (constructor_elt, vid.inits) - 1;\n        VEC_iterate (constructor_elt, vid.inits, ix, e);\n        ix--, jx++)\n-    VEC_replace (constructor_elt, *inits, jx, e);\n+    VEC_replace (constructor_elt, *inits, jx, *e);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */"}, {"sha": "5908996c2dc82f4b8c39f167926160c0b37f6290", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -5282,7 +5282,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n \t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (str_init)) == 1)\n \t{\n \t  str_init = VEC_index (constructor_elt,\n-\t\t\t\tCONSTRUCTOR_ELTS (str_init), 0)->value;\n+\t\t\t\tCONSTRUCTOR_ELTS (str_init), 0).value;\n \t}\n \n       /* If it's a string literal, then it's the initializer for the array\n@@ -5372,7 +5372,7 @@ reshape_init (tree type, tree init, tsubst_flags_t complain)\n     return init;\n \n   /* Recurse on this CONSTRUCTOR.  */\n-  d.cur = VEC_index (constructor_elt, v, 0);\n+  d.cur = &VEC_index (constructor_elt, v, 0);\n   d.end = d.cur + VEC_length (constructor_elt, v);\n \n   new_init = reshape_init_r (type, &d, true, complain);\n@@ -5917,7 +5917,7 @@ type_dependent_init_p (tree init)\n       nelts = VEC_length (constructor_elt, elts);\n       for (i = 0; i < nelts; ++i)\n \tif (type_dependent_init_p (VEC_index (constructor_elt,\n-\t\t\t\t\t      elts, i)->value))\n+\t\t\t\t\t      elts, i).value))\n \t  return true;\n     }\n   else\n@@ -5947,7 +5947,7 @@ value_dependent_init_p (tree init)\n       nelts = VEC_length (constructor_elt, elts);\n       for (i = 0; i < nelts; ++i)\n \tif (value_dependent_init_p (VEC_index (constructor_elt,\n-\t\t\t\t\t       elts, i)->value))\n+\t\t\t\t\t       elts, i).value))\n \t  return true;\n     }\n   else\n@@ -6896,7 +6896,7 @@ cp_complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (initial_value)))\n \t{\n \t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initial_value);\n-\t  tree value = VEC_index (constructor_elt, v, 0)->value;\n+\t  tree value = VEC_index (constructor_elt, v, 0).value;\n \n \t  if (TREE_CODE (value) == STRING_CST\n \t      && VEC_length (constructor_elt, v) == 1)"}, {"sha": "a7f12ba7cfed7de5da879fba7f27c600a202a84d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -273,7 +273,7 @@ cp_lexer_dump_tokens (FILE *file, VEC(cp_token,gc) *buffer,\n \n   if (start_token > VEC_address (cp_token, buffer))\n     {\n-      cp_lexer_print_token (file, VEC_index (cp_token, buffer, 0));\n+      cp_lexer_print_token (file, &VEC_index (cp_token, buffer, 0));\n       fprintf (file, \" ... \");\n     }\n \n@@ -313,8 +313,7 @@ cp_lexer_dump_tokens (FILE *file, VEC(cp_token,gc) *buffer,\n   if (i == num && i < VEC_length (cp_token, buffer))\n     {\n       fprintf (file, \" ... \");\n-      cp_lexer_print_token (file, VEC_index (cp_token, buffer,\n-\t\t\t    VEC_length (cp_token, buffer) - 1));\n+      cp_lexer_print_token (file, &VEC_last (cp_token, buffer));\n     }\n \n   fprintf (file, \"\\n\");\n@@ -1723,11 +1722,11 @@ cp_parser_context_new (cp_parser_context* next)\n /* Managing the unparsed function queues.  */\n \n #define unparsed_funs_with_default_args \\\n-  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues)->funs_with_default_args\n+  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues).funs_with_default_args\n #define unparsed_funs_with_definitions \\\n-  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues)->funs_with_definitions\n+  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues).funs_with_definitions\n #define unparsed_nsdmis \\\n-  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues)->nsdmis\n+  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues).nsdmis\n \n static void\n push_unparsed_function_queues (cp_parser *parser)\n@@ -8048,7 +8047,7 @@ record_lambda_scope (tree lambda)\n static void\n finish_lambda_scope (void)\n {\n-  tree_int *p = VEC_last (tree_int, lambda_scope_stack);\n+  tree_int *p = &VEC_last (tree_int, lambda_scope_stack);\n   if (lambda_scope != p->t)\n     {\n       lambda_scope = p->t;"}, {"sha": "51cb5ee9c62cd523b530e13d33e78329086d0bd8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -295,7 +295,7 @@ typeid_ok_p (void)\n     }\n \n   pseudo_type_info\n-    = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE)->type;\n+    = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE).type;\n   type_info_type = TYPE_MAIN_VARIANT (const_type_info_type_node);\n \n   /* Make sure abi::__type_info_pseudo has the same alias set\n@@ -422,7 +422,7 @@ get_tinfo_decl (tree type)\n   if (!d)\n     {\n       int ix = get_pseudo_ti_index (type);\n-      tinfo_s *ti = VEC_index (tinfo_s, tinfo_descs, ix);\n+      tinfo_s *ti = &VEC_index (tinfo_s, tinfo_descs, ix);\n \n       d = build_lang_decl (VAR_DECL, name, ti->type);\n       SET_DECL_ASSEMBLER_NAME (d, name);\n@@ -1079,7 +1079,7 @@ typeinfo_in_lib_p (tree type)\n static tree\n get_pseudo_ti_init (tree type, unsigned tk_index)\n {\n-  tinfo_s *ti = VEC_index (tinfo_s, tinfo_descs, tk_index);\n+  tinfo_s *ti = &VEC_index (tinfo_s, tinfo_descs, tk_index);\n \n   gcc_assert (at_eof);\n   switch (tk_index)\n@@ -1105,7 +1105,7 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \ttree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \n \t/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */\n-\tti = VEC_index (tinfo_s, tinfo_descs, tk_index);\n+\tti = &VEC_index (tinfo_s, tinfo_descs, tk_index);\n \treturn class_initializer (ti, type, 1, tinfo);\n       }\n \n@@ -1160,14 +1160,14 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tinfo);\n \t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, offset);\n \t    base_init = build_constructor (init_list_type_node, v);\n-\t    e = VEC_index (constructor_elt, init_vec, ix);\n+\t    e = &VEC_index (constructor_elt, init_vec, ix);\n \t    e->index = NULL_TREE;\n \t    e->value = base_init;\n \t  }\n \tbase_inits = build_constructor (init_list_type_node, init_vec);\n \n \t/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */\n-\tti = VEC_index (tinfo_s, tinfo_descs, tk_index);\n+\tti = &VEC_index (tinfo_s, tinfo_descs, tk_index);\n \treturn class_initializer (ti, type, 3,\n \t\t\t\t  build_int_cst (NULL_TREE, hint),\n \t\t\t\t  build_int_cst (NULL_TREE, nbases),\n@@ -1214,7 +1214,7 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n   fields = build_decl (input_location,\n \t\t       FIELD_DECL, NULL_TREE,\n \t\t       VEC_index (tinfo_s, tinfo_descs,\n-\t\t\t\t  TK_TYPE_INFO_TYPE)->type);\n+\t\t\t\t  TK_TYPE_INFO_TYPE).type);\n \n   /* Now add the derived fields.  */\n   while ((field_decl = va_arg (ap, tree)))\n@@ -1228,7 +1228,7 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n   CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n \n-  ti = VEC_index (tinfo_s, tinfo_descs, tk);\n+  ti = &VEC_index (tinfo_s, tinfo_descs, tk);\n   ti->type = cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n   ti->name = get_identifier (real_name);\n   ti->vtable = NULL_TREE;\n@@ -1321,7 +1321,7 @@ get_pseudo_ti_index (tree type)\n \t\t  while (VEC_iterate (tinfo_s, tinfo_descs, len++, ti))\n \t\t    ti->type = ti->vtable = ti->name = NULL_TREE;\n \t\t}\n-\t      else if (VEC_index (tinfo_s, tinfo_descs, ix)->type)\n+\t      else if (VEC_index (tinfo_s, tinfo_descs, ix).type)\n \t\t/* already created.  */\n \t\tbreak;\n \n@@ -1335,7 +1335,7 @@ get_pseudo_ti_index (tree type)\n \t\tarray_domain = build_index_type (size_int (num_bases));\n \t      base_array =\n \t\tbuild_array_type (VEC_index (tinfo_s, tinfo_descs,\n-\t\t\t\t\t     TK_BASE_TYPE)->type,\n+\t\t\t\t\t     TK_BASE_TYPE).type,\n \t\t\t\t  array_domain);\n \n \t      push_abi_namespace ();\n@@ -1387,7 +1387,7 @@ create_tinfo_types (void)\n     DECL_CHAIN (field) = fields;\n     fields = field;\n \n-    ti = VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE);\n+    ti = &VEC_index (tinfo_s, tinfo_descs, TK_TYPE_INFO_TYPE);\n     ti->type = make_class_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;\n     ti->name = NULL_TREE;\n@@ -1427,7 +1427,7 @@ create_tinfo_types (void)\n     DECL_CHAIN (field) = fields;\n     fields = field;\n \n-    ti = VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);\n+    ti = &VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);\n \n     ti->type = make_class_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;"}, {"sha": "ebac9604f1b0fbf03a86147d8c3e630e5b1f13ad", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -161,7 +161,7 @@ resume_deferring_access_checks (void)\n {\n   if (!deferred_access_no_check)\n     VEC_last (deferred_access, deferred_access_stack)\n-      ->deferring_access_checks_kind = dk_deferred;\n+      .deferring_access_checks_kind = dk_deferred;\n }\n \n /* Stop deferring access checks.  */\n@@ -171,7 +171,7 @@ stop_deferring_access_checks (void)\n {\n   if (!deferred_access_no_check)\n     VEC_last (deferred_access, deferred_access_stack)\n-      ->deferring_access_checks_kind = dk_no_deferred;\n+      .deferring_access_checks_kind = dk_no_deferred;\n }\n \n /* Discard the current deferred access checks and restore the\n@@ -198,7 +198,7 @@ get_deferred_access_checks (void)\n     return NULL;\n   else\n     return (VEC_last (deferred_access, deferred_access_stack)\n-\t    ->deferred_access_checks);\n+\t    .deferred_access_checks);\n }\n \n /* Take current deferred checks and combine with the\n@@ -216,10 +216,10 @@ pop_to_parent_deferring_access_checks (void)\n       deferred_access *ptr;\n \n       checks = (VEC_last (deferred_access, deferred_access_stack)\n-\t\t->deferred_access_checks);\n+\t\t.deferred_access_checks);\n \n       VEC_pop (deferred_access, deferred_access_stack);\n-      ptr = VEC_last (deferred_access, deferred_access_stack);\n+      ptr = &VEC_last (deferred_access, deferred_access_stack);\n       if (ptr->deferring_access_checks_kind == dk_no_deferred)\n \t{\n \t  /* Check access.  */\n@@ -321,7 +321,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n \n   gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n \n-  ptr = VEC_last (deferred_access, deferred_access_stack);\n+  ptr = &VEC_last (deferred_access, deferred_access_stack);\n \n   /* If we are not supposed to defer access checks, just check now.  */\n   if (ptr->deferring_access_checks_kind == dk_no_deferred)\n@@ -5948,7 +5948,7 @@ build_constexpr_constructor_member_initializers (tree type, tree body)\n       if (VEC_length (constructor_elt, vec) > 0)\n \t{\n \t  /* In a delegating constructor, return the target.  */\n-\t  constructor_elt *ce = VEC_index (constructor_elt, vec, 0);\n+\t  constructor_elt *ce = &VEC_index (constructor_elt, vec, 0);\n \t  if (ce->index == current_class_ptr)\n \t    {\n \t      body = ce->value;\n@@ -6820,7 +6820,7 @@ cxx_eval_array_reference (const constexpr_call *call, tree t,\n     }\n   i = tree_low_cst (index, 0);\n   if (TREE_CODE (ary) == CONSTRUCTOR)\n-    return VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ary), i)->value;\n+    return VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ary), i).value;\n   else if (elem_nchars == 1)\n     return build_int_cst (cv_unqualified (TREE_TYPE (TREE_TYPE (ary))),\n \t\t\t  TREE_STRING_POINTER (ary)[i]);"}, {"sha": "7cc2457e3b28bc21f54a2d78e6b11f390b78bc35", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1337,7 +1337,7 @@ strip_typedefs_expr (tree t)\n \ttype = strip_typedefs (TREE_TYPE (t));\n \tfor (i = 0; i < n; ++i)\n \t  {\n-\t    constructor_elt *e = VEC_index (constructor_elt, vec, i);\n+\t    constructor_elt *e = &VEC_index (constructor_elt, vec, i);\n \t    tree op = strip_typedefs_expr (e->value);\n \t    if (op != e->value)\n \t      {"}, {"sha": "2180535e83722756cb5254e5e9e37fd6a072453e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1178,7 +1178,7 @@ process_init_constructor_record (tree type, tree init,\n \n       if (idx < VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)))\n \t{\n-\t  constructor_elt *ce = VEC_index (constructor_elt,\n+\t  constructor_elt *ce = &VEC_index (constructor_elt,\n \t\t\t\t\t   CONSTRUCTOR_ELTS (init), idx);\n \t  if (ce->index)\n \t    {\n@@ -1305,7 +1305,7 @@ process_init_constructor_union (tree type, tree init,\n       VEC_block_remove (constructor_elt, CONSTRUCTOR_ELTS (init), 1, len-1);\n     }\n \n-  ce = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (init), 0);\n+  ce = &VEC_index (constructor_elt, CONSTRUCTOR_ELTS (init), 0);\n \n   /* If this element specifies a field, initialize via that field.  */\n   if (ce->index)"}, {"sha": "55492fa81417deddd14a364de6ec9f62f720e158", "filename": "gcc/df-scan.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -4448,7 +4448,6 @@ df_bb_verify (basic_block bb)\n       if (!INSN_P (insn))\n         continue;\n       df_insn_refs_verify (&collection_rec, bb, insn, true);\n-      df_free_collection_rec (&collection_rec);\n     }\n \n   /* Do the artificial defs and uses.  */"}, {"sha": "cc46a61e4ea46816b114350282398bb855c1aa95", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 132, "deletions": 11, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -13,17 +13,17 @@ involve determining information about GCC's data structures from GCC's\n source code and using this information to perform garbage collection and\n implement precompiled headers.\n \n-A full C parser would be too complicated for this task, so a limited\n-subset of C is interpreted and special markers are used to determine\n-what parts of the source to look at.  All @code{struct} and\n-@code{union} declarations that define data structures that are\n-allocated under control of the garbage collector must be marked.  All\n-global variables that hold pointers to garbage-collected memory must\n-also be marked.  Finally, all global variables that need to be saved\n-and restored by a precompiled header must be marked.  (The precompiled\n-header mechanism can only save static variables if they're scalar.\n-Complex data structures must be allocated in garbage-collected memory\n-to be saved in a precompiled header.)\n+A full C++ parser would be too complicated for this task, so a limited\n+subset of C++ is interpreted and special markers are used to determine\n+what parts of the source to look at.  All @code{struct}, @code{union}\n+and @code{template} structure declarations that define data structures\n+that are allocated under control of the garbage collector must be\n+marked.  All global variables that hold pointers to garbage-collected\n+memory must also be marked.  Finally, all global variables that need\n+to be saved and restored by a precompiled header must be marked.  (The\n+precompiled header mechanism can only save static variables if they're\n+scalar. Complex data structures must be allocated in garbage-collected\n+memory to be saved in a precompiled header.)\n \n The full format of a marker is\n @smallexample\n@@ -68,6 +68,7 @@ These don't need to be marked.\n @menu\n * GTY Options::         What goes inside a @code{GTY(())}.\n * GGC Roots::           Making global variables GGC roots.\n+* User GC::\t\tAdding user-provided GC marking routines.\n * Files::               How the generated files work.\n * Invoking the garbage collector::   How to invoke the garbage collector.\n * Troubleshooting::     When something does not work as expected.\n@@ -440,8 +441,128 @@ The @code{special} option is used to mark types that have to be dealt\n with by special case machinery.  The parameter is the name of the\n special case.  See @file{gengtype.c} for further details.  Avoid\n adding new special cases unless there is no other alternative.\n+\n+@findex user\n+@item user\n+\n+The @code{user} option indicates that the code to mark structure\n+fields is completely handled by user-provided routines.  See section\n+@ref{User GC} for details on what functions need to be provided.\n @end table\n \n+@node User GC\n+@section Support for user-provided GC marking routines\n+@cindex user gc\n+The garbage collector supports types for which no automatic marking\n+code is generated.  For these types, the user is required to provide\n+three functions: one to act as a marker for garbage collection, and\n+two functions to act as marker and pointer walker for pre-compiled\n+headers.\n+\n+Given a structure @code{struct GTY((user)) my_struct}, the following functions\n+should be defined to mark @code{my_struct}:\n+\n+@smallexample\n+void gt_ggc_mx (my_struct *p)\n+@{\n+  /* This marks field 'fld'.  */\n+  gt_ggc_mx (p->fld);\n+@}\n+\n+void gt_pch_nx (my_struct *p)\n+@{\n+  /* This marks field 'fld'.  */\n+  gt_pch_nx (tp->fld);\n+@}\n+\n+void gt_pch_nx (my_struct *p, gt_pointer_operator op, void *cookie)\n+@{\n+  /* For every field 'fld', call the given pointer operator.  */\n+  op (&(tp->fld), cookie);\n+@}\n+@end smallexample\n+\n+In general, each marker @code{M} should call @code{M} for every\n+pointer field in the structure.  Fields that are not allocated in GC\n+or are not pointers must be ignored.\n+\n+For embedded lists (e.g., structures with a @code{next} or @code{prev}\n+pointer), the marker must follow the chain and mark every element in\n+it.\n+\n+Note that the rules for the pointer walker @code{gt_pch_nx (my_struct\n+*, gt_pointer_operator, void *)} are slightly different.  In this\n+case, the operation @code{op} must be applied to the @emph{address} of\n+every pointer field.\n+\n+@section User-provided marking routines for template types\n+When a template type @code{TP} is marked with @code{GTY}, all\n+instances of that type are considered user-provided types.  This means\n+that the individual instances of @code{TP} do not need to be marked\n+with @code{GTY}.  The user needs to provide template functions to mark\n+all the fields of the type.\n+\n+The following code snippets represent all the functions that need to\n+be provided. Note that type @code{TP} may reference to more than one\n+type. In these snippets, there is only one type @code{T}, but there\n+could be more.\n+\n+@smallexample\n+template<typename T>\n+void gt_ggc_mx (TP<T> *tp)\n+@{\n+  extern void gt_ggc_mx (T&);\n+\n+  /* This marks field 'fld' of type 'T'.  */\n+  gt_ggc_mx (tp->fld);\n+@}\n+\n+template<typename T>\n+void gt_pch_nx (TP<T> *tp)\n+@{\n+  extern void gt_pch_nx (T&);\n+\n+  /* This marks field 'fld' of type 'T'.  */\n+  gt_pch_nx (tp->fld);\n+@}\n+\n+template<typename T>\n+void gt_pch_nx (TP<T *> *tp, gt_pointer_operator op, void *cookie)\n+@{\n+  /* For every field 'fld' of 'tp' with type 'T *', call the given\n+     pointer operator.  */\n+  op (&(tp->fld), cookie);\n+@}\n+\n+template<typename T>\n+void gt_pch_nx (TP<T> *tp, gt_pointer_operator, void *cookie)\n+@{\n+  extern void gt_pch_nx (T *, gt_pointer_operator, void *);\n+\n+  /* For every field 'fld' of 'tp' with type 'T', call the pointer\n+     walker for all the fields of T.  */\n+  gt_pch_nx (&(tp->fld), op, cookie);\n+@}\n+@end smallexample\n+\n+Support for user-defined types is currently limited. The following\n+restrictions apply:\n+\n+@enumerate\n+@item Type @code{TP} and all the argument types @code{T} must be\n+marked with @code{GTY}.\n+\n+@item Type @code{TP} can only have type names in its argument list.\n+\n+@item The pointer walker functions are different for @code{TP<T>} and\n+@code{TP<T *>}. In the case of @code{TP<T>}, references to\n+@code{T} must be handled by calling @code{gt_pch_nx} (which\n+will, in turn, walk all the pointers inside fields of @code{T}).\n+In the case of @code{TP<T *>}, references to @code{T *} must be\n+handled by calling the @code{op} function on the address of the\n+pointer (see the code snippets above).\n+@end enumerate\n+\n @node GGC Roots\n @section Marking Roots for the Garbage Collector\n @cindex roots, marking"}, {"sha": "dfdd6247e5d1a5327ccc700c3e2061f258bcee7c", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1288,16 +1288,6 @@ opposite effect.  If neither option is specified, the configure script\n will try to guess whether the @code{.init_array} and\n @code{.fini_array} sections are supported and, if they are, use them.\n \n-@item --enable-build-with-cxx\n-Build GCC using a C++ compiler rather than a C compiler.  This is an\n-experimental option which may become the default in a later release.\n-\n-@item --enable-build-poststage1-with-cxx\n-When bootstrapping, build stages 2 and 3 of GCC using a C++ compiler\n-rather than a C compiler.  Stage 1 is still built with a C compiler.\n-This is enabled by default and may be disabled using\n-@option{--disable-build-poststage1-with-cxx}.\n-\n @item --enable-maintainer-mode\n The build rules that regenerate the Autoconf and Automake output files as\n well as the GCC master message catalog @file{gcc.pot} are normally"}, {"sha": "2f48f2b3049bc658f39906287ba60bfe4cb7a240", "filename": "gcc/double-int.c", "status": "modified", "additions": 210, "deletions": 90, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -610,7 +610,7 @@ div_and_round_double (unsigned code, int uns,\n /* Returns mask for PREC bits.  */\n \n double_int\n-double_int_mask (unsigned prec)\n+double_int::mask (unsigned prec)\n {\n   unsigned HOST_WIDE_INT m;\n   double_int mask;\n@@ -635,20 +635,20 @@ double_int_mask (unsigned prec)\n    of precision PREC.  */\n \n double_int\n-double_int_max_value (unsigned int prec, bool uns)\n+double_int::max_value (unsigned int prec, bool uns)\n {\n-  return double_int_mask (prec - (uns ? 0 : 1));\n+  return double_int::mask (prec - (uns ? 0 : 1));\n }\n \n /* Returns a minimum value for signed or unsigned integer\n    of precision PREC.  */\n \n double_int\n-double_int_min_value (unsigned int prec, bool uns)\n+double_int::min_value (unsigned int prec, bool uns)\n {\n   if (uns)\n     return double_int_zero;\n-  return double_int_lshift (double_int_one, prec - 1, prec, false);\n+  return double_int_one.lshift (prec - 1, prec, false);\n }\n \n /* Clears the bits of CST over the precision PREC.  If UNS is false, the bits\n@@ -659,20 +659,21 @@ double_int_min_value (unsigned int prec, bool uns)\n    of CST, with the given signedness.  */\n \n double_int\n-double_int_ext (double_int cst, unsigned prec, bool uns)\n+double_int::ext (unsigned prec, bool uns) const\n {\n   if (uns)\n-    return double_int_zext (cst, prec);\n+    return this->zext (prec);\n   else\n-    return double_int_sext (cst, prec);\n+    return this->sext (prec);\n }\n \n-/* The same as double_int_ext with UNS = true.  */\n+/* The same as double_int::ext with UNS = true.  */\n \n double_int\n-double_int_zext (double_int cst, unsigned prec)\n+double_int::zext (unsigned prec) const\n {\n-  double_int mask = double_int_mask (prec);\n+  const double_int &cst = *this;\n+  double_int mask = double_int::mask (prec);\n   double_int r;\n \n   r.low = cst.low & mask.low;\n@@ -681,12 +682,13 @@ double_int_zext (double_int cst, unsigned prec)\n   return r;\n }\n \n-/* The same as double_int_ext with UNS = false.  */\n+/* The same as double_int::ext with UNS = false.  */\n \n double_int\n-double_int_sext (double_int cst, unsigned prec)\n+double_int::sext (unsigned prec) const\n {\n-  double_int mask = double_int_mask (prec);\n+  const double_int &cst = *this;\n+  double_int mask = double_int::mask (prec);\n   double_int r;\n   unsigned HOST_WIDE_INT snum;\n \n@@ -714,8 +716,9 @@ double_int_sext (double_int cst, unsigned prec)\n /* Returns true if CST fits in signed HOST_WIDE_INT.  */\n \n bool\n-double_int_fits_in_shwi_p (double_int cst)\n+double_int::fits_signed () const\n {\n+  const double_int &cst = *this;\n   if (cst.high == 0)\n     return (HOST_WIDE_INT) cst.low >= 0;\n   else if (cst.high == -1)\n@@ -728,19 +731,20 @@ double_int_fits_in_shwi_p (double_int cst)\n    unsigned HOST_WIDE_INT if UNS is true.  */\n \n bool\n-double_int_fits_in_hwi_p (double_int cst, bool uns)\n+double_int::fits (bool uns) const\n {\n   if (uns)\n-    return double_int_fits_in_uhwi_p (cst);\n+    return this->fits_unsigned ();\n   else\n-    return double_int_fits_in_shwi_p (cst);\n+    return this->fits_signed ();\n }\n \n /* Returns A * B.  */\n \n double_int\n-double_int_mul (double_int a, double_int b)\n+double_int::operator * (double_int b) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   mul_double (a.low, a.high, b.low, b.high, &ret.low, &ret.high);\n   return ret;\n@@ -750,9 +754,9 @@ double_int_mul (double_int a, double_int b)\n    *OVERFLOW is set to nonzero.  */\n \n double_int\n-double_int_mul_with_sign (double_int a, double_int b,\n-                          bool unsigned_p, int *overflow)\n+double_int::mul_with_sign (double_int b, bool unsigned_p, int *overflow) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   *overflow = mul_double_with_sign (a.low, a.high, b.low, b.high,\n                                     &ret.low, &ret.high, unsigned_p);\n@@ -762,8 +766,9 @@ double_int_mul_with_sign (double_int a, double_int b,\n /* Returns A + B.  */\n \n double_int\n-double_int_add (double_int a, double_int b)\n+double_int::operator + (double_int b) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   add_double (a.low, a.high, b.low, b.high, &ret.low, &ret.high);\n   return ret;\n@@ -772,8 +777,9 @@ double_int_add (double_int a, double_int b)\n /* Returns A - B.  */\n \n double_int\n-double_int_sub (double_int a, double_int b)\n+double_int::operator - (double_int b) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   neg_double (b.low, b.high, &b.low, &b.high);\n   add_double (a.low, a.high, b.low, b.high, &ret.low, &ret.high);\n@@ -783,8 +789,9 @@ double_int_sub (double_int a, double_int b)\n /* Returns -A.  */\n \n double_int\n-double_int_neg (double_int a)\n+double_int::operator - () const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   neg_double (a.low, a.high, &ret.low, &ret.high);\n   return ret;\n@@ -796,9 +803,10 @@ double_int_neg (double_int a)\n    stored to MOD.  */\n \n double_int\n-double_int_divmod (double_int a, double_int b, bool uns, unsigned code,\n-\t\t   double_int *mod)\n+double_int::divmod (double_int b, bool uns, unsigned code,\n+\t\t    double_int *mod) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n \n   div_and_round_double (code, uns, a.low, a.high,\n@@ -807,91 +815,91 @@ double_int_divmod (double_int a, double_int b, bool uns, unsigned code,\n   return ret;\n }\n \n-/* The same as double_int_divmod with UNS = false.  */\n+/* The same as double_int::divmod with UNS = false.  */\n \n double_int\n-double_int_sdivmod (double_int a, double_int b, unsigned code, double_int *mod)\n+double_int::sdivmod (double_int b, unsigned code, double_int *mod) const\n {\n-  return double_int_divmod (a, b, false, code, mod);\n+  return this->divmod (b, false, code, mod);\n }\n \n-/* The same as double_int_divmod with UNS = true.  */\n+/* The same as double_int::divmod with UNS = true.  */\n \n double_int\n-double_int_udivmod (double_int a, double_int b, unsigned code, double_int *mod)\n+double_int::udivmod (double_int b, unsigned code, double_int *mod) const\n {\n-  return double_int_divmod (a, b, true, code, mod);\n+  return this->divmod (b, true, code, mod);\n }\n \n /* Returns A / B (computed as unsigned depending on UNS, and rounded as\n    specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n    must be included before tree.h.  */\n \n double_int\n-double_int_div (double_int a, double_int b, bool uns, unsigned code)\n+double_int::div (double_int b, bool uns, unsigned code) const\n {\n   double_int mod;\n \n-  return double_int_divmod (a, b, uns, code, &mod);\n+  return this->divmod (b, uns, code, &mod);\n }\n \n-/* The same as double_int_div with UNS = false.  */\n+/* The same as double_int::div with UNS = false.  */\n \n double_int\n-double_int_sdiv (double_int a, double_int b, unsigned code)\n+double_int::sdiv (double_int b, unsigned code) const\n {\n-  return double_int_div (a, b, false, code);\n+  return this->div (b, false, code);\n }\n \n-/* The same as double_int_div with UNS = true.  */\n+/* The same as double_int::div with UNS = true.  */\n \n double_int\n-double_int_udiv (double_int a, double_int b, unsigned code)\n+double_int::udiv (double_int b, unsigned code) const\n {\n-  return double_int_div (a, b, true, code);\n+  return this->div (b, true, code);\n }\n \n /* Returns A % B (computed as unsigned depending on UNS, and rounded as\n    specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n    must be included before tree.h.  */\n \n double_int\n-double_int_mod (double_int a, double_int b, bool uns, unsigned code)\n+double_int::mod (double_int b, bool uns, unsigned code) const\n {\n   double_int mod;\n \n-  double_int_divmod (a, b, uns, code, &mod);\n+  this->divmod (b, uns, code, &mod);\n   return mod;\n }\n \n-/* The same as double_int_mod with UNS = false.  */\n+/* The same as double_int::mod with UNS = false.  */\n \n double_int\n-double_int_smod (double_int a, double_int b, unsigned code)\n+double_int::smod (double_int b, unsigned code) const\n {\n-  return double_int_mod (a, b, false, code);\n+  return this->mod (b, false, code);\n }\n \n-/* The same as double_int_mod with UNS = true.  */\n+/* The same as double_int::mod with UNS = true.  */\n \n double_int\n-double_int_umod (double_int a, double_int b, unsigned code)\n+double_int::umod (double_int b, unsigned code) const\n {\n-  return double_int_mod (a, b, true, code);\n+  return this->mod (b, true, code);\n }\n \n /* Return TRUE iff PRODUCT is an integral multiple of FACTOR, and return\n    the multiple in *MULTIPLE.  Otherwise return FALSE and leave *MULTIPLE\n    unchanged.  */\n \n bool\n-double_int_multiple_of (double_int product, double_int factor,\n-\t\t\tbool unsigned_p, double_int *multiple)\n+double_int::multiple_of (double_int factor,\n+\t\t\t bool unsigned_p, double_int *multiple) const\n {\n   double_int remainder;\n-  double_int quotient = double_int_divmod (product, factor, unsigned_p,\n+  double_int quotient = this->divmod (factor, unsigned_p,\n \t\t\t\t\t   TRUNC_DIV_EXPR, &remainder);\n-  if (double_int_zero_p (remainder))\n+  if (remainder.is_zero ())\n     {\n       *multiple = quotient;\n       return true;\n@@ -902,8 +910,9 @@ double_int_multiple_of (double_int product, double_int factor,\n \n /* Set BITPOS bit in A.  */\n double_int\n-double_int_setbit (double_int a, unsigned bitpos)\n+double_int::set_bit (unsigned bitpos) const\n {\n+  double_int a = *this;\n   if (bitpos < HOST_BITS_PER_WIDE_INT)\n     a.low |= (unsigned HOST_WIDE_INT) 1 << bitpos;\n   else\n@@ -914,8 +923,9 @@ double_int_setbit (double_int a, unsigned bitpos)\n \n /* Count trailing zeros in A.  */\n int\n-double_int_ctz (double_int a)\n+double_int::trailing_zeros () const\n {\n+  const double_int &a = *this;\n   unsigned HOST_WIDE_INT w = a.low ? a.low : (unsigned HOST_WIDE_INT) a.high;\n   unsigned bits = a.low ? 0 : HOST_BITS_PER_WIDE_INT;\n   if (!w)\n@@ -929,79 +939,126 @@ double_int_ctz (double_int a)\n    otherwise use logical shift.  */\n \n double_int\n-double_int_lshift (double_int a, HOST_WIDE_INT count, unsigned int prec, bool arith)\n+double_int::lshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   lshift_double (a.low, a.high, count, prec, &ret.low, &ret.high, arith);\n   return ret;\n }\n \n-/* Shift A rigth by COUNT places keeping only PREC bits of result.  Shift\n+/* Shift A right by COUNT places keeping only PREC bits of result.  Shift\n    left if COUNT is negative.  ARITH true specifies arithmetic shifting;\n    otherwise use logical shift.  */\n \n double_int\n-double_int_rshift (double_int a, HOST_WIDE_INT count, unsigned int prec, bool arith)\n+double_int::rshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const\n {\n+  const double_int &a = *this;\n   double_int ret;\n   lshift_double (a.low, a.high, -count, prec, &ret.low, &ret.high, arith);\n   return ret;\n }\n \n+/* Arithmetic shift A left by COUNT places keeping only PREC bits of result.\n+   Shift right if COUNT is negative.  */\n+\n+double_int\n+double_int::alshift (HOST_WIDE_INT count, unsigned int prec) const\n+{\n+  double_int r;\n+  lshift_double (low, high, count, prec, &r.low, &r.high, true);\n+  return r;\n+}\n+\n+/* Arithmetic shift A right by COUNT places keeping only PREC bits of result.\n+   Shift left if COUNT is negative.  */\n+\n+double_int\n+double_int::arshift (HOST_WIDE_INT count, unsigned int prec) const\n+{\n+  double_int r;\n+  lshift_double (low, high, -count, prec, &r.low, &r.high, true);\n+  return r;\n+}\n+\n+/* Logical shift A left by COUNT places keeping only PREC bits of result.\n+   Shift right if COUNT is negative.  */\n+\n+double_int\n+double_int::llshift (HOST_WIDE_INT count, unsigned int prec) const\n+{\n+  double_int r;\n+  lshift_double (low, high, count, prec, &r.low, &r.high, false);\n+  return r;\n+}\n+\n+/* Logical shift A right by COUNT places keeping only PREC bits of result.\n+   Shift left if COUNT is negative.  */\n+\n+double_int\n+double_int::lrshift (HOST_WIDE_INT count, unsigned int prec) const\n+{\n+  double_int r;\n+  lshift_double (low, high, -count, prec, &r.low, &r.high, false);\n+  return r;\n+}\n+\n /* Rotate  A left by COUNT places keeping only PREC bits of result.\n    Rotate right if COUNT is negative.  */\n \n double_int\n-double_int_lrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n+double_int::lrotate (HOST_WIDE_INT count, unsigned int prec) const\n {\n   double_int t1, t2;\n \n   count %= prec;\n   if (count < 0)\n     count += prec;\n \n-  t1 = double_int_lshift (a, count, prec, false);\n-  t2 = double_int_rshift (a, prec - count, prec, false);\n+  t1 = this->lshift (count, prec, false);\n+  t2 = this->rshift (prec - count, prec, false);\n \n-  return double_int_ior (t1, t2);\n+  return t1 | t2;\n }\n \n /* Rotate A rigth by COUNT places keeping only PREC bits of result.\n    Rotate right if COUNT is negative.  */\n \n double_int\n-double_int_rrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n+double_int::rrotate (HOST_WIDE_INT count, unsigned int prec) const\n {\n   double_int t1, t2;\n \n   count %= prec;\n   if (count < 0)\n     count += prec;\n \n-  t1 = double_int_rshift (a, count, prec, false);\n-  t2 = double_int_lshift (a, prec - count, prec, false);\n+  t1 = this->rshift (count, prec, false);\n+  t2 = this->lshift (prec - count, prec, false);\n \n-  return double_int_ior (t1, t2);\n+  return t1 | t2;\n }\n \n /* Returns -1 if A < B, 0 if A == B and 1 if A > B.  Signedness of the\n    comparison is given by UNS.  */\n \n int\n-double_int_cmp (double_int a, double_int b, bool uns)\n+double_int::cmp (double_int b, bool uns) const\n {\n   if (uns)\n-    return double_int_ucmp (a, b);\n+    return this->ucmp (b);\n   else\n-    return double_int_scmp (a, b);\n+    return this->scmp (b);\n }\n \n /* Compares two unsigned values A and B.  Returns -1 if A < B, 0 if A == B,\n    and 1 if A > B.  */\n \n int\n-double_int_ucmp (double_int a, double_int b)\n+double_int::ucmp (double_int b) const\n {\n+  const double_int &a = *this;\n   if ((unsigned HOST_WIDE_INT) a.high < (unsigned HOST_WIDE_INT) b.high)\n     return -1;\n   if ((unsigned HOST_WIDE_INT) a.high > (unsigned HOST_WIDE_INT) b.high)\n@@ -1018,8 +1075,9 @@ double_int_ucmp (double_int a, double_int b)\n    and 1 if A > B.  */\n \n int\n-double_int_scmp (double_int a, double_int b)\n+double_int::scmp (double_int b) const\n {\n+  const double_int &a = *this;\n   if (a.high < b.high)\n     return -1;\n   if (a.high > b.high)\n@@ -1032,49 +1090,111 @@ double_int_scmp (double_int a, double_int b)\n   return 0;\n }\n \n+/* Compares two unsigned values A and B for less-than.  */\n+\n+bool\n+double_int::ult (double_int b) const\n+{\n+  if ((unsigned HOST_WIDE_INT) high < (unsigned HOST_WIDE_INT) b.high)\n+    return true;\n+  if ((unsigned HOST_WIDE_INT) high > (unsigned HOST_WIDE_INT) b.high)\n+    return false;\n+  if (low < b.low)\n+    return true;\n+  return false;\n+}\n+\n+/* Compares two unsigned values A and B for greater-than.  */\n+\n+bool\n+double_int::ugt (double_int b) const\n+{\n+  if ((unsigned HOST_WIDE_INT) high > (unsigned HOST_WIDE_INT) b.high)\n+    return true;\n+  if ((unsigned HOST_WIDE_INT) high < (unsigned HOST_WIDE_INT) b.high)\n+    return false;\n+  if (low > b.low)\n+    return true;\n+  return false;\n+}\n+\n+/* Compares two signed values A and B for less-than.  */\n+\n+bool\n+double_int::slt (double_int b) const\n+{\n+  if (high < b.high)\n+    return true;\n+  if (high > b.high)\n+    return false;\n+  if (low < b.low)\n+    return true;\n+  return false;\n+}\n+\n+/* Compares two signed values A and B for greater-than.  */\n+\n+bool\n+double_int::sgt (double_int b) const\n+{\n+  if (high > b.high)\n+    return true;\n+  if (high < b.high)\n+    return false;\n+  if (low > b.low)\n+    return true;\n+  return false;\n+}\n+\n+\n /* Compares two values A and B.  Returns max value.  Signedness of the\n    comparison is given by UNS.  */\n \n double_int\n-double_int_max (double_int a, double_int b, bool uns)\n+double_int::max (double_int b, bool uns)\n {\n-  return (double_int_cmp (a, b, uns) == 1) ? a : b;\n+  return (this->cmp (b, uns) == 1) ? *this : b;\n }\n \n /* Compares two signed values A and B.  Returns max value.  */\n \n-double_int double_int_smax (double_int a, double_int b)\n+double_int\n+double_int::smax (double_int b)\n {\n-  return (double_int_scmp (a, b) == 1) ? a : b;\n+  return (this->scmp (b) == 1) ? *this : b;\n }\n \n /* Compares two unsigned values A and B.  Returns max value.  */\n \n-double_int double_int_umax (double_int a, double_int b)\n+double_int\n+double_int::umax (double_int b)\n {\n-  return (double_int_ucmp (a, b) == 1) ? a : b;\n+  return (this->ucmp (b) == 1) ? *this : b;\n }\n \n /* Compares two values A and B.  Returns mix value.  Signedness of the\n    comparison is given by UNS.  */\n \n-double_int double_int_min (double_int a, double_int b, bool uns)\n+double_int\n+double_int::min (double_int b, bool uns)\n {\n-  return (double_int_cmp (a, b, uns) == -1) ? a : b;\n+  return (this->cmp (b, uns) == -1) ? *this : b;\n }\n \n /* Compares two signed values A and B.  Returns min value.  */\n \n-double_int double_int_smin (double_int a, double_int b)\n+double_int\n+double_int::smin (double_int b)\n {\n-  return (double_int_scmp (a, b) == -1) ? a : b;\n+  return (this->scmp (b) == -1) ? *this : b;\n }\n \n /* Compares two unsigned values A and B.  Returns min value.  */\n \n-double_int double_int_umin (double_int a, double_int b)\n+double_int\n+double_int::umin (double_int b)\n {\n-  return (double_int_ucmp (a, b) == -1) ? a : b;\n+  return (this->ucmp (b) == -1) ? *this : b;\n }\n \n /* Splits last digit of *CST (taken as unsigned) in BASE and returns it.  */\n@@ -1102,19 +1222,19 @@ dump_double_int (FILE *file, double_int cst, bool uns)\n   unsigned digits[100], n;\n   int i;\n \n-  if (double_int_zero_p (cst))\n+  if (cst.is_zero ())\n     {\n       fprintf (file, \"0\");\n       return;\n     }\n \n-  if (!uns && double_int_negative_p (cst))\n+  if (!uns && cst.is_negative ())\n     {\n       fprintf (file, \"-\");\n-      cst = double_int_neg (cst);\n+      cst = -cst;\n     }\n \n-  for (n = 0; !double_int_zero_p (cst); n++)\n+  for (n = 0; !cst.is_zero (); n++)\n     digits[n] = double_int_split_digit (&cst, 10);\n   for (i = n - 1; i >= 0; i--)\n     fprintf (file, \"%u\", digits[i]);\n@@ -1130,10 +1250,10 @@ mpz_set_double_int (mpz_t result, double_int val, bool uns)\n   bool negate = false;\n   unsigned HOST_WIDE_INT vp[2];\n \n-  if (!uns && double_int_negative_p (val))\n+  if (!uns && val.is_negative ())\n     {\n       negate = true;\n-      val = double_int_neg (val);\n+      val = -val;\n     }\n \n   vp[0] = val.low;\n@@ -1191,9 +1311,9 @@ mpz_get_double_int (const_tree type, mpz_t val, bool wrap)\n   res.low = vp[0];\n   res.high = (HOST_WIDE_INT) vp[1];\n \n-  res = double_int_ext (res, TYPE_PRECISION (type), TYPE_UNSIGNED (type));\n+  res = res.ext (TYPE_PRECISION (type), TYPE_UNSIGNED (type));\n   if (mpz_sgn (val) < 0)\n-    res = double_int_neg (res);\n+    res = -res;\n \n   return res;\n }"}, {"sha": "9bbf644603c4f9d9e282ab81b803d20fedfac1ad", "filename": "gcc/double-int.h", "status": "modified", "additions": 597, "deletions": 78, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -50,10 +50,132 @@ along with GCC; see the file COPYING3.  If not see\n    numbers with precision higher than HOST_WIDE_INT).  It might be less\n    confusing to have them both signed or both unsigned.  */\n \n-typedef struct\n+typedef struct double_int\n {\n+public:\n+  /* Normally, we would define constructors to create instances.\n+     Two things prevent us from doing so.\n+     First, defining a constructor makes the class non-POD in C++03,\n+     and we certainly want double_int to be a POD.\n+     Second, the GCC conding conventions prefer explicit conversion,\n+     and explicit conversion operators are not available until C++11.  */\n+\n+  static double_int from_unsigned (unsigned HOST_WIDE_INT cst);\n+  static double_int from_signed (HOST_WIDE_INT cst);\n+\n+  /* No copy assignment operator or destructor to keep the type a POD.  */\n+\n+  /* There are some special value-creation static member functions.  */\n+\n+  static double_int mask (unsigned prec);\n+  static double_int max_value (unsigned int prec, bool uns);\n+  static double_int min_value (unsigned int prec, bool uns);\n+\n+  /* The following functions are mutating operations.  */\n+\n+  double_int &operator ++ (); // prefix\n+  double_int &operator -- (); // prefix\n+  double_int &operator *= (double_int);\n+  double_int &operator += (double_int);\n+  double_int &operator -= (double_int);\n+\n+  /* The following functions are non-mutating operations.  */\n+\n+  /* Conversion functions.  */\n+\n+  HOST_WIDE_INT to_signed () const;\n+  unsigned HOST_WIDE_INT to_unsigned () const;\n+\n+  /* Conversion query functions.  */\n+\n+  bool fits_unsigned () const;\n+  bool fits_signed () const;\n+  bool fits (bool uns) const;\n+\n+  /* Attribute query functions.  */\n+\n+  int trailing_zeros () const;\n+  int popcount () const;\n+\n+  /* Arithmetic query operations.  */\n+\n+  bool multiple_of (double_int, bool, double_int *) const;\n+\n+  /* Arithmetic operation functions.  */\n+\n+  double_int set_bit (unsigned) const;\n+  double_int mul_with_sign (double_int, bool, int *) const;\n+\n+  double_int operator * (double_int b) const;\n+  double_int operator + (double_int b) const;\n+  double_int operator - (double_int b) const;\n+  double_int operator - () const;\n+  double_int operator ~ () const;\n+  double_int operator & (double_int b) const;\n+  double_int operator | (double_int b) const;\n+  double_int operator ^ (double_int b) const;\n+  double_int and_not (double_int b) const;\n+\n+  double_int lshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const;\n+  double_int rshift (HOST_WIDE_INT count, unsigned int prec, bool arith) const;\n+  double_int alshift (HOST_WIDE_INT count, unsigned int prec) const;\n+  double_int arshift (HOST_WIDE_INT count, unsigned int prec) const;\n+  double_int llshift (HOST_WIDE_INT count, unsigned int prec) const;\n+  double_int lrshift (HOST_WIDE_INT count, unsigned int prec) const;\n+  double_int lrotate (HOST_WIDE_INT count, unsigned int prec) const;\n+  double_int rrotate (HOST_WIDE_INT count, unsigned int prec) const;\n+\n+  /* You must ensure that double_int::ext is called on the operands\n+     of the following operations, if the precision of the numbers\n+     is less than HOST_BITS_PER_DOUBLE_INT bits.  */\n+  double_int div (double_int, bool, unsigned) const;\n+  double_int sdiv (double_int, unsigned) const;\n+  double_int udiv (double_int, unsigned) const;\n+  double_int mod (double_int, bool, unsigned) const;\n+  double_int smod (double_int, unsigned) const;\n+  double_int umod (double_int, unsigned) const;\n+  double_int divmod (double_int, bool, unsigned, double_int *) const;\n+  double_int sdivmod (double_int, unsigned, double_int *) const;\n+  double_int udivmod (double_int, unsigned, double_int *) const;\n+\n+  /* Precision control functions.  */\n+\n+  double_int ext (unsigned prec, bool uns) const;\n+  double_int zext (unsigned prec) const;\n+  double_int sext (unsigned prec) const;\n+\n+  /* Comparative functions.  */\n+\n+  bool is_zero () const;\n+  bool is_one () const;\n+  bool is_minus_one () const;\n+  bool is_negative () const;\n+\n+  int cmp (double_int b, bool uns) const;\n+  int ucmp (double_int b) const;\n+  int scmp (double_int b) const;\n+\n+  bool ult (double_int b) const;\n+  bool ugt (double_int b) const;\n+  bool slt (double_int b) const;\n+  bool sgt (double_int b) const;\n+\n+  double_int max (double_int b, bool uns);\n+  double_int smax (double_int b);\n+  double_int umax (double_int b);\n+\n+  double_int min (double_int b, bool uns);\n+  double_int smin (double_int b);\n+  double_int umin (double_int b);\n+\n+  bool operator == (double_int cst2) const;\n+  bool operator != (double_int cst2) const;\n+\n+  /* Please migrate away from using these member variables publically.  */\n+\n   unsigned HOST_WIDE_INT low;\n   HOST_WIDE_INT high;\n+\n } double_int;\n \n #define HOST_BITS_PER_DOUBLE_INT (2 * HOST_BITS_PER_WIDE_INT)\n@@ -63,155 +185,407 @@ typedef struct\n /* Constructs double_int from integer CST.  The bits over the precision of\n    HOST_WIDE_INT are filled with the sign bit.  */\n \n-static inline double_int\n-shwi_to_double_int (HOST_WIDE_INT cst)\n+inline\n+double_int double_int::from_signed (HOST_WIDE_INT cst)\n {\n   double_int r;\n-\n   r.low = (unsigned HOST_WIDE_INT) cst;\n   r.high = cst < 0 ? -1 : 0;\n-\n   return r;\n }\n \n+/* FIXME(crowl): Remove after converting callers.  */\n+static inline double_int\n+shwi_to_double_int (HOST_WIDE_INT cst)\n+{\n+  return double_int::from_signed (cst);\n+}\n+\n /* Some useful constants.  */\n+/* FIXME(crowl): Maybe remove after converting callers?\n+   The problem is that a named constant would not be as optimizable,\n+   while the functional syntax is more verbose.  */\n \n-#define double_int_minus_one (shwi_to_double_int (-1))\n-#define double_int_zero (shwi_to_double_int (0))\n-#define double_int_one (shwi_to_double_int (1))\n-#define double_int_two (shwi_to_double_int (2))\n-#define double_int_ten (shwi_to_double_int (10))\n+#define double_int_minus_one (double_int::from_signed (-1))\n+#define double_int_zero (double_int::from_signed (0))\n+#define double_int_one (double_int::from_signed (1))\n+#define double_int_two (double_int::from_signed (2))\n+#define double_int_ten (double_int::from_signed (10))\n \n /* Constructs double_int from unsigned integer CST.  The bits over the\n    precision of HOST_WIDE_INT are filled with zeros.  */\n \n-static inline double_int\n-uhwi_to_double_int (unsigned HOST_WIDE_INT cst)\n+inline\n+double_int double_int::from_unsigned (unsigned HOST_WIDE_INT cst)\n {\n   double_int r;\n-\n   r.low = cst;\n   r.high = 0;\n-\n   return r;\n }\n \n+/* FIXME(crowl): Remove after converting callers.  */\n+static inline double_int\n+uhwi_to_double_int (unsigned HOST_WIDE_INT cst)\n+{\n+  return double_int::from_unsigned (cst);\n+}\n+\n+inline double_int &\n+double_int::operator ++ ()\n+{\n+  *this += double_int_one;\n+  return *this;\n+}\n+\n+inline double_int &\n+double_int::operator -- ()\n+{\n+  *this -= double_int_one;\n+  return *this;\n+}\n+\n+inline double_int &\n+double_int::operator *= (double_int b)\n+{\n+  *this = *this * b;\n+  return *this;\n+}\n+\n+inline double_int &\n+double_int::operator += (double_int b)\n+{\n+  *this = *this + b;\n+  return *this;\n+}\n+\n+inline double_int &\n+double_int::operator -= (double_int b)\n+{\n+  *this = *this - b;\n+  return *this;\n+}\n+\n /* Returns value of CST as a signed number.  CST must satisfy\n-   double_int_fits_in_shwi_p.  */\n+   double_int::fits_signed.  */\n \n+inline HOST_WIDE_INT\n+double_int::to_signed () const\n+{\n+  return (HOST_WIDE_INT) low;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline HOST_WIDE_INT\n double_int_to_shwi (double_int cst)\n {\n-  return (HOST_WIDE_INT) cst.low;\n+  return cst.to_signed ();\n }\n \n /* Returns value of CST as an unsigned number.  CST must satisfy\n-   double_int_fits_in_uhwi_p.  */\n+   double_int::fits_unsigned.  */\n+\n+inline unsigned HOST_WIDE_INT\n+double_int::to_unsigned () const\n+{\n+  return low;\n+}\n \n+/* FIXME(crowl): Remove after converting callers.  */\n static inline unsigned HOST_WIDE_INT\n double_int_to_uhwi (double_int cst)\n {\n-  return cst.low;\n+  return cst.to_unsigned ();\n }\n \n-bool double_int_fits_in_hwi_p (double_int, bool);\n-bool double_int_fits_in_shwi_p (double_int);\n-\n /* Returns true if CST fits in unsigned HOST_WIDE_INT.  */\n \n+inline bool\n+double_int::fits_unsigned () const\n+{\n+  return high == 0;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline bool\n double_int_fits_in_uhwi_p (double_int cst)\n {\n-  return cst.high == 0;\n+  return cst.fits_unsigned ();\n+}\n+\n+/* Returns true if CST fits in signed HOST_WIDE_INT.  */\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline bool\n+double_int_fits_in_shwi_p (double_int cst)\n+{\n+  return cst.fits_signed ();\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline bool\n+double_int_fits_in_hwi_p (double_int cst, bool uns)\n+{\n+  return cst.fits (uns);\n }\n \n /* The following operations perform arithmetics modulo 2^precision,\n    so you do not need to call double_int_ext between them, even if\n    you are representing numbers with precision less than\n    HOST_BITS_PER_DOUBLE_INT bits.  */\n \n-double_int double_int_mul (double_int, double_int);\n-double_int double_int_mul_with_sign (double_int, double_int, bool, int *);\n-double_int double_int_add (double_int, double_int);\n-double_int double_int_sub (double_int, double_int);\n-double_int double_int_neg (double_int);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_mul (double_int a, double_int b)\n+{\n+  return a * b;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_mul_with_sign (double_int a, double_int b,\n+\t\t\t  bool unsigned_p, int *overflow)\n+{\n+  return a.mul_with_sign (b, unsigned_p, overflow);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_add (double_int a, double_int b)\n+{\n+  return a + b;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_sub (double_int a, double_int b)\n+{\n+  return a - b;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_neg (double_int a)\n+{\n+  return -a;\n+}\n \n /* You must ensure that double_int_ext is called on the operands\n    of the following operations, if the precision of the numbers\n    is less than HOST_BITS_PER_DOUBLE_INT bits.  */\n-double_int double_int_div (double_int, double_int, bool, unsigned);\n-double_int double_int_sdiv (double_int, double_int, unsigned);\n-double_int double_int_udiv (double_int, double_int, unsigned);\n-double_int double_int_mod (double_int, double_int, bool, unsigned);\n-double_int double_int_smod (double_int, double_int, unsigned);\n-double_int double_int_umod (double_int, double_int, unsigned);\n-double_int double_int_divmod (double_int, double_int, bool, unsigned, double_int *);\n-double_int double_int_sdivmod (double_int, double_int, unsigned, double_int *);\n-double_int double_int_udivmod (double_int, double_int, unsigned, double_int *);\n \n-bool double_int_multiple_of (double_int, double_int, bool, double_int *);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_div (double_int a, double_int b, bool uns, unsigned code)\n+{\n+  return a.div (b, uns, code);\n+}\n \n-double_int double_int_setbit (double_int, unsigned);\n-int double_int_ctz (double_int);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_sdiv (double_int a, double_int b, unsigned code)\n+{\n+  return a.sdiv (b, code);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_udiv (double_int a, double_int b, unsigned code)\n+{\n+  return a.udiv (b, code);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_mod (double_int a, double_int b, bool uns, unsigned code)\n+{\n+  return a.mod (b, uns, code);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_smod (double_int a, double_int b, unsigned code)\n+{\n+  return a.smod (b, code);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_umod (double_int a, double_int b, unsigned code)\n+{\n+  return a.umod (b, code);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_divmod (double_int a, double_int b, bool uns,\n+\t\t   unsigned code, double_int *mod)\n+{\n+  return a.divmod (b, uns, code, mod);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_sdivmod (double_int a, double_int b, unsigned code, double_int *mod)\n+{\n+  return a.sdivmod (b, code, mod);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_udivmod (double_int a, double_int b, unsigned code, double_int *mod)\n+{\n+  return a.udivmod (b, code, mod);\n+}\n+\n+/***/\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline bool\n+double_int_multiple_of (double_int product, double_int factor,\n+                        bool unsigned_p, double_int *multiple)\n+{\n+  return product.multiple_of (factor, unsigned_p, multiple);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_setbit (double_int a, unsigned bitpos)\n+{\n+  return a.set_bit (bitpos);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline int\n+double_int_ctz (double_int a)\n+{\n+  return a.trailing_zeros ();\n+}\n \n /* Logical operations.  */\n \n /* Returns ~A.  */\n \n+inline double_int\n+double_int::operator ~ () const\n+{\n+  double_int result;\n+  result.low = ~low;\n+  result.high = ~high;\n+  return result;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline double_int\n double_int_not (double_int a)\n {\n-  a.low = ~a.low;\n-  a.high = ~a.high;\n-  return a;\n+  return ~a;\n }\n \n /* Returns A | B.  */\n \n+inline double_int\n+double_int::operator | (double_int b) const\n+{\n+  double_int result;\n+  result.low = low | b.low;\n+  result.high = high | b.high;\n+  return result;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline double_int\n double_int_ior (double_int a, double_int b)\n {\n-  a.low |= b.low;\n-  a.high |= b.high;\n-  return a;\n+  return a | b;\n }\n \n /* Returns A & B.  */\n \n+inline double_int\n+double_int::operator & (double_int b) const\n+{\n+  double_int result;\n+  result.low = low & b.low;\n+  result.high = high & b.high;\n+  return result;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline double_int\n double_int_and (double_int a, double_int b)\n {\n-  a.low &= b.low;\n-  a.high &= b.high;\n-  return a;\n+  return a & b;\n }\n \n /* Returns A & ~B.  */\n \n+inline double_int\n+double_int::and_not (double_int b) const\n+{\n+  double_int result;\n+  result.low = low & ~b.low;\n+  result.high = high & ~b.high;\n+  return result;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline double_int\n double_int_and_not (double_int a, double_int b)\n {\n-  a.low &= ~b.low;\n-  a.high &= ~b.high;\n-  return a;\n+  return a.and_not (b);\n }\n \n /* Returns A ^ B.  */\n \n+inline double_int\n+double_int::operator ^ (double_int b) const\n+{\n+  double_int result;\n+  result.low = low ^ b.low;\n+  result.high = high ^ b.high;\n+  return result;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline double_int\n double_int_xor (double_int a, double_int b)\n {\n-  a.low ^= b.low;\n-  a.high ^= b.high;\n-  return a;\n+  return a ^ b;\n }\n \n \n /* Shift operations.  */\n-double_int double_int_lshift (double_int, HOST_WIDE_INT, unsigned int, bool);\n-double_int double_int_rshift (double_int, HOST_WIDE_INT, unsigned int, bool);\n-double_int double_int_lrotate (double_int, HOST_WIDE_INT, unsigned int);\n-double_int double_int_rrotate (double_int, HOST_WIDE_INT, unsigned int);\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_lshift (double_int a, HOST_WIDE_INT count, unsigned int prec,\n+\t\t   bool arith)\n+{\n+  return a.lshift (count, prec, arith);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_rshift (double_int a, HOST_WIDE_INT count, unsigned int prec,\n+\t\t   bool arith)\n+{\n+  return a.rshift (count, prec, arith);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_lrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n+{\n+  return a.lrotate (count, prec);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_rrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n+{\n+  return a.rrotate (count, prec);\n+}\n \n /* Returns true if CST is negative.  Of course, CST is considered to\n    be signed.  */\n@@ -222,29 +596,115 @@ double_int_negative_p (double_int cst)\n   return cst.high < 0;\n }\n \n-int double_int_cmp (double_int, double_int, bool);\n-int double_int_scmp (double_int, double_int);\n-int double_int_ucmp (double_int, double_int);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline int\n+double_int_cmp (double_int a, double_int b, bool uns)\n+{\n+  return a.cmp (b, uns);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline int\n+double_int_scmp (double_int a, double_int b)\n+{\n+  return a.scmp (b);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline int\n+double_int_ucmp (double_int a, double_int b)\n+{\n+  return a.ucmp (b);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_max (double_int a, double_int b, bool uns)\n+{\n+  return a.max (b, uns);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_smax (double_int a, double_int b)\n+{\n+  return a.smax (b);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_umax (double_int a, double_int b)\n+{\n+  return a.umax (b);\n+}\n \n-double_int double_int_max (double_int, double_int, bool);\n-double_int double_int_smax (double_int, double_int);\n-double_int double_int_umax (double_int, double_int);\n \n-double_int double_int_min (double_int, double_int, bool);\n-double_int double_int_smin (double_int, double_int);\n-double_int double_int_umin (double_int, double_int);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_min (double_int a, double_int b, bool uns)\n+{\n+  return a.min (b, uns);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_smin (double_int a, double_int b)\n+{\n+  return a.smin (b);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_umin (double_int a, double_int b)\n+{\n+  return a.umin (b);\n+}\n \n void dump_double_int (FILE *, double_int, bool);\n \n /* Zero and sign extension of numbers in smaller precisions.  */\n \n-double_int double_int_ext (double_int, unsigned, bool);\n-double_int double_int_sext (double_int, unsigned);\n-double_int double_int_zext (double_int, unsigned);\n-double_int double_int_mask (unsigned);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_ext (double_int a, unsigned prec, bool uns)\n+{ \n+  return a.ext (prec, uns);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_sext (double_int a, unsigned prec)\n+{\n+  return a.sext (prec);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_zext (double_int a, unsigned prec)\n+{\n+  return a.zext (prec);\n+}\n \n-double_int double_int_max_value (unsigned int, bool);\n-double_int double_int_min_value (unsigned int, bool);\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_mask (unsigned prec)\n+{\n+  return double_int::mask (prec);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_max_value (unsigned int prec, bool uns)\n+{\n+  return double_int::max_value (prec, uns);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n+inline double_int\n+double_int_min_value (unsigned int prec, bool uns)\n+{\n+  return double_int::min_value (prec, uns);\n+}\n \n #define ALL_ONES (~((unsigned HOST_WIDE_INT) 0))\n \n@@ -254,69 +714,128 @@ double_int double_int_min_value (unsigned int, bool);\n \n /* Returns true if CST is zero.  */\n \n+inline bool\n+double_int::is_zero () const\n+{\n+  return low == 0 && high == 0;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline bool\n double_int_zero_p (double_int cst)\n {\n-  return cst.low == 0 && cst.high == 0;\n+  return cst.is_zero ();\n }\n \n /* Returns true if CST is one.  */\n \n+inline bool\n+double_int::is_one () const\n+{\n+  return low == 1 && high == 0;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline bool\n double_int_one_p (double_int cst)\n {\n-  return cst.low == 1 && cst.high == 0;\n+  return cst.is_one ();\n }\n \n /* Returns true if CST is minus one.  */\n \n+inline bool\n+double_int::is_minus_one () const\n+{\n+  return low == ALL_ONES && high == -1;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline bool\n double_int_minus_one_p (double_int cst)\n {\n-  return (cst.low == ALL_ONES && cst.high == -1);\n+  return cst.is_minus_one ();\n+}\n+\n+/* Returns true if CST is negative.  */\n+\n+inline bool\n+double_int::is_negative () const\n+{\n+  return high < 0;\n }\n \n /* Returns true if CST1 == CST2.  */\n \n+inline bool\n+double_int::operator == (double_int cst2) const\n+{\n+  return low == cst2.low && high == cst2.high;\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline bool\n double_int_equal_p (double_int cst1, double_int cst2)\n {\n-  return cst1.low == cst2.low && cst1.high == cst2.high;\n+  return cst1 == cst2;\n+}\n+\n+/* Returns true if CST1 != CST2.  */\n+\n+inline bool\n+double_int::operator != (double_int cst2) const\n+{\n+  return low != cst2.low || high != cst2.high;\n }\n \n /* Return number of set bits of CST.  */\n \n+inline int\n+double_int::popcount () const\n+{\n+  return popcount_hwi (high) + popcount_hwi (low);\n+}\n+\n+/* FIXME(crowl): Remove after converting callers.  */\n static inline int\n double_int_popcount (double_int cst)\n {\n-  return popcount_hwi (cst.high) + popcount_hwi (cst.low);\n+  return cst.popcount ();\n }\n \n \n /* Legacy interface with decomposed high/low parts.  */\n \n+/* FIXME(crowl): Remove after converting callers.  */\n extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t bool);\n+/* FIXME(crowl): Remove after converting callers.  */\n #define add_double(l1,h1,l2,h2,lv,hv) \\\n   add_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n+/* FIXME(crowl): Remove after converting callers.  */\n extern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+/* FIXME(crowl): Remove after converting callers.  */\n extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t bool);\n+/* FIXME(crowl): Remove after converting callers.  */\n extern int mul_double_wide_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t      unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t      bool);\n+/* FIXME(crowl): Remove after converting callers.  */\n #define mul_double(l1,h1,l2,h2,lv,hv) \\\n   mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n+/* FIXME(crowl): Remove after converting callers.  */\n extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t   HOST_WIDE_INT, unsigned int,\n \t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n+/* FIXME(crowl): Remove after converting callers.  */\n extern int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,"}, {"sha": "17027857babd9d859321c68b6ab4fcc58e5fef49", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -2550,7 +2550,7 @@ create_cfi_notes (void)\n   gcc_checking_assert (trace_work_list == NULL);\n \n   /* Always begin at the entry trace.  */\n-  ti = VEC_index (dw_trace_info, trace_info, 0);\n+  ti = &VEC_index (dw_trace_info, trace_info, 0);\n   scan_trace (ti);\n \n   while (!VEC_empty (dw_trace_info_ref, trace_work_list))\n@@ -2597,7 +2597,7 @@ connect_traces (void)\n   /* Remove all unprocessed traces from the list.  */\n   for (i = n - 1; i > 0; --i)\n     {\n-      ti = VEC_index (dw_trace_info, trace_info, i);\n+      ti = &VEC_index (dw_trace_info, trace_info, i);\n       if (ti->beg_row == NULL)\n \t{\n \t  VEC_ordered_remove (dw_trace_info, trace_info, i);\n@@ -2609,13 +2609,13 @@ connect_traces (void)\n \n   /* Work from the end back to the beginning.  This lets us easily insert\n      remember/restore_state notes in the correct order wrt other notes.  */\n-  prev_ti = VEC_index (dw_trace_info, trace_info, n - 1);\n+  prev_ti = &VEC_index (dw_trace_info, trace_info, n - 1);\n   for (i = n - 1; i > 0; --i)\n     {\n       dw_cfi_row *old_row;\n \n       ti = prev_ti;\n-      prev_ti = VEC_index (dw_trace_info, trace_info, i - 1);\n+      prev_ti = &VEC_index (dw_trace_info, trace_info, i - 1);\n \n       add_cfi_insn = ti->head;\n \n@@ -2686,7 +2686,7 @@ connect_traces (void)\n \n       for (i = 0; i < n; ++i)\n \t{\n-\t  ti = VEC_index (dw_trace_info, trace_info, i);\n+\t  ti = &VEC_index (dw_trace_info, trace_info, i);\n \n \t  if (ti->switch_sections)\n \t    prev_args_size = 0;\n@@ -2884,8 +2884,8 @@ create_cie_data (void)\n \t  break;\n \tcase 1:\n \t  cie_return_save = ggc_alloc_reg_saved_in_data ();\n-\t  *cie_return_save = *VEC_index (reg_saved_in_data,\n-\t\t\t\t\t cie_trace.regs_saved_in_regs, 0);\n+\t  *cie_return_save = VEC_index (reg_saved_in_data,\n+\t\t\t\t\tcie_trace.regs_saved_in_regs, 0);\n \t  VEC_free (reg_saved_in_data, heap, cie_trace.regs_saved_in_regs);\n \t  break;\n \tdefault:"}, {"sha": "4bc4cc333978c581f9ba1cc64e08048d5a684f0c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -5821,7 +5821,7 @@ same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n     return 0;\n \n   FOR_EACH_VEC_ELT (dw_attr_node, die1->die_attr, ix, a1)\n-    if (!same_attr_p (a1, VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n+    if (!same_attr_p (a1, &VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n       return 0;\n \n   c1 = die1->die_child;\n@@ -7072,7 +7072,7 @@ build_abbrev_table (dw_die_ref die, htab_t extern_map)\n \n       FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, die_a)\n \t{\n-\t  abbrev_a = VEC_index (dw_attr_node, abbrev->die_attr, ix);\n+\t  abbrev_a = &VEC_index (dw_attr_node, abbrev->die_attr, ix);\n \t  if ((abbrev_a->dw_attr != die_a->dw_attr)\n \t      || (value_format (abbrev_a) != value_format (die_a)))\n \t    {\n@@ -20532,8 +20532,8 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n   unsigned int i, count, encoded_filename_len, linebuf_len;\n   void **slot;\n \n-  first = VEC_index (macinfo_entry, macinfo_table, idx);\n-  second = VEC_index (macinfo_entry, macinfo_table, idx + 1);\n+  first = &VEC_index (macinfo_entry, macinfo_table, idx);\n+  second = &VEC_index (macinfo_entry, macinfo_table, idx + 1);\n \n   /* Optimize only if there are at least two consecutive define/undef ops,\n      and either all of them are before first DW_MACINFO_start_file\n@@ -20573,7 +20573,7 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n   if (VEC_empty (macinfo_entry, files))\n     base = \"\";\n   else\n-    base = lbasename (VEC_last (macinfo_entry, files)->info);\n+    base = lbasename (VEC_last (macinfo_entry, files).info);\n   for (encoded_filename_len = 0, i = 0; base[i]; i++)\n     if (ISIDNUM (base[i]) || base[i] == '.')\n       encoded_filename_len++;\n@@ -20604,7 +20604,7 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n \n   /* Construct a macinfo_entry for DW_MACRO_GNU_transparent_include\n      in the empty vector entry before the first define/undef.  */\n-  inc = VEC_index (macinfo_entry, macinfo_table, idx - 1);\n+  inc = &VEC_index (macinfo_entry, macinfo_table, idx - 1);\n   inc->code = DW_MACRO_GNU_transparent_include;\n   inc->lineno = 0;\n   inc->info = ggc_strdup (grp_name);\n@@ -20697,7 +20697,7 @@ output_macinfo (void)\n \t      && VEC_length (macinfo_entry, files) != 1\n \t      && i > 0\n \t      && i + 1 < length\n-\t      && VEC_index (macinfo_entry, macinfo_table, i - 1)->code == 0)\n+\t      && VEC_index (macinfo_entry, macinfo_table, i - 1).code == 0)\n \t    {\n \t      unsigned count = optimize_macinfo_range (i, files, &macinfo_htab);\n \t      if (count)\n@@ -21307,14 +21307,14 @@ static inline void\n move_linkage_attr (dw_die_ref die)\n {\n   unsigned ix = VEC_length (dw_attr_node, die->die_attr);\n-  dw_attr_node linkage = *VEC_index (dw_attr_node, die->die_attr, ix - 1);\n+  dw_attr_node linkage = VEC_index (dw_attr_node, die->die_attr, ix - 1);\n \n   gcc_assert (linkage.dw_attr == DW_AT_linkage_name\n \t      || linkage.dw_attr == DW_AT_MIPS_linkage_name);\n \n   while (--ix > 0)\n     {\n-      dw_attr_node *prev = VEC_index (dw_attr_node, die->die_attr, ix - 1);\n+      dw_attr_node *prev = &VEC_index (dw_attr_node, die->die_attr, ix - 1);\n \n       if (prev->dw_attr == DW_AT_decl_line || prev->dw_attr == DW_AT_name)\n \tbreak;\n@@ -22226,8 +22226,8 @@ dwarf2out_finish (const char *filename)\n   for (i = 0; i < VEC_length (deferred_locations, deferred_locations_list); i++)\n     {\n       add_location_or_const_value_attribute (\n-        VEC_index (deferred_locations, deferred_locations_list, i)->die,\n-        VEC_index (deferred_locations, deferred_locations_list, i)->variable,\n+        VEC_index (deferred_locations, deferred_locations_list, i).die,\n+        VEC_index (deferred_locations, deferred_locations_list, i).variable,\n \tfalse,\n \tDW_AT_location);\n     }"}, {"sha": "210cc148d310b7d027b3ff31a0544ba0250d3021", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -6091,7 +6091,7 @@ locator_location (int loc)\n \t  break;\n \t}\n     }\n-  return *VEC_index (location_t, locations_locators_vals, min);\n+  return VEC_index (location_t, locations_locators_vals, min);\n }\n \n /* Return source line of the statement that produced this insn.  */"}, {"sha": "01745125a8e81873c63a5d5e8bba533ee83723a9", "filename": "gcc/except.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -304,8 +304,8 @@ init_eh_for_function (void)\n   cfun->eh = ggc_alloc_cleared_eh_status ();\n \n   /* Make sure zero'th entries are used.  */\n-  VEC_safe_push (eh_region, gc, cfun->eh->region_array, NULL);\n-  VEC_safe_push (eh_landing_pad, gc, cfun->eh->lp_array, NULL);\n+  VEC_safe_push (eh_region, gc, cfun->eh->region_array, (eh_region) NULL);\n+  VEC_safe_push (eh_landing_pad, gc, cfun->eh->lp_array, (eh_landing_pad) NULL);\n }\n \f\n /* Routines to generate the exception tree somewhat directly.\n@@ -806,7 +806,7 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n       if (targetm.arm_eabi_unwinder)\n \tVEC_safe_push (tree, gc, cfun->eh->ehspec_data.arm_eabi, NULL_TREE);\n       else\n-\tVEC_safe_push (uchar, gc, cfun->eh->ehspec_data.other, 0);\n+\tVEC_safe_push (uchar, gc, cfun->eh->ehspec_data.other, (uchar) 0);\n     }\n \n   return n->filter;\n@@ -2395,10 +2395,10 @@ add_call_site (rtx landing_pad, int action, int section)\n   record->action = action;\n \n   VEC_safe_push (call_site_record, gc,\n-\t\t crtl->eh.call_site_record[section], record);\n+\t\t crtl->eh.call_site_record_v[section], record);\n \n   return call_site_base + VEC_length (call_site_record,\n-\t\t\t\t      crtl->eh.call_site_record[section]) - 1;\n+\t\t\t\t      crtl->eh.call_site_record_v[section]) - 1;\n }\n \n /* Turn REG_EH_REGION notes back into NOTE_INSN_EH_REGION notes.\n@@ -2546,10 +2546,10 @@ convert_to_eh_region_ranges (void)\n \telse if (last_action != -3)\n \t  last_landing_pad = pc_rtx;\n \tcall_site_base += VEC_length (call_site_record,\n-\t\t\t\t      crtl->eh.call_site_record[cur_sec]);\n+\t\t\t\t      crtl->eh.call_site_record_v[cur_sec]);\n \tcur_sec++;\n-\tgcc_assert (crtl->eh.call_site_record[cur_sec] == NULL);\n-\tcrtl->eh.call_site_record[cur_sec]\n+\tgcc_assert (crtl->eh.call_site_record_v[cur_sec] == NULL);\n+\tcrtl->eh.call_site_record_v[cur_sec]\n \t  = VEC_alloc (call_site_record, gc, 10);\n       }\n \n@@ -2633,14 +2633,14 @@ push_sleb128 (VEC (uchar, gc) **data_area, int value)\n static int\n dw2_size_of_call_site_table (int section)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record[section]);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[section]);\n   int size = n * (4 + 4 + 4);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record[section], i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record_v[section], i);\n       size += size_of_uleb128 (cs->action);\n     }\n \n@@ -2650,14 +2650,14 @@ dw2_size_of_call_site_table (int section)\n static int\n sjlj_size_of_call_site_table (void)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record[0]);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[0]);\n   int size = 0;\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record[0], i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record_v[0], i);\n       size += size_of_uleb128 (INTVAL (cs->landing_pad));\n       size += size_of_uleb128 (cs->action);\n     }\n@@ -2669,7 +2669,7 @@ sjlj_size_of_call_site_table (void)\n static void\n dw2_output_call_site_table (int cs_format, int section)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record[section]);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[section]);\n   int i;\n   const char *begin;\n \n@@ -2683,7 +2683,7 @@ dw2_output_call_site_table (int cs_format, int section)\n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record[section], i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record_v[section], i);\n       char reg_start_lab[32];\n       char reg_end_lab[32];\n       char landing_pad_lab[32];\n@@ -2731,13 +2731,13 @@ dw2_output_call_site_table (int cs_format, int section)\n static void\n sjlj_output_call_site_table (void)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record[0]);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record_v[0]);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record[0], i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record_v[0], i);\n \n       dw2_asm_output_data_uleb128 (INTVAL (cs->landing_pad),\n \t\t\t\t   \"region %d landing pad\", i);\n@@ -3051,7 +3051,7 @@ output_function_exception_table (const char *fnname)\n   targetm.asm_out.emit_except_table_label (asm_out_file);\n \n   output_one_function_exception_table (0);\n-  if (crtl->eh.call_site_record[1] != NULL)\n+  if (crtl->eh.call_site_record_v[1] != NULL)\n     output_one_function_exception_table (1);\n \n   switch_to_section (current_function_section ());"}, {"sha": "9a34bc53de1784a53d763dfefd99c6271cdb89cc", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 115, "deletions": 168, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -111,13 +111,11 @@ fixed_from_string (FIXED_VALUE_TYPE *f, const char *str, enum machine_mode mode)\n       /* From the spec, we need to evaluate 1 to the maximal value.  */\n       f->data.low = -1;\n       f->data.high = -1;\n-      f->data = double_int_ext (f->data,\n-\t\t\t\tGET_MODE_FBIT (f->mode)\n-\t\t\t\t+ GET_MODE_IBIT (f->mode), 1);\n+      f->data = f->data.zext (GET_MODE_FBIT (f->mode)\n+\t\t\t\t+ GET_MODE_IBIT (f->mode));\n     }\n   else\n-    f->data = double_int_ext (f->data,\n-\t\t\t      SIGNED_FIXED_POINT_MODE_P (f->mode)\n+    f->data = f->data.ext (SIGNED_FIXED_POINT_MODE_P (f->mode)\n \t\t\t      + GET_MODE_FBIT (f->mode)\n \t\t\t      + GET_MODE_IBIT (f->mode),\n \t\t\t      UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n@@ -159,8 +157,8 @@ fixed_saturate1 (enum machine_mode mode, double_int a, double_int *f,\n       double_int max;\n       max.low = -1;\n       max.high = -1;\n-      max = double_int_ext (max, i_f_bits, 1);\n-      if (double_int_cmp (a, max, 1) == 1)\n+      max = max.zext (i_f_bits);\n+      if (a.ugt (max))\n \t{\n \t  if (sat_p)\n \t    *f = max;\n@@ -173,21 +171,19 @@ fixed_saturate1 (enum machine_mode mode, double_int a, double_int *f,\n       double_int max, min;\n       max.high = -1;\n       max.low = -1;\n-      max = double_int_ext (max, i_f_bits, 1);\n+      max = max.zext (i_f_bits);\n       min.high = 0;\n       min.low = 1;\n-      lshift_double (min.low, min.high, i_f_bits,\n-\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &min.low, &min.high, 1);\n-      min = double_int_ext (min, 1 + i_f_bits, 0);\n-      if (double_int_cmp (a, max, 0) == 1)\n+      min = min.alshift (i_f_bits, HOST_BITS_PER_DOUBLE_INT);\n+      min = min.sext (1 + i_f_bits);\n+      if (a.sgt (max))\n \t{\n \t  if (sat_p)\n \t    *f = max;\n \t  else\n \t    overflow_p = true;\n \t}\n-      else if (double_int_cmp (a, min, 0) == -1)\n+      else if (a.slt (min))\n \t{\n \t  if (sat_p)\n \t    *f = min;\n@@ -221,10 +217,10 @@ fixed_saturate2 (enum machine_mode mode, double_int a_high, double_int a_low,\n       max_r.low = 0;\n       max_s.high = -1;\n       max_s.low = -1;\n-      max_s = double_int_ext (max_s, i_f_bits, 1);\n-      if (double_int_cmp (a_high, max_r, 1) == 1\n-\t  || (double_int_equal_p (a_high, max_r) &&\n-\t      double_int_cmp (a_low, max_s, 1) == 1))\n+      max_s = max_s.zext (i_f_bits);\n+      if (a_high.ugt (max_r)\n+\t  || (a_high == max_r &&\n+\t      a_low.ugt (max_s)))\n \t{\n \t  if (sat_p)\n \t    *f = max_s;\n@@ -239,27 +235,25 @@ fixed_saturate2 (enum machine_mode mode, double_int a_high, double_int a_low,\n       max_r.low = 0;\n       max_s.high = -1;\n       max_s.low = -1;\n-      max_s = double_int_ext (max_s, i_f_bits, 1);\n+      max_s = max_s.zext (i_f_bits);\n       min_r.high = -1;\n       min_r.low = -1;\n       min_s.high = 0;\n       min_s.low = 1;\n-      lshift_double (min_s.low, min_s.high, i_f_bits,\n-\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &min_s.low, &min_s.high, 1);\n-      min_s = double_int_ext (min_s, 1 + i_f_bits, 0);\n-      if (double_int_cmp (a_high, max_r, 0) == 1\n-\t  || (double_int_equal_p (a_high, max_r) &&\n-\t      double_int_cmp (a_low, max_s, 1) == 1))\n+      min_s = min_s.alshift (i_f_bits, HOST_BITS_PER_DOUBLE_INT);\n+      min_s = min_s.sext (1 + i_f_bits);\n+      if (a_high.sgt (max_r)\n+\t  || (a_high == max_r &&\n+\t      a_low.ugt (max_s)))\n \t{\n \t  if (sat_p)\n \t    *f = max_s;\n \t  else\n \t    overflow_p = true;\n \t}\n-      else if (double_int_cmp (a_high, min_r, 0) == -1\n-\t       || (double_int_equal_p (a_high, min_r) &&\n-\t\t   double_int_cmp (a_low, min_s, 1) == -1))\n+      else if (a_high.slt (min_r)\n+\t       || (a_high == min_r &&\n+\t\t   a_low.ult (min_s)))\n \t{\n \t  if (sat_p)\n \t    *f = min_s;\n@@ -297,19 +291,19 @@ do_fixed_add (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n   /* This was a conditional expression but it triggered a bug in\n      Sun C 5.5.  */\n   if (subtract_p)\n-    temp = double_int_neg (b->data);\n+    temp = -b->data;\n   else\n     temp = b->data;\n \n   unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n   i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n   f->mode = a->mode;\n-  f->data = double_int_add (a->data, temp);\n+  f->data = a->data + temp;\n   if (unsigned_p) /* Unsigned type.  */\n     {\n       if (subtract_p) /* Unsigned subtraction.  */\n \t{\n-\t  if (double_int_cmp (a->data, b->data, 1) == -1)\n+\t  if (a->data.ult (b->data))\n \t    {\n \t      if (sat_p)\n \t\t{\n@@ -322,9 +316,9 @@ do_fixed_add (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t}\n       else /* Unsigned addition.  */\n \t{\n-\t  f->data = double_int_ext (f->data, i_f_bits, 1);\n-\t  if (double_int_cmp (f->data, a->data, 1) == -1\n-\t      || double_int_cmp (f->data, b->data, 1) == -1)\n+\t  f->data = f->data.zext (i_f_bits);\n+\t  if (f->data.ult (a->data)\n+\t      || f->data.ult (b->data))\n \t    {\n \t      if (sat_p)\n \t\t{\n@@ -353,22 +347,17 @@ do_fixed_add (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t    {\n \t      f->data.low = 1;\n \t      f->data.high = 0;\n-\t      lshift_double (f->data.low, f->data.high, i_f_bits,\n-\t\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t     &f->data.low, &f->data.high, 1);\n+\t      f->data = f->data.alshift (i_f_bits, HOST_BITS_PER_DOUBLE_INT);\n \t      if (get_fixed_sign_bit (a->data, i_f_bits) == 0)\n \t\t{\n-\t\t  double_int one;\n-\t\t  one.low = 1;\n-\t\t  one.high = 0;\n-\t\t  f->data = double_int_sub (f->data, one);\n+\t\t  --f->data;\n \t\t}\n \t    }\n \t  else\n \t    overflow_p = true;\n \t}\n     }\n-  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  f->data = f->data.ext ((!unsigned_p) + i_f_bits, unsigned_p);\n   return overflow_p;\n }\n \n@@ -386,11 +375,10 @@ do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n   f->mode = a->mode;\n   if (GET_MODE_PRECISION (f->mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      f->data = double_int_mul (a->data, b->data);\n-      lshift_double (f->data.low, f->data.high,\n-\t\t     (-GET_MODE_FBIT (f->mode)),\n+      f->data = a->data * b->data;\n+      f->data = f->data.lshift ((-GET_MODE_FBIT (f->mode)),\n \t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &f->data.low, &f->data.high, !unsigned_p);\n+\t\t     !unsigned_p);\n       overflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n     }\n   else\n@@ -412,43 +400,43 @@ do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n       b_low.high = 0;\n \n       /* Perform four multiplications.  */\n-      low_low = double_int_mul (a_low, b_low);\n-      low_high = double_int_mul (a_low, b_high);\n-      high_low = double_int_mul (a_high, b_low);\n-      high_high = double_int_mul (a_high, b_high);\n+      low_low = a_low * b_low;\n+      low_high = a_low * b_high;\n+      high_low = a_high * b_low;\n+      high_high = a_high * b_high;\n \n       /* Accumulate four results to {r, s}.  */\n       temp1.high = high_low.low;\n       temp1.low = 0;\n-      s = double_int_add (low_low, temp1);\n-      if (double_int_cmp (s, low_low, 1) == -1\n-\t  || double_int_cmp (s, temp1, 1) == -1)\n+      s = low_low + temp1;\n+      if (s.ult (low_low)\n+\t  || s.ult (temp1))\n \tcarry ++; /* Carry */\n       temp1.high = s.high;\n       temp1.low = s.low;\n       temp2.high = low_high.low;\n       temp2.low = 0;\n-      s = double_int_add (temp1, temp2);\n-      if (double_int_cmp (s, temp1, 1) == -1\n-\t  || double_int_cmp (s, temp2, 1) == -1)\n+      s = temp1 + temp2;\n+      if (s.ult (temp1)\n+\t  || s.ult (temp2))\n \tcarry ++; /* Carry */\n \n       temp1.low = high_low.high;\n       temp1.high = 0;\n-      r = double_int_add (high_high, temp1);\n+      r = high_high + temp1;\n       temp1.low = low_high.high;\n       temp1.high = 0;\n-      r = double_int_add (r, temp1);\n+      r += temp1;\n       temp1.low = carry;\n       temp1.high = 0;\n-      r = double_int_add (r, temp1);\n+      r += temp1;\n \n       /* We need to subtract b from r, if a < 0.  */\n       if (!unsigned_p && a->data.high < 0)\n-\tr = double_int_sub (r, b->data);\n+\tr -= b->data;\n       /* We need to subtract a from r, if b < 0.  */\n       if (!unsigned_p && b->data.high < 0)\n-\tr = double_int_sub (r, a->data);\n+\tr -= a->data;\n \n       /* Shift right the result by FBIT.  */\n       if (GET_MODE_FBIT (f->mode) == HOST_BITS_PER_DOUBLE_INT)\n@@ -470,29 +458,23 @@ do_fixed_multiply (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t}\n       else\n \t{\n-\t  lshift_double (s.low, s.high,\n-\t\t\t (-GET_MODE_FBIT (f->mode)),\n-\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &s.low, &s.high, 0);\n-\t  lshift_double (r.low, r.high,\n-\t\t\t (HOST_BITS_PER_DOUBLE_INT\n+\t  s = s.llshift ((-GET_MODE_FBIT (f->mode)), HOST_BITS_PER_DOUBLE_INT);\n+\t  f->data = r.llshift ((HOST_BITS_PER_DOUBLE_INT\n \t\t\t  - GET_MODE_FBIT (f->mode)),\n-\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &f->data.low, &f->data.high, 0);\n+\t\t\t HOST_BITS_PER_DOUBLE_INT);\n \t  f->data.low = f->data.low | s.low;\n \t  f->data.high = f->data.high | s.high;\n \t  s.low = f->data.low;\n \t  s.high = f->data.high;\n-\t  lshift_double (r.low, r.high,\n-\t\t\t (-GET_MODE_FBIT (f->mode)),\n+\t  r = r.lshift ((-GET_MODE_FBIT (f->mode)),\n \t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &r.low, &r.high, !unsigned_p);\n+\t\t\t !unsigned_p);\n \t}\n \n       overflow_p = fixed_saturate2 (f->mode, r, s, &f->data, sat_p);\n     }\n \n-  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  f->data = f->data.ext ((!unsigned_p) + i_f_bits, unsigned_p);\n   return overflow_p;\n }\n \n@@ -510,11 +492,10 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n   f->mode = a->mode;\n   if (GET_MODE_PRECISION (f->mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      lshift_double (a->data.low, a->data.high,\n-\t\t     GET_MODE_FBIT (f->mode),\n+      f->data = a->data.lshift (GET_MODE_FBIT (f->mode),\n \t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &f->data.low, &f->data.high, !unsigned_p);\n-      f->data = double_int_div (f->data, b->data, unsigned_p, TRUNC_DIV_EXPR);\n+\t\t     !unsigned_p);\n+      f->data = f->data.div (b->data, unsigned_p, TRUNC_DIV_EXPR);\n       overflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n     }\n   else\n@@ -527,7 +508,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n       /* If a < 0, negate a.  */\n       if (!unsigned_p && a->data.high < 0)\n \t{\n-\t  pos_a = double_int_neg (a->data);\n+\t  pos_a = -a->data;\n \t  num_of_neg ++;\n \t}\n       else\n@@ -536,7 +517,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n       /* If b < 0, negate b.  */\n       if (!unsigned_p && b->data.high < 0)\n \t{\n-\t  pos_b = double_int_neg (b->data);\n+\t  pos_b = -b->data;\n \t  num_of_neg ++;\n \t}\n       else\n@@ -551,62 +532,50 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t}\n       else\n  \t{\n-\t  lshift_double (pos_a.low, pos_a.high,\n-\t\t\t GET_MODE_FBIT (f->mode),\n-\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &s.low, &s.high, 0);\n-\t  lshift_double (pos_a.low, pos_a.high,\n-\t\t\t - (HOST_BITS_PER_DOUBLE_INT\n+\t  s = pos_a.llshift (GET_MODE_FBIT (f->mode), HOST_BITS_PER_DOUBLE_INT);\n+\t  r = pos_a.llshift (- (HOST_BITS_PER_DOUBLE_INT\n \t\t\t    - GET_MODE_FBIT (f->mode)),\n-\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &r.low, &r.high, 0);\n+\t\t\t HOST_BITS_PER_DOUBLE_INT);\n  \t}\n \n       /* Divide r by pos_b to quo_r.  The remainder is in mod.  */\n-      div_and_round_double (TRUNC_DIV_EXPR, 1, r.low, r.high, pos_b.low,\n-\t\t\t    pos_b.high, &quo_r.low, &quo_r.high, &mod.low,\n-\t\t\t    &mod.high);\n-\n-      quo_s.high = 0;\n-      quo_s.low = 0;\n+      quo_r = r.divmod (pos_b, 1, TRUNC_DIV_EXPR, &mod);\n+      quo_s = double_int_zero;\n \n       for (i = 0; i < HOST_BITS_PER_DOUBLE_INT; i++)\n \t{\n \t  /* Record the leftmost bit of mod.  */\n \t  int leftmost_mod = (mod.high < 0);\n \n \t  /* Shift left mod by 1 bit.  */\n-\t  lshift_double (mod.low, mod.high, 1, HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &mod.low, &mod.high, 0);\n+\t  mod = mod.llshift (1, HOST_BITS_PER_DOUBLE_INT);\n \n \t  /* Test the leftmost bit of s to add to mod.  */\n \t  if (s.high < 0)\n \t    mod.low += 1;\n \n \t  /* Shift left quo_s by 1 bit.  */\n-\t  lshift_double (quo_s.low, quo_s.high, 1, HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &quo_s.low, &quo_s.high, 0);\n+\t  quo_s = quo_s.llshift (1, HOST_BITS_PER_DOUBLE_INT);\n \n \t  /* Try to calculate (mod - pos_b).  */\n-\t  temp = double_int_sub (mod, pos_b);\n+\t  temp = mod - pos_b;\n \n-\t  if (leftmost_mod == 1 || double_int_cmp (mod, pos_b, 1) != -1)\n+\t  if (leftmost_mod == 1 || mod.ucmp (pos_b) != -1)\n \t    {\n \t      quo_s.low += 1;\n \t      mod = temp;\n \t    }\n \n \t  /* Shift left s by 1 bit.  */\n-\t  lshift_double (s.low, s.high, 1, HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &s.low, &s.high, 0);\n+\t  s = s.llshift (1, HOST_BITS_PER_DOUBLE_INT);\n \n \t}\n \n       if (num_of_neg == 1)\n \t{\n-\t  quo_s = double_int_neg (quo_s);\n+\t  quo_s = -quo_s;\n \t  if (quo_s.high == 0 && quo_s.low == 0)\n-\t    quo_r = double_int_neg (quo_r);\n+\t    quo_r = -quo_r;\n \t  else\n \t    {\n \t      quo_r.low = ~quo_r.low;\n@@ -618,7 +587,7 @@ do_fixed_divide (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n       overflow_p = fixed_saturate2 (f->mode, quo_r, quo_s, &f->data, sat_p);\n     }\n \n-  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  f->data = f->data.ext ((!unsigned_p) + i_f_bits, unsigned_p);\n   return overflow_p;\n }\n \n@@ -643,10 +612,9 @@ do_fixed_shift (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \n   if (GET_MODE_PRECISION (f->mode) <= HOST_BITS_PER_WIDE_INT || (!left_p))\n     {\n-      lshift_double (a->data.low, a->data.high,\n-\t\t     left_p ? b->data.low : (-b->data.low),\n+      f->data = a->data.lshift (left_p ? b->data.low : (-b->data.low),\n \t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &f->data.low, &f->data.high, !unsigned_p);\n+\t\t     !unsigned_p);\n       if (left_p) /* Only left shift saturates.  */\n \toverflow_p = fixed_saturate1 (f->mode, f->data, &f->data, sat_p);\n     }\n@@ -661,23 +629,20 @@ do_fixed_shift (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a,\n \t}\n       else\n \t{\n-\t  lshift_double (a->data.low, a->data.high,\n-\t\t\t b->data.low,\n+\t  temp_low = a->data.lshift (b->data.low,\n \t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &temp_low.low, &temp_low.high, !unsigned_p);\n+\t\t\t !unsigned_p);\n \t  /* Logical shift right to temp_high.  */\n-\t  lshift_double (a->data.low, a->data.high,\n-\t\t\t b->data.low - HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t &temp_high.low, &temp_high.high, 0);\n+\t  temp_high = a->data.llshift (b->data.low - HOST_BITS_PER_DOUBLE_INT,\n+\t\t\t HOST_BITS_PER_DOUBLE_INT);\n \t}\n       if (!unsigned_p && a->data.high < 0) /* Signed-extend temp_high.  */\n-\ttemp_high = double_int_ext (temp_high, b->data.low, unsigned_p);\n+\ttemp_high = temp_high.ext (b->data.low, unsigned_p);\n       f->data = temp_low;\n       overflow_p = fixed_saturate2 (f->mode, temp_high, temp_low, &f->data,\n \t\t\t\t    sat_p);\n     }\n-  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  f->data = f->data.ext ((!unsigned_p) + i_f_bits, unsigned_p);\n   return overflow_p;\n }\n \n@@ -692,8 +657,8 @@ do_fixed_neg (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a, bool sat_p)\n   bool unsigned_p = UNSIGNED_FIXED_POINT_MODE_P (a->mode);\n   int i_f_bits = GET_MODE_IBIT (a->mode) + GET_MODE_FBIT (a->mode);\n   f->mode = a->mode;\n-  f->data = double_int_neg (a->data);\n-  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  f->data = -a->data;\n+  f->data = f->data.ext ((!unsigned_p) + i_f_bits, unsigned_p);\n \n   if (unsigned_p) /* Unsigned type.  */\n     {\n@@ -718,7 +683,7 @@ do_fixed_neg (FIXED_VALUE_TYPE *f, const FIXED_VALUE_TYPE *a, bool sat_p)\n \t      /* Saturate to the maximum by subtracting f->data by one.  */\n \t      f->data.low = -1;\n \t      f->data.high = -1;\n-\t      f->data = double_int_ext (f->data, i_f_bits, 1);\n+\t      f->data = f->data.zext (i_f_bits);\n \t    }\n \t  else\n \t    overflow_p = true;\n@@ -789,25 +754,25 @@ fixed_compare (int icode, const FIXED_VALUE_TYPE *op0,\n   switch (code)\n     {\n     case NE_EXPR:\n-      return !double_int_equal_p (op0->data, op1->data);\n+      return op0->data != op1->data;\n \n     case EQ_EXPR:\n-      return double_int_equal_p (op0->data, op1->data);\n+      return op0->data == op1->data;\n \n     case LT_EXPR:\n-      return double_int_cmp (op0->data, op1->data,\n+      return op0->data.cmp (op1->data,\n \t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) == -1;\n \n     case LE_EXPR:\n-      return double_int_cmp (op0->data, op1->data,\n+      return op0->data.cmp (op1->data,\n \t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) != 1;\n \n     case GT_EXPR:\n-      return double_int_cmp (op0->data, op1->data,\n+      return op0->data.cmp (op1->data,\n \t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) == 1;\n \n     case GE_EXPR:\n-      return double_int_cmp (op0->data, op1->data,\n+      return op0->data.cmp (op1->data,\n \t\t\t     UNSIGNED_FIXED_POINT_MODE_P (op0->mode)) != -1;\n \n     default:\n@@ -835,19 +800,15 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n       /* Left shift a to temp_high, temp_low based on a->mode.  */\n       double_int temp_high, temp_low;\n       int amount = GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode);\n-      lshift_double (a->data.low, a->data.high,\n-\t\t     amount,\n+      temp_low = a->data.lshift (amount,\n \t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &temp_low.low, &temp_low.high,\n \t\t     SIGNED_FIXED_POINT_MODE_P (a->mode));\n       /* Logical shift right to temp_high.  */\n-      lshift_double (a->data.low, a->data.high,\n-\t\t     amount - HOST_BITS_PER_DOUBLE_INT,\n-\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &temp_high.low, &temp_high.high, 0);\n+      temp_high = a->data.llshift (amount - HOST_BITS_PER_DOUBLE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT);\n       if (SIGNED_FIXED_POINT_MODE_P (a->mode)\n \t  && a->data.high < 0) /* Signed-extend temp_high.  */\n-\ttemp_high = double_int_ext (temp_high, amount, 0);\n+\ttemp_high = temp_high.sext (amount);\n       f->mode = mode;\n       f->data = temp_low;\n       if (SIGNED_FIXED_POINT_MODE_P (a->mode) ==\n@@ -885,10 +846,9 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t\t      /* Set to maximum.  */\n \t\t      f->data.low = -1;  /* Set to all ones.  */\n \t\t      f->data.high = -1;  /* Set to all ones.  */\n-\t\t      f->data = double_int_ext (f->data,\n-\t\t\t\t\t\tGET_MODE_FBIT (f->mode)\n-\t\t\t\t\t\t+ GET_MODE_IBIT (f->mode),\n-\t\t\t\t\t\t1); /* Clear the sign.  */\n+\t\t      f->data = f->data.zext (GET_MODE_FBIT (f->mode)\n+\t\t\t\t\t\t+ GET_MODE_IBIT (f->mode));\n+\t\t\t\t\t\t/* Clear the sign.  */\n \t\t    }\n \t\t  else\n \t\t    overflow_p = true;\n@@ -903,10 +863,8 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n     {\n       /* Right shift a to temp based on a->mode.  */\n       double_int temp;\n-      lshift_double (a->data.low, a->data.high,\n-\t\t     GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode),\n+      temp = a->data.lshift (GET_MODE_FBIT (mode) - GET_MODE_FBIT (a->mode),\n \t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &temp.low, &temp.high,\n \t\t     SIGNED_FIXED_POINT_MODE_P (a->mode));\n       f->mode = mode;\n       f->data = temp;\n@@ -944,10 +902,9 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t\t      /* Set to maximum.  */\n \t\t      f->data.low = -1;  /* Set to all ones.  */\n \t\t      f->data.high = -1;  /* Set to all ones.  */\n-\t\t      f->data = double_int_ext (f->data,\n-\t\t\t\t\t\tGET_MODE_FBIT (f->mode)\n-\t\t\t\t\t\t+ GET_MODE_IBIT (f->mode),\n-\t\t\t\t\t\t1); /* Clear the sign.  */\n+\t\t      f->data = f->data.zext (GET_MODE_FBIT (f->mode)\n+\t\t\t\t\t\t+ GET_MODE_IBIT (f->mode));\n+\t\t\t\t\t\t/* Clear the sign.  */\n \t\t    }\n \t\t  else\n \t\t    overflow_p = true;\n@@ -959,8 +916,7 @@ fixed_convert (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t}\n     }\n \n-  f->data = double_int_ext (f->data,\n-\t\t\t    SIGNED_FIXED_POINT_MODE_P (f->mode)\n+  f->data = f->data.ext (SIGNED_FIXED_POINT_MODE_P (f->mode)\n \t\t\t    + GET_MODE_FBIT (f->mode)\n \t\t\t    + GET_MODE_IBIT (f->mode),\n \t\t\t    UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n@@ -988,19 +944,14 @@ fixed_convert_from_int (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n     }\n   else\n     {\n-      lshift_double (a.low, a.high,\n-\t\t     amount,\n-\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &temp_low.low, &temp_low.high, 0);\n+      temp_low = a.llshift (amount, HOST_BITS_PER_DOUBLE_INT);\n \n       /* Logical shift right to temp_high.  */\n-      lshift_double (a.low, a.high,\n-\t\t     amount - HOST_BITS_PER_DOUBLE_INT,\n-\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t     &temp_high.low, &temp_high.high, 0);\n+      temp_high = a.llshift (amount - HOST_BITS_PER_DOUBLE_INT,\n+\t\t     HOST_BITS_PER_DOUBLE_INT);\n     }\n   if (!unsigned_p && a.high < 0) /* Signed-extend temp_high.  */\n-    temp_high = double_int_ext (temp_high, amount, 0);\n+    temp_high = temp_high.sext (amount);\n \n   f->mode = mode;\n   f->data = temp_low;\n@@ -1038,10 +989,9 @@ fixed_convert_from_int (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t\t  /* Set to maximum.  */\n \t\t  f->data.low = -1;  /* Set to all ones.  */\n \t\t  f->data.high = -1;  /* Set to all ones.  */\n-\t\t  f->data = double_int_ext (f->data,\n-\t\t\t\t\t    GET_MODE_FBIT (f->mode)\n-\t\t\t\t\t    + GET_MODE_IBIT (f->mode),\n-\t\t\t\t\t    1); /* Clear the sign.  */\n+\t\t  f->data = f->data.zext (GET_MODE_FBIT (f->mode)\n+\t\t\t\t\t    + GET_MODE_IBIT (f->mode));\n+\t\t\t\t\t    /* Clear the sign.  */\n \t\t}\n \t      else\n \t\toverflow_p = true;\n@@ -1051,8 +1001,7 @@ fixed_convert_from_int (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t\t\t\t\t  &f->data, sat_p);\n \t}\n     }\n-  f->data = double_int_ext (f->data,\n-\t\t\t    SIGNED_FIXED_POINT_MODE_P (f->mode)\n+  f->data = f->data.ext (SIGNED_FIXED_POINT_MODE_P (f->mode)\n \t\t\t    + GET_MODE_FBIT (f->mode)\n \t\t\t    + GET_MODE_IBIT (f->mode),\n \t\t\t    UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n@@ -1093,10 +1042,8 @@ fixed_convert_from_real (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t    {\n \t      f->data.low = 1;\n \t      f->data.high = 0;\n-\t      lshift_double (f->data.low, f->data.high, i_f_bits,\n-\t\t\t     HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t     &f->data.low, &f->data.high, 1);\n-\t      f->data = double_int_ext (f->data, 1 + i_f_bits, 0);\n+\t      f->data = f->data.alshift (i_f_bits, HOST_BITS_PER_DOUBLE_INT);\n+\t      f->data = f->data.sext (1 + i_f_bits);\n \t    }\n \t}\n       else\n@@ -1108,12 +1055,12 @@ fixed_convert_from_real (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \t{\n \t  f->data.low = -1;\n \t  f->data.high = -1;\n-\t  f->data = double_int_ext (f->data, i_f_bits, 1);\n+\t  f->data = f->data.zext (i_f_bits);\n \t}\n       else\n \toverflow_p = true;\n     }\n-  f->data = double_int_ext (f->data, (!unsigned_p) + i_f_bits, unsigned_p);\n+  f->data = f->data.ext ((!unsigned_p) + i_f_bits, unsigned_p);\n   return overflow_p;\n }\n "}, {"sha": "3bfd203bea8794a65747f852d62bc5404c8c7f36", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -14285,7 +14285,7 @@ fold (tree expr)\n \t    while (begin != end)\n \t      {\n \t\tunsigned HOST_WIDE_INT middle = (begin + end) / 2;\n-\t\ttree index = VEC_index (constructor_elt, elts, middle)->index;\n+\t\ttree index = VEC_index (constructor_elt, elts, middle).index;\n \n \t\tif (TREE_CODE (index) == INTEGER_CST\n \t\t    && tree_int_cst_lt (index, op1))\n@@ -14300,7 +14300,7 @@ fold (tree expr)\n \t\t\t && tree_int_cst_lt (op1, TREE_OPERAND (index, 0)))\n \t\t  end = middle;\n \t\telse\n-\t\t  return VEC_index (constructor_elt, elts, middle)->value;\n+\t\t  return VEC_index (constructor_elt, elts, middle).value;\n \t      }\n \t  }\n "}, {"sha": "684bbce1b070d743752a47a1151235e9f33c39ed", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -157,7 +157,7 @@ struct GTY(()) rtl_eh {\n \n   VEC(uchar,gc) *action_record_data;\n \n-  VEC(call_site_record,gc) *call_site_record[2];\n+  VEC(call_site_record,gc) *call_site_record_v[2];\n };\n \n #define pending_stack_adjust (crtl->expr.x_pending_stack_adjust)"}, {"sha": "d1cba8810ef873ad4623ebc2529b856b673ccae4", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -223,7 +223,7 @@ single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   bitmap_copy (local_lr, &lr_bb_info->in);\n \n   /* Push a marker for the leave_block callback.  */\n-  VEC_safe_push (df_ref, heap, reg_defs_stack, NULL);\n+  VEC_safe_push (df_ref, heap, reg_defs_stack, (df_ref) NULL);\n \n   process_uses (df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n   process_defs (df_get_artificial_defs (bb_index), DF_REF_AT_TOP);"}, {"sha": "815747eaf0f6167a5e40fcf578157a6a3f2fd490", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -2520,7 +2520,7 @@ execute (void)\n      and record info about each one.\n      Also search for the programs that are to be run.  */\n \n-  VEC_safe_push (const_char_p, heap, argbuf, 0);\n+  VEC_safe_push (const_char_p, heap, argbuf, (const_char_p)0);\n \n   commands[0].prog = VEC_index (const_char_p, argbuf, 0); /* first command.  */\n   commands[0].argv = VEC_address (const_char_p, argbuf);"}, {"sha": "6432113933677dd5511386112fcecfc067a17065", "filename": "gcc/gdbinit.in", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgdbinit.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgdbinit.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbinit.in?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -182,6 +182,13 @@ document pbm\n Dump the bitmap that is in $ as a comma-separated list of numbers.\n end\n \n+# Define some macros helpful to gdb when it is expanding macros.\n+macro define __FILE__ \"gdb\"\n+macro define __LINE__ 1\n+\n+# Gracefully handle aborts in functions used from gdb.\n+set unwindonsignal on\n+\n # Put breakpoints at exit and fancy_abort in case abort is mapped\n # to either fprintf/exit or fancy_abort.\n b fancy_abort\n@@ -196,3 +203,9 @@ set complaints 0\n # USE_SYSTEM_ABORT is defined, so gdb may complain and bail out.\n b exit\n b abort\n+\n+# Skip all inline functions in tree.h.\n+# These are used in accessor macros.\n+# Note that this is added at the end because older gdb versions\n+# do not understand the 'skip' command.\n+skip \"tree.h\""}, {"sha": "122a4a4cfbeedf99adc75da6a299467c8a277fe5", "filename": "gcc/genautomata.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -5076,7 +5076,8 @@ store_alt_unit_usage (regexp_t regexp, regexp_t unit, int cycle,\n \n   length = (cycle + 1) * REGEXP_ONEOF (regexp)->regexps_num;\n   while (VEC_length (unit_usage_t, cycle_alt_unit_usages) < length)\n-    VEC_safe_push (unit_usage_t, heap, cycle_alt_unit_usages, 0);\n+    VEC_safe_push (unit_usage_t, heap, cycle_alt_unit_usages,\n+\t\t   (unit_usage_t) NULL);\n \n   index = cycle * REGEXP_ONEOF (regexp)->regexps_num + alt_num;\n   prev = NULL;\n@@ -7673,7 +7674,8 @@ output_min_issue_delay_table (automaton_t automaton)\n \n \t      if (VEC_index (vect_el_t, min_issue_delay_vect, asn))\n \t\t{\n-\t\t  VEC_replace (vect_el_t, min_issue_delay_vect, asn, 0);\n+\t\t  VEC_replace (vect_el_t, min_issue_delay_vect, asn,\n+\t\t\t       (vect_el_t) 0);\n \t\t  changed = 1;\n \t\t}\n \n@@ -7723,7 +7725,8 @@ output_min_issue_delay_table (automaton_t automaton)\n \t    if (automaton->max_min_delay < x)\n \t      automaton->max_min_delay = x;\n \t    if (x == -1)\n-\t      VEC_replace (vect_el_t, min_issue_delay_vect, np, 0);\n+\t      VEC_replace (vect_el_t, min_issue_delay_vect, np,\n+\t\t\t   (vect_el_t) 0);\n \t  }\n       }\n \n@@ -7749,7 +7752,8 @@ output_min_issue_delay_table (automaton_t automaton)\n     = VEC_alloc (vect_el_t, heap, compressed_min_issue_delay_len);\n \n   for (i = 0; i < compressed_min_issue_delay_len; i++)\n-    VEC_quick_push (vect_el_t, compressed_min_issue_delay_vect, 0);\n+    VEC_quick_push (vect_el_t, compressed_min_issue_delay_vect,\n+\t\t    (vect_el_t) 0);\n \n   for (i = 0; i < min_issue_delay_len; i++)\n     {\n@@ -7798,7 +7802,8 @@ output_dead_lock_vect (automaton_t automaton)\n \t  automaton->locked_states++;\n \t}\n       else\n-\tVEC_replace (vect_el_t, dead_lock_vect, s->order_state_num, 0);\n+\tVEC_replace (vect_el_t, dead_lock_vect, s->order_state_num,\n+\t\t     (vect_el_t) 0);\n     }\n   if (automaton->locked_states == 0)\n     return;\n@@ -7840,7 +7845,7 @@ output_reserved_units_table (automaton_t automaton)\n   reserved_units_table = VEC_alloc (vect_el_t, heap, reserved_units_size);\n \n   for (i = 0; i < reserved_units_size; i++)\n-    VEC_quick_push (vect_el_t, reserved_units_table, 0);\n+    VEC_quick_push (vect_el_t, reserved_units_table, (vect_el_t) 0);\n   for (n = 0; n < VEC_length (state_t, output_states_vect); n++)\n     {\n       state_t s = VEC_index (state_t, output_states_vect, n);"}, {"sha": "175febeb58f9ff3236c955a8dfc31ece02335045", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -201,7 +201,7 @@ VEC_safe_set_locstr (VEC(locstr,heap) **vp, unsigned int ix, char *str)\n   else\n     {\n       while (ix > VEC_length (locstr, *vp))\n-\tVEC_safe_push (locstr, heap, *vp, 0);\n+\tVEC_safe_push (locstr, heap, *vp, (locstr) NULL);\n       VEC_safe_push (locstr, heap, *vp, str);\n     }\n }"}, {"sha": "5788a6a26d6178d0b3570a83ede83db334886b6d", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,6 +1,6 @@\n /* -*- indented-text -*- */\n /* Process source files and output type information.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -91,19 +91,6 @@ EOID\t[^[:alnum:]_]\n   BEGIN(in_struct);\n   return STATIC;\n }\n-\n-^{HWS}DEF_VEC_[OP]/{EOID} {\n-  BEGIN(in_struct);\n-  return DEFVEC_OP;\n-}\n-^{HWS}DEF_VEC_I/{EOID} {\n-  BEGIN(in_struct);\n-  return DEFVEC_I;\n-}\n-^{HWS}DEF_VEC_ALLOC_[IOP]/{EOID} {\n-  BEGIN(in_struct);\n-  return DEFVEC_ALLOC;\n-}\n }\n \n <in_struct>{\n@@ -121,6 +108,7 @@ EOID\t[^[:alnum:]_]\n \"enum\"/{EOID}\t\t\t{ return ENUM; }\n \"ptr_alias\"/{EOID}\t  \t{ return PTR_ALIAS; }\n \"nested_ptr\"/{EOID}\t\t{ return NESTED_PTR; }\n+\"user\"/{EOID}\t\t\t{ return USER_GTY; }\n [0-9]+\t\t\t\t{ return NUM; }\n \"param\"[0-9]*\"_is\"/{EOID}\t\t{\n   *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);"}, {"sha": "03ee7819b0f76dae66abf9250d05e7a5a006e67a", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 85, "deletions": 76, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,5 +1,5 @@\n /* Process source files and output type information.\n-   Copyright (C) 2006, 2007, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2010, 2012 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -77,9 +77,6 @@ static const char *const token_names[] = {\n   \"struct\",\n   \"enum\",\n   \"VEC\",\n-  \"DEF_VEC_[OP]\",\n-  \"DEF_VEC_I\",\n-  \"DEF_VEC_ALLOC_[IOP]\",\n   \"...\",\n   \"ptr_alias\",\n   \"nested_ptr\",\n@@ -212,28 +209,70 @@ string_seq (void)\n   return s1;\n }\n \n-/* typedef_name: either an ID, or VEC(x,y) which is translated to VEC_x_y.\n-   Use only where VEC(x,y) is legitimate, i.e. in positions where a\n-   typedef name may appear.  */\n+\n+/* The caller has detected a template declaration that starts\n+   with TMPL_NAME.  Parse up to the closing '>'.  This recognizes\n+   simple template declarations of the form ID<ID1,ID2,...,IDn>.\n+   It does not try to parse anything more sophisticated than that.\n+\n+   Returns the template declaration string \"ID<ID1,ID2,...,IDn>\".  */\n+\n+static const char *\n+require_template_declaration (const char *tmpl_name)\n+{\n+  char *str;\n+\n+  /* Recognize the opening '<'.  */\n+  require ('<');\n+  str = concat (tmpl_name, \"<\", (char *) 0);\n+\n+  /* Read the comma-separated list of identifiers.  */\n+  while (token () != '>')\n+    {\n+      const char *id = require2 (ID, ',');\n+      if (id == NULL)\n+\tid = \",\";\n+      str = concat (str, id, (char *) 0);\n+    }\n+\n+  /* Recognize the closing '>'.  */\n+  require ('>');\n+  str = concat (str, \">\", (char *) 0);\n+\n+  return str;\n+}\n+\n+\n+/* typedef_name: either an ID, or VEC(x,y), or a template type\n+   specification of the form ID<t1,t2,...,tn>.\n+\n+   FIXME cxx-conversion.  VEC(x,y) is currently translated to the\n+   template 'vec_t<x>'.  This is to support the transition to C++ and\n+   avoid re-writing all the 'VEC(x,y)' declarations in the code.  This\n+   needs to be fixed when the branch is merged into trunk.  */\n+\n static const char *\n typedef_name (void)\n {\n   if (token () == VEC_TOKEN)\n     {\n-      const char *c1, *c2, *r;\n+      const char *c1, *r;\n       advance ();\n       require ('(');\n       c1 = require2 (ID, SCALAR);\n       require (',');\n-      c2 = require (ID);\n+      require (ID);\n       require (')');\n-      r = concat (\"VEC_\", c1, \"_\", c2, (char *) 0);\n+      r = concat (\"vec_t<\", c1, \">\", (char *) 0);\n       free (CONST_CAST (char *, c1));\n-      free (CONST_CAST (char *, c2));\n       return r;\n     }\n+\n+  const char *id = require (ID);\n+  if (token () == '<')\n+    return require_template_declaration (id);\n   else\n-    return require (ID);\n+    return id;\n }\n \n /* Absorb a sequence of tokens delimited by balanced ()[]{}.  */\n@@ -460,6 +499,10 @@ option (options_p prev)\n       advance ();\n       return nestedptr_optvalue (prev);\n \n+    case USER_GTY:\n+      advance ();\n+      return create_string_option (prev, \"user\", \"\");\n+\n     default:\n       parse_error (\"expected an option keyword, have %s\", print_cur_token ());\n       advance ();\n@@ -694,6 +737,18 @@ struct_field_seq (void)\n   return nreverse_pairs (f);\n }\n \n+/* Return true if OPTS contain the option named STR.  */\n+\n+static bool\n+opts_have (options_p opts, const char *str)\n+{\n+  for (options_p opt = opts; opt; opt = opt->next)\n+    if (strcmp (opt->name, str) == 0)\n+      return true;\n+  return false;\n+}\n+\n+\n /* This is called type(), but what it parses (sort of) is what C calls\n    declaration-specifiers and specifier-qualifier-list:\n \n@@ -735,7 +790,7 @@ type (options_p *optsp, bool nested)\n \t  GTY_BEFORE_ID,\n \t  GTY_AFTER_ID\n \t} is_gty = NO_GTY;\n-\tbool is_union = (token () == UNION);\n+\tenum typekind kind = (token () == UNION) ? TYPE_UNION : TYPE_STRUCT;\n \tadvance ();\n \n \t/* Top-level structures that are not explicitly tagged GTY(())\n@@ -766,24 +821,36 @@ type (options_p *optsp, bool nested)\n \n \tif (is_gty)\n \t  {\n+\t    bool is_user_gty = opts_have (opts, \"user\");\n \t    if (token () == '{')\n \t      {\n \t\tpair_p fields;\n \n \t\tif (is_gty == GTY_AFTER_ID)\n \t\t  parse_error (\"GTY must be specified before identifier\");\n \n-\t\tadvance ();\n-\t\tfields = struct_field_seq ();\n-\t\trequire ('}');\n-\t\treturn new_structure (s, is_union, &lexer_line, fields, opts);\n+\t\tif (!is_user_gty)\n+\t\t  {\n+\t\t    advance ();\n+\t\t    fields = struct_field_seq ();\n+\t\t    require ('}');\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Do not look inside user defined structures.  */\n+\t\t    fields = NULL;\n+\t\t    kind = TYPE_USER_STRUCT;\n+\t\t    consume_balanced ('{', '}');\n+\t\t  }\n+\n+\t\treturn new_structure (s, kind, &lexer_line, fields, opts);\n \t      }\n \t  }\n \telse if (token () == '{')\n \t  consume_balanced ('{', '}');\n \tif (opts)\n \t  *optsp = opts;\n-\treturn find_structure (s, is_union);\n+\treturn find_structure (s, kind);\n       }\n \n     case ENUM:\n@@ -891,55 +958,6 @@ extern_or_static (void)\n     }\n }\n \n-/* Definition of a generic VEC structure:\n-\n-   'DEF_VEC_[IPO]' '(' id ')' ';'\n-\n-   Scalar VECs require slightly different treatment than otherwise -\n-   that's handled in note_def_vec, we just pass it along.*/\n-static void\n-def_vec (void)\n-{\n-  bool is_scalar = (token () == DEFVEC_I);\n-  const char *type;\n-\n-  require2 (DEFVEC_OP, DEFVEC_I);\n-  require ('(');\n-  type = require2 (ID, SCALAR);\n-  require (')');\n-  require (';');\n-\n-  if (!type)\n-    return;\n-\n-  note_def_vec (type, is_scalar, &lexer_line);\n-  note_def_vec_alloc (type, \"none\", &lexer_line);\n-}\n-\n-/* Definition of an allocation strategy for a VEC structure:\n-\n-   'DEF_VEC_ALLOC_[IPO]' '(' id ',' id ')' ';'\n-\n-   For purposes of gengtype, this just declares a wrapper structure.  */\n-static void\n-def_vec_alloc (void)\n-{\n-  const char *type, *astrat;\n-\n-  require (DEFVEC_ALLOC);\n-  require ('(');\n-  type = require2 (ID, SCALAR);\n-  require (',');\n-  astrat = require (ID);\n-  require (')');\n-  require (';');\n-\n-  if (!type || !astrat)\n-    return;\n-\n-  note_def_vec_alloc (type, astrat, &lexer_line);\n-}\n-\n /* Parse the file FNAME for GC-relevant declarations and definitions.\n    This is the only entry point to this file.  */\n void\n@@ -964,15 +982,6 @@ parse_file (const char *fname)\n \t  typedef_decl ();\n \t  break;\n \n-\tcase DEFVEC_OP:\n-\tcase DEFVEC_I:\n-\t  def_vec ();\n-\t  break;\n-\n-\tcase DEFVEC_ALLOC:\n-\t  def_vec_alloc ();\n-\t  break;\n-\n \tcase EOF_TOKEN:\n \t  goto eof;\n "}, {"sha": "c94d50b1ef686d9ffdc5b2407ba644fc25e89f5b", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -51,6 +51,7 @@ type_lineloc (const_type_p ty)\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n+    case TYPE_USER_STRUCT:\n       return CONST_CAST (struct fileloc*, &ty->u.s.line);\n     case TYPE_PARAM_STRUCT:\n       return CONST_CAST (struct fileloc*, &ty->u.param_struct.line);\n@@ -798,6 +799,22 @@ write_state_struct_type (type_p current)\n   write_state_type (current->u.s.lang_struct);\n }\n \n+/* Write a GTY user-defined struct type.  */\n+static void\n+write_state_user_struct_type (type_p current)\n+{\n+  DBGPRINTF (\"user_struct type @ %p #%d '%s'\", (void *) current,\n+\t     current->state_number, current->u.s.tag);\n+  fprintf (state_file, \"user_struct \");\n+  write_state_common_type_content (current);\n+  if (current->u.s.tag != NULL)\n+    write_state_a_string (current->u.s.tag);\n+  else\n+    fprintf (state_file, \"nil\");\n+  write_state_fileloc (type_lineloc (current));\n+  write_state_fields (current->u.s.fields);\n+}\n+\n /* write a GTY union type.  */\n static void\n write_state_union_type (type_p current)\n@@ -828,7 +845,7 @@ write_state_lang_struct_type (type_p current)\n       DBGPRINTF (\"homonymous #%d hty @ %p #%d '%s'\", nbhomontype,\n \t\t (void *) hty, hty->state_number, hty->u.s.tag);\n       /* Every member of the homonymous list should have the same tag.  */\n-      gcc_assert (UNION_OR_STRUCT_P (hty));\n+      gcc_assert (union_or_struct_p (hty));\n       gcc_assert (hty->u.s.lang_struct == current);\n       if (!homoname)\n \thomoname = hty->u.s.tag;\n@@ -947,6 +964,9 @@ write_state_type (type_p current)\n \tcase TYPE_STRUCT:\n \t  write_state_struct_type (current);\n \t  break;\n+\tcase TYPE_USER_STRUCT:\n+\t  write_state_user_struct_type (current);\n+\t  break;\n \tcase TYPE_UNION:\n \t  write_state_union_type (current);\n \t  break;\n@@ -1365,6 +1385,42 @@ read_state_struct_type (type_p type)\n }\n \n \n+/* Read a GTY-ed user-provided struct TYPE.  */\n+\n+static void\n+read_state_user_struct_type (type_p type)\n+{\n+  struct state_token_st *t0;\n+\n+  type->kind = TYPE_USER_STRUCT;\n+  read_state_common_type_content (type);\n+  t0 = peek_state_token (0);\n+  if (state_token_kind (t0) == STOK_STRING)\n+    {\n+      if (state_token_is_name (t0, \"nil\"))\n+\t{\n+\t  type->u.s.tag = NULL;\n+\t  DBGPRINTF (\"read anonymous struct type @%p #%d\",\n+\t\t     (void *) type, type->state_number);\n+\t}\n+      else\n+\t{\n+\t  type->u.s.tag = xstrdup (t0->stok_un.stok_string);\n+\t  DBGPRINTF (\"read struct type @%p #%d '%s'\",\n+\t\t     (void *) type, type->state_number, type->u.s.tag);\n+\t}\n+\n+      next_state_tokens (1);\n+      read_state_fileloc (&(type->u.s.line));\n+      read_state_fields (&(type->u.s.fields));\n+    }\n+  else\n+    {\n+      fatal_reading_state (t0, \"Bad tag in user-struct type\");\n+    }\n+}\n+\n+\n /* Read a GTY-ed union type.  */\n static void\n read_state_union_type (type_p type)\n@@ -1655,6 +1711,12 @@ read_state_type (type_p *current)\n \t      next_state_tokens (1);\n \t      read_state_array_type (*current);\n \t    }\n+\t  else if (state_token_is_name (t0, \"user_struct\"))\n+\t    {\n+\t      *current = XCNEW (struct type);\n+\t      next_state_tokens (1);\n+\t      read_state_user_struct_type (*current);\n+\t    }\n \t  else\n \t    fatal_reading_state (t0, \"bad type in (!type\");\n \t}"}, {"sha": "2ae43726b59a50524d72db8b62f2d391f3ecbf47", "filename": "gcc/gengtype.c", "status": "modified", "additions": 543, "deletions": 187, "changes": 730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,5 +1,6 @@\n /* Process source files and output type information.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,\n+   2012\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -89,6 +90,10 @@ static const char *get_file_realbasename (const input_file *);\n \n static int get_prefix_langdir_index (const char *);\n static const char *get_file_langdir (const input_file *);\n+\n+static void dump_pair (int indent, pair_p p);\n+static void dump_type (int indent, type_p p);\n+static void dump_type_list (int indent, type_p p);\n \f\n \n /* Nonzero iff an error has occurred.  */\n@@ -166,6 +171,7 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n   int nb_types = 0, nb_scalar = 0, nb_string = 0;\n   int nb_struct = 0, nb_union = 0, nb_array = 0, nb_pointer = 0;\n   int nb_lang_struct = 0, nb_param_struct = 0;\n+  int nb_user_struct = 0;\n   type_p p = NULL;\n   for (p = t; p; p = p->next)\n     {\n@@ -181,6 +187,9 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n \tcase TYPE_STRUCT:\n \t  nb_struct++;\n \t  break;\n+\tcase TYPE_USER_STRUCT:\n+\t  nb_user_struct++;\n+\t  break;\n \tcase TYPE_UNION:\n \t  nb_union++;\n \t  break;\n@@ -211,6 +220,8 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n   if (nb_lang_struct > 0 || nb_param_struct > 0)\n     fprintf (stderr, \"@@%%@@ %d lang_structs, %d param_structs\\n\",\n \t     nb_lang_struct, nb_param_struct);\n+  if (nb_user_struct > 0)\n+    fprintf (stderr, \"@@%%@@ %d user_structs\\n\", nb_user_struct);\n   fprintf (stderr, \"\\n\");\n }\n #endif /* ENABLE_CHECKING */\n@@ -539,6 +550,51 @@ do_scalar_typedef (const char *s, struct fileloc *pos)\n   do_typedef (s, &scalar_nonchar, pos);\n }\n \n+\n+/* Define TYPE_NAME to be a user defined type at location POS.  */\n+\n+static type_p\n+create_user_defined_type (const char *type_name, struct fileloc *pos)\n+{\n+  type_p ty = find_structure (type_name, TYPE_USER_STRUCT);\n+  ty->u.s.line = *pos;\n+  ty->u.s.bitmap = get_lang_bitmap (pos->file);\n+  do_typedef (type_name, ty, pos);\n+\n+  /* If TYPE_NAME specifies a template, create references to the types\n+     in the template by pretending that each type is a field of TY.\n+     This is needed to make sure that the types referenced by the\n+     template are marked as used.  */\n+  char *str = xstrdup (type_name);\n+  char *open_bracket = strchr (str, '<');\n+  if (open_bracket)\n+    {\n+      /* We only accept simple template declarations (see\n+\t require_template_declaration), so we only need to parse a\n+\t comma-separated list of strings, implicitly assumed to\n+\t be type names.  */\n+      char *arg = open_bracket + 1;\n+      char *type_id = strtok (arg, \",>\");\n+      pair_p fields = 0;\n+      while (type_id)\n+\t{\n+\t  /* Create a new field for every type found inside the template\n+\t     parameter list.  */\n+\t  const char *field_name = xstrdup (type_id);\n+\t  type_p arg_type = resolve_typedef (field_name, pos);\n+\t  fields = create_field_at (fields, arg_type, field_name, 0, pos);\n+\t  type_id = strtok (0, \",>\");\n+\t}\n+\n+      /* Associate the field list to TY.  */\n+      ty->u.s.fields = fields;\n+    }\n+  free (str);\n+\n+  return ty;\n+}\n+\n+\n /* Return the type previously defined for S.  Use POS to report errors.  */\n \n type_p\n@@ -548,20 +604,27 @@ resolve_typedef (const char *s, struct fileloc *pos)\n   for (p = typedefs; p != NULL; p = p->next)\n     if (strcmp (p->name, s) == 0)\n       return p->type;\n-  error_at_line (pos, \"unidentified type `%s'\", s);\n-  return &scalar_nonchar;\t/* treat as \"int\" */\n+\n+  /* If we did not find a typedef registered, assume this is a name\n+     for a user-defined type which will need to provide its own\n+     marking functions.  */\n+  return create_user_defined_type (s, pos);\n }\n \n-/* Create and return a new structure with tag NAME (or a union iff\n-   ISUNION is nonzero), at POS with fields FIELDS and options O.  */\n+/* Create and return a new structure with tag NAME at POS with fields\n+   FIELDS and options O.  The KIND of structure must be one of\n+   TYPE_STRUCT, TYPE_UNION or TYPE_USER_STRUCT.  */\n \n type_p\n-new_structure (const char *name, int isunion, struct fileloc *pos,\n+new_structure (const char *name, enum typekind kind, struct fileloc *pos,\n \t       pair_p fields, options_p o)\n {\n   type_p si;\n   type_p s = NULL;\n   lang_bitmap bitmap = get_lang_bitmap (pos->file);\n+  bool isunion = (kind == TYPE_UNION);\n+\n+  gcc_assert (union_or_struct_p (kind));\n \n   for (si = structures; si != NULL; si = si->next)\n     if (strcmp (name, si->u.s.tag) == 0 && UNION_P (si) == isunion)\n@@ -621,7 +684,7 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n       error_at_line (&s->u.s.line, \"previous definition here\");\n     }\n \n-  s->kind = isunion ? TYPE_UNION : TYPE_STRUCT;\n+  s->kind = kind;\n   s->u.s.tag = name;\n   s->u.s.line = *pos;\n   s->u.s.fields = fields;\n@@ -633,14 +696,18 @@ new_structure (const char *name, int isunion, struct fileloc *pos,\n   return s;\n }\n \n-/* Return the previously-defined structure with tag NAME (or a union\n-   iff ISUNION is nonzero), or a new empty structure or union if none\n-   was defined previously.  */\n+/* Return the previously-defined structure or union with tag NAME,\n+   or a new empty structure or union if none was defined previously.\n+   The KIND of structure must be one of TYPE_STRUCT, TYPE_UNION or\n+   TYPE_USER_STRUCT.  */\n \n type_p\n-find_structure (const char *name, int isunion)\n+find_structure (const char *name, enum typekind kind)\n {\n   type_p s;\n+  bool isunion = (kind == TYPE_UNION);\n+\n+  gcc_assert (union_or_struct_p (kind));\n \n   for (s = structures; s != NULL; s = s->next)\n     if (strcmp (name, s->u.s.tag) == 0 && UNION_P (s) == isunion)\n@@ -651,7 +718,7 @@ find_structure (const char *name, int isunion)\n   s->next = structures;\n   s->state_number = -type_count;\n   structures = s;\n-  s->kind = isunion ? TYPE_UNION : TYPE_STRUCT;\n+  s->kind = kind;\n   s->u.s.tag = name;\n   structures = s;\n   return s;\n@@ -851,7 +918,7 @@ create_optional_field_ (pair_p next, type_p type, const char *name,\n   union_fields->opt = \n     create_string_option (union_fields->opt, \"tag\", \"1\");\n   union_type = \n-    new_structure (xasprintf (\"%s_%d\", \"fake_union\", id++), 1,\n+    new_structure (xasprintf (\"%s_%d\", \"fake_union\", id++), TYPE_UNION,\n                    &lexer_line, union_fields, NULL);\n \n   /* Create the field and give it the new fake union type.  Add a \"desc\"\n@@ -993,16 +1060,16 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \n   nodot = create_string_option (NULL, \"dot\", \"\");\n \n-  rtx_tp = create_pointer (find_structure (\"rtx_def\", 0));\n-  rtvec_tp = create_pointer (find_structure (\"rtvec_def\", 0));\n-  tree_tp = create_pointer (find_structure (\"tree_node\", 1));\n-  mem_attrs_tp = create_pointer (find_structure (\"mem_attrs\", 0));\n+  rtx_tp = create_pointer (find_structure (\"rtx_def\", TYPE_STRUCT));\n+  rtvec_tp = create_pointer (find_structure (\"rtvec_def\", TYPE_STRUCT));\n+  tree_tp = create_pointer (find_structure (\"tree_node\", TYPE_UNION));\n+  mem_attrs_tp = create_pointer (find_structure (\"mem_attrs\", TYPE_STRUCT));\n   reg_attrs_tp = \n-    create_pointer (find_structure (\"reg_attrs\", 0));\n+    create_pointer (find_structure (\"reg_attrs\", TYPE_STRUCT));\n   basic_block_tp = \n-    create_pointer (find_structure (\"basic_block_def\", 0));\n+    create_pointer (find_structure (\"basic_block_def\", TYPE_STRUCT));\n   constant_tp =\n-    create_pointer (find_structure (\"constant_descriptor_rtx\", 0));\n+    create_pointer (find_structure (\"constant_descriptor_rtx\", TYPE_STRUCT));\n   scalar_tp = &scalar_nonchar;\t/* rtunion int */\n \n   {\n@@ -1042,7 +1109,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t  note_flds->opt = \n \t    create_string_option (nodot, \"tag\", note_insn_name[c]);\n       }\n-    note_union_tp = new_structure (\"rtx_def_note_subunion\", 1,\n+    note_union_tp = new_structure (\"rtx_def_note_subunion\", TYPE_UNION,\n \t\t\t\t   &lexer_line, note_flds, NULL);\n   }\n   /* Create a type to represent the various forms of SYMBOL_REF_DATA.  */\n@@ -1052,7 +1119,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n     sym_flds->opt = create_string_option (nodot, \"default\", \"\");\n     sym_flds = create_field (sym_flds, constant_tp, \"rt_constant\");\n     sym_flds->opt = create_string_option (nodot, \"tag\", \"1\");\n-    symbol_union_tp = new_structure (\"rtx_def_symbol_subunion\", 1,\n+    symbol_union_tp = new_structure (\"rtx_def_symbol_subunion\", TYPE_UNION,\n \t\t\t\t     &lexer_line, sym_flds, NULL);\n   }\n   for (i = 0; i < NUM_RTX_CODE; i++)\n@@ -1185,22 +1252,24 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t{\n \t  /* Add the \"block_sym\" field if SYMBOL_REF_HAS_BLOCK_INFO_P\n \t     holds.  */\n-\t  type_p field_tp = find_structure (\"block_symbol\", 0);\n+\t  type_p field_tp = find_structure (\"block_symbol\", TYPE_STRUCT);\n \t  subfields\n \t    = create_optional_field (subfields, field_tp, \"block_sym\",\n \t\t\t\t     \"SYMBOL_REF_HAS_BLOCK_INFO_P (&%0)\");\n \t}\n \n       sname = xasprintf (\"rtx_def_%s\", rtx_name[i]);\n-      substruct = new_structure (sname, 0, &lexer_line, subfields, NULL);\n+      substruct = new_structure (sname, TYPE_STRUCT, &lexer_line, subfields,\n+\t\t\t\t NULL);\n \n       ftag = xstrdup (rtx_name[i]);\n       for (nmindex = 0; nmindex < strlen (ftag); nmindex++)\n \tftag[nmindex] = TOUPPER (ftag[nmindex]);\n       flds = create_field (flds, substruct, \"\");\n       flds->opt = create_string_option (nodot, \"tag\", ftag);\n     }\n-  return new_structure (\"rtx_def_subunion\", 1, &lexer_line, flds, nodot);\n+  return new_structure (\"rtx_def_subunion\", TYPE_UNION, &lexer_line, flds,\n+\t\t\tnodot);\n }\n \n /* Handle `special(\"tree_exp\")'.  This is a special case for\n@@ -1229,7 +1298,8 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n \t\t\t\t    \"TREE_OPERAND_LENGTH ((tree) &%0)\");\n   flds->opt = create_string_option (flds->opt, \"default\", \"\");\n \n-  return new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n+  return new_structure (\"tree_exp_subunion\", TYPE_UNION, &lexer_line, flds,\n+\t\t\tnodot);\n }\n \n /* Perform any special processing on a type T, about to become the type\n@@ -1275,8 +1345,8 @@ adjust_field_type (type_p t, options_p opt)\n       {\n \tint num = ISDIGIT (opt->name[5]) ? opt->name[5] - '0' : 0;\n \n-\tif (!UNION_OR_STRUCT_P (t)\n-\t    && (t->kind != TYPE_POINTER || !UNION_OR_STRUCT_P (t->u.p)))\n+\tif (!union_or_struct_p (t)\n+\t    && (t->kind != TYPE_POINTER || !union_or_struct_p (t->u.p)))\n \t  {\n \t    error_at_line (&lexer_line,\n \t\t\t   \"option `%s' may only be applied to structures or structure pointers\",\n@@ -1369,6 +1439,7 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n     {\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n+    case TYPE_USER_STRUCT:\n       {\n \tpair_p f;\n \tint dummy;\n@@ -1468,7 +1539,7 @@ static outf_p\n create_file (const char *name, const char *oname)\n {\n   static const char *const hdr[] = {\n-    \"   Copyright (C) 2004, 2007, 2009 Free Software Foundation, Inc.\\n\",\n+    \"   Copyright (C) 2004, 2007, 2009, 2012 Free Software Foundation, Inc.\\n\",\n     \"\\n\",\n     \"This file is part of GCC.\\n\",\n     \"\\n\",\n@@ -2176,7 +2247,6 @@ close_output_files (void)\n \n   for (of = output_files; of; of = of->next)\n     {\n-\n       if (!is_file_equal (of))\n \t{\n \t  FILE *newfile = NULL;\n@@ -2303,9 +2373,38 @@ struct walk_type_data\n   bool fn_wants_lvalue;\n   bool in_record_p;\n   int loopcounter;\n+  bool in_ptr_field;\n   bool have_this_obj;\n };\n \n+\n+/* Given a string TYPE_NAME, representing a C++ typename, return a valid\n+   pre-processor identifier to use in a #define directive.  This replaces\n+   special characters used in C++ identifiers like '>', '<' and ':' with\n+   '_'.\n+\n+   If no C++ special characters are found in TYPE_NAME, return\n+   TYPE_NAME.  Otherwise, return a copy of TYPE_NAME with the special\n+   characters replaced with '_'.  In this case, the caller is\n+   responsible for freeing the allocated string.  */\n+\n+static const char *\n+filter_type_name (const char *type_name)\n+{\n+  if (strchr (type_name, '<') || strchr (type_name, ':'))\n+    {\n+      size_t i;\n+      char *s = xstrdup (type_name);\n+      for (i = 0; i < strlen (s); i++)\n+\tif (s[i] == '<' || s[i] == '>' || s[i] == ':')\n+\t  s[i] = '_';\n+      return s;\n+    }\n+  else\n+    return type_name;\n+}\n+\n+\n /* Print a mangled name representing T to OF.  */\n \n static void\n@@ -2332,8 +2431,14 @@ output_mangled_typename (outf_p of, const_type_p t)\n       case TYPE_STRUCT:\n       case TYPE_UNION:\n       case TYPE_LANG_STRUCT:\n-\toprintf (of, \"%lu%s\", (unsigned long) strlen (t->u.s.tag),\n-\t\t t->u.s.tag);\n+      case TYPE_USER_STRUCT:\n+\t{\n+\t  const char *id_for_tag = filter_type_name (t->u.s.tag);\n+\t  oprintf (of, \"%lu%s\", (unsigned long) strlen (id_for_tag),\n+\t\t   id_for_tag);\n+\t  if (id_for_tag != t->u.s.tag)\n+\t    free (CONST_CAST(char *, id_for_tag));\n+\t}\n \tbreak;\n       case TYPE_PARAM_STRUCT:\n \t{\n@@ -2390,6 +2495,7 @@ output_escaped_param (struct walk_type_data *d, const char *param,\n \t}\n }\n \n+\n /* Call D->PROCESS_FIELD for every field (or subfield) of D->VAL,\n    which is of type T.  Write code to D->OF to constrain execution (at\n    the point that D->PROCESS_FIELD is called) to the appropriate\n@@ -2470,7 +2576,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n       if (pointer_p)\n \tt = t->u.p;\n-      if (!UNION_OR_STRUCT_P (t))\n+      if (!union_or_struct_p (t))\n \terror_at_line (d->line, \"`use_params' option on unimplemented type\");\n       else\n \tt = find_param_structure (t, d->param);\n@@ -2498,7 +2604,7 @@ walk_type (type_p t, struct walk_type_data *d)\n     }\n \n   if (maybe_undef_p\n-      && (t->kind != TYPE_POINTER || !UNION_OR_STRUCT_P (t->u.p)))\n+      && (t->kind != TYPE_POINTER || !union_or_struct_p (t->u.p)))\n     {\n       error_at_line (d->line,\n \t\t     \"field `%s' has invalid option `maybe_undef_p'\\n\",\n@@ -2521,6 +2627,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n     case TYPE_POINTER:\n       {\n+\td->in_ptr_field = true;\n \tif (maybe_undef_p && t->u.p->u.s.line.file == NULL)\n \t  {\n \t    oprintf (d->of, \"%*sgcc_assert (!%s);\\n\", d->indent, \"\", d->val);\n@@ -2548,7 +2655,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n \tif (!length)\n \t  {\n-\t    if (!UNION_OR_STRUCT_P (t->u.p)\n+\t    if (!union_or_struct_p (t->u.p)\n \t\t&& t->u.p->kind != TYPE_PARAM_STRUCT)\n \t      {\n \t\terror_at_line (d->line,\n@@ -2561,7 +2668,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t      {\n \t\tconst char *oldprevval2 = d->prev_val[2];\n \n-\t\tif (!UNION_OR_STRUCT_P (nested_ptr_d->type))\n+\t\tif (!union_or_struct_p (nested_ptr_d->type))\n \t\t  {\n \t\t    error_at_line (d->line,\n \t\t\t\t   \"field `%s' has invalid \"\n@@ -2638,6 +2745,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    d->indent -= 2;\n \t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n \t  }\n+\td->in_ptr_field = false;\n       }\n       break;\n \n@@ -2921,6 +3029,10 @@ walk_type (type_p t, struct walk_type_data *d)\n       }\n       break;\n \n+    case TYPE_USER_STRUCT:\n+      d->process_field (t, d);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -2978,7 +3090,7 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n \t      oprintf (d->of, \", gt_e_\");\n \t      output_mangled_typename (d->of, f);\n \t    }\n-\t  else if (UNION_OR_STRUCT_P (f) && f->u.p->u.s.line.file != NULL)\n+\t  else if (union_or_struct_p (f) && f->u.p->u.s.line.file != NULL)\n \t    {\n \t      oprintf (d->of, \", gt_ggc_e_\");\n \t      output_mangled_typename (d->of, f);\n@@ -2998,13 +3110,27 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n     case TYPE_PARAM_STRUCT:\n-      oprintf (d->of, \"%*sgt_%s_\", d->indent, \"\", wtd->prefix);\n-      output_mangled_typename (d->of, f);\n-      oprintf (d->of, \" (%s%s);\\n\", cast, d->val);\n-      if (d->reorder_fn && wtd->reorder_note_routine)\n-\toprintf (d->of, \"%*s%s (%s%s, %s%s, %s);\\n\", d->indent, \"\",\n-\t\t wtd->reorder_note_routine, cast, d->val, cast, d->val,\n-\t\t d->reorder_fn);\n+    case TYPE_USER_STRUCT:\n+      if (f->kind == TYPE_USER_STRUCT && !d->in_ptr_field)\n+\t{\n+\t  /* If F is a user-defined type and the field is not a\n+\t     pointer to the type, then we should not generate the\n+\t     standard pointer-marking code.  All we need to do is call\n+\t     the user-provided marking function to process the fields\n+\t     of F.  */\n+\t  oprintf (d->of, \"%*sgt_%sx (&(%s));\\n\", d->indent, \"\", wtd->prefix,\n+\t\t   d->val);\n+\t}\n+      else\n+\t{\n+\t  oprintf (d->of, \"%*sgt_%s_\", d->indent, \"\", wtd->prefix);\n+\t  output_mangled_typename (d->of, f);\n+\t  oprintf (d->of, \" (%s%s);\\n\", cast, d->val);\n+\t  if (d->reorder_fn && wtd->reorder_note_routine)\n+\t    oprintf (d->of, \"%*s%s (%s%s, %s%s, %s);\\n\", d->indent, \"\",\n+\t\t     wtd->reorder_note_routine, cast, d->val, cast, d->val,\n+\t\t     d->reorder_fn);\n+\t}\n       break;\n \n     case TYPE_SCALAR:\n@@ -3025,7 +3151,7 @@ output_type_enum (outf_p of, type_p s)\n       oprintf (of, \", gt_e_\");\n       output_mangled_typename (of, s);\n     }\n-  else if (UNION_OR_STRUCT_P (s) && s->u.s.line.file != NULL)\n+  else if (union_or_struct_p (s) && s->u.s.line.file != NULL)\n     {\n       oprintf (of, \", gt_ggc_e_\");\n       output_mangled_typename (of, s);\n@@ -3043,27 +3169,199 @@ get_output_file_for_structure (const_type_p s, type_p *param)\n   const input_file *fn;\n   int i;\n \n-  gcc_assert (UNION_OR_STRUCT_P (s));\n+  gcc_assert (union_or_struct_p (s));\n   fn = s->u.s.line.file;\n \n   /* This is a hack, and not the good kind either.  */\n   for (i = NUM_PARAM - 1; i >= 0; i--)\n     if (param && param[i] && param[i]->kind == TYPE_POINTER\n-\t&& UNION_OR_STRUCT_P (param[i]->u.p))\n+\t&& union_or_struct_p (param[i]->u.p))\n       fn = param[i]->u.p->u.s.line.file;\n \n   /* The call to get_output_file_with_visibility may update fn by\n      caching its result inside, so we need the CONST_CAST.  */\n   return get_output_file_with_visibility (CONST_CAST (input_file*, fn));\n }\n \n+\n+/* Returns the specifier keyword for a string or union type S, empty string\n+   otherwise.  */\n+\n+static const char *\n+get_type_specifier (const type_p s)\n+{\n+  if (s->kind == TYPE_STRUCT)\n+    return \"struct \";\n+  else if (s->kind == TYPE_LANG_STRUCT)\n+    return get_type_specifier (s->u.s.lang_struct);\n+  else if (s->kind == TYPE_UNION)\n+    return \"union \";\n+  return \"\";\n+}\n+\n+\n+/* Emits a declaration for type TY (assumed to be a union or a\n+   structure) on stream OUT.  */\n+\n+static void\n+write_type_decl (outf_p out, type_p ty)\n+{\n+  if (union_or_struct_p (ty))\n+    oprintf (out, \"%s%s\", get_type_specifier (ty), ty->u.s.tag);\n+  else if (ty->kind == TYPE_SCALAR)\n+    {\n+      if (ty->u.scalar_is_char)\n+\toprintf (out, \"const char\");\n+      else\n+\toprintf (out, \"void\");\n+    }\n+  else if (ty->kind == TYPE_POINTER)\n+    {\n+      write_type_decl (out, ty->u.p);\n+      oprintf (out, \" *\");\n+    }\n+  else if (ty->kind == TYPE_ARRAY)\n+    {\n+      write_type_decl (out, ty->u.a.p);\n+      oprintf (out, \" *\");\n+    }\n+  else if (ty->kind == TYPE_STRING)\n+    {\n+      oprintf (out, \"const char *\");\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* Write on OF the name of the marker function for structure S. PREFIX\n+   is the prefix to use (to distinguish ggc from pch markers).  */\n+\n+static void\n+write_marker_function_name (outf_p of, type_p s, const char *prefix)\n+{\n+  if (union_or_struct_p (s))\n+    {\n+      const char *id_for_tag = filter_type_name (s->u.s.tag);\n+      oprintf (of, \"gt_%sx_%s\", prefix, id_for_tag);\n+      if (id_for_tag != s->u.s.tag)\n+\tfree (CONST_CAST(char *, id_for_tag));\n+    }\n+  else if (s->kind == TYPE_PARAM_STRUCT)\n+    {\n+      oprintf (of, \"gt_%s_\", prefix);\n+      output_mangled_typename (of, s);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* Write on OF a user-callable routine to act as an entry point for\n+   the marking routine for S, generated by write_func_for_structure.\n+   PREFIX is the prefix to use to distinguish ggc and pch markers.  */\n+\n+static void\n+write_user_func_for_structure_ptr (outf_p of, type_p s, const char *prefix)\n+{\n+  /* Parameterized structures are not supported in user markers. There\n+     is no way for the marker function to know which specific type\n+     to use to generate the call to the void * entry point.  For\n+     instance, a marker for struct htab may need to call different\n+     routines to mark the fields, depending on the paramN_is attributes.\n+\n+     A user-defined marker that accepts 'struct htab' as its argument\n+     would not know which variant to call. Generating several entry\n+     points accepting 'struct htab' would cause multiply-defined\n+     errors during compilation.  */\n+  gcc_assert (union_or_struct_p (s));\n+\n+  type_p alias_of = NULL;\n+  for (options_p opt = s->u.s.opt; opt; opt = opt->next)\n+    if (strcmp (opt->name, \"ptr_alias\") == 0)\n+      {\n+\t/* ALIAS_OF is set if ORIG_S is marked \"ptr_alias\". This means that\n+\t   we do not generate marking code for ORIG_S here. Instead, a\n+\t   forwarder #define in gtype-desc.h will cause every call to its\n+\t   marker to call the target of this alias.\n+\n+\t   However, we still want to create a user entry code for the\n+\t   aliased type. So, if ALIAS_OF is set, we only generate the\n+\t   user-callable marker function.  */\n+\talias_of = opt->info.type;\n+\tbreak;\n+      }\n+\n+  oprintf (of, \"\\nvoid\\n\");\n+  oprintf (of, \"gt_%sx (\", prefix);\n+  write_type_decl (of, s);\n+  oprintf (of, \" *& x)\\n\");\n+  oprintf (of, \"{\\n\");\n+  oprintf (of, \"  if (x)\\n    \");\n+  write_marker_function_name (of, alias_of ? alias_of : s, prefix);\n+  oprintf (of, \" ((void *) x);\\n\");\n+  oprintf (of, \"}\\n\");\n+}\n+\n+\n+/* Write a function to mark all the fields of type S on OF.  PREFIX\n+   and D are as in write_user_marking_functions.  */\n+\n+static void\n+write_user_func_for_structure_body (type_p s, const char *prefix,\n+\t\t\t\t    struct walk_type_data *d)\n+{\n+  oprintf (d->of, \"\\nvoid\\n\");\n+  oprintf (d->of, \"gt_%sx (\", prefix);\n+  write_type_decl (d->of, s);\n+  oprintf (d->of, \"& x_r ATTRIBUTE_UNUSED)\\n\");\n+  oprintf (d->of, \"{\\n\");\n+  oprintf (d->of, \"  \");\n+  write_type_decl (d->of, s);\n+  oprintf (d->of, \" * ATTRIBUTE_UNUSED x = &x_r;\\n\");\n+  d->val = \"(*x)\";\n+  d->indent = 2;\n+  walk_type (s, d);\n+  oprintf (d->of, \"}\\n\");\n+}\n+\n+\n+/* Emit the user-callable functions needed to mark all the types used\n+   by the user structure S.  PREFIX is the prefix to use to\n+   distinguish ggc and pch markers.  D contains data needed to pass to\n+   walk_type when traversing the fields of a type.\n+\n+   For every type T referenced by S, two routines are generated: one\n+   that takes 'T *', marks the pointer and calls the second routine,\n+   which just marks the fields of T.  */\n+\n+static void\n+write_user_marking_functions (type_p s, const char *prefix,\n+\t\t\t      struct walk_type_data *d)\n+{\n+  gcc_assert (s->kind == TYPE_USER_STRUCT);\n+\n+  for (pair_p fld = s->u.s.fields; fld; fld = fld->next)\n+    {\n+      type_p fld_type = fld->type;\n+      if (fld_type->kind == TYPE_POINTER)\n+\t{\n+\t  type_p pointed_to_type = fld_type->u.p;\n+\t  if (union_or_struct_p (pointed_to_type))\n+\t    write_user_func_for_structure_ptr (d->of, pointed_to_type, prefix);\n+\t}\n+      else if (union_or_struct_p (fld_type))\n+\twrite_user_func_for_structure_body (fld_type, prefix, d);\n+    }\n+}\n+\n+\n /* For S, a structure that's part of ORIG_S, and using parameters\n    PARAM, write out a routine that:\n    - Takes a parameter, a void * but actually of type *S\n    - If SEEN_ROUTINE returns nonzero, calls write_types_process_field on each\n    field of S or its substructures and (in some cases) things\n-   that are pointed to by S.\n-*/\n+   that are pointed to by S.  */\n \n static void\n write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n@@ -3113,22 +3411,19 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \n   oprintf (d.of, \"\\n\");\n   oprintf (d.of, \"void\\n\");\n-  if (param == NULL)\n-    oprintf (d.of, \"gt_%sx_%s\", wtd->prefix, orig_s->u.s.tag);\n-  else\n-    {\n-      oprintf (d.of, \"gt_%s_\", wtd->prefix);\n-      output_mangled_typename (d.of, orig_s);\n-    }\n+  write_marker_function_name (d.of, orig_s, wtd->prefix);\n   oprintf (d.of, \" (void *x_p)\\n\");\n-  oprintf (d.of, \"{\\n\");\n-  oprintf (d.of, \"  %s %s * %sx = (%s %s *)x_p;\\n\",\n-\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n-\t   chain_next == NULL ? \"const \" : \"\",\n-\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+  oprintf (d.of, \"{\\n  \");\n+  write_type_decl (d.of, s);\n+  oprintf (d.of, \" * %sx = (\", chain_next == NULL ? \"const \" : \"\");\n+  write_type_decl (d.of, s);\n+  oprintf (d.of, \" *)x_p;\\n\");\n   if (chain_next != NULL)\n-    oprintf (d.of, \"  %s %s * xlimit = x;\\n\",\n-\t     s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+    {\n+      oprintf (d.of, \"  \");\n+      write_type_decl (d.of, s);\n+      oprintf (d.of, \" * xlimit = x;\\n\");\n+    }\n   if (chain_next == NULL)\n     {\n       oprintf (d.of, \"  if (%s (x\", wtd->marker_routine);\n@@ -3211,9 +3506,17 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n     {\n       oprintf (d.of, \"      %s (x);\\n\", mark_hook_name);\n     }\n+  \n   d.prev_val[2] = \"*x\";\n   d.indent = 6;\n-  walk_type (s, &d);\n+  if (orig_s->kind != TYPE_USER_STRUCT)\n+    walk_type (s, &d);\n+  else\n+    {\n+      /* User structures have no fields to walk. Simply generate a call\n+\t to the user-provided structure marker.  */\n+      oprintf (d.of, \"%*sgt_%sx (x);\\n\", d.indent, \"\", wtd->prefix);\n+    }\n \n   if (chain_next != NULL)\n     {\n@@ -3226,8 +3529,12 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n   if (chain_circular != NULL)\n     oprintf (d.of, \"  while (x != xlimit);\\n\");\n   oprintf (d.of, \"}\\n\");\n+\n+  if (orig_s->kind == TYPE_USER_STRUCT)\n+    write_user_marking_functions (orig_s, wtd->prefix, &d);\n }\n \n+\n /* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n@@ -3238,9 +3545,10 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n   type_p s;\n \n   oprintf (output_header, \"\\n/* %s*/\\n\", wtd->comment);\n+\n   /* We first emit the macros and the declarations. Functions' code is\n      emitted afterwards.  This is needed in plugin mode.  */\n-  oprintf (output_header, \"/* macros and declarations */\\n\");\n+  oprintf (output_header, \"/* Macros and declarations.  */\\n\");\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n       {\n@@ -3249,12 +3557,14 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \tif (s->gc_used == GC_MAYBE_POINTED_TO && s->u.s.line.file == NULL)\n \t  continue;\n \n+\tconst char *s_id_for_tag = filter_type_name (s->u.s.tag);\n+\n \toprintf (output_header, \"#define gt_%s_\", wtd->prefix);\n \toutput_mangled_typename (output_header, s);\n \toprintf (output_header, \"(X) do { \\\\\\n\");\n \toprintf (output_header,\n \t\t \"  if (X != NULL) gt_%sx_%s (X);\\\\\\n\", wtd->prefix,\n-\t\t s->u.s.tag);\n+\t\t s_id_for_tag);\n \toprintf (output_header, \"  } while (0)\\n\");\n \n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n@@ -3264,9 +3574,14 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t      const_type_p const t = (const_type_p) opt->info.type;\n \t      if (t->kind == TYPE_STRUCT\n \t\t  || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)\n-\t\toprintf (output_header,\n-\t\t\t \"#define gt_%sx_%s gt_%sx_%s\\n\",\n-\t\t\t wtd->prefix, s->u.s.tag, wtd->prefix, t->u.s.tag);\n+\t\t{\n+\t\t  const char *t_id_for_tag = filter_type_name (t->u.s.tag);\n+\t\t  oprintf (output_header,\n+\t\t\t   \"#define gt_%sx_%s gt_%sx_%s\\n\",\n+\t\t\t   wtd->prefix, s->u.s.tag, wtd->prefix, t_id_for_tag);\n+\t\t  if (t_id_for_tag != t->u.s.tag)\n+\t\t    free (CONST_CAST(char *, t_id_for_tag));\n+\t\t}\n \t      else\n \t\terror_at_line (&s->u.s.line,\n \t\t\t       \"structure alias is not a structure\");\n@@ -3278,7 +3593,10 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t/* Declare the marker procedure only once.  */\n \toprintf (output_header,\n \t\t \"extern void gt_%sx_%s (void *);\\n\",\n-\t\t wtd->prefix, s->u.s.tag);\n+\t\t wtd->prefix, s_id_for_tag);\n+\n+\tif (s_id_for_tag != s->u.s.tag)\n+\t  free (CONST_CAST(char *, s_id_for_tag));\n \n \tif (s->u.s.line.file == NULL)\n \t  {\n@@ -3400,6 +3718,90 @@ static const struct write_types_data pch_wtd = {\n \n /* Write out the local pointer-walking routines.  */\n \n+/* process_field routine for local pointer-walking for user-callable\n+   routines.  The difference between this and\n+   write_types_local_process_field is that, in this case, we do not\n+   need to check whether the given pointer matches the address of the\n+   parent structure.  This check was already generated by the call\n+   to gt_pch_nx in the main gt_pch_p_*() function that is calling\n+   this code.  */\n+\n+static void\n+write_types_local_user_process_field (type_p f, const struct walk_type_data *d)\n+{\n+  switch (f->kind)\n+    {\n+    case TYPE_POINTER:\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+    case TYPE_PARAM_STRUCT:\n+    case TYPE_STRING:\n+      oprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+      break;\n+\n+    case TYPE_USER_STRUCT:\n+      if (d->in_ptr_field)\n+\toprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+      else\n+\toprintf (d->of, \"%*s  gt_pch_nx (&(%s), op, cookie);\\n\",\n+\t\t d->indent, \"\", d->val);\n+      break;\n+\n+    case TYPE_SCALAR:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Write a function to PCH walk all the fields of type S on OF.\n+   D contains data needed by walk_type to recurse into the fields of S.  */\n+\n+static void\n+write_pch_user_walking_for_structure_body (type_p s, struct walk_type_data *d)\n+{\n+  oprintf (d->of, \"\\nvoid\\n\");\n+  oprintf (d->of, \"gt_pch_nx (\");\n+  write_type_decl (d->of, s);\n+  oprintf (d->of, \"* x ATTRIBUTE_UNUSED,\\n\"\n+\t   \"\\tATTRIBUTE_UNUSED gt_pointer_operator op,\\n\"\n+\t   \"\\tATTRIBUTE_UNUSED void *cookie)\\n\");\n+  oprintf (d->of, \"{\\n\");\n+  d->val = \"(*x)\";\n+  d->indent = 2;\n+  d->process_field = write_types_local_user_process_field;\n+  walk_type (s, d);\n+  oprintf (d->of, \"}\\n\");\n+}\n+\n+\n+/* Emit the user-callable functions needed to mark all the types used\n+   by the user structure S.  PREFIX is the prefix to use to\n+   distinguish ggc and pch markers. CHAIN_NEXT is set if S has the\n+   chain_next option defined.  D contains data needed to pass to\n+   walk_type when traversing the fields of a type.\n+\n+   For every type T referenced by S, two routines are generated: one\n+   that takes 'T *', marks the pointer and calls the second routine,\n+   which just marks the fields of T.  */\n+\n+static void\n+write_pch_user_walking_functions (type_p s, struct walk_type_data *d)\n+{\n+  gcc_assert (s->kind == TYPE_USER_STRUCT);\n+\n+  for (pair_p fld = s->u.s.fields; fld; fld = fld->next)\n+    {\n+      type_p fld_type = fld->type;\n+      if (union_or_struct_p (fld_type))\n+\twrite_pch_user_walking_for_structure_body (fld_type, d);\n+    }\n+}\n+\n+\n /* process_field routine for local pointer-walking.  */\n \n static void\n@@ -3419,6 +3821,16 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n       oprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n       break;\n \n+    case TYPE_USER_STRUCT:\n+      oprintf (d->of, \"%*sif ((void *)(%s) == this_obj)\\n\", d->indent, \"\",\n+\t       d->prev_val[3]);\n+      if (d->in_ptr_field)\n+\toprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+      else\n+\toprintf (d->of, \"%*s  gt_pch_nx (&(%s), op, cookie);\\n\",\n+\t\t d->indent, \"\", d->val);\n+      break;\n+\n     case TYPE_SCALAR:\n       break;\n \n@@ -3427,6 +3839,7 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n     }\n }\n \n+\n /* For S, a structure that's part of ORIG_S, and using parameters\n    PARAM, write out a routine that:\n    - Is of type gt_note_pointers\n@@ -3460,13 +3873,29 @@ write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n \t   \"\\tATTRIBUTE_UNUSED gt_pointer_operator op,\\n\"\n \t   \"\\tATTRIBUTE_UNUSED void *cookie)\\n\");\n   oprintf (d.of, \"{\\n\");\n-  oprintf (d.of, \"  %s %s * const x ATTRIBUTE_UNUSED = (%s %s *)x_p;\\n\",\n+  oprintf (d.of, \"  %s %s * x ATTRIBUTE_UNUSED = (%s %s *)x_p;\\n\",\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n   d.indent = 2;\n   d.have_this_obj = true;\n-  walk_type (s, &d);\n+\n+  if (s->kind != TYPE_USER_STRUCT)\n+    walk_type (s, &d);\n+  else\n+    {\n+      /* User structures have no fields to walk. Simply generate a\n+\t call to the user-provided PCH walker.  */\n+      oprintf (d.of, \"%*sif ((void *)(%s) == this_obj)\\n\", d.indent, \"\",\n+\t       d.prev_val[3]);\n+      oprintf (d.of, \"%*s  gt_pch_nx (&(%s), op, cookie);\\n\",\n+\t       d.indent, \"\", d.val);\n+    }\n+\n   oprintf (d.of, \"}\\n\");\n+\n+  /* Write user-callable entry points for the PCH walking routines.  */\n+  if (orig_s->kind == TYPE_USER_STRUCT)\n+    write_pch_user_walking_functions (s, &d);\n }\n \n /* Write out local marker routines for STRUCTURES and PARAM_STRUCTS.  */\n@@ -3478,6 +3907,7 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \n   if (!output_header)\n     return;\n+\n   oprintf (output_header, \"\\n/* Local pointer-walking routines.  */\\n\");\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n@@ -3557,15 +3987,15 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n /* Nonzero if S is a type for which typed GC allocators should be output.  */\n \n #define USED_BY_TYPED_GC_P(s)\t\t\t\t\t\t\\\n-  (((s->kind == TYPE_POINTER)\t\t\t\t\t\t\\\n-    && ((s->u.p->gc_used == GC_POINTED_TO)\t\t\t\t\\\n-\t|| (s->u.p->gc_used == GC_USED)))\t\t\t\t\\\n-   || (UNION_OR_STRUCT_P (s) &&\t\t\t\t\t\t\\\n-       (((s)->gc_used == GC_POINTED_TO)\t\t\t\t\t\\\n-\t|| ((s)->gc_used == GC_MAYBE_POINTED_TO\t\t\t\t\\\n-\t    && s->u.s.line.file != NULL)\t\t\t\t\\\n-\t|| ((s)->gc_used == GC_USED\t\t\t\t\t\\\n-\t    && strncmp (s->u.s.tag, \"anonymous\", strlen (\"anonymous\"))))))\n+  ((s->kind == TYPE_POINTER\t\t\t\t\t\t\\\n+    && (s->u.p->gc_used == GC_POINTED_TO\t\t\t\t\\\n+\t|| s->u.p->gc_used == GC_USED))\t\t\t\t\t\\\n+   || (union_or_struct_p (s)   \t\t\t\t\t\t\\\n+       && ((s)->gc_used == GC_POINTED_TO\t\t\t\t\\\n+\t   || ((s)->gc_used == GC_MAYBE_POINTED_TO\t\t\t\\\n+\t       && s->u.s.line.file != NULL)\t\t\t\t\\\n+\t   || ((s)->gc_used == GC_USED\t\t\t\t\t\\\n+\t       && strncmp (s->u.s.tag, \"anonymous\", strlen (\"anonymous\"))))))\n \n \n /* Write out the 'enum' definition for gt_types_enum.  */\n@@ -3587,7 +4017,7 @@ write_enum_defn (type_p structures, type_p param_structs)\n \tnbstruct++;\n \tDBGPRINTF (\"write_enum_defn s @ %p nbstruct %d\",\n \t\t   (void*) s, nbstruct);\n-\tif (UNION_OR_STRUCT_P (s))\n+\tif (union_or_struct_p (s))\n \t  DBGPRINTF (\"write_enum_defn s %p #%d is unionorstruct tagged %s\",\n \t\t     (void*) s, nbstruct, s->u.s.tag);\n \toprintf (header_file, \" gt_ggc_e_\");\n@@ -3873,6 +4303,11 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n       }\n       break;\n \n+    case TYPE_USER_STRUCT:\n+      write_root (f, v, type->u.a.p, name, has_length, line, if_marked,\n+\t\t  emit_pch);\n+      break;\n+\n     case TYPE_POINTER:\n       {\n \ttype_p tp;\n@@ -3882,13 +4317,16 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n \ttp = type->u.p;\n \n-\tif (!has_length && UNION_OR_STRUCT_P (tp))\n+\tif (!has_length && union_or_struct_p (tp))\n \t  {\n-\t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", tp->u.s.tag);\n+\t    const char *id_for_tag = filter_type_name (tp->u.s.tag);\n+\t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", id_for_tag);\n \t    if (emit_pch)\n-\t      oprintf (f, \"    &gt_pch_nx_%s\", tp->u.s.tag);\n+\t      oprintf (f, \"    &gt_pch_nx_%s\", id_for_tag);\n \t    else\n \t      oprintf (f, \"    NULL\");\n+\t    if (id_for_tag != tp->u.s.tag)\n+\t      free (CONST_CAST(char *, id_for_tag));\n \t  }\n \telse if (!has_length && tp->kind == TYPE_PARAM_STRUCT)\n \t  {\n@@ -3903,7 +4341,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t      oprintf (f, \",\\n    NULL\");\n \t  }\n \telse if (has_length\n-\t\t && (tp->kind == TYPE_POINTER || UNION_OR_STRUCT_P (tp)))\n+\t\t && (tp->kind == TYPE_POINTER || union_or_struct_p (tp)))\n \t  {\n \t    oprintf (f, \"    &gt_ggc_ma_%s,\\n\", name);\n \t    if (emit_pch)\n@@ -4146,7 +4584,8 @@ write_roots (pair_p variables, bool emit_pch)\n \tcontinue;\n       if (v->type->kind != TYPE_POINTER\n \t  || v->type->u.p->kind != TYPE_PARAM_STRUCT\n-\t  || v->type->u.p->u.param_struct.stru != find_structure (\"htab\", 0))\n+\t  || v->type->u.p->u.param_struct.stru != find_structure (\"htab\",\n+\t                                                          TYPE_STRUCT))\n \t{\n \t  error_at_line (&v->line,\n \t\t\t \"if_marked option used but not hash table\");\n@@ -4249,96 +4688,6 @@ write_roots (pair_p variables, bool emit_pch)\n   finish_root_table (flp, \"pch_rs\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_pch_scalar_rtab\");\n }\n-/* Record the definition of the vec_prefix structure, as defined in vec.h:\n-\n-   struct vec_prefix GTY(()) {\n-   unsigned num;\n-   unsigned alloc;\n-   };  */\n-static type_p\n-vec_prefix_type (void)\n-{\n-  static type_p prefix_type = NULL;\n-  if (prefix_type == NULL)\n-    {\n-      pair_p fields;\n-      static struct fileloc pos = { NULL, 0 };\n-      type_p len_ty = create_scalar_type (\"unsigned\");\n-      pos.file = input_file_by_name (__FILE__); pos.line = __LINE__;\n-      fields = create_field_at (0, len_ty, \"alloc\", 0, &pos);\n-      fields = create_field_at (fields, len_ty, \"num\", 0, &pos);\n-      prefix_type = new_structure (\"vec_prefix\", 0, &pos, fields, 0);\n-      prefix_type->u.s.bitmap = -1;\n-    }\n-  return prefix_type;\n-}\n-\n-/* Record the definition of a generic VEC structure, as if we had expanded\n-   the macros in vec.h:\n-\n-   typedef struct VEC_<type>_base GTY(()) {\n-   struct vec_prefix prefix;\n-   <type> GTY((length (\"%h.prefix.num\"))) vec[1];\n-   } VEC_<type>_base\n-\n-   where the GTY(()) tags are only present if is_scalar is _false_.  */\n-\n-void\n-note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n-{\n-  pair_p fields;\n-  type_p t;\n-  options_p o;\n-  const char *name = concat (\"VEC_\", type_name, \"_base\", (char *) 0);\n-\n-  if (is_scalar)\n-    {\n-      t = create_scalar_type (type_name);\n-      o = 0;\n-    }\n-  else\n-    {\n-      t = resolve_typedef (type_name, pos);\n-      o = create_string_option (0, \"length\", \"%h.prefix.num\");\n-    }\n-  /* We assemble the field list in reverse order.  */\n-  fields = create_field_at (0, create_array (t, \"1\"), \"vec\", o, pos);\n-  fields = create_field_at (fields, vec_prefix_type (), \"prefix\", 0, pos);\n-\n-  do_typedef (name, new_structure (name, 0, pos, fields, 0), pos);\n-}\n-\n-/* Record the definition of an allocation-specific VEC structure, as if\n-   we had expanded the macros in vec.h:\n-\n-   typedef struct VEC_<type>_<astrat> {\n-     VEC_<type>_base base;\n-   } VEC_<type>_<astrat>;\n-*/\n-void\n-note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n-{\n-  const char *astratname = concat (\"VEC_\", type, \"_\", astrat, (char *) 0);\n-  const char *basename = concat (\"VEC_\", type, \"_base\", (char *) 0);\n-\n-  pair_p field = create_field_at (0, resolve_typedef (basename, pos),\n-\t\t\t\t  \"base\", 0, pos);\n-\n-  do_typedef (astratname, new_structure (astratname, 0, pos, field, 0), pos);\n-}\n-\n-/* Returns the specifier keyword for a string or union type S, empty string\n-   otherwise.  */\n-\n-static const char *\n-get_type_specifier (const type_p s)\n-{\n-  if (s->kind == TYPE_STRUCT || s->kind == TYPE_LANG_STRUCT)\n-    return \"struct \";\n-  if (s->kind == TYPE_UNION)\n-    return \"union \";\n-  return \"\";\n-}\n \n /* TRUE if type S has the GTY variable_size annotation.  */\n \n@@ -4375,7 +4724,8 @@ write_typed_alloc_def (outf_p f,\n   bool third_arg = ((zone == specific_zone)\n \t\t    && (variable_size || (quantity == vector)));\n   gcc_assert (f != NULL);\n-  oprintf (f, \"#define ggc_alloc_%s%s\", allocator_type, type_name);\n+  const char *type_name_as_id = filter_type_name (type_name);\n+  oprintf (f, \"#define ggc_alloc_%s%s\", allocator_type, type_name_as_id);\n   oprintf (f, \"(%s%s%s%s%s) \",\n \t   (variable_size ? \"SIZE\" : \"\"),\n \t   (two_args ? \", \" : \"\"),\n@@ -4392,6 +4742,8 @@ write_typed_alloc_def (outf_p f,\n   if (quantity == vector)\n     oprintf (f, \", n\");\n   oprintf (f, \" MEM_STAT_INFO)))\\n\");\n+  if (type_name_as_id != type_name)\n+    free (CONST_CAST(char *, type_name_as_id));\n }\n \n /* Writes a typed allocator definition into output F for a struct or\n@@ -4403,7 +4755,7 @@ write_typed_struct_alloc_def (outf_p f,\n \t\t\t      enum alloc_quantity quantity,\n \t\t\t      enum alloc_zone zone)\n {\n-  gcc_assert (UNION_OR_STRUCT_P (s));\n+  gcc_assert (union_or_struct_p (s));\n   write_typed_alloc_def (f, variable_size_p (s), get_type_specifier (s),\n                          s->u.s.tag, allocator_type, quantity, zone);\n }\n@@ -4438,7 +4790,7 @@ write_typed_alloc_defns (outf_p f,\n     {\n       if (!USED_BY_TYPED_GC_P (s))\n \tcontinue;\n-      gcc_assert (UNION_OR_STRUCT_P (s));\n+      gcc_assert (union_or_struct_p (s));\n       /* In plugin mode onput output ggc_alloc macro definitions\n \t relevant to plugin input files.  */\n       if (nb_plugin_files > 0 \n@@ -4502,6 +4854,7 @@ output_typename (outf_p of, const_type_p t)\n       output_typename (of, t->u.p);\n       break;\n     case TYPE_STRUCT:\n+    case TYPE_USER_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n       oprintf (of, \"%s\", t->u.s.tag);\n@@ -4560,10 +4913,6 @@ write_splay_tree_allocators (const_type_p param_structs)\n       }\n }\n \n-static void dump_pair (int indent, pair_p p);\n-static void dump_type (int indent, type_p p);\n-static void dump_type_list (int indent, type_p p);\n-\n #define INDENT 2\n \n /* Dumps the value of typekind KIND.  */\n@@ -4583,6 +4932,9 @@ dump_typekind (int indent, enum typekind kind)\n     case TYPE_STRUCT:\n       printf (\"TYPE_STRUCT\");\n       break;\n+    case TYPE_USER_STRUCT:\n+      printf (\"TYPE_USER_STRUCT\");\n+      break;\n     case TYPE_UNION:\n       printf (\"TYPE_UNION\");\n       break;\n@@ -4678,8 +5030,7 @@ dump_type_u_s (int indent, type_p t)\n {\n   pair_p fields;\n \n-  gcc_assert (t->kind == TYPE_STRUCT || t->kind == TYPE_UNION\n-\t      || t->kind == TYPE_LANG_STRUCT);\n+  gcc_assert (union_or_struct_p (t));\n   printf (\"%*cu.s.tag = %s\\n\", indent, ' ', t->u.s.tag);\n   dump_fileloc (indent, t->u.s.line);\n   printf (\"%*cu.s.fields =\\n\", indent, ' ');\n@@ -4750,6 +5101,9 @@ dump_type (int indent, type_p t)\n {\n   PTR *slot;\n \n+  if (seen_types == NULL)\n+    seen_types = htab_create (100, htab_hash_pointer, htab_eq_pointer, NULL);\n+\n   printf (\"%*cType at %p: \", indent, ' ', (void *) t);\n   slot = htab_find_slot (seen_types, t, INSERT);\n   if (*slot != NULL)\n@@ -4775,6 +5129,7 @@ dump_type (int indent, type_p t)\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n+    case TYPE_USER_STRUCT:\n       dump_type_u_s (indent + INDENT, t);\n       break;\n     case TYPE_POINTER:\n@@ -4834,11 +5189,12 @@ dump_structures (const char *name, type_p structures)\n static void\n dump_everything (void)\n {\n-  seen_types = htab_create (100, htab_hash_pointer, htab_eq_pointer, NULL);\n   dump_pair_list (\"typedefs\", typedefs);\n   dump_structures (\"structures\", structures);\n   dump_structures (\"param_structs\", param_structs);\n   dump_pair_list (\"variables\", variables);\n+\n+  /* Allocated with the first call to dump_type.  */\n   htab_delete (seen_types);\n }\n \f"}, {"sha": "4a178ec3967e552e9df07425c247776db6bb6183", "filename": "gcc/gengtype.h", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,5 +1,5 @@\n /* Process source files and output type information.\n-   Copyright (C) 2002, 2003, 2004, 2007, 2008, 2010, 2011 \n+   Copyright (C) 2002, 2003, 2004, 2007, 2008, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -143,11 +143,14 @@ enum typekind {\n   TYPE_LANG_STRUCT,     /* GCC front-end language specific structs.\n                            Various languages may have homonymous but\n                            different structs.  */\n-  TYPE_PARAM_STRUCT     /* Type for parametrized structs, e.g. hash_t\n+  TYPE_PARAM_STRUCT,    /* Type for parametrized structs, e.g. hash_t\n                            hash-tables, ...  See (param_is, use_param,\n                            param1_is, param2_is,... use_param1,\n                            use_param_2,... use_params) GTY\n                            options.  */\n+  TYPE_USER_STRUCT\t/* User defined type.  Walkers and markers for\n+\t\t\t   this type are assumed to be provided by the\n+\t\t\t   user.  */\n };\n \n /* Discriminating kind for options.  */\n@@ -319,27 +322,35 @@ extern struct type scalar_char;\n \n /* Test if a type is a union, either a plain one or a language\n    specific one.  */\n-#define UNION_P(x)                                      \\\n-    ((x)->kind == TYPE_UNION ||                         \\\n-     ((x)->kind == TYPE_LANG_STRUCT                     \\\n-      && (x)->u.s.lang_struct->kind == TYPE_UNION))\n+#define UNION_P(x)\t\t\t\t\t\\\n+    ((x)->kind == TYPE_UNION\t\t\t\t\\\n+     || ((x)->kind == TYPE_LANG_STRUCT\t\t\t\\\n+         && (x)->u.s.lang_struct->kind == TYPE_UNION))\n \n /* Test if a type is a union or a structure, perhaps a language\n    specific one.  */\n-#define UNION_OR_STRUCT_P(x)\t\t\t\\\n-    ((x)->kind == TYPE_UNION \t\t\t\\\n-     || (x)->kind == TYPE_STRUCT\t\t\\\n-     || (x)->kind == TYPE_LANG_STRUCT)\n-\n+static inline bool\n+union_or_struct_p (enum typekind kind)\n+{\n+  return (kind == TYPE_UNION\n+\t  || kind == TYPE_STRUCT\n+          || kind == TYPE_LANG_STRUCT\n+\t  || kind == TYPE_USER_STRUCT);\n+}\n \n+static inline bool\n+union_or_struct_p (const_type_p x)\n+{\n+  return union_or_struct_p (x->kind);\n+}\n \n /* Give the file location of a type, if any. */\n static inline struct fileloc* \n type_fileloc (type_p t)\n {\n   if (!t) \n     return NULL;\n-  if (UNION_OR_STRUCT_P(t))\n+  if (union_or_struct_p (t))\n     return &t->u.s.line;\n   if  (t->kind == TYPE_PARAM_STRUCT)\n     return &t->u.param_struct.line;\n@@ -410,10 +421,10 @@ extern char *xasprintf (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n extern void do_scalar_typedef (const char *s, struct fileloc *pos);\n extern type_p resolve_typedef (const char *s, struct fileloc *pos);\n-extern type_p new_structure (const char *name, int isunion,\n+extern type_p new_structure (const char *name, enum typekind kind,\n \t\t\t     struct fileloc *pos, pair_p fields,\n \t\t\t     options_p o);\n-extern type_p find_structure (const char *s, int isunion);\n+extern type_p find_structure (const char *s, enum typekind kind);\n extern type_p create_scalar_type (const char *name);\n extern type_p create_pointer (type_p t);\n extern type_p create_array (type_p t, const char *len);\n@@ -424,10 +435,6 @@ extern pair_p nreverse_pairs (pair_p list);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n \t\t\t   struct fileloc *pos);\n-extern void note_def_vec (const char *type_name, bool is_scalar,\n-\t\t\t  struct fileloc *pos);\n-extern void note_def_vec_alloc (const char *type, const char *astrat,\n-\t\t\t\tstruct fileloc *pos);\n \n /* Lexer and parser routines.  */\n extern int yylex (const char **yylval);\n@@ -453,12 +460,10 @@ enum\n     STRUCT,\n     ENUM,\n     VEC_TOKEN,\n-    DEFVEC_OP,\n-    DEFVEC_I,\n-    DEFVEC_ALLOC,\n     ELLIPSIS,\n     PTR_ALIAS,\n     NESTED_PTR,\n+    USER_GTY,\n     PARAM_IS,\n     NUM,\n     SCALAR,"}, {"sha": "ca3f6325fa9f83a877af0ca8d7508bf3ef06ae36", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1441,6 +1441,26 @@ gt_ggc_m_S (const void *p)\n   return;\n }\n \n+\n+/* User-callable entry points for marking string X.  */\n+\n+void\n+gt_ggc_mx (const char *& x)\n+{\n+  gt_ggc_m_S (x);\n+}\n+\n+void\n+gt_ggc_mx (unsigned char *& x)\n+{\n+  gt_ggc_m_S (x);\n+}\n+\n+void\n+gt_ggc_mx (unsigned char& x ATTRIBUTE_UNUSED)\n+{\n+}\n+\n /* If P is not marked, marks it and return false.  Otherwise return true.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */"}, {"sha": "2cf7167518292aea777a041cb2bcff91d6b337d0", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1508,6 +1508,26 @@ gt_ggc_m_S (const void *p)\n   ggc_set_mark (p);\n }\n \n+\n+/* User-callable entry points for marking string X.  */\n+\n+void\n+gt_ggc_mx (const char *& x)\n+{\n+  gt_ggc_m_S (x);\n+}\n+\n+void\n+gt_ggc_mx (unsigned char *& x)\n+{\n+  gt_ggc_m_S (x);\n+}\n+\n+void\n+gt_ggc_mx (unsigned char& x ATTRIBUTE_UNUSED)\n+{\n+}\n+\n /* If P is not marked, mark it and return false.  Otherwise return true.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */"}, {"sha": "5f25a580b182d6e844e9aee440bb053c4981c3a9", "filename": "gcc/ggc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -32,9 +32,6 @@ extern const char empty_string[];\t/* empty string */\n /* Internal functions and data structures used by the GTY\n    machinery, including the generated gt*.[hc] files.  */\n \n-/* The first parameter is a pointer to a pointer, the second a cookie.  */\n-typedef void (*gt_pointer_operator) (void *, void *);\n-\n #include \"gtype-desc.h\"\n \n /* One of these applies its third parameter (with cookie in the fourth"}, {"sha": "7a51e8c271ca0cbd113bc8ac9e7b9a9a255d895a", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -121,7 +121,7 @@ lower_function_body (void)\n   if (gimple_seq_may_fallthru (lowered_body)\n       && (VEC_empty (return_statements_t, data.return_statements)\n \t  || gimple_return_retval (VEC_last (return_statements_t,\n-\t\t\t           data.return_statements)->stmt) != NULL))\n+\t\t\t           data.return_statements).stmt) != NULL))\n     {\n       x = gimple_build_return (NULL);\n       gimple_set_location (x, cfun->function_end_locus);\n@@ -137,7 +137,7 @@ lower_function_body (void)\n \n       /* Unfortunately, we can't use VEC_pop because it returns void for\n \t objects.  */\n-      t = *VEC_last (return_statements_t, data.return_statements);\n+      t = VEC_last (return_statements_t, data.return_statements);\n       VEC_truncate (return_statements_t,\n \t  \t    data.return_statements,\n \t  \t    VEC_length (return_statements_t,\n@@ -835,7 +835,7 @@ lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n   for (i = VEC_length (return_statements_t, data->return_statements) - 1;\n        i >= 0; i--)\n     {\n-      tmp_rs = *VEC_index (return_statements_t, data->return_statements, i);\n+      tmp_rs = VEC_index (return_statements_t, data->return_statements, i);\n \n       if (gimple_return_retval (stmt) == gimple_return_retval (tmp_rs.stmt))\n \t{"}, {"sha": "ed2474fe390844581772696fc715878e95c2ee15", "filename": "gcc/gimplify.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -2116,15 +2116,15 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t\tfallback_t fallback)\n {\n   tree *p;\n-  VEC(tree,heap) *stack;\n+  VEC(tree,heap) *expr_stack;\n   enum gimplify_status ret = GS_ALL_DONE, tret;\n   int i;\n   location_t loc = EXPR_LOCATION (*expr_p);\n   tree expr = *expr_p;\n \n   /* Create a stack of the subexpressions so later we can walk them in\n      order from inner to outer.  */\n-  stack = VEC_alloc (tree, heap, 10);\n+  expr_stack = VEC_alloc (tree, heap, 10);\n \n   /* We can handle anything that get_inner_reference can deal with.  */\n   for (p = expr_p; ; p = &TREE_OPERAND (*p, 0))\n@@ -2144,13 +2144,13 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       else\n \tbreak;\n \n-      VEC_safe_push (tree, heap, stack, *p);\n+      VEC_safe_push (tree, heap, expr_stack, *p);\n     }\n \n-  gcc_assert (VEC_length (tree, stack));\n+  gcc_assert (VEC_length (tree, expr_stack));\n \n-  /* Now STACK is a stack of pointers to all the refs we've walked through\n-     and P points to the innermost expression.\n+  /* Now EXPR_STACK is a stack of pointers to all the refs we've\n+     walked through and P points to the innermost expression.\n \n      Java requires that we elaborated nodes in source order.  That\n      means we must gimplify the inner expression followed by each of\n@@ -2161,9 +2161,9 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n      So we do this in three steps.  First we deal with the annotations\n      for any variables in the components, then we gimplify the base,\n      then we gimplify any indices, from left to right.  */\n-  for (i = VEC_length (tree, stack) - 1; i >= 0; i--)\n+  for (i = VEC_length (tree, expr_stack) - 1; i >= 0; i--)\n     {\n-      tree t = VEC_index (tree, stack, i);\n+      tree t = VEC_index (tree, expr_stack, i);\n \n       if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n@@ -2256,9 +2256,9 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n   /* And finally, the indices and operands of ARRAY_REF.  During this\n      loop we also remove any useless conversions.  */\n-  for (; VEC_length (tree, stack) > 0; )\n+  for (; VEC_length (tree, expr_stack) > 0; )\n     {\n-      tree t = VEC_pop (tree, stack);\n+      tree t = VEC_pop (tree, expr_stack);\n \n       if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n@@ -2286,7 +2286,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       canonicalize_component_ref (expr_p);\n     }\n \n-  VEC_free (tree, heap, stack);\n+  VEC_free (tree, heap, expr_stack);\n \n   gcc_assert (*expr_p == expr || ret != GS_ALL_DONE);\n \n@@ -3845,7 +3845,7 @@ optimize_compound_literals_in_ctor (tree orig_ctor)\n \n   for (idx = 0; idx < num; idx++)\n     {\n-      tree value = VEC_index (constructor_elt, elts, idx)->value;\n+      tree value = VEC_index (constructor_elt, elts, idx).value;\n       tree newval = value;\n       if (TREE_CODE (value) == CONSTRUCTOR)\n \tnewval = optimize_compound_literals_in_ctor (value);\n@@ -3869,7 +3869,7 @@ optimize_compound_literals_in_ctor (tree orig_ctor)\n \t  CONSTRUCTOR_ELTS (ctor) = VEC_copy (constructor_elt, gc, elts);\n \t  elts = CONSTRUCTOR_ELTS (ctor);\n \t}\n-      VEC_index (constructor_elt, elts, idx)->value = newval;\n+      VEC_index (constructor_elt, elts, idx).value = newval;\n     }\n   return ctor;\n }\n@@ -4120,8 +4120,8 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \t/* Extract the real and imaginary parts out of the ctor.  */\n \tgcc_assert (VEC_length (constructor_elt, elts) == 2);\n-\tr = VEC_index (constructor_elt, elts, 0)->value;\n-\ti = VEC_index (constructor_elt, elts, 1)->value;\n+\tr = VEC_index (constructor_elt, elts, 0).value;\n+\ti = VEC_index (constructor_elt, elts, 1).value;\n \tif (r == NULL || i == NULL)\n \t  {\n \t    tree zero = build_zero_cst (TREE_TYPE (type));"}, {"sha": "d3a6e29a9ec5439d0f8457e59e6ba0df28d4cd98", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,3 +1,11 @@\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.  Configury.\n+\n+\t* go-c.h: Remove all handlers of ENABLE_BUILD_WITH_CXX.\n+\t* go-gcc.cc: Likewise.\n+\t* go-system.h: Likewise.\n+\n 2012-07-24  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* go-lang.c (lang_decl): Add variable_size GTY option."}, {"sha": "a7f7b1fe2f2f81d2cda27facb331b49693cd81bb", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -20,16 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GO_GO_C_H\n #define GO_GO_C_H\n \n-#ifdef ENABLE_BUILD_WITH_CXX\n #define GO_EXTERN_C\n-#else\n-#define GO_EXTERN_C extern \"C\"\n-#endif\n-\n-#if defined(__cplusplus) && !defined(ENABLE_BUILD_WITH_CXX)\n-extern \"C\"\n-{\n-#endif\n \n #include \"machmode.h\"\n \n@@ -71,8 +62,4 @@ extern const char *go_read_export_data (int, off_t, char **, size_t *, int *);\n \n extern GTY(()) tree go_non_zero_struct;\n \n-#if defined(__cplusplus) && !defined(ENABLE_BUILD_WITH_CXX)\n-} /* End extern \"C\".  */\n-#endif\n-\n #endif /* !defined(GO_GO_C_H) */"}, {"sha": "84bc97297ba96a28a6d5d6279fbd40b145eb897e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -24,20 +24,11 @@\n // include it here before tree.h includes it later.\n #include <gmp.h>\n \n-#ifndef ENABLE_BUILD_WITH_CXX\n-extern \"C\"\n-{\n-#endif\n-\n #include \"tree.h\"\n #include \"tree-iterator.h\"\n #include \"gimple.h\"\n #include \"toplev.h\"\n \n-#ifndef ENABLE_BUILD_WITH_CXX\n-}\n-#endif\n-\n #include \"go-c.h\"\n \n #include \"gogo.h\""}, {"sha": "2decc555df5999f2491260829692c2ff22f39556", "filename": "gcc/go/go-system.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2Fgo-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgo%2Fgo-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-system.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -134,11 +134,6 @@ struct hash<T*>\n // later.\n #include <cstdio>\n \n-#ifndef ENABLE_BUILD_WITH_CXX\n-extern \"C\"\n-{\n-#endif\n-\n #include \"system.h\"\n #include \"ansidecl.h\"\n #include \"coretypes.h\"\n@@ -147,10 +142,6 @@ extern \"C\"\n #include \"input.h\"\t\t/* For source_location.  */\n #include \"intl.h\"\t\t/* For _().  */\n \n-#ifndef ENABLE_BUILD_WITH_CXX\n-} // End extern \"C\"\n-#endif\n-\n // When using gcc, go_assert is just gcc_assert.\n #define go_assert(EXPR) gcc_assert(EXPR)\n "}, {"sha": "f53be25800464c8536b02bcc99d831c8f00d9889", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1249,7 +1249,7 @@ build_sese_conditions_before (struct dom_walk_data *dw_data,\n       if (e->flags & EDGE_TRUE_VALUE)\n \tVEC_safe_push (gimple, heap, *cases, stmt);\n       else\n-\tVEC_safe_push (gimple, heap, *cases, NULL);\n+\tVEC_safe_push (gimple, heap, *cases, (gimple) NULL);\n     }\n \n   gbb = gbb_from_bb (bb);"}, {"sha": "7909a9894868f4c3a890bbc075ad99cc5c7a447d", "filename": "gcc/hash-table.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fhash-table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fhash-table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -0,0 +1,190 @@\n+/* A type-safe hash table template.\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Lawrence Crowl <crowl@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* This file implements a typed hash table.\n+   The implementation borrows from libiberty's hashtab.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"hash-table.h\"\n+\n+\n+/* Table of primes and multiplicative inverses.\n+\n+   Note that these are not minimally reduced inverses.  Unlike when generating\n+   code to divide by a constant, we want to be able to use the same algorithm\n+   all the time.  All of these inverses (are implied to) have bit 32 set.\n+\n+   For the record, here's the function that computed the table; it's a \n+   vastly simplified version of the function of the same name from gcc.  */\n+\n+#if 0\n+unsigned int\n+ceil_log2 (unsigned int x)\n+{\n+  int i;\n+  for (i = 31; i >= 0 ; --i)\n+    if (x > (1u << i))\n+      return i+1;\n+  abort ();\n+}\n+\n+unsigned int\n+choose_multiplier (unsigned int d, unsigned int *mlp, unsigned char *shiftp)\n+{\n+  unsigned long long mhigh;\n+  double nx;\n+  int lgup, post_shift;\n+  int pow, pow2;\n+  int n = 32, precision = 32;\n+\n+  lgup = ceil_log2 (d);\n+  pow = n + lgup;\n+  pow2 = n + lgup - precision;\n+\n+  nx = ldexp (1.0, pow) + ldexp (1.0, pow2);\n+  mhigh = nx / d;\n+\n+  *shiftp = lgup - 1;\n+  *mlp = mhigh;\n+  return mhigh >> 32;\n+}\n+#endif\n+\n+struct prime_ent const prime_tab[] = {\n+  {          7, 0x24924925, 0x9999999b, 2 },\n+  {         13, 0x3b13b13c, 0x745d1747, 3 },\n+  {         31, 0x08421085, 0x1a7b9612, 4 },\n+  {         61, 0x0c9714fc, 0x15b1e5f8, 5 },\n+  {        127, 0x02040811, 0x0624dd30, 6 },\n+  {        251, 0x05197f7e, 0x073260a5, 7 },\n+  {        509, 0x01824366, 0x02864fc8, 8 },\n+  {       1021, 0x00c0906d, 0x014191f7, 9 },\n+  {       2039, 0x0121456f, 0x0161e69e, 10 },\n+  {       4093, 0x00300902, 0x00501908, 11 },\n+  {       8191, 0x00080041, 0x00180241, 12 },\n+  {      16381, 0x000c0091, 0x00140191, 13 },\n+  {      32749, 0x002605a5, 0x002a06e6, 14 },\n+  {      65521, 0x000f00e2, 0x00110122, 15 },\n+  {     131071, 0x00008001, 0x00018003, 16 },\n+  {     262139, 0x00014002, 0x0001c004, 17 },\n+  {     524287, 0x00002001, 0x00006001, 18 },\n+  {    1048573, 0x00003001, 0x00005001, 19 },\n+  {    2097143, 0x00004801, 0x00005801, 20 },\n+  {    4194301, 0x00000c01, 0x00001401, 21 },\n+  {    8388593, 0x00001e01, 0x00002201, 22 },\n+  {   16777213, 0x00000301, 0x00000501, 23 },\n+  {   33554393, 0x00001381, 0x00001481, 24 },\n+  {   67108859, 0x00000141, 0x000001c1, 25 },\n+  {  134217689, 0x000004e1, 0x00000521, 26 },\n+  {  268435399, 0x00000391, 0x000003b1, 27 },\n+  {  536870909, 0x00000019, 0x00000029, 28 },\n+  { 1073741789, 0x0000008d, 0x00000095, 29 },\n+  { 2147483647, 0x00000003, 0x00000007, 30 },\n+  /* Avoid \"decimal constant so large it is unsigned\" for 4294967291.  */\n+  { 0xfffffffb, 0x00000006, 0x00000008, 31 }\n+};\n+\n+/* The following function returns an index into the above table of the\n+   nearest prime number which is greater than N, and near a power of two. */\n+\n+unsigned int\n+hash_table_higher_prime_index (unsigned long n)\n+{\n+  unsigned int low = 0;\n+  unsigned int high = sizeof(prime_tab) / sizeof(prime_tab[0]);\n+\n+  while (low != high)\n+    {\n+      unsigned int mid = low + (high - low) / 2;\n+      if (n > prime_tab[mid].prime)\n+\tlow = mid + 1;\n+      else\n+\thigh = mid;\n+    }\n+\n+  /* If we've run out of primes, abort.  */\n+  if (n > prime_tab[low].prime)\n+    {\n+      fprintf (stderr, \"Cannot find prime bigger than %lu\\n\", n);\n+      abort ();\n+    }\n+\n+  return low;\n+}\n+\n+/* Return X % Y using multiplicative inverse values INV and SHIFT.\n+\n+   The multiplicative inverses computed above are for 32-bit types,\n+   and requires that we be able to compute a highpart multiply.\n+\n+   FIX: I am not at all convinced that\n+     3 loads, 2 multiplications, 3 shifts, and 3 additions\n+   will be faster than\n+     1 load and 1 modulus\n+   on modern systems running a compiler.  */\n+\n+#ifdef UNSIGNED_64BIT_TYPE\n+static inline hashval_t\n+mul_mod (hashval_t x, hashval_t y, hashval_t inv, int shift)\n+{\n+  __extension__ typedef UNSIGNED_64BIT_TYPE ull;\n+   hashval_t t1, t2, t3, t4, q, r;\n+\n+   t1 = ((ull)x * inv) >> 32;\n+   t2 = x - t1;\n+   t3 = t2 >> 1;\n+   t4 = t1 + t3;\n+   q  = t4 >> shift;\n+   r  = x - (q * y);\n+\n+   return r;\n+}\n+#endif\n+\n+/* Compute the primary table index for HASH given current prime index.  */\n+\n+hashval_t\n+hash_table_mod1 (hashval_t hash, unsigned int index)\n+{\n+  const struct prime_ent *p = &prime_tab[index];\n+#ifdef UNSIGNED_64BIT_TYPE\n+  if (sizeof (hashval_t) * CHAR_BIT <= 32)\n+    return mul_mod (hash, p->prime, p->inv, p->shift);\n+#endif\n+  return hash % p->prime;\n+}\n+\n+\n+/* Compute the secondary table index for HASH given current prime index.  */\n+\n+hashval_t\n+hash_table_mod2 (hashval_t hash, unsigned int index)\n+{\n+  const struct prime_ent *p = &prime_tab[index];\n+#ifdef UNSIGNED_64BIT_TYPE\n+  if (sizeof (hashval_t) * CHAR_BIT <= 32)\n+    return 1 + mul_mod (hash, p->prime - 2, p->inv_m2, p->shift);\n+#endif\n+  return 1 + hash % (p->prime - 2);\n+}"}, {"sha": "2c483e2b858185f4ab7f09c120ea9345e55f39ab", "filename": "gcc/hash-table.h", "status": "added", "additions": 783, "deletions": 0, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -0,0 +1,783 @@\n+/* A type-safe hash table template.\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Lawrence Crowl <crowl@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* This file implements a typed hash table.\n+   The implementation borrows from libiberty's hashtab.  */\n+\n+\n+#ifndef TYPED_HASHTAB_H\n+#define TYPED_HASHTAB_H\n+\n+#include \"hashtab.h\"\n+\n+\n+/* The ordinary memory allocator.  */\n+/* FIXME (crowl): This allocator may be extracted for wider sharing later.  */\n+\n+template <typename Type>\n+struct xcallocator\n+{\n+  static Type *control_alloc (size_t count);\n+  static Type *data_alloc (size_t count);\n+  static void control_free (Type *memory);\n+  static void data_free (Type *memory);\n+};\n+\n+\n+/* Allocate memory for COUNT control blocks.  */\n+\n+template <typename Type>\n+inline Type *\n+xcallocator <Type>::control_alloc (size_t count)\n+{\n+  return static_cast <Type *> (xcalloc (count, sizeof (Type)));\n+}\n+\n+\n+/* Allocate memory for COUNT data blocks.  */ \n+\n+template <typename Type>\n+inline Type *\n+xcallocator <Type>::data_alloc (size_t count)\n+{\n+  return static_cast <Type *> (xcalloc (count, sizeof (Type)));\n+}\n+\n+\n+/* Free memory for control blocks.  */\n+\n+template <typename Type>\n+inline void\n+xcallocator <Type>::control_free (Type *memory)\n+{\n+  return ::free (memory);\n+}\n+  \n+\n+/* Free memory for data blocks.  */\n+\n+template <typename Type>\n+inline void\n+xcallocator <Type>::data_free (Type *memory)\n+{\n+  return ::free (memory);\n+}\n+\n+\n+/* A common function for hashing a CANDIDATE typed pointer.  */\n+\n+template <typename Element>\n+inline hashval_t\n+typed_pointer_hash (const Element *candidate)\n+{\n+  /* This is a really poor hash function, but it is what the current code uses,\n+     so I am reusing it to avoid an additional axis in testing.  */\n+  return (hashval_t) ((intptr_t)candidate >> 3);\n+}\n+\n+\n+/* A common function for comparing an EXISTING and CANDIDATE typed pointers\n+   for equality. */\n+\n+template <typename Element>\n+inline int\n+typed_pointer_equal (const Element *existing, const Element * candidate)\n+{\n+  return existing == candidate;\n+}\n+\n+\n+/* A common function for doing nothing on removing a RETIRED slot.  */\n+\n+template <typename Element>\n+inline void\n+typed_null_remove (Element *retired ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+\n+/* A common function for using free on removing a RETIRED slot.  */\n+\n+template <typename Element>\n+inline void\n+typed_free_remove (Element *retired)\n+{\n+  free (retired);\n+}\n+\n+\n+/* Table of primes and their inversion information.  */\n+\n+struct prime_ent\n+{\n+  hashval_t prime;\n+  hashval_t inv;\n+  hashval_t inv_m2;     /* inverse of prime-2 */\n+  hashval_t shift;\n+};\n+\n+extern struct prime_ent const prime_tab[];\n+\n+\n+/* Functions for computing hash table indexes.  */\n+\n+extern unsigned int hash_table_higher_prime_index (unsigned long n);\n+extern hashval_t hash_table_mod1 (hashval_t hash, unsigned int index);\n+extern hashval_t hash_table_mod2 (hashval_t hash, unsigned int index);\n+\n+\n+/* Internal implementation type.  */\n+\n+template <typename Element>\n+struct hash_table_control\n+{\n+  /* Table itself.  */\n+  Element **entries;\n+\n+  /* Current size (in entries) of the hash table.  */\n+  size_t size;\n+\n+  /* Current number of elements including also deleted elements.  */\n+  size_t n_elements;\n+\n+  /* Current number of deleted elements in the table.  */\n+  size_t n_deleted;\n+\n+  /* The following member is used for debugging. Its value is number\n+     of all calls of `htab_find_slot' for the hash table. */\n+  unsigned int searches;\n+\n+  /* The following member is used for debugging.  Its value is number\n+     of collisions fixed for time of work with the hash table. */\n+  unsigned int collisions;\n+\n+  /* Current size (in entries) of the hash table, as an index into the\n+     table of primes.  */\n+  unsigned int size_prime_index;\n+};\n+\n+\n+/* User-facing hash table type.\n+\n+   The table stores elements of type Element.\n+\n+   It hashes elements with the Hash function.\n+     The table currently works with relatively weak hash functions.\n+     Use typed_pointer_hash <Element> when hashing pointers instead of objects.\n+\n+   It compares elements with the Equal function.\n+     Two elements with the same hash may not be equal.\n+     Use typed_pointer_equal <Element> when hashing pointers instead of objects.\n+\n+   It removes elements with the Remove function.\n+     This feature is useful for freeing memory.\n+     Use typed_null_remove <Element> when not freeing objects.\n+     Use typed_free_remove <Element> when doing a simple object free.\n+\n+   Use the Allocator template to allocate and free memory.\n+     The default is xcallocator.\n+\n+*/\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator = xcallocator>\n+class hash_table\n+{\n+\n+private:\n+\n+  hash_table_control <Element> *htab;\n+\n+  Element **find_empty_slot_for_expand (hashval_t hash);\n+  void expand ();\n+\n+public:\n+\n+  hash_table ();\n+  void create (size_t initial_slots);\n+  bool is_created ();\n+  void dispose ();\n+  Element *find (Element *comparable);\n+  Element *find_with_hash (Element *comparable, hashval_t hash);\n+  Element **find_slot (Element *comparable, enum insert_option insert);\n+  Element **find_slot_with_hash (Element *comparable, hashval_t hash,\n+\t\t\t\t enum insert_option insert);\n+  void empty ();\n+  void clear_slot (Element **slot);\n+  void remove_elt (Element *comparable);\n+  void remove_elt_with_hash (Element *comparable, hashval_t hash);\n+  size_t size();\n+  size_t elements();\n+  double collisions();\n+\n+  template <typename Argument,\n+\t    int (*Callback) (Element **slot, Argument argument)>\n+  void traverse_noresize (Argument argument);\n+\n+  template <typename Argument,\n+\t    int (*Callback) (Element **slot, Argument argument)>\n+  void traverse (Argument argument);\n+};\n+\n+\n+/* Construct the hash table.  The only useful operation next is create.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline\n+hash_table <Element, Hash, Equal, Remove, Allocator>::hash_table ()\n+: htab (NULL)\n+{\n+}\n+\n+\n+/* See if the table has been created, as opposed to constructed.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline bool\n+hash_table <Element, Hash, Equal, Remove, Allocator>::is_created ()\n+{\n+  return htab != NULL;\n+}\n+\n+\n+/* Like find_with_hash, but compute the hash value from the element.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline Element *\n+hash_table <Element, Hash, Equal, Remove, Allocator>::find (Element *comparable)\n+{\n+  return find_with_hash (comparable, Hash (comparable));\n+}\n+\n+\n+/* Like find_slot_with_hash, but compute the hash value from the element.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline Element **\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::find_slot (Element *comparable, enum insert_option insert)\n+{\n+  return find_slot_with_hash (comparable, Hash (comparable), insert);\n+}\n+\n+\n+/* Like remove_elt_with_hash, but compute the hash value from the element.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline void\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::remove_elt (Element *comparable)\n+{\n+  remove_elt_with_hash (comparable, Hash (comparable));\n+}\n+\n+\n+/* Return the current size of this hash table.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline size_t\n+hash_table <Element, Hash, Equal, Remove, Allocator>::size()\n+{\n+  return htab->size;\n+}\n+\n+\n+/* Return the current number of elements in this hash table. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline size_t\n+hash_table <Element, Hash, Equal, Remove, Allocator>::elements()\n+{\n+  return htab->n_elements - htab->n_deleted;\n+}\n+\n+\n+  /* Return the fraction of fixed collisions during all work with given\n+     hash table. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+inline double\n+hash_table <Element, Hash, Equal, Remove, Allocator>::collisions()\n+{\n+  if (htab->searches == 0)\n+    return 0.0;\n+\n+  return static_cast <double> (htab->collisions) / htab->searches;\n+}\n+\n+\n+/* Create a hash table with at least the given number of INITIAL_SLOTS.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>::create (size_t size)\n+{\n+  unsigned int size_prime_index;\n+\n+  size_prime_index = hash_table_higher_prime_index (size);\n+  size = prime_tab[size_prime_index].prime;\n+\n+  htab = Allocator <hash_table_control <Element> > ::control_alloc (1);\n+  gcc_assert (htab != NULL);\n+  htab->entries = Allocator <Element*> ::data_alloc (size);\n+  gcc_assert (htab->entries != NULL);\n+  htab->size = size;\n+  htab->size_prime_index = size_prime_index;\n+}\n+\n+\n+/* Dispose of a hash table.  Free all memory and return this hash table to\n+   the non-created state.  Naturally the hash table must already exist.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>::dispose ()\n+{\n+  size_t size = htab->size;\n+  Element **entries = htab->entries;\n+\n+  for (int i = size - 1; i >= 0; i--)\n+    if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n+      Remove (entries[i]);\n+\n+  Allocator <Element *> ::data_free (entries);\n+  Allocator <hash_table_control <Element> > ::control_free (htab);\n+  htab = NULL;\n+}\n+\n+\n+/* Similar to find_slot, but without several unwanted side effects:\n+    - Does not call Equal when it finds an existing entry.\n+    - Does not change the count of elements/searches/collisions in the\n+      hash table.\n+   This function also assumes there are no deleted entries in the table.\n+   HASH is the hash value for the element to be inserted.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+Element **\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::find_empty_slot_for_expand (hashval_t hash)\n+{\n+  hashval_t index = hash_table_mod1 (hash, htab->size_prime_index);\n+  size_t size = htab->size;\n+  Element **slot = htab->entries + index;\n+  hashval_t hash2;\n+\n+  if (*slot == HTAB_EMPTY_ENTRY)\n+    return slot;\n+  else if (*slot == HTAB_DELETED_ENTRY)\n+    abort ();\n+\n+  hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n+  for (;;)\n+    {\n+      index += hash2;\n+      if (index >= size)\n+        index -= size;\n+\n+      slot = htab->entries + index;\n+      if (*slot == HTAB_EMPTY_ENTRY)\n+        return slot;\n+      else if (*slot == HTAB_DELETED_ENTRY)\n+        abort ();\n+    }\n+}\n+\n+\n+/* The following function changes size of memory allocated for the\n+   entries and repeatedly inserts the table elements.  The occupancy\n+   of the table after the call will be about 50%.  Naturally the hash\n+   table must already exist.  Remember also that the place of the\n+   table entries is changed.  If memory allocation fails, this function\n+   will abort.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>::expand ()\n+{\n+  Element **oentries;\n+  Element **olimit;\n+  Element **p;\n+  Element **nentries;\n+  size_t nsize, osize, elts;\n+  unsigned int oindex, nindex;\n+\n+  oentries = htab->entries;\n+  oindex = htab->size_prime_index;\n+  osize = htab->size;\n+  olimit = oentries + osize;\n+  elts = elements ();\n+\n+  /* Resize only when table after removal of unused elements is either\n+     too full or too empty.  */\n+  if (elts * 2 > osize || (elts * 8 < osize && osize > 32))\n+    {\n+      nindex = hash_table_higher_prime_index (elts * 2);\n+      nsize = prime_tab[nindex].prime;\n+    }\n+  else\n+    {\n+      nindex = oindex;\n+      nsize = osize;\n+    }\n+\n+  nentries = Allocator <Element *> ::data_alloc (nsize);\n+  gcc_assert (nentries != NULL);\n+  htab->entries = nentries;\n+  htab->size = nsize;\n+  htab->size_prime_index = nindex;\n+  htab->n_elements -= htab->n_deleted;\n+  htab->n_deleted = 0;\n+\n+  p = oentries;\n+  do\n+    {\n+      Element *x = *p;\n+\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n+        {\n+          Element **q = find_empty_slot_for_expand (Hash (x));\n+\n+          *q = x;\n+        }\n+\n+      p++;\n+    }\n+  while (p < olimit);\n+\n+  Allocator <Element *> ::data_free (oentries);\n+}\n+\n+\n+/* This function searches for a hash table entry equal to the given\n+   COMPARABLE element starting with the given HASH value.  It cannot\n+   be used to insert or delete an element. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+Element *\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::find_with_hash (Element *comparable, hashval_t hash)\n+{\n+  hashval_t index, hash2;\n+  size_t size;\n+  Element *entry;\n+\n+  htab->searches++;\n+  size = htab->size;\n+  index = hash_table_mod1 (hash, htab->size_prime_index);\n+\n+  entry = htab->entries[index];\n+  if (entry == HTAB_EMPTY_ENTRY\n+      || (entry != HTAB_DELETED_ENTRY && Equal (entry, comparable)))\n+    return entry;\n+\n+  hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n+  for (;;)\n+    {\n+      htab->collisions++;\n+      index += hash2;\n+      if (index >= size)\n+        index -= size;\n+\n+      entry = htab->entries[index];\n+      if (entry == HTAB_EMPTY_ENTRY\n+          || (entry != HTAB_DELETED_ENTRY && Equal (entry, comparable)))\n+        return entry;\n+    }\n+}\n+\n+\n+/* This function searches for a hash table slot containing an entry\n+   equal to the given COMPARABLE element and starting with the given\n+   HASH.  To delete an entry, call this with insert=NO_INSERT, then\n+   call clear_slot on the slot returned (possibly after doing some\n+   checks).  To insert an entry, call this with insert=INSERT, then\n+   write the value you want into the returned slot.  When inserting an\n+   entry, NULL may be returned if memory allocation fails. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+Element **\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::find_slot_with_hash (Element *comparable, hashval_t hash,\n+\t\t       enum insert_option insert)\n+{\n+  Element **first_deleted_slot;\n+  hashval_t index, hash2;\n+  size_t size;\n+  Element *entry;\n+\n+  size = htab->size;\n+  if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n+    {\n+      expand ();\n+      size = htab->size;\n+    }\n+\n+  index = hash_table_mod1 (hash, htab->size_prime_index);\n+\n+  htab->searches++;\n+  first_deleted_slot = NULL;\n+\n+  entry = htab->entries[index];\n+  if (entry == HTAB_EMPTY_ENTRY)\n+    goto empty_entry;\n+  else if (entry == HTAB_DELETED_ENTRY)\n+    first_deleted_slot = &htab->entries[index];\n+  else if (Equal (entry, comparable))\n+    return &htab->entries[index];\n+      \n+  hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n+  for (;;)\n+    {\n+      htab->collisions++;\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+      \n+      entry = htab->entries[index];\n+      if (entry == HTAB_EMPTY_ENTRY)\n+\tgoto empty_entry;\n+      else if (entry == HTAB_DELETED_ENTRY)\n+\t{\n+\t  if (!first_deleted_slot)\n+\t    first_deleted_slot = &htab->entries[index];\n+\t}\n+      else if (Equal (entry, comparable))\n+\treturn &htab->entries[index];\n+    }\n+\n+ empty_entry:\n+  if (insert == NO_INSERT)\n+    return NULL;\n+\n+  if (first_deleted_slot)\n+    {\n+      htab->n_deleted--;\n+      *first_deleted_slot = static_cast <Element *> (HTAB_EMPTY_ENTRY);\n+      return first_deleted_slot;\n+    }\n+\n+  htab->n_elements++;\n+  return &htab->entries[index];\n+}\n+\n+\n+/* This function clears all entries in the given hash table.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>::empty ()\n+{\n+  size_t size = htab_size (htab);\n+  Element **entries = htab->entries;\n+  int i;\n+\n+  for (i = size - 1; i >= 0; i--)\n+    if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n+      Remove (entries[i]);\n+\n+  /* Instead of clearing megabyte, downsize the table.  */\n+  if (size > 1024*1024 / sizeof (PTR))\n+    {\n+      int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n+      int nsize = prime_tab[nindex].prime;\n+\n+      Allocator <Element *> ::data_free (htab->entries);\n+      htab->entries = Allocator <Element *> ::data_alloc (nsize);\n+      htab->size = nsize;\n+      htab->size_prime_index = nindex;\n+    }\n+  else\n+    memset (entries, 0, size * sizeof (Element *));\n+  htab->n_deleted = 0;\n+  htab->n_elements = 0;\n+}\n+\n+\n+/* This function clears a specified SLOT in a hash table.  It is\n+   useful when you've already done the lookup and don't want to do it\n+   again. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::clear_slot (Element **slot)\n+{\n+  if (slot < htab->entries || slot >= htab->entries + htab->size\n+      || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n+    abort ();\n+\n+  Remove (*slot);\n+\n+  *slot = HTAB_DELETED_ENTRY;\n+  htab->n_deleted++;\n+}\n+\n+\n+/* This function deletes an element with the given COMPARABLE value\n+   from hash table starting with the given HASH.  If there is no\n+   matching element in the hash table, this function does nothing. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::remove_elt_with_hash (Element *comparable, hashval_t hash)\n+{\n+  Element **slot;\n+\n+  slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n+  if (*slot == HTAB_EMPTY_ENTRY)\n+    return;\n+\n+  Remove (*slot);\n+\n+  *slot = static_cast <Element *> (HTAB_DELETED_ENTRY);\n+  htab->n_deleted++;\n+}\n+\n+\n+/* This function scans over the entire hash table calling CALLBACK for\n+   each live entry.  If CALLBACK returns false, the iteration stops.\n+   ARGUMENT is passed as CALLBACK's second argument. */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+template <typename Argument,\n+\t  int (*Callback) (Element **slot, Argument argument)>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::traverse_noresize (Argument argument)\n+{\n+  Element **slot;\n+  Element **limit;\n+\n+  slot = htab->entries;\n+  limit = slot + htab->size;\n+\n+  do\n+    {\n+      Element *x = *slot;\n+\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n+        if (! Callback (slot, argument))\n+          break;\n+    }\n+  while (++slot < limit);\n+}\n+\n+\n+/* Like traverse_noresize, but does resize the table when it is too empty\n+   to improve effectivity of subsequent calls.  */\n+\n+template <typename Element,\n+\t  hashval_t (*Hash) (const Element *candidate),\n+\t  int (*Equal) (const Element *existing, const Element * candidate),\n+\t  void (*Remove) (Element *retired),\n+\t  template <typename Type> class Allocator>\n+template <typename Argument,\n+\t  int (*Callback) (Element **slot, Argument argument)>\n+void\n+hash_table <Element, Hash, Equal, Remove, Allocator>\n+::traverse (Argument argument)\n+{\n+  size_t size = htab->size;\n+  if (elements () * 8 < size && size > 32)\n+    expand ();\n+\n+  traverse_noresize <Argument, Callback> (argument);\n+}\n+\n+#endif /* TYPED_HASHTAB_H */"}, {"sha": "cd9b3f28b73b381b08ed72e9d6ebc60dbdf448df", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -345,12 +345,12 @@ discover_loop (hwloop_info loop, basic_block tail_bb, rtx tail_insn, rtx reg)\n }\n \n /* Analyze the structure of the loops in the current function.  Use\n-   STACK for bitmap allocations.  Returns all the valid candidates for\n+   LOOP_STACK for bitmap allocations.  Returns all the valid candidates for\n    hardware loops found in this function.  HOOKS is the argument\n    passed to reorg_loops, used here to find the iteration registers\n    from a loop_end pattern.  */\n static hwloop_info\n-discover_loops (bitmap_obstack *stack, struct hw_doloop_hooks *hooks)\n+discover_loops (bitmap_obstack *loop_stack, struct hw_doloop_hooks *hooks)\n {\n   hwloop_info loops = NULL;\n   hwloop_info loop;\n@@ -406,7 +406,7 @@ discover_loops (bitmap_obstack *stack, struct hw_doloop_hooks *hooks)\n       loops = loop;\n       loop->loop_no = nloops++;\n       loop->blocks = VEC_alloc (basic_block, heap, 20);\n-      loop->block_bitmap = BITMAP_ALLOC (stack);\n+      loop->block_bitmap = BITMAP_ALLOC (loop_stack);\n \n       if (dump_file)\n \t{\n@@ -626,18 +626,18 @@ reorg_loops (bool do_reorder, struct hw_doloop_hooks *hooks)\n {\n   hwloop_info loops = NULL;\n   hwloop_info loop;\n-  bitmap_obstack stack;\n+  bitmap_obstack loop_stack;\n \n   df_live_add_problem ();\n   df_live_set_all_dirty ();\n   df_analyze ();\n \n-  bitmap_obstack_initialize (&stack);\n+  bitmap_obstack_initialize (&loop_stack);\n \n   if (dump_file)\n     fprintf (dump_file, \";; Find loops, first pass\\n\\n\");\n \n-  loops = discover_loops (&stack, hooks);\n+  loops = discover_loops (&loop_stack, hooks);\n \n   if (do_reorder)\n     {\n@@ -647,7 +647,7 @@ reorg_loops (bool do_reorder, struct hw_doloop_hooks *hooks)\n       if (dump_file)\n \tfprintf (dump_file, \";; Find loops, second pass\\n\\n\");\n \n-      loops = discover_loops (&stack, hooks);\n+      loops = discover_loops (&loop_stack, hooks);\n     }\n \n   for (loop = loops; loop; loop = loop->next)"}, {"sha": "453d685e8357631350a138c2f137f82e9afcc275", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -331,9 +331,9 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n       condition *cc1;\n       if (!(clause & (1 << c1)))\n \tcontinue;\n-      cc1 = VEC_index (condition,\n-\t\t       conditions,\n-\t\t       c1 - predicate_first_dynamic_condition);\n+      cc1 = &VEC_index (condition,\n+\t\t        conditions,\n+\t\t        c1 - predicate_first_dynamic_condition);\n       /* We have no way to represent !CHANGED and !IS_NOT_CONSTANT\n \t and thus there is no point for looking for them.  */\n       if (cc1->code == CHANGED\n@@ -342,12 +342,12 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n       for (c2 = c1 + 1; c2 <= NUM_CONDITIONS; c2++)\n \tif (clause & (1 << c2))\n \t  {\n-\t    condition *cc1 = VEC_index (condition,\n-\t\t\t\t\tconditions,\n-\t\t\t\t\tc1 - predicate_first_dynamic_condition);\n-\t    condition *cc2 = VEC_index (condition,\n-\t\t\t\t\tconditions,\n-\t\t\t\t\tc2 - predicate_first_dynamic_condition);\n+\t    condition *cc1 = &VEC_index (condition,\n+\t\t\t\t\t conditions,\n+\t\t\t\t\t c1 - predicate_first_dynamic_condition);\n+\t    condition *cc2 = &VEC_index (condition,\n+\t\t\t\t\t conditions,\n+\t\t\t\t\t c2 - predicate_first_dynamic_condition);\n \t    if (cc1->operand_num == cc2->operand_num\n \t\t&& cc1->val == cc2->val\n \t\t&& cc2->code != IS_NOT_CONSTANT\n@@ -512,7 +512,7 @@ predicate_probability (conditions conds,\n \t      {\n \t\tif (i2 >= predicate_first_dynamic_condition)\n \t\t  {\n-\t\t    condition *c = VEC_index\n+\t\t    condition *c = &VEC_index\n \t\t\t\t    (condition, conds,\n \t\t\t\t     i2 - predicate_first_dynamic_condition);\n \t\t    if (c->code == CHANGED\n@@ -522,7 +522,7 @@ predicate_probability (conditions conds,\n \t\t      {\n \t\t\tint iprob = VEC_index (inline_param_summary_t,\n \t\t\t\t\t       inline_param_summary,\n-\t\t\t\t\t       c->operand_num)->change_prob;\n+\t\t\t\t\t       c->operand_num).change_prob;\n \t\t\tthis_prob = MAX (this_prob, iprob);\n \t\t      }\n \t\t    else\n@@ -552,8 +552,8 @@ dump_condition (FILE *f, conditions conditions, int cond)\n     fprintf (f, \"not inlined\");\n   else\n     {\n-      c = VEC_index (condition, conditions,\n-\t\t     cond - predicate_first_dynamic_condition);\n+      c = &VEC_index (condition, conditions,\n+\t\t      cond - predicate_first_dynamic_condition);\n       fprintf (f, \"op%i\", c->operand_num);\n       if (c->agg_contents)\n \tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n@@ -648,7 +648,7 @@ account_size_time (struct inline_summary *summary, int size, int time,\n     {\n       i = 0;\n       found = true;\n-      e = VEC_index (size_time_entry, summary->entry, 0);\n+      e = &VEC_index (size_time_entry, summary->entry, 0);\n       gcc_assert (!e->predicate.clause[0]);\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS) && (time || size))\n@@ -834,7 +834,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t  else if (inline_p\n \t\t   && !VEC_index (inline_param_summary_t,\n \t\t\t\t  es->param,\n-\t\t\t\t  i)->change_prob)\n+\t\t\t\t  i).change_prob)\n \t    VEC_replace (tree, known_vals, i, error_mark_node);\n \t  /* TODO: When IPA-CP starts propagating and merging aggregate jump\n \t     functions, use its knowledge of the caller too, just like the\n@@ -1218,7 +1218,7 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n \t     i++)\n \t  {\n \t    int prob = VEC_index (inline_param_summary_t,\n-\t\t\t\t  es->param, i)->change_prob;\n+\t\t\t\t  es->param, i).change_prob;\n \n \t    if (!prob)\n \t      fprintf (f, \"%*s op%i is compile time invariant\\n\",\n@@ -1822,8 +1822,8 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n \treturn p;\n       /* If we know when operand is constant,\n \t we still can say something useful.  */\n-      if (!true_predicate_p (VEC_index (predicate_t, nonconstant_names,\n-\t\t\t\t\tSSA_NAME_VERSION (use))))\n+      if (!true_predicate_p (&VEC_index (predicate_t, nonconstant_names,\n+\t\t\t\t\t SSA_NAME_VERSION (use))))\n \tcontinue;\n       return p;\n     }\n@@ -1846,14 +1846,14 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n \t    continue;\n \t}\n       else\n-\tp = *VEC_index (predicate_t, nonconstant_names,\n-\t\t\tSSA_NAME_VERSION (use));\n+\tp = VEC_index (predicate_t, nonconstant_names,\n+\t\t       SSA_NAME_VERSION (use));\n       op_non_const = or_predicates (summary->conds, &p, &op_non_const);\n     }\n   if (gimple_code (stmt) == GIMPLE_ASSIGN\n       && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n     VEC_replace (predicate_t, nonconstant_names,\n-\t\t SSA_NAME_VERSION (gimple_assign_lhs (stmt)), &op_non_const);\n+\t\t SSA_NAME_VERSION (gimple_assign_lhs (stmt)), op_non_const);\n   return op_non_const;\n }\n \n@@ -2068,7 +2068,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  struct predicate false_p = false_predicate ();\n \t\t  VEC_replace (predicate_t, nonconstant_names,\n \t\t\t       SSA_NAME_VERSION (gimple_call_lhs (stmt)),\n-\t\t\t       &false_p);\n+\t\t\t       false_p);\n \t\t}\n \t      if (ipa_node_params_vector)\n \t\t{\n@@ -2083,7 +2083,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t      int prob = param_change_prob (stmt, i);\n \t\t      gcc_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n \t\t      VEC_index (inline_param_summary_t,\n-\t\t\t\t es->param, i)->change_prob = prob;\n+\t\t\t\t es->param, i).change_prob = prob;\n \t\t    }\n \t\t}\n \n@@ -2550,8 +2550,8 @@ remap_predicate (struct inline_summary *info,\n \t      {\n \t\t struct condition *c;\n \n-\t\t c = VEC_index (condition, callee_info->conds,\n-\t\t\t\tcond - predicate_first_dynamic_condition);\n+\t\t c = &VEC_index (condition, callee_info->conds,\n+\t\t\t\t cond - predicate_first_dynamic_condition);\n \t\t /* See if we can remap condition operand to caller's operand.\n \t\t    Otherwise give up.  */\n \t\t if (!operand_map\n@@ -2660,18 +2660,18 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n \t    {\n \t      int jf_formal_id = ipa_get_jf_pass_through_formal_id (jfunc);\n \t      int prob1 = VEC_index (inline_param_summary_t,\n-\t\t\t\t     es->param, i)->change_prob;\n+\t\t\t\t     es->param, i).change_prob;\n \t      int prob2 = VEC_index\n \t\t\t     (inline_param_summary_t,\n-\t\t\t     inlined_es->param, jf_formal_id)->change_prob;\n+\t\t\t     inlined_es->param, jf_formal_id).change_prob;\n \t      int prob = ((prob1 * prob2 + REG_BR_PROB_BASE / 2)\n \t\t\t  / REG_BR_PROB_BASE);\n \n \t      if (prob1 && prob2 && !prob)\n \t\tprob = 1;\n \n \t      VEC_index (inline_param_summary_t,\n-\t\t\t es->param, i)->change_prob = prob;\n+\t\t\t es->param, i).change_prob = prob;\n \t    }\n \t}\n   }\n@@ -2922,12 +2922,12 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t  <= edge->uid)\n \tVEC_safe_grow_cleared (edge_growth_cache_entry, heap, edge_growth_cache,\n \t\t\t       cgraph_edge_max_uid);\n-      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid)->time\n+      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).time\n \t= ret + (ret >= 0);\n \n       ret_size = size - es->call_stmt_size;\n       gcc_checking_assert (es->call_stmt_size);\n-      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid)->size\n+      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid).size\n \t= ret_size + (ret_size >= 0);\n     }\n   return ret;\n@@ -2954,7 +2954,7 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n       do_estimate_edge_time (edge);\n       size = VEC_index (edge_growth_cache_entry,\n \t\t\tedge_growth_cache,\n-\t\t\tedge->uid)->size;\n+\t\t\tedge->uid).size;\n       gcc_checking_assert (size);\n       return size - (size > 0);\n     }\n@@ -3191,7 +3191,7 @@ read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n     {\n       VEC_safe_grow_cleared (inline_param_summary_t, heap, es->param, length);\n       for (i = 0; i < length; i++)\n-\tVEC_index (inline_param_summary_t, es->param, i)->change_prob\n+\tVEC_index (inline_param_summary_t, es->param, i).change_prob\n \t  = streamer_read_uhwi (ib);\n     }\n }\n@@ -3350,7 +3350,7 @@ write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n   streamer_write_uhwi (ob, VEC_length (inline_param_summary_t, es->param));\n   for (i = 0; i < (int)VEC_length (inline_param_summary_t, es->param); i++)\n     streamer_write_uhwi (ob, VEC_index (inline_param_summary_t,\n-\t\t\t\t        es->param, i)->change_prob);\n+\t\t\t\t        es->param, i).change_prob);\n }\n \n "}, {"sha": "c43ce25e19ea38fd17d07d588d08fd504cd02454", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1287,7 +1287,7 @@ inline_small_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n-  fibheap_t heap = fibheap_new ();\n+  fibheap_t edge_heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_size, max_size;\n   VEC (cgraph_edge_p, heap) *new_indirect_edges = NULL;\n@@ -1344,24 +1344,24 @@ inline_small_functions (void)\n \t      && edge->inline_failed)\n \t    {\n \t      gcc_assert (!edge->aux);\n-\t      update_edge_key (heap, edge);\n+\t      update_edge_key (edge_heap, edge);\n \t    }\n       }\n \n   gcc_assert (in_lto_p\n \t      || !max_count\n \t      || (profile_info && flag_branch_probabilities));\n \n-  while (!fibheap_empty (heap))\n+  while (!fibheap_empty (edge_heap))\n     {\n       int old_size = overall_size;\n       struct cgraph_node *where, *callee;\n-      int badness = fibheap_min_key (heap);\n+      int badness = fibheap_min_key (edge_heap);\n       int current_badness;\n       int cached_badness;\n       int growth;\n \n-      edge = (struct cgraph_edge *) fibheap_extract_min (heap);\n+      edge = (struct cgraph_edge *) fibheap_extract_min (edge_heap);\n       gcc_assert (edge->aux);\n       edge->aux = NULL;\n       if (!edge->inline_failed)\n@@ -1382,7 +1382,7 @@ inline_small_functions (void)\n       gcc_assert (current_badness >= badness);\n       if (current_badness != badness)\n \t{\n-\t  edge->aux = fibheap_insert (heap, current_badness, edge);\n+\t  edge->aux = fibheap_insert (edge_heap, current_badness, edge);\n \t  continue;\n \t}\n \n@@ -1447,8 +1447,8 @@ inline_small_functions (void)\n \t  /* Recursive inliner inlines all recursive calls of the function\n \t     at once. Consequently we need to update all callee keys.  */\n \t  if (flag_indirect_inlining)\n-\t    add_new_edges_to_heap (heap, new_indirect_edges);\n-          update_callee_keys (heap, where, updated_nodes);\n+\t    add_new_edges_to_heap (edge_heap, new_indirect_edges);\n+          update_callee_keys (edge_heap, where, updated_nodes);\n \t}\n       else\n \t{\n@@ -1482,12 +1482,12 @@ inline_small_functions (void)\n \t  gcc_checking_assert (!callee->global.inlined_to);\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n \t  if (flag_indirect_inlining)\n-\t    add_new_edges_to_heap (heap, new_indirect_edges);\n+\t    add_new_edges_to_heap (edge_heap, new_indirect_edges);\n \n \t  reset_edge_caches (edge->callee);\n           reset_node_growth_cache (callee);\n \n-\t  update_callee_keys (heap, edge->callee, updated_nodes);\n+\t  update_callee_keys (edge_heap, edge->callee, updated_nodes);\n \t}\n       where = edge->caller;\n       if (where->global.inlined_to)\n@@ -1499,7 +1499,7 @@ inline_small_functions (void)\n \t inlined into (since it's body size changed) and for the functions\n \t called by function we inlined (since number of it inlinable callers\n \t might change).  */\n-      update_caller_keys (heap, where, updated_nodes, NULL);\n+      update_caller_keys (edge_heap, where, updated_nodes, NULL);\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)\n@@ -1525,7 +1525,7 @@ inline_small_functions (void)\n   free_growth_caches ();\n   if (new_indirect_edges)\n     VEC_free (cgraph_edge_p, heap, new_indirect_edges);\n-  fibheap_delete (heap);\n+  fibheap_delete (edge_heap);\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Unit growth for small function inlining: %i->%i (%i%%)\\n\","}, {"sha": "d6909afbcd686a7dbc20111c798b19369f763690", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -200,13 +200,13 @@ extern int nfunctions_inlined;\n static inline struct inline_summary *\n inline_summary (struct cgraph_node *node)\n {\n-  return VEC_index (inline_summary_t, inline_summary_vec, node->uid);\n+  return &VEC_index (inline_summary_t, inline_summary_vec, node->uid);\n }\n \n static inline struct inline_edge_summary *\n inline_edge_summary (struct cgraph_edge *edge)\n {\n-  return VEC_index (inline_edge_summary_t,\n+  return &VEC_index (inline_edge_summary_t,\n \t\t    inline_edge_summary_vec, edge->uid);\n }\n \n@@ -235,7 +235,7 @@ estimate_edge_growth (struct cgraph_edge *edge)\n   if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) <= edge->uid\n       || !(ret = VEC_index (edge_growth_cache_entry,\n \t\t\t    edge_growth_cache,\n-\t\t\t    edge->uid)->size))\n+\t\t\t    edge->uid).size))\n     return do_estimate_edge_growth (edge);\n   return ret - (ret > 0);\n }\n@@ -251,7 +251,7 @@ estimate_edge_time (struct cgraph_edge *edge)\n   if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) <= edge->uid\n       || !(ret = VEC_index (edge_growth_cache_entry,\n \t\t\t    edge_growth_cache,\n-\t\t\t    edge->uid)->time))\n+\t\t\t    edge->uid).time))\n     return do_estimate_edge_time (edge);\n   return ret - (ret > 0);\n }\n@@ -274,6 +274,6 @@ reset_edge_growth_cache (struct cgraph_edge *edge)\n   if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) > edge->uid)\n     {\n       struct edge_growth_cache_entry zero = {0, 0};\n-      VEC_replace (edge_growth_cache_entry, edge_growth_cache, edge->uid, &zero);\n+      VEC_replace (edge_growth_cache_entry, edge_growth_cache, edge->uid, zero);\n     }\n }"}, {"sha": "966dbfabcdb8e7b5fccdd3c8a43697f329620eb0", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -94,7 +94,7 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   for (parm = fnargs; parm; parm = DECL_CHAIN (parm))\n     {\n       VEC_index (ipa_param_descriptor_t,\n-\t\t info->descriptors, param_num)->decl = parm;\n+\t\t info->descriptors, param_num).decl = parm;\n       param_num++;\n     }\n }\n@@ -2439,10 +2439,10 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t\t\t\t       old_args->jump_functions);\n \n   for (i = 0; i < VEC_length (ipa_jump_func_t, old_args->jump_functions); i++)\n-    VEC_index (ipa_jump_func_t, new_args->jump_functions, i)->agg.items\n+    VEC_index (ipa_jump_func_t, new_args->jump_functions, i).agg.items\n       = VEC_copy (ipa_agg_jf_item_t, gc,\n \t\t  VEC_index (ipa_jump_func_t,\n-\t\t\t     old_args->jump_functions, i)->agg.items);\n+\t\t\t     old_args->jump_functions, i).agg.items);\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -2672,7 +2672,7 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n       struct ipa_parm_adjustment *adj;\n       gcc_assert (link);\n \n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n       parm = VEC_index (tree, oparms, adj->base_index);\n       adj->base = parm;\n \n@@ -2738,8 +2738,8 @@ ipa_modify_formal_parameters (tree fndecl, ipa_parm_adjustment_vec adjustments,\n      When we are asked to remove it, we need to build new FUNCTION_TYPE\n      instead.  */\n   if (TREE_CODE (orig_type) != METHOD_TYPE\n-       || (VEC_index (ipa_parm_adjustment_t, adjustments, 0)->copy_param\n-\t && VEC_index (ipa_parm_adjustment_t, adjustments, 0)->base_index == 0))\n+       || (VEC_index (ipa_parm_adjustment_t, adjustments, 0).copy_param\n+\t  && VEC_index (ipa_parm_adjustment_t, adjustments, 0).base_index == 0))\n     {\n       new_type = build_distinct_type_copy (orig_type);\n       TYPE_ARG_TYPES (new_type) = new_reversed;\n@@ -2806,7 +2806,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n     {\n       struct ipa_parm_adjustment *adj;\n \n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n \n       if (adj->copy_param)\n \t{\n@@ -2989,7 +2989,7 @@ index_in_adjustments_multiple_times_p (int base_index,\n   for (i = 0; i < len; i++)\n     {\n       struct ipa_parm_adjustment *adj;\n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n \n       if (adj->base_index == base_index)\n \t{\n@@ -3020,7 +3020,7 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n   for (i = 0; i < inlen; i++)\n     {\n       struct ipa_parm_adjustment *n;\n-      n = VEC_index (ipa_parm_adjustment_t, inner, i);\n+      n = &VEC_index (ipa_parm_adjustment_t, inner, i);\n \n       if (n->remove_param)\n \tremovals++;\n@@ -3032,10 +3032,10 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n   for (i = 0; i < outlen; i++)\n     {\n       struct ipa_parm_adjustment *r;\n-      struct ipa_parm_adjustment *out = VEC_index (ipa_parm_adjustment_t,\n-\t\t\t\t\t\t   outer, i);\n-      struct ipa_parm_adjustment *in = VEC_index (ipa_parm_adjustment_t, tmp,\n-\t\t\t\t\t\t  out->base_index);\n+      struct ipa_parm_adjustment *out = &VEC_index (ipa_parm_adjustment_t,\n+\t\t\t\t\t\t    outer, i);\n+      struct ipa_parm_adjustment *in = &VEC_index (ipa_parm_adjustment_t, tmp,\n+\t\t\t\t\t\t   out->base_index);\n \n       gcc_assert (!in->remove_param);\n       if (out->remove_param)\n@@ -3068,8 +3068,8 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n \n   for (i = 0; i < inlen; i++)\n     {\n-      struct ipa_parm_adjustment *n = VEC_index (ipa_parm_adjustment_t,\n-\t\t\t\t\t\t inner, i);\n+      struct ipa_parm_adjustment *n = &VEC_index (ipa_parm_adjustment_t,\n+\t\t\t\t\t\t  inner, i);\n \n       if (n->remove_param)\n \tVEC_quick_push (ipa_parm_adjustment_t, adjustments, n);\n@@ -3094,7 +3094,7 @@ ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n   for (i = 0; i < len; i++)\n     {\n       struct ipa_parm_adjustment *adj;\n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n \n       if (!first)\n \tfprintf (file, \"                 \");"}, {"sha": "1fdd8333f018f057826123e2bbcce2d204bede0d", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -359,7 +359,7 @@ ipa_get_param_count (struct ipa_node_params *info)\n static inline tree\n ipa_get_param (struct ipa_node_params *info, int i)\n {\n-  return VEC_index (ipa_param_descriptor_t, info->descriptors, i)->decl;\n+  return VEC_index (ipa_param_descriptor_t, info->descriptors, i).decl;\n }\n \n /* Set the used flag corresponding to the Ith formal parameter of the function\n@@ -368,7 +368,7 @@ ipa_get_param (struct ipa_node_params *info, int i)\n static inline void\n ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n {\n-  VEC_index (ipa_param_descriptor_t, info->descriptors, i)->used = val;\n+  VEC_index (ipa_param_descriptor_t, info->descriptors, i).used = val;\n }\n \n /* Return the used flag corresponding to the Ith formal parameter of the\n@@ -377,7 +377,7 @@ ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n static inline bool\n ipa_is_param_used (struct ipa_node_params *info, int i)\n {\n-  return VEC_index (ipa_param_descriptor_t, info->descriptors, i)->used;\n+  return VEC_index (ipa_param_descriptor_t, info->descriptors, i).used;\n }\n \n /* ipa_edge_args stores information related to a callsite and particularly its\n@@ -406,7 +406,7 @@ ipa_get_cs_argument_count (struct ipa_edge_args *args)\n static inline struct ipa_jump_func *\n ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n {\n-  return VEC_index (ipa_jump_func_t, args->jump_functions, i);\n+  return &VEC_index (ipa_jump_func_t, args->jump_functions, i);\n }\n \n /* Vectors need to have typedefs of structures.  */\n@@ -425,10 +425,10 @@ extern GTY(()) VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n /* Return the associated parameter/argument info corresponding to the given\n    node/edge.  */\n-#define IPA_NODE_REF(NODE) (VEC_index (ipa_node_params_t, \\\n-\t\t\t\t       ipa_node_params_vector, (NODE)->uid))\n-#define IPA_EDGE_REF(EDGE) (VEC_index (ipa_edge_args_t, \\\n-\t\t\t\t       ipa_edge_args_vector, (EDGE)->uid))\n+#define IPA_NODE_REF(NODE) (&VEC_index (ipa_node_params_t, \\\n+\t\t\t\t        ipa_node_params_vector, (NODE)->uid))\n+#define IPA_EDGE_REF(EDGE) (&VEC_index (ipa_edge_args_t, \\\n+\t\t\t\t        ipa_edge_args_vector, (EDGE)->uid))\n /* This macro checks validity of index returned by\n    ipa_get_param_decl_index function.  */\n #define IS_VALID_JUMP_FUNC_INDEX(I) ((I) != -1)"}, {"sha": "575bba901ac3b2e753769e0d58104b590fd1353e", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -73,7 +73,7 @@ ipa_ref_list_first_reference (struct ipa_ref_list *list)\n {\n   if (!VEC_length (ipa_ref_t, list->references))\n     return NULL;\n-  return VEC_index (ipa_ref_t, list->references, 0);\n+  return &VEC_index (ipa_ref_t, list->references, 0);\n }\n \n /* Return first referring ref in LIST or NULL if empty.  */"}, {"sha": "21799ab3a15f411fb119fa6dca141ae40773abfa", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -49,7 +49,7 @@ ipa_record_reference (symtab_node referring_node,\n   old_references = list->references;\n   VEC_safe_grow (ipa_ref_t, gc, list->references,\n \t\t VEC_length (ipa_ref_t, list->references) + 1);\n-  ref = VEC_last (ipa_ref_t, list->references);\n+  ref = &VEC_last (ipa_ref_t, list->references);\n \n   list2 = &referred_node->symbol.ref_list;\n   VEC_safe_push (ipa_ref_ptr, heap, list2->referring, ref);\n@@ -93,7 +93,7 @@ ipa_remove_reference (struct ipa_ref *ref)\n     }\n   VEC_pop (ipa_ref_ptr, list->referring);\n \n-  last = VEC_last (ipa_ref_t, list2->references);\n+  last = &VEC_last (ipa_ref_t, list2->references);\n   if (ref != last)\n     {\n       *ref = *last;\n@@ -111,7 +111,7 @@ void\n ipa_remove_all_references (struct ipa_ref_list *list)\n {\n   while (VEC_length (ipa_ref_t, list->references))\n-    ipa_remove_reference (VEC_last (ipa_ref_t, list->references));\n+    ipa_remove_reference (&VEC_last (ipa_ref_t, list->references));\n   VEC_free (ipa_ref_t, gc, list->references);\n   list->references = NULL;\n }"}, {"sha": "3eec70c78f43d157ebcc1d4ef642164ba0ba6257", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -917,7 +917,7 @@ find_split_points (int overall_time, int overall_size)\n \n   while (!VEC_empty (stack_entry, stack))\n     {\n-      stack_entry *entry = VEC_last (stack_entry, stack);\n+      stack_entry *entry = &VEC_last (stack_entry, stack);\n \n       /* We are walking an acyclic graph, so edge_num counts\n \t succ and pred edges together.  However when considering\n@@ -984,9 +984,9 @@ find_split_points (int overall_time, int overall_size)\n \t      new_entry.bb = dest;\n \t      new_entry.edge_num = 0;\n \t      new_entry.overall_time\n-\t\t = VEC_index (bb_info, bb_info_vec, dest->index)->time;\n+\t\t = VEC_index (bb_info, bb_info_vec, dest->index).time;\n \t      new_entry.overall_size\n-\t\t = VEC_index (bb_info, bb_info_vec, dest->index)->size;\n+\t\t = VEC_index (bb_info, bb_info_vec, dest->index).size;\n \t      new_entry.earliest = INT_MAX;\n \t      new_entry.set_ssa_names = BITMAP_ALLOC (NULL);\n \t      new_entry.used_ssa_names = BITMAP_ALLOC (NULL);\n@@ -1006,8 +1006,8 @@ find_split_points (int overall_time, int overall_size)\n \t and merge stuff we accumulate during the walk.  */\n       else if (entry->bb != ENTRY_BLOCK_PTR)\n \t{\n-\t  stack_entry *prev = VEC_index (stack_entry, stack,\n-\t\t\t\t\t VEC_length (stack_entry, stack) - 2);\n+\t  stack_entry *prev = &VEC_index (stack_entry, stack,\n+\t\t\t\t\t  VEC_length (stack_entry, stack) - 2);\n \n \t  entry->bb->aux = (void *)(intptr_t)-1;\n \t  prev->can_split &= entry->can_split;\n@@ -1489,8 +1489,8 @@ execute_split_functions (void)\n \t}\n       overall_time += time;\n       overall_size += size;\n-      VEC_index (bb_info, bb_info_vec, bb->index)->time = time;\n-      VEC_index (bb_info, bb_info_vec, bb->index)->size = size;\n+      VEC_index (bb_info, bb_info_vec, bb->index).time = time;\n+      VEC_index (bb_info, bb_info_vec, bb->index).size = size;\n     }\n   find_split_points (overall_time, overall_size);\n   if (best_split_point.split_bbs)"}, {"sha": "07dfb61b9aa8cda5ef0b72f2ebe24b0d6c4a70e5", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -233,6 +233,6 @@ uses_jv_markobj_p (tree dtable)\n      this function is only used with flag_reduced_reflection.  No\n      point in asserting unless we hit the bad case.  */\n   gcc_assert (!flag_reduced_reflection || TARGET_VTABLE_USES_DESCRIPTORS == 0);\n-  v = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (dtable), 3)->value;\n+  v = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (dtable), 3).value;\n   return (PROCEDURE_OBJECT_DESCRIPTOR == TREE_INT_CST_LOW (v));\n }"}, {"sha": "f806cea141488542fd962c9ab7596211b7dab0c5", "filename": "gcc/java/class.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1533,7 +1533,7 @@ make_method_value (tree mdecl)\n \tv = VEC_alloc (constructor_elt, gc, length);\n \tVEC_safe_grow_cleared (constructor_elt, gc, v, length);\n \n-\te = VEC_index (constructor_elt, v, idx--);\n+\te = &VEC_index (constructor_elt, v, idx--);\n \te->value = null_pointer_node;\n \n \tFOR_EACH_VEC_ELT (tree, DECL_FUNCTION_THROWS (mdecl), ix, t)\n@@ -1542,7 +1542,7 @@ make_method_value (tree mdecl)\n \t    tree utf8\n \t      = build_utf8_ref (unmangle_classname (IDENTIFIER_POINTER (sig),\n \t\t\t\t\t\t    IDENTIFIER_LENGTH (sig)));\n-\t    e = VEC_index (constructor_elt, v, idx--);\n+\t    e = &VEC_index (constructor_elt, v, idx--);\n \t    e->value = utf8;\n \t  }\n \tgcc_assert (idx == -1);\n@@ -1621,7 +1621,7 @@ get_dispatch_table (tree type, tree this_class_addr)\n   arraysize += 2;\n \n   VEC_safe_grow_cleared (constructor_elt, gc, v, arraysize);\n-  e = VEC_index (constructor_elt, v, arraysize - 1);\n+  e = &VEC_index (constructor_elt, v, arraysize - 1);\n \n #define CONSTRUCTOR_PREPEND_VALUE(E, V) E->value = V, E--\n   for (i = nvirtuals;  --i >= 0; )\n@@ -3007,7 +3007,7 @@ emit_catch_table (tree this_class)\n   int n_catch_classes;\n   constructor_elt *e;\n   /* Fill in the dummy entry that make_class created.  */\n-  e = VEC_index (constructor_elt, TYPE_CATCH_CLASSES (this_class), 0);\n+  e = &VEC_index (constructor_elt, TYPE_CATCH_CLASSES (this_class), 0);\n   e->value = make_catch_class_record (null_pointer_node, null_pointer_node);\n   CONSTRUCTOR_APPEND_ELT (TYPE_CATCH_CLASSES (this_class), NULL_TREE,\n \t\t\t  make_catch_class_record (null_pointer_node,"}, {"sha": "c709fa40a3c7389a02ce6aa74f4b30de15f837a1", "filename": "gcc/java/constants.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -514,8 +514,8 @@ build_constants_constructor (void)\n       int c = outgoing_cpool->count;\n       VEC_safe_grow_cleared (constructor_elt, gc, tags, c);\n       VEC_safe_grow_cleared (constructor_elt, gc, data, c);\n-      t = VEC_index (constructor_elt, tags, c-1);\n-      d = VEC_index (constructor_elt, data, c-1);\n+      t = &VEC_index (constructor_elt, tags, c-1);\n+      d = &VEC_index (constructor_elt, data, c-1);\n     }\n \n #define CONSTRUCTOR_PREPEND_VALUE(E, V) E->value = V, E--"}, {"sha": "5167b9b75c591e03f06ea704e6b3fbc0b167135c", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1430,7 +1430,7 @@ extern tree *type_map;\n #define PUSH_SUPER_VALUE(V, VALUE) \\\n   do \\\n     { \\\n-      constructor_elt *_elt___ = VEC_last (constructor_elt, V); \\\n+      constructor_elt *_elt___ = &VEC_last (constructor_elt, V); \\\n       tree _next___ = DECL_CHAIN (_elt___->index); \\\n       gcc_assert (!DECL_NAME (_elt___->index)); \\\n       _elt___->value = VALUE; \\\n@@ -1444,7 +1444,7 @@ extern tree *type_map;\n #define PUSH_FIELD_VALUE(V, NAME, VALUE) \t\t\t\t\\\n   do \\\n     { \\\n-      constructor_elt *_elt___ = VEC_last (constructor_elt, V); \\\n+      constructor_elt *_elt___ = &VEC_last (constructor_elt, V); \\\n       tree _next___ = DECL_CHAIN (_elt___->index); \\\n       gcc_assert (strcmp (IDENTIFIER_POINTER (DECL_NAME (_elt___->index)), \\\n \t\t\t  NAME) == 0); \\"}, {"sha": "673055eacc5f0e184362064df21894f0147db393", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -229,7 +229,7 @@ static void remove_node_from_ps (partial_schedule_ptr, ps_insn_ptr);\n \n #define NODE_ASAP(node) ((node)->aux.count)\n \n-#define SCHED_PARAMS(x) VEC_index (node_sched_params, node_sched_param_vec, x)\n+#define SCHED_PARAMS(x) (&VEC_index (node_sched_params, node_sched_param_vec, x))\n #define SCHED_TIME(x) (SCHED_PARAMS (x)->time)\n #define SCHED_ROW(x) (SCHED_PARAMS (x)->row)\n #define SCHED_STAGE(x) (SCHED_PARAMS (x)->stage)\n@@ -305,7 +305,7 @@ static struct ps_reg_move_info *\n ps_reg_move (partial_schedule_ptr ps, int id)\n {\n   gcc_checking_assert (id >= ps->g->num_nodes);\n-  return VEC_index (ps_reg_move_info, ps->reg_moves, id - ps->g->num_nodes);\n+  return &VEC_index (ps_reg_move_info, ps->reg_moves, id - ps->g->num_nodes);\n }\n \n /* Return the rtl instruction that is being scheduled by partial schedule"}, {"sha": "caa16c72b50efd0ce4553e65325f4de984a62ea2", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -3209,7 +3209,7 @@ objc_build_constructor (tree type, VEC(constructor_elt,gc) *elts)\n #ifdef OBJCPLUS\n   /* Adjust for impedance mismatch.  We should figure out how to build\n      CONSTRUCTORs that consistently please both the C and C++ gods.  */\n-  if (!VEC_index (constructor_elt, elts, 0)->index)\n+  if (!VEC_index (constructor_elt, elts, 0).index)\n     TREE_TYPE (constructor) = init_list_type_node;\n #endif\n "}, {"sha": "1d0f1949b800cfdf4da5ac57abc5db4b1758edfc", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -802,7 +802,7 @@ add_removable_extension (const_rtx expr, rtx insn,\n \t different extension.  FIXME: this obviously can be improved.  */\n       for (def = defs; def; def = def->next)\n \tif ((idx = def_map[INSN_UID(DF_REF_INSN (def->ref))])\n-\t    && (cand = VEC_index (ext_cand, *insn_list, idx - 1))\n+\t    && (cand = &VEC_index (ext_cand, *insn_list, idx - 1))\n \t    && (cand->code != code || cand->mode != mode))\n \t  {\n \t    if (dump_file)"}, {"sha": "dc7550a1cee6e5b490446d139536250379e377b5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -201,7 +201,7 @@ typedef struct stack_def\n   int top;\t\t\t/* index to top stack element */\n   HARD_REG_SET reg_set;\t\t/* set of live registers */\n   unsigned char reg[REG_STACK_SIZE];/* register - stack mapping */\n-} *stack;\n+} *stack_ptr;\n \n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n@@ -246,27 +246,27 @@ static rtx not_a_num;\n /* Forward declarations */\n \n static int stack_regs_mentioned_p (const_rtx pat);\n-static void pop_stack (stack, int);\n+static void pop_stack (stack_ptr, int);\n static rtx *get_true_reg (rtx *);\n \n static int check_asm_stack_operands (rtx);\n static void get_asm_operands_in_out (rtx, int *, int *);\n static rtx stack_result (tree);\n static void replace_reg (rtx *, int);\n static void remove_regno_note (rtx, enum reg_note, unsigned int);\n-static int get_hard_regnum (stack, rtx);\n-static rtx emit_pop_insn (rtx, stack, rtx, enum emit_where);\n-static void swap_to_top(rtx, stack, rtx, rtx);\n-static bool move_for_stack_reg (rtx, stack, rtx);\n-static bool move_nan_for_stack_reg (rtx, stack, rtx);\n+static int get_hard_regnum (stack_ptr, rtx);\n+static rtx emit_pop_insn (rtx, stack_ptr, rtx, enum emit_where);\n+static void swap_to_top(rtx, stack_ptr, rtx, rtx);\n+static bool move_for_stack_reg (rtx, stack_ptr, rtx);\n+static bool move_nan_for_stack_reg (rtx, stack_ptr, rtx);\n static int swap_rtx_condition_1 (rtx);\n static int swap_rtx_condition (rtx);\n-static void compare_for_stack_reg (rtx, stack, rtx);\n-static bool subst_stack_regs_pat (rtx, stack, rtx);\n-static void subst_asm_stack_regs (rtx, stack);\n-static bool subst_stack_regs (rtx, stack);\n-static void change_stack (rtx, stack, stack, enum emit_where);\n-static void print_stack (FILE *, stack);\n+static void compare_for_stack_reg (rtx, stack_ptr, rtx);\n+static bool subst_stack_regs_pat (rtx, stack_ptr, rtx);\n+static void subst_asm_stack_regs (rtx, stack_ptr);\n+static bool subst_stack_regs (rtx, stack_ptr);\n+static void change_stack (rtx, stack_ptr, stack_ptr, enum emit_where);\n+static void print_stack (FILE *, stack_ptr);\n static rtx next_flags_user (rtx);\n \f\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n@@ -354,7 +354,7 @@ next_flags_user (rtx insn)\n /* Reorganize the stack into ascending numbers, before this insn.  */\n \n static void\n-straighten_stack (rtx insn, stack regstack)\n+straighten_stack (rtx insn, stack_ptr regstack)\n {\n   struct stack_def temp_stack;\n   int top;\n@@ -377,7 +377,7 @@ straighten_stack (rtx insn, stack regstack)\n /* Pop a register from the stack.  */\n \n static void\n-pop_stack (stack regstack, int regno)\n+pop_stack (stack_ptr regstack, int regno)\n {\n   int top = regstack->top;\n \n@@ -721,7 +721,7 @@ remove_regno_note (rtx insn, enum reg_note note, unsigned int regno)\n    returned if the register is not found.  */\n \n static int\n-get_hard_regnum (stack regstack, rtx reg)\n+get_hard_regnum (stack_ptr regstack, rtx reg)\n {\n   int i;\n \n@@ -742,7 +742,7 @@ get_hard_regnum (stack regstack, rtx reg)\n    cases the movdf pattern to pop.  */\n \n static rtx\n-emit_pop_insn (rtx insn, stack regstack, rtx reg, enum emit_where where)\n+emit_pop_insn (rtx insn, stack_ptr regstack, rtx reg, enum emit_where where)\n {\n   rtx pop_insn, pop_rtx;\n   int hard_regno;\n@@ -793,7 +793,7 @@ emit_pop_insn (rtx insn, stack regstack, rtx reg, enum emit_where where)\n    If REG is already at the top of the stack, no insn is emitted.  */\n \n static void\n-emit_swap_insn (rtx insn, stack regstack, rtx reg)\n+emit_swap_insn (rtx insn, stack_ptr regstack, rtx reg)\n {\n   int hard_regno;\n   rtx swap_rtx;\n@@ -900,7 +900,7 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n    is emitted.  */\n \n static void\n-swap_to_top (rtx insn, stack regstack, rtx src1, rtx src2)\n+swap_to_top (rtx insn, stack_ptr regstack, rtx src1, rtx src2)\n {\n   struct stack_def temp_stack;\n   int regno, j, k, temp;\n@@ -941,7 +941,7 @@ swap_to_top (rtx insn, stack regstack, rtx src1, rtx src2)\n    was deleted in the process.  */\n \n static bool\n-move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n+move_for_stack_reg (rtx insn, stack_ptr regstack, rtx pat)\n {\n   rtx *psrc =  get_true_reg (&SET_SRC (pat));\n   rtx *pdest = get_true_reg (&SET_DEST (pat));\n@@ -1092,7 +1092,7 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n    a NaN into DEST, then invokes move_for_stack_reg.  */\n \n static bool\n-move_nan_for_stack_reg (rtx insn, stack regstack, rtx dest)\n+move_nan_for_stack_reg (rtx insn, stack_ptr regstack, rtx dest)\n {\n   rtx pat;\n \n@@ -1231,7 +1231,7 @@ swap_rtx_condition (rtx insn)\n    set up.  */\n \n static void\n-compare_for_stack_reg (rtx insn, stack regstack, rtx pat_src)\n+compare_for_stack_reg (rtx insn, stack_ptr regstack, rtx pat_src)\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n@@ -1320,7 +1320,7 @@ compare_for_stack_reg (rtx insn, stack regstack, rtx pat_src)\n static int\n subst_stack_regs_in_debug_insn (rtx *loc, void *data)\n {\n-  stack regstack = (stack)data;\n+  stack_ptr regstack = (stack_ptr)data;\n   int hard_regno;\n \n   if (!STACK_REG_P (*loc))\n@@ -1361,7 +1361,7 @@ subst_all_stack_regs_in_debug_insn (rtx insn, struct stack_def *regstack)\n    was deleted in the process.  */\n \n static bool\n-subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n+subst_stack_regs_pat (rtx insn, stack_ptr regstack, rtx pat)\n {\n   rtx *dest, *src;\n   bool control_flow_insn_deleted = false;\n@@ -2009,7 +2009,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n    requirements, since record_asm_stack_regs removes any problem asm.  */\n \n static void\n-subst_asm_stack_regs (rtx insn, stack regstack)\n+subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n {\n   rtx body = PATTERN (insn);\n   int alt;\n@@ -2292,7 +2292,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n    a control flow insn was deleted in the process.  */\n \n static bool\n-subst_stack_regs (rtx insn, stack regstack)\n+subst_stack_regs (rtx insn, stack_ptr regstack)\n {\n   rtx *note_link, note;\n   bool control_flow_insn_deleted = false;\n@@ -2404,7 +2404,7 @@ subst_stack_regs (rtx insn, stack regstack)\n    is no longer needed once this has executed.  */\n \n static void\n-change_stack (rtx insn, stack old, stack new_stack, enum emit_where where)\n+change_stack (rtx insn, stack_ptr old, stack_ptr new_stack, enum emit_where where)\n {\n   int reg;\n   int update_end = 0;\n@@ -2610,7 +2610,7 @@ change_stack (rtx insn, stack old, stack new_stack, enum emit_where where)\n /* Print stack configuration.  */\n \n static void\n-print_stack (FILE *file, stack s)\n+print_stack (FILE *file, stack_ptr s)\n {\n   if (! file)\n     return;\n@@ -2686,7 +2686,7 @@ static void\n convert_regs_exit (void)\n {\n   int value_reg_low, value_reg_high;\n-  stack output_stack;\n+  stack_ptr output_stack;\n   rtx retvalue;\n \n   retvalue = stack_result (current_function_decl);\n@@ -2719,8 +2719,8 @@ convert_regs_exit (void)\n static void\n propagate_stack (edge e)\n {\n-  stack src_stack = &BLOCK_INFO (e->src)->stack_out;\n-  stack dest_stack = &BLOCK_INFO (e->dest)->stack_in;\n+  stack_ptr src_stack = &BLOCK_INFO (e->src)->stack_out;\n+  stack_ptr dest_stack = &BLOCK_INFO (e->dest)->stack_in;\n   int reg;\n \n   /* Preserve the order of the original stack, but check whether\n@@ -2746,8 +2746,8 @@ static bool\n compensate_edge (edge e)\n {\n   basic_block source = e->src, target = e->dest;\n-  stack target_stack = &BLOCK_INFO (target)->stack_in;\n-  stack source_stack = &BLOCK_INFO (source)->stack_out;\n+  stack_ptr target_stack = &BLOCK_INFO (target)->stack_in;\n+  stack_ptr source_stack = &BLOCK_INFO (source)->stack_out;\n   struct stack_def regstack;\n   int reg;\n "}, {"sha": "d125242c8515068dcf0c797203c2ae9248764e8f", "filename": "gcc/regrename.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -728,8 +728,8 @@ regrename_analyze (bitmap bb_mask)\n \t      rtx insn;\n \t      FOR_BB_INSNS (bb1, insn)\n \t\t{\n-\t\t  insn_rr_info *p = VEC_index (insn_rr_info, insn_rr,\n-\t\t\t\t\t       INSN_UID (insn));\n+\t\t  insn_rr_info *p = &VEC_index (insn_rr_info, insn_rr,\n+\t\t\t\t\t        INSN_UID (insn));\n \t\t  p->op_info = NULL;\n \t\t}\n \t    }\n@@ -1583,7 +1583,7 @@ build_def_use (basic_block bb)\n \n \t  if (insn_rr != NULL)\n \t    {\n-\t      insn_info = VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n+\t      insn_info = &VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n \t      insn_info->op_info = XOBNEWVEC (&rename_obstack, operand_rr_info,\n \t\t\t\t\t      recog_data.n_operands);\n \t      memset (insn_info->op_info, 0,"}, {"sha": "a672ddc45db52f108e69d0ac80c39b30ad71a042", "filename": "gcc/reload.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -243,19 +243,19 @@ typedef struct reg_equivs\n } reg_equivs_t;\n \n #define reg_equiv_constant(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->constant\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).constant\n #define reg_equiv_invariant(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->invariant\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).invariant\n #define reg_equiv_memory_loc(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->memory_loc\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).memory_loc\n #define reg_equiv_address(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->address\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).address\n #define reg_equiv_mem(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->mem\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).mem\n #define reg_equiv_alt_mem_list(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->alt_mem_list\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).alt_mem_list\n #define reg_equiv_init(ELT) \\\n-  VEC_index (reg_equivs_t, reg_equivs, (ELT))->init\n+  VEC_index (reg_equivs_t, reg_equivs, (ELT)).init\n \n DEF_VEC_O(reg_equivs_t);\n DEF_VEC_ALLOC_O(reg_equivs_t, gc);"}, {"sha": "1a3d279dd63287c91c83b73a57ac916b707d5a4a", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -664,7 +664,8 @@ grow_reg_equivs (void)\n   for (i = old_size; i < max_regno; i++)\n     {\n       VEC_quick_insert (reg_equivs_t, reg_equivs, i, 0);\n-      memset (VEC_index (reg_equivs_t, reg_equivs, i), 0, sizeof (reg_equivs_t));\n+      memset (&VEC_index (reg_equivs_t, reg_equivs, i), 0,\n+\t      sizeof (reg_equivs_t));\n     }\n     \n }"}, {"sha": "2e462380bb8abf37f75c4bb64ce19173779e8fd4", "filename": "gcc/sched-int.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -873,7 +873,7 @@ DEF_VEC_ALLOC_O (haifa_insn_data_def, heap);\n \n extern VEC(haifa_insn_data_def, heap) *h_i_d;\n \n-#define HID(INSN) (VEC_index (haifa_insn_data_def, h_i_d, INSN_UID (INSN)))\n+#define HID(INSN) (&VEC_index (haifa_insn_data_def, h_i_d, INSN_UID (INSN)))\n \n /* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n    sched-rgn.c.  */\n@@ -895,7 +895,7 @@ DEF_VEC_ALLOC_O (haifa_deps_insn_data_def, heap);\n \n extern VEC(haifa_deps_insn_data_def, heap) *h_d_i_d;\n \n-#define HDID(INSN) (VEC_index (haifa_deps_insn_data_def, h_d_i_d,\t\\\n+#define HDID(INSN) (&VEC_index (haifa_deps_insn_data_def, h_d_i_d,\t\\\n \t\t\t       INSN_LUID (INSN)))\n #define INSN_DEP_COUNT(INSN)\t(HDID (INSN)->dep_count)\n #define HAS_INTERNAL_DEP(INSN)  (HDID (INSN)->has_internal_dep)\n@@ -909,7 +909,7 @@ extern VEC(haifa_deps_insn_data_def, heap) *h_d_i_d;\n #define INSN_COND_DEPS(INSN)\t(HDID (INSN)->cond_deps)\n #define CANT_MOVE(INSN)\t(HDID (INSN)->cant_move)\n #define CANT_MOVE_BY_LUID(LUID)\t(VEC_index (haifa_deps_insn_data_def, h_d_i_d, \\\n-                                            LUID)->cant_move)\n+                                            LUID).cant_move)\n \n \n #define INSN_PRIORITY(INSN)\t(HID (INSN)->priority)"}, {"sha": "449efc97cbccb69bb495132b64cac917ad7d4cf2", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1524,7 +1524,7 @@ insert_in_history_vect (VEC (expr_history_def, heap) **pvect,\n \n   if (res)\n     {\n-      expr_history_def *phist = VEC_index (expr_history_def, vect, ind);\n+      expr_history_def *phist = &VEC_index (expr_history_def, vect, ind);\n \n       /* It is possible that speculation types of expressions that were\n          propagated through different paths will be different here.  In this\n@@ -4159,7 +4159,7 @@ finish_insns (void)\n      removed during the scheduling.  */\n   for (i = 0; i < VEC_length (sel_insn_data_def, s_i_d); i++)\n     {\n-      sel_insn_data_def *sid_entry = VEC_index (sel_insn_data_def, s_i_d, i);\n+      sel_insn_data_def *sid_entry = &VEC_index (sel_insn_data_def, s_i_d, i);\n \n       if (sid_entry->live)\n         return_regset_to_pool (sid_entry->live);"}, {"sha": "ef884a56f1257d64f15e17640319af504a3c3c66", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -765,8 +765,8 @@ DEF_VEC_ALLOC_O (sel_insn_data_def, heap);\n extern VEC (sel_insn_data_def, heap) *s_i_d;\n \n /* Accessor macros for s_i_d.  */\n-#define SID(INSN) (VEC_index (sel_insn_data_def, s_i_d,\tINSN_LUID (INSN)))\n-#define SID_BY_UID(UID) (VEC_index (sel_insn_data_def, s_i_d,\tLUID_BY_UID (UID)))\n+#define SID(INSN) (&VEC_index (sel_insn_data_def, s_i_d,\tINSN_LUID (INSN)))\n+#define SID_BY_UID(UID) (&VEC_index (sel_insn_data_def, s_i_d,\tLUID_BY_UID (UID)))\n \n extern sel_insn_data_def insn_sid (insn_t);\n \n@@ -897,7 +897,7 @@ extern void sel_finish_global_bb_info (void);\n \n /* Get data for BB.  */\n #define SEL_GLOBAL_BB_INFO(BB)\t\t\t\t\t\\\n-  (VEC_index (sel_global_bb_info_def, sel_global_bb_info, (BB)->index))\n+  (&VEC_index (sel_global_bb_info_def, sel_global_bb_info, (BB)->index))\n \n /* Access macros.  */\n #define BB_LV_SET(BB) (SEL_GLOBAL_BB_INFO (BB)->lv_set)\n@@ -927,8 +927,8 @@ DEF_VEC_ALLOC_O (sel_region_bb_info_def, heap);\n extern VEC (sel_region_bb_info_def, heap) *sel_region_bb_info;\n \n /* Get data for BB.  */\n-#define SEL_REGION_BB_INFO(BB) (VEC_index (sel_region_bb_info_def,\t\\\n-\t\t\t\t\t   sel_region_bb_info, (BB)->index))\n+#define SEL_REGION_BB_INFO(BB) (&VEC_index (sel_region_bb_info_def,\t\\\n+\t\t\t\t\t    sel_region_bb_info, (BB)->index))\n \n /* Get BB's note_list.\n    A note_list is a list of various notes that was scattered across BB"}, {"sha": "b5bffa11978cadd7a613b71ad7e5ec729b3667b1", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1938,9 +1938,9 @@ undo_transformations (av_set_t *av_ptr, rtx insn)\n         {\n           expr_history_def *phist;\n \n-          phist = VEC_index (expr_history_def,\n-                             EXPR_HISTORY_OF_CHANGES (expr),\n-                             index);\n+          phist = &VEC_index (expr_history_def,\n+                              EXPR_HISTORY_OF_CHANGES (expr),\n+                              index);\n \n           switch (phist->type)\n             {\n@@ -3581,7 +3581,7 @@ vinsn_vec_has_expr_p (vinsn_vec_t vinsn_vec, expr_t expr)\n \t\t\t\t     EXPR_HISTORY_OF_CHANGES (expr))\n \t\t     ? VEC_index (expr_history_def,\n \t\t\t\t  EXPR_HISTORY_OF_CHANGES (expr),\n-\t\t\t\t  i++)->old_expr_vinsn\n+\t\t\t\t  i++).old_expr_vinsn\n \t\t     : NULL))\n     FOR_EACH_VEC_ELT (vinsn_t, vinsn_vec, n, vinsn)\n       if (VINSN_SEPARABLE_P (vinsn))"}, {"sha": "281e5501d1ee7eb87e4805bca5776c6ed5c6c75d", "filename": "gcc/stringpool.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -49,7 +49,7 @@ static const char digit_vector[] = {\n \n struct ht *ident_hash;\n \n-static hashnode alloc_node (hash_table *);\n+static hashnode alloc_node (cpp_hash_table *);\n static int mark_ident (struct cpp_reader *, hashnode, const void *);\n \n static void *\n@@ -70,7 +70,7 @@ init_stringpool (void)\n \n /* Allocate a hash node.  */\n static hashnode\n-alloc_node (hash_table *table ATTRIBUTE_UNUSED)\n+alloc_node (cpp_hash_table *table ATTRIBUTE_UNUSED)\n {\n   return GCC_IDENT_TO_HT_IDENT (make_node (IDENTIFIER_NODE));\n }\n@@ -210,6 +210,32 @@ gt_pch_n_S (const void *x)\n   gt_pch_note_object (CONST_CAST (void *, x), CONST_CAST (void *, x),\n \t\t      &gt_pch_p_S, gt_types_enum_last);\n }\n+\n+\n+/* User-callable entry point for marking string X.  */\n+\n+void\n+gt_pch_nx (const char *& x)\n+{\n+  gt_pch_n_S (x);\n+}\n+\n+void\n+gt_pch_nx (unsigned char *& x)\n+{\n+  gt_pch_n_S (x);\n+}\n+\n+void\n+gt_pch_nx (unsigned char& x ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+void\n+gt_pch_nx (unsigned char *x, gt_pointer_operator op, void *cookie)\n+{\n+  op (x, cookie);\n+}\n \f\n /* Handle saving and restoring the string pool for PCH.  */\n "}, {"sha": "be020dab8099c838da280a5062750446904a189f", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -374,7 +374,7 @@ gen_conditions_for_domain (tree arg, inp_domain domain,\n     {\n       /* Now push a separator.  */\n       if (domain.has_lb)\n-        VEC_quick_push (gimple, conds, NULL);\n+        VEC_quick_push (gimple, conds, (gimple)NULL);\n \n       gen_one_condition (arg, domain.ub,\n                          (domain.is_ub_inclusive\n@@ -496,7 +496,7 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n      type is integer.  */\n \n   /* Push a separator.  */\n-  VEC_quick_push (gimple, conds, NULL);\n+  VEC_quick_push (gimple, conds, (gimple)NULL);\n \n   temp = create_tmp_var (int_type, \"DCE_COND1\");\n   cst0 = build_int_cst (int_type, 0);"}, {"sha": "c718cc0a3dce03eb82dfc9b443da4c5e6297807a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -7872,3 +7872,54 @@ struct gimple_opt_pass pass_warn_unused_result =\n     0,\t\t\t\t\t/* todo_flags_finish */\n   }\n };\n+\n+\n+/* Garbage collection support for edge_def.  */\n+\n+extern void gt_ggc_mx (tree&);\n+extern void gt_ggc_mx (gimple&);\n+extern void gt_ggc_mx (rtx&);\n+extern void gt_ggc_mx (basic_block&);\n+\n+void\n+gt_ggc_mx (edge_def *e)\n+{\n+  gt_ggc_mx (e->src);\n+  gt_ggc_mx (e->dest);\n+  if (current_ir_type () == IR_GIMPLE)\n+    gt_ggc_mx (e->insns.g);\n+  else\n+    gt_ggc_mx (e->insns.r);\n+  gt_ggc_mx (e->goto_block);\n+}\n+\n+/* PCH support for edge_def.  */\n+\n+extern void gt_pch_nx (tree&);\n+extern void gt_pch_nx (gimple&);\n+extern void gt_pch_nx (rtx&);\n+extern void gt_pch_nx (basic_block&);\n+\n+void\n+gt_pch_nx (edge_def *e)\n+{\n+  gt_pch_nx (e->src);\n+  gt_pch_nx (e->dest);\n+  if (current_ir_type () == IR_GIMPLE)\n+    gt_pch_nx (e->insns.g);\n+  else\n+    gt_pch_nx (e->insns.r);\n+  gt_pch_nx (e->goto_block);\n+}\n+\n+void\n+gt_pch_nx (edge_def *e, gt_pointer_operator op, void *cookie)\n+{\n+  op (&(e->src), cookie);\n+  op (&(e->dest), cookie);\n+  if (current_ir_type () == IR_GIMPLE)\n+    op (&(e->insns.g), cookie);\n+  else\n+    op (&(e->insns.r), cookie);\n+  op (&(e->goto_block), cookie);\n+}"}, {"sha": "504f9a8b433f887d8e79d5976d6a0c045c7d8e3d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -3999,7 +3999,7 @@ splice_all_param_accesses (VEC (access_p, heap) **representatives)\n \t    result = UNUSED_PARAMS;\n \t}\n       else\n-\tVEC_quick_push (access_p, *representatives, NULL);\n+\tVEC_quick_push (access_p, *representatives, (access_p) NULL);\n     }\n \n   if (result == NO_GOOD_ACCESS)\n@@ -4208,7 +4208,7 @@ get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)\n     {\n       struct ipa_parm_adjustment *adj;\n \n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n       if (!adj->copy_param && adj->base == base)\n \treturn adj;\n     }\n@@ -4315,7 +4315,7 @@ sra_ipa_modify_expr (tree *expr, bool convert,\n \n   for (i = 0; i < len; i++)\n     {\n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n \n       if (adj->base == base &&\n \t  (adj->offset == offset || adj->remove_param))\n@@ -4522,7 +4522,7 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n       tree name, vexpr, copy = NULL_TREE;\n       use_operand_p use_p;\n \n-      adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n+      adj = &VEC_index (ipa_parm_adjustment_t, adjustments, i);\n       if (adj->copy_param || !is_gimple_reg (adj->base))\n \tcontinue;\n       name = ssa_default_def (cfun, adj->base);"}, {"sha": "57a590d4a63b93f5e78bc87b49b620c4aecec4cf", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -215,7 +215,8 @@ addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n \t\t\t       templ_index + 1);\n \n       /* Reuse the templates for addresses, so that we do not waste memory.  */\n-      templ = VEC_index (mem_addr_template, mem_addr_template_list, templ_index);\n+      templ = &VEC_index (mem_addr_template, mem_addr_template_list,\n+\t\t\t  templ_index);\n       if (!templ->ref)\n \t{\n \t  sym = (addr->symbol ?"}, {"sha": "4b798b70b5c53486126219ab8fd64bc3c254acc7", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -130,6 +130,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"gimple-fold.h\"\n #include \"params.h\"\n+#include \"hash-table.h\"\n \n \n /* Possible lattice values.  */\n@@ -1687,11 +1688,17 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n+typedef hash_table <gimple_statement_d, typed_pointer_hash<gimple_statement_d>,\n+\t\t    typed_pointer_equal<gimple_statement_d>,\n+\t\t    typed_null_remove<gimple_statement_d> >\n+\t\t   gimple_htab;\n+\n /* Given a BUILT_IN_STACK_SAVE value SAVED_VAL, insert a clobber of VAR before\n    each matching BUILT_IN_STACK_RESTORE.  Mark visited phis in VISITED.  */\n \n static void\n-insert_clobber_before_stack_restore (tree saved_val, tree var, htab_t *visited)\n+insert_clobber_before_stack_restore (tree saved_val, tree var,\n+\t\t\t\t     gimple_htab *visited)\n {\n   gimple stmt, clobber_stmt;\n   tree clobber;\n@@ -1711,10 +1718,10 @@ insert_clobber_before_stack_restore (tree saved_val, tree var, htab_t *visited)\n       }\n     else if (gimple_code (stmt) == GIMPLE_PHI)\n       {\n-\tif (*visited == NULL)\n-\t  *visited = htab_create (10, htab_hash_pointer, htab_eq_pointer, NULL);\n+\tif (!visited->is_created ())\n+\t  visited->create (10);\n \n-\tslot = (gimple *)htab_find_slot (*visited, stmt, INSERT);\n+\tslot = visited->find_slot (stmt, INSERT);\n \tif (*slot != NULL)\n \t  continue;\n \n@@ -1757,7 +1764,7 @@ insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n {\n   gimple stmt;\n   tree saved_val;\n-  htab_t visited = NULL;\n+  gimple_htab visited;\n \n   for (; !gsi_end_p (i); gsi_prev_dom_bb_nondebug (&i))\n     {\n@@ -1774,8 +1781,8 @@ insert_clobbers_for_var (gimple_stmt_iterator i, tree var)\n       break;\n     }\n \n-  if (visited != NULL)\n-    htab_delete (visited);\n+  if (visited.is_created ())\n+    visited.dispose ();\n }\n \n /* Detects a __builtin_alloca_with_align with constant size argument.  Declares"}, {"sha": "c8557ac56ed11d481542a6871cf36308af6afd51", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"dumpfile.h\"\n #include \"tree-flow.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tree-ssa-live.h\"\n #include \"diagnostic-core.h\"\n \n@@ -1258,22 +1258,19 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n     }\n }\n \n-/* Returns a hash code for P.  */\n+/* Returns a hash code for N.  */\n \n-static hashval_t\n-hash_ssa_name_by_var (const void *p)\n+inline hashval_t\n+hash_ssa_name_by_var (const_tree n)\n {\n-  const_tree n = (const_tree) p;\n   return (hashval_t) htab_hash_pointer (SSA_NAME_VAR (n));\n }\n \n-/* Returns nonzero if P1 and P2 are equal.  */\n+/* Returns nonzero if N1 and N2 are equal.  */\n \n-static int\n-eq_ssa_name_by_var (const void *p1, const void *p2)\n+inline int\n+eq_ssa_name_by_var (const_tree n1, const_tree n2)\n {\n-  const_tree n1 = (const_tree) p1;\n-  const_tree n2 = (const_tree) p2;\n   return SSA_NAME_VAR (n1) == SSA_NAME_VAR (n2);\n }\n \n@@ -1289,7 +1286,9 @@ coalesce_ssa_name (void)\n   bitmap used_in_copies = BITMAP_ALLOC (NULL);\n   var_map map;\n   unsigned int i;\n-  static htab_t ssa_name_hash;\n+  static hash_table <tree_node, hash_ssa_name_by_var, eq_ssa_name_by_var,\n+\t\t     typed_null_remove<tree_node> >\n+\t\t    ssa_name_hash;\n \n   cl = create_coalesce_list ();\n   map = create_outofssa_var_map (cl, used_in_copies);\n@@ -1298,8 +1297,7 @@ coalesce_ssa_name (void)\n      so debug info remains undisturbed.  */\n   if (!optimize)\n     {\n-      ssa_name_hash = htab_create (10, hash_ssa_name_by_var,\n-      \t\t\t\t   eq_ssa_name_by_var, NULL);\n+      ssa_name_hash.create (10);\n       for (i = 1; i < num_ssa_names; i++)\n \t{\n \t  tree a = ssa_name (i);\n@@ -1309,7 +1307,7 @@ coalesce_ssa_name (void)\n \t      && !DECL_IGNORED_P (SSA_NAME_VAR (a))\n \t      && (!has_zero_uses (a) || !SSA_NAME_IS_DEFAULT_DEF (a)))\n \t    {\n-\t      tree *slot = (tree *) htab_find_slot (ssa_name_hash, a, INSERT);\n+\t      tree *slot = ssa_name_hash.find_slot (a, INSERT);\n \n \t      if (!*slot)\n \t\t*slot = a;\n@@ -1322,7 +1320,7 @@ coalesce_ssa_name (void)\n \t\t}\n \t    }\n \t}\n-      htab_delete (ssa_name_hash);\n+      ssa_name_hash.dispose ();\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);"}, {"sha": "d3795be6ebeada3d6ad1e1e0569884c191b5c9d6", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1734,7 +1734,8 @@ dom_opt_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n-  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n+  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack,\n+\t\t (expr_hash_elt_t)NULL);\n   VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (bb);\n@@ -1745,7 +1746,8 @@ dom_opt_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   /* Create equivalences from redundant PHIs.  PHIs are only truly\n      redundant when they exist in the same block, so push another\n      marker and unwind right afterwards.  */\n-  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n+  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack,\n+\t\t (expr_hash_elt_t)NULL);\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     eliminate_redundant_computations (&gsi);\n   remove_local_expressions_from_table ();\n@@ -1800,7 +1802,8 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  /* Push a marker onto the available expression stack so that we\n \t     unwind any expressions related to the TRUE arm before processing\n \t     the false arm below.  */\n-          VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n+          VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack,\n+\t\t\t (expr_hash_elt_t)NULL);\n \t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n \n \t  edge_info = (struct edge_info *) true_edge->aux;"}, {"sha": "c0a825229d764dbe52b08244d7d39583ab81fa64", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -3120,7 +3120,7 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n \n    TODO -- there must be some better way.  This all is quite crude.  */\n \n-typedef struct\n+typedef struct address_cost_data_s\n {\n   HOST_WIDE_INT min_offset, max_offset;\n   unsigned costs[2][2][2][2];"}, {"sha": "51d9e02228de1c220e5825bfc3865faf78a5260a", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-flow.h\"\n #include \"gimple.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tree-iterator.h\"\n #include \"alloc-pool.h\"\n #include \"obstack.h\"\n@@ -177,12 +177,11 @@ typedef struct pre_expr_d\n #define PRE_EXPR_REFERENCE(e) (e)->u.reference\n #define PRE_EXPR_CONSTANT(e) (e)->u.constant\n \n-static int\n-pre_expr_eq (const void *p1, const void *p2)\n-{\n-  const struct pre_expr_d *e1 = (const struct pre_expr_d *) p1;\n-  const struct pre_expr_d *e2 = (const struct pre_expr_d *) p2;\n+/* Compare E1 and E1 for equality.  */\n \n+inline int\n+ssa_pre_expr_eq (const struct pre_expr_d *e1, const struct pre_expr_d *e2)\n+{\n   if (e1->kind != e2->kind)\n     return false;\n \n@@ -203,10 +202,11 @@ pre_expr_eq (const void *p1, const void *p2)\n     }\n }\n \n-static hashval_t\n-pre_expr_hash (const void *p1)\n+/* Hash E.  */\n+\n+inline hashval_t\n+ssa_pre_expr_hash (const struct pre_expr_d *e)\n {\n-  const struct pre_expr_d *e = (const struct pre_expr_d *) p1;\n   switch (e->kind)\n     {\n     case CONSTANT:\n@@ -222,23 +222,24 @@ pre_expr_hash (const void *p1)\n     }\n }\n \n-\n /* Next global expression id number.  */\n static unsigned int next_expression_id;\n \n /* Mapping from expression to id number we can use in bitmap sets.  */\n DEF_VEC_P (pre_expr);\n DEF_VEC_ALLOC_P (pre_expr, heap);\n static VEC(pre_expr, heap) *expressions;\n-static htab_t expression_to_id;\n+static hash_table <pre_expr_d, ssa_pre_expr_hash, ssa_pre_expr_eq,\n+\t\t   typed_null_remove <pre_expr_d> >\n+\t\t  expression_to_id;\n static VEC(unsigned, heap) *name_to_id;\n \n /* Allocate an expression id for EXPR.  */\n \n static inline unsigned int\n alloc_expression_id (pre_expr expr)\n {\n-  void **slot;\n+  struct pre_expr_d **slot;\n   /* Make sure we won't overflow. */\n   gcc_assert (next_expression_id + 1 > next_expression_id);\n   expr->id = next_expression_id++;\n@@ -257,7 +258,7 @@ alloc_expression_id (pre_expr expr)\n     }\n   else\n     {\n-      slot = htab_find_slot (expression_to_id, expr, INSERT);\n+      slot = expression_to_id.find_slot (expr, INSERT);\n       gcc_assert (!*slot);\n       *slot = expr;\n     }\n@@ -275,7 +276,7 @@ get_expression_id (const pre_expr expr)\n static inline unsigned int\n lookup_expression_id (const pre_expr expr)\n {\n-  void **slot;\n+  struct pre_expr_d **slot;\n \n   if (expr->kind == NAME)\n     {\n@@ -286,7 +287,7 @@ lookup_expression_id (const pre_expr expr)\n     }\n   else\n     {\n-      slot = htab_find_slot (expression_to_id, expr, NO_INSERT);\n+      slot = expression_to_id.find_slot (expr, NO_INSERT);\n       if (!slot)\n \treturn 0;\n       return ((pre_expr)*slot)->id;\n@@ -479,11 +480,6 @@ static bitmap need_eh_cleanup;\n /* Set of blocks with statements that have had their AB properties changed.  */\n static bitmap need_ab_cleanup;\n \n-/* The phi_translate_table caches phi translations for a given\n-   expression and predecessor.  */\n-\n-static htab_t phi_translate_table;\n-\n /* A three tuple {e, pred, v} used to cache phi translations in the\n    phi_translate_table.  */\n \n@@ -506,50 +502,56 @@ typedef const struct expr_pred_trans_d *const_expr_pred_trans_t;\n \n /* Return the hash value for a phi translation table entry.  */\n \n-static hashval_t\n-expr_pred_trans_hash (const void *p)\n+inline hashval_t\n+ssa_expr_pred_trans_hash (const expr_pred_trans_d *ve)\n {\n-  const_expr_pred_trans_t const ve = (const_expr_pred_trans_t) p;\n   return ve->hashcode;\n }\n \n /* Return true if two phi translation table entries are the same.\n    P1 and P2 should point to the expr_pred_trans_t's to be compared.*/\n \n-static int\n-expr_pred_trans_eq (const void *p1, const void *p2)\n+inline int\n+ssa_expr_pred_trans_eq (const expr_pred_trans_d *ve1,\n+\t\t\tconst expr_pred_trans_d *ve2)\n {\n-  const_expr_pred_trans_t const ve1 = (const_expr_pred_trans_t) p1;\n-  const_expr_pred_trans_t const ve2 = (const_expr_pred_trans_t) p2;\n   basic_block b1 = ve1->pred;\n   basic_block b2 = ve2->pred;\n \n   /* If they are not translations for the same basic block, they can't\n      be equal.  */\n   if (b1 != b2)\n     return false;\n-  return pre_expr_eq (ve1->e, ve2->e);\n+  return ssa_pre_expr_eq (ve1->e, ve2->e);\n }\n \n+/* The phi_translate_table caches phi translations for a given\n+   expression and predecessor.  */\n+\n+static hash_table <expr_pred_trans_d, ssa_expr_pred_trans_hash,\n+\t\t   ssa_expr_pred_trans_eq,\n+\t\t   typed_free_remove <expr_pred_trans_d> >\n+\t\t  phi_translate_table;\n+\n /* Search in the phi translation table for the translation of\n    expression E in basic block PRED.\n    Return the translated value, if found, NULL otherwise.  */\n \n static inline pre_expr\n phi_trans_lookup (pre_expr e, basic_block pred)\n {\n-  void **slot;\n+  expr_pred_trans_t *slot;\n   struct expr_pred_trans_d ept;\n \n   ept.e = e;\n   ept.pred = pred;\n-  ept.hashcode = iterative_hash_hashval_t (pre_expr_hash (e), pred->index);\n-  slot = htab_find_slot_with_hash (phi_translate_table, &ept, ept.hashcode,\n+  ept.hashcode = iterative_hash_hashval_t (ssa_pre_expr_hash (e), pred->index);\n+  slot = phi_translate_table.find_slot_with_hash (&ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n     return NULL;\n   else\n-    return ((expr_pred_trans_t) *slot)->v;\n+    return (*slot)->v;\n }\n \n \n@@ -559,18 +561,18 @@ phi_trans_lookup (pre_expr e, basic_block pred)\n static inline void\n phi_trans_add (pre_expr e, pre_expr v, basic_block pred)\n {\n-  void **slot;\n+  expr_pred_trans_t *slot;\n   expr_pred_trans_t new_pair = XNEW (struct expr_pred_trans_d);\n   new_pair->e = e;\n   new_pair->pred = pred;\n   new_pair->v = v;\n-  new_pair->hashcode = iterative_hash_hashval_t (pre_expr_hash (e),\n+  new_pair->hashcode = iterative_hash_hashval_t (ssa_pre_expr_hash (e),\n \t\t\t\t\t\t pred->index);\n \n-  slot = htab_find_slot_with_hash (phi_translate_table, new_pair,\n+  slot = phi_translate_table.find_slot_with_hash (new_pair,\n \t\t\t\t   new_pair->hashcode, INSERT);\n   free (*slot);\n-  *slot = (void *) new_pair;\n+  *slot = new_pair;\n }\n \n \n@@ -1607,12 +1609,12 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\tif (double_int_fits_in_shwi_p (off))\n \t\t  newop.off = off.low;\n \t      }\n-\t    VEC_replace (vn_reference_op_s, newoperands, j, &newop);\n+\t    VEC_replace (vn_reference_op_s, newoperands, j, newop);\n \t    /* If it transforms from an SSA_NAME to an address, fold with\n \t       a preceding indirect reference.  */\n \t    if (j > 0 && op[0] && TREE_CODE (op[0]) == ADDR_EXPR\n \t\t&& VEC_index (vn_reference_op_s,\n-\t\t\t      newoperands, j - 1)->opcode == MEM_REF)\n+\t\t\t      newoperands, j - 1).opcode == MEM_REF)\n \t      vn_reference_fold_indirect (&newoperands, &j);\n \t  }\n \tif (i != VEC_length (vn_reference_op_s, operands))\n@@ -2596,8 +2598,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t\t\t\t  unsigned int *operand, gimple_seq *stmts,\n \t\t\t\t  gimple domstmt)\n {\n-  vn_reference_op_t currop = VEC_index (vn_reference_op_s, ref->operands,\n-\t\t\t\t\t*operand);\n+  vn_reference_op_t currop = &VEC_index (vn_reference_op_s, ref->operands,\n+\t\t\t\t\t *operand);\n   tree genop;\n   ++*operand;\n   switch (currop->opcode)\n@@ -2674,8 +2676,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n       {\n \tpre_expr op0expr, op1expr;\n \ttree genop0 = NULL_TREE, genop1 = NULL_TREE;\n-\tvn_reference_op_t nextop = VEC_index (vn_reference_op_s, ref->operands,\n-\t\t\t\t\t      ++*operand);\n+\tvn_reference_op_t nextop = &VEC_index (vn_reference_op_s, ref->operands,\n+\t\t\t\t\t       ++*operand);\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t\tstmts, domstmt);\n \tif (!baseop)\n@@ -3493,7 +3495,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t\t    do_insertion = true;\n \t\t  if (first_s == NULL)\n \t\t    first_s = edoubleprime;\n-\t\t  else if (!pre_expr_eq (first_s, edoubleprime))\n+\t\t  else if (!ssa_pre_expr_eq (first_s, edoubleprime))\n \t\t    all_same = false;\n \t\t}\n \t    }\n@@ -4774,7 +4776,7 @@ init_pre (bool do_fre)\n \n   next_expression_id = 1;\n   expressions = NULL;\n-  VEC_safe_push (pre_expr, heap, expressions, NULL);\n+  VEC_safe_push (pre_expr, heap, expressions, (pre_expr)NULL);\n   value_expressions = VEC_alloc (bitmap_set_t, heap, get_max_value_id () + 1);\n   VEC_safe_grow_cleared (bitmap_set_t, heap, value_expressions,\n \t\t\t get_max_value_id() + 1);\n@@ -4797,11 +4799,8 @@ init_pre (bool do_fre)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n-\t\t\t\t     expr_pred_trans_eq, free);\n-  expression_to_id = htab_create (num_ssa_names * 3,\n-\t\t\t\t  pre_expr_hash,\n-\t\t\t\t  pre_expr_eq, NULL);\n+  phi_translate_table.create (5110);\n+  expression_to_id.create (num_ssa_names * 3);\n   bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n \t\t\t\t       sizeof (struct bitmap_set), 30);\n   pre_expr_pool = create_alloc_pool (\"pre_expr nodes\",\n@@ -4833,8 +4832,8 @@ fini_pre (bool do_fre)\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (bitmap_set_pool);\n   free_alloc_pool (pre_expr_pool);\n-  htab_delete (phi_translate_table);\n-  htab_delete (expression_to_id);\n+  phi_translate_table.dispose ();\n+  expression_to_id.dispose ();\n   VEC_free (unsigned, heap, name_to_id);\n \n   free_aux_for_blocks ();"}, {"sha": "2b1298d14025dbbf8150f69afa2674c853d7d8f8", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -962,7 +962,7 @@ static VEC (oecount, heap) *cvec;\n static hashval_t\n oecount_hash (const void *p)\n {\n-  const oecount *c = VEC_index (oecount, cvec, (size_t)p - 42);\n+  const oecount *c = &VEC_index (oecount, cvec, (size_t)p - 42);\n   return htab_hash_pointer (c->op) ^ (hashval_t)c->oecode;\n }\n \n@@ -971,8 +971,8 @@ oecount_hash (const void *p)\n static int\n oecount_eq (const void *p1, const void *p2)\n {\n-  const oecount *c1 = VEC_index (oecount, cvec, (size_t)p1 - 42);\n-  const oecount *c2 = VEC_index (oecount, cvec, (size_t)p2 - 42);\n+  const oecount *c1 = &VEC_index (oecount, cvec, (size_t)p1 - 42);\n+  const oecount *c2 = &VEC_index (oecount, cvec, (size_t)p2 - 42);\n   return (c1->oecode == c2->oecode\n \t  && c1->op == c2->op);\n }\n@@ -1354,7 +1354,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t  else\n \t    {\n \t      VEC_pop (oecount, cvec);\n-\t      VEC_index (oecount, cvec, (size_t)*slot - 42)->cnt++;\n+\t      VEC_index (oecount, cvec, (size_t)*slot - 42).cnt++;\n \t    }\n \t}\n     }\n@@ -1381,7 +1381,7 @@ undistribute_ops_list (enum tree_code opcode,\n   candidates2 = sbitmap_alloc (length);\n   while (!VEC_empty (oecount, cvec))\n     {\n-      oecount *c = VEC_last (oecount, cvec);\n+      oecount *c = &VEC_last (oecount, cvec);\n       if (c->cnt < 2)\n \tbreak;\n \n@@ -3190,7 +3190,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \t\t  fputs (\"Multiplying by cached product \", dump_file);\n \t\t  for (elt = j; elt < vec_len; elt++)\n \t\t    {\n-\t\t      rf = VEC_index (repeat_factor, repeat_factor_vec, elt);\n+\t\t      rf = &VEC_index (repeat_factor, repeat_factor_vec, elt);\n \t\t      print_generic_expr (dump_file, rf->factor, 0);\n \t\t      if (elt < vec_len - 1)\n \t\t\tfputs (\" * \", dump_file);\n@@ -3216,7 +3216,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \t\t\t dump_file);\n \t\t  for (elt = j; elt < vec_len; elt++)\n \t\t    {\n-\t\t      rf = VEC_index (repeat_factor, repeat_factor_vec, elt);\n+\t\t      rf = &VEC_index (repeat_factor, repeat_factor_vec, elt);\n \t\t      print_generic_expr (dump_file, rf->factor, 0);\n \t\t      if (elt < vec_len - 1)\n \t\t\tfputs (\" * \", dump_file);\n@@ -3250,7 +3250,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \t      fputs (\"Building __builtin_pow call for (\", dump_file);\n \t      for (elt = j; elt < vec_len; elt++)\n \t\t{\n-\t\t  rf = VEC_index (repeat_factor, repeat_factor_vec, elt);\n+\t\t  rf = &VEC_index (repeat_factor, repeat_factor_vec, elt);\n \t\t  print_generic_expr (dump_file, rf->factor, 0);\n \t\t  if (elt < vec_len - 1)\n \t\t    fputs (\" * \", dump_file);\n@@ -3275,8 +3275,8 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \t\t{\n \t\t  tree op1, op2;\n \n-\t\t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, ii);\n-\t\t  rf2 = VEC_index (repeat_factor, repeat_factor_vec, ii + 1);\n+\t\t  rf1 = &VEC_index (repeat_factor, repeat_factor_vec, ii);\n+\t\t  rf2 = &VEC_index (repeat_factor, repeat_factor_vec, ii + 1);\n \n \t\t  /* Init the last factor's representative to be itself.  */\n \t\t  if (!rf2->repr)\n@@ -3300,7 +3300,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \n \t  /* Form a call to __builtin_powi for the maximum product\n \t     just formed, raised to the power obtained earlier.  */\n-\t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, j);\n+\t  rf1 = &VEC_index (repeat_factor, repeat_factor_vec, j);\n \t  iter_result = make_temp_ssa_name (type, NULL, \"reassocpow\");\n \t  pow_stmt = gimple_build_call (powi_fndecl, 2, rf1->repr, \n \t\t\t\t\tbuild_int_cst (integer_type_node,\n@@ -3333,7 +3333,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \t  unsigned k = power;\n \t  unsigned n;\n \n-\t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, i);\n+\t  rf1 = &VEC_index (repeat_factor, repeat_factor_vec, i);\n \t  rf1->count -= power;\n \t  \n \t  FOR_EACH_VEC_ELT_REVERSE (operand_entry_t, *ops, n, oe)"}, {"sha": "5756df330df224735702dfc49667017097aca9a7", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -775,7 +775,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n   alias_set_type base_alias_set = -1;\n \n   /* First get the final access size from just the outermost expression.  */\n-  op = VEC_index (vn_reference_op_s, ops, 0);\n+  op = &VEC_index (vn_reference_op_s, ops, 0);\n   if (op->opcode == COMPONENT_REF)\n     size_tree = DECL_SIZE (op->op0);\n   else if (op->opcode == BIT_FIELD_REF)\n@@ -815,7 +815,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t      && op->op0\n \t      && DECL_P (TREE_OPERAND (op->op0, 0)))\n \t    {\n-\t      vn_reference_op_t pop = VEC_index (vn_reference_op_s, ops, i-1);\n+\t      vn_reference_op_t pop = &VEC_index (vn_reference_op_s, ops, i-1);\n \t      base = TREE_OPERAND (op->op0, 0);\n \t      if (pop->off == -1)\n \t\t{\n@@ -1004,8 +1004,8 @@ vn_reference_fold_indirect (VEC (vn_reference_op_s, heap) **ops,\n \t\t\t    unsigned int *i_p)\n {\n   unsigned int i = *i_p;\n-  vn_reference_op_t op = VEC_index (vn_reference_op_s, *ops, i);\n-  vn_reference_op_t mem_op = VEC_index (vn_reference_op_s, *ops, i - 1);\n+  vn_reference_op_t op = &VEC_index (vn_reference_op_s, *ops, i);\n+  vn_reference_op_t mem_op = &VEC_index (vn_reference_op_s, *ops, i - 1);\n   tree addr_base;\n   HOST_WIDE_INT addr_offset;\n \n@@ -1036,8 +1036,8 @@ vn_reference_maybe_forwprop_address (VEC (vn_reference_op_s, heap) **ops,\n \t\t\t\t     unsigned int *i_p)\n {\n   unsigned int i = *i_p;\n-  vn_reference_op_t op = VEC_index (vn_reference_op_s, *ops, i);\n-  vn_reference_op_t mem_op = VEC_index (vn_reference_op_s, *ops, i - 1);\n+  vn_reference_op_t op = &VEC_index (vn_reference_op_s, *ops, i);\n+  vn_reference_op_t mem_op = &VEC_index (vn_reference_op_s, *ops, i - 1);\n   gimple def_stmt;\n   enum tree_code code;\n   double_int off;\n@@ -1114,7 +1114,7 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n \n   /* Try to simplify the translated expression if it is\n      a call to a builtin function with at most two arguments.  */\n-  op = VEC_index (vn_reference_op_s, operands, 0);\n+  op = &VEC_index (vn_reference_op_s, operands, 0);\n   if (op->opcode == CALL_EXPR\n       && TREE_CODE (op->op0) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (op->op0, 0)) == FUNCTION_DECL\n@@ -1124,9 +1124,9 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n     {\n       vn_reference_op_t arg0, arg1 = NULL;\n       bool anyconst = false;\n-      arg0 = VEC_index (vn_reference_op_s, operands, 1);\n+      arg0 = &VEC_index (vn_reference_op_s, operands, 1);\n       if (VEC_length (vn_reference_op_s, operands) > 2)\n-\targ1 = VEC_index (vn_reference_op_s, operands, 2);\n+\targ1 = &VEC_index (vn_reference_op_s, operands, 2);\n       if (TREE_CODE_CLASS (arg0->opcode) == tcc_constant\n \t  || (arg0->opcode == ADDR_EXPR\n \t      && is_gimple_min_invariant (arg0->op0)))\n@@ -1158,7 +1158,7 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n \t   && VEC_length (vn_reference_op_s, operands) == 2)\n     {\n       vn_reference_op_t arg0;\n-      arg0 = VEC_index (vn_reference_op_s, operands, 1);\n+      arg0 = &VEC_index (vn_reference_op_s, operands, 1);\n       if (arg0->opcode == STRING_CST\n \t  && (TYPE_MODE (op->type)\n \t      == TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0->op0))))\n@@ -1226,12 +1226,12 @@ valueize_refs_1 (VEC (vn_reference_op_s, heap) *orig, bool *valueized_anything)\n \t  && vro->op0\n \t  && TREE_CODE (vro->op0) == ADDR_EXPR\n \t  && VEC_index (vn_reference_op_s,\n-\t\t\torig, i - 1)->opcode == MEM_REF)\n+\t\t\torig, i - 1).opcode == MEM_REF)\n \tvn_reference_fold_indirect (&orig, &i);\n       else if (i > 0\n \t       && vro->opcode == SSA_NAME\n \t       && VEC_index (vn_reference_op_s,\n-\t\t\t     orig, i - 1)->opcode == MEM_REF)\n+\t\t\t     orig, i - 1).opcode == MEM_REF)\n \tvn_reference_maybe_forwprop_address (&orig, &i);\n       /* If it transforms a non-constant ARRAY_REF into a constant\n \t one, adjust the constant offset.  */\n@@ -1624,9 +1624,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n       i = VEC_length (vn_reference_op_s, vr->operands) - 1;\n       j = VEC_length (vn_reference_op_s, lhs_ops) - 1;\n       while (j >= 0 && i >= 0\n-\t     && vn_reference_op_eq (VEC_index (vn_reference_op_s,\n-\t\t\t\t\t       vr->operands, i),\n-\t\t\t\t    VEC_index (vn_reference_op_s, lhs_ops, j)))\n+\t     && vn_reference_op_eq (&VEC_index (vn_reference_op_s,\n+\t\t\t\t\t        vr->operands, i),\n+\t\t\t\t    &VEC_index (vn_reference_op_s, lhs_ops, j)))\n \t{\n \t  i--;\n \t  j--;\n@@ -1639,10 +1639,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n \t don't care here - further lookups with the rewritten operands\n \t will simply fail if we messed up types too badly.  */\n       if (j == 0 && i >= 0\n-\t  && VEC_index (vn_reference_op_s, lhs_ops, 0)->opcode == MEM_REF\n-\t  && VEC_index (vn_reference_op_s, lhs_ops, 0)->off != -1\n-\t  && (VEC_index (vn_reference_op_s, lhs_ops, 0)->off\n-\t      == VEC_index (vn_reference_op_s, vr->operands, i)->off))\n+\t  && VEC_index (vn_reference_op_s, lhs_ops, 0).opcode == MEM_REF\n+\t  && VEC_index (vn_reference_op_s, lhs_ops, 0).off != -1\n+\t  && (VEC_index (vn_reference_op_s, lhs_ops, 0).off\n+\t      == VEC_index (vn_reference_op_s, vr->operands, i).off))\n \ti--, j--;\n \n       /* i now points to the first additional op.\n@@ -1669,7 +1669,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n \tVEC_truncate (vn_reference_op_s, vr->operands,\n \t\t      i + 1 + VEC_length (vn_reference_op_s, rhs));\n       FOR_EACH_VEC_ELT (vn_reference_op_s, rhs, j, vro)\n-\tVEC_replace (vn_reference_op_s, vr->operands, i + 1 + j, vro);\n+\tVEC_replace (vn_reference_op_s, vr->operands, i + 1 + j, *vro);\n       VEC_free (vn_reference_op_s, heap, rhs);\n       vr->operands = valueize_refs (vr->operands);\n       vr->hashcode = vn_reference_compute_hash (vr);\n@@ -1807,12 +1807,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n       op.opcode = MEM_REF;\n       op.op0 = build_int_cst (ptr_type_node, at - rhs_offset);\n       op.off = at - lhs_offset + rhs_offset;\n-      VEC_replace (vn_reference_op_s, vr->operands, 0, &op);\n+      VEC_replace (vn_reference_op_s, vr->operands, 0, op);\n       op.type = TREE_TYPE (rhs);\n       op.opcode = TREE_CODE (rhs);\n       op.op0 = rhs;\n       op.off = -1;\n-      VEC_replace (vn_reference_op_s, vr->operands, 1, &op);\n+      VEC_replace (vn_reference_op_s, vr->operands, 1, op);\n       vr->hashcode = vn_reference_compute_hash (vr);\n \n       /* Adjust *ref from the new operands.  */\n@@ -3746,7 +3746,7 @@ DFS (tree name)\n \t  /* Restore the last use walker and continue walking there.  */\n \t  use = name;\n \t  name = VEC_pop (tree, namevec);\n-\t  memcpy (&iter, VEC_last (ssa_op_iter, itervec),\n+\t  memcpy (&iter, &VEC_last (ssa_op_iter, itervec),\n \t\t  sizeof (ssa_op_iter));\n \t  VEC_pop (ssa_op_iter, itervec);\n \t  goto continue_walking;"}, {"sha": "162502edcf73913c825f46fff4607d96be045a8d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -2927,7 +2927,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n   for (j = 0; j < n; j++)\n     {\n       varinfo_t curr;\n-      c = *VEC_index (ce_s, *results, j);\n+      c = VEC_index (ce_s, *results, j);\n       curr = get_varinfo (c.var);\n \n       if (c.type == ADDRESSOF\n@@ -2989,7 +2989,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n       else\n \tc.offset = rhsoffset;\n \n-      VEC_replace (ce_s, *results, j, &c);\n+      VEC_replace (ce_s, *results, j, c);\n     }\n }\n \n@@ -3058,7 +3058,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n      adding the required subset of sub-fields below.  */\n   get_constraint_for_1 (t, results, true, lhs_p);\n   gcc_assert (VEC_length (ce_s, *results) == 1);\n-  result = VEC_last (ce_s, *results);\n+  result = &VEC_last (ce_s, *results);\n \n   if (result->type == SCALAR\n       && get_varinfo (result->var)->is_full_var)\n@@ -3284,13 +3284,13 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n \t      if (address_p)\n \t\treturn;\n \n-\t      cs = *VEC_last (ce_s, *results);\n+\t      cs = VEC_last (ce_s, *results);\n \t      if (cs.type == DEREF\n \t\t  && type_can_have_subvars (TREE_TYPE (t)))\n \t\t{\n \t\t  /* For dereferences this means we have to defer it\n \t\t     to solving time.  */\n-\t\t  VEC_last (ce_s, *results)->offset = UNKNOWN_OFFSET;\n+\t\t  VEC_last (ce_s, *results).offset = UNKNOWN_OFFSET;\n \t\t  return;\n \t\t}\n \t      if (cs.type != SCALAR)\n@@ -3451,8 +3451,8 @@ do_structure_copy (tree lhsop, tree rhsop)\n \n   get_constraint_for (lhsop, &lhsc);\n   get_constraint_for_rhs (rhsop, &rhsc);\n-  lhsp = VEC_index (ce_s, lhsc, 0);\n-  rhsp = VEC_index (ce_s, rhsc, 0);\n+  lhsp = &VEC_index (ce_s, lhsc, 0);\n+  rhsp = &VEC_index (ce_s, rhsc, 0);\n   if (lhsp->type == DEREF\n       || (lhsp->type == ADDRESSOF && lhsp->var == anything_id)\n       || rhsp->type == DEREF)\n@@ -3481,7 +3481,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n       for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp);)\n \t{\n \t  varinfo_t lhsv, rhsv;\n-\t  rhsp = VEC_index (ce_s, rhsc, k);\n+\t  rhsp = &VEC_index (ce_s, rhsc, k);\n \t  lhsv = get_varinfo (lhsp->var);\n \t  rhsv = get_varinfo (rhsp->var);\n \t  if (lhsv->may_have_pointers\n@@ -4377,7 +4377,7 @@ find_func_aliases_for_call (gimple t)\n \t  lhs = get_function_part_constraint (fi, fi_parm_base + j);\n \t  while (VEC_length (ce_s, rhsc) != 0)\n \t    {\n-\t      rhsp = VEC_last (ce_s, rhsc);\n+\t      rhsp = &VEC_last (ce_s, rhsc);\n \t      process_constraint (new_constraint (lhs, *rhsp));\n \t      VEC_pop (ce_s, rhsc);\n \t    }\n@@ -4399,7 +4399,7 @@ find_func_aliases_for_call (gimple t)\n \t      VEC(ce_s, heap) *tem = NULL;\n \t      VEC_safe_push (ce_s, heap, tem, &rhs);\n \t      do_deref (&tem);\n-\t      rhs = *VEC_index (ce_s, tem, 0);\n+\t      rhs = VEC_index (ce_s, tem, 0);\n \t      VEC_free(ce_s, heap, tem);\n \t    }\n \t  FOR_EACH_VEC_ELT (ce_s, lhsc, j, lhsp)\n@@ -4471,7 +4471,7 @@ find_func_aliases (gimple origt)\n \t      struct constraint_expr *c2;\n \t      while (VEC_length (ce_s, rhsc) > 0)\n \t\t{\n-\t\t  c2 = VEC_last (ce_s, rhsc);\n+\t\t  c2 = &VEC_last (ce_s, rhsc);\n \t\t  process_constraint (new_constraint (*c, *c2));\n \t\t  VEC_pop (ce_s, rhsc);\n \t\t}\n@@ -5158,7 +5158,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t    bool must_have_pointers_p;\n \n \t    if (!VEC_empty (fieldoff_s, *fieldstack))\n-\t      pair = VEC_last (fieldoff_s, *fieldstack);\n+\t      pair = &VEC_last (fieldoff_s, *fieldstack);\n \n \t    /* If there isn't anything at offset zero, create sth.  */\n \t    if (!pair"}, {"sha": "ec644ee354157308d76952381d6ae20aea6139d8", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -193,7 +193,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"tree-ssa-alias.h\"\n #include \"params.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-ssa-sccvn.h\"\n #include \"tree-dump.h\"\n@@ -368,11 +368,10 @@ same_succ_print (FILE *file, const same_succ e)\n \n /* Prints same_succ VE to VFILE.  */\n \n-static int\n-same_succ_print_traverse (void **ve, void *vfile)\n+inline int\n+ssa_same_succ_print_traverse (same_succ *pe, FILE *file)\n {\n-  const same_succ e = *((const same_succ *)ve);\n-  FILE *file = ((FILE*)vfile);\n+  const same_succ e = *pe;\n   same_succ_print (file, e);\n   return 1;\n }\n@@ -416,10 +415,9 @@ stmt_update_dep_bb (gimple stmt)\n \n /* Calculates hash value for same_succ VE.  */\n \n-static hashval_t\n-same_succ_hash (const void *ve)\n+hashval_t\n+ssa_same_succ_hash (const_same_succ e)\n {\n-  const_same_succ e = (const_same_succ)ve;\n   hashval_t hashval = bitmap_hash (e->succs);\n   int flags;\n   unsigned int i;\n@@ -515,11 +513,9 @@ inverse_flags (const_same_succ e1, const_same_succ e2)\n \n /* Compares SAME_SUCCs VE1 and VE2.  */\n \n-static int\n-same_succ_equal (const void *ve1, const void *ve2)\n+int\n+ssa_same_succ_equal (const_same_succ e1, const_same_succ e2)\n {\n-  const_same_succ e1 = (const_same_succ)ve1;\n-  const_same_succ e2 = (const_same_succ)ve2;\n   unsigned int i, first1, first2;\n   gimple_stmt_iterator gsi1, gsi2;\n   gimple s1, s2;\n@@ -590,17 +586,15 @@ same_succ_alloc (void)\n \n /* Delete same_succ VE.  */\n \n-static void\n-same_succ_delete (void *ve)\n+inline void\n+ssa_same_succ_delete (same_succ e)\n {\n-  same_succ e = (same_succ)ve;\n-\n   BITMAP_FREE (e->bbs);\n   BITMAP_FREE (e->succs);\n   BITMAP_FREE (e->inverse);\n   VEC_free (int, heap, e->succ_flags);\n \n-  XDELETE (ve);\n+  XDELETE (e);\n }\n \n /* Reset same_succ SAME.  */\n@@ -616,7 +610,9 @@ same_succ_reset (same_succ same)\n \n /* Hash table with all same_succ entries.  */\n \n-static htab_t same_succ_htab;\n+static hash_table <struct same_succ_def, ssa_same_succ_hash,\n+\t\t   ssa_same_succ_equal, ssa_same_succ_delete>\n+\t\t  same_succ_htab;\n \n /* Array that is used to store the edge flags for a successor.  */\n \n@@ -637,7 +633,7 @@ extern void debug_same_succ (void);\n DEBUG_FUNCTION void\n debug_same_succ ( void)\n {\n-  htab_traverse (same_succ_htab, same_succ_print_traverse, stderr);\n+  same_succ_htab.traverse <FILE *, ssa_same_succ_print_traverse> (stderr);\n }\n \n DEF_VEC_P (same_succ);\n@@ -696,10 +692,9 @@ find_same_succ_bb (basic_block bb, same_succ *same_p)\n   EXECUTE_IF_SET_IN_BITMAP (same->succs, 0, j, bj)\n     VEC_safe_push (int, heap, same->succ_flags, same_succ_edge_flags[j]);\n \n-  same->hashval = same_succ_hash (same);\n+  same->hashval = ssa_same_succ_hash (same);\n \n-  slot = (same_succ *) htab_find_slot_with_hash (same_succ_htab, same,\n-\t\t\t\t\t\t   same->hashval, INSERT);\n+  slot = same_succ_htab.find_slot_with_hash (same, same->hashval, INSERT);\n   if (*slot == NULL)\n     {\n       *slot = same;\n@@ -733,7 +728,7 @@ find_same_succ (void)\n \tsame = same_succ_alloc ();\n     }\n \n-  same_succ_delete (same);\n+  ssa_same_succ_delete (same);\n }\n \n /* Initializes worklist administration.  */\n@@ -742,9 +737,7 @@ static void\n init_worklist (void)\n {\n   alloc_aux_for_blocks (sizeof (struct aux_bb_info));\n-  same_succ_htab\n-    = htab_create (n_basic_blocks, same_succ_hash, same_succ_equal,\n-\t\t   same_succ_delete);\n+  same_succ_htab.create (n_basic_blocks);\n   same_succ_edge_flags = XCNEWVEC (int, last_basic_block);\n   deleted_bbs = BITMAP_ALLOC (NULL);\n   deleted_bb_preds = BITMAP_ALLOC (NULL);\n@@ -764,8 +757,7 @@ static void\n delete_worklist (void)\n {\n   free_aux_for_blocks ();\n-  htab_delete (same_succ_htab);\n-  same_succ_htab = NULL;\n+  same_succ_htab.dispose ();\n   XDELETEVEC (same_succ_edge_flags);\n   same_succ_edge_flags = NULL;\n   BITMAP_FREE (deleted_bbs);\n@@ -795,7 +787,7 @@ same_succ_flush_bb (basic_block bb)\n   same_succ same = BB_SAME_SUCC (bb);\n   BB_SAME_SUCC (bb) = NULL;\n   if (bitmap_single_bit_set_p (same->bbs))\n-    htab_remove_elt_with_hash (same_succ_htab, same, same->hashval);\n+    same_succ_htab.remove_elt_with_hash (same, same->hashval);\n   else\n     bitmap_clear_bit (same->bbs, bb->index);\n }\n@@ -868,7 +860,7 @@ update_worklist (void)\n       if (same == NULL)\n \tsame = same_succ_alloc ();\n     }\n-  same_succ_delete (same);\n+  ssa_same_succ_delete (same);\n   bitmap_clear (deleted_bb_preds);\n }\n \n@@ -1637,7 +1629,7 @@ tail_merge_optimize (unsigned int todo)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"htab collision / search: %f\\n\",\n-\t     htab_collisions (same_succ_htab));\n+\t     same_succ_htab.collisions ());\n \n   if (nr_bbs_removed_total > 0)\n     {"}, {"sha": "3ecb3030d03674a610f7136f8710ab60b7993451", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"dumpfile.h\"\n #include \"cfgloop.h\"\n+#include \"hash-table.h\"\n \n /* Given a block B, update the CFG and SSA graph to reflect redirecting\n    one or more in-edges to B to instead reach the destination of an\n@@ -126,11 +127,8 @@ struct redirection_data\n   struct el *incoming_edges;\n };\n \n-/* Main data structure to hold information for duplicates of BB.  */\n-static htab_t redirection_data;\n-\n /* Data structure of information to pass to hash table traversal routines.  */\n-struct local_info\n+struct ssa_local_info_t\n {\n   /* The current block we are working on.  */\n   basic_block bb;\n@@ -220,24 +218,32 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n }\n \n /* Hashing and equality routines for our hash table.  */\n-static hashval_t\n-redirection_data_hash (const void *p)\n+inline hashval_t\n+ssa_redirection_data_hash (const struct redirection_data *p)\n {\n-  edge e = ((const struct redirection_data *)p)->outgoing_edge;\n+  edge e = p->outgoing_edge;\n   return e->dest->index;\n }\n \n-static int\n-redirection_data_eq (const void *p1, const void *p2)\n+inline int\n+ssa_redirection_data_eq (const struct redirection_data *p1,\n+\t\t\t const struct redirection_data *p2)\n {\n-  edge e1 = ((const struct redirection_data *)p1)->outgoing_edge;\n-  edge e2 = ((const struct redirection_data *)p2)->outgoing_edge;\n-  edge e3 = ((const struct redirection_data *)p1)->intermediate_edge;\n-  edge e4 = ((const struct redirection_data *)p2)->intermediate_edge;\n+  edge e1 = p1->outgoing_edge;\n+  edge e2 = p2->outgoing_edge;\n+  edge e3 = p1->intermediate_edge;\n+  edge e4 = p2->intermediate_edge;\n \n   return e1 == e2 && e3 == e4;\n }\n \n+/* Main data structure to hold information for duplicates of BB.  */\n+\n+static hash_table <struct redirection_data, ssa_redirection_data_hash,\n+\t\t   ssa_redirection_data_eq,\n+\t\t   typed_free_remove<struct redirection_data> >\n+\t\t  redirection_data;\n+\n /* Given an outgoing edge E lookup and return its entry in our hash table.\n \n    If INSERT is true, then we insert the entry into the hash table if\n@@ -247,7 +253,7 @@ redirection_data_eq (const void *p1, const void *p2)\n static struct redirection_data *\n lookup_redirection_data (edge e, enum insert_option insert)\n {\n-  void **slot;\n+  struct redirection_data **slot;\n   struct redirection_data *elt;\n \n  /* Build a hash table element so we can see if E is already\n@@ -259,7 +265,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n   elt->dup_block = NULL;\n   elt->incoming_edges = NULL;\n \n-  slot = htab_find_slot (redirection_data, elt, insert);\n+  slot = redirection_data.find_slot (elt, insert);\n \n   /* This will only happen if INSERT is false and the entry is not\n      in the hash table.  */\n@@ -273,7 +279,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n      INSERT is true.  */\n   if (*slot == NULL)\n     {\n-      *slot = (void *)elt;\n+      *slot = elt;\n       elt->incoming_edges = XNEW (struct el);\n       elt->incoming_edges->e = e;\n       elt->incoming_edges->next = NULL;\n@@ -287,7 +293,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n       free (elt);\n \n       /* Get the entry stored in the hash table.  */\n-      elt = (struct redirection_data *) *slot;\n+      elt = *slot;\n \n       /* If insertion was requested, then we need to add INCOMING_EDGE\n \t to the list of incoming edges associated with E.  */\n@@ -375,9 +381,9 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n \n /* Wire up the outgoing edges from the duplicate block and\n    update any PHIs as needed.  */\n-static void\n-fix_duplicate_block_edges (struct redirection_data *rd,\n-\t\t\t   struct local_info *local_info)\n+void\n+ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n+\t\t\t       ssa_local_info_t *local_info)\n {\n   /* If we were threading through an joiner block, then we want\n      to keep its control statement and redirect an outgoing edge.\n@@ -412,11 +418,11 @@ fix_duplicate_block_edges (struct redirection_data *rd,\n }\n /* Hash table traversal callback routine to create duplicate blocks.  */\n \n-static int\n-create_duplicates (void **slot, void *data)\n+int\n+ssa_create_duplicates (struct redirection_data **slot,\n+\t\t       ssa_local_info_t *local_info)\n {\n-  struct redirection_data *rd = (struct redirection_data *) *slot;\n-  struct local_info *local_info = (struct local_info *)data;\n+  struct redirection_data *rd = *slot;\n \n   /* Create a template block if we have not done so already.  Otherwise\n      use the template to create a new block.  */\n@@ -435,7 +441,7 @@ create_duplicates (void **slot, void *data)\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n \t block.   */\n-      fix_duplicate_block_edges (rd, local_info);\n+      ssa_fix_duplicate_block_edges (rd, local_info);\n     }\n \n   /* Keep walking the hash table.  */\n@@ -446,11 +452,11 @@ create_duplicates (void **slot, void *data)\n    block creation.  This hash table traversal callback creates the\n    outgoing edge for the template block.  */\n \n-static int\n-fixup_template_block (void **slot, void *data)\n+inline int\n+ssa_fixup_template_block (struct redirection_data **slot,\n+\t\t\t  ssa_local_info_t *local_info)\n {\n-  struct redirection_data *rd = (struct redirection_data *) *slot;\n-  struct local_info *local_info = (struct local_info *)data;\n+  struct redirection_data *rd = *slot;\n \n   /* If this is the template block halt the traversal after updating\n      it appropriately.\n@@ -461,7 +467,7 @@ fixup_template_block (void **slot, void *data)\n      a new outgoing edge.  In both cases we may need to update PHIs.  */\n   if (rd->dup_block && rd->dup_block == local_info->template_block)\n     {\n-      fix_duplicate_block_edges (rd, local_info);\n+      ssa_fix_duplicate_block_edges (rd, local_info);\n       return 0;\n     }\n \n@@ -471,11 +477,11 @@ fixup_template_block (void **slot, void *data)\n /* Hash table traversal callback to redirect each incoming edge\n    associated with this hash table element to its new destination.  */\n \n-static int\n-redirect_edges (void **slot, void *data)\n+int\n+ssa_redirect_edges (struct redirection_data **slot,\n+\t\t    ssa_local_info_t *local_info)\n {\n-  struct redirection_data *rd = (struct redirection_data *) *slot;\n-  struct local_info *local_info = (struct local_info *)data;\n+  struct redirection_data *rd = *slot;\n   struct el *next, *el;\n \n   /* Walk over all the incoming edges associated associated with this\n@@ -594,17 +600,14 @@ thread_block (basic_block bb, bool noloop_only)\n      redirect to a duplicate of BB.  */\n   edge e, e2;\n   edge_iterator ei;\n-  struct local_info local_info;\n+  ssa_local_info_t local_info;\n   struct loop *loop = bb->loop_father;\n \n   /* To avoid scanning a linear array for the element we need we instead\n      use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n      incoming and outgoing edges such linear searches can get expensive.  */\n-  redirection_data = htab_create (EDGE_COUNT (bb->succs),\n-\t\t\t\t  redirection_data_hash,\n-\t\t\t\t  redirection_data_eq,\n-\t\t\t\t  free);\n+  redirection_data.create (EDGE_COUNT (bb->succs));\n \n   /* If we thread the latch of the loop to its exit, the loop ceases to\n      exist.  Make sure we do not restrict ourselves in order to preserve\n@@ -678,24 +681,26 @@ thread_block (basic_block bb, bool noloop_only)\n   local_info.template_block = NULL;\n   local_info.bb = bb;\n   local_info.jumps_threaded = false;\n-  htab_traverse (redirection_data, create_duplicates, &local_info);\n+  redirection_data.traverse <ssa_local_info_t *, ssa_create_duplicates>\n+\t\t\t    (&local_info);\n \n   /* The template does not have an outgoing edge.  Create that outgoing\n      edge and update PHI nodes as the edge's target as necessary.\n \n      We do this after creating all the duplicates to avoid creating\n      unnecessary edges.  */\n-  htab_traverse (redirection_data, fixup_template_block, &local_info);\n+  redirection_data.traverse <ssa_local_info_t *, ssa_fixup_template_block>\n+\t\t\t    (&local_info);\n \n   /* The hash table traversals above created the duplicate blocks (and the\n      statements within the duplicate blocks).  This loop creates PHI nodes for\n      the duplicated blocks and redirects the incoming edges into BB to reach\n      the duplicates of BB.  */\n-  htab_traverse (redirection_data, redirect_edges, &local_info);\n+  redirection_data.traverse <ssa_local_info_t *, ssa_redirect_edges>\n+\t\t\t    (&local_info);\n \n   /* Done with this block.  Clear REDIRECTION_DATA.  */\n-  htab_delete (redirection_data);\n-  redirection_data = NULL;\n+  redirection_data.dispose ();\n \n   if (noloop_only\n       && bb == bb->loop_father->header)"}, {"sha": "bdf3fd23dbd12e2cd36a613bc1fa2f959c2dc842", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -188,7 +188,7 @@ adjust_vec_debug_stmts (void)\n \n   while (!VEC_empty (adjust_info, adjust_vec))\n     {\n-      adjust_debug_stmts_now (VEC_last (adjust_info, adjust_vec));\n+      adjust_debug_stmts_now (&VEC_last (adjust_info, adjust_vec));\n       VEC_pop (adjust_info, adjust_vec);\n     }\n \n@@ -2550,4 +2550,3 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t     GSI_SAME_STMT);\n     }\n }\n-"}, {"sha": "a4c7483a5b89a9453d87f07ec22953f1ab5b5c5e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1098,7 +1098,7 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   tmp_stmts = VEC_alloc (gimple, heap, group_size);\n \n   for (i = 0; i < group_size; i++)\n-    VEC_safe_push (gimple, heap, tmp_stmts, NULL);\n+    VEC_safe_push (gimple, heap, tmp_stmts, (gimple)NULL);\n \n   FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n@@ -2653,7 +2653,7 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n      stmts later.  */\n   for (i = VEC_length (gimple, SLP_TREE_VEC_STMTS (node));\n        i < (int) SLP_TREE_NUMBER_OF_VEC_STMTS (node); i++)\n-    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (node), NULL);\n+    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (node), (gimple)NULL);\n \n   perm_dest = vect_create_destination_var (gimple_assign_lhs (stmt), vectype);\n   for (i = 0; i < ncopies; i++)"}, {"sha": "0fd400d97ccb3dfe3b606b1d3aac8a7694bc6631", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -8864,7 +8864,7 @@ vrp_fold_stmt (gimple_stmt_iterator *si)\n \n    A NULL entry is used to mark the end of pairs which need to be\n    restored.  */\n-static VEC(tree,heap) *stack;\n+static VEC(tree,heap) *equiv_stack;\n \n /* A trivial wrapper so that we can present the generic jump threading\n    code with a simple API for simplifying statements.  STMT is the\n@@ -8932,7 +8932,7 @@ identify_jump_threads (void)\n \n   /* Allocate our unwinder stack to unwind any temporary equivalences\n      that might be recorded.  */\n-  stack = VEC_alloc (tree, heap, 20);\n+  equiv_stack = VEC_alloc (tree, heap, 20);\n \n   /* To avoid lots of silly node creation, we create a single\n      conditional and just modify it in-place when attempting to\n@@ -8986,7 +8986,7 @@ identify_jump_threads (void)\n \t      if (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t\tcontinue;\n \n-\t      thread_across_edge (dummy, e, true, &stack,\n+\t      thread_across_edge (dummy, e, true, &equiv_stack,\n \t\t\t\t  simplify_stmt_for_jump_threading);\n \t    }\n \t}\n@@ -9007,7 +9007,7 @@ static void\n finalize_jump_threads (void)\n {\n   thread_through_all_blocks (false);\n-  VEC_free (tree, heap, stack);\n+  VEC_free (tree, heap, equiv_stack);\n }\n \n "}, {"sha": "c0d349169608e48a94c362458d4ab5308d22e14b", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -6704,8 +6704,8 @@ simple_cst_equal (const_tree t1, const_tree t2)\n \n         for (idx = 0; idx < VEC_length (constructor_elt, v1); ++idx)\n \t  /* ??? Should we handle also fields here? */\n-\t  if (!simple_cst_equal (VEC_index (constructor_elt, v1, idx)->value,\n-\t\t\t\t VEC_index (constructor_elt, v2, idx)->value))\n+\t  if (!simple_cst_equal (VEC_index (constructor_elt, v1, idx).value,\n+\t\t\t\t VEC_index (constructor_elt, v2, idx).value))\n \t    return false;\n \treturn true;\n       }"}, {"sha": "ba4a021a9978af96dbf809059870a4c1fa0870e9", "filename": "gcc/tree.h", "status": "modified", "additions": 556, "deletions": 205, "changes": 761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -719,195 +719,80 @@ enum tree_node_structure_enum {\n    is accessed incorrectly. The macros die with a fatal error.  */\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n-#define TREE_CHECK(T, CODE) __extension__\t\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != (CODE))\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, \t\\\n-\t\t\t (CODE), 0);\t\t\t\t\t\\\n-    __t; })\n-\n-#define TREE_NOT_CHECK(T, CODE) __extension__\t\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) == (CODE))\t\t\t\t\t\\\n-      tree_not_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t\t\t     (CODE), 0);\t\t\t\t\\\n-    __t; })\n-\n-#define TREE_CHECK2(T, CODE1, CODE2) __extension__\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE2))\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\t\\\n- \t\t\t (CODE1), (CODE2), 0);\t\t\t\t\\\n-    __t; })\n-\n-#define TREE_NOT_CHECK2(T, CODE1, CODE2) __extension__\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) == (CODE1)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE2))\t\t\t\t\t\\\n-      tree_not_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t\t\t     (CODE1), (CODE2), 0);\t\t\t\\\n-    __t; })\n-\n-#define TREE_CHECK3(T, CODE1, CODE2, CODE3) __extension__\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE2)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE3))\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\t\\\n-\t\t\t     (CODE1), (CODE2), (CODE3), 0);\t\t\\\n-    __t; })\n-\n-#define TREE_NOT_CHECK3(T, CODE1, CODE2, CODE3) __extension__\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) == (CODE1)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE2)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE3))\t\t\t\t\t\\\n-      tree_not_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t\t\t     (CODE1), (CODE2), (CODE3), 0);\t\t\\\n-    __t; })\n-\n-#define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) __extension__\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE2)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE3)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE4))\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\t\\\n-\t\t\t     (CODE1), (CODE2), (CODE3), (CODE4), 0);\t\\\n-    __t; })\n-\n-#define TREE_NOT_CHECK4(T, CODE1, CODE2, CODE3, CODE4) __extension__\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) == (CODE1)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE2)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE3)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE4))\t\t\t\t\t\\\n-      tree_not_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t\t\t     (CODE1), (CODE2), (CODE3), (CODE4), 0);\t\\\n-    __t; })\n-\n-#define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) __extension__\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE2)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE3)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE4)\t\t\t\t\t\\\n-\t&& TREE_CODE (__t) != (CODE5))\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\t\\\n-\t\t\t     (CODE1), (CODE2), (CODE3), (CODE4), (CODE5), 0);\\\n-    __t; })\n-\n-#define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) __extension__ \\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) == (CODE1)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE2)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE3)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE4)\t\t\t\t\t\\\n-\t|| TREE_CODE (__t) == (CODE5))\t\t\t\t\t\\\n-      tree_not_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t\t\t     (CODE1), (CODE2), (CODE3), (CODE4), (CODE5), 0);\\\n-    __t; })\n-\n-#define CONTAINS_STRUCT_CHECK(T, STRUCT) __extension__\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-  if (tree_contains_struct[TREE_CODE(__t)][(STRUCT)] != 1)\t\t\\\n-      tree_contains_struct_check_failed (__t, (STRUCT), __FILE__, __LINE__,\t\\\n-\t\t\t       __FUNCTION__);\t\t\t\t\\\n-    __t; })\n-\n-#define TREE_CLASS_CHECK(T, CLASS) __extension__\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE_CLASS (TREE_CODE(__t)) != (CLASS))\t\t\t\\\n-      tree_class_check_failed (__t, (CLASS), __FILE__, __LINE__,\t\\\n-\t\t\t       __FUNCTION__);\t\t\t\t\\\n-    __t; })\n-\n-#define TREE_RANGE_CHECK(T, CODE1, CODE2) __extension__\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) < (CODE1) || TREE_CODE (__t) > (CODE2))\t\t\\\n-      tree_range_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t\t\t       (CODE1), (CODE2));\t\t\t\\\n-    __t; })\n-\n-#define OMP_CLAUSE_SUBCODE_CHECK(T, CODE) __extension__\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != OMP_CLAUSE)\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,  \t\\\n-\t\t\t OMP_CLAUSE, 0);\t\t\t\t\\\n-    if (__t->omp_clause.code != (CODE))\t\t\t\t\t\\\n-      omp_clause_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, \t\\\n-\t\t\t       (CODE));\t\t\t\t\t\\\n-    __t; })\n-\n-#define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2) __extension__\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != OMP_CLAUSE)\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,  \t\\\n-\t\t\t OMP_CLAUSE, 0);\t\t\t\t\\\n-    if ((int) __t->omp_clause.code < (int) (CODE1)\t\t\t\\\n-        || (int) __t->omp_clause.code > (int) (CODE2))\t\t\t\\\n-      omp_clause_range_check_failed (__t, __FILE__, __LINE__,\t\t\\\n-\t\t\t\t     __FUNCTION__, (CODE1), (CODE2));\t\\\n-    __t; })\n+#define TREE_CHECK(T, CODE) \\\n+(tree_check ((T), __FILE__, __LINE__, __FUNCTION__, (CODE)))\n+\n+#define TREE_NOT_CHECK(T, CODE) \\\n+(tree_not_check ((T), __FILE__, __LINE__, __FUNCTION__, (CODE)))\n+\n+#define TREE_CHECK2(T, CODE1, CODE2) \\\n+(tree_check2 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2)))\n+\n+#define TREE_NOT_CHECK2(T, CODE1, CODE2) \\\n+(tree_not_check2 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2)))\n+\n+#define TREE_CHECK3(T, CODE1, CODE2, CODE3) \\\n+(tree_check3 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2), (CODE3)))\n+\n+#define TREE_NOT_CHECK3(T, CODE1, CODE2, CODE3) \\\n+(tree_not_check3 ((T), __FILE__, __LINE__, __FUNCTION__, \\\n+                               (CODE1), (CODE2), (CODE3)))\n+\n+#define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) \\\n+(tree_check4 ((T), __FILE__, __LINE__, __FUNCTION__, \\\n+                           (CODE1), (CODE2), (CODE3), (CODE4)))\n+\n+#define TREE_NOT_CHECK4(T, CODE1, CODE2, CODE3, CODE4) \\\n+(tree_not_check4 ((T), __FILE__, __LINE__, __FUNCTION__, \\\n+                               (CODE1), (CODE2), (CODE3), (CODE4)))\n+\n+#define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) \\\n+(tree_check5 ((T), __FILE__, __LINE__, __FUNCTION__, \\\n+                           (CODE1), (CODE2), (CODE3), (CODE4), (CODE5)))\n+\n+#define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) \\\n+(tree_not_check5 ((T), __FILE__, __LINE__, __FUNCTION__, \\\n+                               (CODE1), (CODE2), (CODE3), (CODE4), (CODE5)))\n+\n+#define CONTAINS_STRUCT_CHECK(T, STRUCT) \\\n+(contains_struct_check ((T), (STRUCT), __FILE__, __LINE__, __FUNCTION__))\n+\n+#define TREE_CLASS_CHECK(T, CLASS) \\\n+(tree_class_check ((T), (CLASS), __FILE__, __LINE__, __FUNCTION__))\n+\n+#define TREE_RANGE_CHECK(T, CODE1, CODE2) \\\n+(tree_range_check ((T), (CODE1), (CODE2), __FILE__, __LINE__, __FUNCTION__))\n+\n+#define OMP_CLAUSE_SUBCODE_CHECK(T, CODE) \\\n+(omp_clause_subcode_check ((T), (CODE), __FILE__, __LINE__, __FUNCTION__))\n+\n+#define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2) \\\n+(omp_clause_range_check ((T), (CODE1), (CODE2), \\\n+                                      __FILE__, __LINE__, __FUNCTION__))\n \n /* These checks have to be special cased.  */\n-#define EXPR_CHECK(T) __extension__\t\t\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\t\t\t\\\n-    if (!IS_EXPR_CODE_CLASS (__c))\t\t\t\t\t\\\n-      tree_class_check_failed (__t, tcc_expression, __FILE__, __LINE__,\t\\\n-\t\t\t       __FUNCTION__);\t\t\t\t\\\n-    __t; })\n+#define EXPR_CHECK(T) \\\n+(expr_check ((T), __FILE__, __LINE__, __FUNCTION__))\n \n /* These checks have to be special cased.  */\n-#define NON_TYPE_CHECK(T) __extension__\t\t\t\t\t\\\n-({  __typeof (T) const __t = (T);\t\t\t\t\t\\\n-    if (TYPE_P (__t))\t\t\t\t\t\t\t\\\n-      tree_not_class_check_failed (__t, tcc_type, __FILE__, __LINE__,\t\\\n-\t\t\t\t   __FUNCTION__);\t\t\t\\\n-    __t; })\n-\n-#define TREE_VEC_ELT_CHECK(T, I) __extension__\t\t\t\t\\\n-(*({__typeof (T) const __t = (T);\t\t\t\t\t\\\n-    const int __i = (I);\t\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != TREE_VEC)\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\t\\\n-  \t\t\t TREE_VEC, 0);\t\t\t\t\t\\\n-    if (__i < 0 || __i >= __t->vec.length)\t\t\t\t\\\n-      tree_vec_elt_check_failed (__i, __t->vec.length,\t\t\t\\\n-\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n-    &__t->vec.a[__i]; }))\n-\n-#define OMP_CLAUSE_ELT_CHECK(T, I) __extension__\t\t\t\\\n-(*({__typeof (T) const __t = (T);\t\t\t\t\t\\\n-    const int __i = (I);\t\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != OMP_CLAUSE)\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,  \t\\\n-\t\t\t OMP_CLAUSE, 0);\t\t\t\t\\\n-    if (__i < 0 || __i >= omp_clause_num_ops [__t->omp_clause.code])\t\\\n-      omp_clause_operand_check_failed (__i, __t, __FILE__, __LINE__,\t\\\n-\t                               __FUNCTION__);\t\t\t\\\n-    &__t->omp_clause.ops[__i]; }))\n+#define NON_TYPE_CHECK(T) \\\n+(non_type_check ((T), __FILE__, __LINE__, __FUNCTION__))\n+\n+#define TREE_VEC_ELT_CHECK(T, I) \\\n+(*(CONST_CAST2 (tree *, typeof (T)*, \\\n+     tree_vec_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))))\n+\n+#define OMP_CLAUSE_ELT_CHECK(T, I) \\\n+(*(omp_clause_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__)))\n \n /* Special checks for TREE_OPERANDs.  */\n-#define TREE_OPERAND_CHECK(T, I) __extension__\t\t\t\t\\\n-(*({__typeof (T) const __t = EXPR_CHECK (T);\t\t\t\t\\\n-    const int __i = (I);\t\t\t\t\t\t\\\n-    if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\t\t\t\\\n-      tree_operand_check_failed (__i, __t,\t\t\t\t\\\n-\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n-    &__t->exp.operands[__i]; }))\n-\n-#define TREE_OPERAND_CHECK_CODE(T, CODE, I) __extension__\t\t\\\n-(*({__typeof (T) const __t = (T);\t\t\t\t\t\\\n-    const int __i = (I);\t\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != CODE)\t\t\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, (CODE), 0);\\\n-    if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\t\t\t\\\n-      tree_operand_check_failed (__i, __t,\t\t\t\t\\\n-\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n-    &__t->exp.operands[__i]; }))\n+#define TREE_OPERAND_CHECK(T, I) \\\n+(*(CONST_CAST2 (tree*, typeof (T)*, \\\n+     tree_operand_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))))\n+\n+#define TREE_OPERAND_CHECK_CODE(T, CODE, I) \\\n+(*(tree_operand_check_code ((T), (CODE), (I), \\\n+                                         __FILE__, __LINE__, __FUNCTION__)))\n \n /* Nodes are chained together for many purposes.\n    Types are chained together to record them for being output to the debugger\n@@ -918,17 +803,15 @@ enum tree_node_structure_enum {\n    Often lists of things are represented by TREE_LIST nodes that\n    are chained together.  */\n \n-#define TREE_CHAIN(NODE) __extension__ \\\n-(*({__typeof (NODE) const __t = CONTAINS_STRUCT_CHECK (NODE, TS_COMMON);\\\n-    &__t->common.chain; }))\n+#define TREE_CHAIN(NODE) \\\n+(CONTAINS_STRUCT_CHECK (NODE, TS_COMMON)->common.chain)\n \n /* In all nodes that are expressions, this is the data type of the expression.\n    In POINTER_TYPE nodes, this is the type that the pointer points to.\n    In ARRAY_TYPE nodes, this is the type of the elements.\n    In VECTOR_TYPE nodes, this is the type of the elements.  */\n-#define TREE_TYPE(NODE) __extension__ \\\n-(*({__typeof (NODE) const __t = CONTAINS_STRUCT_CHECK (NODE, TS_TYPED); \\\n-    &__t->typed.type; }))\n+#define TREE_TYPE(NODE) \\\n+(CONTAINS_STRUCT_CHECK (NODE, TS_TYPED)->typed.type)\n \n extern void tree_contains_struct_check_failed (const_tree,\n \t\t\t\t\t       const enum tree_node_structure_enum,\n@@ -1608,7 +1491,7 @@ struct GTY(()) tree_vec {\n /* In a CONSTRUCTOR node.  */\n #define CONSTRUCTOR_ELTS(NODE) (CONSTRUCTOR_CHECK (NODE)->constructor.elts)\n #define CONSTRUCTOR_ELT(NODE,IDX) \\\n-  (VEC_index (constructor_elt, CONSTRUCTOR_ELTS (NODE), IDX))\n+  (&VEC_index (constructor_elt, CONSTRUCTOR_ELTS (NODE), IDX))\n #define CONSTRUCTOR_NELTS(NODE) \\\n   (VEC_length (constructor_elt, CONSTRUCTOR_ELTS (NODE)))\n \n@@ -1618,7 +1501,7 @@ struct GTY(()) tree_vec {\n #define FOR_EACH_CONSTRUCTOR_VALUE(V, IX, VAL) \\\n   for (IX = 0; (IX >= VEC_length (constructor_elt, V)) \\\n \t       ? false \\\n-\t       : ((VAL = VEC_index (constructor_elt, V, IX)->value), \\\n+\t       : ((VAL = VEC_index (constructor_elt, V, IX).value), \\\n \t       true); \\\n        (IX)++)\n \n@@ -1628,8 +1511,8 @@ struct GTY(()) tree_vec {\n #define FOR_EACH_CONSTRUCTOR_ELT(V, IX, INDEX, VAL) \\\n   for (IX = 0; (IX >= VEC_length (constructor_elt, V)) \\\n \t       ? false \\\n-\t       : (((void) (VAL = VEC_index (constructor_elt, V, IX)->value)), \\\n-\t\t  (INDEX = VEC_index (constructor_elt, V, IX)->index), \\\n+\t       : (((void) (VAL = VEC_index (constructor_elt, V, IX).value)), \\\n+\t\t  (INDEX = VEC_index (constructor_elt, V, IX).index), \\\n \t\t  true); \\\n        (IX)++)\n \n@@ -3743,6 +3626,486 @@ union GTY ((ptr_alias (union lang_tree_node),\n   struct tree_optimization_option GTY ((tag (\"TS_OPTIMIZATION\"))) optimization;\n   struct tree_target_option GTY ((tag (\"TS_TARGET_OPTION\"))) target_option;\n };\n+\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+\n+inline tree\n+tree_check (tree __t, const char *__f, int __l, const char *__g, tree_code __c)\n+{\n+  if (TREE_CODE (__t) != __c)\n+    tree_check_failed (__t, __f, __l, __g, __c, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_not_check (tree __t, const char *__f, int __l, const char *__g,\n+                enum tree_code __c)\n+{\n+  if (TREE_CODE (__t) == __c)\n+    tree_not_check_failed (__t, __f, __l, __g, __c, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_check2 (tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_not_check2 (tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_check3 (tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2\n+      && TREE_CODE (__t) != __c3)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_not_check3 (tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2\n+      || TREE_CODE (__t) == __c3)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_check4 (tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+             enum tree_code __c4)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2\n+      && TREE_CODE (__t) != __c3\n+      && TREE_CODE (__t) != __c4)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_not_check4 (tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+                 enum tree_code __c4)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2\n+      || TREE_CODE (__t) == __c3\n+      || TREE_CODE (__t) == __c4)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_check5 (tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+             enum tree_code __c4, enum tree_code __c5)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2\n+      && TREE_CODE (__t) != __c3\n+      && TREE_CODE (__t) != __c4\n+      && TREE_CODE (__t) != __c5)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);\n+  return __t;\n+}\n+\n+inline tree\n+tree_not_check5 (tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+                 enum tree_code __c4, enum tree_code __c5)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2\n+      || TREE_CODE (__t) == __c3\n+      || TREE_CODE (__t) == __c4\n+      || TREE_CODE (__t) == __c5)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);\n+  return __t;\n+}\n+\n+inline tree\n+contains_struct_check (tree __t, const enum tree_node_structure_enum __s,\n+                       const char *__f, int __l, const char *__g)\n+{\n+  if (tree_contains_struct[TREE_CODE(__t)][__s] != 1)\n+      tree_contains_struct_check_failed (__t, __s, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline tree\n+tree_class_check (tree __t, const enum tree_code_class __class,\n+                  const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE(__t)) != __class)\n+    tree_class_check_failed (__t, __class, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline tree\n+tree_range_check (tree __t,\n+                  enum tree_code __code1, enum tree_code __code2,\n+                  const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) < __code1 || TREE_CODE (__t) > __code2)\n+    tree_range_check_failed (__t, __f, __l, __g, __code1, __code2);\n+  return __t;\n+}\n+\n+inline tree\n+omp_clause_subcode_check (tree __t, enum omp_clause_code __code,\n+                          const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != OMP_CLAUSE)\n+    tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);\n+  if (__t->omp_clause.code != __code)\n+    omp_clause_check_failed (__t, __f, __l, __g, __code);\n+  return __t;\n+}\n+\n+inline tree\n+omp_clause_range_check (tree __t,\n+                        enum omp_clause_code __code1,\n+                        enum omp_clause_code __code2,\n+                        const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != OMP_CLAUSE)\n+    tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);\n+  if ((int) __t->omp_clause.code < (int) __code1\n+      || (int) __t->omp_clause.code > (int) __code2)\n+    omp_clause_range_check_failed (__t, __f, __l, __g, __code1, __code2);\n+  return __t;\n+}\n+\n+/* These checks have to be special cased.  */\n+\n+inline tree\n+expr_check (tree __t, const char *__f, int __l, const char *__g)\n+{\n+  char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\n+  if (!IS_EXPR_CODE_CLASS (__c))\n+    tree_class_check_failed (__t, tcc_expression, __f, __l, __g);\n+  return __t;\n+}\n+\n+/* These checks have to be special cased.  */\n+\n+inline tree\n+non_type_check (tree __t, const char *__f, int __l, const char *__g)\n+{\n+  if (TYPE_P (__t))\n+    tree_not_class_check_failed (__t, tcc_type, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline tree *\n+tree_vec_elt_check (tree __t, int __i,\n+                    const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != TREE_VEC)\n+    tree_check_failed (__t, __f, __l, __g, TREE_VEC, 0);\n+  if (__i < 0 || __i >= __t->vec.length)\n+    tree_vec_elt_check_failed (__i, __t->vec.length, __f, __l, __g);\n+  return &CONST_CAST_TREE (__t)->vec.a[__i];\n+}\n+\n+inline tree *\n+omp_clause_elt_check (tree __t, int __i,\n+                      const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != OMP_CLAUSE)\n+    tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);\n+  if (__i < 0 || __i >= omp_clause_num_ops [__t->omp_clause.code])\n+    omp_clause_operand_check_failed (__i, __t, __f, __l, __g);\n+  return &__t->omp_clause.ops[__i];\n+}\n+\n+inline const_tree\n+tree_check (const_tree __t, const char *__f, int __l, const char *__g,\n+\t    tree_code __c)\n+{\n+  if (TREE_CODE (__t) != __c)\n+    tree_check_failed (__t, __f, __l, __g, __c, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_not_check (const_tree __t, const char *__f, int __l, const char *__g,\n+                enum tree_code __c)\n+{\n+  if (TREE_CODE (__t) == __c)\n+    tree_not_check_failed (__t, __f, __l, __g, __c, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_check2 (const_tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_not_check2 (const_tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_check3 (const_tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2\n+      && TREE_CODE (__t) != __c3)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_not_check3 (const_tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2\n+      || TREE_CODE (__t) == __c3)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_check4 (const_tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+             enum tree_code __c4)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2\n+      && TREE_CODE (__t) != __c3\n+      && TREE_CODE (__t) != __c4)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_not_check4 (const_tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+                 enum tree_code __c4)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2\n+      || TREE_CODE (__t) == __c3\n+      || TREE_CODE (__t) == __c4)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_check5 (const_tree __t, const char *__f, int __l, const char *__g,\n+             enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+             enum tree_code __c4, enum tree_code __c5)\n+{\n+  if (TREE_CODE (__t) != __c1\n+      && TREE_CODE (__t) != __c2\n+      && TREE_CODE (__t) != __c3\n+      && TREE_CODE (__t) != __c4\n+      && TREE_CODE (__t) != __c5)\n+    tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_not_check5 (const_tree __t, const char *__f, int __l, const char *__g,\n+                 enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,\n+                 enum tree_code __c4, enum tree_code __c5)\n+{\n+  if (TREE_CODE (__t) == __c1\n+      || TREE_CODE (__t) == __c2\n+      || TREE_CODE (__t) == __c3\n+      || TREE_CODE (__t) == __c4\n+      || TREE_CODE (__t) == __c5)\n+    tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);\n+  return __t;\n+}\n+\n+inline const_tree\n+contains_struct_check (const_tree __t, const enum tree_node_structure_enum __s,\n+                       const char *__f, int __l, const char *__g)\n+{\n+  if (tree_contains_struct[TREE_CODE(__t)][__s] != 1)\n+      tree_contains_struct_check_failed (__t, __s, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_class_check (const_tree __t, const enum tree_code_class __class,\n+                  const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE(__t)) != __class)\n+    tree_class_check_failed (__t, __class, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline const_tree\n+tree_range_check (const_tree __t,\n+                  enum tree_code __code1, enum tree_code __code2,\n+                  const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) < __code1 || TREE_CODE (__t) > __code2)\n+    tree_range_check_failed (__t, __f, __l, __g, __code1, __code2);\n+  return __t;\n+}\n+\n+inline const_tree\n+omp_clause_subcode_check (const_tree __t, enum omp_clause_code __code,\n+                          const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != OMP_CLAUSE)\n+    tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);\n+  if (__t->omp_clause.code != __code)\n+    omp_clause_check_failed (__t, __f, __l, __g, __code);\n+  return __t;\n+}\n+\n+inline const_tree\n+omp_clause_range_check (const_tree __t,\n+                        enum omp_clause_code __code1,\n+                        enum omp_clause_code __code2,\n+                        const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != OMP_CLAUSE)\n+    tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);\n+  if ((int) __t->omp_clause.code < (int) __code1\n+      || (int) __t->omp_clause.code > (int) __code2)\n+    omp_clause_range_check_failed (__t, __f, __l, __g, __code1, __code2);\n+  return __t;\n+}\n+\n+inline const_tree\n+expr_check (const_tree __t, const char *__f, int __l, const char *__g)\n+{\n+  char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\n+  if (!IS_EXPR_CODE_CLASS (__c))\n+    tree_class_check_failed (__t, tcc_expression, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline const_tree\n+non_type_check (const_tree __t, const char *__f, int __l, const char *__g)\n+{\n+  if (TYPE_P (__t))\n+    tree_not_class_check_failed (__t, tcc_type, __f, __l, __g);\n+  return __t;\n+}\n+\n+inline const_tree *\n+tree_vec_elt_check (const_tree __t, int __i,\n+                    const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != TREE_VEC)\n+    tree_check_failed (__t, __f, __l, __g, TREE_VEC, 0);\n+  if (__i < 0 || __i >= __t->vec.length)\n+    tree_vec_elt_check_failed (__i, __t->vec.length, __f, __l, __g);\n+  return CONST_CAST (const_tree *, &__t->vec.a[__i]);\n+  //return &__t->vec.a[__i];\n+}\n+\n+inline const_tree *\n+omp_clause_elt_check (const_tree __t, int __i,\n+                      const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != OMP_CLAUSE)\n+    tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);\n+  if (__i < 0 || __i >= omp_clause_num_ops [__t->omp_clause.code])\n+    omp_clause_operand_check_failed (__i, __t, __f, __l, __g);\n+  return CONST_CAST (const_tree *, &__t->omp_clause.ops[__i]);\n+}\n+\n+#endif\n+\n+/* Compute the number of operands in an expression node NODE.  For\n+   tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,\n+   otherwise it is looked up from the node's code.  */\n+static inline int\n+tree_operand_length (const_tree node)\n+{\n+  if (VL_EXP_CLASS_P (node))\n+    return VL_EXP_OPERAND_LENGTH (node);\n+  else\n+    return TREE_CODE_LENGTH (TREE_CODE (node));\n+}\n+\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+\n+/* Special checks for TREE_OPERANDs.  */\n+inline tree *\n+tree_operand_check (tree __t, int __i,\n+                    const char *__f, int __l, const char *__g)\n+{\n+  const_tree __u = EXPR_CHECK (__t);\n+  if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__u))\n+    tree_operand_check_failed (__i, __u, __f, __l, __g);\n+  return &CONST_CAST_TREE (__u)->exp.operands[__i];\n+}\n+\n+inline tree *\n+tree_operand_check_code (tree __t, enum tree_code __code, int __i,\n+                         const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != __code)\n+    tree_check_failed (__t, __f, __l, __g, __code, 0);\n+  if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\n+    tree_operand_check_failed (__i, __t, __f, __l, __g);\n+  return &__t->exp.operands[__i];\n+}\n+\n+inline const_tree *\n+tree_operand_check (const_tree __t, int __i,\n+                    const char *__f, int __l, const char *__g)\n+{\n+  const_tree __u = EXPR_CHECK (__t);\n+  if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__u))\n+    tree_operand_check_failed (__i, __u, __f, __l, __g);\n+  return CONST_CAST (const_tree *, &__u->exp.operands[__i]);\n+}\n+\n+inline const_tree *\n+tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n+                         const char *__f, int __l, const char *__g)\n+{\n+  if (TREE_CODE (__t) != __code)\n+    tree_check_failed (__t, __f, __l, __g, __code, 0);\n+  if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\n+    tree_operand_check_failed (__i, __t, __f, __l, __g);\n+  return CONST_CAST (const_tree *, &__t->exp.operands[__i]);\n+}\n+\n+#endif\n+\n \f\n /* Standard named or nameless data types of the C compiler.  */\n \n@@ -5917,18 +6280,6 @@ is_tm_safe_or_pure (const_tree x)\n \n void init_inline_once (void);\n \n-/* Compute the number of operands in an expression node NODE.  For\n-   tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,\n-   otherwise it is looked up from the node's code.  */\n-static inline int\n-tree_operand_length (const_tree node)\n-{\n-  if (VL_EXP_CLASS_P (node))\n-    return VL_EXP_OPERAND_LENGTH (node);\n-  else\n-    return TREE_CODE_LENGTH (TREE_CODE (node));\n-}\n-\n /* Abstract iterators for CALL_EXPRs.  These static inline definitions\n    have to go towards the end of tree.h so that union tree_node is fully\n    defined by this point.  */"}, {"sha": "818fb2456b55b53046ce6d5c17550dd61822d5fb", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -7821,7 +7821,7 @@ loc_exp_dep_clear (variable var)\n {\n   while (!VEC_empty (loc_exp_dep, VAR_LOC_DEP_VEC (var)))\n     {\n-      loc_exp_dep *led = VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n+      loc_exp_dep *led = &VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n       if (led->next)\n \tled->next->pprev = led->pprev;\n       if (led->pprev)\n@@ -7865,7 +7865,7 @@ loc_exp_insert_dep (variable var, rtx x, htab_t vars)\n   else\n     {\n       VEC_quick_push (loc_exp_dep, VAR_LOC_DEP_VEC (var), NULL);\n-      led = VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n+      led = &VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n     }\n   led->dv = var->dv;\n   led->value = x;"}, {"sha": "b380a47d944389ace32b66beb736b84c85d033a5", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -2871,8 +2871,8 @@ compare_constant (const tree t1, const tree t2)\n \n \tfor (idx = 0; idx < VEC_length (constructor_elt, v1); ++idx)\n \t  {\n-\t    constructor_elt *c1 = VEC_index (constructor_elt, v1, idx);\n-\t    constructor_elt *c2 = VEC_index (constructor_elt, v2, idx);\n+\t    constructor_elt *c1 = &VEC_index (constructor_elt, v1, idx);\n+\t    constructor_elt *c2 = &VEC_index (constructor_elt, v2, idx);\n \n \t    /* Check that each value is the same...  */\n \t    if (!compare_constant (c1->value, c2->value))"}, {"sha": "51a55d95fbf75cd43394f6b0098aef220c558d57", "filename": "gcc/vec.c", "status": "modified", "additions": 5, "deletions": 118, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,7 +1,8 @@\n /* Vector API for GNU compiler.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Nathan Sidwell <nathan@codesourcery.com>\n+   Re-implemented in C++ by Diego Novillo <dnovillo@google.com>\n \n This file is part of GCC.\n \n@@ -213,7 +214,7 @@ calculate_allocation (const struct vec_prefix *pfx, int reserve, bool exact)\n    trailing array is at VEC_OFFSET offset and consists of ELT_SIZE\n    sized elements.  */\n \n-static void *\n+void *\n vec_gc_o_reserve_1 (void *vec, int reserve, size_t vec_offset, size_t elt_size,\n \t\t    bool exact MEM_STAT_DECL)\n {\n@@ -246,61 +247,10 @@ vec_gc_o_reserve_1 (void *vec, int reserve, size_t vec_offset, size_t elt_size,\n   return vec;\n }\n \n-/* Ensure there are at least RESERVE free slots in VEC, growing\n-   exponentially.  If RESERVE < 0 grow exactly, else grow\n-   exponentially.  As a special case, if VEC is NULL, and RESERVE is\n-   0, no vector will be created. */\n-\n-void *\n-vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_gc_o_reserve_1 (vec, reserve,\n-\t\t\t     sizeof (struct vec_prefix),\n-\t\t\t     sizeof (void *), false\n-\t\t\t     PASS_MEM_STAT);\n-}\n-\n-/* Ensure there are at least RESERVE free slots in VEC, growing\n-   exactly.  If RESERVE < 0 grow exactly, else grow exponentially.  As\n-   a special case, if VEC is NULL, and RESERVE is 0, no vector will be\n-   created. */\n-\n-void *\n-vec_gc_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_gc_o_reserve_1 (vec, reserve,\n-\t\t\t     sizeof (struct vec_prefix),\n-\t\t\t     sizeof (void *), true\n-\t\t\t     PASS_MEM_STAT);\n-}\n-\n-/* As for vec_gc_p_reserve, but for object vectors.  The vector's\n-   trailing array is at VEC_OFFSET offset and consists of ELT_SIZE\n-   sized elements.  */\n-\n-void *\n-vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n-\t\t  MEM_STAT_DECL)\n-{\n-  return vec_gc_o_reserve_1 (vec, reserve, vec_offset, elt_size, false\n-\t\t\t     PASS_MEM_STAT);\n-}\n-\n-/* As for vec_gc_p_reserve_exact, but for object vectors.  The\n-   vector's trailing array is at VEC_OFFSET offset and consists of\n-   ELT_SIZE sized elements.  */\n-\n-void *\n-vec_gc_o_reserve_exact (void *vec, int reserve, size_t vec_offset,\n-\t\t\tsize_t elt_size MEM_STAT_DECL)\n-{\n-  return vec_gc_o_reserve_1 (vec, reserve, vec_offset, elt_size, true\n-\t\t\t     PASS_MEM_STAT);\n-}\n \n /* As for vec_gc_o_reserve_1, but for heap allocated vectors.  */\n \n-static void *\n+void *\n vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n \t\t      size_t elt_size, bool exact MEM_STAT_DECL)\n {\n@@ -328,47 +278,6 @@ vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n   return vec;\n }\n \n-/* As for vec_gc_p_reserve, but for heap allocated vectors.  */\n-\n-void *\n-vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_heap_o_reserve_1 (vec, reserve,\n-\t\t\t       sizeof (struct vec_prefix),\n-\t\t\t       sizeof (void *), false\n-\t\t\t       PASS_MEM_STAT);\n-}\n-\n-/* As for vec_gc_p_reserve_exact, but for heap allocated vectors.  */\n-\n-void *\n-vec_heap_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_heap_o_reserve_1 (vec, reserve,\n-\t\t\t       sizeof (struct vec_prefix),\n-\t\t\t       sizeof (void *), true\n-\t\t\t       PASS_MEM_STAT);\n-}\n-\n-/* As for vec_gc_o_reserve, but for heap allocated vectors.  */\n-\n-void *\n-vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n-\t\t    MEM_STAT_DECL)\n-{\n-  return vec_heap_o_reserve_1 (vec, reserve, vec_offset, elt_size, false\n-\t\t\t       PASS_MEM_STAT);\n-}\n-\n-/* As for vec_gc_o_reserve_exact, but for heap allocated vectors.  */\n-\n-void *\n-vec_heap_o_reserve_exact (void *vec, int reserve, size_t vec_offset,\n-\t\t\t  size_t elt_size MEM_STAT_DECL)\n-{\n-  return vec_heap_o_reserve_1 (vec, reserve, vec_offset, elt_size, true\n-\t\t\t       PASS_MEM_STAT);\n-}\n \n /* Stack vectors are a little different.  VEC_alloc turns into a call\n    to vec_stack_p_reserve_exact1 and passes in space allocated via a\n@@ -449,28 +358,6 @@ vec_stack_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n \n /* Grow a vector allocated on the stack.  */\n \n-void *\n-vec_stack_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_stack_o_reserve_1 (vec, reserve,\n-\t\t\t\tsizeof (struct vec_prefix),\n-\t\t\t\tsizeof (void *), false\n-\t\t\t\tPASS_MEM_STAT);\n-}\n-\n-/* Exact version of vec_stack_p_reserve.  */\n-\n-void *\n-vec_stack_p_reserve_exact (void *vec, int reserve MEM_STAT_DECL)\n-{\n-  return vec_stack_o_reserve_1 (vec, reserve,\n-\t\t\t\tsizeof (struct vec_prefix),\n-\t\t\t\tsizeof (void *), true\n-\t\t\t\tPASS_MEM_STAT);\n-}\n-\n-/* Like vec_stack_p_reserve, but for objects.  */\n-\n void *\n vec_stack_o_reserve (void *vec, int reserve, size_t vec_offset,\n \t\t     size_t elt_size MEM_STAT_DECL)\n@@ -479,7 +366,7 @@ vec_stack_o_reserve (void *vec, int reserve, size_t vec_offset,\n \t\t\t\tPASS_MEM_STAT);\n }\n \n-/* Like vec_stack_p_reserve_exact, but for objects.  */\n+/* Exact version of vec_stack_o_reserve.  */\n \n void *\n vec_stack_o_reserve_exact (void *vec, int reserve, size_t vec_offset,"}, {"sha": "5fdb859741dc0e5a66c4918e201372a26f8041d5", "filename": "gcc/vec.h", "status": "modified", "additions": 738, "deletions": 1001, "changes": 1739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,7 +1,8 @@\n /* Vector API for GNU compiler.\n-   Copyright (C) 2004, 2005, 2007, 2008, 2009, 2010\n+   Copyright (C) 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Nathan Sidwell <nathan@codesourcery.com>\n+   Re-implemented in C++ by Diego Novillo <dnovillo@google.com>\n \n This file is part of GCC.\n \n@@ -134,6 +135,153 @@ along with GCC; see the file COPYING3.  If not see\n \n */\n \n+#if ENABLE_CHECKING\n+#define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n+#define VEC_CHECK_DECL ,const char *file_,unsigned line_,const char *function_\n+#define VEC_CHECK_PASS ,file_,line_,function_\n+\n+#define VEC_ASSERT(EXPR,OP,T,A) \\\n+  (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(T,A)), 0))\n+\n+extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n+     ATTRIBUTE_NORETURN;\n+#define VEC_ASSERT_FAIL(OP,VEC) vec_assert_fail (OP,#VEC VEC_CHECK_PASS)\n+#else\n+#define VEC_CHECK_INFO\n+#define VEC_CHECK_DECL\n+#define VEC_CHECK_PASS\n+#define VEC_ASSERT(EXPR,OP,T,A) (void)(EXPR)\n+#endif\n+\n+#define VEC(T,A) vec_t<T>\n+\n+enum vec_allocation_t { heap, gc, stack };\n+\n+struct vec_prefix\n+{\n+  unsigned num;\n+  unsigned alloc;\n+};\n+\n+/* Vector type, user visible.  */\n+template<typename T>\n+struct GTY(()) vec_t\n+{\n+  vec_prefix prefix;\n+  T vec[1];\n+};\n+\n+/* Garbage collection support for vec_t.  */\n+\n+template<typename T>\n+void\n+gt_ggc_mx (vec_t<T> *v)\n+{\n+  extern void gt_ggc_mx (T&);\n+  for (unsigned i = 0; i < v->prefix.num; i++)\n+    gt_ggc_mx (v->vec[i]);\n+}\n+\n+\n+/* PCH support for vec_t.  */\n+\n+template<typename T>\n+void\n+gt_pch_nx (vec_t<T> *v)\n+{\n+  extern void gt_pch_nx (T&);\n+  for (unsigned i = 0; i < v->prefix.num; i++)\n+    gt_pch_nx (v->vec[i]);\n+}\n+\n+template<typename T>\n+void\n+gt_pch_nx (vec_t<T *> *v, gt_pointer_operator op, void *cookie)\n+{\n+  for (unsigned i = 0; i < v->prefix.num; i++)\n+    op (&(v->vec[i]), cookie);\n+}\n+\n+template<typename T>\n+void\n+gt_pch_nx (vec_t<T> *v, gt_pointer_operator op, void *cookie)\n+{\n+  extern void gt_pch_nx (T *, gt_pointer_operator, void *);\n+  for (unsigned i = 0; i < v->prefix.num; i++)\n+    gt_pch_nx (&(v->vec[i]), op, cookie);\n+}\n+\n+\n+/* FIXME cxx-conversion.  Remove these definitions and update all\n+   calling sites.  */\n+/* Vector of integer-like object.  */\n+#define DEF_VEC_I(T)\t\t\tstruct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_I(T,A)\t\tstruct vec_swallow_trailing_semi\n+\n+/* Vector of pointer to object.  */\n+#define DEF_VEC_P(T)\t\t\tstruct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_P(T,A)\t\tstruct vec_swallow_trailing_semi\n+\n+/* Vector of object.  */\n+#define DEF_VEC_O(T)\t\t\tstruct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_O(T,A)\t\tstruct vec_swallow_trailing_semi\n+\n+/* Vectors on the stack.  */\n+#define DEF_VEC_ALLOC_P_STACK(T)\tstruct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_O_STACK(T)\tstruct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_I_STACK(T)\tstruct vec_swallow_trailing_semi\n+\n+/* Vectors of atomic types.  Atomic types do not need to have its\n+   elements marked for GC and PCH.  To avoid unnecessary traversals,\n+   we provide template instantiations for the GC/PCH functions that\n+   do not traverse the vector.\n+\n+   FIXME cxx-conversion - Once vec_t users are converted this can\n+   be provided in some other way (e.g., adding an additional template\n+   parameter to the vec_t class).  */\n+#define DEF_VEC_A(TYPE)\t\t\t\t\t\t\\\n+template<typename T>\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+gt_ggc_mx (vec_t<TYPE> *v ATTRIBUTE_UNUSED)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+template<typename T>\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+gt_pch_nx (vec_t<TYPE> *v ATTRIBUTE_UNUSED)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+template<typename T>\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+gt_pch_nx (vec_t<TYPE> *v ATTRIBUTE_UNUSED,\t\t\t\\\n+\t   gt_pointer_operator op ATTRIBUTE_UNUSED,\t\t\\\n+\t   void *cookie ATTRIBUTE_UNUSED)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+struct vec_swallow_trailing_semi\n+\n+#define DEF_VEC_ALLOC_A(T,A)\t\tstruct vec_swallow_trailing_semi\n+\n+/* Support functions for stack vectors.  */\n+extern void *vec_stack_p_reserve_exact_1 (int, void *);\n+extern void *vec_stack_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n+extern void *vec_stack_o_reserve_exact (void *, int, size_t, size_t\n+\t\t\t\t\t MEM_STAT_DECL);\n+extern void vec_stack_free (void *);\n+\n+/* Reallocate an array of elements with prefix.  */\n+template<typename T, enum vec_allocation_t A>\n+extern vec_t<T> *vec_reserve (vec_t<T> *, int MEM_STAT_DECL);\n+\n+template<typename T, enum vec_allocation_t A>\n+extern vec_t<T> *vec_reserve_exact (vec_t<T> *, int MEM_STAT_DECL);\n+\n+extern void dump_vec_loc_statistics (void);\n+extern void ggc_free (void *);\n+extern void vec_heap_free (void *);\n+\n+\n /* Macros to invoke API calls.  A single macro works for both pointer\n    and object vectors, but the argument and return types might well be\n    different.  In each macro, T is the typedef of the vector elements,\n@@ -148,15 +296,45 @@ along with GCC; see the file COPYING3.  If not see\n    Return the number of active elements in V.  V can be NULL, in which\n    case zero is returned.  */\n \n-#define VEC_length(T,V)\t(VEC_OP(T,base,length)(VEC_BASE(V)))\n+#define VEC_length(T,V)\t(VEC_length_1<T> (V))\n+\n+template<typename T>\n+static inline unsigned\n+VEC_length_1 (const vec_t<T> *vec_)\n+{\n+  return vec_ ? vec_->prefix.num : 0;\n+}\n \n \n /* Check if vector is empty\n    int VEC_T_empty(const VEC(T) *v);\n \n    Return nonzero if V is an empty vector (or V is NULL), zero otherwise.  */\n \n-#define VEC_empty(T,V)\t(VEC_length (T,V) == 0)\n+#define VEC_empty(T,V)\t(VEC_empty_1<T> (V))\n+\n+template<typename T>\n+static inline bool\n+VEC_empty_1 (const vec_t<T> *vec_)\n+{\n+  return VEC_length (T, vec_) == 0;\n+}\n+\n+\n+/* Get the address of the array of elements\n+   T *VEC_T_address (VEC(T) v)\n+\n+   If you need to directly manipulate the array (for instance, you\n+   want to feed it to qsort), use this accessor.  */\n+\n+#define VEC_address(T,V)\t(VEC_address_1<T> (V))\n+\n+template<typename T>\n+static inline T *\n+VEC_address_1 (vec_t<T> *vec_)\n+{\n+  return vec_ ? vec_->vec : 0;\n+}\n \n \n /* Get the final element of the vector.\n@@ -166,16 +344,42 @@ along with GCC; see the file COPYING3.  If not see\n \n    Return the final element.  V must not be empty.  */\n \n-#define VEC_last(T,V)\t(VEC_OP(T,base,last)(VEC_BASE(V) VEC_CHECK_INFO))\n+#define VEC_last(T,V)\t(VEC_last_1<T> (V VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline T&\n+VEC_last_1 (vec_t<T> *vec_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (vec_ && vec_->prefix.num, \"last\", T, base);\n+  return vec_->vec[vec_->prefix.num - 1];\n+}\n+\n \n /* Index into vector\n    T VEC_T_index(VEC(T) *v, unsigned ix); // Integer\n    T VEC_T_index(VEC(T) *v, unsigned ix); // Pointer\n    T *VEC_T_index(VEC(T) *v, unsigned ix); // Object\n \n-   Return the IX'th element.  If IX must be in the domain of V.  */\n+   Return the IX'th element.  IX must be in the domain of V.  */\n+\n+#define VEC_index(T,V,I) (VEC_index_1<T> (V, I VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline T&\n+VEC_index_1 (vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\n+  return vec_->vec[ix_];\n+}\n+\n+template<typename T>\n+static inline const T&\n+VEC_index_1 (const vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\n+  return vec_->vec[ix_];\n+}\n \n-#define VEC_index(T,V,I) (VEC_OP(T,base,index)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n /* Iterate over vector\n    int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Integer\n@@ -189,7 +393,39 @@ along with GCC; see the file COPYING3.  If not see\n      for (ix = 0; VEC_iterate(T,v,ix,ptr); ix++)\n        continue;  */\n \n-#define VEC_iterate(T,V,I,P)\t(VEC_OP(T,base,iterate)(VEC_BASE(V),I,&(P)))\n+#define VEC_iterate(T,V,I,P)\t(VEC_iterate_1<T> (V, I, &(P)))\n+\n+template<typename T>\n+static inline bool\n+VEC_iterate_1 (const vec_t<T> *vec_, unsigned ix_, T *ptr)\n+{\n+  if (vec_ && ix_ < vec_->prefix.num)\n+    {\n+      *ptr = vec_->vec[ix_];\n+      return true;\n+    }\n+  else\n+    {\n+      *ptr = 0;\n+      return false;\n+    }\n+}\n+\n+template<typename T>\n+static inline bool\n+VEC_iterate_1 (vec_t<T> *vec_, unsigned ix_, T **ptr)\n+{\n+  if (vec_ && ix_ < vec_->prefix.num)\n+    {\n+      *ptr = &vec_->vec[ix_];\n+      return true;\n+    }\n+  else\n+    {\n+      *ptr = 0;\n+      return false;\n+    }\n+}\n \n /* Convenience macro for forward iteration.  */\n \n@@ -208,39 +444,124 @@ along with GCC; see the file COPYING3.  If not see\n        VEC_iterate (T, (V), (I), (P));\t  \\\n        (I)--)\n \n+\n+/* Use these to determine the required size and initialization of a\n+   vector embedded within another structure (as the final member).\n+\n+   size_t VEC_T_embedded_size(int reserve);\n+   void VEC_T_embedded_init(VEC(T) *v, int reserve);\n+\n+   These allow the caller to perform the memory allocation.  */\n+\n+#define VEC_embedded_size(T,N)\t (VEC_embedded_size_1<T> (N))\n+\n+template<typename T>\n+static inline size_t\n+VEC_embedded_size_1 (int alloc_)\n+{\n+  return offsetof (vec_t<T>, vec) + alloc_ * sizeof (T);\n+}\n+\n+#define VEC_embedded_init(T,O,N) (VEC_embedded_init_1<T> (O, N))\n+\n+template<typename T>\n+static inline void\n+VEC_embedded_init_1 (vec_t<T> *vec_, int alloc_)\n+{\n+  vec_->prefix.num = 0;\n+  vec_->prefix.alloc = alloc_;\n+}\n+\n+\n /* Allocate new vector.\n    VEC(T,A) *VEC_T_A_alloc(int reserve);\n \n    Allocate a new vector with space for RESERVE objects.  If RESERVE\n-   is zero, NO vector is created.  */\n+   is zero, NO vector is created.\n+\n+   We support a vector which starts out with space on the stack and\n+   switches to heap space when forced to reallocate.  This works a\n+   little differently.  In the case of stack vectors, VEC_alloc will\n+   expand to a call to VEC_alloc_1 that calls XALLOCAVAR to request the\n+   initial allocation.  This uses alloca to get the initial space.\n+   Since alloca can not be usefully called in an inline function,\n+   VEC_alloc must always be a macro.\n+\n+   Only the initial allocation will be made using alloca, so pass a\n+   reasonable estimate that doesn't use too much stack space; don't\n+   pass zero.  Don't return a VEC(TYPE,stack) vector from the function\n+   which allocated it.  */\n+\n+#define VEC_alloc(T,A,N)\t\t\t\t\t\\\n+  ((A == stack)\t\t\t\t\t\t\t\\\n+    ? VEC_alloc_1 (N,\t\t\t\t\t\t\\\n+ \t\t   XALLOCAVAR (vec_t<T>, \t\t\t\\\n+\t\t\t       VEC_embedded_size_1<T> (N)))\t\\\n+    : VEC_alloc_1<T, A> (N MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline vec_t<T> *\n+VEC_alloc_1 (int alloc_ MEM_STAT_DECL)\n+{\n+  return vec_reserve_exact<T, A> (NULL, alloc_ PASS_MEM_STAT);\n+}\n+\n+template<typename T>\n+static inline vec_t<T> *\n+VEC_alloc_1 (int alloc_, vec_t<T> *space)\n+{\n+  return (vec_t<T> *) vec_stack_p_reserve_exact_1 (alloc_, space);\n+}\n \n-#define VEC_alloc(T,A,N)\t(VEC_OP(T,A,alloc)(N MEM_STAT_INFO))\n \n /* Free a vector.\n    void VEC_T_A_free(VEC(T,A) *&);\n \n    Free a vector and set it to NULL.  */\n \n-#define VEC_free(T,A,V)\t(VEC_OP(T,A,free)(&V))\n+#define VEC_free(T,A,V)\t\t(VEC_free_1<T, A> (&V))\n \n-/* Use these to determine the required size and initialization of a\n-   vector embedded within another structure (as the final member).\n-\n-   size_t VEC_T_embedded_size(int reserve);\n-   void VEC_T_embedded_init(VEC(T) *v, int reserve);\n-\n-   These allow the caller to perform the memory allocation.  */\n+template<typename T, enum vec_allocation_t A>\n+static inline void\n+VEC_free_1 (vec_t<T> **vec_)\n+{\n+  if (*vec_)\n+    {\n+      if (A == heap)\n+\tvec_heap_free (*vec_);\n+      else if (A == gc)\n+\tggc_free (*vec_);\n+      else if (A == stack)\n+\tvec_stack_free (*vec_);\n+    }\n+  *vec_ = NULL;\n+}\n \n-#define VEC_embedded_size(T,N)\t (VEC_OP(T,base,embedded_size)(N))\n-#define VEC_embedded_init(T,O,N) (VEC_OP(T,base,embedded_init)(VEC_BASE(O),N))\n \n /* Copy a vector.\n    VEC(T,A) *VEC_T_A_copy(VEC(T) *);\n \n    Copy the live elements of a vector into a new vector.  The new and\n    old vectors need not be allocated by the same mechanism.  */\n \n-#define VEC_copy(T,A,V) (VEC_OP(T,A,copy)(VEC_BASE(V) MEM_STAT_INFO))\n+#define VEC_copy(T,A,V) (VEC_copy_1<T, A> (V MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline vec_t<T> *\n+VEC_copy_1 (vec_t<T> *vec_ MEM_STAT_DECL)\n+{\n+  size_t len_ = vec_ ? vec_->prefix.num : 0;\n+  vec_t<T> *new_vec_ = NULL;\n+\n+  if (len_)\n+    {\n+      new_vec_ = vec_reserve_exact<T, A> (NULL, len_ PASS_MEM_STAT);\n+      new_vec_->prefix.num = len_;\n+      memcpy (new_vec_->vec, vec_->vec, sizeof (T) * len_);\n+    }\n+  return new_vec_;\n+}\n+\n \n /* Determine if a vector has additional capacity.\n \n@@ -252,8 +573,18 @@ along with GCC; see the file COPYING3.  If not see\n    nonzero in exactly the same circumstances that VEC_T_reserve\n    will.  */\n \n-#define VEC_space(T,V,R) \\\n-\t(VEC_OP(T,base,space)(VEC_BASE(V),R VEC_CHECK_INFO))\n+#define VEC_space(T,V,R)\t(VEC_space_1<T> (V, R VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline int\n+VEC_space_1 (vec_t<T> *vec_, int alloc_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\n+  return vec_\n+\t ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_\n+\t : !alloc_;\n+}\n+\n \n /* Reserve space.\n    int VEC_T_A_reserve(VEC(T,A) *&v, int reserve);\n@@ -264,7 +595,20 @@ along with GCC; see the file COPYING3.  If not see\n    occurred.  */\n \n #define VEC_reserve(T,A,V,R)\t\\\n-\t(VEC_OP(T,A,reserve)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n+  \t(VEC_reserve_1<T, A> (&(V), (int)(R) VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline int\n+VEC_reserve_1 (vec_t<T> **vec_, int alloc_  VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  int extend = !VEC_space_1 (*vec_, alloc_ VEC_CHECK_PASS);\n+\n+  if (extend)\n+    *vec_ = vec_reserve<T, A> (*vec_, alloc_ PASS_MEM_STAT);\n+\n+  return extend;\n+}\n+\n \n /* Reserve space exactly.\n    int VEC_T_A_reserve_exact(VEC(T,A) *&v, int reserve);\n@@ -275,7 +619,20 @@ along with GCC; see the file COPYING3.  If not see\n    occurred.  */\n \n #define VEC_reserve_exact(T,A,V,R)\t\\\n-\t(VEC_OP(T,A,reserve_exact)(&(V),R VEC_CHECK_INFO MEM_STAT_INFO))\n+\t(VEC_reserve_exact_1<T, A> (&(V), R VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline int\n+VEC_reserve_exact_1 (vec_t<T> **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  int extend = !VEC_space_1 (*vec_, alloc_ VEC_CHECK_PASS);\n+\n+  if (extend)\n+    *vec_ = vec_reserve_exact<T, A> (*vec_, alloc_ PASS_MEM_STAT);\n+\n+  return extend;\n+}\n+\n \n /* Copy elements with no reallocation\n    void VEC_T_splice (VEC(T) *dst, VEC(T) *src); // Integer\n@@ -287,8 +644,23 @@ along with GCC; see the file COPYING3.  If not see\n    often will be.  DST is assumed to have sufficient headroom\n    available.  */\n \n-#define VEC_splice(T,DST,SRC)\t\t\t\\\n-  (VEC_OP(T,base,splice)(VEC_BASE(DST), VEC_BASE(SRC) VEC_CHECK_INFO))\n+#define VEC_splice(T,DST,SRC)\t(VEC_splice_1<T> (DST, SRC VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline void\n+VEC_splice_1 (vec_t<T> *dst_, vec_t<T> *src_ VEC_CHECK_DECL)\n+{\n+  if (src_)\n+    {\n+      unsigned len_ = src_->prefix.num;\n+      VEC_ASSERT (dst_->prefix.num + len_ <= dst_->prefix.alloc, \"splice\",\n+\t\t  T, base);\n+\n+      memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (T));\n+      dst_->prefix.num += len_;\n+    }\n+}\n+\n \n /* Copy elements with reallocation\n    void VEC_T_safe_splice (VEC(T,A) *&dst, VEC(T) *src); // Integer\n@@ -301,7 +673,21 @@ along with GCC; see the file COPYING3.  If not see\n    reallocated if needed.  */\n \n #define VEC_safe_splice(T,A,DST,SRC)\t\t\t\t\t\\\n-  (VEC_OP(T,A,safe_splice)(&(DST), VEC_BASE(SRC) VEC_CHECK_INFO MEM_STAT_INFO))\n+\t(VEC_safe_splice_1<T, A> (&(DST), SRC VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline void\n+VEC_safe_splice_1 (vec_t<T> **dst_, vec_t<T> *src_ VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  if (src_)\n+    {\n+      VEC_reserve_exact_1<T, A> (dst_, src_->prefix.num\n+\t\t\t\t VEC_CHECK_PASS MEM_STAT_INFO);\n+\n+      VEC_splice_1 (*dst_, src_ VEC_CHECK_PASS);\n+    }\n+}\n+\n   \n /* Push object with no reallocation\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Integer\n@@ -313,8 +699,31 @@ along with GCC; see the file COPYING3.  If not see\n    case NO initialization is performed.  There must\n    be sufficient space in the vector.  */\n \n-#define VEC_quick_push(T,V,O)\t\\\n-\t(VEC_OP(T,base,quick_push)(VEC_BASE(V),O VEC_CHECK_INFO))\n+#define VEC_quick_push(T,V,O)\t(VEC_quick_push_1<T> (V, O VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline T &\n+VEC_quick_push_1 (vec_t<T> *vec_, T obj_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\n+  vec_->vec[vec_->prefix.num] = obj_;\n+  T &val_ = vec_->vec[vec_->prefix.num];\n+  vec_->prefix.num++;\n+  return val_;\n+}\n+\n+template<typename T>\n+static inline T *\n+VEC_quick_push_1 (vec_t<T> *vec_, const T *ptr_ VEC_CHECK_DECL)\n+{\n+  T *slot_;\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\n+  slot_ = &vec_->vec[vec_->prefix.num++];\n+  if (ptr_)\n+    *slot_ = *ptr_;\n+  return slot_;\n+}\n+\n \n /* Push object with reallocation\n    T *VEC_T_A_safe_push (VEC(T,A) *&v, T obj); // Integer\n@@ -326,7 +735,24 @@ along with GCC; see the file COPYING3.  If not see\n    case NO initialization is performed.  Reallocates V, if needed.  */\n \n #define VEC_safe_push(T,A,V,O)\t\t\\\n-\t(VEC_OP(T,A,safe_push)(&(V),O VEC_CHECK_INFO MEM_STAT_INFO))\n+\t(VEC_safe_push_1<T, A> (&(V), O VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline T &\n+VEC_safe_push_1 (vec_t<T> **vec_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  return VEC_quick_push_1 (*vec_, obj_ VEC_CHECK_PASS);\n+}\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline T *\n+VEC_safe_push_1 (vec_t<T> **vec_, const T *ptr_ VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  return VEC_quick_push_1 (*vec_, ptr_ VEC_CHECK_PASS);\n+}\n+\n \n /* Pop element off end\n    T VEC_T_pop (VEC(T) *v);\t\t// Integer\n@@ -336,16 +762,35 @@ along with GCC; see the file COPYING3.  If not see\n    Pop the last element off the end. Returns the element popped, for\n    pointer vectors.  */\n \n-#define VEC_pop(T,V)\t(VEC_OP(T,base,pop)(VEC_BASE(V) VEC_CHECK_INFO))\n+#define VEC_pop(T,V)\t(VEC_pop_1<T> (V VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline T&\n+VEC_pop_1 (vec_t<T> *vec_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (vec_->prefix.num, \"pop\", T, base);\n+  return vec_->vec[--vec_->prefix.num];\n+}\n+\n \n /* Truncate to specific length\n    void VEC_T_truncate (VEC(T) *v, unsigned len);\n \n    Set the length as specified.  The new length must be less than or\n    equal to the current length.  This is an O(1) operation.  */\n \n-#define VEC_truncate(T,V,I)\t\t\\\n-\t(VEC_OP(T,base,truncate)(VEC_BASE(V),I VEC_CHECK_INFO))\n+#define VEC_truncate(T,V,I)\t\\\n+\t(VEC_truncate_1<T> (V, (unsigned)(I) VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline void\n+VEC_truncate_1 (vec_t<T> *vec_, unsigned size_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (vec_ ? vec_->prefix.num >= size_ : !size_, \"truncate\", T, base);\n+  if (vec_)\n+    vec_->prefix.num = size_;\n+}\n+\n \n /* Grow to a specific length.\n    void VEC_T_A_safe_grow (VEC(T,A) *&v, int len);\n@@ -355,7 +800,20 @@ along with GCC; see the file COPYING3.  If not see\n    uninitialized.  */\n \n #define VEC_safe_grow(T,A,V,I)\t\t\\\n-\t(VEC_OP(T,A,safe_grow)(&(V),I VEC_CHECK_INFO MEM_STAT_INFO))\n+\t(VEC_safe_grow_1<T, A> (&(V), (int)(I) VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline void\n+VEC_safe_grow_1 (vec_t<T> **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  VEC_ASSERT (size_ >= 0 && VEC_length (T, *vec_) <= (unsigned)size_,\n+\t      \"grow\", T, A);\n+  VEC_reserve_exact_1<T, A> (vec_,\n+\t\t\t     size_ - (int)(*vec_ ? (*vec_)->prefix.num : 0)\n+\t\t\t     VEC_CHECK_PASS PASS_MEM_STAT);\n+  (*vec_)->prefix.num = size_;\n+}\n+\n \n /* Grow to a specific length.\n    void VEC_T_A_safe_grow_cleared (VEC(T,A) *&v, int len);\n@@ -364,8 +822,21 @@ along with GCC; see the file COPYING3.  If not see\n    long or longer than the current length.  The new elements are\n    initialized to zero.  */\n \n-#define VEC_safe_grow_cleared(T,A,V,I)\t\t\\\n-\t(VEC_OP(T,A,safe_grow_cleared)(&(V),I VEC_CHECK_INFO MEM_STAT_INFO))\n+#define VEC_safe_grow_cleared(T,A,V,I)\t\t\t\\\n+\t(VEC_safe_grow_cleared_1<T,A> (&(V), (int)(I)\t\\\n+\t\t\t\t       VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline void\n+VEC_safe_grow_cleared_1 (vec_t<T> **vec_, int size_ VEC_CHECK_DECL\n+\t\t\t MEM_STAT_DECL)\n+{\n+  int oldsize = VEC_length (T, *vec_);\n+  VEC_safe_grow_1<T, A> (vec_, size_ VEC_CHECK_PASS PASS_MEM_STAT);\n+  memset (&(VEC_address (T, *vec_)[oldsize]), 0,\n+\t  sizeof (T) * (size_ - oldsize));\n+}\n+\n \n /* Replace element\n    T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Integer\n@@ -379,20 +850,57 @@ along with GCC; see the file COPYING3.  If not see\n    performed.  */\n \n #define VEC_replace(T,V,I,O)\t\t\\\n-\t(VEC_OP(T,base,replace)(VEC_BASE(V),I,O VEC_CHECK_INFO))\n+\t(VEC_replace_1<T> (V, (unsigned)(I), O VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline T&\n+VEC_replace_1 (vec_t<T> *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"replace\", T, base);\n+  vec_->vec[ix_] = obj_;\n+  return vec_->vec[ix_];\n+}\n+\n \n /* Insert object with no reallocation\n-   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Integer\n-   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Pointer\n-   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T *val); // Object\n+   void VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Integer\n+   void VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Pointer\n+   void VEC_T_quick_insert (VEC(T) *v, unsigned ix, T *val); // Object\n \n-   Insert an element, VAL, at the IXth position of V. Return a pointer\n-   to the slot created.  For vectors of object, the new value can be\n-   NULL, in which case no initialization of the inserted slot takes\n-   place. There must be sufficient space.  */\n+   Insert an element, VAL, at the IXth position of V.  For vectors of\n+   object, the new value can be NULL, in which case no initialization\n+   of the inserted slot takes place. There must be sufficient space.  */\n \n #define VEC_quick_insert(T,V,I,O)\t\\\n-\t(VEC_OP(T,base,quick_insert)(VEC_BASE(V),I,O VEC_CHECK_INFO))\n+\t(VEC_quick_insert_1<T> (V,I,O VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline void\n+VEC_quick_insert_1 (vec_t<T> *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\n+{\n+  T *slot_;\n+\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\n+  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\n+  slot_ = &vec_->vec[ix_];\n+  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\n+  *slot_ = obj_;\n+}\n+\n+template<typename T>\n+static inline void\n+VEC_quick_insert_1 (vec_t<T> *vec_, unsigned ix_, const T *ptr_ VEC_CHECK_DECL)\n+{\n+  T *slot_;\n+\n+  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\n+  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\n+  slot_ = &vec_->vec[ix_];\n+  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\n+  if (ptr_)\n+    *slot_ = *ptr_;\n+}\n+\n \n /* Insert object with reallocation\n    T *VEC_T_A_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Integer\n@@ -405,31 +913,70 @@ along with GCC; see the file COPYING3.  If not see\n    place. Reallocate V, if necessary.  */\n \n #define VEC_safe_insert(T,A,V,I,O)\t\\\n-\t(VEC_OP(T,A,safe_insert)(&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n+\t(VEC_safe_insert_1<T, A> (&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline void\n+VEC_safe_insert_1 (vec_t<T> **vec_, unsigned ix_, T obj_\n+\t\t   VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  VEC_quick_insert_1 (*vec_, ix_, obj_ VEC_CHECK_PASS);\n+}\n+\n+template<typename T, enum vec_allocation_t A>\n+static inline void\n+VEC_safe_insert_1 (vec_t<T> **vec_, unsigned ix_, T *ptr_\n+\t\t   VEC_CHECK_DECL MEM_STAT_DECL)\n+{\n+  VEC_reserve_1<T, A> (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n+  VEC_quick_insert_1 (*vec_, ix_, ptr_ VEC_CHECK_PASS);\n+}\n+\n+\n \n /* Remove element retaining order\n-   T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Integer\n-   T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Pointer\n+   void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Integer\n+   void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Pointer\n    void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Object\n \n    Remove an element from the IXth position of V. Ordering of\n-   remaining elements is preserved.  For pointer vectors returns the\n-   removed object.  This is an O(N) operation due to a memmove.  */\n+   remaining elements is preserved.  This is an O(N) operation due to\n+   a memmove.  */\n \n #define VEC_ordered_remove(T,V,I)\t\\\n-\t(VEC_OP(T,base,ordered_remove)(VEC_BASE(V),I VEC_CHECK_INFO))\n+\t(VEC_ordered_remove_1<T> (V,I VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline void\n+VEC_ordered_remove_1 (vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+{\n+  T *slot_;\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\n+  slot_ = &vec_->vec[ix_];\n+  memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (T));\n+}\n+\n \n /* Remove element destroying order\n-   T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Integer\n-   T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Pointer\n+   void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Integer\n+   void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Pointer\n    void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Object\n \n-   Remove an element from the IXth position of V. Ordering of\n-   remaining elements is destroyed.  For pointer vectors returns the\n-   removed object.  This is an O(1) operation.  */\n+   Remove an element from the IXth position of V.  Ordering of\n+   remaining elements is destroyed.  This is an O(1) operation.  */\n \n #define VEC_unordered_remove(T,V,I)\t\\\n-\t(VEC_OP(T,base,unordered_remove)(VEC_BASE(V),I VEC_CHECK_INFO))\n+\t(VEC_unordered_remove_1<T> (V,I VEC_CHECK_INFO))\n+\n+template<typename T>\n+static inline void\n+VEC_unordered_remove_1 (vec_t<T> *vec_, unsigned ix_ VEC_CHECK_DECL)\n+{\n+  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\n+  vec_->vec[ix_] = vec_->vec[--vec_->prefix.num];\n+}\n+\n \n /* Remove a block of elements\n    void VEC_T_block_remove (VEC(T) *v, unsigned ix, unsigned len);\n@@ -438,22 +985,27 @@ along with GCC; see the file COPYING3.  If not see\n    This is an O(N) operation due to memmove.  */\n \n #define VEC_block_remove(T,V,I,L)\t\\\n-\t(VEC_OP(T,base,block_remove)(VEC_BASE(V),I,L VEC_CHECK_INFO))\n+\t(VEC_block_remove_1<T> (V, I, L VEC_CHECK_INFO))\n \n-/* Get the address of the array of elements\n-   T *VEC_T_address (VEC(T) v)\n-\n-   If you need to directly manipulate the array (for instance, you\n-   want to feed it to qsort), use this accessor.  */\n+template<typename T>\n+static inline void\n+VEC_block_remove_1 (vec_t<T> *vec_, unsigned ix_, unsigned len_ VEC_CHECK_DECL)\n+{\n+  T *slot_;\n+  VEC_ASSERT (ix_ + len_ <= vec_->prefix.num, \"block_remove\", T, base);\n+  slot_ = &vec_->vec[ix_];\n+  vec_->prefix.num -= len_;\n+  memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (T));\n+}\n \n-#define VEC_address(T,V)\t\t(VEC_OP(T,base,address)(VEC_BASE(V)))\n \n /* Conveniently sort the contents of the vector with qsort.\n    void VEC_qsort (VEC(T) *v, int (*cmp_func)(const void *, const void *))  */\n \n-#define VEC_qsort(T,V,CMP) qsort(VEC_address (T,V), VEC_length(T,V),\t\\\n+#define VEC_qsort(T,V,CMP) qsort(VEC_address (T, V), VEC_length (T, V),\t\\\n \t\t\t\t sizeof (T), CMP)\n \n+\n /* Find the first index in the vector not less than the object.\n    unsigned VEC_T_lower_bound (VEC(T) *v, const T val,\n                                bool (*lessthan) (const T, const T)); // Integer\n@@ -466,955 +1018,140 @@ along with GCC; see the file COPYING3.  If not see\n    changing the ordering of V.  LESSTHAN is a function that returns\n    true if the first argument is strictly less than the second.  */\n \n-#define VEC_lower_bound(T,V,O,LT)    \\\n-       (VEC_OP(T,base,lower_bound)(VEC_BASE(V),O,LT VEC_CHECK_INFO))\n+#define VEC_lower_bound(T,V,O,LT)\t\\\n+        (VEC_lower_bound_1<T> (V, O, LT VEC_CHECK_INFO))\n \n-/* Reallocate an array of elements with prefix.  */\n-extern void *vec_gc_p_reserve (void *, int MEM_STAT_DECL);\n-extern void *vec_gc_p_reserve_exact (void *, int MEM_STAT_DECL);\n-extern void *vec_gc_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n-extern void *vec_gc_o_reserve_exact (void *, int, size_t, size_t\n-\t\t\t\t     MEM_STAT_DECL);\n-extern void ggc_free (void *);\n-#define vec_gc_free(V) ggc_free (V)\n-extern void *vec_heap_p_reserve (void *, int MEM_STAT_DECL);\n-extern void *vec_heap_p_reserve_exact (void *, int MEM_STAT_DECL);\n-extern void *vec_heap_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n-extern void *vec_heap_o_reserve_exact (void *, int, size_t, size_t\n-\t\t\t\t       MEM_STAT_DECL);\n-extern void dump_vec_loc_statistics (void);\n-extern void vec_heap_free (void *);\n-\n-#if ENABLE_CHECKING\n-#define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n-#define VEC_CHECK_DECL ,const char *file_,unsigned line_,const char *function_\n-#define VEC_CHECK_PASS ,file_,line_,function_\n-\n-#define VEC_ASSERT(EXPR,OP,T,A) \\\n-  (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(T,A)), 0))\n-\n-extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n-     ATTRIBUTE_NORETURN;\n-#define VEC_ASSERT_FAIL(OP,VEC) vec_assert_fail (OP,#VEC VEC_CHECK_PASS)\n-#else\n-#define VEC_CHECK_INFO\n-#define VEC_CHECK_DECL\n-#define VEC_CHECK_PASS\n-#define VEC_ASSERT(EXPR,OP,T,A) (void)(EXPR)\n-#endif\n-\n-/* Note: gengtype has hardwired knowledge of the expansions of the\n-   VEC, DEF_VEC_*, and DEF_VEC_ALLOC_* macros.  If you change the\n-   expansions of these macros you may need to change gengtype too.  */\n-\n-typedef struct GTY(()) vec_prefix\n+template<typename T>\n+static inline unsigned\n+VEC_lower_bound_1 (vec_t<T> *vec_, T obj_,\n+\t\t   bool (*lessthan_)(T, T) VEC_CHECK_DECL)\n {\n-  unsigned num;\n-  unsigned alloc;\n-} vec_prefix;\n-\n-#define VEC(T,A) VEC_##T##_##A\n-#define VEC_OP(T,A,OP) VEC_##T##_##A##_##OP\n-\n-/* Base of vector type, not user visible.  */\n-#define VEC_T(T,B)\t\t\t\t\t\t\t  \\\n-typedef struct VEC(T,B) \t\t\t\t \t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  struct vec_prefix prefix;\t\t\t\t\t\t  \\\n-  T vec[1];\t\t\t\t\t\t\t\t  \\\n-} VEC(T,B)\n-\n-#define VEC_T_GTY(T,B)\t\t\t\t\t\t\t  \\\n-typedef struct GTY(()) VEC(T,B)\t\t\t\t \t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  struct vec_prefix prefix;\t\t\t\t\t\t  \\\n-  T GTY ((length (\"%h.prefix.num\"))) vec[1];\t\t\t\t  \\\n-} VEC(T,B)\n-\n-#define VEC_T_GTY_ATOMIC(T,B)\t\t\t\t\t\t  \\\n-typedef struct GTY(()) VEC(T,B)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  struct vec_prefix prefix;\t\t\t\t\t\t  \\\n-  T GTY ((atomic)) vec[1];\t\t\t\t\t\t  \\\n-} VEC(T,B)\n-\n-/* Derived vector type, user visible.  */\n-#define VEC_TA_GTY(T,B,A,GTY)\t\t\t\t\t\t  \\\n-typedef struct GTY VEC(T,A)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T,B) base;\t\t\t\t\t\t\t  \\\n-} VEC(T,A)\n-\n-#define VEC_TA(T,B,A)\t\t\t\t\t\t\t  \\\n-typedef struct VEC(T,A)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T,B) base;\t\t\t\t\t\t\t  \\\n-} VEC(T,A)\n-\n-/* Convert to base type.  */\n-#if GCC_VERSION >= 4000\n-#define VEC_BASE(P) \\\n-  ((offsetof (__typeof (*P), base) == 0 || (P)) ? &(P)->base : 0)\n-#else\n-#define VEC_BASE(P)  ((P) ? &(P)->base : 0)\n-#endif\n-\n-/* Vector of integer-like object.  */\n-#define DEF_VEC_I(T)\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,must_be,integral_type) (void) \t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  (void)~(T)0;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-VEC_T(T,base);\t\t\t\t\t\t\t\t  \\\n-VEC_TA(T,base,none);\t\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-#define DEF_VEC_ALLOC_I(T,A)\t\t\t\t\t\t  \\\n-VEC_TA(T,base,A);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_I(T,A)\t\t\t\t\t\t  \\\n-DEF_VEC_NONALLOC_FUNCS_I(T,A)\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-/* Vector of pointer to object.  */\n-#define DEF_VEC_P(T) \t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,must_be,pointer_type) (void) \t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  (void)((T)1 == (void *)1);\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-VEC_T_GTY(T,base);\t\t\t\t\t\t\t  \\\n-VEC_TA(T,base,none);\t\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-#define DEF_VEC_ALLOC_P(T,A)\t\t\t\t\t\t  \\\n-VEC_TA(T,base,A);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t\t  \\\n-DEF_VEC_NONALLOC_FUNCS_P(T,A)\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-#define DEF_VEC_FUNC_P(T)\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)   \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->prefix.num : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,base,last)\t\t\t\t\t  \\\n-     (const VEC(T,base) *vec_ VEC_CHECK_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && vec_->prefix.num, \"last\", T, base);\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return vec_->vec[vec_->prefix.num - 1];\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,base,index)\t\t\t\t\t  \\\n-     (const VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return vec_->vec[ix_];\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,base,iterate)\t\t\t  \t  \\\n-     (const VEC(T,base) *vec_, unsigned ix_, T *ptr)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec_ && ix_ < vec_->prefix.num)\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = vec_->vec[ix_];\t\t\t\t\t\t  \\\n-      return 1;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = (T) 0;\t\t\t\t\t\t\t  \\\n-      return 0;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline size_t VEC_OP (T,base,embedded_size)\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return offsetof (VEC(T,base),vec) + alloc_ * sizeof(T);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,embedded_init)\t\t\t  \\\n-     (VEC(T,base) *vec_, int alloc_)\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_->prefix.num = 0;\t\t\t\t\t\t\t  \\\n-  vec_->prefix.alloc = alloc_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n-     (VEC(T,base) *vec_, int alloc_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\t\t\t\t  \\\n-  return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_;\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP(T,base,splice)\t\t\t\t  \\\n-     (VEC(T,base) *dst_, VEC(T,base) *src_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (src_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      unsigned len_ = src_->prefix.num;\t\t\t\t\t  \\\n-      VEC_ASSERT (dst_->prefix.num + len_ <= dst_->prefix.alloc, \"splice\", T, base);\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (T));\t  \\\n-      dst_->prefix.num += len_;\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, T obj_ VEC_CHECK_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\t\t  \\\n-  slot_ = &vec_->vec[vec_->prefix.num++];\t\t\t\t\t  \\\n-  *slot_ = obj_;\t\t\t\t\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,base,pop) (VEC(T,base) *vec_ VEC_CHECK_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->prefix.num, \"pop\", T, base);\t\t\t\t  \\\n-  obj_ = vec_->vec[--vec_->prefix.num];\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return obj_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,truncate)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ ? vec_->prefix.num >= size_ : !size_, \"truncate\", T, base);\t  \\\n-  if (vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_->prefix.num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,base,replace)\t\t  \t     \t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T old_obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"replace\", T, base);\t\t\t  \\\n-  old_obj_ = vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->vec[ix_] = obj_;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return old_obj_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,quick_insert)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, T obj_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\t\t  \\\n-  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\t\t  \\\n-  *slot_ = obj_;\t\t\t\t\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,base,ordered_remove)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-  T obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (T));     \t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return obj_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,base,unordered_remove)\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-  T obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  *slot_ = vec_->vec[--vec_->prefix.num];\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return obj_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,block_remove)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, unsigned len_ VEC_CHECK_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ + len_ <= vec_->prefix.num, \"block_remove\", T, base);\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->prefix.num -= len_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (T));\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,address)\t\t\t\t  \\\n-     (VEC(T,base) *vec_)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n-     (VEC(T,base) *vec_, const T obj_,\t\t\t\t\t  \\\n-      bool (*lessthan_)(const T, const T) VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-   unsigned int len_ = VEC_OP (T,base, length) (vec_);\t\t\t  \\\n-   unsigned int half_, middle_;\t\t\t\t\t\t  \\\n-   unsigned int first_ = 0;\t\t\t\t\t\t  \\\n-   while (len_ > 0)\t\t\t\t\t\t\t  \\\n-     {\t\t\t\t\t\t\t\t\t  \\\n-        T middle_elem_;\t\t\t\t\t\t\t  \\\n-        half_ = len_ >> 1;\t\t\t\t\t\t  \\\n-        middle_ = first_;\t\t\t\t\t\t  \\\n-        middle_ += half_;\t\t\t\t\t\t  \\\n-        middle_elem_ = VEC_OP (T,base,index) (vec_, middle_ VEC_CHECK_PASS); \\\n-        if (lessthan_ (middle_elem_, obj_))\t\t\t\t  \\\n-          {\t\t\t\t\t\t\t\t  \\\n-             first_ = middle_;\t\t\t\t\t\t  \\\n-             ++first_;\t\t\t\t\t\t\t  \\\n-             len_ = len_ - half_ - 1;\t\t\t\t\t  \\\n-          }\t\t\t\t\t\t\t\t  \\\n-        else\t\t\t\t\t\t\t\t  \\\n-          len_ = half_;\t\t\t\t\t\t\t  \\\n-     }\t\t\t\t\t\t\t\t\t  \\\n-   return first_;\t\t\t\t\t\t\t  \\\n+  unsigned int len_ = VEC_length (T, vec_);\n+  unsigned int half_, middle_;\n+  unsigned int first_ = 0;\n+  while (len_ > 0)\n+    {\n+      T middle_elem_;\n+      half_ = len_ >> 1;\n+      middle_ = first_;\n+      middle_ += half_;\n+      middle_elem_ = VEC_index_1 (vec_, middle_ VEC_CHECK_PASS);\n+      if (lessthan_ (middle_elem_, obj_))\n+\t{\n+\t  first_ = middle_;\n+\t  ++first_;\n+\t  len_ = len_ - half_ - 1;\n+\t}\n+      else\n+\tlen_ = half_;\n+    }\n+  return first_;\n }\n \n-#define DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t  \\\n-static inline VEC(T,A) *VEC_OP (T,A,alloc)\t\t\t\t  \\\n-     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC(T,A) *) vec_##A##_p_reserve_exact (NULL, alloc_\t\t  \\\n-\t\t\t\t\t\t PASS_MEM_STAT);\t  \\\n-}\n-\n-\n-#define DEF_VEC_NONALLOC_FUNCS_P(T,A)\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n-     (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_##A##_free (*vec_);\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->prefix.num : 0;\t\t\t\t\t  \\\n-  VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (len_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_ = (VEC (T,A) *)(vec_##A##_p_reserve_exact\t\t  \\\n-\t\t\t       (NULL, len_ PASS_MEM_STAT));\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->base.prefix.num = len_;\t\t\t\t\t  \\\n-      memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  return new_vec_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,A,reserve)\t       \t\t\t\t  \\\n-     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-\t\t  \t\t\t\t\t\t\t  \\\n-  if (extend)\t  \t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T,A) *) vec_##A##_p_reserve (*vec_, alloc_ PASS_MEM_STAT); \\\n-\t\t  \t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,A,reserve_exact)  \t\t\t\t  \\\n-     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-\t\t  \t\t\t\t\t\t\t  \\\n-  if (extend)\t  \t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T,A) *) vec_##A##_p_reserve_exact (*vec_, alloc_\t  \\\n-\t\t\t\t\t\t    PASS_MEM_STAT);\t  \\\n-\t\t  \t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n-     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n-\t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n-\t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n-  VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n-\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->prefix.num : 0) \\\n-\t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-  VEC_BASE (*vec_)->prefix.num = size_;\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n-     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int oldsize = VEC_OP(T,base,length) VEC_BASE(*vec_);\t\t\t  \\\n-  VEC_OP (T,A,safe_grow) (vec_, size_ VEC_CHECK_PASS PASS_MEM_STAT);\t  \\\n-  memset (&(VEC_OP (T,base,address) VEC_BASE(*vec_))[oldsize], 0,\t  \\\n-\t  sizeof (T) * (size_ - oldsize));\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n-     (VEC(T,A) **dst_, VEC(T,base) *src_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (src_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,A,reserve_exact) (dst_, src_->prefix.num\t\t\t  \\\n-\t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n-\t\t\t      VEC_CHECK_PASS);\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n-     (VEC(T,A) **vec_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)       \t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,base,quick_push) (VEC_BASE(*vec_), obj_ VEC_CHECK_PASS); \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n-     (VEC(T,A) **vec_, unsigned ix_, T obj_ VEC_CHECK_DECL MEM_STAT_DECL)  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n- \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-}\n-\n-/* Vector of object.  */\n-#define DEF_VEC_O(T)\t\t\t\t\t\t\t  \\\n-VEC_T_GTY(T,base);\t\t\t\t\t\t\t  \\\n-VEC_TA(T,base,none);\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_O(T)\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-#define DEF_VEC_ALLOC_O(T,A)\t\t\t\t\t\t  \\\n-VEC_TA(T,base,A);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_O(T,A)\t\t\t\t\t\t  \\\n-DEF_VEC_NONALLOC_FUNCS_O(T,A)\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-/* Vector of atomic object.  */\n-#define DEF_VEC_A(T)\t\t\t\t\t\t\t  \\\n-VEC_T_GTY_ATOMIC(T,base);\t\t\t\t\t\t  \\\n-VEC_TA(T,base,none);\t\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_O(T)\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-#define DEF_VEC_ALLOC_A(T,A) DEF_VEC_ALLOC_O(T,A)\n-\n-#define DEF_VEC_FUNC_O(T)\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->prefix.num : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,last) (VEC(T,base) *vec_ VEC_CHECK_DECL)  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && vec_->prefix.num, \"last\", T, base);\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return &vec_->vec[vec_->prefix.num - 1];\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,index)\t\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ && ix_ < vec_->prefix.num, \"index\", T, base);\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,base,iterate)\t\t\t     \t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, T **ptr)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec_ && ix_ < vec_->prefix.num)\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-      return 1;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = 0;\t\t\t\t\t\t\t\t  \\\n-      return 0;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline size_t VEC_OP (T,base,embedded_size)\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return offsetof (VEC(T,base),vec) + alloc_ * sizeof(T);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,embedded_init)\t\t\t  \\\n-     (VEC(T,base) *vec_, int alloc_)\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_->prefix.num = 0;\t\t\t\t\t\t\t  \\\n-  vec_->prefix.alloc = alloc_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,base,space)\t       \t\t\t\t  \\\n-     (VEC(T,base) *vec_, int alloc_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (alloc_ >= 0, \"space\", T, base);\t\t\t\t  \\\n-  return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_;\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP(T,base,splice)\t\t\t\t  \\\n-     (VEC(T,base) *dst_, VEC(T,base) *src_ VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (src_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      unsigned len_ = src_->prefix.num;\t\t\t\t\t  \\\n-      VEC_ASSERT (dst_->prefix.num + len_ <= dst_->prefix.alloc, \"splice\", T, base);\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (T));\t  \\\n-      dst_->prefix.num += len_;\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,quick_push)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, const T *obj_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"push\", T, base);\t\t  \\\n-  slot_ = &vec_->vec[vec_->prefix.num++];\t\t\t\t\t  \\\n-  if (obj_)\t\t\t\t\t\t\t\t  \\\n-    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,pop) (VEC(T,base) *vec_ VEC_CHECK_DECL) \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->prefix.num, \"pop\", T, base);\t\t\t\t  \\\n-  --vec_->prefix.num;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,truncate)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned size_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_ ? vec_->prefix.num >= size_ : !size_, \"truncate\", T, base);\t  \\\n-  if (vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_->prefix.num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,replace)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, const T *obj_ VEC_CHECK_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"replace\", T, base);\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  if (obj_)\t\t\t\t\t\t\t\t  \\\n-    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,quick_insert)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, const T *obj_ VEC_CHECK_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (vec_->prefix.num < vec_->prefix.alloc, \"insert\", T, base);\t\t  \\\n-  VEC_ASSERT (ix_ <= vec_->prefix.num, \"insert\", T, base);\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (T));\t\t  \\\n-  if (obj_)\t\t\t\t\t\t\t\t  \\\n-    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n-  \t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,ordered_remove)\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (T));\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,unordered_remove)\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_ VEC_CHECK_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ < vec_->prefix.num, \"remove\", T, base);\t\t\t  \\\n-  vec_->vec[ix_] = vec_->vec[--vec_->prefix.num];\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,base,block_remove)\t\t\t\t  \\\n-     (VEC(T,base) *vec_, unsigned ix_, unsigned len_ VEC_CHECK_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (ix_ + len_ <= vec_->prefix.num, \"block_remove\", T, base);\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->prefix.num -= len_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (T));\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,base,address)\t\t\t\t  \\\n-     (VEC(T,base) *vec_)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,base,lower_bound)\t\t\t  \\\n-     (VEC(T,base) *vec_, const T *obj_,\t\t\t\t\t  \\\n-      bool (*lessthan_)(const T *, const T *) VEC_CHECK_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-   unsigned int len_ = VEC_OP (T, base, length) (vec_);\t\t\t  \\\n-   unsigned int half_, middle_;\t\t\t\t\t\t  \\\n-   unsigned int first_ = 0;\t\t\t\t\t\t  \\\n-   while (len_ > 0)\t\t\t\t\t\t\t  \\\n-     {\t\t\t\t\t\t\t\t\t  \\\n-        T *middle_elem_;\t\t\t\t\t\t  \\\n-        half_ = len_ >> 1;\t\t\t\t\t\t  \\\n-        middle_ = first_;\t\t\t\t\t\t  \\\n-        middle_ += half_;\t\t\t\t\t\t  \\\n-        middle_elem_ = VEC_OP (T,base,index) (vec_, middle_ VEC_CHECK_PASS); \\\n-        if (lessthan_ (middle_elem_, obj_))\t\t\t\t  \\\n-          {\t\t\t\t\t\t\t\t  \\\n-             first_ = middle_;\t\t\t\t\t\t  \\\n-             ++first_;\t\t\t\t\t\t\t  \\\n-             len_ = len_ - half_ - 1;\t\t\t\t\t  \\\n-          }\t\t\t\t\t\t\t\t  \\\n-        else\t\t\t\t\t\t\t\t  \\\n-          len_ = half_;\t\t\t\t\t\t\t  \\\n-     }\t\t\t\t\t\t\t\t\t  \\\n-   return first_;\t\t\t\t\t\t\t  \\\n-}\n-\n-#define DEF_VEC_ALLOC_FUNC_O(T,A)\t\t\t\t\t  \\\n-static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n-     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC(T,A) *) vec_##A##_o_reserve_exact (NULL, alloc_,\t\t  \\\n-\t\t\t\t\t\t offsetof (VEC(T,A),base.vec), \\\n-\t\t\t\t\t\t sizeof (T)\t\t  \\\n-\t\t\t\t\t\t PASS_MEM_STAT);\t  \\\n-}\n-\n-#define DEF_VEC_NONALLOC_FUNCS_O(T,A)\t\t\t\t\t  \\\n-static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->prefix.num : 0;\t\t\t\t\t  \\\n-  VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (len_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve_exact\t\t  \\\n-\t\t\t       (NULL, len_,\t\t\t\t  \\\n-\t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n-\t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->base.prefix.num = len_;\t\t\t\t\t  \\\n-      memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  return new_vec_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n-     (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_##A##_free (*vec_);\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n-     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve (*vec_, alloc_,\t\t  \\\n-\t\t\t   \t\t      offsetof (VEC(T,A),base.vec),\\\n- \t\t\t\t\t      sizeof (T)\t\t  \\\n-\t\t\t   \t\t      PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,A,reserve_exact)   \t    \t\t\t  \\\n-     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve_exact\t\t\t  \\\n-\t\t\t (*vec_, alloc_,\t\t\t\t  \\\n-\t\t\t  offsetof (VEC(T,A),base.vec),\t\t\t  \\\n-\t\t\t  sizeof (T) PASS_MEM_STAT);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n-     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n-\t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n-\t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n-  VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n-\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->prefix.num : 0) \\\n-\t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-  VEC_BASE (*vec_)->prefix.num = size_;\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n-     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int oldsize = VEC_OP(T,base,length) VEC_BASE(*vec_);\t\t\t  \\\n-  VEC_OP (T,A,safe_grow) (vec_, size_ VEC_CHECK_PASS PASS_MEM_STAT);\t  \\\n-  memset (&(VEC_OP (T,base,address) VEC_BASE(*vec_))[oldsize], 0,\t  \\\n-\t  sizeof (T) * (size_ - oldsize));\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n-     (VEC(T,A) **dst_, VEC(T,base) *src_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (src_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,A,reserve_exact) (dst_, src_->prefix.num\t\t\t  \\\n-\t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n-\t\t\t      VEC_CHECK_PASS);\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n-     (VEC(T,A) **vec_, const T *obj_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,base,quick_push) (VEC_BASE(*vec_), obj_ VEC_CHECK_PASS);  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n-     (VEC(T,A) **vec_, unsigned ix_, const T *obj_\t\t\t  \\\n- \t\tVEC_CHECK_DECL MEM_STAT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-}\n-\n-#define DEF_VEC_ALLOC_FUNC_I(T,A)\t\t\t\t\t  \\\n-static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n-     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC(T,A) *) vec_##A##_o_reserve_exact\t\t\t\t  \\\n-\t\t      (NULL, alloc_, offsetof (VEC(T,A),base.vec),\t  \\\n-\t\t       sizeof (T) PASS_MEM_STAT);\t\t\t  \\\n-}\n-\n-#define DEF_VEC_NONALLOC_FUNCS_I(T,A)\t\t\t\t\t  \\\n-static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->prefix.num : 0;\t\t\t\t\t  \\\n-  VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (len_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve_exact\t\t  \\\n-\t\t\t       (NULL, len_,\t\t\t\t  \\\n-\t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n-\t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->base.prefix.num = len_;\t\t\t\t\t  \\\n-      memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  return new_vec_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n-     (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_##A##_free (*vec_);\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n-     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve (*vec_, alloc_,\t\t  \\\n-\t\t\t   \t\t      offsetof (VEC(T,A),base.vec),\\\n- \t\t\t\t\t      sizeof (T)\t\t  \\\n-\t\t\t   \t\t      PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,A,reserve_exact)   \t    \t\t\t  \\\n-     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_), alloc_\t\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve_exact\t\t\t  \\\n-\t\t\t (*vec_, alloc_, offsetof (VEC(T,A),base.vec),\t  \\\n-\t\t\t  sizeof (T) PASS_MEM_STAT);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n-     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n-\t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n-\t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n-  VEC_OP (T,A,reserve_exact) (vec_,\t\t\t\t\t  \\\n-\t\t\t      size_ - (int)(*vec_ ? VEC_BASE(*vec_)->prefix.num : 0) \\\n-\t\t\t      VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-  VEC_BASE (*vec_)->prefix.num = size_;\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,A,safe_grow_cleared)\t\t\t  \\\n-     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int oldsize = VEC_OP(T,base,length) VEC_BASE(*vec_);\t\t\t  \\\n-  VEC_OP (T,A,safe_grow) (vec_, size_ VEC_CHECK_PASS PASS_MEM_STAT);\t  \\\n-  memset (&(VEC_OP (T,base,address) VEC_BASE(*vec_))[oldsize], 0,\t  \\\n-\t  sizeof (T) * (size_ - oldsize));\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP(T,A,safe_splice)\t\t\t\t  \\\n-     (VEC(T,A) **dst_, VEC(T,base) *src_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (src_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,A,reserve_exact) (dst_, src_->prefix.num\t\t\t  \\\n-\t\t\t\t  VEC_CHECK_PASS MEM_STAT_INFO);\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      VEC_OP (T,base,splice) (VEC_BASE (*dst_), src_\t\t\t  \\\n-\t\t\t      VEC_CHECK_PASS);\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n-     (VEC(T,A) **vec_, const T obj_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,base,quick_push) (VEC_BASE(*vec_), obj_ VEC_CHECK_PASS);  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n-     (VEC(T,A) **vec_, unsigned ix_, const T obj_\t\t\t  \\\n- \t\tVEC_CHECK_DECL MEM_STAT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n-\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+template<typename T>\n+static inline unsigned\n+VEC_lower_bound_1 (vec_t<T> *vec_, const T *ptr_,\n+\t\t   bool (*lessthan_)(const T*, const T*) VEC_CHECK_DECL)\n+{\n+  unsigned int len_ = VEC_length (T, vec_);\n+  unsigned int half_, middle_;\n+  unsigned int first_ = 0;\n+  while (len_ > 0)\n+    {\n+      T *middle_elem_;\n+      half_ = len_ >> 1;\n+      middle_ = first_;\n+      middle_ += half_;\n+      middle_elem_ = &VEC_index_1 (vec_, middle_ VEC_CHECK_PASS);\n+      if (lessthan_ (middle_elem_, ptr_))\n+\t{\n+\t  first_ = middle_;\n+\t  ++first_;\n+\t  len_ = len_ - half_ - 1;\n+\t}\n+      else\n+\tlen_ = half_;\n+    }\n+  return first_;\n }\n \n-/* We support a vector which starts out with space on the stack and\n-   switches to heap space when forced to reallocate.  This works a\n-   little differently.  Instead of DEF_VEC_ALLOC_P(TYPE, heap|gc), use\n-   DEF_VEC_ALLOC_P_STACK(TYPE).  This uses alloca to get the initial\n-   space; because alloca can not be usefully called in an inline\n-   function, and because a macro can not define a macro, you must then\n-   write a #define for each type:\n \n-   #define VEC_{TYPE}_stack_alloc(alloc)                          \\\n-     VEC_stack_alloc({TYPE}, alloc)\n+void *vec_heap_o_reserve_1 (void *, int, size_t, size_t, bool MEM_STAT_DECL);\n+void *vec_gc_o_reserve_1 (void *, int, size_t, size_t, bool MEM_STAT_DECL);\n \n-   This is really a hack and perhaps can be made better.  Note that\n-   this macro will wind up evaluating the ALLOC parameter twice.\n+/* Ensure there are at least RESERVE free slots in VEC_, growing\n+   exponentially.  If RESERVE < 0 grow exactly, else grow\n+   exponentially.  As a special case, if VEC_ is NULL, and RESERVE is\n+   0, no vector will be created. */\n \n-   Only the initial allocation will be made using alloca, so pass a\n-   reasonable estimate that doesn't use too much stack space; don't\n-   pass zero.  Don't return a VEC(TYPE,stack) vector from the function\n-   which allocated it.  */\n-\n-extern void *vec_stack_p_reserve (void *, int MEM_STAT_DECL);\n-extern void *vec_stack_p_reserve_exact (void *, int MEM_STAT_DECL);\n-extern void *vec_stack_p_reserve_exact_1 (int, void *);\n-extern void *vec_stack_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n-extern void *vec_stack_o_reserve_exact (void *, int, size_t, size_t\n-\t\t\t\t\t MEM_STAT_DECL);\n-extern void vec_stack_free (void *);\n-\n-/* Unfortunately, we cannot use MEM_STAT_DECL here.  */\n-#if GATHER_STATISTICS\n-#define VEC_stack_alloc(T,alloc,name,line,function)\t\t\t  \\\n-  (VEC_OP (T,stack,alloc1)\t\t\t\t\t\t  \\\n-   (alloc, XALLOCAVAR (VEC(T,stack), VEC_embedded_size (T, alloc))))\n-#else\n-#define VEC_stack_alloc(T,alloc)\t\t\t\t\t  \\\n-  (VEC_OP (T,stack,alloc1)\t\t\t\t\t\t  \\\n-   (alloc, XALLOCAVAR (VEC(T,stack), VEC_embedded_size (T, alloc))))\n-#endif\n-\n-#define DEF_VEC_ALLOC_P_STACK(T)\t\t\t\t\t  \\\n-VEC_TA(T,base,stack);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_P_STACK(T)\t\t\t\t\t\t  \\\n-DEF_VEC_NONALLOC_FUNCS_P(T,stack)\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-#define DEF_VEC_ALLOC_FUNC_P_STACK(T)\t\t\t\t\t  \\\n-static inline VEC(T,stack) *VEC_OP (T,stack,alloc1)\t\t\t  \\\n-     (int alloc_, VEC(T,stack)* space)\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC(T,stack) *) vec_stack_p_reserve_exact_1 (alloc_, space);\t  \\\n+template<typename T, enum vec_allocation_t A>\n+vec_t<T> *\n+vec_reserve (vec_t<T> *vec_, int reserve MEM_STAT_DECL)\n+{\n+  if (A == gc)\n+    return (vec_t<T> *) vec_gc_o_reserve_1 (vec_, reserve,\n+\t\t\t\t\t    offsetof (vec_t<T>, vec),\n+\t\t\t\t\t    sizeof (T), false\n+\t\t\t\t\t    PASS_MEM_STAT);\n+  else if (A == heap)\n+    return (vec_t<T> *) vec_heap_o_reserve_1 (vec_, reserve,\n+\t\t\t\t\t      offsetof (vec_t<T>, vec),\n+\t\t\t\t\t      sizeof (T), false\n+\t\t\t\t\t      PASS_MEM_STAT);\n+  else\n+    {\n+      /* Only allow stack vectors when re-growing them.  The initial\n+\t allocation of stack vectors must be done with the\n+\t VEC_stack_alloc macro, because it uses alloca() for the\n+\t allocation.  */\n+      if (vec_ == NULL)\n+\t{\n+\t  fprintf (stderr, \"Stack vectors must be initially allocated \"\n+\t\t   \"with VEC_stack_alloc.\\n\");\n+\t  gcc_unreachable ();\n+\t}\n+      return (vec_t<T> *) vec_stack_o_reserve (vec_, reserve,\n+\t\t\t\t\t       offsetof (vec_t<T>, vec),\n+\t\t\t\t\t       sizeof (T) PASS_MEM_STAT);\n+    }\n }\n \n-#define DEF_VEC_ALLOC_O_STACK(T)\t\t\t\t\t  \\\n-VEC_TA(T,base,stack);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_O_STACK(T)\t\t\t\t\t\t  \\\n-DEF_VEC_NONALLOC_FUNCS_O(T,stack)\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n \n-#define DEF_VEC_ALLOC_FUNC_O_STACK(T)\t\t\t\t\t  \\\n-static inline VEC(T,stack) *VEC_OP (T,stack,alloc1)\t\t\t  \\\n-     (int alloc_, VEC(T,stack)* space)\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC(T,stack) *) vec_stack_p_reserve_exact_1 (alloc_, space);\t  \\\n-}\n-\n-#define DEF_VEC_ALLOC_I_STACK(T)\t\t\t\t\t  \\\n-VEC_TA(T,base,stack);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_I_STACK(T)\t\t\t\t\t\t  \\\n-DEF_VEC_NONALLOC_FUNCS_I(T,stack)\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n+/* Ensure there are at least RESERVE free slots in VEC_, growing\n+   exactly.  If RESERVE < 0 grow exactly, else grow exponentially.  As\n+   a special case, if VEC_ is NULL, and RESERVE is 0, no vector will be\n+   created. */\n \n-#define DEF_VEC_ALLOC_FUNC_I_STACK(T)\t\t\t\t\t  \\\n-static inline VEC(T,stack) *VEC_OP (T,stack,alloc1)\t\t\t  \\\n-     (int alloc_, VEC(T,stack)* space)\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC(T,stack) *) vec_stack_p_reserve_exact_1 (alloc_, space);   \\\n+template<typename T, enum vec_allocation_t A>\n+vec_t<T> *\n+vec_reserve_exact (vec_t<T> *vec_, int reserve MEM_STAT_DECL)\n+{\n+  if (A == gc)\n+    return (vec_t<T> *) vec_gc_o_reserve_1 (vec_, reserve,\n+\t\t\t\t\t    sizeof (struct vec_prefix),\n+\t\t\t\t\t    sizeof (T), true\n+\t\t\t\t\t    PASS_MEM_STAT);\n+  else if (A == heap)\n+    return (vec_t<T> *) vec_heap_o_reserve_1 (vec_, reserve,\n+\t\t\t\t\t      sizeof (struct vec_prefix),\n+\t\t\t\t\t      sizeof (T), true\n+\t\t\t\t\t      PASS_MEM_STAT);\n+  else if (A == stack)\n+    {\n+      /* Only allow stack vectors when re-growing them.  The initial\n+\t allocation of stack vectors must be done with VEC_alloc,\n+\t because it uses alloca() for the allocation.  */\n+      if (vec_ == NULL)\n+\t{\n+\t  fprintf (stderr, \"Stack vectors must be initially allocated \"\n+\t\t   \"with VEC_stack_alloc.\\n\");\n+\t  gcc_unreachable ();\n+\t}\n+      return (vec_t<T> *) vec_stack_o_reserve_exact (vec_, reserve,\n+\t\t\t\t\t\t     sizeof (struct vec_prefix),\n+\t\t\t\t\t\t     sizeof (T)\n+\t\t\t\t\t\t     PASS_MEM_STAT);\n+    }\n }\n \n #endif /* GCC_VEC_H */"}, {"sha": "e4da6ef3a107b622c16ba3af3ea01130a191b8ea", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -1,3 +1,18 @@\n+2012-08-14   Diego Novillo  <dnovillo@google.com>\n+\n+\tMerge from cxx-conversion branch.  Configury.\n+\n+\t* Makefile.in: Remove all handlers of ENABLE_BUILD_WITH_CXX.\n+\t* configure.ac: Likewise.\n+\t* configure: Regenerate.\n+\n+2012-08-14   Lawrence Crowl  <crowl@google.com>\n+\n+\tMerge from cxx-conversion branch.  New C++ hash table.\n+\n+\t* include/symtab.h (typedef struct ht hash_table): Change the typedef\n+\tname to cpp_hash_table.  Update all users of the typedef.\n+\n 2012-07-30  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n \n \t* include/line-map.h (line_map_macro): Use the \"atomic\" GTY option"}, {"sha": "3ae3280a2e3f4f3ccd6d2d1bcb3938cfe89948a7", "filename": "libcpp/Makefile.in", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FMakefile.in?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -77,16 +77,9 @@ ALL_CXXFLAGS = $(CXXFLAGS) $(WARN_CXXFLAGS) $(NOEXCEPTION_FLAGS) $(INCLUDES) \\\n \t$(CPPFLAGS)\n \n # The name of the compiler to use.\n-ENABLE_BUILD_WITH_CXX = @ENABLE_BUILD_WITH_CXX@\n-ifneq ($(ENABLE_BUILD_WITH_CXX),yes)\n-COMPILER = $(CC)\n-COMPILER_FLAGS = $(ALL_CFLAGS)\n-DEPMODE = $(CCDEPMODE)\n-else\n COMPILER = $(CXX)\n COMPILER_FLAGS = $(ALL_CXXFLAGS)\n DEPMODE = $(CXXDEPMODE)\n-endif\n \n \n libcpp_a_OBJS = charset.o directives.o directives-only.o errors.o \\"}, {"sha": "01e4462307f7ae6aa1b563133746fb45e41af74e", "filename": "libcpp/configure", "status": "modified", "additions": 7, "deletions": 279, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -612,7 +612,6 @@ USE_NLS\n ALLOCA\n LIBOBJS\n CXXDEPMODE\n-CCDEPMODE\n DEPDIR\n am__leading_dot\n WERROR\n@@ -623,7 +622,6 @@ warn\n AUTOHEADER\n AUTOCONF\n ACLOCAL\n-ENABLE_BUILD_WITH_CXX\n EGREP\n GREP\n CPP\n@@ -696,7 +694,6 @@ ac_subst_files=''\n ac_user_opts='\n enable_option_checking\n enable_largefile\n-enable_build_with_cxx\n enable_werror_always\n with_gnu_ld\n enable_rpath\n@@ -1332,7 +1329,6 @@ Optional Features:\n   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)\n   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]\n   --disable-largefile     omit support for large files\n-  --enable-build-with-cxx build with C++ compiler instead of C compiler\n   --enable-werror-always  enable -Werror despite compiler version\n   --disable-rpath         do not hardcode runtime library paths\n   --enable-maintainer-mode enable rules only needed by maintainers\n@@ -4541,17 +4537,6 @@ rm -rf conftest*\n fi\n \n \n-# See if we are building gcc with C++.\n-# Do this early so setting lang to C++ affects following tests\n-# Check whether --enable-build-with-cxx was given.\n-if test \"${enable_build_with_cxx+set}\" = set; then :\n-  enableval=$enable_build_with_cxx; ENABLE_BUILD_WITH_CXX=$enableval\n-else\n-  ENABLE_BUILD_WITH_CXX=no\n-fi\n-\n-\n-\n MISSING=`cd $ac_aux_dir && ${PWDCMD-pwd}`/missing\n for ac_prog in aclocal\n do\n@@ -4895,104 +4880,6 @@ DEPDIR=\"${am__leading_dot}deps\"\n ac_config_commands=\"$ac_config_commands depdir\"\n \n \n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"no\"; then\n-depcc=\"$CC\"   am_compiler_list=\n-\n-am_depcomp=$ac_aux_dir/depcomp\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc\" >&5\n-$as_echo_n \"checking dependency style of $depcc... \" >&6; }\n-if test \"${am_cv_CC_dependencies_compiler_type+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  if test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named `D' -- because `-MD' means `put the output\n-  # in D'.\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_CC_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n 's/^\\([a-zA-Z0-9]*\\))$/\\1/p' < ./depcomp`\n-  fi\n-  for depmode in $am_compiler_list; do\n-    if test $depmode = none; then break; fi\n-\n-    $as_echo \"$as_me:$LINENO: trying $depmode\" >&5\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n-      # Solaris 8's {/usr,}/bin/sh.\n-      touch sub/conftst$i.h\n-    done\n-    echo \"include sub/conftest.Po\" > confmf\n-\n-    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle `-M -o', and we need to detect this.\n-    depcmd=\"depmode=$depmode \\\n-       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c\"\n-    echo \"| $depcmd\" | sed -e 's/  */ /g' >&5\n-    if env $depcmd > conftest.err 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po >>conftest.err 2>&1 &&\n-       grep sub/conftest.${OBJEXT-o} sub/conftest.Po >>conftest.err 2>&1 &&\n-       ${MAKE-make} -s -f confmf >>conftest.err 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_CC_dependencies_compiler_type=$depmode\n-\t$as_echo \"$as_me:$LINENO: success\" >&5\n-        break\n-      fi\n-    fi\n-    $as_echo \"$as_me:$LINENO: failure, diagnostics are:\" >&5\n-    sed -e 's/^/| /' < conftest.err >&5\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_CC_dependencies_compiler_type=none\n-fi\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type\" >&5\n-$as_echo \"$am_cv_CC_dependencies_compiler_type\" >&6; }\n-if test x${am_cv_CC_dependencies_compiler_type-none} = xnone\n-then as_fn_error \"no usable dependency style found\" \"$LINENO\" 5\n-else CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type\n-\n-fi\n-\n-else\n ac_ext=cpp\n ac_cpp='$CXXCPP $CPPFLAGS'\n ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n@@ -5112,7 +4999,6 @@ else CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type\n \n fi\n \n-fi\n \n # Checks for header files.\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether time.h and sys/time.h may both be included\" >&5\n@@ -6454,6 +6340,12 @@ fi\n \n # g++ on Solaris 10+ defines _XOPEN_SOURCE=600, which exposes a different\n # iconv() prototype.\n+ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n \n       if test \"X$prefix\" = \"XNONE\"; then\n     acl_final_prefix=\"$ac_default_prefix\"\n@@ -6995,13 +6887,6 @@ fi\n   fi\n \n \n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"; then :\n-  ac_ext=cpp\n-ac_cpp='$CXXCPP $CPPFLAGS'\n-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n-\n \n \n \n@@ -7157,169 +7042,12 @@ _ACEOF\n \n   fi\n \n-   ac_ext=c\n+ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n-else\n-\n-\n-\n-\n-\n-          am_save_CPPFLAGS=\"$CPPFLAGS\"\n-\n-  for element in $INCICONV; do\n-    haveit=\n-    for x in $CPPFLAGS; do\n-\n-  acl_save_prefix=\"$prefix\"\n-  prefix=\"$acl_final_prefix\"\n-  acl_save_exec_prefix=\"$exec_prefix\"\n-  exec_prefix=\"$acl_final_exec_prefix\"\n-  eval x=\\\"$x\\\"\n-  exec_prefix=\"$acl_save_exec_prefix\"\n-  prefix=\"$acl_save_prefix\"\n-\n-      if test \"X$x\" = \"X$element\"; then\n-        haveit=yes\n-        break\n-      fi\n-    done\n-    if test -z \"$haveit\"; then\n-      CPPFLAGS=\"${CPPFLAGS}${CPPFLAGS:+ }$element\"\n-    fi\n-  done\n-\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for iconv\" >&5\n-$as_echo_n \"checking for iconv... \" >&6; }\n-if test \"${am_cv_func_iconv+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-    am_cv_func_iconv=\"no, consider installing GNU libiconv\"\n-    am_cv_lib_iconv=no\n-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <stdlib.h>\n-#include <iconv.h>\n-int\n-main ()\n-{\n-iconv_t cd = iconv_open(\"\",\"\");\n-       iconv(cd,NULL,NULL,NULL,NULL);\n-       iconv_close(cd);\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  am_cv_func_iconv=yes\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-    if test \"$am_cv_func_iconv\" != yes; then\n-      am_save_LIBS=\"$LIBS\"\n-      LIBS=\"$LIBS $LIBICONV\"\n-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <stdlib.h>\n-#include <iconv.h>\n-int\n-main ()\n-{\n-iconv_t cd = iconv_open(\"\",\"\");\n-         iconv(cd,NULL,NULL,NULL,NULL);\n-         iconv_close(cd);\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  am_cv_lib_iconv=yes\n-        am_cv_func_iconv=yes\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-      LIBS=\"$am_save_LIBS\"\n-    fi\n-\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $am_cv_func_iconv\" >&5\n-$as_echo \"$am_cv_func_iconv\" >&6; }\n-  if test \"$am_cv_func_iconv\" = yes; then\n-\n-$as_echo \"#define HAVE_ICONV 1\" >>confdefs.h\n-\n-  fi\n-  if test \"$am_cv_lib_iconv\" = yes; then\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking how to link with libiconv\" >&5\n-$as_echo_n \"checking how to link with libiconv... \" >&6; }\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $LIBICONV\" >&5\n-$as_echo \"$LIBICONV\" >&6; }\n-  else\n-            CPPFLAGS=\"$am_save_CPPFLAGS\"\n-    LIBICONV=\n-    LTLIBICONV=\n-  fi\n-\n-\n-\n-  if test \"$am_cv_func_iconv\" = yes; then\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for iconv declaration\" >&5\n-$as_echo_n \"checking for iconv declaration... \" >&6; }\n-    if test \"${am_cv_proto_iconv+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-#include <stdlib.h>\n-#include <iconv.h>\n-extern\n-#ifdef __cplusplus\n-\"C\"\n-#endif\n-#if defined(__STDC__) || defined(__cplusplus)\n-size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n-#else\n-size_t iconv();\n-#endif\n-\n-int\n-main ()\n-{\n-\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  am_cv_proto_iconv_arg1=\"\"\n-else\n-  am_cv_proto_iconv_arg1=\"const\"\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-      am_cv_proto_iconv=\"extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\"\n-fi\n-\n-    am_cv_proto_iconv=`echo \"$am_cv_proto_iconv\" | tr -s ' ' | sed -e 's/( /(/'`\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: ${ac_t:-\n-         }$am_cv_proto_iconv\" >&5\n-$as_echo \"${ac_t:-\n-         }$am_cv_proto_iconv\" >&6; }\n-\n-cat >>confdefs.h <<_ACEOF\n-#define ICONV_CONST $am_cv_proto_iconv_arg1\n-_ACEOF\n-\n-  fi\n-\n-fi\n \n # More defines and substitutions.\n PACKAGE=\"$PACKAGE_TARNAME\""}, {"sha": "29bd8c5e6f1a7bddb628f415f3138dfeaa69a483", "filename": "libcpp/configure.ac", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure.ac?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -17,14 +17,6 @@ AC_PROG_RANLIB\n AC_USE_SYSTEM_EXTENSIONS\n AC_SYS_LARGEFILE\n \n-# See if we are building gcc with C++.\n-# Do this early so setting lang to C++ affects following tests\n-AC_ARG_ENABLE(build-with-cxx,\n-[  --enable-build-with-cxx build with C++ compiler instead of C compiler],\n-ENABLE_BUILD_WITH_CXX=$enableval,\n-ENABLE_BUILD_WITH_CXX=no)\n-AC_SUBST(ENABLE_BUILD_WITH_CXX)\n-\n MISSING=`cd $ac_aux_dir && ${PWDCMD-pwd}`/missing\n AC_CHECK_PROGS([ACLOCAL], [aclocal], [$MISSING aclocal])\n AC_CHECK_PROGS([AUTOCONF], [autoconf], [$MISSING autoconf])\n@@ -49,15 +41,11 @@ ACX_PROG_CC_WARNINGS_ARE_ERRORS([manual])\n \n # Dependency checking.\n ZW_CREATE_DEPDIR\n-if test \"$ENABLE_BUILD_WITH_CXX\" = \"no\"; then\n-ZW_PROG_COMPILER_DEPENDENCIES([CC])\n-else\n AC_LANG_PUSH([C++])\n AC_COMPILE_IFELSE([[int i;]], [],\n \t\t  [AC_MSG_ERROR([C++ compiler missing or inoperational])])\n AC_LANG_POP([C++])\n ZW_PROG_COMPILER_DEPENDENCIES([CXX])\n-fi\n \n # Checks for header files.\n AC_HEADER_TIME\n@@ -108,11 +96,9 @@ fi\n \n # g++ on Solaris 10+ defines _XOPEN_SOURCE=600, which exposes a different\n # iconv() prototype.\n-AS_IF([test \"$ENABLE_BUILD_WITH_CXX\" = \"yes\"],\n-  [AC_LANG_PUSH([C++])\n-   AM_ICONV\n-   AC_LANG_POP([C++])],\n-  [AM_ICONV])\n+AC_LANG_PUSH([C++])\n+AM_ICONV\n+AC_LANG_POP([C++])\n \n # More defines and substitutions.\n PACKAGE=\"$PACKAGE_TARNAME\""}, {"sha": "d0973f4c9861629addc52713fcb8af4c9709072b", "filename": "libcpp/identifiers.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fidentifiers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fidentifiers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fidentifiers.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -28,12 +28,12 @@ along with this program; see the file COPYING3.  If not see\n #include \"cpplib.h\"\n #include \"internal.h\"\n \n-static hashnode alloc_node (hash_table *);\n+static hashnode alloc_node (cpp_hash_table *);\n \n /* Return an identifier node for hashtable.c.  Used by cpplib except\n    when integrated with the C front ends.  */\n static hashnode\n-alloc_node (hash_table *table)\n+alloc_node (cpp_hash_table *table)\n {\n   cpp_hashnode *node;\n \n@@ -45,7 +45,7 @@ alloc_node (hash_table *table)\n /* Set up the identifier hash table.  Use TABLE if non-null, otherwise\n    create our own.  */\n void\n-_cpp_init_hashtable (cpp_reader *pfile, hash_table *table)\n+_cpp_init_hashtable (cpp_reader *pfile, cpp_hash_table *table)\n {\n   struct spec_nodes *s;\n "}, {"sha": "30d7645beb0a808048b90382599e2c7f7113ab1c", "filename": "libcpp/include/symtab.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Finclude%2Fsymtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Finclude%2Fsymtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fsymtab.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -38,7 +38,7 @@ struct GTY(()) ht_identifier {\n #define HT_LEN(NODE) ((NODE)->len)\n #define HT_STR(NODE) ((NODE)->str)\n \n-typedef struct ht hash_table;\n+typedef struct ht cpp_hash_table;\n typedef struct ht_identifier *hashnode;\n \n enum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC};\n@@ -51,7 +51,7 @@ struct ht\n \n   hashnode *entries;\n   /* Call back, allocate a node.  */\n-  hashnode (*alloc_node) (hash_table *);\n+  hashnode (*alloc_node) (cpp_hash_table *);\n   /* Call back, allocate something that hangs off a node like a cpp_macro.  \n      NULL means use the usual allocator.  */\n   void * (*alloc_subobject) (size_t);\n@@ -71,14 +71,14 @@ struct ht\n };\n \n /* Initialize the hashtable with 2 ^ order entries.  */\n-extern hash_table *ht_create (unsigned int order);\n+extern cpp_hash_table *ht_create (unsigned int order);\n \n /* Frees all memory associated with a hash table.  */\n-extern void ht_destroy (hash_table *);\n+extern void ht_destroy (cpp_hash_table *);\n \n-extern hashnode ht_lookup (hash_table *, const unsigned char *,\n+extern hashnode ht_lookup (cpp_hash_table *, const unsigned char *,\n \t\t\t   size_t, enum ht_lookup_option);\n-extern hashnode ht_lookup_with_hash (hash_table *, const unsigned char *,\n+extern hashnode ht_lookup_with_hash (cpp_hash_table *, const unsigned char *,\n                                      size_t, unsigned int,\n                                      enum ht_lookup_option);\n #define HT_HASHSTEP(r, c) ((r) * 67 + ((c) - 113));\n@@ -88,17 +88,17 @@ extern hashnode ht_lookup_with_hash (hash_table *, const unsigned char *,\n    TABLE->PFILE, the node, and a PTR, and the callback sequence stops\n    if the callback returns zero.  */\n typedef int (*ht_cb) (struct cpp_reader *, hashnode, const void *);\n-extern void ht_forall (hash_table *, ht_cb, const void *);\n+extern void ht_forall (cpp_hash_table *, ht_cb, const void *);\n \n /* For all nodes in TABLE, call the callback.  If the callback returns\n    a nonzero value, the node is removed from the table.  */\n-extern void ht_purge (hash_table *, ht_cb, const void *);\n+extern void ht_purge (cpp_hash_table *, ht_cb, const void *);\n \n /* Restore the hash table.  */\n-extern void ht_load (hash_table *ht, hashnode *entries,\n+extern void ht_load (cpp_hash_table *ht, hashnode *entries,\n \t\t     unsigned int nslots, unsigned int nelements, bool own);\n \n /* Dump allocation statistics to stderr.  */\n-extern void ht_dump_statistics (hash_table *);\n+extern void ht_dump_statistics (cpp_hash_table *);\n \n #endif /* LIBCPP_SYMTAB_H */"}, {"sha": "040ab34eb90dcc8dab6518f80d5d6d44c27da944", "filename": "libcpp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -149,7 +149,7 @@ init_library (void)\n \n /* Initialize a cpp_reader structure.  */\n cpp_reader *\n-cpp_create_reader (enum c_lang lang, hash_table *table,\n+cpp_create_reader (enum c_lang lang, cpp_hash_table *table,\n \t\t   struct line_maps *line_table)\n {\n   cpp_reader *pfile;"}, {"sha": "79dd54f06cfa83e7c66dbda36129634ff0bdaa19", "filename": "libcpp/internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -619,7 +619,7 @@ extern void _cpp_push_token_context (cpp_reader *, cpp_hashnode *,\n extern void _cpp_backup_tokens_direct (cpp_reader *, unsigned int);\n \n /* In identifiers.c */\n-extern void _cpp_init_hashtable (cpp_reader *, hash_table *);\n+extern void _cpp_init_hashtable (cpp_reader *, cpp_hash_table *);\n extern void _cpp_destroy_hashtable (cpp_reader *);\n \n /* In files.c */"}, {"sha": "a3537a09e2681fe8ce20b0d9f7e26496821c1b8e", "filename": "libcpp/symtab.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0823efedd0fb8669b7e840954bc54c3b2cf08d67/libcpp%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fsymtab.c?ref=0823efedd0fb8669b7e840954bc54c3b2cf08d67", "patch": "@@ -31,7 +31,7 @@ along with this program; see the file COPYING3.  If not see\n    existing entry with a potential new one.  */\n \n static unsigned int calc_hash (const unsigned char *, size_t);\n-static void ht_expand (hash_table *);\n+static void ht_expand (cpp_hash_table *);\n static double approx_sqrt (double);\n \n /* A deleted entry.  */\n@@ -53,13 +53,13 @@ calc_hash (const unsigned char *str, size_t len)\n \n /* Initialize an identifier hashtable.  */\n \n-hash_table *\n+cpp_hash_table *\n ht_create (unsigned int order)\n {\n   unsigned int nslots = 1 << order;\n-  hash_table *table;\n+  cpp_hash_table *table;\n \n-  table = XCNEW (hash_table);\n+  table = XCNEW (cpp_hash_table);\n \n   /* Strings need no alignment.  */\n   _obstack_begin (&table->stack, 0, 0,\n@@ -77,7 +77,7 @@ ht_create (unsigned int order)\n /* Frees all memory associated with a hash table.  */\n \n void\n-ht_destroy (hash_table *table)\n+ht_destroy (cpp_hash_table *table)\n {\n   obstack_free (&table->stack, NULL);\n   if (table->entries_owned)\n@@ -91,15 +91,15 @@ ht_destroy (hash_table *table)\n    returns NULL.  Otherwise insert and returns a new entry.  A new\n    string is allocated.  */\n hashnode\n-ht_lookup (hash_table *table, const unsigned char *str, size_t len,\n+ht_lookup (cpp_hash_table *table, const unsigned char *str, size_t len,\n \t   enum ht_lookup_option insert)\n {\n   return ht_lookup_with_hash (table, str, len, calc_hash (str, len),\n \t\t\t      insert);\n }\n \n hashnode\n-ht_lookup_with_hash (hash_table *table, const unsigned char *str,\n+ht_lookup_with_hash (cpp_hash_table *table, const unsigned char *str,\n \t\t     size_t len, unsigned int hash,\n \t\t     enum ht_lookup_option insert)\n {\n@@ -182,7 +182,7 @@ ht_lookup_with_hash (hash_table *table, const unsigned char *str,\n /* Double the size of a hash table, re-hashing existing entries.  */\n \n static void\n-ht_expand (hash_table *table)\n+ht_expand (cpp_hash_table *table)\n {\n   hashnode *nentries, *p, *limit;\n   unsigned int size, sizemask;\n@@ -224,7 +224,7 @@ ht_expand (hash_table *table)\n /* For all nodes in TABLE, callback CB with parameters TABLE->PFILE,\n    the node, and V.  */\n void\n-ht_forall (hash_table *table, ht_cb cb, const void *v)\n+ht_forall (cpp_hash_table *table, ht_cb cb, const void *v)\n {\n   hashnode *p, *limit;\n \n@@ -242,7 +242,7 @@ ht_forall (hash_table *table, ht_cb cb, const void *v)\n /* Like ht_forall, but a nonzero return from the callback means that\n    the entry should be removed from the table.  */\n void\n-ht_purge (hash_table *table, ht_cb cb, const void *v)\n+ht_purge (cpp_hash_table *table, ht_cb cb, const void *v)\n {\n   hashnode *p, *limit;\n \n@@ -259,7 +259,7 @@ ht_purge (hash_table *table, ht_cb cb, const void *v)\n \n /* Restore the hash table.  */\n void\n-ht_load (hash_table *ht, hashnode *entries,\n+ht_load (cpp_hash_table *ht, hashnode *entries,\n \t unsigned int nslots, unsigned int nelements,\n \t bool own)\n {\n@@ -274,7 +274,7 @@ ht_load (hash_table *ht, hashnode *entries,\n /* Dump allocation statistics to stderr.  */\n \n void\n-ht_dump_statistics (hash_table *table)\n+ht_dump_statistics (cpp_hash_table *table)\n {\n   size_t nelts, nids, overhead, headers;\n   size_t total_bytes, longest, deleted = 0;"}]}