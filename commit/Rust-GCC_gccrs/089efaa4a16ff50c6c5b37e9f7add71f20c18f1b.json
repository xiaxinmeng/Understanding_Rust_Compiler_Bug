{"sha": "089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5ZWZhYTRhMTZmZjUwYzZjNWIzN2U5ZjdhZGQ3MWYyMGMxOGYxYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-01-21T19:05:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-01-21T19:05:23Z"}, "message": "re PR tree-optimization/13000 ([unit-at-a-time] Using -O2 cannot detect missing return statement in a function)\n\n\tPR tree-optimization/13000\n\t* tree-inline.c: Include \"tree-flow.h\".\n\t(expand_call_inline): If warn_return_type, warn if non-void inline\n\tfunction falls through.\n\t* tree-cfg.c (execute_warn_function_return): Don't warn about\n\tcontrol reaching end if TREE_NO_WARNING is set.  Set\n\tTREE_NO_WARNING.\n\t* gimple-low.c (block_may_fallthru): Don't assume that SWITCH_EXPR\n\thas been lowered.\n\t* gimplify.c (shortcut_cond_expr): Don't emit a jump over the else\n\tbranch if we don't need one.\n\t* c-typeck.c: Include \"tree-flow.h\"\n\t(c_finish_bc_stmt): Don't add a goto if the current statement\n\tlist doesn't fall through to the current point.\n\nFrom-SVN: r94024", "tree": {"sha": "29a38b973974253486c46f8b085f055eee2e1e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29a38b973974253486c46f8b085f055eee2e1e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f"}], "stats": {"total": 81, "additions": 75, "deletions": 6}, "files": [{"sha": "b97af9a6f31740acc55156767e1d39e9f2f73b79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "patch": "@@ -1,3 +1,20 @@\n+2005-01-20  Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR tree-optimization/13000\n+\t* tree-inline.c: Include \"tree-flow.h\".\n+\t(expand_call_inline): If warn_return_type, warn if non-void inline\n+\tfunction falls through.\n+\t* tree-cfg.c (execute_warn_function_return): Don't warn about\n+\tcontrol reaching end if TREE_NO_WARNING is set.  Set\n+\tTREE_NO_WARNING.\n+\t* gimple-low.c (block_may_fallthru): Don't assume that SWITCH_EXPR\n+\thas been lowered.\n+\t* gimplify.c (shortcut_cond_expr): Don't emit a jump over the else\n+\tbranch if we don't need one.\n+\t* c-typeck.c: Include \"tree-flow.h\"\n+\t(c_finish_bc_stmt): Don't add a goto if the current statement\n+\tlist doesn't fall through to the current point.\n+\n 2005-01-21  Roger Sayle  <roger@eyesopen.com>\n \n \tPR rtl-optimization/576"}, {"sha": "a4e4bc9df26efb1c08e7f3b8f7d8902d4dc2d6c9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "patch": "@@ -43,6 +43,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"tree-iterator.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-flow.h\"\n \n /* Possible cases of implicit bad conversions.  Used to select\n    diagnostic messages in convert_for_assignment.  */\n@@ -6762,10 +6763,23 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n tree\n c_finish_bc_stmt (tree *label_p, bool is_break)\n {\n+  bool skip;\n   tree label = *label_p;\n \n+  /* In switch statements break is sometimes stylistically used after\n+     a return statement.  This can lead to spurious warnings about\n+     control reaching the end of a non-void function when it is\n+     inlined.  Note that we are calling block_may_fallthru with\n+     language specific tree nodes; this works because\n+     block_may_fallthru returns true when given something it does not\n+     understand.  */\n+  skip = !block_may_fallthru (cur_stmt_list);\n+\n   if (!label)\n-    *label_p = label = create_artificial_label ();\n+    {\n+      if (!skip)\n+\t*label_p = label = create_artificial_label ();\n+    }\n   else if (TREE_CODE (label) != LABEL_DECL)\n     {\n       if (is_break)\n@@ -6775,6 +6789,9 @@ c_finish_bc_stmt (tree *label_p, bool is_break)\n       return NULL_TREE;\n     }\n \n+  if (skip)\n+    return NULL_TREE;\n+\n   return add_stmt (build1 (GOTO_EXPR, void_type_node, label));\n }\n "}, {"sha": "17ba0393c25bda78f8de13e00f740f3e60d995bd", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "patch": "@@ -278,11 +278,17 @@ block_may_fallthru (tree block)\n     case GOTO_EXPR:\n     case RETURN_EXPR:\n     case RESX_EXPR:\n-    case SWITCH_EXPR:\n       /* Easy cases.  If the last statement of the block implies \n \t control transfer, then we can't fall through.  */\n       return false;\n \n+    case SWITCH_EXPR:\n+      /* If SWITCH_LABELS is set, this is lowered, and represents a\n+\t branch to a selected label and hence can not fall through.\n+\t Otherwise SWITCH_BODY is set, and the switch can fall\n+\t through.  */\n+      return SWITCH_LABELS (stmt) != NULL_TREE;\n+\n     case COND_EXPR:\n       if (block_may_fallthru (COND_EXPR_THEN (stmt)))\n \treturn true;"}, {"sha": "60d35724aaffd9df1a0af3c3aa8f0603bc3ea34e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "patch": "@@ -1911,7 +1911,7 @@ shortcut_cond_expr (tree expr)\n   tree true_label, false_label, end_label, t;\n   tree *true_label_p;\n   tree *false_label_p;\n-  bool emit_end, emit_false;\n+  bool emit_end, emit_false, jump_over_else;\n   bool then_se = then_ && TREE_SIDE_EFFECTS (then_);\n   bool else_se = else_ && TREE_SIDE_EFFECTS (else_);\n \n@@ -2013,6 +2013,16 @@ shortcut_cond_expr (tree expr)\n   emit_end = (end_label == NULL_TREE);\n   emit_false = (false_label == NULL_TREE);\n \n+  /* We only emit the jump over the else clause if we have to--if the\n+     then clause may fall through.  Otherwise we can wind up with a\n+     useless jump and a useless label at the end of gimplified code,\n+     which will cause us to think that this conditional as a whole\n+     falls through even if it doesn't.  If we then inline a function\n+     which ends with such a condition, that can cause us to issue an\n+     inappropriate warning about control reaching the end of a\n+     non-void function.  */\n+  jump_over_else = block_may_fallthru (then_);\n+\n   pred = shortcut_cond_r (pred, true_label_p, false_label_p);\n \n   expr = NULL;\n@@ -2021,8 +2031,11 @@ shortcut_cond_expr (tree expr)\n   append_to_statement_list (then_, &expr);\n   if (else_se)\n     {\n-      t = build_and_jump (&end_label);\n-      append_to_statement_list (t, &expr);\n+      if (jump_over_else)\n+\t{\n+\t  t = build_and_jump (&end_label);\n+\t  append_to_statement_list (t, &expr);\n+\t}\n       if (emit_false)\n \t{\n \t  t = build1 (LABEL_EXPR, void_type_node, false_label);"}, {"sha": "93dfc343f8289255f3a42a9326e5ef35e22442e8", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "patch": "@@ -5677,6 +5677,7 @@ execute_warn_function_return (void)\n   /* If we see \"return;\" in some basic block, then we do reach the end\n      without returning a value.  */\n   else if (warn_return_type\n+\t   && !TREE_NO_WARNING (cfun->decl)\n \t   && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0\n \t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (cfun->decl))))\n     {\n@@ -5697,6 +5698,7 @@ execute_warn_function_return (void)\n \t\tlocus = &cfun->function_end_locus;\n \t      warning (\"%Hcontrol reaches end of non-void function\", locus);\n #endif\n+\t      TREE_NO_WARNING (cfun->decl) = 1;\n \t      break;\n \t    }\n \t}"}, {"sha": "b46276a4e4ce5190f93e12352b78672615bde117", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089efaa4a16ff50c6c5b37e9f7add71f20c18f1b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=089efaa4a16ff50c6c5b37e9f7add71f20c18f1b", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cgraph.h\"\n #include \"intl.h\"\n #include \"tree-mudflap.h\"\n+#include \"tree-flow.h\"\n #include \"function.h\"\n #include \"diagnostic.h\"\n #include \"debug.h\"\n@@ -1607,9 +1608,22 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n      function itself.  */\n   {\n     struct cgraph_node *old_node = id->current_node;\n+    tree copy;\n \n     id->current_node = edge->callee;\n-    append_to_statement_list (copy_body (id), &BIND_EXPR_BODY (expr));\n+    copy = copy_body (id);\n+\n+    if (warn_return_type\n+\t&& !TREE_NO_WARNING (fn)\n+\t&& !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fn)))\n+\t&& block_may_fallthru (copy))\n+      {\n+\twarning (\"control may reach end of non-void function %qD being inlined\",\n+\t\t fn);\n+\tTREE_NO_WARNING (fn) = 1;\n+      }\n+\n+    append_to_statement_list (copy, &BIND_EXPR_BODY (expr));\n     id->current_node = old_node;\n   }\n   inlined_body = &BIND_EXPR_BODY (expr);"}]}