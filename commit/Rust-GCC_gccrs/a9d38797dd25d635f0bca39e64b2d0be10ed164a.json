{"sha": "a9d38797dd25d635f0bca39e64b2d0be10ed164a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlkMzg3OTdkZDI1ZDYzNWYwYmNhMzllNjRiMmQwYmUxMGVkMTY0YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-18T19:53:00Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-18T19:53:00Z"}, "message": "x\n\nFrom-SVN: r13201", "tree": {"sha": "ec146751786deaf26f6e192b938e87fc3114cf0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec146751786deaf26f6e192b938e87fc3114cf0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9d38797dd25d635f0bca39e64b2d0be10ed164a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d38797dd25d635f0bca39e64b2d0be10ed164a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9d38797dd25d635f0bca39e64b2d0be10ed164a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d38797dd25d635f0bca39e64b2d0be10ed164a/comments", "author": null, "committer": null, "parents": [{"sha": "9293498fb3d941e3831b7fe0258c861190d044da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9293498fb3d941e3831b7fe0258c861190d044da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9293498fb3d941e3831b7fe0258c861190d044da"}], "stats": {"total": 402, "additions": 105, "deletions": 297}, "files": [{"sha": "c6a025bc855a5caf06455d791f0f2a059ac4c63c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 105, "deletions": 297, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d38797dd25d635f0bca39e64b2d0be10ed164a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d38797dd25d635f0bca39e64b2d0be10ed164a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a9d38797dd25d635f0bca39e64b2d0be10ed164a", "patch": "@@ -280,35 +280,8 @@ extern char *language_string;\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n-#ifndef SHORT_TYPE_SIZE\n-#define SHORT_TYPE_SIZE (BITS_PER_UNIT * 2)\n-#endif\n-#ifndef INT_TYPE_SIZE\n-#define INT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-#ifndef LONG_TYPE_SIZE\n-#define LONG_TYPE_SIZE BITS_PER_WORD\n-#endif\n-#ifndef LONG_LONG_TYPE_SIZE\n-#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-#ifndef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n-#endif\n-#ifndef WCHAR_UNSIGNED\n-#define WCHAR_UNSIGNED 0\n-#endif\n-#ifndef FLOAT_TYPE_SIZE\n-#define FLOAT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-#ifndef DOUBLE_TYPE_SIZE\n-#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-#ifndef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n #ifndef PTR_SIZE\n-#define PTR_SIZE (POINTER_SIZE / 8)\n+#define PTR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n #endif\n \n /* The size in bytes of a DWARF field indicating an offset or length\n@@ -563,58 +536,6 @@ static long int current_funcdef_frame_size = 0;\n static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n \n-/* DWARF requires that the compiler's primary datatypes\n-   are mapped into a reference to a DIE that defines that\n-   primary (base) type.  The base_type_info structure is used\n-   to track the correspondence between the name of a\n-   base type used by GCC, and its corresponding type\n-   characteristics.  Note, that the bt_size field below\n-   is the size in bits.  */\n-typedef struct base_type_struct *base_type_ref;\n-typedef struct base_type_struct\n-  {\n-    char *bt_name;\n-    enum dwarf_type bt_type;\n-    int bt_is_signed;\n-    int bt_size;\n-  }\n-base_type_info;\n-\n-/* Characteristics of base types used by the compiler.  */\n-static base_type_info base_type_table[] =\n-{\n-  {\"void\", DW_ATE_unsigned, 0, 0},\n-  /* TODO: on some architectures, \"char\" may be signed. */\n-  {\"char\", DW_ATE_unsigned_char, 0, CHAR_TYPE_SIZE},\n-  {\"unsigned char\", DW_ATE_unsigned_char, 0, CHAR_TYPE_SIZE},\n-  {\"signed char\", DW_ATE_signed_char, 1, CHAR_TYPE_SIZE},\n-  {\"int\", DW_ATE_signed, 1, /* INT_TYPE_SIZE */ 4*8},\n-  {\"unsigned int\", DW_ATE_unsigned, 0, /* INT_TYPE_SIZE */ 4*8},\n-  {\"short\", DW_ATE_signed, 1, SHORT_TYPE_SIZE},\n-  {\"short int\", DW_ATE_signed, 1, SHORT_TYPE_SIZE},\n-  {\"short unsigned int\", DW_ATE_unsigned, 0, SHORT_TYPE_SIZE},\n-  {\"long\", DW_ATE_signed, 1, /* LONG_TYPE_SIZE */ 4*8},\n-  {\"long int\", DW_ATE_signed, 1, /* LONG_TYPE_SIZE */ 4*8},\n-  {\"long unsigned int\", DW_ATE_unsigned, 0, /* LONG_TYPE_SIZE */ 4*8},\n-  {\"long long int\", DW_ATE_signed, 1, LONG_LONG_TYPE_SIZE},\n-  {\"long long unsigned int\", DW_ATE_unsigned, 0, LONG_LONG_TYPE_SIZE},\n-  {\"float\", DW_ATE_float, 1, /* FLOAT_TYPE_SIZE */ 4*8},\n-  {\"double\", DW_ATE_float, 1, DOUBLE_TYPE_SIZE},\n-  {\"long double\", DW_ATE_float, 1, LONG_DOUBLE_TYPE_SIZE},\n-  {\"complex\", DW_ATE_complex_float, 1, 2 * /* FLOAT_TYPE_SIZE */ 4*8},\n-  {\"double complex\", DW_ATE_complex_float, 1, 2 * DOUBLE_TYPE_SIZE},\n-  {\"long double complex\", DW_ATE_complex_float, 1, 2 * LONG_DOUBLE_TYPE_SIZE}\n-};\n-#define NUM_BASE_TYPES (sizeof(base_type_table)/sizeof(base_type_info))\n-\n-/* Record the DIE associated with a given base type  This table is\n-   parallel to the base_type_table, and records the DIE genereated\n-   to describe base type that has been previously referenced.  */\n-static dw_die_ref base_type_die_table[NUM_BASE_TYPES];\n-\n-/* This predefined base type is used to create certain anonymous types */\n-static dw_die_ref int_base_type_die;\n-\n /* A pointer to the ..._DECL node which we have most recently been working\n    on.  We keep this around just in case something about it looks screwy and\n    we want to tell the user what the source coordinates for the actual\n@@ -2285,6 +2206,21 @@ get_AT_unsigned (die, attr_kind)\n   return 0;\n }\n \n+inline int\n+is_c_family ()\n+{\n+  register unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  return (lang == DW_LANG_C || lang == DW_LANG_C89\n+\t  || lang == DW_LANG_C_plus_plus);\n+} \n+\n+inline int\n+is_fortran ()\n+{\n+  register unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  return (lang == DW_LANG_Fortran77 || lang == DW_LANG_Fortran90);\n+} \n+\n /* Remove the specified attribute if present.  */\n inline void\n remove_AT (die, attr_kind)\n@@ -4660,37 +4596,6 @@ is_body_block (stmt)\n   return 0;\n }\n \n-/* Reset the base type to DIE table, and build a special predefined\n-   base type entry for the \"int\" signed integer base type.  The\n-   \"int\" base type is used to construct subscript index range\n-   definitions, in situations where an anonymous integer type\n-   is required.  */\n-inline void\n-init_base_type_table ()\n-{\n-  register int i;\n-  register base_type_ref bt;\n-  for (i = 0; i < NUM_BASE_TYPES; ++i)\n-    {\n-      base_type_die_table[i] = NULL;\n-    }\n-  assert (comp_unit_die != 0);\n-  for (i = 0; i < NUM_BASE_TYPES; ++i)\n-    {\n-      bt = &base_type_table[i];\n-      if (strcmp (bt->bt_name, \"int\") == 0)\n-\t{\n-\t  int_base_type_die = new_die (DW_TAG_base_type, comp_unit_die);\n-\t  base_type_die_table[i] = int_base_type_die;\n-\t  add_AT_string (int_base_type_die, DW_AT_name, bt->bt_name);\n-\t  add_AT_unsigned (int_base_type_die,\n-\t\t\t   DW_AT_byte_size, bt->bt_size / 8);\n-\t  add_AT_unsigned (int_base_type_die, DW_AT_encoding, bt->bt_type);\n-\t  break;\n-\t}\n-    }\n-}\n-\n /* Given a pointer to a tree node for some base type, return a pointer to\n    a DIE that describes the given type.\n \n@@ -4700,144 +4605,71 @@ static dw_die_ref\n base_type_die (type)\n      register tree type;\n {\n-  register dw_die_ref base_type_result = NULL;\n-  register char *type_name = NULL;\n-  register int type_index = 0;\n-  register base_type_ref bt;\n-  register int i;\n+  register dw_die_ref base_type_result;\n+  register char *type_name;\n+  register enum dwarf_type encoding;\n \n-  if (TREE_CODE (type) == ERROR_MARK)\n+  if (TREE_CODE (type) == ERROR_MARK\n+      || TREE_CODE (type) == VOID_TYPE)\n     return 0;\n \n+  {\n+    register tree name = TYPE_NAME (type);\n+    if (TREE_CODE (name) == TYPE_DECL)\n+      name = DECL_NAME (name);\n+    type_name = IDENTIFIER_POINTER (name);\n+  }\n+\n   switch (TREE_CODE (type))\n     {\n-    case VOID_TYPE:\n-    case ERROR_MARK:\n-      break;\n-\n     case INTEGER_TYPE:\n-      /* Carefully distinguish all the standard types of C, without messing\n+      /* Carefully distinguish the C character types, without messing\n          up if the language is not C. Note that we check only for the names\n          that contain spaces; other names might occur by coincidence in other \n          languages.  */\n-      if (TYPE_NAME (type) != 0\n-\t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t  && DECL_NAME (TYPE_NAME (type)) != 0\n-\t  && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)\n+      if (! (TYPE_PRECISION (type) == CHAR_TYPE_SIZE\n+\t     && (type == char_type_node\n+\t\t || ! strcmp (type_name, \"signed char\")\n+\t\t || ! strcmp (type_name, \"unsigned char\"))))\n \t{\n-\t  type_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\t  for (i = 0; i < NUM_BASE_TYPES; ++i)\n-\t    {\n-\t      bt = &base_type_table[i];\n-\t      if (strcmp (type_name, bt->bt_name) == 0)\n-\t\t{\n-\t\t  type_index = i;\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t  if (TREE_UNSIGNED (type))\n+\t    encoding = DW_ATE_unsigned;\n+\t  else\n+\t    encoding = DW_ATE_signed;\n+\t  break;\n \t}\n+      /* else fall through */\n \n-      /* Most integer types will be sorted out above, however, for the sake\n-         of special `array index' integer types, the following code is also\n-         provided.  */\n-      if (type_index == 0)\n-\t{\n-\t  for (i = 0; i < NUM_BASE_TYPES; ++i)\n-\t    {\n-\t      bt = &base_type_table[i];\n-\t      if (bt->bt_size == TYPE_PRECISION (type)\n-\t\t  && (TREE_UNSIGNED (type) == 0) == bt->bt_is_signed)\n-\t\t{\n-\t\t  type_index = i;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n+    case CHAR_TYPE:\n+      /* GNU Pascal/Ada CHAR type.  Not used in C.  */\n+      if (TREE_UNSIGNED (type))\n+\tencoding = DW_ATE_unsigned_char;\n+      else\n+\tencoding = DW_ATE_signed_char;\n       break;\n \n     case REAL_TYPE:\n-      /* Carefully distinguish all the standard types of C, without messing\n-         up if the language is not C.  */\n-      for (i = 0; i < NUM_BASE_TYPES; ++i)\n-\t{\n-\t  bt = &base_type_table[i];\n-\t  if ((bt->bt_type == DW_ATE_float)\n-\t      && (bt->bt_size == TYPE_PRECISION (type)))\n-\t    {\n-\t      type_index = i;\n-\t      break;\n-\t    }\n-\t}\n+      encoding = DW_ATE_float;\n       break;\n \n     case COMPLEX_TYPE:\n-      for (i = 0; i < NUM_BASE_TYPES; ++i)\n-\t{\n-\t  bt = &base_type_table[i];\n-\t  if ((bt->bt_type == DW_ATE_complex_float)\n-\t      && (bt->bt_size == TYPE_PRECISION (type)))\n-\t    {\n-\t      type_index = i;\n-\t      break;\n-\t    }\n-\t}\n-      break;\n-\n-    case CHAR_TYPE:\n-      /* GNU Pascal/Ada CHAR type.  Not used in C.  */\n-      for (i = 0; i < NUM_BASE_TYPES; ++i)\n-\t{\n-\t  bt = &base_type_table[i];\n-\t  if (bt->bt_type == DW_ATE_signed_char\n-\t      || bt->bt_type == DW_ATE_unsigned_char)\n-\t    {\n-\t      if (bt->bt_size == TYPE_PRECISION (type)\n-\t\t  && ((TREE_UNSIGNED (type) == 0) == bt->bt_is_signed))\n-\t\t{\n-\t\t  type_index = i;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n+      encoding = DW_ATE_complex_float;\n       break;\n \n     case BOOLEAN_TYPE:\n-      /* GNU FORTRAN/Ada BOOLEAN type.  */\n-      for (i = 0; i < NUM_BASE_TYPES; ++i)\n-\t{\n-\t  bt = &base_type_table[i];\n-\t  if (bt->bt_type == DW_ATE_boolean\n-\t      && bt->bt_size == TYPE_PRECISION (type))\n-\t    {\n-\t      type_index = i;\n-\t      break;\n-\t    }\n-\t}\n+      /* GNU FORTRAN/Ada/C++ BOOLEAN type.  */\n+      encoding = DW_ATE_boolean;\n       break;\n \n     default:\n-      abort ();\t\t\t/* No other TREE_CODEs are Dwarf fundamental\n-\t\t\t\t   types.  */\n+      abort (); /* No other TREE_CODEs are Dwarf fundamental types.  */\n     }\n \n-  if (type_index == 0)\n-    {\n-      base_type_result = NULL;\n-    }\n-  else\n-    {\n-      base_type_result = base_type_die_table[type_index];\n-      if (base_type_result == NULL)\n-\t{\n-\t  bt = &base_type_table[type_index];\n-\t  base_type_result = new_die (DW_TAG_base_type, comp_unit_die);\n-\t  base_type_die_table[type_index] = base_type_result;\n-\t  add_AT_string (base_type_result, DW_AT_name, bt->bt_name);\n-\t  add_AT_unsigned (base_type_result, DW_AT_byte_size, bt->bt_size / 8);\n-\t  add_AT_unsigned (base_type_result, DW_AT_encoding, bt->bt_type);\n-\t}\n-\n-    }\n+  base_type_result = new_die (DW_TAG_base_type, comp_unit_die);\n+  add_AT_string (base_type_result, DW_AT_name, type_name);\n+  add_AT_unsigned (base_type_result, DW_AT_byte_size,\n+\t\t   TYPE_PRECISION (type) / BITS_PER_UNIT);\n+  add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);\n \n   return base_type_result;\n }\n@@ -4925,7 +4757,9 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n   if (code != ERROR_MARK)\n     {\n-      type = build_type_variant (type, is_const_type, is_volatile_type);\n+      /* Take the MAIN_VARIANT here to avoid C typedef types. */\n+      type = build_type_variant (TYPE_MAIN_VARIANT (type),\n+\t\t\t\t is_const_type, is_volatile_type);\n \n       mod_type_die = lookup_type_die (type);\n       if (mod_type_die)\n@@ -4934,15 +4768,12 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n       if (is_const_type)\n \t{\n \t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die);\n-\t  sub_die = modified_type_die\n-\t    (build_type_variant (type, 0, is_volatile_type),\n-\t     0, is_volatile_type, context_die);\n+\t  sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n \t}\n       else if (is_volatile_type)\n \t{\n \t  mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die);\n-\t  sub_die = modified_type_die\n-\t    (TYPE_MAIN_VARIANT (type), 0, 0, context_die);\n+\t  sub_die = modified_type_die (type, 0, 0, context_die);\n \t}\n       else if (code == POINTER_TYPE)\n \t{\n@@ -5703,7 +5534,10 @@ add_name_attribute (die, name_string)\n }\n \n /* Given a tree node describing an array bound (either lower or upper) output\n-   a representation for that bound.  */\n+   a representation for that bound.\n+\n+   FIXME: This uses location descriptions for variable bounds, whereas the\n+   DWARF-2 spec only allowes for constants or DIE references.  */\n static void\n add_bound_info (subrange_die, bound_attr, bound)\n      register dw_die_ref subrange_die;\n@@ -5811,27 +5645,20 @@ add_subscript_info (type_die, type)\n \t  lower = TYPE_MIN_VALUE (domain);\n \t  upper = TYPE_MAX_VALUE (domain);\n \n-\t  /* TODO: establish DW_AT_type for the basis type a byte_size\n-\t     attribute if the byte size is non-standard */\n-\t  add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n+\t  /* define the index type.  */\n+\t  if (TREE_TYPE (domain))\n+\t    add_type_attribute (subrange_die, TREE_TYPE (domain), 0, 0,\n+\t\t\t\ttype_die);\n+\n+\t  if (! is_c_family () && ! is_fortran ())\n+\t    add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n \t  add_bound_info (subrange_die, DW_AT_upper_bound, upper);\n \t}\n       else\n \t{\n-\t  /* We have an array type with an unspecified length. For C and C++\n-\t     we can assume that this really means that (a) the index type is\n-\t     an integral type, and (b) the lower bound is zero. Note that\n-\t     Dwarf defines the representation of an unspecified (upper) bound \n-\t     as being a zero-length location description.  */\n-\n-\t  /* define the (assumed) index type.  */\n-\t  add_AT_die_ref (subrange_die, DW_AT_type, int_base_type_die);\n-\n-\t  /* Add the (assumed) lower bound (constant) value.   */\n-\t  add_AT_unsigned (subrange_die, DW_AT_lower_bound, 0);\n-\n-\t  /* Add the (empty) location description for the upper bound.  */\n-\t  add_AT_loc (subrange_die, DW_AT_upper_bound, NULL);\n+\t  /* We have an array type with an unspecified length.  The DWARF-2\n+\t     spec does not say how to handle this; let's just leave out the\n+\t     bounds.  */\n \t}\n #ifndef MIPS_DEBUGGING_INFO\n     }\n@@ -6204,9 +6031,18 @@ gen_array_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register dw_die_ref scope_die = scope_die_for (type, context_die);\n-  register dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die);\n+  register dw_die_ref array_die;\n   register tree element_type;\n \n+  /* ??? The SGI dwarf reader fails for array of array of enum types unless\n+     the inner array type comes before the outer array type.  Thus we must\n+     call gen_type_die before we call new_die.  See below also.  */\n+#ifdef MIPS_DEBUGGING_INFO\n+  gen_type_die (TREE_TYPE (type), context_die);\n+#endif\n+\n+  array_die = new_die (DW_TAG_array_type, scope_die);\n+\n #if 0\n   /* We default the array ordering.  SDB will probably do\n      the right things even if DW_AT_ordering is not present.  It's not even\n@@ -6218,7 +6054,12 @@ gen_array_type_die (type, context_die)\n   add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);\n #endif\n \n-  add_subscript_info (array_die, type);\n+#ifdef MIPS_DEBUGGING_INFO\n+  if (! TYPE_DOMAIN (type))\n+    add_AT_unsigned (array_die, DW_AT_declaration, 1);\n+  else\n+#endif\n+    add_subscript_info (array_die, type);\n \n   equate_type_number_to_die (type, array_die);\n \n@@ -6233,8 +6074,8 @@ gen_array_type_die (type, context_die)\n     {\n       element_type = TREE_TYPE (element_type);\n     }\n-#endif\n   gen_type_die (element_type, context_die);\n+#endif\n \n   add_type_attribute (array_die, element_type, 0, 0, context_die);\n }\n@@ -6430,21 +6271,6 @@ gen_unspecified_parameters_die (decl_or_type, context_die)\n {\n   register dw_die_ref parm_die = new_die (DW_TAG_unspecified_parameters,\n \t\t\t\t\t  context_die);\n-  /* This kludge is here only for the sake of being compatible with what the\n-     USL CI5 C compiler does.  The specification of Dwarf Version 1 doesn't\n-     say that DW_TAG_unspecified_parameters DIEs should contain any\n-     attributes other than the DW_AT_sibling attribute, but they are\n-     certainly allowed to contain additional attributes, and the CI5 compiler \n-     generates DW_AT_name, DW_AT_base_type, and DW_AT_location attributes\n-     within DW_TAG_unspecified_parameters DIEs which appear in the child\n-     lists for DIEs representing function definitions, so we do likewise\n-     here.  */\n-  if (TREE_CODE (decl_or_type) == FUNCTION_DECL\n-      && DECL_INITIAL (decl_or_type))\n-    {\n-      add_name_attribute (parm_die, \"...\");\n-      add_AT_die_ref (parm_die, DW_AT_type, int_base_type_die);\n-    }\n }\n \n /* Generate a list of nameless DW_TAG_formal_parameter DIEs (and perhaps a\n@@ -7005,26 +6831,22 @@ gen_compile_unit_die (main_input_filename)\n #endif\n \n   add_AT_string (comp_unit_die, DW_AT_producer, producer);\n+\n   if (strcmp (language_string, \"GNU C++\") == 0)\n-    {\n-      add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C_plus_plus);\n-    }\n+    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C_plus_plus);\n   else if (strcmp (language_string, \"GNU Ada\") == 0)\n-    {\n-      add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_Ada83);\n-    }\n+    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_Ada83);\n+  else if (strcmp (language_string, \"GNU F77\") == 0)\n+    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_Fortran77);\n   else if (flag_traditional)\n-    {\n-      add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C);\n-    }\n+    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C);\n   else\n-    {\n-      add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C89);\n-    }\n+    add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C89);\n+\n+#if 0 /* unimplemented */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    {\n-      add_AT_unsigned (comp_unit_die, DW_AT_macro_info, 0);\n-    }\n+    add_AT_unsigned (comp_unit_die, DW_AT_macro_info, 0);\n+#endif\n }\n \n /* Generate a DIE for a string type.  */\n@@ -7717,19 +7539,9 @@ dwarf2out_file_scope_decl (decl, set_finalizing)\n \n     case TYPE_DECL:\n       /* Don't bother trying to generate any DIEs to represent any of the\n-         normal built-in types for the language we are compiling, except in\n-         cases where the types in question are *not* DWARF fundamental types. \n-         We make an exception in the case of non-fundamental types for the\n-         sake of objective C (and perhaps C++) because the GNU front-ends for \n-         these languages may in fact create certain \"built-in\" types which\n-         are (for example) RECORD_TYPEs.  In such cases, we really need to\n-         output these (non-fundamental) types because other DIEs may contain\n-         references to them.  */\n-      if (DECL_SOURCE_LINE (decl) == 0\n-\t  && is_base_type (TREE_TYPE (decl)))\n-\t{\n-\t  return;\n-\t}\n+         normal built-in types for the language we are compiling.  */\n+      if (DECL_SOURCE_LINE (decl) == 0)\n+\treturn;\n \n       /* If we are in terse mode, don't generate any DIEs to represent any\n          actual typedefs.  */\n@@ -8173,10 +7985,6 @@ dwarf2out_init (asm_out_file, main_input_filename)\n      invoked when the given (base) source file was compiled.  */\n   gen_compile_unit_die (main_input_filename);\n \n-  /* clear the association between base types and their DIE's */\n-  if (debug_info_level > DINFO_LEVEL_TERSE)\n-    init_base_type_table ();\n-\n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n }\n "}]}