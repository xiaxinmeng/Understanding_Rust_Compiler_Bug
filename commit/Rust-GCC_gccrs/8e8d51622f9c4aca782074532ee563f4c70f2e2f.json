{"sha": "8e8d51622f9c4aca782074532ee563f4c70f2e2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4ZDUxNjIyZjljNGFjYTc4MjA3NDUzMmVlNTYzZjRjNzBmMmUyZg==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@apple.com", "date": "2004-08-25T19:52:54Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2004-08-25T19:52:54Z"}, "message": "Add more details to hot/cold partitioning comments and documentation.\n\n2004-08-25  Caroline Tice  <ctice@apple.com>\n\n        * bb-reorder.c (partition_hot_cold_basic_blocks):  Add more details\n        to comments at start of function.\n        * cfgbuild.c (make_edges):  Add more details to hot/cold partitioning\n        comment.\n        * cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n        merge_blocks_move_predecessor_nojumps,\n        merge_blocks_move_successor_nojumps, merge_blocks_move,\n        try_crossjump_to_edge, try_crossjump_bb): Likewise.\n        * cfglayout.c (fixup_reorder_chain): Likewise.\n        * cfgrtl.c (rtl_can_merge_blocks, try_redirect_by_replacing_jump,\n        cfg_layout_can_merge_blocks_p):  Likewise.\n        * ifcvt.c (find_if_case_1, find_if_case_2): Likewise.\n        * passes.c (rest_of_compilation): Update comments for calling\n        optimization that partitions hot/cold basic blocks.\n        * doc/invoke.texi:  Update documentation of\n        freorder-blocks-and-partition flag.\n\nFrom-SVN: r86570", "tree": {"sha": "a5867d1e566bb25285998220b8ed1c4261740f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5867d1e566bb25285998220b8ed1c4261740f02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e8d51622f9c4aca782074532ee563f4c70f2e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8d51622f9c4aca782074532ee563f4c70f2e2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8d51622f9c4aca782074532ee563f4c70f2e2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8d51622f9c4aca782074532ee563f4c70f2e2f/comments", "author": null, "committer": null, "parents": [{"sha": "41a21e1d8b4bf5ed02dd953d8059c6c311f89edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a21e1d8b4bf5ed02dd953d8059c6c311f89edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41a21e1d8b4bf5ed02dd953d8059c6c311f89edf"}], "stats": {"total": 208, "additions": 173, "deletions": 35}, "files": [{"sha": "71935c9a9ff4202aaecac300558b91b38b451840", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -1,3 +1,22 @@\n+2004-08-25  Caroline Tice  <ctice@apple.com>\n+\n+\t* bb-reorder.c (partition_hot_cold_basic_blocks):  Add more details\n+\tto comments at start of function.\n+\t* cfgbuild.c (make_edges):  Add more details to hot/cold partitioning\n+\tcomment.\n+\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges, \n+\tmerge_blocks_move_predecessor_nojumps, \n+\tmerge_blocks_move_successor_nojumps, merge_blocks_move, \n+\ttry_crossjump_to_edge, try_crossjump_bb): Likewise.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t* cfgrtl.c (rtl_can_merge_blocks, try_redirect_by_replacing_jump,\n+\tcfg_layout_can_merge_blocks_p):  Likewise.\n+\t* ifcvt.c (find_if_case_1, find_if_case_2): Likewise.\n+\t* passes.c (rest_of_compilation): Update comments for calling \n+\toptimization that partitions hot/cold basic blocks.\n+\t* doc/invoke.texi:  Update documentation of \n+\tfreorder-blocks-and-partition flag.\n+\t\n 2004-08-25  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (reg): Renamed mode attribute from ccreg."}, {"sha": "cf39ce0c9889a59902359c5395d3222879fb2a5c", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -2009,20 +2009,57 @@ reorder_basic_blocks (unsigned int flags)\n    been called.  However part of this optimization may introduce new\n    register usage, so it must be called before register allocation has\n    occurred.  This means that this optimization is actually called\n-   well before the optimization that reorders basic blocks (see function\n-   above).\n+   well before the optimization that reorders basic blocks (see\n+   function above).\n \n    This optimization checks the feedback information to determine\n-   which basic blocks are hot/cold and adds\n-   NOTE_INSN_UNLIKELY_EXECUTED_CODE to non-hot basic blocks.  The\n+   which basic blocks are hot/cold and causes reorder_basic_blocks to\n+   add NOTE_INSN_UNLIKELY_EXECUTED_CODE to non-hot basic blocks.  The\n    presence or absence of this note is later used for writing out\n-   sections in the .o file.  This optimization must also modify the\n-   CFG to make sure there are no fallthru edges between hot & cold\n-   blocks, as those blocks will not necessarily be contiguous in the\n-   .o (or assembly) file; and in those cases where the architecture\n-   requires it, conditional and unconditional branches that cross\n-   between sections are converted into unconditional or indirect\n-   jumps, depending on what is appropriate.  */\n+   sections in the .o file.  Because hot and cold sections can be\n+   arbitrarily large (within the bounds of memory), far beyond the\n+   size of a single function, it is necessary to fix up all edges that\n+   cross section boundaries, to make sure the instructions used can\n+   actually span the required distance.  The fixes are described\n+   below.\n+\n+   Fall-through edges must be changed into jumps; it is not safe or\n+   legal to fall through across a section boundary.  Whenever a\n+   fall-through edge crossing a section boundary is encountered, a new\n+   basic block is inserted (in the same section as the fall-through\n+   source), and the fall through edge is redirected to the new basic\n+   block.  The new basic block contains an unconditional jump to the\n+   original fall-through target.  (If the unconditional jump is\n+   insufficient to cross section boundaries, that is dealt with a\n+   little later, see below).\n+\n+   In order to deal with architectures that have short conditional\n+   branches (which cannot span all of memory) we take any conditional\n+   jump that attempts to cross a section boundary and add a level of\n+   indirection: it becomes a conditional jump to a new basic block, in\n+   the same section.  The new basic block contains an unconditional\n+   jump to the original target, in the other section.\n+\n+   For those architectures whose unconditional branch is also\n+   incapable of reaching all of memory, those unconditional jumps are\n+   converted into indirect jumps, through a register.\n+\n+   IMPORTANT NOTE: This optimization causes some messy interactions\n+   with the cfg cleanup optimizations; those optimizations want to\n+   merge blocks wherever possible, and to collapse indirect jump\n+   sequences (change \"A jumps to B jumps to C\" directly into \"A jumps\n+   to C\").  Those optimizations can undo the jump fixes that\n+   partitioning is required to make (see above), in order to ensure\n+   that jumps attempting to cross section boundaries are really able\n+   to cover whatever distance the jump requires (on many architectures\n+   conditional or unconditional jumps are not able to reach all of\n+   memory).  Therefore tests have to be inserted into each such\n+   optimization to make sure that it does not undo stuff necessary to\n+   cross partition boundaries.  This would be much less of a problem\n+   if we could perform this optimization later in the compilation, but\n+   unfortunately the fact that we may need to create indirect jumps\n+   (through registers) requires that this optimization be performed\n+   before register allocation.  */\n \n void\n partition_hot_cold_basic_blocks (void)"}, {"sha": "6c4a67ac57263cfcb9b4367ac49c323a45ef829e", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -232,7 +232,10 @@ make_edges (basic_block min, basic_block max, int update_p)\n   current_function_has_computed_jump = 0;\n \n   /* If we are partitioning hot and cold basic blocks into separate\n-     sections, we cannot assume there is no computed jump.  */\n+     sections, we cannot assume there is no computed jump (partitioning\n+     sometimes requires the use of indirect jumps; see comments about\n+     partitioning at the top of bb-reorder.c:partition_hot_cold_basic_blocks \n+     for complete details).  */\n \n   if (flag_reorder_blocks_and_partition)\n     current_function_has_computed_jump = 1;"}, {"sha": "91412cf84d5810d5734768f88d88e62324fc614f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -150,7 +150,13 @@ try_simplify_condjump (basic_block cbranch_block)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections. \n+\n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (flag_reorder_blocks_and_partition\n       && (BB_PARTITION (jump_block) != BB_PARTITION (jump_dest_block)\n@@ -419,8 +425,14 @@ try_forward_edges (int mode, basic_block b)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections. \n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really m\n+     ust be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n     return false;\n@@ -447,7 +459,14 @@ try_forward_edges (int mode, basic_block b)\n       counter = 0;\n \n       /* If we are partitioning hot/cold basic_blocks, we don't want to mess\n-\t up jumps that cross between hot/cold sections.  */\n+\t up jumps that cross between hot/cold sections.\n+\n+\t Basic block partitioning may result in some jumps that appear\n+\t to be optimizable (or blocks that appear to be mergeable), but which \n+\t really must be left untouched (they are required to make it safely \n+\t across partition boundaries).  See the comments at the top of\n+\t bb-reorder.c:partition_hot_cold_basic_blocks for complete\n+\t details.  */\n \n       if (flag_reorder_blocks_and_partition\n \t  && first != EXIT_BLOCK_PTR\n@@ -670,8 +689,14 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections.\n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && (BB_PARTITION (a) != BB_PARTITION (b)\n \t  || find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)))\n@@ -722,8 +747,14 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections. \n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n \t  || BB_PARTITION (a) != BB_PARTITION (b)))\n@@ -787,8 +818,14 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections. \n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n \t  || find_reg_note (BB_END (c), REG_CROSSING_JUMP, NULL_RTX)\n@@ -1471,7 +1508,13 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   newpos1 = newpos2 = NULL_RTX;\n \n   /* If we have partitioned hot/cold basic blocks, it is a bad idea\n-     to try this optimization.  */\n+     to try this optimization. \n+\n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (flag_reorder_blocks_and_partition && no_new_pseudos)\n     return false;\n@@ -1670,8 +1713,14 @@ try_crossjump_bb (int mode, basic_block bb)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections. \n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && (BB_PARTITION (bb->pred->src) != BB_PARTITION (bb->pred->pred_next->src)\n \t  || (bb->pred->flags & EDGE_CROSSING)))"}, {"sha": "994ab45c491d44d5694f24e439f73d99d031b654", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -794,7 +794,8 @@ fixup_reorder_chain (void)\n \t  bb = nb;\n \t  \n \t  /* Make sure new bb is tagged for correct section (same as\n-\t     fall-thru source).  */\n+\t     fall-thru source, since you cannot fall-throu across\n+\t     section boundaries).  */\n \t  BB_COPY_PARTITION (e_fall->src, bb->pred->src);\n \t  if (flag_reorder_blocks_and_partition\n \t      && targetm.have_named_sections)"}, {"sha": "6dba6c1dfa86e079265cd0e2044beef3c298a433", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -613,10 +613,11 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n      mess up unconditional or indirect jumps that cross between hot\n      and cold sections.\n \n-     ??? If two basic blocks could otherwise be merged (which implies\n-     that the jump between the two is unconditional), and one is in a\n-     hot section and the other is in a cold section, surely that means\n-     that one of the section choices is wrong.  */\n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See  the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n@@ -672,7 +673,13 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections.\n+\n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See  the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n   \n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n@@ -2663,11 +2670,12 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n      mess up unconditional or indirect jumps that cross between hot\n      and cold sections.\n \n-     ??? If two basic blocks could otherwise be merged (which implies\n-     that the jump between the two is unconditional), and one is in a\n-     hot section and the other is in a cold section, surely that means\n-     that one of the section choices is wrong.  */\n-  \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See  the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n \t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)"}, {"sha": "25acc613c8e8f3c6bd2a31229b6e4d85dc524e2c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -4617,6 +4617,11 @@ to reduce number of taken branches, partitions hot and cold basic blocks\n into separate sections of the assembly and .o files, to improve\n paging and cache locality performance.\n \n+This optimization is automatically turned off in the presence of\n+exception handling, for linkonce sections, for functions with a user-defined\n+section attribute and on any architecture that does not support named\n+sections.\n+\n @item -freorder-functions\n @opindex freorder-functions\n Reorder basic blocks in the compiled function in order to reduce number of"}, {"sha": "7473054757f2ee1d9e40509c3e4054b087bcd0d3", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -2850,8 +2850,14 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections.\n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See  the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && ((BB_END (then_bb) \n \t   && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n@@ -2909,6 +2915,9 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     {\n       new_bb->index = then_bb_index;\n       BASIC_BLOCK (then_bb_index) = new_bb;\n+      /* Since the fallthru edge was redirected from test_bb to new_bb,\n+         we need to ensure that new_bb is in the same partition as\n+         test bb (you can not fall through across section boundaries).  */\n       BB_COPY_PARTITION (new_bb, test_bb);\n     }\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n@@ -2933,8 +2942,14 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.  */\n+     and cold sections.\n   \n+     Basic block partitioning may result in some jumps that appear to\n+     be optimizable (or blocks that appear to be mergeable), but which really \n+     must be left untouched (they are required to make it safely across \n+     partition boundaries).  See  the comments at the top of \n+     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n+\n   if (flag_reorder_blocks_and_partition\n       && ((BB_END (then_bb)\n \t   && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))"}, {"sha": "06c2d8990f7a8d16f29a95088729231739f3fa7e", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8d51622f9c4aca782074532ee563f4c70f2e2f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8e8d51622f9c4aca782074532ee563f4c70f2e2f", "patch": "@@ -1856,8 +1856,9 @@ rest_of_compilation (void)\n     rest_of_handle_if_after_combine ();\n \n   /* The optimization to partition hot/cold basic blocks into separate\n-     sections of the .o file does not work well with exception handling.\n-     Don't call it if there are exceptions.  */\n+     sections of the .o file does not work well with linkonce or with\n+     user defined section attributes.  Don't call it if either case\n+     arises.  */\n \n   if (flag_reorder_blocks_and_partition \n       && !DECL_ONE_ONLY (current_function_decl)"}]}