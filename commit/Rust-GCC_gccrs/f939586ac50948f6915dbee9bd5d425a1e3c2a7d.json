{"sha": "f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkzOTU4NmFjNTA5NDhmNjkxNWRiZWU5YmQ1ZDQyNWExZTNjMmE3ZA==", "commit": {"author": {"name": "Venkataramanan Kumar", "email": "venkataramanan.kumar@amd.com", "date": "2015-11-17T07:41:08Z"}, "committer": {"name": "Venkataramanan Kumar", "email": "vekumar@gcc.gnu.org", "date": "2015-11-17T07:41:08Z"}, "message": "Relax trap assumptions in tree if convert.\n\n2015-11-17  Venkataramanan Kumar  <Venkataramanan.Kumar@amd.com>\n\n\t* tree-if-conv.c: Include varasm.h\n\t(ref_DR_map): Define.\n\t(baseref_DR_map): Like wise\n\t(struct ifc_dr): Add new tree predicate field.\n\t(hash_memrefs_baserefs_and_store_DRs_read_written_info): New function.\n\t(memrefs_read_or_written_unconditionally): Remove.\n\t(write_memrefs_written_at_least_once): Remove.\n\t(ifcvt_memrefs_wont_trap): Use hash maps to query\n\tunconditional read/written information.\n\t(if_convertible_loop_p_1):  Initialize hash maps and predicates\n\tbefore hashing data references and delete hashmaps at the end.\n\n2015-11-17  Venkataramanan Kumar  <Venkataramanan.Kumar@amd.com>\n\n\t* gcc.dg/tree-ssa/ifc-8.c: New test.\n\nFrom-SVN: r230454", "tree": {"sha": "c67bb88bca0b89d9a24fa9c58c33c023db83603a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c67bb88bca0b89d9a24fa9c58c33c023db83603a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/comments", "author": null, "committer": null, "parents": [{"sha": "b925d25d7eeccf5a259f5c744b2de8d8285e0bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b925d25d7eeccf5a259f5c744b2de8d8285e0bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b925d25d7eeccf5a259f5c744b2de8d8285e0bc3"}], "stats": {"total": 276, "additions": 151, "deletions": 125}, "files": [{"sha": "6316ab6d122699379813284a657a23b77015b795", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "patch": "@@ -1,3 +1,17 @@\n+2015-11-17  Venkataramanan Kumar  <Venkataramanan.Kumar@amd.com>\n+\n+\t* tree-if-conv.c: Include varasm.h\n+\t(ref_DR_map): Define.\n+\t(baseref_DR_map): Like wise\n+\t(struct ifc_dr): Add new tree predicate field.\n+\t(hash_memrefs_baserefs_and_store_DRs_read_written_info): New function.\n+\t(memrefs_read_or_written_unconditionally): Remove.\n+\t(write_memrefs_written_at_least_once): Remove.\n+\t(ifcvt_memrefs_wont_trap): Use hash maps to query\n+\tunconditional read/written information.\n+\t(if_convertible_loop_p_1):  Initialize hash maps and predicates\n+\tbefore hashing data references and delete hashmaps at the end.\n+\n 2015-11-16  Thomas Preud'homme <thomas.preudhomme@arm.com>\n \n \tPR 56036"}, {"sha": "52112ea8dcd571f696b9f9894b9569e97287f9bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "patch": "@@ -1,3 +1,7 @@\n+2015-11-17  Venkataramanan Kumar  <Venkataramanan.Kumar@amd.com>\n+\n+\t* gcc.dg/tree-ssa/ifc-8.c: New test.\n+\n 2015-11-16  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/68362"}, {"sha": "89a34104a69dbd30a4bf5b4b97672e11b0a27ad6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-8.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-8.c?ref=f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "patch": "@@ -0,0 +1,17 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-ifcvt-details -fno-common -ftree-loop-if-convert-stores\" } */\n+\n+#define LEN 4096\n+ __attribute__((aligned (32))) float array[LEN];\n+\n+void test ()\n+{\n+  for (int i = 0; i < LEN; i++)\n+    {\n+      if (array[i] > (float)0.)\n+\tarray[i] = 3;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "01065cbf16e817afa95d39427163ffa2600487c4", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 116, "deletions": 125, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f939586ac50948f6915dbee9bd5d425a1e3c2a7d/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=f939586ac50948f6915dbee9bd5d425a1e3c2a7d", "patch": "@@ -110,13 +110,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-address.h\"\n #include \"dbgcnt.h\"\n #include \"tree-hash-traits.h\"\n+#include \"varasm.h\"\n \n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n /* Apply more aggressive (extended) if-conversion if true.  */\n static bool aggressive_if_conv;\n \n+/* Hash table to store references, DR pairs.  */\n+static hash_map<tree_operand_hash, data_reference_p> *ref_DR_map;\n+\n+/* Hash table to store base reference, DR pairs.  */\n+static hash_map<tree_operand_hash, data_reference_p> *baseref_DR_map;\n+\n /* Structure used to predicate basic blocks.  This is attached to the\n    ->aux field of the BBs in the loop to be if-converted.  */\n struct bb_predicate {\n@@ -580,139 +587,71 @@ struct ifc_dr {\n \n   /* -1 when not initialized, 0 when false, 1 when true.  */\n   int rw_unconditionally;\n+\n+  tree predicate;\n };\n \n #define IFC_DR(DR) ((struct ifc_dr *) (DR)->aux)\n #define DR_WRITTEN_AT_LEAST_ONCE(DR) (IFC_DR (DR)->written_at_least_once)\n #define DR_RW_UNCONDITIONALLY(DR) (IFC_DR (DR)->rw_unconditionally)\n \n-/* Returns true when the memory references of STMT are read or written\n-   unconditionally.  In other words, this function returns true when\n-   for every data reference A in STMT there exist other accesses to\n-   a data reference with the same base with predicates that add up (OR-up) to\n-   the true predicate: this ensures that the data reference A is touched\n-   (read or written) on every iteration of the if-converted loop.  */\n-\n-static bool\n-memrefs_read_or_written_unconditionally (gimple *stmt,\n-\t\t\t\t\t vec<data_reference_p> drs)\n-{\n-  int i, j;\n-  data_reference_p a, b;\n-  tree ca = bb_predicate (gimple_bb (stmt));\n-\n-  for (i = 0; drs.iterate (i, &a); i++)\n-    if (DR_STMT (a) == stmt)\n-      {\n-\tbool found = false;\n-\tint x = DR_RW_UNCONDITIONALLY (a);\n-\n-\tif (x == 0)\n-\t  return false;\n-\n-\tif (x == 1)\n-\t  continue;\n-\n-\tfor (j = 0; drs.iterate (j, &b); j++)\n-          {\n-            tree ref_base_a = DR_REF (a);\n-            tree ref_base_b = DR_REF (b);\n-\n-            if (DR_STMT (b) == stmt)\n-              continue;\n-\n-            while (TREE_CODE (ref_base_a) == COMPONENT_REF\n-                   || TREE_CODE (ref_base_a) == IMAGPART_EXPR\n-                   || TREE_CODE (ref_base_a) == REALPART_EXPR)\n-              ref_base_a = TREE_OPERAND (ref_base_a, 0);\n-\n-            while (TREE_CODE (ref_base_b) == COMPONENT_REF\n-                   || TREE_CODE (ref_base_b) == IMAGPART_EXPR\n-                   || TREE_CODE (ref_base_b) == REALPART_EXPR)\n-              ref_base_b = TREE_OPERAND (ref_base_b, 0);\n-\n-  \t    if (operand_equal_p (ref_base_a, ref_base_b, 0))\n-\t      {\n-\t        tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n-\n-\t        if (DR_RW_UNCONDITIONALLY (b) == 1\n-\t\t    || is_true_predicate (cb)\n-\t\t    || is_true_predicate (ca\n-                        = fold_or_predicates (EXPR_LOCATION (cb), ca, cb)))\n-\t\t  {\n-\t\t    DR_RW_UNCONDITIONALLY (a) = 1;\n-  \t\t    DR_RW_UNCONDITIONALLY (b) = 1;\n-\t\t    found = true;\n-\t\t    break;\n-\t\t  }\n-               }\n-\t    }\n-\n-\tif (!found)\n-\t  {\n-\t    DR_RW_UNCONDITIONALLY (a) = 0;\n-\t    return false;\n-\t  }\n-      }\n-\n-  return true;\n-}\n-\n-/* Returns true when the memory references of STMT are unconditionally\n-   written.  In other words, this function returns true when for every\n-   data reference A written in STMT, there exist other writes to the\n-   same data reference with predicates that add up (OR-up) to the true\n-   predicate: this ensures that the data reference A is written on\n-   every iteration of the if-converted loop.  */\n-\n-static bool\n-write_memrefs_written_at_least_once (gimple *stmt,\n-\t\t\t\t     vec<data_reference_p> drs)\n+/* Iterates over DR's and stores refs, DR and base refs, DR pairs in\n+   HASH tables.  While storing them in HASH table, it checks if the\n+   reference is unconditionally read or written and stores that as a flag\n+   information.  For base reference it checks if it is written atlest once\n+   unconditionally and stores it as flag information along with DR.\n+   In other words for every data reference A in STMT there exist other\n+   accesses to a data reference with the same base with predicates that\n+   add up (OR-up) to the true predicate: this ensures that the data\n+   reference A is touched (read or written) on every iteration of the\n+   if-converted loop.  */\n+static void\n+hash_memrefs_baserefs_and_store_DRs_read_written_info (data_reference_p a)\n {\n-  int i, j;\n-  data_reference_p a, b;\n-  tree ca = bb_predicate (gimple_bb (stmt));\n \n-  for (i = 0; drs.iterate (i, &a); i++)\n-    if (DR_STMT (a) == stmt\n-\t&& DR_IS_WRITE (a))\n-      {\n-\tbool found = false;\n-\tint x = DR_WRITTEN_AT_LEAST_ONCE (a);\n+  data_reference_p *master_dr, *base_master_dr;\n+  tree ref = DR_REF (a);\n+  tree base_ref = DR_BASE_OBJECT (a);\n+  tree ca = bb_predicate (gimple_bb (DR_STMT (a)));\n+  bool exist1, exist2;\n \n-\tif (x == 0)\n-\t  return false;\n+  while (TREE_CODE (ref) == COMPONENT_REF\n+\t || TREE_CODE (ref) == IMAGPART_EXPR\n+\t || TREE_CODE (ref) == REALPART_EXPR)\n+    ref = TREE_OPERAND (ref, 0);\n \n-\tif (x == 1)\n-\t  continue;\n+  master_dr = &ref_DR_map->get_or_insert (ref, &exist1);\n \n-\tfor (j = 0; drs.iterate (j, &b); j++)\n-\t  if (DR_STMT (b) != stmt\n-\t      && DR_IS_WRITE (b)\n-\t      && same_data_refs_base_objects (a, b))\n-\t    {\n-\t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n+  if (!exist1)\n+    {\n+      IFC_DR (a)->predicate = ca;\n+      *master_dr = a;\n+    }\n+  else\n+    IFC_DR (*master_dr)->predicate\n+\t= fold_or_predicates\n+\t\t(EXPR_LOCATION (IFC_DR (*master_dr)->predicate),\n+\t\t ca, IFC_DR (*master_dr)->predicate);\n \n-\t      if (DR_WRITTEN_AT_LEAST_ONCE (b) == 1\n-\t\t  || is_true_predicate (cb)\n-\t\t  || is_true_predicate (ca = fold_or_predicates (EXPR_LOCATION (cb),\n-\t\t\t\t\t\t\t\t ca, cb)))\n-\t\t{\n-\t\t  DR_WRITTEN_AT_LEAST_ONCE (a) = 1;\n-\t\t  DR_WRITTEN_AT_LEAST_ONCE (b) = 1;\n-\t\t  found = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n+  if (is_true_predicate (IFC_DR (*master_dr)->predicate))\n+    DR_RW_UNCONDITIONALLY (*master_dr) = 1;\n \n-\tif (!found)\n-\t  {\n-\t    DR_WRITTEN_AT_LEAST_ONCE (a) = 0;\n-\t    return false;\n-\t  }\n-      }\n+  base_master_dr = &baseref_DR_map->get_or_insert (base_ref,&exist2);\n \n-  return true;\n+  if (!exist2)\n+    {\n+      IFC_DR (a)->predicate = ca;\n+      *base_master_dr = a;\n+    }\n+  else\n+    IFC_DR (*base_master_dr)->predicate\n+\t= fold_or_predicates\n+\t\t(EXPR_LOCATION (IFC_DR (*base_master_dr)->predicate),\n+\t\t ca, IFC_DR (*base_master_dr)->predicate);\n+\n+  if (DR_IS_WRITE (a)\n+      && (is_true_predicate (IFC_DR (*base_master_dr)->predicate)))\n+    DR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) = 1;\n }\n \n /* Return true when the memory references of STMT won't trap in the\n@@ -731,13 +670,50 @@ write_memrefs_written_at_least_once (gimple *stmt,\n    iteration.  To check that the memory accesses are correctly formed\n    and that we are allowed to read and write in these locations, we\n    check that the memory accesses to be if-converted occur at every\n-   iteration unconditionally.  */\n-\n+   iteration unconditionally.\n+\n+   Returns true for the memory reference in STMT, same memory reference\n+   is read or written unconditionally atleast once and the base memory\n+   reference is written unconditionally once.  This is to check reference\n+   will not write fault.  Also retuns true if the memory reference is\n+   unconditionally read once then we are conditionally writing to memory\n+   which is defined as read and write and is bound to the definition\n+   we are seeing.  */\n static bool\n-ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> refs)\n+ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n {\n-  return write_memrefs_written_at_least_once (stmt, refs)\n-    && memrefs_read_or_written_unconditionally (stmt, refs);\n+  data_reference_p *master_dr, *base_master_dr;\n+  data_reference_p a = drs[gimple_uid (stmt) - 1];\n+\n+  tree ref_base_a = DR_REF (a);\n+  tree base = DR_BASE_OBJECT (a);\n+\n+  gcc_assert (DR_STMT (a) == stmt);\n+\n+  while (TREE_CODE (ref_base_a) == COMPONENT_REF\n+\t || TREE_CODE (ref_base_a) == IMAGPART_EXPR\n+\t || TREE_CODE (ref_base_a) == REALPART_EXPR)\n+    ref_base_a = TREE_OPERAND (ref_base_a, 0);\n+\n+  master_dr = ref_DR_map->get (ref_base_a);\n+  base_master_dr = baseref_DR_map->get (base);\n+\n+  gcc_assert (master_dr != NULL && base_master_dr != NULL);\n+\n+  if (DR_RW_UNCONDITIONALLY (*master_dr) == 1)\n+    {\n+      if (DR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) == 1)\n+\treturn true;\n+      else\n+\t{\n+\t  tree base_tree = get_base_address (DR_REF (a));\n+\t  if (DECL_P (base_tree)\n+\t      && decl_binds_to_current_def_p (base_tree)\n+\t      && !TREE_READONLY (base_tree))\n+\t  return true;\n+\t}\n+    }\n+  return false;\n }\n \n /* Wrapper around gimple_could_trap_p refined for the needs of the\n@@ -1280,6 +1256,7 @@ if_convertible_loop_p_1 (struct loop *loop,\n \t  case GIMPLE_CALL:\n \t  case GIMPLE_DEBUG:\n \t  case GIMPLE_COND:\n+\t    gimple_set_uid (gsi_stmt (gsi), 0);\n \t    break;\n \t  default:\n \t    return false;\n@@ -1288,13 +1265,20 @@ if_convertible_loop_p_1 (struct loop *loop,\n \n   data_reference_p dr;\n \n+  ref_DR_map = new hash_map<tree_operand_hash, data_reference_p>;\n+  baseref_DR_map = new hash_map<tree_operand_hash, data_reference_p>;\n+\n+  predicate_bbs (loop);\n+\n   for (i = 0; refs->iterate (i, &dr); i++)\n     {\n       dr->aux = XNEW (struct ifc_dr);\n       DR_WRITTEN_AT_LEAST_ONCE (dr) = -1;\n       DR_RW_UNCONDITIONALLY (dr) = -1;\n+      if (gimple_uid (DR_STMT (dr)) == 0)\n+\tgimple_set_uid (DR_STMT (dr), i + 1);\n+      hash_memrefs_baserefs_and_store_DRs_read_written_info (dr);\n     }\n-  predicate_bbs (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -1391,6 +1375,13 @@ if_convertible_loop_p (struct loop *loop, bool *any_mask_load_store)\n \n   free_data_refs (refs);\n   free_dependence_relations (ddrs);\n+\n+  delete ref_DR_map;\n+  ref_DR_map = NULL;\n+\n+  delete baseref_DR_map;\n+  baseref_DR_map = NULL;\n+\n   return res;\n }\n "}]}