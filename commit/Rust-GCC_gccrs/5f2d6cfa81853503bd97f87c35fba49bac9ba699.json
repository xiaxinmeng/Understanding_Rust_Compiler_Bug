{"sha": "5f2d6cfa81853503bd97f87c35fba49bac9ba699", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyZDZjZmE4MTg1MzUwM2JkOTdmODdjMzVmYmE0OWJhYzliYTY5OQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@redhat.com", "date": "2001-06-20T07:18:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2001-06-20T07:18:18Z"}, "message": "Fix __builtin_expect on PowerPCs\n\nFrom-SVN: r43470", "tree": {"sha": "4bd38fb5a549034c774eecc97c073ba05857bbda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bd38fb5a549034c774eecc97c073ba05857bbda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f2d6cfa81853503bd97f87c35fba49bac9ba699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2d6cfa81853503bd97f87c35fba49bac9ba699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2d6cfa81853503bd97f87c35fba49bac9ba699", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2d6cfa81853503bd97f87c35fba49bac9ba699/comments", "author": null, "committer": null, "parents": [{"sha": "f34c9fd4a6c2b2395665848eaf60ac9999c41793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f34c9fd4a6c2b2395665848eaf60ac9999c41793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f34c9fd4a6c2b2395665848eaf60ac9999c41793"}], "stats": {"total": 167, "additions": 164, "deletions": 3}, "files": [{"sha": "658e7640debbc8a36ab4c6b08b2641d9955696e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f2d6cfa81853503bd97f87c35fba49bac9ba699", "patch": "@@ -1,3 +1,17 @@\n+2001-06-20  Michael Meissner  <meissner@redhat.com>\n+\n+\t* builtins.c (predict.h): Include.\n+\t(expand_builtin_expect): Update comment.\n+\t(expand_builtin_expect_jump): New function to expand\n+\t__builtin_expect inside of a conditional jump expansion.\n+\n+\t* expr.c (do_jump): Special case __builtin_expect (<test>, 0) and\n+\t__builtin_expect (<test>, 1).\n+\n+\t* Makefile.in (builtins.o): Depend on $(PREDICT_H).\n+\n+\t* rtl.h (expand_builtin_expect_jump): Add prototype.\n+\n 2001-06-19  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* doc/rtl.texi (Machine Modes): Correct description of"}, {"sha": "563e7b718d67b3d954ea425a69f25fe03634c957", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5f2d6cfa81853503bd97f87c35fba49bac9ba699", "patch": "@@ -1371,7 +1371,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h \\\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(REGS_H) $(EXPR_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n-   except.h $(TM_P_H)\n+   except.h $(TM_P_H) $(PREDICT_H)\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h $(EXPR_H) \\\n    $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H)\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h  \\"}, {"sha": "3e4ef1553eefd67f8d6c0b6e827a91178adbddfd", "filename": "gcc/builtins.c", "status": "modified", "additions": 113, "deletions": 2, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5f2d6cfa81853503bd97f87c35fba49bac9ba699", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"typeclass.h\"\n #include \"toplev.h\"\n+#include \"predict.h\"\n #include \"tm_p.h\"\n \n #define CALLED_AS_BUILT_IN(NODE) \\\n@@ -3232,8 +3233,9 @@ expand_builtin_fputs (arglist, ignore)\n \t\t      VOIDmode, EXPAND_NORMAL);\n }\n \n-/* Expand a call to __builtin_expect.  We return our argument and\n-   emit a NOTE_INSN_EXPECTED_VALUE note.  */\n+/* Expand a call to __builtin_expect.  We return our argument and emit a\n+   NOTE_INSN_EXPECTED_VALUE note.  This is the expansion of __builtin_expect in\n+   a non-jump context.  */\n \n static rtx\n expand_builtin_expect (arglist, target)\n@@ -3273,6 +3275,115 @@ expand_builtin_expect (arglist, target)\n \n   return target;\n }\n+\n+/* Like expand_builtin_expect, except do this in a jump context.  This is\n+   called from do_jump if the conditional is a __builtin_expect.  Return either\n+   a SEQUENCE of insns to emit the jump or NULL if we cannot optimize\n+   __builtin_expect.  We need to optimize this at jump time so that machines\n+   like the PowerPC don't turn the test into a SCC operation, and then jump\n+   based on the test being 0/1.  */\n+\n+rtx\n+expand_builtin_expect_jump (exp, if_false_label, if_true_label)\n+     tree exp;\n+     rtx if_false_label;\n+     rtx if_true_label;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx ret = NULL_RTX;\n+\n+  /* Only handle __builtin_expect (test, 0) and\n+     __builtin_expect (test, 1).  */\n+  if (TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n+      && TREE_CODE (arg1) == INTEGER_CST\n+      && (TREE_INT_CST_LOW (arg1) == 0 || TREE_INT_CST_LOW (arg1) == 1)\n+      && TREE_INT_CST_HIGH (arg1) == 0)\n+    {\n+      int j;\n+      int num_jumps = 0;\n+\n+      /* Expand the jump insns.  */\n+      start_sequence ();\n+      do_jump (arg0, if_false_label, if_true_label);\n+      ret = gen_sequence ();\n+      end_sequence ();\n+\n+      /* Now that the __builtin_expect has been validated, go through and add\n+\t the expect's to each of the conditional jumps.  If we run into an\n+\t error, just give up and generate the 'safe' code of doing a SCC\n+\t operation and then doing a branch on that.  */\n+      for (j = 0; j < XVECLEN (ret, 0); j++)\n+\t{\n+\t  rtx insn = XVECEXP (ret, 0, j);\n+\t  rtx pattern;\n+\n+\t  if (GET_CODE (insn) == JUMP_INSN && any_condjump_p (insn)\n+\t      && (pattern = pc_set (insn)) != NULL_RTX)\n+\t    {\n+\t      rtx ifelse = SET_SRC (pattern);\n+\t      rtx label;\n+\t      int taken;\n+\n+\t      if (GET_CODE (ifelse) != IF_THEN_ELSE)\n+\t\tcontinue;\n+\n+\t      if (GET_CODE (XEXP (ifelse, 1)) == LABEL_REF)\n+\t\t{\n+\t\t  taken = 1;\n+\t\t  label = XEXP (XEXP (ifelse, 1), 0);\n+\t\t}\n+\t      /* An inverted jump reverses the probabilities.  */\n+\t      else if (GET_CODE (XEXP (ifelse, 2)) == LABEL_REF)\n+\t\t{\n+\t\t  taken = 0;\n+\t\t  label = XEXP (XEXP (ifelse, 2), 0);\n+\t\t}\n+\t      /* We shouldn't have to worry about conditional returns during\n+\t\t the expansion stage, but handle it gracefully anyway.  */\n+\t      else if (GET_CODE (XEXP (ifelse, 1)) == RETURN)\n+\t\t{\n+\t\t  taken = 1;\n+\t\t  label = NULL_RTX;\n+\t\t}\n+\t      /* An inverted return reverses the probabilities.  */\n+\t      else if (GET_CODE (XEXP (ifelse, 2)) == RETURN)\n+\t\t{\n+\t\t  taken = 0;\n+\t\t  label = NULL_RTX;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\n+\t      /* If the test is expected to fail, reverse the\n+\t\t probabilities.  */\n+\t      if (TREE_INT_CST_LOW (arg1) == 0)\n+\t\ttaken = 1 - taken;\n+\n+\t      /* If we are jumping to the false label, reverse the\n+\t\t probabilities.  */\n+\t      if (label == NULL_RTX)\n+\t\t;\t\t/* conditional return */\n+\t      else if (label == if_false_label)\n+\t\ttaken = 1 - taken;\n+\t      else if (label != if_true_label)\n+\t\tcontinue;\n+\n+\t      num_jumps++;\n+\t      predict_insn_def (insn, PRED_BUILTIN_EXPECT, taken);\n+\t    }\n+\t}\n+\n+      /* If no jumps were modified, fail and do __builtin_expect the normal\n+\t way.  */\n+      if (num_jumps == 0)\n+\tret = NULL_RTX;\n+    }\n+\n+  return ret;\n+}\n+\n \f\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient"}, {"sha": "4031cab1635c911b5a1c574b89b1a921156100b5", "filename": "gcc/expr.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5f2d6cfa81853503bd97f87c35fba49bac9ba699", "patch": "@@ -9913,6 +9913,39 @@ do_jump (exp, if_false_label, if_true_label)\n       }\n       break;\n \n+      /* Special case:\n+\t\t__builtin_expect (<test>, 0)\tand\n+\t\t__builtin_expect (<test>, 1)\n+\n+\t We need to do this here, so that <test> is not converted to a SCC\n+\t operation on machines that use condition code registers and COMPARE\n+\t like the PowerPC, and then the jump is done based on whether the SCC\n+\t operation produced a 1 or 0.  */\n+    case CALL_EXPR:\n+      /* Check for a built-in function.  */\n+      if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR)\n+\t{\n+\t  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\t  tree arglist = TREE_OPERAND (exp, 1);\n+\n+\t  if (TREE_CODE (fndecl) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN (fndecl)\n+\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n+\t      && arglist != NULL_TREE\n+\t      && TREE_CHAIN (arglist) != NULL_TREE)\n+\t    {\n+\t      rtx seq = expand_builtin_expect_jump (exp, if_false_label,\n+\t\t\t\t\t\t    if_true_label);\n+\n+\t      if (seq != NULL_RTX)\n+\t\t{\n+\t\t  emit_insn (seq);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+      /* fall through and generate the normal code.  */\n+\n     default:\n     normal:\n       temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);"}, {"sha": "ca35d3f33bc9ef5aa7b43b4e0cb2b428c1402cbc", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2d6cfa81853503bd97f87c35fba49bac9ba699/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5f2d6cfa81853503bd97f87c35fba49bac9ba699", "patch": "@@ -1146,6 +1146,9 @@ extern int ceil_log2\t\t\tPARAMS ((unsigned HOST_WIDE_INT));\n #define plus_constant_for_output(X,C)  \\\n   plus_constant_for_output_wide (X, (HOST_WIDE_INT) (C))\n \n+/* In builtins.c */\n+extern rtx expand_builtin_expect_jump\tPARAMS ((union tree_node *, rtx, rtx));\n+\n /* In explow.c */\n extern void set_stack_check_libfunc PARAMS ((rtx));\n extern HOST_WIDE_INT trunc_int_for_mode\tPARAMS ((HOST_WIDE_INT,"}]}