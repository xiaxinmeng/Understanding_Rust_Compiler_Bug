{"sha": "50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlMTBmYTg4MWRlMmI5ZmQ4MmY4M2JjMGM0YzI0MjI3ZTJhNGE5Nw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-03-29T20:29:26Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-03-29T20:29:26Z"}, "message": "call.c (add_builtin_candidate): Use TYPE_PTR_P and VOID_TYPE_P.\n\n2013-03-29  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* call.c (add_builtin_candidate): Use TYPE_PTR_P and VOID_TYPE_P.\n\t(build_op_call_1): Likewise.\n\t(build_over_call): Likewise.\n\t(compare_ics): Likewise.\n\t* class.c (build_base_path): Likewise.\n\t(resolve_address_of_overloaded_function): Likewise.\n\t* cp-tree.h: Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t(convert_to_reference): Likewise.\n\t(ocp_convert): Likewise.\n\t(convert_force): Likewise, tidy.\n\t* cxx-pretty-print.c (pp_cxx_postfix_expression): Likewise.\n\t(pp_cxx_ptr_operator): Likewise.\n\t* decl.c (duplicate_decls): Likewise.\n\t(start_decl): Likewise.\n\t(grok_op_properties): Likewise.\n\t(start_preparsed_function): Likewise.\n\t(store_parm_decls): Likewise.\n\t(finish_function): Likewise.\n\t* decl2.c (delete_sanity): Likewise.\n\t(acceptable_java_type): Likewise.\n\t(grokbitfield): Likewise.\n\t(cp_reconstruct_complex_type): Likewise.\n\t* error.c (dump_type_prefix): Likewise.\n\t(dump_expr): Likewise.\n\t* except.c (push_eh_cleanup): Likewise.\n\t(complete_ptr_ref_or_void_ptr_p): Likewise.\n\t(can_convert_eh): Likewise.\n\t* init.c (build_new_1): Likewise.\n\t(build_delete): Likewise.\n\t(build_vec_delete): Likewise.\n\t* mangle.c (write_type): Likewise.\n\t* parser.c (lookup_literal_operator): Likewise.\n\t* pt.c (convert_nontype_argument_function): Likewise.\n\t(convert_nontype_argument): Likewise.\n\t(tsubst): Likewise.\n\t(unify): Likewise.\n\t(dependent_type_p_r): Likewise.\n\t* rtti.c (build_headof): Likewise.\n\t(build_typeid): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t(target_incomplete_p): Likewise.\n\t(typeinfo_in_lib_p): Likewise.\n\t* semantics.c (finish_omp_for): Likewise.\n\t(cxx_eval_call_expression): Likewise.\n\t(maybe_resolve_dummy): Likewise.\n\t* tree.c (build_target_expr): Likewise.\n\t(cp_build_qualified_type_real): Likewise.\n\t* typeck.c (composite_pointer_type_r): Likewise.\n\t(composite_pointer_type): Likewise.\n\t(comp_except_types): Likewise.\n\t(cxx_sizeof_nowarn): Likewise.\n\t(string_conv_p): Likewise.\n\t(cp_build_array_ref): Likewise.\n\t(cp_build_function_call_vec): Likewise, also use TYPE_PTRFN_P.\n\t(pointer_diff): Likewise.\n\t(cp_build_addr_expr_1): Likewise.\n\t(cp_build_unary_op): Likewise.\n\t(build_static_cast_1): Likewise.\n\t(cp_build_c_cast): Likewise.\n\t(comp_ptr_ttypes_real): Likewise.\n\t(ptr_reasonably_similar): Likewise.\n\t(comp_ptr_ttypes_const): Likewise.\n\t(casts_away_constness): Likewise.\n\t(check_literal_operator_args): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\t(add_exception_specifier): Likewise.\n\nFrom-SVN: r197249", "tree": {"sha": "9cb10a80ad3e11c0cfaafc6f3b7ba397b73dd690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cb10a80ad3e11c0cfaafc6f3b7ba397b73dd690"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/comments", "author": null, "committer": null, "parents": [{"sha": "10c6dc8e3932d33c8e47e6706885d2412b29c069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c6dc8e3932d33c8e47e6706885d2412b29c069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c6dc8e3932d33c8e47e6706885d2412b29c069"}], "stats": {"total": 284, "additions": 174, "deletions": 110}, "files": [{"sha": "16ea0743d6e755fa6829654d73bab7afc9ebcc78", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -1,3 +1,73 @@\n+2013-03-29  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* call.c (add_builtin_candidate): Use TYPE_PTR_P and VOID_TYPE_P.\n+\t(build_op_call_1): Likewise.\n+\t(build_over_call): Likewise.\n+\t(compare_ics): Likewise.\n+\t* class.c (build_base_path): Likewise.\n+\t(resolve_address_of_overloaded_function): Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t(convert_to_reference): Likewise.\n+\t(ocp_convert): Likewise.\n+\t(convert_force): Likewise, tidy.\n+\t* cxx-pretty-print.c (pp_cxx_postfix_expression): Likewise.\n+\t(pp_cxx_ptr_operator): Likewise.\n+\t* decl.c (duplicate_decls): Likewise.\n+\t(start_decl): Likewise.\n+\t(grok_op_properties): Likewise.\n+\t(start_preparsed_function): Likewise.\n+\t(store_parm_decls): Likewise.\n+\t(finish_function): Likewise.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t(acceptable_java_type): Likewise.\n+\t(grokbitfield): Likewise.\n+\t(cp_reconstruct_complex_type): Likewise.\n+\t* error.c (dump_type_prefix): Likewise.\n+\t(dump_expr): Likewise.\n+\t* except.c (push_eh_cleanup): Likewise.\n+\t(complete_ptr_ref_or_void_ptr_p): Likewise.\n+\t(can_convert_eh): Likewise.\n+\t* init.c (build_new_1): Likewise.\n+\t(build_delete): Likewise.\n+\t(build_vec_delete): Likewise.\n+\t* mangle.c (write_type): Likewise.\n+\t* parser.c (lookup_literal_operator): Likewise.\n+\t* pt.c (convert_nontype_argument_function): Likewise.\n+\t(convert_nontype_argument): Likewise.\n+\t(tsubst): Likewise.\n+\t(unify): Likewise.\n+\t(dependent_type_p_r): Likewise.\n+\t* rtti.c (build_headof): Likewise.\n+\t(build_typeid): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t(target_incomplete_p): Likewise.\n+\t(typeinfo_in_lib_p): Likewise.\n+\t* semantics.c (finish_omp_for): Likewise.\n+\t(cxx_eval_call_expression): Likewise.\n+\t(maybe_resolve_dummy): Likewise.\n+\t* tree.c (build_target_expr): Likewise.\n+\t(cp_build_qualified_type_real): Likewise.\n+\t* typeck.c (composite_pointer_type_r): Likewise.\n+\t(composite_pointer_type): Likewise.\n+\t(comp_except_types): Likewise.\n+\t(cxx_sizeof_nowarn): Likewise.\n+\t(string_conv_p): Likewise.\n+\t(cp_build_array_ref): Likewise.\n+\t(cp_build_function_call_vec): Likewise, also use TYPE_PTRFN_P.\n+\t(pointer_diff): Likewise.\n+\t(cp_build_addr_expr_1): Likewise.\n+\t(cp_build_unary_op): Likewise.\n+\t(build_static_cast_1): Likewise.\n+\t(cp_build_c_cast): Likewise.\n+\t(comp_ptr_ttypes_real): Likewise.\n+\t(ptr_reasonably_similar): Likewise.\n+\t(comp_ptr_ttypes_const): Likewise.\n+\t(casts_away_constness): Likewise.\n+\t(check_literal_operator_args): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\t(add_exception_specifier): Likewise.\n+\n 2013-03-29  Jason Merrill  <jason@redhat.com>\n \n \tN3582"}, {"sha": "1c368ca8ce849b8cd6ad7d3b32767eeb14f3614f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -2285,7 +2285,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     T&      operator*(T*);  */\n \n     case INDIRECT_REF:\n-      if (TREE_CODE (type1) == POINTER_TYPE\n+      if (TYPE_PTR_P (type1)\n \t  && !uses_template_parms (TREE_TYPE (type1))\n \t  && (TYPE_PTROB_P (type1)\n \t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n@@ -2301,7 +2301,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     T       operator-(T);  */\n \n     case UNARY_PLUS_EXPR: /* unary + */\n-      if (TREE_CODE (type1) == POINTER_TYPE)\n+      if (TYPE_PTR_P (type1))\n \tbreak;\n     case NEGATE_EXPR:\n       if (ARITHMETIC_TYPE_P (type1))\n@@ -2325,8 +2325,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n      where CV12 is the union of CV1 and CV2.  */\n \n     case MEMBER_REF:\n-      if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && TYPE_PTRMEM_P (type2))\n+      if (TYPE_PTR_P (type1) && TYPE_PTRMEM_P (type2))\n \t{\n \t  tree c1 = TREE_TYPE (type1);\n \t  tree c2 = TYPE_PTRMEM_CLASS_TYPE (type2);\n@@ -2546,7 +2545,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t      || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n \t      || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2))\n \t      || ((TYPE_PTRMEMFUNC_P (type1)\n-\t\t   || TREE_CODE (type1) == POINTER_TYPE)\n+\t\t   || TYPE_PTR_P (type1))\n \t\t  && null_ptr_cst_p (args[1])))\n \t    {\n \t      type2 = type1;\n@@ -4083,12 +4082,12 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n       tree fns = TREE_VALUE (convs);\n       tree totype = TREE_TYPE (convs);\n \n-      if ((TREE_CODE (totype) == POINTER_TYPE\n+      if ((TYPE_PTR_P (totype)\n \t   && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n \t  || (TREE_CODE (totype) == REFERENCE_TYPE\n \t      && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n \t  || (TREE_CODE (totype) == REFERENCE_TYPE\n-\t      && TREE_CODE (TREE_TYPE (totype)) == POINTER_TYPE\n+\t      && TYPE_PTR_P (TREE_TYPE (totype))\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (totype))) == FUNCTION_TYPE))\n \tfor (; fns; fns = OVL_NEXT (fns))\n \t  {\n@@ -6766,7 +6765,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n \t So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n-      gcc_assert (TREE_CODE (parmtype) == POINTER_TYPE);\n+      gcc_assert (TYPE_PTR_P (parmtype));\n       /* Convert to the base in which the function was declared.  */\n       gcc_assert (cand->conversion_path != NULL_TREE);\n       converted_arg = build_base_path (PLUS_EXPR,\n@@ -8136,8 +8135,8 @@ compare_ics (conversion *ics1, conversion *ics2)\n \t   conversion of B* to A* is better than conversion of B* to\n \t   void*, and conversion of A* to void* is better than\n \t   conversion of B* to void*.  */\n-      if (TREE_CODE (deref_to_type1) == VOID_TYPE\n-\t  && TREE_CODE (deref_to_type2) == VOID_TYPE)\n+      if (VOID_TYPE_P (deref_to_type1)\n+\t  && VOID_TYPE_P (deref_to_type2))\n \t{\n \t  if (is_properly_derived_from (deref_from_type1,\n \t\t\t\t\tderef_from_type2))\n@@ -8146,12 +8145,12 @@ compare_ics (conversion *ics1, conversion *ics2)\n \t\t\t\t\t     deref_from_type1))\n \t    return 1;\n \t}\n-      else if (TREE_CODE (deref_to_type1) == VOID_TYPE\n-\t       || TREE_CODE (deref_to_type2) == VOID_TYPE)\n+      else if (VOID_TYPE_P (deref_to_type1)\n+\t       || VOID_TYPE_P (deref_to_type2))\n \t{\n \t  if (same_type_p (deref_from_type1, deref_from_type2))\n \t    {\n-\t      if (TREE_CODE (deref_to_type2) == VOID_TYPE)\n+\t      if (VOID_TYPE_P (deref_to_type2))\n \t\t{\n \t\t  if (is_properly_derived_from (deref_from_type1,\n \t\t\t\t\t\tderef_to_type1))"}, {"sha": "cea8a512cd35aa928135fa27f245cc51b9822774", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -244,7 +244,7 @@ build_base_path (enum tree_code code,\n   tree null_test = NULL;\n   tree ptr_target_type;\n   int fixed_type_p;\n-  int want_pointer = TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE;\n+  int want_pointer = TYPE_PTR_P (TREE_TYPE (expr));\n   bool has_empty = false;\n   bool virtual_access;\n \n@@ -7142,7 +7142,7 @@ resolve_address_of_overloaded_function (tree target_type,\n   /* By the time we get here, we should be seeing only real\n      pointer-to-member types, not the internal POINTER_TYPE to\n      METHOD_TYPE representation.  */\n-  gcc_assert (TREE_CODE (target_type) != POINTER_TYPE\n+  gcc_assert (!TYPE_PTR_P (target_type)\n \t      || TREE_CODE (TREE_TYPE (target_type)) != METHOD_TYPE);\n \n   gcc_assert (is_overloaded_fn (overload));"}, {"sha": "eef60a23cb90732fe76d4c146c0a3065646a48eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -3450,7 +3450,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    Keep these checks in ascending order, for speed.  */\n #define TYPE_OBJ_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) != REFERENCE_TYPE\t\t\\\n-   && TREE_CODE (NODE) != VOID_TYPE\t\t\\\n+   && !VOID_TYPE_P (NODE)  \t\t        \\\n    && TREE_CODE (NODE) != FUNCTION_TYPE\t\t\\\n    && TREE_CODE (NODE) != METHOD_TYPE)\n \n@@ -3473,7 +3473,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Returns true if NODE is a pointer to function.  */\n #define TYPE_PTRFN_P(NODE)\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n+  (TYPE_PTR_P (NODE)\t\t\t                \\\n    && TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE)\n \n /* Returns true if NODE is a reference to function.  */"}, {"sha": "866396c5b4073dfc79e134dd9565fb83608d7ebe", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -105,14 +105,14 @@ cp_convert_to_pointer (tree type, tree expr, tsubst_flags_t complain)\n     }\n \n   /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n-  if (TREE_CODE (type) == POINTER_TYPE\n+  if (TYPE_PTR_P (type)\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  || VOID_TYPE_P (TREE_TYPE (type))))\n     {\n       if (TYPE_PTRMEMFUNC_P (intype)\n \t  || TREE_CODE (intype) == METHOD_TYPE)\n \treturn convert_member_func_to_ptr (type, expr, complain);\n-      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+      if (TYPE_PTR_P (TREE_TYPE (expr)))\n \treturn build_nop (type, expr);\n       intype = TREE_TYPE (expr);\n     }\n@@ -127,7 +127,7 @@ cp_convert_to_pointer (tree type, tree expr, tsubst_flags_t complain)\n       intype = TYPE_MAIN_VARIANT (intype);\n \n       if (TYPE_MAIN_VARIANT (type) != intype\n-\t  && TREE_CODE (type) == POINTER_TYPE\n+\t  && TYPE_PTR_P (type)\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n \t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (type))\n \t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (intype))\n@@ -483,7 +483,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n \t meant.  */\n       if ((complain & tf_warning)\n-\t  && TREE_CODE (intype) == POINTER_TYPE\n+\t  && TYPE_PTR_P (intype)\n \t  && (comptypes (TREE_TYPE (intype), type,\n \t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n \twarning_at (loc, 0, \"casting %qT to %qT does not dereference pointer\",\n@@ -723,7 +723,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t  if (((INTEGRAL_OR_ENUMERATION_TYPE_P (intype)\n \t\t|| TREE_CODE (intype) == REAL_TYPE)\n \t       && ! (convtype & CONV_STATIC))\n-\t      || TREE_CODE (intype) == POINTER_TYPE)\n+\t      || TYPE_PTR_P (intype))\n \t    {\n \t      if (complain & tf_error)\n \t\tpermerror (loc, \"conversion from %q#T to %q#T\", intype, type);\n@@ -758,7 +758,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t}\n       if (code == BOOLEAN_TYPE)\n \t{\n-\t  if (TREE_CODE (intype) == VOID_TYPE)\n+\t  if (VOID_TYPE_P (intype))\n \t    {\n \t      if (complain & tf_error)\n \t\terror_at (loc,\n@@ -1457,8 +1457,7 @@ convert_force (tree type, tree expr, int convtype, tsubst_flags_t complain)\n \t\t\t\t\t\t\t      complain));\n \n   /* From typeck.c convert_for_assignment */\n-  if (((TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE && TREE_CODE (e) == ADDR_EXPR\n-\t&& TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE\n+  if (((TYPE_PTR_P (TREE_TYPE (e)) && TREE_CODE (e) == ADDR_EXPR\n \t&& TREE_CODE (TREE_TYPE (TREE_TYPE (e))) == METHOD_TYPE)\n        || integer_zerop (e)\n        || TYPE_PTRMEMFUNC_P (TREE_TYPE (e)))"}, {"sha": "0b707fbde2d250ccb8502813f6bde2346320cea5", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -530,7 +530,7 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n \t    if (TREE_CODE (object) == ADDR_EXPR)\n \t      object = TREE_OPERAND (object, 0);\n \n-\t    if (TREE_CODE (TREE_TYPE (object)) != POINTER_TYPE)\n+\t    if (!TYPE_PTR_P (TREE_TYPE (object)))\n \t      {\n \t\tpp_cxx_postfix_expression (pp, object);\n \t\tpp_cxx_dot (pp);\n@@ -1364,7 +1364,7 @@ pp_cxx_ptr_operator (cxx_pretty_printer *pp, tree t)\n \tpp_cxx_ptr_operator (pp, TREE_TYPE (t));\n       pp_c_attributes_display (pp_c_base (pp),\n \t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (t)));\n-      if (TREE_CODE (t) == POINTER_TYPE)\n+      if (TYPE_PTR_P (t))\n \t{\n \t  pp_star (pp);\n \t  pp_cxx_cv_qualifier_seq (pp, t);"}, {"sha": "ae4c5b4714841caa38e15f6666fd492254e0712f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -1348,7 +1348,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t  {\n \t\t    tree t = TREE_VALUE (t1);\n \n-\t\t    if (TREE_CODE (t) == POINTER_TYPE\n+\t\t    if (TYPE_PTR_P (t)\n \t\t\t&& TYPE_NAME (TREE_TYPE (t))\n \t\t\t&& DECL_NAME (TYPE_NAME (TREE_TYPE (t)))\n \t\t\t   == get_identifier (\"FILE\")\n@@ -4451,7 +4451,7 @@ start_decl (const cp_declarator *declarator,\n \n   deprecated_state = DEPRECATED_NORMAL;\n \n-  if (decl == NULL_TREE || TREE_CODE (decl) == VOID_TYPE\n+  if (decl == NULL_TREE || VOID_TYPE_P (decl)\n       || decl == error_mark_node)\n     return error_mark_node;\n \n@@ -11487,7 +11487,7 @@ grok_op_properties (tree decl, bool complain)\n \t  if (ref)\n \t    t = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n \n-\t  if (TREE_CODE (t) == VOID_TYPE)\n+\t  if (VOID_TYPE_P (t))\n             warning (OPT_Wconversion,\n                      ref\n                      ? G_(\"conversion to a reference to void \"\n@@ -12951,7 +12951,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   bool honor_interface;\n \n   /* Sanity check.  */\n-  gcc_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE);\n+  gcc_assert (VOID_TYPE_P (TREE_VALUE (void_list_node)));\n   gcc_assert (TREE_CHAIN (void_list_node) == NULL_TREE);\n \n   fntype = TREE_TYPE (decl1);\n@@ -13016,7 +13016,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   /* Effective C++ rule 15.  */\n   if (warn_ecpp\n       && DECL_OVERLOADED_OPERATOR_P (decl1) == NOP_EXPR\n-      && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n+      && VOID_TYPE_P (TREE_TYPE (fntype)))\n     warning (OPT_Weffc__, \"%<operator=%> should return a reference to %<*this%>\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n@@ -13187,7 +13187,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       tree t = DECL_ARGUMENTS (decl1);\n \n       gcc_assert (t != NULL_TREE && TREE_CODE (t) == PARM_DECL);\n-      gcc_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE);\n+      gcc_assert (TYPE_PTR_P (TREE_TYPE (t)));\n \n       cp_function_chain->x_current_class_ref\n \t= cp_build_indirect_ref (t, RO_NULL, tf_warning_or_error);\n@@ -13415,7 +13415,7 @@ store_parm_decls (tree current_function_parms)\n \t  if (TREE_CODE (parm) == PARM_DECL)\n \t    {\n \t      if (DECL_NAME (parm) == NULL_TREE\n-\t\t  || TREE_CODE (parm) != VOID_TYPE)\n+\t\t  || !VOID_TYPE_P (parm))\n \t\tpushdecl (parm);\n \t      else\n \t\terror (\"parameter %qD declared void\", parm);\n@@ -13838,7 +13838,7 @@ finish_function (int flags)\n \n   /* Complain if there's just no return statement.  */\n   if (warn_return_type\n-      && TREE_CODE (TREE_TYPE (fntype)) != VOID_TYPE\n+      && !VOID_TYPE_P (TREE_TYPE (fntype))\n       && !dependent_type_p (TREE_TYPE (fntype))\n       && !current_function_returns_value && !current_function_returns_null\n       /* Don't complain if we abort or throw.  */"}, {"sha": "09fd86464b0ddf6d36d5a165ca291cc9b48f51ec", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -460,7 +460,7 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete,\n     }\n \n   /* Deleting ptr to void is undefined behavior [expr.delete/3].  */\n-  if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n+  if (VOID_TYPE_P (TREE_TYPE (type)))\n     {\n       warning (0, \"deleting %qT is undefined\", type);\n       doing_vec = 0;\n@@ -518,9 +518,9 @@ acceptable_java_type (tree type)\n   if (type == error_mark_node)\n     return false;\n \n-  if (TREE_CODE (type) == VOID_TYPE || TYPE_FOR_JAVA (type))\n+  if (VOID_TYPE_P (type) || TYPE_FOR_JAVA (type))\n     return true;\n-  if (TREE_CODE (type) == POINTER_TYPE || TREE_CODE (type) == REFERENCE_TYPE)\n+  if (TYPE_PTR_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       type = TREE_TYPE (type);\n       if (TREE_CODE (type) == RECORD_TYPE)\n@@ -535,7 +535,7 @@ acceptable_java_type (tree type)\n \t  while (--i >= 0)\n \t    {\n \t      type = TREE_VEC_ELT (args, i);\n-\t      if (TREE_CODE (type) == POINTER_TYPE)\n+\t      if (TYPE_PTR_P (type))\n \t\ttype = TREE_TYPE (type);\n \t      if (! TYPE_FOR_JAVA (type))\n \t\treturn false;\n@@ -1024,7 +1024,7 @@ grokbitfield (const cp_declarator *declarator,\n     return NULL_TREE; /* friends went bad.  */\n \n   /* Pass friendly classes back.  */\n-  if (TREE_CODE (value) == VOID_TYPE)\n+  if (VOID_TYPE_P (value))\n     return void_type_node;\n \n   if (!INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (value))\n@@ -1234,7 +1234,7 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n {\n   tree inner, outer;\n \n-  if (TREE_CODE (type) == POINTER_TYPE)\n+  if (TYPE_PTR_P (type))\n     {\n       inner = cp_reconstruct_complex_type (TREE_TYPE (type), bottom);\n       outer = build_pointer_type_for_mode (inner, TYPE_MODE (type),"}, {"sha": "38da24304e01aaeb43cfd11ccfd29286d8cb40d0", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -708,7 +708,7 @@ dump_type_prefix (tree t, int flags)\n \t    pp_c_attributes_display (pp_c_base (cxx_pp),\n \t\t\t\t     TYPE_ATTRIBUTES (sub));\n \t  }\n-\tif (TREE_CODE (t) == POINTER_TYPE)\n+\tif (TYPE_PTR_P (t))\n \t  pp_character(cxx_pp, '*');\n \telse if (TREE_CODE (t) == REFERENCE_TYPE)\n \t{\n@@ -2108,7 +2108,7 @@ dump_expr (tree t, int flags)\n \t{\n \t  tree next = TREE_TYPE (TREE_TYPE (t));\n \n-\t  while (TREE_CODE (next) == POINTER_TYPE)\n+\t  while (TYPE_PTR_P (next))\n \t    next = TREE_TYPE (next);\n \n \t  if (TREE_CODE (next) == FUNCTION_TYPE)"}, {"sha": "b762a51c67a02796cf0c4068ae0afba15f6aa59d", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -277,7 +277,7 @@ push_eh_cleanup (tree type)\n static bool\n decl_is_java_type (tree decl, int err)\n {\n-  bool r = (TREE_CODE (decl) == POINTER_TYPE\n+  bool r = (TYPE_PTR_P (decl)\n \t    && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n \t    && TYPE_FOR_JAVA (TREE_TYPE (decl)));\n \n@@ -930,7 +930,7 @@ complete_ptr_ref_or_void_ptr_p (tree type, tree from)\n     return 0;\n \n   /* Or a pointer or ref to one, or cv void *.  */\n-  is_ptr = TREE_CODE (type) == POINTER_TYPE;\n+  is_ptr = TYPE_PTR_P (type);\n   if (is_ptr || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       tree core = TREE_TYPE (type);\n@@ -1026,15 +1026,15 @@ can_convert_eh (tree to, tree from)\n   to = non_reference (to);\n   from = non_reference (from);\n \n-  if (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)\n+  if (TYPE_PTR_P (to) && TYPE_PTR_P (from))\n     {\n       to = TREE_TYPE (to);\n       from = TREE_TYPE (from);\n \n       if (! at_least_as_qualified_p (to, from))\n \treturn 0;\n \n-      if (TREE_CODE (to) == VOID_TYPE)\n+      if (VOID_TYPE_P (to))\n \treturn 1;\n \n       /* Else fall through.  */"}, {"sha": "ab6af1411a6119da38c94d96a15efd5a79908911", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -2294,7 +2294,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \treturn error_mark_node;\n     }\n \n-  if (TREE_CODE (elt_type) == VOID_TYPE)\n+  if (VOID_TYPE_P (elt_type))\n     {\n       if (complain & tf_error)\n         error (\"invalid type %<void%> for new\");\n@@ -2399,7 +2399,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n      this now, since PLACEMENT will change in the calls below.  */\n   placement_first = NULL_TREE;\n   if (vec_safe_length (*placement) == 1\n-      && (TREE_CODE (TREE_TYPE ((**placement)[0])) == POINTER_TYPE))\n+      && (TYPE_PTR_P (TREE_TYPE ((**placement)[0]))))\n     placement_first = (**placement)[0];\n \n   /* Allocate the object.  */\n@@ -2523,7 +2523,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n       && TREE_CODE (alloc_call) == CALL_EXPR\n       && call_expr_nargs (alloc_call) == 2\n       && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 0))) == INTEGER_TYPE\n-      && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 1))) == POINTER_TYPE)\n+      && TYPE_PTR_P (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 1))))\n     {\n       tree placement_arg = CALL_EXPR_ARG (alloc_call, 1);\n \n@@ -3742,7 +3742,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \n   addr = mark_rvalue_use (addr);\n \n-  if (TREE_CODE (type) == POINTER_TYPE)\n+  if (TYPE_PTR_P (type))\n     {\n       bool complete_p = true;\n \n@@ -4045,7 +4045,7 @@ build_vec_delete (tree base, tree maxindex,\n \n   type = TREE_TYPE (base);\n \n-  if (TREE_CODE (type) == POINTER_TYPE)\n+  if (TYPE_PTR_P (type))\n     {\n       /* Step back one from start of vector, and read dimension.  */\n       tree cookie_addr;"}, {"sha": "5fe3bf5dfda7671feb746a243b39823557f12be8", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -1912,7 +1912,7 @@ write_type (tree type)\n \t      write_string (target_mangling);\n \t      /* Add substitutions for types other than fundamental\n \t\t types.  */\n-\t      if (TREE_CODE (type) != VOID_TYPE\n+\t      if (!VOID_TYPE_P (type)\n \t\t  && TREE_CODE (type) != INTEGER_TYPE\n \t\t  && TREE_CODE (type) != REAL_TYPE\n \t\t  && TREE_CODE (type) != BOOLEAN_TYPE)\n@@ -1966,7 +1966,7 @@ write_type (tree type)\n \n \t    case POINTER_TYPE:\n \t    case REFERENCE_TYPE:\n-\t      if (TREE_CODE (type) == POINTER_TYPE)\n+\t      if (TYPE_PTR_P (type))\n \t\twrite_char ('P');\n \t      else if (TYPE_REF_IS_RVALUE (type))\n \t\twrite_char ('O');"}, {"sha": "78b13c3f7fb503dbac332a4822298523fac1fd3c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -3615,7 +3615,7 @@ lookup_literal_operator (tree name, vec<tree, va_gc> *args)\n \t    {\n \t      tree tparm = TREE_VALUE (parmtypes);\n \t      tree targ = TREE_TYPE ((*args)[ix]);\n-\t      bool ptr = TREE_CODE (tparm) == POINTER_TYPE;\n+\t      bool ptr = TYPE_PTR_P (tparm);\n \t      bool arr = TREE_CODE (targ) == ARRAY_TYPE;\n \t      if ((ptr || arr || !same_type_p (tparm, targ))\n \t\t  && (!ptr || !arr"}, {"sha": "532e761f17c1a797b4a05850e474cc01e62da88d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -5140,7 +5140,7 @@ convert_nontype_argument_function (tree type, tree expr)\n   if (TREE_CODE (fn_no_ptr) != FUNCTION_DECL)\n     {\n       error (\"%qE is not a valid template argument for type %qT\", expr, type);\n-      if (TREE_CODE (type) == POINTER_TYPE)\n+      if (TYPE_PTR_P (type))\n \terror (\"it must be the address of a function with external linkage\");\n       else\n \terror (\"it must be the name of a function with external linkage\");\n@@ -5547,7 +5547,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t  tree addr = TREE_OPERAND (probe, 0);\n \t  if (TREE_CODE (probe_type) == REFERENCE_TYPE\n \t      && TREE_CODE (addr) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_TYPE (addr)) == POINTER_TYPE\n+\t      && TYPE_PTR_P (TREE_TYPE (addr))\n \t      && (same_type_ignoring_top_level_qualifiers_p\n \t\t  (TREE_TYPE (probe_type),\n \t\t   TREE_TYPE (TREE_TYPE (addr)))))\n@@ -5566,7 +5566,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       tree probe = expr;\n       STRIP_NOPS (probe);\n       if (TREE_CODE (probe) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_TYPE (probe)) == POINTER_TYPE)\n+\t  && TYPE_PTR_P (TREE_TYPE (probe)))\n \t{\n \t  /* Skip the ADDR_EXPR only if it is part of the decay for\n \t     an array. Otherwise, it is part of the original argument\n@@ -11527,7 +11527,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  only enforce this check in strict C++98 mode.  */\n \tif ((TREE_CODE (type) == REFERENCE_TYPE\n \t     && (((cxx_dialect == cxx98) && flag_iso) || code != REFERENCE_TYPE))\n-\t    || (code == REFERENCE_TYPE && TREE_CODE (type) == VOID_TYPE))\n+\t    || (code == REFERENCE_TYPE && VOID_TYPE_P (type)))\n \t  {\n \t    static location_t last_loc;\n \n@@ -11537,7 +11537,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    if (complain & tf_error\n \t\t&& last_loc != input_location)\n \t      {\n-\t\tif (TREE_CODE (type) == VOID_TYPE)\n+\t\tif (VOID_TYPE_P (type))\n \t\t  error (\"forming reference to void\");\n                else if (code == POINTER_TYPE)\n                  error (\"forming pointer to reference type %qT\", type);\n@@ -11600,7 +11600,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      error (\"creating pointer to member reference type %qT\", type);\n \t    return error_mark_node;\n \t  }\n-\tif (TREE_CODE (type) == VOID_TYPE)\n+\tif (VOID_TYPE_P (type))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"creating pointer to member of type void\");\n@@ -11660,7 +11660,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t   -- Attempting to create an array with an element type that\n \t      is void, a function type, or a reference type, or [DR337]\n \t      an abstract class type.  */\n-\tif (TREE_CODE (type) == VOID_TYPE\n+\tif (VOID_TYPE_P (type)\n \t    || TREE_CODE (type) == FUNCTION_TYPE\n \t    || TREE_CODE (type) == REFERENCE_TYPE)\n \t  {\n@@ -16797,7 +16797,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n     case POINTER_TYPE:\n       {\n-\tif (TREE_CODE (arg) != POINTER_TYPE)\n+\tif (!TYPE_PTR_P (arg))\n \t  return unify_type_mismatch (explain_p, parm, arg);\n \n \t/* [temp.deduct.call]\n@@ -19382,7 +19382,7 @@ dependent_type_p_r (tree type)\n     return (dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n \t    || dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE\n \t\t\t\t\t   (type)));\n-  else if (TREE_CODE (type) == POINTER_TYPE\n+  else if (TYPE_PTR_P (type)\n \t   || TREE_CODE (type) == REFERENCE_TYPE)\n     return dependent_type_p (TREE_TYPE (type));\n   else if (TREE_CODE (type) == FUNCTION_TYPE"}, {"sha": "e83d6666d9b14c373fe1634d2a3534da5b9646aa", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -173,7 +173,7 @@ build_headof (tree exp)\n   tree offset;\n   tree index;\n \n-  gcc_assert (TREE_CODE (type) == POINTER_TYPE);\n+  gcc_assert (TYPE_PTR_P (type));\n   type = TREE_TYPE (type);\n \n   if (!TYPE_POLYMORPHIC_P (type))\n@@ -327,7 +327,7 @@ build_typeid (tree exp, tsubst_flags_t complain)\n   /* FIXME when integrating with c_fully_fold, mark\n      resolves_to_fixed_type_p case as a non-constant expression.  */\n   if (INDIRECT_REF_P (exp)\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n+      && TYPE_PTR_P (TREE_TYPE (TREE_OPERAND (exp, 0)))\n       && TYPE_POLYMORPHIC_P (TREE_TYPE (exp))\n       && ! resolves_to_fixed_type_p (exp, &nonnull)\n       && ! nonnull)\n@@ -528,7 +528,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n   switch (tc)\n     {\n     case POINTER_TYPE:\n-      if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n+      if (VOID_TYPE_P (TREE_TYPE (type)))\n \tbreak;\n       /* Fall through.  */\n     case REFERENCE_TYPE:\n@@ -559,7 +559,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \n       expr = mark_rvalue_use (expr);\n \n-      if (TREE_CODE (exprtype) != POINTER_TYPE)\n+      if (!TYPE_PTR_P (exprtype))\n \t{\n \t  errstr = _(\"source is not a pointer\");\n \t  goto fail;\n@@ -620,7 +620,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n       {\n \texpr = build_base_path (PLUS_EXPR, convert_from_reference (expr),\n \t\t\t\tbinfo, 0, complain);\n-\tif (TREE_CODE (exprtype) == POINTER_TYPE)\n+\tif (TYPE_PTR_P (exprtype))\n \t  expr = rvalue (expr);\n \treturn expr;\n       }\n@@ -822,7 +822,7 @@ target_incomplete_p (tree type)\n \t  return true;\n \ttype = TYPE_PTRMEM_POINTED_TO_TYPE (type);\n       }\n-    else if (TREE_CODE (type) == POINTER_TYPE)\n+    else if (TYPE_PTR_P (type))\n       type = TREE_TYPE (type);\n     else\n       return !COMPLETE_OR_VOID_TYPE_P (type);\n@@ -1053,7 +1053,7 @@ typeinfo_in_lib_p (tree type)\n {\n   /* The typeinfo objects for `T*' and `const T*' are in the runtime\n      library for simple types T.  */\n-  if (TREE_CODE (type) == POINTER_TYPE\n+  if (TYPE_PTR_P (type)\n       && (cp_type_quals (TREE_TYPE (type)) == TYPE_QUAL_CONST\n \t  || cp_type_quals (TREE_TYPE (type)) == TYPE_UNQUALIFIED))\n     type = TREE_TYPE (type);"}, {"sha": "1821ff4217e9d8a329a673371230529e4b6dc04b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -4915,7 +4915,7 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t}\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (decl))\n-\t  && TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE)\n+\t  && !TYPE_PTR_P (TREE_TYPE (decl)))\n \t{\n \t  error_at (elocus, \"invalid type for iteration variable %qE\", decl);\n \t  return NULL;\n@@ -6859,7 +6859,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n \t    {\n \t      tree ob_arg = get_nth_callarg (t, 0);\n \t      STRIP_NOPS (ob_arg);\n-\t      gcc_assert (TREE_CODE (TREE_TYPE (ob_arg)) == POINTER_TYPE\n+\t      gcc_assert (TYPE_PTR_P (TREE_TYPE (ob_arg))\n \t\t\t  && CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (ob_arg))));\n \t      result = adjust_temp_type (TREE_TYPE (TREE_TYPE (ob_arg)),\n \t\t\t\t\t result);\n@@ -9623,7 +9623,7 @@ maybe_resolve_dummy (tree object)\n     return object;\n \n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (object));\n-  gcc_assert (TREE_CODE (type) != POINTER_TYPE);\n+  gcc_assert (!TYPE_PTR_P (type));\n \n   if (type != current_class_type\n       && current_class_type"}, {"sha": "7fb8698ecfc33ac24bc8b5882d8016bf9ad7c413", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -309,7 +309,7 @@ build_target_expr (tree decl, tree value, tsubst_flags_t complain)\n   gcc_assert (VOID_TYPE_P (TREE_TYPE (value))\n \t      || TREE_TYPE (decl) == TREE_TYPE (value)\n \t      /* On ARM ctors return 'this'.  */\n-\t      || (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n+\t      || (TYPE_PTR_P (TREE_TYPE (value))\n \t\t  && TREE_CODE (value) == CALL_EXPR)\n \t      || useless_type_conversion_p (TREE_TYPE (decl),\n \t\t\t\t\t    TREE_TYPE (value)));\n@@ -1086,7 +1086,7 @@ cp_build_qualified_type_real (tree type,\n      pointer-to-member-function type, because these will be distinct\n      between the unqualified and qualified types.  */\n   if (result != type\n-      && TREE_CODE (type) == POINTER_TYPE\n+      && TYPE_PTR_P (type)\n       && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n       && TYPE_LANG_SPECIFIC (result) == TYPE_LANG_SPECIFIC (type))\n     TYPE_LANG_SPECIFIC (result) = NULL;\n@@ -1095,7 +1095,7 @@ cp_build_qualified_type_real (tree type,\n      type of a pointer-to-method type, which could have the same\n      sharing problem described above.  */\n   if (TYPE_CANONICAL (result) != TYPE_CANONICAL (type)\n-      && TREE_CODE (type) == POINTER_TYPE\n+      && TYPE_PTR_P (type)\n       && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n       && (TYPE_LANG_SPECIFIC (TYPE_CANONICAL (result)) \n           == TYPE_LANG_SPECIFIC (TYPE_CANONICAL (type))))"}, {"sha": "7e2dcccac6b998052f793349dc33558201870078", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -483,7 +483,7 @@ composite_pointer_type_r (tree t1, tree t2,\n   tree attributes;\n \n   /* Determine the types pointed to by T1 and T2.  */\n-  if (TREE_CODE (t1) == POINTER_TYPE)\n+  if (TYPE_PTR_P (t1))\n     {\n       pointee1 = TREE_TYPE (t1);\n       pointee2 = TREE_TYPE (t2);\n@@ -503,8 +503,7 @@ composite_pointer_type_r (tree t1, tree t2,\n      types.  */\n   if (same_type_ignoring_top_level_qualifiers_p (pointee1, pointee2))\n     result_type = pointee1;\n-  else if ((TREE_CODE (pointee1) == POINTER_TYPE\n-\t    && TREE_CODE (pointee2) == POINTER_TYPE)\n+  else if ((TYPE_PTR_P (pointee1) && TYPE_PTR_P (pointee2))\n \t   || (TYPE_PTRMEM_P (pointee1) && TYPE_PTRMEM_P (pointee2)))\n     {\n       result_type = composite_pointer_type_r (pointee1, pointee2, operation,\n@@ -581,7 +580,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n        and cv2.\n \n     If either type is a pointer to void, make sure it is T1.  */\n-  if (TREE_CODE (t2) == POINTER_TYPE && VOID_TYPE_P (TREE_TYPE (t2)))\n+  if (TYPE_PTR_P (t2) && VOID_TYPE_P (TREE_TYPE (t2)))\n     {\n       tree t;\n       t = t1;\n@@ -590,7 +589,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n     }\n \n   /* Now, if T1 is a pointer to void, merge the qualifiers.  */\n-  if (TREE_CODE (t1) == POINTER_TYPE && VOID_TYPE_P (TREE_TYPE (t1)))\n+  if (TYPE_PTR_P (t1) && VOID_TYPE_P (TREE_TYPE (t1)))\n     {\n       tree attributes;\n       tree result_type;\n@@ -628,16 +627,16 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       return build_type_attribute_variant (result_type, attributes);\n     }\n \n-  if (c_dialect_objc () && TREE_CODE (t1) == POINTER_TYPE\n-      && TREE_CODE (t2) == POINTER_TYPE)\n+  if (c_dialect_objc () && TYPE_PTR_P (t1)\n+      && TYPE_PTR_P (t2))\n     {\n       if (objc_have_common_type (t1, t2, -3, NULL_TREE))\n \treturn objc_common_type (t1, t2);\n     }\n \n   /* [expr.eq] permits the application of a pointer conversion to\n      bring the pointers to a common type.  */\n-  if (TREE_CODE (t1) == POINTER_TYPE && TREE_CODE (t2) == POINTER_TYPE\n+  if (TYPE_PTR_P (t1) && TYPE_PTR_P (t2)\n       && CLASS_TYPE_P (TREE_TYPE (t1))\n       && CLASS_TYPE_P (TREE_TYPE (t2))\n       && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (t1),\n@@ -959,8 +958,7 @@ comp_except_types (tree a, tree b, bool exact)\n       if (cp_type_quals (a) || cp_type_quals (b))\n \treturn false;\n \n-      if (TREE_CODE (a) == POINTER_TYPE\n-\t  && TREE_CODE (b) == POINTER_TYPE)\n+      if (TYPE_PTR_P (a) && TYPE_PTR_P (b))\n \t{\n \t  a = TREE_TYPE (a);\n \t  b = TREE_TYPE (b);\n@@ -1553,7 +1551,7 @@ tree\n cxx_sizeof_nowarn (tree type)\n {\n   if (TREE_CODE (type) == FUNCTION_TYPE\n-      || TREE_CODE (type) == VOID_TYPE\n+      || VOID_TYPE_P (type)\n       || TREE_CODE (type) == ERROR_MARK)\n     return size_one_node;\n   else if (!COMPLETE_TYPE_P (type))\n@@ -2069,7 +2067,7 @@ string_conv_p (const_tree totype, const_tree exp, int warn)\n {\n   tree t;\n \n-  if (TREE_CODE (totype) != POINTER_TYPE)\n+  if (!TYPE_PTR_P (totype))\n     return 0;\n \n   t = TREE_TYPE (totype);\n@@ -3091,7 +3089,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n     if (ar == error_mark_node || ind == error_mark_node)\n       return error_mark_node;\n \n-    if (TREE_CODE (TREE_TYPE (ar)) != POINTER_TYPE)\n+    if (!TYPE_PTR_P (TREE_TYPE (ar)))\n       {\n \tif (complain & tf_error)\n \t  error_at (loc, \"subscripted value is neither array nor pointer\");\n@@ -3401,11 +3399,10 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n       return error_mark_node;\n     }\n \n-  is_method = (TREE_CODE (fntype) == POINTER_TYPE\n+  is_method = (TYPE_PTR_P (fntype)\n \t       && TREE_CODE (TREE_TYPE (fntype)) == METHOD_TYPE);\n \n-  if (!((TREE_CODE (fntype) == POINTER_TYPE\n-\t && TREE_CODE (TREE_TYPE (fntype)) == FUNCTION_TYPE)\n+  if (!(TYPE_PTRFN_P (fntype)\n \t|| is_method\n \t|| TREE_CODE (function) == TEMPLATE_ID_EXPR))\n     {\n@@ -4823,7 +4820,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n   if (!complete_type_or_else (target_type, NULL_TREE))\n     return error_mark_node;\n \n-  if (TREE_CODE (target_type) == VOID_TYPE)\n+  if (VOID_TYPE_P (target_type))\n     {\n       if (complain & tf_error)\n \tpermerror (input_location, \"ISO C++ forbids using pointer of \"\n@@ -5308,7 +5305,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n       val = build_address (arg);\n     }\n \n-  if (TREE_CODE (argtype) == POINTER_TYPE\n+  if (TYPE_PTR_P (argtype)\n       && TREE_CODE (TREE_TYPE (argtype)) == METHOD_TYPE)\n     {\n       build_ptrmemfunc_type (argtype);\n@@ -5536,7 +5533,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \n \t/* Compute the increment.  */\n \n-\tif (TREE_CODE (argtype) == POINTER_TYPE)\n+\tif (TYPE_PTR_P (argtype))\n \t  {\n \t    tree type = complete_type (TREE_TYPE (argtype));\n \n@@ -6244,7 +6241,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n   /* [expr.static.cast]\n \n      Any expression can be explicitly converted to type cv void.  */\n-  if (TREE_CODE (type) == VOID_TYPE)\n+  if (VOID_TYPE_P (type))\n     return convert_to_void (expr, ICV_CAST, complain);\n \n   /* [class.abstract]\n@@ -6366,7 +6363,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n      converted to a pointer to object type.  A value of type pointer\n      to object converted to \"pointer to cv void\" and back to the\n      original pointer type will have its original value.  */\n-  if (TREE_CODE (intype) == POINTER_TYPE\n+  if (TYPE_PTR_P (intype)\n       && VOID_TYPE_P (TREE_TYPE (intype))\n       && TYPE_PTROB_P (type))\n     {\n@@ -6886,7 +6883,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n     {\n       /* Allow casting from T1* to T2[] because Cfront allows it.\n \t NIHCL uses it. It is not valid ISO C++ however.  */\n-      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+      if (TYPE_PTR_P (TREE_TYPE (expr)))\n \t{\n           if (complain & tf_error)\n             permerror (input_location, \"ISO C++ forbids casting to an array type %qT\", type);\n@@ -6910,7 +6907,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (type) == POINTER_TYPE\n+  if (TYPE_PTR_P (type)\n       && TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n       /* Casting to an integer of smaller size is an error detected elsewhere.  */\n       && TYPE_PRECISION (type) > TYPE_PRECISION (TREE_TYPE (value))\n@@ -8420,7 +8417,7 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n       if (TREE_CODE (to) == VECTOR_TYPE)\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n-      if (TREE_CODE (to) != POINTER_TYPE && !TYPE_PTRDATAMEM_P (to))\n+      if (!TYPE_PTR_P (to) && !TYPE_PTRDATAMEM_P (to))\n \treturn ((constp >= 0 || to_more_cv_qualified)\n \t\t&& (is_opaque_pointer\n \t\t    || same_type_ignoring_top_level_qualifiers_p (to, from)));\n@@ -8484,9 +8481,9 @@ ptr_reasonably_similar (const_tree to, const_tree from)\n   for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n     {\n       /* Any target type is similar enough to void.  */\n-      if (TREE_CODE (to) == VOID_TYPE)\n+      if (VOID_TYPE_P (to))\n \treturn !error_type_p (from);\n-      if (TREE_CODE (from) == VOID_TYPE)\n+      if (VOID_TYPE_P (from))\n \treturn !error_type_p (to);\n \n       if (TREE_CODE (to) != TREE_CODE (from))\n@@ -8509,7 +8506,7 @@ ptr_reasonably_similar (const_tree to, const_tree from)\n       if (TREE_CODE (to) == FUNCTION_TYPE)\n \treturn !error_type_p (to) && !error_type_p (from);\n \n-      if (TREE_CODE (to) != POINTER_TYPE)\n+      if (!TYPE_PTR_P (to))\n \treturn comptypes\n \t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from),\n \t   COMPARE_BASE | COMPARE_DERIVED);\n@@ -8538,7 +8535,7 @@ comp_ptr_ttypes_const (tree to, tree from)\n       if (TREE_CODE (to) == VECTOR_TYPE)\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n-      if (TREE_CODE (to) != POINTER_TYPE)\n+      if (!TYPE_PTR_P (to))\n \treturn (is_opaque_pointer\n \t\t|| same_type_ignoring_top_level_qualifiers_p (to, from));\n     }\n@@ -8758,8 +8755,7 @@ casts_away_constness (tree t1, tree t2, tsubst_flags_t complain)\n \n   /* Casting away constness is only something that makes sense for\n      pointer or reference types.  */\n-  if (TREE_CODE (t1) != POINTER_TYPE\n-      || TREE_CODE (t2) != POINTER_TYPE)\n+  if (!TYPE_PTR_P (t1) || !TYPE_PTR_P (t2))\n     return false;\n \n   /* Top-level qualifiers don't matter.  */\n@@ -8869,7 +8865,7 @@ check_literal_operator_args (const_tree decl,\n \t  tree t = TREE_VALUE (argtype);\n \t  ++arity;\n \n-\t  if (TREE_CODE (t) == POINTER_TYPE)\n+\t  if (TYPE_PTR_P (t))\n \t    {\n \t      bool maybe_raw_p = false;\n \t      t = TREE_TYPE (t);"}, {"sha": "61ec4b58f64c1c8347745db2081cebf3f19816c6", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "patch": "@@ -1585,7 +1585,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n   else\n     last_rval = decay_conversion (expr, complain);\n \n-  if (TREE_CODE (TREE_TYPE (last_rval)) == POINTER_TYPE)\n+  if (TYPE_PTR_P (TREE_TYPE (last_rval)))\n     {\n       if (processing_template_decl)\n \t{\n@@ -1851,7 +1851,7 @@ add_exception_specifier (tree list, tree spec, int complain)\n   /* [except.spec] 1, type in an exception specifier shall not be\n      incomplete, or pointer or ref to incomplete other than pointer\n      to cv void.  */\n-  is_ptr = TREE_CODE (core) == POINTER_TYPE;\n+  is_ptr = TYPE_PTR_P (core);\n   if (is_ptr || TREE_CODE (core) == REFERENCE_TYPE)\n     core = TREE_TYPE (core);\n   if (complain < 0)"}]}