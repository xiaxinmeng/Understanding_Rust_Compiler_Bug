{"sha": "15f8ac7f0878178cca61636f81323629624e4585", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmOGFjN2YwODc4MTc4Y2NhNjE2MzZmODEzMjM2Mjk2MjRlNDU4NQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-05-14T22:33:28Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-05-14T22:33:28Z"}, "message": "name-lookup.c (struct scope_binding): New.\n\n\t* name-lookup.c (struct scope_binding): New.\n\t(EMPTY_SCOPE_BINDING): New.\n\t(lookup_using_namespace): Take a scope_binding instead of a\n\tcxx_binding.\n\t(qualified_lookup_using_namespace): Likewise.\n\t(cxx_binding_clear): Delete.\n\t(do_nonmember_using_decl): Use a scope_binding instead of a\n\tcxx_binding.\n\t(lookup_tag): Don't call select_decl.\n\t(ambiguous_decl): Don't return anything (and change callers to match).\n\tTake a scope_binding as the second parameter.\n\t(lookup_namespace_name): Use a scope_binding instead of a\n\tcxx_binding.\n\t(unqualified_namespace_lookup): Likewise.\n\t(lookup_qualified_name): Likewise.\n\t(select_decl): Take a scope_binding instead of a cxx_binding.\n\tUse macros rather than hand-coding tests for type-ness.\n\nFrom-SVN: r81864", "tree": {"sha": "3e8287a81abc527140b1f10cc83f72439495a9cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e8287a81abc527140b1f10cc83f72439495a9cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15f8ac7f0878178cca61636f81323629624e4585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f8ac7f0878178cca61636f81323629624e4585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f8ac7f0878178cca61636f81323629624e4585", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f8ac7f0878178cca61636f81323629624e4585/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae0d0d592f01a1d71ee5941b241b9af75c66ef23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae0d0d592f01a1d71ee5941b241b9af75c66ef23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae0d0d592f01a1d71ee5941b241b9af75c66ef23"}], "stats": {"total": 108, "additions": 65, "deletions": 43}, "files": [{"sha": "f1c24c1a36eda059f3f3efcbc457810e28ee996b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f8ac7f0878178cca61636f81323629624e4585/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f8ac7f0878178cca61636f81323629624e4585/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=15f8ac7f0878178cca61636f81323629624e4585", "patch": "@@ -1,3 +1,23 @@\n+2004-05-14  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* name-lookup.c (struct scope_binding): New.\n+\t(EMPTY_SCOPE_BINDING): New.\n+\t(lookup_using_namespace): Take a scope_binding instead of a\n+\tcxx_binding.\n+\t(qualified_lookup_using_namespace): Likewise.\n+\t(cxx_binding_clear): Delete.\n+\t(do_nonmember_using_decl): Use a scope_binding instead of a\n+\tcxx_binding.\n+\t(lookup_tag): Don't call select_decl.\n+\t(ambiguous_decl): Don't return anything (and change callers to match).\n+\tTake a scope_binding as the second parameter.\n+\t(lookup_namespace_name): Use a scope_binding instead of a\n+\tcxx_binding.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(lookup_qualified_name): Likewise.\n+\t(select_decl): Take a scope_binding instead of a cxx_binding.\n+\tUse macros rather than hand-coding tests for type-ness.\n+\n 2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n \n \t* cp-gimplify.c: Rename from cp-simplify.c."}, {"sha": "b3cc1dedc1b327b1e1cf444322636389bab42d8b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f8ac7f0878178cca61636f81323629624e4585/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f8ac7f0878178cca61636f81323629624e4585/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=15f8ac7f0878178cca61636f81323629624e4585", "patch": "@@ -32,14 +32,23 @@ Boston, MA 02111-1307, USA.  */\n #include \"diagnostic.h\"\n #include \"debug.h\"\n \n+/* The bindings for a particular name in a particular scope.  */\n+\n+struct scope_binding {\n+  tree value;\n+  tree type;\n+};\n+#define EMPTY_SCOPE_BINDING { NULL_TREE, NULL_TREE }\n+\n static cxx_scope *innermost_nonclass_level (void);\n-static tree select_decl (cxx_binding *, int);\n+static tree select_decl (const struct scope_binding *, int);\n static cxx_binding *binding_for_name (cxx_scope *, tree);\n static tree lookup_name_current_level (tree);\n static tree push_overloaded_decl (tree, int);\n-static bool lookup_using_namespace (tree, cxx_binding *, tree,\n+static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n                                     tree, int);\n-static bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n+static bool qualified_lookup_using_namespace (tree, tree,\n+\t\t\t\t\t      struct scope_binding *, int);\n static tree lookup_type_current_level (tree);\n static tree push_using_directive (tree);\n static void cp_emit_debug_info_for_using (tree, tree);\n@@ -319,9 +328,6 @@ binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n \n static GTY((deletable)) cxx_binding *free_bindings;\n \n-/* Zero out a cxx_binding pointed to by B.  */\n-#define cxx_binding_clear(B) memset ((B), 0, sizeof (cxx_binding))\n-\n /* (GC)-allocate a binding object with VALUE and TYPE member initialized.  */\n \n static cxx_binding *\n@@ -2116,10 +2122,9 @@ static void\n do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n                          tree *newval, tree *newtype)\n {\n-  cxx_binding decls;\n+  struct scope_binding decls = EMPTY_SCOPE_BINDING;\n \n   *newval = *newtype = NULL_TREE;\n-  cxx_binding_clear (&decls);\n   if (!qualified_lookup_using_namespace (name, scope, &decls, 0))\n     /* Lookup error */\n     return;\n@@ -2362,23 +2367,24 @@ lookup_tag (enum tree_code form, tree name,\n \t  {\n             cxx_binding *binding =\n               cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (tail), name);\n-\t    tree old;\n-\n-\t    /* If we just skipped past a template parameter level,\n-\t       even though THISLEVEL_ONLY, and we find a template\n-\t       class declaration, then we use the _TYPE node for the\n-\t       template.  See the example below.  */\n-\t    if (thislevel_only && !allow_template_parms_p\n-\t\t&& binding && binding->value\n-\t\t&& DECL_CLASS_TEMPLATE_P (binding->value))\n-\t      old = binding->value;\n-\t    else if (binding)\n-\t      old = select_decl (binding, LOOKUP_PREFER_TYPES);\n-            else\n-              old = NULL_TREE;\n-\n-\t    if (old)\n+\n+\t    if (binding && (binding->type\n+\t\t\t    || (binding->value \n+\t\t\t\t&& DECL_DECLARES_TYPE_P (binding->value))))\n \t      {\n+\t\ttree old;\n+\t\t\n+\t\t/* If we just skipped past a template parameter level,\n+\t\t   even though THISLEVEL_ONLY, and we find a template\n+\t\t   class declaration, then we use the _TYPE node for the\n+\t\t   template.  See the example below.  */\n+\t\tif (thislevel_only && !allow_template_parms_p\n+\t\t    && binding->value\n+\t\t    && DECL_CLASS_TEMPLATE_P (binding->value))\n+\t\t  old = binding->value;\n+\t\telse\n+\t\t  old = binding->type ? binding->type : binding->value;\n+\n \t\t/* We've found something at this binding level.  If it is\n \t\t   a typedef, extract the tag it refers to.  Lookup fails\n \t\t   if the typedef doesn't refer to a taggable type.  */\n@@ -3493,8 +3499,9 @@ merge_functions (tree s1, tree s2)\n    XXX In what way should I treat extern declarations?\n    XXX I don't want to repeat the entire duplicate_decls here */\n \n-static cxx_binding *\n-ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n+static void\n+ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n+\t\tint flags)\n {\n   tree val, type;\n   my_friendly_assert (old != NULL, 393);\n@@ -3568,7 +3575,6 @@ ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n           error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n         }\n     }\n-  return old;\n }\n \n /* Return the declarations that are members of the namespace NS.  */\n@@ -3618,7 +3624,7 @@ lookup_namespace_name (tree namespace, tree name)\n {\n   tree val;\n   tree template_id = NULL_TREE;\n-  cxx_binding binding;\n+  struct scope_binding binding = EMPTY_SCOPE_BINDING;\n \n   timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n@@ -3648,7 +3654,6 @@ lookup_namespace_name (tree namespace, tree name)\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n \n-  cxx_binding_clear (&binding);\n   if (!qualified_lookup_using_namespace (name, namespace, &binding, 0))\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n@@ -3695,7 +3700,7 @@ lookup_namespace_name (tree namespace, tree name)\n /* Select the right _DECL from multiple choices.  */\n \n static tree\n-select_decl (cxx_binding *binding, int flags)\n+select_decl (const struct scope_binding *binding, int flags)\n {\n   tree val;\n   val = binding->value;\n@@ -3714,9 +3719,8 @@ select_decl (cxx_binding *binding, int flags)\n   if (binding->type && (!val || (flags & LOOKUP_PREFER_TYPES)))\n     val = binding->type;\n   /* Don't return non-types if we really prefer types.  */\n-  else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n-\t   && (TREE_CODE (val) != TEMPLATE_DECL\n-\t       || !DECL_CLASS_TEMPLATE_P (val)))\n+  else if (val && LOOKUP_TYPES_ONLY (flags) \n+\t   && ! DECL_DECLARES_TYPE_P (val))\n     val = NULL_TREE;\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n@@ -3733,10 +3737,9 @@ unqualified_namespace_lookup (tree name, int flags)\n   tree siter;\n   struct cp_binding_level *level;\n   tree val = NULL_TREE;\n-  cxx_binding binding;\n+  struct scope_binding binding = EMPTY_SCOPE_BINDING;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  cxx_binding_clear (&binding);\n \n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n@@ -3800,9 +3803,8 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n \n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n-      cxx_binding binding;\n+      struct scope_binding binding = EMPTY_SCOPE_BINDING;\n \n-      cxx_binding_clear (&binding);\n       flags |= LOOKUP_COMPLAIN;\n       if (is_type_p)\n \tflags |= LOOKUP_PREFER_TYPES;\n@@ -3828,8 +3830,8 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n    Returns false on errors.  */\n \n static bool\n-lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n-                        int flags)\n+lookup_using_namespace (tree name, struct scope_binding *val,\n+\t\t\ttree usings, tree scope, int flags)\n {\n   tree iter;\n   timevar_push (TV_NAME_LOOKUP);\n@@ -3843,7 +3845,7 @@ lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n           cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n         /* Resolve ambiguities.  */\n         if (val1)\n-          val = ambiguous_decl (name, val, val1, flags);\n+          ambiguous_decl (name, val, val1, flags);\n       }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n }\n@@ -3854,8 +3856,8 @@ lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n    or false on error.  */\n \n static bool\n-qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n-                                  int flags)\n+qualified_lookup_using_namespace (tree name, tree scope,\n+\t\t\t\t  struct scope_binding *result, int flags)\n {\n   /* Maintain a list of namespaces visited...  */\n   tree seen = NULL_TREE;\n@@ -3872,7 +3874,7 @@ qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n \tcxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n       seen = tree_cons (scope, NULL_TREE, seen);\n       if (binding)\n-        result = ambiguous_decl (name, result, binding, flags);\n+        ambiguous_decl (name, result, binding, flags);\n \n       /* Consider strong using directives always, and non-strong ones\n \t if we haven't found a binding yet.  ??? Shouldn't we consider"}]}