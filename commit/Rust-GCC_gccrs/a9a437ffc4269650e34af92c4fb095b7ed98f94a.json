{"sha": "a9a437ffc4269650e34af92c4fb095b7ed98f94a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhNDM3ZmZjNDI2OTY1MGUzNGFmOTJjNGZiMDk1YjdlZDk4Zjk0YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-17T12:36:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-17T12:36:41Z"}, "message": "tree-ssa-strlen: Fix up count_nonzero_bytes* [PR94015]\n\nAs I said already yesterday in another PR, I'm afraid the mixing of apples\nand oranges (what we are actually computing, whether what bytes are zero or\nnon-zero in the native representation of EXP itself or what EXP points to)\nin a single function where it performs some handling which must be specific\nto one or the other case unconditionally and only from time to time\ndetermines something based on if nbytes is 0 or not will continue to bite us\nagain and again.\nSo, this patch performs at least a partial cleanup to separate those two\ncases into two functions.\nIn addition to the separation, the patch uses e.g. ctor_for_folding so that\nit does handle volatile loads properly and various other checks instead of\ndirectly using DECL_INITIAL or does guard native_encode_expr call the way it\nis guarded elsewhere (that host and target byte sizes are expected).\n\nI've left other issues I found as is for now, like the *allnonnul being IMHO\nwrongly computed (if we don't know anything about the bytes, such as if\n_1 = MEM[s_2(D)];\nMEM[whatever] = _1;\nwhere nothing really is known about strlen(s) etc., the code right now\nclears *nulterm and *allnul, but keeps *allnonnull set), but the callers\nseem to never use that value for anything (so the question is why is it\ncomputed and how exactly should it be defined).  Another thing I find quite\nweird is the distinction between count_nonzero_bytes failing (return false)\nand when it succeeds, but sets values to a don't know state (the warning is\nonly issued if it succeeds), plus what lenrange[2] is for.  The size of the\nstore should be visible already from the store statement.  Also the looking\nat the type of the MEM_REF first operand to determine if it is is_char_store\nis really weird, because both in user code and through sccvn where pointer\nconversions are useless the type of the MEM_REF operand doesn't have to have\nanything to do with what the code actually does.\n\n2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/94015\n\t* tree-ssa-strlen.c (count_nonzero_bytes): Split portions of the\n\tfunction where EXP is address of the bytes being stored rather than\n\tthe bytes themselves into count_nonzero_bytes_addr.  Punt on zero\n\tsized MEM_REF.  Use VAR_P macro and handle CONST_DECL like VAR_DECLs.\n\tUse ctor_for_folding instead of looking at DECL_INITIAL.  Punt before\n\tcalling native_encode_expr if host or target doesn't have 8-bit\n\tchars.  Formatting fixes.\n\t(count_nonzero_bytes_addr): New function.\n\n\t* gcc.dg/pr94015.c: New test.", "tree": {"sha": "477f7c4ccbcffabba6fa3732d506e543c779f371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/477f7c4ccbcffabba6fa3732d506e543c779f371"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9a437ffc4269650e34af92c4fb095b7ed98f94a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a437ffc4269650e34af92c4fb095b7ed98f94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a437ffc4269650e34af92c4fb095b7ed98f94a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a437ffc4269650e34af92c4fb095b7ed98f94a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5db0eb95c341d03d27b6893b22230ec8d4cb92e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5db0eb95c341d03d27b6893b22230ec8d4cb92e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5db0eb95c341d03d27b6893b22230ec8d4cb92e0"}], "stats": {"total": 358, "additions": 254, "deletions": 104}, "files": [{"sha": "c51606cf53e5b7a5c6c68193b103285eac5dd76e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9a437ffc4269650e34af92c4fb095b7ed98f94a", "patch": "@@ -1,3 +1,15 @@\n+2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/94015\n+\t* tree-ssa-strlen.c (count_nonzero_bytes): Split portions of the\n+\tfunction where EXP is address of the bytes being stored rather than\n+\tthe bytes themselves into count_nonzero_bytes_addr.  Punt on zero\n+\tsized MEM_REF.  Use VAR_P macro and handle CONST_DECL like VAR_DECLs.\n+\tUse ctor_for_folding instead of looking at DECL_INITIAL.  Punt before\n+\tcalling native_encode_expr if host or target doesn't have 8-bit\n+\tchars.  Formatting fixes.\n+\t(count_nonzero_bytes_addr): New function.\n+\n 2020-03-17  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n             Mihail Ionescu  <mihail.ionescu@arm.com>\n             Srinath Parvathaneni  <srinath.parvathaneni@arm.com>"}, {"sha": "a389a6a1a14d7828ced4b5c4987f4931b3ec1cd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9a437ffc4269650e34af92c4fb095b7ed98f94a", "patch": "@@ -1,3 +1,8 @@\n+2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/94015\n+\t* gcc.dg/pr94015.c: New test.\n+\n 2020-03-17  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n             Mihail Ionescu  <mihail.ionescu@arm.com>\n             Srinath Parvathaneni  <srinath.parvathaneni@arm.com>"}, {"sha": "2c91b23583417323b74b609bed941ff97c9983d6", "filename": "gcc/testsuite/gcc.dg/pr94015.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94015.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94015.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94015.c?ref=a9a437ffc4269650e34af92c4fb095b7ed98f94a", "patch": "@@ -0,0 +1,107 @@\n+/* PR tree-optimization/94015 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+char buf[10] = \"AAAAAAAAA\";\n+\n+__attribute__((noipa)) char *\n+alloc (void)\n+{\n+  return buf;\n+}\n+\n+__attribute__((noipa)) void\n+f1 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"1234567\";\n+  s[7] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f2 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"123456\";\n+  s[6] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f3 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"12345\";\n+  s[5] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f4 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"1234\";\n+  s[4] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f5 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"123\";\n+  s[3] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f6 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"12\";\n+  s[2] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f7 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"1\";\n+  s[1] = '\\0';\n+}\n+\n+__attribute__((noipa)) void\n+f8 (void)\n+{\n+  char *s = alloc ();\n+  *(char **)s = \"\";\n+  s[0] = '\\0';\n+}\n+\n+int\n+main ()\n+{\n+  if (sizeof (char *) > 8)\n+    return 0;\n+  f1 ();\n+  if (buf[7] != 0)\n+    __builtin_abort ();\n+  f2 ();\n+  if (buf[6] != 0)\n+    __builtin_abort ();\n+  f3 ();\n+  if (buf[5] != 0)\n+    __builtin_abort ();\n+  f4 ();\n+  if (buf[4] != 0)\n+    __builtin_abort ();\n+  f5 ();\n+  if (buf[3] != 0)\n+    __builtin_abort ();\n+  f6 ();\n+  if (buf[2] != 0)\n+    __builtin_abort ();\n+  f7 ();\n+  if (buf[1] != 0)\n+    __builtin_abort ();\n+  f8 ();\n+  if (buf[0] != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "7fcc6107857b3ebf1c2a478a82620960cccd1c62", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 130, "deletions": 104, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a437ffc4269650e34af92c4fb095b7ed98f94a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=a9a437ffc4269650e34af92c4fb095b7ed98f94a", "patch": "@@ -4605,6 +4605,11 @@ int ssa_name_limit_t::next_ssa_name (tree ssa_name)\n   return 0;\n }\n \n+static bool\n+count_nonzero_bytes_addr (tree, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\t  unsigned [3], bool *, bool *, bool *,\n+\t\t\t  const vr_values *, ssa_name_limit_t &);\n+\n /* Determines the minimum and maximum number of leading non-zero bytes\n    in the representation of EXP and set LENRANGE[0] and LENRANGE[1]\n    to each.\n@@ -4627,102 +4632,6 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t\t     bool *allnul, bool *allnonnul, const vr_values *rvals,\n \t\t     ssa_name_limit_t &snlim)\n {\n-  int idx = get_stridx (exp);\n-  if (idx > 0)\n-    {\n-      strinfo *si = get_strinfo (idx);\n-      if (!si)\n-\treturn false;\n-\n-      /* Handle both constant lengths as well non-constant lengths\n-\t in some range.  */\n-      unsigned HOST_WIDE_INT minlen, maxlen;\n-      if (tree_fits_shwi_p (si->nonzero_chars))\n-\tminlen = maxlen = tree_to_shwi (si->nonzero_chars);\n-      else if (nbytes\n-\t       && si->nonzero_chars\n-\t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n-\t{\n-\t  const value_range_equiv *vr\n-\t    = CONST_CAST (class vr_values *, rvals)\n-\t    ->get_value_range (si->nonzero_chars);\n-\t  if (vr->kind () != VR_RANGE\n-\t      || !range_int_cst_p (vr))\n-\t    return false;\n-\n-\t minlen = tree_to_uhwi (vr->min ());\n-\t maxlen = tree_to_uhwi (vr->max ());\n-\t}\n-      else\n-\treturn false;\n-\n-      if (maxlen < offset)\n-\treturn false;\n-\n-      minlen = minlen < offset ? 0 : minlen - offset;\n-      maxlen -= offset;\n-      if (maxlen + 1 < nbytes)\n-\treturn false;\n-\n-      if (!nbytes\n-\t  && TREE_CODE (si->ptr) == SSA_NAME\n-\t  && !POINTER_TYPE_P (TREE_TYPE (si->ptr)))\n-\t{\n-\t  /* SI->PTR is an SSA_NAME with a DEF_STMT like\n-\t       _1 = MEM <unsigned int> [(char * {ref-all})s_4(D)];  */\n-\t  gimple *stmt = SSA_NAME_DEF_STMT (exp);\n-\t  if (gimple_assign_single_p (stmt)\n-\t      && gimple_assign_rhs_code (stmt) == MEM_REF)\n-\t    {\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\t      if (tree refsize = TYPE_SIZE_UNIT (TREE_TYPE (rhs)))\n-\t\tif (tree_fits_uhwi_p (refsize))\n-\t\t  {\n-\t\t    nbytes = tree_to_uhwi (refsize);\n-\t\t    maxlen = nbytes;\n-\t\t  }\n-\t    }\n-\n-\t  if (!nbytes)\n-\t    return false;\n-\t}\n-\n-      if (nbytes <= minlen)\n-\t*nulterm = false;\n-\n-      if (nbytes < minlen)\n-\t{\n-\t  minlen = nbytes;\n-\t  if (nbytes < maxlen)\n-\t    maxlen = nbytes;\n-\t}\n-\n-      if (minlen < lenrange[0])\n-\tlenrange[0] = minlen;\n-      if (lenrange[1] < maxlen)\n-\tlenrange[1] = maxlen;\n-\n-      if (lenrange[2] < nbytes)\n-\tlenrange[2] = nbytes;\n-\n-      /* Since only the length of the string are known and not its contents,\n-\t clear ALLNUL and ALLNONNUL purely on the basis of the length.  */\n-      *allnul = false;\n-      if (minlen < nbytes)\n-\t*allnonnul = false;\n-\n-      return true;\n-    }\n-\n-  if (TREE_CODE (exp) == ADDR_EXPR)\n-    {\n-      /* If the size of the access hasn't been determined yet it's that\n-\t of a pointer.  */\n-      if (!nbytes)\n-\tnbytes = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n-\n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n       /* Handle non-zero single-character stores specially.  */\n@@ -4778,8 +4687,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n       tree arg = TREE_OPERAND (exp, 0);\n       tree off = TREE_OPERAND (exp, 1);\n \n-      if (TREE_CODE (off) != INTEGER_CST\n-\t  || !tree_fits_uhwi_p (off))\n+      if (TREE_CODE (off) != INTEGER_CST || !tree_fits_uhwi_p (off))\n \treturn false;\n \n       unsigned HOST_WIDE_INT wioff = tree_to_uhwi (off);\n@@ -4796,15 +4704,17 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n       if (!typesize || !tree_fits_uhwi_p (typesize))\n \treturn false;\n       nbytes = tree_to_uhwi (typesize);\n+      if (!nbytes)\n+\treturn false;\n \n       /* Handle MEM_REF = SSA_NAME types of assignments.  */\n-      return count_nonzero_bytes (arg, offset, nbytes, lenrange, nulterm,\n-\t\t\t\t  allnul, allnonnul, rvals, snlim);\n+      return count_nonzero_bytes_addr (arg, offset, nbytes, lenrange, nulterm,\n+\t\t\t\t       allnul, allnonnul, rvals, snlim);\n     }\n \n-  if (TREE_CODE (exp) == VAR_DECL && TREE_READONLY (exp))\n+  if (VAR_P (exp) || TREE_CODE (exp) == CONST_DECL)\n     {\n-      exp = DECL_INITIAL (exp);\n+      exp = ctor_for_folding (exp);\n       if (!exp)\n \treturn false;\n     }\n@@ -4831,6 +4741,8 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n   unsigned char buf[256];\n   if (!prep)\n     {\n+      if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n+\treturn false;\n       /* If the pointer to representation hasn't been set above\n \t for STRING_CST point it at the buffer.  */\n       prep = reinterpret_cast <char *>(buf);\n@@ -4874,8 +4786,8 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n   if (n)\n     {\n       /* When the initial number of non-zero bytes N is non-zero, reset\n-       *ALLNUL; if N is less than that the size of the representation\n-       also clear *ALLNONNUL.  */\n+\t *ALLNUL; if N is less than that the size of the representation\n+\t also clear *ALLNONNUL.  */\n       *allnul = false;\n       if (n < nbytes)\n \t*allnonnul = false;\n@@ -4901,6 +4813,120 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n   return true;\n }\n \n+/* Like count_nonzero_bytes, but instead of counting bytes in EXP, count\n+   bytes that are pointed to by EXP, which should be a pointer.  */\n+\n+static bool\n+count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n+\t\t\t  unsigned HOST_WIDE_INT nbytes,\n+\t\t\t  unsigned lenrange[3], bool *nulterm,\n+\t\t\t  bool *allnul, bool *allnonnul,\n+\t\t\t  const vr_values *rvals, ssa_name_limit_t &snlim)\n+{\n+  int idx = get_stridx (exp);\n+  if (idx > 0)\n+    {\n+      strinfo *si = get_strinfo (idx);\n+      if (!si)\n+\treturn false;\n+\n+      /* Handle both constant lengths as well non-constant lengths\n+\t in some range.  */\n+      unsigned HOST_WIDE_INT minlen, maxlen;\n+      if (tree_fits_shwi_p (si->nonzero_chars))\n+\tminlen = maxlen = tree_to_shwi (si->nonzero_chars);\n+      else if (si->nonzero_chars\n+\t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n+\t{\n+\t  vr_values *v = CONST_CAST (vr_values *, rvals);\n+\t  const value_range_equiv *vr = v->get_value_range (si->nonzero_chars);\n+\t  if (vr->kind () != VR_RANGE || !range_int_cst_p (vr))\n+\t    return false;\n+\n+\t  minlen = tree_to_uhwi (vr->min ());\n+\t  maxlen = tree_to_uhwi (vr->max ());\n+\t}\n+      else\n+\treturn false;\n+\n+      if (maxlen < offset)\n+\treturn false;\n+\n+      minlen = minlen < offset ? 0 : minlen - offset;\n+      maxlen -= offset;\n+      if (maxlen + 1 < nbytes)\n+\treturn false;\n+\n+      if (nbytes <= minlen)\n+\t*nulterm = false;\n+\n+      if (nbytes < minlen)\n+\t{\n+\t  minlen = nbytes;\n+\t  if (nbytes < maxlen)\n+\t    maxlen = nbytes;\n+\t}\n+\n+      if (minlen < lenrange[0])\n+\tlenrange[0] = minlen;\n+      if (lenrange[1] < maxlen)\n+\tlenrange[1] = maxlen;\n+\n+      if (lenrange[2] < nbytes)\n+\tlenrange[2] = nbytes;\n+\n+      /* Since only the length of the string are known and not its contents,\n+\t clear ALLNUL and ALLNONNUL purely on the basis of the length.  */\n+      *allnul = false;\n+      if (minlen < nbytes)\n+\t*allnonnul = false;\n+\n+      return true;\n+    }\n+\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    return count_nonzero_bytes (TREE_OPERAND (exp, 0), offset, nbytes,\n+\t\t\t\tlenrange, nulterm, allnul, allnonnul, rvals,\n+\t\t\t\tsnlim);\n+\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (exp);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  /* Avoid processing an SSA_NAME that has already been visited\n+\t     or if an SSA_NAME limit has been reached.  Indicate success\n+\t     if the former and failure if the latter.  */\n+\t  if (int res = snlim.next_ssa_name (exp))\n+\t    return res > 0;\n+\n+\t  /* Determine the minimum and maximum from the PHI arguments.  */\n+\t  unsigned int n = gimple_phi_num_args (stmt);\n+\t  for (unsigned i = 0; i != n; i++)\n+\t    {\n+\t      tree def = gimple_phi_arg_def (stmt, i);\n+\t      if (!count_nonzero_bytes_addr (def, offset, nbytes, lenrange,\n+\t\t\t\t\t     nulterm, allnul, allnonnul, rvals,\n+\t\t\t\t\t     snlim))\n+\t\treturn false;\n+\t    }\n+\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Otherwise we don't know anything.  */\n+  lenrange[0] = 0;\n+  if (lenrange[1] < nbytes)\n+    lenrange[1] = nbytes;\n+  if (lenrange[2] < nbytes)\n+    lenrange[2] = nbytes;\n+  *nulterm = false;\n+  *allnul = false;\n+  *allnonnul = false;\n+  return true;\n+}\n+\n /* Same as above except with an implicit SSA_NAME limit.  RVALS is used\n    to determine ranges of dynamically computed string lengths (the results\n    of strlen).  */"}]}