{"sha": "e54273ebeca55f85a6d35b48ac5f5c8a808a25ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0MjczZWJlY2E1NWY4NWE2ZDM1YjQ4YWM1ZjVjOGE4MDhhMjVlZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-09-15T14:41:43Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-09-15T14:41:43Z"}, "message": "bfin.c (struct loop_info): New members block_bitmap and bad.\n\n\t* config/bfin/bfin.c (struct loop_info): New members block_bitmap and\n\tbad.\n\t(struct loop_work and related VEC declarations): Delete.\n\t(bfin_dump_loops): Print out new member bad.\n\t(bfin_bb_in_loop): Use plain bitmap test.  Don't recurse.\n\t(bfin_scan_loop): Don't recurse.\n\t(bfin_optimize_loop): Don't use a loop depth of -1 to indicate bad\n\tloops.  No longer need to update outer loops if the current one is\n\tfound bad.  Move some validitiy checks to bfin_discover_loop.\n\t(bfin_discover_loop): New function, mostly split from bfin_reorg_loops,\n\tbut changed not to check for nesting.  Also changed to use the new bad\n\tflag.\n\t(bfin_reorg_loops): Use bfin_discover_loop to find single loops one at a\n\ttime.  Use bitmap based test to discover loop nesting.\n\nFrom-SVN: r116972", "tree": {"sha": "5d43d34de617c8f2b978eb593bca0382e7c2544e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d43d34de617c8f2b978eb593bca0382e7c2544e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee/comments", "author": null, "committer": null, "parents": [{"sha": "61943a216576f8e1f7de347d2ef56883e2b746d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61943a216576f8e1f7de347d2ef56883e2b746d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61943a216576f8e1f7de347d2ef56883e2b746d8"}], "stats": {"total": 419, "additions": 208, "deletions": 211}, "files": [{"sha": "afcb7d2afb7e4e1e29b6ba7f31c20d20dc524920", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e54273ebeca55f85a6d35b48ac5f5c8a808a25ee", "patch": "@@ -11,6 +11,21 @@\n \n \t* cfgrtl.c (emit_insn_at_entry): Use gcc_assert, not abort.\n \n+\t* config/bfin/bfin.c (struct loop_info): New members block_bitmap and\n+\tbad.\n+\t(struct loop_work and related VEC declarations): Delete.\n+\t(bfin_dump_loops): Print out new member bad.\n+\t(bfin_bb_in_loop): Use plain bitmap test.  Don't recurse.\n+\t(bfin_scan_loop): Don't recurse.\n+\t(bfin_optimize_loop): Don't use a loop depth of -1 to indicate bad\n+\tloops.  No longer need to update outer loops if the current one is\n+\tfound bad.  Move some validitiy checks to bfin_discover_loop.\n+\t(bfin_discover_loop): New function, mostly split from bfin_reorg_loops,\n+\tbut changed not to check for nesting.  Also changed to use the new bad\n+\tflag.\n+\t(bfin_reorg_loops): Use bfin_discover_loop to find single loops one at a\n+\ttime.  Use bitmap based test to discover loop nesting.\n+\n 2006-09-15  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* doc/tm.texi (TARGET_FUNCTION_VALUE): Put @deftypefn all in"}, {"sha": "f7cf0205fef786a402cbc185bc3a8f0fd78d9bd3", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 193, "deletions": 211, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54273ebeca55f85a6d35b48ac5f5c8a808a25ee/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e54273ebeca55f85a6d35b48ac5f5c8a808a25ee", "patch": "@@ -2797,9 +2797,12 @@ struct loop_info GTY (())\n   /* The length of the loop.  */\n   int length;\n \n-  /* The nesting depth of the loop.  Set to -1 for a bad loop.  */\n+  /* The nesting depth of the loop.  */\n   int depth;\n \n+  /* Nonzero if we can't optimize this loop.  */\n+  int bad;\n+\n   /* True if we have visited this loop.  */\n   int visited;\n \n@@ -2815,28 +2818,17 @@ struct loop_info GTY (())\n   /* Immediate outer loop of this loop.  */\n   struct loop_info *outer;\n \n-  /* Vector of blocks only within the loop, (excluding those within\n-     inner loops).  */\n+  /* Vector of blocks only within the loop, including those within\n+     inner loops.  */\n   VEC (basic_block,heap) *blocks;\n \n+  /* Same information in a bitmap.  */\n+  bitmap block_bitmap;\n+\n   /* Vector of inner loops within this loop  */\n   VEC (loop_info,heap) *loops;\n };\n \n-/* Information used during loop detection.  */\n-typedef struct loop_work GTY(())\n-{\n-  /* Basic block to be scanned.  */\n-  basic_block block;\n-\n-  /* Loop it will be within.  */\n-  loop_info loop;\n-} loop_work;\n-\n-/* Work list.  */\n-DEF_VEC_O (loop_work);\n-DEF_VEC_ALLOC_O (loop_work,heap);\n-\n static void\n bfin_dump_loops (loop_info loops)\n {\n@@ -2849,6 +2841,8 @@ bfin_dump_loops (loop_info loops)\n       unsigned ix;\n \n       fprintf (dump_file, \";; loop %d: \", loop->loop_no);\n+      if (loop->bad)\n+\tfprintf (dump_file, \"(bad) \");\n       fprintf (dump_file, \"{head:%d, depth:%d}\", loop->head->index, loop->depth);\n \n       fprintf (dump_file, \" blocks: [ \");\n@@ -2870,19 +2864,7 @@ bfin_dump_loops (loop_info loops)\n static bool\n bfin_bb_in_loop (loop_info loop, basic_block bb)\n {\n-  unsigned ix;\n-  loop_info inner;\n-  basic_block b;\n-\n-  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n-    if (b == bb)\n-      return true;\n-\n-  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n-    if (bfin_bb_in_loop (inner, bb))\n-      return true;\n-\n-  return false;\n+  return bitmap_bit_p (loop->block_bitmap, bb->index);\n }\n \n /* Scan the blocks of LOOP (and its inferiors) looking for uses of\n@@ -2893,7 +2875,6 @@ static bool\n bfin_scan_loop (loop_info loop, rtx reg, rtx loop_end)\n {\n   unsigned ix;\n-  loop_info inner;\n   basic_block bb;\n \n   for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n@@ -2912,10 +2893,6 @@ bfin_scan_loop (loop_info loop, rtx reg, rtx loop_end)\n \t    return true;\n \t}\n     }\n-  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n-    if (bfin_scan_loop (inner, reg, NULL_RTX))\n-      return true;\n-\n   return false;\n }\n \n@@ -2925,7 +2902,7 @@ static void\n bfin_optimize_loop (loop_info loop)\n {\n   basic_block bb;\n-  loop_info inner, outer;\n+  loop_info inner;\n   rtx insn, init_insn, last_insn, nop_insn;\n   rtx loop_init, start_label, end_label;\n   rtx reg_lc0, reg_lc1, reg_lt0, reg_lt1, reg_lb0, reg_lb1;\n@@ -2935,71 +2912,40 @@ bfin_optimize_loop (loop_info loop)\n   int length;\n   unsigned ix;\n   int inner_depth = 0;\n-  int inner_num;\n-  int bb_num;\n \n   if (loop->visited)\n     return;\n \n   loop->visited = 1;\n \n-  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n-    {\n-      if (inner->loop_no == loop->loop_no)\n-\tloop->depth = -1;\n-      else\n-\tbfin_optimize_loop (inner);\n-\n-      if (inner->depth < 0 || inner->depth > MAX_LOOP_DEPTH)\n-\t{\n-\t  inner->outer = NULL;\n-\t  VEC_ordered_remove (loop_info, loop->loops, ix);\n-\t}\n-\n-      if (inner_depth < inner->depth)\n-\tinner_depth = inner->depth;\n-\n-      loop->clobber_loop0 |= inner->clobber_loop0;\n-      loop->clobber_loop1 |= inner->clobber_loop1;\n-    }\n-\n-  if (loop->depth < 0)\n+  if (loop->bad)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d bad when found\\n\", loop->loop_no);\n       goto bad_loop;\n     }\n \n-  loop->depth = inner_depth + 1;\n-  if (loop->depth > MAX_LOOP_DEPTH)\n+  /* Every loop contains in its list of inner loops every loop nested inside\n+     it, even if there are intermediate loops.  This works because we're doing\n+     a depth-first search here and never visit a loop more than once.  */\n+  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; loop %d too deep\\n\", loop->loop_no);\n-      goto bad_loop;\n-    }\n+      bfin_optimize_loop (inner);\n \n-  /* Make sure we only have one entry point.  */\n-  if (EDGE_COUNT (loop->head->preds) == 2)\n-    {\n-      loop->predecessor = EDGE_PRED (loop->head, 0)->src;\n-      if (loop->predecessor == loop->tail)\n-\t/* We wanted the other predecessor.  */\n-\tloop->predecessor = EDGE_PRED (loop->head, 1)->src;\n-\n-      /* We can only place a loop insn on a fall through edge of a\n-\t single exit block.  */\n-      if (EDGE_COUNT (loop->predecessor->succs) != 1\n-\t  || !(EDGE_SUCC (loop->predecessor, 0)->flags & EDGE_FALLTHRU)\n-\t  /* If loop->predecessor is in loop, loop->head is not really\n-\t     the head of the loop.  */\n-\t  || bfin_bb_in_loop (loop, loop->predecessor))\n-\tloop->predecessor = NULL;\n+      if (!inner->bad && inner_depth < inner->depth)\n+\t{\n+\t  inner_depth = inner->depth;\n+\n+\t  loop->clobber_loop0 |= inner->clobber_loop0;\n+\t  loop->clobber_loop1 |= inner->clobber_loop1;\n+\t}\n     }\n \n-  if (loop->predecessor == NULL)\n+  loop->depth = inner_depth + 1;\n+  if (loop->depth > MAX_LOOP_DEPTH)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \";; loop %d has bad predecessor\\n\", loop->loop_no);\n+\tfprintf (dump_file, \";; loop %d too deep\\n\", loop->loop_no);\n       goto bad_loop;\n     }\n \n@@ -3264,49 +3210,7 @@ bfin_optimize_loop (loop_info loop)\n   if (dump_file)\n     fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n \n-  /* Mark this loop bad.  */\n-  if (loop->depth <= MAX_LOOP_DEPTH)\n-    loop->depth = -1;\n-\n-  outer = loop->outer;\n-\n-  /* Move all inner loops to loop's outer loop.  */\n-  inner_num = VEC_length (loop_info, loop->loops);\n-  if (inner_num)\n-    {\n-      loop_info l;\n-\n-      if (outer)\n-\tVEC_reserve (loop_info, heap, outer->loops, inner_num);\n-\n-      for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, l); ix++)\n-\t{\n-\t  l->outer = outer;\n-\t  if (outer)\n-\t    VEC_quick_push (loop_info, outer->loops, l);\n-\t}\n-\n-      VEC_free (loop_info, heap, loop->loops);\n-    }\n-\n-  /* Move all blocks to loop's outer loop.  */\n-  bb_num = VEC_length (basic_block, loop->blocks);\n-  if (bb_num)\n-    {\n-      basic_block b;\n-\n-      if (outer)\n-\tVEC_reserve (basic_block, heap, outer->blocks, bb_num);\n-\n-      for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n-\t{\n-\t  b->aux = outer;\n-\t  if (outer)\n-\t    VEC_quick_push (basic_block, outer->blocks, b);\n-\t}\n-\n-      VEC_free (basic_block, heap, loop->blocks);\n-    }\n+  loop->bad = 1;\n \n   if (DPREG_P (loop->iter_reg))\n     {\n@@ -3331,18 +3235,146 @@ bfin_optimize_loop (loop_info loop)\n     }\n }\n \n+/* Called from bfin_reorg_loops when a potential loop end is found.  LOOP is\n+   a newly set up structure describing the loop, it is this function's\n+   responsibility to fill most of it.  TAIL_BB and TAIL_INSN point to the\n+   loop_end insn and its enclosing basic block.  */\n+\n+static void\n+bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n+{\n+  unsigned dwork = 0;\n+  basic_block bb;\n+  VEC (basic_block,heap) *works = VEC_alloc (basic_block,heap,20);\n+\n+  loop->tail = tail_bb;\n+  loop->head = BRANCH_EDGE (tail_bb)->dest;\n+  loop->successor = FALLTHRU_EDGE (tail_bb)->dest;\n+  loop->predecessor = NULL;\n+  loop->loop_end = tail_insn;\n+  loop->last_insn = NULL_RTX;\n+  loop->iter_reg = SET_DEST (XVECEXP (PATTERN (tail_insn), 0, 1));\n+  loop->depth = loop->length = 0;\n+  loop->visited = 0;\n+  loop->clobber_loop0 = loop->clobber_loop1 = 0;\n+  loop->outer = NULL;\n+  loop->loops = NULL;\n+\n+  loop->init = loop->loop_init = NULL_RTX;\n+  loop->start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (tail_insn), 0, 0)), 1), 0);\n+  loop->end_label = NULL_RTX;\n+  loop->bad = 0;\n+\n+  VEC_safe_push (basic_block, heap, works, loop->head);\n+\n+  while (VEC_iterate (basic_block, works, dwork++, bb))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      if (bb == EXIT_BLOCK_PTR)\n+\t{\n+\t  /* We've reached the exit block.  The loop must be bad. */\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \";; Loop is bad - reached exit block while scanning\\n\");\n+\t  loop->bad = 1;\n+\t  break;\n+\t}\n+\n+      if (bitmap_bit_p (loop->block_bitmap, bb->index))\n+\tcontinue;\n+\n+      /* We've not seen this block before.  Add it to the loop's\n+\t list and then add each successor to the work list.  */\n+\n+      VEC_safe_push (basic_block, heap, loop->blocks, bb);\n+      bitmap_set_bit (loop->block_bitmap, bb->index);\n+\n+      if (bb != tail_bb)\n+\t{\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      basic_block succ = EDGE_SUCC (bb, ei.index)->dest;\n+\t      if (!REGNO_REG_SET_P (succ->il.rtl->global_live_at_start,\n+\t\t\t\t    REGNO (loop->iter_reg)))\n+\t\tcontinue;\n+\t      if (!VEC_space (basic_block, works, 1))\n+\t\t{\n+\t\t  if (dwork)\n+\t\t    {\n+\t\t      VEC_block_remove (basic_block, works, 0, dwork);\n+\t\t      dwork = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    VEC_reserve (basic_block, heap, works, 1);\n+\t\t}\n+\t      VEC_quick_push (basic_block, works, succ);\n+\t    }\n+\t}\n+    }\n+\n+  if (!loop->bad)\n+    {\n+      /* Make sure we only have one entry point.  */\n+      if (EDGE_COUNT (loop->head->preds) == 2)\n+\t{\n+\t  loop->predecessor = EDGE_PRED (loop->head, 0)->src;\n+\t  if (loop->predecessor == loop->tail)\n+\t    /* We wanted the other predecessor.  */\n+\t    loop->predecessor = EDGE_PRED (loop->head, 1)->src;\n+\n+\t  /* We can only place a loop insn on a fall through edge of a\n+\t     single exit block.  */\n+\t  if (EDGE_COUNT (loop->predecessor->succs) != 1\n+\t      || !(EDGE_SUCC (loop->predecessor, 0)->flags & EDGE_FALLTHRU)\n+\t      /* If loop->predecessor is in loop, loop->head is not really\n+\t\t the head of the loop.  */\n+\t      || bfin_bb_in_loop (loop, loop->predecessor))\n+\t    loop->predecessor = NULL;\n+\t}\n+\n+      if (loop->predecessor == NULL)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop has bad predecessor\\n\");\n+\t  loop->bad = 1;\n+\t}\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  /* Make sure nothing jumps into this loop.  This shouldn't happen as we\n+     wouldn't have generated the counted loop patterns in such a case.\n+     However, this test must be done after the test above to detect loops\n+     with invalid headers.  */\n+  if (!loop->bad)\n+    for (dwork = 0; VEC_iterate (basic_block, loop->blocks, dwork, bb); dwork++)\n+      {\n+\tedge e;\n+\tedge_iterator ei;\n+\tif (bb == loop->head)\n+\t  continue;\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  {\n+\t    basic_block pred = EDGE_PRED (bb, ei.index)->src;\n+\t    if (!bfin_bb_in_loop (loop, pred))\n+\t      abort ();\n+\t  }\n+      }\n+#endif\n+  VEC_free (basic_block, heap, works);\n+}\n+\n static void\n bfin_reorg_loops (FILE *dump_file)\n {\n+  bitmap_obstack stack;\n+  bitmap tmp_bitmap;\n   basic_block bb;\n   loop_info loops = NULL;\n   loop_info loop;\n   int nloops = 0;\n-  unsigned dwork = 0;\n-  VEC (loop_work,heap) *works = VEC_alloc (loop_work,heap,20);\n-  loop_work *work;\n-  edge e;\n-  edge_iterator ei;\n+\n+  bitmap_obstack_initialize (&stack);\n \n   /* Find all the possible loop tails.  This means searching for every\n      loop_end instruction.  For each one found, create a loop_info\n@@ -3355,37 +3387,17 @@ bfin_reorg_loops (FILE *dump_file)\n \ttail = PREV_INSN (tail);\n \n       bb->aux = NULL;\n+\n       if (INSN_P (tail) && recog_memoized (tail) == CODE_FOR_loop_end)\n \t{\n \t  /* A possible loop end */\n \n \t  loop = XNEW (struct loop_info);\n \t  loop->next = loops;\n \t  loops = loop;\n-\t  loop->tail = bb;\n-\t  loop->head = BRANCH_EDGE (bb)->dest;\n-\t  loop->successor = FALLTHRU_EDGE (bb)->dest;\n-\t  loop->predecessor = NULL;\n-\t  loop->loop_end = tail;\n-\t  loop->last_insn = NULL_RTX;\n-\t  loop->iter_reg = SET_DEST (XVECEXP (PATTERN (tail), 0, 1));\n-\t  loop->depth = loop->length = 0;\n-\t  loop->visited = 0;\n-\t  loop->clobber_loop0 = loop->clobber_loop1 = 0;\n-\t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n-\t  VEC_quick_push (basic_block, loop->blocks, bb);\n-\t  loop->outer = NULL;\n-\t  loop->loops = NULL;\n \t  loop->loop_no = nloops++;\n-\n-\t  loop->init = loop->loop_init = NULL_RTX;\n-\t  loop->start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (tail), 0, 0)), 1), 0);\n-\t  loop->end_label = NULL_RTX;\n-\n-\t  work = VEC_safe_push (loop_work, heap, works, NULL);\n-\t  work->block = loop->head;\n-\t  work->loop = loop;\n-\n+\t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n+\t  loop->block_bitmap = BITMAP_ALLOC (&stack);\n \t  bb->aux = loop;\n \n \t  if (dump_file)\n@@ -3394,75 +3406,44 @@ bfin_reorg_loops (FILE *dump_file)\n \t\t       loop->loop_no);\n \t      print_rtl_single (dump_file, tail);\n \t    }\n+\n+\t  bfin_discover_loop (loop, bb, tail);\n \t}\n     }\n \n-  /*  Now find all the closed loops.\n-      until work list empty,\n-       if block's auxptr is set\n-         if != loop slot\n-           if block's loop's start != block\n-\t     mark loop as bad\n-\t   else\n-             append block's loop's fallthrough block to worklist\n-\t     increment this loop's depth\n-       else if block is exit block\n-         mark loop as bad\n-       else\n-\t  set auxptr\n-\t  for each target of block\n-\t    add to worklist */\n-  while (VEC_iterate (loop_work, works, dwork++, work))\n+  tmp_bitmap = BITMAP_ALLOC (&stack);\n+  /* Compute loop nestings.  */\n+  for (loop = loops; loop; loop = loop->next)\n     {\n-      loop = work->loop;\n-      bb = work->block;\n-      if (bb == EXIT_BLOCK_PTR)\n-\t/* We've reached the exit block.  The loop must be bad. */\n-\tloop->depth = -1;\n-      else if (!bb->aux)\n+      loop_info other;\n+      if (loop->bad)\n+\tcontinue;\n+\n+      for (other = loop->next; other; other = other->next)\n \t{\n-\t  /* We've not seen this block before.  Add it to the loop's\n-\t     list and then add each successor to the work list.  */\n-\t  bb->aux = loop;\n-\t  VEC_safe_push (basic_block, heap, loop->blocks, bb);\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (other->bad)\n+\t    continue;\n+\n+\t  bitmap_and (tmp_bitmap, other->block_bitmap, loop->block_bitmap);\n+\t  if (bitmap_empty_p (tmp_bitmap))\n+\t    continue;\n+\t  if (bitmap_equal_p (tmp_bitmap, other->block_bitmap))\n \t    {\n-\t      if (!VEC_space (loop_work, works, 1))\n-\t\t{\n-\t\t  if (dwork)\n-\t\t    {\n-\t\t      VEC_block_remove (loop_work, works, 0, dwork);\n-\t\t      dwork = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    VEC_reserve (loop_work, heap, works, 1);\n-\t\t}\n-\t      work = VEC_quick_push (loop_work, works, NULL);\n-\t      work->block = EDGE_SUCC (bb, ei.index)->dest;\n-\t      work->loop = loop;\n+\t      other->outer = loop;\n+\t      VEC_safe_push (loop_info, heap, loop->loops, other);\n+\t    }\n+\t  else if (bitmap_equal_p (tmp_bitmap, loop->block_bitmap))\n+\t    {\n+\t      loop->outer = other;\n+\t      VEC_safe_push (loop_info, heap, other->loops, loop);\n \t    }\n-\t}\n-      else if (bb->aux != loop)\n-\t{\n-\t  /* We've seen this block in a different loop.  If it's not\n-\t     the other loop's head, then this loop must be bad.\n-\t     Otherwise, the other loop might be a nested loop, so\n-\t     continue from that loop's successor.  */\n-\t  loop_info other = bb->aux;\n-\n-\t  if (other->head != bb)\n-\t    loop->depth = -1;\n \t  else\n \t    {\n-\t      other->outer = loop;\n-\t      VEC_safe_push (loop_info, heap, loop->loops, other);\n-\t      work = VEC_safe_push (loop_work, heap, works, NULL);\n-\t      work->loop = loop;\n-\t      work->block = other->successor;\n+\t      loop->bad = other->bad = 1;\n \t    }\n \t}\n     }\n-  VEC_free (loop_work, heap, works);\n+  BITMAP_FREE (tmp_bitmap);\n \n   if (dump_file)\n     {\n@@ -3487,6 +3468,7 @@ bfin_reorg_loops (FILE *dump_file)\n       loops = loop->next;\n       VEC_free (loop_info, heap, loop->loops);\n       VEC_free (basic_block, heap, loop->blocks);\n+      BITMAP_FREE (loop->block_bitmap);\n       XDELETE (loop);\n     }\n "}]}