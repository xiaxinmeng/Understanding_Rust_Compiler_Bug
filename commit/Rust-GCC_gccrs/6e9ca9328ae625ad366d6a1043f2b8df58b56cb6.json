{"sha": "6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU5Y2E5MzI4YWU2MjVhZDM2NmQ2YTEwNDNmMmI4ZGY1OGI1NmNiNg==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2018-04-04T08:48:56Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-04-04T08:48:56Z"}, "message": "[NDS32] Refine movcc, cmov, cstore and cbranch patterns.\n\ngcc/\n\t* config/nds32/nds32-md-auxiliary.c (nds32_inverse_cond_code,\n\tnds32_cond_code_str, output_cond_branch,\n\toutput_cond_branch_compare_zero, nds32_expand_cbranch,\n\tnds32_expand_cstore, nds32_expand_movcc,\n\tnds32_output_cbranchsi4_equality_zero,\n\tnds32_output_cbranchsi4_equality_reg,\n\tnds32_output_cbranchsi4_equality_reg_or_const_int,\n\tnds32_output_cbranchsi4_greater_less_zero: New functions.\n\t* config/nds32/nds32-protos.h (nds32_expand_cbranch,\n\tnds32_expand_cstore, nds32_expand_movcc,\n\tnds32_output_cbranchsi4_equality_zero,\n\tnds32_output_cbranchsi4_equality_reg,\n\tnds32_output_cbranchsi4_equality_reg_or_const_int,\n\tnds32_output_cbranchsi4_greater_less_zero): Declare.\n\t* config/nds32/predicates.md (nds32_movecc_comparison_operator,\n\tnds32_rimm11s_operand): New predicates.\n\t* config/nds32/nds32.h (nds32_expand_result_type): New enum type.\n\t* config/nds32/nds32.md: Rewrite all the branch and conditional move\n\tpatterns.\n\nCo-Authored-By: Kito Cheng <kito.cheng@gmail.com>\n\nFrom-SVN: r259070", "tree": {"sha": "e5a377918a8b280b3fbb5af53e7e8c0bbd60c7c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5a377918a8b280b3fbb5af53e7e8c0bbd60c7c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ba6d58573ac8f5e9437be68df85d9651deb04db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ba6d58573ac8f5e9437be68df85d9651deb04db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ba6d58573ac8f5e9437be68df85d9651deb04db"}], "stats": {"total": 2169, "additions": 1251, "deletions": 918}, "files": [{"sha": "651523fab1ef185ab7c3912646f493862b49b0b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "patch": "@@ -1,3 +1,26 @@\n+2018-04-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito.cheng@gmail.com>\n+\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_inverse_cond_code,\n+\tnds32_cond_code_str, output_cond_branch,\n+\toutput_cond_branch_compare_zero, nds32_expand_cbranch,\n+\tnds32_expand_cstore, nds32_expand_movcc,\n+\tnds32_output_cbranchsi4_equality_zero,\n+\tnds32_output_cbranchsi4_equality_reg,\n+\tnds32_output_cbranchsi4_equality_reg_or_const_int,\n+\tnds32_output_cbranchsi4_greater_less_zero: New functions.\n+\t* config/nds32/nds32-protos.h (nds32_expand_cbranch,\n+\tnds32_expand_cstore, nds32_expand_movcc,\n+\tnds32_output_cbranchsi4_equality_zero,\n+\tnds32_output_cbranchsi4_equality_reg,\n+\tnds32_output_cbranchsi4_equality_reg_or_const_int,\n+\tnds32_output_cbranchsi4_greater_less_zero): Declare.\n+\t* config/nds32/predicates.md (nds32_movecc_comparison_operator,\n+\tnds32_rimm11s_operand): New predicates.\n+\t* config/nds32/nds32.h (nds32_expand_result_type): New enum type.\n+\t* config/nds32/nds32.md: Rewrite all the branch and conditional move\n+\tpatterns.\n+\n 2018-04-04  Kito Cheng  <kito.cheng@gmail.com>\n \n \t* config/nds32/nds32-doubleword.md: Refine all the instruction type."}, {"sha": "f707f19853027cb6c030deca95087de8db9ec42c", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 960, "deletions": 1, "changes": 961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "patch": "@@ -37,6 +37,8 @@\n #include \"output.h\"\n #include \"tm-constrs.h\"\n #include \"expr.h\"\n+#include \"emit-rtl.h\"\n+#include \"explow.h\"\n \n /* ------------------------------------------------------------------------ */\n \n@@ -76,7 +78,780 @@ nds32_byte_to_size (int byte)\n     }\n }\n \n-/* A helper function to return memory format.  */\n+static int\n+nds32_inverse_cond_code (int code)\n+{\n+  switch (code)\n+    {\n+      case NE:\n+\treturn EQ;\n+      case EQ:\n+\treturn NE;\n+      case GT:\n+\treturn LE;\n+      case LE:\n+\treturn GT;\n+      case GE:\n+\treturn LT;\n+      case LT:\n+\treturn GE;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+static const char *\n+nds32_cond_code_str (int code)\n+{\n+  switch (code)\n+    {\n+      case NE:\n+\treturn \"ne\";\n+      case EQ:\n+\treturn \"eq\";\n+      case GT:\n+\treturn \"gt\";\n+      case LE:\n+\treturn \"le\";\n+      case GE:\n+\treturn \"ge\";\n+      case LT:\n+\treturn \"lt\";\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+static void\n+output_cond_branch (int code, const char *suffix, bool r5_p,\n+\t\t    bool long_jump_p, rtx *operands)\n+{\n+  char pattern[256];\n+  const char *cond_code;\n+\n+  if (r5_p && REGNO (operands[2]) == 5 && TARGET_16_BIT)\n+    {\n+      /* This is special case for beqs38 and bnes38,\n+\t second operand 2 can't be $r5 and it's almost meanless,\n+\t however it may occur after copy propgation.  */\n+      if (code == EQ)\n+\t{\n+\t  /* $r5 == $r5 always taken! */\n+\t  if (long_jump_p)\n+\t    snprintf (pattern, sizeof (pattern),\n+\t\t      \"j\\t%%3\");\n+\t  else\n+\t    snprintf (pattern, sizeof (pattern),\n+\t\t      \"j8\\t%%3\");\n+\t}\n+      else\n+\t/* Don't output anything since $r5 != $r5 never taken! */\n+\tpattern[0] = '\\0';\n+    }\n+  else if (long_jump_p)\n+    {\n+      int inverse_code = nds32_inverse_cond_code (code);\n+      cond_code = nds32_cond_code_str (inverse_code);\n+\n+      /*      b<cond><suffix>  $r0, $r1, .L0\n+\t    =>\n+\t      b<inverse_cond><suffix>  $r0, $r1, .LCB0\n+\t      j  .L0\n+\t    .LCB0:\n+\n+\t    or\n+\n+\t      b<cond><suffix>  $r0, $r1, .L0\n+\t    =>\n+\t      b<inverse_cond><suffix>  $r0, $r1, .LCB0\n+\t      j  .L0\n+\t    .LCB0:\n+      */\n+      if (r5_p && TARGET_16_BIT)\n+\t{\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%ss38\\t %%2, .LCB%%=\\n\\tj\\t%%3\\n.LCB%%=:\",\n+\t\t    cond_code);\n+\t}\n+      else\n+\t{\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%s%s\\t%%1, %%2, .LCB%%=\\n\\tj\\t%%3\\n.LCB%%=:\",\n+\t\t    cond_code, suffix);\n+\t}\n+    }\n+  else\n+    {\n+      cond_code = nds32_cond_code_str (code);\n+      if (r5_p && TARGET_16_BIT)\n+\t{\n+\t  /* b<cond>s38  $r1, .L0   */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%ss38\\t %%2, %%3\", cond_code);\n+\t}\n+      else\n+\t{\n+\t  /* b<cond><suffix>  $r0, $r1, .L0   */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%s%s\\t%%1, %%2, %%3\", cond_code, suffix);\n+\t}\n+    }\n+\n+  output_asm_insn (pattern, operands);\n+}\n+\n+static void\n+output_cond_branch_compare_zero (int code, const char *suffix,\n+\t\t\t\t bool long_jump_p, rtx *operands,\n+\t\t\t\t bool ta_implied_p)\n+{\n+  char pattern[256];\n+  const char *cond_code;\n+  if (long_jump_p)\n+    {\n+      int inverse_code = nds32_inverse_cond_code (code);\n+      cond_code = nds32_cond_code_str (inverse_code);\n+\n+      if (ta_implied_p && TARGET_16_BIT)\n+\t{\n+\t  /*    b<cond>z<suffix>  .L0\n+\t      =>\n+\t\tb<inverse_cond>z<suffix>  .LCB0\n+\t\tj  .L0\n+\t      .LCB0:\n+\t   */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%sz%s\\t.LCB%%=\\n\\tj\\t%%2\\n.LCB%%=:\",\n+\t\t    cond_code, suffix);\n+\t}\n+      else\n+\t{\n+\t  /*      b<cond>z<suffix>  $r0, .L0\n+\t\t=>\n+\t\t  b<inverse_cond>z<suffix>  $r0, .LCB0\n+\t\t  j  .L0\n+\t\t.LCB0:\n+\t   */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%sz%s\\t%%1, .LCB%%=\\n\\tj\\t%%2\\n.LCB%%=:\",\n+\t\t    cond_code, suffix);\n+\t}\n+    }\n+  else\n+    {\n+      cond_code = nds32_cond_code_str (code);\n+      if (ta_implied_p && TARGET_16_BIT)\n+\t{\n+\t  /* b<cond>z<suffix>  .L0  */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%sz%s\\t%%2\", cond_code, suffix);\n+\t}\n+      else\n+\t{\n+\t  /* b<cond>z<suffix>  $r0, .L0  */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"b%sz%s\\t%%1, %%2\", cond_code, suffix);\n+\t}\n+    }\n+\n+  output_asm_insn (pattern, operands);\n+}\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* Auxiliary function for expand RTL pattern.  */\n+\n+enum nds32_expand_result_type\n+nds32_expand_cbranch (rtx *operands)\n+{\n+  rtx tmp_reg;\n+  enum rtx_code code;\n+\n+  code = GET_CODE (operands[0]);\n+\n+  /* If operands[2] is (const_int 0),\n+     we can use beqz,bnez,bgtz,bgez,bltz,or blez instructions.\n+     So we have gcc generate original template rtx.  */\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    if (INTVAL (operands[2]) == 0)\n+      if ((code != GTU)\n+\t  && (code != GEU)\n+\t  && (code != LTU)\n+\t  && (code != LEU))\n+\treturn EXPAND_CREATE_TEMPLATE;\n+\n+  /* For other comparison, NDS32 ISA only has slt (Set-on-Less-Than)\n+     behavior for the comparison, we might need to generate other\n+     rtx patterns to achieve same semantic.  */\n+  switch (code)\n+    {\n+    case GT:\n+    case GTU:\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  /* GT  reg_A, const_int  =>  !(LT  reg_A, const_int + 1) */\n+\t  if (optimize_size || optimize == 0)\n+\t    tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+\t  else\n+\t    tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  /* We want to plus 1 into the integer value\n+\t     of operands[2] to create 'slt' instruction.\n+\t     This caculation is performed on the host machine,\n+\t     which may be 64-bit integer.\n+\t     So the meaning of caculation result may be\n+\t     different from the 32-bit nds32 target.\n+\n+\t     For example:\n+\t       0x7fffffff + 0x1 -> 0x80000000,\n+\t       this value is POSITIVE on 64-bit machine,\n+\t       but the expected value on 32-bit nds32 target\n+\t       should be NEGATIVE value.\n+\n+\t     Hence, instead of using GEN_INT(), we use gen_int_mode() to\n+\t     explicitly create SImode constant rtx.  */\n+\t  enum rtx_code cmp_code;\n+\n+\t  rtx plus1 = gen_int_mode (INTVAL (operands[2]) + 1, SImode);\n+\t  if (satisfies_constraint_Is15 (plus1))\n+\t    {\n+\t      operands[2] = plus1;\n+\t      cmp_code = EQ;\n+\t      if (code == GT)\n+\t\t{\n+\t\t  /* GT, use slts instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slts_compare (tmp_reg, operands[1], operands[2]));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* GTU, use slt instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      cmp_code = NE;\n+\t      if (code == GT)\n+\t\t{\n+\t\t  /* GT, use slts instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slts_compare (tmp_reg, operands[2], operands[1]));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* GTU, use slt instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slt_compare  (tmp_reg, operands[2], operands[1]));\n+\t\t}\n+\t    }\n+\n+\t  PUT_CODE (operands[0], cmp_code);\n+\t  operands[1] = tmp_reg;\n+\t  operands[2] = const0_rtx;\n+\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+      else\n+\t{\n+\t  /* GT  reg_A, reg_B  =>  LT  reg_B, reg_A */\n+\t  if (optimize_size || optimize == 0)\n+\t    tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+\t  else\n+\t    tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  if (code == GT)\n+\t    {\n+\t      /* GT, use slts instruction */\n+\t      emit_insn (gen_slts_compare (tmp_reg, operands[2], operands[1]));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* GTU, use slt instruction */\n+\t      emit_insn (gen_slt_compare  (tmp_reg, operands[2], operands[1]));\n+\t    }\n+\n+\t  PUT_CODE (operands[0], NE);\n+\t  operands[1] = tmp_reg;\n+\t  operands[2] = const0_rtx;\n+\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+\n+    case GE:\n+    case GEU:\n+      /* GE  reg_A, reg_B      =>  !(LT  reg_A, reg_B) */\n+      /* GE  reg_A, const_int  =>  !(LT  reg_A, const_int) */\n+      if (optimize_size || optimize == 0)\n+\ttmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+      else\n+\ttmp_reg = gen_reg_rtx (SImode);\n+\n+      if (code == GE)\n+\t{\n+\t  /* GE, use slts instruction */\n+\t  emit_insn (gen_slts_compare (tmp_reg, operands[1], operands[2]));\n+\t}\n+      else\n+\t{\n+\t  /* GEU, use slt instruction */\n+\t  emit_insn (gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n+\t}\n+\n+      PUT_CODE (operands[0], EQ);\n+      operands[1] = tmp_reg;\n+      operands[2] = const0_rtx;\n+      emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n+\t\t\t\t operands[2], operands[3]));\n+\n+      return EXPAND_DONE;\n+\n+    case LT:\n+    case LTU:\n+      /* LT  reg_A, reg_B      =>  LT  reg_A, reg_B */\n+      /* LT  reg_A, const_int  =>  LT  reg_A, const_int */\n+      if (optimize_size || optimize == 0)\n+\ttmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+      else\n+\ttmp_reg = gen_reg_rtx (SImode);\n+\n+      if (code == LT)\n+\t{\n+\t  /* LT, use slts instruction */\n+\t  emit_insn (gen_slts_compare (tmp_reg, operands[1], operands[2]));\n+\t}\n+      else\n+\t{\n+\t  /* LTU, use slt instruction */\n+\t  emit_insn (gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n+\t}\n+\n+      PUT_CODE (operands[0], NE);\n+      operands[1] = tmp_reg;\n+      operands[2] = const0_rtx;\n+      emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n+\t\t\t\t operands[2], operands[3]));\n+\n+      return EXPAND_DONE;\n+\n+    case LE:\n+    case LEU:\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  /* LE  reg_A, const_int  =>  LT  reg_A, const_int + 1 */\n+\t  if (optimize_size || optimize == 0)\n+\t    tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+\t  else\n+\t    tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  enum rtx_code cmp_code;\n+\t  /* Note that (le:SI X INT_MAX) is not the same as (lt:SI X INT_MIN).\n+\t     We better have an assert here in case GCC does not properly\n+\t     optimize it away.  The INT_MAX here is 0x7fffffff for target.  */\n+\t  rtx plus1 = gen_int_mode (INTVAL (operands[2]) + 1, SImode);\n+\t  if (satisfies_constraint_Is15 (plus1))\n+\t    {\n+\t      operands[2] = plus1;\n+\t      cmp_code = NE;\n+\t      if (code == LE)\n+\t\t{\n+\t\t  /* LE, use slts instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slts_compare (tmp_reg, operands[1], operands[2]));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* LEU, use slt instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      cmp_code = EQ;\n+\t      if (code == LE)\n+\t\t{\n+\t\t  /* LE, use slts instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slts_compare (tmp_reg, operands[2], operands[1]));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* LEU, use slt instruction */\n+\t\t  emit_insn (\n+\t\t    gen_slt_compare  (tmp_reg, operands[2], operands[1]));\n+\t\t}\n+\t    }\n+\n+\t  PUT_CODE (operands[0], cmp_code);\n+\t  operands[1] = tmp_reg;\n+\t  operands[2] = const0_rtx;\n+\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+      else\n+\t{\n+\t  /* LE  reg_A, reg_B  =>  !(LT  reg_B, reg_A) */\n+\t  if (optimize_size || optimize == 0)\n+\t    tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n+\t  else\n+\t    tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  if (code == LE)\n+\t    {\n+\t      /* LE, use slts instruction */\n+\t      emit_insn (gen_slts_compare (tmp_reg, operands[2], operands[1]));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* LEU, use slt instruction */\n+\t      emit_insn (gen_slt_compare  (tmp_reg, operands[2], operands[1]));\n+\t    }\n+\n+\t  PUT_CODE (operands[0], EQ);\n+\t  operands[1] = tmp_reg;\n+\t  operands[2] = const0_rtx;\n+\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+\n+    case EQ:\n+    case NE:\n+      /* NDS32 ISA has various form for eq/ne behavior no matter\n+\t what kind of the operand is.\n+\t So just generate original template rtx.  */\n+\n+      /* Put operands[2] into register if operands[2] is a large\n+\t const_int or ISAv2.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (!satisfies_constraint_Is11 (operands[2])\n+\t      || TARGET_ISA_V2))\n+\toperands[2] = force_reg (SImode, operands[2]);\n+\n+      return EXPAND_CREATE_TEMPLATE;\n+\n+    default:\n+      return EXPAND_FAIL;\n+    }\n+}\n+\n+enum nds32_expand_result_type\n+nds32_expand_cstore (rtx *operands)\n+{\n+  rtx tmp_reg;\n+  enum rtx_code code;\n+\n+  code = GET_CODE (operands[1]);\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+      if (GET_CODE (operands[3]) == CONST_INT)\n+\t{\n+\t  /* reg_R = (reg_A == const_int_B)\n+\t     --> xori reg_C, reg_A, const_int_B\n+\t\t slti reg_R, reg_C, const_int_1\n+\t     reg_R = (reg_A != const_int_B)\n+\t     --> xori reg_C, reg_A, const_int_B\n+\t\t slti reg_R, const_int0, reg_C */\n+\t  tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  /* If the integer value is not in the range of imm15s,\n+\t     we need to force register first because our addsi3 pattern\n+\t     only accept nds32_rimm15s_operand predicate.  */\n+\t  rtx new_imm = gen_int_mode (-INTVAL (operands[3]), SImode);\n+\t  if (satisfies_constraint_Is15 (new_imm))\n+\t    emit_insn (gen_addsi3 (tmp_reg, operands[2], new_imm));\n+\t  else\n+\t    {\n+\t      if (!(satisfies_constraint_Iu15 (operands[3])\n+\t\t    || (TARGET_EXT_PERF\n+\t\t\t&& satisfies_constraint_It15 (operands[3]))))\n+\t\toperands[3] = force_reg (SImode, operands[3]);\n+\t      emit_insn (gen_xorsi3 (tmp_reg, operands[2], operands[3]));\n+\t    }\n+\n+\t  if (code == EQ)\n+\t    emit_insn (gen_slt_eq0 (operands[0], tmp_reg));\n+\t  else\n+\t    emit_insn (gen_slt_compare (operands[0], const0_rtx, tmp_reg));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+      else\n+\t{\n+\t  /* reg_R = (reg_A == reg_B)\n+\t     --> xor  reg_C, reg_A, reg_B\n+\t\t slti reg_R, reg_C, const_int_1\n+\t     reg_R = (reg_A != reg_B)\n+\t     --> xor  reg_C, reg_A, reg_B\n+\t\t slti reg_R, const_int0, reg_C */\n+\t  tmp_reg = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_xorsi3 (tmp_reg, operands[2], operands[3]));\n+\t  if (code == EQ)\n+\t    emit_insn (gen_slt_eq0 (operands[0], tmp_reg));\n+\t  else\n+\t    emit_insn (gen_slt_compare (operands[0], const0_rtx, tmp_reg));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+    case GT:\n+    case GTU:\n+      /* reg_R = (reg_A > reg_B)       --> slt reg_R, reg_B, reg_A */\n+      /* reg_R = (reg_A > const_int_B) --> slt reg_R, const_int_B, reg_A */\n+      if (code == GT)\n+\t{\n+\t  /* GT, use slts instruction */\n+\t  emit_insn (gen_slts_compare (operands[0], operands[3], operands[2]));\n+\t}\n+      else\n+\t{\n+\t  /* GTU, use slt instruction */\n+\t  emit_insn (gen_slt_compare  (operands[0], operands[3], operands[2]));\n+\t}\n+\n+      return EXPAND_DONE;\n+\n+    case GE:\n+    case GEU:\n+      if (GET_CODE (operands[3]) == CONST_INT)\n+\t{\n+\t  /* reg_R = (reg_A >= const_int_B)\n+\t     --> movi reg_C, const_int_B - 1\n+\t\t slt  reg_R, reg_C, reg_A */\n+\t  tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  emit_insn (gen_movsi (tmp_reg,\n+\t\t\t\tgen_int_mode (INTVAL (operands[3]) - 1,\n+\t\t\t\t\t      SImode)));\n+\t  if (code == GE)\n+\t    {\n+\t      /* GE, use slts instruction */\n+\t      emit_insn (gen_slts_compare (operands[0], tmp_reg, operands[2]));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* GEU, use slt instruction */\n+\t      emit_insn (gen_slt_compare  (operands[0], tmp_reg, operands[2]));\n+\t    }\n+\n+\t  return EXPAND_DONE;\n+\t}\n+      else\n+\t{\n+\t  /* reg_R = (reg_A >= reg_B)\n+\t     --> slt  reg_R, reg_A, reg_B\n+\t\t xori reg_R, reg_R, const_int_1 */\n+\t  if (code == GE)\n+\t    {\n+\t      /* GE, use slts instruction */\n+\t      emit_insn (gen_slts_compare (operands[0],\n+\t\t\t\t\t   operands[2], operands[3]));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* GEU, use slt instruction */\n+\t      emit_insn (gen_slt_compare  (operands[0],\n+\t\t\t\t\t   operands[2], operands[3]));\n+\t    }\n+\n+\t  /* perform 'not' behavior */\n+\t  emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+\n+    case LT:\n+    case LTU:\n+      /* reg_R = (reg_A < reg_B)       --> slt reg_R, reg_A, reg_B */\n+      /* reg_R = (reg_A < const_int_B) --> slt reg_R, reg_A, const_int_B */\n+      if (code == LT)\n+\t{\n+\t  /* LT, use slts instruction */\n+\t  emit_insn (gen_slts_compare (operands[0], operands[2], operands[3]));\n+\t}\n+      else\n+\t{\n+\t  /* LTU, use slt instruction */\n+\t  emit_insn (gen_slt_compare  (operands[0], operands[2], operands[3]));\n+\t}\n+\n+      return EXPAND_DONE;\n+\n+    case LE:\n+    case LEU:\n+      if (GET_CODE (operands[3]) == CONST_INT)\n+\t{\n+\t  /* reg_R = (reg_A <= const_int_B)\n+\t     --> movi reg_C, const_int_B + 1\n+\t\t slt  reg_R, reg_A, reg_C */\n+\t  tmp_reg = gen_reg_rtx (SImode);\n+\n+\t  emit_insn (gen_movsi (tmp_reg,\n+\t\t\t\tgen_int_mode (INTVAL (operands[3]) + 1,\n+\t\t\t\t\t\t      SImode)));\n+\t  if (code == LE)\n+\t    {\n+\t      /* LE, use slts instruction */\n+\t      emit_insn (gen_slts_compare (operands[0], operands[2], tmp_reg));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* LEU, use slt instruction */\n+\t      emit_insn (gen_slt_compare  (operands[0], operands[2], tmp_reg));\n+\t    }\n+\n+\t  return EXPAND_DONE;\n+\t}\n+      else\n+\t{\n+\t  /* reg_R = (reg_A <= reg_B) --> slt  reg_R, reg_B, reg_A\n+\t\t\t\t\t  xori reg_R, reg_R, const_int_1 */\n+\t  if (code == LE)\n+\t    {\n+\t      /* LE, use slts instruction */\n+\t      emit_insn (gen_slts_compare (operands[0],\n+\t\t\t\t\t   operands[3], operands[2]));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* LEU, use slt instruction */\n+\t      emit_insn (gen_slt_compare  (operands[0],\n+\t\t\t\t\t   operands[3], operands[2]));\n+\t    }\n+\n+\t  /* perform 'not' behavior */\n+\t  emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n+\n+\t  return EXPAND_DONE;\n+\t}\n+\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+enum nds32_expand_result_type\n+nds32_expand_movcc (rtx *operands)\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  enum rtx_code new_code = code;\n+  machine_mode cmp0_mode = GET_MODE (XEXP (operands[1], 0));\n+  rtx cmp_op0 = XEXP (operands[1], 0);\n+  rtx cmp_op1 = XEXP (operands[1], 1);\n+  rtx tmp;\n+\n+  if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n+      && XEXP (operands[1], 1) == const0_rtx)\n+    {\n+      /* If the operands[1] rtx is already (eq X 0) or (ne X 0),\n+\t we have gcc generate original template rtx.  */\n+      return EXPAND_CREATE_TEMPLATE;\n+    }\n+  else\n+    {\n+      /* Since there is only 'slt'(Set when Less Than) instruction for\n+\t comparison in Andes ISA, the major strategy we use here is to\n+\t convert conditional move into 'LT + EQ' or 'LT + NE' rtx combination.\n+\t We design constraints properly so that the reload phase will assist\n+\t to make one source operand to use same register as result operand.\n+\t Then we can use cmovz/cmovn to catch the other source operand\n+\t which has different register.  */\n+      int reverse = 0;\n+\n+      /* Main Goal: Use 'LT + EQ' or 'LT + NE' to target \"then\" part\n+\t Strategy : Reverse condition and swap comparison operands\n+\n+\t For example:\n+\n+\t     a <= b ? P : Q   (LE or LEU)\n+\t --> a >  b ? Q : P   (reverse condition)\n+\t --> b <  a ? Q : P   (swap comparison operands to achieve 'LT/LTU')\n+\n+\t     a >= b ? P : Q   (GE or GEU)\n+\t --> a <  b ? Q : P   (reverse condition to achieve 'LT/LTU')\n+\n+\t     a <  b ? P : Q   (LT or LTU)\n+\t --> (NO NEED TO CHANGE, it is already 'LT/LTU')\n+\n+\t     a >  b ? P : Q   (GT or GTU)\n+\t --> b <  a ? P : Q   (swap comparison operands to achieve 'LT/LTU') */\n+      switch (code)\n+\t{\n+\tcase GE: case GEU: case LE: case LEU:\n+\t  new_code = reverse_condition (code);\n+\t  reverse = 1;\n+\t  break;\n+\tcase EQ:\n+\tcase NE:\n+\t  /* no need to reverse condition */\n+\t  break;\n+\tdefault:\n+\t  return EXPAND_FAIL;\n+\t}\n+\n+      /* For '>' comparison operator, we swap operands\n+\t so that we can have 'LT/LTU' operator.  */\n+      if (new_code == GT || new_code == GTU)\n+\t{\n+\t  tmp     = cmp_op0;\n+\t  cmp_op0 = cmp_op1;\n+\t  cmp_op1 = tmp;\n+\n+\t  new_code = swap_condition (new_code);\n+\t}\n+\n+      /* Use a temporary register to store slt/slts result.  */\n+      tmp = gen_reg_rtx (SImode);\n+\n+      if (new_code == EQ || new_code == NE)\n+\t{\n+\t  emit_insn (gen_xorsi3 (tmp, cmp_op0, cmp_op1));\n+\t  /* tmp == 0 if cmp_op0 == cmp_op1.  */\n+\t  operands[1] = gen_rtx_fmt_ee (new_code, VOIDmode, tmp, const0_rtx);\n+\t}\n+      else\n+\t{\n+\t  /* This emit_insn will create corresponding 'slt/slts'\n+\t      insturction.  */\n+\t  if (new_code == LT)\n+\t    emit_insn (gen_slts_compare (tmp, cmp_op0, cmp_op1));\n+\t  else if (new_code == LTU)\n+\t    emit_insn (gen_slt_compare (tmp, cmp_op0, cmp_op1));\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  /* Change comparison semantic into (eq X 0) or (ne X 0) behavior\n+\t     so that cmovz or cmovn will be matched later.\n+\n+\t     For reverse condition cases, we want to create a semantic that:\n+\t       (eq X 0) --> pick up \"else\" part\n+\t     For normal cases, we want to create a semantic that:\n+\t       (ne X 0) --> pick up \"then\" part\n+\n+\t     Later we will have cmovz/cmovn instruction pattern to\n+\t     match corresponding behavior and output instruction.  */\n+\t  operands[1] = gen_rtx_fmt_ee (reverse ? EQ : NE,\n+\t\t\t\t\tVOIDmode, tmp, const0_rtx);\n+\t}\n+    }\n+  return EXPAND_CREATE_TEMPLATE;\n+}\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* Function to return memory format.  */\n enum nds32_16bit_address_type\n nds32_mem_format (rtx op)\n {\n@@ -1146,6 +1921,190 @@ nds32_expand_unaligned_store (rtx *operands, enum machine_mode mode)\n     }\n }\n \n+const char *\n+nds32_output_cbranchsi4_equality_zero (rtx_insn *insn, rtx *operands)\n+{\n+  enum rtx_code code;\n+  bool long_jump_p = false;\n+\n+  code = GET_CODE (operands[0]);\n+\n+  /* This zero-comparison conditional branch has two forms:\n+       32-bit instruction =>          beqz/bnez           imm16s << 1\n+       16-bit instruction => beqzs8/bnezs8/beqz38/bnez38  imm8s << 1\n+\n+     For 32-bit case,\n+     we assume it is always reachable. (but check range -65500 ~ 65500)\n+\n+     For 16-bit case,\n+     it must satisfy { 255 >= (label - pc) >= -256 } condition.\n+     However, since the $pc for nds32 is at the beginning of the instruction,\n+     we should leave some length space for current insn.\n+     So we use range -250 ~ 250.  */\n+\n+  switch (get_attr_length (insn))\n+    {\n+    case 8:\n+      long_jump_p = true;\n+      /* fall through  */\n+    case 2:\n+      if (which_alternative == 0)\n+\t{\n+\t  /* constraint: t */\n+\t  /*    b<cond>zs8  .L0\n+\t      or\n+\t\tb<inverse_cond>zs8  .LCB0\n+\t\tj  .L0\n+\t      .LCB0:\n+\t   */\n+\t  output_cond_branch_compare_zero (code, \"s8\", long_jump_p,\n+\t\t\t\t\t   operands, true);\n+\t  return \"\";\n+\t}\n+      else if (which_alternative == 1)\n+\t{\n+\t  /* constraint: l */\n+\t  /*    b<cond>z38  $r0, .L0\n+\t      or\n+\t\tb<inverse_cond>z38  $r0, .LCB0\n+\t\tj  .L0\n+\t      .LCB0:\n+\t   */\n+\t  output_cond_branch_compare_zero (code, \"38\", long_jump_p,\n+\t\t\t\t\t   operands, false);\n+\t  return \"\";\n+\t}\n+      else\n+\t{\n+\t  /* constraint: r */\n+\t  /* For which_alternative==2, it should not be here.  */\n+\t  gcc_unreachable ();\n+\t}\n+    case 10:\n+      /* including constraints: t, l, and r */\n+      long_jump_p = true;\n+      /* fall through  */\n+    case 4:\n+      /* including constraints: t, l, and r */\n+      output_cond_branch_compare_zero (code, \"\", long_jump_p, operands, false);\n+      return \"\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+const char *\n+nds32_output_cbranchsi4_equality_reg (rtx_insn *insn, rtx *operands)\n+{\n+  enum rtx_code code;\n+  bool long_jump_p, r5_p;\n+  int insn_length;\n+\n+  insn_length = get_attr_length (insn);\n+\n+  long_jump_p = (insn_length == 10 || insn_length == 8) ? true : false;\n+  r5_p = (insn_length == 2 || insn_length == 8) ? true : false;\n+\n+  code = GET_CODE (operands[0]);\n+\n+  /* This register-comparison conditional branch has one form:\n+       32-bit instruction =>          beq/bne           imm14s << 1\n+\n+     For 32-bit case,\n+     we assume it is always reachable. (but check range -16350 ~ 16350).  */\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+      output_cond_branch (code, \"\", r5_p, long_jump_p, operands);\n+      return \"\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+const char *\n+nds32_output_cbranchsi4_equality_reg_or_const_int (rtx_insn *insn,\n+\t\t\t\t\t\t   rtx *operands)\n+{\n+  enum rtx_code code;\n+  bool long_jump_p, r5_p;\n+  int insn_length;\n+\n+  insn_length = get_attr_length (insn);\n+\n+  long_jump_p = (insn_length == 10 || insn_length == 8) ? true : false;\n+  r5_p = (insn_length == 2 || insn_length == 8) ? true : false;\n+\n+  code = GET_CODE (operands[0]);\n+\n+  /* This register-comparison conditional branch has one form:\n+       32-bit instruction =>          beq/bne           imm14s << 1\n+       32-bit instruction =>         beqc/bnec          imm8s << 1\n+\n+     For 32-bit case, we assume it is always reachable.\n+     (but check range -16350 ~ 16350 and -250 ~ 250).  */\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+      if (which_alternative == 2)\n+\t{\n+\t  /* r, Is11 */\n+\t  /* b<cond>c */\n+\t  output_cond_branch (code, \"c\", r5_p, long_jump_p, operands);\n+\t}\n+      else\n+\t{\n+\t  /* r, r */\n+\t  /* v, r */\n+\t  output_cond_branch (code, \"\", r5_p, long_jump_p, operands);\n+\t}\n+      return \"\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+const char *\n+nds32_output_cbranchsi4_greater_less_zero (rtx_insn *insn, rtx *operands)\n+{\n+  enum rtx_code code;\n+  bool long_jump_p;\n+  int insn_length;\n+\n+  insn_length = get_attr_length (insn);\n+\n+  gcc_assert (insn_length == 4 || insn_length == 10);\n+\n+  long_jump_p = (insn_length == 10) ? true : false;\n+\n+  code = GET_CODE (operands[0]);\n+\n+  /* This zero-greater-less-comparison conditional branch has one form:\n+       32-bit instruction =>      bgtz/bgez/bltz/blez     imm16s << 1\n+\n+     For 32-bit case, we assume it is always reachable.\n+     (but check range -65500 ~ 65500).  */\n+\n+  switch (code)\n+    {\n+    case GT:\n+    case GE:\n+    case LT:\n+    case LE:\n+      output_cond_branch_compare_zero (code, \"\", long_jump_p, operands, false);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return \"\";\n+}\n+\n /* Return true X is need use long call.  */\n bool\n nds32_long_call_p (rtx symbol)"}, {"sha": "97aad41840b5fe9ca67a15ebcfeffff9a7d5b994", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "patch": "@@ -116,6 +116,16 @@ extern bool nds32_symbol_load_store_p (rtx_insn *);\n extern const char *nds32_output_casesi_pc_relative (rtx *);\n extern const char *nds32_output_casesi (rtx *);\n \n+/* Auxiliary functions for conditional branch generation.  */\n+\n+extern enum nds32_expand_result_type nds32_expand_cbranch (rtx *);\n+extern enum nds32_expand_result_type nds32_expand_cstore (rtx *);\n+\n+/* Auxiliary functions for conditional move generation.  */\n+\n+extern enum nds32_expand_result_type nds32_expand_movcc (rtx *);\n+\n+\n /* Auxiliary functions to identify long-call symbol.  */\n extern bool nds32_long_call_p (rtx);\n \n@@ -132,6 +142,12 @@ extern const char *nds32_output_32bit_load (rtx *, int);\n extern const char *nds32_output_32bit_load_s (rtx *, int);\n extern const char *nds32_output_smw_single_word (rtx *);\n extern const char *nds32_output_lmw_single_word (rtx *);\n+extern const char *nds32_output_cbranchsi4_equality_zero (rtx_insn *, rtx *);\n+extern const char *nds32_output_cbranchsi4_equality_reg (rtx_insn *, rtx *);\n+extern const char *nds32_output_cbranchsi4_equality_reg_or_const_int (rtx_insn *,\n+\t\t\t\t\t\t\t\t      rtx *);\n+extern const char *nds32_output_cbranchsi4_greater_less_zero (rtx_insn *, rtx *);\n+\n \n /* Auxiliary functions to output stack push/pop instruction.  */\n "}, {"sha": "e2f109766dbc1cc4a7134a4f2795f3ee2ccf31b5", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "patch": "@@ -33,6 +33,14 @@\n #define NDS32_SYMBOL_REF_RODATA_P(x) \\\n   ((SYMBOL_REF_FLAGS (x) & NDS32_SYMBOL_FLAG_RODATA) != 0)\n \n+/* Classifies expand result for expand helper function.  */\n+enum nds32_expand_result_type\n+{\n+  EXPAND_DONE,\n+  EXPAND_FAIL,\n+  EXPAND_CREATE_TEMPLATE\n+};\n+\n /* Computing the Length of an Insn.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n   (LENGTH = nds32_adjust_insn_length (INSN, LENGTH))"}, {"sha": "662be73d8e8e4c4c51057f39af434217e1d4b9c6", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 236, "deletions": 917, "changes": 1153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "patch": "@@ -801,148 +801,65 @@\n ;; Conditional Move patterns\n ;; ----------------------------------------------------------------------------\n \n-(define_expand \"movsicc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"register_operand\" \"\")))]\n-  \"TARGET_CMOV\"\n+(define_expand \"mov<mode>cc\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n+\t(if_then_else:QIHISI (match_operand 1 \"nds32_movecc_comparison_operator\" \"\")\n+\t\t\t (match_operand:QIHISI 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:QIHISI 3 \"register_operand\" \"\")))]\n+  \"TARGET_CMOV && !optimize_size\"\n {\n-  if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n-      && GET_MODE (XEXP (operands[1], 0)) == SImode\n-      && XEXP (operands[1], 1) == const0_rtx)\n-    {\n-      /* If the operands[1] rtx is already (eq X 0) or (ne X 0),\n-         we have gcc generate original template rtx.  */\n-      goto create_template;\n-    }\n-  else\n+  enum nds32_expand_result_type result = nds32_expand_movcc (operands);\n+  switch (result)\n     {\n-      /* Since there is only 'slt'(Set when Less Than) instruction for\n-         comparison in Andes ISA, the major strategy we use here is to\n-         convert conditional move into 'LT + EQ' or 'LT + NE' rtx combination.\n-         We design constraints properly so that the reload phase will assist\n-         to make one source operand to use same register as result operand.\n-         Then we can use cmovz/cmovn to catch the other source operand\n-         which has different register.  */\n-      enum rtx_code code = GET_CODE (operands[1]);\n-      enum rtx_code new_code = code;\n-      rtx cmp_op0 = XEXP (operands[1], 0);\n-      rtx cmp_op1 = XEXP (operands[1], 1);\n-      rtx tmp;\n-      int reverse = 0;\n-\n-      /* Main Goal: Use 'LT + EQ' or 'LT + NE' to target \"then\" part\n-         Strategy : Reverse condition and swap comparison operands\n-\n-         For example:\n-\n-             a <= b ? P : Q   (LE or LEU)\n-         --> a >  b ? Q : P   (reverse condition)\n-         --> b <  a ? Q : P   (swap comparison operands to achieve 'LT/LTU')\n-\n-             a >= b ? P : Q   (GE or GEU)\n-         --> a <  b ? Q : P   (reverse condition to achieve 'LT/LTU')\n-\n-             a <  b ? P : Q   (LT or LTU)\n-         --> (NO NEED TO CHANGE, it is already 'LT/LTU')\n-\n-             a >  b ? P : Q   (GT or GTU)\n-         --> b <  a ? P : Q   (swap comparison operands to achieve 'LT/LTU') */\n-      switch (code)\n-\t{\n-\tcase NE:\n-\t  /*   (a != b ? P : Q)\n-\t     can be expressed as\n-\t       (a == b ? Q : P)\n-\t     so, fall through to reverse condition */\n-\tcase GE: case GEU: case LE: case LEU:\n-\t  new_code = reverse_condition (code);\n-\t  reverse = 1;\n-\t  break;\n-\tcase EQ: case GT: case GTU: case LT: case LTU:\n-\t  /* no need to reverse condition */\n-\t  break;\n-\tdefault:\n-\t  FAIL;\n-\t}\n-\n-      /* For '>' comparison operator, we swap operands\n-         so that we can have 'LT/LTU' operator.  */\n-      if (new_code == GT || new_code == GTU)\n-\t{\n-\t  tmp     = cmp_op0;\n-\t  cmp_op0 = cmp_op1;\n-\t  cmp_op1 = tmp;\n-\n-\t  new_code = swap_condition (new_code);\n-\t}\n-\n-      /* Use a temporary register to store slt/slts result.  */\n-      tmp = gen_reg_rtx (SImode);\n-\n-      /* Split EQ and NE because we don't have direct comparison of EQ and NE.\n-         If we don't split it, the conditional move transformation will fail\n-         when producing (SET A (EQ B C)) or (SET A (NE B C)).  */\n-      if (new_code == EQ)\n-\t{\n-\t  emit_insn (gen_xorsi3 (tmp, cmp_op0, cmp_op1));\n-\t  emit_insn (gen_slt_compare (tmp, tmp, GEN_INT (1)));\n-\t}\n-      else if (new_code == NE)\n-\t{\n-\t  emit_insn (gen_xorsi3 (tmp, cmp_op0, cmp_op1));\n-\t  emit_insn (gen_slt_compare (tmp, GEN_INT (0), tmp));\n-        }\n-      else\n-\t/* This emit_insn will create corresponding 'slt/slts' insturction.  */\n-\temit_insn (gen_rtx_SET (tmp, gen_rtx_fmt_ee (new_code, SImode,\n-\t\t\t\t\t\t     cmp_op0, cmp_op1)));\n-\n-      /* Change comparison semantic into (eq X 0) or (ne X 0) behavior\n-         so that cmovz or cmovn will be matched later.\n-\n-         For reverse condition cases, we want to create a semantic that:\n-           (eq X 0) --> pick up \"else\" part\n-         For normal cases, we want to create a semantic that:\n-           (ne X 0) --> pick up \"then\" part\n-\n-         Later we will have cmovz/cmovn instruction pattern to\n-         match corresponding behavior and output instruction.  */\n-      operands[1] = gen_rtx_fmt_ee (reverse ? EQ : NE,\n-\t\t\t\t    VOIDmode, tmp, const0_rtx);\n+    case EXPAND_DONE:\n+      DONE;\n+      break;\n+    case EXPAND_FAIL:\n+      FAIL;\n+      break;\n+    case EXPAND_CREATE_TEMPLATE:\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-\n-create_template:\n-  do {} while(0); /* dummy line */\n })\n \n-(define_insn \"cmovz\"\n-  [(set (match_operand:SI 0 \"register_operand\"                      \"=r, r\")\n-        (if_then_else:SI (eq (match_operand:SI 1 \"register_operand\" \" r, r\")\n+(define_insn \"cmovz<mode>\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\"                      \"=r, r\")\n+\t(if_then_else:QIHISI (eq (match_operand:SI 1 \"register_operand\" \" r, r\")\n \t\t\t     (const_int 0))\n-\t\t\t (match_operand:SI 2 \"register_operand\"     \" r, 0\")\n-\t\t\t (match_operand:SI 3 \"register_operand\"     \" 0, r\")))]\n+\t\t\t (match_operand:QIHISI 2 \"register_operand\"     \" r, 0\")\n+\t\t\t (match_operand:QIHISI 3 \"register_operand\"     \" 0, r\")))]\n   \"TARGET_CMOV\"\n   \"@\n    cmovz\\t%0, %2, %1\n    cmovn\\t%0, %3, %1\"\n   [(set_attr \"type\"  \"alu\")\n    (set_attr \"length\"  \"4\")])\n \n-(define_insn \"cmovn\"\n-  [(set (match_operand:SI 0 \"register_operand\"                      \"=r, r\")\n-\t(if_then_else:SI (ne (match_operand:SI 1 \"register_operand\" \" r, r\")\n+(define_insn \"cmovn<mode>\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\"                      \"=r, r\")\n+\t(if_then_else:QIHISI (ne (match_operand:SI 1 \"register_operand\" \" r, r\")\n \t\t\t     (const_int 0))\n-\t\t\t (match_operand:SI 2 \"register_operand\"     \" r, 0\")\n-\t\t\t (match_operand:SI 3 \"register_operand\"     \" 0, r\")))]\n+\t\t\t (match_operand:QIHISI 2 \"register_operand\"     \" r, 0\")\n+\t\t\t (match_operand:QIHISI 3 \"register_operand\"     \" 0, r\")))]\n   \"TARGET_CMOV\"\n   \"@\n    cmovn\\t%0, %2, %1\n    cmovz\\t%0, %3, %1\"\n   [(set_attr \"type\"  \"alu\")\n    (set_attr \"length\"  \"4\")])\n \n+;; A hotfix to help RTL combiner to merge a cmovn insn and a zero_extend insn.\n+;; It should be removed once after we change the expansion form of the cmovn.\n+(define_insn \"*cmovn_simplified_<mode>\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:QIHISI 2 \"register_operand\" \"r\")\n+\t\t\t (match_operand:QIHISI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"cmovn\\t%0, %2, %1\"\n+  [(set_attr \"type\" \"alu\")])\n \n ;; ----------------------------------------------------------------------------\n ;; Conditional Branch patterns\n@@ -957,573 +874,188 @@ create_template:\n \t\t      (pc)))]\n   \"\"\n {\n-  rtx tmp_reg;\n-  enum rtx_code code;\n-\n-  code = GET_CODE (operands[0]);\n-\n-  /* If operands[2] is (const_int 0),\n-     we can use beqz,bnez,bgtz,bgez,bltz,or blez instructions.\n-     So we have gcc generate original template rtx.  */\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    if (INTVAL (operands[2]) == 0)\n-      if ((code != GTU)\n-\t  && (code != GEU)\n-\t  && (code != LTU)\n-\t  && (code != LEU))\n-\tgoto create_template;\n-\n-  /* For other comparison, NDS32 ISA only has slt (Set-on-Less-Than)\n-     behavior for the comparison, we might need to generate other\n-     rtx patterns to achieve same semantic.  */\n-  switch (code)\n+  enum nds32_expand_result_type result = nds32_expand_cbranch (operands);\n+  switch (result)\n     {\n-    case GT:\n-    case GTU:\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  /* GT  reg_A, const_int  =>  !(LT  reg_A, const_int + 1) */\n-\t  tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n-\n-\t  /* We want to plus 1 into the integer value\n-\t     of operands[2] to create 'slt' instruction.\n-\t     This caculation is performed on the host machine,\n-\t     which may be 64-bit integer.\n-\t     So the meaning of caculation result may be\n-\t     different from the 32-bit nds32 target.\n-\n-\t     For example:\n-\t       0x7fffffff + 0x1 -> 0x80000000,\n-\t       this value is POSITIVE on 64-bit machine,\n-\t       but the expected value on 32-bit nds32 target\n-\t       should be NEGATIVE value.\n-\n-\t     Hence, instead of using GEN_INT(), we use gen_int_mode() to\n-\t     explicitly create SImode constant rtx.  */\n-\t  operands[2] = gen_int_mode (INTVAL (operands[2]) + 1, SImode);\n-\n-\t  if (code == GT)\n-\t    {\n-\t      /* GT, use slts instruction */\n-\t      emit_insn (gen_slts_compare (tmp_reg, operands[1], operands[2]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* GTU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n-\t    }\n-\n-\t  PUT_CODE (operands[0], EQ);\n-\t  operands[1] = tmp_reg;\n-\t  operands[2] = const0_rtx;\n-\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n-\t\t\t\t     operands[2], operands[3]));\n-\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  /* GT  reg_A, reg_B  =>  LT  reg_B, reg_A */\n-\t  tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n-\n-\t  if (code == GT)\n-\t    {\n-\t      /* GT, use slts instruction */\n-\t      emit_insn (gen_slts_compare (tmp_reg, operands[2], operands[1]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* GTU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (tmp_reg, operands[2], operands[1]));\n-\t    }\n-\n-\t  PUT_CODE (operands[0], NE);\n-\t  operands[1] = tmp_reg;\n-\t  operands[2] = const0_rtx;\n-\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n-\t\t\t\t     operands[2], operands[3]));\n-\n-\t  DONE;\n-\t}\n-\n-    case GE:\n-    case GEU:\n-      /* GE  reg_A, reg_B      =>  !(LT  reg_A, reg_B) */\n-      /* GE  reg_A, const_int  =>  !(LT  reg_A, const_int) */\n-      tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n-\n-      if (code == GE)\n-\t{\n-\t  /* GE, use slts instruction */\n-\t  emit_insn (gen_slts_compare (tmp_reg, operands[1], operands[2]));\n-\t}\n-      else\n-\t{\n-\t  /* GEU, use slt instruction */\n-\t  emit_insn (gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n-\t}\n-\n-      PUT_CODE (operands[0], EQ);\n-      operands[1] = tmp_reg;\n-      operands[2] = const0_rtx;\n-      emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n-\t\t\t\t operands[2], operands[3]));\n-\n+    case EXPAND_DONE:\n       DONE;\n-\n-    case LT:\n-    case LTU:\n-      /* LT  reg_A, reg_B      =>  LT  reg_A, reg_B */\n-      /* LT  reg_A, const_int  =>  LT  reg_A, const_int */\n-      tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n-\n-      if (code == LT)\n-\t{\n-\t  /* LT, use slts instruction */\n-\t  emit_insn (gen_slts_compare (tmp_reg, operands[1], operands[2]));\n-\t}\n-      else\n-\t{\n-\t  /* LTU, use slt instruction */\n-\t  emit_insn (gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n-\t}\n-\n-      PUT_CODE (operands[0], NE);\n-      operands[1] = tmp_reg;\n-      operands[2] = const0_rtx;\n-      emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n-\t\t\t\t operands[2], operands[3]));\n-\n-      DONE;\n-\n-    case LE:\n-    case LEU:\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  /* LE  reg_A, const_int  =>  LT  reg_A, const_int + 1 */\n-\t  tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n-\n-\t  /* Note that (le:SI X INT_MAX) is not the same as (lt:SI X INT_MIN).\n-\t     We better have an assert here in case GCC does not properly\n-\t     optimize it away.  The INT_MAX here is 0x7fffffff for target.  */\n-\t  gcc_assert (code != LE || INTVAL (operands[2]) != 0x7fffffff);\n-\t  operands[2] = gen_int_mode (INTVAL (operands[2]) + 1, SImode);\n-\n-\t  if (code == LE)\n-\t    {\n-\t      /* LE, use slts instruction */\n-\t      emit_insn (gen_slts_compare (tmp_reg, operands[1], operands[2]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* LEU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (tmp_reg, operands[1], operands[2]));\n-\t    }\n-\n-\t  PUT_CODE (operands[0], NE);\n-\t  operands[1] = tmp_reg;\n-\t  operands[2] = const0_rtx;\n-\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n-\t\t\t\t     operands[2], operands[3]));\n-\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  /* LE  reg_A, reg_B  =>  !(LT  reg_B, reg_A) */\n-\t  tmp_reg = gen_rtx_REG (SImode, TA_REGNUM);\n-\n-\t  if (code == LE)\n-\t    {\n-\t      /* LE, use slts instruction */\n-\t      emit_insn (gen_slts_compare (tmp_reg, operands[2], operands[1]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* LEU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (tmp_reg, operands[2], operands[1]));\n-\t    }\n-\n-\t  PUT_CODE (operands[0], EQ);\n-\t  operands[1] = tmp_reg;\n-\t  operands[2] = const0_rtx;\n-\t  emit_insn (gen_cbranchsi4 (operands[0], operands[1],\n-\t\t\t\t     operands[2], operands[3]));\n-\n-\t  DONE;\n-\t}\n-\n-    case EQ:\n-    case NE:\n-      /* NDS32 ISA has various form for eq/ne behavior no matter\n-         what kind of the operand is.\n-         So just generate original template rtx.  */\n-      goto create_template;\n-\n-    default:\n+      break;\n+    case EXPAND_FAIL:\n       FAIL;\n+      break;\n+    case EXPAND_CREATE_TEMPLATE:\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-\n-create_template:\n-  do {} while(0); /* dummy line */\n })\n \n \n-(define_insn \"*cbranchsi4_equality_zero\"\n+(define_insn \"cbranchsi4_equality_zero\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"nds32_equality_comparison_operator\"\n-\t\t\t[(match_operand:SI 1 \"register_operand\"  \"t, l, r\")\n+\t\t\t[(match_operand:SI 1 \"register_operand\"  \"t,l, r\")\n \t\t\t (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n {\n-  enum rtx_code code;\n-\n-  code = GET_CODE (operands[0]);\n-\n-  /* This zero-comparison conditional branch has two forms:\n-       32-bit instruction =>          beqz/bnez           imm16s << 1\n-       16-bit instruction => beqzs8/bnezs8/beqz38/bnez38  imm8s << 1\n-\n-     For 32-bit case,\n-     we assume it is always reachable. (but check range -65500 ~ 65500)\n-\n-     For 16-bit case,\n-     it must satisfy { 255 >= (label - pc) >= -256 } condition.\n-     However, since the $pc for nds32 is at the beginning of the instruction,\n-     we should leave some length space for current insn.\n-     So we use range -250 ~ 250.  */\n-\n-  switch (get_attr_length (insn))\n-    {\n-    case 2:\n-      if (which_alternative == 0)\n-\t{\n-\t  /* constraint: t */\n-\t  return (code == EQ) ? \"beqzs8\\t%2\" : \"bnezs8\\t%2\";\n-\t}\n-      else if (which_alternative == 1)\n-\t{\n-\t  /* constraint: l */\n-\t  return (code == EQ) ? \"beqz38\\t%1, %2\" : \"bnez38\\t%1, %2\";\n-\t}\n-      else\n-\t{\n-\t  /* constraint: r */\n-\t  /* For which_alternative==2, it should not be here.  */\n-\t  gcc_unreachable ();\n-\t}\n-    case 4:\n-      /* including constraints: t, l, and r */\n-      return (code == EQ) ? \"beqz\\t%1, %2\" : \"bnez\\t%1, %2\";\n-    case 6:\n-      if (which_alternative == 0)\n-\t{\n-\t  /* constraint: t */\n-\t  if (code == EQ)\n-\t    {\n-\t      /*    beqzs8  .L0\n-\t          =>\n-\t            bnezs8  .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"bnezs8\\t.LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\t    }\n-\t  else\n-\t    {\n-\t      /*    bnezs8  .L0\n-\t          =>\n-\t            beqzs8  .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"beqzs8\\t.LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\t    }\n-\t}\n-      else if (which_alternative == 1)\n-\t{\n-\t  /* constraint: l */\n-\t  if (code == EQ)\n-\t    {\n-\t      /*    beqz38  $r0, .L0\n-\t          =>\n-\t            bnez38  $r0, .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"bnez38\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\t    }\n-\t  else\n-\t    {\n-\t      /*    bnez38  $r0, .L0\n-\t          =>\n-\t            beqz38  $r0, .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"beqz38\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* constraint: r */\n-\t  /* For which_alternative==2, it should not be here.  */\n-\t  gcc_unreachable ();\n-\t}\n-    case 8:\n-      /* constraint: t, l, r.  */\n-      if (code == EQ)\n-\t{\n-\t  /*    beqz  $r8, .L0\n-\t      =>\n-\t        bnez  $r8, .LCB0\n-\t        j  .L0\n-\t      .LCB0:\n-\t   */\n-\t  return \"bnez\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\t}\n-      else\n-\t{\n-\t  /*    bnez  $r8, .L0\n-\t      =>\n-\t        beqz  $r8, .LCB0\n-\t        j  .L0\n-\t      .LCB0:\n-\t   */\n-\t  return \"beqz\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\t}\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return nds32_output_cbranchsi4_equality_zero (insn, operands);\n }\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"enabled\" \"yes\")\n+   (set_attr_alternative \"enabled\"\n+     [\n+       ;; Alternative 0\n+       (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\"))\n+       ;; Alternative 1\n+       (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\"))\n+       ;; Alternative 2\n+       (const_string \"yes\")\n+     ])\n    (set_attr_alternative \"length\"\n      [\n        ;; Alternative 0\n-       (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -250))\n-\t\t\t  (le (minus (match_dup 2) (pc)) (const_int  250)))\n-\t\t     (if_then_else (match_test \"TARGET_16_BIT\")\n-\t\t\t\t   (const_int 2)\n-\t\t\t\t   (const_int 4))\n-\t\t     (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n-\t\t\t\t\t(le (minus (match_dup 2) (pc)) (const_int  65500)))\n-\t\t\t\t   (const_int 4)\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -250))\n+\t\t\t\t\t(le (minus (match_dup 2) (pc)) (const_int  250)))\n \t\t\t\t   (if_then_else (match_test \"TARGET_16_BIT\")\n-\t\t\t\t\t\t (const_int 6)\n-\t\t\t\t\t\t (const_int 8))))\n+\t\t\t\t\t\t (const_int 2)\n+\t\t\t\t\t\t (const_int 4))\n+\t\t\t\t   (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n+\t\t\t\t\t\t      (le (minus (match_dup 2) (pc)) (const_int  65500)))\n+\t\t\t\t\t\t (const_int 4)\n+\t\t\t\t\t\t (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t\t\t\t\t\t       (const_int 8)\n+\t\t\t\t\t\t\t       (const_int 10))))\n+\t\t     (const_int 10))\n        ;; Alternative 1\n-       (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -250))\n-\t\t\t  (le (minus (match_dup 2) (pc)) (const_int  250)))\n-\t\t     (if_then_else (match_test \"TARGET_16_BIT\")\n-\t\t\t\t   (const_int 2)\n-\t\t\t\t   (const_int 4))\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -250))\n+\t\t\t\t\t(le (minus (match_dup 2) (pc)) (const_int  250)))\n+\t\t\t\t   (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t\t\t\t\t (const_int 2)\n+\t\t\t\t\t\t (const_int 4))\n+\t\t\t\t   (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n+\t\t\t\t\t\t      (le (minus (match_dup 2) (pc)) (const_int  65500)))\n+\t\t\t\t\t\t (const_int 4)\n+\t\t\t\t\t\t (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t\t\t\t\t\t       (const_int 8)\n+\t\t\t\t\t\t\t       (const_int 10))))\n+\t\t     (const_int 10))\n+       ;; Alternative 2\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n \t\t     (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n \t\t\t\t\t(le (minus (match_dup 2) (pc)) (const_int  65500)))\n \t\t\t\t   (const_int 4)\n-\t\t\t\t   (if_then_else (match_test \"TARGET_16_BIT\")\n-\t\t\t\t\t\t (const_int 6)\n-\t\t\t\t\t\t (const_int 8))))\n-       ;; Alternative 2\n-       (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n-\t\t\t  (le (minus (match_dup 2) (pc)) (const_int  65500)))\n-\t\t     (const_int 4)\n-\t\t     (const_int 8))\n+\t\t\t\t   (const_int 10))\n+\t\t     (const_int 10))\n      ])])\n \n \n ;; This pattern is dedicated to V2 ISA,\n ;; because V2 DOES NOT HAVE beqc/bnec instruction.\n-(define_insn \"*cbranchsi4_equality_reg\"\n+(define_insn \"cbranchsi4_equality_reg\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"nds32_equality_comparison_operator\"\n-\t\t\t[(match_operand:SI 1 \"register_operand\"           \"r\")\n-\t\t\t (match_operand:SI 2 \"nds32_reg_constant_operand\" \"r\")])\n+\t\t\t[(match_operand:SI 1 \"register_operand\" \"v, r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"l, r\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_ISA_V2\"\n {\n-  enum rtx_code code;\n-\n-  code = GET_CODE (operands[0]);\n-\n-  /* This register-comparison conditional branch has one form:\n-       32-bit instruction =>          beq/bne           imm14s << 1\n-\n-     For 32-bit case,\n-     we assume it is always reachable. (but check range -16350 ~ 16350).  */\n-\n-  switch (code)\n-    {\n-    case EQ:\n-      /* r, r */\n-      switch (get_attr_length (insn))\n-\t{\n-\tcase 4:\n-\t  return \"beq\\t%1, %2, %3\";\n-\tcase 8:\n-\t  /*    beq  $r0, $r1, .L0\n-\t      =>\n-\t        bne  $r0, $r1, .LCB0\n-\t        j  .L0\n-\t      .LCB0:\n-\t   */\n-\t  return \"bne\\t%1, %2, .LCB%=\\;j\\t%3\\n.LCB%=:\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-    case NE:\n-      /* r, r */\n-      switch (get_attr_length (insn))\n-\t{\n-\tcase 4:\n-\t  return \"bne\\t%1, %2, %3\";\n-\tcase 8:\n-\t  /*    bne  $r0, $r1, .L0\n-\t      =>\n-\t        beq  $r0, $r1, .LCB0\n-\t        j  .L0\n-\t      .LCB0:\n-\t   */\n-\t  return \"beq\\t%1, %2, .LCB%=\\;j\\t%3\\n.LCB%=:\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return nds32_output_cbranchsi4_equality_reg (insn, operands);\n }\n   [(set_attr \"type\"   \"branch\")\n-   (set (attr \"length\")\n-\t(if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -16350))\n-\t\t\t   (le (minus (match_dup 3) (pc)) (const_int  16350)))\n-\t\t      (const_int 4)\n-\t\t      (const_int 8)))])\n+   (set_attr_alternative \"enabled\"\n+     [\n+       ;; Alternative 0\n+       (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\"))\n+       ;; Alternative 1\n+       (const_string \"yes\")\n+     ])\n+   (set_attr_alternative \"length\"\n+     [\n+       ;; Alternative 0\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t\t\t\t\t(le (minus (match_dup 3) (pc)) (const_int  250)))\n+\t\t\t\t   (const_int 2)\n+\t\t\t\t   (if_then_else (and (ge (minus (match_dup 3) (pc))\n+\t\t\t\t\t\t\t  (const_int -16350))\n+\t\t\t\t\t\t      (le (minus (match_dup 3) (pc))\n+\t\t\t\t\t\t\t  (const_int  16350)))\n+\t\t\t\t\t\t (const_int 4)\n+\t\t\t\t\t\t (const_int 8)))\n+\t\t     (const_int 8))\n+       ;; Alternative 1\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -16350))\n+\t\t\t\t\t(le (minus (match_dup 3) (pc)) (const_int  16350)))\n+\t\t\t\t   (const_int 4)\n+\t\t\t\t   (const_int 10))\n+\t\t     (const_int 10))\n+     ])])\n \n \n ;; This pattern is dedicated to V3/V3M,\n ;; because V3/V3M DO HAVE beqc/bnec instruction.\n-(define_insn \"*cbranchsi4_equality_reg_or_const_int\"\n+(define_insn \"cbranchsi4_equality_reg_or_const_int\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"nds32_equality_comparison_operator\"\n-\t\t\t[(match_operand:SI 1 \"register_operand\"           \"r,    r\")\n-\t\t\t (match_operand:SI 2 \"nds32_reg_constant_operand\" \"r, Is11\")])\n+\t\t\t[(match_operand:SI 1 \"register_operand\"      \"v, r,    r\")\n+\t\t\t (match_operand:SI 2 \"nds32_rimm11s_operand\" \"l, r, Is11\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_ISA_V3 || TARGET_ISA_V3M\"\n {\n-  enum rtx_code code;\n-\n-  code = GET_CODE (operands[0]);\n-\n-  /* This register-comparison conditional branch has one form:\n-       32-bit instruction =>          beq/bne           imm14s << 1\n-       32-bit instruction =>         beqc/bnec          imm8s << 1\n-\n-     For 32-bit case, we assume it is always reachable.\n-     (but check range -16350 ~ 16350 and -250 ~ 250).  */\n-\n-  switch (code)\n-    {\n-    case EQ:\n-      if (which_alternative == 0)\n-\t{\n-\t  /* r, r */\n-\t  switch (get_attr_length (insn))\n-\t    {\n-\t    case 4:\n-\t      return \"beq\\t%1, %2, %3\";\n-\t    case 8:\n-\t      /*    beq  $r0, $r1, .L0\n-\t          =>\n-\t            bne  $r0, $r1, .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"bne\\t%1, %2, .LCB%=\\;j\\t%3\\n.LCB%=:\";\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* r, Is11 */\n-\t  switch (get_attr_length (insn))\n-\t    {\n-\t    case 4:\n-\t      return \"beqc\\t%1, %2, %3\";\n-\t    case 8:\n-\t      /*    beqc  $r0, constant, .L0\n-\t          =>\n-\t            bnec  $r0, constant, .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"bnec\\t%1, %2, .LCB%=\\;j\\t%3\\n.LCB%=:\";\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-    case NE:\n-      if (which_alternative == 0)\n-\t{\n-\t  /* r, r */\n-\t  switch (get_attr_length (insn))\n-\t    {\n-\t    case 4:\n-\t      return \"bne\\t%1, %2, %3\";\n-\t    case 8:\n-\t      /*    bne  $r0, $r1, .L0\n-\t          =>\n-\t            beq  $r0, $r1, .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"beq\\t%1, %2, .LCB%=\\;j\\t%3\\n.LCB%=:\";\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* r, Is11 */\n-\t  switch (get_attr_length (insn))\n-\t    {\n-\t    case 4:\n-\t      return \"bnec\\t%1, %2, %3\";\n-\t    case 8:\n-\t      /*    bnec  $r0, constant, .L0\n-\t          =>\n-\t            beqc  $r0, constant, .LCB0\n-\t            j  .L0\n-\t          .LCB0:\n-\t       */\n-\t      return \"beqc\\t%1, %2, .LCB%=\\;j\\t%3\\n.LCB%=:\";\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return nds32_output_cbranchsi4_equality_reg_or_const_int (insn, operands);\n }\n   [(set_attr \"type\"   \"branch\")\n+   (set_attr_alternative \"enabled\"\n+     [\n+       ;; Alternative 0\n+       (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t     (const_string \"yes\")\n+\t\t     (const_string \"no\"))\n+       ;; Alternative 1\n+       (const_string \"yes\")\n+       ;; Alternative 2\n+       (const_string \"yes\")\n+     ])\n    (set_attr_alternative \"length\"\n      [\n        ;; Alternative 0\n-       (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -16350))\n-\t\t\t  (le (minus (match_dup 3) (pc)) (const_int  16350)))\n-\t\t     (const_int 4)\n-\t\t     (const_int 8))\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t\t\t\t\t(le (minus (match_dup 3) (pc)) (const_int  250)))\n+\t\t\t\t   (const_int 2)\n+\t\t\t\t   (if_then_else (and (ge (minus (match_dup 3) (pc))\n+\t\t\t\t\t\t\t  (const_int -16350))\n+\t\t\t\t\t\t      (le (minus (match_dup 3) (pc))\n+\t\t\t\t\t\t\t  (const_int  16350)))\n+\t\t\t\t\t\t (const_int 4)\n+\t\t\t\t\t\t (const_int 8)))\n+\t\t    (const_int 8))\n        ;; Alternative 1\n-       (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n-\t\t\t  (le (minus (match_dup 3) (pc)) (const_int  250)))\n-\t\t     (const_int 4)\n-\t\t     (const_int 8))\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -16350))\n+\t\t\t\t\t(le (minus (match_dup 3) (pc)) (const_int  16350)))\n+\t\t\t\t   (const_int 4)\n+\t\t\t\t   (const_int 10))\n+\t\t    (const_int 10))\n+       ;; Alternative 2\n+       (if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t     (if_then_else (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t\t\t\t\t(le (minus (match_dup 3) (pc)) (const_int  250)))\n+\t\t\t\t   (const_int 4)\n+\t\t\t\t   (const_int 10))\n+\t\t    (const_int 10))\n      ])])\n \n \n@@ -1536,80 +1068,16 @@ create_template:\n \t\t      (pc)))]\n   \"\"\n {\n-  enum rtx_code code;\n-\n-  code = GET_CODE (operands[0]);\n-\n-  /* This zero-greater-less-comparison conditional branch has one form:\n-       32-bit instruction =>      bgtz/bgez/bltz/blez     imm16s << 1\n-\n-     For 32-bit case, we assume it is always reachable.\n-     (but check range -65500 ~ 65500).  */\n-\n-  if (get_attr_length (insn) == 8)\n-    {\n-      /* The branch target is too far to simply use one\n-         bgtz/bgez/bltz/blez instruction.\n-         We need to reverse condition and use 'j' to jump to the target.  */\n-      switch (code)\n-\t{\n-\tcase GT:\n-\t  /*   bgtz  $r8, .L0\n-\t     =>\n-\t       blez  $r8, .LCB0\n-\t       j  .L0\n-\t     .LCB0:\n-\t   */\n-\t  return \"blez\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\tcase GE:\n-\t  /*   bgez  $r8, .L0\n-\t     =>\n-\t       bltz  $r8, .LCB0\n-\t       j  .L0\n-\t     .LCB0:\n-\t   */\n-\t  return \"bltz\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\tcase LT:\n-\t  /*   bltz  $r8, .L0\n-\t     =>\n-\t       bgez  $r8, .LCB0\n-\t       j  .L0\n-\t     .LCB0:\n-\t   */\n-\t  return \"bgez\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\tcase LE:\n-\t  /*   blez  $r8, .L0\n-\t     =>\n-\t       bgtz  $r8, .LCB0\n-\t       j  .L0\n-\t     .LCB0:\n-\t   */\n-\t  return \"bgtz\\t%1, .LCB%=\\;j\\t%2\\n.LCB%=:\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-  switch (code)\n-    {\n-    case GT:\n-      return \"bgtz\\t%1, %2\";\n-    case GE:\n-      return \"bgez\\t%1, %2\";\n-    case LT:\n-      return \"bltz\\t%1, %2\";\n-    case LE:\n-      return \"blez\\t%1, %2\";\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return nds32_output_cbranchsi4_greater_less_zero (insn, operands);\n }\n   [(set_attr \"type\"   \"branch\")\n    (set (attr \"length\")\n-        (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n-\t\t\t   (le (minus (match_dup 2) (pc)) (const_int  65500)))\n-\t\t      (const_int 4)\n-\t\t      (const_int 8)))])\n+\t(if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t      (if_then_else (and (ge (minus (match_dup 2) (pc)) (const_int -65500))\n+\t\t\t\t\t (le (minus (match_dup 2) (pc)) (const_int  65500)))\n+\t\t\t\t    (const_int 4)\n+\t\t\t\t    (const_int 10))\n+\t\t      (const_int 10)))])\n \n \n (define_expand \"cstoresi4\"\n@@ -1619,228 +1087,77 @@ create_template:\n \t   (match_operand:SI 3 \"nonmemory_operand\" \"\")]))]\n   \"\"\n {\n-  rtx tmp_reg;\n-  enum rtx_code code;\n-\n-  code = GET_CODE (operands[1]);\n-\n-  switch (code)\n+  enum nds32_expand_result_type result = nds32_expand_cstore (operands);\n+  switch (result)\n     {\n-    case EQ:\n-      if (GET_CODE (operands[3]) == CONST_INT)\n-\t{\n-\t  /* reg_R = (reg_A == const_int_B)\n-\t     --> addi reg_C, reg_A, -const_int_B\n-\t         slti reg_R, reg_C, const_int_1 */\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\t  operands[3] = gen_int_mode (-INTVAL (operands[3]), SImode);\n-\t  /* If the integer value is not in the range of imm15s,\n-\t     we need to force register first because our addsi3 pattern\n-\t     only accept nds32_rimm15s_operand predicate.  */\n-\t  if (!satisfies_constraint_Is15 (operands[3]))\n-\t    operands[3] = force_reg (SImode, operands[3]);\n-\t  emit_insn (gen_addsi3 (tmp_reg, operands[2], operands[3]));\n-\t  emit_insn (gen_slt_compare (operands[0], tmp_reg, const1_rtx));\n-\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  /* reg_R = (reg_A == reg_B)\n-\t     --> xor  reg_C, reg_A, reg_B\n-\t         slti reg_R, reg_C, const_int_1 */\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\t  emit_insn (gen_xorsi3 (tmp_reg, operands[2], operands[3]));\n-\t  emit_insn (gen_slt_compare (operands[0], tmp_reg, const1_rtx));\n-\n-\t  DONE;\n-\t}\n-\n-    case NE:\n-      if (GET_CODE (operands[3]) == CONST_INT)\n-\t{\n-\t  /* reg_R = (reg_A != const_int_B)\n-\t     --> addi reg_C, reg_A, -const_int_B\n-\t         slti reg_R, const_int_0, reg_C */\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\t  operands[3] = gen_int_mode (-INTVAL (operands[3]), SImode);\n-\t  /* If the integer value is not in the range of imm15s,\n-\t     we need to force register first because our addsi3 pattern\n-\t     only accept nds32_rimm15s_operand predicate.  */\n-\t  if (!satisfies_constraint_Is15 (operands[3]))\n-\t    operands[3] = force_reg (SImode, operands[3]);\n-\t  emit_insn (gen_addsi3 (tmp_reg, operands[2], operands[3]));\n-\t  emit_insn (gen_slt_compare (operands[0], const0_rtx, tmp_reg));\n-\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  /* reg_R = (reg_A != reg_B)\n-\t     --> xor  reg_C, reg_A, reg_B\n-\t         slti reg_R, const_int_0, reg_C */\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\t  emit_insn (gen_xorsi3 (tmp_reg, operands[2], operands[3]));\n-\t  emit_insn (gen_slt_compare (operands[0], const0_rtx, tmp_reg));\n-\n-\t  DONE;\n-\t}\n-\n-    case GT:\n-    case GTU:\n-      /* reg_R = (reg_A > reg_B)       --> slt reg_R, reg_B, reg_A */\n-      /* reg_R = (reg_A > const_int_B) --> slt reg_R, const_int_B, reg_A */\n-      if (code == GT)\n-\t{\n-\t  /* GT, use slts instruction */\n-\t  emit_insn (gen_slts_compare (operands[0], operands[3], operands[2]));\n-\t}\n-      else\n-\t{\n-\t  /* GTU, use slt instruction */\n-\t  emit_insn (gen_slt_compare  (operands[0], operands[3], operands[2]));\n-\t}\n-\n+    case EXPAND_DONE:\n       DONE;\n-\n-    case GE:\n-    case GEU:\n-      if (GET_CODE (operands[3]) == CONST_INT)\n-\t{\n-\t  /* reg_R = (reg_A >= const_int_B)\n-\t     --> movi reg_C, const_int_B - 1\n-\t         slt  reg_R, reg_C, reg_A */\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\n-\t  emit_insn (gen_movsi (tmp_reg,\n-\t\t\t\tgen_int_mode (INTVAL (operands[3]) - 1,\n-\t\t\t\t\t      SImode)));\n-\t  if (code == GE)\n-\t    {\n-\t      /* GE, use slts instruction */\n-\t      emit_insn (gen_slts_compare (operands[0], tmp_reg, operands[2]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* GEU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (operands[0], tmp_reg, operands[2]));\n-\t    }\n-\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  /* reg_R = (reg_A >= reg_B)\n-\t     --> slt  reg_R, reg_A, reg_B\n-\t         xori reg_R, reg_R, const_int_1 */\n-\t  if (code == GE)\n-\t    {\n-\t      /* GE, use slts instruction */\n-\t      emit_insn (gen_slts_compare (operands[0],\n-\t\t\t\t\t   operands[2], operands[3]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* GEU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (operands[0],\n-\t\t\t\t\t   operands[2], operands[3]));\n-\t    }\n-\n-\t  /* perform 'not' behavior */\n-\t  emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n-\n-\t  DONE;\n-\t}\n-\n-    case LT:\n-    case LTU:\n-      /* reg_R = (reg_A < reg_B)       --> slt reg_R, reg_A, reg_B */\n-      /* reg_R = (reg_A < const_int_B) --> slt reg_R, reg_A, const_int_B */\n-      if (code == LT)\n-\t{\n-\t  /* LT, use slts instruction */\n-\t  emit_insn (gen_slts_compare (operands[0], operands[2], operands[3]));\n-\t}\n-      else\n-\t{\n-\t  /* LTU, use slt instruction */\n-\t  emit_insn (gen_slt_compare  (operands[0], operands[2], operands[3]));\n-\t}\n-\n-      DONE;\n-\n-    case LE:\n-    case LEU:\n-      if (GET_CODE (operands[3]) == CONST_INT)\n-\t{\n-\t  /* reg_R = (reg_A <= const_int_B)\n-\t     --> movi reg_C, const_int_B + 1\n-\t         slt  reg_R, reg_A, reg_C */\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\n-\t  emit_insn (gen_movsi (tmp_reg,\n-\t\t\t\tgen_int_mode (INTVAL (operands[3]) + 1,\n-\t\t\t\t\t\t      SImode)));\n-\t  if (code == LE)\n-\t    {\n-\t      /* LE, use slts instruction */\n-\t      emit_insn (gen_slts_compare (operands[0], operands[2], tmp_reg));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* LEU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (operands[0], operands[2], tmp_reg));\n-\t    }\n-\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  /* reg_R = (reg_A <= reg_B) --> slt  reg_R, reg_B, reg_A\n-\t                                  xori reg_R, reg_R, const_int_1 */\n-\t  if (code == LE)\n-\t    {\n-\t      /* LE, use slts instruction */\n-\t      emit_insn (gen_slts_compare (operands[0],\n-\t\t\t\t\t   operands[3], operands[2]));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* LEU, use slt instruction */\n-\t      emit_insn (gen_slt_compare  (operands[0],\n-\t\t\t\t\t   operands[3], operands[2]));\n-\t    }\n-\n-\t  /* perform 'not' behavior */\n-\t  emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n-\n-\t  DONE;\n-\t}\n-\n-\n+      break;\n+    case EXPAND_FAIL:\n+      FAIL;\n+      break;\n+    case EXPAND_CREATE_TEMPLATE:\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n })\n \n \n-(define_insn \"slts_compare\"\n-  [(set (match_operand:SI 0 \"register_operand\"         \"=t,    t, r,    r\")\n-\t(lt:SI (match_operand:SI 1 \"nonmemory_operand\" \" d,    d, r,    r\")\n-\t       (match_operand:SI 2 \"nonmemory_operand\" \" r, Iu05, r, Is15\")))]\n+(define_expand \"slts_compare\"\n+  [(set (match_operand:SI 0 \"register_operand\"       \"\")\n+\t(lt:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t       (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!REG_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+\n+  if (!REG_P (operands[2]) && !satisfies_constraint_Is15 (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n+\n+(define_insn \"slts_compare_impl\"\n+  [(set (match_operand:SI 0 \"register_operand\"             \"=t,   t, r,    r\")\n+\t(lt:SI (match_operand:SI 1 \"register_operand\"      \" d,   d, r,    r\")\n+\t       (match_operand:SI 2 \"nds32_rimm15s_operand\" \" r,Iu05, r, Is15\")))]\n   \"\"\n   \"@\n    slts45\\t%1, %2\n    sltsi45\\t%1, %2\n    slts\\t%0, %1, %2\n    sltsi\\t%0, %1, %2\"\n-  [(set_attr \"type\"   \"    alu,    alu,    alu,    alu\")\n-   (set_attr \"length\" \"      2,      2,      4,      4\")])\n+  [(set_attr \"type\"   \"alu,    alu,    alu,    alu\")\n+   (set_attr \"length\" \"  2,      2,      4,      4\")])\n+\n+(define_insn \"slt_eq0\"\n+  [(set (match_operand:SI 0 \"register_operand\"        \"=t, r\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \" d, r\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"@\n+   slti45\\t%1, 1\n+   slti\\t%0, %1, 1\"\n+  [(set_attr \"type\"   \"alu, alu\")\n+   (set_attr \"length\" \"  2,   4\")])\n+\n+(define_expand \"slt_compare\"\n+  [(set (match_operand:SI 0 \"register_operand\"        \"\")\n+\t(ltu:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!REG_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+\n+  if (!REG_P (operands[2]) && !satisfies_constraint_Is15 (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n \n-(define_insn \"slt_compare\"\n-  [(set (match_operand:SI 0 \"register_operand\"          \"=t,    t, r,    r\")\n-\t(ltu:SI (match_operand:SI 1 \"nonmemory_operand\" \" d,    d, r,    r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \" r, Iu05, r, Is15\")))]\n+(define_insn \"slt_compare_impl\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=t,    t, r,    r\")\n+\t(ltu:SI (match_operand:SI 1 \"register_operand\"      \" d,    d, r,    r\")\n+\t\t(match_operand:SI 2 \"nds32_rimm15s_operand\" \" r, Iu05, r, Is15\")))]\n   \"\"\n   \"@\n    slt45\\t%1, %2\n@@ -1883,10 +1200,12 @@ create_template:\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"enabled\" \"yes\")\n    (set (attr \"length\")\n-\t(if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -250))\n-\t\t\t   (le (minus (match_dup 0) (pc)) (const_int  250)))\n-\t\t      (if_then_else (match_test \"TARGET_16_BIT\")\n-\t\t\t\t    (const_int 2)\n+\t(if_then_else (match_test \"!CROSSING_JUMP_P (insn)\")\n+\t\t      (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -250))\n+\t\t\t\t\t (le (minus (match_dup 0) (pc)) (const_int  250)))\n+\t\t\t\t    (if_then_else (match_test \"TARGET_16_BIT\")\n+\t\t\t\t\t\t  (const_int 2)\n+\t\t\t\t\t\t  (const_int 4))\n \t\t\t\t    (const_int 4))\n \t\t      (const_int 4)))])\n "}, {"sha": "7cf4635e1cf971342289f7865d9122a16f0cbdbd", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9ca9328ae625ad366d6a1043f2b8df58b56cb6/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=6e9ca9328ae625ad366d6a1043f2b8df58b56cb6", "patch": "@@ -24,6 +24,9 @@\n (define_predicate \"nds32_greater_less_comparison_operator\"\n   (match_code \"gt,ge,lt,le\"))\n \n+(define_predicate \"nds32_movecc_comparison_operator\"\n+  (match_code \"eq,ne,le,leu,ge,geu\"))\n+\n (define_special_predicate \"nds32_logical_binary_operator\"\n   (match_code \"and,ior,xor\"))\n \n@@ -39,6 +42,11 @@\n        (and (match_operand 0 \"const_int_operand\")\n \t    (match_test \"satisfies_constraint_Is15 (op)\"))))\n \n+(define_predicate \"nds32_rimm11s_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_operand 0 \"const_int_operand\")\n+\t    (match_test \"satisfies_constraint_Is11 (op)\"))))\n+\n (define_predicate \"nds32_imm5u_operand\"\n   (and (match_operand 0 \"const_int_operand\")\n        (match_test \"satisfies_constraint_Iu05 (op)\")))"}]}