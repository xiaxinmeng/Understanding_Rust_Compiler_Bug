{"sha": "860603449e04d4a21c9b695e72232639d8bf4f34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwNjAzNDQ5ZTA0ZDRhMjFjOWI2OTVlNzIyMzI2MzlkOGJmNGYzNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-16T15:04:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-16T15:04:26Z"}, "message": "gigi.h (gnat_init_decl_processing): Delete.\n\n\t* gcc-interface/gigi.h (gnat_init_decl_processing): Delete.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Constify a few variables.\n\t<object>: Do not create the fake PARM_DECL if no debug info is needed.\n\tDo not create the corresponding VAR_DECL of a CONST_DECL for debugging\n\tpurposes if no debug info is needed.\n\tFix formatting.  Reorder and add comments.\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Attribute_Reference>: Constify\n\tvariable and remove obsolete comment.\n\t* gcc-interface/utils.c (convert_vms_descriptor64): Tweak comment.\n\t(convert_vms_descriptor32): Likewise.\n\t(convert): Remove dead code.\n\t<UNCONSTRAINED_ARRAY_REF>: Pass the field instead of its name to build\n\tthe reference to the P_ARRAY pointer.\n\t<POINTER_TYPE>: Likewise.\n\t(maybe_unconstrained_array) <UNCONSTRAINED_ARRAY_TYPE>: Likewise.\n\t(gnat_init_decl_processing): Delete, move contents to...\n\t* gcc-interface/misc.c (gnat_init): ...here.\n\nFrom-SVN: r158428", "tree": {"sha": "1b898ebbf96f3d1614cf445a68b90becfcb2e0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b898ebbf96f3d1614cf445a68b90becfcb2e0a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/860603449e04d4a21c9b695e72232639d8bf4f34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860603449e04d4a21c9b695e72232639d8bf4f34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/860603449e04d4a21c9b695e72232639d8bf4f34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860603449e04d4a21c9b695e72232639d8bf4f34/comments", "author": null, "committer": null, "parents": [{"sha": "9b04d6de98437348c1423741c6987ad3c958913b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b04d6de98437348c1423741c6987ad3c958913b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b04d6de98437348c1423741c6987ad3c958913b"}], "stats": {"total": 347, "additions": 184, "deletions": 163}, "files": [{"sha": "261263592e92e36c51bd228240078bc320dc446c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=860603449e04d4a21c9b695e72232639d8bf4f34", "patch": "@@ -1,3 +1,23 @@\n+2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gnat_init_decl_processing): Delete.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Constify a few variables.\n+\t<object>: Do not create the fake PARM_DECL if no debug info is needed.\n+\tDo not create the corresponding VAR_DECL of a CONST_DECL for debugging\n+\tpurposes if no debug info is needed.\n+\tFix formatting.  Reorder and add comments.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Attribute_Reference>: Constify\n+\tvariable and remove obsolete comment.\n+\t* gcc-interface/utils.c (convert_vms_descriptor64): Tweak comment.\n+\t(convert_vms_descriptor32): Likewise.\n+\t(convert): Remove dead code.\n+\t<UNCONSTRAINED_ARRAY_REF>: Pass the field instead of its name to build\n+\tthe reference to the P_ARRAY pointer.\n+\t<POINTER_TYPE>: Likewise.\n+\t(maybe_unconstrained_array) <UNCONSTRAINED_ARRAY_TYPE>: Likewise.\n+\t(gnat_init_decl_processing): Delete, move contents to...\n+\t* gcc-interface/misc.c (gnat_init): ...here.\n+\n 2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (unchecked_conversion_nop): Handle function"}, {"sha": "02d729621bcf55405c709db839e86aae518d1beb", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 108, "deletions": 99, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=860603449e04d4a21c9b695e72232639d8bf4f34", "patch": "@@ -182,6 +182,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   const Entity_Kind kind = Ekind (gnat_entity);\n   /* True if this is a type.  */\n   const bool is_type = IN (kind, Type_Kind);\n+  /* True if debug info is requested for this entity.  */\n+  const bool debug_info_p = Needs_Debug_Info (gnat_entity);\n+  /* True if this entity is to be considered as imported.  */\n+  const bool imported_p\n+    = (Is_Imported (gnat_entity) && No (Address_Clause (gnat_entity)));\n   /* For a type, contains the equivalent GNAT node to be used in gigi.  */\n   Entity_Id gnat_equiv_type = Empty;\n   /* Temporary used to walk the GNAT tree.  */\n@@ -206,11 +211,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   bool maybe_present = false;\n   /* True if we made GNU_DECL and its type here.  */\n   bool this_made_decl = false;\n-  /* True if debug info is requested for this entity.  */\n-  bool debug_info_p = Needs_Debug_Info (gnat_entity);\n-  /* True if this entity is to be considered as imported.  */\n-  bool imported_p = (Is_Imported (gnat_entity)\n-\t\t     && No (Address_Clause (gnat_entity)));\n   /* Size and alignment of the GCC node, if meaningful.  */\n   unsigned int esize = 0, align = 0;\n   /* Contains the list of attributes directly attached to the entity.  */\n@@ -548,10 +548,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Out_Parameter:\n     case E_Variable:\n \n-      /* Simple variables, loop variables, Out parameters, and exceptions.  */\n+      /* Simple variables, loop variables, Out parameters and exceptions.  */\n     object:\n       {\n-\tbool used_by_ref = false;\n \tbool const_flag\n \t  = ((kind == E_Constant || kind == E_Variable)\n \t     && Is_True_Constant (gnat_entity)\n@@ -563,6 +562,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool inner_const_flag = const_flag;\n \tbool static_p = Is_Statically_Allocated (gnat_entity);\n \tbool mutable_p = false;\n+\tbool used_by_ref = false;\n \ttree gnu_ext_name = NULL_TREE;\n \ttree renamed_obj = NULL_TREE;\n \ttree gnu_object_size;\n@@ -604,9 +604,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (kind == E_Loop_Parameter)\n \t  gnu_type = get_base_type (gnu_type);\n \n-\t/* Reject non-renamed objects whose types are unconstrained arrays or\n-\t   any object whose type is a dummy type or VOID_TYPE.  */\n-\n+\t/* Reject non-renamed objects whose type is an unconstrained array or\n+\t   any object whose type is a dummy type or void.  */\n \tif ((TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n \t     && No (Renamed_Object (gnat_entity)))\n \t    || TYPE_IS_DUMMY_P (gnu_type)\n@@ -626,6 +625,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gcc_assert (Present (Alignment (gnat_entity)));\n \t    align = validate_alignment (Alignment (gnat_entity), gnat_entity,\n \t\t\t\t\tTYPE_ALIGN (gnu_type));\n+\n \t    /* No point in changing the type if there is an address clause\n \t       as the final type of the object will be a reference type.  */\n \t    if (Present (Address_Clause (gnat_entity)))\n@@ -636,11 +636,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t  false, false, definition, true);\n \t  }\n \n-\t/* If we are defining the object, see if it has a Size value and\n-\t   validate it if so.  If we are not defining the object and a Size\n-\t   clause applies, simply retrieve the value.  We don't want to ignore\n-\t   the clause and it is expected to have been validated already.  Then\n-\t   get the new type, if any.  */\n+\t/* If we are defining the object, see if it has a Size and validate it\n+\t   if so.  If we are not defining the object and a Size clause applies,\n+\t   simply retrieve the value.  We don't want to ignore the clause and\n+\t   it is expected to have been validated already.  Then get the new\n+\t   type, if any.  */\n \tif (definition)\n \t  gnu_size = validate_size (Esize (gnat_entity), gnu_type,\n \t\t\t\t    gnat_entity, VAR_DECL, false,\n@@ -659,8 +659,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \t/* If this object has self-referential size, it must be a record with\n-\t   a default value.  We are supposed to allocate an object of the\n-\t   maximum size in this case unless it is a constant with an\n+\t   a default discriminant.  We are supposed to allocate an object of\n+\t   the maximum size in this case, unless it is a constant with an\n \t   initializing expression, in which case we can get the size from\n \t   that.  Note that the resulting size may still be a variable, so\n \t   this may end up with an indirect allocation.  */\n@@ -707,8 +707,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t  }\n \n-\t/* If the size is zero bytes, make it one byte since some linkers have\n-\t   trouble with zero-sized objects.  If the object will have a\n+\t/* If the size is zero byte, make it one byte since some linkers have\n+\t   troubles with zero-sized objects.  If the object will have a\n \t   template, that will make it nonzero so don't bother.  Also avoid\n \t   doing that for an object renaming or an object with an address\n \t   clause, as we would lose useful information on the view size\n@@ -774,7 +774,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t   ??? Note that we ignore Has_Volatile_Components on objects; it's\n \t   not at all clear what to do in that case.  */\n-\n \tif (Has_Atomic_Components (gnat_entity))\n \t  {\n \t    tree gnu_inner = (TREE_CODE (gnu_type) == ARRAY_TYPE\n@@ -789,10 +788,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Now check if the type of the object allows atomic access.  Note\n \t   that we must test the type, even if this object has size and\n-\t   alignment to allow such access, because we will be going\n-\t   inside the padded record to assign to the object.  We could fix\n-\t   this by always copying via an intermediate value, but it's not\n-\t   clear it's worth the effort.  */\n+\t   alignment to allow such access, because we will be going inside\n+\t   the padded record to assign to the object.  We could fix this by\n+\t   always copying via an intermediate value, but it's not clear it's\n+\t   worth the effort.  */\n \tif (Is_Atomic (gnat_entity))\n \t  check_ok_for_atomic (gnu_type, gnat_entity, false);\n \n@@ -1024,16 +1023,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = TYPE_PADDING_P (gnu_type)\n \t\t? TYPE_FIELDS (TREE_TYPE (TYPE_FIELDS (gnu_type)))\n \t\t: TYPE_FIELDS (gnu_type);\n-\n \t    gnu_expr\n \t      = gnat_build_constructor\n-\t      (gnu_type,\n-\t       tree_cons\n-\t       (template_field,\n-\t\tbuild_template (TREE_TYPE (template_field),\n-\t\t\t\tTREE_TYPE (TREE_CHAIN (template_field)),\n-\t\t\t\tNULL_TREE),\n-\t\tNULL_TREE));\n+\t\t(gnu_type,\n+\t\t tree_cons\n+\t\t (template_field,\n+\t\t  build_template (TREE_TYPE (template_field),\n+\t\t\t\t  TREE_TYPE (TREE_CHAIN (template_field)),\n+\t\t\t\t  NULL_TREE),\n+\t\t  NULL_TREE));\n \t  }\n \n \t/* Convert the expression to the type of the object except in the\n@@ -1050,12 +1048,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type))))))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n-\t/* If this is a pointer and it does not have an initializing\n-\t   expression, initialize it to NULL, unless the object is\n-\t   imported.  */\n+\t/* If this is a pointer that doesn't have an initializing expression,\n+\t   initialize it to NULL, unless the object is imported.  */\n \tif (definition\n \t    && (POINTER_TYPE_P (gnu_type) || TYPE_IS_FAT_POINTER_P (gnu_type))\n-\t    && !Is_Imported (gnat_entity) && !gnu_expr)\n+\t    && !gnu_expr\n+\t    && !Is_Imported (gnat_entity))\n \t  gnu_expr = integer_zero_node;\n \n \t/* If we are defining the object and it has an Address clause, we must\n@@ -1065,10 +1063,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   effects in this case.  */\n \tif (definition && Present (Address_Clause (gnat_entity)))\n \t  {\n+\t    Node_Id gnat_expr = Expression (Address_Clause (gnat_entity));\n \t    tree gnu_address\n \t      = present_gnu_tree (gnat_entity)\n-\t\t? get_gnu_tree (gnat_entity)\n-\t\t: gnat_to_gnu (Expression (Address_Clause (gnat_entity)));\n+\t\t? get_gnu_tree (gnat_entity) : gnat_to_gnu (gnat_expr);\n \n \t    save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n@@ -1081,9 +1079,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n \t    gnu_address = convert (gnu_type, gnu_address);\n \t    used_by_ref = true;\n-\t    const_flag = !Is_Public (gnat_entity)\n-\t      || compile_time_known_address_p (Expression (Address_Clause\n-\t\t\t\t\t\t\t   (gnat_entity)));\n+\t    const_flag\n+\t      = !Is_Public (gnat_entity)\n+\t\t|| compile_time_known_address_p (gnat_expr);\n \n \t    /* If this is a deferred constant, the initializer is attached to\n \t       the full view.  */\n@@ -1154,14 +1152,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   If the object's size overflows, make an allocator too, so that\n \t   Storage_Error gets raised.  Note that we will never free\n \t   such memory, so we presume it never will get allocated.  */\n-\n \tif (!allocatable_size_p (TYPE_SIZE_UNIT (gnu_type),\n-\t\t\t\t global_bindings_p () || !definition\n+\t\t\t\t global_bindings_p ()\n+\t\t\t\t || !definition\n \t\t\t\t || static_p)\n-\t    || (gnu_size\n-\t\t&& ! allocatable_size_p (gnu_size,\n-\t\t\t\t\t global_bindings_p () || !definition\n-\t\t\t\t\t || static_p)))\n+\t    || (gnu_size && !allocatable_size_p (gnu_size,\n+\t\t\t\t\t\t global_bindings_p ()\n+\t\t\t\t\t\t || !definition\n+\t\t\t\t\t\t || static_p)))\n \t  {\n \t    gnu_type = build_reference_type (gnu_type);\n \t    gnu_size = NULL_TREE;\n@@ -1180,7 +1178,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       If we are elaborating a mutable object, tell build_allocator to\n \t       ignore a possibly simpler size from the initializer, if any, as\n \t       we must allocate the maximum possible size in this case.  */\n-\n \t    if (definition)\n \t      {\n \t\ttree gnu_alloc_type = TREE_TYPE (gnu_type);\n@@ -1302,13 +1299,32 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    (TREE_TYPE (TYPE_FIELDS (gnu_type))), 1)))\n \t  static_p = true;\n \n+\t/* Now create the variable or the constant and set various flags.  */\n \tgnu_decl\n \t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t     gnu_expr, const_flag, Is_Public (gnat_entity),\n \t\t\t     imported_p || !definition, static_p, attr_list,\n \t\t\t     gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n+\n+\t/* If we are defining an Out parameter and optimization isn't enabled,\n+\t   create a fake PARM_DECL for debugging purposes and make it point to\n+\t   the VAR_DECL.  Suppress debug info for the latter but make sure it\n+\t   will live on the stack so that it can be accessed from within the\n+\t   debugger through the PARM_DECL.  */\n+\tif (kind == E_Out_Parameter && definition && !optimize && debug_info_p)\n+\t  {\n+\t    tree param = create_param_decl (gnu_entity_name, gnu_type, false);\n+\t    gnat_pushdecl (param, gnat_entity);\n+\t    SET_DECL_VALUE_EXPR (param, gnu_decl);\n+\t    DECL_HAS_VALUE_EXPR_P (param) = 1;\n+\t    DECL_IGNORED_P (gnu_decl) = 1;\n+\t    TREE_ADDRESSABLE (gnu_decl) = 1;\n+\t  }\n+\n+\t/* If this is a renaming pointer, attach the renamed object to it and\n+\t   register it if we are at top level.  */\n \tif (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n \t  {\n \t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n@@ -1319,46 +1335,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t  }\n \n-\tif (definition && DECL_SIZE_UNIT (gnu_decl)\n-\t    && get_block_jmpbuf_decl ()\n-\t    && (TREE_CODE (DECL_SIZE_UNIT (gnu_decl)) != INTEGER_CST\n-\t\t|| (flag_stack_check == GENERIC_STACK_CHECK\n-\t\t    && compare_tree_int (DECL_SIZE_UNIT (gnu_decl),\n-\t\t\t\t\t STACK_CHECK_MAX_VAR_SIZE) > 0)))\n-\t  add_stmt_with_node (build_call_1_expr\n-\t\t\t      (update_setjmp_buf_decl,\n-\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t       get_block_jmpbuf_decl ())),\n-\t\t\t      gnat_entity);\n-\n-\t/* If we are defining an Out parameter and we're not optimizing,\n-\t   create a fake PARM_DECL for debugging purposes and make it\n-\t   point to the VAR_DECL.  Suppress debug info for the latter\n-\t   but make sure it will still live on the stack so it can be\n-\t   accessed from within the debugger through the PARM_DECL.  */\n-\tif (kind == E_Out_Parameter && definition && !optimize)\n-\t  {\n-\t    tree param = create_param_decl (gnu_entity_name, gnu_type, false);\n-\t    gnat_pushdecl (param, gnat_entity);\n-\t    SET_DECL_VALUE_EXPR (param, gnu_decl);\n-\t    DECL_HAS_VALUE_EXPR_P (param) = 1;\n-\t    if (debug_info_p)\n-\t      debug_info_p = false;\n-\t    else\n-\t      DECL_IGNORED_P (param) = 1;\n-\t    TREE_ADDRESSABLE (gnu_decl) = 1;\n-\t  }\n-\n-\t/* If this is a public constant or we're not optimizing and we're not\n-\t   making a VAR_DECL for it, make one just for export or debugger use.\n-\t   Likewise if the address is taken or if either the object or type is\n-\t   aliased.  Make an external declaration for a reference, unless this\n-\t   is a Standard entity since there no real symbol at the object level\n-\t   for these.  */\n+\t/* If this is a constant and we are defining it or it generates a real\n+\t   symbol at the object level and we are referencing it, we may want\n+\t   or need to have a true variable to represent it:\n+\t     - if optimization isn't enabled, for debugging purposes,\n+\t     - if the constant is public and not overlaid on something else,\n+\t     - if its address is taken,\n+\t     - if either itself or its type is aliased.  */\n \tif (TREE_CODE (gnu_decl) == CONST_DECL\n \t    && (definition || Sloc (gnat_entity) > Standard_Location)\n-\t    && ((Is_Public (gnat_entity) && No (Address_Clause (gnat_entity)))\n-\t\t|| !optimize\n+\t    && ((!optimize && debug_info_p)\n+\t\t|| (Is_Public (gnat_entity)\n+\t\t    && No (Address_Clause (gnat_entity)))\n \t\t|| Address_Taken (gnat_entity)\n \t\t|| Is_Aliased (gnat_entity)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n@@ -1372,8 +1360,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \n \t    /* As debugging information will be generated for the variable,\n-\t       do not generate information for the constant.  */\n-\t    DECL_IGNORED_P (gnu_decl) = 1;\n+\t       do not generate debugging information for the constant.  */\n+\t    if (debug_info_p)\n+\t      DECL_IGNORED_P (gnu_decl) = 1;\n+\t    else\n+\t      DECL_IGNORED_P (gnu_corr_var) = 1;\n \t  }\n \n \t/* If this is a constant, even if we don't need a true variable, we\n@@ -1385,13 +1376,31 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (TREE_CODE (gnu_decl) == CONST_DECL)\n \t  DECL_CONST_ADDRESS_P (gnu_decl) = constructor_address_p (gnu_expr);\n \n-\t/* If this is declared in a block that contains a block with an\n-\t   exception handler, we must force this variable in memory to\n-\t   suppress an invalid optimization.  */\n-\tif (Has_Nested_Block_With_Handler (Scope (gnat_entity))\n-\t    && Exception_Mechanism != Back_End_Exceptions)\n+\t/* If this object is declared in a block that contains a block with an\n+\t   exception handler, and we aren't using the GCC exception mechanism,\n+\t   we must force this variable in memory in order to avoid an invalid\n+\t   optimization.  */\n+\tif (Exception_Mechanism != Back_End_Exceptions\n+\t    && Has_Nested_Block_With_Handler (Scope (gnat_entity)))\n \t  TREE_ADDRESSABLE (gnu_decl) = 1;\n \n+\t/* If we are defining an object with variable size or an object with\n+\t   fixed size that will be dynamically allocated, and we are using the\n+\t   setjmp/longjmp exception mechanism, update the setjmp buffer.  */\n+\tif (definition\n+\t    && Exception_Mechanism == Setjmp_Longjmp\n+\t    && get_block_jmpbuf_decl ()\n+\t    && DECL_SIZE_UNIT (gnu_decl)\n+\t    && (TREE_CODE (DECL_SIZE_UNIT (gnu_decl)) != INTEGER_CST\n+\t\t|| (flag_stack_check == GENERIC_STACK_CHECK\n+\t\t    && compare_tree_int (DECL_SIZE_UNIT (gnu_decl),\n+\t\t\t\t\t STACK_CHECK_MAX_VAR_SIZE) > 0)))\n+\t  add_stmt_with_node (build_call_1_expr\n+\t\t\t      (update_setjmp_buf_decl,\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t       get_block_jmpbuf_decl ())),\n+\t\t\t      gnat_entity);\n+\n \t/* Back-annotate Esize and Alignment of the object if not already\n \t   known.  Note that we pick the values of the type, not those of\n \t   the object, to shield ourselves from low-level platform-dependent\n@@ -1969,7 +1978,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Now make the array of arrays and update the pointer to the array\n \t   in the fat pointer.  Note that it is the first field.  */\n-        tem = gnat_to_gnu_component_type (gnat_entity, definition,\n+\ttem = gnat_to_gnu_component_type (gnat_entity, definition,\n \t\t\t\t\t  debug_info_p);\n \n \t/* If Component_Size is not already specified, annotate it with the\n@@ -2023,7 +2032,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n \n \t/* If the maximum size doesn't overflow, use it.  */\n-        if (gnu_max_size\n+\tif (gnu_max_size\n \t    && TREE_CODE (gnu_max_size) == INTEGER_CST\n \t    && !TREE_OVERFLOW (gnu_max_size)\n \t    && TREE_CODE (gnu_max_size_unit) == INTEGER_CST\n@@ -2049,9 +2058,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t  gnu_fat_type, NULL, true,\n \t\t\t  debug_info_p, gnat_entity);\n \n-       /* Create the type to be used as what a thin pointer designates: an\n-          record type for the object and its template with the field offsets\n-          shifted to have the template at a negative offset.  */\n+\t/* Create the type to be used as what a thin pointer designates:\n+\t   a record type for the object and its template with the fields\n+\t   shifted to have the template at a negative offset.  */\n \ttem = build_unc_object_type (gnu_template_type, tem,\n \t\t\t\t     create_concat_name (gnat_name, \"XUT\"));\n \tshift_unc_components_for_thin_pointers (tem);\n@@ -2901,7 +2910,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      debug_info_p, false);\n \n \t/* If it is passed by reference, force BLKmode to ensure that objects\n-+\t   of this type will always be put in memory.  */\n+\t   of this type will always be put in memory.  */\n \tif (Is_By_Reference_Type (gnat_entity))\n \t  SET_TYPE_MODE (gnu_type, BLKmode);\n "}, {"sha": "61baf34d26ff412495dc69972a55503d64afab20", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=860603449e04d4a21c9b695e72232639d8bf4f34", "patch": "@@ -444,7 +444,6 @@ extern tree get_block_jmpbuf_decl (void);\n    and uses GNAT_NODE for location information.  */\n extern void gnat_pushdecl (tree decl, Node_Id gnat_node);\n \n-extern void gnat_init_decl_processing (void);\n extern void gnat_init_gcc_eh (void);\n extern void gnat_install_builtins (void);\n "}, {"sha": "1b31890f32c922251d4dc5f6ca991e6d3edc9cc0", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=860603449e04d4a21c9b695e72232639d8bf4f34", "patch": "@@ -388,9 +388,31 @@ internal_error_function (const char *msgid, va_list *ap)\n static bool\n gnat_init (void)\n {\n-  /* Performs whatever initialization steps needed by the language-dependent\n-     lexical analyzer.  */\n-  gnat_init_decl_processing ();\n+  /* Do little here, most of the standard declarations are set up after the\n+     front-end has been run.  */\n+  build_common_tree_nodes (true, true);\n+\n+  /* In Ada, we use a signed type for SIZETYPE.  Use the signed type\n+     corresponding to the width of Pmode.  In most cases when ptr_mode\n+     and Pmode differ, C will use the width of ptr_mode for SIZETYPE.\n+     But we get far better code using the width of Pmode.  */\n+  size_type_node = gnat_type_for_mode (Pmode, 0);\n+  set_sizetype (size_type_node);\n+\n+  /* In Ada, we use an unsigned 8-bit type for the default boolean type.  */\n+  boolean_type_node = make_unsigned_type (8);\n+  TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n+  SET_TYPE_RM_MAX_VALUE (boolean_type_node,\n+\t\t\t build_int_cst (boolean_type_node, 1));\n+  SET_TYPE_RM_SIZE (boolean_type_node, bitsize_int (1));\n+\n+  build_common_tree_nodes_2 (0);\n+  boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n+\n+  ptr_void_type_node = build_pointer_type (void_type_node);\n+\n+  /* Show that REFERENCE_TYPEs are internal and should be Pmode.  */\n+  internal_reference_types ();\n \n   /* Add the input filename as the last argument.  */\n   if (main_input_filename)\n@@ -400,11 +422,9 @@ gnat_init (void)\n       gnat_argv[gnat_argc] = NULL;\n     }\n \n+  /* Register our internal error function.  */\n   global_dc->internal_error = &internal_error_function;\n \n-  /* Show that REFERENCE_TYPEs are internal and should be Pmode.  */\n-  internal_reference_types ();\n-\n   return true;\n }\n "}, {"sha": "7f35bc2ca57c659ec41742dcb81e2845a91fb8a2", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=860603449e04d4a21c9b695e72232639d8bf4f34", "patch": "@@ -4285,21 +4285,20 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Attribute_Reference:\n       {\n-\t/* The attribute designator (like an enumeration value).  */\n-\tint attribute = Get_Attribute_Id (Attribute_Name (gnat_node));\n-\n-\t/* The Elab_Spec and Elab_Body attributes are special in that\n-\t   Prefix is a unit, not an object with a GCC equivalent.  Similarly\n-\t   for Elaborated, since that variable isn't otherwise known.  */\n-\tif (attribute == Attr_Elab_Body || attribute == Attr_Elab_Spec)\n-\t  return (create_subprog_decl\n-\t\t  (create_concat_name (Entity (Prefix (gnat_node)),\n-\t\t\t\t       attribute == Attr_Elab_Body\n-\t\t\t\t       ? \"elabb\" : \"elabs\"),\n-\t\t   NULL_TREE, void_ftype, NULL_TREE, false, true, true, NULL,\n-\t\t   gnat_node));\n-\n-\tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attribute);\n+\t/* The attribute designator.  */\n+\tconst int attr = Get_Attribute_Id (Attribute_Name (gnat_node));\n+\n+\t/* The Elab_Spec and Elab_Body attributes are special in that Prefix\n+\t   is a unit, not an object with a GCC equivalent.  */\n+\tif (attr == Attr_Elab_Spec || attr == Attr_Elab_Body)\n+\t  return\n+\t    create_subprog_decl (create_concat_name\n+\t\t\t\t (Entity (Prefix (gnat_node)),\n+\t\t\t\t  attr == Attr_Elab_Body ? \"elabb\" : \"elabs\"),\n+\t\t\t\t NULL_TREE, void_ftype, NULL_TREE, false,\n+\t\t\t\t true, true, NULL, gnat_node);\n+\n+\tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attr);\n       }\n       break;\n "}, {"sha": "e110ef51e32b7d632efd5fe316b3c19088489583", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 16, "deletions": 42, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/860603449e04d4a21c9b695e72232639d8bf4f34/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=860603449e04d4a21c9b695e72232639d8bf4f34", "patch": "@@ -514,34 +514,6 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     }\n }\n \f\n-/* Do little here.  Set up the standard declarations later after the\n-   front end has been run.  */\n-\n-void\n-gnat_init_decl_processing (void)\n-{\n-  build_common_tree_nodes (true, true);\n-\n-  /* In Ada, we use a signed type for SIZETYPE.  Use the signed type\n-     corresponding to the width of Pmode.  In most cases when ptr_mode\n-     and Pmode differ, C will use the width of ptr_mode for SIZETYPE.\n-     But we get far better code using the width of Pmode.  */\n-  size_type_node = gnat_type_for_mode (Pmode, 0);\n-  set_sizetype (size_type_node);\n-\n-  /* In Ada, we use an unsigned 8-bit type for the default boolean type.  */\n-  boolean_type_node = make_unsigned_type (8);\n-  TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n-  SET_TYPE_RM_MAX_VALUE (boolean_type_node,\n-\t\t\t build_int_cst (boolean_type_node, 1));\n-  SET_TYPE_RM_SIZE (boolean_type_node, bitsize_int (1));\n-\n-  build_common_tree_nodes_2 (0);\n-  boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n-\n-  ptr_void_type_node = build_pointer_type (void_type_node);\n-}\n-\f\n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.  */\n \n void\n@@ -3000,7 +2972,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n       tree lfield, ufield;\n \n-      /* Convert POINTER to the type of the P_ARRAY field.  */\n+      /* Convert POINTER to the pointer-to-array type.  */\n       gnu_expr64 = convert (p_array_type, gnu_expr64);\n \n       switch (iklass)\n@@ -3148,7 +3120,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n \n-      /* Convert POINTER to the type of the P_ARRAY field.  */\n+      /* Convert POINTER to the pointer-to-array type.  */\n       gnu_expr32 = convert (p_array_type, gnu_expr32);\n \n       switch (iklass)\n@@ -3955,10 +3927,12 @@ convert (tree type, tree expr)\n     case UNCONSTRAINED_ARRAY_REF:\n       /* Convert this to the type of the inner array by getting the address of\n \t the array from the template.  */\n+      expr = TREE_OPERAND (expr, 0);\n       expr = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t     build_component_ref (TREE_OPERAND (expr, 0),\n-\t\t\t\t\t\t  get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t  NULL_TREE, false));\n+\t\t\t     build_component_ref (expr, NULL_TREE,\n+\t\t\t\t\t\t  TYPE_FIELDS\n+\t\t\t\t\t\t  (TREE_TYPE (expr)),\n+\t\t\t\t\t\t  false));\n       etype = TREE_TYPE (expr);\n       ecode = TREE_CODE (etype);\n       break;\n@@ -4033,9 +4007,7 @@ convert (tree type, tree expr)\n     }\n \n   /* In all other cases of related types, make a NOP_EXPR.  */\n-  else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype)\n-\t   || (code == INTEGER_CST && ecode == INTEGER_CST\n-\t       && (type == TREE_TYPE (etype) || etype == TREE_TYPE (type))))\n+  else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n     return fold_convert (type, expr);\n \n   switch (code)\n@@ -4114,8 +4086,8 @@ convert (tree type, tree expr)\n       /* If converting fat pointer to normal pointer, get the pointer to the\n \t array and then convert it.  */\n       else if (TYPE_IS_FAT_POINTER_P (etype))\n-\texpr = build_component_ref (expr, get_identifier (\"P_ARRAY\"),\n-\t\t\t\t    NULL_TREE, false);\n+\texpr\n+\t  = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (etype), false);\n \n       return fold (convert_to_pointer (type, expr));\n \n@@ -4226,7 +4198,7 @@ remove_conversions (tree exp, bool true_address)\n }\n \f\n /* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n-   refers to the underlying array.  If its type has TYPE_CONTAINS_TEMPLATE_P,\n+   refers to the underlying array.  If it has TYPE_CONTAINS_TEMPLATE_P,\n    likewise return an expression pointing to the underlying array.  */\n \n tree\n@@ -4240,11 +4212,13 @@ maybe_unconstrained_array (tree exp)\n     case UNCONSTRAINED_ARRAY_TYPE:\n       if (code == UNCONSTRAINED_ARRAY_REF)\n \t{\n+\t  new_exp = TREE_OPERAND (exp, 0);\n \t  new_exp\n \t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t      build_component_ref (TREE_OPERAND (exp, 0),\n-\t\t\t\t\t\t   get_identifier (\"P_ARRAY\"),\n-\t\t\t\t\t\t   NULL_TREE, false));\n+\t\t\t      build_component_ref (new_exp, NULL_TREE,\n+\t\t\t\t\t\t   TYPE_FIELDS\n+\t\t\t\t\t\t   (TREE_TYPE (new_exp)),\n+\t\t\t\t\t\t   false));\n \t  TREE_READONLY (new_exp) = TREE_READONLY (exp);\n \t  return new_exp;\n \t}"}]}