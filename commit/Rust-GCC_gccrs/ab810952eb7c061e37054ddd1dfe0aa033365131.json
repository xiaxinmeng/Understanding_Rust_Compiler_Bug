{"sha": "ab810952eb7c061e37054ddd1dfe0aa033365131", "node_id": "C_kwDOANBUbNoAKGFiODEwOTUyZWI3YzA2MWUzNzA1NGRkZDFkZmUwYWEwMzMzNjUxMzE", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-27T12:49:02Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-10-27T13:12:05Z"}, "message": "ipa-cp: Use profile counters (or not) based on local availability\n\nThis is a follow-up small patch to address Honza's review of my\nprevious patch to select saner profile count to base heuristics on.\nCurrently the IPA-CP heuristics switch to PGO-mode only if there are\nPGO counters available for any part of the call graph.  This change\nmakes it to switch to the PGO mode only if any of the incoming edges\nbringing in the constant in question had any ipa-quality counts on\nthem.  Consequently, if a part of the program is built with\n-fprofile-use and another part without, IPA-CP will use\nestimated-frequency-based heuristics for the latter.\n\nI still wonder whether this should only happen with\nflag_profile_partial_training on.  It seems like we're behaving as if\nit was always on.\n\ngcc/ChangeLog:\n\n2021-10-18  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (good_cloning_opportunity_p): Decide whether to use\n\tprofile feedback depending on their local availability.", "tree": {"sha": "2c6d25511afd3baed2f9d5f4d397d8f05aab8cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c6d25511afd3baed2f9d5f4d397d8f05aab8cd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab810952eb7c061e37054ddd1dfe0aa033365131", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmF5UCUACgkQv2PBvD+k\nNUDkqxAAlRcBrsBUoCke1Ettr5KGotjvaJcZQLLGzSmirWWKLk7czY668xBqaF4+\njFp84QMbL4zTIeDOu+Lj0cC+qwLph3oYdA4QrZZ7G0r1iIsB2ow7y2S8WqKzp4GQ\nTgkwSnGwEcSss7HAPE+W7r+PxXi+GepEuSu3lrsXrvOwJSQenI7RoHyKtqbBwqBo\nEzR1beDcmAUPhQf0fjs06zuB9EQrxW0dQPjxO7f2PB7sOaswgix7D5LpL6ZSECS/\naorf4MsTFaXi5HGB4OvExoSBP+ZEhqyIt5/0Ua/rZhiyA3Kckk+ERpBqzM+kIBp0\nrRjCIOWY6iIXzTl3/+nfrWYJ0yikrzhZNbQoAqMR7scHSWb7fwKAfKLgjN5dxl/M\ngSeGCZyBX1G3g13juBckNTWDd+BDBWowWk2CAcdeYtVHFHWOxl2lQgBa4VyDskwi\n8hx0i4K71OlwZ9FYl01S3E65tVUq9241TpJl9Qm2HXsSwL2Hk8z69hjVX0rhq7vr\nb8X0ZGkJRPfwvIPEmeFjQ+GiDPlS6t9A6hDqxus1EYsB4jhU7jDeN25TCNYMS43W\nT5dCKcN+Sh1ovCAgFetwOnQqzd5PTP7lHwNLtNIINSdk9M78nBFtsGZscfeQwWfx\nuwHY3DdSbxZXu/00nZ8Y4jUQkxRVjc/Cs9p9Ax4ox5InhanLMnM=\n=W/SQ\n-----END PGP SIGNATURE-----", "payload": "tree 2c6d25511afd3baed2f9d5f4d397d8f05aab8cd2\nparent ab1008255e37b5b51a433ed69e04c06300543799\nauthor Martin Jambor <mjambor@suse.cz> 1635338942 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1635340325 +0200\n\nipa-cp: Use profile counters (or not) based on local availability\n\nThis is a follow-up small patch to address Honza's review of my\nprevious patch to select saner profile count to base heuristics on.\nCurrently the IPA-CP heuristics switch to PGO-mode only if there are\nPGO counters available for any part of the call graph.  This change\nmakes it to switch to the PGO mode only if any of the incoming edges\nbringing in the constant in question had any ipa-quality counts on\nthem.  Consequently, if a part of the program is built with\n-fprofile-use and another part without, IPA-CP will use\nestimated-frequency-based heuristics for the latter.\n\nI still wonder whether this should only happen with\nflag_profile_partial_training on.  It seems like we're behaving as if\nit was always on.\n\ngcc/ChangeLog:\n\n2021-10-18  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (good_cloning_opportunity_p): Decide whether to use\n\tprofile feedback depending on their local availability.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab810952eb7c061e37054ddd1dfe0aa033365131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab810952eb7c061e37054ddd1dfe0aa033365131", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab810952eb7c061e37054ddd1dfe0aa033365131/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab1008255e37b5b51a433ed69e04c06300543799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab1008255e37b5b51a433ed69e04c06300543799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab1008255e37b5b51a433ed69e04c06300543799"}], "stats": {"total": 4, "additions": 2, "deletions": 2}, "files": [{"sha": "703541d15cc275244ca6418efa3c88f7ae53c84c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab810952eb7c061e37054ddd1dfe0aa033365131/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab810952eb7c061e37054ddd1dfe0aa033365131/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ab810952eb7c061e37054ddd1dfe0aa033365131", "patch": "@@ -3311,9 +3311,9 @@ good_cloning_opportunity_p (struct cgraph_node *node, sreal time_benefit,\n \n   ipa_node_params *info = ipa_node_params_sum->get (node);\n   int eval_threshold = opt_for_fn (node->decl, param_ipa_cp_eval_threshold);\n-  if (base_count > profile_count::zero ())\n+  if (count_sum > profile_count::zero ())\n     {\n-\n+      gcc_assert (base_count > profile_count::zero ());\n       sreal factor = count_sum.probability_in (base_count).to_sreal ();\n       sreal evaluation = (time_benefit * factor) / size_cost;\n       evaluation = incorporate_penalties (node, info, evaluation);"}]}