{"sha": "d0940d56623ac8e6e6f43c873d039c2466bb6798", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA5NDBkNTY2MjNhYzhlNmU2ZjQzYzg3M2QwMzljMjQ2NmJiNjc5OA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-04-02T09:24:19Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-04-02T09:24:19Z"}, "message": "re PR c++/26693 (Access checks not performed for types in templates)\n\ngcc/ChangeLog:\n2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n\n    PR c++/26693\n    * c-decl.c: (clone_underlying_type): Move this ...\n    * c-common.c (set_underlying_type): ... here.\n    Also, make sure the function properly sets TYPE_STUB_DECL() on\n    the newly created typedef variant type.\n    * c-common.h (is_typedef_decl, set_underlying_type): Declare ...\n    * c-common.c (is_typedef_decl, set_underlying_type): ... new entry points.\n\ngcc/cp/ChangeLog:\n2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n\n    PR c++/26693\n    * decl2.c (grokfield): when a typedef appears in a\n    class, create the typedef variant type node for it.\n    (save_template_attributes): Creating typedef variant type node\n     here is now useless.\n    * decl.c (grokdeclarator): If the typedef'ed struct/class was\n    anonymous, set the proper type name to all its type variants.\n    (xref_basetypes) : Fixup the variant types after setting\n    TYPE_BINFO on REF.\n    * name-lookup.c (pushdecl_maybe_friend): Reuse the\n    set_underlying_type function to install typedef variant types.\n    * cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): New template accessor\n    macro.\n    (append_type_to_template_for_access_check): New entry points.\n    * semantics.c (check_accessibility_of_qualified_id):\n    When a typedef that is a member of a class appears in a template,\n    add it to the template. It will be ...\n    * class.c (finish_struct_bits): Split type variant fixup into ...\n    (fixup_type_variants): A new entry point.\n    * pt.c (instantiate_class_template, instantiate_template ): ... access\n    checked at template instantiation time.\n    (resolve_type_name_type): The type name should be the name of the\n    main type variant.\n    (retrieve_specialization): Specializations of template typedefs aren't\n    to be looked up in DECL_TEMPLATE_INSTANTIATIONS (tmpl).\n    (append_type_to_template_for_access_check): New entry point.\n    (tsubst_decl): For typedefs, build the variant type from the correct\n    original type.\n    (get_class_bindings): Fix function comment.\n    (perform_typedefs_access_check): New entry point.\n\ngcc/testsuite/ChangeLog:\n2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n\n    PR c++/26693\n    * g++.dg/template/typedef11.C: New test.\n    * g++.dg/template/typedef12.C: Likewise.\n    * g++.dg/template/typedef13.C: Likewise.\n    * g++.dg/template/typedef14.C: Likewise.\n    * g++.dg/template/typedef15.C: Likewise.\n    * g++.dg/template/typedef16.C: Likewise.\n    * g++.dg/template/sfinae3.C: Compile this pedantically.\n    The only errors expected should be the one saying the typedef is ill\n    formed.\n    * g++.old-deja/g++.pt/typename8.C: Likewise.\n    * g++.dg/template/access11.C: Update this.\n\nlibstdc++-v3/ChangeLog:\n2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n\n    * include/ext/bitmap_allocator.h: the typedefs should be made public\n    if we want them to be accessible. This has been revealed by the patch\n    that fixes PR c++/26693 in g++.\n\nFrom-SVN: r145440", "tree": {"sha": "4ae7dcdc112d00327f2e63a2d51dc32abfd729db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ae7dcdc112d00327f2e63a2d51dc32abfd729db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0940d56623ac8e6e6f43c873d039c2466bb6798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0940d56623ac8e6e6f43c873d039c2466bb6798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0940d56623ac8e6e6f43c873d039c2466bb6798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0940d56623ac8e6e6f43c873d039c2466bb6798/comments", "author": null, "committer": null, "parents": [{"sha": "bf1cbdc6e43e3a62ef6ecac786ac70ecf5851ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1cbdc6e43e3a62ef6ecac786ac70ecf5851ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1cbdc6e43e3a62ef6ecac786ac70ecf5851ef6"}], "stats": {"total": 572, "additions": 449, "deletions": 123}, "files": [{"sha": "e50c34ceb087270e46eccad1e8db552184617ae6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1,3 +1,13 @@\n+2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/26693\n+\t* c-decl.c: (clone_underlying_type): Move this ...\n+\t* c-common.c (set_underlying_type): ... here.\n+\tAlso, make sure the function properly sets TYPE_STUB_DECL() on\n+\tthe newly created typedef variant type.\n+\t* c-common.h (is_typedef_decl, set_underlying_type): Declare ...\n+\t* c-common.c (is_typedef_decl, set_underlying_type): ... new entry points.\n+\n 2009-04-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37221"}, {"sha": "9886cdf36689f07bdd8af45ceb482a3ad5001d5d", "filename": "gcc/c-common.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -9172,4 +9172,76 @@ warn_for_sign_compare (location_t location,\n     }\n }\n \n+/* Setup a TYPE_DECL node as a typedef representation.\n+\n+   X is a TYPE_DECL for a typedef statement.  Create a brand new\n+   ..._TYPE node (which will be just a variant of the existing\n+   ..._TYPE node with identical properties) and then install X\n+   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n+\n+   The whole point here is to end up with a situation where each\n+   and every ..._TYPE node the compiler creates will be uniquely\n+   associated with AT MOST one node representing a typedef name.\n+   This way, even though the compiler substitutes corresponding\n+   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n+   early on, later parts of the compiler can always do the reverse\n+   translation and get back the corresponding typedef name.  For\n+   example, given:\n+\n+\ttypedef struct S MY_TYPE;\n+\tMY_TYPE object;\n+\n+   Later parts of the compiler might only know that `object' was of\n+   type `struct S' if it were not for code just below.  With this\n+   code however, later parts of the compiler see something like:\n+\n+\tstruct S' == struct S\n+\ttypedef struct S' MY_TYPE;\n+\tstruct S' object;\n+\n+    And they can then deduce (from the node for type struct S') that\n+    the original object declaration was:\n+\n+\t\tMY_TYPE object;\n+\n+    Being able to do this is important for proper support of protoize,\n+    and also for generating precise symbolic debugging information\n+    which takes full account of the programmer's (typedef) vocabulary.\n+\n+    Obviously, we don't want to generate a duplicate ..._TYPE node if\n+    the TYPE_DECL node that we are now processing really represents a\n+    standard built-in type.  */\n+\n+void\n+set_underlying_type (tree x)\n+{\n+  if (x == error_mark_node)\n+    return;\n+  if (DECL_IS_BUILTIN (x))\n+    {\n+      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n+\tTYPE_NAME (TREE_TYPE (x)) = x;\n+    }\n+  else if (TREE_TYPE (x) != error_mark_node\n+\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n+    {\n+      tree tt = TREE_TYPE (x);\n+      DECL_ORIGINAL_TYPE (x) = tt;\n+      tt = build_variant_type_copy (tt);\n+      TYPE_STUB_DECL (tt) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n+      TYPE_NAME (tt) = x;\n+      TREE_USED (tt) = TREE_USED (x);\n+      TREE_TYPE (x) = tt;\n+    }\n+}\n+\n+/* Returns true if X is a typedef decl.  */\n+\n+bool\n+is_typedef_decl (tree x)\n+{\n+  return (x && TREE_CODE (x) == TYPE_DECL\n+          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "f5c755b22bf4fffe706fdeaebdedb56a31e703d4", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1009,6 +1009,8 @@ extern void warn_for_sign_compare (location_t,\n \t\t\t\t   tree op0, tree op1, \n \t\t\t\t   tree result_type, \n \t\t\t\t   enum tree_code resultcode);\n+extern void set_underlying_type (tree x);\n+extern bool is_typedef_decl (tree x);\n \n /* In c-gimplify.c  */\n extern void c_genericize (tree);"}, {"sha": "8930d93c0cda2d3745624d7309205bb655da36f6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -2002,67 +2002,6 @@ warn_if_shadowing (tree new_decl)\n       }\n }\n \n-\n-/* Subroutine of pushdecl.\n-\n-   X is a TYPE_DECL for a typedef statement.  Create a brand new\n-   ..._TYPE node (which will be just a variant of the existing\n-   ..._TYPE node with identical properties) and then install X\n-   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n-\n-   The whole point here is to end up with a situation where each\n-   and every ..._TYPE node the compiler creates will be uniquely\n-   associated with AT MOST one node representing a typedef name.\n-   This way, even though the compiler substitutes corresponding\n-   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n-   early on, later parts of the compiler can always do the reverse\n-   translation and get back the corresponding typedef name.  For\n-   example, given:\n-\n-\ttypedef struct S MY_TYPE;\n-\tMY_TYPE object;\n-\n-   Later parts of the compiler might only know that `object' was of\n-   type `struct S' if it were not for code just below.  With this\n-   code however, later parts of the compiler see something like:\n-\n-\tstruct S' == struct S\n-\ttypedef struct S' MY_TYPE;\n-\tstruct S' object;\n-\n-    And they can then deduce (from the node for type struct S') that\n-    the original object declaration was:\n-\n-\t\tMY_TYPE object;\n-\n-    Being able to do this is important for proper support of protoize,\n-    and also for generating precise symbolic debugging information\n-    which takes full account of the programmer's (typedef) vocabulary.\n-\n-    Obviously, we don't want to generate a duplicate ..._TYPE node if\n-    the TYPE_DECL node that we are now processing really represents a\n-    standard built-in type.  */\n-\n-static void\n-clone_underlying_type (tree x)\n-{\n-  if (DECL_IS_BUILTIN (x))\n-    {\n-      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n-\tTYPE_NAME (TREE_TYPE (x)) = x;\n-    }\n-  else if (TREE_TYPE (x) != error_mark_node\n-\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n-    {\n-      tree tt = TREE_TYPE (x);\n-      DECL_ORIGINAL_TYPE (x) = tt;\n-      tt = build_variant_type_copy (tt);\n-      TYPE_NAME (tt) = x;\n-      TREE_USED (tt) = TREE_USED (x);\n-      TREE_TYPE (x) = tt;\n-    }\n-}\n-\n /* Record a decl-node X as belonging to the current lexical scope.\n    Check for errors (such as an incompatible declaration for the same\n    name already seen in the same scope).\n@@ -2288,7 +2227,7 @@ pushdecl (tree x)\n \n  skip_external_and_shadow_checks:\n   if (TREE_CODE (x) == TYPE_DECL)\n-    clone_underlying_type (x);\n+    set_underlying_type (x);\n \n   bind (name, x, scope, /*invisible=*/false, nested, locus);\n "}, {"sha": "63d5c0762bb738fbf013d510c0d09f9460059db2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1,3 +1,36 @@\n+2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/26693\n+\t* decl2.c (grokfield): when a typedef appears in a\n+\tclass, create the typedef variant type node for it.\n+\t(save_template_attributes): Creating typedef variant type node\n+\t here is now useless.\n+\t* decl.c (grokdeclarator): If the typedef'ed struct/class was\n+\tanonymous, set the proper type name to all its type variants.\n+\t(xref_basetypes) : Fixup the variant types after setting\n+\tTYPE_BINFO on REF.\n+\t* name-lookup.c (pushdecl_maybe_friend): Reuse the\n+\tset_underlying_type function to install typedef variant types.\n+\t* cp-tree.h (MEMBER_TYPES_NEEDING_ACCESS_CHECK): New template accessor\n+\tmacro.\n+\t(append_type_to_template_for_access_check): New entry points.\n+\t* semantics.c (check_accessibility_of_qualified_id):\n+\tWhen a typedef that is a member of a class appears in a template,\n+\tadd it to the template. It will be ...\n+\t* class.c (finish_struct_bits): Split type variant fixup into ...\n+\t(fixup_type_variants): A new entry point.\n+\t* pt.c (instantiate_class_template, instantiate_template ): ... access\n+\tchecked at template instantiation time.\n+\t(resolve_type_name_type): The type name should be the name of the\n+\tmain type variant.\n+\t(retrieve_specialization): Specializations of template typedefs aren't\n+\tto looked up in DECL_TEMPLATE_INSTANTIATIONS (tmpl).\n+\t(append_type_to_template_for_access_check): New entry point.\n+\t(tsubst_decl): For typedefs, build the variant type from the correct\n+\toriginal type.\n+\t(get_class_bindings): Fix function comment.\n+\t(perform_typedefs_access_check): New entry point.\n+\n 2009-03-31  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/34691"}, {"sha": "c1885be2e7792c1648ddb9a9bd8bb14341d0b36d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1439,16 +1439,17 @@ determine_primary_bases (tree t)\n       BINFO_VIRTUALS (type_binfo) = BINFO_VIRTUALS (primary);\n     }\n }\n-\f\n-/* Set memoizing fields and bits of T (and its variants) for later\n-   use.  */\n \n-static void\n-finish_struct_bits (tree t)\n+/* Update the variant types of T.  */\n+\n+void\n+fixup_type_variants (tree t)\n {\n   tree variants;\n \n-  /* Fix up variants (if any).  */\n+  if (!t)\n+    return;\n+\n   for (variants = TYPE_NEXT_VARIANT (t);\n        variants;\n        variants = TYPE_NEXT_VARIANT (variants))\n@@ -1472,6 +1473,17 @@ finish_struct_bits (tree t)\n       /* All variants of a class have the same attributes.  */\n       TYPE_ATTRIBUTES (variants) = TYPE_ATTRIBUTES (t);\n     }\n+}\n+\n+\f\n+/* Set memoizing fields and bits of T (and its variants) for later\n+   use.  */\n+\n+static void\n+finish_struct_bits (tree t)\n+{\n+  /* Fix up variants (if any).  */\n+  fixup_type_variants (t);\n \n   if (BINFO_N_BASE_BINFOS (TYPE_BINFO (t)) && TYPE_POLYMORPHIC_P (t))\n     /* For a class w/o baseclasses, 'finish_struct' has set"}, {"sha": "f28cfc6353ac2810592c3165331cfa6598fce734", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -3181,6 +3181,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == TYPE_DECL \\\n    && !DECL_TEMPLATE_TEMPLATE_PARM_P (NODE))\n \n+/* The chained list of typedefs that are referenced in templates.\n+   These typedefs need to be access checked at template instantiation time.\n+   There are put here at parsing time.  */\n+#define MEMBER_TYPES_NEEDING_ACCESS_CHECK(NODE) DECL_ACCESS (NODE)\n+\n /* Nonzero if NODE which declares a type.  */\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n@@ -4278,6 +4283,7 @@ extern bool type_has_user_nondefault_constructor (tree);\n extern bool type_has_user_provided_constructor  (tree);\n extern bool type_has_user_provided_default_constructor (tree);\n extern bool defaultable_fn_p\t\t\t(tree);\n+extern void fixup_type_variants\t\t\t(tree);\n \n /* in cvt.c */\n extern tree convert_to_reference\t\t(tree, tree, int, int, tree);\n@@ -4548,6 +4554,7 @@ extern tree check_explicit_specialization\t(tree, tree, int, int);\n extern tree make_auto\t\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n+extern void append_type_to_template_for_access_check (tree, tree, tree);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, tree, bool, bool);"}, {"sha": "6e122a542b4a268a9f134168298398f1a50b27ee", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -8823,12 +8823,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t  && TYPE_ANONYMOUS_P (type)\n \t  && cp_type_quals (type) == TYPE_UNQUALIFIED)\n \t{\n-\t  tree oldname = TYPE_NAME (type);\n \t  tree t;\n \n \t  /* Replace the anonymous name with the real name everywhere.  */\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-\t    if (TYPE_NAME (t) == oldname)\n+\t    if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n \t      TYPE_NAME (t) = decl;\n \n \t  if (TYPE_LANG_SPECIFIC (type))\n@@ -10787,6 +10786,9 @@ xref_basetypes (tree ref, tree base_list)\n   BINFO_OFFSET (binfo) = size_zero_node;\n   BINFO_TYPE (binfo) = ref;\n \n+  /* Apply base-class info set up to the variants of this type.  */\n+  fixup_type_variants (ref);\n+\n   if (max_bases)\n     {\n       BINFO_BASE_ACCESSES (binfo) = VEC_alloc (tree, gc, max_bases);"}, {"sha": "91c707d7b69734842b7928ddb7d8d2e39afe7a41", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -820,6 +820,9 @@ grokfield (const cp_declarator *declarator,\n \t  cplus_decl_attributes (&value, attrlist, attrflags);\n \t}\n \n+      if (declspecs->specs[(int)ds_typedef])\n+\tset_underlying_type (value);\n+\n       return value;\n     }\n \n@@ -1125,19 +1128,6 @@ save_template_attributes (tree *attr_p, tree *decl_p)\n   if (!late_attrs)\n     return;\n \n-  /* Give this type a name so we know to look it up again at instantiation\n-     time.  */\n-  if (TREE_CODE (*decl_p) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (*decl_p) == NULL_TREE)\n-    {\n-      tree oldt = TREE_TYPE (*decl_p);\n-      tree newt = build_variant_type_copy (oldt);\n-      DECL_ORIGINAL_TYPE (*decl_p) = oldt;\n-      TREE_TYPE (*decl_p) = newt;\n-      TYPE_NAME (newt) = *decl_p;\n-      TREE_USED (newt) = TREE_USED (*decl_p);\n-    }\n-\n   if (DECL_P (*decl_p))\n     q = &DECL_ATTRIBUTES (*decl_p);\n   else"}, {"sha": "f02605f5ae0d5a62b1c43ea4cdec9f7b33e4b09c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -862,28 +862,20 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \n       /* If declaring a type as a typedef, copy the type (unless we're\n \t at line 0), and install this TYPE_DECL as the new type's typedef\n-\t name.  See the extensive comment in ../c-decl.c (pushdecl).  */\n+\t name.  See the extensive comment of set_underlying_type ().  */\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  tree type = TREE_TYPE (x);\n-\t  if (DECL_IS_BUILTIN (x))\n-\t    {\n-\t      if (TYPE_NAME (type) == 0)\n-\t\tTYPE_NAME (type) = x;\n-\t    }\n-\t  else if (type != error_mark_node && TYPE_NAME (type) != x\n-\t\t   /* We don't want to copy the type when all we're\n-\t\t      doing is making a TYPE_DECL for the purposes of\n-\t\t      inlining.  */\n-\t\t   && (!TYPE_NAME (type)\n-\t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n-\t    {\n-\t      DECL_ORIGINAL_TYPE (x) = type;\n-\t      type = build_variant_type_copy (type);\n-\t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n-\t      TYPE_NAME (type) = x;\n-\t      TREE_TYPE (x) = type;\n-\t    }\n+\n+\t  if (DECL_IS_BUILTIN (x)\n+\t      || (TREE_TYPE (x) != error_mark_node\n+\t\t  && TYPE_NAME (type) != x\n+\t\t  /* We don't want to copy the type when all we're\n+\t\t     doing is making a TYPE_DECL for the purposes of\n+\t\t     inlining.  */\n+\t\t  && (!TYPE_NAME (type)\n+\t\t      || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x))))\n+\t    set_underlying_type (x);\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)"}, {"sha": "58a4d3f77ea6187a6c4fe73df9b5c32babef28b3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -175,6 +175,7 @@ static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree, bool);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_pack_expansion (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n+static void perform_typedefs_access_check (tree tmpl, tree targs);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -949,6 +950,7 @@ retrieve_specialization (tree tmpl, tree args,\n \t DECL_TEMPLATE_SPECIALIZATIONS list.  */\n       if (!class_specializations_p\n \t  && TREE_CODE (DECL_TEMPLATE_RESULT (tmpl)) == TYPE_DECL\n+\t  && !is_typedef_decl (DECL_TEMPLATE_RESULT (tmpl))\n \t  && TAGGED_TYPE_P (TREE_TYPE (tmpl)))\n \tsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n       else\n@@ -6928,6 +6930,37 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n     }\n }\n \n+/* Perform (or defer) access check for typedefs that were referenced\n+   from within the template TMPL code.\n+   This is a subroutine of instantiate_template and instantiate_class_template.\n+   TMPL is the template to consider and TARGS is the list of arguments of\n+   that template.  */\n+\n+static void\n+perform_typedefs_access_check (tree tmpl, tree targs)\n+{\n+  tree t;\n+\n+  if (!tmpl || TREE_CODE (tmpl) != TEMPLATE_DECL)\n+    return;\n+\n+  for (t = MEMBER_TYPES_NEEDING_ACCESS_CHECK (tmpl); t; t = TREE_CHAIN (t))\n+    {\n+      tree type_decl = TREE_PURPOSE (t);\n+      tree type_scope = TREE_VALUE (t);\n+\n+      if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n+\tcontinue;\n+\n+      if (uses_template_parms (type_decl))\n+\ttype_decl = tsubst (type_decl, targs, tf_error, NULL_TREE);\n+      if (uses_template_parms (type_scope))\n+\ttype_scope = tsubst (type_scope, targs, tf_error, NULL_TREE);\n+\n+      perform_or_defer_access_check (TYPE_BINFO (type_scope), type_decl, type_decl);\n+    }\n+}\n+\n tree\n instantiate_class_template (tree type)\n {\n@@ -7403,6 +7436,12 @@ instantiate_class_template (tree type)\n \t  && DECL_TEMPLATE_INFO (t))\n \ttsubst_default_arguments (t);\n \n+  /* Some typedefs referenced from within the template code need to be access\n+     checked at template instantiation time, i.e now. These types were\n+     added to the template at parsing time. Let's get those and perform\n+     the acces checks then.  */\n+  perform_typedefs_access_check (templ, args);\n+  perform_deferred_access_checks ();\n   pop_nested_class ();\n   pop_from_top_level ();\n   pop_deferring_access_checks ();\n@@ -12024,6 +12063,12 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   /* Now we know the specialization, compute access previously\n      deferred.  */\n   push_access_scope (fndecl);\n+\n+  /* Some typedefs referenced from within the template code need to be access\n+     checked at template instantiation time, i.e now. These types were\n+     added to the template at parsing time. Let's get those and perfom\n+     the acces checks then.  */\n+  perform_typedefs_access_check (tmpl, targ_ptr);\n   perform_deferred_access_checks ();\n   pop_access_scope (fndecl);\n   pop_deferring_access_checks ();\n@@ -14404,7 +14449,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n \n /* Return the innermost template arguments that, when applied to a\n    template specialization whose innermost template parameters are\n-   TPARMS, and whose specialization arguments are PARMS, yield the\n+   TPARMS, and whose specialization arguments are SPEC_ARGS, yield the\n    ARGS.\n \n    For example, suppose we have:\n@@ -16722,7 +16767,15 @@ resolve_typename_type (tree type, bool only_current_p)\n   gcc_assert (TREE_CODE (type) == TYPENAME_TYPE);\n \n   scope = TYPE_CONTEXT (type);\n-  name = TYPE_IDENTIFIER (type);\n+  /* Usually the non-qualified identifier of a TYPENAME_TYPE is\n+     TYPE_IDENTIFIER (type). But when 'type' is a typedef variant of\n+     a TYPENAME_TYPE node, then TYPE_NAME (type) is set to the TYPE_DECL representing\n+     the typedef. In that case TYPE_IDENTIFIER (type) is not the non-qualified\n+     identifier  of the TYPENAME_TYPE anymore.\n+     So by getting the TYPE_IDENTIFIER of the _main declaration_ of the\n+     TYPENAME_TYPE instead, we avoid messing up with a possible\n+     typedef variant case.  */\n+  name = TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (type));\n \n   /* If the SCOPE is itself a TYPENAME_TYPE, then we need to resolve\n      it first before we can figure out what NAME refers to.  */\n@@ -17047,4 +17100,46 @@ type_uses_auto (tree type)\n   return NULL_TREE;\n }\n \n+/* Append TYPE_DECL to the template TEMPL.\n+   TEMPL is either a class type or a FUNCTION_DECL associated\n+   to a TEMPLATE_DECL.\n+   At TEMPL instanciation time, TYPE_DECL will be checked to see\n+   if it can be accessed through SCOPE.  */\n+\n+void\n+append_type_to_template_for_access_check (tree templ,\n+                                          tree type_decl,\n+\t\t\t\t\t  tree scope)\n+{\n+  tree node, templ_decl;\n+\n+  gcc_assert (templ\n+\t      && get_template_info (templ)\n+\t      && TI_TEMPLATE (get_template_info (templ))\n+\t      && type_decl\n+\t      && (TREE_CODE (type_decl) == TYPE_DECL));\n+\n+  templ_decl = TI_TEMPLATE (get_template_info (templ));\n+  gcc_assert (templ_decl);\n+\n+  /* Make sure we don't append the type to the template twice.\n+     If this appears to be too slow, the\n+     MEMBER_TYPE_NEEDING_ACCESS_CHECK property\n+     of templ should be a hash table instead.  */\n+  for (node = MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl);\n+       node;\n+       node = TREE_CHAIN (node))\n+    {\n+      tree decl = TREE_PURPOSE (node);\n+      tree type_scope = TREE_VALUE (node);\n+\n+      if (decl == type_decl && type_scope == scope)\n+\treturn;\n+    }\n+\n+  MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl) =\n+    tree_cons (type_decl, scope,\n+\t       MEMBER_TYPES_NEEDING_ACCESS_CHECK (templ_decl));\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "ee8c0ccfafa4071ea2463dcb012c4c6c37ed2b23", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1528,6 +1528,32 @@ check_accessibility_of_qualified_id (tree decl,\n   tree scope;\n   tree qualifying_type = NULL_TREE;\n \n+  /* If we are parsing a template declaration and if decl is a typedef,\n+     add it to a list tied to the template.\n+     At template instantiation time, that list will be walked and\n+     access check performed.  */\n+  if (is_typedef_decl (decl))\n+    {\n+      /* This the scope through which type_decl is accessed.\n+\t It will be useful information later to do access check for\n+\t type_decl usage.  */\n+      tree scope = nested_name_specifier\n+      ?  nested_name_specifier\n+      : DECL_CONTEXT (decl);\n+      tree templ_info = NULL;\n+      tree cs = current_scope ();\n+\n+      if (cs && (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL))\n+\ttempl_info = get_template_info (cs);\n+\n+      if (templ_info\n+\t  && TI_TEMPLATE (templ_info)\n+\t  && scope\n+\t  && CLASS_TYPE_P (scope)\n+\t  && !currently_open_class (scope))\n+\tappend_type_to_template_for_access_check (current_scope (), decl, scope);\n+    }\n+\n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n     return;"}, {"sha": "3081d43219a5e7795a4259c10341745f7b5f7d85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1,3 +1,18 @@\n+2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/26693\n+\t* g++.dg/template/typedef11.C: New test.\n+\t* g++.dg/template/typedef12.C: Likewise.\n+\t* g++.dg/template/typedef13.C: Likewise.\n+\t* g++.dg/template/typedef14.C: Likewise.\n+\t* g++.dg/template/typedef15.C: Likewise.\n+\t* g++.dg/template/typedef16.C: Likewise.\n+\t* g++.dg/template/sfinae3.C: Compile this pedantically.\n+\tThe only errors expected should be the one saying the typedef is ill\n+\tformed.\n+\t* g++.old-deja/g++.pt/typename8.C: Likewise.\n+\t* g++.dg/template/access11.C: Update this.\n+\n 2009-04-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37221"}, {"sha": "38bd5155f65b81126d639d9779b1241c9f013f21", "filename": "gcc/testsuite/g++.dg/template/access11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess11.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -17,8 +17,8 @@ template <> struct X::Y<int> {\n   A::X x;\t\t\t// { dg-error \"this context\" }\n };\n \n-template <typename T> struct X::Y {\n+template <typename T> struct X::Y { // { dg-error \"this context\" }\n   typename T::X x;\t\t// { dg-error \"this context\" }\n };\n \n-template struct X::Y<A>;\t// { dg-message \"instantiated\" }\n+template struct X::Y<A>;\t// { dg-message \"instantiated from here\" }"}, {"sha": "349463d95fe3680f893bbbdd704148cfc69f4588", "filename": "gcc/testsuite/g++.dg/template/sfinae3.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae3.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1,5 +1,5 @@\n // PR c++/24671\n-// { dg-options \"\" }\n+// { dg-do compile }\n \n template<typename> struct A\n {\n@@ -9,9 +9,9 @@ template<typename> struct A\n \n template<typename> struct B\n {\n-  B(const B&); // { dg-message \"candidate\" }\n-  typedef typename A<char[A<B>::i]>::X Y;\n-  template<typename T> B(T, Y); // { dg-error \"call\" }\n+  B(const B&);\n+  typedef typename A<char[A<B>::i]>::X Y; // { dg-error \"forbids zero-size array\" }\n+  template<typename T> B(T, Y);\n };\n \n-B<int> b(0,0); \n+B<int> b(0,0); // { dg-message \"instantiated from here\" }"}, {"sha": "c7c7c989f729330474b0abf0fd0a6eeadad1dfb3", "filename": "gcc/testsuite/g++.dg/template/typedef11.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef11.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -0,0 +1,25 @@\n+// Author: Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+\n+class Alpha\n+{\n+  typedef int X; // { dg-error \"'typedef int Alpha::X' is private\" }\n+};\n+\n+template<int>\n+class Beta\n+{\n+    typedef int Y; // { dg-error \"'typedef int Beta<0>::Y' is private\" }\n+};\n+\n+template <int>\n+int\n+bar ()\n+{\n+  Beta<0>::Y i = 0;\n+  return Alpha::X ();\n+}\n+\n+int i = bar<0> (); // { dg-error \"within this context\" }"}, {"sha": "30605044f6f2469e639ce6a8a19ca0b3210913a4", "filename": "gcc/testsuite/g++.dg/template/typedef12.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef12.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -0,0 +1,23 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: Jason Merrill <jason@redhat.com>, PR c++/26693\n+// { dg-do compile }\n+\n+class A\n+{\n+     protected:\n+           typedef int mytype;\n+};\n+\n+template <class T> class B;\n+\n+class C: public A\n+{\n+      template <class T> friend class B;\n+};\n+\n+template <class T> class B\n+{\n+      C::mytype mem;\n+};\n+\n+B<int> b;"}, {"sha": "aa8bb3268298c6e044416a4425344644b26c106a", "filename": "gcc/testsuite/g++.dg/template/typedef13.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -0,0 +1,16 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+class A\n+{\n+  typedef int mytype; // { dg-error \"typedef int A::mytype' is private\" }\n+};\n+\n+template <class T> class B : public A\n+{ // { dg-error \"within this context\"  }\n+  mytype mem;\n+};\n+\n+B<int> b; // { dg-message \"instantiated from here\" }\n+"}, {"sha": "caa565a08cd0154a36eb9964c59b263e62089591", "filename": "gcc/testsuite/g++.dg/template/typedef14.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef14.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -0,0 +1,16 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+template <class T>\n+struct A\n+{\n+  typedef int mytype;\n+\n+  void\n+  foo ()\n+  {\n+    mytype v = ~static_cast<mytype> (0);\n+  }\n+};\n+"}, {"sha": "e9e3d94ff2e918744e2c5db3e66aa77613837954", "filename": "gcc/testsuite/g++.dg/template/typedef15.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef15.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -0,0 +1,25 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/26693\n+// { dg-do compile }\n+\n+template<class T> struct C0;\n+\n+struct Foo {\n+  typedef int TypedefedFoo;\n+  typedef C0<Foo> TypedefedC0;\n+};\n+\n+template<class T>\n+struct C0\n+{\n+  typedef Foo TypedefedFoo;\n+  typename T::TypedefedC0::TypedefedFoo m;\n+};\n+\n+template<class U>\n+struct C1\n+{\n+  typedef C0<Foo> TypedefedC0;\n+};\n+\n+C0<C1<int> > c;"}, {"sha": "29870605a62370989381d8a5c6e00d9cbce19fea", "filename": "gcc/testsuite/g++.dg/template/typedef16.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef16.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -0,0 +1,27 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin PR c++/26693 \n+// { dg-do compile }\n+\n+struct C0\n+{\n+};\n+\n+template<class T, class U>\n+struct C1\n+{\n+    typedef C0 TypedefedC0;\n+\n+    template<class W>\n+    void foo (TypedefedC0 *, W)\n+    {\n+    }\n+\n+    template<class W>  C1 (W w)\n+    {\n+        TypedefedC0 c;\n+        foo (&c, w);\n+    }\n+\n+};\n+C0 c0;\n+C1<int, char> c1 (&c0);"}, {"sha": "4861cf301ed38b5d18bf635a7a95f2c1559bb0c4", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename8.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename8.C?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -5,14 +5,14 @@ template < class T > class A\n public:\n   typedef typename T::myT anotherT; // { dg-error \"\" } undefined type\n \n-  anotherT t; // { dg-error \"\" } undefined type \n+  anotherT t;\n \n   A() { }\n-  A(anotherT _t) { // { dg-error \"\" } undefined type\n+  A(anotherT _t) {\n     t=_t;\n   }\n \n-  anotherT getT() { // { dg-error \"\" } undefined type\n+  anotherT getT() {\n     return t;\n   }\n };"}, {"sha": "61b2c0594a2cbdc9d1d2aa081f6c6c71feadadd5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -1,3 +1,9 @@\n+2009-04-02  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* include/ext/bitmap_allocator.h: the typedefs should be made public\n+\tif we want them to be accessible. This has been revealed by the patch\n+\tthat fixes PR c++/26693 in g++.\n+\n 2009-04-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/abi/post/powerpc64-linux-gnu/32/baseline_symbols.txt:\n@@ -785,22 +791,13 @@\n \ton HPUX.\n \t* configure: Regenerate.\n \n-2009-01-22  Dodji Seketeli  <dodji@redhat.com>\n-\n-\t* include/ext/bitmap_allocator.h: Reverting changes related to PR\n-\tc++/26693.\n-\n 2009-01-21  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/29_atomics/headers/stdatomic.h/functions.c: Remove\n \tatomic_flag_fence.\n \n 2009-01-21  Dodji Seketeli  <dodji@redhat.com>\n \n-\t* include/ext/bitmap_allocator.h: the typedefs should be made public\n-\tif we want them to be accessible. This has been revealed by the patch\n-\tthat fixes PR c++/26693 in g++.\n-\n 2009-01-20  Benjamin Kosnik  <bkoz@redhat.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "b7ff6fd40703f0dd28a91f79b10573a7eaadd325", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0940d56623ac8e6e6f43c873d039c2466bb6798/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0940d56623ac8e6e6f43c873d039c2466bb6798/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=d0940d56623ac8e6e6f43c873d039c2466bb6798", "patch": "@@ -550,11 +550,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    */\n   class free_list\n   {\n+  public:\n     typedef size_t* \t\t\t\tvalue_type;\n     typedef __detail::__mini_vector<value_type> vector_type;\n     typedef vector_type::iterator \t\titerator;\n     typedef __mutex\t\t\t\t__mutex_type;\n \n+  private:\n     struct _LT_pointer_compare\n     {\n       bool"}]}