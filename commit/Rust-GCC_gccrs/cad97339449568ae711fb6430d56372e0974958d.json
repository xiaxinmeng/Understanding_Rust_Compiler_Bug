{"sha": "cad97339449568ae711fb6430d56372e0974958d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkOTczMzk0NDk1NjhhZTcxMWZiNjQzMGQ1NjM3MmUwOTc0OTU4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-21T10:51:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-21T10:51:22Z"}, "message": "[multiple changes]\n\n2015-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb: Minor reformatting.\n\t* cstand.adb (Print_Standard): Fix bad printing of Duration\n\tlow bound.\n\t* a-reatim.adb (Time_Of): Complete rewrite to properly detect\n\tout of range args.\n\n2015-05-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb: add (useless) initial value.\n\t* sem_ch3.adb (Replace_Anonymous_Access_To_Protected_Subprogram):\n\tCheck whether the procedure has parameters before processing\n\tformals in ASIS mode.\n\nFrom-SVN: r223477", "tree": {"sha": "37d7ac2f5cebd2498cf6c3526382477879e49b08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37d7ac2f5cebd2498cf6c3526382477879e49b08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cad97339449568ae711fb6430d56372e0974958d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad97339449568ae711fb6430d56372e0974958d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad97339449568ae711fb6430d56372e0974958d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad97339449568ae711fb6430d56372e0974958d/comments", "author": null, "committer": null, "parents": [{"sha": "cc68dfe2e83fcbdedba5e627e15045ed43f12655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc68dfe2e83fcbdedba5e627e15045ed43f12655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc68dfe2e83fcbdedba5e627e15045ed43f12655"}], "stats": {"total": 259, "additions": 174, "deletions": 85}, "files": [{"sha": "04e0cae6be73944ba8f89f995019b759c08038e9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cad97339449568ae711fb6430d56372e0974958d", "patch": "@@ -1,3 +1,18 @@\n+2015-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb: Minor reformatting.\n+\t* cstand.adb (Print_Standard): Fix bad printing of Duration\n+\tlow bound.\n+\t* a-reatim.adb (Time_Of): Complete rewrite to properly detect\n+\tout of range args.\n+\n+2015-05-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb: add (useless) initial value.\n+\t* sem_ch3.adb (Replace_Anonymous_Access_To_Protected_Subprogram):\n+\tCheck whether the procedure has parameters before processing\n+\tformals in ASIS mode.\n+\n 2015-05-21  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Check_Iterator_Functions): Emit error on Iterator"}, {"sha": "c259e81764497c53c4f73ee5b5e379ce26397a6c", "filename": "gcc/ada/a-reatim.adb", "status": "modified", "additions": 103, "deletions": 62, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fa-reatim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fa-reatim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.adb?ref=cad97339449568ae711fb6430d56372e0974958d", "patch": "@@ -227,78 +227,119 @@ package body Ada.Real_Time is\n    -------------\n \n    function Time_Of (SC : Seconds_Count; TS : Time_Span) return Time is\n+      pragma Suppress (Overflow_Check);\n+      pragma Suppress (Range_Check);\n+      --  We do all our own checks for this function\n+\n+      --  This is not such a simple case, since TS is already 64 bits, and\n+      --  so we can't just promote everything to a wider type to ensure proper\n+      --  testing for overflow. The situation is that Seconds_Count is a MUCH\n+      --  wider type than Time_Span and Time (both of which have the underlying\n+      --  type Duration).\n+\n+      --         <------------------- Seconds_Count -------------------->\n+      --                            <-- Duration -->\n+\n+      --  Now it is possible for an SC value outside the Duration range to\n+      --  be \"brought back into range\" by an appropriate TS value, but there\n+      --  are also clearly SC values that are completely out of range. Note\n+      --  that the above diagram is wildly out of scale, the difference in\n+      --  ranges is much greater than shown.\n+\n+      --  We can't just go generating out of range Duration values to test for\n+      --  overflow, since Duration is a full range type, so we follow the steps\n+      --  shown below.\n+\n+      SC_Lo : constant Seconds_Count :=\n+                Seconds_Count (Duration (Time_Span_First) + Duration'(0.5));\n+      SC_Hi : constant Seconds_Count :=\n+                Seconds_Count (Duration (Time_Span_Last)  - Duration'(0.5));\n+      --  These are the maximum values of the seconds (integer) part of the\n+      --  Duration range. Used to compute and check the seconds in the result.\n+\n+      TS_SC : Seconds_Count;\n+      --  Seconds part of input value\n+\n+      TS_Fraction : Duration;\n+      --  Fractional part of input value, may be negative\n+\n+      Result_SC : Seconds_Count;\n+      --  Seconds value for result\n+\n+      Fudge : constant Seconds_Count := 10;\n+      --  Fudge value used to do end point checks far from end point\n+\n+      FudgeD : constant Duration := Duration (Fudge);\n+      --  Fudge value as Duration\n+\n+      Fudged_Result : Duration;\n+      --  Result fudged up or down by FudgeD\n+\n+      procedure Out_Of_Range;\n+      pragma No_Return (Out_Of_Range);\n+      --  Raise exception for result out of range\n+\n+      ------------------\n+      -- Out_Of_Range --\n+      ------------------\n+\n+      procedure Out_Of_Range is\n+      begin\n+         raise Constraint_Error with\n+           \"result for Ada.Real_Time.Time_Of is out of range\";\n+      end Out_Of_Range;\n+\n+   --  Start of processing for Time_Of\n+\n    begin\n-      --  Simple case first, TS = 0.0, we need to make sure SC is in range\n+      --  If SC is so far out of range that there is no possibility of the\n+      --  addition of TS getting it back in range, raise an exception right\n+      --  away. That way we don't have to worry about SC values overflowing.\n+\n+      if SC < 3 * SC_Lo or else SC > 3 * SC_Hi then\n+         Out_Of_Range;\n+      end if;\n+\n+      --  Decompose input TS value\n+\n+      TS_SC := Seconds_Count (Duration (TS));\n+      TS_Fraction := Duration (TS) - Duration (TS_SC);\n+\n+      --  Compute result seconds. If clearly out of range, raise error now\n \n-      if TS = 0.0 then\n-         if SC >= Seconds_Count (Duration (Time_Span_First) + Duration'(0.5))\n-               and then\n-            SC <= Seconds_Count (Duration (Time_Span_Last)  - Duration'(0.5))\n-         then\n-            --  Don't need any further checks after that manual check\n+      Result_SC := SC + TS_SC;\n \n-            declare\n-               pragma Suppress (All_Checks);\n-            begin\n-               return Time (SC);\n-            end;\n+      if Result_SC < (SC_Lo - 1) or else Result_SC > (SC_Hi + 1) then\n+         Out_Of_Range;\n+      end if;\n+\n+      --  Now the result is simply Result_SC + TS_Fraction, but we can't just\n+      --  go computing that since it might be out of range. So what we do is\n+      --  to compute a value fudged down or up by 10.0 (arbitrary value, but\n+      --  that will do fine), and check that fudged value, and if in range\n+      --  unfudge it and return the result.\n \n-         --  Here we have a Seconds_Count value that is out of range\n+      --  Fudge positive result down, and check high bound\n \n+      if Result_SC > 0 then\n+         Fudged_Result := Duration (Result_SC - Fudge) + TS_Fraction;\n+\n+         if Fudged_Result <= Duration'Last - FudgeD then\n+            return Time (Fudged_Result + FudgeD);\n          else\n-            raise Constraint_Error;\n+            Out_Of_Range;\n          end if;\n-      end if;\n \n-      --  We want to return Time (SC) + TS. To avoid spurious overflows in\n-      --  the intermediate result Time (SC) we take advantage of the different\n-      --  signs in SC and TS (when that is the case).\n-\n-      --  If the signs of SC and TS are different then we avoid converting SC\n-      --  to Time (as we do in the else part). The reason for that is that SC\n-      --  converted to Time may overflow the range of Time, while the addition\n-      --  of SC plus TS does not overflow (because of their different signs).\n-      --  The approach is to add and remove the greatest value of time\n-      --  (greatest absolute value) to both SC and TS. SC and TS have different\n-      --  signs, so we add the positive constant to the negative value, and the\n-      --  negative constant to the positive value, to prevent overflows.\n-\n-      if (SC > 0 and then TS < 0.0) or else (SC < 0 and then TS > 0.0) then\n-         declare\n-            Closest_Boundary : constant Seconds_Count :=\n-              (if TS >= 0.0 then\n-                  Seconds_Count (Time_Span_Last  - Time_Span (0.5))\n-               else\n-                  Seconds_Count (Time_Span_First + Time_Span (0.5)));\n-            --  Value representing the integer part of the Time_Span boundary\n-            --  closest to TS (its number of seconds). Truncate towards zero\n-            --  to be sure that transforming this value back into Time cannot\n-            --  overflow (when SC is equal to 0). The sign of Closest_Boundary\n-            --  is always different from the sign of SC, hence avoiding\n-            --  overflow in the expression Time (SC + Closest_Boundary)\n-            --  which is part of the return statement.\n-\n-            Dist_To_Boundary : constant Time_Span :=\n-              TS - Time_Span (Closest_Boundary);\n-            --  Distance between TS and Closest_Boundary expressed in Time_Span\n-            --  Both operands in the subtraction have the same sign, hence\n-            --  avoiding overflow.\n-\n-         begin\n-            --  Both operands in the inner addition have different signs,\n-            --  hence avoiding overflow. The Time () conversion and the outer\n-            --  addition can overflow only if SC + TC is not within Time'Range.\n-\n-            return Time (SC + Closest_Boundary) + Dist_To_Boundary;\n-         end;\n-\n-      --  Both operands have the same sign, so we can convert SC into Time\n-      --  right away; if this conversion overflows then the result of adding SC\n-      --  and TS would overflow anyway (so we would just be detecting the\n-      --  overflow a bit earlier).\n+      --  Same for negative values of seconds, fundge up and check low bound\n \n       else\n-         return Time (SC) + TS;\n+         Fudged_Result := Duration (Result_SC + Fudge) + TS_Fraction;\n+\n+         if Fudged_Result >= Duration'First + FudgeD then\n+            return Time (Fudged_Result - FudgeD);\n+         else\n+            Out_Of_Range;\n+         end if;\n       end if;\n    end Time_Of;\n "}, {"sha": "da30887b36de331ee367d7fb3653e2dd08b88e8f", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=cad97339449568ae711fb6430d56372e0974958d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2033,13 +2033,13 @@ package body CStand is\n \n       if Duration_32_Bits_On_Target then\n          P (\"   type Duration is delta 0.020\");\n-         P (\"     range -((2 ** 31 - 1) * 0.020) ..\");\n+         P (\"     range -((2 ** 31)     * 0.020) ..\");\n          P (\"           +((2 ** 31 - 1) * 0.020);\");\n          P (\"   for Duration'Small use 0.020;\");\n \n       else\n          P (\"   type Duration is delta 0.000000001\");\n-         P (\"     range -((2 ** 63 - 1) * 0.000000001) ..\");\n+         P (\"     range -((2 ** 63)     * 0.000000001) ..\");\n          P (\"           +((2 ** 63 - 1) * 0.000000001);\");\n          P (\"   for Duration'Small use 0.000000001;\");\n       end if;"}, {"sha": "b87027ded73236bd44721ea0629c41f4717c860d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=cad97339449568ae711fb6430d56372e0974958d", "patch": "@@ -4290,7 +4290,7 @@ package body Freeze is\n             end if;\n          end if;\n \n-         --  Make sure that if we have terator aspect, then we have\n+         --  Make sure that if we have an iterator aspect, then we have\n          --  either Constant_Indexing or Variable_Indexing.\n \n          declare\n@@ -4305,14 +4305,14 @@ package body Freeze is\n \n             if Present (Iterator_Aspect) then\n                if Has_Aspect (Rec, Aspect_Constant_Indexing)\n-                 or else\n+                    or else\n                   Has_Aspect (Rec, Aspect_Variable_Indexing)\n                then\n                   null;\n                else\n                   Error_Msg_N\n                     (\"Iterator_Element requires indexing aspect\",\n-                       Iterator_Aspect);\n+                     Iterator_Aspect);\n                end if;\n             end if;\n          end;"}, {"sha": "565efe01dbb3995f1b502b3af3fd67251098ea05", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=cad97339449568ae711fb6430d56372e0974958d", "patch": "@@ -5834,7 +5834,11 @@ package body Sem_Ch3 is\n             Set_Scope  (Typ, Current_Scope);\n             Push_Scope (Typ);\n \n-            Process_Formals (Parameter_Specifications (Spec), Spec);\n+            --  Nothing to do if procedure is parameterless\n+\n+            if Present (Parameter_Specifications (Spec)) then\n+               Process_Formals (Parameter_Specifications (Spec), Spec);\n+            end if;\n \n             if Nkind (Spec) = N_Access_Function_Definition then\n                declare"}, {"sha": "38c32df4c1e777650f1a689177bbc57d55550acb", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad97339449568ae711fb6430d56372e0974958d/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=cad97339449568ae711fb6430d56372e0974958d", "patch": "@@ -1726,6 +1726,11 @@ package body Sem_Ch5 is\n       --  indicator, verify that the container type has an Iterate aspect that\n       --  implements the reversible iterator interface.\n \n+      function Get_Cursor_Type (Typ : Entity_Id) return Entity_Id;\n+      --  For containers with Iterator and related aspects, the cursor the\n+      --  is obtained by locating an entity with the proper name in the\n+      --  scope of the type.\n+\n       -----------------------------\n       -- Check_Reverse_Iteration --\n       -----------------------------\n@@ -1741,6 +1746,34 @@ package body Sem_Ch5 is\n          end if;\n       end Check_Reverse_Iteration;\n \n+      ---------------------\n+      -- Get_Cursor_Type --\n+      ---------------------\n+\n+      function Get_Cursor_Type (Typ : Entity_Id) return Entity_Id is\n+         Ent : Entity_Id;\n+\n+      begin\n+         Ent := First_Entity (Scope (Typ));\n+         while Present (Ent) loop\n+            exit when Chars (Ent) = Name_Cursor;\n+            Next_Entity (Ent);\n+         end loop;\n+\n+         if No (Ent) then\n+            return Any_Type;\n+         end if;\n+\n+         --  The cursor is the target of generated assignments in the\n+         --  loop, and cannot have a limited type.\n+\n+         if Is_Limited_Type (Etype (Ent)) then\n+            Error_Msg_N (\"cursor type cannot be limited\", N);\n+         end if;\n+\n+         return Etype (Ent);\n+      end Get_Cursor_Type;\n+\n    --   Start of processing for  Analyze_iterator_Specification\n \n    begin\n@@ -2054,8 +2087,9 @@ package body Sem_Ch5 is\n \n             else\n                declare\n-                  Element : constant Entity_Id :=\n+                  Element     : constant Entity_Id :=\n                     Find_Value_Of_Aspect (Typ, Aspect_Iterator_Element);\n+                  Cursor_Type : Entity_Id;\n \n                begin\n                   if No (Element) then\n@@ -2064,6 +2098,8 @@ package body Sem_Ch5 is\n \n                   else\n                      Set_Etype (Def_Id, Entity (Element));\n+                     Cursor_Type := Get_Cursor_Type (Typ);\n+                     pragma Assert (Present (Cursor_Type));\n \n                      --  If subtype indication was given, verify that it covers\n                      --  the element type of the container.\n@@ -2139,8 +2175,15 @@ package body Sem_Ch5 is\n                begin\n                   if Iter_Kind = N_Selected_Component then\n                      Obj := Prefix (Original_Node (Iter_Name));\n+\n                   elsif Iter_Kind = N_Function_Call then\n                      Obj := First_Actual (Original_Node (Iter_Name));\n+\n+                  --  If neither, likely previous error, make sure Obj has some\n+                  --  reasonable value in such a case.\n+\n+                  else\n+                     Obj := Iter_Name;\n                   end if;\n \n                   if Nkind (Obj) = N_Selected_Component\n@@ -2166,23 +2209,9 @@ package body Sem_Ch5 is\n                Ent := Etype (Def_Id);\n \n             else\n-               Ent := First_Entity (Scope (Typ));\n-               while Present (Ent) loop\n-                  if Chars (Ent) = Name_Cursor then\n-                     Set_Etype (Def_Id, Etype (Ent));\n-                     exit;\n-                  end if;\n-\n-                  Next_Entity (Ent);\n-               end loop;\n+               Set_Etype (Def_Id, Get_Cursor_Type (Typ));\n             end if;\n \n-            --  The cursor is the target of generated assignments in the\n-            --  loop, and cannot have a limited type.\n-\n-            if Is_Limited_Type (Etype (Def_Id)) then\n-               Error_Msg_N (\"cursor type cannot be limited\", N);\n-            end if;\n          end if;\n       end if;\n "}]}