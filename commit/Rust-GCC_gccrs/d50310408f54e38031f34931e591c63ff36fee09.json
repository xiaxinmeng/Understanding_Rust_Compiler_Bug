{"sha": "d50310408f54e38031f34931e591c63ff36fee09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUwMzEwNDA4ZjU0ZTM4MDMxZjM0OTMxZTU5MWM2M2ZmMzZmZWUwOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-11-10T22:17:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-11-13T18:36:29Z"}, "message": "c++: Implement C++20 'using enum'.  [PR91367]\n\nThis feature allows the programmer to import enumerator names into the\ncurrent scope so later mentions don't need to use the fully-qualified name.\nThese usings are not subject to the usual restrictions on using-decls: in\nparticular, they can move between class and non-class scopes, and between\nclasses that are not related by inheritance.  This last caused difficulty\nfor our normal approach to using-decls within a class hierarchy, as we\nassume that the class where we looked up a used declaration is derived from\nthe class where it was first declared.  So to simplify things, in that case\nwe make a clone of the CONST_DECL in the using class.\n\nThanks to Nathan for the start of this work: in particular, the\nlookup_using_decl rewrite.\n\nThe changes to dwarf2out revealed an existing issue with the D front-end: we\nwere doing the wrong thing for importing a D CONST_DECL, because\ndwarf2out_imported_module_or_decl_1 was looking through it to its type,\nexpecting it to be an enumerator, but in one case in thread.d, the constant\nhad type int.  Adding the ability to import a C++ enumerator also fixed\nthat, but that led to a crash in force_decl_die, which didn't know what to\ndo with a CONST_DECL.  So now it does.\n\nCo-authored-by: Nathan Sidwell <nathan@acm.org>\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (USING_DECL_UNRELATED_P): New.\n\t(CONST_DECL_USING_P): New.\n\t* class.c (handle_using_decl): If USING_DECL_UNRELATED_P,\n\tclone the CONST_DECL.\n\t* name-lookup.c (supplement_binding_1): A clone hides its\n\tusing-declaration.\n\t(lookup_using_decl): Rewrite to separate lookup and validation.\n\t(do_class_using_decl): Adjust.\n\t(finish_nonmember_using_decl): Adjust.\n\t* parser.c (make_location): Add cp_token overload.\n\t(finish_using_decl): Split out from...\n\t(cp_parser_using_declaration): ...here.  Don't look through enums.\n\t(cp_parser_using_enum): New.\n\t(cp_parser_block_declaration): Call it.\n\t(cp_parser_member_declaration): Call it.\n\t* semantics.c (finish_id_expression_1): Handle enumerator\n\tused from class scope.\n\ngcc/ChangeLog:\n\n\t* dwarf2out.c (gen_enumeration_type_die): Call\n\tequate_decl_number_to_die for enumerators.\n\t(gen_member_die): Don't move enumerators to their\n\tenclosing class.\n\t(dwarf2out_imported_module_or_decl_1): Allow importing\n\tindividual enumerators.\n\t(force_decl_die): Handle CONST_DECL.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/inh-ctor28.C: Adjust expected diagnostic.\n\t* g++.dg/cpp0x/inh-ctor33.C: Likewise.\n\t* g++.dg/cpp0x/using-enum-1.C: Add comment.\n\t* g++.dg/cpp0x/using-enum-2.C: Allowed in C++20.\n\t* g++.dg/cpp0x/using-enum-3.C: Likewise.\n\t* g++.dg/cpp1z/class-deduction69.C: Adjust diagnostic.\n\t* g++.dg/inherit/using5.C: Likewise.\n\t* g++.dg/cpp2a/using-enum-1.C: New test.\n\t* g++.dg/cpp2a/using-enum-2.C: New test.\n\t* g++.dg/cpp2a/using-enum-3.C: New test.\n\t* g++.dg/cpp2a/using-enum-4.C: New test.\n\t* g++.dg/cpp2a/using-enum-5.C: New test.\n\t* g++.dg/cpp2a/using-enum-6.C: New test.\n\t* g++.dg/debug/dwarf2/using-enum.C: New test.", "tree": {"sha": "8797b7178962c36a470b2e374fd5b3c8d2fb45fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8797b7178962c36a470b2e374fd5b3c8d2fb45fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d50310408f54e38031f34931e591c63ff36fee09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50310408f54e38031f34931e591c63ff36fee09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50310408f54e38031f34931e591c63ff36fee09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50310408f54e38031f34931e591c63ff36fee09/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b3b59683c1e7d31a9d313dd97394abebf644be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b3b59683c1e7d31a9d313dd97394abebf644be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b3b59683c1e7d31a9d313dd97394abebf644be"}], "stats": {"total": 783, "additions": 648, "deletions": 135}, "files": [{"sha": "ec47b0698ab4413327b60bd956db9fa1c8fe0e4f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -1331,6 +1331,23 @@ handle_using_decl (tree using_decl, tree t)\n \tadd_method (t, *iter, true);\n \talter_access (t, *iter, access);\n       }\n+  else if (USING_DECL_UNRELATED_P (using_decl))\n+    {\n+      /* C++20 using enum can import non-inherited enumerators into class\n+\t scope.  We implement that by making a copy of the CONST_DECL for which\n+\t CONST_DECL_USING_P is true.  */\n+      gcc_assert (TREE_CODE (decl) == CONST_DECL);\n+\n+      tree copy = copy_decl (decl);\n+      DECL_CONTEXT (copy) = t;\n+      DECL_ARTIFICIAL (copy) = true;\n+      /* We emitted debug info for the USING_DECL above; make sure we don't\n+\t also emit anything for this clone.  */\n+      DECL_IGNORED_P (copy) = true;\n+      DECL_SOURCE_LOCATION (copy) = DECL_SOURCE_LOCATION (using_decl);\n+      finish_member_declaration (copy);\n+      DECL_ABSTRACT_ORIGIN (copy) = decl;\n+    }\n   else\n     alter_access (t, decl, access);\n }"}, {"sha": "9ae6ff5f7a2c9e45c8eb2b05d28be3438370611e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -529,6 +529,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TEMPLATE_DECL_COMPLEX_ALIAS_P (in TEMPLATE_DECL)\n       DECL_INSTANTIATING_NSDMI_P (in a FIELD_DECL)\n       LABEL_DECL_CDTOR (in LABEL_DECL)\n+      USING_DECL_UNRELATED_P (in USING_DECL)\n    3: DECL_IN_AGGR_P.\n    4: DECL_C_BIT_FIELD (in a FIELD_DECL)\n       DECL_ANON_UNION_VAR_P (in a VAR_DECL)\n@@ -3409,6 +3410,16 @@ struct GTY(()) lang_decl {\n /* Non zero if the using decl refers to a dependent type.  */\n #define USING_DECL_TYPENAME_P(NODE) DECL_LANG_FLAG_1 (USING_DECL_CHECK (NODE))\n \n+/* True if member using decl NODE refers to a non-inherited NODE.  */\n+#define USING_DECL_UNRELATED_P(NODE) DECL_LANG_FLAG_2 (USING_DECL_CHECK (NODE))\n+\n+/* True iff the CONST_DECL is a class-scope clone from C++20 using enum,\n+   created by handle_using_decl.  */\n+#define CONST_DECL_USING_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == CONST_DECL\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) == ENUMERAL_TYPE\t\\\n+   && DECL_CONTEXT (NODE) != TREE_TYPE (NODE))\n+\n /* In a FUNCTION_DECL, this is nonzero if this function was defined in\n    the class definition.  We have saved away the text of the function,\n    but have not yet processed it.  */"}, {"sha": "bf05e7bbcd12535d6da01b4566896fff0ab1b269", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 164, "deletions": 92, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -2125,6 +2125,10 @@ supplement_binding_1 (cxx_binding *binding, tree decl)\n       region to refer only to the namespace to which it already\n       refers.  */\n     ok = false;\n+  else if (TREE_CODE (bval) == USING_DECL\n+\t   && CONST_DECL_USING_P (decl))\n+    /* Let the clone hide the using-decl that introduced it.  */\n+    binding->value = decl;\n   else\n     {\n       if (!error_operand_p (bval))\n@@ -4540,135 +4544,217 @@ push_class_level_binding (tree name, tree x)\n /* Process and lookup a using decl SCOPE::lookup.name, filling in\n    lookup.values & lookup.type.  Return true if ok.  */\n \n-static bool\n+static tree\n lookup_using_decl (tree scope, name_lookup &lookup)\n {\n   tree current = current_scope ();\n   bool dependent_p = false;\n+  tree binfo = NULL_TREE;\n+  base_kind b_kind = bk_not_base;\n+\n+  /* Because C++20 breaks the invariant that only member using-decls\n+     refer to members and only non-member using-decls refer to\n+     non-members, we first do the lookups, and then do validation that\n+     what we found is ok.  */\n+\n+  if (TREE_CODE (scope) == ENUMERAL_TYPE\n+      && cxx_dialect < cxx20\n+      && UNSCOPED_ENUM_P (scope)\n+      && !TYPE_FUNCTION_SCOPE_P (scope))\n+    {\n+      /* PR c++/60265 argued that since C++11 added explicit enum scope, we\n+\t should allow it as meaning the enclosing scope.  I don't see any\n+\t justification for this in C++11, but let's keep allowing it.  */\n+      tree ctx = CP_TYPE_CONTEXT (scope);\n+      if (CLASS_TYPE_P (ctx) == CLASS_TYPE_P (current))\n+\tscope = ctx;\n+    }\n \n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n       /* Naming a namespace member.  */\n-      if (TYPE_P (current))\n+      qualified_namespace_lookup (scope, &lookup);\n+\n+      if (TYPE_P (current)\n+\t  && (!lookup.value\n+\t      || lookup.type\n+\t      || cxx_dialect < cxx20\n+\t      || TREE_CODE (lookup.value) != CONST_DECL))\n \t{\n \t  error (\"using-declaration for non-member at class scope\");\n-\t  return false;\n+\t  return NULL_TREE;\n \t}\n-\n-      qualified_namespace_lookup (scope, &lookup);\n     }\n   else if (TREE_CODE (scope) == ENUMERAL_TYPE)\n     {\n-      error (\"using-declaration may not name enumerator %<%E::%D%>\",\n-\t     scope, lookup.name);\n-      return false;\n+      /* Naming an enumeration member.  */\n+      if (cxx_dialect < cxx20)\n+\terror (\"%<using%> with enumeration scope %q#T \"\n+\t       \"only available with %<-std=c++20%> or %<-std=gnu++20%>\",\n+\t       scope);\n+      lookup.value = lookup_enumerator (scope, lookup.name);\n     }\n   else\n     {\n-      /* Naming a class member.  */\n-      if (!TYPE_P (current))\n-\t{\n-\t  error (\"using-declaration for member at non-class scope\");\n-\t  return false;\n-\t}\n+      /* Naming a class member.  This is awkward in C++20, because we\n+\t might be naming an enumerator of an unrelated class.  */\n \n-      /* Make sure the name is not invalid */\n+      /* You cannot using-decl a destructor.  */\n       if (TREE_CODE (lookup.name) == BIT_NOT_EXPR)\n \t{\n \t  error (\"%<%T::%D%> names destructor\", scope, lookup.name);\n-\t  return false;\n+\t  return NULL_TREE;\n \t}\n \n       /* Using T::T declares inheriting ctors, even if T is a typedef.  */\n       if (MAYBE_CLASS_TYPE_P (scope)\n \t  && (lookup.name == TYPE_IDENTIFIER (scope)\n \t      || constructor_name_p (lookup.name, scope)))\n \t{\n+\t  if (!TYPE_P (current))\n+\t    {\n+\t      error (\"non-member using-decl names constructor of %qT\", scope);\n+\t      return NULL_TREE;\n+\t    }\n \t  maybe_warn_cpp0x (CPP0X_INHERITING_CTORS);\n \t  lookup.name = ctor_identifier;\n \t  CLASSTYPE_NON_AGGREGATE (current) = true;\n     \t}\n \n-      /* Cannot introduce a constructor name.  */\n-      if (constructor_name_p (lookup.name, current))\n+      if (!MAYBE_CLASS_TYPE_P (scope))\n+\t;\n+      else if (TYPE_P (current))\n \t{\n-\t  error (\"%<%T::%D%> names constructor in %qT\",\n-\t\t scope, lookup.name, current);\n-\t  return false;\n-\t}\n-\n-      /* Member using decls finish processing when completing the\n-\t class.  */\n-      /* From [namespace.udecl]:\n-\n-         A using-declaration used as a member-declaration shall refer\n-         to a member of a base class of the class being defined.\n+\t  dependent_p = dependent_scope_p (scope);\n+\t  if (!dependent_p)\n+\t    {\n+\t      binfo = lookup_base (current, scope, ba_any, &b_kind, tf_none);\n+\t      gcc_checking_assert (b_kind >= bk_not_base);\n \n-         In general, we cannot check this constraint in a template\n-         because we do not know the entire set of base classes of the\n-         current class type. Morover, if SCOPE is dependent, it might\n-         match a non-dependent base.  */\n+\t      if (lookup.name == ctor_identifier)\n+\t\t{\n+\t\t  /* Even if there are dependent bases, SCOPE will not\n+\t\t     be direct base, no matter.  */\n+\t\t  if (b_kind < bk_proper_base || !binfo_direct_p (binfo))\n+\t\t    {\n+\t\t      error (\"%qT is not a direct base of %qT\", scope, current);\n+\t\t      return NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t      else if (b_kind < bk_proper_base)\n+\t\tbinfo = TYPE_BINFO (scope);\n+\t      else if (IDENTIFIER_CONV_OP_P (lookup.name)\n+\t\t       && dependent_type_p (TREE_TYPE (lookup.name)))\n+\t\tdependent_p = true;\n+\t    }\n+\t}\n+      else\n+\tbinfo = TYPE_BINFO (scope);\n \n-      dependent_p = dependent_scope_p (scope);\n       if (!dependent_p)\n \t{\n-\t  base_kind b_kind;\n-\t  tree binfo = lookup_base (current, scope, ba_any, &b_kind,\n-\t\t\t\t    tf_warning_or_error);\n-\t  if (b_kind < bk_proper_base)\n+\t  if (binfo)\n+\t    lookup.value = lookup_member (binfo, lookup.name, /*protect=*/2,\n+\t\t\t\t\t  /*want_type=*/false, tf_none);\n+\n+\t  tree saved_value = lookup.value;\n+\t  if (lookup.value\n+\t      && b_kind < bk_proper_base)\n \t    {\n-\t      /* If there are dependent bases, scope might resolve at\n-\t\t instantiation time, even if it isn't exactly one of\n-\t\t the dependent bases.  */\n-\t      if (b_kind == bk_same_type || !any_dependent_bases_p ())\n+\t      if (cxx_dialect >= cxx20\n+\t\t  && TREE_CODE (lookup.value) == CONST_DECL)\n \t\t{\n-\t\t  error_not_base_type (scope, current);\n-\t\t  return false;\n+\t\t  /* Using an unrelated enum; check access here rather\n+\t\t     than separately for class and non-class using.  */\n+\t\t  perform_or_defer_access_check\n+\t\t    (binfo, lookup.value, lookup.value, tf_warning_or_error);\n+\t\t  /* And then if this is a copy from handle_using_decl, look\n+\t\t     through to the original enumerator.  */\n+\t\t  if (CONST_DECL_USING_P (lookup.value))\n+\t\t    lookup.value = DECL_ABSTRACT_ORIGIN (lookup.value);\n \t\t}\n-\t      /* Treat as-if dependent.  */\n-\t      dependent_p = true;\n+\t      else\n+\t\tlookup.value = NULL_TREE;\n \t    }\n-\t  else if (lookup.name == ctor_identifier && !binfo_direct_p (binfo))\n+\n+\t  if (!lookup.value)\n \t    {\n-\t      error (\"cannot inherit constructors from indirect base %qT\",\n-\t\t     scope);\n-\t      return false;\n+\t      if (!TYPE_P (current))\n+\t\t{\n+\t\t  error (\"using-declaration for member at non-class scope\");\n+\t\t  return NULL_TREE;\n+\t\t}\n+\n+\t      if (b_kind < bk_proper_base)\n+\t\t{\n+\t\t  if (b_kind == bk_not_base && any_dependent_bases_p ())\n+\t\t    /* Treat as-if dependent.  */\n+\t\t    dependent_p = true;\n+\t\t  else\n+\t\t    {\n+\t\t      auto_diagnostic_group g;\n+\t\t      error_not_base_type (scope, current);\n+\t\t      if (saved_value && DECL_IMPLICIT_TYPEDEF_P (saved_value)\n+\t\t\t  && (TREE_CODE (TREE_TYPE (saved_value))\n+\t\t\t      == ENUMERAL_TYPE))\n+\t\t\tinform (input_location,\n+\t\t\t\t\"did you mean %<using enum %T::%D%>?\",\n+\t\t\t\tscope, lookup.name);\n+\t\t      return NULL_TREE;\n+\t\t    }\n+\t\t}\n \t    }\n-\t  else if (IDENTIFIER_CONV_OP_P (lookup.name)\n-\t\t   && dependent_type_p (TREE_TYPE (lookup.name)))\n-\t    dependent_p = true;\n-\t  else\n-\t    lookup.value = lookup_member (binfo, lookup.name, 0,\n-\t\t\t\t\t  false, tf_warning_or_error);\n \t}\n     }\n \n-  if (!dependent_p)\n+  /* Did we find anything sane?  */\n+  if (dependent_p)\n+    ;\n+  else if (!lookup.value)\n     {\n-      if (!lookup.value)\n-\t{\n-\t  error (\"%qD has not been declared in %qE\", lookup.name, scope);\n-\t  return false;\n-\t}\n+      error (\"%qD has not been declared in %qD\", lookup.name, scope);\n+      return NULL_TREE;\n+    }\n+  else if (TREE_CODE (lookup.value) == TREE_LIST\n+\t   /* We can (independently) have ambiguous implicit typedefs.  */\n+\t   || (lookup.type && TREE_CODE (lookup.type) == TREE_LIST))\n+    {\n+      error (\"reference to %qD is ambiguous\", lookup.name);\n+      print_candidates (TREE_CODE (lookup.value) == TREE_LIST\n+\t\t\t? lookup.value : lookup.type);\n+      return NULL_TREE;\n+    }\n+  else if (TREE_CODE (lookup.value) == NAMESPACE_DECL)\n+    {\n+      error (\"using-declaration may not name namespace %qD\", lookup.value);\n+      return NULL_TREE;\n+    }\n \n-      if (TREE_CODE (lookup.value) == TREE_LIST\n-\t  /* We can (independently) have ambiguous implicit typedefs.  */\n-\t  || (lookup.type && TREE_CODE (lookup.type) == TREE_LIST))\n-\t{\n-\t  error (\"reference to %qD is ambiguous\", lookup.name);\n-\t  print_candidates (TREE_CODE (lookup.value) == TREE_LIST\n-\t\t\t    ? lookup.value : lookup.type);\n-\t  return false;\n-\t}\n+  if (TYPE_P (current))\n+    {\n+      /* In class scope.  */\n \n-      if (TREE_CODE (lookup.value) == NAMESPACE_DECL)\n+      /* Cannot introduce a constructor name.  */\n+      if (constructor_name_p (lookup.name, current))\n \t{\n-\t  error (\"using-declaration may not name namespace %qD\", lookup.value);\n-\t  return false;\n+\t  error (\"%<%T::%D%> names constructor in %qT\",\n+\t\t scope, lookup.name, current);\n+\t  return NULL_TREE;\n \t}\n+\n+      if (lookup.value && BASELINK_P (lookup.value))\n+\t/* The binfo from which the functions came does not matter.  */\n+\tlookup.value = BASELINK_FUNCTIONS (lookup.value);\n     }\n \n-  return true;\n+  tree using_decl = build_lang_decl (USING_DECL, lookup.name, NULL_TREE);\n+  USING_DECL_SCOPE (using_decl) = scope;\n+  USING_DECL_DECLS (using_decl) = lookup.value;\n+  DECL_DEPENDENT_P (using_decl) = dependent_p;\n+  if (TYPE_P (current) && b_kind == bk_not_base)\n+    USING_DECL_UNRELATED_P (using_decl) = true;\n+\n+  return using_decl;\n }\n \n /* Process \"using SCOPE::NAME\" in a class scope.  Return the\n@@ -4682,20 +4768,7 @@ do_class_using_decl (tree scope, tree name)\n     return NULL_TREE;\n \n   name_lookup lookup (name);\n-  if (!lookup_using_decl (scope, lookup))\n-    return NULL_TREE;\n-\n-  tree found = lookup.value;\n-  if (found && BASELINK_P (found))\n-    /* The binfo from which the functions came does not matter.  */\n-    found = BASELINK_FUNCTIONS (found);\n-\n-  tree using_decl = build_lang_decl (USING_DECL, lookup.name, NULL_TREE);\n-  USING_DECL_SCOPE (using_decl) = scope;\n-  USING_DECL_DECLS (using_decl) = found;\n-  DECL_DEPENDENT_P (using_decl) = !found;\n-\n-  return using_decl;\n+  return lookup_using_decl (scope, lookup);\n }\n \n \f\n@@ -5076,7 +5149,8 @@ finish_nonmember_using_decl (tree scope, tree name)\n \n   name_lookup lookup (name);\n \n-  if (!lookup_using_decl (scope, lookup))\n+  tree using_decl = lookup_using_decl (scope, lookup);\n+  if (!using_decl)\n     return;\n \n   /* Emit debug info.  */\n@@ -5105,8 +5179,6 @@ finish_nonmember_using_decl (tree scope, tree name)\n     }\n   else\n     {\n-      tree using_decl = build_lang_decl (USING_DECL, lookup.name, NULL_TREE);\n-      USING_DECL_SCOPE (using_decl) = scope;\n       add_decl_expr (using_decl);\n \n       cxx_binding *binding = find_local_binding (current_binding_level, name);"}, {"sha": "42f705266bb33b67ef9a7cd82dce0f1c755d049f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 117, "deletions": 28, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -808,6 +808,14 @@ make_location (location_t caret, location_t start, cp_lexer *lexer)\n   return make_location (caret, start, t->location);\n }\n \n+/* Overload for make_location taking tokens instead of locations.  */\n+\n+static inline location_t\n+make_location (cp_token *caret, cp_token *start, cp_token *end)\n+{\n+  return make_location (caret->location, start->location, end->location);\n+}\n+\n /* nonzero if we are presently saving tokens.  */\n \n static inline int\n@@ -2233,6 +2241,8 @@ static bool cp_parser_using_declaration\n   (cp_parser *, bool);\n static void cp_parser_using_directive\n   (cp_parser *);\n+static void cp_parser_using_enum\n+  (cp_parser *);\n static tree cp_parser_alias_declaration\n   (cp_parser *);\n static void cp_parser_asm_definition\n@@ -13726,6 +13736,8 @@ cp_parser_block_declaration (cp_parser *parser,\n       token2 = cp_lexer_peek_nth_token (parser->lexer, 2);\n       if (token2->keyword == RID_NAMESPACE)\n \tcp_parser_using_directive (parser);\n+      else if (token2->keyword == RID_ENUM)\n+\tcp_parser_using_enum (parser);\n       /* If the second token after 'using' is '=', then we have an\n \t alias-declaration.  */\n       else if (cxx_dialect >= cxx11\n@@ -20010,6 +20022,31 @@ cp_parser_qualified_namespace_specifier (cp_parser* parser)\n   return cp_parser_namespace_name (parser);\n }\n \n+/* Subroutine of cp_parser_using_declaration.  */\n+\n+static tree\n+finish_using_decl (tree qscope, tree identifier, bool typename_p = false)\n+{\n+  tree decl = NULL_TREE;\n+  if (at_class_scope_p ())\n+    {\n+      /* Create the USING_DECL.  */\n+      decl = do_class_using_decl (qscope, identifier);\n+\n+      if (check_for_bare_parameter_packs (decl))\n+\treturn error_mark_node;\n+\n+      if (decl && typename_p)\n+\tUSING_DECL_TYPENAME_P (decl) = 1;\n+\n+      /* Add it to the list of members in this class.  */\n+      finish_member_declaration (decl);\n+    }\n+  else\n+    finish_nonmember_using_decl (qscope, identifier);\n+  return decl;\n+}\n+\n /* Parse a using-declaration, or, if ACCESS_DECLARATION_P is true, an\n    access declaration.\n \n@@ -20029,7 +20066,6 @@ cp_parser_using_declaration (cp_parser* parser,\n   cp_token *token;\n   bool typename_p = false;\n   bool global_scope_p;\n-  tree decl;\n   tree identifier;\n   tree qscope;\n   int oldcount = errorcount;\n@@ -20088,9 +20124,6 @@ cp_parser_using_declaration (cp_parser* parser,\n \t\t\t\t\t\t  /*is_declaration=*/true);\n   if (!qscope)\n     qscope = global_namespace;\n-  else if (UNSCOPED_ENUM_P (qscope)\n-\t   && !TYPE_FUNCTION_SCOPE_P (qscope))\n-    qscope = CP_TYPE_CONTEXT (qscope);\n \n   cp_warn_deprecated_use_scopes (qscope);\n \n@@ -20138,25 +20171,13 @@ cp_parser_using_declaration (cp_parser* parser,\n \t      \"a template-id may not appear in a using-declaration\");\n   else\n     {\n-      if (at_class_scope_p ())\n-\t{\n-\t  /* Create the USING_DECL.  */\n-\t  decl = do_class_using_decl (qscope, identifier);\n-\n-\t  if (decl && typename_p)\n-\t    USING_DECL_TYPENAME_P (decl) = 1;\n+      tree decl = finish_using_decl (qscope, identifier, typename_p);\n \n-\t  if (check_for_bare_parameter_packs (decl))\n-\t    {\n-\t      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n-\t      return false;\n-\t    }\n-\t  else\n-\t    /* Add it to the list of members in this class.  */\n-\t    finish_member_declaration (decl);\n+      if (decl == error_mark_node)\n+\t{\n+\t  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+\t  return false;\n \t}\n-      else\n-\tfinish_nonmember_using_decl (qscope, identifier);\n     }\n \n   if (!access_declaration_p\n@@ -20182,6 +20203,76 @@ cp_parser_using_declaration (cp_parser* parser,\n   return true;\n }\n \n+/* C++20 using enum declaration.\n+\n+   using-enum-declaration :\n+       using elaborated-enum-specifier ;  */\n+\n+static void\n+cp_parser_using_enum (cp_parser *parser)\n+{\n+  cp_parser_require_keyword (parser, RID_USING, RT_USING);\n+\n+  /* Using cp_parser_elaborated_type_specifier rejects typedef-names, which\n+     breaks one of the motivating examples in using-enum-5.C.\n+     cp_parser_simple_type_specifier seems to be closer to what we actually\n+     want, though that hasn't been properly specified yet.  */\n+\n+  /* Consume 'enum'.  */\n+  gcc_checking_assert (cp_lexer_next_token_is_keyword (parser->lexer, RID_ENUM));\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  cp_token *start = cp_lexer_peek_token (parser->lexer);\n+\n+  tree type = (cp_parser_simple_type_specifier\n+\t       (parser, NULL, CP_PARSER_FLAGS_TYPENAME_OPTIONAL));\n+\n+  cp_token *end = cp_lexer_previous_token (parser->lexer);\n+\n+  if (type == error_mark_node\n+      || !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+    {\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+      return;\n+    }\n+  if (TREE_CODE (type) == TYPE_DECL)\n+    type = TREE_TYPE (type);\n+\n+  /* The elaborated-enum-specifier shall not name a dependent type and the type\n+     shall have a reachable enum-specifier.  */\n+  const char *msg = nullptr;\n+  if (cxx_dialect < cxx20)\n+    msg = _(\"%<using enum%> \"\n+\t    \"only available with %<-std=c++20%> or %<-std=gnu++20%>\");\n+  else if (dependent_type_p (type))\n+    msg = _(\"%<using enum%> of dependent type %qT\");\n+  else if (TREE_CODE (type) != ENUMERAL_TYPE)\n+    msg = _(\"%<using enum%> of non-enumeration type %q#T\");\n+  else if (!COMPLETE_TYPE_P (type))\n+    msg = _(\"%<using enum%> of incomplete type %qT\");\n+  else if (OPAQUE_ENUM_P (type))\n+    msg = _(\"%<using enum%> of %qT before its enum-specifier\");\n+  if (msg)\n+    {\n+      location_t loc = make_location (start, start, end);\n+      auto_diagnostic_group g;\n+      error_at (loc, msg, type);\n+      loc = location_of (type);\n+      if (cxx_dialect < cxx20 || loc == input_location)\n+\t;\n+      else if (OPAQUE_ENUM_P (type))\n+\tinform (loc, \"opaque-enum-declaration here\");\n+      else\n+\tinform (loc, \"declared here\");\n+    }\n+\n+  /* A using-enum-declaration introduces the enumerator names of the named\n+     enumeration as if by a using-declaration for each enumerator.  */\n+  if (TREE_CODE (type) == ENUMERAL_TYPE)\n+    for (tree v = TYPE_VALUES (type); v; v = TREE_CHAIN (v))\n+      finish_using_decl (type, DECL_NAME (TREE_VALUE (v)));\n+}\n+\n /* Parse an alias-declaration.\n \n    alias-declaration:\n@@ -25279,12 +25370,10 @@ cp_parser_member_declaration (cp_parser* parser)\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n     {\n       if (cxx_dialect < cxx11)\n-\t{\n-\t  /* Parse the using-declaration.  */\n-\t  cp_parser_using_declaration (parser,\n-\t\t\t\t       /*access_declaration_p=*/false);\n-\t  return;\n-\t}\n+\t/* Parse the using-declaration.  */\n+\tcp_parser_using_declaration (parser, /*access_declaration_p=*/false);\n+      else if (cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_ENUM))\n+\tcp_parser_using_enum (parser);\n       else\n \t{\n \t  tree decl;\n@@ -25305,8 +25394,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  else\n \t    cp_parser_using_declaration (parser,\n \t\t\t\t\t /*access_declaration_p=*/false);\n-\t  return;\n \t}\n+      return;\n     }\n \n   /* Check for @defs.  */"}, {"sha": "5ff70ff4844a897454281b944c8f008bf4e49d0e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -4019,9 +4019,17 @@ finish_id_expression_1 (tree id_expression,\n \t      if (context != current_class_type)\n \t\t{\n \t\t  tree path = currently_open_derived_class (context);\n-\t\t  perform_or_defer_access_check (TYPE_BINFO (path),\n-\t\t\t\t\t\t decl, decl,\n-\t\t\t\t\t\t tf_warning_or_error);\n+\t\t  if (!path)\n+\t\t    /* PATH can be null for using an enum of an unrelated\n+\t\t       class; we checked its access in lookup_using_decl.\n+\n+\t\t       ??? Should this case make a clone instead, like\n+\t\t       handle_using_decl?  */\n+\t\t    gcc_assert (TREE_CODE (decl) == CONST_DECL);\n+\t\t  else\n+\t\t    perform_or_defer_access_check (TYPE_BINFO (path),\n+\t\t\t\t\t\t   decl, decl,\n+\t\t\t\t\t\t   tf_warning_or_error);\n \t\t}\n \t    }\n "}, {"sha": "0e8436e51c454d7631ce054857bc399c1ae5fe8e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -22193,6 +22193,9 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \t  dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die, link);\n \t  tree value = TREE_VALUE (link);\n \n+\t  if (DECL_P (value))\n+\t    equate_decl_number_to_die (value, enum_die);\n+\n \t  gcc_assert (!ENUM_IS_OPAQUE (type));\n \t  add_name_attribute (enum_die,\n \t\t\t      IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n@@ -25247,6 +25250,10 @@ gen_member_die (tree type, dw_die_ref context_die)\n \t\t  splice = false;\n \t\t}\n \t    }\n+\t  else if (child->die_tag == DW_TAG_enumerator)\n+\t    /* Enumerators remain under their enumeration even if\n+\t       their names are introduced in the enclosing scope.  */\n+\t    splice = false;\n \n \t  if (splice)\n \t    splice_child_die (context_die, child);\n@@ -26158,6 +26165,13 @@ force_decl_die (tree decl)\n \t    decl_die = comp_unit_die ();\n \t  break;\n \n+\tcase CONST_DECL:\n+\t  /* Enumerators shouldn't need force_decl_die.  */\n+\t  gcc_assert (DECL_CONTEXT (decl) == NULL_TREE\n+\t\t      || TREE_CODE (DECL_CONTEXT (decl)) != ENUMERAL_TYPE);\n+\t  gen_decl_die (decl, NULL, NULL, context_die);\n+\t  break;\n+\n \tcase TRANSLATION_UNIT_DECL:\n \t  decl_die = comp_unit_die ();\n \t  break;\n@@ -26743,7 +26757,7 @@ dwarf2out_imported_module_or_decl_1 (tree decl,\n   else\n     xloc = expand_location (input_location);\n \n-  if (TREE_CODE (decl) == TYPE_DECL || TREE_CODE (decl) == CONST_DECL)\n+  if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       at_import_die = force_type_die (TREE_TYPE (decl));\n       /* For namespace N { typedef void T; } using N::T; base_type_die"}, {"sha": "59801a1d7bc2c41d0ac39500337dc1ac650229ef", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor28.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -4,4 +4,4 @@\n struct A {};\n struct B : virtual A {};\n struct C : virtual A {};\n-struct D : B,C { using A::A; };\t// { dg-error \"indirect\" }\n+struct D : B,C { using A::A; };\t// { dg-error \"not a direct base\" }"}, {"sha": "4e612907a4236edec15add00fd7ba0b74bc0091f", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor33.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor33.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -10,7 +10,7 @@ public:\n class Y : public X { };\n \n class Z : public Y {\n-  using X::X; // { dg-error \"cannot inherit constructors from indirect base .X.\" }\n+  using X::X; // { dg-error \".X. is not a direct base of .Z.\" }\n };\n \n int main()"}, {"sha": "bf251babeaefa43f18effecd313204b0efcd6d51", "filename": "gcc/testsuite/g++.dg/cpp0x/using-enum-1.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-1.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -1,6 +1,9 @@\n // PR c++/60265\n // { dg-do compile { target c++11 } }\n \n+// [namespace.udecl]/7 shall not name a scoped enumerator.\n+// (so unscoped enumerator is ok)\n+\n namespace A\n {\n   enum E { V };"}, {"sha": "8ea70d79d4dd83fd57fb4c1e7569377420fef7ae", "filename": "gcc/testsuite/g++.dg/cpp0x/using-enum-2.C", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-2.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -1,20 +1,23 @@\n // PR c++/60265\n // { dg-do compile { target c++11 } }\n \n+// [namespace.udecl]/7 shall not name a scoped enumerator.\n+// (this changes in C++2a)\n+\n namespace A\n {\n   enum class E { V };\n \n-  using E::V;        // { dg-error \"name enumerator\" }\n+  using E::V;        // { dg-error \"enum\" \"\" { target { ! c++2a } } }\n }\n \n void foo()\n {\n-  using A::E::V;     // { dg-error \"name enumerator\" }\n+  using A::E::V;     // { dg-error \"enum\" \"\" { target { ! c++2a } } }\n }\n \n-using A::E::V;       // { dg-error \"name enumerator\" }\n+using A::E::V;       // { dg-error \"enum\" \"\" { target { ! c++2a } } }\n \n enum class F { U };\n \n-using F::U;          // { dg-error \"name enumerator\" }\n+using F::U;          // { dg-error \"enum\" \"\" { target { ! c++2a } } }"}, {"sha": "34f8bf4fa0bb1491375daab1c42991a89e5664b7", "filename": "gcc/testsuite/g++.dg/cpp0x/using-enum-3.C", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-3.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -1,21 +1,30 @@\n // PR c++/89511\n // { dg-do compile { target c++11 } }\n \n+// [namespace.udecl] In a using-declaration used as a\n+// member-declaration, the nested-name-specifier shall name a base\n+// class of the class being defined\n+// (this changes in C++2a)\n+\n void f ()\n {\n   enum e { a };\n-  using e::a; // { dg-error \"name enumerator\" }\n+  using e::a;  // { dg-error \"redeclaration\" }\n+  // { dg-error \"enum\" \"\" { target { ! c++2a } } .-1 }\n }\n \n+enum E { A };\n+\n struct S {\n   enum E { A };\n-  using E::A; // { dg-error \"type .S. is not a base type for type .S.\" }\n+  using E::A; // { dg-error \"not a base\" \"\" { target { ! c++2a } } }\n+  // { dg-error \"conflicts\" \"\" { target c++2a } .-1 }\n };\n \n namespace N {\n   enum E { B };\n }\n \n struct T {\n-  using N::E::B; // { dg-error \"using-declaration for non-member at class scope\" }\n+  using N::E::B; // { dg-error \"enum\" \"\" { target { ! c++2a } } }\n };"}, {"sha": "d3363668cc52c2000d97037aa2c75739e05cb969", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction69.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction69.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction69.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction69.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -6,7 +6,7 @@ namespace a {\n   template <typename...> using c = b;\n }\n template <typename... d> struct e : a::c<d...> { // { dg-error \"incomplete\" }\n-  using a::c<>::c;\t\t// { dg-prune-output \"not a base\" }\n+  using a::c<>::c;\t\t// { dg-prune-output \"not a direct base\" }\n };\n template <template <typename> typename f> void g() { f(); }\n void h() { g<e>(); }"}, {"sha": "fd34ca8759ac07b30b4cd590f9097f677151ef4f", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-1.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-1.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,62 @@\n+// Test of using an enumerator.\n+// { dg-do compile { target c++2a } }\n+\n+// using ENUM::V;\n+enum class E {v};\n+\n+using E::v;\n+using E::v; // OK\n+\n+E a = v;\n+\n+class C\n+{\n+  using E::v;\t\t\t// { dg-message \"declared private here\" }\n+\n+  static inline const E m = v;\n+};\n+\n+E b = C::v;\t\t\t// { dg-error \"private\" }\n+\n+struct B\n+{\n+  enum E {e};\n+  enum class EC {f};\n+  using EC::f;\n+};\n+\n+struct D\n+{\n+private:\n+  using B::e;\t\t\t// { dg-message \"declared private here\" }\n+  using B::f;\t\t\t// { dg-message \"declared private here\" }\n+};\n+\n+struct F : D\n+{\n+  static inline const auto bad1 = e; // { dg-error \"private\" }\n+  static inline const auto bad2 = f; // { dg-error \"private\" }\n+\n+  static inline const auto ok1 = B::e;\n+  static inline const auto ok2 = B::f;\n+  static inline const auto also_ok1 = B::E::e;\n+  static inline const auto also_ok2 = B::EC::f;\n+};\n+\n+using B::e;\n+auto bob = e;\n+\n+struct Q\n+{\n+  using B::e;\n+};\n+using Q::e;\t\t\t// OK\n+\n+using D::e;\t\t\t// { dg-error \"private\" }\n+\n+template <class T>\n+struct X : T\n+{\n+  using T::e;\n+};\n+auto fob = X<Q>::e;"}, {"sha": "66b37f9c0104ab0659db99b55230e58d91c1332c", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-2.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-2.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,48 @@\n+// Test of 'using enum' in different scopes.\n+// { dg-do compile { target c++20 } }\n+\n+namespace N\n+{\n+  enum class E { e, f };\n+}\n+\n+int main()\n+{\n+  using enum N::E;\n+  static_assert (e < f);\n+}\n+\n+struct A\n+{\n+  using enum N::E;\n+  static_assert (e < f);\n+};\n+\n+namespace M\n+{\n+  using enum N::E;\n+  static_assert (e < f);\n+\n+  enum class X: int;\t\t// { dg-message \"opaque\" }\n+  using enum X;\t\t\t// { dg-error \"enum-specifier\" }\n+}\n+\n+template <class T>\n+void f()\n+{\n+  using enum N::E;\n+  static_assert (e < f);\n+}\n+\n+template <class T>\n+struct AT\n+{\n+  using enum N::E;\n+  static_assert (e < f);\n+};\n+\n+template <class T>\n+struct BT\n+{\n+  using enum T::E;\t\t// { dg-error \"dependent\" }\n+};"}, {"sha": "d09bd6a46834b33666d7a4a71f67d336bb1b5994", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-3.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-3.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,6 @@\n+// Test of 'using enum' syntax error recovery.\n+// { dg-do compile { target c++20 } }\n+\n+using enum 2 + garbage3'850%^&;\t\t// { dg-error \"\" }\n+\n+void f() {}"}, {"sha": "03432cf45326af78395258cff115fc7f0ab21f8c", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-4.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,13 @@\n+// Test for suggestion to try 'using enum'.\n+// { dg-do compile { target c++20 } }\n+\n+struct A\n+{\n+  enum E { e };\n+};\n+\n+struct B\n+{\n+  using A::E;\t\t\t// { dg-error \"\" }\n+  // { dg-message \"using enum\" \"\" { target *-*-* } .-1 }\n+};"}, {"sha": "e5fe820925b2631f68c273cfcd6081b3a9bea080", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-5.C", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-5.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,132 @@\n+// Examples from P1099R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace my_lib {\n+\n+  enum class errcode\n+    {\n+     SUCCESS = 0,\n+     ENOMEM = 1,\n+     EAGAIN = 2,\n+     ETOOSLOW = 3\n+    };\n+  using enum errcode; // import enumerators into namespace\n+}\n+\n+namespace NS {\n+  my_lib::errcode get_widget() {\n+    using namespace my_lib;\n+    return ETOOSLOW; // works, and conversions to int don't.\n+    int i = ETOOSLOW;\t\t// { dg-error \"\" }\n+  }\n+}\n+\n+enum class rgba_color_channel { red, green, blue, alpha};\n+\n+const char * to_string(rgba_color_channel channel) {\n+  switch (channel) {\n+    using enum rgba_color_channel;\n+  case red:   return \"red\";\n+  case green: return \"green\";\n+  case blue:  return \"blue\";\n+  case alpha: return \"alpha\";\n+  }\n+  return nullptr;\n+}\n+\n+namespace ns {\n+  struct E_detail {\n+    enum E { e1, e2 };\n+    friend void swap(E&, E&);  // adl-only swap in the only associated scope of the enum\n+  };\n+  using E = E_detail::E;  // import E into ns\n+  using enum E;           // expose the enumerators of E in ns. Also note the direct reference to E.\n+}\n+\n+int main() {\n+  auto x = ns::e1;\n+  auto y = ns::e2;\n+  swap(x, y); // finds the swap in the associated struct\n+}\n+\n+namespace N0 {\n+  enum E { x };\n+  struct S {\n+    enum H { y };\n+    enum class K { z };\n+    using E::x; // OK, introduces x into S\n+    using E::x; // { dg-error \"\" } redeclaration in class scope\n+    using H::y; // { dg-error \"\" } redeclaration in class scope\n+    using K::z; // OK, introduces z into S\n+  };\n+  namespace NS {\n+    enum H { y };\n+    enum class K { z };\n+    using E::x; // OK, introduces x into NS\n+    using E::x; // OK, just a redeclaration of the same entity\n+    using H::y; // OK, redeclaration of the same entity\n+    using K::z; // OK, introduces z into NS\n+  };\n+}\n+namespace N1 {\n+  struct S {\n+    enum E { x };\n+    enum class EC { y };\n+    using EC::y;\n+  };\n+\n+  void f() {\n+    using S::x; // OK\n+    x; // resolves to S::E::x;\n+    using S::y; // OK\n+    y; // resolves to S::EC::y;\n+  }\n+}\n+\n+namespace N2 {\n+  enum class E { a, b, c };\n+  using E::a, E::b, E::c; // OK, imports all three\n+  auto x = (a,b,c);\n+}\n+\n+namespace N3 {\n+  struct B {\n+    enum class E { x };\n+  };\n+  enum class H { y };\n+  struct C : B {\n+    using enum B::E; // OK, introduces E::x into C\n+    using enum H; // OK, introduces y into C. Does not introduce H\n+  };\n+  auto i = C::y;  // OK\n+  C::H h;\t  // { dg-error \"\" }\n+}\n+\n+namespace N4 {\n+  enum class button { up, down };\n+  struct S {\n+    using button::up;\n+    button b = up; // OK\n+  };\n+}\n+\n+namespace N5 {\n+  enum class fruit { orange, apple };\n+  struct S {\n+    using enum fruit; // OK, introduces orange and apple into S\n+  };\n+  void f() {\n+    S s;\n+    s.orange; // OK, names fruit::orange\n+    S::orange; // OK, names fruit::orange\n+  }\n+}\n+\n+namespace N6 {\n+  enum class fruit { orange, apple };\n+  enum class color { red, orange };\n+  void f() {\n+    using enum fruit; // OK\n+    using enum color; // { dg-error \"\" } color::orange and fruit::orange conflict\n+  }\n+}"}, {"sha": "732cdfdcd3c4e7e44d33cc46d46e3dcffb0003de", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-6.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-6.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target c++2a } }\n+\n+using enum void;\t\t// { dg-error \"non-enum\" }\n+struct A {};\t\t\t// { dg-message \"declared here\" }\n+using enum A;\t\t\t// { dg-error \"non-enum\" }"}, {"sha": "7663a13cc61b1e93b71602985455ed44dc8b407b", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/using-enum.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fusing-enum.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fusing-enum.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fusing-enum.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -0,0 +1,21 @@\n+// Test of 'using enum' debug info.\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"-g -dA\" }\n+\n+struct A\n+{\n+  // All the counts are +1 for the abbreviation table.\n+  // { dg-final { scan-assembler-times \"DW_TAG_enumeration_type\" 2 } }\n+  // { dg-final { scan-assembler-times \"DW_TAG_enumerator\" 3 } }\n+  enum E { e, f };\n+};\n+\n+struct B\n+{\n+  // The using-enum-declaration is represented by two\n+  // DW_TAG_imported_declaration, one for each enumerator.\n+  // { dg-final { scan-assembler-times \"DW_TAG_imported_declaration\" 3 } }\n+  using enum A::E;\n+};\n+\n+B b;"}, {"sha": "514cd8daeb8cd1e351519c0e9baaed4e1b45a55d", "filename": "gcc/testsuite/g++.dg/inherit/using5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50310408f54e38031f34931e591c63ff36fee09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing5.C?ref=d50310408f54e38031f34931e591c63ff36fee09", "patch": "@@ -6,7 +6,7 @@\n \n template<int> struct A\n {\n-  A::A; // { dg-error \"constructor|not a base\" }\n+  A::A; // { dg-error \"constructor|not a direct base\" }\n };\n \n struct B"}]}