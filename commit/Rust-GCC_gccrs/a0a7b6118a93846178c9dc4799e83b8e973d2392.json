{"sha": "a0a7b6118a93846178c9dc4799e83b8e973d2392", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhN2I2MTE4YTkzODQ2MTc4YzlkYzQ3OTllODNiOGU5NzNkMjM5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-02-20T15:47:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-02-20T15:47:21Z"}, "message": "re PR tree-optimization/56265 (ICE in ipa_make_edge_direct_to_target)\n\n\n\tPR tree-optimization/56265\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Fixup callgraph when target is\n\treferenced for firs ttime.\n\t* testsuite/g++.dg/ipa/devirt-11.C: New testcase.\n\nFrom-SVN: r196177", "tree": {"sha": "8b602fb1fb7fa12cf4fd2de573072632591e29d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b602fb1fb7fa12cf4fd2de573072632591e29d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a7b6118a93846178c9dc4799e83b8e973d2392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7b6118a93846178c9dc4799e83b8e973d2392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a7b6118a93846178c9dc4799e83b8e973d2392", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7b6118a93846178c9dc4799e83b8e973d2392/comments", "author": null, "committer": null, "parents": [{"sha": "c0e50f7246effd184a626f401784df686767d389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e50f7246effd184a626f401784df686767d389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e50f7246effd184a626f401784df686767d389"}], "stats": {"total": 122, "additions": 119, "deletions": 3}, "files": [{"sha": "98d18c0bc5ce0af45e2054af260e85571d99313b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0a7b6118a93846178c9dc4799e83b8e973d2392", "patch": "@@ -1,3 +1,9 @@\n+2013-02-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/56265\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Fixup callgraph when target is\n+\treferenced for firs ttime.\n+\n 2013-02-20  Richard Biener  <rguenther@suse.de>\n \n \t* tree-call-cdce.c (tree_call_cdce): Do not remove unused locals."}, {"sha": "f68349363b09596018bf2003995caa55a8358b80", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a0a7b6118a93846178c9dc4799e83b8e973d2392", "patch": "@@ -2100,10 +2100,65 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n   if (TREE_CODE (target) == ADDR_EXPR)\n     target = TREE_OPERAND (target, 0);\n   if (TREE_CODE (target) != FUNCTION_DECL)\n-    return NULL;\n+    {\n+      target = canonicalize_constructor_val (target, NULL);\n+      if (!target || TREE_CODE (target) != FUNCTION_DECL)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"ipa-prop: Discovered direct call to non-function\"\n+\t\t\t\t\" in (%s/%i).\\n\",\n+\t\t     cgraph_node_name (ie->caller), ie->caller->uid);\n+\t  return NULL;\n+\t}\n+    }\n   callee = cgraph_get_node (target);\n-  if (!callee)\n-    return NULL;\n+\n+  /* Because may-edges are not explicitely represented and vtable may be external,\n+     we may create the first reference to the object in the unit.  */\n+  if (!callee || callee->global.inlined_to)\n+    {\n+      struct cgraph_node *first_clone = callee;\n+\n+      /* We are better to ensure we can refer to it.\n+\t In the case of static functions we are out of luck, since we already\t\n+\t removed its body.  In the case of public functions we may or may\n+\t not introduce the reference.  */\n+      if (!canonicalize_constructor_val (target, NULL)\n+\t  || !TREE_PUBLIC (target))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n+\t\t     \"(%s/%i -> %s/%i) but can not refer to it. Giving up.\\n\",\n+\t\t     xstrdup (cgraph_node_name (ie->caller)), ie->caller->uid,\n+\t\t     xstrdup (cgraph_node_name (ie->callee)), ie->callee->uid);\n+\t  return NULL;\n+\t}\n+\n+      /* Create symbol table node.  Even if inline clone exists, we can not take\n+\t it as a target of non-inlined call.  */\n+      callee = cgraph_create_node (target);\n+\n+      /* OK, we previously inlined the function, then removed the offline copy and\n+\t now we want it back for external call.  This can happen when devirtualizing\n+\t while inlining function called once that happens after extern inlined and\n+\t virtuals are already removed.  In this case introduce the external node\n+\t and make it available for call.  */\n+      if (first_clone)\n+\t{\n+\t  first_clone->clone_of = callee;\n+\t  callee->clones = first_clone;\n+\t  symtab_prevail_in_asm_name_hash ((symtab_node)callee);\n+\t  symtab_insert_node_to_hashtable ((symtab_node)callee);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"ipa-prop: Introduced new external node \"\n+\t\t     \"(%s/%i) and turned into root of the clone tree.\\n\",\n+\t\t     xstrdup (cgraph_node_name (callee)), callee->uid);\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"ipa-prop: Introduced new external node \"\n+\t\t \"(%s/%i).\\n\",\n+\t\t xstrdup (cgraph_node_name (callee)), callee->uid);\n+    }\n   ipa_check_create_node_params ();\n \n   /* We can not make edges to inline clones.  It is bug that someone removed"}, {"sha": "d79a94f9641cdf4844b4b27d246f0878810a4863", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a0a7b6118a93846178c9dc4799e83b8e973d2392", "patch": "@@ -1,3 +1,8 @@\n+2013-02-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/56265\n+\t* testsuite/g++.dg/ipa/devirt-11.C: New testcase.\n+\n 2013-02-20  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/forwprop-8.c: Adjust."}, {"sha": "c139f8f9633337e9c9e222e4370af74ec8186962", "filename": "gcc/testsuite/g++.dg/ipa/devirt-11.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b6118a93846178c9dc4799e83b8e973d2392/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C?ref=a0a7b6118a93846178c9dc4799e83b8e973d2392", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-inline\" } */\n+int baz ();\n+struct A\n+{\n+  virtual int fn2 () = 0;\n+  virtual int *fn3 ();\n+  double *fn4 ();\n+  int fn5 (int);\n+  template <class T>\n+  void fn1 (A &, T) { fn3 (); fn4 (); fn2 (); }\n+};\n+struct B : A\n+{\n+  int fn2 () { return 6; }\n+  void fn3 (int, double);\n+  B (bool = true);\n+  B (int, int);\n+};\n+template <typename T>\n+void\n+foo (B &x, A &y, A &z)\n+{\n+  y.fn2 ();\n+  z.fn2 ();\n+  int i = baz ();\n+  int j = (y.fn3 ())[i];\n+  x.fn3 (j, (y.fn4 ())[i] + (z.fn4 ())[z.fn5 (j)]);\n+}\n+inline B\n+operator+ (A &y, A &z)\n+{\n+  B x;\n+  foo<int> (x, y, z);\n+  return x;\n+}\n+void\n+bar ()\n+{\n+  B a, b, c (4, 0), d;\n+  a.fn1 (b, .6);\n+  baz ();\n+  c + d;\n+}\n+/* While inlining function called once we should devirtualize a new call to fn2\n+   and two to fn3. While doing so the new symbol for fn2 needs to be\n+   introduced.  */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 3 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"and turned into root of the clone tree\" 1 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}