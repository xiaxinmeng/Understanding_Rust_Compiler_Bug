{"sha": "07385c4994a45ba1781fb91e0585da3a0628e14d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczODVjNDk5NGE0NWJhMTc4MWZiOTFlMDU4NWRhM2EwNjI4ZTE0ZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "2000-04-12T20:10:19Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-04-12T20:10:19Z"}, "message": "sh.h (STRUCT_VALUE): Just 0 for TARGET_HITACHI.\n\n\t* sh.h (STRUCT_VALUE): Just 0 for TARGET_HITACHI.\n\t(struct sh_args): Add new field force_mem.\n\t(INIT_CUMULATIVE_ARGS): Initialize it.\n\t(FUNCTION_ARG, FUNCTION_ARG_ADVANCE): Act on it.\n\nFrom-SVN: r33123", "tree": {"sha": "5032e59ac24ca3f23ab79c35b9f235a7eac72e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5032e59ac24ca3f23ab79c35b9f235a7eac72e6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07385c4994a45ba1781fb91e0585da3a0628e14d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07385c4994a45ba1781fb91e0585da3a0628e14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07385c4994a45ba1781fb91e0585da3a0628e14d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07385c4994a45ba1781fb91e0585da3a0628e14d/comments", "author": null, "committer": null, "parents": [{"sha": "504f140d090036a703458e7690870ff3e66ad89b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504f140d090036a703458e7690870ff3e66ad89b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/504f140d090036a703458e7690870ff3e66ad89b"}], "stats": {"total": 34, "additions": 20, "deletions": 14}, "files": [{"sha": "43332c7e23c1055687d3151cd6b0c643cd4b4caa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07385c4994a45ba1781fb91e0585da3a0628e14d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07385c4994a45ba1781fb91e0585da3a0628e14d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07385c4994a45ba1781fb91e0585da3a0628e14d", "patch": "@@ -1,3 +1,10 @@\n+Wed Apr 12 20:51:20 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* sh.h (STRUCT_VALUE): Just 0 for TARGET_HITACHI.\n+\t(struct sh_args): Add new field force_mem.\n+\t(INIT_CUMULATIVE_ARGS): Initialize it.\n+\t(FUNCTION_ARG, FUNCTION_ARG_ADVANCE): Act on it.\n+\n Wed Apr 12 17:20:41 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t(expand_call): Do not reverse args in \"equal from\" field."}, {"sha": "1cb93444213e68edbba43e023eba590a2654e793", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07385c4994a45ba1781fb91e0585da3a0628e14d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07385c4994a45ba1781fb91e0585da3a0628e14d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=07385c4994a45ba1781fb91e0585da3a0628e14d", "patch": "@@ -594,19 +594,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* The Hitachi calling convention doesn't quite fit into this scheme since\n    the address is passed like an invisible argument, but one that is always\n-   passed in memory.  We approximate this by saying where the pointer is;\n-   however, this will put any actual arguments that are passed in memory\n-   in the wrong place.\n-   If we wanted to implement this exactly, we'd need a STRUCT_VALUE of 0,\n-   an extra field in CUMULATIVE_ARGS, initialize it in INIT_CUMULATIVE_ARGS,\n-   and hack FUNCTION_ARG (actually PASS_IN_REG_P) / FUNCTION_ARG_ADVANCE\n-   to look directly at DECL_RESULT of the current function in conjunction\n-   with CUM to determine if the argument in question it is a struct value\n-   pointer, and if it is, pass it in memory.  */\n+   passed in memory.  */\n #define STRUCT_VALUE \\\n-  (TARGET_HITACHI \\\n-   ? gen_rtx_MEM (Pmode, arg_pointer_rtx) \\\n-   : gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM))\n+  (TARGET_HITACHI ? 0 : gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM))\n \n #define RETURN_IN_MEMORY(TYPE) \\\n   (TYPE_MODE (TYPE) == BLKmode \\\n@@ -969,6 +959,7 @@ extern enum reg_class reg_class_from_letter[];\n enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };\n struct sh_args {\n     int arg_count[2];\n+    int force_mem;\n };\n \n #define CUMULATIVE_ARGS  struct sh_args\n@@ -1003,12 +994,17 @@ struct sh_args {\n    For a library call, FNTYPE is 0.\n \n    On SH, the offset always starts at 0: the first parm reg is always\n-   the same reg for a given argument class.  */\n+   the same reg for a given argument class.\n+\n+   For TARGET_HITACHI, the structure value pointer is passed in memory.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n   do {\t\t\t\t\t\t\t\t\\\n     (CUM).arg_count[(int) SH_ARG_INT] = 0;\t\t\t\\\n     (CUM).arg_count[(int) SH_ARG_FLOAT] = 0;\t\t\t\\\n+    (CUM).force_mem\t\t\t\t\t\t\\\n+      = (TARGET_HITACHI && FNTYPE\t\t\t\t\\\n+\t && aggregate_value_p (TREE_TYPE (FNTYPE)));\t\t\\\n   } while (0)\n \n /* Update the data in CUM to advance over an argument\n@@ -1017,7 +1013,9 @@ struct sh_args {\n    available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n+ if ((CUM).force_mem)\t\t\t\t\t\\\n+   (CUM).force_mem = 0;\t\t\t\t\t\\\n+ else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n    ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\\\n     = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n        + ((MODE) == BLKmode\t\t\t\t\\\n@@ -1031,6 +1029,7 @@ struct sh_args {\n   (((TYPE) == 0 \\\n     || (! TREE_ADDRESSABLE ((tree)(TYPE)) \\\n \t&& (! TARGET_HITACHI || ! AGGREGATE_TYPE_P (TYPE)))) \\\n+   && ! (CUM).force_mem \\\n    && (TARGET_SH3E \\\n        ? ((MODE) == BLKmode \\\n \t  ? (((CUM).arg_count[(int) SH_ARG_INT] * UNITS_PER_WORD \\"}]}