{"sha": "2636fde4ba0c5819f06739c731f5a9176d5a65bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYzNmZkZTRiYTBjNTgxOWYwNjczOWM3MzFmNWE5MTc2ZDVhNjViZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-16T07:20:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-16T07:20:46Z"}, "message": "method.c (build_overload_value): Handle TEMPLATE_CONST_PARMs here.\n\n\t* method.c (build_overload_value): Handle TEMPLATE_CONST_PARMs here.\n\t(build_overload_int): Not here.\n\nWed Oct 15 00:35:28 1997  Mike Stump  <mrs@wrs.com>\n\n\t* class.c (build_type_pathname): Remove.\n\t(prepare_fresh_vtable): Fix problem with complex MI vtable names.\n\nFrom-SVN: r15928", "tree": {"sha": "57f6c60612e19f552c7ec3548903b470205eeb74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57f6c60612e19f552c7ec3548903b470205eeb74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2636fde4ba0c5819f06739c731f5a9176d5a65bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2636fde4ba0c5819f06739c731f5a9176d5a65bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2636fde4ba0c5819f06739c731f5a9176d5a65bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2636fde4ba0c5819f06739c731f5a9176d5a65bd/comments", "author": null, "committer": null, "parents": [{"sha": "96b63cd7a25592e0831692272568f2b0e63b5cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96b63cd7a25592e0831692272568f2b0e63b5cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96b63cd7a25592e0831692272568f2b0e63b5cc5"}], "stats": {"total": 177, "additions": 93, "deletions": 84}, "files": [{"sha": "a278b09edc3b6ccaa16ff0e70bd74f37d2156673", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2636fde4ba0c5819f06739c731f5a9176d5a65bd", "patch": "@@ -1,3 +1,13 @@\n+Thu Oct 16 00:14:48 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (build_overload_value): Handle TEMPLATE_CONST_PARMs here.\n+\t(build_overload_int): Not here.\n+\n+Wed Oct 15 00:35:28 1997  Mike Stump  <mrs@wrs.com>\n+\n+\t* class.c (build_type_pathname): Remove.\n+\t(prepare_fresh_vtable): Fix problem with complex MI vtable names.\n+\n 1997-10-14  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* parse.y (unary_expr): Give a pedwarn if someone tries to use the"}, {"sha": "e24d6a230b946cad77aeae9532c0b9e680e6d430", "filename": "gcc/cp/class.c", "status": "modified", "additions": 73, "deletions": 74, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2636fde4ba0c5819f06739c731f5a9176d5a65bd", "patch": "@@ -96,7 +96,6 @@ static tree get_derived_offset PROTO((tree, tree));\n static tree get_basefndecls PROTO((tree, tree));\n static void set_rtti_entry PROTO((tree, tree, tree));\n static tree build_vtable PROTO((tree, tree));\n-static tree build_type_pathname PROTO((char *, tree, tree));\n static void prepare_fresh_vtable PROTO((tree, tree));\n static void fixup_vtable_deltas1 PROTO((tree, tree));\n static void fixup_vtable_deltas PROTO((tree, int, tree));\n@@ -588,8 +587,8 @@ get_vtable_name (type)\n      tree type;\n {\n   tree type_id = build_typename_overload (type);\n-  char *buf = (char *)alloca (strlen (VTABLE_NAME_FORMAT)\n-\t\t\t      + IDENTIFIER_LENGTH (type_id) + 2);\n+  char *buf = (char *) alloca (strlen (VTABLE_NAME_FORMAT)\n+\t\t\t       + IDENTIFIER_LENGTH (type_id) + 2);\n   char *ptr = IDENTIFIER_POINTER (type_id);\n   int i;\n   for (i = 0; ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++) ;\n@@ -737,69 +736,6 @@ build_vtable (binfo, type)\n   return decl;\n }\n \n-/* Given a base type PARENT, and a derived type TYPE, build\n-   a name which distinguishes exactly the PARENT member of TYPE's type.\n-\n-   FORMAT is a string which controls how sprintf formats the name\n-   we have generated.\n-\n-   For example, given\n-\n-\tclass A; class B; class C : A, B;\n-\n-   it is possible to distinguish \"A\" from \"C's A\".  And given\n-\n-\tclass L;\n-\tclass A : L; class B : L; class C : A, B;\n-\n-   it is possible to distinguish \"L\" from \"A's L\", and also from\n-   \"C's L from A\".\n-\n-   Make sure to use the DECL_ASSEMBLER_NAME of the TYPE_NAME of the\n-   type, as template have DECL_NAMEs like: X<int>, whereas the\n-   DECL_ASSEMBLER_NAME is set to be something the assembler can handle.  */\n-\n-static tree\n-build_type_pathname (format, parent, type)\n-     char *format;\n-     tree parent, type;\n-{\n-  extern struct obstack temporary_obstack;\n-  char *first, *base, *name;\n-  int i;\n-  tree id;\n-\n-  parent = TYPE_MAIN_VARIANT (parent);\n-\n-  /* Remember where to cut the obstack to.  */\n-  first = obstack_base (&temporary_obstack);\n-\n-  /* Put on TYPE+PARENT.  */\n-  obstack_grow (&temporary_obstack,\n-\t\tTYPE_ASSEMBLER_NAME_STRING (type),\n-\t\tTYPE_ASSEMBLER_NAME_LENGTH (type));\n-#ifdef JOINER\n-  obstack_1grow (&temporary_obstack, JOINER);\n-#else\n-  obstack_1grow (&temporary_obstack, '_');\n-#endif\n-  obstack_grow0 (&temporary_obstack,\n-\t\t TYPE_ASSEMBLER_NAME_STRING (parent),\n-\t\t TYPE_ASSEMBLER_NAME_LENGTH (parent));\n-  i = obstack_object_size (&temporary_obstack);\n-  base = obstack_base (&temporary_obstack);\n-  obstack_finish (&temporary_obstack);\n-\n-  /* Put on FORMAT+TYPE+PARENT.  */\n-  obstack_blank (&temporary_obstack, strlen (format) + i + 1);\n-  name = obstack_base (&temporary_obstack);\n-  sprintf (name, format, base);\n-  id = get_identifier (name);\n-  obstack_free (&temporary_obstack, first);\n-\n-  return id;\n-}\n-\n extern tree signed_size_zero_node;\n \n /* Give TYPE a new virtual function table which is initialized\n@@ -810,20 +746,83 @@ extern tree signed_size_zero_node;\n    FOR_TYPE is the derived type which caused this table to\n    be needed.\n \n-   BINFO is the type association which provided TYPE for FOR_TYPE.  */\n+   BINFO is the type association which provided TYPE for FOR_TYPE.\n+\n+   The order in which vtables are built (by calling this function) for\n+   an object must remain the same, otherwise a binary incompatibility\n+   can result.  */\n \n static void\n prepare_fresh_vtable (binfo, for_type)\n      tree binfo, for_type;\n {\n-  tree basetype = BINFO_TYPE (binfo);\n+  tree basetype;\n   tree orig_decl = BINFO_VTABLE (binfo);\n-  /* This name is too simplistic.  We can have multiple basetypes for\n-     for_type, and we really want different names.  (mrs) */\n-  tree name = build_type_pathname (VTABLE_NAME_FORMAT, basetype, for_type);\n-  tree new_decl = build_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n+  tree name;\n+  tree new_decl;\n   tree offset;\n+  tree path = binfo;\n+  char *buf, *buf2;\n+  char joiner = '_';\n+  int i;\n+\n+#ifdef JOINER\n+  joiner = JOINER;\n+#endif\n+\n+  basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (binfo));\n+\n+  buf2 = TYPE_ASSEMBLER_NAME_STRING (basetype);\n+  i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1;\n+\n+  /* We know that the vtable that we are going to create doesn't exist\n+     yet in the global namespace, and when we finish, it will be\n+     pushed into the global namespace.  In complex MI hierarchies, we\n+     have to loop while the name we are thinking of adding is globally\n+     defined, adding more name components to the vtable name as we\n+     loop, until the name is unique.  This is because in complex MI\n+     cases, we might have the same base more than once.  This means\n+     that the order in which this function is called for vtables must\n+     remain the same, otherwise binary compatibility can be\n+     compromised.  */\n+\n+  while (1)\n+    {\n+      char *buf1 = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (for_type) + 1 + i);\n+      char *new_buf2;\n+\n+      sprintf (buf1, \"%s%c%s\", TYPE_ASSEMBLER_NAME_STRING (for_type), joiner,\n+\t       buf2);\n+      buf = (char *) alloca (strlen (VTABLE_NAME_FORMAT) + strlen (buf1) + 1);\n+      sprintf (buf, VTABLE_NAME_FORMAT, buf1);\n+      name = get_identifier (buf);\n+\n+      /* If this name doesn't clash, then we can use it, otherwise\n+\t we add more to the name until it is unique.  */\n+\n+      if (! IDENTIFIER_GLOBAL_VALUE (name))\n+\tbreak;\n+\n+      /* Set values for next loop through, if the name isn't unique.  */\n+\n+      path = BINFO_INHERITANCE_CHAIN (path);\n+\n+      /* We better not run out of stuff to make it unique.  */\n+      my_friendly_assert (path != NULL_TREE, 368);\n+\n+      basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (path));\n+\n+      /* We better not run out of stuff to make it unique.  */\n+      my_friendly_assert (for_type != basetype, 369);\n+\n+      i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1 + i;\n+      new_buf2 = (char *) alloca (i);\n+      sprintf (new_buf2, \"%s%c%s\",\n+\t       TYPE_ASSEMBLER_NAME_STRING (basetype), joiner, buf2);\n+      buf2 = new_buf2;\n+    }\n \n+  new_decl = build_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n   /* Remember which class this vtable is really for.  */\n   DECL_CONTEXT (new_decl) = for_type;\n \n@@ -5407,8 +5406,8 @@ get_vfield_name (type)\n     binfo = BINFO_BASETYPE (binfo, 0);\n \n   type = BINFO_TYPE (binfo);\n-  buf = (char *)alloca (sizeof (VFIELD_NAME_FORMAT)\n-\t\t\t+ TYPE_NAME_LENGTH (type) + 2);\n+  buf = (char *) alloca (sizeof (VFIELD_NAME_FORMAT)\n+\t\t\t + TYPE_NAME_LENGTH (type) + 2);\n   sprintf (buf, VFIELD_NAME_FORMAT, TYPE_NAME_STRING (type));\n   return get_identifier (buf);\n }"}, {"sha": "15f444bf8fd8f0f62e1d358e38391a4d738a9c49", "filename": "gcc/cp/method.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2636fde4ba0c5819f06739c731f5a9176d5a65bd", "patch": "@@ -435,15 +435,7 @@ build_overload_int (value, in_template)\n      tree value;\n      int in_template;\n {\n-  if (TREE_CODE (value) == TEMPLATE_CONST_PARM)\n-    {\n-      OB_PUTC ('Y');\n-      build_underscore_int (TEMPLATE_CONST_IDX (value));\n-      build_underscore_int (TEMPLATE_CONST_LEVEL (value));\n-      return;\n-    }\n-  else if (in_template\n-\t   && TREE_CODE (value) != INTEGER_CST)\n+  if (in_template && TREE_CODE (value) != INTEGER_CST)\n     /* We don't ever want this output, but it's inconvenient not to\n        be able to build the string.  This should cause assembler\n        errors we'll notice.  */\n@@ -487,6 +479,14 @@ build_overload_value (type, value, in_template)\n       numeric_output_need_bar = 0;\n     }\n \n+  if (TREE_CODE (value) == TEMPLATE_CONST_PARM)\n+    {\n+      OB_PUTC ('Y');\n+      build_underscore_int (TEMPLATE_CONST_IDX (value));\n+      build_underscore_int (TEMPLATE_CONST_LEVEL (value));\n+      return;\n+    }\n+\n   if (TREE_CODE (type) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n     {"}, {"sha": "d876e76806f66cc2562fd46535f77a9e18a1ddc5", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2636fde4ba0c5819f06739c731f5a9176d5a65bd/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=2636fde4ba0c5819f06739c731f5a9176d5a65bd", "patch": "@@ -301,7 +301,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 367.  Free: */\n+/* First used: 0 (reserved), Last used: 369.  Free: */\n \n static int abortcount = 0;\n "}]}