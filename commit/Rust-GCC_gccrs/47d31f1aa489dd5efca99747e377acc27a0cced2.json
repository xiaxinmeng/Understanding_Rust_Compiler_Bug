{"sha": "47d31f1aa489dd5efca99747e377acc27a0cced2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkMzFmMWFhNDg5ZGQ1ZWZjYTk5NzQ3ZTM3N2FjYzI3YTBjY2VkMg==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2018-10-11T21:31:32Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2018-10-11T21:31:32Z"}, "message": "fold-vec-insert-char-p8.c: New.\n\n[testsuite]\n\n2018-10-10  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\t* gcc.target/powerpc/fold-vec-insert-char-p8.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-char-p9.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-double.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-float-p8.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-float-p9.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-int-p8.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-int-p9.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-longlong.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-short-p8.c: New.\n\t* gcc.target/powerpc/fold-vec-insert-short-p9.c: New.\n\nFrom-SVN: r265067", "tree": {"sha": "9e1f73ca3fb1fe2e79d9edc100920c64858677bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e1f73ca3fb1fe2e79d9edc100920c64858677bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d31f1aa489dd5efca99747e377acc27a0cced2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d31f1aa489dd5efca99747e377acc27a0cced2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d31f1aa489dd5efca99747e377acc27a0cced2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d31f1aa489dd5efca99747e377acc27a0cced2/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c32917793e8ecf6c8ca77060b0cb0c985e66419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c32917793e8ecf6c8ca77060b0cb0c985e66419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c32917793e8ecf6c8ca77060b0cb0c985e66419"}], "stats": {"total": 557, "additions": 548, "deletions": 9}, "files": [{"sha": "edb680ec4a700972f956989e652467245feffb7e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -1,3 +1,16 @@\n+2018-10-11  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/fold-vec-insert-char-p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-char-p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-double.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-float-p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-float-p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-int-p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-int-p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-longlong.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-short-p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-insert-short-p9.c: New.\n+\n 2018-10-11  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-extract-char.p7.c: New.\n@@ -35,15 +48,6 @@\n \t* gcc.dg/sinatan-2.c: New test.\n \t* gcc.dg/sinatan-3.c: New test.\n \n-2018-10-11  Will Schmidt  <will_schmidt@vnet.ibm.com>\n-\n-\t* gcc.target/powerpc/fold-vec-select-char.c: New.\n-\t* gcc.target/powerpc/fold-vec-select-double.c: New.\n-\t* gcc.target/powerpc/fold-vec-select-float.c: New.\n-\t* gcc.target/powerpc/fold-vec-select-int.c: New.\n-\t* gcc.target/powerpc/fold-vec-select-longlong.c: New.\n-\t* gcc.target/powerpc/fold-vec-select-short.c: New.\n-\n 2018-10-11  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-mergeeo-floatdouble.c: New."}, {"sha": "8279bfe4eefbc0778b5fd2a5a5cf0bd7f28c64ad", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-char-p8.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-char-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-char-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-char-p8.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,59 @@\n+/* Verify that overloaded built-ins for vec_insert () with char\n+   inputs produce the right codegen.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+/* The below contains vec_insert () calls with both variable and constant\n+ values.  Only the constant value calls are early-gimple folded, but all\n+ are tested for coverage.  */\n+\n+#include <altivec.h>\n+\n+vector bool char testub_var (unsigned char x, vector bool char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector signed char testss_var (signed char x, vector signed char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector unsigned char testsu_var (signed char x, vector unsigned char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector unsigned char testuu_var (unsigned char x, vector unsigned char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector bool char testub_cst  (unsigned char x, vector bool char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+vector signed char testss_cst  (signed char x, vector signed char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+vector unsigned char testsu_cst (signed char x, vector unsigned char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+vector unsigned char testuu_cst (unsigned char x, vector unsigned char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+\n+/* one store per _var test */\n+/* { dg-final { scan-assembler-times {\\mstvx\\M|\\mstxvw4x\\M} 4 } } */\n+/* one store-byte per test */\n+/* { dg-final { scan-assembler-times {\\mstb\\M} 8 } } */\n+/* one load per test */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxvw4x\\M} 8 } } */\n+\n+/* one lvebx per _cst test.*/\n+/* { dg-final { scan-assembler-times {\\mlvebx\\M} 4 } } */\n+/* one vperm per _cst test.*/\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 4 } } */\n+"}, {"sha": "8604fa035b06897481804dc6a271f16cae960113", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-char-p9.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-char-p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-char-p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-char-p9.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,63 @@\n+/* Verify that overloaded built-ins for vec_insert () with char\n+   inputs produce the right codegen.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O2 -mcpu=power9\" } */\n+\n+/* The below contains vec_insert () calls with both variable and constant\n+ values.  Only the constant value calls are early-gimple folded, but all\n+ are tested for coverage.  */\n+\n+#include <altivec.h>\n+\n+vector bool char testub_var (unsigned char x, vector bool char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector signed char testss_var (signed char x, vector signed char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector unsigned char testsu_var (signed char x, vector unsigned char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector unsigned char testuu_var (unsigned char x, vector unsigned char v, signed int i)\n+{\n+       return vec_insert (x, v, i);\n+}\n+vector bool char testub_cst  (unsigned char x, vector bool char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+vector signed char testss_cst  (signed char x, vector signed char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+vector unsigned char testsu_cst (signed char x, vector unsigned char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+vector unsigned char testuu_cst (unsigned char x, vector unsigned char v)\n+{\n+       return vec_insert (x, v, 12);\n+}\n+\n+/* load immediate, add, store, stb, load variable test.  */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M|\\mstvx\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mstb\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mlvebx\\M|\\mlxv\\M|\\mlvx\\M} 4 { target lp64} } } */\n+/* an insert and a move per constant test. */\n+/* { dg-final { scan-assembler-times {\\mmtvsrwz\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mvinsertb\\M} 4 { target lp64 } } } */\n+\n+/* -m32 codegen. */\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M} 4 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 4 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M} 4 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mstb\\M} 8 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 8 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlvebx\\M} 4 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 4 { target ilp32 } } } */"}, {"sha": "435d28d5420c31a57d73355a1bf6ca9cbec2a948", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-double.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-double.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,29 @@\n+/* Verify that overloaded built-ins for vec_insert with \n+   double inputs produce the right codegen.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector double\n+testd_var (double d, vector double vd, signed int si)\n+{\n+  return vec_insert (d, vd, si);\n+}\n+\n+vector double\n+testd_cst (double d, vector double vd)\n+{\n+  return vec_insert (d, vd, 1);\n+}\n+/* The number of xxpermdi instructions varies between\n+ P7,P8,P9, ensure at least one hit. */\n+/* { dg-final { scan-assembler {\\mxxpermdi\\M} } } */\n+\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M|\\mstxv\\M|\\mstvx\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mstfdx\\M|\\mstfd\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mlxvd2x\\M|\\mlxv\\M|\\mlvx\\M} 1 } } */\n+"}, {"sha": "7544707f0c586ccae7fb8d0b8dbebdd86a3b3d49", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-float-p8.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-float-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-float-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-float-p8.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,31 @@\n+/* Verify that overloaded built-ins for vec_insert with float\n+   inputs produce the right codegen.  Power8 variant.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+vector float\n+testf_var (float f, vector float vf, signed int i)\n+{\n+  return vec_insert (f, vf, i);\n+}\n+\n+vector float\n+testf_cst (float f, vector float vf)\n+{\n+  return vec_insert (f, vf, 12);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mstvx\\M|\\mstxv\\M|\\mstxvd2x\\M} 1 } } */\n+/* cst tests has stfs instead of stfsx. */\n+/* { dg-final { scan-assembler-times {\\mstfs\\M|\\mstfsx\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxv\\M|\\mlxvd2x\\M|\\mlxvw4x\\M} 2 } } */\n+\n+/* cst test has a lvewx,vperm combo */\n+/* { dg-final { scan-assembler-times {\\mlvewx\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 1 } } */\n+"}, {"sha": "2b3a19aeec548dbcbb3152f81c99f2bfad6e1da6", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-float-p9.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-float-p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-float-p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-float-p9.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,35 @@\n+/* Verify that overloaded built-ins for vec_insert with float\n+   inputs produce the right codegen.  Power9 variant.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O2 -mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+vector float\n+testf_var (float f, vector float vf, signed int i)\n+{\n+  return vec_insert (f, vf, i);\n+}\n+\n+vector float\n+testf_cst (float f, vector float vf)\n+{\n+  return vec_insert (f, vf, 12);\n+}\n+\n+/* var test has a load and store. */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M|\\mlvx\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mstfsx\\M} 1 { target lp64} } } */\n+\n+/* cst test have a xscvdpspn,xxextractuw,xxinsertw combo */\n+/* { dg-final { scan-assembler-times {\\mxscvdpspn\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxextractuw\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxinsertw\\M} 1 { target lp64 } } } */\n+\n+/* { dg-final { scan-assembler-times {\\mstfs\\M} 2 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 2 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlvewx\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 1 { target ilp32 } } } */"}, {"sha": "4bac5bb2739c02b5e0421b385c65ec43577d88dc", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-int-p8.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-int-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-int-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-int-p8.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,58 @@\n+/* Verify that overloaded built-ins for vec_insert() with int\n+   inputs produce the right codegen.  Power8 variant.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+vector bool int\n+testbi_var(unsigned int x, vector bool int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector signed int\n+testsi_var(signed int x, vector signed int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned int\n+testui1_var(signed int x, vector unsigned int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned int\n+testui2_var(unsigned int x, vector unsigned int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector bool int\n+testbi_cst(unsigned int x, vector bool int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector signed int\n+testsi_cst(signed int x, vector signed int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned int\n+testui1_cst(signed int x, vector unsigned int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned int\n+testui2_cst(unsigned int x, vector unsigned int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+/* Each test has lvx (8).  cst tests have additional lvewx. (4) */\n+/* var tests have both stwx (4) and stvx (4).  cst tests have stw (4).*/\n+/* { dg-final { scan-assembler-times {\\mstvx\\M|\\mstwx\\M|\\mstw\\M|\\mstxvw4x\\M} 12 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxvw4x\\M} 8 } } */\n+\n+/* { dg-final { scan-assembler-times {\\mlvewx\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 4 } } */"}, {"sha": "3f14ad296363bc8d37d987c1750ec54af9e69e0d", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-int-p9.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-int-p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-int-p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-int-p9.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,67 @@\n+/* Verify that overloaded built-ins for vec_insert() with int\n+   inputs produce the right codegen.  Power9 variant.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O2 -mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+vector bool int\n+testbi_var(unsigned int x, vector bool int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector signed int\n+testsi_var(signed int x, vector signed int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned int\n+testui1_var(signed int x, vector unsigned int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned int\n+testui2_var(unsigned int x, vector unsigned int v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector bool int\n+testbi_cst(unsigned int x, vector bool int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector signed int\n+testsi_cst(signed int x, vector signed int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned int\n+testui1_cst(signed int x, vector unsigned int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned int\n+testui2_cst(unsigned int x, vector unsigned int v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+\n+/* load immediate, add, store, stb, load variable test.  */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M|\\mstvx\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mstwx\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M|\\mlvx\\M} 4 { target lp64 } } } */\n+\n+/* an insert and a move per constant test. */\n+/* { dg-final { scan-assembler-times {\\mmtvsrwz\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxinsertw\\M} 4 { target lp64 } } } */\n+\n+\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 12 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mstw\\M} 8 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M} 8 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlvewx\\M} 4 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 4 { target ilp32 } } } */"}, {"sha": "dd346241847d72e8fdde71b318b739604e074bfc", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-longlong.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-longlong.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,73 @@\n+/* Verify that overloaded built-ins for vec_insert() with long long\n+   inputs produce the right codegen.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+vector bool long long\n+testbl_var(unsigned long long x, vector bool long long v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+\n+vector signed long long\n+testsl_var(signed long long x, vector signed long long v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+\n+vector unsigned long long\n+testul1_var(signed long long x, vector unsigned long long v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+\n+vector unsigned long long\n+testul2_var(unsigned long long x, vector unsigned long long v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+\n+vector bool long long\n+testbl_cst(unsigned long long x, vector bool long long v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+vector signed long long\n+testsl_cst(signed long long x, vector signed long long v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+vector unsigned long long\n+testul1_cst(signed long long x, vector unsigned long long v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+vector unsigned long long\n+testul2_cst(unsigned long long x, vector unsigned long long v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+/* Number of xxpermdi insns varies between power targets.  ensure at least one. */\n+/* { dg-final { scan-assembler {\\mxxpermdi\\M} } } */\n+\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 4 } } */\n+\n+/* The number of addi instructions decreases on newer systems.  Measured as 8 on\n+ power7 and power8 targets, and drops to 4 on power9 targets that use the\n+ newer stxv,lxv instructions.  For this test ensure we get at least one.  */\n+/* { dg-final { scan-assembler {\\maddi\\M} } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M|\\mstvx\\M|\\mstxv\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mstdx\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mstw\\M} 8 { target ilp32 } } } */\n+\n+/* { dg-final { scan-assembler-times {\\mlxvd2x\\M|\\mlxv\\M|\\mlvx\\M} 4 } } */\n+"}, {"sha": "3da05cfad47fcf0823e9cb7b7934703c5bc2fdcc", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-short-p8.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-short-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-short-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-short-p8.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,58 @@\n+/* Verify that overloaded built-ins for vec_insert() with short\n+   inputs produce the right codegen.  Power8 variant.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+vector bool short\n+testbs_var(unsigned short x, vector bool short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector signed short\n+testss_var(signed short x, vector signed short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned short\n+testus1_var(signed short x, vector unsigned short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned short\n+testus2_var(unsigned short x, vector unsigned short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector bool short\n+testbs_cst(signed short x, vector bool short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector signed short\n+testss_cst(signed short x, vector signed short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned short\n+testus1_cst(signed short x, vector unsigned short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned short\n+testus2_cst(unsigned short x, vector unsigned short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mlhz\\M|\\mlvx\\M|\\mlxv\\M|\\mlxvw4x\\M} 8 } } */\n+/* stores.. 2 each per variable tests, 1 each per cst test. */\n+/* { dg-final { scan-assembler-times {\\msthx\\M|\\mstvx\\M|\\msth\\M|\\mstxvw4x\\M} 12 } } */\n+\n+/* { dg-final { scan-assembler-times {\\mlvehx\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mvperm\\M} 4 } } */\n+"}, {"sha": "8da46aa4b27d04b0e4fd3989a26d5a260eacbec0", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-insert-short-p9.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-short-p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d31f1aa489dd5efca99747e377acc27a0cced2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-short-p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-insert-short-p9.c?ref=47d31f1aa489dd5efca99747e377acc27a0cced2", "patch": "@@ -0,0 +1,62 @@\n+/* Verify that overloaded built-ins for vec_insert() with short\n+   inputs produce the right codegen.  Power9 variant.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O2 -mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+vector bool short\n+testbs_var(unsigned short x, vector bool short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector signed short\n+testss_var(signed short x, vector signed short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned short\n+testus1_var(signed short x, vector unsigned short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector unsigned short\n+testus2_var(unsigned short x, vector unsigned short v, signed int i)\n+{\n+   return vec_insert(x, v, i);\n+}\n+vector bool short\n+testbs_cst(signed short x, vector bool short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector signed short\n+testss_cst(signed short x, vector signed short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned short\n+testus1_cst(signed short x, vector unsigned short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+vector unsigned short\n+testus2_cst(unsigned short x, vector unsigned short v)\n+{\n+   return vec_insert(x, v, 12);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mmtvsrwz\\M} 4 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mvinserth\\M} 4 { target lp64 } } } */\n+\n+/* { dg-final { scan-assembler-times {\\mstxv\\M|\\mstvx\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M|\\mlvx\\M} 4 { target lp64 }} } */\n+\n+/* -m32 uses sth/lvehx as part of the sequence. */\n+/* { dg-final { scan-assembler-times {\\msth\\M} 8 { target ilp32 }} } */\n+/* { dg-final { scan-assembler-times {\\mlvehx\\M} 4 { target ilp32 }} } */\n+/* { dg-final { scan-assembler-times {\\mlxv\\M|\\mlvx\\M} 8 { target ilp32 }} } */\n+"}]}