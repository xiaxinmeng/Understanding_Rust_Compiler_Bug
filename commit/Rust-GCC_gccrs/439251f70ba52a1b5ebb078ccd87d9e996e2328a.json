{"sha": "439251f70ba52a1b5ebb078ccd87d9e996e2328a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5MjUxZjcwYmE1MmExYjVlYmIwNzhjY2Q4N2Q5ZTk5NmUyMzI4YQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-29T21:22:18Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-29T21:22:18Z"}, "message": "Revert previous accidental commit.\n\nFrom-SVN: r83875", "tree": {"sha": "9f9208e2e36459be4ab63eec75b266de54c37221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9208e2e36459be4ab63eec75b266de54c37221"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/439251f70ba52a1b5ebb078ccd87d9e996e2328a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/439251f70ba52a1b5ebb078ccd87d9e996e2328a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/439251f70ba52a1b5ebb078ccd87d9e996e2328a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/439251f70ba52a1b5ebb078ccd87d9e996e2328a/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc9b4531337a13e969472e6a53187b36b73c4aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc9b4531337a13e969472e6a53187b36b73c4aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc9b4531337a13e969472e6a53187b36b73c4aa"}], "stats": {"total": 427, "additions": 209, "deletions": 218}, "files": [{"sha": "fab762fc63e59aff5a354e6810012b471b98630b", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 8, "deletions": 215, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/439251f70ba52a1b5ebb078ccd87d9e996e2328a/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/439251f70ba52a1b5ebb078ccd87d9e996e2328a/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=439251f70ba52a1b5ebb078ccd87d9e996e2328a", "patch": "@@ -874,12 +874,12 @@ match_char_spec (gfc_typespec * ts)\n    to the matched specification.  This is necessary for FUNCTION and\n    IMPLICIT statements.\n \n-   If implicit_flag is nonzero, then we don't check for the optional \n-   kind specification.  Not doing so is needed for matching an IMPLICIT\n+   If kind_flag is nonzero, then we check for the optional kind\n+   specification.  Not doing so is needed for matching an IMPLICIT\n    statement correctly.  */\n \n-static match\n-match_type_spec (gfc_typespec * ts, int implicit_flag)\n+match\n+gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -898,10 +898,7 @@ match_type_spec (gfc_typespec * ts, int implicit_flag)\n   if (gfc_match (\" character\") == MATCH_YES)\n     {\n       ts->type = BT_CHARACTER;\n-      if (implicit_flag == 0)\n-\treturn match_char_spec (ts);\n-      else\n-\treturn MATCH_YES;\n+      return match_char_spec (ts);\n     }\n \n   if (gfc_match (\" real\") == MATCH_YES)\n@@ -963,7 +960,7 @@ match_type_spec (gfc_typespec * ts, int implicit_flag)\n get_kind:\n   /* For all types except double, derived and character, look for an\n      optional kind specifier.  MATCH_NO is actually OK at this point.  */\n-  if (implicit_flag == 1)\n+  if (kind_flag == 0)\n     return MATCH_YES;\n \n   if (gfc_current_form == FORM_FREE)\n@@ -985,210 +982,6 @@ match_type_spec (gfc_typespec * ts, int implicit_flag)\n }\n \n \n-/* Match an IMPLICIT NONE statement.  Actually, this statement is\n-   already matched in parse.c, or we would not end up here in the\n-   first place.  So the only thing we need to check, is if there is\n-   trailing garbage.  If not, the match is successful.  */\n-\n-match\n-gfc_match_implicit_none (void)\n-{\n-\n-  return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n-}\n-\n-\n-/* Match the letter range(s) of an IMPLICIT statement.  */\n-\n-static match\n-match_implicit_range (gfc_typespec * ts)\n-{\n-  int c, c1, c2, inner;\n-  locus cur_loc;\n-\n-  cur_loc = gfc_current_locus;\n-\n-  gfc_gobble_whitespace ();\n-  c = gfc_next_char ();\n-  if (c != '(')\n-    {\n-      gfc_error (\"Missing character range in IMPLICIT at %C\");\n-      goto bad;\n-    }\n-\n-  inner = 1;\n-  while (inner)\n-    {\n-      gfc_gobble_whitespace ();\n-      c1 = gfc_next_char ();\n-      if (!ISALPHA (c1))\n-\tgoto bad;\n-\n-      gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n-\n-      switch (c)\n-\t{\n-\tcase ')':\n-\t  inner = 0;\t\t/* Fall through */\n-\n-\tcase ',':\n-\t  c2 = c1;\n-\t  break;\n-\n-\tcase '-':\n-\t  gfc_gobble_whitespace ();\n-\t  c2 = gfc_next_char ();\n-\t  if (!ISALPHA (c2))\n-\t    goto bad;\n-\n-\t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n-\n-\t  if ((c != ',') && (c != ')'))\n-\t    goto bad;\n-\t  if (c == ')')\n-\t    inner = 0;\n-\n-\t  break;\n-\n-\tdefault:\n-\t  goto bad;\n-\t}\n-\n-      if (c1 > c2)\n-\t{\n-\t  gfc_error (\"Letters must be in alphabetic order in \"\n-\t\t     \"IMPLICIT statement at %C\");\n-\t  goto bad;\n-\t}\n-\n-      /* See if we can add the newly matched range to the pending\n-         implicits from this IMPLICIT statement.  We do not check for\n-         conflicts with whatever earlier IMPLICIT statements may have\n-         set.  This is done when we've successfully finished matching\n-         the current one.  */\n-      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n-\tgoto bad;\n-    }\n-\n-  return MATCH_YES;\n-\n-bad:\n-  gfc_syntax_error (ST_IMPLICIT);\n-\n-  gfc_current_locus = cur_loc;\n-  return MATCH_ERROR;\n-}\n-\n-\n-/* Match an IMPLICIT statement, storing the types for\n-   gfc_set_implicit() if the statement is accepted by the parser.\n-   There is a strange looking, but legal syntactic construction\n-   possible.  It looks like:\n-\n-     IMPLICIT INTEGER (a-b) (c-d)\n-\n-   This is legal if \"a-b\" is a constant expression that happens to\n-   equal one of the legal kinds for integers.  The real problem\n-   happens with an implicit specification that looks like:\n-\n-     IMPLICIT INTEGER (a-b)\n-\n-   In this case, a typespec matcher that is \"greedy\" (as most of the\n-   matchers are) gobbles the character range as a kindspec, leaving\n-   nothing left.  We therefore have to go a bit more slowly in the\n-   matching process by inhibiting the kindspec checking during\n-   typespec matching and checking for a kind later.  */\n-\n-match\n-gfc_match_implicit (void)\n-{\n-  gfc_typespec ts;\n-  locus cur_loc;\n-  int c;\n-  match m;\n-\n-  /* We don't allow empty implicit statements.  */\n-  if (gfc_match_eos () == MATCH_YES)\n-    {\n-      gfc_error (\"Empty IMPLICIT statement at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  /* First cleanup.  */\n-  gfc_clear_new_implicit ();\n-\n-  do\n-    {\n-      /* A basic type is mandatory here.  */\n-      m = match_type_spec (&ts, 1);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      cur_loc = gfc_current_locus;\n-      m = match_implicit_range (&ts);\n-\n-      if (m != MATCH_YES && ts.type == BT_CHARACTER)\n-\t{\n-\t  /* looks like we are matching CHARACTER (<len>) (<range>)  */\n-\t  m = match_char_spec (&ts);\n-\t}\t  \n-\n-      if (m == MATCH_YES)\n-\t{\n-\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n-\t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n-\t  if ((c == '\\n') || (c == ','))\n-\t    continue;\n-\n-\t  gfc_current_locus = cur_loc;\n-\t}\n-\n-      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n-      m = gfc_match_kind_spec (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\t{\n-\t  m = gfc_match_old_kind_spec (&ts);\n-\t  if (m == MATCH_ERROR)\n-\t    goto error;\n-\t  if (m == MATCH_NO)\n-\t    goto syntax;\n-\t}\n-\n-      m = match_implicit_range (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n-      if ((c != '\\n') && (c != ','))\n-\tgoto syntax;\n-\n-    }\n-  while (c == ',');\n-\n-  /* All we need to now is try to merge the new implicit types back\n-     into the existing types.  This will fail if another implicit\n-     type is already defined for a letter.  */\n-  return (gfc_merge_new_implicit () == SUCCESS) ?\n-      MATCH_YES : MATCH_ERROR;\n-\n-syntax:\n-  gfc_syntax_error (ST_IMPLICIT);\n-\n-error:\n-  return MATCH_ERROR;\n-}\n-\n-\n /* Matches an attribute specification including array specs.  If\n    successful, leaves the variables current_attr and current_as\n    holding the specification.  Also sets the colon_seen variable for\n@@ -1449,7 +1242,7 @@ gfc_match_data_decl (void)\n   gfc_symbol *sym;\n   match m;\n \n-  m = match_type_spec (&current_ts, 0);\n+  m = gfc_match_type_spec (&current_ts, 1);\n   if (m != MATCH_YES)\n     return m;\n \n@@ -1539,7 +1332,7 @@ match_prefix (gfc_typespec * ts)\n \n loop:\n   if (!seen_type && ts != NULL\n-      && match_type_spec (ts, 0) == MATCH_YES\n+      && gfc_match_type_spec (ts, 1) == MATCH_YES\n       && gfc_match_space () == MATCH_YES)\n     {\n "}, {"sha": "d605361ec0377c035a9c3c0ef287e3fba250a4d0", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/439251f70ba52a1b5ebb078ccd87d9e996e2328a/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/439251f70ba52a1b5ebb078ccd87d9e996e2328a/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=439251f70ba52a1b5ebb078ccd87d9e996e2328a", "patch": "@@ -2048,6 +2048,204 @@ gfc_match_call (void)\n }\n \n \n+/* Match an IMPLICIT NONE statement.  Actually, this statement is\n+   already matched in parse.c, or we would not end up here in the\n+   first place.  So the only thing we need to check, is if there is\n+   trailing garbage.  If not, the match is successful.  */\n+\n+match\n+gfc_match_implicit_none (void)\n+{\n+\n+  return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n+}\n+\n+\n+/* Match the letter range(s) of an IMPLICIT statement.  */\n+\n+static match\n+match_implicit_range (gfc_typespec * ts)\n+{\n+  int c, c1, c2, inner;\n+  locus cur_loc;\n+\n+  cur_loc = gfc_current_locus;\n+\n+  gfc_gobble_whitespace ();\n+  c = gfc_next_char ();\n+  if (c != '(')\n+    {\n+      gfc_error (\"Missing character range in IMPLICIT at %C\");\n+      goto bad;\n+    }\n+\n+  inner = 1;\n+  while (inner)\n+    {\n+      gfc_gobble_whitespace ();\n+      c1 = gfc_next_char ();\n+      if (!ISALPHA (c1))\n+\tgoto bad;\n+\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+\n+      switch (c)\n+\t{\n+\tcase ')':\n+\t  inner = 0;\t\t/* Fall through */\n+\n+\tcase ',':\n+\t  c2 = c1;\n+\t  break;\n+\n+\tcase '-':\n+\t  gfc_gobble_whitespace ();\n+\t  c2 = gfc_next_char ();\n+\t  if (!ISALPHA (c2))\n+\t    goto bad;\n+\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\n+\t  if ((c != ',') && (c != ')'))\n+\t    goto bad;\n+\t  if (c == ')')\n+\t    inner = 0;\n+\n+\t  break;\n+\n+\tdefault:\n+\t  goto bad;\n+\t}\n+\n+      if (c1 > c2)\n+\t{\n+\t  gfc_error (\"Letters must be in alphabetic order in \"\n+\t\t     \"IMPLICIT statement at %C\");\n+\t  goto bad;\n+\t}\n+\n+      /* See if we can add the newly matched range to the pending\n+         implicits from this IMPLICIT statement.  We do not check for\n+         conflicts with whatever earlier IMPLICIT statements may have\n+         set.  This is done when we've successfully finished matching\n+         the current one.  */\n+      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n+\tgoto bad;\n+    }\n+\n+  return MATCH_YES;\n+\n+bad:\n+  gfc_syntax_error (ST_IMPLICIT);\n+\n+  gfc_current_locus = cur_loc;\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match an IMPLICIT statement, storing the types for\n+   gfc_set_implicit() if the statement is accepted by the parser.\n+   There is a strange looking, but legal syntactic construction\n+   possible.  It looks like:\n+\n+     IMPLICIT INTEGER (a-b) (c-d)\n+\n+   This is legal if \"a-b\" is a constant expression that happens to\n+   equal one of the legal kinds for integers.  The real problem\n+   happens with an implicit specification that looks like:\n+\n+     IMPLICIT INTEGER (a-b)\n+\n+   In this case, a typespec matcher that is \"greedy\" (as most of the\n+   matchers are) gobbles the character range as a kindspec, leaving\n+   nothing left.  We therefore have to go a bit more slowly in the\n+   matching process by inhibiting the kindspec checking during\n+   typespec matching and checking for a kind later.  */\n+\n+match\n+gfc_match_implicit (void)\n+{\n+  gfc_typespec ts;\n+  locus cur_loc;\n+  int c;\n+  match m;\n+\n+  /* We don't allow empty implicit statements.  */\n+  if (gfc_match_eos () == MATCH_YES)\n+    {\n+      gfc_error (\"Empty IMPLICIT statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* First cleanup.  */\n+  gfc_clear_new_implicit ();\n+\n+  do\n+    {\n+      /* A basic type is mandatory here.  */\n+      m = gfc_match_type_spec (&ts, 0);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      cur_loc = gfc_current_locus;\n+      m = match_implicit_range (&ts);\n+\n+      if (m == MATCH_YES)\n+\t{\n+\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\t  if ((c == '\\n') || (c == ','))\n+\t    continue;\n+\n+\t  gfc_current_locus = cur_loc;\n+\t}\n+\n+      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n+      m = gfc_match_kind_spec (&ts);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\t{\n+\t  m = gfc_match_old_kind_spec (&ts);\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_NO)\n+\t    goto syntax;\n+\t}\n+\n+      m = match_implicit_range (&ts);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+      if ((c != '\\n') && (c != ','))\n+\tgoto syntax;\n+\n+    }\n+  while (c == ',');\n+\n+  /* All we need to now is try to merge the new implicit types back\n+     into the existing types.  This will fail if another implicit\n+     type is already defined for a letter.  */\n+  return (gfc_merge_new_implicit () == SUCCESS) ?\n+      MATCH_YES : MATCH_ERROR;\n+\n+syntax:\n+  gfc_syntax_error (ST_IMPLICIT);\n+\n+error:\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Given a name, return a pointer to the common head structure,\n    creating it if it does not exist.\n    TODO: Add to global symbol tree.  */"}, {"sha": "85729ec0ae834a1ae855145fc0602a95997d40e2", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/439251f70ba52a1b5ebb078ccd87d9e996e2328a/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/439251f70ba52a1b5ebb078ccd87d9e996e2328a/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=439251f70ba52a1b5ebb078ccd87d9e996e2328a", "patch": "@@ -75,6 +75,8 @@ match gfc_match_deallocate (void);\n match gfc_match_return (void);\n match gfc_match_call (void);\n match gfc_match_common (void);\n+match gfc_match_implicit_none (void);\n+match gfc_match_implicit (void);\n match gfc_match_block_data (void);\n match gfc_match_namelist (void);\n match gfc_match_module (void);\n@@ -96,6 +98,7 @@ gfc_common_head *gfc_get_common (char *);\n match gfc_match_null (gfc_expr **);\n match gfc_match_kind_spec (gfc_typespec *);\n match gfc_match_old_kind_spec (gfc_typespec *);\n+match gfc_match_type_spec (gfc_typespec *, int);\n \n match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);\n@@ -105,9 +108,6 @@ match gfc_match_entry (void);\n match gfc_match_subroutine (void);\n match gfc_match_derived_decl (void);\n \n-match gfc_match_implicit_none (void);\n-match gfc_match_implicit (void);\n-\n /* Matchers for attribute declarations */\n match gfc_match_allocatable (void);\n match gfc_match_dimension (void);"}]}