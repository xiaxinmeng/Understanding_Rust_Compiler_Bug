{"sha": "0e228dd9078e5482b605b0d778347a77e4b69152", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUyMjhkZDkwNzhlNTQ4MmI2MDViMGQ3NzgzNDdhNzdlNGI2OTE1Mg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-06-29T12:21:37Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-06-29T12:21:37Z"}, "message": "gigi.h (gnat_build_constructor): Take a VEC instead of a TREE_LIST.\n\n\t* gcc-interface/gigi.h (gnat_build_constructor): Take a VEC instead\n\tof a TREE_LIST.  Update comment.\n\t* gcc-interface/trans.c (gigi): Build a VEC instead of a TREE_LIST.\n\tAdjust call to gnat_build_constructor.\n\t(Attribute_to_gnu): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(pos_to_constructor): Likewise.\n\t(extract_values): Likewise.\n\t* gcc-interface/utils.c (build_template): Likewise.\n\t(convert_vms_descriptor64): Likewise.\n\t(convert_vms_descriptor32): Likewise.\n\t(convert_to_fat_pointer): Likewise.\n\t(convert): Likewise.\n\t(unchecked_convert): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Likewise.\n\t* gcc-interface/utils2.c (build_allocator): Likewise.\n\t(fill_vms_descriptor): Likewise.\n\t(gnat_build_constructor): Take a VEC instead of a TREE_LIST.\n\t(compare_elmt_bitpos): Adjust for parameters being constructor_elts\n\tinstead of TREE_LISTs.\n\nFrom-SVN: r161529", "tree": {"sha": "0833ec6be792c53dfbf123fe804e1cfe6e39e253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0833ec6be792c53dfbf123fe804e1cfe6e39e253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e228dd9078e5482b605b0d778347a77e4b69152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e228dd9078e5482b605b0d778347a77e4b69152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e228dd9078e5482b605b0d778347a77e4b69152", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e228dd9078e5482b605b0d778347a77e4b69152/comments", "author": null, "committer": null, "parents": [{"sha": "079e7538c0259b82dc4fd0b71c05ef918725a321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079e7538c0259b82dc4fd0b71c05ef918725a321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079e7538c0259b82dc4fd0b71c05ef918725a321"}], "stats": {"total": 318, "additions": 169, "deletions": 149}, "files": [{"sha": "03ea684e8c846fcdd22cba114842babfc0bcdc35", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0e228dd9078e5482b605b0d778347a77e4b69152", "patch": "@@ -1,3 +1,26 @@\n+2010-06-29  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/gigi.h (gnat_build_constructor): Take a VEC instead\n+\tof a TREE_LIST.  Update comment.\n+\t* gcc-interface/trans.c (gigi): Build a VEC instead of a TREE_LIST.\n+\tAdjust call to gnat_build_constructor.\n+\t(Attribute_to_gnu): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(pos_to_constructor): Likewise.\n+\t(extract_values): Likewise.\n+\t* gcc-interface/utils.c (build_template): Likewise.\n+\t(convert_vms_descriptor64): Likewise.\n+\t(convert_vms_descriptor32): Likewise.\n+\t(convert_to_fat_pointer): Likewise.\n+\t(convert): Likewise.\n+\t(unchecked_convert): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Likewise.\n+\t* gcc-interface/utils2.c (build_allocator): Likewise.\n+\t(fill_vms_descriptor): Likewise.\n+\t(gnat_build_constructor): Take a VEC instead of a TREE_LIST.\n+\t(compare_elmt_bitpos): Adjust for parameters being constructor_elts\n+\tinstead of TREE_LISTs.\n+\n 2010-06-28  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gcc-interface/misc.c: Do not include except.h."}, {"sha": "6952060259d0bc20893d2401353cc46dcf57b5ee", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0e228dd9078e5482b605b0d778347a77e4b69152", "patch": "@@ -1047,15 +1047,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = TYPE_PADDING_P (gnu_type)\n \t\t? TYPE_FIELDS (TREE_TYPE (TYPE_FIELDS (gnu_type)))\n \t\t: TYPE_FIELDS (gnu_type);\n-\t    gnu_expr\n-\t      = gnat_build_constructor\n-\t\t(gnu_type,\n-\t\t tree_cons\n-\t\t (template_field,\n-\t\t  build_template (TREE_TYPE (template_field),\n-\t\t\t\t  TREE_TYPE (TREE_CHAIN (template_field)),\n-\t\t\t\t  NULL_TREE),\n-\t\t  NULL_TREE));\n+\t    VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n+\t    tree t = build_template (TREE_TYPE (template_field),\n+\t\t\t\t     TREE_TYPE (TREE_CHAIN (template_field)),\n+\t\t\t\t     NULL_TREE);\n+\t    CONSTRUCTOR_APPEND_ELT (v, template_field, t);\n+\t    gnu_expr = gnat_build_constructor (gnu_type, v);\n \t  }\n \n \t/* Convert the expression to the type of the object except in the"}, {"sha": "767700f6f76a2d2eb44a6b527df39873343379df", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=0e228dd9078e5482b605b0d778347a77e4b69152", "patch": "@@ -785,9 +785,9 @@ extern tree build_call_0_expr (tree fundecl);\n     (N_Raise_{Constraint,Storage,Program}_Error).  */\n extern tree build_call_raise (int msg, Node_Id gnat_node, char kind);\n \n-/* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n+/* Return a CONSTRUCTOR of TYPE whose elements are V.  This is not the\n    same as build_constructor in the language-independent tree.c.  */\n-extern tree gnat_build_constructor (tree type, tree list);\n+extern tree gnat_build_constructor (tree type, VEC(constructor_elt,gc) *v);\n \n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,"}, {"sha": "c62e7e632c8488bce0e671dbc5e3d010e005dbf2", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=0e228dd9078e5482b605b0d778347a77e4b69152", "patch": "@@ -545,10 +545,16 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     {\n       tree null_node = fold_convert (ptr_void_ftype, null_pointer_node);\n-      tree field_list = NULL_TREE, null_list = NULL_TREE;\n+      tree field_list = NULL_TREE;\n       int j;\n+      VEC(constructor_elt,gc) *null_vec = NULL;\n+      constructor_elt *elt;\n \n       fdesc_type_node = make_node (RECORD_TYPE);\n+      VEC_safe_grow (constructor_elt, gc, null_vec,\n+\t\t     TARGET_VTABLE_USES_DESCRIPTORS);\n+      elt = (VEC_address (constructor_elt,null_vec)\n+\t     + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n \n       for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; j++)\n \t{\n@@ -557,12 +563,14 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t\t\t\t NULL_TREE, NULL_TREE, 0, 1);\n \t  TREE_CHAIN (field) = field_list;\n \t  field_list = field;\n-\t  null_list = tree_cons (field, null_node, null_list);\n+\t  elt->index = field;\n+\t  elt->value = null_node;\n+\t  elt--;\n \t}\n \n       finish_record_type (fdesc_type_node, nreverse (field_list), 0, false);\n       record_builtin_type (\"descriptor\", fdesc_type_node);\n-      null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_list);\n+      null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_vec);\n     }\n \n   long_long_float_type\n@@ -1231,10 +1239,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       else if (TARGET_VTABLE_USES_DESCRIPTORS\n \t       && Is_Dispatch_Table_Entity (Etype (gnat_node)))\n \t{\n-\t  tree gnu_field, gnu_list = NULL_TREE, t;\n+\t  tree gnu_field, t;\n \t  /* Descriptors can only be built here for top-level functions.  */\n \t  bool build_descriptor = (global_bindings_p () != 0);\n \t  int i;\n+\t  VEC(constructor_elt,gc) *gnu_vec = NULL;\n+\t  constructor_elt *elt;\n \n \t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n@@ -1249,6 +1259,10 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t      gnu_result = build1 (INDIRECT_REF, gnu_result_type, gnu_result);\n \t    }\n \n+\t  VEC_safe_grow (constructor_elt, gc, gnu_vec,\n+\t\t\t TARGET_VTABLE_USES_DESCRIPTORS);\n+\t  elt = (VEC_address (constructor_elt, gnu_vec)\n+\t\t + TARGET_VTABLE_USES_DESCRIPTORS - 1);\n \t  for (gnu_field = TYPE_FIELDS (gnu_result_type), i = 0;\n \t       i < TARGET_VTABLE_USES_DESCRIPTORS;\n \t       gnu_field = TREE_CHAIN (gnu_field), i++)\n@@ -1263,10 +1277,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\tt = build3 (COMPONENT_REF, ptr_void_ftype, gnu_result,\n \t\t\t    gnu_field, NULL_TREE);\n \n-\t      gnu_list = tree_cons (gnu_field, t, gnu_list);\n+\t      elt->index = gnu_field;\n+\t      elt->value = t;\n+\t      elt--;\n \t    }\n \n-\t  gnu_result = gnat_build_constructor (gnu_result_type, gnu_list);\n+\t  gnu_result = gnat_build_constructor (gnu_result_type, gnu_vec);\n \t  break;\n \t}\n \n@@ -3912,24 +3928,21 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  String_Id gnat_string = Strval (gnat_node);\n \t  int length = String_Length (gnat_string);\n \t  int i;\n-\t  tree gnu_list = NULL_TREE;\n \t  tree gnu_idx = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n+\t  VEC(constructor_elt,gc) *gnu_vec\n+\t    = VEC_alloc (constructor_elt, gc, length);\n \n \t  for (i = 0; i < length; i++)\n \t    {\n-\t      gnu_list\n-\t\t= tree_cons (gnu_idx,\n-\t\t\t     build_int_cst (TREE_TYPE (gnu_result_type),\n-\t\t\t\t\t    Get_String_Char (gnat_string,\n-\t\t\t\t\t\t\t     i + 1)),\n-\t\t\t     gnu_list);\n+\t      tree t = build_int_cst (TREE_TYPE (gnu_result_type),\n+\t\t\t\t      Get_String_Char (gnat_string, i + 1));\n \n+\t      CONSTRUCTOR_APPEND_ELT (gnu_vec, gnu_idx, t);\n \t      gnu_idx = int_const_binop (PLUS_EXPR, gnu_idx, integer_one_node,\n \t\t\t\t\t 0);\n \t    }\n \n-\t  gnu_result\n-\t    = gnat_build_constructor (gnu_result_type, nreverse (gnu_list));\n+\t  gnu_result = gnat_build_constructor (gnu_result_type, gnu_vec);\n \t}\n       break;\n \n@@ -4317,7 +4330,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_aggr_type = TYPE_REPRESENTATIVE_ARRAY (gnu_result_type);\n \n \tif (Null_Record_Present (gnat_node))\n-\t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL_TREE);\n+\t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL);\n \n \telse if (TREE_CODE (gnu_aggr_type) == RECORD_TYPE\n \t\t || TREE_CODE (gnu_aggr_type) == UNION_TYPE)\n@@ -7307,9 +7320,9 @@ static tree\n pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t\t    Entity_Id gnat_component_type)\n {\n-  tree gnu_expr_list = NULL_TREE;\n   tree gnu_index = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_array_type));\n   tree gnu_expr;\n+  VEC(constructor_elt,gc) *gnu_expr_vec = NULL;\n \n   for ( ; Present (gnat_expr); gnat_expr = Next (gnat_expr))\n     {\n@@ -7332,14 +7345,13 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t    gnu_expr = emit_range_check (gnu_expr, gnat_component_type, Empty);\n \t}\n \n-      gnu_expr_list\n-\t= tree_cons (gnu_index, convert (TREE_TYPE (gnu_array_type), gnu_expr),\n-\t\t     gnu_expr_list);\n+      CONSTRUCTOR_APPEND_ELT (gnu_expr_vec, gnu_index,\n+\t\t\t      convert (TREE_TYPE (gnu_array_type), gnu_expr));\n \n       gnu_index = int_const_binop (PLUS_EXPR, gnu_index, integer_one_node, 0);\n     }\n \n-  return gnat_build_constructor (gnu_array_type, nreverse (gnu_expr_list));\n+  return gnat_build_constructor (gnu_array_type, gnu_expr_vec);\n }\n \f\n /* Subroutine of assoc_to_constructor: VALUES is a list of field associations,\n@@ -7350,8 +7362,8 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n static tree\n extract_values (tree values, tree record_type)\n {\n-  tree result = NULL_TREE;\n   tree field, tem;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n     {\n@@ -7385,10 +7397,10 @@ extract_values (tree values, tree record_type)\n       if (!value)\n \tcontinue;\n \n-      result = tree_cons (field, value, result);\n+      CONSTRUCTOR_APPEND_ELT (v, field, value);\n     }\n \n-  return gnat_build_constructor (record_type, nreverse (result));\n+  return gnat_build_constructor (record_type, v);\n }\n \f\n /* EXP is to be treated as an array or record.  Handle the cases when it is"}, {"sha": "c5d612da91b081d88ee40b623f52fac39c96558a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0e228dd9078e5482b605b0d778347a77e4b69152", "patch": "@@ -2222,7 +2222,7 @@ max_size (tree exp, bool max_p)\n tree\n build_template (tree template_type, tree array_type, tree expr)\n {\n-  tree template_elts = NULL_TREE;\n+  VEC(constructor_elt,gc) *template_elts = NULL;\n   tree bound_list = NULL_TREE;\n   tree field;\n \n@@ -2271,11 +2271,11 @@ build_template (tree template_type, tree array_type, tree expr)\n       min = SUBSTITUTE_PLACEHOLDER_IN_EXPR (min, expr);\n       max = SUBSTITUTE_PLACEHOLDER_IN_EXPR (max, expr);\n \n-      template_elts = tree_cons (TREE_CHAIN (field), max,\n-\t\t\t\t tree_cons (field, min, template_elts));\n+      CONSTRUCTOR_APPEND_ELT (template_elts, field, min);\n+      CONSTRUCTOR_APPEND_ELT (template_elts, TREE_CHAIN (field), max);\n     }\n \n-  return gnat_build_constructor (template_type, nreverse (template_elts));\n+  return gnat_build_constructor (template_type, template_elts);\n }\n \f\n /* Build a 32-bit VMS descriptor from a Mechanism_Type, which must specify a\n@@ -2950,6 +2950,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n       tree lfield, ufield;\n+      VEC(constructor_elt,gc) *v;\n \n       /* Convert POINTER to the pointer-to-array type.  */\n       gnu_expr64 = convert (p_array_type, gnu_expr64);\n@@ -2959,14 +2960,15 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH64 is the 5th field.  */\n+\t  v = VEC_alloc (constructor_elt, gc, 2);\n \t  t = TREE_CHAIN (TREE_CHAIN (klass));\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  t = tree_cons (min_field,\n-\t\t\t convert (TREE_TYPE (min_field), integer_one_node),\n-\t\t\t tree_cons (max_field,\n-\t\t\t\t    convert (TREE_TYPE (max_field), t),\n-\t\t\t\t    NULL_TREE));\n-\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n+\t\t\t\t  convert (TREE_TYPE (min_field),\n+\t\t\t\t\t   integer_one_node));\n+\t  CONSTRUCTOR_APPEND_ELT (v, max_field,\n+\t\t\t\t  convert (TREE_TYPE (max_field), t));\n+\t  template_tree = gnat_build_constructor (template_type, v);\n \t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n \n \t  /* For class S, we are done.  */\n@@ -2990,10 +2992,11 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n            (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n-\t  t = tree_cons (TYPE_FIELDS (template_type), lfield,\n-\t\t\t tree_cons (TREE_CHAIN (TYPE_FIELDS (template_type)),\n-                                    ufield, NULL_TREE));\n-\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  v = VEC_alloc (constructor_elt, gc, 2);\n+\t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n+\t  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (template_type)),\n+\t\t\t\t  ufield);\n+\t  template_tree = gnat_build_constructor (template_type, v);\n \n \t  /* Otherwise use the {1, LENGTH} template we build above.  */\n \t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n@@ -3037,10 +3040,11 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n            (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (template_type))), ufield);\n \n \t  /* Build the template in the form of a constructor. */\n-\t  t = tree_cons (TYPE_FIELDS (template_type), lfield,\n-\t\t\t tree_cons (TREE_CHAIN (TYPE_FIELDS (template_type)),\n-                                    ufield, NULL_TREE));\n-\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  v = VEC_alloc (constructor_elt, gc, 2);\n+\t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (template_type), lfield);\n+\t  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (template_type)),\n+\t\t\t\t  ufield);\n+\t  template_tree = gnat_build_constructor (template_type, v);\n \t  template_tree = build3 (COND_EXPR, template_type, u,\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n@@ -3057,10 +3061,11 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t}\n \n       /* Build the fat pointer in the form of a constructor.  */\n-      t = tree_cons (TYPE_FIELDS (gnu_type), gnu_expr64,\n-\t\t     tree_cons (TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n-\t\t\t\ttemplate_addr, NULL_TREE));\n-      return gnat_build_constructor (gnu_type, t);\n+      v = VEC_alloc (constructor_elt, gc, 2);\n+      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr64);\n+      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n+\t\t\t      template_addr);\n+      return gnat_build_constructor (gnu_type, v);\n     }\n \n   else\n@@ -3098,6 +3103,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n       int iklass = TREE_INT_CST_LOW (DECL_INITIAL (klass));\n+      VEC(constructor_elt,gc) *v;\n \n       /* Convert POINTER to the pointer-to-array type.  */\n       gnu_expr32 = convert (p_array_type, gnu_expr32);\n@@ -3107,14 +3113,15 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH is the 1st field.  */\n+\t  v = VEC_alloc (constructor_elt, gc, 2);\n \t  t = TYPE_FIELDS (desc_type);\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  t = tree_cons (min_field,\n-\t\t\t convert (TREE_TYPE (min_field), integer_one_node),\n-\t\t\t tree_cons (max_field,\n-\t\t\t\t    convert (TREE_TYPE (max_field), t),\n-\t\t\t\t    NULL_TREE));\n-\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  CONSTRUCTOR_APPEND_ELT (v, min_field,\n+\t\t\t\t  convert (TREE_TYPE (min_field),\n+\t\t\t\t\t   integer_one_node));\n+\t  CONSTRUCTOR_APPEND_ELT (v, max_field,\n+\t\t\t\t  convert (TREE_TYPE (max_field), t));\n+\t  template_tree = gnat_build_constructor (template_type, v);\n \t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n \n \t  /* For class S, we are done.  */\n@@ -3178,11 +3185,12 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t}\n \n       /* Build the fat pointer in the form of a constructor.  */\n-      t = tree_cons (TYPE_FIELDS (gnu_type), gnu_expr32,\n-\t\t     tree_cons (TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n-\t\t\t\ttemplate_addr, NULL_TREE));\n+      v = VEC_alloc (constructor_elt, gc, 2);\n+      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (gnu_type), gnu_expr32);\n+      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n+\t\t\t      template_addr);\n \n-      return gnat_build_constructor (gnu_type, t);\n+      return gnat_build_constructor (gnu_type, v);\n     }\n \n   else\n@@ -3551,19 +3559,19 @@ convert_to_fat_pointer (tree type, tree expr)\n   tree p_array_type = TREE_TYPE (TYPE_FIELDS (type));\n   tree etype = TREE_TYPE (expr);\n   tree template_tree;\n+  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n \n   /* If EXPR is null, make a fat pointer that contains null pointers to the\n      template and array.  */\n   if (integer_zerop (expr))\n-    return\n-      gnat_build_constructor\n-\t(type,\n-\t tree_cons (TYPE_FIELDS (type),\n-\t\t    convert (p_array_type, expr),\n-\t\t    tree_cons (TREE_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t       convert (build_pointer_type (template_type),\n-\t\t\t\t\texpr),\n-\t\t\t       NULL_TREE)));\n+    {\n+      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n+\t\t\t      convert (p_array_type, expr));\n+      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (type)),\n+\t\t\t      convert (build_pointer_type (template_type),\n+\t\t\t\t       expr));\n+      return gnat_build_constructor (type, v);\n+    }\n \n   /* If EXPR is a thin pointer, make template and data from the record..  */\n   else if (TYPE_IS_THIN_POINTER_P (etype))\n@@ -3598,15 +3606,12 @@ convert_to_fat_pointer (tree type, tree expr)\n \n      Note that the call to \"build_template\" above is still fine because it\n      will only refer to the provided TEMPLATE_TYPE in this case.  */\n-  return\n-    gnat_build_constructor\n-      (type,\n-       tree_cons (TYPE_FIELDS (type),\n-\t\t  convert (p_array_type, expr),\n-\t\t  tree_cons (TREE_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t     template_tree),\n-\t\t\t     NULL_TREE)));\n+  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n+\t\t\t  convert (p_array_type, expr));\n+  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (type)),\n+\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t  template_tree));\n+  return gnat_build_constructor (type, v);\n }\n \f\n /* Convert to a thin pointer type, TYPE.  The only thing we know how to convert\n@@ -3663,6 +3668,8 @@ convert (tree type, tree expr)\n      constructor to build the record, unless a variable size is involved.  */\n   else if (code == RECORD_TYPE && TYPE_PADDING_P (type))\n     {\n+      VEC(constructor_elt,gc) *v;\n+\n       /* If we previously converted from another type and our type is\n \t of variable size, remove the conversion to avoid the need for\n \t variable-sized temporaries.  Likewise for a conversion between\n@@ -3713,13 +3720,10 @@ convert (tree type, tree expr)\n \t\t\t\t\t   expr),\n \t\t\t\t  false);\n \n-      return\n-\tgnat_build_constructor (type,\n-\t\t\t\ttree_cons (TYPE_FIELDS (type),\n-\t\t\t\t\t   convert (TREE_TYPE\n-\t\t\t\t\t\t    (TYPE_FIELDS (type)),\n-\t\t\t\t\t\t    expr),\n-\t\t\t\t\t   NULL_TREE));\n+      v = VEC_alloc (constructor_elt, gc, 1);\n+      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n+\t\t\t      convert (TREE_TYPE (TYPE_FIELDS (type)), expr));\n+      return gnat_build_constructor (type, v);\n     }\n \n   /* If the input type has padding, remove it and convert to the output type.\n@@ -3771,20 +3775,19 @@ convert (tree type, tree expr)\n   if (code == RECORD_TYPE && TYPE_CONTAINS_TEMPLATE_P (type))\n     {\n       tree obj_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (type)));\n+      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n \n       /* If the source already has a template, get a reference to the\n \t associated array only, as we are going to rebuild a template\n \t for the target type anyway.  */\n       expr = maybe_unconstrained_array (expr);\n \n-      return\n-\tgnat_build_constructor\n-\t  (type,\n-\t   tree_cons (TYPE_FIELDS (type),\n-\t\t      build_template (TREE_TYPE (TYPE_FIELDS (type)),\n-\t\t\t\t      obj_type, NULL_TREE),\n-\t\t      tree_cons (TREE_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t\t convert (obj_type, expr), NULL_TREE)));\n+      CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n+\t\t\t      build_template (TREE_TYPE (TYPE_FIELDS (type)),\n+\t\t\t\t\t      obj_type, NULL_TREE));\n+      CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (type)),\n+\t\t\t      convert (obj_type, expr));\n+      return gnat_build_constructor (type, v);\n     }\n \n   /* There are some special cases of expressions that we process\n@@ -4114,11 +4117,14 @@ convert (tree type, tree expr)\n \n     case RECORD_TYPE:\n       if (TYPE_JUSTIFIED_MODULAR_P (type) && !AGGREGATE_TYPE_P (etype))\n-\treturn\n-\t  gnat_build_constructor\n-\t    (type, tree_cons (TYPE_FIELDS (type),\n-\t\t\t      convert (TREE_TYPE (TYPE_FIELDS (type)), expr),\n-\t\t\t      NULL_TREE));\n+\t{\n+\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n+\n+\t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n+\t\t\t\t  convert (TREE_TYPE (TYPE_FIELDS (type)),\n+\t\t\t\t\t   expr));\n+\t  return gnat_build_constructor (type, v);\n+\t}\n \n       /* ... fall through ... */\n \n@@ -4410,11 +4416,13 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       tree rec_type = make_node (RECORD_TYPE);\n       tree field = create_field_decl (get_identifier (\"OBJ\"), etype, rec_type,\n \t\t\t\t      NULL_TREE, NULL_TREE, 1, 0);\n+      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n \n       TYPE_FIELDS (rec_type) = field;\n       layout_type (rec_type);\n \n-      expr = gnat_build_constructor (rec_type, build_tree_list (field, expr));\n+      CONSTRUCTOR_APPEND_ELT (v, field, expr);\n+      expr = gnat_build_constructor (rec_type, v);\n       expr = unchecked_convert (type, expr, notrunc_p);\n     }\n "}, {"sha": "ab3814ec4e0b0a050bcf07288ac7b7727254171d", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e228dd9078e5482b605b0d778347a77e4b69152/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=0e228dd9078e5482b605b0d778347a77e4b69152", "patch": "@@ -1521,34 +1521,31 @@ build_call_raise (int msg, Node_Id gnat_node, char kind)\n static int\n compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n {\n-  const_tree const elmt1 = * (const_tree const *) rt1;\n-  const_tree const elmt2 = * (const_tree const *) rt2;\n-  const_tree const field1 = TREE_PURPOSE (elmt1);\n-  const_tree const field2 = TREE_PURPOSE (elmt2);\n+  const constructor_elt * const elmt1 = (const constructor_elt const *) rt1;\n+  const constructor_elt * const elmt2 = (const constructor_elt const *) rt2;\n+  const_tree const field1 = elmt1->index;\n+  const_tree const field2 = elmt2->index;\n   const int ret\n     = tree_int_cst_compare (bit_position (field1), bit_position (field2));\n \n   return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n }\n \n-/* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n+/* Return a CONSTRUCTOR of TYPE whose elements are V.  */\n \n tree\n-gnat_build_constructor (tree type, tree list)\n+gnat_build_constructor (tree type, VEC(constructor_elt,gc) *v)\n {\n   bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n   bool side_effects = false;\n-  tree elmt, result;\n-  int n_elmts;\n+  tree result, obj, val;\n+  unsigned int n_elmts;\n \n   /* Scan the elements to see if they are all constant or if any has side\n      effects, to let us set global flags on the resulting constructor.  Count\n      the elements along the way for possible sorting purposes below.  */\n-  for (n_elmts = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), n_elmts ++)\n+  FOR_EACH_CONSTRUCTOR_ELT (v, n_elmts, obj, val)\n     {\n-      tree obj = TREE_PURPOSE (elmt);\n-      tree val = TREE_VALUE (elmt);\n-\n       /* The predicate must be in keeping with output_constructor.  */\n       if (!TREE_CONSTANT (val)\n \t  || (TREE_CODE (type) == RECORD_TYPE\n@@ -1565,27 +1562,10 @@ gnat_build_constructor (tree type, tree list)\n      by increasing bit position.  This is necessary to ensure the\n      constructor can be output as static data.  */\n   if (allconstant && TREE_CODE (type) == RECORD_TYPE && n_elmts > 1)\n-    {\n-      /* Fill an array with an element tree per index, and ask qsort to order\n-\t them according to what a bitpos comparison function says.  */\n-      tree *gnu_arr = (tree *) alloca (sizeof (tree) * n_elmts);\n-      int i;\n-\n-      for (i = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), i++)\n-\tgnu_arr[i] = elmt;\n+    qsort (VEC_address (constructor_elt, v), n_elmts,\n+           sizeof (constructor_elt), compare_elmt_bitpos);\n \n-      qsort (gnu_arr, n_elmts, sizeof (tree), compare_elmt_bitpos);\n-\n-      /* Then reconstruct the list from the sorted array contents.  */\n-      list = NULL_TREE;\n-      for (i = n_elmts - 1; i >= 0; i--)\n-\t{\n-\t  TREE_CHAIN (gnu_arr[i]) = list;\n-\t  list = gnu_arr[i];\n-\t}\n-    }\n-\n-  result = build_constructor_from_list (type, list);\n+  result = build_constructor (type, v);\n   TREE_CONSTANT (result) = TREE_STATIC (result) = allconstant;\n   TREE_SIDE_EFFECTS (result) = side_effects;\n   TREE_READONLY (result) = TYPE_READONLY (type) || allconstant;\n@@ -1986,7 +1966,6 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       tree template_type = TREE_TYPE (TYPE_FIELDS (storage_type));\n       tree storage_ptr_type = build_pointer_type (storage_type);\n       tree storage;\n-      tree template_cons = NULL_TREE;\n \n       size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n \t\t\t\t\t     init);\n@@ -2013,12 +1992,12 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t bounds.  */\n       if (init)\n \t{\n-\t  template_cons = tree_cons (TREE_CHAIN (TYPE_FIELDS (storage_type)),\n-\t\t\t\t     init, NULL_TREE);\n-\t  template_cons = tree_cons (TYPE_FIELDS (storage_type),\n-\t\t\t\t     build_template (template_type, type,\n-\t\t\t\t\t\t     init),\n-\t\t\t\t     template_cons);\n+\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n+\n+\t  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (storage_type),\n+\t\t\t\t  build_template (template_type, type, init));\n+\t  CONSTRUCTOR_APPEND_ELT (v, TREE_CHAIN (TYPE_FIELDS (storage_type)),\n+\t\t\t\t  init);\n \n \t  return convert\n \t    (result_type,\n@@ -2027,7 +2006,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t     (MODIFY_EXPR, storage_type,\n \t\t      build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t      convert (storage_ptr_type, storage)),\n-\t\t      gnat_build_constructor (storage_type, template_cons)),\n+\t\t      gnat_build_constructor (storage_type, v)),\n \t\t     convert (storage_ptr_type, storage)));\n \t}\n       else\n@@ -2100,10 +2079,11 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n {\n   tree parm_decl = get_gnu_tree (gnat_formal);\n   tree record_type = TREE_TYPE (TREE_TYPE (parm_decl));\n-  tree const_list = NULL_TREE, field;\n+  tree field;\n   const bool do_range_check\n     = strcmp (\"MBO\",\n \t      IDENTIFIER_POINTER (DECL_NAME (TYPE_FIELDS (record_type))));\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   expr = maybe_unconstrained_array (expr);\n   gnat_mark_addressable (expr);\n@@ -2135,10 +2115,10 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n \t\t\t\t\t      N_Raise_Constraint_Error),\n \t\t\t    NULL_TREE));\n         }\n-      const_list = tree_cons (field, conexpr, const_list);\n+      CONSTRUCTOR_APPEND_ELT (v, field, conexpr);\n     }\n \n-  return gnat_build_constructor (record_type, nreverse (const_list));\n+  return gnat_build_constructor (record_type, v);\n }\n \n /* Indicate that we need to take the address of T and that it therefore"}]}