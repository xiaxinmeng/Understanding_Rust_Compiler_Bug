{"sha": "50a41d64f384053a948bccdf9897078d92547103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBhNDFkNjRmMzg0MDUzYTk0OGJjY2RmOTg5NzA3OGQ5MjU0NzEwMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:49:51Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:49:51Z"}, "message": "Change use to type-based pool allocator in\n\n\t* ipa-inline-analysis.c (edge_set_predicate): Use new type-based pool allocator.\n\t(set_hint_predicate): Likewise.\n\t(inline_summary_alloc): Likewise.\n\t(reset_inline_edge_summary): Likewise.\n\t(reset_inline_summary): Likewise.\n\t(set_cond_stmt_execution_predicate): Likewise.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(compute_bb_predicates): Likewise.\n\t(estimate_function_body_sizes): Likewise.\n\t(inline_free_summary): Likewise.\n\nFrom-SVN: r223970", "tree": {"sha": "93d6e6cf6494ce64e06f208e18bbf2a50a28131c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93d6e6cf6494ce64e06f208e18bbf2a50a28131c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50a41d64f384053a948bccdf9897078d92547103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a41d64f384053a948bccdf9897078d92547103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50a41d64f384053a948bccdf9897078d92547103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a41d64f384053a948bccdf9897078d92547103/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "601f32936b3d8f16d853ece064e7f3c9de743016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601f32936b3d8f16d853ece064e7f3c9de743016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601f32936b3d8f16d853ece064e7f3c9de743016"}], "stats": {"total": 52, "additions": 30, "deletions": 22}, "files": [{"sha": "da0d4974b861b6dd954e45293fe1497591d73c90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a41d64f384053a948bccdf9897078d92547103/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a41d64f384053a948bccdf9897078d92547103/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50a41d64f384053a948bccdf9897078d92547103", "patch": "@@ -1,3 +1,16 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-inline-analysis.c (edge_set_predicate): Use new type-based pool allocator.\n+\t(set_hint_predicate): Likewise.\n+\t(inline_summary_alloc): Likewise.\n+\t(reset_inline_edge_summary): Likewise.\n+\t(reset_inline_summary): Likewise.\n+\t(set_cond_stmt_execution_predicate): Likewise.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(compute_bb_predicates): Likewise.\n+\t(estimate_function_body_sizes): Likewise.\n+\t(inline_free_summary): Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-prop.c (ipa_set_jf_constant): Use new type-based pool allocator."}, {"sha": "7d8edee355ec9998c7f372ad45dcd1ecab4fae8a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a41d64f384053a948bccdf9897078d92547103/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a41d64f384053a948bccdf9897078d92547103/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=50a41d64f384053a948bccdf9897078d92547103", "patch": "@@ -170,7 +170,7 @@ vec<inline_edge_summary_t> inline_edge_summary_vec;\n vec<edge_growth_cache_entry> edge_growth_cache;\n \n /* Edge predicates goes here.  */\n-static alloc_pool edge_predicate_pool;\n+static pool_allocator<predicate> edge_predicate_pool (\"edge predicates\", 10);\n \n /* Return true predicate (tautology).\n    We represent it by empty list of clauses.  */\n@@ -804,13 +804,13 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n   if (predicate && !true_predicate_p (predicate))\n     {\n       if (!es->predicate)\n-\tes->predicate = (struct predicate *) pool_alloc (edge_predicate_pool);\n+\tes->predicate = edge_predicate_pool.allocate ();\n       *es->predicate = *predicate;\n     }\n   else\n     {\n       if (es->predicate)\n-\tpool_free (edge_predicate_pool, es->predicate);\n+\tedge_predicate_pool.remove (es->predicate);\n       es->predicate = NULL;\n     }\n }\n@@ -823,13 +823,13 @@ set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n   if (false_predicate_p (&new_predicate) || true_predicate_p (&new_predicate))\n     {\n       if (*p)\n-\tpool_free (edge_predicate_pool, *p);\n+\tedge_predicate_pool.remove (*p);\n       *p = NULL;\n     }\n   else\n     {\n       if (!*p)\n-\t*p = (struct predicate *) pool_alloc (edge_predicate_pool);\n+\t*p = edge_predicate_pool.allocate ();\n       **p = new_predicate;\n     }\n }\n@@ -1044,9 +1044,6 @@ inline_summary_alloc (void)\n \n   if (inline_edge_summary_vec.length () <= (unsigned) symtab->edges_max_uid)\n     inline_edge_summary_vec.safe_grow_cleared (symtab->edges_max_uid + 1);\n-  if (!edge_predicate_pool)\n-    edge_predicate_pool = create_alloc_pool (\"edge predicates\",\n-\t\t\t\t\t     sizeof (struct predicate), 10);\n }\n \n /* We are called multiple time for given function; clear\n@@ -1061,7 +1058,7 @@ reset_inline_edge_summary (struct cgraph_edge *e)\n \n       es->call_stmt_size = es->call_stmt_time = 0;\n       if (es->predicate)\n-\tpool_free (edge_predicate_pool, es->predicate);\n+\tedge_predicate_pool.remove (es->predicate);\n       es->predicate = NULL;\n       es->param.release ();\n     }\n@@ -1086,17 +1083,17 @@ reset_inline_summary (struct cgraph_node *node,\n   info->scc_no = 0;\n   if (info->loop_iterations)\n     {\n-      pool_free (edge_predicate_pool, info->loop_iterations);\n+      edge_predicate_pool.remove (info->loop_iterations);\n       info->loop_iterations = NULL;\n     }\n   if (info->loop_stride)\n     {\n-      pool_free (edge_predicate_pool, info->loop_stride);\n+      edge_predicate_pool.remove (info->loop_stride);\n       info->loop_stride = NULL;\n     }\n   if (info->array_index)\n     {\n-      pool_free (edge_predicate_pool, info->array_index);\n+      edge_predicate_pool.remove (info->array_index);\n       info->array_index = NULL;\n     }\n   vec_free (info->conds);\n@@ -1812,7 +1809,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n \t      struct predicate p = add_condition (summary, index, &aggpos,\n \t\t\t\t\t\t  this_code,\n \t\t\t\t\t\t  gimple_cond_rhs (last));\n-\t      e->aux = pool_alloc (edge_predicate_pool);\n+\t      e->aux = edge_predicate_pool.allocate ();\n \t      *(struct predicate *) e->aux = p;\n \t    }\n \t}\n@@ -1845,7 +1842,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n     {\n       struct predicate p = add_condition (summary, index, &aggpos,\n \t\t\t\t\t  IS_NOT_CONSTANT, NULL_TREE);\n-      e->aux = pool_alloc (edge_predicate_pool);\n+      e->aux = edge_predicate_pool.allocate ();\n       *(struct predicate *) e->aux = p;\n     }\n }\n@@ -1878,7 +1875,7 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      e->aux = pool_alloc (edge_predicate_pool);\n+      e->aux = edge_predicate_pool.allocate ();\n       *(struct predicate *) e->aux = false_predicate ();\n     }\n   n = gimple_switch_num_labels (last);\n@@ -1932,7 +1929,7 @@ compute_bb_predicates (struct cgraph_node *node,\n \n   /* Entry block is always executable.  */\n   ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n-    = pool_alloc (edge_predicate_pool);\n+    = edge_predicate_pool.allocate ();\n   *(struct predicate *) ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n     = true_predicate ();\n \n@@ -1968,7 +1965,7 @@ compute_bb_predicates (struct cgraph_node *node,\n \t      if (!bb->aux)\n \t\t{\n \t\t  done = false;\n-\t\t  bb->aux = pool_alloc (edge_predicate_pool);\n+\t\t  bb->aux = edge_predicate_pool.allocate ();\n \t\t  *((struct predicate *) bb->aux) = p;\n \t\t}\n \t      else if (!predicates_equal_p (&p, (struct predicate *) bb->aux))\n@@ -2864,12 +2861,12 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       edge_iterator ei;\n \n       if (bb->aux)\n-\tpool_free (edge_predicate_pool, bb->aux);\n+\tedge_predicate_pool.remove ((predicate *)bb->aux);\n       bb->aux = NULL;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->aux)\n-\t    pool_free (edge_predicate_pool, e->aux);\n+\t    edge_predicate_pool.remove ((predicate *) e->aux);\n \t  e->aux = NULL;\n \t}\n     }\n@@ -4460,7 +4457,5 @@ inline_free_summary (void)\n   inline_summaries->release ();\n   inline_summaries = NULL;\n   inline_edge_summary_vec.release ();\n-  if (edge_predicate_pool)\n-    free_alloc_pool (edge_predicate_pool);\n-  edge_predicate_pool = 0;\n+  edge_predicate_pool.release ();\n }"}]}