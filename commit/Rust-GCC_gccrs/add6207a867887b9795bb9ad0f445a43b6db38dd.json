{"sha": "add6207a867887b9795bb9ad0f445a43b6db38dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRkNjIwN2E4Njc4ODdiOTc5NWJiOWFkMGY0NDVhNDNiNmRiMzhkZA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-04-20T14:19:13Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-04-20T14:19:13Z"}, "message": "re PR rtl-optimization/44214 (Compiler does not optimize vector divide with -freciprocal-math (or -ffast-math))\n\ngcc:\n\n2012-04-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR rtl-optimization/44214\n\t* fold-const.c (exact_inverse): New function.\n\t(fold_binary_loc): Fold vector and complex division by constant into\n\tmultiply by recripocal with flag_reciprocal_math; fold vector division\n\tby constant into multiply by reciprocal with exact inverse.\n\ngcc/testsuite:\n\n2012-04-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR rtl-optimization/44214\n\t* gcc.dg/pr44214-1.c: New test.\n\t* gcc.dg/pr44214-2.c: Likewise.\n\t* gcc.dg/pr44214-3.c: Likewise.\n\nFrom-SVN: r186625", "tree": {"sha": "439c9e905aa25afd2fd523e6ed1cbc6b9dff236a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/439c9e905aa25afd2fd523e6ed1cbc6b9dff236a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/add6207a867887b9795bb9ad0f445a43b6db38dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add6207a867887b9795bb9ad0f445a43b6db38dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/add6207a867887b9795bb9ad0f445a43b6db38dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add6207a867887b9795bb9ad0f445a43b6db38dd/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead84f73b0a0f39ea39aa0329b6da83e4a9e6e02"}], "stats": {"total": 135, "additions": 122, "deletions": 13}, "files": [{"sha": "0a3eda63c1acef8f721f45af2f9a58ceaaee19cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=add6207a867887b9795bb9ad0f445a43b6db38dd", "patch": "@@ -1,3 +1,11 @@\n+2012-04-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR rtl-optimization/44214\n+\t* fold-const.c (exact_inverse): New function.\n+\t(fold_binary_loc): Fold vector and complex division by constant into\n+\tmultiply by recripocal with flag_reciprocal_math; fold vector division\n+\tby constant into multiply by reciprocal with exact inverse.\n+\n 2012-04-20  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-symtab.c (lto_cgraph_replace_node): Merge needed instead of force flags."}, {"sha": "fa75fdbec360c3b9a57626cef1b6ab7e5187dd80", "filename": "gcc/fold-const.c", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=add6207a867887b9795bb9ad0f445a43b6db38dd", "patch": "@@ -9693,6 +9693,48 @@ fold_addr_of_array_ref_difference (location_t loc, tree type,\n   return NULL_TREE;\n }\n \n+/* If the real or vector real constant CST of type TYPE has an exact\n+   inverse, return it, else return NULL.  */\n+\n+static tree\n+exact_inverse (tree type, tree cst)\n+{\n+  REAL_VALUE_TYPE r;\n+  tree unit_type, *elts;\n+  enum machine_mode mode;\n+  unsigned vec_nelts, i;\n+\n+  switch (TREE_CODE (cst))\n+    {\n+    case REAL_CST:\n+      r = TREE_REAL_CST (cst);\n+\n+      if (exact_real_inverse (TYPE_MODE (type), &r))\n+\treturn build_real (type, r);\n+\n+      return NULL_TREE;\n+\n+    case VECTOR_CST:\n+      vec_nelts = VECTOR_CST_NELTS (cst);\n+      elts = XALLOCAVEC (tree, vec_nelts);\n+      unit_type = TREE_TYPE (type);\n+      mode = TYPE_MODE (unit_type);\n+\n+      for (i = 0; i < vec_nelts; i++)\n+\t{\n+\t  r = TREE_REAL_CST (VECTOR_CST_ELT (cst, i));\n+\t  if (!exact_real_inverse (mode, &r))\n+\t    return NULL_TREE;\n+\t  elts[i] = build_real (unit_type, r);\n+\t}\n+\n+      return build_vector (type, elts);\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n /* Fold a binary expression of code CODE and type TYPE with operands\n    OP0 and OP1.  LOC is the location of the resulting expression.\n    Return the folded expression if folding is successful.  Otherwise,\n@@ -11734,23 +11776,24 @@ fold_binary_loc (location_t loc,\n \t so only do this if -freciprocal-math.  We can actually\n \t always safely do it if ARG1 is a power of two, but it's hard to\n \t tell if it is or not in a portable manner.  */\n-      if (TREE_CODE (arg1) == REAL_CST)\n+      if (optimize\n+\t  && (TREE_CODE (arg1) == REAL_CST\n+\t      || (TREE_CODE (arg1) == COMPLEX_CST\n+\t\t  && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg1)))\n+\t      || (TREE_CODE (arg1) == VECTOR_CST\n+\t\t  && VECTOR_FLOAT_TYPE_P (TREE_TYPE (arg1)))))\n \t{\n \t  if (flag_reciprocal_math\n-\t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n-\t\t\t\t\t  arg1)))\n+\t      && 0 != (tem = const_binop (code, build_one_cst (type), arg1)))\n \t    return fold_build2_loc (loc, MULT_EXPR, type, arg0, tem);\n-\t  /* Find the reciprocal if optimizing and the result is exact.  */\n-\t  if (optimize)\n+\t  /* Find the reciprocal if optimizing and the result is exact.\n+\t     TODO: Complex reciprocal not implemented.  */\n+\t  if (TREE_CODE (arg1) != COMPLEX_CST)\n \t    {\n-\t      REAL_VALUE_TYPE r;\n-\t      r = TREE_REAL_CST (arg1);\n-\t      if (exact_real_inverse (TYPE_MODE(TREE_TYPE(arg0)), &r))\n-\t\t{\n-\t\t  tem = build_real (type, r);\n-\t\t  return fold_build2_loc (loc, MULT_EXPR, type,\n-\t\t\t\t      fold_convert_loc (loc, type, arg0), tem);\n-\t\t}\n+\t      tree inverse = exact_inverse (TREE_TYPE (arg0), arg1);\n+\n+\t      if (inverse)\n+\t\treturn fold_build2_loc (loc, MULT_EXPR, type, arg0, inverse);\n \t    }\n \t}\n       /* Convert A/B/C to A/(B*C).  */"}, {"sha": "e8d4f0dd5453627b3f2563534ea2842de9860831", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=add6207a867887b9795bb9ad0f445a43b6db38dd", "patch": "@@ -1,3 +1,10 @@\n+2012-04-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR rtl-optimization/44214\n+\t* gcc.dg/pr44214-1.c: New test.\n+\t* gcc.dg/pr44214-2.c: Likewise.\n+\t* gcc.dg/pr44214-3.c: Likewise.\n+\n 2012-04-20  Richard Guenther  <rguenther@suse.de>\n \n \t* g++.dg/torture/20120420-1.C: New testcase."}, {"sha": "292ce57c30e36fbd76bb2fbfe2f3a9f183555c68", "filename": "gcc/testsuite/gcc.dg/pr44214-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-1.c?ref=add6207a867887b9795bb9ad0f445a43b6db38dd", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -freciprocal-math -fdump-tree-ccp1\" } */\n+\n+typedef double v2df __attribute__ ((vector_size (16)));\n+\n+void do_div (v2df *a, v2df *b)\n+{\n+  *a = *b / (v2df) { 2.0, 3.0 };\n+}\n+\n+/* Constant folding should multiply *b by the reciprocals of the\n+   vector elements.  The fold does not take place for generic\n+   vectors until the first CCP pass.  The string \" * \" occurs 3\n+   times:  one multiply and two indirect parameters.  */\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\\\* \" 3 \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump-times \" / \" 0 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "7e8581a2bb38bfe255db18735c3cd0167a075d28", "filename": "gcc/testsuite/gcc.dg/pr44214-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-2.c?ref=add6207a867887b9795bb9ad0f445a43b6db38dd", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -freciprocal-math -fdump-tree-original\" } */\n+\n+void do_div (_Complex double *a, _Complex double *b)\n+{\n+  *a = *b / (4.0 - 5.0fi);\n+}\n+\n+/* Constant folding should multiply *b by the reciprocal of 4 - 5i\n+   = 4/41 + (5/41)i.  */\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\\\* \" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \" / \" 0 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "46d5ee8c78e8b5fdf3327fbd2ae78e9ee65553ed", "filename": "gcc/testsuite/gcc.dg/pr44214-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/add6207a867887b9795bb9ad0f445a43b6db38dd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44214-3.c?ref=add6207a867887b9795bb9ad0f445a43b6db38dd", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ccp1\" } */\n+\n+typedef double v2df __attribute__ ((vector_size (16)));\n+\n+void do_div (v2df *a, v2df *b)\n+{\n+  *a = *b / (v2df) { 2.0, 2.0 };\n+}\n+\n+/* Since 2.0 has an exact reciprocal, constant folding should multiply *b\n+   by the reciprocals of the vector elements.  As a result there should be\n+   one vector multiply and zero divides in the optimized code.  The fold\n+   does not take place for generic vectors until the first CCP pass.  The\n+   string \" * \" occurs 3 times:  one multiply and two indirect parameters.  */\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\\\* \" 3 \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump-times \" / \" 0 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}]}