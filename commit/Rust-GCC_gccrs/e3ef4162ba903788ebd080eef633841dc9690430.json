{"sha": "e3ef4162ba903788ebd080eef633841dc9690430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNlZjQxNjJiYTkwMzc4OGViZDA4MGVlZjYzMzg0MWRjOTY5MDQzMA==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-09-01T09:07:00Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-09-01T09:07:00Z"}, "message": "tree-ssa-math-opts.c (struct symbolic_number): Clarify comment about the size of byte markers.\n\n2014-09-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    * tree-ssa-math-opts.c (struct symbolic_number): Clarify comment about\n    the size of byte markers.\n    (do_shift_rotate): Fix confusion between host, target and marker byte\n    size.\n    (verify_symbolic_number_p): Likewise.\n    (find_bswap_or_nop_1): Likewise.\n    (find_bswap_or_nop): Likewise.\n\nFrom-SVN: r214780", "tree": {"sha": "6a39a5a4f89ba07d17a7c8b4148a0ab98f40e203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a39a5a4f89ba07d17a7c8b4148a0ab98f40e203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3ef4162ba903788ebd080eef633841dc9690430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3ef4162ba903788ebd080eef633841dc9690430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3ef4162ba903788ebd080eef633841dc9690430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3ef4162ba903788ebd080eef633841dc9690430/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a810ff44d9b11d1742571750c34ae5e6f0f7d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a810ff44d9b11d1742571750c34ae5e6f0f7d44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a810ff44d9b11d1742571750c34ae5e6f0f7d44"}], "stats": {"total": 93, "additions": 55, "deletions": 38}, "files": [{"sha": "19f7f7935d68e5566f48229e8e6d9e61640a7d60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef4162ba903788ebd080eef633841dc9690430/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef4162ba903788ebd080eef633841dc9690430/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3ef4162ba903788ebd080eef633841dc9690430", "patch": "@@ -1,3 +1,13 @@\n+2014-09-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* tree-ssa-math-opts.c (struct symbolic_number): Clarify comment about\n+\tthe size of byte markers.\n+\t(do_shift_rotate): Fix confusion between host, target and marker byte\n+\tsize.\n+\t(verify_symbolic_number_p): Likewise.\n+\t(find_bswap_or_nop_1): Likewise.\n+\t(find_bswap_or_nop): Likewise.\n+\n 2014-09-01  Olivier Hainque  <hainque@adacore.com>\n \n \t* Makefile.in (FLAGS_TO_PASS): Propagate INSTALL, INSTALL_DATA,"}, {"sha": "c1c2c82e9aecc3ea3f6fe33a82935744a4054069", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef4162ba903788ebd080eef633841dc9690430/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef4162ba903788ebd080eef633841dc9690430/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=e3ef4162ba903788ebd080eef633841dc9690430", "patch": "@@ -1600,11 +1600,10 @@ make_pass_cse_sincos (gcc::context *ctxt)\n \n /* A symbolic number is used to detect byte permutation and selection\n    patterns.  Therefore the field N contains an artificial number\n-   consisting of byte size markers:\n+   consisting of octet sized markers:\n \n-   0    - byte has the value 0\n-   1..size - byte contains the content of the byte\n-   number indexed with that value minus one.\n+   0    - target byte has the value 0\n+   1..size - marker value is the target byte index minus one.\n \n    To detect permutations on memory sources (arrays and structures), a symbolic\n    number is also associated a base address (the array or structure the load is\n@@ -1629,6 +1628,8 @@ struct symbolic_number {\n   unsigned HOST_WIDE_INT range;\n };\n \n+#define BITS_PER_MARKER 8\n+\n /* The number which the find_bswap_or_nop_1 result should match in\n    order to have a nop.  The number is masked according to the size of\n    the symbolic number before using it.  */\n@@ -1650,15 +1651,16 @@ do_shift_rotate (enum tree_code code,\n \t\t struct symbolic_number *n,\n \t\t int count)\n {\n-  int bitsize = TYPE_PRECISION (n->type);\n+  int size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n \n-  if (count % 8 != 0)\n+  if (count % BITS_PER_UNIT != 0)\n     return false;\n+  count = (count / BITS_PER_UNIT) * BITS_PER_MARKER;\n \n   /* Zero out the extra bits of N in order to avoid them being shifted\n      into the significant bits.  */\n-  if (bitsize < 8 * (int)sizeof (int64_t))\n-    n->n &= ((uint64_t)1 << bitsize) - 1;\n+  if (size < 64 / BITS_PER_MARKER)\n+    n->n &= ((uint64_t) 1 << (size * BITS_PER_MARKER)) - 1;\n \n   switch (code)\n     {\n@@ -1668,22 +1670,22 @@ do_shift_rotate (enum tree_code code,\n     case RSHIFT_EXPR:\n       /* Arithmetic shift of signed type: result is dependent on the value.  */\n       if (!TYPE_UNSIGNED (n->type)\n-\t  && (n->n & ((uint64_t) 0xff << (bitsize - 8))))\n+\t  && (n->n & ((uint64_t) 0xff << ((size - 1) * BITS_PER_MARKER))))\n \treturn false;\n       n->n >>= count;\n       break;\n     case LROTATE_EXPR:\n-      n->n = (n->n << count) | (n->n >> (bitsize - count));\n+      n->n = (n->n << count) | (n->n >> ((size * BITS_PER_MARKER) - count));\n       break;\n     case RROTATE_EXPR:\n-      n->n = (n->n >> count) | (n->n << (bitsize - count));\n+      n->n = (n->n >> count) | (n->n << ((size * BITS_PER_MARKER) - count));\n       break;\n     default:\n       return false;\n     }\n   /* Zero unused bits for size.  */\n-  if (bitsize < 8 * (int)sizeof (int64_t))\n-    n->n &= ((uint64_t)1 << bitsize) - 1;\n+  if (size < 64 / BITS_PER_MARKER)\n+    n->n &= ((uint64_t) 1 << (size * BITS_PER_MARKER)) - 1;\n   return true;\n }\n \n@@ -1724,13 +1726,13 @@ init_symbolic_number (struct symbolic_number *n, tree src)\n   if (size % BITS_PER_UNIT != 0)\n     return false;\n   size /= BITS_PER_UNIT;\n-  if (size > (int)sizeof (uint64_t))\n+  if (size > 64 / BITS_PER_MARKER)\n     return false;\n   n->range = size;\n   n->n = CMPNOP;\n \n-  if (size < (int)sizeof (int64_t))\n-    n->n &= ((uint64_t)1 << (size * BITS_PER_UNIT)) - 1;\n+  if (size < 64 / BITS_PER_MARKER)\n+    n->n &= ((uint64_t) 1 << (size * BITS_PER_MARKER)) - 1;\n \n   return true;\n }\n@@ -1868,15 +1870,17 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \tcase BIT_AND_EXPR:\n \t  {\n \t    int i, size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n-\t    uint64_t val = int_cst_value (rhs2);\n-\t    uint64_t tmp = val;\n+\t    uint64_t val = int_cst_value (rhs2), mask = 0;\n+\t    uint64_t tmp = (1 << BITS_PER_UNIT) - 1;\n \n \t    /* Only constants masking full bytes are allowed.  */\n-\t    for (i = 0; i < size; i++, tmp >>= BITS_PER_UNIT)\n-\t      if ((tmp & 0xff) != 0 && (tmp & 0xff) != 0xff)\n+\t    for (i = 0; i < size; i++, tmp <<= BITS_PER_UNIT)\n+\t      if ((val & tmp) != 0 && (val & tmp) != tmp)\n \t\treturn NULL;\n+\t      else if (val & tmp)\n+\t\tmask |= (uint64_t) 0xff << (i * BITS_PER_MARKER);\n \n-\t    n->n &= val;\n+\t    n->n &= mask;\n \t  }\n \t  break;\n \tcase LSHIFT_EXPR:\n@@ -1895,25 +1899,27 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t    type_size = TYPE_PRECISION (type);\n \t    if (type_size % BITS_PER_UNIT != 0)\n \t      return NULL;\n-\t    if (type_size > (int)sizeof (uint64_t) * 8)\n+\t    type_size /= BITS_PER_UNIT;\n+\t    if (type_size > 64 / BITS_PER_MARKER)\n \t      return NULL;\n \n \t    /* Sign extension: result is dependent on the value.  */\n-\t    old_type_size = TYPE_PRECISION (n->type);\n+\t    old_type_size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n \t    if (!TYPE_UNSIGNED (n->type)\n \t\t&& type_size > old_type_size\n-\t\t&& n->n & ((uint64_t) 0xff << (old_type_size - 8)))\n+\t\t&& n->n & ((uint64_t) 0xff << ((old_type_size - 1)\n+\t\t\t\t\t       * BITS_PER_MARKER)))\n \t      return NULL;\n \n-\t    if (type_size / BITS_PER_UNIT < (int)(sizeof (int64_t)))\n+\t    if (type_size < 64 / BITS_PER_MARKER)\n \t      {\n \t\t/* If STMT casts to a smaller type mask out the bits not\n \t\t   belonging to the target type.  */\n-\t\tn->n &= ((uint64_t)1 << type_size) - 1;\n+\t\tn->n &= ((uint64_t) 1 << (type_size * BITS_PER_MARKER)) - 1;\n \t      }\n \t    n->type = type;\n \t    if (!n->base_addr)\n-\t      n->range = type_size / BITS_PER_UNIT;\n+\t      n->range = type_size;\n \t  }\n \t  break;\n \tdefault:\n@@ -1963,7 +1969,6 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t      != gimple_assign_rhs1 (source_stmt2))\n \t    {\n \t      int64_t inc, mask;\n-\t      unsigned i;\n \t      HOST_WIDE_INT off_sub;\n \t      struct symbolic_number *n_ptr;\n \n@@ -1987,21 +1992,23 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n \t      off_sub = n2.bytepos - n1.bytepos;\n \n-\t      /* Check that the range of memory covered < biggest int size.  */\n-\t      if (off_sub + n2.range > (int) sizeof (int64_t))\n+\t      /* Check that the range of memory covered can be represented by\n+\t\t a symbolic number.  */\n+\t      if (off_sub + n2.range > 64 / BITS_PER_MARKER)\n \t\treturn NULL;\n \t      n->range = n2.range + off_sub;\n \n \t      /* Reinterpret byte marks in symbolic number holding the value of\n \t\t bigger weight according to target endianness.  */\n \t      inc = BYTES_BIG_ENDIAN ? off_sub + n2.range - n1.range : off_sub;\n-\t      mask = 0xFF;\n+\t      size = TYPE_PRECISION (n1.type) / BITS_PER_UNIT;\n+\t      mask = 0xff;\n \t      if (BYTES_BIG_ENDIAN)\n \t\tn_ptr = &n1;\n \t      else\n \t\tn_ptr = &n2;\n-\t      for (i = 0; i < sizeof (int64_t); i++, inc <<= 8,\n-\t\t   mask <<= 8)\n+\t      for (i = 0; i < size; i++, inc <<= BITS_PER_MARKER,\n+\t\t\t\t\t mask <<= BITS_PER_MARKER)\n \t\t{\n \t\t  if (n_ptr->n & mask)\n \t\t    n_ptr->n += inc;\n@@ -2021,7 +2028,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  n->bytepos = n1.bytepos;\n \t  n->type = n1.type;\n \t  size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n-\t  for (i = 0, mask = 0xff; i < size; i++, mask <<= BITS_PER_UNIT)\n+\t  for (i = 0, mask = 0xff; i < size; i++, mask <<= BITS_PER_MARKER)\n \t    {\n \t      uint64_t masked1, masked2;\n \n@@ -2082,17 +2089,17 @@ find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n       int rsize;\n       uint64_t tmpn;\n \n-      for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_UNIT, rsize++);\n+      for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_MARKER, rsize++);\n       n->range = rsize;\n     }\n \n   /* Zero out the extra bits of N and CMP*.  */\n-  if (n->range < (int)sizeof (int64_t))\n+  if (n->range < (int) sizeof (int64_t))\n     {\n       uint64_t mask;\n \n-      mask = ((uint64_t)1 << (n->range * BITS_PER_UNIT)) - 1;\n-      cmpxchg >>= (sizeof (int64_t) - n->range) * BITS_PER_UNIT;\n+      mask = ((uint64_t) 1 << (n->range * BITS_PER_MARKER)) - 1;\n+      cmpxchg >>= (64 / BITS_PER_MARKER - n->range) * BITS_PER_MARKER;\n       cmpnop &= mask;\n     }\n "}]}