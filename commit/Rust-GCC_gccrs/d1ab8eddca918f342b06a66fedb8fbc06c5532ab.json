{"sha": "d1ab8eddca918f342b06a66fedb8fbc06c5532ab", "node_id": "C_kwDOANBUbNoAKGQxYWI4ZWRkY2E5MThmMzQyYjA2YTY2ZmVkYjhmYmMwNmM1NTMyYWI", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-03T14:30:22Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-12-06T13:58:48Z"}, "message": "ada: Use larger type for membership test of universal value\n\nWhen a membership test is applied to a nonstatic expression of a universal\ntype, for example an attribute whose type is universal_integer and whose\nprefix is not static, the operation is performed using the tested type that\nis determined by the choice list.  In particular, a check that the value of\nthe expression lies in the range of the tested type may be generated before\nthe test is actually performed.\n\nThis goes against the spirit of membership tests, which are typically used\nto guard a specific operation and ought not to fail a check in doing so.\n\nTherefore the resolution of the operands of membership tests is changed in\nthis case to use the universal type instead of the tested type. The final\ncomputation of the type used to actually perform the test is left to the\nexpander, which already has the appropriate circuitry.\n\nThis nevertheless requires fixing an irregularity in the expansion of the\nsubtype_mark form of membership tests, which was dependent on the presence\nof predicates for the subtype; the confusing name of a routine used by this\nexpansion is also changed in the process.\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_In) <Substitute_Valid_Check>: Rename to...\n\t<Substitute_Valid_Test>: ...this.\n\tUse Is_Entity_Name to test for the presence of entity references.\n\tDo not warn or substitute a valid test for a test with a mark for\n\ta subtype that is predicated.\n\tApply the same transformation for a test with a mark for a subtype\n\tthat is predicated as for a subtype that is not.\n\tRemove useless return statement.\n\t* sem_res.adb (Resolve_Membership_Op): Perform a special resolution\n\tif the left operand is of a universal numeric type.", "tree": {"sha": "b7d9e0f6b0e6d09fa2bf84689db9ac3f295c1c6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7d9e0f6b0e6d09fa2bf84689db9ac3f295c1c6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1ab8eddca918f342b06a66fedb8fbc06c5532ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ab8eddca918f342b06a66fedb8fbc06c5532ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1ab8eddca918f342b06a66fedb8fbc06c5532ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ab8eddca918f342b06a66fedb8fbc06c5532ab/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f459afaa679956df1f3c0243a87583e4d4b43a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f459afaa679956df1f3c0243a87583e4d4b43a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f459afaa679956df1f3c0243a87583e4d4b43a2e"}], "stats": {"total": 139, "additions": 106, "deletions": 33}, "files": [{"sha": "7edef4c39c3f65a65b20498ade39cdeb44a2a191", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 60, "deletions": 33, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ab8eddca918f342b06a66fedb8fbc06c5532ab/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ab8eddca918f342b06a66fedb8fbc06c5532ab/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d1ab8eddca918f342b06a66fedb8fbc06c5532ab", "patch": "@@ -6454,15 +6454,15 @@ package body Exp_Ch4 is\n       Rop    : constant Node_Id    := Right_Opnd (N);\n       Static : constant Boolean    := Is_OK_Static_Expression (N);\n \n-      procedure Substitute_Valid_Check;\n+      procedure Substitute_Valid_Test;\n       --  Replaces node N by Lop'Valid. This is done when we have an explicit\n       --  test for the left operand being in range of its subtype.\n \n-      ----------------------------\n-      -- Substitute_Valid_Check --\n-      ----------------------------\n+      ---------------------------\n+      -- Substitute_Valid_Test --\n+      ---------------------------\n \n-      procedure Substitute_Valid_Check is\n+      procedure Substitute_Valid_Test is\n          function Is_OK_Object_Reference (Nod : Node_Id) return Boolean;\n          --  Determine whether arbitrary node Nod denotes a source object that\n          --  may safely act as prefix of attribute 'Valid.\n@@ -6502,7 +6502,7 @@ package body Exp_Ch4 is\n             return False;\n          end Is_OK_Object_Reference;\n \n-      --  Start of processing for Substitute_Valid_Check\n+      --  Start of processing for Substitute_Valid_Test\n \n       begin\n          Rewrite (N,\n@@ -6526,7 +6526,7 @@ package body Exp_Ch4 is\n             Error_Msg_N -- CODEFIX\n               (\"\\??use ''Valid attribute instead\", N);\n          end if;\n-      end Substitute_Valid_Check;\n+      end Substitute_Valid_Test;\n \n       --  Local variables\n \n@@ -6579,15 +6579,15 @@ package body Exp_Ch4 is\n         --  eliminates the cases where MINIMIZED/ELIMINATED mode overflow\n         --  checks have changed the type of the left operand.\n \n-        and then Nkind (Rop) in N_Has_Entity\n+        and then Is_Entity_Name (Rop)\n         and then Ltyp = Entity (Rop)\n \n         --  Skip this for predicated types, where such expressions are a\n         --  reasonable way of testing if something meets the predicate.\n \n         and then No (Predicate_Function (Ltyp))\n       then\n-         Substitute_Valid_Check;\n+         Substitute_Valid_Test;\n          return;\n       end if;\n \n@@ -6605,48 +6605,60 @@ package body Exp_Ch4 is\n             Lo : constant Node_Id := Low_Bound (Rop);\n             Hi : constant Node_Id := High_Bound (Rop);\n \n-            Lo_Orig : constant Node_Id := Original_Node (Lo);\n-            Hi_Orig : constant Node_Id := Original_Node (Hi);\n-\n-            Lcheck : Compare_Result;\n-            Ucheck : Compare_Result;\n+            Lo_Orig  : constant Node_Id := Original_Node (Lo);\n+            Hi_Orig  : constant Node_Id := Original_Node (Hi);\n+            Rop_Orig : constant Node_Id := Original_Node (Rop);\n+\n+            Comes_From_Simple_Range_In_Source : constant Boolean :=\n+              Comes_From_Source (N)\n+                and then not\n+                  (Is_Entity_Name (Rop_Orig)\n+                    and then Is_Type (Entity (Rop_Orig))\n+                    and then Present (Predicate_Function (Entity (Rop_Orig))));\n+            --  This is true for a membership test present in the source with a\n+            --  range or mark for a subtype that is not predicated. As already\n+            --  explained a few lines above, we do not want to give warnings on\n+            --  a test with a mark for a subtype that is predicated.\n \n             Warn : constant Boolean :=\n                       Constant_Condition_Warnings\n-                        and then Comes_From_Source (N)\n+                        and then Comes_From_Simple_Range_In_Source\n                         and then not In_Instance;\n             --  This must be true for any of the optimization warnings, we\n             --  clearly want to give them only for source with the flag on. We\n             --  also skip these warnings in an instance since it may be the\n             --  case that different instantiations have different ranges.\n \n+            Lcheck : Compare_Result;\n+            Ucheck : Compare_Result;\n+\n          begin\n-            --  If test is explicit x'First .. x'Last, replace by valid check\n+            --  If test is explicit x'First .. x'Last, replace by 'Valid test\n \n             if Is_Scalar_Type (Ltyp)\n \n+              --  Only relevant for source comparisons\n+\n+              and then Comes_From_Simple_Range_In_Source\n+\n               --  And left operand is X'First where X matches left operand\n               --  type (this eliminates cases of type mismatch, including\n               --  the cases where ELIMINATED/MINIMIZED mode has changed the\n               --  type of the left operand.\n \n               and then Nkind (Lo_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Lo_Orig) = Name_First\n-              and then Nkind (Prefix (Lo_Orig)) in N_Has_Entity\n+              and then Is_Entity_Name (Prefix (Lo_Orig))\n               and then Entity (Prefix (Lo_Orig)) = Ltyp\n \n               --  Same tests for right operand\n \n               and then Nkind (Hi_Orig) = N_Attribute_Reference\n               and then Attribute_Name (Hi_Orig) = Name_Last\n-              and then Nkind (Prefix (Hi_Orig)) in N_Has_Entity\n+              and then Is_Entity_Name (Prefix (Hi_Orig))\n               and then Entity (Prefix (Hi_Orig)) = Ltyp\n-\n-              --  Relevant only for source cases\n-\n-              and then Comes_From_Source (N)\n             then\n-               Substitute_Valid_Check;\n+               Substitute_Valid_Test;\n                goto Leave;\n             end if;\n \n@@ -6655,7 +6667,7 @@ package body Exp_Ch4 is\n             --  for substituting a valid test. We only do this for discrete\n             --  types, since it won't arise in practice for float types.\n \n-            if Comes_From_Source (N)\n+            if Comes_From_Simple_Range_In_Source\n               and then Is_Discrete_Type (Ltyp)\n               and then Compile_Time_Known_Value (Type_High_Bound (Ltyp))\n               and then Compile_Time_Known_Value (Type_Low_Bound  (Ltyp))\n@@ -6668,7 +6680,7 @@ package body Exp_Ch4 is\n               --  have a test in the generic that makes sense with some types\n               --  and not with other types.\n \n-              --  Similarly, do not rewrite membership as a validity check if\n+              --  Similarly, do not rewrite membership as a 'Valid test if\n               --  within the predicate function for the type.\n \n               --  Finally, if the original bounds are type conversions, even\n@@ -6688,7 +6700,7 @@ package body Exp_Ch4 is\n                   null;\n \n                else\n-                  Substitute_Valid_Check;\n+                  Substitute_Valid_Test;\n                   goto Leave;\n                end if;\n             end if;\n@@ -6823,12 +6835,12 @@ package body Exp_Ch4 is\n                goto Leave;\n \n             --  If type is scalar type, rewrite as x in t'First .. t'Last.\n-            --  This reason we do this is that the bounds may have the wrong\n+            --  The reason we do this is that the bounds may have the wrong\n             --  type if they come from the original type definition. Also this\n             --  way we get all the processing above for an explicit range.\n \n-            --  Don't do this for predicated types, since in this case we\n-            --  want to check the predicate.\n+            --  Don't do this for predicated types, since in this case we want\n+            --  to generate the predicate check at the end of the function.\n \n             elsif Is_Scalar_Type (Typ) then\n                if No (Predicate_Function (Typ)) then\n@@ -6843,6 +6855,7 @@ package body Exp_Ch4 is\n                         Make_Attribute_Reference (Loc,\n                           Attribute_Name => Name_Last,\n                           Prefix         => New_Occurrence_Of (Typ, Loc))));\n+\n                   Analyze_And_Resolve (N, Restyp);\n                end if;\n \n@@ -7150,6 +7163,24 @@ package body Exp_Ch4 is\n            and then Current_Scope /= PFunc\n            and then Nkind (Rop) /= N_Range\n          then\n+            --  First apply the transformation that was skipped above\n+\n+            if Is_Scalar_Type (Rtyp) then\n+               Rewrite (Rop,\n+                 Make_Range (Loc,\n+                   Low_Bound =>\n+                     Make_Attribute_Reference (Loc,\n+                       Attribute_Name => Name_First,\n+                       Prefix         => New_Occurrence_Of (Rtyp, Loc)),\n+\n+                   High_Bound =>\n+                     Make_Attribute_Reference (Loc,\n+                       Attribute_Name => Name_Last,\n+                       Prefix         => New_Occurrence_Of (Rtyp, Loc))));\n+\n+               Analyze_And_Resolve (N, Restyp);\n+            end if;\n+\n             if not In_Range_Check then\n                --  Indicate via Static_Mem parameter that this predicate\n                --  evaluation is for a membership test.\n@@ -7169,10 +7200,6 @@ package body Exp_Ch4 is\n \n             Set_Analyzed (Left_Opnd (N));\n             Analyze_And_Resolve (N, Standard_Boolean, Suppress => All_Checks);\n-\n-            --  All done, skip attempt at compile time determination of result\n-\n-            return;\n          end if;\n       end Predicate_Check;\n    end Expand_N_In;"}, {"sha": "3574afd19ace025df9b4955ad2437ad93cadd02a", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ab8eddca918f342b06a66fedb8fbc06c5532ab/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ab8eddca918f342b06a66fedb8fbc06c5532ab/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d1ab8eddca918f342b06a66fedb8fbc06c5532ab", "patch": "@@ -10105,6 +10105,51 @@ package body Sem_Res is\n       then\n          T := Etype (R);\n \n+      --  If the left operand is of a universal numeric type and the right\n+      --  operand is not, we do not resolve the operands to the tested type\n+      --  but to the universal type instead. If not conforming to the letter,\n+      --  it's conforming to the spirit of the specification of membership\n+      --  tests, which are typically used to guard a specific operation and\n+      --  ought not to fail a check in doing so. Without this, in the case of\n+\n+      --    type Small_Length is range 1 .. 16;\n+\n+      --    function Is_Small_String (S : String) return Boolean is\n+      --    begin\n+      --      return S'Length in Small_Length;\n+      --    end;\n+\n+      --   the function Is_Small_String would fail a range check for strings\n+      --   larger than 127 characters.\n+\n+      elsif not Is_Overloaded (L)\n+        and then Is_Universal_Numeric_Type (Etype (L))\n+        and then (Is_Overloaded (R)\n+                   or else not Is_Universal_Numeric_Type (Etype (R)))\n+      then\n+         T := Etype (L);\n+\n+         --  If the right operand is 'Range, we first need to resolve it (to\n+         --  the tested type) so that it is rewritten as an N_Range, before\n+         --  converting its bounds and resolving it again below.\n+\n+         if Nkind (R) = N_Attribute_Reference\n+           and then Attribute_Name (R) = Name_Range\n+         then\n+            Resolve (R);\n+         end if;\n+\n+         --  If the right operand is an N_Range, we convert its bounds to the\n+         --  universal type before resolving it.\n+\n+         if Nkind (R) = N_Range then\n+            Rewrite (R,\n+              Make_Range (Sloc (R),\n+                Low_Bound  => Convert_To (T, Low_Bound (R)),\n+                High_Bound => Convert_To (T, High_Bound (R))));\n+            Analyze (R);\n+         end if;\n+\n       --  Ada 2005 (AI-251): Support the following case:\n \n       --      type I is interface;\n@@ -10124,6 +10169,7 @@ package body Sem_Res is\n         and then not Is_Interface (Etype (R))\n       then\n          return;\n+\n       else\n          T := Intersect_Types (L, R);\n       end if;"}]}