{"sha": "b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgwY2NhN2I0NzMyNWY4YzQ2ZDZmMzVjMGE1ZDdhYTE3YTI4ZTdjNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-05-23T05:53:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-05-23T05:53:21Z"}, "message": "tree-vrp.c (avoid_overflow_infinity): New static function, broken out of set_value_range_to_value.\n\n\t* tree-vrp.c (avoid_overflow_infinity): New static function,\n\tbroken out of set_value_range_to_value.\n\t(set_value_range_to_value): Call avoid_overflow_infinity.\n\t(extract_range_from_assert): Likewise.\n\nFrom-SVN: r124981", "tree": {"sha": "1980beba6fedbc0a5a4d5ca82a97a041f1f61a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1980beba6fedbc0a5a4d5ca82a97a041f1f61a73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5/comments", "author": null, "committer": null, "parents": [{"sha": "24016fdb16333fbe2a6fa54ab02828d8121cfe52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24016fdb16333fbe2a6fa54ab02828d8121cfe52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24016fdb16333fbe2a6fa54ab02828d8121cfe52"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "ab1dc587a2ad6b3af5d4d2ddd69273114aab189a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5", "patch": "@@ -1,3 +1,10 @@\n+2007-05-22  Ian Lance Taylor  <iant@google.com>\n+\n+\t* tree-vrp.c (avoid_overflow_infinity): New static function,\n+\tbroken out of set_value_range_to_value.\n+\t(set_value_range_to_value): Call avoid_overflow_infinity.\n+\t(extract_range_from_assert): Likewise.\n+\n 2007-05-22  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR middle-end/31095"}, {"sha": "dda5dd18cb06afaec84b619693e614c6cc431292", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b80cca7b47325f8c46d6f35c0a5d7aa17a28e7c5", "patch": "@@ -201,6 +201,27 @@ is_overflow_infinity (tree val)\n \t      || operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0)));\n }\n \n+/* If VAL is now an overflow infinity, return VAL.  Otherwise, return\n+   the same value with TREE_OVERFLOW clear.  This can be used to avoid\n+   confusing a regular value with an overflow value.  */\n+\n+static inline tree\n+avoid_overflow_infinity (tree val)\n+{\n+  if (!is_overflow_infinity (val))\n+    return val;\n+\n+  if (operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0))\n+    return TYPE_MAX_VALUE (TREE_TYPE (val));\n+  else\n+    {\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (operand_equal_p (val, TYPE_MIN_VALUE (TREE_TYPE (val)), 0));\n+#endif\n+      return TYPE_MIN_VALUE (TREE_TYPE (val));\n+    }\n+}\n+\n \n /* Return whether VAL is equal to the maximum value of its type.  This\n    will be true for a positive overflow infinity.  We can't do a\n@@ -361,19 +382,7 @@ static inline void\n set_value_range_to_value (value_range_t *vr, tree val, bitmap equiv)\n {\n   gcc_assert (is_gimple_min_invariant (val));\n-  if (is_overflow_infinity (val))\n-    {\n-      if (operand_equal_p (val, TYPE_MAX_VALUE (TREE_TYPE (val)), 0))\n-\tval = TYPE_MAX_VALUE (TREE_TYPE (val));\n-      else\n-\t{\n-#ifdef ENABLE_CHECKING\n-\t  gcc_assert (operand_equal_p (val,\n-\t\t\t\t       TYPE_MIN_VALUE (TREE_TYPE (val)), 0));\n-#endif\n-\t  val = TYPE_MIN_VALUE (TREE_TYPE (val));\n-\t}\n-    }\n+  val = avoid_overflow_infinity (val);\n   set_value_range (vr, VR_RANGE, val, val, equiv);\n }\n \n@@ -1103,6 +1112,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       cond_code = swap_tree_comparison (TREE_CODE (cond));\n     }\n \n+  limit = avoid_overflow_infinity (limit);\n+\n   type = TREE_TYPE (limit);\n   gcc_assert (limit != var);\n "}]}