{"sha": "051664b06948af35f87a68332931d5edb5d33f76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxNjY0YjA2OTQ4YWYzNWY4N2E2ODMzMjkzMWQ1ZWRiNWQzM2Y3Ng==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-06-23T03:58:44Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-06-23T03:58:44Z"}, "message": "in include/ChangeLog:\n\n\t* dyn-string.h (dyn_string_init, dyn_string_new,\n\tdyn_string_delete, dyn_string_release, dyn_string_resize,\n\tdyn_string_clear, dyn_string_copy, dyn_string_copy_cstr,\n\tdyn_string_prepend, dyn_string_prepend_cstr, dyn_string_insert,\n\tdyn_string_insert_cstr, dyn_string_append, dyn_string_append_cstr,\n\tdyn_string_append_char, dyn_string_substring_dyn_string_eq):\n\tDefine as same name with __cxa_ prepended, if IN_LIBGCC2.\n\t(dyn_string_init, dyn_string_copy, dyn_string_copy_cstr,\n\tdyn_string_prepend, dyn_string_prepend_cstr, dyn_string_insert,\n\tdyn_string_insert_cstr, dyn_string_append, dyn_string_append_cstr,\n\tdyn_string_append_char, dyn_string_substring): Change return type\n\tto int.\n\nin libiberty/ChangeLog:\n\n\t* cp-demangle.c: Don't include ctype.h.\n\t(IS_DIGIT): New macro.\n\t(IS_ALPHA): Likewise.  Use IS_DIGIT and IS_ALPHA throughout\n\tinstead of isdigit and isalpanum.\n\t(demangling_def): Make name and next const pointers.\n\t(STATUS_ALLOCATION_FAILED): New status code.\n\t(dyn_string_append_space): Handle failure in\n\tdyn_string_append_char.\n\t(int_to_dyn_string): Likewise.  Change return value to status_t.\n\t(string_list_new): Handle failure of dyn_string_init.\n\t(result_close_template_list): Change return type to status_t.\n\tHandle failure in dyn_string_append.\n\t(result_push): Change return value to status_t.  Handle failure in\n\tstring_list_new.  Handle failure of result_push throughout.\n\t(substitution_add): Change return value to status_t.  Handle\n\tdyn_string failures.  Handle failure of substitution_add\n\tthroughout.\n\t(template_arg_list_new): Return NULL on allocation failure.\n\t(result_append_string): Return STATUS_ALLOCATION_FAILED on error.\n\tHandle error result throughout.\n\t(result_append): Likewise.\n\t(result_append_char): Likewise.\n\t(result_append_space): Likewise.\n\t(demangling_new): Make argument a const pointer.  Handle\n\tallocation failures.\n\t(demangle_template_args): Handle failure in template_arg_list_new\n\tand result_close_template_list.\n\t(demangle_discriminator): Return if int_to_dyn_string fails.\n\t(cp_demangle): Likewise.\n\t(cp_demangle_type): New function.\n\t(cplus_demangle_new_abi): Don't call dyn_string_delete.  Abort on\n\tmemory allocation failure.\n\t(main): Likewise.\n\t* dyn-string.c (RETURN_ON_ALLOCATION_FAILURE): Define if\n\tIN_LIBGCC2.\n\t(dyn_string_init): Change return value to int.  Handle\n\tRETURN_ON_ALLOCATION_FAILURE case.\n\t(dyn_string_new): Handle RETURN_ON_ALLOCATION_FAILURE case.\n\t(dyn_string_release): Delete the dyn_string.\n\t(dyn_string_resize): Handle RETURN_ON_ALLOCATION_FAILURE case.\n\t(dyn_string_copy): Change return type to int.\n\t(dyn_string_copy_cstr): Likewise.\n\t(dyn_string_prepend): Likewise.\n\t(dyn_string_prepend_cstr): Likewise.\n\t(dyn_string_insert): Likewise.\n\t(dyn_string_insert_cstr): Likewise.\n\t(dyn_string_append): Likewise.\n\t(dyn_string_append_cstr): Likewise.\n\t(dyn_string_append_char): Likewise.\n\t(dyn_string_substring): Likewise.\n\nin gcc/cp/ChangeLog:\n\n\t* Make-lang.in (CXX_LIB2FUNCS): Add cp-demangle.o and dyn-string.o.\n\t(CXX_LIB2SRCS): Add cp-demangle.c and dyn-string.c.\n\t(cp-demangle.o): New rule.\n\t(dyn-string.o): Likewise.\n\t* inc/cxxabi.h (__cxa_demangle): New declaration.\n\nFrom-SVN: r34657", "tree": {"sha": "05629f3ad35fc30f6e539559e8930fae5517a8a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05629f3ad35fc30f6e539559e8930fae5517a8a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051664b06948af35f87a68332931d5edb5d33f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051664b06948af35f87a68332931d5edb5d33f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051664b06948af35f87a68332931d5edb5d33f76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051664b06948af35f87a68332931d5edb5d33f76/comments", "author": null, "committer": null, "parents": [{"sha": "31f8e4f306e9ef25c534afb1601fb9547801ae90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f8e4f306e9ef25c534afb1601fb9547801ae90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31f8e4f306e9ef25c534afb1601fb9547801ae90"}], "stats": {"total": 1217, "additions": 895, "deletions": 322}, "files": [{"sha": "71cad2a0d0fe7198d7439286fa8a34ee0b7d8c46", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -1,3 +1,11 @@\n+2000-06-21  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* Make-lang.in (CXX_LIB2FUNCS): Add cp-demangle.o and dyn-string.o.\n+\t(CXX_LIB2SRCS): Add cp-demangle.c and dyn-string.c.\n+\t(cp-demangle.o): New rule.\n+\t(dyn-string.o): Likewise.\n+\t* inc/cxxabi.h (__cxa_demangle): New declaration.\n+\n 2000-06-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (BV_USE_VCALL_INDEX_P): New macro."}, {"sha": "91a1a548eed884e6a6dc87a9f176576da507f38d", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -62,10 +62,13 @@ CXX_EXTRA_HEADERS = $(srcdir)/cp/inc/typeinfo $(srcdir)/cp/inc/exception \\\n \n # Extra code to include in libgcc2.\n CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o opnew.o opnewnt.o opvnew.o opvnewnt.o \\\n-\topdel.o opdelnt.o opvdel.o opvdelnt.o exception.o vec.o\n+\topdel.o opdelnt.o opvdel.o opvdelnt.o exception.o vec.o \\\n+\tcp-demangle.o dyn-string.o\n CXX_LIB2SRCS = $(srcdir)/cp/new.cc $(srcdir)/cp/new1.cc $(srcdir)/cp/new2.cc \\\n \t$(srcdir)/cp/exception.cc $(srcdir)/cp/tinfo.cc \\\n-\t$(srcdir)/cp/tinfo2.cc $(srcdir)/cp/tinfo.h\n+\t$(srcdir)/cp/tinfo2.cc $(srcdir)/cp/tinfo.h \\\n+\t$(srcdir)/../libiberty/cp-demangle.c \\\n+\t$(srcdir)/../libiberty/dyn-string.c\n #\f\n # Define the names for selecting c++ in LANGUAGES.\n # Note that it would be nice to move the dependency on g++\n@@ -178,6 +181,14 @@ opvdelnt.o: cc1plus$(exeext) $(srcdir)/cp/new2.cc\n vec.o: cc1plus$(exeext) $(srcdir)/cp/vec.cc\n \t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(GXX_ABI_FLAG) $(CXXFLAGS) $(INCLUDES) \\\n \t  -c $(srcdir)/cp/vec.cc -o vec.o\n+cp-demangle.o: $(srcdir)/../libiberty/cp-demangle.c\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(CFLAGS) $(INCLUDES) \\\n+\t -DHAVE_CONFIG_H \\\n+         -c $(srcdir)/../libiberty/cp-demangle.c -o cp-demangle.o\n+dyn-string.o: $(srcdir)/../libiberty/dyn-string.c\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(CFLAGS) $(INCLUDES) \\\n+\t -DHAVE_CONFIG_H \\\n+\t -c $(srcdir)/../libiberty/dyn-string.c -o dyn-string.o\n \n # We want to update cplib2.txt if any of the source files change...\n cplib2.txt: $(CXX_LIB2SRCS) $(CXX_EXTRA_HEADERS)"}, {"sha": "8987b6d4196a29a0afc4053d045c1e1711ad2c67", "filename": "gcc/cp/inc/cxxabi.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -459,6 +459,14 @@ void __cxa_vec_delete (void *__array_address,\n                        __SIZE_TYPE__ __padding_size,\n                        void (*__destructor) (void *));\n \n+/* demangling routines */\n+\n+extern \"C\" \n+char *__cxa_demangle (const char *__mangled_name,\n+\t\t      char *__output_buffer,\n+\t\t      __SIZE_TYPE__ *__length,\n+\t\t      int *__status);\n+\n } /* namespace __cxxabiv1 */\n \n /* User programs should use the alias `abi'. */"}, {"sha": "3c0e92dc4164fd29ed014f86a299b45244bfd7b6", "filename": "include/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -1,3 +1,18 @@\n+2000-06-21  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* dyn-string.h (dyn_string_init, dyn_string_new,\n+\tdyn_string_delete, dyn_string_release, dyn_string_resize,\n+\tdyn_string_clear, dyn_string_copy, dyn_string_copy_cstr,\n+\tdyn_string_prepend, dyn_string_prepend_cstr, dyn_string_insert,\n+\tdyn_string_insert_cstr, dyn_string_append, dyn_string_append_cstr,\n+\tdyn_string_append_char, dyn_string_substring_dyn_string_eq):\n+\tDefine as same name with __cxa_ prepended, if IN_LIBGCC2.\n+\t(dyn_string_init, dyn_string_copy, dyn_string_copy_cstr,\n+\tdyn_string_prepend, dyn_string_prepend_cstr, dyn_string_insert,\n+\tdyn_string_insert_cstr, dyn_string_append, dyn_string_append_cstr,\n+\tdyn_string_append_char, dyn_string_substring): Change return type\n+\tto int.\n+\t\n 2000-06-07  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* demangle.h (demangling_styles): Remove trailing comma in enum."}, {"sha": "103f9472538f24508c05fdce92c58c1a7e69b946", "filename": "include/dyn-string.h", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/include%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/include%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdyn-string.h?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -40,25 +40,53 @@ typedef struct dyn_string\n   (strcmp ((DS1)->s, (DS2)->s))\n \n \n-extern void dyn_string_init             PARAMS ((struct dyn_string *, int));\n+/* dyn_string functions are used in the demangling implementation\n+   included in the G++ runtime library.  To prevent collisions with\n+   names in user programs, the functions that are used in the\n+   demangler are given implementation-reserved names.  */\n+\n+#ifdef IN_LIBGCC2\n+\n+#define dyn_string_init                 __cxa_dyn_string_init\n+#define dyn_string_new                  __cxa_dyn_string_new\n+#define dyn_string_delete               __cxa_dyn_string_delete\n+#define dyn_string_release              __cxa_dyn_string_release\n+#define dyn_string_resize               __cxa_dyn_string_resize\n+#define dyn_string_clear                __cxa_dyn_string_clear\n+#define dyn_string_copy                 __cxa_dyn_string_copy\n+#define dyn_string_copy_cstr            __cxa_dyn_string_copy_cstr\n+#define dyn_string_prepend              __cxa_dyn_string_prepend\n+#define dyn_string_prepend_cstr         __cxa_dyn_string_prepend_cstr\n+#define dyn_string_insert               __cxa_dyn_string_insert\n+#define dyn_string_insert_cstr          __cxa_dyn_string_insert_cstr\n+#define dyn_string_append               __cxa_dyn_string_append\n+#define dyn_string_append_cstr          __cxa_dyn_string_append_cstr\n+#define dyn_string_append_char          __cxa_dyn_string_append_char\n+#define dyn_string_substring            __cxa_dyn_string_substring\n+#define dyn_string_eq                   __cxa_dyn_string_eq\n+\n+#endif /* IN_LIBGCC2 */\n+\n+\n+extern int dyn_string_init              PARAMS ((struct dyn_string *, int));\n extern dyn_string_t dyn_string_new      PARAMS ((int));\n extern void dyn_string_delete           PARAMS ((dyn_string_t));\n extern char *dyn_string_release         PARAMS ((dyn_string_t));\n extern dyn_string_t dyn_string_resize   PARAMS ((dyn_string_t, int));\n extern void dyn_string_clear            PARAMS ((dyn_string_t));\n-extern void dyn_string_copy             PARAMS ((dyn_string_t, dyn_string_t));\n-extern void dyn_string_copy_cstr        PARAMS ((dyn_string_t, const char *));\n-extern void dyn_string_prepend          PARAMS ((dyn_string_t, dyn_string_t));\n-extern void dyn_string_prepend_cstr     PARAMS ((dyn_string_t, const char *));\n-extern void dyn_string_insert           PARAMS ((dyn_string_t, int,\n+extern int dyn_string_copy              PARAMS ((dyn_string_t, dyn_string_t));\n+extern int dyn_string_copy_cstr         PARAMS ((dyn_string_t, const char *));\n+extern int dyn_string_prepend           PARAMS ((dyn_string_t, dyn_string_t));\n+extern int dyn_string_prepend_cstr      PARAMS ((dyn_string_t, const char *));\n+extern int dyn_string_insert            PARAMS ((dyn_string_t, int,\n \t\t\t\t\t\t dyn_string_t));\n-extern void dyn_string_insert_cstr      PARAMS ((dyn_string_t, int,\n+extern int dyn_string_insert_cstr       PARAMS ((dyn_string_t, int,\n \t\t\t\t\t\t const char *));\n-extern dyn_string_t dyn_string_append   PARAMS ((dyn_string_t, dyn_string_t));\n-extern dyn_string_t dyn_string_append_cstr   \n+extern int dyn_string_append            PARAMS ((dyn_string_t, dyn_string_t));\n+extern int dyn_string_append_cstr   \n                                         PARAMS ((dyn_string_t, const char *));\n-extern dyn_string_t dyn_string_append_char\n+extern int dyn_string_append_char\n                                         PARAMS ((dyn_string_t, int));\n-extern void dyn_string_substring        PARAMS ((dyn_string_t, \n+extern int dyn_string_substring         PARAMS ((dyn_string_t, \n \t\t\t\t\t\t dyn_string_t, int, int));\n extern int dyn_string_eq                PARAMS ((dyn_string_t, dyn_string_t));"}, {"sha": "5bac397881e0b82d2f88f8a48bc71cc06fdf45ea", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -1,3 +1,56 @@\n+2000-06-21  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* cp-demangle.c: Don't include ctype.h.\n+\t(IS_DIGIT): New macro.\n+\t(IS_ALPHA): Likewise.  Use IS_DIGIT and IS_ALPHA throughout\n+\tinstead of isdigit and isalpanum.\n+\t(demangling_def): Make name and next const pointers.\n+\t(STATUS_ALLOCATION_FAILED): New status code.\n+\t(dyn_string_append_space): Handle failure in\n+\tdyn_string_append_char.\n+\t(int_to_dyn_string): Likewise.  Change return value to status_t.\n+\t(string_list_new): Handle failure of dyn_string_init.\n+\t(result_close_template_list): Change return type to status_t.\n+\tHandle failure in dyn_string_append.\n+\t(result_push): Change return value to status_t.  Handle failure in\n+\tstring_list_new.  Handle failure of result_push throughout.\n+\t(substitution_add): Change return value to status_t.  Handle\n+\tdyn_string failures.  Handle failure of substitution_add\n+\tthroughout.\n+\t(template_arg_list_new): Return NULL on allocation failure.\n+\t(result_append_string): Return STATUS_ALLOCATION_FAILED on error.\n+\tHandle error result throughout.\n+\t(result_append): Likewise.\n+\t(result_append_char): Likewise.\n+\t(result_append_space): Likewise.\n+\t(demangling_new): Make argument a const pointer.  Handle\n+\tallocation failures.\n+\t(demangle_template_args): Handle failure in template_arg_list_new\n+\tand result_close_template_list.\n+\t(demangle_discriminator): Return if int_to_dyn_string fails.\n+\t(cp_demangle): Likewise.\n+\t(cp_demangle_type): New function.\n+\t(cplus_demangle_new_abi): Don't call dyn_string_delete.  Abort on\n+\tmemory allocation failure.\n+\t(main): Likewise.\n+\t* dyn-string.c (RETURN_ON_ALLOCATION_FAILURE): Define if\n+\tIN_LIBGCC2.\n+\t(dyn_string_init): Change return value to int.  Handle\n+\tRETURN_ON_ALLOCATION_FAILURE case.\n+\t(dyn_string_new): Handle RETURN_ON_ALLOCATION_FAILURE case.\n+\t(dyn_string_release): Delete the dyn_string.\n+\t(dyn_string_resize): Handle RETURN_ON_ALLOCATION_FAILURE case.\n+\t(dyn_string_copy): Change return type to int.\n+\t(dyn_string_copy_cstr): Likewise.\n+\t(dyn_string_prepend): Likewise.\n+\t(dyn_string_prepend_cstr): Likewise.\n+\t(dyn_string_insert): Likewise.\n+\t(dyn_string_insert_cstr): Likewise.\n+\t(dyn_string_append): Likewise.\n+\t(dyn_string_append_cstr): Likewise.\n+\t(dyn_string_append_char): Likewise.\n+\t(dyn_string_substring): Likewise.\n+\t\n 2000-06-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cp-demangle.c (demangle_operator_name): Add spaces before"}, {"sha": "651f7aa2704ad9181fcd9d56f101e71f21a9e341", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 622, "deletions": 248, "changes": 870, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -27,8 +27,6 @@\n #include \"config.h\"\n #endif\n \n-#include <ctype.h>\n-\n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n #endif\n@@ -47,13 +45,20 @@\n /* If CP_DEMANGLE_DEBUG is defined, a trace of the grammar evaluation,\n    and other debugging output, will be generated. */\n #ifdef CP_DEMANGLE_DEBUG\n-#define DEMANGLE_TRACE(PRODUCTION, DM) \\\n-  fprintf (stderr, \" -> %-24s at position %3d\\n\", \\\n+#define DEMANGLE_TRACE(PRODUCTION, DM)                                  \\\n+  fprintf (stderr, \" -> %-24s at position %3d\\n\",                       \\\n            (PRODUCTION), current_position (DM));\n #else\n #define DEMANGLE_TRACE(PRODUCTION, DM)\n #endif\n \n+/* Don't include <ctype.h>, to prevent additional unresolved symbols\n+   from being dragged into the C++ runtime library.  */\n+#define IS_DIGIT(CHAR) ((CHAR) >= '0' && (CHAR) <= '9')\n+#define IS_ALPHA(CHAR)                                                  \\\n+  (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \\\n+   || ((CHAR) >= 'A' && (CHAR) <= 'Z'))\n+\n /* If flag_verbose is zero, some simplifications will be made to the\n    output to make it easier to read and supress details that are\n    generally not of interest to the average C++ programmer.\n@@ -118,10 +123,10 @@ typedef struct template_arg_list_def *template_arg_list_t;\n struct demangling_def\n {\n   /* The full mangled name being mangled.  */\n-  char *name;\n+  const char *name;\n \n   /* Pointer into name at the current position.  */\n-  char *next;\n+  const char *next;\n \n   /* Stack for strings containing demangled result generated so far.\n      Text is emitted to the topmost (first) string.  */\n@@ -159,26 +164,45 @@ typedef struct demangling_def *demangling_t;\n typedef const char *status_t;\n \n /* Special values that can be used as a status_t.  */\n-#define STATUS_OK             NULL\n-#define STATUS_ERROR          \"Error.\"\n-#define STATUS_UNIMPLEMENTED  \"Unimplemented.\"\n-#define STATUS_INTERNAL_ERROR \"Internal error.\"\n+#define STATUS_OK                       NULL\n+#define STATUS_ERROR                    \"Error.\"\n+#define STATUS_UNIMPLEMENTED            \"Unimplemented.\"\n+#define STATUS_INTERNAL_ERROR           \"Internal error.\"\n+\n+/* This status code indicates a failure in malloc or realloc.  */\n+static const char* const status_allocation_failed = \"Allocation failed.\";\n+#define STATUS_ALLOCATION_FAILED        status_allocation_failed\n+\n+/* Non-zero if STATUS indicates that no error has occurred.  */\n+#define STATUS_NO_ERROR(STATUS)         ((STATUS) == STATUS_OK)\n+\n+/* Evaluate EXPR, which must produce a status_t.  If the status code\n+   indicates an error, return from the current function with that\n+   status code.  */\n+#define RETURN_IF_ERROR(EXPR)                                           \\\n+  do                                                                    \\\n+    {                                                                   \\\n+      status_t s = EXPR;                                                \\\n+      if (!STATUS_NO_ERROR (s))                                         \\\n+\treturn s;                                                       \\\n+    }                                                                   \\\n+  while (0)\n \n-static void int_to_dyn_string \n+static status_t int_to_dyn_string \n   PARAMS ((int, dyn_string_t));\n static string_list_t string_list_new\n   PARAMS ((int));\n static void string_list_delete\n   PARAMS ((string_list_t));\n-static void result_close_template_list \n+static status_t result_close_template_list \n   PARAMS ((demangling_t));\n-static void result_push\n+static status_t result_push\n   PARAMS ((demangling_t));\n static string_list_t result_pop\n   PARAMS ((demangling_t));\n static int substitution_start\n   PARAMS ((demangling_t));\n-static void substitution_add\n+static status_t substitution_add\n   PARAMS ((demangling_t, int, int, int));\n static dyn_string_t substitution_get\n   PARAMS ((demangling_t, int, int *));\n@@ -205,7 +229,7 @@ static void template_arg_list_print\n static template_arg_list_t current_template_arg_list\n   PARAMS ((demangling_t));\n static demangling_t demangling_new\n-  PARAMS ((char *));\n+  PARAMS ((const char *));\n static void demangling_delete \n   PARAMS ((demangling_t));\n \n@@ -214,15 +238,12 @@ static void demangling_delete\n   (dyn_string_buf (DS)[dyn_string_length (DS) - 1])\n \n /* Append a space character (` ') to DS if it does not already end\n-   with one.  */\n+   with one.  Evaluates to 1 on success, or 0 on allocation failure.  */\n #define dyn_string_append_space(DS)                                     \\\n-  do                                                                    \\\n-    {                                                                   \\\n-      if (dyn_string_length (DS) > 0                                    \\\n-          && dyn_string_last_char (DS) != ' ')                          \\\n-\tdyn_string_append_char ((DS), ' ');                             \\\n-    }                                                                   \\\n-  while (0)\n+      ((dyn_string_length (DS) > 0                                      \\\n+        && dyn_string_last_char (DS) != ' ')                            \\\n+       ? dyn_string_append_char ((DS), ' ')                             \\\n+       : 1)\n \n /* Returns the index of the current position in the mangled name.  */\n #define current_position(DM)    ((DM)->next - (DM)->name)\n@@ -251,15 +272,18 @@ static void demangling_delete\n \n /* Appends a dyn_string_t to the demangled result.  */\n #define result_append_string(DM, STRING)                                \\\n-  dyn_string_append (&(DM)->result->string, (STRING))\n+  (dyn_string_append (&(DM)->result->string, (STRING))                  \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n /* Appends NUL-terminated string CSTR to the demangled result.  */\n #define result_append(DM, CSTR)                                         \\\n-  dyn_string_append_cstr (&(DM)->result->string, (CSTR))\n+  (dyn_string_append_cstr (&(DM)->result->string, (CSTR))               \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n /* Appends character CHAR to the demangled result.  */\n #define result_append_char(DM, CHAR)                                    \\\n-  dyn_string_append_char (&(DM)->result->string, (CHAR))\n+  (dyn_string_append_char (&(DM)->result->string, (CHAR))               \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n /* The length of the current demangled result.  */\n #define result_length(DM)                                               \\\n@@ -268,23 +292,13 @@ static void demangling_delete\n /* Appends a space to the demangled result if the last character is\n    not a space.  */\n #define result_append_space(DM)                                         \\\n-  dyn_string_append_space (&(DM)->result->string)\n-\n-/* Evaluate EXPR, which must produce a status_t.  If the status code\n-   indicates an error, return from the current function with that\n-   status code.  */\n-#define RETURN_IF_ERROR(EXPR)                                           \\\n-  do                                                                    \\\n-    {                                                                   \\\n-      status_t s = EXPR;                                                \\\n-      if (s != STATUS_OK)                                               \\\n-\treturn s;                                                       \\\n-    }                                                                   \\\n-  while (0)\n+  (dyn_string_append_space (&(DM)->result->string)                      \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n-/* Appends a base 10 representation of VALUE to DS.  */\n+/* Appends a base 10 representation of VALUE to DS.  STATUS_OK on\n+   success.  On failure, deletes DS and returns an error code.  */\n \n-static void \n+static status_t\n int_to_dyn_string (value, ds)\n      int value;\n      dyn_string_t ds;\n@@ -295,14 +309,16 @@ int_to_dyn_string (value, ds)\n   /* Handle zero up front.  */\n   if (value == 0)\n     {\n-      dyn_string_append_char (ds, '0');\n-      return;\n+      if (!dyn_string_append_char (ds, '0'))\n+\treturn STATUS_ALLOCATION_FAILED;\n+      return STATUS_OK;\n     }\n \n   /* For negative numbers, emit a minus sign.  */\n   if (value < 0)\n     {\n-      dyn_string_append_char (ds, '-');\n+      if (!dyn_string_append_char (ds, '-'))\n+\treturn STATUS_ALLOCATION_FAILED;\n       value = -value;\n     }\n   \n@@ -318,23 +334,31 @@ int_to_dyn_string (value, ds)\n   while (mask > 0)\n     {\n       int digit = value / mask;\n-      dyn_string_append_char (ds, '0' + digit);\n+\n+      if (!dyn_string_append_char (ds, '0' + digit))\n+\treturn STATUS_ALLOCATION_FAILED;\n+\n       value -= digit * mask;\n       mask /= 10;\n     }\n+\n+  return STATUS_OK;\n }\n \n /* Creates a new string list node.  The contents of the string are\n    empty, but the initial buffer allocation is LENGTH.  The string\n-   list node should be deleted with string_list_delete.  */\n+   list node should be deleted with string_list_delete.  Returns NULL\n+   if allocation fails.  */\n \n static string_list_t \n string_list_new (length)\n      int length;\n {\n-  string_list_t s = \n-    (string_list_t) xmalloc (sizeof (struct string_list_def));\n-  dyn_string_init ((dyn_string_t) s, length);\n+  string_list_t s = (string_list_t) malloc (sizeof (struct string_list_def));\n+  if (s == NULL)\n+    return NULL;\n+  if (!dyn_string_init ((dyn_string_t) s, length))\n+    return NULL;\n   return s;\n }  \n \n@@ -357,26 +381,46 @@ string_list_delete (node)\n    first, so that the two greater-than characters don't look like a\n    right shift token.  */\n \n-static void\n+static status_t\n result_close_template_list (dm)\n      demangling_t dm;\n {\n   dyn_string_t s = &dm->result->string;\n+\n+  /* Add a space if the last character is already a closing angle\n+     bracket, so that a nested template arg list doesn't look like\n+     it's closed with a right-shift operator.  */\n   if (dyn_string_last_char (s) == '>')\n-    dyn_string_append_char (s, ' ');\n-  dyn_string_append_char (s, '>');\n+    {\n+      if (!dyn_string_append_char (s, ' '))\n+\treturn STATUS_ALLOCATION_FAILED;\n+    }\n+\n+  /* Add closing angle brackets.  */\n+  if (!dyn_string_append_char (s, '>'))\n+    return STATUS_ALLOCATION_FAILED;\n+\n+  return STATUS_OK;\n }\n \n /* Allocates and pushes a new string onto the demangled results stack\n-   for DM.  Subsequent demangling with DM will emit to the new string.  */\n+   for DM.  Subsequent demangling with DM will emit to the new string.\n+   Returns STATUS_OK on success, STATUS_ALLOCATION_FAILED on\n+   allocation failure.  */\n \n-static void\n+static status_t\n result_push (dm)\n      demangling_t dm;\n {\n   string_list_t new_string = string_list_new (0);\n+  if (new_string == NULL)\n+    /* Allocation failed.  */\n+    return STATUS_ALLOCATION_FAILED;\n+\n+  /* Link the new string to the front of the list of result strings.  */\n   new_string->next = (string_list_t) dm->result;\n   dm->result = new_string;\n+  return STATUS_OK;\n }\n \n /* Removes and returns the topmost element on the demangled results\n@@ -412,7 +456,7 @@ substitution_start (dm)\n    otherwise-identical types and other <template-param>s with\n    different indices.  */\n \n-static void\n+static status_t\n substitution_add (dm, start_position, template_p, template_parm_number)\n      demangling_t dm;\n      int start_position;\n@@ -423,8 +467,17 @@ substitution_add (dm, start_position, template_p, template_parm_number)\n   dyn_string_t substitution = dyn_string_new (0);\n   int i;\n \n-  dyn_string_substring (substitution, \n-\t\t\tresult, start_position, result_length (dm));\n+  if (substitution == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n+  /* Extract the substring of the current demangling result that\n+     represents the subsitution candidate.  */\n+  if (!dyn_string_substring (substitution, \n+\t\t\t     result, start_position, result_length (dm)))\n+    {\n+      dyn_string_delete (substitution);\n+      return STATUS_ALLOCATION_FAILED;\n+    }\n \n   /* Check whether SUBSTITUTION already occurs.  */\n   for (i = 0; i < dm->num_substitutions; ++i)\n@@ -435,17 +488,25 @@ substitution_add (dm, start_position, template_p, template_parm_number)\n \t/* Callers expect this function to take ownership of\n \t   SUBSTITUTION, so delete it.  */\n \tdyn_string_delete (substitution);\n-\treturn;\n+\treturn STATUS_OK;\n       }\n \n   /* If there's no room for the new entry, grow the array.  */\n   if (dm->substitutions_allocated == dm->num_substitutions)\n     {\n+      size_t new_array_size;\n       dm->substitutions_allocated *= 2;\n-      dm->substitutions = (struct substitution_def *) \n-\txrealloc (dm->substitutions,\n-\t\t  sizeof (struct substitution_def) \n-\t\t  * dm->substitutions_allocated);\n+      new_array_size = \n+\tsizeof (struct substitution_def) * dm->substitutions_allocated;\n+\n+      dm->substitutions = (struct substitution_def *)\n+\trealloc (dm->substitutions, new_array_size);\n+      if (dm->substitutions == NULL)\n+\t/* Realloc failed.  */\n+\t{\n+\t  dyn_string_delete (substitution);\n+\t  return STATUS_ALLOCATION_FAILED;\n+\t}\n     }\n \n   /* Add the substitution to the array.  */\n@@ -457,6 +518,8 @@ substitution_add (dm, start_position, template_p, template_parm_number)\n #ifdef CP_DEMANGLE_DEBUG\n   substitutions_print (dm, stderr);\n #endif\n+\n+  return STATUS_OK;\n }\n \n /* Returns the Nth-most-recent substitution.  Sets *TEMPLATE_P to\n@@ -509,13 +572,16 @@ substitutions_print (dm, fp)\n \n #endif /* CP_DEMANGLE_DEBUG */\n \n-/* Creates a new template argument list.  */\n+/* Creates a new template argument list.  Returns NULL if allocation\n+   fails.  */\n \n static template_arg_list_t\n template_arg_list_new ()\n {\n-  template_arg_list_t new_list \n-    = (template_arg_list_t) xmalloc (sizeof (struct template_arg_list_def));\n+  template_arg_list_t new_list =\n+    (template_arg_list_t) malloc (sizeof (struct template_arg_list_def));\n+  if (new_list == NULL)\n+    return NULL;\n   /* Initialize the new list to have no arguments.  */\n   new_list->first_argument = NULL;\n   new_list->last_argument = NULL;\n@@ -652,24 +718,34 @@ current_template_arg_list (dm)\n }\n \n /* Allocates a demangling_t object for demangling mangled NAME.  A new\n-   result must be pushed before the returned object can be used.  */\n+   result must be pushed before the returned object can be used.\n+   Returns NULL if allocation fails.  */\n \n static demangling_t\n demangling_new (name)\n-     char *name;\n+     const char *name;\n {\n-  demangling_t dm = (demangling_t) \n-    xmalloc (sizeof (struct demangling_def));\n+  demangling_t dm;\n+  dm = (demangling_t) malloc (sizeof (struct demangling_def));\n+  if (dm == NULL)\n+    return NULL;\n \n   dm->name = name;\n   dm->next = name;\n   dm->result = NULL;\n-  dm->last_source_name = dyn_string_new (0);\n   dm->num_substitutions = 0;\n   dm->substitutions_allocated = 10;\n-  dm->substitutions = (struct substitution_def *) \n-    xmalloc (dm->substitutions_allocated * sizeof (struct substitution_def));\n   dm->template_arg_lists = NULL;\n+  dm->last_source_name = dyn_string_new (0);\n+  if (dm->last_source_name == NULL)\n+    return NULL;\n+  dm->substitutions = (struct substitution_def *)\n+    malloc (dm->substitutions_allocated * sizeof (struct substitution_def));\n+  if (dm->substitutions == NULL)\n+    {\n+      dyn_string_delete (dm->last_source_name);\n+      return NULL;\n+    }\n \n   return dm;\n }\n@@ -775,7 +851,9 @@ static status_t demangle_local_name\n static status_t demangle_discriminator \n   PARAMS ((demangling_t, int));\n static status_t cp_demangle\n-  PARAMS ((char *, dyn_string_t));\n+  PARAMS ((const char *, dyn_string_t));\n+static status_t cp_demangle_type\n+  PARAMS ((const char*, dyn_string_t));\n \n /* When passed to demangle_bare_function_type, indicates that the\n    function's return type is not encoded before its parameter types.  */\n@@ -850,7 +928,7 @@ demangle_encoding (dm)\n       if (special_std_substitution)\n \t{\n \t  /* This was the magic `std::' substitution.  */\n-\t  result_append (dm, \"::\");\n+\t  RETURN_IF_ERROR (result_append (dm, \"::\"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t}\n     }\n@@ -878,7 +956,8 @@ demangle_encoding (dm)\n \t      (demangle_bare_function_type (dm, BFT_NO_RETURN_TYPE)); \n \t}\n \n-      substitution_add (dm, start, template_p, NOT_TEMPLATE_PARM);\n+      RETURN_IF_ERROR (substitution_add (dm, start, template_p, \n+\t\t\t\t\t NOT_TEMPLATE_PARM));\n     }\n \n   /* Pop off template argument lists that were built during the\n@@ -931,7 +1010,7 @@ demangle_name (dm, template_p)\n \t{\n \t  (void) next_char (dm);\n \t  (void) next_char (dm);\n-\t  result_append (dm, \"std::\");\n+\t  RETURN_IF_ERROR (result_append (dm, \"std::\"));\n \t  RETURN_IF_ERROR (demangle_unqualified_name (dm));\n \t}\n       else\n@@ -943,7 +1022,7 @@ demangle_name (dm, template_p)\n \t      /* This was the magic `std::' substitution.  We can have\n \t\t a <nested-name> or one of the unscoped names\n \t\t following.  */\n-\t      result_append (dm, \"::\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"::\"));\n \t      RETURN_IF_ERROR (demangle_name (dm, template_p));\n \t    }\n \t}\n@@ -958,7 +1037,8 @@ demangle_name (dm, template_p)\n       if (peek_char (dm) == 'I')\n \t{\n \t  /* Add a substitution for the unqualified template name.  */\n-\t  substitution_add (dm, start, 0, NOT_TEMPLATE_PARM);\n+\t  RETURN_IF_ERROR (substitution_add (dm, start, 0, \n+\t\t\t\t\t     NOT_TEMPLATE_PARM));\n \n \t  RETURN_IF_ERROR (demangle_template_args (dm));\n \t  *template_p = 1;\n@@ -990,12 +1070,18 @@ demangle_nested_name (dm, template_p)\n   peek = peek_char (dm);\n   if (peek == 'r' || peek == 'V' || peek == 'K')\n     {\n+      status_t status;\n+\n       /* Snarf up and emit CV qualifiers.  */\n       dyn_string_t cv_qualifiers = dyn_string_new (24);\n+      if (cv_qualifiers == NULL)\n+\treturn STATUS_ALLOCATION_FAILED;\n+\n       demangle_CV_qualifiers (dm, cv_qualifiers);\n-      result_append_string (dm, cv_qualifiers);\n+      status = result_append_string (dm, cv_qualifiers);\n       dyn_string_delete (cv_qualifiers);\n-      result_append_space (dm);\n+      RETURN_IF_ERROR (status);\n+      RETURN_IF_ERROR (result_append_space (dm));\n     }\n   \n   RETURN_IF_ERROR (demangle_prefix (dm, template_p));\n@@ -1043,14 +1129,14 @@ demangle_prefix (dm, template_p)\n \n       peek = peek_char (dm);\n       \n-      if (isdigit ((unsigned char) peek)\n+      if (IS_DIGIT ((unsigned char) peek)\n \t  || (peek >= 'a' && peek <= 'z')\n \t  || peek == 'C' || peek == 'D'\n \t  || peek == 'S')\n \t{\n \t  /* We have another level of scope qualification.  */\n \t  if (nested)\n-\t    result_append (dm, \"::\");\n+\t    RETURN_IF_ERROR (result_append (dm, \"::\"));\n \t  else\n \t    nested = 1;\n \n@@ -1072,7 +1158,7 @@ demangle_prefix (dm, template_p)\n \t  if (*template_p)\n \t    return STATUS_INTERNAL_ERROR;\n \t  /* The template name is a substitution candidate.  */\n-\t  substitution_add (dm, start, 0, NOT_TEMPLATE_PARM);\n+\t  RETURN_IF_ERROR (substitution_add (dm, start, 0, NOT_TEMPLATE_PARM));\n \t  RETURN_IF_ERROR (demangle_template_args (dm));\n \t  *template_p = 1;\n \t}\n@@ -1083,7 +1169,8 @@ demangle_prefix (dm, template_p)\n \treturn \"Unexpected character in <compound-name>.\";\n \n       /* Add a new substitution for the prefix thus far.  */\n-      substitution_add (dm, start, *template_p, NOT_TEMPLATE_PARM);\n+      RETURN_IF_ERROR (substitution_add (dm, start, *template_p, \n+\t\t\t\t\t NOT_TEMPLATE_PARM));\n     }\n }\n \n@@ -1104,7 +1191,7 @@ demangle_unqualified_name (dm)\n \n   DEMANGLE_TRACE (\"unqualified-name\", dm);\n \n-  if (isdigit ((unsigned char) peek))\n+  if (IS_DIGIT ((unsigned char) peek))\n     RETURN_IF_ERROR (demangle_source_name (dm));\n   else if (peek >= 'a' && peek <= 'z')\n     {\n@@ -1142,7 +1229,7 @@ demangle_source_name (dm)\n \t\t\t\t\tdm->last_source_name));\n \n   /* Emit it.  */\n-  result_append_string (dm, dm->last_source_name);\n+  RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));\n \n   return STATUS_OK;\n }\n@@ -1168,6 +1255,9 @@ demangle_number (dm, value, base, is_signed)\n \n   DEMANGLE_TRACE (\"number\", dm);\n \n+  if (number == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n   demangle_number_literally (dm, number, base, is_signed);\n   *value = strtol (dyn_string_buf (number), NULL, base);\n   dyn_string_delete (number);\n@@ -1201,17 +1291,21 @@ demangle_number_literally (dm, str, base, is_signed)\n       advance_char (dm);\n       /* The normal way to write a negative number is with a minus\n \t sign.  */\n-      dyn_string_append_char (str, '-');\n+      if (!dyn_string_append_char (str, '-'))\n+\treturn STATUS_ALLOCATION_FAILED;\n     }\n \n   /* Loop until we hit a non-digit.  */\n   while (1)\n     {\n       char peek = peek_char (dm);\n-      if (isdigit ((unsigned char) peek)\n+      if (IS_DIGIT ((unsigned char) peek)\n \t  || (base == 36 && peek >= 'A' && peek <= 'Z'))\n-\t/* Accumulate digits.  */\n-\tdyn_string_append_char (str, next_char (dm));\n+\t{\n+\t  /* Accumulate digits.  */\n+\t  if (!dyn_string_append_char (str, next_char (dm)))\n+\t    return STATUS_ALLOCATION_FAILED;\n+\t}\n       else\n \t/* Not a digit?  All done.  */\n \tbreak;\n@@ -1232,12 +1326,15 @@ demangle_identifier (dm, length, identifier)\n   DEMANGLE_TRACE (\"identifier\", dm);\n \n   dyn_string_clear (identifier);\n-  dyn_string_resize (identifier, length);\n+  if (!dyn_string_resize (identifier, length))\n+    return STATUS_ALLOCATION_FAILED;\n+\n   while (length-- > 0)\n     {\n       if (end_of_name_p (dm))\n \treturn \"Unexpected end of name in <identifier>.\";\n-      dyn_string_append_char (identifier, next_char (dm));\n+      if (!dyn_string_append_char (identifier, next_char (dm)))\n+\treturn STATUS_ALLOCATION_FAILED;\n     }\n \n   return STATUS_OK;\n@@ -1380,7 +1477,7 @@ demangle_operator_name (dm, short_name, num_args)\n   /* Is this a vendor extended operator?  */\n   if (c0 == 'v' && c1 == 'x')\n     {\n-      result_append (dm, \"operator\");\n+      RETURN_IF_ERROR (result_append (dm, \"operator\"));\n       RETURN_IF_ERROR (demangle_source_name (dm));\n       *num_args = 0;\n       return STATUS_OK;\n@@ -1389,7 +1486,7 @@ demangle_operator_name (dm, short_name, num_args)\n   /* Is this a conversion operator?  */\n   if (c0 == 'c' && c1 == 'v')\n     {\n-      result_append (dm, \"operator \");\n+      RETURN_IF_ERROR (result_append (dm, \"operator \"));\n       /* Demangle the converted-to type.  */\n       RETURN_IF_ERROR (demangle_type (dm));\n       *num_args = 0;\n@@ -1407,8 +1504,8 @@ demangle_operator_name (dm, short_name, num_args)\n \t/* Found it.  */\n \t{\n \t  if (!short_name)\n-\t    result_append (dm, \"operator\");\n-\t  result_append (dm, p->name);\n+\t    RETURN_IF_ERROR (result_append (dm, \"operator\"));\n+\t  RETURN_IF_ERROR (result_append (dm, p->name));\n \t  *num_args = p->num_args;\n \n \t  return STATUS_OK;\n@@ -1461,11 +1558,13 @@ demangle_special_name (dm)\n       /* A guard variable name.  Consume the G.  */\n       advance_char (dm);\n       RETURN_IF_ERROR (demangle_char (dm, 'V'));\n-      result_append (dm, \"guard variable for \");\n+      RETURN_IF_ERROR (result_append (dm, \"guard variable for \"));\n       RETURN_IF_ERROR (demangle_name (dm, &unused));\n     }\n   else if (peek == 'T')\n     {\n+      status_t status = STATUS_OK;\n+\n       /* Other C++ implementation miscellania.  Consume the T.  */\n       advance_char (dm);\n \n@@ -1474,96 +1573,108 @@ demangle_special_name (dm)\n \tcase 'V':\n \t  /* Virtual table.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"vtable for \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"vtable for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'T':\n \t  /* VTT structure.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"VTT for \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"VTT for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'I':\n \t  /* Typeinfo structure.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"typeinfo for \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"typeinfo for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'F':\n \t  /* Typeinfo function.  Used only in old ABI with new mangling.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"typeinfo fn for \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"typeinfo fn for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'S':\n \t  /* Character string containing type name, used in typeinfo. */\n \t  advance_char (dm);\n-\t  result_append (dm, \"typeinfo name for \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"typeinfo name for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'J':\n \t  /* The java Class variable corresponding to a C++ class.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"java Class for \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"java Class for \"));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  break;\n \n \tcase 'h':\n \t  /* Non-virtual thunk.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"non-virtual thunk\");\n+\t  RETURN_IF_ERROR (result_append (dm, \"non-virtual thunk\"));\n \t  /* Demangle and emit the offset.  */\n \t  number = dyn_string_new (4);\n+\t  if (number == NULL)\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  demangle_number_literally (dm, number, 10, 1);\n \t  /* Don't display the offset unless in verbose mode.  */\n \t  if (flag_verbose)\n \t    {\n-\t      result_append_char (dm, ' ');\n-\t      result_append_string (dm, number);\n+\t      status = result_append_char (dm, ' ');\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tstatus = result_append_string (dm, number);\n \t    }\n \t  dyn_string_delete (number);\n+\t  RETURN_IF_ERROR (status);\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the target name and function type.  */\n-\t  result_append (dm, \" to \");\n+\t  RETURN_IF_ERROR (result_append (dm, \" to \"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t  break;\n \n \tcase 'v':\n \t  /* Virtual thunk.  */\n \t  advance_char (dm);\n-\t  result_append (dm, \"virtual thunk \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"virtual thunk \"));\n \t  /* Demangle and emit the offset.  */\n \t  number = dyn_string_new (4);\n+\t  if (number == NULL)\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  demangle_number_literally (dm, number, 10, 1);\n \t  /* Don't display the offset unless in verbose mode.  */\n \t  if (flag_verbose)\n \t    {\n-\t      result_append_string (dm, number);\n-\t      result_append_char (dm, ' ');\n+\t      status = result_append_string (dm, number);\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tresult_append_char (dm, ' ');\n \t    }\n \t  dyn_string_delete (number);\n+\t  RETURN_IF_ERROR (status);\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the vcall offset.  */\n \t  number = dyn_string_new (4);\n+\t  if (number == NULL)\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  demangle_number_literally (dm, number, 10, 1);\n \t  /* Don't display the vcall offset unless in verbose mode.  */\n \t  if (flag_verbose)\n \t    {\n-\t      result_append_string (dm, number);\n-\t      result_append_char (dm, ' ');\n+\t      status = result_append_string (dm, number);\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tstatus = result_append_char (dm, ' ');\n \t    }\n \t  dyn_string_delete (number);\n+\t  RETURN_IF_ERROR (status);\n \t  /* Demangle the separator.  */\n \t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t  /* Demangle and emit the target function.  */\n-\t  result_append (dm, \"to \");\n+\t  RETURN_IF_ERROR (result_append (dm, \"to \"));\n \t  RETURN_IF_ERROR (demangle_encoding (dm));\n \t  break;\n \n@@ -1572,23 +1683,27 @@ demangle_special_name (dm)\n \t  if (!flag_strict)\n \t    {\n \t      advance_char (dm);\n-\t      result_append (dm, \"construction vtable for \");\n+\t      RETURN_IF_ERROR (result_append (dm, \"construction vtable for \"));\n \t      RETURN_IF_ERROR (demangle_type (dm));\n \t      /* Demangle the offset.  */\n \t      number = dyn_string_new (4);\n+\t      if (number == NULL)\n+\t\treturn STATUS_ALLOCATION_FAILED;\n \t      demangle_number_literally (dm, number, 10, 1);\n \t      /* Demangle the underscore separator.  */\n \t      RETURN_IF_ERROR (demangle_char (dm, '_'));\n \t      /* Demangle the base type.  */\n-\t      result_append (dm, \"-in-\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"-in-\"));\n \t      RETURN_IF_ERROR (demangle_type (dm));\n \t      /* Don't display the offset unless in verbose mode.  */\n \t      if (flag_verbose)\n \t\t{\n-\t\t  result_append_char (dm, ' ');\n-\t\t  result_append_string (dm, number);\n+\t\t  status = result_append_char (dm, ' ');\n+\t\t  if (STATUS_NO_ERROR (status))\n+\t\t    result_append_string (dm, number);\n \t\t}\n \t      dyn_string_delete (number);\n+\t      RETURN_IF_ERROR (status);\n \t      break;\n \t    }\n \t  /* If flag_strict, fall through.  */\n@@ -1643,14 +1758,14 @@ demangle_ctor_dtor_name (dm)\n       advance_char (dm);\n       if (peek_char (dm) < '1' || peek_char (dm) > '4')\n \treturn \"Unrecognized constructor.\";\n-      result_append_string (dm, dm->last_source_name);\n+      RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));\n       /* Print the flavor of the constructor if in verbose mode.  */\n       flavor = next_char (dm) - '1';\n       if (flag_verbose)\n \t{\n-\t  result_append (dm, \"[\");\n-\t  result_append (dm, ctor_flavors[flavor]);\n-\t  result_append_char (dm, ']');\n+\t  RETURN_IF_ERROR (result_append (dm, \"[\"));\n+\t  RETURN_IF_ERROR (result_append (dm, ctor_flavors[flavor]));\n+\t  RETURN_IF_ERROR (result_append_char (dm, ']'));\n \t}\n     }\n   else if (peek == 'D')\n@@ -1659,15 +1774,15 @@ demangle_ctor_dtor_name (dm)\n       advance_char (dm);\n       if (peek_char (dm) < '0' || peek_char (dm) > '2')\n \treturn \"Unrecognized destructor.\";\n-      result_append_char (dm, '~');\n-      result_append_string (dm, dm->last_source_name);\n+      RETURN_IF_ERROR (result_append_char (dm, '~'));\n+      RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));\n       /* Print the flavor of the destructor if in verbose mode.  */\n       flavor = next_char (dm) - '0';\n       if (flag_verbose)\n \t{\n-\t  result_append (dm, \" [\");\n-\t  result_append (dm, dtor_flavors[flavor]);\n-\t  result_append_char (dm, ']');\n+\t  RETURN_IF_ERROR (result_append (dm, \" [\"));\n+\t  RETURN_IF_ERROR (result_append (dm, dtor_flavors[flavor]));\n+\t  RETURN_IF_ERROR (result_append_char (dm, ']'));\n \t}\n     }\n   else\n@@ -1701,19 +1816,24 @@ demangle_type_ptr (dm)\n \n   DEMANGLE_TRACE (\"type*\", dm);\n \n+  if (symbols == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n   /* Scan forward, collecting pointers and references into symbols,\n      until we hit something else.  Then emit the type.  */\n   while (1)\n     {\n       next = peek_char (dm);\n       if (next == 'P')\n \t{\n-\t  dyn_string_append_char (symbols, '*');\n+\t  if (!dyn_string_append_char (symbols, '*'))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  advance_char (dm);\n \t}\n       else if (next == 'R')\n \t{\n-\t  dyn_string_append_char (symbols, '&');\n+\t  if (!dyn_string_append_char (symbols, '&'))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  advance_char (dm);\n \t}\n       else if (next == 'M')\n@@ -1725,14 +1845,16 @@ demangle_type_ptr (dm)\n \t  advance_char (dm);\n \n \t  /* Capture the type of which this is a pointer-to-member.  */\n-\t  result_push (dm);\n+\t  RETURN_IF_ERROR (result_push (dm));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  class_type = (dyn_string_t) result_pop (dm);\n \n \t  /* Build the pointer-to-member notation.  It comes before\n \t     other pointer and reference qualifiers -- */\n-\t  dyn_string_prepend_cstr (symbols, \"::*\");\n-\t  dyn_string_prepend (symbols, class_type);\n+\t  if (!dyn_string_prepend_cstr (symbols, \"::*\"))\n+\t    return STATUS_ALLOCATION_FAILED;\n+\t  if (!dyn_string_prepend (symbols, class_type))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  dyn_string_delete (class_type);\n \n \t  if (peek_char (dm) == 'F')\n@@ -1741,10 +1863,12 @@ demangle_type_ptr (dm)\n \t  /* Demangle the type of the pointed-to member.  */\n \t  status = demangle_type (dm);\n \t  /* Make it pretty.  */\n-\t  result_append_space (dm);\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_space (dm);\n \t  /* Add the pointer-to-member syntax, and other pointer and\n \t     reference symbols.  */\n-\t  result_append_string (dm, symbols);\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_string (dm, symbols);\n \t  /* Clean up.  */\n \t  dyn_string_delete (symbols);\n \n@@ -1755,10 +1879,13 @@ demangle_type_ptr (dm)\n \t{\n \t  /* Ooh, tricky, a pointer-to-function.  */\n \t  int position = result_length (dm);\n-\t  result_append_char (dm, '(');\n-\t  result_append_string (dm, symbols);\n-\t  result_append_char (dm, ')');\n+\t  status = result_append_char (dm, '(');\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_string (dm, symbols);\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_char (dm, ')');\n \t  dyn_string_delete (symbols);\n+\t  RETURN_IF_ERROR (status);\n \n \t  RETURN_IF_ERROR (demangle_function_type (dm, position));\n \t  return STATUS_OK;\n@@ -1768,8 +1895,10 @@ demangle_type_ptr (dm)\n \t  /* No more pointe or reference tokens.  Finish up.  */\n \t  status = demangle_type (dm);\n \n-\t  result_append_string (dm, symbols);\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_string (dm, symbols);\n \t  dyn_string_delete (symbols);\n+\t  RETURN_IF_ERROR (status);\n \n \t  RETURN_IF_ERROR (status);\n \t  return STATUS_OK;\n@@ -1809,7 +1938,7 @@ demangle_type (dm)\n \n   /* A <class-enum-type> can start with a digit (a <source-name>), an\n      N (a <nested-name>), or a Z (a <local-name>).  */\n-  if (isdigit ((unsigned char) peek) || peek == 'N' || peek == 'Z')\n+  if (IS_DIGIT ((unsigned char) peek) || peek == 'N' || peek == 'Z')\n     RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n   else if (peek >= 'a' && peek <= 'z')\n     {\n@@ -1825,22 +1954,30 @@ demangle_type (dm)\n \t{\n \t  status_t status;\n \t  dyn_string_t cv_qualifiers = dyn_string_new (24);\n+\n+\t  if (cv_qualifiers == NULL)\n+\t    return STATUS_ALLOCATION_FAILED;\n+\n \t  demangle_CV_qualifiers (dm, cv_qualifiers);\n \n \t  /* If the qualifiers apply to a pointer or reference, they\n \t     need to come after the whole qualified type.  */\n \t  if (peek_char (dm) == 'P' || peek_char (dm) == 'R')\n \t    {\n \t      status = demangle_type (dm);\n-\t      result_append_space (dm);\n-\t      result_append_string (dm, cv_qualifiers);\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tstatus = result_append_space (dm);\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tstatus = result_append_string (dm, cv_qualifiers);\n \t    }\n \t  /* Otherwise, the qualifiers come first.  */\n \t  else\n \t    {\n-\t      result_append_string (dm, cv_qualifiers);\n-\t      result_append_space (dm);\n-\t      status = demangle_type (dm);\n+\t      status = result_append_string (dm, cv_qualifiers);\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tstatus = result_append_space (dm);\n+\t      if (STATUS_NO_ERROR (status))\n+\t\tstatus = demangle_type (dm);\n \t    }\n \n \t  dyn_string_delete (cv_qualifiers);\n@@ -1866,7 +2003,7 @@ demangle_type (dm)\n \t  {\n \t    /* This was the magic `std::' substitution.  What follows\n \t       must be a class name in that namespace.  */\n-\t    result_append (dm, \"::\");\n+\t    RETURN_IF_ERROR (result_append (dm, \"::\"));\n \t    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n \t  }\n \tbreak;\n@@ -1879,14 +2016,14 @@ demangle_type (dm)\n \n       case 'C':\n \t/* A C99 complex type.  */\n-\tresult_append (dm, \"complex \");\n+\tRETURN_IF_ERROR (result_append (dm, \"complex \"));\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_type (dm));\n \tbreak;\n \n       case 'G':\n \t/* A C99 imaginary type.  */\n-\tresult_append (dm, \"imaginary \");\n+\tRETURN_IF_ERROR (result_append (dm, \"imaginary \"));\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_type (dm));\n \tbreak;\n@@ -1895,7 +2032,7 @@ demangle_type (dm)\n \t/* Vendor extended type qualifier.  */\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_source_name (dm));\n-\tresult_append_char (dm, ' ');\n+\tRETURN_IF_ERROR (result_append_char (dm, ' '));\n \tRETURN_IF_ERROR (demangle_type (dm));\n \tbreak;\n \n@@ -1909,7 +2046,7 @@ demangle_type (dm)\n        <template-param>, pass its index since from the point of\n        substitutions, a <template-param> token is a substitution\n        candidate distinct from the type that is substituted for it.  */\n-    substitution_add (dm, start, template_p, template_parm);\n+    RETURN_IF_ERROR (substitution_add (dm, start, template_p, template_parm));\n \n   /* Pop off template argument lists added during mangling of this\n      type.  */\n@@ -1996,7 +2133,7 @@ demangle_builtin_type (dm)\n       if (type_name == NULL)\n \treturn \"Unrecognized <builtin-type> code.\";\n \n-      result_append (dm, type_name);\n+      RETURN_IF_ERROR (result_append (dm, type_name));\n       advance_char (dm);\n       return STATUS_OK;\n     }\n@@ -2020,18 +2157,24 @@ demangle_CV_qualifiers (dm, qualifiers)\n       switch (peek_char (dm))\n \t{\n \tcase 'r':\n-\t  dyn_string_append_space (qualifiers);\n-\t  dyn_string_append_cstr (qualifiers, \"restrict\");\n+\t  if (!dyn_string_append_space (qualifiers))\n+\t    return STATUS_ALLOCATION_FAILED;\n+\t  if (!dyn_string_append_cstr (qualifiers, \"restrict\"))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  break;\n \n \tcase 'V':\n-\t  dyn_string_append_space (qualifiers);\n-\t  dyn_string_append_cstr (qualifiers, \"volatile\");\n+\t  if (!dyn_string_append_space (qualifiers))\n+\t    return STATUS_ALLOCATION_FAILED;\n+\t  if (!dyn_string_append_cstr (qualifiers, \"volatile\"))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  break;\n \n \tcase 'K':\n-\t  dyn_string_append_space (qualifiers);\n-\t  dyn_string_append_cstr (qualifiers, \"const\");\n+\t  if (!dyn_string_append_space (qualifiers))\n+\t    return STATUS_ALLOCATION_FAILED;\n+\t  if (!dyn_string_append_cstr (qualifiers, \"const\"))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  break;\n \n \tdefault:\n@@ -2059,7 +2202,7 @@ demangle_function_type (dm, function_name_pos)\n     {\n       /* Indicate this function has C linkage if in verbose mode.  */\n       if (flag_verbose)\n-\tresult_append (dm, \" [extern \\\"C\\\"] \");\n+\tRETURN_IF_ERROR (result_append (dm, \" [extern \\\"C\\\"] \"));\n       advance_char (dm);\n     }\n   RETURN_IF_ERROR (demangle_bare_function_type (dm, function_name_pos));\n@@ -2086,26 +2229,29 @@ demangle_bare_function_type (dm, return_type_pos)\n \n   DEMANGLE_TRACE (\"bare-function-type\", dm);\n \n-  result_append_char (dm, '(');\n+  RETURN_IF_ERROR (result_append_char (dm, '('));\n   while (!end_of_name_p (dm) && peek_char (dm) != 'E')\n     {\n       if (sequence == -1)\n \t/* We're decoding the function's return type.  */\n \t{\n \t  dyn_string_t return_type;\n+\t  status_t status = STATUS_OK;\n \n \t  /* Decode the return type off to the side.  */\n-\t  result_push (dm);\n+\t  RETURN_IF_ERROR (result_push (dm));\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t  return_type = (dyn_string_t) result_pop (dm);\n \n-\t  /* Add a space to the end of the type.  */\n-\t  dyn_string_append_space (return_type);\n+\t  /* Add a space to the end of the type.  Insert the return\n+             type where we've been asked to. */\n+\t  if (!dyn_string_append_space (return_type) \n+\t      || !dyn_string_insert (result_string (dm), return_type_pos, \n+\t\t\t\t     return_type))\n+\t    status = STATUS_ALLOCATION_FAILED;\n \n-\t  /* Insert the return type where we've been asked to.  */\n-\t  dyn_string_insert (result_string (dm), return_type_pos, \n-\t\t\t return_type);\n \t  dyn_string_delete (return_type);\n+\t  RETURN_IF_ERROR (status);\n \t}\n       else \n \t{\n@@ -2120,14 +2266,14 @@ demangle_bare_function_type (dm, return_type_pos)\n \t    }\n \t  /* Separate parameter types by commas.  */\n \t  if (sequence > 0)\n-\t    result_append (dm, \", \");\n+\t    RETURN_IF_ERROR (result_append (dm, \", \"));\n \t  /* Demangle the type.  */\n \t  RETURN_IF_ERROR (demangle_type (dm));\n \t}\n \n       ++sequence;\n     }\n-  result_append_char (dm, ')');\n+  RETURN_IF_ERROR (result_append_char (dm, ')'));\n \n   return STATUS_OK;\n }\n@@ -2156,23 +2302,35 @@ static status_t\n demangle_array_type (dm)\n      demangling_t dm;\n {\n+  status_t status;\n   dyn_string_t array_size = dyn_string_new (10);\n \n-  RETURN_IF_ERROR (demangle_char (dm, 'A'));\n+  if (array_size == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n+  status = demangle_char (dm, 'A');\n \n   /* Demangle the array size into array_size.  */\n-  RETURN_IF_ERROR (demangle_number_literally (dm, array_size, 10, 0));\n+  if (STATUS_NO_ERROR (status))\n+    status = demangle_number_literally (dm, array_size, 10, 0);\n \n   /* Demangle the base type of the array.  */\n-  RETURN_IF_ERROR (demangle_char (dm, '_'));\n-  RETURN_IF_ERROR (demangle_type (dm));\n+  if (STATUS_NO_ERROR (status))\n+    status = demangle_char (dm, '_');\n+  if (STATUS_NO_ERROR (status))\n+    status = demangle_type (dm);\n \n   /* Emit the array dimension syntax.  */\n-  result_append_char (dm, '[');\n-  result_append_string (dm, array_size);\n-  result_append_char (dm, ']');\n+  if (STATUS_NO_ERROR (status))\n+    status = result_append_char (dm, '[');\n+  if (STATUS_NO_ERROR (status))\n+    status = result_append_string (dm, array_size);\n+  if (STATUS_NO_ERROR (status))\n+    status = result_append_char (dm, ']');\n   dyn_string_delete (array_size);\n   \n+  RETURN_IF_ERROR (status);\n+\n   return STATUS_OK;\n }\n \n@@ -2213,7 +2371,7 @@ demangle_template_param (dm, template_parm_number)\n     /* parm_number exceeded the number of arguments in the current\n        template argument list.  */\n     return \"Template parameter number out of bounds.\";\n-  result_append_string (dm, (dyn_string_t) arg);\n+  RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));\n \n   if (peek_char (dm) == 'I')\n     RETURN_IF_ERROR (demangle_template_args (dm));\n@@ -2231,39 +2389,46 @@ demangle_template_args (dm)\n      demangling_t dm;\n {\n   int first = 1;\n+  dyn_string_t old_last_source_name;\n   template_arg_list_t arg_list = template_arg_list_new ();\n \n+  if (arg_list == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n   /* Preserve the most recently demangled source name.  */\n-  dyn_string_t old_last_source_name = dm->last_source_name;\n+  old_last_source_name = dm->last_source_name;\n   dm->last_source_name = dyn_string_new (0);\n \n   DEMANGLE_TRACE (\"template-args\", dm);\n \n+  if (dm->last_source_name == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n   RETURN_IF_ERROR (demangle_char (dm, 'I'));\n-  result_append_char (dm, '<');\n+  RETURN_IF_ERROR (result_append_char (dm, '<'));\n   do\n     {\n       string_list_t arg;\n \n       if (first)\n \tfirst = 0;\n       else\n-\tresult_append (dm, \", \");\n+\tRETURN_IF_ERROR (result_append (dm, \", \"));\n \n       /* Capture the template arg.  */\n-      result_push (dm);\n+      RETURN_IF_ERROR (result_push (dm));\n       RETURN_IF_ERROR (demangle_template_arg (dm));\n       arg = result_pop (dm);\n \n       /* Emit it in the demangled name.  */\n-      result_append_string (dm, (dyn_string_t) arg);\n+      RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));\n \n       /* Save it for use in expanding <template-param>s.  */\n       template_arg_list_add_arg (arg_list, arg);\n     }\n   while (peek_char (dm) != 'E');\n   /* Append the '>'.  */\n-  result_close_template_list (dm);\n+  RETURN_IF_ERROR (result_close_template_list (dm));\n \n   /* Consume the 'E'.  */\n   advance_char (dm);\n@@ -2293,8 +2458,9 @@ static status_t\n demangle_literal (dm)\n      demangling_t dm;\n {\n-  dyn_string_t value = dyn_string_new (0);\n   char peek = peek_char (dm);\n+  dyn_string_t value_string;\n+  status_t status;\n \n   DEMANGLE_TRACE (\"literal\", dm);\n \n@@ -2331,9 +2497,9 @@ demangle_literal (dm)\n \t     corresponding to false or true, respectively.  */\n \t  value = peek_char (dm);\n \t  if (value == '0')\n-\t    result_append (dm, \"false\");\n+\t    RETURN_IF_ERROR (result_append (dm, \"false\"));\n \t  else if (value == '1')\n-\t    result_append (dm, \"true\");\n+\t    RETURN_IF_ERROR (result_append (dm, \"true\"));\n \t  else\n \t    return \"Unrecognized bool constant.\";\n \t  /* Consume the 0 or 1.  */\n@@ -2346,25 +2512,37 @@ demangle_literal (dm)\n \n \t  /* Consume the type character.  */\n \t  advance_char (dm);\n+\n \t  /* Demangle the number and write it out.  */\n-\t  RETURN_IF_ERROR (demangle_number_literally (dm, value, 10, 1));\n-\t  result_append_string (dm, value);\n+\t  value_string = dyn_string_new (0);\n+\t  status = demangle_number_literally (dm, value_string, 10, 1);\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_string (dm, value_string);\n \t  /* For long integers, append an l.  */\n-\t  if (code == 'l')\n-\t    result_append_char (dm, code);\n+\t  if (code == 'l' && STATUS_NO_ERROR (status))\n+\t    status = result_append_char (dm, code);\n+\t  dyn_string_delete (value_string);\n+\n+\t  RETURN_IF_ERROR (status);\n \t  return STATUS_OK;\n \t}\n       /* ...else code == ' ', so fall through to represent this\n \t literal's type explicitly using cast syntax.  */\n     }\n \n-  result_append_char (dm, '(');\n+  RETURN_IF_ERROR (result_append_char (dm, '('));\n   RETURN_IF_ERROR (demangle_type (dm));\n-  result_append_char (dm, ')');\n+  RETURN_IF_ERROR (result_append_char (dm, ')'));\n+\n+  value_string = dyn_string_new (0);\n+  if (value_string == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n \n-  RETURN_IF_ERROR (demangle_number_literally (dm, value, 10, 1));\n-  result_append_string (dm, value);\n-  dyn_string_delete (value);\n+  status = demangle_number_literally (dm, value_string, 10, 1);\n+  if (STATUS_NO_ERROR (status))\n+    status = result_append_string (dm, value_string);\n+  dyn_string_delete (value_string);\n+  RETURN_IF_ERROR (status);\n \n   return STATUS_OK;\n }\n@@ -2436,37 +2614,43 @@ demangle_expression (dm)\n     /* An operator expression.  */\n     {\n       int num_args;\n+      status_t status = STATUS_OK;\n       dyn_string_t operator_name;\n \n       /* We have an operator name.  Since we want to output binary\n \t operations in infix notation, capture the operator name\n \t first.  */\n-      result_push (dm);\n+      RETURN_IF_ERROR (result_push (dm));\n       RETURN_IF_ERROR (demangle_operator_name (dm, 1, &num_args));\n       operator_name = (dyn_string_t) result_pop (dm);\n \n       /* If it's binary, do an operand first.  */\n       if (num_args > 1)\n \t{\n-\t  result_append_char (dm, '(');\n-\t  RETURN_IF_ERROR (demangle_expression (dm));\n-\t  result_append_char (dm, ')');\n+\t  status = result_append_char (dm, '(');\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = demangle_expression (dm);\n+\t  if (STATUS_NO_ERROR (status))\n+\t    status = result_append_char (dm, ')');\n \t}\n \n-      /* Now emit the operator, followed by its second (if binary) or\n-\t only (if unary) operand.  */\n-      result_append_string (dm, operator_name);\n+      /* Emit the operator.  */  \n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_append_string (dm, operator_name);\n       dyn_string_delete (operator_name);\n-      result_append_char (dm, '(');\n+      RETURN_IF_ERROR (status);\n+      \n+      /* Emit its second (if binary) or only (if unary) operand.  */\n+      RETURN_IF_ERROR (result_append_char (dm, '('));\n       RETURN_IF_ERROR (demangle_expression (dm));\n-      result_append_char (dm, ')');\n+      RETURN_IF_ERROR (result_append_char (dm, ')'));\n \n       /* The ternary operator takes a third operand.  */\n       if (num_args == 3)\n \t{\n-\t  result_append (dm, \":(\");\n+\t  RETURN_IF_ERROR (result_append (dm, \":(\"));\n \t  RETURN_IF_ERROR (demangle_expression (dm));\n-\t  result_append_char (dm, ')');\n+\t  RETURN_IF_ERROR (result_append_char (dm, ')'));\n \t}\n     }\n \n@@ -2485,7 +2669,7 @@ demangle_scope_expression (dm)\n   RETURN_IF_ERROR (demangle_char (dm, 's'));\n   RETURN_IF_ERROR (demangle_char (dm, 'r'));\n   RETURN_IF_ERROR (demangle_type (dm));\n-  result_append (dm, \"::\");\n+  RETURN_IF_ERROR (result_append (dm, \"::\"));\n   RETURN_IF_ERROR (demangle_encoding (dm));\n   return STATUS_OK;\n }\n@@ -2572,85 +2756,96 @@ demangle_substitution (dm, template_p, special_std_substitution)\n   /* If the following character is 0-9 or a capital letter, interpret\n      the sequence up to the next underscore as a base-36 substitution\n      index.  */\n-  else if (isdigit ((unsigned char) peek) \n+  else if (IS_DIGIT ((unsigned char) peek) \n \t   || (peek >= 'A' && peek <= 'Z'))\n     RETURN_IF_ERROR (demangle_number (dm, &seq_id, 36, 0));\n   else \n     {\n+      const char *new_last_source_name = NULL;\n+\n       switch (peek)\n \t{\n \tcase 't':\n-\t  result_append (dm, \"std\");\n+\t  RETURN_IF_ERROR (result_append (dm, \"std\"));\n \t  *special_std_substitution = 1;\n \t  break;\n \n \tcase 'a':\n-\t  result_append (dm, \"std::allocator\");\n-\t  dyn_string_copy_cstr (dm->last_source_name, \"allocator\");\n+\t  RETURN_IF_ERROR (result_append (dm, \"std::allocator\"));\n+\t  new_last_source_name = \"allocator\";\n \t  break;\n \n \tcase 'b':\n-\t  result_append (dm, \"std::basic_string\");\n-\t  dyn_string_copy_cstr (dm->last_source_name, \"basic_string\");\n+\t  RETURN_IF_ERROR (result_append (dm, \"std::basic_string\"));\n+\t  new_last_source_name = \"basic_string\";\n \t  break;\n \t  \n \tcase 's':\n \t  if (!flag_verbose)\n \t    {\n-\t      result_append (dm, \"std::string\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"string\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::string\"));\n+\t      new_last_source_name = \"string\";\n \t    }\n \t  else\n \t    {\n-\t      result_append (dm, \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_string\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\"));\n+\t      new_last_source_name = \"basic_string\";\n \t    }\n \t  break;\n \n \tcase 'i':\n \t  if (!flag_verbose)\n \t    {\n-\t      result_append (dm, \"std::istream\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"istream\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::istream\"));\n+\t      new_last_source_name = \"istream\";\n \t    }\n \t  else\n \t    {\n-\t      result_append (dm, \"std::basic_istream<char, std::char_traints<char> >\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_istream\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_istream<char, std::char_traints<char> >\"));\n+\t      new_last_source_name = \"basic_istream\";\n \t    }\n \t  break;\n \n \tcase 'o':\n \t  if (!flag_verbose)\n \t    {\n-\t      result_append (dm, \"std::ostream\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"ostream\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::ostream\"));\n+\t      new_last_source_name = \"ostream\";\n \t    }\n \t  else\n \t    {\n-\t      result_append (dm, \"std::basic_ostream<char, std::char_traits<char> >\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_ostream\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_ostream<char, std::char_traits<char> >\"));\n+\t      new_last_source_name = \"basic_ostream\";\n \t    }\n \t  break;\n \n \tcase 'd':\n \t  if (!flag_verbose) \n \t    {\n-\t      result_append (dm, \"std::iostream\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"iostream\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::iostream\"));\n+\t      new_last_source_name = \"iostream\";\n \t    }\n \t  else\n \t    {\n-\t      result_append (dm, \"std::basic_iostream<char, std::char_traits<char> >\");\n-\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_iostream\");\n+\t      RETURN_IF_ERROR (result_append (dm, \"std::basic_iostream<char, std::char_traits<char> >\"));\n+\t      new_last_source_name = \"basic_iostream\";\n \t    }\n \t  break;\n \n \tdefault:\n \t  return \"Unrecognized <substitution>.\";\n \t}\n       \n+      /* Consume the character we just processed.  */\n       advance_char (dm);\n+\n+      if (new_last_source_name != NULL)\n+\t{\n+\t  if (!dyn_string_copy_cstr (dm->last_source_name, \n+\t\t\t\t     new_last_source_name))\n+\t    return STATUS_ALLOCATION_FAILED;\n+\t}\n+\n       return STATUS_OK;\n     }\n \n@@ -2662,7 +2857,7 @@ demangle_substitution (dm, template_p, special_std_substitution)\n     return \"Substitution number out of range.\";\n \n   /* Emit the substitution text.  */\n-  result_append_string (dm, text);\n+  RETURN_IF_ERROR (result_append_string (dm, text));\n \n   RETURN_IF_ERROR (demangle_char (dm, '_'));\n   return STATUS_OK;\n@@ -2682,20 +2877,20 @@ demangle_local_name (dm)\n   RETURN_IF_ERROR (demangle_char (dm, 'Z'));\n   RETURN_IF_ERROR (demangle_encoding (dm));\n   RETURN_IF_ERROR (demangle_char (dm, 'E'));\n-  result_append (dm, \"'s \");\n+  RETURN_IF_ERROR (result_append (dm, \"'s \"));\n \n   if (peek_char (dm) == 's')\n     {\n       /* Local character string literal.  */\n-      result_append (dm, \"string literal\");\n+      RETURN_IF_ERROR (result_append (dm, \"string literal\"));\n       /* Consume the s.  */\n       advance_char (dm);\n       RETURN_IF_ERROR (demangle_discriminator (dm, 0));\n     }\n   else\n     {\n       int unused;\n-      result_append (dm, \"local \");\n+      RETURN_IF_ERROR (result_append (dm, \"local \"));\n       /* Local name for some other entity.  Demangle its name.  */\n       RETURN_IF_ERROR (demangle_name (dm, &unused));\n       RETURN_IF_ERROR (demangle_discriminator (dm, 1));\n@@ -2725,9 +2920,9 @@ demangle_discriminator (dm, suppress_first)\n       /* Consume the underscore.  */\n       advance_char (dm);\n       if (flag_verbose)\n-\tresult_append (dm, \" [#\");\n+\tRETURN_IF_ERROR (result_append (dm, \" [#\"));\n       /* Check if there's a number following the underscore.  */\n-      if (isdigit ((unsigned char) peek_char (dm)))\n+      if (IS_DIGIT ((unsigned char) peek_char (dm)))\n \t{\n \t  int discriminator;\n \t  /* Demangle the number.  */\n@@ -2736,22 +2931,22 @@ demangle_discriminator (dm, suppress_first)\n \t    /* Write the discriminator.  The mangled number is two\n \t       less than the discriminator ordinal, counting from\n \t       zero.  */\n-\t    int_to_dyn_string (discriminator + 2, \n-\t\t\t       (dyn_string_t) dm->result);\n+\t    RETURN_IF_ERROR (int_to_dyn_string (discriminator + 2, \n+\t\t\t\t\t\t(dyn_string_t) dm->result));\n \t}\n       else\n \t{\n \t  if (flag_verbose)\n \t    /* A missing digit correspond to one.  */\n-\t    result_append_char (dm, '1');\n+\t    RETURN_IF_ERROR (result_append_char (dm, '1'));\n \t}\n       if (flag_verbose)\n-\tresult_append_char (dm, ']');\n+\tRETURN_IF_ERROR (result_append_char (dm, ']'));\n     }\n   else if (!suppress_first)\n     {\n       if (flag_verbose)\n-\tresult_append (dm, \" [#0]\");\n+\tRETURN_IF_ERROR (result_append (dm, \" [#0]\"));\n     }\n \n   return STATUS_OK;\n@@ -2763,7 +2958,7 @@ demangle_discriminator (dm, suppress_first)\n \n static status_t\n cp_demangle (name, result)\n-     char *name;\n+     const char *name;\n      dyn_string_t result;\n {\n   status_t status;\n@@ -2772,14 +2967,22 @@ cp_demangle (name, result)\n   if (length > 2 && name[0] == '_' && name[1] == 'Z')\n     {\n       demangling_t dm = demangling_new (name);\n+      if (dm == NULL)\n+\treturn STATUS_ALLOCATION_FAILED;\n \n-      result_push (dm);\n-      status = demangle_mangled_name (dm);\n+      status = result_push (dm);\n+      if (status != STATUS_OK)\n+\t{\n+\t  demangling_delete (dm);\n+\t  return status;\n+\t}\n \n-      if (status == STATUS_OK)\n+      status = demangle_mangled_name (dm);\n+      if (STATUS_NO_ERROR (status))\n \t{\n \t  dyn_string_t demangled = (dyn_string_t) result_pop (dm);\n-\t  dyn_string_copy (result, demangled);\n+\t  if (!dyn_string_copy (result, demangled))\n+\t    return STATUS_ALLOCATION_FAILED;\n \t  dyn_string_delete (demangled);\n \t}\n       \n@@ -2790,13 +2993,167 @@ cp_demangle (name, result)\n       /* It's evidently not a mangled C++ name.  It could be the name\n \t of something with C linkage, though, so just copy NAME into\n \t RESULT.  */\n-      dyn_string_copy_cstr (result, name);\n+      if (!dyn_string_copy_cstr (result, name))\n+\treturn STATUS_ALLOCATION_FAILED;\n       status = STATUS_OK;\n     }\n \n+  return status; \n+}\n+\n+/* Demangle TYPE_NAME into RESULT, which must be an initialized\n+   dyn_string_t.  On success, returns STATUS_OK.  On failiure, returns\n+   an error message, and the contents of RESULT are unchanged.  */\n+\n+static status_t\n+cp_demangle_type (type_name, result)\n+     const char* type_name;\n+     dyn_string_t result;\n+{\n+  status_t status;\n+  demangling_t dm = demangling_new (type_name);\n+  \n+  if (dm == NULL)\n+    return STATUS_ALLOCATION_FAILED;\n+\n+  /* Demangle the type name.  The demangled name is stored in dm.  */\n+  status = result_push (dm);\n+  if (status != STATUS_OK)\n+    {\n+      demangling_delete (dm);\n+      return status;\n+    }\n+\n+  status = demangle_type (dm);\n+\n+  if (STATUS_NO_ERROR (status))\n+    {\n+      /* The demangling succeeded.  Pop the result out of dm and copy\n+\t it into RESULT.  */\n+      dyn_string_t demangled = (dyn_string_t) result_pop (dm);\n+      if (!dyn_string_copy (result, demangled))\n+\treturn STATUS_ALLOCATION_FAILED;\n+      dyn_string_delete (demangled);\n+    }\n+\n+  /* Clean up.  */\n+  demangling_delete (dm);\n+\n   return status;\n }\n \n+\n+#ifdef IN_LIBGCC2\n+\n+extern char *__cxa_demangle PARAMS ((const char *, char *, size_t *, int *));\n+\n+/* ABI-mandated entry point in the C++ runtime library for performing\n+   demangling.  MANGLED_NAME is a NUL-terminated character string\n+   containing the name to be demangled.  \n+\n+   OUTPUT_BUFFER is a region of memory, allocated with malloc, of\n+   *LENGTH bytes, into which the demangled name is stored.  If\n+   OUTPUT_BUFFER is not long enough, it is expanded using realloc.\n+   OUTPUT_BUFFER may instead be NULL; in that case, the demangled name\n+   is placed in a region of memory allocated with malloc.  \n+\n+   If LENGTH is non-NULL, the length of the buffer conaining the\n+   demangled name, is placed in *LENGTH.  \n+\n+   The return value is a pointer to the start of the NUL-terminated\n+   demangled name, or NULL if the demangling fails.  The caller is\n+   responsible for deallocating this memory using free.  \n+\n+   *STATUS is set to one of the following values:\n+      0: The demangling operation succeeded.\n+     -1: A memory allocation failiure occurred.\n+     -2: MANGLED_NAME is not a valid name under the C++ ABI mangling rules.\n+     -3: One of the arguments is invalid.\n+\n+   The demagling is performed using the C++ ABI mangling rules, with\n+   GNU extensions.  */\n+\n+char *\n+__cxa_demangle (mangled_name, output_buffer, length, status)\n+     const char *mangled_name;\n+     char *output_buffer;\n+     size_t *length;\n+     int *status;\n+{\n+  struct dyn_string demangled_name;\n+  status_t result;\n+\n+  if (status == NULL)\n+    return NULL;\n+\n+  if (mangled_name == NULL) {\n+    *status = -3;\n+    return NULL;\n+  }\n+\n+  /* Did the caller provide a buffer for the demangled name?  */\n+  if (output_buffer == NULL) {\n+    /* No; dyn_string will malloc a buffer for us.  */\n+    if (!dyn_string_init (&demangled_name, 0)) \n+      {\n+\t*status = -1;\n+\treturn NULL;\n+      }\n+  }\n+  else {\n+    /* Yes.  Check that the length was provided.  */\n+    if (length == NULL) {\n+      *status = -3;\n+      return NULL;\n+    }\n+    /* Install the buffer into a dyn_string.  */\n+    demangled_name.allocated = *length;\n+    demangled_name.length = 0;\n+    demangled_name.s = output_buffer;\n+  }\n+\n+  if (mangled_name[0] == '_' && mangled_name[1] == 'Z')\n+    /* MANGLED_NAME apprears to be a function or variable name.\n+       Demangle it accordingly.  */\n+    result = cp_demangle (mangled_name, &demangled_name);\n+  else\n+    /* Try to demangled MANGLED_NAME as the name of a type.  */\n+    result = cp_demangle_type (mangled_name, &demangled_name);\n+\n+  if (result == STATUS_OK) \n+    /* The demangling succeeded.  */\n+    {\n+      /* If LENGTH isn't NULL, store the allocated buffer length\n+\t there; the buffer may have been realloced by dyn_string\n+\t functions.  */\n+      if (length != NULL)\n+\t*length = demangled_name.allocated;\n+      /* The operation was a success.  */\n+      *status = 0;\n+      return dyn_string_buf (&demangled_name);\n+    }\n+  else if (result == STATUS_ALLOCATION_FAILED)\n+    /* A call to malloc or realloc failed during the demangling\n+       operation.  */\n+    {\n+      *status = -1;\n+      return NULL;\n+    }\n+  else\n+    /* The demangling failed for another reason, most probably because\n+       MANGLED_NAME isn't a valid mangled name.  */\n+    {\n+      /* If the buffer containing the demangled name wasn't provided\n+\t by the caller, free it.  */\n+      if (output_buffer == NULL)\n+\tfree (dyn_string_buf (&demangled_name));\n+      *status = -2;\n+      return NULL;\n+    }\n+}\n+\n+#else /* !IN_LIBGCC2 */\n+\n /* Variant entry point for integration with the existing cplus-dem\n    demangler.  Attempts to demangle MANGLED.  If the demangling\n    succeeds, returns a buffer, allocated with malloc, containing the\n@@ -2811,17 +3168,20 @@ cplus_demangle_new_abi (mangled)\n   dyn_string_t demangled = dyn_string_new (0);\n   /* Attempt the demangling.  */\n   status_t status = cp_demangle ((char *) mangled, demangled);\n-  if (status == STATUS_OK)\n+  if (STATUS_NO_ERROR (status))\n     /* Demangling succeeded.  */\n     {\n       /* Grab the demangled result from the dyn_string.  It was\n \t allocated with malloc, so we can return it directly.  */\n       char *return_value = dyn_string_release (demangled);\n-      /* The dyn_string can go away.  */\n-      dyn_string_delete (demangled);\n       /* Hand back the demangled name.  */\n       return return_value;\n     }\n+  else if (status == STATUS_ALLOCATION_FAILED)\n+    {\n+      fprintf (stderr, \"Memory allocation failed.\\n\");\n+      abort ();\n+    }\n   else\n     /* Demangling failed.  */\n     {\n@@ -2830,6 +3190,8 @@ cplus_demangle_new_abi (mangled)\n     }\n }\n \n+#endif /* IN_LIBGCC2 */\n+\n #ifdef STANDALONE_DEMANGLER\n \n #include \"getopt.h\"\n@@ -2839,7 +3201,7 @@ static void print_usage\n \n /* Non-zero if CHAR is a character than can occur in a mangled name.  */\n #define is_mangled_char(CHAR)                                           \\\n-  (isalnum ((unsigned char) (CHAR)) || (CHAR) == '_')\n+  (IS_ALPHA (CHAR) || IS_DIGIT (CHAR) || (CHAR) == '_')\n \n /* The name of this program, as invoked.  */\n const char* program_name;\n@@ -2968,8 +3330,14 @@ main (argc, argv)\n \n \t  /* If the demangling succeeded, great!  Print out the\n \t     demangled version.  */\n-\t  if (status == STATUS_OK)\n+\t  if (STATUS_NO_ERROR (status))\n \t    fputs (dyn_string_buf (demangled), stdout);\n+\t  /* Abort on allocation failures.  */\n+\t  else if (status == STATUS_ALLOCATION_FAILED)\n+\t    {\n+\t      fprintf (stderr, \"Memory allocation failed.\\n\");\n+\t      abort ();\n+\t    }\n \t  /* Otherwise, it might not have been a mangled name.  Just\n \t     print out the original text.  */\n \t  else\n@@ -3000,8 +3368,14 @@ main (argc, argv)\n \t  status = cp_demangle (argv[i], result);\n \n \t  /* If it worked, print the demangled name.  */\n-\t  if (status == STATUS_OK)\n+\t  if (STATUS_NO_ERROR (status))\n \t    printf (\"%s\\n\", dyn_string_buf (result));\n+\t  /* Abort on allocaiton failures.  */\n+\t  if (status == STATUS_ALLOCATION_FAILED)\n+\t    {\n+\t      fprintf (stderr, \"Memory allocaiton failed.\\n\");\n+\t      abort ():\n+\t    }\n \t  /* If not, print the error message to stderr instead.  */\n \t  else \n \t    fprintf (stderr, \"%s\\n\", status);"}, {"sha": "69897f84c5e61a1f33a04263d9e115d6641addf0", "filename": "libiberty/dyn-string.c", "status": "modified", "additions": 137, "deletions": 61, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051664b06948af35f87a68332931d5edb5d33f76/libiberty%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051664b06948af35f87a68332931d5edb5d33f76/libiberty%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fdyn-string.c?ref=051664b06948af35f87a68332931d5edb5d33f76", "patch": "@@ -36,14 +36,26 @@ Boston, MA 02111-1307, USA.  */\n #include \"libiberty.h\"\n #include \"dyn-string.h\"\n \n+/* If this file is being compiled for inclusion in the C++ runtime\n+   library, as part of the demangler implementation, we don't want to\n+   abort if an allocation fails.  Instead, percolate an error code up\n+   through the call chain.  */\n+\n+#ifdef IN_LIBGCC2\n+#define RETURN_ON_ALLOCATION_FAILURE\n+#endif\n+\n /* Performs in-place initialization of a dyn_string struct.  This\n    function can be used with a dyn_string struct on the stack or\n    embedded in another object.  The contents of of the string itself\n    are still dynamically allocated.  The string initially is capable\n    of holding at least SPACE characeters, including the terminating\n-   NUL.  If SPACE is 0, it will silently be increated to 1.  */\n+   NUL.  If SPACE is 0, it will silently be increated to 1.  \n \n-void\n+   If RETURN_ON_ALLOCATION_FAILURE is defined and memory allocation\n+   fails, returns 0.  Otherwise returns 1.  */\n+\n+int\n dyn_string_init (ds_struct_ptr, space)\n      struct dyn_string *ds_struct_ptr;\n      int space;\n@@ -52,22 +64,44 @@ dyn_string_init (ds_struct_ptr, space)\n   if (space == 0)\n     space = 1;\n \n-  ds_struct_ptr->allocated = space;\n+#ifdef RETURN_ON_ALLOCATION_FAILURE\n+  ds_struct_ptr->s = (char *) malloc (space);\n+  if (ds_struct_ptr->s == NULL)\n+    return 0;\n+#else\n   ds_struct_ptr->s = (char *) xmalloc (space);\n+#endif\n+  ds_struct_ptr->allocated = space;\n   ds_struct_ptr->length = 0;\n   ds_struct_ptr->s[0] = '\\0';\n-}    \n \n-/* Create a new dynamic string capable of holding at least SPACE characters,\n-   including the terminating NUL.  If SPACE is 0, it will be silently\n-   increased to 1.  */\n+  return 1;\n+}\n+\n+/* Create a new dynamic string capable of holding at least SPACE\n+   characters, including the terminating NUL.  If SPACE is 0, it will\n+   be silently increased to 1.  If RETURN_ON_ALLOCATION_FAILURE is\n+   defined and memory allocation fails, returns NULL.  Otherwise\n+   returns the newly allocated string.  */\n \n dyn_string_t \n dyn_string_new (space)\n      int space;\n {\n-  dyn_string_t result = (dyn_string_t) xmalloc (sizeof (struct dyn_string));\n+  dyn_string_t result;\n+#ifdef RETURN_ON_ALLOCATION_FAILURE\n+  result = (dyn_string_t) malloc (sizeof (struct dyn_string));\n+  if (result == NULL)\n+    return NULL;\n+  if (!dyn_string_init (result, space))\n+    {\n+      free (result);\n+      return NULL;\n+    }\n+#else\n+  result = (dyn_string_t) xmalloc (sizeof (struct dyn_string));\n   dyn_string_init (result, space);\n+#endif\n   return result;\n }\n \n@@ -83,7 +117,7 @@ dyn_string_delete (ds)\n \n /* Returns the contents of DS in a buffer allocated with malloc.  It\n    is the caller's responsibility to deallocate the buffer using free.\n-   DS is then set to the empty string.  */\n+   DS is then set to the empty string.  Deletes DS itself.  */\n \n char*\n dyn_string_release (ds)\n@@ -93,15 +127,18 @@ dyn_string_release (ds)\n   char* result = ds->s;\n   /* The buffer is no longer owned by DS.  */\n   ds->s = NULL;\n-  /* Reinitialize DS to the empty string.  */\n-  dyn_string_init (ds, 0);\n+  /* Delete DS.  */\n+  free (ds);\n   /* Return the old buffer.  */\n   return result;\n }\n \n /* Increase the capacity of DS so it can hold at least SPACE\n    characters, plus the terminating NUL.  This function will not (at\n-   present) reduce the capacity of DS.  */\n+   present) reduce the capacity of DS.  Returns DS on success. \n+\n+   If RETURN_ON_ALLOCATION_FAILURE is defined and a memory allocation\n+   operation fails, deletes DS and returns NULL.  */\n \n dyn_string_t \n dyn_string_resize (ds, space)\n@@ -113,14 +150,24 @@ dyn_string_resize (ds, space)\n   /* Increase SPACE to hold the NUL termination.  */\n   ++space;\n \n+  /* Increase allocation by factors of two.  */\n   while (space > new_allocated)\n     new_allocated *= 2;\n     \n   if (new_allocated != ds->allocated)\n     {\n-      /* We actually need more space.  */\n       ds->allocated = new_allocated;\n+      /* We actually need more space.  */\n+#ifdef RETURN_ON_ALLOCATION_FAILURE\n+      ds->s = (char *) realloc (ds->s, ds->allocated);\n+      if (ds->s == NULL)\n+\t{\n+\t  free (ds);\n+\t  return NULL;\n+\t}\n+#else\n       ds->s = (char *) xrealloc (ds->s, ds->allocated);\n+#endif\n     }\n \n   return ds;\n@@ -138,9 +185,10 @@ dyn_string_clear (ds)\n }\n \n /* Makes the contents of DEST the same as the contents of SRC.  DEST\n-   and SRC must be distinct.  */\n+   and SRC must be distinct.  Returns 1 on success.  On failure, if\n+   RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */\n \n-void\n+int\n dyn_string_copy (dest, src)\n      dyn_string_t dest;\n      dyn_string_t src;\n@@ -149,55 +197,66 @@ dyn_string_copy (dest, src)\n     abort ();\n \n   /* Make room in DEST.  */\n-  dyn_string_resize (dest, src->length);\n+  if (dyn_string_resize (dest, src->length) == NULL)\n+    return 0;\n   /* Copy DEST into SRC.  */\n   strcpy (dest->s, src->s);\n   /* Update the size of DEST.  */\n   dest->length = src->length;\n+  return 1;\n }\n \n-/* Copies SRC, a NUL-terminated string, into DEST.  */\n+/* Copies SRC, a NUL-terminated string, into DEST.  Returns 1 on\n+   success.  On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST\n+   and returns 0.  */\n \n-void\n+int\n dyn_string_copy_cstr (dest, src)\n      dyn_string_t dest;\n      const char *src;\n {\n   int length = strlen (src);\n   /* Make room in DEST.  */\n-  dyn_string_resize (dest, length);\n+  if (dyn_string_resize (dest, length) == NULL)\n+    return 0;\n   /* Copy DEST into SRC.  */\n   strcpy (dest->s, src);\n   /* Update the size of DEST.  */\n   dest->length = length;\n+  return 1;\n }\n \n /* Inserts SRC at the beginning of DEST.  DEST is expanded as\n-   necessary.  SRC and DEST must be distinct.  */\n+   necessary.  SRC and DEST must be distinct.  Returns 1 on success.\n+   On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and\n+   returns 0.  */\n \n-void \n+int\n dyn_string_prepend (dest, src)\n      dyn_string_t dest;\n      dyn_string_t src;\n {\n-  dyn_string_insert (dest, 0, src);\n+  return dyn_string_insert (dest, 0, src);\n }\n \n /* Inserts SRC, a NUL-terminated string, at the beginning of DEST.\n-   DEST is expanded as necessary.  */\n+   DEST is expanded as necessary.  Returns 1 on success.  On failure,\n+   if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0. */\n \n-void \n+int\n dyn_string_prepend_cstr (dest, src)\n      dyn_string_t dest;\n      const char *src;\n {\n-  dyn_string_insert_cstr (dest, 0, src);\n+  return dyn_string_insert_cstr (dest, 0, src);\n }\n \n-/* Inserts SRC into DEST starting at position POS.  DEST is expanded as\n-   necessary.  SRC and DEST must be distinct.  */\n+/* Inserts SRC into DEST starting at position POS.  DEST is expanded\n+   as necessary.  SRC and DEST must be distinct.  Returns 1 on\n+   success.  On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST\n+   and returns 0.  */\n \n-void \n+int\n dyn_string_insert (dest, pos, src)\n      dyn_string_t dest;\n      int pos;\n@@ -208,20 +267,24 @@ dyn_string_insert (dest, pos, src)\n   if (src == dest)\n     abort ();\n \n-  dyn_string_resize (dest, dest->length + src->length);\n+  if (dyn_string_resize (dest, dest->length + src->length) == NULL)\n+    return 0;\n   /* Make room for the insertion.  Be sure to copy the NUL.  */\n   for (i = dest->length; i >= pos; --i)\n     dest->s[i + src->length] = dest->s[i];\n   /* Splice in the new stuff.  */\n   strncpy (dest->s + pos, src->s, src->length);\n   /* Compute the new length.  */\n   dest->length += src->length;\n+  return 1;\n }\n \n /* Inserts SRC, a NUL-terminated string, into DEST starting at\n-   position POS.  DEST is expanded as necessary.  */\n+   position POS.  DEST is expanded as necessary.  Returns 1 on\n+   success.  On failure, RETURN_ON_ALLOCATION_FAILURE, deletes DEST\n+   and returns 0.  */\n \n-void \n+int\n dyn_string_insert_cstr (dest, pos, src)\n      dyn_string_t dest;\n      int pos;\n@@ -230,71 +293,81 @@ dyn_string_insert_cstr (dest, pos, src)\n   int i;\n   int length = strlen (src);\n \n-  dyn_string_resize (dest, dest->length + length);\n+  if (dyn_string_resize (dest, dest->length + length) == NULL)\n+    return 0;\n   /* Make room for the insertion.  Be sure to copy the NUL.  */\n   for (i = dest->length; i >= pos; --i)\n     dest->s[i + length] = dest->s[i];\n   /* Splice in the new stuff.  */\n   strncpy (dest->s + pos, src, length);\n   /* Compute the new length.  */\n   dest->length += length;\n+  return 1;\n }\n \n-/* Append S to DS, resizing DS if necessary.  Returns DS.  */\n+/* Append S to DS, resizing DS if necessary.  Returns 1 on success.\n+   On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and\n+   returns 0.  */\n \n-dyn_string_t\n-dyn_string_append (ds, s)\n-     dyn_string_t ds;\n+int\n+dyn_string_append (dest, s)\n+     dyn_string_t dest;\n      dyn_string_t s;\n {\n-  dyn_string_resize (ds, ds->length + s->length);\n-  strcpy (ds->s + ds->length, s->s);\n-  ds->length += s->length;\n-  return ds;\n+  if (dyn_string_resize (dest, dest->length + s->length) == 0)\n+    return 0;\n+  strcpy (dest->s + dest->length, s->s);\n+  dest->length += s->length;\n+  return 1;\n }\n \n /* Append the NUL-terminated string S to DS, resizing DS if necessary.\n-   Returns DS.  */\n+   Returns 1 on success.  On failure, if RETURN_ON_ALLOCATION_FAILURE,\n+   deletes DEST and returns 0.  */\n \n-dyn_string_t \n-dyn_string_append_cstr (ds, s)\n-     dyn_string_t ds;\n+int\n+dyn_string_append_cstr (dest, s)\n+     dyn_string_t dest;\n      const char *s;\n {\n   int len = strlen (s);\n \n   /* The new length is the old length plus the size of our string, plus\n      one for the null at the end.  */\n-  dyn_string_resize (ds, ds->length + len);\n-  strcpy (ds->s + ds->length, s);\n-  ds->length += len;\n-\n-  return ds;\n+  if (dyn_string_resize (dest, dest->length + len) == NULL)\n+    return 0;\n+  strcpy (dest->s + dest->length, s);\n+  dest->length += len;\n+  return 1;\n }\n \n-/* Appends C to the end of DS.  */\n+/* Appends C to the end of DEST.  Returns 1 on success.  On failiure,\n+   if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */\n \n-dyn_string_t \n-dyn_string_append_char (ds, c)\n-     dyn_string_t ds;\n+int\n+dyn_string_append_char (dest, c)\n+     dyn_string_t dest;\n      int c;\n {\n   /* Make room for the extra character.  */\n-  dyn_string_resize (ds, ds->length + 1);\n+  if (dyn_string_resize (dest, dest->length + 1) == NULL)\n+    return 0;\n   /* Append the character; it will overwrite the old NUL.  */\n-  ds->s[ds->length] = c;\n+  dest->s[dest->length] = c;\n   /* Add a new NUL at the end.  */\n-  ds->s[ds->length + 1] = '\\0';\n+  dest->s[dest->length + 1] = '\\0';\n   /* Update the length.  */\n-  ++(ds->length);\n-  return ds;\n+  ++(dest->length);\n+  return 1;\n }\n \n /* Sets the contents of DEST to the substring of SRC starting at START\n    and ending before END.  START must be less than or equal to END,\n-   and both must be between zero and the length of SRC, inclusive.  */\n+   and both must be between zero and the length of SRC, inclusive.\n+   Returns 1 on success.  On failure, if RETURN_ON_ALLOCATION_FAILURE,\n+   deletes DEST and returns 0.  */\n \n-void\n+int\n dyn_string_substring (dest, src, start, end)\n      dyn_string_t dest;\n      dyn_string_t src;\n@@ -308,14 +381,17 @@ dyn_string_substring (dest, src, start, end)\n     abort ();\n \n   /* Make room for the substring.  */\n-  dyn_string_resize (dest, length);\n+  if (dyn_string_resize (dest, length) == NULL)\n+    return 0;\n   /* Copy the characters in the substring,  */\n   for (i = length; --i >= 0; )\n     dest->s[i] = src->s[start + i];\n   /* NUL-terimate the result.  */\n   dest->s[length] = '\\0';\n   /* Record the length of the substring.  */\n   dest->length = length;\n+\n+  return 1;\n }\n \n /* Returns non-zero if DS1 and DS2 have the same contents.  */"}]}