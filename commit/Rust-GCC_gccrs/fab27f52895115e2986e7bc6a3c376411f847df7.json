{"sha": "fab27f52895115e2986e7bc6a3c376411f847df7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiMjdmNTI4OTUxMTVlMjk4NmU3YmM2YTNjMzc2NDExZjg0N2RmNw==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-05-19T04:24:31Z"}, "committer": {"name": "Mikhail Maltsev", "email": "miyuki@gcc.gnu.org", "date": "2015-05-19T04:24:31Z"}, "message": "Use std::swap instead of explicit swaps\n\ngcc/\n\t* bb-reorder.c (fix_up_fall_thru_edges): Use std::swap instead of\n\texplicit swaps.\n\t* dojump.c (do_compare_rtx_and_jump): Likewise.\n\t* expmed.c (emit_store_flag_1): Likewise.\n\t* fibonacci_heap.h (fibonacci_heap::union_with): Likewise.\n\t* final.c (sprint_ul): Use std::reverse for reversing a string.\n\t* fold-const.c (extract_muldiv_1): Use std::swap.\n\t* genmodes.c (emit_mode_int_n): Likewise.\n\t* ifcvt.c (dead_or_predicable): Likewise.\n\t* ira-build.c (ira_merge_live_ranges): Likewise.\n\t(swap_allocno_copy_ends_if_necessary): Likewise.\n\t* ira.c (ira_setup_alts): Likewise.\n\t* loop-iv.c (iv_analyze_expr): Likewise.\n\t(implies_p): Likewise.\n\t(canon_condition): Likewise.\n\t* lra-constraints.c (swap_operands): Likewise.\n\t* lra-lives.c (lra_merge_live_ranges): Likewise.\n\t* omega.c (swap): Remove.\n\t(bswap): Remove.\n\t(omega_unprotect_1): Use std::swap.\n\t(omega_solve_geq): Likewise.\n\t* optabs.c (expand_binop_directly): Likewise.\n\t(expand_binop): Likewise.\n\t(emit_conditional_move): Likewise.\n\t(emit_conditional_add): Likewise.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* reg-stack.c (emit_swap_insn): Likewise.\n\t(swap_to_top): Likewise.\n\t(compare_for_stack_reg): Likewise.\n\t(subst_asm_stack_regs): Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t* reload1.c (gen_reload_chain_without_interm_reg_p): Likewise.\n\t* sel-sched.c (invoke_reorder_hooks): Likewise.\n\t(create_block_for_bookkeeping): Likewise.\n\t* tree-data-ref.c (lambda_matrix_row_exchange): Remove.\n\t(lambda_matrix_right_hermite): Use std::swap.\n\t* tree-ssa-coalesce.c (sort_coalesce_list): Likewise.\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n\t* tree-ssa-loop-ivopts.c (iv_ca_delta_reverse): Likewise.\n\t* tree-ssa-math-opts.c (is_widening_mult_p): Likewise.\n\t* tree-ssa-phiopt.c (hoist_adjacent_loads): Likewise.\n\t* tree-ssa-reassoc.c (linearize_expr_tree): Likewise.\n\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Likewise.\n\t* tree-vrp.c (compare_ranges): Likewise.\n\t* var-tracking.c (add_with_sets): Likewise.\n\t(vt_find_locations): Likewise.\n\ngcc/c/\n\t* c-typeck.c (build_array_ref): Use std::swap instead of explicit\n\tswaps\n\ngcc/cp/\n\t* typeck.c (composite_pointer_type): Use std::swap instead of explicit\n\tswaps.\n\ngcc/c-family/\n\t* c-common.c (shorten_compare): Use std::swap instead of explicit swaps.\n\ngcc/fortran/\n\t* interface.c (compare_actual_formal): Use std::swap instead of\n\texplicit swaps.\n\t* trans-array.c (gfc_trans_scalarized_loop_end): Likewise.\n\t* trans-intrinsic.c (walk_inline_intrinsic_transpose): Likewise.\n\nFrom-SVN: r223332", "tree": {"sha": "eefdc0644e3d1f6b92e84e3b1ced07ac8b856fb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eefdc0644e3d1f6b92e84e3b1ced07ac8b856fb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fab27f52895115e2986e7bc6a3c376411f847df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab27f52895115e2986e7bc6a3c376411f847df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fab27f52895115e2986e7bc6a3c376411f847df7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab27f52895115e2986e7bc6a3c376411f847df7/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de7fe0877856955efc5bce5fff364557da958d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de7fe0877856955efc5bce5fff364557da958d70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de7fe0877856955efc5bce5fff364557da958d70"}], "stats": {"total": 630, "additions": 207, "deletions": 423}, "files": [{"sha": "44017c1806770306cf34fe3956b112e621ffc33e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1,3 +1,52 @@\n+2015-05-19  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* bb-reorder.c (fix_up_fall_thru_edges): Use std::swap instead of\n+\texplicit swaps.\n+\t* dojump.c (do_compare_rtx_and_jump): Likewise.\n+\t* expmed.c (emit_store_flag_1): Likewise.\n+\t* fibonacci_heap.h (fibonacci_heap::union_with): Likewise.\n+\t* final.c (sprint_ul): Use std::reverse for reversing a string.\n+\t* fold-const.c (extract_muldiv_1): Use std::swap.\n+\t* genmodes.c (emit_mode_int_n): Likewise.\n+\t* ifcvt.c (dead_or_predicable): Likewise.\n+\t* ira-build.c (ira_merge_live_ranges): Likewise.\n+\t(swap_allocno_copy_ends_if_necessary): Likewise.\n+\t* ira.c (ira_setup_alts): Likewise.\n+\t* loop-iv.c (iv_analyze_expr): Likewise.\n+\t(implies_p): Likewise.\n+\t(canon_condition): Likewise.\n+\t* lra-constraints.c (swap_operands): Likewise.\n+\t* lra-lives.c (lra_merge_live_ranges): Likewise.\n+\t* omega.c (swap): Remove.\n+\t(bswap): Remove.\n+\t(omega_unprotect_1): Use std::swap.\n+\t(omega_solve_geq): Likewise.\n+\t* optabs.c (expand_binop_directly): Likewise.\n+\t(expand_binop): Likewise.\n+\t(emit_conditional_move): Likewise.\n+\t(emit_conditional_add): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* reg-stack.c (emit_swap_insn): Likewise.\n+\t(swap_to_top): Likewise.\n+\t(compare_for_stack_reg): Likewise.\n+\t(subst_asm_stack_regs): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* reload1.c (gen_reload_chain_without_interm_reg_p): Likewise.\n+\t* sel-sched.c (invoke_reorder_hooks): Likewise.\n+\t(create_block_for_bookkeeping): Likewise.\n+\t* tree-data-ref.c (lambda_matrix_row_exchange): Remove.\n+\t(lambda_matrix_right_hermite): Use std::swap.\n+\t* tree-ssa-coalesce.c (sort_coalesce_list): Likewise.\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n+\t* tree-ssa-loop-ivopts.c (iv_ca_delta_reverse): Likewise.\n+\t* tree-ssa-math-opts.c (is_widening_mult_p): Likewise.\n+\t* tree-ssa-phiopt.c (hoist_adjacent_loads): Likewise.\n+\t* tree-ssa-reassoc.c (linearize_expr_tree): Likewise.\n+\t* tree-ssa-threadedge.c (simplify_control_stmt_condition): Likewise.\n+\t* tree-vrp.c (compare_ranges): Likewise.\n+\t* var-tracking.c (add_with_sets): Likewise.\n+\t(vt_find_locations): Likewise.\n+\n 2015-05-18  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* config/freebsd-spec.h (FBSD_STARTFILE_SPEC): Add the bits to build"}, {"sha": "a97c2cd4c97faf7636e42d90e57e60bafd97edf9", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1812,7 +1812,6 @@ fix_up_fall_thru_edges (void)\n   edge succ2;\n   edge fall_thru;\n   edge cond_jump = NULL;\n-  edge e;\n   bool cond_jump_crosses;\n   int invert_worked;\n   rtx_insn *old_jump;\n@@ -1901,9 +1900,7 @@ fix_up_fall_thru_edges (void)\n \t\t\t  fall_thru->flags &= ~EDGE_FALLTHRU;\n \t\t\t  cond_jump->flags |= EDGE_FALLTHRU;\n \t\t\t  update_br_prob_note (cur_bb);\n-\t\t\t  e = fall_thru;\n-\t\t\t  fall_thru = cond_jump;\n-\t\t\t  cond_jump = e;\n+\t\t\t  std::swap (fall_thru, cond_jump);\n \t\t\t  cond_jump->flags |= EDGE_CROSSING;\n \t\t\t  fall_thru->flags &= ~EDGE_CROSSING;\n \t\t\t}"}, {"sha": "bf403ce57c7995bb9d26b6d8b97fd1dde63278e9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1,3 +1,7 @@\n+2015-05-19  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* c-common.c (shorten_compare): Use std::swap instead of explicit swaps.\n+\n 2015-05-18  Tom de Vries  <tom@codesourcery.com>\n \n \t* c-common.c (build_va_arg_1): New function."}, {"sha": "3998b23b00b15953ef586df4871596a4f79914b0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -4372,20 +4372,12 @@ shorten_compare (location_t loc, tree *op0_ptr, tree *op1_ptr,\n       && !integer_zerop (primop1) && !real_zerop (primop1)\n       && !fixed_zerop (primop1))\n     {\n-      tree tem = primop0;\n-      int temi = unsignedp0;\n-      primop0 = primop1;\n-      primop1 = tem;\n-      tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (primop0, primop1);\n+      std::swap (op0, op1);\n       *op0_ptr = op0;\n       *op1_ptr = op1;\n-      unsignedp0 = unsignedp1;\n-      unsignedp1 = temi;\n-      temi = real1;\n-      real1 = real2;\n-      real2 = temi;\n+      std::swap (unsignedp0, unsignedp1);\n+      std::swap (real1, real2);\n \n       switch (code)\n \t{"}, {"sha": "d573d7ab6d4aa3e81bb26fda0ec1213a93d5290f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1,3 +1,8 @@\n+2015-05-19  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* c-typeck.c (build_array_ref): Use std::swap instead of explicit\n+\tswaps\n+\n 2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR fortran/44054"}, {"sha": "7f544902bb106981cba6844d32c043dc91ebc81e", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -2474,7 +2474,6 @@ build_array_ref (location_t loc, tree array, tree index)\n       /* Allow vector[index] but not index[vector].  */\n       && TREE_CODE (TREE_TYPE (array)) != VECTOR_TYPE)\n     {\n-      tree temp;\n       if (TREE_CODE (TREE_TYPE (index)) != ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (index)) != POINTER_TYPE)\n \t{\n@@ -2483,9 +2482,7 @@ build_array_ref (location_t loc, tree array, tree index)\n \n \t  return error_mark_node;\n \t}\n-      temp = array;\n-      array = index;\n-      index = temp;\n+      std::swap (array, index);\n       swapped = true;\n     }\n "}, {"sha": "3271a5491f66e79ca6ab09f57c24e7cd42568b27", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1,3 +1,8 @@\n+2015-05-19  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* typeck.c (composite_pointer_type): Use std::swap instead of explicit\n+\tswaps.\n+\n 2015-05-18  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (retrieve_specialization): Make sure our arguments have"}, {"sha": "a4d702b2a1d0321f55e9060c588de8f2aedc2ed8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -606,12 +606,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \n     If either type is a pointer to void, make sure it is T1.  */\n   if (TYPE_PTR_P (t2) && VOID_TYPE_P (TREE_TYPE (t2)))\n-    {\n-      tree t;\n-      t = t1;\n-      t1 = t2;\n-      t2 = t;\n-    }\n+    std::swap (t1, t2);\n \n   /* Now, if T1 is a pointer to void, merge the qualifiers.  */\n   if (TYPE_PTR_P (t1) && VOID_TYPE_P (TREE_TYPE (t1)))"}, {"sha": "b564d6417bf6281c960e0217e699f22e9ca81f20", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1096,11 +1096,8 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t  && ! can_compare_p (code, mode, ccp_jump)\n \t  && can_compare_p (swap_condition (code), mode, ccp_jump))\n \t{\n-\t  rtx tmp;\n \t  code = swap_condition (code);\n-\t  tmp = op0;\n-\t  op0 = op1;\n-\t  op1 = tmp;\n+\t  std::swap (op0, op1);\n \t}\n       else if (SCALAR_FLOAT_MODE_P (mode)\n \t       && ! can_compare_p (code, mode, ccp_jump)"}, {"sha": "2da9a6552a0dad9d03bf99cb2ce68a498535bc18", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -5256,7 +5256,6 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   machine_mode compare_mode;\n   enum mode_class mclass;\n   enum rtx_code scode;\n-  rtx tem;\n \n   if (unsignedp)\n     code = unsigned_condition (code);\n@@ -5267,9 +5266,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   if (swap_commutative_operands_p (op0, op1))\n     {\n-      tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (op0, op1);\n       code = swap_condition (code);\n     }\n \n@@ -5316,6 +5313,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && (!MEM_P (op0) || ! MEM_VOLATILE_P (op0)))\n     {\n+      rtx tem;\n       if ((code == EQ || code == NE)\n \t  && (op1 == const0_rtx || op1 == constm1_rtx))\n \t{\n@@ -5415,8 +5413,8 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n      if (icode != CODE_FOR_nothing)\n \t{\n \t  do_pending_stack_adjust ();\n-\t  tem = emit_cstore (target, icode, code, mode, compare_mode,\n-\t\t\t     unsignedp, op0, op1, normalizep, target_mode);\n+\t  rtx tem = emit_cstore (target, icode, code, mode, compare_mode,\n+\t\t\t\t unsignedp, op0, op1, normalizep, target_mode);\n \t  if (tem)\n \t    return tem;\n "}, {"sha": "2e74176f58ad6b3e9415afe657f037032742cb64", "filename": "gcc/fibonacci_heap.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffibonacci_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffibonacci_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffibonacci_heap.h?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -457,7 +457,7 @@ fibonacci_heap<K,V>::union_with (fibonacci_heap<K,V> *heapb)\n {\n   fibonacci_heap<K,V> *heapa = this;\n \n-  fibonacci_node<K,V> *a_root, *b_root, *temp;\n+  fibonacci_node<K,V> *a_root, *b_root;\n \n   /* If one of the heaps is empty, the union is just the other heap.  */\n   if ((a_root = heapa->m_root) == NULL)\n@@ -474,9 +474,7 @@ fibonacci_heap<K,V>::union_with (fibonacci_heap<K,V> *heapb)\n   /* Merge them to the next nodes on the opposite chain.  */\n   a_root->m_left->m_right = b_root;\n   b_root->m_left->m_right = a_root;\n-  temp = a_root->m_left;\n-  a_root->m_left = b_root->m_left;\n-  b_root->m_left = temp;\n+  std::swap (a_root->m_left, b_root->m_left);\n   heapa->m_nodes += heapb->m_nodes;\n \n   /* And set the new minimum, if it's changed.  */"}, {"sha": "aaeececc0b40019cc4e80b45aa2fa91c5e8c94cd", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -4131,25 +4131,10 @@ fprint_ul (FILE *f, unsigned long value)\n int\n sprint_ul (char *s, unsigned long value)\n {\n-  int len;\n-  char tmp_c;\n-  int i;\n-  int j;\n-\n-  len = sprint_ul_rev (s, value);\n+  int len = sprint_ul_rev (s, value);\n   s[len] = '\\0';\n \n-  /* Reverse the string. */\n-  i = 0;\n-  j = len - 1;\n-  while (i < j)\n-    {\n-      tmp_c = s[i];\n-      s[i] = s[j];\n-      s[j] = tmp_c;\n-      i++; j--;\n-    }\n-\n+  std::reverse (s, s + len);\n   return len;\n }\n "}, {"sha": "1476ee0b1edecba7ca86a927518efd0ef2b11624", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -6139,12 +6139,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t  /* If OP1 was not easily negatable, the constant may be OP0.  */\n \t  if (TREE_CODE (op0) == INTEGER_CST)\n \t    {\n-\t      tree tem = op0;\n-\t      op0 = op1;\n-\t      op1 = tem;\n-\t      tem = t1;\n-\t      t1 = t2;\n-\t      t2 = tem;\n+\t      std::swap (op0, op1);\n+\t      std::swap (t1, t2);\n \t    }\n \t}\n "}, {"sha": "6b3ad09298704da1132d7581fce1ae6da7a3bee0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1,3 +1,10 @@\n+2015-05-19  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* interface.c (compare_actual_formal): Use std::swap instead of\n+\texplicit swaps.\n+\t* trans-array.c (gfc_trans_scalarized_loop_end): Likewise.\n+\t* trans-intrinsic.c (walk_inline_intrinsic_transpose): Likewise.\n+\n 2015-05-18  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66106"}, {"sha": "9f55f0a19f99c8dbfadaf0345c7a72ba93edfdd1", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -2566,7 +2566,7 @@ static int\n compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t \t       int ranks_must_agree, int is_elemental, locus *where)\n {\n-  gfc_actual_arglist **new_arg, *a, *actual, temp;\n+  gfc_actual_arglist **new_arg, *a, *actual;\n   gfc_formal_arglist *f;\n   int i, n, na;\n   unsigned long actual_size, formal_size;\n@@ -3029,13 +3029,8 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n   if (na != 0)\n     {\n-      temp = *new_arg[0];\n-      *new_arg[0] = *actual;\n-      *actual = temp;\n-\n-      a = new_arg[0];\n-      new_arg[0] = new_arg[na];\n-      new_arg[na] = a;\n+      std::swap (*new_arg[0], *actual);\n+      std::swap (new_arg[0], new_arg[na]);\n     }\n \n   for (i = 0; i < n - 1; i++)"}, {"sha": "e6edf742377ec32caff7e465b79cfa05a4007ea5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -3644,11 +3644,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       loopbody = gfc_finish_block (pbody);\n \n       if (reverse_loop)\n-\t{\n-\t  tmp = loop->from[n];\n-\t  loop->from[n] = loop->to[n];\n-\t  loop->to[n] = tmp;\n-\t}\n+\tstd::swap (loop->from[n], loop->to[n]);\n \n       /* Initialize the loopvar.  */\n       if (loop->loopvar[n] != loop->from[n])"}, {"sha": "323c600c99c9ce02451cfb61bdd80fad1f597bc8", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -8324,14 +8324,10 @@ walk_inline_intrinsic_transpose (gfc_ss *ss, gfc_expr *expr)\n       if (tmp_ss->info->type != GFC_SS_SCALAR\n \t  && tmp_ss->info->type != GFC_SS_REFERENCE)\n \t{\n-\t  int tmp_dim;\n-\n \t  gcc_assert (tmp_ss->dimen == 2);\n \n \t  /* We just invert dimensions.  */\n-\t  tmp_dim = tmp_ss->dim[0];\n-\t  tmp_ss->dim[0] = tmp_ss->dim[1];\n-\t  tmp_ss->dim[1] = tmp_dim;\n+\t  std::swap (tmp_ss->dim[0], tmp_ss->dim[1]);\n \t}\n \n       /* Stop when tmp_ss points to the last valid element of the chain...  */"}, {"sha": "af1fe4f6c93223db845d7229c413b46367958a76", "filename": "gcc/genmodes.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1600,11 +1600,7 @@ emit_mode_int_n (void)\n   for (i = 0; i<n_modes - 1; i++)\n     for (j = i + 1; j < n_modes; j++)\n       if (mode_sort[i]->int_n > mode_sort[j]->int_n)\n-\t{\n-\t  m = mode_sort[i];\n-\t  mode_sort[i] = mode_sort[j];\n-\t  mode_sort[j] = m;\n-\t}\n+\tstd::swap (mode_sort[i], mode_sort[j]);\n \n   for (i = 0; i < n_modes; i ++)\n     {"}, {"sha": "afeb034fc066942e3dcb63e1b60cdb2c801d3b2c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -4462,14 +4462,10 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       redirect_edge_succ (BRANCH_EDGE (test_bb), new_dest);\n       if (reversep)\n \t{\n-\t  gcov_type count, probability;\n-\t  count = BRANCH_EDGE (test_bb)->count;\n-\t  BRANCH_EDGE (test_bb)->count = FALLTHRU_EDGE (test_bb)->count;\n-\t  FALLTHRU_EDGE (test_bb)->count = count;\n-\t  probability = BRANCH_EDGE (test_bb)->probability;\n-\t  BRANCH_EDGE (test_bb)->probability\n-\t    = FALLTHRU_EDGE (test_bb)->probability;\n-\t  FALLTHRU_EDGE (test_bb)->probability = probability;\n+\t  std::swap (BRANCH_EDGE (test_bb)->count,\n+\t\t     FALLTHRU_EDGE (test_bb)->count);\n+\t  std::swap (BRANCH_EDGE (test_bb)->probability,\n+\t\t     FALLTHRU_EDGE (test_bb)->probability);\n \t  update_br_prob_note (test_bb);\n \t}\n     }"}, {"sha": "8b6b9564fcb1e86bfb3f3c95aba910682d8173ed", "filename": "gcc/ira-build.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1000,7 +1000,7 @@ ira_copy_live_range_list (live_range_t r)\n live_range_t\n ira_merge_live_ranges (live_range_t r1, live_range_t r2)\n {\n-  live_range_t first, last, temp;\n+  live_range_t first, last;\n \n   if (r1 == NULL)\n     return r2;\n@@ -1009,18 +1009,14 @@ ira_merge_live_ranges (live_range_t r1, live_range_t r2)\n   for (first = last = NULL; r1 != NULL && r2 != NULL;)\n     {\n       if (r1->start < r2->start)\n-\t{\n-\t  temp = r1;\n-\t  r1 = r2;\n-\t  r2 = temp;\n-\t}\n+\tstd::swap (r1, r2);\n       if (r1->start <= r2->finish + 1)\n \t{\n \t  /* Intersected ranges: merge r1 and r2 into r1.  */\n \t  r1->start = r2->start;\n \t  if (r1->finish < r2->finish)\n \t    r1->finish = r2->finish;\n-\t  temp = r2;\n+\t  live_range_t temp = r2;\n \t  r2 = r2->next;\n \t  ira_finish_live_range (temp);\n \t  if (r2 == NULL)\n@@ -1479,23 +1475,12 @@ add_allocno_copy_to_list (ira_copy_t cp)\n static void\n swap_allocno_copy_ends_if_necessary (ira_copy_t cp)\n {\n-  ira_allocno_t temp;\n-  ira_copy_t temp_cp;\n-\n   if (ALLOCNO_NUM (cp->first) <= ALLOCNO_NUM (cp->second))\n     return;\n \n-  temp = cp->first;\n-  cp->first = cp->second;\n-  cp->second = temp;\n-\n-  temp_cp = cp->prev_first_allocno_copy;\n-  cp->prev_first_allocno_copy = cp->prev_second_allocno_copy;\n-  cp->prev_second_allocno_copy = temp_cp;\n-\n-  temp_cp = cp->next_first_allocno_copy;\n-  cp->next_first_allocno_copy = cp->next_second_allocno_copy;\n-  cp->next_second_allocno_copy = temp_cp;\n+  std::swap (cp->first, cp->second);\n+  std::swap (cp->prev_first_allocno_copy, cp->prev_second_allocno_copy);\n+  std::swap (cp->next_first_allocno_copy, cp->next_second_allocno_copy);\n }\n \n /* Create (or update frequency if the copy already exists) and return"}, {"sha": "a4108872c281ceaf72100fa18082046c6ef84185", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1808,7 +1808,6 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n   int nop, nalt;\n   bool curr_swapped;\n   const char *p;\n-  rtx op;\n   int commutative = -1;\n \n   extract_insn (insn);\n@@ -1850,7 +1849,7 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \t    {\n \t      int c, len;\n \n-\t      op = recog_data.operand[nop];\n+\t      rtx op = recog_data.operand[nop];\n \t      p = insn_constraints[nop * recog_data.n_alternatives + nalt];\n \t      if (*p == 0 || *p == ',')\n \t\tcontinue;\n@@ -1923,10 +1922,8 @@ ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n \tbreak;\n       if (curr_swapped)\n \tbreak;\n-      op = recog_data.operand[commutative];\n-      recog_data.operand[commutative] = recog_data.operand[commutative + 1];\n-      recog_data.operand[commutative + 1] = op;\n-\n+      std::swap (recog_data.operand[commutative],\n+\t\t recog_data.operand[commutative + 1]);\n     }\n }\n "}, {"sha": "8c3ef7784e6b277e63dd34086bc67c84f575a780", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -977,7 +977,7 @@ bool\n iv_analyze_expr (rtx_insn *insn, rtx rhs, machine_mode mode,\n \t\t struct rtx_iv *iv)\n {\n-  rtx mby = NULL_RTX, tmp;\n+  rtx mby = NULL_RTX;\n   rtx op0 = NULL_RTX, op1 = NULL_RTX;\n   struct rtx_iv iv0, iv1;\n   enum rtx_code code = GET_CODE (rhs);\n@@ -1028,11 +1028,7 @@ iv_analyze_expr (rtx_insn *insn, rtx rhs, machine_mode mode,\n       op0 = XEXP (rhs, 0);\n       mby = XEXP (rhs, 1);\n       if (!CONSTANT_P (mby))\n-\t{\n-\t  tmp = op0;\n-\t  op0 = mby;\n-\t  mby = tmp;\n-\t}\n+\tstd::swap (op0, mby);\n       if (!CONSTANT_P (mby))\n \treturn false;\n       break;\n@@ -1544,7 +1540,7 @@ replace_in_expr (rtx *expr, rtx dest, rtx src)\n static bool\n implies_p (rtx a, rtx b)\n {\n-  rtx op0, op1, opb0, opb1, r;\n+  rtx op0, op1, opb0, opb1;\n   machine_mode mode;\n \n   if (rtx_equal_p (a, b))\n@@ -1559,7 +1555,7 @@ implies_p (rtx a, rtx b)\n \t  || (GET_CODE (op0) == SUBREG\n \t      && REG_P (SUBREG_REG (op0))))\n \t{\n-\t  r = simplify_replace_rtx (b, op0, op1);\n+\t  rtx r = simplify_replace_rtx (b, op0, op1);\n \t  if (r == const_true_rtx)\n \t    return true;\n \t}\n@@ -1568,7 +1564,7 @@ implies_p (rtx a, rtx b)\n \t  || (GET_CODE (op1) == SUBREG\n \t      && REG_P (SUBREG_REG (op1))))\n \t{\n-\t  r = simplify_replace_rtx (b, op1, op0);\n+\t  rtx r = simplify_replace_rtx (b, op1, op0);\n \t  if (r == const_true_rtx)\n \t    return true;\n \t}\n@@ -1604,18 +1600,10 @@ implies_p (rtx a, rtx b)\n     {\n \n       if (GET_CODE (a) == GT)\n-\t{\n-\t  r = op0;\n-\t  op0 = op1;\n-\t  op1 = r;\n-\t}\n+\tstd::swap (op0, op1);\n \n       if (GET_CODE (b) == GE)\n-\t{\n-\t  r = opb0;\n-\t  opb0 = opb1;\n-\t  opb1 = r;\n-\t}\n+\tstd::swap (opb0, opb1);\n \n       if (SCALAR_INT_MODE_P (mode)\n \t  && rtx_equal_p (op1, opb1)\n@@ -1707,7 +1695,6 @@ implies_p (rtx a, rtx b)\n rtx\n canon_condition (rtx cond)\n {\n-  rtx tem;\n   rtx op0, op1;\n   enum rtx_code code;\n   machine_mode mode;\n@@ -1719,9 +1706,7 @@ canon_condition (rtx cond)\n   if (swap_commutative_operands_p (op0, op1))\n     {\n       code = swap_condition (code);\n-      tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (op0, op1);\n     }\n \n   mode = GET_MODE (op0);"}, {"sha": "b8e9d1f0c168b57ea9dd410de456d485e3dccaac", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -3293,15 +3293,9 @@ simple_move_p (void)\n static inline void\n swap_operands (int nop)\n {\n-  machine_mode mode = curr_operand_mode[nop];\n-  curr_operand_mode[nop] = curr_operand_mode[nop + 1];\n-  curr_operand_mode[nop + 1] = mode;\n-  mode = original_subreg_reg_mode[nop];\n-  original_subreg_reg_mode[nop] = original_subreg_reg_mode[nop + 1];\n-  original_subreg_reg_mode[nop + 1] = mode;\n-  rtx x = *curr_id->operand_loc[nop];\n-  *curr_id->operand_loc[nop] = *curr_id->operand_loc[nop + 1];\n-  *curr_id->operand_loc[nop + 1] = x;\n+  std::swap (curr_operand_mode[nop], curr_operand_mode[nop + 1]);\n+  std::swap (original_subreg_reg_mode[nop], original_subreg_reg_mode[nop + 1]);\n+  std::swap (*curr_id->operand_loc[nop], *curr_id->operand_loc[nop + 1]);\n   /* Swap the duplicates too.  */\n   lra_update_dup (curr_id, nop);\n   lra_update_dup (curr_id, nop + 1);"}, {"sha": "085411ee7d0b22622e18cb61a7012379ddd345ea", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -192,7 +192,7 @@ lra_copy_live_range_list (lra_live_range_t r)\n lra_live_range_t\n lra_merge_live_ranges (lra_live_range_t r1, lra_live_range_t r2)\n {\n-  lra_live_range_t first, last, temp;\n+  lra_live_range_t first, last;\n \n   if (r1 == NULL)\n     return r2;\n@@ -201,16 +201,13 @@ lra_merge_live_ranges (lra_live_range_t r1, lra_live_range_t r2)\n   for (first = last = NULL; r1 != NULL && r2 != NULL;)\n     {\n       if (r1->start < r2->start)\n-\t{\n-\t  temp = r1;\n-\t  r1 = r2;\n-\t  r2 = temp;\n-\t}\n+\tstd::swap (r1, r2);\n+\n       if (r1->start == r2->finish + 1)\n \t{\n \t  /* Joint ranges: merge r1 and r2 into r1.  */\n \t  r1->start = r2->start;\n-\t  temp = r2;\n+\t  lra_live_range_t temp = r2;\n \t  r2 = r2->next;\n \t  pool_free (live_range_pool, temp);\n \t}"}, {"sha": "436d9f7178b974085f6223156677d6a3d5c80fcf", "filename": "gcc/omega.c", "status": "modified", "additions": 11, "deletions": 42, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1882,28 +1882,6 @@ cleanout_wildcards (omega_pb pb)\n     normalize_omega_problem (pb);\n }\n \n-/* Swap values contained in I and J.  */\n-\n-static inline void\n-swap (int *i, int *j)\n-{\n-  int tmp;\n-  tmp = *i;\n-  *i = *j;\n-  *j = tmp;\n-}\n-\n-/* Swap values contained in I and J.  */\n-\n-static inline void\n-bswap (bool *i, bool *j)\n-{\n-  bool tmp;\n-  tmp = *i;\n-  *i = *j;\n-  *j = tmp;\n-}\n-\n /* Make variable IDX unprotected in PB, by swapping its index at the\n    PB->safe_vars rank.  */\n \n@@ -1920,19 +1898,19 @@ omega_unprotect_1 (omega_pb pb, int *idx, bool *unprotect)\n       for (e = pb->num_geqs - 1; e >= 0; e--)\n \t{\n \t  pb->geqs[e].touched = 1;\n-\t  swap (&pb->geqs[e].coef[*idx], &pb->geqs[e].coef[j]);\n+\t  std::swap (pb->geqs[e].coef[*idx], pb->geqs[e].coef[j]);\n \t}\n \n       for (e = pb->num_eqs - 1; e >= 0; e--)\n-\tswap (&pb->eqs[e].coef[*idx], &pb->eqs[e].coef[j]);\n+\tstd::swap (pb->eqs[e].coef[*idx], pb->eqs[e].coef[j]);\n \n       for (e = pb->num_subs - 1; e >= 0; e--)\n-\tswap (&pb->subs[e].coef[*idx], &pb->subs[e].coef[j]);\n+\tstd::swap (pb->subs[e].coef[*idx], pb->subs[e].coef[j]);\n \n       if (unprotect)\n-\tbswap (&unprotect[*idx], &unprotect[j]);\n+\tstd::swap (unprotect[*idx], unprotect[j]);\n \n-      swap (&pb->var[*idx], &pb->var[j]);\n+      std::swap (pb->var[*idx], pb->var[j]);\n       pb->forwarding_address[pb->var[*idx]] = *idx;\n       pb->forwarding_address[pb->var[j]] = j;\n       (*idx)--;\n@@ -3999,7 +3977,6 @@ omega_solve_geq (omega_pb pb, enum omega_result desired_res)\n \n       if (i != n_vars)\n \t{\n-\t  int t;\n \t  int j = pb->num_vars;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4008,24 +3985,18 @@ omega_solve_geq (omega_pb pb, enum omega_result desired_res)\n \t      omega_print_problem (dump_file, pb);\n \t    }\n \n-\t  swap (&pb->var[i], &pb->var[j]);\n+\t  std::swap (pb->var[i], pb->var[j]);\n \n \t  for (e = pb->num_geqs - 1; e >= 0; e--)\n \t    if (pb->geqs[e].coef[i] != pb->geqs[e].coef[j])\n \t      {\n \t\tpb->geqs[e].touched = 1;\n-\t\tt = pb->geqs[e].coef[i];\n-\t\tpb->geqs[e].coef[i] = pb->geqs[e].coef[j];\n-\t\tpb->geqs[e].coef[j] = t;\n+\t\tstd::swap (pb->geqs[e].coef[i], pb->geqs[e].coef[j]);\n \t      }\n \n \t  for (e = pb->num_subs - 1; e >= 0; e--)\n \t    if (pb->subs[e].coef[i] != pb->subs[e].coef[j])\n-\t      {\n-\t\tt = pb->subs[e].coef[i];\n-\t\tpb->subs[e].coef[i] = pb->subs[e].coef[j];\n-\t\tpb->subs[e].coef[j] = t;\n-\t      }\n+\t      std::swap (pb->subs[e].coef[i], pb->subs[e].coef[j]);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -4624,16 +4595,14 @@ omega_solve_geq (omega_pb pb, enum omega_result desired_res)\n \t      /* Sort array LOWER_BOUND.  */\n \t      for (j = 0; j < lower_bounds; j++)\n \t\t{\n-\t\t  int k, smallest = j;\n+\t\t  int smallest = j;\n \n-\t\t  for (k = j + 1; k < lower_bounds; k++)\n+\t\t  for (int k = j + 1; k < lower_bounds; k++)\n \t\t    if (pb->geqs[lower_bound[smallest]].coef[i] >\n \t\t\tpb->geqs[lower_bound[k]].coef[i])\n \t\t      smallest = k;\n \n-\t\t  k = lower_bound[smallest];\n-\t\t  lower_bound[smallest] = lower_bound[j];\n-\t\t  lower_bound[j] = k;\n+\t\t  std::swap (lower_bound[smallest], lower_bound[j]);\n \t\t}\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "d883b000f0486d1dad04d1e7b82122d22994fe4b", "filename": "gcc/optabs.c", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1418,19 +1418,14 @@ expand_binop_directly (machine_mode mode, optab binoptab,\n   bool commutative_p;\n   rtx pat;\n   rtx xop0 = op0, xop1 = op1;\n-  rtx swap;\n \n   /* If it is a commutative operator and the modes would match\n      if we would swap the operands, we can save the conversions.  */\n   commutative_p = commutative_optab_p (binoptab);\n   if (commutative_p\n       && GET_MODE (xop0) != xmode0 && GET_MODE (xop1) != xmode1\n       && GET_MODE (xop0) == xmode1 && GET_MODE (xop1) == xmode1)\n-    {\n-      swap = xop0;\n-      xop0 = xop1;\n-      xop1 = swap;\n-    }\n+    std::swap (xop0, xop1);\n \n   /* If we are optimizing, force expensive constants into a register.  */\n   xop0 = avoid_expensive_constant (xmode0, binoptab, 0, xop0, unsignedp);\n@@ -1463,11 +1458,7 @@ expand_binop_directly (machine_mode mode, optab binoptab,\n      Also try to make the last operand a constant.  */\n   if (commutative_p\n       && swap_commutative_operands_with_target (target, xop0, xop1))\n-    {\n-      swap = xop1;\n-      xop1 = xop0;\n-      xop0 = swap;\n-    }\n+    std::swap (xop0, xop1);\n \n   /* Now, if insn's predicates don't allow our operands, put them into\n      pseudo regs.  */\n@@ -1722,11 +1713,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      Also try to make the last operand a constant.  */\n   if (commutative_optab_p (binoptab)\n       && swap_commutative_operands_with_target (target, op0, op1))\n-    {\n-      temp = op1;\n-      op1 = op0;\n-      op0 = temp;\n-    }\n+    std::swap (op0, op1);\n \n   /* These can be done a word at a time.  */\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n@@ -4553,7 +4540,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t       machine_mode cmode, rtx op2, rtx op3,\n \t\t       machine_mode mode, int unsignedp)\n {\n-  rtx tem, comparison;\n+  rtx comparison;\n   rtx_insn *last;\n   enum insn_code icode;\n   enum rtx_code reversed;\n@@ -4563,9 +4550,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   if (swap_commutative_operands_p (op0, op1))\n     {\n-      tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (op0, op1);\n       code = swap_condition (code);\n     }\n \n@@ -4584,9 +4569,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       && ((reversed = reversed_comparison_code_parts (code, op0, op1, NULL))\n           != UNKNOWN))\n     {\n-      tem = op2;\n-      op2 = op3;\n-      op3 = tem;\n+      std::swap (op2, op3);\n       code = reversed;\n     }\n \n@@ -4675,7 +4658,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t      machine_mode cmode, rtx op2, rtx op3,\n \t\t      machine_mode mode, int unsignedp)\n {\n-  rtx tem, comparison;\n+  rtx comparison;\n   rtx_insn *last;\n   enum insn_code icode;\n \n@@ -4684,9 +4667,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   if (swap_commutative_operands_p (op0, op1))\n     {\n-      tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (op0, op1);\n       code = swap_condition (code);\n     }\n "}, {"sha": "b12ef5b1028d03bd1f5d21b76412736eabe1adf4", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -632,7 +632,6 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n       int best = i;\n       int best_reject = alternative_reject[alternative_order[i]];\n       int best_nregs = alternative_nregs[alternative_order[i]];\n-      int tmp;\n \n       for (j = i + 1; j < recog_data.n_alternatives; j++)\n \t{\n@@ -648,9 +647,7 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \t    }\n \t}\n \n-      tmp = alternative_order[best];\n-      alternative_order[best] = alternative_order[i];\n-      alternative_order[i] = tmp;\n+      std::swap (alternative_order[best], alternative_order[i]);\n     }\n \n   /* Substitute the operands as determined by op_alt_regno for the best"}, {"sha": "a8637005dd744afe37995e380f8418b1973cc4a8", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -812,7 +812,7 @@ emit_swap_insn (rtx_insn *insn, stack_ptr regstack, rtx reg)\n {\n   int hard_regno;\n   rtx swap_rtx;\n-  int tmp, other_reg;\t\t/* swap regno temps */\n+  int other_reg;\t\t/* swap regno temps */\n   rtx_insn *i1;\t\t\t/* the stack-reg insn prior to INSN */\n   rtx i1set = NULL_RTX;\t\t/* the SET rtx within I1 */\n \n@@ -833,10 +833,7 @@ emit_swap_insn (rtx_insn *insn, stack_ptr regstack, rtx reg)\n   gcc_assert (hard_regno >= FIRST_STACK_REG);\n \n   other_reg = regstack->top - (hard_regno - FIRST_STACK_REG);\n-\n-  tmp = regstack->reg[other_reg];\n-  regstack->reg[other_reg] = regstack->reg[regstack->top];\n-  regstack->reg[regstack->top] = tmp;\n+  std::swap (regstack->reg[regstack->top], regstack->reg[other_reg]);\n \n   /* Find the previous insn involving stack regs, but don't pass a\n      block boundary.  */\n@@ -918,7 +915,7 @@ static void\n swap_to_top (rtx_insn *insn, stack_ptr regstack, rtx src1, rtx src2)\n {\n   struct stack_def temp_stack;\n-  int regno, j, k, temp;\n+  int regno, j, k;\n \n   temp_stack = *regstack;\n \n@@ -930,9 +927,7 @@ swap_to_top (rtx_insn *insn, stack_ptr regstack, rtx src1, rtx src2)\n       k = temp_stack.top - (regno - FIRST_STACK_REG);\n       j = temp_stack.top;\n \n-      temp = temp_stack.reg[k];\n-      temp_stack.reg[k] = temp_stack.reg[j];\n-      temp_stack.reg[j] = temp;\n+      std::swap (temp_stack.reg[j], temp_stack.reg[k]);\n     }\n \n   /* Place operand 2 next on the stack.  */\n@@ -943,9 +938,7 @@ swap_to_top (rtx_insn *insn, stack_ptr regstack, rtx src1, rtx src2)\n       k = temp_stack.top - (regno - FIRST_STACK_REG);\n       j = temp_stack.top - 1;\n \n-      temp = temp_stack.reg[k];\n-      temp_stack.reg[k] = temp_stack.reg[j];\n-      temp_stack.reg[j] = temp;\n+      std::swap (temp_stack.reg[j], temp_stack.reg[k]);\n     }\n \n   change_stack (insn, regstack, &temp_stack, EMIT_BEFORE);\n@@ -1261,10 +1254,7 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx pat_src)\n \t   && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))\n       && swap_rtx_condition (insn))\n     {\n-      rtx temp;\n-      temp = XEXP (pat_src, 0);\n-      XEXP (pat_src, 0) = XEXP (pat_src, 1);\n-      XEXP (pat_src, 1) = temp;\n+      std::swap (XEXP (pat_src, 0), XEXP (pat_src, 1));\n \n       src1 = get_true_reg (&XEXP (pat_src, 0));\n       src2 = get_true_reg (&XEXP (pat_src, 1));\n@@ -2139,15 +2129,13 @@ subst_asm_stack_regs (rtx_insn *insn, stack_ptr regstack)\n \t       it and swap it with whatever is already in I's place.\n \t       K is where recog_data.operand[i] is now.  J is where it\n \t       should be.  */\n-\t    int j, k, temp;\n+\t    int j, k;\n \n \t    k = temp_stack.top - (regno - FIRST_STACK_REG);\n \t    j = (temp_stack.top\n \t\t - (REGNO (recog_data.operand[i]) - FIRST_STACK_REG));\n \n-\t    temp = temp_stack.reg[k];\n-\t    temp_stack.reg[k] = temp_stack.reg[j];\n-\t    temp_stack.reg[j] = temp;\n+\t    std::swap (temp_stack.reg[j], temp_stack.reg[k]);\n \t  }\n       }\n "}, {"sha": "a3edb15d4be3c7596979a10e8466a6e0b2ff2878", "filename": "gcc/reload.c", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -3064,9 +3064,6 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \n \t  if (swapped)\n \t    {\n-\t      enum reg_class tclass;\n-\t      int t;\n-\n \t      recog_data.operand[commutative] = substed_operand[commutative + 1];\n \t      recog_data.operand[commutative + 1] = substed_operand[commutative];\n \t      /* Swap the duplicates too.  */\n@@ -3076,17 +3073,12 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t  *recog_data.dup_loc[i]\n \t\t    = recog_data.operand[(int) recog_data.dup_num[i]];\n \n-\t      tclass = preferred_class[commutative];\n-\t      preferred_class[commutative] = preferred_class[commutative + 1];\n-\t      preferred_class[commutative + 1] = tclass;\n-\n-\t      t = pref_or_nothing[commutative];\n-\t      pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n-\t      pref_or_nothing[commutative + 1] = t;\n-\n-\t      t = address_reloaded[commutative];\n-\t      address_reloaded[commutative] = address_reloaded[commutative + 1];\n-\t      address_reloaded[commutative + 1] = t;\n+\t      std::swap (preferred_class[commutative],\n+\t\t\t preferred_class[commutative + 1]);\n+\t      std::swap (pref_or_nothing[commutative],\n+\t\t\t pref_or_nothing[commutative + 1]);\n+\t      std::swap (address_reloaded[commutative],\n+\t\t\t address_reloaded[commutative + 1]);\n \t    }\n \n \t  this_earlyclobber = 0;\n@@ -3818,9 +3810,6 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \n \t  if (swapped)\n \t    {\n-\t      enum reg_class tclass;\n-\t      int t;\n-\n \t      /* If the commutative operands have been swapped, swap\n \t\t them back in order to check the next alternative.  */\n \t      recog_data.operand[commutative] = substed_operand[commutative];\n@@ -3833,17 +3822,12 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t    = recog_data.operand[(int) recog_data.dup_num[i]];\n \n \t      /* Unswap the operand related information as well.  */\n-\t      tclass = preferred_class[commutative];\n-\t      preferred_class[commutative] = preferred_class[commutative + 1];\n-\t      preferred_class[commutative + 1] = tclass;\n-\n-\t      t = pref_or_nothing[commutative];\n-\t      pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n-\t      pref_or_nothing[commutative + 1] = t;\n-\n-\t      t = address_reloaded[commutative];\n-\t      address_reloaded[commutative] = address_reloaded[commutative + 1];\n-\t      address_reloaded[commutative + 1] = t;\n+\t      std::swap (preferred_class[commutative],\n+\t\t\t preferred_class[commutative + 1]);\n+\t      std::swap (pref_or_nothing[commutative],\n+\t\t\t pref_or_nothing[commutative + 1]);\n+\t      std::swap (address_reloaded[commutative],\n+\t\t\t address_reloaded[commutative + 1]);\n \t    }\n \t}\n     }\n@@ -3892,18 +3876,12 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \n   if (goal_alternative_swapped)\n     {\n-      rtx tem;\n-\n-      tem = substed_operand[commutative];\n-      substed_operand[commutative] = substed_operand[commutative + 1];\n-      substed_operand[commutative + 1] = tem;\n-      tem = recog_data.operand[commutative];\n-      recog_data.operand[commutative] = recog_data.operand[commutative + 1];\n-      recog_data.operand[commutative + 1] = tem;\n-      tem = *recog_data.operand_loc[commutative];\n-      *recog_data.operand_loc[commutative]\n-\t= *recog_data.operand_loc[commutative + 1];\n-      *recog_data.operand_loc[commutative + 1] = tem;\n+      std::swap (substed_operand[commutative],\n+\t\t substed_operand[commutative + 1]);\n+      std::swap (recog_data.operand[commutative],\n+\t\t recog_data.operand[commutative + 1]);\n+      std::swap (*recog_data.operand_loc[commutative],\n+\t\t *recog_data.operand_loc[commutative + 1]);\n \n       for (i = 0; i < n_reloads; i++)\n \t{"}, {"sha": "3ac8c2da7642edefb28508697e24b6bc5101ee3d", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -5707,18 +5707,15 @@ gen_reload_chain_without_interm_reg_p (int r1, int r2)\n   /* Assume other cases in gen_reload are not possible for\n      chain reloads or do need an intermediate hard registers.  */\n   bool result = true;\n-  int regno, n, code;\n+  int regno, code;\n   rtx out, in;\n   rtx_insn *insn;\n   rtx_insn *last = get_last_insn ();\n \n   /* Make r2 a component of r1.  */\n   if (reg_mentioned_p (rld[r1].in, rld[r2].in))\n-    {\n-      n = r1;\n-      r1 = r2;\n-      r2 = n;\n-    }\n+    std::swap (r1, r2);\n+\n   gcc_assert (reg_mentioned_p (rld[r2].in, rld[r1].in));\n   regno = rld[r1].regno >= 0 ? rld[r1].regno : rld[r2].regno;\n   gcc_assert (regno >= 0);"}, {"sha": "6a58b2c4a8a2642e69c52ea33a0f2f69afab338d", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -4142,16 +4142,12 @@ invoke_reorder_hooks (fence_t fence)\n       for (i = 0, n = ready.n_ready; i < n; i++)\n         if (EXPR_INSN_RTX (vec[i]) != arr[i])\n           {\n-            expr_t tmp;\n-\n             for (j = i; j < n; j++)\n               if (EXPR_INSN_RTX (vec[j]) == arr[i])\n                 break;\n             gcc_assert (j < n);\n \n-            tmp = vec[i];\n-            vec[i] = vec[j];\n-            vec[j] = tmp;\n+\t    std::swap (vec[i], vec[j]);\n           }\n     }\n \n@@ -4610,15 +4606,12 @@ create_block_for_bookkeeping (edge e1, edge e2)\n \t    {\n \t      sel_global_bb_info_def gbi;\n \t      sel_region_bb_info_def rbi;\n-\t      int i;\n \n \t      if (sched_verbose >= 2)\n \t\tsel_print (\"Swapping block ids %i and %i\\n\",\n \t\t\t   new_bb->index, succ->index);\n \n-\t      i = new_bb->index;\n-\t      new_bb->index = succ->index;\n-\t      succ->index = i;\n+\t      std::swap (new_bb->index, succ->index);\n \n \t      SET_BASIC_BLOCK_FOR_FN (cfun, new_bb->index, new_bb);\n \t      SET_BASIC_BLOCK_FOR_FN (cfun, succ->index, succ);\n@@ -4633,15 +4626,13 @@ create_block_for_bookkeeping (edge e1, edge e2)\n \t\t      sizeof (rbi));\n \t      memcpy (SEL_REGION_BB_INFO (succ), &rbi, sizeof (rbi));\n \n-\t      i = BLOCK_TO_BB (new_bb->index);\n-\t      BLOCK_TO_BB (new_bb->index) = BLOCK_TO_BB (succ->index);\n-\t      BLOCK_TO_BB (succ->index) = i;\n+\t      std::swap (BLOCK_TO_BB (new_bb->index),\n+\t\t\t BLOCK_TO_BB (succ->index));\n \n-\t      i = CONTAINING_RGN (new_bb->index);\n-\t      CONTAINING_RGN (new_bb->index) = CONTAINING_RGN (succ->index);\n-\t      CONTAINING_RGN (succ->index) = i;\n+\t      std::swap (CONTAINING_RGN (new_bb->index),\n+\t\t\t CONTAINING_RGN (succ->index));\n \n-\t      for (i = 0; i < current_nr_blocks; i++)\n+\t      for (int i = 0; i < current_nr_blocks; i++)\n \t\tif (BB_TO_BLOCK (i) == succ->index)\n \t\t  BB_TO_BLOCK (i) = new_bb->index;\n \t\telse if (BB_TO_BLOCK (i) == new_bb->index)\n@@ -4666,10 +4657,8 @@ create_block_for_bookkeeping (edge e1, edge e2)\n \t\t\t   CODE_LABEL_NUMBER (BB_HEAD (new_bb)),\n \t\t\t   CODE_LABEL_NUMBER (BB_HEAD (succ)));\n \n-\t      i = CODE_LABEL_NUMBER (BB_HEAD (new_bb));\n-\t      CODE_LABEL_NUMBER (BB_HEAD (new_bb))\n-\t\t= CODE_LABEL_NUMBER (BB_HEAD (succ));\n-\t      CODE_LABEL_NUMBER (BB_HEAD (succ)) = i;\n+\t      std::swap (CODE_LABEL_NUMBER (BB_HEAD (new_bb)),\n+\t\t\t CODE_LABEL_NUMBER (BB_HEAD (succ)));\n \t    }\n \t}\n     }"}, {"sha": "505d63b00832d4aed0e0a6782a067f2596abf956", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -2411,18 +2411,6 @@ lambda_matrix_row_add (lambda_matrix mat, int n, int r1, int r2, int const1)\n     mat[r2][i] += const1 * mat[r1][i];\n }\n \n-/* Swap rows R1 and R2 in matrix MAT.  */\n-\n-static void\n-lambda_matrix_row_exchange (lambda_matrix mat, int r1, int r2)\n-{\n-  lambda_vector row;\n-\n-  row = mat[r1];\n-  mat[r1] = mat[r2];\n-  mat[r2] = row;\n-}\n-\n /* Multiply vector VEC1 of length SIZE by a constant CONST1,\n    and store the result in VEC2.  */\n \n@@ -2503,10 +2491,10 @@ lambda_matrix_right_hermite (lambda_matrix A, int m, int n,\n \t\t  factor = sigma * (a / b);\n \n \t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n-\t\t  lambda_matrix_row_exchange (S, i, i-1);\n+\t\t  std::swap (S[i], S[i-1]);\n \n \t\t  lambda_matrix_row_add (U, m, i, i-1, -factor);\n-\t\t  lambda_matrix_row_exchange (U, i, i-1);\n+\t\t  std::swap (U[i], U[i-1]);\n \t\t}\n \t    }\n \t}"}, {"sha": "b05a86086efbe25276ef277ba890cb924fcb526c", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -433,15 +433,13 @@ sort_coalesce_list (coalesce_list_p cl)\n   if (num == 2)\n     {\n       if (cl->sorted[0]->cost > cl->sorted[1]->cost)\n-        {\n-\t  p = cl->sorted[0];\n-\t  cl->sorted[0] = cl->sorted[1];\n-\t  cl->sorted[1] = p;\n-\t}\n+\tstd::swap (cl->sorted[0], cl->sorted[1]);\n       return;\n     }\n \n-  /* Only call qsort if there are more than 2 items.  */\n+  /* Only call qsort if there are more than 2 items.\n+     ??? Maybe std::sort will do better, provided that compare_pairs\n+     can be inlined.  */\n   if (num > 2)\n       qsort (cl->sorted, num, sizeof (coalesce_pair_p), compare_pairs);\n }"}, {"sha": "4170c9be3af15e01fe109ef420b5f34b88de5dd7", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -438,25 +438,13 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n \t;\n       else if (bits1 == bits2)\n \t{\n-\t  t = name2;\n-\t  name2 = bits2;\n-\t  bits2 = t;\n-\t  t = name1;\n-\t  name1 = bits1;\n-\t  bits1 = t;\n+\t  std::swap (name2, bits2);\n+\t  std::swap (name1, bits1);\n \t}\n       else if (name1 == bits2)\n-\t{\n-\t  t = name2;\n-\t  name2 = bits2;\n-\t  bits2 = t;\n-\t}\n+\tstd::swap (name2, bits2);\n       else if (bits1 == name2)\n-\t{\n-\t  t = name1;\n-\t  name1 = bits1;\n-\t  bits1 = t;\n-\t}\n+\tstd::swap (name1, bits1);\n       else\n \treturn false;\n "}, {"sha": "3ed32d8e2fbbc02dcae18da061a0052096b96740", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -5587,17 +5587,14 @@ static struct iv_ca_delta *\n iv_ca_delta_reverse (struct iv_ca_delta *delta)\n {\n   struct iv_ca_delta *act, *next, *prev = NULL;\n-  struct cost_pair *tmp;\n \n   for (act = delta; act; act = next)\n     {\n       next = act->next_change;\n       act->next_change = prev;\n       prev = act;\n \n-      tmp = act->old_cp;\n-      act->old_cp = act->new_cp;\n-      act->new_cp = tmp;\n+      std::swap (act->old_cp, act->new_cp);\n     }\n \n   return prev;"}, {"sha": "98e2c49533351494d2626704550bd9bcef105282", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -3013,13 +3013,8 @@ is_widening_mult_p (gimple stmt,\n   /* Ensure that the larger of the two operands comes first. */\n   if (TYPE_PRECISION (*type1_out) < TYPE_PRECISION (*type2_out))\n     {\n-      tree tmp;\n-      tmp = *type1_out;\n-      *type1_out = *type2_out;\n-      *type2_out = tmp;\n-      tmp = *rhs1_out;\n-      *rhs1_out = *rhs2_out;\n-      *rhs2_out = tmp;\n+      std::swap (*type1_out, *type2_out);\n+      std::swap (*rhs1_out, *rhs2_out);\n     }\n \n   return true;"}, {"sha": "09d6f6749108db4c51b496e960017f3c8c5e69ab", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -1911,8 +1911,8 @@ hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n   for (gsi = gsi_start_phis (bb3); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi_stmt = gsi.phi ();\n-      gimple def1, def2, defswap;\n-      tree arg1, arg2, ref1, ref2, field1, field2, fieldswap;\n+      gimple def1, def2;\n+      tree arg1, arg2, ref1, ref2, field1, field2;\n       tree tree_offset1, tree_offset2, tree_size2, next;\n       int offset1, offset2, size2;\n       unsigned align1;\n@@ -1987,12 +1987,8 @@ hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n \t  if (next != field1)\n \t    continue;\n \n-\t  fieldswap = field1;\n-\t  field1 = field2;\n-\t  field2 = fieldswap;\n-\t  defswap = def1;\n-\t  def1 = def2;\n-\t  def2 = defswap;\n+\t  std::swap (field1, field2);\n+\t  std::swap (def1, def2);\n \t}\n \n       bb_for_def1 = gimple_bb (def1);"}, {"sha": "0c67379a5be29fdc78aadad7ebdc06d47396ad51", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -4117,8 +4117,6 @@ linearize_expr_tree (vec<operand_entry_t> *ops, gimple stmt,\n \n   if (!binlhsisreassoc)\n     {\n-      tree temp;\n-\n       /* If this is not a associative operation like division, give up.  */\n       if (!is_associative)\n \t{\n@@ -4170,9 +4168,7 @@ linearize_expr_tree (vec<operand_entry_t> *ops, gimple stmt,\n \n       /* We want to make it so the lhs is always the reassociative op,\n \t so swap.  */\n-      temp = binlhs;\n-      binlhs = binrhs;\n-      binrhs = temp;\n+      std::swap (binlhs, binrhs);\n     }\n   else if (binrhsisreassoc)\n     {"}, {"sha": "932b443d2cd28b6ea63e9d2e1265fa2832ef500b", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -544,11 +544,8 @@ simplify_control_stmt_condition (edge e,\n \t miss threading opportunities.  */\n       if (tree_swap_operands_p (op0, op1, false))\n \t{\n-\t  tree tmp;\n \t  cond_code = swap_tree_comparison (cond_code);\n-\t  tmp = op0;\n-\t  op0 = op1;\n-\t  op1 = tmp;\n+\t  std::swap (op0, op1);\n \t}\n \n       /* Stuff the operator and operands into our dummy conditional"}, {"sha": "22587d00bc564239448c099f56ad723df9a076d4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -4556,11 +4556,8 @@ compare_ranges (enum tree_code comp, value_range_t *vr0, value_range_t *vr1,\n      operands around and change the comparison code.  */\n   if (comp == GT_EXPR || comp == GE_EXPR)\n     {\n-      value_range_t *tmp;\n       comp = (comp == GT_EXPR) ? LT_EXPR : LE_EXPR;\n-      tmp = vr0;\n-      vr0 = vr1;\n-      vr1 = tmp;\n+      std::swap (vr0, vr1);\n     }\n \n   if (comp == EQ_EXPR)"}, {"sha": "0db43584f02e9ae5d773e492be2db0562abb406c", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab27f52895115e2986e7bc6a3c376411f847df7/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=fab27f52895115e2986e7bc6a3c376411f847df7", "patch": "@@ -6509,13 +6509,7 @@ add_with_sets (rtx_insn *insn, struct cselib_set *sets, int n_sets)\n       while (n1 < n2 && mos[n2].type != MO_USE)\n \tn2--;\n       if (n1 < n2)\n-\t{\n-\t  micro_operation sw;\n-\n-\t  sw = mos[n1];\n-\t  mos[n1] = mos[n2];\n-\t  mos[n2] = sw;\n-\t}\n+\tstd::swap (mos[n1], mos[n2]);\n     }\n \n   n2 = VTI (bb)->mos.length () - 1;\n@@ -6526,13 +6520,7 @@ add_with_sets (rtx_insn *insn, struct cselib_set *sets, int n_sets)\n       while (n1 < n2 && mos[n2].type == MO_VAL_LOC)\n \tn2--;\n       if (n1 < n2)\n-\t{\n-\t  micro_operation sw;\n-\n-\t  sw = mos[n1];\n-\t  mos[n1] = mos[n2];\n-\t  mos[n2] = sw;\n-\t}\n+\tstd::swap (mos[n1], mos[n2]);\n     }\n \n   if (CALL_P (insn))\n@@ -6568,13 +6556,7 @@ add_with_sets (rtx_insn *insn, struct cselib_set *sets, int n_sets)\n       while (n1 < n2 && mos[n2].type != MO_VAL_USE)\n \tn2--;\n       if (n1 < n2)\n-\t{\n-\t  micro_operation sw;\n-\n-\t  sw = mos[n1];\n-\t  mos[n1] = mos[n2];\n-\t  mos[n2] = sw;\n-\t}\n+\tstd::swap (mos[n1], mos[n2]);\n     }\n \n   n2 = VTI (bb)->mos.length () - 1;\n@@ -6585,13 +6567,7 @@ add_with_sets (rtx_insn *insn, struct cselib_set *sets, int n_sets)\n       while (n1 < n2 && mos[n2].type != MO_CLOBBER)\n \tn2--;\n       if (n1 < n2)\n-\t{\n-\t  micro_operation sw;\n-\n-\t  sw = mos[n1];\n-\t  mos[n1] = mos[n2];\n-\t  mos[n2] = sw;\n-\t}\n+\tstd::swap (mos[n1], mos[n2]);\n     }\n }\n \n@@ -6982,8 +6958,7 @@ vt_find_locations (void)\n {\n   bb_heap_t *worklist = new bb_heap_t (LONG_MIN);\n   bb_heap_t *pending = new bb_heap_t (LONG_MIN);\n-  bb_heap_t *fibheap_swap = NULL;\n-  sbitmap visited, in_worklist, in_pending, sbitmap_swap;\n+  sbitmap visited, in_worklist, in_pending;\n   basic_block bb;\n   edge e;\n   int *bb_order;\n@@ -7014,12 +6989,8 @@ vt_find_locations (void)\n \n   while (success && !pending->empty ())\n     {\n-      fibheap_swap = pending;\n-      pending = worklist;\n-      worklist = fibheap_swap;\n-      sbitmap_swap = in_pending;\n-      in_pending = in_worklist;\n-      in_worklist = sbitmap_swap;\n+      std::swap (worklist, pending);\n+      std::swap (in_worklist, in_pending);\n \n       bitmap_clear (visited);\n "}]}