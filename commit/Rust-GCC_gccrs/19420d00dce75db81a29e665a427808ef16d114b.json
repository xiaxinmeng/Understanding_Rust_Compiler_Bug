{"sha": "19420d00dce75db81a29e665a427808ef16d114b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk0MjBkMDBkY2U3NWRiODFhMjllNjY1YTQyNzgwOGVmMTZkMTE0Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-08-18T09:31:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-08-18T09:31:11Z"}, "message": "cp-tree.h (PTRMEM_OK_P): New macro.\n\n\t* cp-tree.h (PTRMEM_OK_P): New macro.\n\t(itf_ptrmem_ok): New enumeration value.\n\t* class.c (resolve_address_of_overloaded_function): Add PTRMEM\n\targument. Diagnose implicit pointer to member.\n\t(instantiate_type): Don't diagnose implicit pointer to member\n\there. Pass itf_ptrmem_ok if ok. Adjust calls to\n\tresolve_address_of_overloaded_function.\n\t* init.c (build_offset_ref): Set PTRMEM_OK_P.\n\t(resolve_offset_ref): Don't diagnose implicit pointer to member here.\n\t* semantics.c (finish_parenthesized_expr): Clear OFFSET_REFs here.\n\t* typeck.c (build_x_unary_op): Calculate PTRMEM_OK_P.\n\t(build_unary_op): Deal with single non-static member in\n\tmicrosoft-land.\n\nFrom-SVN: r35777", "tree": {"sha": "b24281de984b1e9b0eb24d983437a18b4ee38340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b24281de984b1e9b0eb24d983437a18b4ee38340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19420d00dce75db81a29e665a427808ef16d114b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19420d00dce75db81a29e665a427808ef16d114b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19420d00dce75db81a29e665a427808ef16d114b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19420d00dce75db81a29e665a427808ef16d114b/comments", "author": null, "committer": null, "parents": [{"sha": "c34911732455bc99d88661e9b4cd287fc4b0cc07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34911732455bc99d88661e9b4cd287fc4b0cc07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34911732455bc99d88661e9b4cd287fc4b0cc07"}], "stats": {"total": 187, "additions": 105, "deletions": 82}, "files": [{"sha": "35a206768876b581781679457d8ae9fc4b00b1bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=19420d00dce75db81a29e665a427808ef16d114b", "patch": "@@ -1,3 +1,19 @@\n+2000-08-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (PTRMEM_OK_P): New macro.\n+\t(itf_ptrmem_ok): New enumeration value.\n+\t* class.c (resolve_address_of_overloaded_function): Add PTRMEM\n+\targument. Diagnose implicit pointer to member.\n+\t(instantiate_type): Don't diagnose implicit pointer to member\n+\there. Pass itf_ptrmem_ok if ok. Adjust calls to\n+\tresolve_address_of_overloaded_function.\n+\t* init.c (build_offset_ref): Set PTRMEM_OK_P.\n+\t(resolve_offset_ref): Don't diagnose implicit pointer to member here.\n+\t* semantics.c (finish_parenthesized_expr): Clear OFFSET_REFs here.\n+\t* typeck.c (build_x_unary_op): Calculate PTRMEM_OK_P.\n+\t(build_unary_op): Deal with single non-static member in\n+\tmicrosoft-land.\n+\n 2000-08-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl2.c (arg_assoc_type): Cope with TYPENAME_TYPE."}, {"sha": "f749c74e6d836b9f0bacfd34a86b4ce41e0057bf", "filename": "gcc/cp/class.c", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=19420d00dce75db81a29e665a427808ef16d114b", "patch": "@@ -132,7 +132,7 @@ static int method_name_cmp PARAMS ((const tree *, const tree *));\n static tree add_implicitly_declared_members PARAMS ((tree, int, int, int));\n static tree fixed_type_or_null PARAMS ((tree, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n-\t\t\t\t\t\t\t  int, tree));\n+\t\t\t\t\t\t\t  int, int, tree));\n static void build_vtable_entry_ref PARAMS ((tree, tree, tree));\n static tree build_vtbl_initializer PARAMS ((tree, tree, tree, tree, int *));\n static int count_fields PARAMS ((tree));\n@@ -5725,19 +5725,22 @@ pop_lang_context ()\n /* Given an OVERLOAD and a TARGET_TYPE, return the function that\n    matches the TARGET_TYPE.  If there is no satisfactory match, return\n    error_mark_node, and issue an error message if COMPLAIN is\n-   non-zero.  If TEMPLATE_ONLY, the name of the overloaded function\n+   non-zero.  Permit pointers to member function if PTRMEM is non-zero.\n+   If TEMPLATE_ONLY, the name of the overloaded function\n    was a template-id, and EXPLICIT_TARGS are the explicitly provided\n    template arguments.  */\n \n static tree\n resolve_address_of_overloaded_function (target_type, \n \t\t\t\t\toverload,\n-\t\t\t\t\tcomplain, \n+\t\t\t\t\tcomplain,\n+\t                                ptrmem,\n \t\t\t\t\ttemplate_only,\n \t\t\t\t\texplicit_targs)\n      tree target_type;\n      tree overload;\n      int complain;\n+     int ptrmem;\n      int template_only;\n      tree explicit_targs;\n {\n@@ -5960,6 +5963,14 @@ resolve_address_of_overloaded_function (target_type,\n   /* Good, exactly one match.  Now, convert it to the correct type.  */\n   fn = TREE_PURPOSE (matches);\n \n+  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+      && !ptrmem && !flag_ms_extensions)\n+    {\n+      if (!complain)\n+        return error_mark_node;\n+\n+      cp_pedwarn (\"assuming pointer to member `%D'\", fn);\n+    }\n   mark_used (fn);\n \n   if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))\n@@ -5993,7 +6004,9 @@ instantiate_type (lhstype, rhs, flags)\n   int complain = (flags & itf_complain);\n   int strict = (flags & itf_no_attributes)\n                ? COMPARE_NO_ATTRIBUTES : COMPARE_STRICT;\n-  tree r;\n+  int allow_ptrmem = flags & itf_ptrmem_ok;\n+  \n+  flags &= ~itf_ptrmem_ok;\n   \n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n@@ -6053,36 +6066,13 @@ instantiate_type (lhstype, rhs, flags)\n       return instantiate_type (lhstype, rhs, flags);\n \n     case COMPONENT_REF:\n-      {\n-\tr = instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n-\n-      comp:\n-\tif (r != error_mark_node && TYPE_PTRMEMFUNC_P (lhstype)\n-\t    && complain && !flag_ms_extensions)\n-\t  {\n-\t    /* Note: we check this after the recursive call to avoid\n-\t       complaining about cases where overload resolution fails.  */\n-\n-\t    tree t = TREE_TYPE (TREE_OPERAND (rhs, 0));\n-\t    tree fn = PTRMEM_CST_MEMBER (r);\n-\n-\t    my_friendly_assert (TREE_CODE (r) == PTRMEM_CST, 990811);\n-\n-\t    cp_pedwarn\n-\t      (\"object-dependent reference to `%E' can only be used in a call\",\n-\t       DECL_NAME (fn));\n-\t    cp_pedwarn\n-\t      (\"  to form a pointer to member function, say `&%T::%E'\",\n-\t       t, DECL_NAME (fn));\n-\t  }\n-\n-\treturn r;\n-      }\n+      return instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n \n     case OFFSET_REF:\n       rhs = TREE_OPERAND (rhs, 1);\n       if (BASELINK_P (rhs))\n-\treturn instantiate_type (lhstype, TREE_VALUE (rhs), flags);\n+\treturn instantiate_type (lhstype, TREE_VALUE (rhs),\n+\t                         flags | allow_ptrmem);\n \n       /* This can happen if we are forming a pointer-to-member for a\n \t member template.  */\n@@ -6095,25 +6085,21 @@ instantiate_type (lhstype, rhs, flags)\n \ttree fns = TREE_OPERAND (rhs, 0);\n \ttree args = TREE_OPERAND (rhs, 1);\n \n-\tr =\n+\treturn\n \t  resolve_address_of_overloaded_function (lhstype,\n \t\t\t\t\t\t  fns,\n \t\t\t\t\t\t  complain,\n+\t                                          allow_ptrmem,\n \t\t\t\t\t\t  /*template_only=*/1,\n \t\t\t\t\t\t  args);\n-\tif (TREE_CODE (fns) == COMPONENT_REF)\n-\t  {\n-\t    rhs = fns;\n-\t    goto comp;\n-\t  }\n-\treturn r;\n       }\n \n     case OVERLOAD:\n       return \n \tresolve_address_of_overloaded_function (lhstype, \n \t\t\t\t\t\trhs,\n \t\t\t\t\t\tcomplain,\n+\t                                        allow_ptrmem,\n \t\t\t\t\t\t/*template_only=*/0,\n \t\t\t\t\t\t/*explicit_targs=*/NULL_TREE);\n \n@@ -6225,8 +6211,12 @@ instantiate_type (lhstype, rhs, flags)\n       return rhs;\n       \n     case ADDR_EXPR:\n+    {\n+      if (PTRMEM_OK_P (rhs))\n+        flags |= itf_ptrmem_ok;\n+      \n       return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n-\n+    }\n     case ENTRY_VALUE_EXPR:\n       my_friendly_abort (184);\n       return error_mark_node;"}, {"sha": "af39281b1363ae311c52451b6c3012b75d343f23", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=19420d00dce75db81a29e665a427808ef16d114b", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       CTOR_BEGIN_P (in CTOR_STMT)\n       BV_USE_VCALL_INDEX_P (in the BINFO_VIRTUALS TREE_LIST)\n+      PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -2666,6 +2667,10 @@ extern int flag_new_for_scope;\n #define TYPE_PTRMEMFUNC_FLAG(NODE) \\\n   (TYPE_LANG_SPECIFIC(NODE)->ptrmemfunc_flag)\n \n+/* Indicates when overload resolution may resolve to a pointer to\n+   member function. [expr.unary.op]/3 */\n+#define PTRMEM_OK_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+\n /* A pointer-to-function member type looks like:\n \n    struct {\n@@ -3208,7 +3213,8 @@ typedef enum special_function_kind {\n typedef enum instantiate_type_flags {\n   itf_none = 0,               /* nothing special */\n   itf_complain = 1 << 0,      /* complain about errors */\n-  itf_no_attributes = 1 << 1  /* ignore attributes on comparisons */\n+  itf_no_attributes = 1 << 1, /* ignore attributes on comparisons */\n+  itf_ptrmem_ok = 1 << 2,     /* pointers to member ok (internal use) */\n } instantiate_type_flags;\n \n /* Non-zero means that if a label exists, and no other identifier"}, {"sha": "097deb7028b483b755c94f27aef7c663895b408c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=19420d00dce75db81a29e665a427808ef16d114b", "patch": "@@ -1710,13 +1710,13 @@ build_offset_ref (type, name)\n \t       expects to encounter OVERLOADs, not raw functions.  */\n \t    t = ovl_cons (t, NULL_TREE);\n \n-\t  return build (OFFSET_REF, \n-\t\t\tunknown_type_node,\n-\t\t\tdecl,\n-\t\t\tbuild (TEMPLATE_ID_EXPR, \n-\t\t\t       TREE_TYPE (t),\n-\t\t\t       t,\n-\t\t\t       TREE_OPERAND (orig_name, 1)));\n+          t = build (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n+\t             TREE_OPERAND (orig_name, 1));\n+\t  t = build (OFFSET_REF, unknown_type_node, decl, t);\n+          \n+          PTRMEM_OK_P (t) = 1;\n+          \t  \n+\t  return t;\n \t}\n \n       if (!really_overloaded_fn (t))\n@@ -1730,11 +1730,16 @@ build_offset_ref (type, name)\n \t  mark_used (t);\n \t  if (DECL_STATIC_FUNCTION_P (t))\n \t    return t;\n-\t  return build (OFFSET_REF, TREE_TYPE (t), decl, t);\n+\t  t = build (OFFSET_REF, TREE_TYPE (t), decl, t);\n+\t  PTRMEM_OK_P (t) = 1;\n+\t  return t;\n \t}\n \n       TREE_TYPE (fnfields) = unknown_type_node;\n-      return build (OFFSET_REF, unknown_type_node, decl, fnfields);\n+      \n+      t = build (OFFSET_REF, unknown_type_node, decl, fnfields);\n+      PTRMEM_OK_P (t) = 1;\n+      return t;\n     }\n \n   t = member;\n@@ -1772,7 +1777,9 @@ build_offset_ref (type, name)\n   /* In member functions, the form `type::name' is no longer\n      equivalent to `this->type::name', at least not until\n      resolve_offset_ref.  */\n-  return build (OFFSET_REF, build_offset_type (type, TREE_TYPE (t)), decl, t);\n+  t = build (OFFSET_REF, build_offset_type (type, TREE_TYPE (t)), decl, t);\n+  PTRMEM_OK_P (t) = 1;\n+  return t;\n }\n \n /* If a OFFSET_REF made it through to here, then it did\n@@ -1806,16 +1813,15 @@ resolve_offset_ref (exp)\n     }\n \n   if (BASELINK_P (member))\n-    {\n-      if (! flag_ms_extensions)\n-\tcp_pedwarn (\"assuming & on overloaded member function\");\n-      return build_unary_op (ADDR_EXPR, exp, 0);\n-    }\n-\n+    return build_unary_op (ADDR_EXPR, exp, 0);\n+  \n   if (TREE_CODE (TREE_TYPE (member)) == METHOD_TYPE)\n     {\n-      if (! flag_ms_extensions)\n-\tcp_pedwarn (\"assuming & on `%E'\", member);\n+      if (!flag_ms_extensions)\n+        /* A single non-static member, make sure we don't allow a\n+           pointer-to-member.  */\n+        exp = ovl_cons (member, NULL_TREE);\n+      \n       return build_unary_op (ADDR_EXPR, exp, 0);\n     }\n "}, {"sha": "70ef712ca841d6be8654095cb6ae51d257a49a3c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=19420d00dce75db81a29e665a427808ef16d114b", "patch": "@@ -1331,6 +1331,10 @@ finish_parenthesized_expr (expr)\n     /* This inhibits warnings in truthvalue_conversion.  */\n     C_SET_EXP_ORIGINAL_CODE (expr, ERROR_MARK); \n \n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    /* [expr.unary.op]/3 The qualified id of a pointer-to-member must not be\n+       enclosed in parentheses.  */\n+    PTRMEM_OK_P (expr) = 0;\n   return expr;\n }\n "}, {"sha": "9ab9b87648536bbe75695d3a64e79673ee064c4f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19420d00dce75db81a29e665a427808ef16d114b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=19420d00dce75db81a29e665a427808ef16d114b", "patch": "@@ -4260,6 +4260,9 @@ build_x_unary_op (code, xarg)\n      enum tree_code code;\n      tree xarg;\n {\n+  tree exp;\n+  int ptrmem = 0;\n+  \n   if (processing_template_decl)\n     return build_min_nt (code, xarg, NULL_TREE);\n \n@@ -4280,14 +4283,26 @@ build_x_unary_op (code, xarg)\n       if (rval || code != ADDR_EXPR)\n \treturn rval;\n     }\n-\n   if (code == ADDR_EXPR)\n     {\n-      if (TREE_CODE (xarg) == TARGET_EXPR)\n+      if (TREE_CODE (xarg) == OFFSET_REF)\n+        {\n+          ptrmem = PTRMEM_OK_P (xarg);\n+          \n+          if (!ptrmem && !flag_ms_extensions\n+              && TREE_CODE (TREE_TYPE (TREE_OPERAND (xarg, 1))) == METHOD_TYPE)\n+            /* A single non-static member, make sure we don't allow a\n+               pointer-to-member.  */\n+            xarg = ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE);\n+        }\n+      else if (TREE_CODE (xarg) == TARGET_EXPR)\n \twarning (\"taking address of temporary\");\n     }\n+  exp = build_unary_op (code, xarg, 0);\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    PTRMEM_OK_P (exp) = ptrmem;\n \n-  return build_unary_op (code, xarg, 0);\n+  return exp;\n }\n \n /* Just like truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */\n@@ -4635,35 +4650,21 @@ build_unary_op (code, xarg, noconvert)\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n \n-      if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n-\t  && OVL_NEXT (TREE_OPERAND (arg, 1)) == NULL_TREE)\n-\t{\n+      if (TREE_CODE (arg) == COMPONENT_REF && flag_ms_extensions\n+          && type_unknown_p (arg)\n+          && OVL_NEXT (TREE_OPERAND (arg, 1)) == NULL_TREE)\n+        {\n \t  /* They're trying to take the address of a unique non-static\n-\t     member function.  This is ill-formed, but let's try to DTRT.\n-\t     Note: We only handle unique functions here because we don't\n-\t     want to complain if there's a static overload; non-unique\n-\t     cases will be handled by instantiate_type.  But we need to\n-\t     handle this case here to allow casts on the resulting PMF.  */\n+\t     member function.  This is ill-formed, except in microsoft-land.  */\n \n \t  tree base = TREE_TYPE (TREE_OPERAND (arg, 0));\n \t  tree name = DECL_NAME (OVL_CURRENT (TREE_OPERAND (arg, 1)));\n-\n-\t  if (! flag_ms_extensions)\n-\t    {\n-\t      if (current_class_type\n-\t\t  && TREE_OPERAND (arg, 0) == current_class_ref)\n-\t\t/* An expression like &memfn.  */\n-\t\tcp_pedwarn (\"ISO C++ forbids taking the address of a non-static member function to form a pointer to member function.  Say `&%T::%D'\", base, name);\n-\t      else\n-\t\tcp_pedwarn (\"ISO C++ forbids taking the address of a bound member function to form a pointer to member function\", base, name);\n-\t    }\n-\n \t  arg = build_offset_ref (base, name);\n-\t}\n-\n+        }\n+        \n       if (type_unknown_p (arg))\n \treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n-\n+\t\n       /* Handle complex lvalues (when permitted)\n \t by reduction to simpler cases.  */\n       val = unary_complex_lvalue (code, arg);"}]}