{"sha": "9cf737f89ffe0c75614ad388440b7b7706b6316b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNmNzM3Zjg5ZmZlMGM3NTYxNGFkMzg4NDQwYjdiNzcwNmI2MzE2Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-05-30T18:32:31Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-05-30T18:32:31Z"}, "message": "bb-reorder.c, [...]: Fix comment formatting.\n\n\t* bb-reorder.c, builtins.c, c-common.c, c-gimplify.c,\n\tc-incpath.c, cgraphunit.c, ddg.c, defaults.h, dwarf2out.c,\n\texpmed.c, flags.h, gcc.c, gensupport.c, gimplify.c, global.c,\n\tpasses.c, reg-stack.c, target.h, toplev.c, tree-alias-ander.c,\n\ttree-alias-common.c, tree-cfg.c, tree-complex.c, tree-dfa.c,\n\ttree-eh.c, tree-mudflap.c, tree-mudflap.h, tree-outof-ssa.c,\n\ttree-phinodes.c, tree-pretty-print.c, tree-ssa-alias.c,\n\ttree-ssa-ccp.c, tree-ssa-live.c, tree-ssa-live.h,\n\ttree-ssa-pre.c, tree.h, value-prof.h, varasm.c: Fix comment\n\tformatting.\n\nFrom-SVN: r82463", "tree": {"sha": "baf32c5e895885ca41746d8d293000d998661d76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baf32c5e895885ca41746d8d293000d998661d76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cf737f89ffe0c75614ad388440b7b7706b6316b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf737f89ffe0c75614ad388440b7b7706b6316b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cf737f89ffe0c75614ad388440b7b7706b6316b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf737f89ffe0c75614ad388440b7b7706b6316b/comments", "author": null, "committer": null, "parents": [{"sha": "0f1f6967a21f8e4cc6ca7448dd9adc5d09c99edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1f6967a21f8e4cc6ca7448dd9adc5d09c99edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1f6967a21f8e4cc6ca7448dd9adc5d09c99edb"}], "stats": {"total": 315, "additions": 164, "deletions": 151}, "files": [{"sha": "98cd5934ca40df5fb5e6abc8123f719ed18d545d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1,3 +1,16 @@\n+2004-05-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* bb-reorder.c, builtins.c, c-common.c, c-gimplify.c,\n+\tc-incpath.c, cgraphunit.c, ddg.c, defaults.h, dwarf2out.c,\n+\texpmed.c, flags.h, gcc.c, gensupport.c, gimplify.c, global.c,\n+\tpasses.c, reg-stack.c, target.h, toplev.c, tree-alias-ander.c,\n+\ttree-alias-common.c, tree-cfg.c, tree-complex.c, tree-dfa.c,\n+\ttree-eh.c, tree-mudflap.c, tree-mudflap.h, tree-outof-ssa.c,\n+\ttree-phinodes.c, tree-pretty-print.c, tree-ssa-alias.c,\n+\ttree-ssa-ccp.c, tree-ssa-live.c, tree-ssa-live.h,\n+\ttree-ssa-pre.c, tree.h, value-prof.h, varasm.c: Fix comment\n+\tformatting.\n+\n 2004-05-30  Steven Bosscher  <stevenb@suse.de>\n \n \t* gimplify.c (sort_case_labels): New.  Split out from..."}, {"sha": "afac18843ba3c798afdef1f7d24f303c2357d174", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1331,7 +1331,7 @@ mark_bb_for_unlikely_executed_section (basic_block bb)\n \n /* If any destination of a crossing edge does not have a label, add label;\n    Convert any fall-through crossing edges (for blocks that do not contain\n-   a jump) to unconditional jumps.   */\n+   a jump) to unconditional jumps.  */\n \n static void \n add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n@@ -1472,7 +1472,7 @@ fix_up_fall_thru_edges (void)\n \t\t      && cur_bb->rbi->next == cond_jump->dest)\n  \t\t    {\n  \t\t      /* Find label in fall_thru block. We've already added\n- \t\t         any missing labels, so there must be one. */\n+ \t\t         any missing labels, so there must be one.  */\n  \t\t      \n  \t\t      fall_thru_label = block_label (fall_thru->dest);\n \n@@ -1554,7 +1554,7 @@ find_jump_block (basic_block jump_dest)\n \t\n \t/* Check each predecessor to see if it has a label, and contains\n \t   only one executable instruction, which is an unconditional jump.\n-\t   If so, we can use it.   */\n+\t   If so, we can use it.  */\n \t\n \tif (GET_CODE (BB_HEAD (src)) == CODE_LABEL)\n \t  for (insn = BB_HEAD (src); "}, {"sha": "28eb1296b38fa7c0f914a06233525bb673696c9e", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1994,7 +1994,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n     errno_set = false;\n \n   /* Check if sincos insn is available, otherwise fallback\n-     to sin or cos insn. */\n+     to sin or cos insn.  */\n   if (builtin_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing) {\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n@@ -8893,7 +8893,7 @@ simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n       {\n \ttree string_arg;\n \n-\t/* If optimizing for size keep fputs. */\n+\t/* If optimizing for size keep fputs.  */\n \tif (optimize_size)\n \t  return 0;\n \tstring_arg = TREE_VALUE (arglist);"}, {"sha": "666dc40a716d79fe36b7aa2843324dc3ac1c3088", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -2820,7 +2820,7 @@ c_apply_type_quals_to_decl (int type_quals, tree decl)\n /* Hash function for the problem of multiple type definitions in\n    different files.  This must hash all types that will compare\n    equal via comptypes to the same value.  In practice it hashes\n-   on some of the simple stuff and leaves the details to comptypes. */\n+   on some of the simple stuff and leaves the details to comptypes.  */\n \n static hashval_t\n c_type_hash (const void *p)\n@@ -2831,7 +2831,7 @@ c_type_hash (const void *p)\n   tree t2;\n   switch (TREE_CODE (t))\n     {\n-      /* For pointers, hash on pointee type plus some swizzling. */\n+      /* For pointers, hash on pointee type plus some swizzling.  */\n       case POINTER_TYPE:\n   return c_type_hash (TREE_TYPE (t)) ^ 0x3003003;\n       /* Hash on number of elements and total size.  */\n@@ -2951,7 +2951,7 @@ c_common_get_alias_set (tree t)\n   if (c_language != clk_c || flag_isoc99)\n     return -1;\n \n-  /* Save time if there's only one input file. */\n+  /* Save time if there's only one input file.  */\n   if (!current_file_decl || TREE_CHAIN (current_file_decl) == NULL_TREE)\n     return -1;\n "}, {"sha": "f20ddfe39050c86d4faa14f48c44862c157718a8", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -722,7 +722,7 @@ gimplify_for_stmt (tree *stmt_p, tree *next_p)\n     {\n       /* Reorganize the statements so that we do the right thing with a\n \t CLEANUP_STMT.  We want the FOR_STMT and nothing else to be in the\n-\t scope of the cleanup, so play with pointers to accomplish that. */\n+\t scope of the cleanup, so play with pointers to accomplish that.  */\n       FOR_INIT_STMT (stmt) = NULL_TREE;\n       chainon (init, stmt);\n       *stmt_p = init;"}, {"sha": "8bd18c62b12d3ddb1550e93b027d6f738dfd1029", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -193,7 +193,7 @@ remove_duplicates (cpp_reader *pfile, struct cpp_dir *head,\n \t    cpp_errno (pfile, CPP_DL_ERROR, cur->name);\n \t  else\n \t    {\n-\t      /* If -Wmissing-include-dirs is given, warn. */\n+\t      /* If -Wmissing-include-dirs is given, warn.  */\n \t      cpp_options *opts = cpp_get_options (pfile);\n \t      if (opts->warn_missing_include_dirs && cur->user_supplied_p)\n \t\tcpp_errno (pfile, CPP_DL_WARNING, cur->name);"}, {"sha": "cbb924c58f2708a8cf432c05b72a70db3f4029c0", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1078,7 +1078,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n \n   what = e->callee;\n \n-  /* Now update size of caller and all functions caller is inlined into. */\n+  /* Now update size of caller and all functions caller is inlined into.  */\n   for (;e && !e->inline_failed; e = e->caller->callers)\n     {\n       old_insns = e->caller->global.insns;"}, {"sha": "5ab8f0d7a136a32b02525f9ccd12489c30507c3f", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -305,7 +305,7 @@ add_deps_for_use (ddg_ptr g, struct df *df, struct ref *use)\n        return;\n   /* We must not add ANTI dep when there is an intra-loop TRUE dep in\n      the opozite direction. If the first_def reaches the USE then there is\n-     such a dep. */\n+     such a dep.  */\n   if (! bitmap_bit_p (bb_info->rd_gen, first_def->id))\n     create_ddg_dep_no_link (g, use_node, def_node, ANTI_DEP, REG_DEP, 1);\n }\n@@ -366,7 +366,7 @@ add_inter_loop_mem_dep (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to)\n }\n \n /* Perform intra-block Data Dependency analysis and connect the nodes in\n-   the DDG.  We assume the loop has a single basic block. */\n+   the DDG.  We assume the loop has a single basic block.  */\n static void\n build_intra_loop_deps (ddg_ptr g)\n {"}, {"sha": "cf8ad0881793e1b4c763176dfb88906a5d5d116c", "filename": "gcc/defaults.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -240,7 +240,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n \n /* Determines whether explicit template instantiations should\n    be given link-once semantics. The C++ ABI requires this \n-   macro to be nonzero; see the documentation. */\n+   macro to be nonzero; see the documentation.  */\n #ifndef TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n # define TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY 1\n #endif\n@@ -273,7 +273,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n \n /* This determines whether this target supports hidden visibility.\n    This is a weaker condition than HAVE_GAS_HIDDEN, which probes for\n-   specific assembler syntax. */\n+   specific assembler syntax.  */\n #ifndef TARGET_SUPPORTS_HIDDEN\n # ifdef HAVE_GAS_HIDDEN\n #  define TARGET_SUPPORTS_HIDDEN 1\n@@ -283,7 +283,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #endif\n \n /* Determines whether we may use common symbols to represent one-only\n-   semantics (a.k.a. \"vague linkage\"). */\n+   semantics (a.k.a. \"vague linkage\").  */\n #ifndef USE_COMMON_FOR_ONE_ONLY\n # define USE_COMMON_FOR_ONE_ONLY 1\n #endif"}, {"sha": "1295f72f476ff3c326ee79b6280d7d9db5114f8b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1950,7 +1950,7 @@ output_call_frame_info (int for_eh)\n      having an FDE kept around when the function it refers to is\n      discarded. (Example where this matters: a primary function\n      template in C++ requires EH information, but an explicit\n-     specialization doesn't. */\n+     specialization doesn't.  */\n   if (TARGET_USES_WEAK_UNWIND_INFO\n       && ! flag_asynchronous_unwind_tables\n       && for_eh)"}, {"sha": "3751bc51a2a0ac936c215fb7784decd0c0eca6fc", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -3017,7 +3017,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n       tem = expand_mult_const (wider_mode, tem, cnst1, 0, &alg, variant);\n       tem = extract_high_half (mode, tem);\n \n-      /* Adjust result for signedness. */\n+      /* Adjust result for signedness.  */\n       if (sign_adjust)\n \ttem = force_operand (gen_rtx_MINUS (mode, tem, op0), tem);\n "}, {"sha": "748f0302ad538f26caf148cd818a4b4df27e284f", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -424,7 +424,7 @@ extern int flag_gen_aux_info;\n \n extern int flag_shared_data;\n \n-/* Controls the activation of SMS modulo scheduling. */\n+/* Controls the activation of SMS modulo scheduling.  */\n extern int flag_modulo_sched;\n \n /* flag_schedule_insns means schedule insns within basic blocks (before"}, {"sha": "3914dc9590e08e8fc81b9462e637d6fe78adc81a", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -6423,7 +6423,7 @@ main (int argc, const char **argv)\n       else\n \t{\n \t  /* Since there is no compiler for this input file, assume it is a\n-\t     linker file. */\n+\t     linker file.  */\n \t  explicit_link_files[i] = 1;\n \t  infiles[i].incompiler = NULL;\n \t}"}, {"sha": "115a178d95fb92e1c7d5721cfa48ab69e1c8311a", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -836,7 +836,7 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \tcontinue;\n \n       /* If the original insn came from a define_insn_and_split,\n-\t generate a new split to handle the predicated insn. */\n+\t generate a new split to handle the predicated insn.  */\n       split = copy_rtx (insn_elem->split->data);\n       /* Predicate the pattern matched by the split.  */\n       pattern = rtx_alloc (COND_EXEC);"}, {"sha": "20d194534cafc89d989967c4db7c5d2bd919a640", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -2220,7 +2220,7 @@ shortcut_cond_expr (tree expr)\n       else_ = build_empty_stmt ();\n     }\n \n-  /* If we aren't hijacking a label for the 'then' branch, it falls through. */\n+  /* If we aren't hijacking a label for the 'then' branch, it falls through.  */\n   if (true_label)\n     true_label_p = &true_label;\n   else"}, {"sha": "5826f835d1b21d03840b2b278e68a26bf9471610", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1991,7 +1991,7 @@ dump_global_regs (FILE *file)\n    conflicts and as a consequence worse register allocation.  The\n    typical example where the information can be different is a\n    register initialized in the loop at the basic block preceding the\n-   loop in CFG. */\n+   loop in CFG.  */\n \n /* The following structure contains basic block data flow information\n    used to calculate partial availability of registers.  */\n@@ -2211,7 +2211,7 @@ calculate_reg_pav (void)\n    blocks.  After the function call a register lives at a program\n    point only if it is initialized on a path from CFG entry to the\n    program point.  The standard GCC life analysis permits registers to\n-   live uninitialized. */\n+   live uninitialized.  */\n \n static void\n make_accurate_live_analysis (void)"}, {"sha": "d3114de937e5ef22690865245f4480906d9f653a", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1626,7 +1626,7 @@ rest_of_compilation (tree decl)\n \n   /* The optimization to partition hot/cold basic blocks into separate\n      sections of the .o file does not work well with exception handling.\n-     Don't call it if there are exceptions. */\n+     Don't call it if there are exceptions.  */\n \n   if (flag_reorder_blocks_and_partition && !flag_exceptions)\n     {"}, {"sha": "7dda02ffc395245afbcf882b09e9d324e2942651", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -1798,7 +1798,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\tswap_to_top (insn, regstack, *src1, *src2);\n \n \t\t/* Push the result back onto stack. Empty stack slot\n-\t\t   will be filled in second part of insn. */\n+\t\t   will be filled in second part of insn.  */\n \t\tif (STACK_REG_P (*dest)) {\n \t\t  regstack->reg[regstack->top] = REGNO (*dest);\n \t\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n@@ -1857,7 +1857,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t  abort();\n \n \t\t/* Push the result back onto stack. Empty stack slot\n-\t\t   will be filled in second part of insn. */\n+\t\t   will be filled in second part of insn.  */\n \t\tif (STACK_REG_P (*dest)) {\n \t\t  regstack->reg[regstack->top + 1] = REGNO (*dest);\n \t\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));"}, {"sha": "d217652098fdead7ee8cede2b313f7bfa932b40e", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -78,7 +78,7 @@ struct gcc_target\n        target requires such labels.  Second argument is the decl the\n        unwind info is associated with, third is a boolean: true if\n        this is for exception handling, fourth is a boolean: true if\n-       this is only a placeholder for an omitted FDE. */\n+       this is only a placeholder for an omitted FDE.  */\n     void (* unwind_label) (FILE *, tree, int, int);\n \n     /* Output an internal label.  */"}, {"sha": "999e0966ac5a9bfcabbb0e508e1437c987207f4b", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -264,7 +264,7 @@ int flag_branch_probabilities = 0;\n int flag_reorder_blocks = 0;\n \n /* Nonzero if blocks should be partitioned into hot and cold sections in\n-   addition to being reordered. */\n+   addition to being reordered.  */\n \n int flag_reorder_blocks_and_partition = 0;\n \n@@ -707,7 +707,7 @@ int flag_schedule_speculative_load_dangerous = 0;\n int flag_sched_stalled_insns = 0;\n int flag_sched_stalled_insns_dep = 1;\n \n-/* The following flag controls the module scheduling activation. */\n+/* The following flag controls the module scheduling activation.  */\n int flag_modulo_sched = 0;\n \n int flag_single_precision_constant;\n@@ -825,7 +825,7 @@ int flag_tree_gvn = 0;\n /* Enable the SSA-PRE tree optimization.  */\n int flag_tree_pre = 0;\n \n-/* Enable points-to analysis on trees. */\n+/* Enable points-to analysis on trees.  */\n enum pta_type flag_tree_points_to = PTA_NONE;\n \n /* Enable SSA-CCP on trees.  */"}, {"sha": "471a7fd99f30bd74b987371e058f93668bee0593", "filename": "gcc/tree-alias-ander.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-alias-ander.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-alias-ander.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-ander.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -147,7 +147,7 @@ static struct tree_alias_ops andersen_ops = {\n   andersen_empty_points_to_set,\n   0, /* data */\n   0, /* Currently non-interprocedural */\n-  1  /* Can do IP on all statics without help. */\n+  1  /* Can do IP on all statics without help.  */\n };\n struct tree_alias_ops *andersen_alias_ops = &andersen_ops;\n \n@@ -427,14 +427,14 @@ pta_pr_ptset (contents_type t)\n   deleteregion (scratch_rgn);\n }\n \n-/* Initialize Andersen alias analysis. */\n+/* Initialize Andersen alias analysis.  */\n static int initted = 0;\n \n static void\n andersen_init (struct tree_alias_ops *ops ATTRIBUTE_UNUSED)\n {\n #if 0\n-  /* Don't claim we can do ip partial unless we have unit_at_a_time on. */\n+  /* Don't claim we can do ip partial unless we have unit_at_a_time on.  */\n   if (!flag_unit_at_a_time)   \n #endif\n     andersen_ops.ip_partial = 0;\n@@ -658,7 +658,7 @@ andersen_op_assign (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n   \n       \n   /* Pointer destroying operations do not give us the same valid pointer\n-     back, and thus, are assignment to pta_bottom. */\n+     back, and thus, are assignment to pta_bottom.  */\n   if (pointer_destroying_op (operation))\n     {\n       pta_assignment (ALIAS_VAR_ATERM (lhs), pta_rvalue (pta_bottom ()));\n@@ -761,7 +761,7 @@ andersen_function_def (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,\n   size_t l = VARRAY_ACTIVE_SIZE (params);\n   size_t i;\n \n-  /* Set up the arguments for the new function type. */\n+  /* Set up the arguments for the new function type.  */\n   for (i = 0; i < l; i++)\n     {\n       alias_var tv = VARRAY_GENERIC_PTR (params, i);\n@@ -814,7 +814,7 @@ andersen_function_call (struct tree_alias_ops *ops,\n \n   /* We can handle functions we've got trees for. non-statics will\n      just have incoming parameters assigned to global_var if\n-     necessary. */\n+     necessary.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_PTA_ALIASVAR (decl)\n       && ops->ip_partial\n@@ -835,7 +835,7 @@ simple_cmp (const aterm a, const aterm b)\n }\n \n \n-/* Get the points-to set for TV, caching if it we had to compute it. */\n+/* Get the points-to set for TV, caching if it we had to compute it.  */\n    \n static aterm_list \n get_ptset (alias_var tv)\n@@ -850,7 +850,7 @@ get_ptset (alias_var tv)\n }\n   \n   \n-/* Determine if two aterm's have the same points-to set. */\n+/* Determine if two aterm's have the same points-to set.  */\n \n static bool\n andersen_same_points_to_set (struct tree_alias_ops *ops ATTRIBUTE_UNUSED,"}, {"sha": "f13b7df78c69cb6dd0e787f8370e6e366d56d4bc", "filename": "gcc/tree-alias-common.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-alias-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-alias-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-common.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -26,7 +26,7 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n #include \"tree-alias-type.h\"\n #include \"bitmap.h\"\n #include \"tree-alias-common.h\"\n-/* If we have andersen's points-to analysis, include it. */\n+/* If we have andersen's points-to analysis, include it.  */\n #ifdef HAVE_BANSHEE\n #include \"tree-alias-ander.h\"\n #endif\n@@ -150,7 +150,7 @@ get_alias_var_decl (tree decl)\n     {\n       newvar = create_alias_var (decl);\n       /* Assign globals to global var for purposes of intraprocedural\n-\t analysis. */\n+\t analysis.  */\n       if ((DECL_CONTEXT (decl) == NULL \n \t   || TREE_PUBLIC (decl)\n \t   || TREE_STATIC (decl)\n@@ -161,7 +161,7 @@ get_alias_var_decl (tree decl)\n \t\t\t\t\t  get_alias_var (pta_global_var), \n \t\t\t\t\t  newvar);\n \t  /* If the global has some DECL_INITIAL, we need to process\n-\t     it here. */\n+\t     it here.  */\n \t  if (DECL_INITIAL (decl))\n \t    find_func_aliases (decl);\n \t}\n@@ -190,7 +190,7 @@ get_alias_var (tree expr)\n   /* If it's a decl, get the alias var of the decl. We farm this off\n      to get_alias_var_decl so it can abort if the alias var doesn't\n      exist, and in case something else *knows* it has a decl, and\n-     wants the alias var. */\n+     wants the alias var.  */\n \n   if (DECL_P (expr))\n     return get_alias_var_decl (expr);\n@@ -240,7 +240,7 @@ get_alias_var (tree expr)\n \t    return get_alias_var (TREE_OPERAND (expr, 1));\n \t  }\n #else\n-        /* Find the first non-component ref, and return its alias variable. */\n+        /* Find the first non-component ref, and return its alias variable.  */\n \ttree p;\n \tfor (p = expr; TREE_CODE (p) == COMPONENT_REF;\n \t     p = TREE_OPERAND (p, 0));\n@@ -260,7 +260,7 @@ get_alias_var (tree expr)\n     case INDIRECT_REF:\n     case BIT_FIELD_REF:\n       /* If it's a ref or cast or conversion of something, get the\n-         alias var of the something. */\n+         alias var of the something.  */\n       return get_alias_var (TREE_OPERAND (expr, 0));\n       break;\n \n@@ -280,7 +280,7 @@ intra_function_call (varray_type args)\n   size_t i;\n   alias_var av = get_alias_var (pta_global_var);\n \n-  /* We assume assignments among the actual parameters. */\n+  /* We assume assignments among the actual parameters.  */\n   for (i = 0; i < l; i++)\n     {\n       alias_var argi = VARRAY_GENERIC_PTR (args, i);\n@@ -292,26 +292,26 @@ intra_function_call (varray_type args)\n \t    continue;\n \t  argj = VARRAY_GENERIC_PTR (args, j);\n \t  /* Restricted pointers can't be aliased with other\n-\t     restricted pointers. */\n+\t     restricted pointers.  */\n \t  if (!TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (argi)))\n \t      || !TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (argj))))\n-\t    /* Do a bit of TBAA to avoid pointless assignments. */\n+\t    /* Do a bit of TBAA to avoid pointless assignments.  */\n \t    if (alias_sets_conflict_p (get_alias_set (ALIAS_VAR_DECL (argi)),\n \t\t\t\t       get_alias_set (ALIAS_VAR_DECL (argj))))\t      \n \t      current_alias_ops->simple_assign (current_alias_ops, argi, argj);\n \t}\n     }\n-  /* We assume that an actual parameter can point to any global. */\n+  /* We assume that an actual parameter can point to any global.  */\n   for (i = 0; i < l; i++)\n     {\n       alias_var argav = VARRAY_GENERIC_PTR (args, i);\n       /* Restricted pointers can't be aliased with other\n-\t restricted pointers. */\n+\t restricted pointers.  */\n       if (!TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (argav)))\n \t  || !TYPE_RESTRICT (TREE_TYPE (ALIAS_VAR_DECL (av))))\n \t{\n \t  /* Arguments can alias globals, and whatever they point to\n-\t     can point to a global as well. */\n+\t     can point to a global as well.  */\n \t  current_alias_ops->simple_assign (current_alias_ops, argav, av);\n \t}\n     }\n@@ -460,19 +460,19 @@ find_func_aliases (tree stp)\n \t  op1 = TREE_OPERAND (op1, 0);\n \t}\n       /* Take care of fact that we may have multi-level component\n-\t refs. */ \n+\t refs.  */ \n       if (TREE_CODE (op1) == COMPONENT_REF)\n \top1 = find_op_of_decl (op1);\n #endif\n       \n       /* You would think we could test rhsAV at the top, rather than\n \t 50 separate times, but we can't, because it can be NULL for\n \t operator assignments, where we'd still collect the individual\n-\t alias vars for the operator. */\n+\t alias vars for the operator.  */\n \n       /* Note that structures are treated as a single alias\n \t variable, since we can disambiguate based on TBAA first,\n-\t and fall back on points-to. */\n+\t and fall back on points-to.  */\n       /* x = <something> */\n       if (is_gimple_variable (op0))\n \t{\n@@ -527,13 +527,13 @@ find_func_aliases (tree stp)\n \t  else if (TREE_CODE (op1) == CALL_EXPR)\n \t    {\n \t      /* Heap assignment. These are __attribute__ malloc or\n-\t\t something, i'll deal with it later. */\n+\t\t something, i'll deal with it later.  */\n \t      if (0)\n \t\t{}\n \t      else\n \t\t{\n \t\t  \n-\t\t  /* NORETURN functions have no effect on aliasing. */\n+\t\t  /* NORETURN functions have no effect on aliasing.  */\n \t\t  if (call_may_return (op1))\n \t\t    {\t\t      \n \t\t      varray_type args;\n@@ -656,7 +656,7 @@ find_func_aliases (tree stp)\n \t\t    || TREE_CODE (op0) == ARRAY_REF)\n \t\t   && TREE_CODE (op1) == ADDR_EXPR)\n \t    {\n-\t      /* This becomes temp = &y and *x = temp . */\n+\t      /* This becomes temp = &y and *x = temp .  */\n \t      alias_var tempvar;\n \t      tree temp = create_tmp_var_raw (void_type_node, \"aliastmp\");\n \t      tempvar = current_alias_ops->add_var (current_alias_ops, temp);\n@@ -672,7 +672,7 @@ find_func_aliases (tree stp)\n \t\t   && (TREE_CODE (op1) == INDIRECT_REF\n \t\t       || TREE_CODE (op1) == ARRAY_REF))\n \t    {\n-\t      /* This becomes temp = *y and *x = temp . */\n+\t      /* This becomes temp = *y and *x = temp .  */\n \t      alias_var tempvar;\n \t      tree temp;\n \t      temp = create_tmp_var_raw (void_type_node, \"aliastmp\");\n@@ -690,7 +690,7 @@ find_func_aliases (tree stp)\n \t    {\n \t      if (rhsAV != NULL)\n \t\t{\n-\t\t  /* This becomes temp = (cast) y and  *x = temp. */\n+\t\t  /* This becomes temp = (cast) y and  *x = temp.  */\n \t\t  alias_var tempvar;\n \t\t  tree temp;\n \t\t  temp = create_tmp_var_raw (void_type_node, \"aliastmp\");\n@@ -711,7 +711,7 @@ find_func_aliases (tree stp)\n \t    }\n \t}\n     }\n-  /* Calls without return values. */\n+  /* Calls without return values.  */\n   else if (TREE_CODE (stp) == CALL_EXPR)\n     {\n       alias_var callvar;\n@@ -787,10 +787,10 @@ create_fun_alias_var (tree decl, int force)\n \t  /* Incoming pointers can point to pta_global_var, unless\n \t     either we are interprocedural, or we can do ip on all\n \t     statics + this function has been defined + it's not an\n-\t     external function. */\n+\t     external function.  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (arg))\n \t      && !current_alias_ops->ip\n-\t      /* FIXME: Need to let analyzer decide in partial case. */\n+\t      /* FIXME: Need to let analyzer decide in partial case.  */\n \t      && (!current_alias_ops->ip_partial\n \t\t  || !cgraph_local_info (decl)->local))\n \t    current_alias_ops->simple_assign (current_alias_ops, var,\n@@ -814,10 +814,10 @@ create_fun_alias_var (tree decl, int force)\n \t  /* Incoming pointers can point to pta_global_var, unless\n \t     either we are interprocedural, or we can do ip on all\n \t     statics + this function has been defined + it's not an\n-\t     external function. */\n+\t     external function.  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (fakedecl))\n \t      && !current_alias_ops->ip\n-\t      /* FIXME: need to let analyzer decide in partial case. */\n+\t      /* FIXME: need to let analyzer decide in partial case.  */\n \t      && (!current_alias_ops->ip_partial\n \t\t  || !TREE_STATIC (decl)\n \t\t  || TREE_PUBLIC (decl)))\n@@ -860,7 +860,7 @@ create_fun_alias_var (tree decl, int force)\n   DECL_PTA_ALIASVAR (decl) = avar;\n \n   /* FIXME: Also, if this is a defining declaration then add the annotation\n-     to all extern definitions of the function. */\n+     to all extern definitions of the function.  */\n   return avar;\n }\n \n@@ -1252,7 +1252,7 @@ alias_get_name (tree t)\n       /* 2 = UF\n \t 4 = the masked pointer\n \t 2 = the <> around it\n-\t 1 = the terminator. */\n+\t 1 = the terminator.  */\n       namep = ggc_alloc (2 + 4 + 2 + 1);\n       sprintf (namep, \"<UV%x>\", MASK_POINTER (t));\n       return namep;"}, {"sha": "e53d71c2aafa94b3cf6855c25d95b536f875b9f6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -685,7 +685,7 @@ make_goto_expr_edges (basic_block bb)\n \t  return;\n \t}\n \n-      /* Nothing more to do for nonlocal gotos. */\n+      /* Nothing more to do for nonlocal gotos.  */\n       if (TREE_CODE (dest) == LABEL_DECL)\n \treturn;\n "}, {"sha": "587c90a1c7aa23e51d9d7fc339b7ec2756f0dca8", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -298,7 +298,7 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n   t1 = do_binop (bsi, MULT_EXPR, inner_type, min, ratio);\n   div = do_binop (bsi, PLUS_EXPR, inner_type, t1, max);\n \n-  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div). */\n+  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div).  */\n   t1 = do_binop (bsi, MULT_EXPR, inner_type, ai, ratio);\n   t2 = do_binop (bsi, PLUS_EXPR, inner_type, ar, t1);\n   rr = do_binop (bsi, code, inner_type, t2, div);"}, {"sha": "9654de2d65fb39cd156482d56d5b77a1859463c0", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -950,7 +950,7 @@ get_virtual_var (tree var)\n \n \n /* Mark variables in BLOCK that have hidden uses.  A hidden use can\n-   occur due to VLA declarations or nested functions.   */\n+   occur due to VLA declarations or nested functions.  */\n \n static void\n find_hidden_use_vars (tree block)\n@@ -976,7 +976,7 @@ find_hidden_use_vars (tree block)\n      VLA parameter and that declaration is not seen by the SSA code. \n \n      Note get_pending_sizes clears the PENDING_SIZES chain, so we\n-     must restore it. */\n+     must restore it.  */\n   tem = get_pending_sizes ();\n   put_pending_sizes (tem);\n   for (; tem; tem = TREE_CHAIN (tem))"}, {"sha": "7d3898176228dcc7f54d48f69c21a84f2309c4df", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -531,7 +531,7 @@ verify_norecord_switch_expr (struct leh_state *state, tree switch_expr)\n /* Redirect a RETURN_EXPR pointed to by STMT_P to FINLAB.  Place in CONT_P\n    whatever is needed to finish the return.  If MOD is non-null, insert it\n    before the new branch.  RETURN_VALUE_P is a cache containing a temporary\n-   variable to be used in manipulating the value returned from the function. */\n+   variable to be used in manipulating the value returned from the function.  */\n \n static void\n do_return_redirection (struct goto_queue_node *q, tree finlab, tree mod,"}, {"sha": "8a57efbe67673667a7582388422e73721f8bfc94", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -209,7 +209,7 @@ static GTY (()) tree mf_cache_shift_decl;\n /* extern const uintptr_t __mf_lc_mask; */\n static GTY (()) tree mf_cache_mask_decl;\n \n-/* Their function-scope local shadows, used in single-threaded mode only. */\n+/* Their function-scope local shadows, used in single-threaded mode only.  */\n \n /* auto const unsigned char __mf_lc_shift_l; */\n static GTY (()) tree mf_cache_shift_decl_l;\n@@ -253,7 +253,7 @@ mf_init_extern_trees (void)\n \n /* Create and initialize local shadow variables for the lookup cache\n    globals.  Put their decls in the *_l globals for use by\n-   mf_build_check_statement_for. */\n+   mf_build_check_statement_for.  */\n \n static void\n mf_decl_cache_locals (tree* body)\n@@ -287,7 +287,7 @@ mf_decl_cache_locals (tree* body)\n static void\n mf_decl_clear_locals (void)\n {\n-  /* Unset local shadows. */\n+  /* Unset local shadows.  */\n   mf_cache_shift_decl_l = NULL_TREE;\n   mf_cache_mask_decl_l = NULL_TREE;\n }\n@@ -316,7 +316,7 @@ mf_varname_tree (tree decl)\n     }\n   pp_clear_output_area (buf);\n \n-  /* Add FILENAME[:LINENUMBER]. */\n+  /* Add FILENAME[:LINENUMBER].  */\n   {\n     const char *sourcefile;\n     unsigned sourceline;\n@@ -721,7 +721,7 @@ mf_xform_derefs (tree fnbody)\n \n /* This struct is passed between mf_xform_decls to store state needed\n    during the traversal searching for objects that have their\n-   addresses taken. */\n+   addresses taken.  */\n struct mf_xform_decls_data\n {\n   tree param_decls;\n@@ -763,7 +763,7 @@ mx_register_decls (tree decl, tree *stmt_list)\n                  method by which VLA declarations turn into calls to\n                  BUILT_IN_STACK_ALLOC.  We assume that multiple\n                  VLAs declared later in the same block get allocation \n-                 code later than the others. */\n+                 code later than the others.  */\n               tree stack_alloc_call = NULL_TREE;\n \n               while(! tsi_end_p (initially_stmts))\n@@ -801,7 +801,7 @@ mx_register_decls (tree decl, tree *stmt_list)\n                               /* Got it! */\n                               size = stack_alloc_op2;\n                               stack_alloc_call = call;\n-                              /* Advance iterator to point past this allocation call. */\n+                              /* Advance iterator to point past this allocation call.  */\n                               tsi_next (&initially_stmts);\n                               break;\n                             }\n@@ -865,7 +865,7 @@ mx_register_decls (tree decl, tree *stmt_list)\n             internal_error (\"mudflap ran off end of BIND_EXPR body\");\n           tsi_link_before (&initially_stmts, register_fncall, TSI_SAME_STMT);\n \n-          /* Accumulate the FINALLY piece. */\n+          /* Accumulate the FINALLY piece.  */\n           append_to_statement_list (unregister_fncall, &finally_stmts);\n \n           mf_mark (decl);"}, {"sha": "700c7341588e21fa085dffa9e09c3ebc8f1017d5", "filename": "gcc/tree-mudflap.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-mudflap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-mudflap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -22,18 +22,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef TREE_MUDFLAP_H\n #define TREE_MUDFLAP_H\n \n-/* Instrumentation. */\n+/* Instrumentation.  */\n extern void mudflap_c_function_decls (tree);\n extern void mudflap_c_function_ops (tree);\n extern void mudflap_enqueue_decl (tree);\n extern void mudflap_enqueue_constant (tree);\n extern void mudflap_finish_file (void);\n \n-/* Tree node marking. */\n+/* Tree node marking.  */\n extern int mf_marked_p (tree);\n extern tree mf_mark (tree);\n \n-/* To be provided by a front-end interface module. */\n+/* To be provided by a front-end interface module.  */\n extern tree mflang_lookup_decl (const char *);\n extern void mflang_flush_calls (tree);\n "}, {"sha": "03c43917f6146fed70c5d1e6a1f29d53a854b1be", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -76,7 +76,7 @@ typedef struct _elim_graph {\n   /* List of nodes in the elimination graph.  */\n   varray_type nodes;\n \n-  /*  The predecessor and successor edge list. */\n+  /*  The predecessor and successor edge list.  */\n   varray_type edge_list;\n \n   /* Visited vector.  */\n@@ -763,7 +763,7 @@ coalesce_ssa_name (var_map map, int flags)\n   root_var_decompact (rv);\n \n   /* First, coalesce all live on entry variables to their root variable. \n-     This will ensure the first use is coming from the correct location. */\n+     This will ensure the first use is coming from the correct location.  */\n \n   live = sbitmap_alloc (num_var_partitions (map));\n   sbitmap_zero (live);"}, {"sha": "4e2d0c1fb34ae0e83f7e6caa4c0aa2a6b2e9aa2e", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -296,7 +296,7 @@ create_phi_node (tree var, basic_block bb)\n   phi = make_phi_node (var, bb_ann (bb)->num_preds);\n \n   /* This is a new phi node, so note that is has not yet been\n-     rewritten. */\n+     rewritten.  */\n   PHI_REWRITTEN (phi) = 0;\n \n   /* Add the new PHI node to the list of PHI nodes for block BB.  */"}, {"sha": "ef130d822da7402ddbf077562c080be0e349b37c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -558,7 +558,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  if (TYPE_METHODS (TREE_TYPE (node)))\n \t    {\n \t      /* The type is a c++ class: all structures have at least\n-\t\t 4 methods. */\n+\t\t 4 methods.  */\n \t      pp_string (buffer, \"class \");\n \t      dump_generic_node (buffer, TREE_TYPE (node), spc, flags, false);\n \t    }"}, {"sha": "230004b874b76be005b5701a8d380840b4e79ce8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -890,7 +890,7 @@ group_aliases_into (tree tag, sbitmap tag_aliases, struct alias_info *ai)\n \n       /* Note that VAR and TAG may be the same if the function has no\n \t addressable variables (see the discussion at the end of\n-\t setup_pointers_and_addressables). */\n+\t setup_pointers_and_addressables).  */\n       if (var != tag)\n \tadd_may_alias (var, tag);\n "}, {"sha": "ecb492bedf078326735db646882ed51b6be144e0", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -461,7 +461,7 @@ visit_phi_node (tree phi)\n   else\n     for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n       {\n-\t/* Compute the meet operator over all the PHI arguments. */\n+\t/* Compute the meet operator over all the PHI arguments.  */\n \tedge e = PHI_ARG_EDGE (phi, i);\n \n \tif (dump_file && (dump_flags & TDF_DETAILS))\n@@ -883,7 +883,7 @@ ccp_fold (tree stmt)\n     }\n \n   /* We may be able to fold away calls to builtin functions if their\n-     arguments are constants. */\n+     arguments are constants.  */\n   else if (code == CALL_EXPR\n \t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == ADDR_EXPR\n \t   && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0))\n@@ -1430,7 +1430,7 @@ likely_value (tree stmt)\n \n /* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].\n    BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE\n-   is the desired result type.   */\n+   is the desired result type.  */\n \n static tree\n maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n@@ -1884,7 +1884,7 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n                   break;\n                 }\n             }\n-        /* Fall through is an error; it will be detected in tree-sra. */\n+        /* Fall through is an error; it will be detected in tree-sra.  */\n         }\n       break;\n "}, {"sha": "f61aed2b799ef961053f9e897c21ce4bef4938ec", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -102,7 +102,7 @@ delete_var_map (var_map map)\n \n /* This function will combine the partitions in MAP for VAR1 and VAR2.  It \n    Returns the partition which represents the new partition.  If the two \n-   partitions cannot be combined, NO_PARTITION is returned. */\n+   partitions cannot be combined, NO_PARTITION is returned.  */\n \n int\n var_union (var_map map, tree var1, tree var2)\n@@ -1344,7 +1344,7 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \t     This is handled specially here since we may also be interested \n \t     in copies between real variables and SSA_NAME variables.  We may\n \t     be interested in trying to coalesce SSA_NAME variables with\n-\t     root variables in some cases.   */\n+\t     root variables in some cases.  */\n \n \t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n \t    {\n@@ -1821,7 +1821,7 @@ register_ssa_partitions_for_vars (bitmap vars, var_map map)\n \n \t     Note we delete PHI nodes in this loop if they are \n \t     associated with virtual vars which are going to be\n-\t     renamed.   */\n+\t     renamed.  */\n \t  for (phi = phi_nodes (bb); phi; phi = next)\n \t    {\n \t      tree result = SSA_NAME_VAR (PHI_RESULT (phi));"}, {"sha": "f8104424aa8a638212aaa8974ff6e0ab33b782cf", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -328,7 +328,7 @@ live_var_map (tree_live_info_p live)\n \n \n /* Merge the live on entry information in LIVE for partitions P1 and P2. Place\n-   the result into P1.  Clear P2. */\n+   the result into P1.  Clear P2.  */\n \n static inline void \n live_merge_and_clear (tree_live_info_p live, int p1, int p2)"}, {"sha": "2e2f42747e592a5005da1511f373b9f439e91f66", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -272,7 +272,7 @@ static int class_count = 0;\n /* Iterated dominance frontiers cache.  */\n static bitmap *idfs_cache;\n \n-/* Partial redundancies statistics. */\n+/* Partial redundancies statistics.  */\n static struct pre_stats_d\n {\n   int reloads;\n@@ -298,21 +298,21 @@ struct expr_info\n {\n   /* The actual expression.  */\n   tree expr;\n-  /* The occurrences. */\n+  /* The occurrences.  */\n   varray_type occurs;\n-  /* The kills. */\n+  /* The kills.  */\n   varray_type kills;\n-  /* The left occurrences. */\n+  /* The left occurrences.  */\n   varray_type lefts;\n-  /* An array of real occurrences. */\n+  /* An array of real occurrences.  */\n   varray_type reals;\n-  /* True if it's a strength reduction candidate. */\n+  /* True if it's a strength reduction candidate.  */\n   bool strred_cand;\n-  /* True if it's a load PRE candidate. */\n+  /* True if it's a load PRE candidate.  */\n   bool loadpre_cand;\n-  /* The euses/ephis in preorder dt order. */\n+  /* The euses/ephis in preorder dt order.  */\n   varray_type euses_dt_order;\n-  /* The name of the temporary for this expression. */\n+  /* The name of the temporary for this expression.  */\n   tree temp;\n };\n \n@@ -530,11 +530,11 @@ okay_injuring_def (tree inj, tree var)\n static bool\n is_injuring_def (struct expr_info *ei, tree inj)\n {\n-  /* Things that are never injuring definitions. */\n+  /* Things that are never injuring definitions.  */\n   if (!inj || IS_EMPTY_STMT (inj) || TREE_CODE (inj) == PHI_NODE)\n     return false;\n \n-  /* Things we can't handle. */\n+  /* Things we can't handle.  */\n   if (TREE_CODE (TREE_OPERAND (inj, 1)) != PLUS_EXPR\n       && TREE_CODE (TREE_OPERAND (inj, 1)) != MINUS_EXPR)\n     return false;\n@@ -558,7 +558,7 @@ is_injuring_def (struct expr_info *ei, tree inj)\n      for an expression like \"a * 5\".\n \n      This limitation only exists because we don't know how to repair\n-     other forms of increments/decrements. */\n+     other forms of increments/decrements.  */\n   if (!names_match_p (TREE_OPERAND (inj, 0), TREE_OPERAND (ei->expr, 0))\n       || !TREE_OPERAND (TREE_OPERAND (inj, 1), 0)\n       || !names_match_p (TREE_OPERAND (TREE_OPERAND (inj, 1), 0),\n@@ -568,7 +568,7 @@ is_injuring_def (struct expr_info *ei, tree inj)\n   /* If we are strength reducing a multiply, we have the additional\n      constraints that\n      1. {expr} is 1\n-     2. {expr} and the RHS of the expression are constants. */\n+     2. {expr} and the RHS of the expression are constants.  */\n   if (TREE_CODE (ei->expr) == MULT_EXPR)\n     {\n       tree irhs1;\n@@ -594,7 +594,7 @@ is_injuring_def (struct expr_info *ei, tree inj)\n }\n \n /* Find the statement defining VAR, ignoring injuries we can repair.\n-   START is the first potential injuring def. */\n+   START is the first potential injuring def.  */\n \n static tree\n factor_through_injuries (struct expr_info *ei, tree start, tree var,\n@@ -705,14 +705,14 @@ static bitmap varphis;\n    alteration reaches that merge point).\n \n    We do this recursively, because we have to figure out\n-   EPHI's for the variables in the PHI as well. */\n+   EPHI's for the variables in the PHI as well.  */\n \n static void\n set_var_phis (struct expr_info *ei, tree phi)\n {\n   basic_block bb = bb_for_stmt (phi);\n   /* If we've already got an EPHI set to be placed in PHI's BB, we\n-     don't need to do this again. */\n+     don't need to do this again.  */\n   if (!bitmap_bit_p (varphis, bb->index)\n \t&& !bitmap_bit_p (dfphis, bb->index))\n     {\n@@ -725,7 +725,7 @@ set_var_phis (struct expr_info *ei, tree phi)\n         {\n           phi_operand = PHI_ARG_DEF (phi, curr_phi_operand);\n \t  /* For strength reduction, factor through injuries we can\n-\t     repair. */\n+\t     repair.  */\n \t  if (ei->strred_cand && TREE_CODE (phi_operand) != PHI_NODE)\n \t    {\n \t      phi_operand = factor_through_injuries (ei, phi_operand,\n@@ -742,7 +742,7 @@ set_var_phis (struct expr_info *ei, tree phi)\n \n \t  /* If our phi operand is defined by a phi, we need to\n \t     record where the phi operands alter the expression as\n-\t     well, and place EPHI's at each point. */\n+\t     well, and place EPHI's at each point.  */\n           if (TREE_CODE (phi_operand) == PHI_NODE)\n             set_var_phis (ei, phi_operand);\n         }\n@@ -840,10 +840,10 @@ expr_phi_insertion (bitmap *dfs, struct expr_info *ei)\n \t}\n     }\n   /* Union the results of the dfphis and the varphis to get the\n-     answer to everywhere we need EPHIS. */\n+     answer to everywhere we need EPHIS.  */\n   bitmap_a_or_b (dfphis, dfphis, varphis);\n \n-  /* Now create the EPHI's in each of these blocks. */\n+  /* Now create the EPHI's in each of these blocks.  */\n   EXECUTE_IF_SET_IN_BITMAP(dfphis, 0, i,\n   {\n     tree ref = create_expr_ref (ei, ei->expr, EPHI_NODE, BASIC_BLOCK (i),\n@@ -970,7 +970,7 @@ create_and_insert_occ_in_preorder_dt_order (struct expr_info *ei)\n   {\n     tree ephi = ephi_at_block (block);\n     /* The ordering for a given BB is EPHI's, real/left/kill\n-       occurrences, phi preds, exit occurrences.   */\n+       occurrences, phi preds, exit occurrences.  */\n     if (ephi != NULL_TREE)\n       VARRAY_PUSH_TREE (ei->euses_dt_order, ephi);\n   }\n@@ -1061,7 +1061,7 @@ create_and_insert_occ_in_preorder_dt_order (struct expr_info *ei)\n \telse if (succ->dest == EXIT_BLOCK_PTR && !(succ->flags & EDGE_FAKE))\n \t  {\n \t    /* No point in inserting exit blocks into heap first, since\n-\t       they'll never be anything on the stack. */\n+\t       they'll never be anything on the stack.  */\n \t    tree newref;\n \t    newref = create_expr_ref (ei, ei->expr, EEXIT_NODE, \n \t\t\t\t      block,\n@@ -1268,15 +1268,15 @@ generate_vops_as_of_bb (tree expr, basic_block pred, basic_block bb)\n }\n \n /* Make a copy of Z as it would look in basic block PRED, using the PHIs\n-   in BB. */\n+   in BB.  */\n \n static tree\n subst_phis (struct expr_info *ei, tree Z, basic_block pred, basic_block bb)\n {\n   tree stmt_copy;\n   size_t i;\n \n-  /* Return the cached version, if we have one. */\n+  /* Return the cached version, if we have one.  */\n   if (pred->index < n_phi_preds \n       && phi_pred_cache[pred->index] != NULL_TREE)\n     return phi_pred_cache[pred->index];\n@@ -1356,7 +1356,7 @@ injured_real_occ_phi_opnd (struct expr_info *ei ATTRIBUTE_UNUSED,\n \t\t\t\tbasic_block use_bb ATTRIBUTE_UNUSED, \n \t\t\t\tint opnd_num ATTRIBUTE_UNUSED)\n {\n-  /* XXX: Implement. */\n+  /* XXX: Implement.  */\n   return false;\n }\n \n@@ -1603,7 +1603,7 @@ process_delayed_rename (struct expr_info *ei, tree use, tree real_occ)\n \n    Renaming is done like Open64 does it.  Basically as the paper says, \n    except that we try to use earlier defined occurrences if they are\n-   available in order to keep the number of saves down. */\n+   available in order to keep the number of saves down.  */\n \n static void\n rename_1 (struct expr_info *ei)\n@@ -1659,7 +1659,7 @@ rename_1 (struct expr_info *ei)\n \t\t     anything).  \n \t\t     Otherwise, we have to assign a new version.\n \t\t     lvalue occurrences always need a new version,\n-\t\t     since they are definitions. */\n+\t\t     since they are definitions.  */\n \t\t  if (!EUSE_LVAL (occur) \n \t\t      && same_e_version_real_occ_real_occ (ei, tos, occur))\n \t\t    {\n@@ -1685,7 +1685,7 @@ rename_1 (struct expr_info *ei)\n \t\t     must change in between the ephi result and the next\n \t\t     occurrence), and we need a new version for the real\n \t\t     occurrence.\n-\t\t     lvalues always need a new version. */\n+\t\t     lvalues always need a new version.  */\n \t\t  if (!EUSE_LVAL (occur)\n \t\t      && same_e_version_phi_result (ei, tos, EREF_STMT (occur),\n \t\t\t\t\t\t    occur))\n@@ -1703,7 +1703,7 @@ rename_1 (struct expr_info *ei)\n \t\t    }\n \t\t}\n \t    }\n-\t  /* EPHI occurrences always get new versions. */\n+\t  /* EPHI occurrences always get new versions.  */\n \t  else if (TREE_CODE (occur) == EPHI_NODE)\n \t    {\t      \n \t      assign_new_class (occur, &stack, NULL);\n@@ -1790,7 +1790,7 @@ rename_1 (struct expr_info *ei)\n \n /* Determine if the EPHI has an argument we could never insert\n    or extend the lifetime of, such as an argument occurring on \n-   an abnormal edge. */\n+   an abnormal edge.  */\n \n static bool\n ephi_has_unsafe_arg (tree ephi)\n@@ -2031,7 +2031,7 @@ reaching_def (tree var, tree currstmt, basic_block bb, tree ignore)\n   basic_block dom;\n   tree phi;\n \n-  /* Check phis first. */\n+  /* Check phis first.  */\n   for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n     {\n       if (phi == currstmt)\n@@ -2043,7 +2043,7 @@ reaching_def (tree var, tree currstmt, basic_block bb, tree ignore)\n     }\n \n   /* We can't walk BB's backwards right now, so we have to walk *all*\n-     the statements, and choose the last name we find. */\n+     the statements, and choose the last name we find.  */\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       tree stmt = bsi_stmt (bsi);\n@@ -2095,7 +2095,7 @@ insert_one_operand (struct expr_info *ei, tree ephi, int opnd_indx,\n   tree newtemp;\n   basic_block bb = bb_for_stmt (x);\n \n-  /* Insert definition of expr at end of BB containing x. */\n+  /* Insert definition of expr at end of BB containing x.  */\n   copy = TREE_OPERAND (EREF_STMT (ephi), 1);\n   copy = unshare_expr (copy);\n   expr = build (MODIFY_EXPR, TREE_TYPE (ei->expr),\n@@ -2568,7 +2568,7 @@ finalize_2 (struct expr_info *ei)\n   do_ephi_df_search (ei, replacing_search);\n }\n \n-/* Perform a DFS on EPHI using the functions in SEARCH. */\n+/* Perform a DFS on EPHI using the functions in SEARCH.  */\n \n static void\n do_ephi_df_search_1 (struct ephi_df_search search, tree ephi)\n@@ -2611,7 +2611,7 @@ do_ephi_df_search (struct expr_info *ei, struct ephi_df_search search)\n }\n \n #if 0\n-/* Calculate the increment necessary due to EXPR for the temporary. */\n+/* Calculate the increment necessary due to EXPR for the temporary.  */\n static tree\n calculate_increment (struct expr_info *ei, tree expr)\n {\n@@ -2723,7 +2723,7 @@ code_motion (struct expr_info *ei)\n   basic_block bb;\n \n   /* First, add the phi node temporaries so the reaching defs are\n-     always right. */\n+     always right.  */\n   for (euse_iter = 0;\n        euse_iter < VARRAY_ACTIVE_SIZE (ei->euses_dt_order);\n        euse_iter++)\n@@ -2747,7 +2747,7 @@ code_motion (struct expr_info *ei)\n \t    }\n \t}\n     }\n-  /* Now do the actual saves and reloads, plus repairs. */\n+  /* Now do the actual saves and reloads, plus repairs.  */\n   for (euse_iter = 0;\n        euse_iter < VARRAY_ACTIVE_SIZE (ei->euses_dt_order);\n        euse_iter++)\n@@ -2827,7 +2827,7 @@ code_motion (struct expr_info *ei)\n \t}\n     }\n   \n-  /* Now do the phi nodes. */\n+  /* Now do the phi nodes.  */\n   for (euse_iter = 0;\n        euse_iter < VARRAY_ACTIVE_SIZE (ei->euses_dt_order);\n        euse_iter++)\n@@ -2942,7 +2942,7 @@ compute_idfs (bitmap * dfs, tree stmt)\n \n }\n \n-/* Return true if EXPR is a strength reduction candidate. */\n+/* Return true if EXPR is a strength reduction candidate.  */\n static bool\n is_strred_cand (const tree expr ATTRIBUTE_UNUSED)\n {\n@@ -2959,7 +2959,7 @@ is_strred_cand (const tree expr ATTRIBUTE_UNUSED)\n \n \n \n-/* Determine if two expressions are lexically equivalent. */\n+/* Determine if two expressions are lexically equivalent.  */\n \n static inline bool\n expr_lexically_eq (const tree v1, const tree v2)\n@@ -3306,7 +3306,7 @@ execute_pre (void)\n   /* Compute immediate dominators.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* DCE screws the dom_children up, without bothering to fix it. So fix it. */\n+  /* DCE screws the dom_children up, without bothering to fix it. So fix it.  */\n   currbbs = n_basic_blocks;\n   dfn = xcalloc (last_basic_block + 1, sizeof (int));\n   build_dfn_array (ENTRY_BLOCK_PTR, 0);"}, {"sha": "085fe7102dda1fe40a9c241aa14ef52858fa0d92", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -54,7 +54,7 @@ enum tree_code {\n extern const char tree_code_type[];\n #define TREE_CODE_CLASS(CODE)\ttree_code_type[(int) (CODE)]\n \n-/* Returns nonzero iff CLASS is not the tree code of a type. */\n+/* Returns nonzero iff CLASS is not the tree code of a type.  */\n \n #define IS_NON_TYPE_CODE_CLASS(CLASS) (strchr (\"xbcdr<12se\", (CLASS)) != 0)\n \n@@ -1245,7 +1245,7 @@ struct tree_eref_common GTY(())\n   /* SSAPRE: The statement associated with this expression reference.  */\n   tree stmt;\n   \n-  /* SSAPRE: True if expression needs to be saved to a temporary. */\n+  /* SSAPRE: True if expression needs to be saved to a temporary.  */\n   unsigned int save:1;\n   \n   /* SSAPRE: True if expression needs to be reloaded from a temporary.  */\n@@ -1254,7 +1254,7 @@ struct tree_eref_common GTY(())\n   /* SSAPRE: Redundancy class of expression.  */\n   unsigned int class;\n   \n-  /* SSAPRE: Processed flag 1. */\n+  /* SSAPRE: Processed flag 1.  */\n   unsigned int processed:1;\n \n   /* SSAPRE: True if expression is injured.  */\n@@ -1269,10 +1269,10 @@ struct tree_euse_node GTY(())\n {\n   struct tree_eref_common common;\n   \n-  /* SSAPRE: Definition for this use. */\n+  /* SSAPRE: Definition for this use.  */\n   tree def;\n   \n-  /* SSAPRE: True if this is an EPHI operand occurrence. */\n+  /* SSAPRE: True if this is an EPHI operand occurrence.  */\n   unsigned int op_occurrence:1;\n   \n   /* SSAPRE: True if expression was inserted as a PHI operand occurrence.  */\n@@ -1287,7 +1287,7 @@ struct ephi_arg_d GTY(())\n   /* SSAPRE: True if this phi argument is injured.  */\n   unsigned int injured:1;\n \n-  /* SSAPRE: True if there is a real occurrence for this phi argument. */\n+  /* SSAPRE: True if there is a real occurrence for this phi argument.  */\n   unsigned int has_real_use:1;\n \n   /* SSAPRE: True if delayed renaming is required on this phi argument.  */\n@@ -1299,7 +1299,7 @@ struct ephi_arg_d GTY(())\n   /* SSAPRE: True if this operand stops forward movement.  */\n   unsigned int stops:1;\n  \n-  /* SSAPRE: Definition of this phi operand. */\n+  /* SSAPRE: Definition of this phi operand.  */\n   tree def;\n   \n   /* SSAPRE: Phi predecessor for this phi operand.  */\n@@ -1317,10 +1317,10 @@ struct tree_ephi_node GTY(())\n   /* SSAPRE: True if PHI is cant_be_avail.  */\n   unsigned int cant_be_avail:1;\n \n-  /* SSAPRE: True if PHI is dead. */\n+  /* SSAPRE: True if PHI is dead.  */\n   unsigned int dead:1;\n   \n-  /* SSAPRE: True if PHI is pointless or identical to some value. */\n+  /* SSAPRE: True if PHI is pointless or identical to some value.  */\n   unsigned int identity:1;\n \n   /* SSAPRE: True if replacing occurrence known for ESSA minimization.  */\n@@ -2184,7 +2184,7 @@ struct tree_type GTY(())\n #define DECL_POINTER_ALIAS_SET(NODE) \\\n   (DECL_CHECK (NODE)->decl.pointer_alias_set)\n \n-/* Used to store the alias_var for a DECL node. */\n+/* Used to store the alias_var for a DECL node.  */\n #define DECL_PTA_ALIASVAR(NODE) \\\n   (DECL_CHECK (NODE)->decl.alias_var)\n \n@@ -3734,7 +3734,7 @@ enum tree_dump_index\n \t\t\t\t   within it.  */\n   TDI_vcg,\t\t\t/* create a VCG graph file for each \n \t\t\t\t   function's flowgraph.  */\n-  TDI_xml,                      /* dump function call graph.   */\n+  TDI_xml,                      /* dump function call graph.  */\n   TDI_all,\t\t\t/* enable all the dumps.  */\n   TDI_end\n };"}, {"sha": "e71e5e5646453a85c7c9dddfa5a9c01954c8fdb2", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -74,7 +74,7 @@ extern bool value_profile_transformations (void);\n \f\n /* External declarations for edge-based profiling.  */\n struct profile_hooks {\n-  /* Insert code to increment an edge count. */\n+  /* Insert code to increment an edge count.  */\n   void (*gen_edge_profiler) (int, edge);\n \n   /* Insert code to increment the interval histogram counter.  */\n@@ -83,7 +83,7 @@ struct profile_hooks {\n   /* Insert code to increment the power of two histogram counter.  */\n   void (*gen_pow2_profiler) (struct histogram_value *, unsigned, unsigned);\n \n-  /* Insert code to find the most common value. */\n+  /* Insert code to find the most common value.  */\n   void (*gen_one_value_profiler) (struct histogram_value *, unsigned, unsigned);\n \n   /* Insert code to find the most common value of a difference between two"}, {"sha": "e7eeb3f60a876056d5a5c1f1d9863b8c0f47ac01", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf737f89ffe0c75614ad388440b7b7706b6316b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9cf737f89ffe0c75614ad388440b7b7706b6316b", "patch": "@@ -2418,7 +2418,7 @@ build_constant_desc (tree exp)\n   desc = ggc_alloc (sizeof (*desc));\n   desc->value = copy_constant (exp);\n \n-  /* Propagate marked-ness to copied constant. */\n+  /* Propagate marked-ness to copied constant.  */\n   if (flag_mudflap && mf_marked_p (exp))\n     mf_mark (desc->value);\n \n@@ -4996,7 +4996,7 @@ default_globalize_label (FILE * stream, const char *name)\n \n /* Default function to output a label for unwind information.  The\n    default is to do nothing.  A target that needs nonlocal labels for\n-   unwind information must provide its own function to do this. */\n+   unwind information must provide its own function to do this.  */\n void\n default_emit_unwind_label (FILE * stream ATTRIBUTE_UNUSED,\n \t\t\t   tree decl ATTRIBUTE_UNUSED,"}]}