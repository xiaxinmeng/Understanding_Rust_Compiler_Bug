{"sha": "28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1NjdjNDBlMmM3Yzg4ZTQyNDI4M2U4YTFhNmZmOGNiN2JhNDQwYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-11-08T17:13:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-11-08T17:13:04Z"}, "message": "builtin-types.def (BT_FN_VOID_BOOL, [...]): New.\n\n\t* builtin-types.def (BT_FN_VOID_BOOL, BT_FN_VOID_SIZE_SIZE_PTR,\n\tBT_FN_UINT_UINT_PTR_PTR, BT_FN_UINT_OMPFN_PTR_UINT_UINT,\n\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n\tBT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n\tBT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR): New.\n\t* gengtype.c (open_base_files): Add omp-general.h.\n\t* gimple.c (gimple_build_omp_critical):\n\t(gimple_build_omp_taskgroup): Add CLAUSES argument.  Call\n\tgimple_omp_taskgroup_set_clauses.\n\t(gimple_build_omp_atomic_load): Add mo argument, call\n\tgimple_omp_atomic_set_memory_order.\n\t(gimple_build_omp_atomic_store): Likewise.\n\t(gimple_copy): Adjust handling of GIMPLE_OMP_TASKGROUP.\n\t* gimple.def (GIMPLE_OMP_TASKGROUP): Use GSS_OMP_SINGLE_LAYOUT\n\tinstead of GSS_OMP.\n\t(GIMPLE_OMP_TEAMS): Use GSS_OMP_PARALLEL_LAYOUT instead\n\tof GSS_OMP_SINGLE_LAYOUT, adjust comments.\n\t* gimple.h (enum gf_mask): Add GF_OMP_TEAMS_HOST, GF_OMP_TASK_TASKWAIT\n\tand GF_OMP_ATOMIC_MEMORY_ORDER.  Remove GF_OMP_ATOMIC_SEQ_CST, use\n\tdifferent value for GF_OMP_ATOMIC_NEED_VALUE.\n\t(struct gimple_statement_omp_taskreg): Add GIMPLE_OMP_TEAMS to\n\tcomments.\n\t(struct gimple_statement_omp_single_layout): And remove here.\n\t(struct gomp_teams): Inherit from gimple_statement_omp_taskreg rather\n\tthan gimple_statement_omp_single_layout.\n\t(is_a_helper <gimple_statement_omp_taskreg *>::test): Allow\n\tGIMPLE_OMP_TEAMS.\n\t(is_a_helper <const gimple_statement_omp_taskreg *>::test): Likewise.\n\t(gimple_omp_subcode): Formatting fix.\n\t(gimple_omp_teams_child_fn, gimple_omp_teams_child_fn_ptr,\n\tgimple_omp_teams_set_child_fn, gimple_omp_teams_data_arg,\n\tgimple_omp_teams_data_arg_ptr, gimple_omp_teams_set_data_arg,\n\tgimple_omp_teams_host, gimple_omp_teams_set_host,\n\tgimple_omp_task_taskwait_p, gimple_omp_task_set_taskwait_p,\n\tgimple_omp_taskgroup_clauses, gimple_omp_taskgroup_clauses_ptr,\n\tgimple_omp_taskgroup_set_clauses): New inline functions.\n\t(gimple_build_omp_atomic_load): Add enum omp_memory_order argument.\n\t(gimple_build_omp_atomic_store): Likewise.\n\t(gimple_omp_atomic_seq_cst_p): Remove.\n\t(gimple_omp_atomic_memory_order): New function.\n\t(gimple_omp_atomic_set_seq_cst): Remove.\n\t(gimple_omp_atomic_set_memory_order): New function.\n\t(gimple_build_omp_taskgroup): Add clauses argument.\n\t* gimple-pretty-print.c (dump_gimple_omp_taskgroup): New function.\n\t(dump_gimple_omp_task): Print taskwait with depend clauses.\n\t(dump_gimple_omp_atomic_load, dump_gimple_omp_atomic_store): Use\n\tdump_omp_atomic_memory_order.\n\t(pp_gimple_stmt_1): Handle GIMPLE_OMP_TASKGROUP.\n\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP_ALLOC_ONLY,\n\tGOVD_MAP_FROM_ONLY and GOVD_NONTEMPORAL.\n\t(enum omp_region_type): Reserve bits 1 and 2 for auxiliary flags,\n\trenumber values of most of ORT_* enumerators, add ORT_HOST_TEAMS,\n\tORT_COMBINED_HOST_TEAMS, ORT_TASKGROUP, ORT_TASKLOOP and\n\tORT_UNTIED_TASKLOOP enumerators.\n\t(enum gimplify_defaultmap_kind): New.\n\t(struct gimplify_omp_ctx): Remove target_map_scalars_firstprivate and\n\ttarget_map_pointers_as_0len_arrays members, add defaultmap.\n\t(new_omp_context): Initialize defaultmap member.\n\t(gimple_add_tmp_var): Handle ORT_TASKGROUP like ORT_WORKSHARE.\n\t(maybe_fold_stmt): Don't fold even in host teams regions.\n\t(omp_firstprivatize_variable): Handle ORT_TASKGROUP like\n\tORT_WORKSHARE.  Test ctx->defaultmap[GDMK_SCALAR] instead of\n\tctx->omp_firstprivatize_variable.\n\t(omp_add_variable): Don't add private/firstprivate for VLAs in\n\tORT_TASKGROUP.\n\t(omp_default_clause): Print \"taskloop\" rather than \"task\" if\n\tORT_*TASKLOOP.\n\t(omp_notice_variable): Handle ORT_TASKGROUP like ORT_WORKSHARE.\n\tHandle new defaultmap clause kinds.\n\t(omp_is_private): Handle ORT_TASKGROUP like ORT_WORKSHARE.  Allow simd\n\titerator to be lastprivate or private.  Fix up diagnostics if linear\n\tis used on collapse>1 simd iterator.\n\t(omp_check_private): Handle ORT_TASKGROUP like ORT_WORKSHARE.\n\t(gimplify_omp_depend): New function.\n\t(gimplify_scan_omp_clauses): Add shared clause on parallel for\n\tcombined parallel master taskloop{, simd} if taskloop has\n\tfirstprivate, lastprivate or reduction clause.  Handle\n\tOMP_CLAUSE_REDUCTION_TASK diagnostics.  Adjust tests for\n\tORT_COMBINED_TEAMS.  Gimplify depend clauses with iterators.  Handle\n\tcancel and simd OMP_CLAUSE_IF_MODIFIERs.  Handle\n\tOMP_CLAUSE_NONTEMPORAL.  Handle new defaultmap clause kinds.  Handle\n\tOMP_CLAUSE_{TASK,IN}_REDUCTION.  Diagnose invalid conditional\n\tlastprivate.\n\t(gimplify_adjust_omp_clauses_1): Ignore GOVD_NONTEMPORAL.  Handle\n\tGOVD_MAP_ALLOC_ONLY and GOVD_MAP_FROM_ONLY.  \n\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_NONTEMPORAL.  Handle\n\tOMP_CLAUSE_{TASK,IN}_REDUCTION.\n\t(gimplify_omp_task): Handle taskwait with depend clauses.\n\t(gimplify_omp_for): Add shared clause on parallel for combined\n\tparallel master taskloop{, simd} if taskloop has firstprivate,\n\tlastprivate or reduction clause.  Use ORT_TASKLOOP or\n\tORT_UNTIED_TASKLOOP instead of ORT_TASK or ORT_UNTIED_TASK.  Adjust\n\ttests for ORT_COMBINED_TEAMS.  Handle C++ range for loops with\n\tNULL TREE_PURPOSE in OMP_FOR_ORIG_DECLS.  Firstprivatize\n\t__for_end and __for_range temporaries on OMP_PARALLEL for\n\tdistribute parallel for{, simd}.  Move OMP_CLAUSE_REDUCTION\n\tand OMP_CLAUSE_IN_REDUCTION from taskloop to the task construct\n\tsandwiched in between two taskloops.\n\t(computable_teams_clause): Test ctx->defaultmap[GDMK_SCALAR]\n\tinstead of ctx->omp_firstprivatize_variable.\n\t(gimplify_omp_workshare): Set ort to ORT_HOST_TEAMS or\n\tORT_COMBINED_HOST_TEAMS if not inside of target construct.  If\n\thost teams, use gimplify_and_return_first etc. for body like\n\tfor target or target data constructs, and at the end call\n\tgimple_omp_teams_set_host on the GIMPLE_OMP_TEAMS object.\n\t(gimplify_omp_atomic): Use OMP_ATOMIC_MEMORY_ORDER instead\n\tof OMP_ATOMIC_SEQ_CST, pass it as new argument to\n\tgimple_build_omp_atomic_load and gimple_build_omp_atomic_store, remove\n\tgimple_omp_atomic_set_seq_cst calls.\n\t(gimplify_expr) <case OMP_TASKGROUP>: Move handling into a separate\n\tcase, handle taskgroup clauses.\n\t* lto-streamer-out.c (hash_tree): Handle\n\tOMP_CLAUSE_{TASK,IN}_REDUCTION.\n\t* Makefile.in (GTFILES): Add omp-general.h.\n\t* omp-builtins.def (BUILT_IN_GOMP_TASKWAIT_DEPEND,\n\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_MAYBE_NONMONOTONIC_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_START, BUILT_IN_GOMP_LOOP_ORDERED_START,\n\tBUILT_IN_GOMP_LOOP_DOACROSS_START,\n\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_LOOP_MAYBE_NONMONOTONIC_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_ULL_MAYBE_NONMONOTONIC_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_ULL_START, BUILT_IN_GOMP_LOOP_ULL_ORDERED_START,\n\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_START,\n\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_MAYBE_NONMONOTONIC_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_RUNTIME,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_MAYBE_NONMONOTONIC_RUNTIME,\n\tBUILT_IN_GOMP_PARALLEL_REDUCTIONS, BUILT_IN_GOMP_SECTIONS2_START,\n\tBUILT_IN_GOMP_TEAMS_REG, BUILT_IN_GOMP_TASKGROUP_REDUCTION_REGISTER,\n\tBUILT_IN_GOMP_TASKGROUP_REDUCTION_UNREGISTER,\n\tBUILT_IN_GOMP_TASK_REDUCTION_REMAP,\n\tBUILT_IN_GOMP_WORKSHARE_TASK_REDUCTION_UNREGISTER): New builtins.\n\t* omp-expand.c (workshare_safe_to_combine_p): Return false for\n\tnon-worksharing loops.\n\t(omp_adjust_chunk_size): Don't adjust anything if chunk_size is zero.\n\t(determine_parallel_type): Don't combine parallel with worksharing\n\twhich has _reductemp_ clause.\n\t(expand_parallel_call): Emit the GOMP_*nonmonotonic_runtime* or\n\tGOMP_*maybe_nonmonotonic_runtime* builtins instead of GOMP_*runtime*\n\tif there is nonmonotonic modifier or if there is no modifier and no\n\tordered clause.  For dynamic and guided schedule without monotonic\n\tand nonmonotonic modifier, default to nonmonotonic.\n\t(expand_omp_for): Likewise.  Adjust expand_omp_for_generic caller, use\n\tGOMP_loop{,_ull}{,_ordered,_doacross}_start builtins if there are\n\ttask reductions.\n\t(expand_task_call): Add GOMP_TASK_FLAG_REDUCTION flag to flags if\n\tthere are any reduction clauses.\n\t(expand_taskwait_call): New function.\n\t(expand_teams_call): New function.\n\t(expand_omp_taskreg): Allow GIMPLE_OMP_TEAMS and call\n\texpand_teams_call for it.  Formatting fix.  Handle taskwait with\n\tdepend clauses.\n\t(expand_omp_for_generic): Add SCHED_ARG argument.  Handle expansion\n\tof worksharing loops with task reductions.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk): Handle\n\texpansion of worksharing loops with task reductions.\n\t(expand_omp_sections): Handle expansion of sections with task\n\treductions.\n\t(expand_omp_synch): For host teams call expand_omp_taskreg.\n\t(omp_memory_order_to_memmodel): New function.\n\t(expand_omp_atomic_load, expand_omp_atomic_store,\n\texpand_omp_atomic_fetch_op): Use it and gimple_omp_atomic_memory_order\n\tinstead of gimple_omp_atomic_seq_cst_p.\n\t(build_omp_regions_1, omp_make_gimple_edges): Treat taskwait with\n\tdepend clauses as a standalone directive.\n\t* omp-general.c (enum omp_requires): New variable.\n\t(omp_extract_for_data): Initialize have_reductemp member.  Allow\n\tNE_EXPR even in OpenMP loops, transform them into LT_EXPR or\n\tGT_EXPR loops depending on incr sign.  Formatting fixes.\n\t* omp-general.h (struct omp_for_data): Add have_reductemp member.\n\t(enum omp_requires): New enum.\n\t(omp_requires_mask): Declare.\n\t* omp-grid.c (grid_eliminate_combined_simd_part): Formatting fix.\n\tFix comment typos.\n\t* omp-low.c (struct omp_context): Add task_reductions and\n\ttask_reduction_map fields.\n\t(is_host_teams_ctx): New function.\n\t(is_taskreg_ctx): Return true also if is_host_teams_ctx.\n\t(use_pointer_for_field): Use is_global_var instead of\n\tTREE_STATIC || DECL_EXTERNAL, and apply only if not privatized\n\tin outer contexts.\n\t(build_outer_var_ref): Ignore taskgroup outer contexts.\n\t(delete_omp_context): Release task_reductions and task_reduction_map.\n\t(scan_sharing_clauses): Don't add any fields for reduction clause on\n\ttaskloop.  Handle OMP_CLAUSE__REDUCTEMP_.  Handle\n\tOMP_CLAUSE_{IN,TASK}_REDUCTION and OMP_CLAUSE_REDUCTION with task\n\tmodifier.  Don't ignore shared clauses in is_host_teams_ctx contexts.\n\tHandle OMP_CLAUSE_NONTEMPORAL.\n\t(add_taskreg_looptemp_clauses): Add OMP_CLAUSE__REDUCTEMP_ clause if\n\tneeded.\n\t(scan_omp_parallel): Add _reductemp_ clause if there are any reduction\n\tclauses with task modifier.\n\t(scan_omp_task): Handle taskwait with depend clauses.\n\t(finish_taskreg_scan): Move field corresponding to _reductemp_ clause\n\tfirst.  Move also OMP_CLAUSE__REDUCTEMP_ clause in front if present.\n\tHandle GIMPLE_OMP_TEAMS like GIMPLE_OMP_PARALLEL.\n\t(scan_omp_for): Fix comment formatting.\n\t(scan_omp_teams): Handle host teams constructs.\n\t(check_omp_nesting_restrictions): Allow teams with no outer\n\tOpenMP context.  Adjust diagnostics for teams strictly nested into\n\tsome explicit OpenMP construct other than target.  Allow OpenMP atomics\n\tinside of simd regions.\n\t(scan_omp_1_stmt): Call scan_sharing_clauses for taskgroups.\n\t(scan_omp_1_stmt) <case GIMPLE_OMP_TEAMS>: Temporarily bump\n\ttaskreg_nesting_level while scanning host teams construct.\n\t(task_reduction_read): New function.\n\t(lower_rec_input_clauses): Handle OMP_CLAUSE_REDUCTION on taskloop\n\tconstruct.  Handle OMP_CLAUSE_IN_REDUCTION and OMP_CLAUSE__REDUCTEMP_\n\tclauses.  Handle OMP_CLAUSE_REDUCTION with task modifier.  Remove\n\tsecond argument create_tmp_var if it is NULL.  Don't ignore shared\n\tclauses in is_host_teams_ctx contexts.  Handle\n\tOMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE on OMP_CLAUSE_FIRSTPRIVATE\n\tclauses.\n\t(lower_reduction_clauses): Ignore reduction clauses with task\n\tmodifier.  Remove second argument create_tmp_var if it is NULL.\n\tInitialize OMP_ATOMIC_MEMORY_ORDER to relaxed.\n\t(lower_send_clauses): Ignore reduction clauses with task modifier.\n\tHandle OMP_CLAUSE__REDUCTEMP_.  Don't send anything for\n\tOMP_CLAUSE_REDUCTION on taskloop.  Handle OMP_CLAUSE_IN_REDUCTION.\n\t(maybe_add_implicit_barrier_cancel): Add OMP_RETURN argument, don't\n\trely that it is the last stmt in body so far.  Ignore outer taskgroup\n\tcontexts.\n\t(omp_task_reductions_find_first, omp_task_reduction_iterate,\n\tlower_omp_task_reductions): New functions.\n\t(lower_omp_sections): Handle reduction clauses with taskgroup\n\tmodifiers.  Adjust maybe_add_implicit_barrier_cancel caller.\n\t(lower_omp_single): Adjust maybe_add_implicit_barrier_cancel caller.\n\t(lower_omp_for): Likewise.  Handle reduction clauses with taskgroup\n\tmodifiers.\n\t(lower_omp_taskgroup): Handle taskgroup reductions.\n\t(create_task_copyfn): Copy over OMP_CLAUSE__REDUCTEMP_ pointer.\n\tHandle OMP_CLAUSE_IN_REDUCTION and OMP_CLAUSE_REDUCTION clauses.\n\t(lower_depend_clauses): If there are any\n\tOMP_CLAUSE_DEPEND_DEPOBJ or OMP_CLAUSE_DEPEND_MUTEXINOUTSET\n\tdepend clauses, use a new array format.  If OMP_CLAUSE_DEPEND_LAST is\n\tseen, assume lowering is done already and return early.  Set kind\n\ton artificial depend clause to OMP_CLAUSE_DEPEND_LAST.\n\t(lower_omp_taskreg): Handle reduction clauses with task modifier on\n\tparallel construct.  Handle reduction clause on taskloop construct.\n\tHandle taskwait with depend clauses.\n\t(lower_omp_1): Use lower_omp_taskreg instead of lower_omp_teams\n\tfor host teams constructs.\n\t* tree.c (omp_clause_num_ops): Add in_reduction, task_reduction,\n\tnontemporal and _reductemp_ clause entries.\n\t(omp_clause_code_name): Likewise.\n\t(walk_tree_1): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION,\n\tOMP_CLAUSE_NONTEMPORAL and OMP_CLAUSE__REDUCTEMP_.\n\t* tree-core.h (enum omp_clause_code): Add\n\tOMP_CLAUSE_{{IN,TASK}_REDUCTION,NONTEMPORAL,_REDUCTEMP_}.\n\t(enum omp_clause_defaultmap_kind, enum omp_memory_order): New.\n\t(struct tree_base): Add omp_atomic_memory_order field into union.\n\tRemove OMP_ATOMIC_SEQ_CST comment.\n\t(enum omp_clause_depend_kind): Add OMP_CLAUSE_DEPEND_MUTEXINOUTSET\n\tand OMP_CLAUSE_DEPEND_DEPOBJ.\n\t(struct tree_omp_clause): Add subcode.defaultmap_kind.\n\t* tree.def (OMP_TASKGROUP): Add another operand, move next to other\n\tOpenMP constructs with body and clauses operands.\n\t* tree.h (OMP_BODY): Use OMP_MASTER instead of OMP_TASKGROUP.\n\t(OMP_CLAUSES): Use OMP_TASKGROUP instead of OMP_SINGLE.\n\t(OMP_TASKGROUP_CLAUSES): Define.\n\t(OMP_CLAUSE_DECL): Use OMP_CLAUSE__REDUCTEMP_ instead of\n\tOMP_CLAUSE__LOOPTEMP_.\n\t(OMP_ATOMIC_SEQ_CST): Remove.\n\t(OMP_ATOMIC_MEMORY_ORDER, OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE,\n\tOMP_CLAUSE_LASTPRIVATE_CONDITIONAL): Define.\n\t(OMP_CLAUSE_REDUCTION_CODE, OMP_CLAUSE_REDUCTION_INIT,\n\tOMP_CLAUSE_REDUCTION_MERGE, OMP_CLAUSE_REDUCTION_PLACEHOLDER,\n\tOMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER,\n\tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF): Handle\n\tOMP_CLAUSE_{,IN_,TASK_}REDUCTION.\n\t(OMP_CLAUSE_REDUCTION_TASK, OMP_CLAUSE_REDUCTION_INSCAN,\n\tOMP_CLAUSE_DEFAULTMAP_KIND, OMP_CLAUSE_DEFAULTMAP_CATEGORY,\n\tOMP_CLAUSE_DEFAULTMAP_BEHAVIOR, OMP_CLAUSE_DEFAULTMAP_SET_KIND):\n\tDefine.\n\t* tree-inline.c (remap_gimple_stmt): Remap taskgroup clauses.\n\t* tree-nested.c (convert_nonlocal_omp_clauses): Handle\n\tOMP_CLAUSE__REDUCTEMP_, OMP_CLAUSE_NONTEMPORAL.\n\t(convert_local_omp_clauses): Likewise.  Remove useless test.\n\t* tree-parloops.c (create_call_for_reduction_1): Pass\n\tOMP_MEMORY_ORDER_RELAXED as new argument to\n\tdump_gimple_omp_atomic_load and dump_gimple_omp_atomic_store.\n\t* tree-pretty-print.c (dump_omp_iterators): New function.\n\t(dump_omp_clause): Handle OMP_CLAUSE__REDUCTEMP_,\n\tOMP_CLAUSE_NONTEMPORAL, OMP_CLAUSE_{TASK,IN}_REDUCTION.  Print\n\treduction modifiers.  Handle OMP_CLAUSE_DEPEND_DEPOBJ and\n\tOMP_CLAUSE_DEPEND_MUTEXINOUTSET.  Print iterators in depend clauses.\n\tPrint __internal__ for OMP_CLAUSE_DEPEND_LAST.  Handle cancel and\n\tsimd OMP_CLAUSE_IF_MODIFIERs.  Handle new kinds of\n\tOMP_CLAUSE_DEFAULTMAP. Print conditional: for\n\tOMP_CLAUSE_LASTPRIVATE_CONDITIONAL.\n\t(dump_omp_atomic_memory_order): New function.\n\t(dump_generic_node): Use it.  Print taskgroup clauses.  Print\n\ttaskwait with depend clauses.\n\t* tree-pretty-print.h (dump_omp_atomic_memory_order): Declare.\n\t* tree-streamer-in.c (unpack_ts_omp_clause_value_fields):\n\tHandle OMP_CLAUSE_{TASK,IN}_REDUCTION.\n\t* tree-streamer-out.c (pack_ts_omp_clause_value_fields,\n\twrite_ts_omp_clause_tree_pointers): Likewise.\ngcc/c-family/\n\t* c-common.h (c_finish_omp_taskgroup): Add CLAUSES argument.\n\t(c_finish_omp_atomic): Replace bool SEQ_CST argument with\n\tenum omp_memory_order MEMORY_ORDER.\n\t(c_finish_omp_flush): Add MO argument.\n\t(c_omp_depend_t_p, c_finish_omp_depobj): Declare.\n\t(c_finish_omp_for): Add FINAL_P argument.\n\t* c-omp.c: Include memmodel.h.\n\t(c_finish_omp_taskgroup): Add CLAUSES argument.  Set\n\tOMP_TASKGROUP_CLAUSES to it.\n\t(c_finish_omp_atomic): Replace bool SEQ_CST argument with\n\tenum omp_memory_order MEMORY_ORDER.  Set OMP_ATOMIC_MEMORY_ORDER\n\tinstead of OMP_ATOMIC_SEQ_CST.\n\t(c_omp_depend_t_p, c_finish_omp_depobj): New functions.\n\t(c_finish_omp_flush): Add MO argument, if not MEMMODEL_LAST, emit\n\t__atomic_thread_fence call with the given value.\n\t(check_omp_for_incr_expr): Formatting fixes.\n\t(c_finish_omp_for): Add FINAL_P argument.  Allow NE_EXPR\n\teven in OpenMP loops, diagnose if NE_EXPR and incr expression\n\tis not constant expression 1 or -1.  Transform NE_EXPR loops\n\twith iterators pointers to VLA into LT_EXPR or GT_EXPR loops.\n\t(c_omp_check_loop_iv_r): Look for orig decl of C++ range for\n\tloops too.\n\t(c_omp_split_clauses): Add support for combined\n\t#pragma omp parallel master and\n\t#pragma omp {,parallel }master taskloop{, simd} constructs.\n\tHandle OMP_CLAUSE_IN_REDUCTION.  Handle OMP_CLAUSE_REDUCTION_TASK.\n\tHandle OMP_CLAUSE_NONTEMPORAL.  Handle splitting OMP_CLAUSE_IF\n\talso to OMP_SIMD.  Copy OMP_CLAUSE_LASTPRIVATE_CONDITIONAL.\n\t(c_omp_predetermined_sharing): Don't return\n\tOMP_CLAUSE_DEFAULT_SHARED for const qualified decls.\n\t* c-pragma.c (omp_pragmas): Add PRAGMA_OMP_DEPOBJ and\n\tPRAGMA_OMP_REQUIRES.\n\t* c-pragma.h (enum pragma_kind): Likewise.\n\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_NONTEMPORAL\n\tand PRAGMA_OMP_CLAUSE_{IN,TASK}_REDUCTION.\ngcc/c/\n\t* c-parser.c: Include memmode.h.\n\t(c_parser_omp_depobj, c_parser_omp_requires): New functions.\n\t(c_parser_pragma): Handle PRAGMA_OMP_DEPOBJ and PRAGMA_OMP_REQUIRES.\n\t(c_parser_omp_clause_name): Handle nontemporal, in_reduction and\n\ttask_reduction clauses.\n\t(c_parser_omp_variable_list): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION.\n\tFor OMP_CLAUSE_DEPEND, parse clause operands as either an array\n\tsection, or lvalue assignment expression.\n\t(c_parser_omp_clause_if): Handle cancel and simd modifiers.\n\t(c_parser_omp_clause_lastprivate): Parse optional\n\tconditional: modifier.\n\t(c_parser_omp_clause_hint): Require constant integer expression rather\n\tthan just integer expression.\n\t(c_parser_omp_clause_defaultmap): Parse new kinds of defaultmap\n\tclause.\n\t(c_parser_omp_clause_reduction): Add IS_OMP and KIND arguments.\n\tParse reduction modifiers.  Pass KIND to c_parser_omp_variable_list.\n\t(c_parser_omp_clause_nontemporal, c_parser_omp_iterators): New\n\tfunctions.\n\t(c_parser_omp_clause_depend): Parse iterator modifier and handle\n\titerators.  Parse mutexinoutset and depobj kinds.\n\t(c_parser_oacc_all_clauses): Adjust c_parser_omp_clause_reduction\n\tcallers.\n\t(c_parser_omp_all_clauses): Likewise.  Handle\n\tPRAGMA_OMP_CLAUSE_NONTEMPORAL and\n\tPRAGMA_OMP_CLAUSE_{IN,TASK}_REDUCTION.\n\t(c_parser_omp_atomic): Parse hint and memory order clauses.  Handle\n\tdefault memory order from requires directive if any.  Adjust\n\tc_finish_omp_atomic caller.\n\t(c_parser_omp_critical): Allow comma in between (name) and hint clause.\n\t(c_parser_omp_flush): Parse flush with memory-order-clause.\n\t(c_parser_omp_for_loop): Allow NE_EXPR even in\n\tOpenMP loops, adjust c_finish_omp_for caller.\n\t(OMP_SIMD_CLAUSE_MASK): Add if and nontemporal clauses.\n\t(c_parser_omp_master): Add p_name, mask and cclauses arguments.\n\tAllow to be called while parsing combined parallel master.\n\tParse combined master taskloop{, simd}.\n\t(c_parser_omp_parallel): Parse combined\n\tparallel master{, taskloop{, simd}} constructs.\n\t(OMP_TASK_CLAUSE_MASK): Add in_reduction clause.\n\t(OMP_TASKGROUP_CLAUSE_MASK): Define.\n\t(c_parser_omp_taskgroup): Add LOC argument.  Parse taskgroup clauses.\n\t(OMP_TASKWAIT_CLAUSE_MASK): Define.\n\t(c_parser_omp_taskwait): Handle taskwait with depend clauses.\n\t(c_parser_omp_teams): Force a BIND_EXPR with BLOCK\n\taround teams body.  Use SET_EXPR_LOCATION.\n\t(c_parser_omp_target_data): Allow target data\n\twith only use_device_ptr clauses.\n\t(c_parser_omp_target): Use SET_EXPR_LOCATION.  Set\n\tOMP_REQUIRES_TARGET_USED bit in omp_requires_mask.\n\t(c_parser_omp_requires): New function.\n\t(c_finish_taskloop_clauses): New function.\n\t(OMP_TASKLOOP_CLAUSE_MASK): Add reduction and in_reduction clauses.\n\t(c_parser_omp_taskloop): Use c_finish_taskloop_clauses.  Add forward\n\tdeclaration.  Disallow in_reduction clause when combined with parallel\n\tmaster.\n\t(c_parser_omp_construct): Adjust c_parser_omp_master and\n\tc_parser_omp_taskgroup callers.\n\t* c-typeck.c (c_finish_omp_cancel): Diagnose if clause with modifier\n\tother than cancel.\n\t(handle_omp_array_sections_1): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION\n\tlike OMP_CLAUSE_REDUCTION.\n\t(handle_omp_array_sections): Likewise.  Call save_expr on array\n\treductions before calling build_index_type.  Handle depend clauses\n\twith iterators.\n\t(struct c_find_omp_var_s): New type.\n\t(c_find_omp_var_r, c_omp_finish_iterators): New functions.\n\t(c_finish_omp_clauses): Don't diagnose nonmonotonic clause\n\twith static, runtime or auto schedule kinds.  Call save_expr for whole\n\tarray reduction sizes.  Diagnose reductions with zero sized elements\n\tor variable length structures.  Diagnose nogroup clause used with\n\treduction clause(s).  Handle depend clause with\n\tOMP_CLAUSE_DEPEND_DEPOBJ.  Diagnose bit-fields.  Require\n\tomp_depend_t type for OMP_CLAUSE_DEPEND_DEPOBJ kinds and\n\tsome different type for other kinds.  Use build_unary_op with\n\tADDR_EXPR and build_indirect_ref instead of c_mark_addressable.\n\tHandle depend clauses with iterators.  Remove no longer needed special\n\tcase that predetermined const qualified vars may be specified in\n\tfirstprivate clause.  Complain if const qualified vars are mentioned\n\tin data-sharing clauses other than firstprivate or shared.  Use\n\terror_at with OMP_CLAUSE_LOCATION (c) as first argument instead of\n\terror.  Formatting fix.  Handle OMP_CLAUSE_NONTEMPORAL and\n\tOMP_CLAUSE_{IN,TASK}_REDUCTION.  Allow any lvalue as\n\tOMP_CLAUSE_DEPEND operand (besides array section), adjust diagnostics.\ngcc/cp/\n\t* constexpr.c (potential_constant_expression_1): Handle OMP_DEPOBJ.\n\t* cp-gimplify.c (cp_genericize_r): Handle\n\tOMP_CLAUSE_{IN,TASK}_REDUCTION.\n\t(cxx_omp_predetermined_sharing_1): Don't return\n\tOMP_CLAUSE_DEFAULT_SHARED for const qualified decls with no mutable\n\tmember.  Return OMP_CLAUSE_DEFAULT_FIRSTPRIVATE for this pointer.\n\t* cp-objcp-common.c (cp_common_init_ts): Handle OMP_DEPOBJ.\n\t* cp-tree.def (OMP_DEPOBJ): New tree code.\n\t* cp-tree.h (OMP_ATOMIC_DEPENDENT_P): Return true also for first\n\targument being OMP_CLAUSE.\n\t(OMP_DEPOBJ_DEPOBJ, OMP_DEPOBJ_CLAUSES): Define.\n\t(cp_convert_omp_range_for, cp_finish_omp_range_for): Declare.\n\t(finish_omp_atomic): Add LOC, CLAUSES and MO arguments.  Remove\n\tSEQ_CST argument.\n\t(finish_omp_for_block): Declare.\n\t(finish_omp_flush): Add MO argument.\n\t(finish_omp_depobj): Declare.\n\t* cxx-pretty-print.c (cxx_pretty_printer::statement): Handle\n\tOMP_DEPOBJ.\n\t* dump.c (cp_dump_tree): Likewise.\n\t* lex.c (cxx_init): Likewise.\n\t* parser.c: Include memmodel.h.\n\t(cp_parser_for): Pass false as new is_omp argument to\n\tcp_parser_range_for.\n\t(cp_parser_range_for): Add IS_OMP argument, return before finalizing\n\tif it is true.\n\t(cp_parser_omp_clause_name): Handle nontemporal, in_reduction and\n\ttask_reduction clauses.\n        (cp_parser_omp_var_list_no_open): Handle\n\tOMP_CLAUSE_{IN,TASK}_REDUCTION.  For OMP_CLAUSE_DEPEND, parse clause\n\toperands as either an array section, or lvalue assignment expression.\n\t(cp_parser_omp_clause_if): Handle cancel and simd modifiers.\n\t(cp_parser_omp_clause_defaultmap): Parse new kinds of defaultmap\n\tclause.\n\t(cp_parser_omp_clause_reduction): Add IS_OMP and KIND arguments.\n\tParse reduction modifiers.  Pass KIND to c_parser_omp_variable_list.\n\t(cp_parser_omp_clause_lastprivate, cp_parser_omp_iterators): New\n\tfunctions.\n\t(cp_parser_omp_clause_depend): Parse iterator modifier and handle\n\titerators.  Parse mutexinoutset and depobj kinds.\n\t(cp_parser_oacc_all_clauses): Adjust cp_parser_omp_clause_reduction\n\tcallers.\n\t(cp_parser_omp_all_clauses): Likewise.  Handle\n\tPRAGMA_OMP_CLAUSE_NONTEMPORAL and\n\tPRAGMA_OMP_CLAUSE_{IN,TASK}_REDUCTION.  Call\n\tcp_parser_omp_clause_lastprivate for OpenMP lastprivate clause.\n\t(cp_parser_omp_atomic): Pass pragma_tok->location as\n\tLOC to finish_omp_atomic.  Parse hint and memory order clauses.\n\tHandle default memory order from requires directive if any.  Adjust\n\tfinish_omp_atomic caller.\n\t(cp_parser_omp_critical): Allow comma in between (name) and hint\n\tclause.\n\t(cp_parser_omp_depobj): New function.\n\t(cp_parser_omp_flush): Parse flush with memory-order-clause.\n\t(cp_parser_omp_for_cond): Allow NE_EXPR even in OpenMP loops.\n\t(cp_convert_omp_range_for, cp_finish_omp_range_for): New functions.\n\t(cp_parser_omp_for_loop): Parse C++11 range for loops among omp\n\tloops.  Handle OMP_CLAUSE_IN_REDUCTION like OMP_CLAUSE_REDUCTION.\n\t(OMP_SIMD_CLAUSE_MASK): Add if and nontemporal clauses.\n\t(cp_parser_omp_simd, cp_parser_omp_for): Call keep_next_level before\n\tbegin_omp_structured_block and call finish_omp_for_block on\n\tfinish_omp_structured_block result.\n\t(cp_parser_omp_master): Add p_name, mask and cclauses arguments.\n\tAllow to be called while parsing combined parallel master.\n\tParse combined master taskloop{, simd}.\n\t(cp_parser_omp_parallel): Parse combined\n\tparallel master{, taskloop{, simd}} constructs.\n\t(cp_parser_omp_single): Use SET_EXPR_LOCATION.\n\t(OMP_TASK_CLAUSE_MASK): Add in_reduction clause.\n\t(OMP_TASKWAIT_CLAUSE_MASK): Define.\n\t(cp_parser_omp_taskwait): Handle taskwait with depend clauses.\n\t(OMP_TASKGROUP_CLAUSE_MASK): Define.\n\t(cp_parser_omp_taskgroup): Parse taskgroup clauses, adjust\n\tc_finish_omp_taskgroup caller.\n\t(cp_parser_omp_distribute): Call keep_next_level before\n\tbegin_omp_structured_block and call finish_omp_for_block on\n\tfinish_omp_structured_block result.\n\t(cp_parser_omp_teams): Force a BIND_EXPR with BLOCK around teams\n\tbody.\n\t(cp_parser_omp_target_data): Allow target data with only\n\tuse_device_ptr clauses.\n\t(cp_parser_omp_target): Set OMP_REQUIRES_TARGET_USED bit in\n\tomp_requires_mask.\n\t(cp_parser_omp_requires): New function.\n\t(OMP_TASKLOOP_CLAUSE_MASK): Add reduction and in_reduction clauses.\n\t(cp_parser_omp_taskloop): Add forward declaration.  Disallow\n\tin_reduction clause when combined with parallel master.  Call\n\tkeep_next_level before begin_omp_structured_block and call\n\tfinish_omp_for_block on finish_omp_structured_block result.\n\t(cp_parser_omp_construct): Adjust cp_parser_omp_master caller.\n\t(cp_parser_pragma): Handle PRAGMA_OMP_DEPOBJ and PRAGMA_OMP_REQUIRES.\n\t* pt.c (tsubst_omp_clause_decl): Add iterators_cache argument.\n\tAdjust recursive calls.  Handle iterators.\n\t(tsubst_omp_clauses): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION and\n\tOMP_CLAUSE_NONTEMPORAL.  Adjust tsubst_omp_clause_decl callers.\n\t(tsubst_decomp_names):\n\t(tsubst_omp_for_iterator): Change orig_declv into a reference.\n\tHandle range for loops.  Move orig_declv handling after declv/initv\n\thandling.\n\t(tsubst_expr): Force a BIND_EXPR with BLOCK around teams body.\n\tAdjust finish_omp_atomic caller.  Call keep_next_level before\n\tbegin_omp_structured_block.  Call cp_finish_omp_range_for for range\n\tfor loops and use {begin,finish}_omp_structured_block instead of\n\t{push,pop}_stmt_list if there are any range for loops.  Call\n\tfinish_omp_for_block on finish_omp_structured_block result.\n\tHandle OMP_DEPOBJ.  Handle taskwait with depend clauses.  For\n\tOMP_ATOMIC call tsubst_omp_clauses on clauses if any, adjust\n\tfinish_omp_atomic caller.  Use OMP_ATOMIC_MEMORY_ORDER rather\n\tthan OMP_ATOMIC_SEQ_CST.  Handle clauses on OMP_TASKGROUP.\n\t(dependent_omp_for_p): Always return true for range for loops if\n\tprocessing_template_decl.  Return true if class type iterator\n\tdoes not have INTEGER_CST increment.\n\t* semantics.c: Include memmodel.h.\n\t(handle_omp_array_sections_1): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION\n\tlike OMP_CLAUSE_REDUCTION.\n\t(handle_omp_array_sections): Likewise.  Call save_expr on array\n\treductions before calling build_index_type.  Handle depend clauses\n\twith iterators.\n\t(finish_omp_reduction_clause): Call save_expr for whole array\n\treduction sizes.  Don't mark OMP_CLAUSE_DECL addressable if it has\n\treference type.  Do mark decl_placeholder addressable if needed.\n\tUse error_at with OMP_CLAUSE_LOCATION (c) as first argument instead\n\tof error.\n\t(cp_omp_finish_iterators): New function.\n\t(finish_omp_clauses): Don't diagnose nonmonotonic clause with static,\n\truntime or auto schedule kinds.  Diagnose nogroup clause used with\n\treduction clause(s).  Handle depend clause with\n\tOMP_CLAUSE_DEPEND_DEPOBJ.  Diagnose bit-fields.  Require\n\tomp_depend_t type for OMP_CLAUSE_DEPEND_DEPOBJ kinds and\n\tsome different type for other kinds.  Use cp_build_addr_expr\n\tand cp_build_indirect_ref instead of cxx_mark_addressable.\n\tHandle depend clauses with iterators.  Only handle static data members\n\tin the special case that const qualified vars may be specified in\n\tfirstprivate clause.  Complain if const qualified vars without mutable\n\tmembers are mentioned in data-sharing clauses other than firstprivate\n\tor shared.  Use error_at with OMP_CLAUSE_LOCATION (c) as first\n\targument instead of error.  Diagnose more than one nontemporal clause\n\trefering to the same variable.  Use error_at rather than error for\n\tpriority and hint clause diagnostics.  Fix pasto for hint clause.\n\tDiagnose hint expression that doesn't fold into INTEGER_CST.\n\tDiagnose if clause with modifier other than cancel.  Handle\n\tOMP_CLAUSE_{IN,TASK}_REDUCTION like OMP_CLAUSE_REDUCTION.  Allow any\n\tlvalue as OMP_CLAUSE_DEPEND operand (besides array section), adjust\n\tdiagnostics.\n\t(handle_omp_for_class_iterator): Don't create a new TREE_LIST if one\n\thas been created already for range for, just fill TREE_PURPOSE and\n\tTREE_VALUE.  Call cp_fully_fold on incr.\n\t(finish_omp_for): Don't check cond/incr if cond is global_namespace.\n\tPass to c_omp_check_loop_iv_exprs orig_declv if non-NULL.  Don't\n\tuse IS_EMPTY_STMT on NULL pre_body.  Adjust c_finish_omp_for caller.\n\t(finish_omp_for_block): New function.\n\t(finish_omp_atomic): Add LOC argument, pass it through\n\tto c_finish_omp_atomic and set it as location of OMP_ATOMIC* trees.\n\tRemove SEQ_CST argument.  Add CLAUSES and MO arguments.  Adjust\n\tc_finish_omp_atomic caller.  Stick clauses if any into first argument\n\tof wrapping OMP_ATOMIC.\n\t(finish_omp_depobj): New function.\n\t(finish_omp_flush): Add MO argument, if not\n\tMEMMODEL_LAST, emit __atomic_thread_fence call with the given value.\n\t(finish_omp_cancel): Diagnose if clause with modifier other than\n\tcancel.\ngcc/fortran/\n\t* trans-openmp.c (gfc_trans_omp_clauses): Use\n\tOMP_CLAUSE_DEFAULTMAP_SET_KIND.\n\t(gfc_trans_omp_atomic): Set OMP_ATOMIC_MEMORY_ORDER\n\trather than OMP_ATOMIC_SEQ_CST.\n\t(gfc_trans_omp_taskgroup): Build OMP_TASKGROUP using\n\tmake_node instead of build1_loc.\n\t* types.def (BT_FN_VOID_BOOL, BT_FN_VOID_SIZE_SIZE_PTR,\n\tBT_FN_UINT_UINT_PTR_PTR, BT_FN_UINT_OMPFN_PTR_UINT_UINT,\n\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n\tBT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n\tBT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR): New.\n\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR): Formatting fix.\ngcc/testsuite/\n\t* c-c++-common/gomp/atomic-17.c: New test.\n\t* c-c++-common/gomp/atomic-18.c: New test.\n\t* c-c++-common/gomp/atomic-19.c: New test.\n\t* c-c++-common/gomp/atomic-20.c: New test.\n\t* c-c++-common/gomp/atomic-21.c: New test.\n\t* c-c++-common/gomp/atomic-22.c: New test.\n\t* c-c++-common/gomp/clauses-1.c (r2): New variable.\n\t(foo): Add ntm argument and test if and nontemporal clauses on\n\tconstructs with simd.\n\t(bar): Put taskloop simd inside of taskgroup with task_reduction,\n\tuse in_reduction clause instead of reduction.  Add another\n\ttaskloop simd without nogroup clause, but with reduction clause and\n\ta new in_reduction.  Add ntm and i3 arguments.  Test if and\n\tnontemporal clauses on constructs with simd.  Change if clauses on\n\tsome constructs from specific to the particular constituents to one\n\twithout a modifier.  Add new tests for combined host teams and for\n\tnew parallel master and {,parallel }master taskloop{, simd} combined\n\tconstructs.\n\t(baz): New function with host teams tests.\n\t* gcc.dg/gomp/combined-1.c: Moved to ...\n\t* c-c++-common/gomp/combined-1.c: ... here.  Adjust expected library\n\tcall.\n\t* c-c++-common/gomp/combined-2.c: New test.\n\t* c-c++-common/gomp/combined-3.c: New test.\n\t* c-c++-common/gomp/critical-1.c: New test.\n\t* c-c++-common/gomp/critical-2.c: New test.\n\t* c-c++-common/gomp/default-1.c: New test.\n\t* c-c++-common/gomp/defaultmap-1.c: New test.\n\t* c-c++-common/gomp/defaultmap-2.c: New test.\n\t* c-c++-common/gomp/defaultmap-3.c: New test.\n\t* c-c++-common/gomp/depend-5.c: New test.\n\t* c-c++-common/gomp/depend-6.c: New test.\n\t* c-c++-common/gomp/depend-iterator-1.c: New test.\n\t* c-c++-common/gomp/depend-iterator-2.c: New test.\n\t* c-c++-common/gomp/depobj-1.c: New test.\n\t* c-c++-common/gomp/flush-1.c: New test.\n\t* c-c++-common/gomp/flush-2.c: New test.\n\t* c-c++-common/gomp/for-1.c: New test.\n\t* c-c++-common/gomp/for-2.c: New test.\n\t* c-c++-common/gomp/for-3.c: New test.\n\t* c-c++-common/gomp/for-4.c: New test.\n\t* c-c++-common/gomp/for-5.c: New test.\n\t* c-c++-common/gomp/for-6.c: New test.\n\t* c-c++-common/gomp/for-7.c: New test.\n\t* c-c++-common/gomp/if-1.c (foo): Add some further tests.\n\t* c-c++-common/gomp/if-2.c (foo): Likewise.  Expect slightly different\n\tdiagnostics wording in one case.\n\t* c-c++-common/gomp/if-3.c: New test.\n\t* c-c++-common/gomp/master-combined-1.c: New test.\n\t* c-c++-common/gomp/master-combined-2.c: New test.\n\t* c-c++-common/gomp/nontemporal-1.c: New test.\n\t* c-c++-common/gomp/nontemporal-2.c: New test.\n\t* c-c++-common/gomp/reduction-task-1.c: New test.\n\t* c-c++-common/gomp/reduction-task-2.c: New test.\n\t* c-c++-common/gomp/requires-1.c: New test.\n\t* c-c++-common/gomp/requires-2.c: New test.\n\t* c-c++-common/gomp/requires-3.c: New test.\n\t* c-c++-common/gomp/requires-4.c: New test.\n\t* c-c++-common/gomp/schedule-modifiers-1.c (bar): Don't expect\n\tdiagnostics for nonmonotonic modifier with static, runtime or auto\n\tschedule kinds.\n\t* c-c++-common/gomp/simd7.c: New test.\n\t* c-c++-common/gomp/target-data-1.c: New test.\n\t* c-c++-common/gomp/taskloop-reduction-1.c: New test.\n\t* c-c++-common/gomp/taskwait-depend-1.c: New test.\n\t* c-c++-common/gomp/teams-1.c: New test.\n\t* c-c++-common/gomp/teams-2.c: New test.\n\t* gcc.dg/gomp/appendix-a/a.24.1.c: Update from OpenMP examples.  Add\n\tshared(c) clause.\n\t* gcc.dg/gomp/atomic-5.c (f1): Add another expected error.\n\t* gcc.dg/gomp/clause-1.c: Adjust expected diagnostics for const\n\tqualified vars without mutable member no longer being predeterined\n\tshared.\n\t* gcc.dg/gomp/sharing-1.c: Likewise.\n\t* g++.dg/gomp/clause-3.C: Likewise.\n\t* g++.dg/gomp/member-2.C: Likewise.\n\t* g++.dg/gomp/predetermined-1.C: Likewise.\n\t* g++.dg/gomp/private-1.C: Likewise.\n\t* g++.dg/gomp/sharing-1.C: Likewise.\n\t* g++.dg/gomp/sharing-2.C: Likewise.  Add a few tests with aggregate\n\tconst static data member without mutable elements.\n\t* gcc.dg/gomp/for-4.c: Expected nonmonotonic functions in the dumps.\n\t* gcc.dg/gomp/for-5.c: Likewise.\n\t* gcc.dg/gomp/for-6.c: Change expected library call.\n\t* gcc.dg/gomp/pr39495-2.c (foo): Don't expect errors on !=.\n\t* gcc.dg/gomp/reduction-2.c: New test.\n\t* gcc.dg/gomp/simd-1.c: New test.\n\t* gcc.dg/gomp/teams-1.c: Adjust expected diagnostic lines.\n\t* g++.dg/gomp/atomic-18.C: New test.\n\t* g++.dg/gomp/atomic-19.C: New test.\n\t* g++.dg/gomp/atomic-5.C (f1): Adjust expected lines of read-only\n\tvariable messages.  Add another expected error.\n\t* g++.dg/gomp/critical-3.C: New test.\n\t* g++.dg/gomp/depend-iterator-1.C: New test.\n\t* g++.dg/gomp/depend-iterator-2.C: New test.\n\t* g++.dg/gomp/depobj-1.C: New test.\n\t* g++.dg/gomp/doacross-1.C: New test.\n\t* g++.dg/gomp/for-21.C: New test.\n\t* g++.dg/gomp/for-4.C: Expected nonmonotonic functions in the dumps.\n\t* g++.dg/gomp/for-5.C: Likewise.\n\t* g++.dg/gomp/for-6.C: Change expected library call.\n\t* g++.dg/gomp/loop-4.C: New test.\n\t* g++.dg/gomp/pr33372-1.C: Adjust location of the expected\n\tdiagnostics.\n\t* g++.dg/gomp/pr33372-3.C: Likewise.\n\t* g++.dg/gomp/pr39495-2.C (foo): Don't expect errors on !=.\n\t* g++.dg/gomp/simd-2.C: New test.\n\t* g++.dg/gomp/tpl-atomic-2.C: Adjust expected diagnostic lines.\ninclude/\n\t* gomp-constants.h (GOMP_TASK_FLAG_REDUCTION,\n\tGOMP_DEPEND_IN, GOMP_DEPEND_OUT, GOMP_DEPEND_INOUT,\n\tGOMP_DEPEND_MUTEXINOUTSET): Define.\nlibgomp/\n\t* affinity.c (gomp_display_affinity_place): New function.\n\t* affinity-fmt.c: New file.\n\t* alloc.c (gomp_aligned_alloc, gomp_aligned_free): New functions.\n\t* config/linux/affinity.c (gomp_display_affinity_place): New function.\n\t* config/nvptx/icv-device.c (omp_get_num_teams, omp_get_team_num):\n\tMove these functions to ...\n\t* config/nvptx/teams.c: ... here.  New file.\n\t* config/nvptx/target.c (omp_pause_resource, omp_pause_resource_all):\n\tNew functions.\n\t* config/nvptx/team.c (gomp_team_start, gomp_pause_host): New\n\tfunctions.\n\t* configure.ac: Check for aligned_alloc, posix_memalign, memalign\n\tand _aligned_malloc.\n\t(HAVE_UNAME, HAVE_GETHOSTNAME, HAVE_GETPID): Add new tests.\n\t* configure.tgt: Add -DUSING_INITIAL_EXEC_TLS to XCFLAGS for Linux.\n\t* env.c (gomp_display_affinity_var, gomp_affinity_format_var,\n\tgomp_affinity_format_len): New variables.\n\t(parse_schedule): Parse monotonic and nonmonotonic modifiers in\n\tOMP_SCHEDULE variable.  Set GFS_MONOTONIC for monotonic schedules.\n\t(handle_omp_display_env): Display monotonic/nonmonotonic schedule\n\tmodifiers.  Display (non-default) chunk sizes.  Print\n\tOMP_DISPLAY_AFFINITY and OMP_AFFINITY_FORMAT.\n\t(initialize_env): Don't call pthread_attr_setdetachstate.  Handle\n\tOMP_DISPLAY_AFFINITY and OMP_AFFINITY_FORMAT env vars.\n\t* fortran.c: Include stdio.h and string.h.\n\t(omp_pause_resource, omp_pause_resource_all): Add ialias_redirect.\n\t(omp_get_schedule_, omp_get_schedule_8_): Mask off GFS_MONOTONIC bit.\n\t(omp_set_affinity_format_, omp_get_affinity_format_,\n\tomp_display_affinity_, omp_capture_affinity_, omp_pause_resource_,\n\tomp_pause_resource_all_): New functions.\n\t* icv.c (omp_set_schedule): Mask off omp_sched_monotonic bit in\n\tswitch.\n\t* icv-device.c (omp_get_num_teams, omp_get_team_num): Move these\n\tfunctions to ...\n\t* teams.c: ... here.  New file.\n\t* libgomp_g.h: Include gstdint.h.\n\t(GOMP_loop_nonmonotonic_runtime_start,\n\tGOMP_loop_maybe_nonmonotonic_runtime_start, GOMP_loop_start,\n\tGOMP_loop_ordered_start, GOMP_loop_nonmonotonic_runtime_next,\n\tGOMP_loop_maybe_nonmonotonic_runtime_next, GOMP_loop_doacross_start,\n\tGOMP_parallel_loop_nonmonotonic_runtime,\n\tGOMP_parallel_loop_maybe_nonmonotonic_runtime,\n\tGOMP_loop_ull_nonmonotonic_runtime_start,\n\tGOMP_loop_ull_maybe_nonmonotonic_runtime_start, GOMP_loop_ull_start,\n\tGOMP_loop_ull_ordered_start, GOMP_loop_ull_nonmonotonic_runtime_next,\n\tGOMP_loop_ull_maybe_nonmonotonic_runtime_next,\n\tGOMP_loop_ull_doacross_start, GOMP_parallel_reductions,\n\tGOMP_taskwait_depend, GOMP_taskgroup_reduction_register,\n\tGOMP_taskgroup_reduction_unregister, GOMP_task_reduction_remap,\n\tGOMP_workshare_task_reduction_unregister, GOMP_sections2_start,\n\tGOMP_teams_reg): Declare.\n\t* libgomp.h (GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC): Define unless\n\tgomp_aligned_alloc uses fallback implementation.\n\t(gomp_aligned_alloc, gomp_aligned_free): Declare.\n\t(enum gomp_schedule_type): Add GFS_MONOTONIC.\n\t(struct gomp_doacross_work_share): Add extra field.\n\t(struct gomp_work_share): Add task_reductions field.\n\t(struct gomp_taskgroup): Add workshare and reductions fields.\n\t(GOMP_NEEDS_THREAD_HANDLE): Define if needed.\n\t(gomp_thread_handle): New typedef.\n\t(gomp_display_affinity_place, gomp_set_affinity_format,\n\tgomp_display_string, gomp_display_affinity,\n\tgomp_display_affinity_thread): Declare.\n\t(gomp_doacross_init, gomp_doacross_ull_init): Add size_t argument.\n\t(gomp_parallel_reduction_register, gomp_workshare_taskgroup_start,\n\tgomp_workshare_task_reduction_register): Declare.\n\t(gomp_team_start): Add taskgroup argument.\n\t(gomp_pause_host): Declare.\n\t(gomp_init_work_share, gomp_work_share_start): Change bool argument\n\tto size_t.\n\t(gomp_thread_self, gomp_thread_to_pthread_t): New inline functions.\n\t* libgomp.map (GOMP_5.0): Export GOMP_loop_start,\n\tGOMP_loop_ordered_start, GOMP_loop_doacross_start,\n\tGOMP_loop_ull_start, GOMP_loop_ull_ordered_start,\n\tGOMP_loop_ull_doacross_start,\n\tGOMP_workshare_task_reduction_unregister, GOMP_sections2_start,\n\tGOMP_loop_maybe_nonmonotonic_runtime_next,\n\tGOMP_loop_maybe_nonmonotonic_runtime_start,\n\tGOMP_loop_nonmonotonic_runtime_next,\n\tGOMP_loop_nonmonotonic_runtime_start,\n\tGOMP_loop_ull_maybe_nonmonotonic_runtime_next,\n\tGOMP_loop_ull_maybe_nonmonotonic_runtime_start,\n\tGOMP_loop_ull_nonmonotonic_runtime_next,\n\tGOMP_loop_ull_nonmonotonic_runtime_start,\n\tGOMP_parallel_loop_maybe_nonmonotonic_runtime,\n\tGOMP_parallel_loop_nonmonotonic_runtime, GOMP_parallel_reductions,\n\tGOMP_taskgroup_reduction_register,\n\tGOMP_taskgroup_reduction_unregister, GOMP_task_reduction_remap,\n\tGOMP_teams_reg and GOMP_taskwait_depend.\n\t(OMP_5.0): Export omp_pause_resource{,_all}{,_},\n\tomp_{capture,display}_affinity{,_}, and\n\tomp_[gs]et_affinity_format{,_}.\n\t* loop.c: Include string.h.\n\t(GOMP_loop_runtime_next): Add ialias.\n\t(GOMP_taskgroup_reduction_register): Add ialias_redirect.\n\t(gomp_loop_static_start, gomp_loop_dynamic_start,\n\tgomp_loop_guided_start, gomp_loop_ordered_static_start,\n\tgomp_loop_ordered_dynamic_start, gomp_loop_ordered_guided_start,\n\tgomp_loop_doacross_static_start, gomp_loop_doacross_dynamic_start,\n\tgomp_loop_doacross_guided_start): Adjust gomp_work_share_start\n\tor gomp_doacross_init callers.\n\t(gomp_adjust_sched, GOMP_loop_start, GOMP_loop_ordered_start,\n\tGOMP_loop_doacross_start): New functions.\n\t(GOMP_loop_runtime_start, GOMP_loop_ordered_runtime_start,\n\tGOMP_loop_doacross_runtime_start, GOMP_parallel_loop_runtime_start):\n\tMask off GFS_MONOTONIC bit.\n\t(GOMP_loop_maybe_nonmonotonic_runtime_next,\n\tGOMP_loop_maybe_nonmonotonic_runtime_start,\n\tGOMP_loop_nonmonotonic_runtime_next,\n\tGOMP_loop_nonmonotonic_runtime_start,\n\tGOMP_parallel_loop_maybe_nonmonotonic_runtime,\n\tGOMP_parallel_loop_nonmonotonic_runtime): New aliases or wrapper\n\tfunctions.\n\t(gomp_parallel_loop_start): Pass NULL as taskgroup to\n\tgomp_team_start.\n\t* loop_ull.c: Include string.h.\n\t(GOMP_loop_ull_runtime_next): Add ialias.\n\t(GOMP_taskgroup_reduction_register): Add ialias_redirect.\n\t(gomp_loop_ull_static_start, gomp_loop_ull_dynamic_start,\n\tgomp_loop_ull_guided_start, gomp_loop_ull_ordered_static_start,\n\tgomp_loop_ull_ordered_dynamic_start,\n\tgomp_loop_ull_ordered_guided_start,\n\tgomp_loop_ull_doacross_static_start,\n\tgomp_loop_ull_doacross_dynamic_start,\n\tgomp_loop_ull_doacross_guided_start): Adjust gomp_work_share_start\n\tand gomp_doacross_ull_init callers.\n\t(gomp_adjust_sched, GOMP_loop_ull_start, GOMP_loop_ull_ordered_start,\n\tGOMP_loop_ull_doacross_start): New functions.\n\t(GOMP_loop_ull_runtime_start,\n\tGOMP_loop_ull_ordered_runtime_start,\n\tGOMP_loop_ull_doacross_runtime_start): Mask off GFS_MONOTONIC bit.\n\t(GOMP_loop_ull_maybe_nonmonotonic_runtime_next,\n\tGOMP_loop_ull_maybe_nonmonotonic_runtime_start,\n\tGOMP_loop_ull_nonmonotonic_runtime_next,\n\tGOMP_loop_ull_nonmonotonic_runtime_start): Likewise.\n\t* Makefile.am (libgomp_la_SOURCES): Add teams.c and affinity-fmt.c.\n\t* omp.h.in (enum omp_sched_t): Add omp_sched_monotonic.\n\t(omp_pause_resource_t, omp_depend_t): New typedefs.\n\t(enum omp_lock_hint_t): Renamed to ...\n\t(enum omp_sync_hint_t): ... this.  Define omp_sync_hint_*\n\tenumerators using numbers and omp_lock_hint_* as their aliases.\n\t(omp_lock_hint_t): New typedef.  Rename to ...\n\t(omp_sync_hint_t): ... this.\n\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint): Use\n\tomp_sync_hint_t instead of omp_lock_hint_t.\n\t(omp_pause_resource, omp_pause_resource_all, omp_set_affinity_format,\n\tomp_get_affinity_format, omp_display_affinity, omp_capture_affinity):\n\tDeclare.\n\t(omp_target_is_present, omp_target_disassociate_ptr):\n\tChange first argument from void * to const void *.\n\t(omp_target_memcpy, omp_target_memcpy_rect): Change second argument\n\tfrom void * to const void *.\n\t(omp_target_associate_ptr): Change first and second arguments from\n\tvoid * to const void *.\n\t* omp_lib.f90.in (omp_pause_resource_kind, omp_pause_soft,\n\tomp_pause_hard): New parameters.\n\t(omp_pause_resource, omp_pause_resource_all, omp_set_affinity_format,\n\tomp_get_affinity_format, omp_display_affinity, omp_capture_affinity):\n\tNew interfaces.\n\t* omp_lib.h.in (omp_pause_resource_kind, omp_pause_soft,\n\tomp_pause_hard): New parameters.\n\t(omp_pause_resource, omp_pause_resource_all, omp_set_affinity_format,\n\tomp_get_affinity_format, omp_display_affinity, omp_capture_affinity):\n\tNew externals.\n\t* ordered.c (gomp_doacross_init, gomp_doacross_ull_init): Add\n\tEXTRA argument.  If not needed to prepare array, if extra is 0,\n\tclear ws->doacross, otherwise allocate just doacross structure and\n\textra payload.  If array is needed, allocate also extra payload.\n\t(GOMP_doacross_post, GOMP_doacross_wait, GOMP_doacross_ull_post,\n\tGOMP_doacross_ull_wait): Handle doacross->array == NULL like\n\tdoacross == NULL.\n\t* parallel.c (GOMP_parallel_start): Pass NULL as taskgroup to\n\tgomp_team_start.\n\t(GOMP_parallel): Likewise.  Formatting fix.\n\t(GOMP_parallel_reductions): New function.\n\t(GOMP_cancellation_point): If taskgroup has workshare\n\tflag set, check cancelled of prev taskgroup if any.\n\t(GOMP_cancel): If taskgroup has workshare flag set, set cancelled\n\ton prev taskgroup if any.\n\t* sections.c: Include string.h.\n\t(GOMP_taskgroup_reduction_register): Add ialias_redirect.\n\t(GOMP_sections_start): Adjust gomp_work_share_start caller.\n\t(GOMP_sections2_start): New function.\n\t(GOMP_parallel_sections_start, GOMP_parallel_sections):\n\tPass NULL as taskgroup to gomp_team_start.\n\t* single.c (GOMP_single_start, GOMP_single_copy_start): Adjust\n\tgomp_work_share_start callers.\n\t* target.c (GOMP_target_update_ext, GOMP_target_enter_exit_data):\n\tIf taskgroup has workshare flag set, check cancelled on prev\n\ttaskgroup if any.  Guard all cancellation tests with\n\tgomp_cancel_var test.\n\t(omp_target_is_present, omp_target_disassociate_ptr):\n\tChange ptr argument from void * to const void *.\n\t(omp_target_memcpy): Change src argument from void * to const void *.\n\t(omp_target_memcpy_rect): Likewise.\n\t(omp_target_memcpy_rect_worker): Likewise.  Use const char * casts\n\tinstead of char * where needed.\n\t(omp_target_associate_ptr): Change host_ptr and device_ptr arguments\n\tfrom void * to const void *.\n\t(omp_pause_resource, omp_pause_resource_all): New functions.\n\t* task.c (gomp_task_handle_depend): Handle new depend array format\n\tin addition to the old.  Handle mutexinoutset kinds the same as\n\tinout for now, handle unspecified kinds.\n\t(gomp_create_target_task): If taskgroup has workshare flag set, check\n\tcancelled on prev taskgroup if any.  Guard all cancellation tests with\n\tgomp_cancel_var test.  Handle new depend array format count in\n\taddition to the old.\n\t(GOMP_task): Likewise.  Adjust function comment.\n\t(gomp_task_run_pre): If taskgroup has workshare flag set, check\n\tcancelled on prev taskgroup if any.  Guard all cancellation tests with\n\tgomp_cancel_var test.\n\t(GOMP_taskwait_depend): New function.\n\t(gomp_task_maybe_wait_for_dependencies): Handle new depend array\n\tformat in addition to the old.  Handle mutexinoutset kinds the same as\n\tinout for now, handle unspecified kinds.  Fix a function comment typo.\n\t(gomp_taskgroup_init): New function.\n\t(GOMP_taskgroup_start): Use it.\n\t(gomp_reduction_register, gomp_create_artificial_team,\n\tGOMP_taskgroup_reduction_register,\n\tGOMP_taskgroup_reduction_unregister, GOMP_task_reduction_remap,\n\tgomp_parallel_reduction_register,\n\tgomp_workshare_task_reduction_register,\n\tgomp_workshare_taskgroup_start,\n\tGOMP_workshare_task_reduction_unregister): New functions.\n\t* taskloop.c (GOMP_taskloop): If taskgroup has workshare flag set,\n\tcheck cancelled on prev taskgroup if any.  Guard all cancellation\n\ttests with gomp_cancel_var test.  Handle GOMP_TASK_FLAG_REDUCTION flag\n\tby calling GOMP_taskgroup_reduction_register.\n\t* team.c (gomp_thread_attr): Remove comment.\n\t(struct gomp_thread_start_data): Add handle field.\n\t(gomp_thread_start): Call pthread_detach.\n\t(gomp_new_team): Adjust gomp_init_work_share caller.\n\t(gomp_free_pool_helper): Call pthread_detach.\n\t(gomp_team_start): Add taskgroup argument, initialize implicit\n\ttasks' taskgroup field to that.  Don't call\n\tpthread_attr_setdetachstate.  Handle OMP_DISPLAY_AFFINITY env var.\n\t(gomp_team_end): Determine nesting by thr->ts.level != 0\n\trather than thr->ts.team != NULL.\n\t(gomp_pause_pool_helper, gomp_pause_host): New functions.\n\t* work.c (alloc_work_share): Use gomp_aligned_alloc instead of\n\tgomp_malloc if GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC is defined.\n\t(gomp_init_work_share): Change ORDERED argument from bool to size_t,\n\tif more than 1 allocate also extra payload at the end of array.  Never\n\tkeep ordered_team_ids NULL, set it to inline_ordered_team_ids instead.\n\t(gomp_work_share_start): Change ORDERED argument from bool to size_t,\n\treturn true instead of ws.\n\t* Makefile.in: Regenerated.\n\t* configure: Regenerated.\n\t* config.h.in: Regenerated.\n\t* testsuite/libgomp.c/cancel-for-2.c (foo): Use cancel modifier\n\tin some cases.\n\t* testsuite/libgomp.c-c++-common/cancel-parallel-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/cancel-taskgroup-3.c: New test.\n\t* testsuite/libgomp.c-c++-common/depend-iterator-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/depend-iterator-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/depend-mutexinout-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/depend-mutexinout-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/depobj-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/display-affinity-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-10.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-11.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-12.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-13.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-14.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-15.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-2.h: If CONDNE macro is defined,\n\tdefine a different N(test), don't define N(f0) to N(f14), but instead\n\tdefine N(f20) to N(f34) using != comparisons.\n\t* testsuite/libgomp.c-c++-common/for-7.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-8.c: New test.\n\t* testsuite/libgomp.c-c++-common/for-9.c: New test.\n\t* testsuite/libgomp.c-c++-common/master-combined-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/pause-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/pause-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/pr66199-10.c: New test.\n\t* testsuite/libgomp.c-c++-common/pr66199-11.c: New test.\n\t* testsuite/libgomp.c-c++-common/pr66199-12.c: New test.\n\t* testsuite/libgomp.c-c++-common/pr66199-13.c: New test.\n\t* testsuite/libgomp.c-c++-common/pr66199-14.c: New test.\n\t* testsuite/libgomp.c-c++-common/simd-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/taskloop-reduction-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/taskloop-reduction-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/taskloop-reduction-3.c: New test.\n\t* testsuite/libgomp.c-c++-common/taskloop-reduction-4.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-11.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-12.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-3.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-4.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-5.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-6.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-7.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-8.c: New test.\n\t* testsuite/libgomp.c-c++-common/task-reduction-9.c: New test.\n\t* testsuite/libgomp.c-c++-common/taskwait-depend-1.c: New test.\n\t* testsuite/libgomp.c++/depend-1.C: New test.\n\t* testsuite/libgomp.c++/depend-iterator-1.C: New test.\n\t* testsuite/libgomp.c++/depobj-1.C: New test.\n\t* testsuite/libgomp.c++/for-16.C: New test.\n\t* testsuite/libgomp.c++/for-21.C: New test.\n\t* testsuite/libgomp.c++/for-22.C: New test.\n\t* testsuite/libgomp.c++/for-23.C: New test.\n\t* testsuite/libgomp.c++/for-24.C: New test.\n\t* testsuite/libgomp.c++/for-25.C: New test.\n\t* testsuite/libgomp.c++/for-26.C: New test.\n\t* testsuite/libgomp.c++/taskloop-reduction-1.C: New test.\n\t* testsuite/libgomp.c++/taskloop-reduction-2.C: New test.\n\t* testsuite/libgomp.c++/taskloop-reduction-3.C: New test.\n\t* testsuite/libgomp.c++/taskloop-reduction-4.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-10.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-11.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-12.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-13.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-14.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-15.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-16.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-17.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-18.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-19.C: New test.\n\t* testsuite/libgomp.c/task-reduction-1.c: New test.\n\t* testsuite/libgomp.c++/task-reduction-1.C: New test.\n\t* testsuite/libgomp.c/task-reduction-2.c: New test.\n\t* testsuite/libgomp.c++/task-reduction-2.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-3.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-4.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-5.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-6.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-7.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-8.C: New test.\n\t* testsuite/libgomp.c++/task-reduction-9.C: New test.\n\t* testsuite/libgomp.c/teams-1.c: New test.\n\t* testsuite/libgomp.c/teams-2.c: New test.\n\t* testsuite/libgomp.c/thread-limit-4.c: New test.\n\t* testsuite/libgomp.c/thread-limit-5.c: New test.\n\t* testsuite/libgomp.fortran/display-affinity-1.f90: New test.\n\nFrom-SVN: r265930", "tree": {"sha": "d35b0640fcabbdcf16b6254688aa76a6fbc4f4a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d35b0640fcabbdcf16b6254688aa76a6fbc4f4a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dfe2a550e8879f9af11e8e2c7c4eb10ea626a7e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe2a550e8879f9af11e8e2c7c4eb10ea626a7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe2a550e8879f9af11e8e2c7c4eb10ea626a7e6"}], "stats": {"total": 27932, "additions": 26490, "deletions": 1442}, "files": [{"sha": "d4619601362bafa2762bc7af2a2e7465c1ca2617", "filename": "gcc/ChangeLog", "status": "modified", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,307 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* builtin-types.def (BT_FN_VOID_BOOL, BT_FN_VOID_SIZE_SIZE_PTR,\n+\tBT_FN_UINT_UINT_PTR_PTR, BT_FN_UINT_OMPFN_PTR_UINT_UINT,\n+\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\tBT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\tBT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR): New.\n+\t* gengtype.c (open_base_files): Add omp-general.h.\n+\t* gimple.c (gimple_build_omp_critical):\n+\t(gimple_build_omp_taskgroup): Add CLAUSES argument.  Call\n+\tgimple_omp_taskgroup_set_clauses.\n+\t(gimple_build_omp_atomic_load): Add mo argument, call\n+\tgimple_omp_atomic_set_memory_order.\n+\t(gimple_build_omp_atomic_store): Likewise.\n+\t(gimple_copy): Adjust handling of GIMPLE_OMP_TASKGROUP.\n+\t* gimple.def (GIMPLE_OMP_TASKGROUP): Use GSS_OMP_SINGLE_LAYOUT\n+\tinstead of GSS_OMP.\n+\t(GIMPLE_OMP_TEAMS): Use GSS_OMP_PARALLEL_LAYOUT instead\n+\tof GSS_OMP_SINGLE_LAYOUT, adjust comments.\n+\t* gimple.h (enum gf_mask): Add GF_OMP_TEAMS_HOST, GF_OMP_TASK_TASKWAIT\n+\tand GF_OMP_ATOMIC_MEMORY_ORDER.  Remove GF_OMP_ATOMIC_SEQ_CST, use\n+\tdifferent value for GF_OMP_ATOMIC_NEED_VALUE.\n+\t(struct gimple_statement_omp_taskreg): Add GIMPLE_OMP_TEAMS to\n+\tcomments.\n+\t(struct gimple_statement_omp_single_layout): And remove here.\n+\t(struct gomp_teams): Inherit from gimple_statement_omp_taskreg rather\n+\tthan gimple_statement_omp_single_layout.\n+\t(is_a_helper <gimple_statement_omp_taskreg *>::test): Allow\n+\tGIMPLE_OMP_TEAMS.\n+\t(is_a_helper <const gimple_statement_omp_taskreg *>::test): Likewise.\n+\t(gimple_omp_subcode): Formatting fix.\n+\t(gimple_omp_teams_child_fn, gimple_omp_teams_child_fn_ptr,\n+\tgimple_omp_teams_set_child_fn, gimple_omp_teams_data_arg,\n+\tgimple_omp_teams_data_arg_ptr, gimple_omp_teams_set_data_arg,\n+\tgimple_omp_teams_host, gimple_omp_teams_set_host,\n+\tgimple_omp_task_taskwait_p, gimple_omp_task_set_taskwait_p,\n+\tgimple_omp_taskgroup_clauses, gimple_omp_taskgroup_clauses_ptr,\n+\tgimple_omp_taskgroup_set_clauses): New inline functions.\n+\t(gimple_build_omp_atomic_load): Add enum omp_memory_order argument.\n+\t(gimple_build_omp_atomic_store): Likewise.\n+\t(gimple_omp_atomic_seq_cst_p): Remove.\n+\t(gimple_omp_atomic_memory_order): New function.\n+\t(gimple_omp_atomic_set_seq_cst): Remove.\n+\t(gimple_omp_atomic_set_memory_order): New function.\n+\t(gimple_build_omp_taskgroup): Add clauses argument.\n+\t* gimple-pretty-print.c (dump_gimple_omp_taskgroup): New function.\n+\t(dump_gimple_omp_task): Print taskwait with depend clauses.\n+\t(dump_gimple_omp_atomic_load, dump_gimple_omp_atomic_store): Use\n+\tdump_omp_atomic_memory_order.\n+\t(pp_gimple_stmt_1): Handle GIMPLE_OMP_TASKGROUP.\n+\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP_ALLOC_ONLY,\n+\tGOVD_MAP_FROM_ONLY and GOVD_NONTEMPORAL.\n+\t(enum omp_region_type): Reserve bits 1 and 2 for auxiliary flags,\n+\trenumber values of most of ORT_* enumerators, add ORT_HOST_TEAMS,\n+\tORT_COMBINED_HOST_TEAMS, ORT_TASKGROUP, ORT_TASKLOOP and\n+\tORT_UNTIED_TASKLOOP enumerators.\n+\t(enum gimplify_defaultmap_kind): New.\n+\t(struct gimplify_omp_ctx): Remove target_map_scalars_firstprivate and\n+\ttarget_map_pointers_as_0len_arrays members, add defaultmap.\n+\t(new_omp_context): Initialize defaultmap member.\n+\t(gimple_add_tmp_var): Handle ORT_TASKGROUP like ORT_WORKSHARE.\n+\t(maybe_fold_stmt): Don't fold even in host teams regions.\n+\t(omp_firstprivatize_variable): Handle ORT_TASKGROUP like\n+\tORT_WORKSHARE.  Test ctx->defaultmap[GDMK_SCALAR] instead of\n+\tctx->omp_firstprivatize_variable.\n+\t(omp_add_variable): Don't add private/firstprivate for VLAs in\n+\tORT_TASKGROUP.\n+\t(omp_default_clause): Print \"taskloop\" rather than \"task\" if\n+\tORT_*TASKLOOP.\n+\t(omp_notice_variable): Handle ORT_TASKGROUP like ORT_WORKSHARE.\n+\tHandle new defaultmap clause kinds.\n+\t(omp_is_private): Handle ORT_TASKGROUP like ORT_WORKSHARE.  Allow simd\n+\titerator to be lastprivate or private.  Fix up diagnostics if linear\n+\tis used on collapse>1 simd iterator.\n+\t(omp_check_private): Handle ORT_TASKGROUP like ORT_WORKSHARE.\n+\t(gimplify_omp_depend): New function.\n+\t(gimplify_scan_omp_clauses): Add shared clause on parallel for\n+\tcombined parallel master taskloop{, simd} if taskloop has\n+\tfirstprivate, lastprivate or reduction clause.  Handle\n+\tOMP_CLAUSE_REDUCTION_TASK diagnostics.  Adjust tests for\n+\tORT_COMBINED_TEAMS.  Gimplify depend clauses with iterators.  Handle\n+\tcancel and simd OMP_CLAUSE_IF_MODIFIERs.  Handle\n+\tOMP_CLAUSE_NONTEMPORAL.  Handle new defaultmap clause kinds.  Handle\n+\tOMP_CLAUSE_{TASK,IN}_REDUCTION.  Diagnose invalid conditional\n+\tlastprivate.\n+\t(gimplify_adjust_omp_clauses_1): Ignore GOVD_NONTEMPORAL.  Handle\n+\tGOVD_MAP_ALLOC_ONLY and GOVD_MAP_FROM_ONLY.  \n+\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_NONTEMPORAL.  Handle\n+\tOMP_CLAUSE_{TASK,IN}_REDUCTION.\n+\t(gimplify_omp_task): Handle taskwait with depend clauses.\n+\t(gimplify_omp_for): Add shared clause on parallel for combined\n+\tparallel master taskloop{, simd} if taskloop has firstprivate,\n+\tlastprivate or reduction clause.  Use ORT_TASKLOOP or\n+\tORT_UNTIED_TASKLOOP instead of ORT_TASK or ORT_UNTIED_TASK.  Adjust\n+\ttests for ORT_COMBINED_TEAMS.  Handle C++ range for loops with\n+\tNULL TREE_PURPOSE in OMP_FOR_ORIG_DECLS.  Firstprivatize\n+\t__for_end and __for_range temporaries on OMP_PARALLEL for\n+\tdistribute parallel for{, simd}.  Move OMP_CLAUSE_REDUCTION\n+\tand OMP_CLAUSE_IN_REDUCTION from taskloop to the task construct\n+\tsandwiched in between two taskloops.\n+\t(computable_teams_clause): Test ctx->defaultmap[GDMK_SCALAR]\n+\tinstead of ctx->omp_firstprivatize_variable.\n+\t(gimplify_omp_workshare): Set ort to ORT_HOST_TEAMS or\n+\tORT_COMBINED_HOST_TEAMS if not inside of target construct.  If\n+\thost teams, use gimplify_and_return_first etc. for body like\n+\tfor target or target data constructs, and at the end call\n+\tgimple_omp_teams_set_host on the GIMPLE_OMP_TEAMS object.\n+\t(gimplify_omp_atomic): Use OMP_ATOMIC_MEMORY_ORDER instead\n+\tof OMP_ATOMIC_SEQ_CST, pass it as new argument to\n+\tgimple_build_omp_atomic_load and gimple_build_omp_atomic_store, remove\n+\tgimple_omp_atomic_set_seq_cst calls.\n+\t(gimplify_expr) <case OMP_TASKGROUP>: Move handling into a separate\n+\tcase, handle taskgroup clauses.\n+\t* lto-streamer-out.c (hash_tree): Handle\n+\tOMP_CLAUSE_{TASK,IN}_REDUCTION.\n+\t* Makefile.in (GTFILES): Add omp-general.h.\n+\t* omp-builtins.def (BUILT_IN_GOMP_TASKWAIT_DEPEND,\n+\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_MAYBE_NONMONOTONIC_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_START, BUILT_IN_GOMP_LOOP_ORDERED_START,\n+\tBUILT_IN_GOMP_LOOP_DOACROSS_START,\n+\tBUILT_IN_GOMP_LOOP_NONMONOTONIC_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_LOOP_MAYBE_NONMONOTONIC_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_MAYBE_NONMONOTONIC_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_START, BUILT_IN_GOMP_LOOP_ULL_ORDERED_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_DOACROSS_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_MAYBE_NONMONOTONIC_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_RUNTIME,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_MAYBE_NONMONOTONIC_RUNTIME,\n+\tBUILT_IN_GOMP_PARALLEL_REDUCTIONS, BUILT_IN_GOMP_SECTIONS2_START,\n+\tBUILT_IN_GOMP_TEAMS_REG, BUILT_IN_GOMP_TASKGROUP_REDUCTION_REGISTER,\n+\tBUILT_IN_GOMP_TASKGROUP_REDUCTION_UNREGISTER,\n+\tBUILT_IN_GOMP_TASK_REDUCTION_REMAP,\n+\tBUILT_IN_GOMP_WORKSHARE_TASK_REDUCTION_UNREGISTER): New builtins.\n+\t* omp-expand.c (workshare_safe_to_combine_p): Return false for\n+\tnon-worksharing loops.\n+\t(omp_adjust_chunk_size): Don't adjust anything if chunk_size is zero.\n+\t(determine_parallel_type): Don't combine parallel with worksharing\n+\twhich has _reductemp_ clause.\n+\t(expand_parallel_call): Emit the GOMP_*nonmonotonic_runtime* or\n+\tGOMP_*maybe_nonmonotonic_runtime* builtins instead of GOMP_*runtime*\n+\tif there is nonmonotonic modifier or if there is no modifier and no\n+\tordered clause.  For dynamic and guided schedule without monotonic\n+\tand nonmonotonic modifier, default to nonmonotonic.\n+\t(expand_omp_for): Likewise.  Adjust expand_omp_for_generic caller, use\n+\tGOMP_loop{,_ull}{,_ordered,_doacross}_start builtins if there are\n+\ttask reductions.\n+\t(expand_task_call): Add GOMP_TASK_FLAG_REDUCTION flag to flags if\n+\tthere are any reduction clauses.\n+\t(expand_taskwait_call): New function.\n+\t(expand_teams_call): New function.\n+\t(expand_omp_taskreg): Allow GIMPLE_OMP_TEAMS and call\n+\texpand_teams_call for it.  Formatting fix.  Handle taskwait with\n+\tdepend clauses.\n+\t(expand_omp_for_generic): Add SCHED_ARG argument.  Handle expansion\n+\tof worksharing loops with task reductions.\n+\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk): Handle\n+\texpansion of worksharing loops with task reductions.\n+\t(expand_omp_sections): Handle expansion of sections with task\n+\treductions.\n+\t(expand_omp_synch): For host teams call expand_omp_taskreg.\n+\t(omp_memory_order_to_memmodel): New function.\n+\t(expand_omp_atomic_load, expand_omp_atomic_store,\n+\texpand_omp_atomic_fetch_op): Use it and gimple_omp_atomic_memory_order\n+\tinstead of gimple_omp_atomic_seq_cst_p.\n+\t(build_omp_regions_1, omp_make_gimple_edges): Treat taskwait with\n+\tdepend clauses as a standalone directive.\n+\t* omp-general.c (enum omp_requires): New variable.\n+\t(omp_extract_for_data): Initialize have_reductemp member.  Allow\n+\tNE_EXPR even in OpenMP loops, transform them into LT_EXPR or\n+\tGT_EXPR loops depending on incr sign.  Formatting fixes.\n+\t* omp-general.h (struct omp_for_data): Add have_reductemp member.\n+\t(enum omp_requires): New enum.\n+\t(omp_requires_mask): Declare.\n+\t* omp-grid.c (grid_eliminate_combined_simd_part): Formatting fix.\n+\tFix comment typos.\n+\t* omp-low.c (struct omp_context): Add task_reductions and\n+\ttask_reduction_map fields.\n+\t(is_host_teams_ctx): New function.\n+\t(is_taskreg_ctx): Return true also if is_host_teams_ctx.\n+\t(use_pointer_for_field): Use is_global_var instead of\n+\tTREE_STATIC || DECL_EXTERNAL, and apply only if not privatized\n+\tin outer contexts.\n+\t(build_outer_var_ref): Ignore taskgroup outer contexts.\n+\t(delete_omp_context): Release task_reductions and task_reduction_map.\n+\t(scan_sharing_clauses): Don't add any fields for reduction clause on\n+\ttaskloop.  Handle OMP_CLAUSE__REDUCTEMP_.  Handle\n+\tOMP_CLAUSE_{IN,TASK}_REDUCTION and OMP_CLAUSE_REDUCTION with task\n+\tmodifier.  Don't ignore shared clauses in is_host_teams_ctx contexts.\n+\tHandle OMP_CLAUSE_NONTEMPORAL.\n+\t(add_taskreg_looptemp_clauses): Add OMP_CLAUSE__REDUCTEMP_ clause if\n+\tneeded.\n+\t(scan_omp_parallel): Add _reductemp_ clause if there are any reduction\n+\tclauses with task modifier.\n+\t(scan_omp_task): Handle taskwait with depend clauses.\n+\t(finish_taskreg_scan): Move field corresponding to _reductemp_ clause\n+\tfirst.  Move also OMP_CLAUSE__REDUCTEMP_ clause in front if present.\n+\tHandle GIMPLE_OMP_TEAMS like GIMPLE_OMP_PARALLEL.\n+\t(scan_omp_for): Fix comment formatting.\n+\t(scan_omp_teams): Handle host teams constructs.\n+\t(check_omp_nesting_restrictions): Allow teams with no outer\n+\tOpenMP context.  Adjust diagnostics for teams strictly nested into\n+\tsome explicit OpenMP construct other than target.  Allow OpenMP atomics\n+\tinside of simd regions.\n+\t(scan_omp_1_stmt): Call scan_sharing_clauses for taskgroups.\n+\t(scan_omp_1_stmt) <case GIMPLE_OMP_TEAMS>: Temporarily bump\n+\ttaskreg_nesting_level while scanning host teams construct.\n+\t(task_reduction_read): New function.\n+\t(lower_rec_input_clauses): Handle OMP_CLAUSE_REDUCTION on taskloop\n+\tconstruct.  Handle OMP_CLAUSE_IN_REDUCTION and OMP_CLAUSE__REDUCTEMP_\n+\tclauses.  Handle OMP_CLAUSE_REDUCTION with task modifier.  Remove\n+\tsecond argument create_tmp_var if it is NULL.  Don't ignore shared\n+\tclauses in is_host_teams_ctx contexts.  Handle\n+\tOMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE on OMP_CLAUSE_FIRSTPRIVATE\n+\tclauses.\n+\t(lower_reduction_clauses): Ignore reduction clauses with task\n+\tmodifier.  Remove second argument create_tmp_var if it is NULL.\n+\tInitialize OMP_ATOMIC_MEMORY_ORDER to relaxed.\n+\t(lower_send_clauses): Ignore reduction clauses with task modifier.\n+\tHandle OMP_CLAUSE__REDUCTEMP_.  Don't send anything for\n+\tOMP_CLAUSE_REDUCTION on taskloop.  Handle OMP_CLAUSE_IN_REDUCTION.\n+\t(maybe_add_implicit_barrier_cancel): Add OMP_RETURN argument, don't\n+\trely that it is the last stmt in body so far.  Ignore outer taskgroup\n+\tcontexts.\n+\t(omp_task_reductions_find_first, omp_task_reduction_iterate,\n+\tlower_omp_task_reductions): New functions.\n+\t(lower_omp_sections): Handle reduction clauses with taskgroup\n+\tmodifiers.  Adjust maybe_add_implicit_barrier_cancel caller.\n+\t(lower_omp_single): Adjust maybe_add_implicit_barrier_cancel caller.\n+\t(lower_omp_for): Likewise.  Handle reduction clauses with taskgroup\n+\tmodifiers.\n+\t(lower_omp_taskgroup): Handle taskgroup reductions.\n+\t(create_task_copyfn): Copy over OMP_CLAUSE__REDUCTEMP_ pointer.\n+\tHandle OMP_CLAUSE_IN_REDUCTION and OMP_CLAUSE_REDUCTION clauses.\n+\t(lower_depend_clauses): If there are any\n+\tOMP_CLAUSE_DEPEND_DEPOBJ or OMP_CLAUSE_DEPEND_MUTEXINOUTSET\n+\tdepend clauses, use a new array format.  If OMP_CLAUSE_DEPEND_LAST is\n+\tseen, assume lowering is done already and return early.  Set kind\n+\ton artificial depend clause to OMP_CLAUSE_DEPEND_LAST.\n+\t(lower_omp_taskreg): Handle reduction clauses with task modifier on\n+\tparallel construct.  Handle reduction clause on taskloop construct.\n+\tHandle taskwait with depend clauses.\n+\t(lower_omp_1): Use lower_omp_taskreg instead of lower_omp_teams\n+\tfor host teams constructs.\n+\t* tree.c (omp_clause_num_ops): Add in_reduction, task_reduction,\n+\tnontemporal and _reductemp_ clause entries.\n+\t(omp_clause_code_name): Likewise.\n+\t(walk_tree_1): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION,\n+\tOMP_CLAUSE_NONTEMPORAL and OMP_CLAUSE__REDUCTEMP_.\n+\t* tree-core.h (enum omp_clause_code): Add\n+\tOMP_CLAUSE_{{IN,TASK}_REDUCTION,NONTEMPORAL,_REDUCTEMP_}.\n+\t(enum omp_clause_defaultmap_kind, enum omp_memory_order): New.\n+\t(struct tree_base): Add omp_atomic_memory_order field into union.\n+\tRemove OMP_ATOMIC_SEQ_CST comment.\n+\t(enum omp_clause_depend_kind): Add OMP_CLAUSE_DEPEND_MUTEXINOUTSET\n+\tand OMP_CLAUSE_DEPEND_DEPOBJ.\n+\t(struct tree_omp_clause): Add subcode.defaultmap_kind.\n+\t* tree.def (OMP_TASKGROUP): Add another operand, move next to other\n+\tOpenMP constructs with body and clauses operands.\n+\t* tree.h (OMP_BODY): Use OMP_MASTER instead of OMP_TASKGROUP.\n+\t(OMP_CLAUSES): Use OMP_TASKGROUP instead of OMP_SINGLE.\n+\t(OMP_TASKGROUP_CLAUSES): Define.\n+\t(OMP_CLAUSE_DECL): Use OMP_CLAUSE__REDUCTEMP_ instead of\n+\tOMP_CLAUSE__LOOPTEMP_.\n+\t(OMP_ATOMIC_SEQ_CST): Remove.\n+\t(OMP_ATOMIC_MEMORY_ORDER, OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE,\n+\tOMP_CLAUSE_LASTPRIVATE_CONDITIONAL): Define.\n+\t(OMP_CLAUSE_REDUCTION_CODE, OMP_CLAUSE_REDUCTION_INIT,\n+\tOMP_CLAUSE_REDUCTION_MERGE, OMP_CLAUSE_REDUCTION_PLACEHOLDER,\n+\tOMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER,\n+\tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF): Handle\n+\tOMP_CLAUSE_{,IN_,TASK_}REDUCTION.\n+\t(OMP_CLAUSE_REDUCTION_TASK, OMP_CLAUSE_REDUCTION_INSCAN,\n+\tOMP_CLAUSE_DEFAULTMAP_KIND, OMP_CLAUSE_DEFAULTMAP_CATEGORY,\n+\tOMP_CLAUSE_DEFAULTMAP_BEHAVIOR, OMP_CLAUSE_DEFAULTMAP_SET_KIND):\n+\tDefine.\n+\t* tree-inline.c (remap_gimple_stmt): Remap taskgroup clauses.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses): Handle\n+\tOMP_CLAUSE__REDUCTEMP_, OMP_CLAUSE_NONTEMPORAL.\n+\t(convert_local_omp_clauses): Likewise.  Remove useless test.\n+\t* tree-parloops.c (create_call_for_reduction_1): Pass\n+\tOMP_MEMORY_ORDER_RELAXED as new argument to\n+\tdump_gimple_omp_atomic_load and dump_gimple_omp_atomic_store.\n+\t* tree-pretty-print.c (dump_omp_iterators): New function.\n+\t(dump_omp_clause): Handle OMP_CLAUSE__REDUCTEMP_,\n+\tOMP_CLAUSE_NONTEMPORAL, OMP_CLAUSE_{TASK,IN}_REDUCTION.  Print\n+\treduction modifiers.  Handle OMP_CLAUSE_DEPEND_DEPOBJ and\n+\tOMP_CLAUSE_DEPEND_MUTEXINOUTSET.  Print iterators in depend clauses.\n+\tPrint __internal__ for OMP_CLAUSE_DEPEND_LAST.  Handle cancel and\n+\tsimd OMP_CLAUSE_IF_MODIFIERs.  Handle new kinds of\n+\tOMP_CLAUSE_DEFAULTMAP. Print conditional: for\n+\tOMP_CLAUSE_LASTPRIVATE_CONDITIONAL.\n+\t(dump_omp_atomic_memory_order): New function.\n+\t(dump_generic_node): Use it.  Print taskgroup clauses.  Print\n+\ttaskwait with depend clauses.\n+\t* tree-pretty-print.h (dump_omp_atomic_memory_order): Declare.\n+\t* tree-streamer-in.c (unpack_ts_omp_clause_value_fields):\n+\tHandle OMP_CLAUSE_{TASK,IN}_REDUCTION.\n+\t* tree-streamer-out.c (pack_ts_omp_clause_value_fields,\n+\twrite_ts_omp_clause_tree_pointers): Likewise.\n+\n 2018-11-08  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR ipa/86395"}, {"sha": "16c9ed6c5fd741698e10c582de4d8c72a889036d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -2579,6 +2579,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/internal-fn.h \\\n   $(srcdir)/hsa-common.c \\\n   $(srcdir)/calls.c \\\n+  $(srcdir)/omp-general.h \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "685b22f975a1c39a7580c7683107692b92714121", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -251,6 +251,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_INT_CONST_STRING, BT_INT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VALIST_REF, BT_VOID, BT_VALIST_REF)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_BOOL, BT_VOID, BT_BOOL)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_CONST_STRING, BT_FLOAT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_CONST_STRING, BT_DOUBLE, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_CONST_STRING,\n@@ -621,6 +622,9 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_UINT32_UINT64_PTR,\n \t\t     BT_VOID, BT_UINT32, BT_UINT64, BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_UINT32_UINT32_PTR,\n \t\t     BT_VOID, BT_UINT32, BT_UINT32, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_SIZE_SIZE_PTR, BT_VOID, BT_SIZE, BT_SIZE,\n+\t\t     BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_PTR_PTR, BT_UINT, BT_UINT, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)\n@@ -644,6 +648,8 @@ DEF_FUNCTION_TYPE_4 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_FILEPTR, BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_UINT_OMPFN_PTR_UINT_UINT,\n+\t\t     BT_UINT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,\n \t\t     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n@@ -729,6 +735,12 @@ DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n+DEF_FUNCTION_TYPE_8 (BT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_8 (BT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_LONG, BT_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n@@ -737,6 +749,14 @@ DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR,\n \t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n \t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_9 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG, BT_PTR, BT_PTR)\n+\n+DEF_FUNCTION_TYPE_10 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t      BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n+\t\t      BT_ULONGLONG, BT_LONG, BT_ULONGLONG, BT_PTR_ULONGLONG,\n+\t\t      BT_PTR_ULONGLONG, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n \t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,"}, {"sha": "f1b9b27f8c003e1a70255893d671b46c4c2a224a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,41 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (c_finish_omp_taskgroup): Add CLAUSES argument.\n+\t(c_finish_omp_atomic): Replace bool SEQ_CST argument with\n+\tenum omp_memory_order MEMORY_ORDER.\n+\t(c_finish_omp_flush): Add MO argument.\n+\t(c_omp_depend_t_p, c_finish_omp_depobj): Declare.\n+\t(c_finish_omp_for): Add FINAL_P argument.\n+\t* c-omp.c: Include memmodel.h.\n+\t(c_finish_omp_taskgroup): Add CLAUSES argument.  Set\n+\tOMP_TASKGROUP_CLAUSES to it.\n+\t(c_finish_omp_atomic): Replace bool SEQ_CST argument with\n+\tenum omp_memory_order MEMORY_ORDER.  Set OMP_ATOMIC_MEMORY_ORDER\n+\tinstead of OMP_ATOMIC_SEQ_CST.\n+\t(c_omp_depend_t_p, c_finish_omp_depobj): New functions.\n+\t(c_finish_omp_flush): Add MO argument, if not MEMMODEL_LAST, emit\n+\t__atomic_thread_fence call with the given value.\n+\t(check_omp_for_incr_expr): Formatting fixes.\n+\t(c_finish_omp_for): Add FINAL_P argument.  Allow NE_EXPR\n+\teven in OpenMP loops, diagnose if NE_EXPR and incr expression\n+\tis not constant expression 1 or -1.  Transform NE_EXPR loops\n+\twith iterators pointers to VLA into LT_EXPR or GT_EXPR loops.\n+\t(c_omp_check_loop_iv_r): Look for orig decl of C++ range for\n+\tloops too.\n+\t(c_omp_split_clauses): Add support for combined\n+\t#pragma omp parallel master and\n+\t#pragma omp {,parallel }master taskloop{, simd} constructs.\n+\tHandle OMP_CLAUSE_IN_REDUCTION.  Handle OMP_CLAUSE_REDUCTION_TASK.\n+\tHandle OMP_CLAUSE_NONTEMPORAL.  Handle splitting OMP_CLAUSE_IF\n+\talso to OMP_SIMD.  Copy OMP_CLAUSE_LASTPRIVATE_CONDITIONAL.\n+\t(c_omp_predetermined_sharing): Don't return\n+\tOMP_CLAUSE_DEFAULT_SHARED for const qualified decls.\n+\t* c-pragma.c (omp_pragmas): Add PRAGMA_OMP_DEPOBJ and\n+\tPRAGMA_OMP_REQUIRES.\n+\t* c-pragma.h (enum pragma_kind): Likewise.\n+\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_NONTEMPORAL\n+\tand PRAGMA_OMP_CLAUSE_{IN,TASK}_REDUCTION.\n+\n 2018-11-08  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-format.c (gcc_dump_printf_char_table): Add entry for %f."}, {"sha": "a2184325a10f652896dad58ddff13cbb994aa665", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1149,18 +1149,21 @@ enum c_omp_region_type\n };\n \n extern tree c_finish_omp_master (location_t, tree);\n-extern tree c_finish_omp_taskgroup (location_t, tree);\n+extern tree c_finish_omp_taskgroup (location_t, tree, tree);\n extern tree c_finish_omp_critical (location_t, tree, tree, tree);\n extern tree c_finish_omp_ordered (location_t, tree, tree);\n extern void c_finish_omp_barrier (location_t);\n extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,\n-\t\t\t\t tree, tree, tree, tree, tree, bool, bool,\n-\t\t\t\t bool = false);\n-extern void c_finish_omp_flush (location_t);\n+\t\t\t\t tree, tree, tree, tree, tree, bool,\n+\t\t\t\t enum omp_memory_order, bool = false);\n+extern bool c_omp_depend_t_p (tree);\n+extern void c_finish_omp_depobj (location_t, tree, enum omp_clause_depend_kind,\n+\t\t\t\t tree);\n+extern void c_finish_omp_flush (location_t, int);\n extern void c_finish_omp_taskwait (location_t);\n extern void c_finish_omp_taskyield (location_t);\n extern tree c_finish_omp_for (location_t, enum tree_code, tree, tree, tree,\n-\t\t\t      tree, tree, tree, tree);\n+\t\t\t      tree, tree, tree, tree, bool);\n extern bool c_omp_check_loop_iv (tree, tree, walk_tree_lh);\n extern bool c_omp_check_loop_iv_exprs (location_t, tree, tree, tree, tree,\n \t\t\t\t       walk_tree_lh);"}, {"sha": "c7d44560da5081b6fc819f15fb724218bd3b6398", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 482, "deletions": 72, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -28,8 +28,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-common.h\"\n #include \"gimple-expr.h\"\n #include \"c-pragma.h\"\n+#include \"stringpool.h\"\n #include \"omp-general.h\"\n #include \"gomp-constants.h\"\n+#include \"memmodel.h\"\n \n \n /* Complete a #pragma oacc wait construct.  LOC is the location of\n@@ -70,7 +72,7 @@ c_finish_oacc_wait (location_t loc, tree parms, tree clauses)\n }\n \n /* Complete a #pragma omp master construct.  STMT is the structured-block\n-   that follows the pragma.  LOC is the l*/\n+   that follows the pragma.  LOC is the location of the #pragma.  */\n \n tree\n c_finish_omp_master (location_t loc, tree stmt)\n@@ -80,18 +82,21 @@ c_finish_omp_master (location_t loc, tree stmt)\n   return t;\n }\n \n-/* Complete a #pragma omp taskgroup construct.  STMT is the structured-block\n-   that follows the pragma.  LOC is the l*/\n+/* Complete a #pragma omp taskgroup construct.  BODY is the structured-block\n+   that follows the pragma.  LOC is the location of the #pragma.  */\n \n tree\n-c_finish_omp_taskgroup (location_t loc, tree stmt)\n+c_finish_omp_taskgroup (location_t loc, tree body, tree clauses)\n {\n-  tree t = add_stmt (build1 (OMP_TASKGROUP, void_type_node, stmt));\n-  SET_EXPR_LOCATION (t, loc);\n-  return t;\n+  tree stmt = make_node (OMP_TASKGROUP);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TASKGROUP_BODY (stmt) = body;\n+  OMP_TASKGROUP_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  return add_stmt (stmt);\n }\n \n-/* Complete a #pragma omp critical construct.  STMT is the structured-block\n+/* Complete a #pragma omp critical construct.  BODY is the structured-block\n    that follows the pragma, NAME is the identifier in the pragma, or null\n    if it was omitted.  LOC is the location of the #pragma.  */\n \n@@ -181,8 +186,8 @@ c_finish_omp_taskyield (location_t loc)\n tree\n c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t     enum tree_code opcode, tree lhs, tree rhs,\n-\t\t     tree v, tree lhs1, tree rhs1, bool swapped, bool seq_cst,\n-\t\t     bool test)\n+\t\t     tree v, tree lhs1, tree rhs1, bool swapped,\n+\t\t     enum omp_memory_order memory_order, bool test)\n {\n   tree x, type, addr, pre = NULL_TREE;\n   HOST_WIDE_INT bitpos = 0, bitsize = 0;\n@@ -264,7 +269,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     {\n       x = build1 (OMP_ATOMIC_READ, type, addr);\n       SET_EXPR_LOCATION (x, loc);\n-      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n+      OMP_ATOMIC_MEMORY_ORDER (x) = memory_order;\n       if (blhs)\n \tx = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), x,\n \t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n@@ -315,7 +320,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     type = void_type_node;\n   x = build2 (code, type, addr, rhs);\n   SET_EXPR_LOCATION (x, loc);\n-  OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n+  OMP_ATOMIC_MEMORY_ORDER (x) = memory_order;\n \n   /* Generally it is hard to prove lhs1 and lhs are the same memory\n      location, just diagnose different variables.  */\n@@ -413,17 +418,173 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n }\n \n \n+/* Return true if TYPE is the implementation's omp_depend_t.  */\n+\n+bool\n+c_omp_depend_t_p (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  return (TREE_CODE (type) == RECORD_TYPE\n+\t  && TYPE_NAME (type)\n+\t  && ((TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t       ? DECL_NAME (TYPE_NAME (type)) : TYPE_NAME (type))\n+\t      == get_identifier (\"omp_depend_t\"))\n+\t  && (!TYPE_CONTEXT (type)\n+\t      || TREE_CODE (TYPE_CONTEXT (type)) == TRANSLATION_UNIT_DECL)\n+\t  && COMPLETE_TYPE_P (type)\n+\t  && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t  && !compare_tree_int (TYPE_SIZE (type),\n+\t\t\t\t2 * tree_to_uhwi (TYPE_SIZE (ptr_type_node))));\n+}\n+\n+\n+/* Complete a #pragma omp depobj construct.  LOC is the location of the\n+   #pragma.  */\n+\n+void\n+c_finish_omp_depobj (location_t loc, tree depobj,\n+\t\t     enum omp_clause_depend_kind kind, tree clause)\n+{\n+  tree t = NULL_TREE;\n+  if (!error_operand_p (depobj))\n+    {\n+      if (!c_omp_depend_t_p (TREE_TYPE (depobj)))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (depobj, loc),\n+\t\t    \"type of %<depobj%> expression is not %<omp_depend_t%>\");\n+\t  depobj = error_mark_node;\n+\t}\n+      else if (TYPE_READONLY (TREE_TYPE (depobj)))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (depobj, loc),\n+\t\t    \"%<const%> qualified %<depobj%> expression\");\n+\t  depobj = error_mark_node;\n+\t}\n+    }\n+  else\n+    depobj = error_mark_node;\n+\n+  if (clause == error_mark_node)\n+    return;\n+\n+  if (clause)\n+    {\n+      gcc_assert (TREE_CODE (clause) == OMP_CLAUSE\n+\t\t  && OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_DEPEND);\n+      if (OMP_CLAUSE_CHAIN (clause))\n+\terror_at (OMP_CLAUSE_LOCATION (clause),\n+\t\t  \"more than one locator in %<depend%> clause on %<depobj%> \"\n+\t\t  \"construct\");\n+      switch (OMP_CLAUSE_DEPEND_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_DEPEND_DEPOBJ:\n+\t  error_at (OMP_CLAUSE_LOCATION (clause),\n+\t\t    \"%<depobj%> dependence type specified in %<depend%> \"\n+\t\t    \"clause on %<depobj%> construct\");\n+\t  return;\n+\tcase OMP_CLAUSE_DEPEND_SOURCE:\n+\tcase OMP_CLAUSE_DEPEND_SINK:\n+\t  error_at (OMP_CLAUSE_LOCATION (clause),\n+\t\t    \"%<depend(%s)%> is only allowed in %<omp ordered%>\",\n+\t\t    OMP_CLAUSE_DEPEND_KIND (clause) == OMP_CLAUSE_DEPEND_SOURCE\n+\t\t    ? \"source\" : \"sink\");\n+\t  return;\n+\tcase OMP_CLAUSE_DEPEND_IN:\n+\tcase OMP_CLAUSE_DEPEND_OUT:\n+\tcase OMP_CLAUSE_DEPEND_INOUT:\n+\tcase OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t  kind = OMP_CLAUSE_DEPEND_KIND (clause);\n+\t  t = OMP_CLAUSE_DECL (clause);\n+\t  gcc_assert (t);\n+\t  if (TREE_CODE (t) == TREE_LIST\n+\t      && TREE_PURPOSE (t)\n+\t      && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (clause),\n+\t\t\t\"%<iterator%> modifier may not be specified on \"\n+\t\t\t\"%<depobj%> construct\");\n+\t      return;\n+\t    }\n+\t  if (TREE_CODE (t) == COMPOUND_EXPR)\n+\t    {\n+\t      tree t1 = build_fold_addr_expr (TREE_OPERAND (t, 1));\n+\t      t = build2 (COMPOUND_EXPR, TREE_TYPE (t1), TREE_OPERAND (t, 0),\n+\t\t\t  t1);\n+\t    }\n+\t  else\n+\t    t = build_fold_addr_expr (t);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    gcc_assert (kind != OMP_CLAUSE_DEPEND_SOURCE);\n+\n+  if (depobj == error_mark_node)\n+    return;\n+\n+  depobj = build_fold_addr_expr_loc (EXPR_LOC_OR_LOC (depobj, loc), depobj);\n+  tree dtype\n+    = build_pointer_type_for_mode (ptr_type_node, TYPE_MODE (ptr_type_node),\n+\t\t\t\t   true);\n+  depobj = fold_convert (dtype, depobj);\n+  tree r;\n+  if (clause)\n+    {\n+      depobj = save_expr (depobj);\n+      r = build_indirect_ref (loc, depobj, RO_UNARY_STAR);\n+      add_stmt (build2 (MODIFY_EXPR, void_type_node, r, t));\n+    }\n+  int k;\n+  switch (kind)\n+    {\n+    case OMP_CLAUSE_DEPEND_IN:\n+      k = GOMP_DEPEND_IN;\n+      break;\n+    case OMP_CLAUSE_DEPEND_OUT:\n+      k = GOMP_DEPEND_OUT;\n+      break;\n+    case OMP_CLAUSE_DEPEND_INOUT:\n+      k = GOMP_DEPEND_INOUT;\n+      break;\n+    case OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+      k = GOMP_DEPEND_MUTEXINOUTSET;\n+      break;\n+    case OMP_CLAUSE_DEPEND_LAST:\n+      k = -1;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  t = build_int_cst (ptr_type_node, k);\n+  depobj = build2_loc (loc, POINTER_PLUS_EXPR, TREE_TYPE (depobj), depobj,\n+\t\t       TYPE_SIZE_UNIT (ptr_type_node));\n+  r = build_indirect_ref (loc, depobj, RO_UNARY_STAR);\n+  add_stmt (build2 (MODIFY_EXPR, void_type_node, r, t));\n+}\n+\n+\n /* Complete a #pragma omp flush construct.  We don't do anything with\n    the variable list that the syntax allows.  LOC is the location of\n    the #pragma.  */\n \n void\n-c_finish_omp_flush (location_t loc)\n+c_finish_omp_flush (location_t loc, int mo)\n {\n   tree x;\n \n-  x = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n-  x = build_call_expr_loc (loc, x, 0);\n+  if (mo == MEMMODEL_LAST)\n+    {\n+      x = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n+      x = build_call_expr_loc (loc, x, 0);\n+    }\n+  else\n+    {\n+      x = builtin_decl_explicit (BUILT_IN_ATOMIC_THREAD_FENCE);\n+      x = build_call_expr_loc (loc, x, 1,\n+\t\t\t       build_int_cst (integer_type_node, mo));\n+    }\n   add_stmt (x);\n }\n \n@@ -454,17 +615,17 @@ check_omp_for_incr_expr (location_t loc, tree exp, tree decl)\n       t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 0), decl);\n       if (t != error_mark_node)\n         return fold_build2_loc (loc, MINUS_EXPR,\n-\t\t\t    TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n+\t\t\t\tTREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n       break;\n     case PLUS_EXPR:\n       t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 0), decl);\n       if (t != error_mark_node)\n         return fold_build2_loc (loc, PLUS_EXPR,\n-\t\t\t    TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n+\t\t\t\tTREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n       t = check_omp_for_incr_expr (loc, TREE_OPERAND (exp, 1), decl);\n       if (t != error_mark_node)\n         return fold_build2_loc (loc, PLUS_EXPR,\n-\t\t\t    TREE_TYPE (exp), TREE_OPERAND (exp, 0), t);\n+\t\t\t\tTREE_TYPE (exp), TREE_OPERAND (exp, 0), t);\n       break;\n     case COMPOUND_EXPR:\n       {\n@@ -530,7 +691,7 @@ c_omp_for_incr_canonicalize_ptr (location_t loc, tree decl, tree incr)\n tree\n c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t  tree orig_declv, tree initv, tree condv, tree incrv,\n-\t\t  tree body, tree pre_body)\n+\t\t  tree body, tree pre_body, bool final_p)\n {\n   location_t elocus;\n   bool fail = false;\n@@ -667,7 +828,8 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t{\n \t\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))\n \t\t    {\n-\t\t      cond_ok = false;\n+\t\t      if (code == OACC_LOOP || TREE_CODE (cond) == EQ_EXPR)\n+\t\t\tcond_ok = false;\n \t\t    }\n \t\t  else if (operand_equal_p (TREE_OPERAND (cond, 1),\n \t\t\t\t\t    TYPE_MIN_VALUE (TREE_TYPE (decl)),\n@@ -679,7 +841,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t\t\t\t    0))\n \t\t    TREE_SET_CODE (cond, TREE_CODE (cond) == NE_EXPR\n \t\t\t\t\t ? LT_EXPR : GE_EXPR);\n-\t\t  else\n+\t\t  else if (code == OACC_LOOP || TREE_CODE (cond) == EQ_EXPR)\n \t\t    cond_ok = false;\n \t\t}\n \n@@ -730,6 +892,21 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\tbreak;\n \n \t      incr_ok = true;\n+\t      if (!fail\n+\t\t  && TREE_CODE (cond) == NE_EXPR\n+\t\t  && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n+\t\t  && TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl)))\n+\t\t  && (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl))))\n+\t\t      != INTEGER_CST))\n+\t\t{\n+\t\t  /* For pointer to VLA, transform != into < or >\n+\t\t     depending on whether incr is increment or decrement.  */\n+\t\t  if (TREE_CODE (incr) == PREINCREMENT_EXPR\n+\t\t      || TREE_CODE (incr) == POSTINCREMENT_EXPR)\n+\t\t    TREE_SET_CODE (cond, LT_EXPR);\n+\t\t  else\n+\t\t    TREE_SET_CODE (cond, GT_EXPR);\n+\t\t}\n \t      incr = c_omp_for_incr_canonicalize_ptr (elocus, decl, incr);\n \t      break;\n \n@@ -765,6 +942,58 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t      incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n \t\t    }\n \t\t}\n+\t      if (!fail\n+\t\t  && incr_ok\n+\t\t  && TREE_CODE (cond) == NE_EXPR)\n+\t\t{\n+\t\t  tree i = TREE_OPERAND (incr, 1);\n+\t\t  i = TREE_OPERAND (i, TREE_OPERAND (i, 0) == decl);\n+\t\t  i = c_fully_fold (i, false, NULL);\n+\t\t  if (!final_p\n+\t\t      && TREE_CODE (i) != INTEGER_CST)\n+\t\t    ;\n+\t\t  else if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+\t\t    {\n+\t\t      tree unit\n+\t\t\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl)));\n+\t\t      if (unit)\n+\t\t\t{\n+\t\t\t  enum tree_code ccode = GT_EXPR;\n+\t\t\t  unit = c_fully_fold (unit, false, NULL);\n+\t\t\t  i = fold_convert (TREE_TYPE (unit), i);\n+\t\t\t  if (operand_equal_p (unit, i, 0))\n+\t\t\t    ccode = LT_EXPR;\n+\t\t\t  if (ccode == GT_EXPR)\n+\t\t\t    {\n+\t\t\t      i = fold_unary (NEGATE_EXPR, TREE_TYPE (i), i);\n+\t\t\t      if (i == NULL_TREE\n+\t\t\t\t  || !operand_equal_p (unit, i, 0))\n+\t\t\t\t{\n+\t\t\t\t  error_at (elocus,\n+\t\t\t\t\t    \"increment is not constant 1 or \"\n+\t\t\t\t\t    \"-1 for != condition\");\n+\t\t\t\t  fail = true;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  if (TREE_CODE (unit) != INTEGER_CST)\n+\t\t\t    /* For pointer to VLA, transform != into < or >\n+\t\t\t       depending on whether the pointer is\n+\t\t\t       incremented or decremented in each\n+\t\t\t       iteration.  */\n+\t\t\t    TREE_SET_CODE (cond, ccode);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (!integer_onep (i) && !integer_minus_onep (i))\n+\t\t\t{\n+\t\t\t  error_at (elocus,\n+\t\t\t\t    \"increment is not constant 1 or -1 for\"\n+\t\t\t\t    \" != condition\");\n+\t\t\t  fail = true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t      break;\n \n \t    default:\n@@ -829,7 +1058,13 @@ c_omp_check_loop_iv_r (tree *tp, int *walk_subtrees, void *data)\n       for (i = 0; i < TREE_VEC_LENGTH (d->declv); i++)\n \tif (*tp == TREE_VEC_ELT (d->declv, i)\n \t    || (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n-\t\t&& *tp == TREE_PURPOSE (TREE_VEC_ELT (d->declv, i))))\n+\t\t&& *tp == TREE_PURPOSE (TREE_VEC_ELT (d->declv, i)))\n+\t    || (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n+\t\t&& TREE_CHAIN (TREE_VEC_ELT (d->declv, i))\n+\t\t&& (TREE_CODE (TREE_CHAIN (TREE_VEC_ELT (d->declv, i)))\n+\t\t    == TREE_VEC)\n+\t\t&& *tp == TREE_VEC_ELT (TREE_CHAIN (TREE_VEC_ELT (d->declv,\n+\t\t\t\t\t\t\t\t  i)), 2)))\n \t  {\n \t    location_t loc = d->expr_loc;\n \t    if (loc == UNKNOWN_LOCATION)\n@@ -1025,18 +1260,24 @@ c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses,\n }\n \n /* This function attempts to split or duplicate clauses for OpenMP\n-   combined/composite constructs.  Right now there are 21 different\n+   combined/composite constructs.  Right now there are 26 different\n    constructs.  CODE is the innermost construct in the combined construct,\n    and MASK allows to determine which constructs are combined together,\n    as every construct has at least one clause that no other construct\n-   has (except for OMP_SECTIONS, but that can be only combined with parallel).\n+   has (except for OMP_SECTIONS, but that can be only combined with parallel,\n+   and OMP_MASTER, which doesn't have any clauses at all).\n    OpenMP combined/composite constructs are:\n    #pragma omp distribute parallel for\n    #pragma omp distribute parallel for simd\n    #pragma omp distribute simd\n    #pragma omp for simd\n+   #pragma omp master taskloop\n+   #pragma omp master taskloop simd\n    #pragma omp parallel for\n    #pragma omp parallel for simd\n+   #pragma omp parallel master\n+   #pragma omp parallel master taskloop\n+   #pragma omp parallel master taskloop simd\n    #pragma omp parallel sections\n    #pragma omp target parallel\n    #pragma omp target parallel for\n@@ -1070,8 +1311,9 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n       {\n       case OMP_FOR:\n       case OMP_SIMD:\n-        cclauses[C_OMP_CLAUSE_SPLIT_FOR]\n-\t  = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n+\tif ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n+\t  cclauses[C_OMP_CLAUSE_SPLIT_FOR]\n+\t    = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n \tbreak;\n       case OMP_SECTIONS:\n \tcclauses[C_OMP_CLAUSE_SPLIT_SECTIONS]\n@@ -1118,6 +1360,7 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \tcase OMP_CLAUSE_SAFELEN:\n \tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_ALIGNED:\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n \t  break;\n \tcase OMP_CLAUSE_GRAINSIZE:\n@@ -1175,8 +1418,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n \t  break;\n-\t/* Private clause is supported on all constructs,\n-\t   it is enough to put it on the innermost one.  For\n+\t/* Private clause is supported on all constructs but master,\n+\t   it is enough to put it on the innermost one other than master.  For\n \t   #pragma omp {for,sections} put it on parallel though,\n \t   as that's what we did for OpenMP 3.1.  */\n \tcase OMP_CLAUSE_PRIVATE:\n@@ -1187,12 +1430,14 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    case OMP_PARALLEL: s = C_OMP_CLAUSE_SPLIT_PARALLEL; break;\n \t    case OMP_DISTRIBUTE: s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE; break;\n \t    case OMP_TEAMS: s = C_OMP_CLAUSE_SPLIT_TEAMS; break;\n+\t    case OMP_MASTER: s = C_OMP_CLAUSE_SPLIT_PARALLEL; break;\n+\t    case OMP_TASKLOOP: s = C_OMP_CLAUSE_SPLIT_TASKLOOP; break;\n \t    default: gcc_unreachable ();\n \t    }\n \t  break;\n \t/* Firstprivate clause is supported on all constructs but\n-\t   simd.  Put it on the outermost of those and duplicate on teams\n-\t   and parallel.  */\n+\t   simd and master.  Put it on the outermost of those and duplicate on\n+\t   teams and parallel.  */\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP))\n \t      != 0)\n@@ -1231,6 +1476,11 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t  else\n \t\t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n \t\t}\n+\t      else if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t\t<< PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n+\t\t/* This must be\n+\t\t   #pragma omp parallel master taskloop{, simd}.  */\n+\t\ts = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t      else\n \t\t/* This must be\n \t\t   #pragma omp parallel{, for{, simd}, sections}\n@@ -1260,8 +1510,10 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  else if ((mask & (OMP_CLAUSE_MASK_1\n \t\t\t    << PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n \t    {\n-\t      /* This must be #pragma omp taskloop simd.  */\n-\t      gcc_assert (code == OMP_SIMD);\n+\t      /* This must be #pragma omp {,{,parallel }master }taskloop simd\n+\t\t or\n+\t\t #pragma omp {,parallel }master taskloop.  */\n+\t      gcc_assert (code == OMP_SIMD || code == OMP_TASKLOOP);\n \t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t    }\n \t  else\n@@ -1271,9 +1523,9 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      s = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n \t  break;\n-\t/* Lastprivate is allowed on distribute, for, sections and simd.  In\n-\t   parallel {for{, simd},sections} we actually want to put it on\n-\t   parallel rather than for or sections.  */\n+\t/* Lastprivate is allowed on distribute, for, sections, taskloop and\n+\t   simd.  In parallel {for{, simd},sections} we actually want to put\n+\t   it on parallel rather than for or sections.  */\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  if (code == OMP_DISTRIBUTE)\n \t    {\n@@ -1287,6 +1539,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t\t\t    OMP_CLAUSE_LASTPRIVATE);\n \t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n \t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];\n+\t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n+\t\t= OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (clauses);\n \t      cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE] = c;\n \t    }\n \t  if (code == OMP_FOR || code == OMP_SECTIONS)\n@@ -1298,12 +1552,19 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n \t      break;\n \t    }\n+\t  if (code == OMP_TASKLOOP)\n+\t    {\n+\t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t      break;\n+\t    }\n \t  gcc_assert (code == OMP_SIMD);\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n \t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n \t\t\t\t    OMP_CLAUSE_LASTPRIVATE);\n \t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n+\t\t= OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (clauses);\n \t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n \t\t  != 0)\n \t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n@@ -1312,6 +1573,16 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      OMP_CLAUSE_CHAIN (c) = cclauses[s];\n \t      cclauses[s] = c;\n \t    }\n+\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_LASTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n+\t\t= OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP] = c;\n+\t    }\n \t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n \t  break;\n \t/* Shared and default clauses are allowed on parallel, teams and\n@@ -1321,6 +1592,19 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n \t      != 0)\n \t    {\n+\t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t\t  != 0)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_CODE (clauses));\n+\t\t  if (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_SHARED)\n+\t\t    OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t\t  else\n+\t\t    OMP_CLAUSE_DEFAULT_KIND (c)\n+\t\t      = OMP_CLAUSE_DEFAULT_KIND (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] = c;\n+\t\t}\n \t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t      break;\n \t    }\n@@ -1345,10 +1629,33 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    }\n \t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  break;\n-\t/* Reduction is allowed on simd, for, parallel, sections and teams.\n-\t   Duplicate it on all of them, but omit on for or sections if\n-\t   parallel is present.  */\n+\t/* Reduction is allowed on simd, for, parallel, sections, taskloop\n+\t   and teams.  Duplicate it on all of them, but omit on for or\n+\t   sections if parallel is present.  If taskloop is combined with\n+\t   parallel, omit it on parallel.  */\n \tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_TASK (clauses))\n+\t    {\n+\t      if (code == OMP_SIMD /* || code == OMP_LOOP */)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t    \"invalid %<task%> reduction modifier on construct \"\n+\t\t\t    \"combined with %<simd%>\" /* or %<loop%> */);\n+\t\t  OMP_CLAUSE_REDUCTION_TASK (clauses) = 0;\n+\t\t}\n+\t      else if (code != OMP_SECTIONS\n+\t\t       && (mask & (OMP_CLAUSE_MASK_1\n+\t\t\t\t   << PRAGMA_OMP_CLAUSE_SCHEDULE)) == 0\n+\t\t       && (mask & (OMP_CLAUSE_MASK_1\n+\t\t\t\t   << PRAGMA_OMP_CLAUSE_SCHEDULE)) == 0)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t    \"invalid %<task%> reduction modifier on construct \"\n+\t\t\t    \"not combined with %<parallel%>, %<for%> or \"\n+\t\t\t    \"%<sections%>\");\n+\t\t  OMP_CLAUSE_REDUCTION_TASK (clauses) = 0;\n+\t\t}\n+\t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE)) != 0)\n \t    {\n \t      if (code == OMP_SIMD)\n@@ -1377,56 +1684,164 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t\t    = OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n \t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c)\n \t\t    = OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clauses);\n-\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n-\t\t  cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] = c;\n-\t\t  s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_TEAMS] = c;\n+\t\t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t\t}\n \t      else if ((mask & (OMP_CLAUSE_MASK_1\n \t\t\t\t<< PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n \t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t      else\n \t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n \t    }\n-\t  else if (code == OMP_SECTIONS || code == OMP_PARALLEL)\n+\t  else if (code == OMP_SECTIONS\n+\t\t   || code == OMP_PARALLEL\n+\t\t   || code == OMP_MASTER)\n \t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t  else if (code == OMP_TASKLOOP)\n+\t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t  else if (code == OMP_SIMD)\n-\t    s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t    {\n+\t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n+\t\t  != 0)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_REDUCTION);\n+\t\t  OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_CODE (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_CODE (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP] = c;\n+\t\t}\n+\t      s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t    }\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_TEAMS;\n \t  break;\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\t  /* in_reduction on taskloop simd becomes reduction on the simd\n+\t     and keeps being in_reduction on taskloop.  */\n+\t  if (code == OMP_SIMD)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_REDUCTION);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_REDUCTION_CODE (c)\n+\t\t= OMP_CLAUSE_REDUCTION_CODE (clauses);\n+\t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n+\t\t= OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n+\t      OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c)\n+\t\t= OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t    }\n+\t  s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t  break;\n \tcase OMP_CLAUSE_IF:\n+\t  if (OMP_CLAUSE_IF_MODIFIER (clauses) != ERROR_MARK)\n+\t    {\n+\t      s = C_OMP_CLAUSE_SPLIT_COUNT;\n+\t      switch (OMP_CLAUSE_IF_MODIFIER (clauses))\n+\t\t{\n+\t\tcase OMP_PARALLEL:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n+\t\t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t\t  break;\n+\t\tcase OMP_SIMD:\n+\t\t  if (code == OMP_SIMD)\n+\t\t    s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t\t  break;\n+\t\tcase OMP_TASKLOOP:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n+\t\t      != 0)\n+\t\t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t\t  break;\n+\t\tcase OMP_TARGET:\n+\t\t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP))\n+\t\t      != 0)\n+\t\t    s = C_OMP_CLAUSE_SPLIT_TARGET;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t      if (s != C_OMP_CLAUSE_SPLIT_COUNT)\n+\t\tbreak;\n+\t      /* Error-recovery here, invalid if-modifier specified, add the\n+\t\t clause to just one construct.  */\n+\t      if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)) != 0)\n+\t\ts = C_OMP_CLAUSE_SPLIT_TARGET;\n+\t      else if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t\t<< PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n+\t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t      else if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t\t<< PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n+\t\ts = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t      else if (code == OMP_SIMD)\n+\t\ts = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      break;\n+\t    }\n+\t  /* Otherwise, duplicate if clause to all constructs.  */\n+\t  if (code == OMP_SIMD)\n+\t    {\n+\t      if ((mask & ((OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP)\n+\t\t\t   | (OMP_CLAUSE_MASK_1\n+\t\t\t      << PRAGMA_OMP_CLAUSE_NUM_THREADS)\n+\t\t\t   | (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)))\n+\t\t  != 0)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_IF);\n+\t\t  OMP_CLAUSE_IF_MODIFIER (c)\n+\t\t    = OMP_CLAUSE_IF_MODIFIER (clauses);\n+\t\t  OMP_CLAUSE_IF_EXPR (c) = OMP_CLAUSE_IF_EXPR (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP))\n \t      != 0)\n-\t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t    {\n+\t      if ((mask & (OMP_CLAUSE_MASK_1\n+\t\t\t   << PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_IF);\n+\t\t  OMP_CLAUSE_IF_MODIFIER (c)\n+\t\t    = OMP_CLAUSE_IF_MODIFIER (clauses);\n+\t\t  OMP_CLAUSE_IF_EXPR (c) = OMP_CLAUSE_IF_EXPR (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP] = c;\n+\t\t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t\t}\n+\t      else\n+\t\ts = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n+\t    }\n \t  else if ((mask & (OMP_CLAUSE_MASK_1\n \t\t\t    << PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n \t    {\n \t      if ((mask & (OMP_CLAUSE_MASK_1\n \t\t\t   << PRAGMA_OMP_CLAUSE_MAP)) != 0)\n \t\t{\n-\t\t  if (OMP_CLAUSE_IF_MODIFIER (clauses) == OMP_PARALLEL)\n-\t\t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n-\t\t  else if (OMP_CLAUSE_IF_MODIFIER (clauses) == OMP_TARGET)\n-\t\t    s = C_OMP_CLAUSE_SPLIT_TARGET;\n-\t\t  else if (OMP_CLAUSE_IF_MODIFIER (clauses) == ERROR_MARK)\n-\t\t    {\n-\t\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n-\t\t\t\t\t    OMP_CLAUSE_IF);\n-\t\t      OMP_CLAUSE_IF_MODIFIER (c)\n-\t\t\t= OMP_CLAUSE_IF_MODIFIER (clauses);\n-\t\t      OMP_CLAUSE_IF_EXPR (c) = OMP_CLAUSE_IF_EXPR (clauses);\n-\t\t      OMP_CLAUSE_CHAIN (c)\n-\t\t\t= cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n-\t\t      cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = c;\n-\t\t      s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      error_at (OMP_CLAUSE_LOCATION (clauses),\n-\t\t\t\t\"expected %<parallel%> or %<target%> %<if%> \"\n-\t\t\t\t\"clause modifier\");\n-\t\t      continue;\n-\t\t    }\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_IF);\n+\t\t  OMP_CLAUSE_IF_MODIFIER (c)\n+\t\t    = OMP_CLAUSE_IF_MODIFIER (clauses);\n+\t\t  OMP_CLAUSE_IF_EXPR (c) = OMP_CLAUSE_IF_EXPR (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = c;\n+\t\t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t\t}\n \t      else\n \t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n@@ -1610,11 +2025,6 @@ c_omp_declare_simd_clauses_to_decls (tree fndecl, tree clauses)\n enum omp_clause_default_kind\n c_omp_predetermined_sharing (tree decl)\n {\n-  /* Variables with const-qualified type having no mutable member\n-     are predetermined shared.  */\n-  if (TREE_READONLY (decl))\n-    return OMP_CLAUSE_DEFAULT_SHARED;\n-\n   /* Predetermine artificial variables holding integral values, those\n      are usually result of gimplify_one_sizepos or SAVE_EXPR\n      gimplification.  */"}, {"sha": "fe21120df2f456e4ea8ff78e924c28355335ba8e", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1286,9 +1286,11 @@ static const struct omp_pragma_def omp_pragmas[] = {\n   { \"cancel\", PRAGMA_OMP_CANCEL },\n   { \"cancellation\", PRAGMA_OMP_CANCELLATION_POINT },\n   { \"critical\", PRAGMA_OMP_CRITICAL },\n+  { \"depobj\", PRAGMA_OMP_DEPOBJ },\n   { \"end\", PRAGMA_OMP_END_DECLARE_TARGET },\n   { \"flush\", PRAGMA_OMP_FLUSH },\n   { \"master\", PRAGMA_OMP_MASTER },\n+  { \"requires\", PRAGMA_OMP_REQUIRES },\n   { \"section\", PRAGMA_OMP_SECTION },\n   { \"sections\", PRAGMA_OMP_SECTIONS },\n   { \"single\", PRAGMA_OMP_SINGLE },"}, {"sha": "b781f739f7f5d5c81a889fc0a88ff6d8ee25a15a", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -47,13 +47,15 @@ enum pragma_kind {\n   PRAGMA_OMP_CANCELLATION_POINT,\n   PRAGMA_OMP_CRITICAL,\n   PRAGMA_OMP_DECLARE,\n+  PRAGMA_OMP_DEPOBJ,\n   PRAGMA_OMP_DISTRIBUTE,\n   PRAGMA_OMP_END_DECLARE_TARGET,\n   PRAGMA_OMP_FLUSH,\n   PRAGMA_OMP_FOR,\n   PRAGMA_OMP_MASTER,\n   PRAGMA_OMP_ORDERED,\n   PRAGMA_OMP_PARALLEL,\n+  PRAGMA_OMP_REQUIRES,\n   PRAGMA_OMP_SECTION,\n   PRAGMA_OMP_SECTIONS,\n   PRAGMA_OMP_SIMD,\n@@ -75,8 +77,8 @@ enum pragma_kind {\n };\n \n \n-/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, 4.0 and 4.5.\n-   Used internally by both C and C++ parsers.  */\n+/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, 4.0, 4.5\n+   and 5.0.  Used internally by both C and C++ parsers.  */\n enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n@@ -96,6 +98,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_GRAINSIZE,\n   PRAGMA_OMP_CLAUSE_HINT,\n   PRAGMA_OMP_CLAUSE_IF,\n+  PRAGMA_OMP_CLAUSE_IN_REDUCTION,\n   PRAGMA_OMP_CLAUSE_INBRANCH,\n   PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR,\n   PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n@@ -104,6 +107,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_MAP,\n   PRAGMA_OMP_CLAUSE_MERGEABLE,\n   PRAGMA_OMP_CLAUSE_NOGROUP,\n+  PRAGMA_OMP_CLAUSE_NONTEMPORAL,\n   PRAGMA_OMP_CLAUSE_NOTINBRANCH,\n   PRAGMA_OMP_CLAUSE_NOWAIT,\n   PRAGMA_OMP_CLAUSE_NUM_TASKS,\n@@ -121,6 +125,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_SHARED,\n   PRAGMA_OMP_CLAUSE_SIMD,\n   PRAGMA_OMP_CLAUSE_SIMDLEN,\n+  PRAGMA_OMP_CLAUSE_TASK_REDUCTION,\n   PRAGMA_OMP_CLAUSE_TASKGROUP,\n   PRAGMA_OMP_CLAUSE_THREAD_LIMIT,\n   PRAGMA_OMP_CLAUSE_THREADS,"}, {"sha": "04f667ba15709d401867ebaaba5d0936356a42bd", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,90 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c: Include memmode.h.\n+\t(c_parser_omp_depobj, c_parser_omp_requires): New functions.\n+\t(c_parser_pragma): Handle PRAGMA_OMP_DEPOBJ and PRAGMA_OMP_REQUIRES.\n+\t(c_parser_omp_clause_name): Handle nontemporal, in_reduction and\n+\ttask_reduction clauses.\n+\t(c_parser_omp_variable_list): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION.\n+\tFor OMP_CLAUSE_DEPEND, parse clause operands as either an array\n+\tsection, or lvalue assignment expression.\n+\t(c_parser_omp_clause_if): Handle cancel and simd modifiers.\n+\t(c_parser_omp_clause_lastprivate): Parse optional\n+\tconditional: modifier.\n+\t(c_parser_omp_clause_hint): Require constant integer expression rather\n+\tthan just integer expression.\n+\t(c_parser_omp_clause_defaultmap): Parse new kinds of defaultmap\n+\tclause.\n+\t(c_parser_omp_clause_reduction): Add IS_OMP and KIND arguments.\n+\tParse reduction modifiers.  Pass KIND to c_parser_omp_variable_list.\n+\t(c_parser_omp_clause_nontemporal, c_parser_omp_iterators): New\n+\tfunctions.\n+\t(c_parser_omp_clause_depend): Parse iterator modifier and handle\n+\titerators.  Parse mutexinoutset and depobj kinds.\n+\t(c_parser_oacc_all_clauses): Adjust c_parser_omp_clause_reduction\n+\tcallers.\n+\t(c_parser_omp_all_clauses): Likewise.  Handle\n+\tPRAGMA_OMP_CLAUSE_NONTEMPORAL and\n+\tPRAGMA_OMP_CLAUSE_{IN,TASK}_REDUCTION.\n+\t(c_parser_omp_atomic): Parse hint and memory order clauses.  Handle\n+\tdefault memory order from requires directive if any.  Adjust\n+\tc_finish_omp_atomic caller.\n+\t(c_parser_omp_critical): Allow comma in between (name) and hint clause.\n+\t(c_parser_omp_flush): Parse flush with memory-order-clause.\n+\t(c_parser_omp_for_loop): Allow NE_EXPR even in\n+\tOpenMP loops, adjust c_finish_omp_for caller.\n+\t(OMP_SIMD_CLAUSE_MASK): Add if and nontemporal clauses.\n+\t(c_parser_omp_master): Add p_name, mask and cclauses arguments.\n+\tAllow to be called while parsing combined parallel master.\n+\tParse combined master taskloop{, simd}.\n+\t(c_parser_omp_parallel): Parse combined\n+\tparallel master{, taskloop{, simd}} constructs.\n+\t(OMP_TASK_CLAUSE_MASK): Add in_reduction clause.\n+\t(OMP_TASKGROUP_CLAUSE_MASK): Define.\n+\t(c_parser_omp_taskgroup): Add LOC argument.  Parse taskgroup clauses.\n+\t(OMP_TASKWAIT_CLAUSE_MASK): Define.\n+\t(c_parser_omp_taskwait): Handle taskwait with depend clauses.\n+\t(c_parser_omp_teams): Force a BIND_EXPR with BLOCK\n+\taround teams body.  Use SET_EXPR_LOCATION.\n+\t(c_parser_omp_target_data): Allow target data\n+\twith only use_device_ptr clauses.\n+\t(c_parser_omp_target): Use SET_EXPR_LOCATION.  Set\n+\tOMP_REQUIRES_TARGET_USED bit in omp_requires_mask.\n+\t(c_parser_omp_requires): New function.\n+\t(c_finish_taskloop_clauses): New function.\n+\t(OMP_TASKLOOP_CLAUSE_MASK): Add reduction and in_reduction clauses.\n+\t(c_parser_omp_taskloop): Use c_finish_taskloop_clauses.  Add forward\n+\tdeclaration.  Disallow in_reduction clause when combined with parallel\n+\tmaster.\n+\t(c_parser_omp_construct): Adjust c_parser_omp_master and\n+\tc_parser_omp_taskgroup callers.\n+\t* c-typeck.c (c_finish_omp_cancel): Diagnose if clause with modifier\n+\tother than cancel.\n+\t(handle_omp_array_sections_1): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION\n+\tlike OMP_CLAUSE_REDUCTION.\n+\t(handle_omp_array_sections): Likewise.  Call save_expr on array\n+\treductions before calling build_index_type.  Handle depend clauses\n+\twith iterators.\n+\t(struct c_find_omp_var_s): New type.\n+\t(c_find_omp_var_r, c_omp_finish_iterators): New functions.\n+\t(c_finish_omp_clauses): Don't diagnose nonmonotonic clause\n+\twith static, runtime or auto schedule kinds.  Call save_expr for whole\n+\tarray reduction sizes.  Diagnose reductions with zero sized elements\n+\tor variable length structures.  Diagnose nogroup clause used with\n+\treduction clause(s).  Handle depend clause with\n+\tOMP_CLAUSE_DEPEND_DEPOBJ.  Diagnose bit-fields.  Require\n+\tomp_depend_t type for OMP_CLAUSE_DEPEND_DEPOBJ kinds and\n+\tsome different type for other kinds.  Use build_unary_op with\n+\tADDR_EXPR and build_indirect_ref instead of c_mark_addressable.\n+\tHandle depend clauses with iterators.  Remove no longer needed special\n+\tcase that predetermined const qualified vars may be specified in\n+\tfirstprivate clause.  Complain if const qualified vars are mentioned\n+\tin data-sharing clauses other than firstprivate or shared.  Use\n+\terror_at with OMP_CLAUSE_LOCATION (c) as first argument instead of\n+\terror.  Formatting fix.  Handle OMP_CLAUSE_NONTEMPORAL and\n+\tOMP_CLAUSE_{IN,TASK}_REDUCTION.  Allow any lvalue as\n+\tOMP_CLAUSE_DEPEND operand (besides array section), adjust diagnostics.\n+\n 2018-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-decl.c (implicit_decl_warning): Update \"is there a suggestion\""}, {"sha": "624d5a34c63bb8931bc1707cefaec6f127637eb7", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1142, "deletions": 116, "changes": 1258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"c-family/name-hint.h\"\n #include \"tree-iterator.h\"\n+#include \"memmodel.h\"\n \n /* We need to walk over decls with incomplete struct/union/enum types\n    after parsing the whole translation unit.\n@@ -1450,6 +1451,7 @@ static void c_parser_oacc_update (c_parser *);\n static void c_parser_omp_construct (c_parser *, bool *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n+static void c_parser_omp_depobj (c_parser *);\n static void c_parser_omp_flush (c_parser *);\n static tree c_parser_omp_for_loop (location_t, c_parser *, enum tree_code,\n \t\t\t\t   tree, tree *, bool *);\n@@ -1464,6 +1466,7 @@ static void c_parser_omp_cancellation_point (c_parser *, enum pragma_context);\n static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);\n static void c_parser_omp_end_declare_target (c_parser *);\n static void c_parser_omp_declare (c_parser *, enum pragma_context);\n+static void c_parser_omp_requires (c_parser *);\n static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);\n static void c_parser_oacc_routine (c_parser *, enum pragma_context);\n \n@@ -11168,6 +11171,15 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       c_parser_omp_barrier (parser);\n       return false;\n \n+    case PRAGMA_OMP_DEPOBJ:\n+      if (context != pragma_compound)\n+\t{\n+\t  construct = \"omp depobj\";\n+\t  goto in_compound;\n+\t}\n+      c_parser_omp_depobj (parser);\n+      return false;\n+\n     case PRAGMA_OMP_FLUSH:\n       if (context != pragma_compound)\n \t{\n@@ -11230,6 +11242,10 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       c_parser_omp_declare (parser, context);\n       return false;\n \n+    case PRAGMA_OMP_REQUIRES:\n+      c_parser_omp_requires (parser);\n+      return false;\n+\n     case PRAGMA_OMP_ORDERED:\n       return c_parser_omp_ordered (parser, context, if_p);\n \n@@ -11452,6 +11468,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \tcase 'i':\n \t  if (!strcmp (\"if_present\", p))\n \t    result = PRAGMA_OACC_CLAUSE_IF_PRESENT;\n+\t  else if (!strcmp (\"in_reduction\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_IN_REDUCTION;\n \t  else if (!strcmp (\"inbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_INBRANCH;\n \t  else if (!strcmp (\"independent\", p))\n@@ -11476,6 +11494,8 @@ c_parser_omp_clause_name (c_parser *parser)\n \tcase 'n':\n \t  if (!strcmp (\"nogroup\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOGROUP;\n+\t  else if (!strcmp (\"nontemporal\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NONTEMPORAL;\n \t  else if (!strcmp (\"notinbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n@@ -11544,7 +11564,9 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_SIMDLEN;\n \t  break;\n \tcase 't':\n-\t  if (!strcmp (\"taskgroup\", p))\n+\t  if (!strcmp (\"task_reduction\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_TASK_REDUCTION;\n+\t  else if (!strcmp (\"taskgroup\", p))\n \t    result = PRAGMA_OMP_CLAUSE_TASKGROUP;\n \t  else if (!strcmp (\"thread_limit\", p))\n \t    result = PRAGMA_OMP_CLAUSE_THREAD_LIMIT;\n@@ -11671,13 +11693,87 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t\t    location_t clause_loc,\n \t\t\t    enum omp_clause_code kind, tree list)\n {\n-  if (c_parser_next_token_is_not (parser, CPP_NAME)\n-      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+  auto_vec<c_token> tokens;\n+  unsigned int tokens_avail = 0;\n+\n+  if (kind != OMP_CLAUSE_DEPEND\n+      && (c_parser_next_token_is_not (parser, CPP_NAME)\n+\t  || c_parser_peek_token (parser)->id_kind != C_ID_ID))\n     c_parser_error (parser, \"expected identifier\");\n \n-  while (c_parser_next_token_is (parser, CPP_NAME)\n-\t && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n+  while (kind == OMP_CLAUSE_DEPEND\n+\t || (c_parser_next_token_is (parser, CPP_NAME)\n+\t     && c_parser_peek_token (parser)->id_kind == C_ID_ID))\n     {\n+      bool array_section_p = false;\n+      if (kind == OMP_CLAUSE_DEPEND)\n+\t{\n+\t  if (c_parser_next_token_is_not (parser, CPP_NAME)\n+\t      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+\t    {\n+\t      struct c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t      if (expr.value != error_mark_node)\n+\t\t{\n+\t\t  tree u = build_omp_clause (clause_loc, kind);\n+\t\t  OMP_CLAUSE_DECL (u) = expr.value;\n+\t\t  OMP_CLAUSE_CHAIN (u) = list;\n+\t\t  list = u;\n+\t\t}\n+\n+\t      if (c_parser_next_token_is_not (parser, CPP_COMMA))\n+\t\tbreak;\n+\n+\t      c_parser_consume_token (parser);\n+\t      continue;\n+\t    }\n+\n+\t  tokens.truncate (0);\n+\t  unsigned int nesting_depth = 0;\n+\t  while (1)\n+\t    {\n+\t      c_token *token = c_parser_peek_token (parser);\n+\t      switch (token->type)\n+\t\t{\n+\t\tcase CPP_EOF:\n+\t\tcase CPP_PRAGMA_EOL:\n+\t\t  break;\n+\t\tcase CPP_OPEN_BRACE:\n+\t\tcase CPP_OPEN_PAREN:\n+\t\tcase CPP_OPEN_SQUARE:\n+\t\t  ++nesting_depth;\n+\t\t  goto add;\n+\t\tcase CPP_CLOSE_BRACE:\n+\t\tcase CPP_CLOSE_PAREN:\n+\t\tcase CPP_CLOSE_SQUARE:\n+\t\t  if (nesting_depth-- == 0)\n+\t\t    break;\n+\t\t  goto add;\n+\t\tcase CPP_COMMA:\n+\t\t  if (nesting_depth == 0)\n+\t\t    break;\n+\t\t  goto add;\n+\t\tdefault:\n+\t\tadd:\n+\t\t  tokens.safe_push (*token);\n+\t\t  c_parser_consume_token (parser);\n+\t\t  continue;\n+\t\t}\n+\t      break;\n+\t    }\n+\n+\t  /* Make sure nothing tries to read past the end of the tokens.  */\n+\t  c_token eof_token;\n+\t  memset (&eof_token, 0, sizeof (eof_token));\n+\t  eof_token.type = CPP_EOF;\n+\t  tokens.safe_push (eof_token);\n+\t  tokens.safe_push (eof_token);\n+\n+\t  tokens_avail = parser->tokens_avail;\n+\t  gcc_assert (parser->tokens == &parser->tokens_buf[0]);\n+\t  parser->tokens = tokens.address ();\n+\t  parser->tokens_avail = tokens.length ();\n+\t}\n+\n       tree t = lookup_name (c_parser_peek_token (parser)->value);\n \n       if (t == NULL_TREE)\n@@ -11728,6 +11824,8 @@ c_parser_omp_variable_list (c_parser *parser,\n \t      /* FALLTHROUGH  */\n \t    case OMP_CLAUSE_DEPEND:\n \t    case OMP_CLAUSE_REDUCTION:\n+\t    case OMP_CLAUSE_IN_REDUCTION:\n+\t    case OMP_CLAUSE_TASK_REDUCTION:\n \t      while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n \t\t{\n \t\t  tree low_bound = NULL_TREE, length = NULL_TREE;\n@@ -11753,6 +11851,7 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t\t  t = error_mark_node;\n \t\t\t  break;\n \t\t\t}\n+\t\t      array_section_p = true;\n \t\t      if (!c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t\t\t{\n \t\t\t  location_t expr_loc\n@@ -11773,6 +11872,30 @@ c_parser_omp_variable_list (c_parser *parser,\n \n \t\t  t = tree_cons (low_bound, length, t);\n \t\t}\n+\t      if (kind == OMP_CLAUSE_DEPEND\n+\t\t  && t != error_mark_node\n+\t\t  && parser->tokens_avail != 2)\n+\t\t{\n+\t\t  if (array_section_p)\n+\t\t    {\n+\t\t      error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\t\"expected %<)%> or %<,%>\");\n+\t\t      t = error_mark_node;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      parser->tokens = tokens.address ();\n+\t\t      parser->tokens_avail = tokens.length ();\n+\n+\t\t      t = c_parser_expr_no_commas (parser, NULL).value;\n+\t\t      if (t != error_mark_node && parser->tokens_avail != 2)\n+\t\t\t{\n+\t\t\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\t    \"expected %<)%> or %<,%>\");\n+\t\t\t  t = error_mark_node;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t      break;\n \t    default:\n \t      break;\n@@ -11789,6 +11912,11 @@ c_parser_omp_variable_list (c_parser *parser,\n       else\n \tlist = tree_cons (t, NULL_TREE, list);\n \n+      if (kind == OMP_CLAUSE_DEPEND)\n+\t{\n+\t  parser->tokens = &parser->tokens_buf[0];\n+\t  parser->tokens_avail = tokens_avail;\n+\t}\n       if (c_parser_next_token_is_not (parser, CPP_COMMA))\n \tbreak;\n \n@@ -12080,7 +12208,11 @@ c_parser_omp_clause_final (c_parser *parser, tree list)\n \n    directive-name-modifier:\n      parallel | task | taskloop | target data | target | target update\n-     | target enter data | target exit data  */\n+     | target enter data | target exit data\n+\n+   OpenMP 5.0:\n+   directive-name-modifier:\n+     ... | simd | cancel  */\n \n static tree\n c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n@@ -12096,8 +12228,12 @@ c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       int n = 2;\n-      if (strcmp (p, \"parallel\") == 0)\n+      if (strcmp (p, \"cancel\") == 0)\n+\tif_modifier = VOID_CST;\n+      else if (strcmp (p, \"parallel\") == 0)\n \tif_modifier = OMP_PARALLEL;\n+      else if (strcmp (p, \"simd\") == 0)\n+\tif_modifier = OMP_SIMD;\n       else if (strcmp (p, \"task\") == 0)\n \tif_modifier = OMP_TASK;\n       else if (strcmp (p, \"taskloop\") == 0)\n@@ -12181,7 +12317,9 @@ c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n \t    const char *p = NULL;\n \t    switch (if_modifier)\n \t      {\n+\t      case VOID_CST: p = \"cancel\"; break;\n \t      case OMP_PARALLEL: p = \"parallel\"; break;\n+\t      case OMP_SIMD: p = \"simd\"; break;\n \t      case OMP_TASK: p = \"task\"; break;\n \t      case OMP_TASKLOOP: p = \"taskloop\"; break;\n \t      case OMP_TARGET_DATA: p = \"target data\"; break;\n@@ -12220,12 +12358,41 @@ c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n }\n \n /* OpenMP 2.5:\n-   lastprivate ( variable-list ) */\n+   lastprivate ( variable-list )\n+\n+   OpenMP 5.0:\n+   lastprivate ( [ lastprivate-modifier : ] variable-list ) */\n \n static tree\n c_parser_omp_clause_lastprivate (c_parser *parser, tree list)\n {\n-  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_LASTPRIVATE, list);\n+  /* The clauses location.  */\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      bool conditional = false;\n+      if (c_parser_next_token_is (parser, CPP_NAME)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+\t{\n+\t  const char *p\n+\t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\t  if (strcmp (p, \"conditional\") == 0)\n+\t    {\n+\t      conditional = true;\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\t    }\n+\t}\n+      tree nlist = c_parser_omp_variable_list (parser, loc,\n+\t\t\t\t\t       OMP_CLAUSE_LASTPRIVATE, list);\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      if (conditional)\n+\tfor (tree c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+\t  OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 1;\n+      return nlist;\n+    }\n+  return list;\n }\n \n /* OpenMP 3.1:\n@@ -12465,9 +12632,10 @@ c_parser_omp_clause_hint (c_parser *parser, tree list)\n \n       parens.skip_until_found_close (parser);\n \n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t  || TREE_CODE (t) != INTEGER_CST)\n \t{\n-\t  c_parser_error (parser, \"expected integer expression\");\n+\t  c_parser_error (parser, \"expected constant integer expression\");\n \t  return list;\n \t}\n \n@@ -12483,47 +12651,166 @@ c_parser_omp_clause_hint (c_parser *parser, tree list)\n }\n \n /* OpenMP 4.5:\n-   defaultmap ( tofrom : scalar ) */\n+   defaultmap ( tofrom : scalar )\n+\n+   OpenMP 5.0:\n+   defaultmap ( implicit-behavior [ : variable-category ] ) */\n \n static tree\n c_parser_omp_clause_defaultmap (c_parser *parser, tree list)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   tree c;\n   const char *p;\n+  enum omp_clause_defaultmap_kind behavior = OMP_CLAUSE_DEFAULTMAP_DEFAULT;\n+  enum omp_clause_defaultmap_kind category\n+    = OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n     return list;\n-  if (!c_parser_next_token_is (parser, CPP_NAME))\n-    {\n-      c_parser_error (parser, \"expected %<tofrom%>\");\n+  if (c_parser_next_token_is_keyword (parser, RID_DEFAULT))\n+    p = \"default\";\n+  else if (!c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+    invalid_behavior:\n+      c_parser_error (parser, \"expected %<alloc%>, %<to%>, %<from%>, \"\n+\t\t\t      \"%<tofrom%>, %<firstprivate%>, %<none%> \"\n+\t\t\t      \"or %<default%>\");\n       goto out_err;\n     }\n-  p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-  if (strcmp (p, \"tofrom\") != 0)\n+  else\n+    p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+  switch (p[0])\n     {\n-      c_parser_error (parser, \"expected %<tofrom%>\");\n-      goto out_err;\n+    case 'a':\n+      if (strcmp (\"alloc\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_ALLOC;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 'd':\n+      if (strcmp (\"default\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_DEFAULT;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 'f':\n+      if (strcmp (\"firstprivate\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_FIRSTPRIVATE;\n+      else if (strcmp (\"from\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_FROM;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 'n':\n+      if (strcmp (\"none\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_NONE;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 't':\n+      if (strcmp (\"tofrom\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_TOFROM;\n+      else if (strcmp (\"to\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_TO;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    default:\n+      goto invalid_behavior;\n     }\n   c_parser_consume_token (parser);\n-  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n-    goto out_err;\n-  if (!c_parser_next_token_is (parser, CPP_NAME))\n-    {\n-      c_parser_error (parser, \"expected %<scalar%>\");\n-      goto out_err;\n-    }\n-  p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-  if (strcmp (p, \"scalar\") != 0)\n+\n+  if (!c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n     {\n-      c_parser_error (parser, \"expected %<scalar%>\");\n-      goto out_err;\n+      if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+\tgoto out_err;\n+      if (!c_parser_next_token_is (parser, CPP_NAME))\n+\t{\n+\tinvalid_category:\n+\t  c_parser_error (parser, \"expected %<scalar%>, %<aggregate%> or \"\n+\t\t\t\t  \"%<pointer%>\");\n+\t  goto out_err;\n+\t}\n+      p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      switch (p[0])\n+\t{\n+\tcase 'a':\n+\t  if (strcmp (\"aggregate\", p) == 0)\n+\t    category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE;\n+\t  else\n+\t    goto invalid_category;\n+\t  break;\n+\n+\tcase 'p':\n+\t  if (strcmp (\"pointer\", p) == 0)\n+\t    category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER;\n+\t  else\n+\t    goto invalid_category;\n+\t  break;\n+\n+\tcase 's':\n+\t  if (strcmp (\"scalar\", p) == 0)\n+\t    category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR;\n+\t  else\n+\t    goto invalid_category;\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid_category;\n+\t}\n+\n+      c_parser_consume_token (parser);\n     }\n-  c_parser_consume_token (parser);\n   parens.skip_until_found_close (parser);\n-  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, \"defaultmap\");\n+\n+  for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEFAULTMAP\n+\t&& (category == OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED\n+\t    || OMP_CLAUSE_DEFAULTMAP_CATEGORY (c) == category\n+\t    || (OMP_CLAUSE_DEFAULTMAP_CATEGORY (c)\n+\t\t== OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED)))\n+      {\n+\tenum omp_clause_defaultmap_kind cat = category;\n+\tlocation_t loc = OMP_CLAUSE_LOCATION (c);\n+\tif (cat == OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED)\n+\t  cat = OMP_CLAUSE_DEFAULTMAP_CATEGORY (c);\n+\tp = NULL;\n+\tswitch (cat)\n+\t  {\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED:\n+\t    p = NULL;\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE:\n+\t    p = \"aggregate\";\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER:\n+\t    p = \"pointer\";\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR:\n+\t    p = \"scalar\";\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tif (p)\n+\t  error_at (loc, \"too many %<defaultmap%> clauses with %qs category\",\n+\t\t    p);\n+\telse\n+\t  error_at (loc, \"too many %<defaultmap%> clauses with unspecified \"\n+\t\t\t \"category\");\n+\tbreak;\n+      }\n+\n   c = build_omp_clause (loc, OMP_CLAUSE_DEFAULTMAP);\n+  OMP_CLAUSE_DEFAULTMAP_SET_KIND (c, behavior, category);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n \n@@ -12957,18 +13244,51 @@ c_parser_omp_clause_private (c_parser *parser, tree list)\n \n    reduction-operator:\n      One of: + * - & ^ | && ||\n-     identifier  */\n+     identifier\n+\n+   OpenMP 5.0:\n+   reduction ( reduction-modifier, reduction-operator : variable-list )\n+   in_reduction ( reduction-operator : variable-list )\n+   task_reduction ( reduction-operator : variable-list )  */\n \n static tree\n-c_parser_omp_clause_reduction (c_parser *parser, tree list)\n+c_parser_omp_clause_reduction (c_parser *parser, enum omp_clause_code kind,\n+\t\t\t       bool is_omp, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   matching_parens parens;\n   if (parens.require_open (parser))\n     {\n+      bool task = false;\n+      bool inscan = false;\n       enum tree_code code = ERROR_MARK;\n       tree reduc_id = NULL_TREE;\n \n+      if (kind == OMP_CLAUSE_REDUCTION && is_omp)\n+\t{\n+\t  if (c_parser_next_token_is_keyword (parser, RID_DEFAULT)\n+\t      && c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      c_parser_consume_token (parser);\n+\t    }\n+\t  else if (c_parser_next_token_is (parser, CPP_NAME)\n+\t\t   && c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n+\t    {\n+\t      const char *p\n+\t\t= IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\t      if (strcmp (p, \"task\") == 0)\n+\t\ttask = true;\n+\t      else if (strcmp (p, \"inscan\") == 0)\n+\t\tinscan = true;\n+\t      if (task || inscan)\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  c_parser_consume_token (parser);\n+\t\t}\n+\t    }\n+\t}\n+\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_PLUS:\n@@ -13025,8 +13345,7 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \t{\n \t  tree nl, c;\n \n-\t  nl = c_parser_omp_variable_list (parser, clause_loc,\n-\t\t\t\t\t   OMP_CLAUSE_REDUCTION, list);\n+\t  nl = c_parser_omp_variable_list (parser, clause_loc, kind, list);\n \t  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n \t    {\n \t      tree d = OMP_CLAUSE_DECL (c), type;\n@@ -13051,6 +13370,10 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \t      while (TREE_CODE (type) == ARRAY_TYPE)\n \t\ttype = TREE_TYPE (type);\n \t      OMP_CLAUSE_REDUCTION_CODE (c) = code;\n+\t      if (task)\n+\t\tOMP_CLAUSE_REDUCTION_TASK (c) = 1;\n+\t      else if (inscan)\n+\t\tOMP_CLAUSE_REDUCTION_INSCAN (c) = 1;\n \t      if (code == ERROR_MARK\n \t\t  || !(INTEGRAL_TYPE_P (type)\n \t\t       || TREE_CODE (type) == REAL_TYPE\n@@ -13510,6 +13833,15 @@ c_parser_omp_clause_linear (c_parser *parser, tree list)\n   return nl;\n }\n \n+/* OpenMP 5.0:\n+   nontemporal ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_nontemporal (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_NONTEMPORAL, list);\n+}\n+\n /* OpenMP 4.0:\n    safelen ( constant-expression ) */\n \n@@ -13670,6 +14002,106 @@ c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n   return u;\n }\n \n+/* OpenMP 5.0:\n+   iterators ( iterators-definition )\n+\n+   iterators-definition:\n+     iterator-specifier\n+     iterator-specifier , iterators-definition\n+\n+   iterator-specifier:\n+     identifier = range-specification\n+     iterator-type identifier = range-specification\n+\n+   range-specification:\n+     begin : end\n+     begin : end : step  */\n+\n+static tree\n+c_parser_omp_iterators (c_parser *parser)\n+{\n+  tree ret = NULL_TREE, *last = &ret;\n+  c_parser_consume_token (parser);\n+\n+  push_scope ();\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return error_mark_node;\n+\n+  do\n+    {\n+      tree iter_type = NULL_TREE, type_expr = NULL_TREE;\n+      if (c_parser_next_tokens_start_typename (parser, cla_prefer_id))\n+\t{\n+\t  struct c_type_name *type = c_parser_type_name (parser);\n+\t  if (type != NULL)\n+\t    iter_type = groktypename (type, &type_expr, NULL);\n+\t}\n+      if (iter_type == NULL_TREE)\n+\titer_type = integer_type_node;\n+\n+      location_t loc = c_parser_peek_token (parser)->location;\n+      if (!c_parser_next_token_is (parser, CPP_NAME))\n+\t{\n+\t  c_parser_error (parser, \"expected identifier\");\n+\t  break;\n+\t}\n+\n+      tree id = c_parser_peek_token (parser)->value;\n+      c_parser_consume_token (parser);\n+\n+      if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+\tbreak;\n+\n+      location_t eloc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (eloc, expr, true, false);\n+      tree begin = expr.value;\n+\n+      if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+\tbreak;\n+\n+      eloc = c_parser_peek_token (parser)->location;\n+      expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (eloc, expr, true, false);\n+      tree end = expr.value;\n+\n+      tree step = integer_one_node;\n+      if (c_parser_next_token_is (parser, CPP_COLON))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  eloc = c_parser_peek_token (parser)->location;\n+\t  expr = c_parser_expr_no_commas (parser, NULL);\n+\t  expr = convert_lvalue_to_rvalue (eloc, expr, true, false);\n+\t  step = expr.value;\n+\t}\n+\n+      tree iter_var = build_decl (loc, VAR_DECL, id, iter_type);\n+      DECL_ARTIFICIAL (iter_var) = 1;\n+      DECL_CONTEXT (iter_var) = current_function_decl;\n+      pushdecl (iter_var);\n+\n+      *last = make_tree_vec (6);\n+      TREE_VEC_ELT (*last, 0) = iter_var;\n+      TREE_VEC_ELT (*last, 1) = begin;\n+      TREE_VEC_ELT (*last, 2) = end;\n+      TREE_VEC_ELT (*last, 3) = step;\n+      last = &TREE_CHAIN (*last);\n+\n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  while (1);\n+\n+  parens.skip_until_found_close (parser);\n+  return ret ? ret : error_mark_node;\n+}\n+\n /* OpenMP 4.0:\n    depend ( depend-kind: variable-list )\n \n@@ -13679,40 +14111,71 @@ c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,\n    OpenMP 4.5:\n    depend ( source )\n \n-   depend ( sink  : vec )  */\n+   depend ( sink  : vec )\n+\n+   OpenMP 5.0:\n+   depend ( depend-modifier , depend-kind: variable-list )\n+\n+   depend-kind:\n+     in | out | inout | mutexinoutset | depobj\n+\n+   depend-modifier:\n+     iterator ( iterators-definition )  */\n \n static tree\n c_parser_omp_clause_depend (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n-  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;\n-  tree nl, c;\n+  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_LAST;\n+  tree nl, c, iterators = NULL_TREE;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n     return list;\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  do\n     {\n+      if (c_parser_next_token_is_not (parser, CPP_NAME))\n+\tgoto invalid_kind;\n+\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (\"iterator\", p) == 0 && iterators == NULL_TREE)\n+\t{\n+\t  iterators = c_parser_omp_iterators (parser);\n+\t  c_parser_require (parser, CPP_COMMA, \"expected %<,%>\");\n+\t  continue;\n+\t}\n       if (strcmp (\"in\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_IN;\n       else if (strcmp (\"inout\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_INOUT;\n+      else if (strcmp (\"mutexinoutset\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n       else if (strcmp (\"out\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_OUT;\n-      else if (strcmp (\"source\", p) == 0)\n-\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n+      else if (strcmp (\"depobj\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_DEPOBJ;\n       else if (strcmp (\"sink\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_SINK;\n+      else if (strcmp (\"source\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n       else\n \tgoto invalid_kind;\n+      break;\n     }\n-  else\n-    goto invalid_kind;\n+  while (1);\n \n   c_parser_consume_token (parser);\n \n+  if (iterators\n+      && (kind == OMP_CLAUSE_DEPEND_SOURCE || kind == OMP_CLAUSE_DEPEND_SINK))\n+    {\n+      pop_scope ();\n+      error_at (clause_loc, \"%<iterator%> modifier incompatible with %qs\",\n+\t\tkind == OMP_CLAUSE_DEPEND_SOURCE ? \"source\" : \"sink\");\n+      iterators = NULL_TREE;\n+    }\n+\n   if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n     {\n       c = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);\n@@ -13733,8 +14196,22 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n       nl = c_parser_omp_variable_list (parser, clause_loc,\n \t\t\t\t       OMP_CLAUSE_DEPEND, list);\n \n+      if (iterators)\n+\t{\n+\t  tree block = pop_scope ();\n+\t  if (iterators == error_mark_node)\n+\t    iterators = NULL_TREE;\n+\t  else\n+\t    TREE_VEC_ELT (iterators, 5) = block;\n+\t}\n+\n       for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n-\tOMP_CLAUSE_DEPEND_KIND (c) = kind;\n+\t{\n+\t  OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+\t  if (iterators)\n+\t    OMP_CLAUSE_DECL (c)\n+\t      = build_tree_list (iterators, OMP_CLAUSE_DECL (c));\n+\t}\n     }\n \n   parens.skip_until_found_close (parser);\n@@ -13744,6 +14221,8 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n   c_parser_error (parser, \"invalid depend kind\");\n  resync_fail:\n   parens.skip_until_found_close (parser);\n+  if (iterators)\n+    pop_scope ();\n   return list;\n }\n \n@@ -14169,12 +14648,14 @@ c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  c_name = \"private\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_REDUCTION:\n-\t  clauses = c_parser_omp_clause_reduction (parser, clauses);\n+\t  clauses\n+\t    = c_parser_omp_clause_reduction (parser, OMP_CLAUSE_REDUCTION,\n+\t\t\t\t\t     false, clauses);\n \t  c_name = \"reduction\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_SEQ:\n \t  clauses = c_parser_oacc_simple_clause (parser, OMP_CLAUSE_SEQ,\n-\t\t\t\t\t\tclauses);\n+\t\t\t\t\t\t clauses);\n \t  c_name = \"seq\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_TILE:\n@@ -14295,6 +14776,12 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_if (parser, clauses, true);\n \t  c_name = \"if\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_IN_REDUCTION:\n+\t  clauses\n+\t    = c_parser_omp_clause_reduction (parser, OMP_CLAUSE_IN_REDUCTION,\n+\t\t\t\t\t     true, clauses);\n+\t  c_name = \"in_reduction\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n \t  clauses = c_parser_omp_clause_lastprivate (parser, clauses);\n \t  c_name = \"lastprivate\";\n@@ -14328,7 +14815,9 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  c_name = \"private\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_REDUCTION:\n-\t  clauses = c_parser_omp_clause_reduction (parser, clauses);\n+\t  clauses\n+\t    = c_parser_omp_clause_reduction (parser, OMP_CLAUSE_REDUCTION,\n+\t\t\t\t\t     true, clauses);\n \t  c_name = \"reduction\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_SCHEDULE:\n@@ -14339,6 +14828,12 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_shared (parser, clauses);\n \t  c_name = \"shared\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_TASK_REDUCTION:\n+\t  clauses\n+\t    = c_parser_omp_clause_reduction (parser, OMP_CLAUSE_TASK_REDUCTION,\n+\t\t\t\t\t     true, clauses);\n+\t  c_name = \"task_reduction\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_UNTIED:\n \t  clauses = c_parser_omp_clause_untied (parser, clauses);\n \t  c_name = \"untied\";\n@@ -14348,6 +14843,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\tclauses);\n \t  c_name = \"inbranch\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NONTEMPORAL:\n+\t  clauses = c_parser_omp_clause_nontemporal (parser, clauses);\n+\t  c_name = \"nontemporal\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOTINBRANCH:\n \t  clauses = c_parser_omp_clause_branch (parser, OMP_CLAUSE_NOTINBRANCH,\n \t\t\t\t\t\tclauses);\n@@ -15252,61 +15751,156 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n   tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE;\n   tree lhs1 = NULL_TREE, rhs1 = NULL_TREE;\n   tree stmt, orig_lhs, unfolded_lhs = NULL_TREE, unfolded_lhs1 = NULL_TREE;\n-  enum tree_code code = OMP_ATOMIC, opcode = NOP_EXPR;\n+  enum tree_code code = ERROR_MARK, opcode = NOP_EXPR;\n+  enum omp_memory_order memory_order = OMP_MEMORY_ORDER_UNSPECIFIED;\n   struct c_expr expr;\n   location_t eloc;\n   bool structured_block = false;\n   bool swapped = false;\n-  bool seq_cst = false;\n   bool non_lvalue_p;\n+  bool first = true;\n+  tree clauses = NULL_TREE;\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n-    {\n-      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-      if (!strcmp (p, \"seq_cst\"))\n-\t{\n-\t  seq_cst = true;\n-\t  c_parser_consume_token (parser);\n-\t  if (c_parser_next_token_is (parser, CPP_COMMA)\n-\t      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n-\t    c_parser_consume_token (parser);\n-\t}\n-    }\n-  if (c_parser_next_token_is (parser, CPP_NAME))\n-    {\n-      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-\n-      if (!strcmp (p, \"read\"))\n-\tcode = OMP_ATOMIC_READ;\n-      else if (!strcmp (p, \"write\"))\n-\tcode = NOP_EXPR;\n-      else if (!strcmp (p, \"update\"))\n-\tcode = OMP_ATOMIC;\n-      else if (!strcmp (p, \"capture\"))\n-\tcode = OMP_ATOMIC_CAPTURE_NEW;\n-      else\n-\tp = NULL;\n-      if (p)\n-\tc_parser_consume_token (parser);\n-    }\n-  if (!seq_cst)\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n-      if (c_parser_next_token_is (parser, CPP_COMMA)\n-\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+      if (!first && c_parser_next_token_is (parser, CPP_COMMA))\n \tc_parser_consume_token (parser);\n \n+      first = false;\n+\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  const char *p\n \t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-\t  if (!strcmp (p, \"seq_cst\"))\n+\t  location_t cloc = c_parser_peek_token (parser)->location;\n+\t  enum tree_code new_code = ERROR_MARK;\n+\t  enum omp_memory_order new_memory_order\n+\t    = OMP_MEMORY_ORDER_UNSPECIFIED;\n+\n+\t  if (!strcmp (p, \"read\"))\n+\t    new_code = OMP_ATOMIC_READ;\n+\t  else if (!strcmp (p, \"write\"))\n+\t    new_code = NOP_EXPR;\n+\t  else if (!strcmp (p, \"update\"))\n+\t    new_code = OMP_ATOMIC;\n+\t  else if (!strcmp (p, \"capture\"))\n+\t    new_code = OMP_ATOMIC_CAPTURE_NEW;\n+\t  else if (!strcmp (p, \"seq_cst\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  else if (!strcmp (p, \"acq_rel\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_ACQ_REL;\n+\t  else if (!strcmp (p, \"release\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_RELEASE;\n+\t  else if (!strcmp (p, \"acquire\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n+\t  else if (!strcmp (p, \"relaxed\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_RELAXED;\n+\t  else if (!strcmp (p, \"hint\"))\n \t    {\n-\t      seq_cst = true;\n \t      c_parser_consume_token (parser);\n+\t      clauses = c_parser_omp_clause_hint (parser, clauses);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      p = NULL;\n+\t      error_at (cloc, \"expected %<read%>, %<write%>, %<update%>, \"\n+\t\t\t      \"%<capture%>, %<seq_cst%>, %<acq_rel%>, \"\n+\t\t\t      \"%<release%>, %<relaxed%> or %<hint%> clause\");\n+\t    }\n+\t  if (p)\n+\t    {\n+\t      if (new_code != ERROR_MARK)\n+\t\t{\n+\t\t  if (code != ERROR_MARK)\n+\t\t    error_at (cloc, \"too many atomic clauses\");\n+\t\t  else\n+\t\t    code = new_code;\n+\t\t}\n+\t      else if (new_memory_order != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t{\n+\t\t  if (memory_order != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t    error_at (cloc, \"too many memory order clauses\");\n+\t\t  else\n+\t\t    memory_order = new_memory_order;\n+\t\t}\n+\t      c_parser_consume_token (parser);\n+\t      continue;\n+\t    }\n+\t}\n+      break;\n+    }\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  if (code == ERROR_MARK)\n+    code = OMP_ATOMIC;\n+  if (memory_order == OMP_MEMORY_ORDER_UNSPECIFIED)\n+    {\n+      omp_requires_mask\n+\t= (enum omp_requires) (omp_requires_mask\n+\t\t\t       | OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER_USED);\n+      switch ((enum omp_memory_order)\n+\t      (omp_requires_mask & OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER))\n+\t{\n+\tcase OMP_MEMORY_ORDER_UNSPECIFIED:\n+\tcase OMP_MEMORY_ORDER_RELAXED:\n+\t  memory_order = OMP_MEMORY_ORDER_RELAXED;\n+\t  break;\n+\tcase OMP_MEMORY_ORDER_SEQ_CST:\n+\t  memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  break;\n+\tcase OMP_MEMORY_ORDER_ACQ_REL:\n+\t  switch (code)\n+\t    {\n+\t    case OMP_ATOMIC_READ:\n+\t      memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n+\t      break;\n+\t    case NOP_EXPR: /* atomic write */\n+\t    case OMP_ATOMIC:\n+\t      memory_order = OMP_MEMORY_ORDER_RELEASE;\n+\t      break;\n+\t    default:\n+\t      memory_order = OMP_MEMORY_ORDER_ACQ_REL;\n+\t      break;\n \t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n-  c_parser_skip_to_pragma_eol (parser);\n+  else\n+    switch (code)\n+      {\n+      case OMP_ATOMIC_READ:\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n+\t    || memory_order == OMP_MEMORY_ORDER_RELEASE)\n+\t  {\n+\t    error_at (loc, \"%<#pragma omp atomic read%> incompatible with \"\n+\t\t\t   \"%<acq_rel%> or %<release%> clauses\");\n+\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      case NOP_EXPR: /* atomic write */\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n+\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n+\t  {\n+\t    error_at (loc, \"%<#pragma omp atomic write%> incompatible with \"\n+\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n+\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      case OMP_ATOMIC:\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n+\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n+\t  {\n+\t    error_at (loc, \"%<#pragma omp atomic update%> incompatible with \"\n+\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n+\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n \n   switch (code)\n     {\n@@ -15624,7 +16218,7 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n     }\n   else\n     stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs, v, lhs1, rhs1,\n-\t\t\t\tswapped, seq_cst);\n+\t\t\t\tswapped, memory_order);\n   if (stmt != error_mark_node)\n     add_stmt (stmt);\n \n@@ -15676,6 +16270,10 @@ c_parser_omp_critical (location_t loc, c_parser *parser, bool *if_p)\n       else\n \tc_parser_error (parser, \"expected identifier\");\n \n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+\n       clauses = c_parser_omp_all_clauses (parser,\n \t\t\t\t\t  OMP_CRITICAL_CLAUSE_MASK,\n \t\t\t\t\t  \"#pragma omp critical\");\n@@ -15691,24 +16289,159 @@ c_parser_omp_critical (location_t loc, c_parser *parser, bool *if_p)\n   return c_finish_omp_critical (loc, stmt, name, clauses);\n }\n \n+/* OpenMP 5.0:\n+   # pragma omp depobj ( depobj ) depobj-clause new-line\n+\n+   depobj-clause:\n+     depend (dependence-type : locator)\n+     destroy\n+     update (dependence-type)\n+\n+   dependence-type:\n+     in\n+     out\n+     inout\n+     mutexinout  */\n+\n+static void\n+c_parser_omp_depobj (c_parser *parser)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  c_parser_consume_pragma (parser);\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    {\n+      c_parser_skip_to_pragma_eol (parser);\n+      return;\n+    }\n+\n+  tree depobj = c_parser_expr_no_commas (parser, NULL).value;\n+  if (depobj != error_mark_node)\n+    {\n+      if (!lvalue_p (depobj))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (depobj, loc),\n+\t\t    \"%<depobj%> expression is not lvalue expression\");\n+\t  depobj = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  tree addr = build_unary_op (EXPR_LOC_OR_LOC (depobj, loc), ADDR_EXPR,\n+\t\t\t\t      depobj, false);\n+\t  if (addr == error_mark_node)\n+\t    depobj = error_mark_node;\n+\t  else\n+\t    depobj = build_indirect_ref (EXPR_LOC_OR_LOC (depobj, loc),\n+\t\t\t\t\t addr, RO_UNARY_STAR);\n+\t}\n+    }\n+\n+  parens.skip_until_found_close (parser);\n+  tree clause = NULL_TREE;\n+  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n+  location_t c_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      c_parser_consume_token (parser);\n+      if (!strcmp (\"depend\", p))\n+\t{\n+\t  clause = c_parser_omp_clause_depend (parser, NULL_TREE);\n+\t  clause = c_finish_omp_clauses (clause, C_ORT_OMP);\n+\t  if (!clause)\n+\t    clause = error_mark_node;\n+\t}\n+      else if (!strcmp (\"destroy\", p))\n+\tkind = OMP_CLAUSE_DEPEND_LAST;\n+      else if (!strcmp (\"update\", p))\n+\t{\n+\t  matching_parens c_parens;\n+\t  if (c_parens.require_open (parser))\n+\t    {\n+\t      location_t c2_loc = c_parser_peek_token (parser)->location;\n+\t      if (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t{\n+\t\t  const char *p2\n+\t\t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+\t\t  c_parser_consume_token (parser);\n+\t\t  if (!strcmp (\"in\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_IN;\n+\t\t  else if (!strcmp (\"out\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_OUT;\n+\t\t  else if (!strcmp (\"inout\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_INOUT;\n+\t\t  else if (!strcmp (\"mutexinoutset\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n+\t\t}\n+\t      if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+\t\t{\n+\t\t  clause = error_mark_node;\n+\t\t  error_at (c2_loc, \"expected %<in%>, %<out%>, %<inout%> or \"\n+\t\t\t\t    \"%<mutexinoutset%>\");\n+\t\t}\n+\t      c_parens.skip_until_found_close (parser);\n+\t    }\n+\t  else\n+\t    clause = error_mark_node;\n+\t}\n+    }\n+  if (!clause && kind == OMP_CLAUSE_DEPEND_SOURCE)\n+    {\n+      clause = error_mark_node;\n+      error_at (c_loc, \"expected %<depend%>, %<destroy%> or %<update%> clause\");\n+    }\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  c_finish_omp_depobj (loc, depobj, kind, clause);\n+}\n+\n+\n /* OpenMP 2.5:\n    # pragma omp flush flush-vars[opt] new-line\n \n    flush-vars:\n-     ( variable-list ) */\n+     ( variable-list )\n+\n+   OpenMP 5.0:\n+   # pragma omp flush memory-order-clause new-line  */\n \n static void\n c_parser_omp_flush (c_parser *parser)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n+  enum memmodel mo = MEMMODEL_LAST;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p\n+\t= IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      if (!strcmp (p, \"acq_rel\"))\n+\tmo = MEMMODEL_ACQ_REL;\n+      else if (!strcmp (p, \"release\"))\n+\tmo = MEMMODEL_RELEASE;\n+      else if (!strcmp (p, \"acquire\"))\n+\tmo = MEMMODEL_ACQUIRE;\n+      else\n+\terror_at (c_parser_peek_token (parser)->location,\n+\t\t  \"expected %<acq_rel%>, %<release%> or %<acquire%>\");\n+      c_parser_consume_token (parser);\n+    }\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n-    c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);\n+    {\n+      if (mo != MEMMODEL_LAST)\n+\terror_at (c_parser_peek_token (parser)->location,\n+\t\t  \"%<flush%> list specified together with memory order \"\n+\t\t  \"clause\");\n+      c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);\n+    }\n   else if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     c_parser_error (parser, \"expected %<(%> or end of line\");\n   c_parser_skip_to_pragma_eol (parser);\n \n-  c_finish_omp_flush (loc);\n+  c_finish_omp_flush (loc, mo);\n }\n \n /* Parse the restricted form of loop statements allowed by OpenACC and OpenMP.\n@@ -15880,6 +16613,10 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t    case LT_EXPR:\n \t    case LE_EXPR:\n \t      break;\n+\t    case NE_EXPR:\n+\t      if (code != OACC_LOOP)\n+\t\tbreak;\n+\t      /* FALLTHRU.  */\n \t    default:\n \t      /* Can't be cond = error_mark_node, because we want to preserve\n \t\t the location until c_finish_omp_for.  */\n@@ -16011,7 +16748,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   if (!fail)\n     {\n       stmt = c_finish_omp_for (loc, code, declv, NULL, initv, condv,\n-\t\t\t       incrv, body, pre_body);\n+\t\t\t       incrv, body, pre_body, true);\n \n       /* Check for iterators appearing in lb, b or incr expressions.  */\n       if (stmt && !c_omp_check_loop_iv (stmt, declv, NULL))\n@@ -16108,7 +16845,9 @@ omp_split_clauses (location_t loc, enum tree_code code,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NONTEMPORAL))\n \n static tree\n c_parser_omp_simd (location_t loc, c_parser *parser,\n@@ -16236,6 +16975,9 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n   return ret;\n }\n \n+static tree c_parser_omp_taskloop (location_t, c_parser *, char *,\n+\t\t\t\t   omp_clause_mask, tree *, bool *);\n+\n /* OpenMP 2.5:\n    # pragma omp master new-line\n      structured-block\n@@ -16244,9 +16986,52 @@ c_parser_omp_for (location_t loc, c_parser *parser,\n */\n \n static tree\n-c_parser_omp_master (location_t loc, c_parser *parser, bool *if_p)\n+c_parser_omp_master (location_t loc, c_parser *parser,\n+\t\t     char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t     bool *if_p)\n {\n-  c_parser_skip_to_pragma_eol (parser);\n+  tree block, clauses, ret;\n+\n+  strcat (p_name, \" master\");\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      if (strcmp (p, \"taskloop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_taskloop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t  if_p);\n+\t  block = c_begin_compound_stmt (true);\n+\t  ret = c_parser_omp_taskloop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t       if_p);\n+\t  block = c_end_compound_stmt (loc, block, true);\n+\t  if (ret == NULL_TREE)\n+\t    return ret;\n+\t  ret = c_finish_omp_master (loc, block);\n+\t  return ret;\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      c_parser_skip_to_pragma_eol (parser, false);\n+      return NULL_TREE;\n+    }\n+\n+  if (cclauses)\n+    {\n+      clauses = c_parser_omp_all_clauses (parser, mask, p_name, false);\n+      omp_split_clauses (loc, OMP_MASTER, mask, clauses, cclauses);\n+    }\n+  else\n+    c_parser_skip_to_pragma_eol (parser);\n+\n   return c_finish_omp_master (loc, c_parser_omp_structured_block (parser,\n \t\t\t\t\t\t\t\t  if_p));\n }\n@@ -16508,19 +17293,38 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n       c_parser_skip_to_pragma_eol (parser);\n       return NULL_TREE;\n     }\n-  else if (!flag_openmp)  /* flag_openmp_simd  */\n-    {\n-      c_parser_skip_to_pragma_eol (parser, false);\n-      return NULL_TREE;\n-    }\n   else if (cclauses == NULL && c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-      if (strcmp (p, \"sections\") == 0)\n+      if (strcmp (p, \"master\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n-\t  if (cclauses == NULL)\n-\t    cclauses = cclauses_buf;\n+\t  cclauses = cclauses_buf;\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_master (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\tif_p);\n+\t  block = c_begin_omp_parallel ();\n+\t  tree ret = c_parser_omp_master (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t  if_p);\n+\t  stmt = c_finish_omp_parallel (loc,\n+\t\t\t\t\tcclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n+\t\t\t\t\tblock);\n+\t  OMP_PARALLEL_COMBINED (stmt) = 1;\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  return stmt;\n+\t}\n+      else if (!flag_openmp)  /* flag_openmp_simd  */\n+\t{\n+\t  c_parser_skip_to_pragma_eol (parser, false);\n+\t  return NULL_TREE;\n+\t}\n+      else if (strcmp (p, \"sections\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  cclauses = cclauses_buf;\n \n \t  c_parser_consume_token (parser);\n \t  block = c_begin_omp_parallel ();\n@@ -16532,6 +17336,11 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n \t  return stmt;\n \t}\n     }\n+  else if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      c_parser_skip_to_pragma_eol (parser, false);\n+      return NULL_TREE;\n+    }\n \n   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n   if (cclauses)\n@@ -16591,7 +17400,8 @@ c_parser_omp_single (location_t loc, c_parser *parser, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n \n static tree\n c_parser_omp_task (location_t loc, c_parser *parser, bool *if_p)\n@@ -16608,16 +17418,35 @@ c_parser_omp_task (location_t loc, c_parser *parser, bool *if_p)\n \n /* OpenMP 3.0:\n    # pragma omp taskwait new-line\n+\n+   OpenMP 5.0:\n+   # pragma omp taskwait taskwait-clause[optseq] new-line\n */\n \n+#define OMP_TASKWAIT_CLAUSE_MASK\t\t\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n+\n static void\n c_parser_omp_taskwait (c_parser *parser)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n-  c_parser_skip_to_pragma_eol (parser);\n \n-  c_finish_omp_taskwait (loc);\n+  tree clauses\n+    = c_parser_omp_all_clauses (parser, OMP_TASKWAIT_CLAUSE_MASK,\n+\t\t\t\t\"#pragma omp taskwait\");\n+\n+  if (clauses)\n+    {\n+      tree stmt = make_node (OMP_TASK);\n+      TREE_TYPE (stmt) = void_node;\n+      OMP_TASK_CLAUSES (stmt) = clauses;\n+      OMP_TASK_BODY (stmt) = NULL_TREE;\n+      SET_EXPR_LOCATION (stmt, loc);\n+      add_stmt (stmt);\n+    }\n+  else\n+    c_finish_omp_taskwait (loc);\n }\n \n /* OpenMP 3.1:\n@@ -16636,15 +17465,22 @@ c_parser_omp_taskyield (c_parser *parser)\n \n /* OpenMP 4.0:\n    # pragma omp taskgroup new-line\n+\n+   OpenMP 5.0:\n+   # pragma omp taskgroup taskgroup-clause[optseq] new-line\n */\n \n+#define OMP_TASKGROUP_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASK_REDUCTION))\n+\n static tree\n-c_parser_omp_taskgroup (c_parser *parser, bool *if_p)\n+c_parser_omp_taskgroup (location_t loc, c_parser *parser, bool *if_p)\n {\n-  location_t loc = c_parser_peek_token (parser)->location;\n-  c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_taskgroup (loc, c_parser_omp_structured_block (parser,\n-\t\t\t\t\t\t\t\t     if_p));\n+  tree clauses = c_parser_omp_all_clauses (parser, OMP_TASKGROUP_CLAUSE_MASK,\n+\t\t\t\t\t   \"#pragma omp taskgroup\");\n+\n+  tree body = c_parser_omp_structured_block (parser, if_p);\n+  return c_finish_omp_taskgroup (loc, body, clauses);\n }\n \n /* OpenMP 4.0:\n@@ -16850,7 +17686,7 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    return c_parser_omp_distribute (loc, parser, p_name, mask,\n \t\t\t\t\t    cclauses, if_p);\n-\t  block = c_begin_compound_stmt (true);\n+\t  block = c_begin_omp_parallel ();\n \t  ret = c_parser_omp_distribute (loc, parser, p_name, mask, cclauses,\n \t\t\t\t\t if_p);\n \t  block = c_end_compound_stmt (loc, block, true);\n@@ -16862,6 +17698,7 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n \t  OMP_TEAMS_CLAUSES (ret) = clauses;\n \t  OMP_TEAMS_BODY (ret) = block;\n \t  OMP_TEAMS_COMBINED (ret) = 1;\n+\t  SET_EXPR_LOCATION (ret, loc);\n \t  return add_stmt (ret);\n \t}\n     }\n@@ -16881,7 +17718,10 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n   tree stmt = make_node (OMP_TEAMS);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TEAMS_CLAUSES (stmt) = clauses;\n-  OMP_TEAMS_BODY (stmt) = c_parser_omp_structured_block (parser, if_p);\n+  block = c_begin_omp_parallel ();\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n+  OMP_TEAMS_BODY (stmt) = c_end_compound_stmt (loc, block, true);\n+  SET_EXPR_LOCATION (stmt, loc);\n \n   return add_stmt (stmt);\n }\n@@ -16929,6 +17769,8 @@ c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)\n \t    *pc = OMP_CLAUSE_CHAIN (*pc);\n \t    continue;\n \t  }\n+      else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_USE_DEVICE_PTR)\n+\tmap_seen = 3;\n       pc = &OMP_CLAUSE_CHAIN (*pc);\n     }\n \n@@ -16937,7 +17779,7 @@ c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)\n       if (map_seen == 0)\n \terror_at (loc,\n \t\t  \"%<#pragma omp target data%> must contain at least \"\n-\t\t  \"one %<map%> clause\");\n+\t\t  \"one %<map%> or %<use_device_ptr%> clause\");\n       return NULL_TREE;\n     }\n \n@@ -17196,6 +18038,10 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n       return false;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n@@ -17296,6 +18142,7 @@ c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)\n \t  OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n \t  OMP_TARGET_BODY (stmt) = block;\n \t  OMP_TARGET_COMBINED (stmt) = 1;\n+\t  SET_EXPR_LOCATION (stmt, loc);\n \t  add_stmt (stmt);\n \t  pc = &OMP_TARGET_CLAUSES (stmt);\n \t  goto check_clauses;\n@@ -18082,6 +18929,176 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n   c_parser_skip_to_pragma_eol (parser);\n }\n \n+/* OpenMP 5.0\n+   #pragma omp requires clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_requires (c_parser *parser)\n+{\n+  bool first = true;\n+  enum omp_requires new_req = (enum omp_requires) 0;\n+\n+  c_parser_consume_pragma (parser);\n+\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    {\n+      if (!first && c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+\n+      first = false;\n+\n+      if (c_parser_next_token_is (parser, CPP_NAME))\n+\t{\n+\t  const char *p\n+\t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\t  location_t cloc = c_parser_peek_token (parser)->location;\n+\t  enum omp_requires this_req = (enum omp_requires) 0;\n+\n+\t  if (!strcmp (p, \"unified_address\"))\n+\t    this_req = OMP_REQUIRES_UNIFIED_ADDRESS;\n+\t  else if (!strcmp (p, \"unified_shared_memory\"))\n+\t    this_req = OMP_REQUIRES_UNIFIED_SHARED_MEMORY;\n+\t  else if (!strcmp (p, \"dynamic_allocators\"))\n+\t    this_req = OMP_REQUIRES_DYNAMIC_ALLOCATORS;\n+\t  else if (!strcmp (p, \"reverse_offload\"))\n+\t    this_req = OMP_REQUIRES_REVERSE_OFFLOAD;\n+\t  else if (!strcmp (p, \"atomic_default_mem_order\"))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\n+\t      matching_parens parens;\n+\t      if (parens.require_open (parser))\n+\t\t{\n+\t\t  if (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t    {\n+\t\t      tree v = c_parser_peek_token (parser)->value;\n+\t\t      p = IDENTIFIER_POINTER (v);\n+\n+\t\t      if (!strcmp (p, \"seq_cst\"))\n+\t\t\tthis_req\n+\t\t\t  = (enum omp_requires) OMP_MEMORY_ORDER_SEQ_CST;\n+\t\t      else if (!strcmp (p, \"relaxed\"))\n+\t\t\tthis_req\n+\t\t\t  = (enum omp_requires) OMP_MEMORY_ORDER_RELAXED;\n+\t\t      else if (!strcmp (p, \"acq_rel\"))\n+\t\t\tthis_req\n+\t\t\t  = (enum omp_requires) OMP_MEMORY_ORDER_ACQ_REL;\n+\t\t    }\n+\t\t  if (this_req == 0)\n+\t\t    {\n+\t\t      error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\t\"expected %<seq_cst%>, %<relaxed%> or \"\n+\t\t\t\t\"%<acq_rel%>\");\n+\t\t      if (c_parser_peek_2nd_token (parser)->type\n+\t\t\t  == CPP_CLOSE_PAREN)\n+\t\t\tc_parser_consume_token (parser);\n+\t\t    }\n+\t\t  else\n+\t\t    c_parser_consume_token (parser);\n+\n+\t\t  parens.skip_until_found_close (parser);\n+\t\t  if (this_req == 0)\n+\t\t    {\n+\t\t      c_parser_skip_to_pragma_eol (parser, false);\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      p = NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      error_at (cloc, \"expected %<unified_address%>, \"\n+\t\t\t      \"%<unified_shared_memory%>, \"\n+\t\t\t      \"%<dynamic_allocators%>, \"\n+\t\t\t       \"%<reverse_offload%> \"\n+\t\t\t       \"or %<atomic_default_mem_order%> clause\");\n+\t      c_parser_skip_to_pragma_eol (parser, false);\n+\t      return;\n+\t    }\n+\t  if (p)\n+\t    c_parser_consume_token (parser);\n+\t  if (this_req)\n+\t    {\n+\t      if ((this_req & ~OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER) != 0)\n+\t\t{\n+\t\t  if ((this_req & new_req) != 0)\n+\t\t    error_at (cloc, \"too many %qs clauses\", p);\n+\t\t  if (this_req != OMP_REQUIRES_DYNAMIC_ALLOCATORS\n+\t\t      && (omp_requires_mask & OMP_REQUIRES_TARGET_USED) != 0)\n+\t\t    error_at (cloc, \"%qs clause used lexically after first \"\n+\t\t\t\t    \"target construct or offloading API\", p);\n+\t\t}\n+\t      else if ((new_req & OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER) != 0)\n+\t\t{\n+\t\t  error_at (cloc, \"too many %qs clauses\",\n+\t\t\t    \"atomic_default_mem_order\");\n+\t\t  this_req = (enum omp_requires) 0;\n+\t\t}\n+\t      else if ((omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER) != 0)\n+\t\t{\n+\t\t  error_at (cloc, \"more than one %<atomic_default_mem_order%>\"\n+\t\t\t\t  \" clause in a single compilation unit\");\n+\t\t  this_req\n+\t\t    = (enum omp_requires)\n+\t\t       (omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER);\n+\t\t}\n+\t      else if ((omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER_USED) != 0)\n+\t\terror_at (cloc, \"%<atomic_default_mem_order%> clause used \"\n+\t\t\t\t\"lexically after first %<atomic%> construct \"\n+\t\t\t\t\"without memory order clause\");\n+\t      new_req = (enum omp_requires) (new_req | this_req);\n+\t      omp_requires_mask\n+\t\t= (enum omp_requires) (omp_requires_mask | this_req);\n+\t      continue;\n+\t    }\n+\t}\n+      break;\n+    }\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  if (new_req == 0)\n+    error_at (loc, \"%<pragma omp requires%> requires at least one clause\");\n+}\n+\n+/* Helper function for c_parser_omp_taskloop.\n+   Disallow zero sized or potentially zero sized task reductions.  */\n+\n+static tree\n+c_finish_taskloop_clauses (tree clauses)\n+{\n+  tree *pc = &clauses;\n+  for (tree c = clauses; c; c = *pc)\n+    {\n+      bool remove = false;\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t{\n+\t  tree type = strip_array_types (TREE_TYPE (OMP_CLAUSE_DECL (c)));\n+\t  if (integer_zerop (TYPE_SIZE_UNIT (type)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"zero sized type %qT in %<reduction%> clause\", type);\n+\t      remove = true;\n+\t    }\n+\t  else if (TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"variable sized type %qT in %<reduction%> clause\",\n+\t\t\ttype);\n+\t      remove = true;\n+\t    }\n+\t}\n+      if (remove)\n+\t*pc = OMP_CLAUSE_CHAIN (c);\n+      else\n+\tpc = &OMP_CLAUSE_CHAIN (c);\n+    }\n+  return clauses;\n+}\n+\n /* OpenMP 4.5:\n    #pragma omp taskloop taskloop-clause[optseq] new-line\n      for-loop\n@@ -18103,7 +19120,9 @@ c_parser_omp_declare (c_parser *parser, enum pragma_context context)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n \n static tree\n c_parser_omp_taskloop (location_t loc, c_parser *parser,\n@@ -18114,6 +19133,10 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n \n   strcat (p_name, \" taskloop\");\n   mask |= OMP_TASKLOOP_CLAUSE_MASK;\n+  /* #pragma omp parallel master taskloop{, simd} disallow in_reduction\n+     clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION);\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -18124,7 +19147,6 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  if (cclauses == NULL)\n \t    cclauses = cclauses_buf;\n-\t  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION);\n \t  c_parser_consume_token (parser);\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,\n@@ -18138,6 +19160,8 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n \t  TREE_TYPE (ret) = void_type_node;\n \t  OMP_FOR_BODY (ret) = block;\n \t  OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n+\t  OMP_FOR_CLAUSES (ret)\n+\t    = c_finish_taskloop_clauses (OMP_FOR_CLAUSES (ret));\n \t  SET_EXPR_LOCATION (ret, loc);\n \t  add_stmt (ret);\n \t  return ret;\n@@ -18156,6 +19180,7 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n     }\n \n+  clauses = c_finish_taskloop_clauses (clauses);\n   block = c_begin_compound_stmt (true);\n   ret = c_parser_omp_for_loop (loc, parser, OMP_TASKLOOP, clauses, NULL, if_p);\n   block = c_end_compound_stmt (loc, block, true);\n@@ -18223,7 +19248,8 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       stmt = c_parser_omp_for (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_MASTER:\n-      stmt = c_parser_omp_master (loc, parser, if_p);\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = c_parser_omp_master (loc, parser, p_name, mask, NULL, if_p);\n       break;\n     case PRAGMA_OMP_PARALLEL:\n       strcpy (p_name, \"#pragma omp\");\n@@ -18244,7 +19270,7 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       stmt = c_parser_omp_task (loc, parser, if_p);\n       break;\n     case PRAGMA_OMP_TASKGROUP:\n-      stmt = c_parser_omp_taskgroup (parser, if_p);\n+      stmt = c_parser_omp_taskgroup (loc, parser, if_p);\n       break;\n     case PRAGMA_OMP_TASKLOOP:\n       strcpy (p_name, \"#pragma omp\");"}, {"sha": "144977e2f1b07253b9b3508ac5cc27238d32957a", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 390, "deletions": 62, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12525,6 +12525,11 @@ c_finish_omp_cancel (location_t loc, tree clauses)\n   tree ifc = omp_find_clause (clauses, OMP_CLAUSE_IF);\n   if (ifc != NULL_TREE)\n     {\n+      if (OMP_CLAUSE_IF_MODIFIER (ifc) != ERROR_MARK\n+\t  && OMP_CLAUSE_IF_MODIFIER (ifc) != VOID_CST)\n+\terror_at (OMP_CLAUSE_LOCATION (ifc),\n+\t\t  \"expected %<cancel%> %<if%> clause modifier\");\n+\n       tree type = TREE_TYPE (OMP_CLAUSE_IF_EXPR (ifc));\n       ifc = fold_build2_loc (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,\n \t\t\t     boolean_type_node, OMP_CLAUSE_IF_EXPR (ifc),\n@@ -12717,7 +12722,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       if (!integer_nonzerop (length))\n \t{\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t    {\n \t      if (integer_zerop (length))\n \t\t{\n@@ -12783,7 +12790,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t      if (tree_int_cst_equal (size, low_bound))\n \t\t{\n \t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"zero length array section in %qs clause\",\n@@ -12802,7 +12811,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  else if (length == NULL_TREE)\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n \t\tmaybe_zero_len = true;\n \t      if (first_non_one == types.length ())\n \t\tfirst_non_one++;\n@@ -12838,7 +12849,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       else if (length == NULL_TREE)\n \t{\n \t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n \t    maybe_zero_len = true;\n \t  if (first_non_one == types.length ())\n \t    first_non_one++;\n@@ -12910,7 +12923,13 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n   bool maybe_zero_len = false;\n   unsigned int first_non_one = 0;\n   auto_vec<tree, 10> types;\n-  tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n+  tree *tp = &OMP_CLAUSE_DECL (c);\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+      && TREE_CODE (*tp) == TREE_LIST\n+      && TREE_PURPOSE (*tp)\n+      && TREE_CODE (TREE_PURPOSE (*tp)) == TREE_VEC)\n+    tp = &TREE_VALUE (*tp);\n+  tree first = handle_omp_array_sections_1 (c, *tp, types,\n \t\t\t\t\t    maybe_zero_len, first_non_one,\n \t\t\t\t\t    ort);\n   if (first == error_mark_node)\n@@ -12919,7 +12938,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n     return false;\n   if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n     {\n-      tree t = OMP_CLAUSE_DECL (c);\n+      tree t = *tp;\n       tree tem = NULL_TREE;\n       /* Need to evaluate side effects in the length expressions\n \t if any.  */\n@@ -12938,7 +12957,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n       if (tem)\n \tfirst = build2 (COMPOUND_EXPR, TREE_TYPE (first), tem, first);\n       first = c_fully_fold (first, false, NULL, true);\n-      OMP_CLAUSE_DECL (c) = first;\n+      *tp = first;\n     }\n   else\n     {\n@@ -13010,7 +13029,9 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \n \t      if (i > first_non_one\n \t\t  && ((length && integer_nonzerop (length))\n-\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION))\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION))\n \t\tcontinue;\n \t      if (length)\n \t\tl = fold_convert (sizetype, length);\n@@ -13038,7 +13059,9 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t\t  tree eltype = TREE_TYPE (types[num - 1]);\n \t\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n \t\t    eltype = TREE_TYPE (eltype);\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t\t    {\n \t\t      if (integer_zerop (size)\n \t\t\t  || integer_zerop (size_in_bytes (eltype)))\n@@ -13062,10 +13085,13 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t}\n       if (side_effects)\n \tsize = build2 (COMPOUND_EXPR, sizetype, side_effects, size);\n-      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t{\n \t  size = size_binop (MINUS_EXPR, size, size_one_node);\n \t  size = c_fully_fold (size, false, NULL);\n+\t  size = save_expr (size);\n \t  tree index_type = build_index_type (size);\n \t  tree eltype = TREE_TYPE (first);\n \t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n@@ -13195,6 +13221,178 @@ c_find_omp_placeholder_r (tree *tp, int *, void *data)\n   return NULL_TREE;\n }\n \n+/* Similarly, but also walk aggregate fields.  */\n+\n+struct c_find_omp_var_s { tree var; hash_set<tree> *pset; };\n+\n+static tree\n+c_find_omp_var_r (tree *tp, int *, void *data)\n+{\n+  if (*tp == ((struct c_find_omp_var_s *) data)->var)\n+    return *tp;\n+  if (RECORD_OR_UNION_TYPE_P (*tp))\n+    {\n+      tree field;\n+      hash_set<tree> *pset = ((struct c_find_omp_var_s *) data)->pset;\n+\n+      for (field = TYPE_FIELDS (*tp); field;\n+\t   field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n+\t  {\n+\t    tree ret = walk_tree (&DECL_FIELD_OFFSET (field),\n+\t\t\t\t  c_find_omp_var_r, data, pset);\n+\t    if (ret)\n+\t      return ret;\n+\t    ret = walk_tree (&DECL_SIZE (field), c_find_omp_var_r, data, pset);\n+\t    if (ret)\n+\t      return ret;\n+\t    ret = walk_tree (&DECL_SIZE_UNIT (field), c_find_omp_var_r, data,\n+\t\t\t     pset);\n+\t    if (ret)\n+\t      return ret;\n+\t    ret = walk_tree (&TREE_TYPE (field), c_find_omp_var_r, data, pset);\n+\t    if (ret)\n+\t      return ret;\n+\t  }\n+    }\n+  else if (INTEGRAL_TYPE_P (*tp))\n+    return walk_tree (&TYPE_MAX_VALUE (*tp), c_find_omp_var_r, data,\n+\t\t      ((struct c_find_omp_var_s *) data)->pset);\n+  return NULL_TREE;\n+}\n+\n+/* Finish OpenMP iterators ITER.  Return true if they are errorneous\n+   and clauses containing them should be removed.  */\n+\n+static bool\n+c_omp_finish_iterators (tree iter)\n+{\n+  bool ret = false;\n+  for (tree it = iter; it; it = TREE_CHAIN (it))\n+    {\n+      tree var = TREE_VEC_ELT (it, 0);\n+      tree begin = TREE_VEC_ELT (it, 1);\n+      tree end = TREE_VEC_ELT (it, 2);\n+      tree step = TREE_VEC_ELT (it, 3);\n+      tree orig_step;\n+      tree type = TREE_TYPE (var);\n+      location_t loc = DECL_SOURCE_LOCATION (var);\n+      if (type == error_mark_node)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n+\t{\n+\t  error_at (loc, \"iterator %qD has neither integral nor pointer type\",\n+\t\t    var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      else if (TYPE_ATOMIC (type))\n+\t{\n+\t  error_at (loc, \"iterator %qD has %<_Atomic%> qualified type\", var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      else if (TYPE_READONLY (type))\n+\t{\n+\t  error_at (loc, \"iterator %qD has const qualified type\", var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      else if (step == error_mark_node\n+\t       || TREE_TYPE (step) == error_mark_node)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      else if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (step, loc),\n+\t\t    \"iterator step with non-integral type\");\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      begin = c_fully_fold (build_c_cast (loc, type, begin), false, NULL);\n+      end = c_fully_fold (build_c_cast (loc, type, end), false, NULL);\n+      orig_step = save_expr (c_fully_fold (step, false, NULL));\n+      tree stype = POINTER_TYPE_P (type) ? sizetype : type;\n+      step = c_fully_fold (build_c_cast (loc, stype, orig_step), false, NULL);\n+      if (POINTER_TYPE_P (type))\n+\t{\n+\t  begin = save_expr (begin);\n+\t  step = pointer_int_sum (loc, PLUS_EXPR, begin, step);\n+\t  step = fold_build2_loc (loc, MINUS_EXPR, sizetype,\n+\t\t\t\t  fold_convert (sizetype, step),\n+\t\t\t\t  fold_convert (sizetype, begin));\n+\t  step = fold_convert (ssizetype, step);\n+\t}\n+      if (integer_zerop (step))\n+\t{\n+\t  error_at (loc, \"iterator %qD has zero step\", var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+\n+      if (begin == error_mark_node\n+\t  || end == error_mark_node\n+\t  || step == error_mark_node\n+\t  || orig_step == error_mark_node)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      hash_set<tree> pset;\n+      tree it2;\n+      for (it2 = TREE_CHAIN (it); it2; it2 = TREE_CHAIN (it2))\n+\t{\n+\t  tree var2 = TREE_VEC_ELT (it2, 0);\n+\t  tree begin2 = TREE_VEC_ELT (it2, 1);\n+\t  tree end2 = TREE_VEC_ELT (it2, 2);\n+\t  tree step2 = TREE_VEC_ELT (it2, 3);\n+\t  tree type2 = TREE_TYPE (var2);\n+\t  location_t loc2 = DECL_SOURCE_LOCATION (var2);\n+\t  struct c_find_omp_var_s data = { var, &pset };\n+\t  if (walk_tree (&type2, c_find_omp_var_r, &data, &pset))\n+\t    {\n+\t      error_at (loc2,\n+\t\t\t\"type of iterator %qD refers to outer iterator %qD\",\n+\t\t\tvar2, var);\n+\t      break;\n+\t    }\n+\t  else if (walk_tree (&begin2, c_find_omp_var_r, &data, &pset))\n+\t    {\n+\t      error_at (EXPR_LOC_OR_LOC (begin2, loc2),\n+\t\t\t\"begin expression refers to outer iterator %qD\", var);\n+\t      break;\n+\t    }\n+\t  else if (walk_tree (&end2, c_find_omp_var_r, &data, &pset))\n+\t    {\n+\t      error_at (EXPR_LOC_OR_LOC (end2, loc2),\n+\t\t\t\"end expression refers to outer iterator %qD\", var);\n+\t      break;\n+\t    }\n+\t  else if (walk_tree (&step2, c_find_omp_var_r, &data, &pset))\n+\t    {\n+\t      error_at (EXPR_LOC_OR_LOC (step2, loc2),\n+\t\t\t\"step expression refers to outer iterator %qD\", var);\n+\t      break;\n+\t    }\n+\t}\n+      if (it2)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      TREE_VEC_ELT (it, 1) = begin;\n+      TREE_VEC_ELT (it, 2) = end;\n+      TREE_VEC_ELT (it, 3) = step;\n+      TREE_VEC_ELT (it, 4) = orig_step;\n+    }\n+  return ret;\n+}\n+\n /* For all elements of CLAUSES, validate them against their constraints.\n    Remove any elements from the list that are invalid.  */\n \n@@ -13212,14 +13410,20 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   bool ordered_seen = false;\n   tree schedule_clause = NULL_TREE;\n   bool oacc_async = false;\n+  tree last_iterators = NULL_TREE;\n+  bool last_iterators_remove = false;\n+  tree *nogroup_seen = NULL;\n+  bool reduction_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n   bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n+  /* If ort == C_ORT_OMP_DECLARE_SIMD used as uniform_head instead.  */\n   bitmap_initialize (&map_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n+  /* If ort == C_ORT_OMP used as nontemporal_head instead.  */\n   bitmap_initialize (&oacc_reduction_head, &bitmap_default_obstack);\n \n   if (ort & C_ORT_ACC)\n@@ -13248,6 +13452,10 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\t  reduction_seen = true;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  need_implicitly_determined = true;\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n@@ -13296,6 +13504,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  break;\n \t\t}\n \t      size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t      size = save_expr (size);\n \t      tree index_type = build_index_type (size);\n \t      tree atype = build_array_type (type, index_type);\n \t      tree ptype = build_pointer_type (type);\n@@ -13311,6 +13520,28 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      remove = true;\n \t      break;\n \t    }\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t      || OMP_CLAUSE_REDUCTION_TASK (c))\n+\t    {\n+\t      /* Disallow zero sized or potentially zero sized task\n+\t\t reductions.  */\n+\t      if (integer_zerop (TYPE_SIZE_UNIT (type)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"zero sized type %qT in %qs clause\", type,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      else if (TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"variable sized type %qT in %qs clause\", type,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == NULL_TREE\n \t      && (FLOAT_TYPE_P (type)\n \t\t  || TREE_CODE (type) == COMPLEX_TYPE))\n@@ -13512,7 +13743,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  if (TYPE_ATOMIC (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t    \"%<_Atomic%> %qD in %<linear%> clause\", t);\n+\t\t\t\"%<_Atomic%> %qD in %<linear%> clause\", t);\n \t      remove = true;\n \t      break;\n \t    }\n@@ -13570,7 +13801,9 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    {\n \t      if (bitmap_bit_p (&oacc_reduction_head, DECL_UID (t)))\n \t\t{\n-\t\t  error (\"%qD appears more than once in reduction clauses\", t);\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD appears more than once in reduction clauses\",\n+\t\t\t    t);\n \t\t  remove = true;\n \t\t}\n \t      else\n@@ -13588,9 +13821,11 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t   && bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears both in data and map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears both in data and map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -13617,9 +13852,11 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears both in data and map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears both in data and map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -13681,6 +13918,25 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    bitmap_set_bit (&aligned_head, DECL_UID (t));\n \t  break;\n \n+\tcase OMP_CLAUSE_NONTEMPORAL:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in %<nontemporal%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&oacc_reduction_head, DECL_UID (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE appears more than once in %<nontemporal%> \"\n+\t\t\t\"clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&oacc_reduction_head, DECL_UID (t));\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n@@ -13717,22 +13973,89 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t}\n \t      break;\n \t    }\n+\t  if (TREE_CODE (t) == TREE_LIST\n+\t      && TREE_PURPOSE (t)\n+\t      && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t    {\n+\t      if (TREE_PURPOSE (t) != last_iterators)\n+\t\tlast_iterators_remove\n+\t\t  = c_omp_finish_iterators (TREE_PURPOSE (t));\n+\t      last_iterators = TREE_PURPOSE (t);\n+\t      t = TREE_VALUE (t);\n+\t      if (last_iterators_remove)\n+\t\tt = error_mark_node;\n+\t    }\n+\t  else\n+\t    last_iterators = NULL_TREE;\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n \t      if (handle_omp_array_sections (c, ort))\n \t\tremove = true;\n+\t      else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<depend%> clause with %<depobj%> dependence \"\n+\t\t\t    \"type on array section\");\n+\t\t  remove = true;\n+\t\t}\n \t      break;\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n-\t  else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t  else if (!lvalue_p (t))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%qE is not a variable in %<depend%> clause\", t);\n+\t\t\t\"%qE is not lvalue expression nor array section in \"\n+\t\t\t\"%<depend%> clause\", t);\n \t      remove = true;\n \t    }\n-\t  else if (!c_mark_addressable (t))\n-\t    remove = true;\n+\t  else if (TREE_CODE (t) == COMPONENT_REF\n+\t\t   && DECL_C_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"bit-field %qE in %qs clause\", t, \"depend\");\n+\t      remove = true;\n+\t    }\n+\t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t    {\n+\t      if (!c_omp_depend_t_p (TREE_TYPE (t)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE does not have %<omp_depend_t%> type in \"\n+\t\t\t    \"%<depend%> clause with %<depobj%> dependence \"\n+\t\t\t    \"type\", t);\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n+\t  else if (c_omp_depend_t_p (TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE should not have %<omp_depend_t%> type in \"\n+\t\t\t\"%<depend%> clause with dependence type other than \"\n+\t\t\t\"%<depobj%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  if (!remove)\n+\t    {\n+\t      tree addr = build_unary_op (OMP_CLAUSE_LOCATION (c), ADDR_EXPR,\n+\t\t\t\t\t  t, false);\n+\t      if (addr == error_mark_node)\n+\t\tremove = true;\n+\t      else\n+\t\t{\n+\t\t  t = build_indirect_ref (OMP_CLAUSE_LOCATION (c), addr,\n+\t\t\t\t\t  RO_UNARY_STAR);\n+\t\t  if (t == error_mark_node)\n+\t\t    remove = true;\n+\t\t  else if (TREE_CODE (OMP_CLAUSE_DECL (c)) == TREE_LIST\n+\t\t\t   && TREE_PURPOSE (OMP_CLAUSE_DECL (c))\n+\t\t\t   && (TREE_CODE (TREE_PURPOSE (OMP_CLAUSE_DECL (c)))\n+\t\t\t       == TREE_VEC))\n+\t\t    TREE_VALUE (OMP_CLAUSE_DECL (c)) = t;\n+\t\t  else\n+\t\t    OMP_CLAUSE_DECL (c) = t;\n+\t\t}\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_MAP:\n@@ -13774,14 +14097,17 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t\t\t{\n \t\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n-\t\t\t    error (\"%qD appears more than once in motion\"\n-\t\t\t\t   \" clauses\", t);\n+\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      \"%qD appears more than once in motion \"\n+\t\t\t\t      \"clauses\", t);\n \t\t\t  else if (ort == C_ORT_ACC)\n-\t\t\t    error (\"%qD appears more than once in data\"\n-\t\t\t\t   \" clauses\", t);\n+\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      \"%qD appears more than once in data \"\n+\t\t\t\t      \"clauses\", t);\n \t\t\t  else\n-\t\t\t    error (\"%qD appears more than once in map\"\n-\t\t\t\t   \" clauses\", t);\n+\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      \"%qD appears more than once in map \"\n+\t\t\t\t      \"clauses\", t);\n \t\t\t  remove = true;\n \t\t\t}\n \t\t      else\n@@ -13891,15 +14217,18 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t  || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t\t{\n-\t\t  error (\"%qD appears more than once in data clauses\", t);\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD appears more than once in data clauses\", t);\n \t\t  remove = true;\n \t\t}\n \t      else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t\t{\n \t\t  if (ort == C_ORT_ACC)\n-\t\t    error (\"%qD appears more than once in data clauses\", t);\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"%qD appears more than once in data clauses\", t);\n \t\t  else\n-\t\t    error (\"%qD appears both in data and map clauses\", t);\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"%qD appears both in data and map clauses\", t);\n \t\t  remove = true;\n \t\t}\n \t      else\n@@ -13908,20 +14237,25 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n-\t\terror (\"%qD appears more than once in motion clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in motion clauses\", t);\n \t      else if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears more than once in map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears both in data and map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears both in data and map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -14041,7 +14375,6 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_PRIORITY:\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n-\tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_HINT:\n@@ -14063,30 +14396,12 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n+\tcase OMP_CLAUSE_NOGROUP:\n+\t  nogroup_seen = pc;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n \tcase OMP_CLAUSE_SCHEDULE:\n-\t  if (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n-\t    {\n-\t      const char *p = NULL;\n-\t      switch (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n-\t\t{\n-\t\tcase OMP_CLAUSE_SCHEDULE_STATIC: p = \"static\"; break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_DYNAMIC: break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_GUIDED: break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_AUTO: p = \"auto\"; break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_RUNTIME: p = \"runtime\"; break;\n-\t\tdefault: gcc_unreachable ();\n-\t\t}\n-\t      if (p)\n-\t\t{\n-\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%<nonmonotonic%> modifier specified for %qs \"\n-\t\t\t    \"schedule kind\", p);\n-\t\t  OMP_CLAUSE_SCHEDULE_KIND (c)\n-\t\t    = (enum omp_clause_schedule_kind)\n-\t\t      (OMP_CLAUSE_SCHEDULE_KIND (c)\n-\t\t       & ~OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n-\t\t}\n-\t    }\n \t  schedule_clause = c;\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n@@ -14145,10 +14460,6 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tcase OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n \t\t  break;\n \t\tcase OMP_CLAUSE_DEFAULT_SHARED:\n-\t\t  /* const vars may be specified in firstprivate clause.  */\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n-\t\t      && TREE_READONLY (t))\n-\t\t    break;\n \t\t  share_name = \"shared\";\n \t\t  break;\n \t\tcase OMP_CLAUSE_DEFAULT_PRIVATE:\n@@ -14165,6 +14476,15 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t  remove = true;\n \t\t}\n+\t      else if (TREE_READONLY (t)\n+\t\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_SHARED\n+\t\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<const%> qualified %qE may appear only in \"\n+\t\t\t    \"%<shared%> or %<firstprivate%> clauses\", t);\n+\t\t  remove = true;\n+\t\t}\n \t    }\n \t}\n \n@@ -14222,6 +14542,14 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n       }\n \n+  if (nogroup_seen && reduction_seen)\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (*nogroup_seen),\n+\t\t\"%<nogroup%> clause must not be used together with \"\n+\t\t\"%<reduction%> clause\");\n+      *nogroup_seen = OMP_CLAUSE_CHAIN (*nogroup_seen);\n+    }\n+\n   bitmap_obstack_release (NULL);\n   return clauses;\n }"}, {"sha": "1497dab500f0e67e5335f33646440462cc1de108", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,167 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* constexpr.c (potential_constant_expression_1): Handle OMP_DEPOBJ.\n+\t* cp-gimplify.c (cp_genericize_r): Handle\n+\tOMP_CLAUSE_{IN,TASK}_REDUCTION.\n+\t(cxx_omp_predetermined_sharing_1): Don't return\n+\tOMP_CLAUSE_DEFAULT_SHARED for const qualified decls with no mutable\n+\tmember.  Return OMP_CLAUSE_DEFAULT_FIRSTPRIVATE for this pointer.\n+\t* cp-objcp-common.c (cp_common_init_ts): Handle OMP_DEPOBJ.\n+\t* cp-tree.def (OMP_DEPOBJ): New tree code.\n+\t* cp-tree.h (OMP_ATOMIC_DEPENDENT_P): Return true also for first\n+\targument being OMP_CLAUSE.\n+\t(OMP_DEPOBJ_DEPOBJ, OMP_DEPOBJ_CLAUSES): Define.\n+\t(cp_convert_omp_range_for, cp_finish_omp_range_for): Declare.\n+\t(finish_omp_atomic): Add LOC, CLAUSES and MO arguments.  Remove\n+\tSEQ_CST argument.\n+\t(finish_omp_for_block): Declare.\n+\t(finish_omp_flush): Add MO argument.\n+\t(finish_omp_depobj): Declare.\n+\t* cxx-pretty-print.c (cxx_pretty_printer::statement): Handle\n+\tOMP_DEPOBJ.\n+\t* dump.c (cp_dump_tree): Likewise.\n+\t* lex.c (cxx_init): Likewise.\n+\t* parser.c: Include memmodel.h.\n+\t(cp_parser_for): Pass false as new is_omp argument to\n+\tcp_parser_range_for.\n+\t(cp_parser_range_for): Add IS_OMP argument, return before finalizing\n+\tif it is true.\n+\t(cp_parser_omp_clause_name): Handle nontemporal, in_reduction and\n+\ttask_reduction clauses.\n+        (cp_parser_omp_var_list_no_open): Handle\n+\tOMP_CLAUSE_{IN,TASK}_REDUCTION.  For OMP_CLAUSE_DEPEND, parse clause\n+\toperands as either an array section, or lvalue assignment expression.\n+\t(cp_parser_omp_clause_if): Handle cancel and simd modifiers.\n+\t(cp_parser_omp_clause_defaultmap): Parse new kinds of defaultmap\n+\tclause.\n+\t(cp_parser_omp_clause_reduction): Add IS_OMP and KIND arguments.\n+\tParse reduction modifiers.  Pass KIND to c_parser_omp_variable_list.\n+\t(cp_parser_omp_clause_lastprivate, cp_parser_omp_iterators): New\n+\tfunctions.\n+\t(cp_parser_omp_clause_depend): Parse iterator modifier and handle\n+\titerators.  Parse mutexinoutset and depobj kinds.\n+\t(cp_parser_oacc_all_clauses): Adjust cp_parser_omp_clause_reduction\n+\tcallers.\n+\t(cp_parser_omp_all_clauses): Likewise.  Handle\n+\tPRAGMA_OMP_CLAUSE_NONTEMPORAL and\n+\tPRAGMA_OMP_CLAUSE_{IN,TASK}_REDUCTION.  Call\n+\tcp_parser_omp_clause_lastprivate for OpenMP lastprivate clause.\n+\t(cp_parser_omp_atomic): Pass pragma_tok->location as\n+\tLOC to finish_omp_atomic.  Parse hint and memory order clauses.\n+\tHandle default memory order from requires directive if any.  Adjust\n+\tfinish_omp_atomic caller.\n+\t(cp_parser_omp_critical): Allow comma in between (name) and hint\n+\tclause.\n+\t(cp_parser_omp_depobj): New function.\n+\t(cp_parser_omp_flush): Parse flush with memory-order-clause.\n+\t(cp_parser_omp_for_cond): Allow NE_EXPR even in OpenMP loops.\n+\t(cp_convert_omp_range_for, cp_finish_omp_range_for): New functions.\n+\t(cp_parser_omp_for_loop): Parse C++11 range for loops among omp\n+\tloops.  Handle OMP_CLAUSE_IN_REDUCTION like OMP_CLAUSE_REDUCTION.\n+\t(OMP_SIMD_CLAUSE_MASK): Add if and nontemporal clauses.\n+\t(cp_parser_omp_simd, cp_parser_omp_for): Call keep_next_level before\n+\tbegin_omp_structured_block and call finish_omp_for_block on\n+\tfinish_omp_structured_block result.\n+\t(cp_parser_omp_master): Add p_name, mask and cclauses arguments.\n+\tAllow to be called while parsing combined parallel master.\n+\tParse combined master taskloop{, simd}.\n+\t(cp_parser_omp_parallel): Parse combined\n+\tparallel master{, taskloop{, simd}} constructs.\n+\t(cp_parser_omp_single): Use SET_EXPR_LOCATION.\n+\t(OMP_TASK_CLAUSE_MASK): Add in_reduction clause.\n+\t(OMP_TASKWAIT_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_taskwait): Handle taskwait with depend clauses.\n+\t(OMP_TASKGROUP_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_taskgroup): Parse taskgroup clauses, adjust\n+\tc_finish_omp_taskgroup caller.\n+\t(cp_parser_omp_distribute): Call keep_next_level before\n+\tbegin_omp_structured_block and call finish_omp_for_block on\n+\tfinish_omp_structured_block result.\n+\t(cp_parser_omp_teams): Force a BIND_EXPR with BLOCK around teams\n+\tbody.\n+\t(cp_parser_omp_target_data): Allow target data with only\n+\tuse_device_ptr clauses.\n+\t(cp_parser_omp_target): Set OMP_REQUIRES_TARGET_USED bit in\n+\tomp_requires_mask.\n+\t(cp_parser_omp_requires): New function.\n+\t(OMP_TASKLOOP_CLAUSE_MASK): Add reduction and in_reduction clauses.\n+\t(cp_parser_omp_taskloop): Add forward declaration.  Disallow\n+\tin_reduction clause when combined with parallel master.  Call\n+\tkeep_next_level before begin_omp_structured_block and call\n+\tfinish_omp_for_block on finish_omp_structured_block result.\n+\t(cp_parser_omp_construct): Adjust cp_parser_omp_master caller.\n+\t(cp_parser_pragma): Handle PRAGMA_OMP_DEPOBJ and PRAGMA_OMP_REQUIRES.\n+\t* pt.c (tsubst_omp_clause_decl): Add iterators_cache argument.\n+\tAdjust recursive calls.  Handle iterators.\n+\t(tsubst_omp_clauses): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION and\n+\tOMP_CLAUSE_NONTEMPORAL.  Adjust tsubst_omp_clause_decl callers.\n+\t(tsubst_decomp_names):\n+\t(tsubst_omp_for_iterator): Change orig_declv into a reference.\n+\tHandle range for loops.  Move orig_declv handling after declv/initv\n+\thandling.\n+\t(tsubst_expr): Force a BIND_EXPR with BLOCK around teams body.\n+\tAdjust finish_omp_atomic caller.  Call keep_next_level before\n+\tbegin_omp_structured_block.  Call cp_finish_omp_range_for for range\n+\tfor loops and use {begin,finish}_omp_structured_block instead of\n+\t{push,pop}_stmt_list if there are any range for loops.  Call\n+\tfinish_omp_for_block on finish_omp_structured_block result.\n+\tHandle OMP_DEPOBJ.  Handle taskwait with depend clauses.  For\n+\tOMP_ATOMIC call tsubst_omp_clauses on clauses if any, adjust\n+\tfinish_omp_atomic caller.  Use OMP_ATOMIC_MEMORY_ORDER rather\n+\tthan OMP_ATOMIC_SEQ_CST.  Handle clauses on OMP_TASKGROUP.\n+\t(dependent_omp_for_p): Always return true for range for loops if\n+\tprocessing_template_decl.  Return true if class type iterator\n+\tdoes not have INTEGER_CST increment.\n+\t* semantics.c: Include memmodel.h.\n+\t(handle_omp_array_sections_1): Handle OMP_CLAUSE_{IN,TASK}_REDUCTION\n+\tlike OMP_CLAUSE_REDUCTION.\n+\t(handle_omp_array_sections): Likewise.  Call save_expr on array\n+\treductions before calling build_index_type.  Handle depend clauses\n+\twith iterators.\n+\t(finish_omp_reduction_clause): Call save_expr for whole array\n+\treduction sizes.  Don't mark OMP_CLAUSE_DECL addressable if it has\n+\treference type.  Do mark decl_placeholder addressable if needed.\n+\tUse error_at with OMP_CLAUSE_LOCATION (c) as first argument instead\n+\tof error.\n+\t(cp_omp_finish_iterators): New function.\n+\t(finish_omp_clauses): Don't diagnose nonmonotonic clause with static,\n+\truntime or auto schedule kinds.  Diagnose nogroup clause used with\n+\treduction clause(s).  Handle depend clause with\n+\tOMP_CLAUSE_DEPEND_DEPOBJ.  Diagnose bit-fields.  Require\n+\tomp_depend_t type for OMP_CLAUSE_DEPEND_DEPOBJ kinds and\n+\tsome different type for other kinds.  Use cp_build_addr_expr\n+\tand cp_build_indirect_ref instead of cxx_mark_addressable.\n+\tHandle depend clauses with iterators.  Only handle static data members\n+\tin the special case that const qualified vars may be specified in\n+\tfirstprivate clause.  Complain if const qualified vars without mutable\n+\tmembers are mentioned in data-sharing clauses other than firstprivate\n+\tor shared.  Use error_at with OMP_CLAUSE_LOCATION (c) as first\n+\targument instead of error.  Diagnose more than one nontemporal clause\n+\trefering to the same variable.  Use error_at rather than error for\n+\tpriority and hint clause diagnostics.  Fix pasto for hint clause.\n+\tDiagnose hint expression that doesn't fold into INTEGER_CST.\n+\tDiagnose if clause with modifier other than cancel.  Handle\n+\tOMP_CLAUSE_{IN,TASK}_REDUCTION like OMP_CLAUSE_REDUCTION.  Allow any\n+\tlvalue as OMP_CLAUSE_DEPEND operand (besides array section), adjust\n+\tdiagnostics.\n+\t(handle_omp_for_class_iterator): Don't create a new TREE_LIST if one\n+\thas been created already for range for, just fill TREE_PURPOSE and\n+\tTREE_VALUE.  Call cp_fully_fold on incr.\n+\t(finish_omp_for): Don't check cond/incr if cond is global_namespace.\n+\tPass to c_omp_check_loop_iv_exprs orig_declv if non-NULL.  Don't\n+\tuse IS_EMPTY_STMT on NULL pre_body.  Adjust c_finish_omp_for caller.\n+\t(finish_omp_for_block): New function.\n+\t(finish_omp_atomic): Add LOC argument, pass it through\n+\tto c_finish_omp_atomic and set it as location of OMP_ATOMIC* trees.\n+\tRemove SEQ_CST argument.  Add CLAUSES and MO arguments.  Adjust\n+\tc_finish_omp_atomic caller.  Stick clauses if any into first argument\n+\tof wrapping OMP_ATOMIC.\n+\t(finish_omp_depobj): New function.\n+\t(finish_omp_flush): Add MO argument, if not\n+\tMEMMODEL_LAST, emit __atomic_thread_fence call with the given value.\n+\t(finish_omp_cancel): Diagnose if clause with modifier other than\n+\tcancel.\n+\n 2018-11-07  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/87904"}, {"sha": "7b696da5834bb3dfddb0f94791371d380b75cf1d", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -5917,6 +5917,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case OMP_ATOMIC_READ:\n     case OMP_ATOMIC_CAPTURE_OLD:\n     case OMP_ATOMIC_CAPTURE_NEW:\n+    case OMP_DEPOBJ:\n     case OACC_PARALLEL:\n     case OACC_KERNELS:\n     case OACC_DATA:"}, {"sha": "eb761b118a17632af0ff322f9a93926f2ee95a99", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1178,6 +1178,8 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t    *walk_subtrees = 0;\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  /* Don't dereference an invisiref in reduction clause's\n \t     OMP_CLAUSE_DECL either.  OMP_CLAUSE_REDUCTION_{INIT,MERGE}\n \t     still needs to be genericized.  */\n@@ -1986,10 +1988,10 @@ cxx_omp_predetermined_sharing_1 (tree decl)\n \treturn OMP_CLAUSE_DEFAULT_SHARED;\n     }\n \n-  /* Const qualified vars having no mutable member are predetermined\n-     shared.  */\n-  if (cxx_omp_const_qual_no_mutable (decl))\n-    return OMP_CLAUSE_DEFAULT_SHARED;\n+  /* this may not be specified in data-sharing clauses, still we need\n+     to predetermined it firstprivate.  */\n+  if (decl == current_class_ptr)\n+    return OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n \n   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n }"}, {"sha": "584f4284b61f22d5ab305eb5be2f3002a1258e17", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -446,6 +446,7 @@ cp_common_init_ts (void)\n   MARK_TS_TYPED (UNARY_RIGHT_FOLD_EXPR);\n   MARK_TS_TYPED (BINARY_LEFT_FOLD_EXPR);\n   MARK_TS_TYPED (BINARY_RIGHT_FOLD_EXPR);\n+  MARK_TS_TYPED (OMP_DEPOBJ);\n }\n \n #include \"gt-cp-cp-objcp-common.h\""}, {"sha": "43d90eb1efb603301dab650b42a5836ad1ef1319", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -499,6 +499,11 @@ DEFTREECODE (BASES, \"bases\", tcc_type, 0)\n    instantiation time.  */\n DEFTREECODE (TEMPLATE_INFO, \"template_info\", tcc_exceptional, 0)\n \n+/* OpenMP - #pragma omp depobj\n+   Operand 0: OMP_DEPOBJ_DEPOBJ: Depobj expression\n+   Operand 1: OMP_DEPOBJ_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_DEPOBJ, \"omp_depobj\", tcc_statement, 2)\n+\n /* Extensions for Concepts. */\n \n /* Used to represent information associated with constrained declarations. */"}, {"sha": "6ca138d4ce65f72ec4b705bca8de74bae276b947", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -4874,9 +4874,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (TREE_LANG_FLAG_1 (SCOPE_REF_CHECK (NODE)))\n \n /* True for an OMP_ATOMIC that has dependent parameters.  These are stored\n-   as an expr in operand 1, and integer_zero_node in operand 0.  */\n+   as an expr in operand 1, and integer_zero_node or clauses in operand 0.  */\n #define OMP_ATOMIC_DEPENDENT_P(NODE) \\\n-  (TREE_CODE (TREE_OPERAND (OMP_ATOMIC_CHECK (NODE), 0)) == INTEGER_CST)\n+  (TREE_CODE (TREE_OPERAND (OMP_ATOMIC_CHECK (NODE), 0)) == INTEGER_CST \\\n+   || TREE_CODE (TREE_OPERAND (OMP_ATOMIC_CHECK (NODE), 0)) == OMP_CLAUSE)\n \n /* Used while gimplifying continue statements bound to OMP_FOR nodes.  */\n #define OMP_FOR_GIMPLIFYING_P(NODE) \\\n@@ -5016,6 +5017,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define ALIGNOF_EXPR_STD_P(NODE) \\\n   TREE_LANG_FLAG_0 (ALIGNOF_EXPR_CHECK (NODE))\n \n+/* OMP_DEPOBJ accessors. These give access to the depobj expression of the\n+   #pragma omp depobj directive and the clauses, respectively.  If\n+   OMP_DEPOBJ_CLAUSES is INTEGER_CST, it is instead the update clause kind\n+   or OMP_CLAUSE_DEPEND_LAST for destroy clause.  */\n+#define OMP_DEPOBJ_DEPOBJ(NODE)\t TREE_OPERAND (OMP_DEPOBJ_CHECK (NODE), 0)\n+#define OMP_DEPOBJ_CLAUSES(NODE) TREE_OPERAND (OMP_DEPOBJ_CHECK (NODE), 1)\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n   none_type = 0, /* Not a tag type.  */\n@@ -6630,6 +6638,9 @@ extern bool maybe_clone_body\t\t\t(tree);\n /* In parser.c */\n extern tree cp_convert_range_for (tree, tree, tree, tree, unsigned int, bool,\n \t\t\t\t  unsigned short);\n+extern void cp_convert_omp_range_for (tree &, vec<tree, va_gc> *, tree &,\n+\t\t\t\t      tree &, tree &, tree &, tree &, tree &);\n+extern void cp_finish_omp_range_for (tree, tree);\n extern bool parsing_nsdmi (void);\n extern bool parsing_default_capturing_generic_lambda_in_template (void);\n extern void inject_this_parameter (tree, cp_cv_quals);\n@@ -7054,11 +7065,16 @@ extern tree finish_omp_task\t\t\t(tree, tree);\n extern tree finish_omp_for\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t tree, tree, tree, tree, tree,\n \t\t\t\t\t\t tree, tree, vec<tree> *, tree);\n-extern void finish_omp_atomic\t\t\t(enum tree_code, enum tree_code,\n-\t\t\t\t\t\t tree, tree, tree, tree, tree,\n-\t\t\t\t\t\t bool);\n+extern tree finish_omp_for_block\t\t(tree, tree);\n+extern void finish_omp_atomic\t\t\t(location_t, enum tree_code,\n+\t\t\t\t\t\t enum tree_code, tree, tree,\n+\t\t\t\t\t\t tree, tree, tree, tree,\n+\t\t\t\t\t\t enum omp_memory_order);\n extern void finish_omp_barrier\t\t\t(void);\n-extern void finish_omp_flush\t\t\t(void);\n+extern void finish_omp_depobj\t\t\t(location_t, tree,\n+\t\t\t\t\t\t enum omp_clause_depend_kind,\n+\t\t\t\t\t\t tree);\n+extern void finish_omp_flush\t\t\t(int);\n extern void finish_omp_taskwait\t\t\t(void);\n extern void finish_omp_taskyield\t\t(void);\n extern void finish_omp_cancel\t\t\t(tree);"}, {"sha": "b79ff5137aa19164cbe265a37ea594431c002bf4", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -2112,6 +2112,42 @@ cxx_pretty_printer::statement (tree t)\n       declaration (t);\n       break;\n \n+    case OMP_DEPOBJ:\n+      pp_cxx_ws_string (this, \"#pragma omp depobj\");\n+      pp_space (this);\n+      pp_cxx_left_paren (this);\n+      expression (OMP_DEPOBJ_DEPOBJ (t));\n+      pp_cxx_right_paren (this);\n+      if (OMP_DEPOBJ_CLAUSES (t) && OMP_DEPOBJ_CLAUSES (t) != error_mark_node)\n+\t{\n+\t  if (TREE_CODE (OMP_DEPOBJ_CLAUSES (t)) == OMP_CLAUSE)\n+\t    dump_omp_clauses (this, OMP_DEPOBJ_CLAUSES (t),\n+\t\t\t      pp_indentation (this), TDF_NONE);\n+\t  else\n+\t    switch (tree_to_uhwi (OMP_DEPOBJ_CLAUSES (t)))\n+\t      {\n+\t      case OMP_CLAUSE_DEPEND_IN:\n+\t\tpp_cxx_ws_string (this, \" update(in)\");\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_INOUT:\n+\t\tpp_cxx_ws_string (this, \" update(inout)\");\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_OUT:\n+\t\tpp_cxx_ws_string (this, \" update(out)\");\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t\tpp_cxx_ws_string (this, \" update(mutexinoutset)\");\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_LAST:\n+\t\tpp_cxx_ws_string (this, \" destroy\");\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t}\n+      pp_needs_newline (this) = true;\n+      break;\n+\n     default:\n       c_pretty_printer::statement (t);\n       break;"}, {"sha": "16538864cbd7bf646c71536b70729cd39d089981", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -328,6 +328,12 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"expr\", EXPR_STMT_EXPR (t));\n       break;\n \n+    case OMP_DEPOBJ:\n+      dump_stmt (di, t);\n+      dump_child (\"depobj\", OMP_DEPOBJ_DEPOBJ (t));\n+      dump_child (\"clauses\", OMP_DEPOBJ_CLAUSES (t));\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "49bcf5157bbb887c26086d1022c2242100047002", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -293,7 +293,7 @@ cxx_init (void)\n    IF_STMT,\t\tCLEANUP_STMT,\tFOR_STMT,\n    RANGE_FOR_STMT,\tWHILE_STMT,\tDO_STMT,\n    BREAK_STMT,\t\tCONTINUE_STMT,\tSWITCH_STMT,\n-   EXPR_STMT\n+   EXPR_STMT,\t\tOMP_DEPOBJ\n   };\n \n   memset (&statement_code_p, 0, sizeof (statement_code_p));"}, {"sha": "deaca5cc97496b4540ccfd60e8a26b1af066b69b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1347, "deletions": 128, "changes": 1475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcc-rich-location.h\"\n #include \"tree-iterator.h\"\n #include \"cp-name-hint.h\"\n+#include \"memmodel.h\"\n \n \f\n /* The lexer.  */\n@@ -2110,7 +2111,7 @@ static tree cp_parser_for\n static tree cp_parser_c_for\n   (cp_parser *, tree, tree, bool, unsigned short);\n static tree cp_parser_range_for\n-  (cp_parser *, tree, tree, tree, bool, unsigned short);\n+  (cp_parser *, tree, tree, tree, bool, unsigned short, bool);\n static void do_range_for_auto_deduction\n   (tree, tree);\n static tree cp_parser_perform_range_for_lookup\n@@ -11843,7 +11844,8 @@ cp_parser_for (cp_parser *parser, bool ivdep, unsigned short unroll)\n   is_range_for = cp_parser_init_statement (parser, &decl);\n \n   if (is_range_for)\n-    return cp_parser_range_for (parser, scope, init, decl, ivdep, unroll);\n+    return cp_parser_range_for (parser, scope, init, decl, ivdep, unroll,\n+\t\t\t\tfalse);\n   else\n     return cp_parser_c_for (parser, scope, init, ivdep, unroll);\n }\n@@ -11901,7 +11903,7 @@ cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep,\n \n static tree\n cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n-\t\t     bool ivdep, unsigned short unroll)\n+\t\t     bool ivdep, unsigned short unroll, bool is_omp)\n {\n   tree stmt, range_expr;\n   auto_vec <cxx_binding *, 16> bindings;\n@@ -11961,6 +11963,11 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n       IDENTIFIER_BINDING (names[i]) = binding;\n     }\n \n+  /* finish_omp_for has its own code for the following, so just\n+     return the range_expr instead.  */\n+  if (is_omp)\n+    return range_expr;\n+\n   /* If in template, STMT is converted to a normal for-statement\n      at instantiation. If not, it is done just ahead. */\n   if (processing_template_decl)\n@@ -31490,7 +31497,7 @@ cp_parser_objc_at_dynamic_declaration (cp_parser *parser)\n }\n \n \f\n-/* OpenMP 2.5 / 3.0 / 3.1 / 4.0 parsing routines.  */\n+/* OpenMP 2.5 / 3.0 / 3.1 / 4.0 / 4.5 / 5.0 parsing routines.  */\n \n /* Returns name of the next clause.\n    If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and\n@@ -31580,6 +31587,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \tcase 'i':\n \t  if (!strcmp (\"if_present\", p))\n \t    result = PRAGMA_OACC_CLAUSE_IF_PRESENT;\n+\t  else if (!strcmp (\"in_reduction\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_IN_REDUCTION;\n \t  else if (!strcmp (\"inbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_INBRANCH;\n \t  else if (!strcmp (\"independent\", p))\n@@ -31604,6 +31613,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \tcase 'n':\n \t  if (!strcmp (\"nogroup\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOGROUP;\n+\t  else if (!strcmp (\"nontemporal\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NONTEMPORAL;\n \t  else if (!strcmp (\"notinbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n@@ -31668,7 +31679,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_SIMDLEN;\n \t  break;\n \tcase 't':\n-\t  if (!strcmp (\"taskgroup\", p))\n+\t  if (!strcmp (\"task_reduction\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_TASK_REDUCTION;\n+\t  else if (!strcmp (\"taskgroup\", p))\n \t    result = PRAGMA_OMP_CLAUSE_TASKGROUP;\n \t  else if (!strcmp (\"thread_limit\", p))\n \t    result = PRAGMA_OMP_CLAUSE_THREAD_LIMIT;\n@@ -31759,6 +31772,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n     {\n       tree name, decl;\n \n+      if (kind == OMP_CLAUSE_DEPEND)\n+\tcp_parser_parse_tentatively (parser);\n       token = cp_lexer_peek_token (parser->lexer);\n       if (kind != 0\n \t  && current_class_ptr\n@@ -31778,15 +31793,25 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t\t\t  /*declarator_p=*/false,\n \t\t\t\t\t  /*optional_p=*/false);\n \t  if (name == error_mark_node)\n-\t    goto skip_comma;\n+\t    {\n+\t      if (kind == OMP_CLAUSE_DEPEND\n+\t\t  && cp_parser_simulate_error (parser))\n+\t\tgoto depend_lvalue;\n+\t      goto skip_comma;\n+\t    }\n \n \t  if (identifier_p (name))\n \t    decl = cp_parser_lookup_name_simple (parser, name, token->location);\n \t  else\n \t    decl = name;\n \t  if (decl == error_mark_node)\n-\t    cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n-\t\t\t\t\t token->location);\n+\t    {\n+\t      if (kind == OMP_CLAUSE_DEPEND\n+\t\t  && cp_parser_simulate_error (parser))\n+\t\tgoto depend_lvalue;\n+\t      cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n+\t\t\t\t\t   token->location);\n+\t    }\n \t}\n       if (decl == error_mark_node)\n \t;\n@@ -31822,6 +31847,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t      /* FALLTHROUGH.  */\n \t    case OMP_CLAUSE_DEPEND:\n \t    case OMP_CLAUSE_REDUCTION:\n+\t    case OMP_CLAUSE_IN_REDUCTION:\n+\t    case OMP_CLAUSE_TASK_REDUCTION:\n \t      while (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t\t{\n \t\t  tree low_bound = NULL_TREE, length = NULL_TREE;\n@@ -31839,15 +31866,27 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t    {\n \t\t      /* Look for `:'.  */\n \t\t      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n-\t\t\tgoto skip_comma;\n+\t\t\t{\n+\t\t\t  if (kind == OMP_CLAUSE_DEPEND\n+\t\t\t      && cp_parser_simulate_error (parser))\n+\t\t\t    goto depend_lvalue;\n+\t\t\t  goto skip_comma;\n+\t\t\t}\n+\t\t      if (kind == OMP_CLAUSE_DEPEND)\n+\t\t\tcp_parser_commit_to_tentative_parse (parser);\n \t\t      if (!cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t\t   CPP_CLOSE_SQUARE))\n \t\t\tlength = cp_parser_expression (parser);\n \t\t    }\n \t\t  /* Look for the closing `]'.  */\n \t\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t  RT_CLOSE_SQUARE))\n-\t\t    goto skip_comma;\n+\t\t    {\n+\t\t      if (kind == OMP_CLAUSE_DEPEND\n+\t\t\t  && cp_parser_simulate_error (parser))\n+\t\t\tgoto depend_lvalue;\n+\t\t      goto skip_comma;\n+\t\t    }\n \n \t\t  decl = tree_cons (low_bound, length, decl);\n \t\t}\n@@ -31856,6 +31895,21 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t      break;\n \t    }\n \n+\t  if (kind == OMP_CLAUSE_DEPEND)\n+\t    {\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n+\t\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN)\n+\t\t  && cp_parser_simulate_error (parser))\n+\t\t{\n+\t\tdepend_lvalue:\n+\t\t  cp_parser_abort_tentative_parse (parser);\n+\t\t  decl = cp_parser_assignment_expression (parser, NULL,\n+\t\t\t\t\t\t\t  false, false);\n+\t\t}\n+\t      else\n+\t\tcp_parser_parse_definitely (parser);\n+\t    }\n+\n \t  tree u = build_omp_clause (token->location, kind);\n \t  OMP_CLAUSE_DECL (u) = decl;\n \t  OMP_CLAUSE_CHAIN (u) = list;\n@@ -32440,7 +32494,11 @@ cp_parser_omp_clause_final (cp_parser *parser, tree list, location_t location)\n \n    directive-name-modifier:\n      parallel | task | taskloop | target data | target | target update\n-     | target enter data | target exit data  */\n+     | target enter data | target exit data\n+\n+   OpenMP 5.0:\n+   directive-name-modifier:\n+     ... | simd | cancel  */\n \n static tree\n cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,\n@@ -32459,8 +32517,12 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,\n       const char *p = IDENTIFIER_POINTER (id);\n       int n = 2;\n \n-      if (strcmp (\"parallel\", p) == 0)\n+      if (strcmp (\"cancel\", p) == 0)\n+\tif_modifier = VOID_CST;\n+      else if (strcmp (\"parallel\", p) == 0)\n \tif_modifier = OMP_PARALLEL;\n+      else if (strcmp (\"simd\", p) == 0)\n+\tif_modifier = OMP_SIMD;\n       else if (strcmp (\"task\", p) == 0)\n \tif_modifier = OMP_TASK;\n       else if (strcmp (\"taskloop\", p) == 0)\n@@ -32547,7 +32609,9 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,\n \t    const char *p = NULL;\n \t    switch (if_modifier)\n \t      {\n+\t      case VOID_CST: p = \"cancel\"; break;\n \t      case OMP_PARALLEL: p = \"parallel\"; break;\n+\t      case OMP_SIMD: p = \"simd\"; break;\n \t      case OMP_TASK: p = \"task\"; break;\n \t      case OMP_TASKLOOP: p = \"taskloop\"; break;\n \t      case OMP_TARGET_DATA: p = \"target data\"; break;\n@@ -32774,55 +32838,174 @@ cp_parser_omp_clause_hint (cp_parser *parser, tree list,\n }\n \n /* OpenMP 4.5:\n-   defaultmap ( tofrom : scalar ) */\n+   defaultmap ( tofrom : scalar )\n+\n+   OpenMP 5.0:\n+   defaultmap ( implicit-behavior [ : variable-category ] ) */\n \n static tree\n cp_parser_omp_clause_defaultmap (cp_parser *parser, tree list,\n \t\t\t\t location_t location)\n {\n   tree c, id;\n   const char *p;\n+  enum omp_clause_defaultmap_kind behavior = OMP_CLAUSE_DEFAULTMAP_DEFAULT;\n+  enum omp_clause_defaultmap_kind category\n+    = OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n     return list;\n \n-  if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DEFAULT))\n+    p = \"default\";\n+  else if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n-      cp_parser_error (parser, \"expected %<tofrom%>\");\n+    invalid_behavior:\n+      cp_parser_error (parser, \"expected %<alloc%>, %<to%>, %<from%>, \"\n+\t\t\t       \"%<tofrom%>, %<firstprivate%>, %<none%> \"\n+\t\t\t       \"or %<default%>\");\n       goto out_err;\n     }\n-  id = cp_lexer_peek_token (parser->lexer)->u.value;\n-  p = IDENTIFIER_POINTER (id);\n-  if (strcmp (p, \"tofrom\") != 0)\n+  else\n     {\n-      cp_parser_error (parser, \"expected %<tofrom%>\");\n-      goto out_err;\n+      id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      p = IDENTIFIER_POINTER (id);\n     }\n-  cp_lexer_consume_token (parser->lexer);\n-  if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n-    goto out_err;\n \n-  if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  switch (p[0])\n     {\n-      cp_parser_error (parser, \"expected %<scalar%>\");\n-      goto out_err;\n+    case 'a':\n+      if (strcmp (\"alloc\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_ALLOC;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 'd':\n+      if (strcmp (\"default\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_DEFAULT;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 'f':\n+      if (strcmp (\"firstprivate\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_FIRSTPRIVATE;\n+      else if (strcmp (\"from\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_FROM;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 'n':\n+      if (strcmp (\"none\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_NONE;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    case 't':\n+      if (strcmp (\"tofrom\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_TOFROM;\n+      else if (strcmp (\"to\", p) == 0)\n+\tbehavior = OMP_CLAUSE_DEFAULTMAP_TO;\n+      else\n+\tgoto invalid_behavior;\n+      break;\n+\n+    default:\n+      goto invalid_behavior;\n     }\n-  id = cp_lexer_peek_token (parser->lexer)->u.value;\n-  p = IDENTIFIER_POINTER (id);\n-  if (strcmp (p, \"scalar\") != 0)\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n     {\n-      cp_parser_error (parser, \"expected %<scalar%>\");\n-      goto out_err;\n+      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+\tgoto out_err;\n+\n+      if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t{\n+\tinvalid_category:\n+\t  cp_parser_error (parser, \"expected %<scalar%>, %<aggregate%> or \"\n+\t\t\t\t   \"%<pointer%>\");\n+\t  goto out_err;\n+\t}\n+      id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      p = IDENTIFIER_POINTER (id);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'a':\n+\t  if (strcmp (\"aggregate\", p) == 0)\n+\t    category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE;\n+\t  else\n+\t    goto invalid_category;\n+\t  break;\n+\n+\tcase 'p':\n+\t  if (strcmp (\"pointer\", p) == 0)\n+\t    category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER;\n+\t  else\n+\t    goto invalid_category;\n+\t  break;\n+\n+\tcase 's':\n+\t  if (strcmp (\"scalar\", p) == 0)\n+\t    category = OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR;\n+\t  else\n+\t    goto invalid_category;\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid_category;\n+\t}\n+\n+      cp_lexer_consume_token (parser->lexer);\n     }\n-  cp_lexer_consume_token (parser->lexer);\n   if (!parens.require_close (parser))\n     goto out_err;\n \n-  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, \"defaultmap\",\n-\t\t\t     location);\n+  for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEFAULTMAP\n+\t&& (category == OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED\n+\t    || OMP_CLAUSE_DEFAULTMAP_CATEGORY (c) == category\n+\t    || (OMP_CLAUSE_DEFAULTMAP_CATEGORY (c)\n+\t\t== OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED)))\n+      {\n+\tenum omp_clause_defaultmap_kind cat = category;\n+\tlocation_t loc = OMP_CLAUSE_LOCATION (c);\n+\tif (cat == OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED)\n+\t  cat = OMP_CLAUSE_DEFAULTMAP_CATEGORY (c);\n+\tp = NULL;\n+\tswitch (cat)\n+\t  {\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED:\n+\t    p = NULL;\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE:\n+\t    p = \"aggregate\";\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER:\n+\t    p = \"pointer\";\n+\t    break;\n+\t  case OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR:\n+\t    p = \"scalar\";\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tif (p)\n+\t  error_at (loc, \"too many %<defaultmap%> clauses with %qs category\",\n+\t\t    p);\n+\telse\n+\t  error_at (loc, \"too many %<defaultmap%> clauses with unspecified \"\n+\t\t\t \"category\");\n+\tbreak;\n+      }\n \n   c = build_omp_clause (location, OMP_CLAUSE_DEFAULTMAP);\n+  OMP_CLAUSE_DEFAULTMAP_SET_KIND (c, behavior, category);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n \n@@ -32897,17 +33080,50 @@ cp_parser_omp_clause_ordered (cp_parser *parser,\n \n    reduction-operator:\n      One of: + * - & ^ | && ||\n-     id-expression  */\n+     id-expression\n+\n+   OpenMP 5.0:\n+   reduction ( reduction-modifier, reduction-operator : variable-list )\n+   in_reduction ( reduction-operator : variable-list )\n+   task_reduction ( reduction-operator : variable-list )  */\n \n static tree\n-cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n+cp_parser_omp_clause_reduction (cp_parser *parser, enum omp_clause_code kind,\n+\t\t\t\tbool is_omp, tree list)\n {\n   enum tree_code code = ERROR_MARK;\n   tree nlist, c, id = NULL_TREE;\n+  bool task = false;\n+  bool inscan = false;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n+  if (kind == OMP_CLAUSE_REDUCTION && is_omp)\n+    {\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DEFAULT)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COMMA))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+      else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COMMA))\n+\t{\n+\t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t  const char *p = IDENTIFIER_POINTER (id);\n+\t  if (strcmp (p, \"task\") == 0)\n+\t    task = true;\n+\t  else if (strcmp (p, \"inscan\") == 0)\n+\t    inscan = true;\n+\t  if (task || inscan)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    }\n+\t}\n+    }\n+\n   switch (cp_lexer_peek_token (parser->lexer)->type)\n     {\n     case CPP_PLUS: code = PLUS_EXPR; break;\n@@ -32980,11 +33196,15 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n     goto resync_fail;\n \n-  nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_REDUCTION, list,\n+  nlist = cp_parser_omp_var_list_no_open (parser, kind, list,\n \t\t\t\t\t  NULL);\n   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n     {\n       OMP_CLAUSE_REDUCTION_CODE (c) = code;\n+      if (task)\n+\tOMP_CLAUSE_REDUCTION_TASK (c) = 1;\n+      else if (inscan)\n+\tOMP_CLAUSE_REDUCTION_INSCAN (c) = 1;\n       OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = id;\n     }\n \n@@ -33303,6 +33523,43 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n   return nlist;\n }\n \n+/* OpenMP 2.5:\n+   lastprivate ( variable-list )\n+\n+   OpenMP 5.0:\n+   lastprivate ( [ lastprivate-modifier : ] variable-list )  */\n+\n+static tree\n+cp_parser_omp_clause_lastprivate (cp_parser *parser, tree list)\n+{\n+  bool conditional = false;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_COLON))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (\"conditional\", p) == 0)\n+\t{\n+\t  conditional = true;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n+    }\n+\n+  tree nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_LASTPRIVATE,\n+\t\t\t\t\t       list, NULL);\n+\n+  if (conditional)\n+    for (tree c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 1;\n+  return nlist;\n+}\n+\n /* OpenMP 4.0:\n    linear ( variable-list )\n    linear ( variable-list : expression )\n@@ -33545,6 +33802,118 @@ cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n   return list;\n }\n \n+/* OpenMP 5.0:\n+   iterators ( iterators-definition )\n+\n+   iterators-definition:\n+     iterator-specifier\n+     iterator-specifier , iterators-definition\n+\n+   iterator-specifier:\n+     identifier = range-specification\n+     iterator-type identifier = range-specification\n+\n+   range-specification:\n+     begin : end\n+     begin : end : step  */\n+\n+static tree\n+cp_parser_omp_iterators (cp_parser *parser)\n+{\n+  tree ret = NULL_TREE, *last = &ret;\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return error_mark_node;\n+\n+  bool saved_colon_corrects_to_scope_p\n+    = parser->colon_corrects_to_scope_p;\n+  bool saved_colon_doesnt_start_class_def_p\n+    = parser->colon_doesnt_start_class_def_p;\n+\n+  do\n+    {\n+      tree iter_type;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_EQ))\n+\titer_type = integer_type_node;\n+      else\n+\t{\n+\t  const char *saved_message\n+\t    = parser->type_definition_forbidden_message;\n+\t  parser->type_definition_forbidden_message\n+\t    = G_(\"types may not be defined in iterator type\");\n+\n+\t  iter_type = cp_parser_type_id (parser);\n+\n+\t  parser->type_definition_forbidden_message = saved_message;\n+\t}\n+\n+      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\t{\n+\t  cp_parser_error (parser, \"expected identifier\");\n+\t  break;\n+\t}\n+\n+      tree id = cp_parser_identifier (parser);\n+      if (id == error_mark_node)\n+\tbreak;\n+\n+      if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+\tbreak;\n+\n+      parser->colon_corrects_to_scope_p = false;\n+      parser->colon_doesnt_start_class_def_p = true;\n+      tree begin = cp_parser_assignment_expression (parser);\n+\n+      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+\tbreak;\n+\n+      tree end = cp_parser_assignment_expression (parser);\n+\n+      tree step = integer_one_node;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  step = cp_parser_assignment_expression (parser);\n+\t}\n+\n+      tree iter_var = build_decl (loc, VAR_DECL, id, iter_type);\n+      DECL_ARTIFICIAL (iter_var) = 1;\n+      DECL_CONTEXT (iter_var) = current_function_decl;\n+      pushdecl (iter_var);\n+\n+      *last = make_tree_vec (6);\n+      TREE_VEC_ELT (*last, 0) = iter_var;\n+      TREE_VEC_ELT (*last, 1) = begin;\n+      TREE_VEC_ELT (*last, 2) = end;\n+      TREE_VEC_ELT (*last, 3) = step;\n+      last = &TREE_CHAIN (*last);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  while (1);\n+\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+  parser->colon_doesnt_start_class_def_p\n+    = saved_colon_doesnt_start_class_def_p;\n+\n+  if (!parens.require_close (parser))\n+    cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t   /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  return ret ? ret : error_mark_node;\n+}\n+\n /* OpenMP 4.0:\n    depend ( depend-kind : variable-list )\n \n@@ -33554,41 +33923,73 @@ cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n    OpenMP 4.5:\n    depend ( source )\n \n-   depend ( sink : vec ) */\n+   depend ( sink : vec )\n+\n+   OpenMP 5.0:\n+   depend ( depend-modifier , depend-kind: variable-list )\n+\n+   depend-kind:\n+     in | out | inout | mutexinoutset | depobj\n+\n+   depend-modifier:\n+     iterator ( iterators-definition )  */\n \n static tree\n cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n {\n-  tree nlist, c;\n-  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;\n+  tree nlist, c, iterators = NULL_TREE;\n+  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_LAST;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n     return list;\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  do\n     {\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\tgoto invalid_kind;\n+\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n \n+      if (strcmp (\"iterator\", p) == 0 && iterators == NULL_TREE)\n+\t{\n+\t  begin_scope (sk_omp, NULL);\n+\t  iterators = cp_parser_omp_iterators (parser);\n+\t  cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n+\t  continue;\n+\t}\n       if (strcmp (\"in\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_IN;\n       else if (strcmp (\"inout\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_INOUT;\n+      else if (strcmp (\"mutexinoutset\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n       else if (strcmp (\"out\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_OUT;\n-      else if (strcmp (\"source\", p) == 0)\n-\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n+      else if (strcmp (\"depobj\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_DEPOBJ;\n       else if (strcmp (\"sink\", p) == 0)\n \tkind = OMP_CLAUSE_DEPEND_SINK;\n+      else if (strcmp (\"source\", p) == 0)\n+\tkind = OMP_CLAUSE_DEPEND_SOURCE;\n       else\n \tgoto invalid_kind;\n+      break;\n     }\n-  else\n-    goto invalid_kind;\n+  while (1);\n \n   cp_lexer_consume_token (parser->lexer);\n \n+  if (iterators\n+      && (kind == OMP_CLAUSE_DEPEND_SOURCE || kind == OMP_CLAUSE_DEPEND_SINK))\n+    {\n+      poplevel (0, 1, 0);\n+      error_at (loc, \"%<iterator%> modifier incompatible with %qs\",\n+\t\tkind == OMP_CLAUSE_DEPEND_SOURCE ? \"source\" : \"sink\");\n+      iterators = NULL_TREE;\n+    }\n+\n   if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n     {\n       c = build_omp_clause (loc, OMP_CLAUSE_DEPEND);\n@@ -33612,14 +34013,30 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n       nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_DEPEND,\n \t\t\t\t\t      list, NULL);\n \n+      if (iterators)\n+\t{\n+\t  tree block = poplevel (1, 1, 0);\n+\t  if (iterators == error_mark_node)\n+\t    iterators = NULL_TREE;\n+\t  else\n+\t    TREE_VEC_ELT (iterators, 5) = block;\n+\t}\n+\n       for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n-\tOMP_CLAUSE_DEPEND_KIND (c) = kind;\n+\t{\n+\t  OMP_CLAUSE_DEPEND_KIND (c) = kind;\n+\t  if (iterators)\n+\t    OMP_CLAUSE_DECL (c)\n+\t      = build_tree_list (iterators, OMP_CLAUSE_DECL (c));\n+\t}\n     }\n   return nlist;\n \n  invalid_kind:\n   cp_parser_error (parser, \"invalid depend kind\");\n  resync_fail:\n+  if (iterators)\n+    poplevel (0, 1, 0);\n   cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t /*or_comma=*/false,\n \t\t\t\t\t /*consume_paren=*/true);\n@@ -34022,7 +34439,9 @@ cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"private\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_REDUCTION:\n-\t  clauses = cp_parser_omp_clause_reduction (parser, clauses);\n+\t  clauses\n+\t    = cp_parser_omp_clause_reduction (parser, OMP_CLAUSE_REDUCTION,\n+\t\t\t\t\t      false, clauses);\n \t  c_name = \"reduction\";\n \t  break;\n \tcase PRAGMA_OACC_CLAUSE_SEQ:\n@@ -34169,9 +34588,14 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t     true);\n \t  c_name = \"if\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_IN_REDUCTION:\n+\t  clauses\n+\t    = cp_parser_omp_clause_reduction (parser, OMP_CLAUSE_IN_REDUCTION,\n+\t\t\t\t\t      true, clauses);\n+\t  c_name = \"in_reduction\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n-\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LASTPRIVATE,\n-\t\t\t\t\t    clauses);\n+\t  clauses = cp_parser_omp_clause_lastprivate (parser, clauses);\n \t  c_name = \"lastprivate\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_MERGEABLE:\n@@ -34209,7 +34633,9 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"private\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_REDUCTION:\n-\t  clauses = cp_parser_omp_clause_reduction (parser, clauses);\n+\t  clauses\n+\t    = cp_parser_omp_clause_reduction (parser, OMP_CLAUSE_REDUCTION,\n+\t\t\t\t\t      true, clauses);\n \t  c_name = \"reduction\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_SCHEDULE:\n@@ -34222,6 +34648,13 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t    clauses);\n \t  c_name = \"shared\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_TASK_REDUCTION:\n+\t  clauses\n+\t    = cp_parser_omp_clause_reduction (parser,\n+\t\t\t\t\t      OMP_CLAUSE_TASK_REDUCTION,\n+\t\t\t\t\t      true, clauses);\n+\t  c_name = \"task_reduction\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_UNTIED:\n \t  clauses = cp_parser_omp_clause_untied (parser, clauses,\n \t\t\t\t\t\t token->location);\n@@ -34232,6 +34665,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t clauses, token->location);\n \t  c_name = \"inbranch\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NONTEMPORAL:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_NONTEMPORAL,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"nontemporal\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOTINBRANCH:\n \t  clauses = cp_parser_omp_clause_branch (parser,\n \t\t\t\t\t\t OMP_CLAUSE_NOTINBRANCH,\n@@ -34494,62 +34932,154 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n {\n   tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE, lhs1 = NULL_TREE;\n   tree rhs1 = NULL_TREE, orig_lhs;\n-  enum tree_code code = OMP_ATOMIC, opcode = NOP_EXPR;\n+  location_t loc = pragma_tok->location;\n+  enum tree_code code = ERROR_MARK, opcode = NOP_EXPR;\n+  enum omp_memory_order memory_order = OMP_MEMORY_ORDER_UNSPECIFIED;\n   bool structured_block = false;\n-  bool seq_cst = false;\n-\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n-    {\n-      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n-      const char *p = IDENTIFIER_POINTER (id);\n-\n-      if (!strcmp (p, \"seq_cst\"))\n-\t{\n-\t  seq_cst = true;\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n-\t      && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME)\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t}\n-    }\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n-    {\n-      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n-      const char *p = IDENTIFIER_POINTER (id);\n+  bool first = true;\n+  tree clauses = NULL_TREE;\n \n-      if (!strcmp (p, \"read\"))\n-\tcode = OMP_ATOMIC_READ;\n-      else if (!strcmp (p, \"write\"))\n-\tcode = NOP_EXPR;\n-      else if (!strcmp (p, \"update\"))\n-\tcode = OMP_ATOMIC;\n-      else if (!strcmp (p, \"capture\"))\n-\tcode = OMP_ATOMIC_CAPTURE_NEW;\n-      else\n-\tp = NULL;\n-      if (p)\n-\tcp_lexer_consume_token (parser->lexer);\n-    }\n-  if (!seq_cst)\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n-\t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME)\n+      if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \tcp_lexer_consume_token (parser->lexer);\n \n+      first = false;\n+\n       if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t{\n \t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t  location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n \t  const char *p = IDENTIFIER_POINTER (id);\n-\n-\t  if (!strcmp (p, \"seq_cst\"))\n+\t  enum tree_code new_code = ERROR_MARK;\n+\t  enum omp_memory_order new_memory_order\n+\t    = OMP_MEMORY_ORDER_UNSPECIFIED;\n+\n+\t  if (!strcmp (p, \"read\"))\n+\t    new_code = OMP_ATOMIC_READ;\n+\t  else if (!strcmp (p, \"write\"))\n+\t    new_code = NOP_EXPR;\n+\t  else if (!strcmp (p, \"update\"))\n+\t    new_code = OMP_ATOMIC;\n+\t  else if (!strcmp (p, \"capture\"))\n+\t    new_code = OMP_ATOMIC_CAPTURE_NEW;\n+\t  else if (!strcmp (p, \"seq_cst\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  else if (!strcmp (p, \"acq_rel\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_ACQ_REL;\n+\t  else if (!strcmp (p, \"release\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_RELEASE;\n+\t  else if (!strcmp (p, \"acquire\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n+\t  else if (!strcmp (p, \"relaxed\"))\n+\t    new_memory_order = OMP_MEMORY_ORDER_RELAXED;\n+\t  else if (!strcmp (p, \"hint\"))\n \t    {\n-\t      seq_cst = true;\n \t      cp_lexer_consume_token (parser->lexer);\n+\t      clauses = cp_parser_omp_clause_hint (parser, clauses, cloc);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      p = NULL;\n+\t      error_at (cloc, \"expected %<read%>, %<write%>, %<update%>, \"\n+\t\t\t      \"%<capture%>, %<seq_cst%>, %<acq_rel%>, \"\n+\t\t\t      \"%<release%>, %<relaxed%> or %<hint%> clause\");\n+\t    }\n+\t  if (p)\n+\t    {\n+\t      if (new_code != ERROR_MARK)\n+\t\t{\n+\t\t  if (code != ERROR_MARK)\n+\t\t    error_at (cloc, \"too many atomic clauses\");\n+\t\t  else\n+\t\t    code = new_code;\n+\t\t}\n+\t      else if (new_memory_order != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t{\n+\t\t  if (memory_order != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t    error_at (cloc, \"too many memory order clauses\");\n+\t\t  else\n+\t\t    memory_order = new_memory_order;\n+\t\t}\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      continue;\n \t    }\n \t}\n+      break;\n     }\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n+  if (code == ERROR_MARK)\n+    code = OMP_ATOMIC;\n+  if (memory_order == OMP_MEMORY_ORDER_UNSPECIFIED)\n+    {\n+      omp_requires_mask\n+\t= (enum omp_requires) (omp_requires_mask\n+\t\t\t       | OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER_USED);\n+      switch ((enum omp_memory_order)\n+\t      (omp_requires_mask & OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER))\n+\t{\n+\tcase OMP_MEMORY_ORDER_UNSPECIFIED:\n+\tcase OMP_MEMORY_ORDER_RELAXED:\n+\t  memory_order = OMP_MEMORY_ORDER_RELAXED;\n+\t  break;\n+\tcase OMP_MEMORY_ORDER_SEQ_CST:\n+\t  memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  break;\n+\tcase OMP_MEMORY_ORDER_ACQ_REL:\n+\t  switch (code)\n+\t    {\n+\t    case OMP_ATOMIC_READ:\n+\t      memory_order = OMP_MEMORY_ORDER_ACQUIRE;\n+\t      break;\n+\t    case NOP_EXPR: /* atomic write */\n+\t    case OMP_ATOMIC:\n+\t      memory_order = OMP_MEMORY_ORDER_RELEASE;\n+\t      break;\n+\t    default:\n+\t      memory_order = OMP_MEMORY_ORDER_ACQ_REL;\n+\t      break;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    switch (code)\n+      {\n+      case OMP_ATOMIC_READ:\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n+\t    || memory_order == OMP_MEMORY_ORDER_RELEASE)\n+\t  {\n+\t    error_at (loc, \"%<#pragma omp atomic read%> incompatible with \"\n+\t\t\t   \"%<acq_rel%> or %<release%> clauses\");\n+\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      case NOP_EXPR: /* atomic write */\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n+\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n+\t  {\n+\t    error_at (loc, \"%<#pragma omp atomic write%> incompatible with \"\n+\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n+\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      case OMP_ATOMIC:\n+\tif (memory_order == OMP_MEMORY_ORDER_ACQ_REL\n+\t    || memory_order == OMP_MEMORY_ORDER_ACQUIRE)\n+\t  {\n+\t    error_at (loc, \"%<#pragma omp atomic update%> incompatible with \"\n+\t\t\t   \"%<acq_rel%> or %<acquire%> clauses\");\n+\t    memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n   switch (code)\n     {\n     case OMP_ATOMIC_READ:\n@@ -34849,7 +35379,9 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n       cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n     }\n done:\n-  finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1, seq_cst);\n+  clauses = finish_omp_clauses (clauses, C_ORT_OMP);\n+  finish_omp_atomic (pragma_tok->location, code, opcode, lhs, rhs, v, lhs1,\n+\t\t     rhs1, clauses, memory_order);\n   if (!structured_block)\n     cp_parser_consume_semicolon_at_end_of_statement (parser);\n   return;\n@@ -34911,6 +35443,10 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n       if (name == error_mark_node)\n \tname = NULL;\n \n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n       clauses = cp_parser_omp_all_clauses (parser,\n \t\t\t\t\t   OMP_CRITICAL_CLAUSE_MASK,\n \t\t\t\t\t   \"#pragma omp critical\", pragma_tok);\n@@ -34922,26 +35458,151 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n   return c_finish_omp_critical (input_location, stmt, name, clauses);\n }\n \n+/* OpenMP 5.0:\n+   # pragma omp depobj ( depobj ) depobj-clause new-line\n+\n+   depobj-clause:\n+     depend (dependence-type : locator)\n+     destroy\n+     update (dependence-type)\n+\n+   dependence-type:\n+     in\n+     out\n+     inout\n+     mutexinout  */\n+\n+static void\n+cp_parser_omp_depobj (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  location_t loc = pragma_tok->location;\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return;\n+    }\n+\n+  tree depobj = cp_parser_assignment_expression (parser);\n+\n+  if (!parens.require_close (parser))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  tree clause = NULL_TREE;\n+  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n+  location_t c_loc = cp_lexer_peek_token (parser->lexer)->location;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      if (!strcmp (\"depend\", p))\n+\t{\n+\t  clause = cp_parser_omp_clause_depend (parser, NULL_TREE, c_loc);\n+\t  if (clause)\n+\t    clause = finish_omp_clauses (clause, C_ORT_OMP);\n+\t  if (!clause)\n+\t    clause = error_mark_node;\n+\t}\n+      else if (!strcmp (\"destroy\", p))\n+\tkind = OMP_CLAUSE_DEPEND_LAST;\n+      else if (!strcmp (\"update\", p))\n+\t{\n+\t  matching_parens c_parens;\n+\t  if (c_parens.require_open (parser))\n+\t    {\n+\t      location_t c2_loc\n+\t\t= cp_lexer_peek_token (parser->lexer)->location;\n+\t      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t\t{\n+\t\t  tree id2 = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  const char *p2 = IDENTIFIER_POINTER (id2);\n+\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  if (!strcmp (\"in\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_IN;\n+\t\t  else if (!strcmp (\"out\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_OUT;\n+\t\t  else if (!strcmp (\"inout\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_INOUT;\n+\t\t  else if (!strcmp (\"mutexinoutset\", p2))\n+\t\t    kind = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n+\t\t}\n+\t      if (kind == OMP_CLAUSE_DEPEND_SOURCE)\n+\t\t{\n+\t\t  clause = error_mark_node;\n+\t\t  error_at (c2_loc, \"expected %<in%>, %<out%>, %<inout%> or \"\n+\t\t\t\t    \"%<mutexinoutset%>\");\n+\t\t}\n+\t      if (!c_parens.require_close (parser))\n+\t\tcp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t       /*recovering=*/true,\n+\t\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t\t       /*consume_paren=*/true);\n+\t    }\n+\t  else\n+\t    clause = error_mark_node;\n+\t}\n+    }\n+  if (!clause && kind == OMP_CLAUSE_DEPEND_SOURCE)\n+    {\n+      clause = error_mark_node;\n+      error_at (c_loc, \"expected %<depend%>, %<destroy%> or %<update%> clause\");\n+    }\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  finish_omp_depobj (loc, depobj, kind, clause);\n+}\n+\n+\n /* OpenMP 2.5:\n    # pragma omp flush flush-vars[opt] new-line\n \n    flush-vars:\n-     ( variable-list ) */\n+     ( variable-list )\n+\n+   OpenMP 5.0:\n+   # pragma omp flush memory-order-clause new-line  */\n \n static void\n cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n {\n+  enum memmodel mo = MEMMODEL_LAST;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      if (!strcmp (p, \"acq_rel\"))\n+\tmo = MEMMODEL_ACQ_REL;\n+      else if (!strcmp (p, \"release\"))\n+\tmo = MEMMODEL_RELEASE;\n+      else if (!strcmp (p, \"acquire\"))\n+\tmo = MEMMODEL_ACQUIRE;\n+      else\n+\terror_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t  \"expected %<acq_rel%>, %<release%> or %<acquire%>\");\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-    (void) cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);\n+    {\n+      if (mo != MEMMODEL_LAST)\n+\terror_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t  \"%<flush%> list specified together with memory order \"\n+\t\t  \"clause\");\n+      (void) cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);\n+    }\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n-  finish_omp_flush ();\n+  finish_omp_flush (mo);\n }\n \n /* Helper function, to parse omp for increment expression.  */\n \n static tree\n-cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n+cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n {\n   tree cond = cp_parser_binary_expression (parser, false, true,\n \t\t\t\t\t   PREC_NOT_OPERATOR, NULL);\n@@ -34960,7 +35621,8 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n     case LE_EXPR:\n       break;\n     case NE_EXPR:\n-      /* Fall through: OpenMP disallows NE_EXPR.  */\n+      if (code != OACC_LOOP)\n+\tbreak;\n       gcc_fallthrough ();\n     default:\n       return error_mark_node;\n@@ -35304,14 +35966,201 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n   return add_private_clause;\n }\n \n+/* Helper for cp_parser_omp_for_loop, handle one range-for loop.  */\n+\n+void\n+cp_convert_omp_range_for (tree &this_pre_body, vec<tree, va_gc> *for_block,\n+\t\t\t  tree &decl, tree &orig_decl, tree &init,\n+\t\t\t  tree &orig_init, tree &cond, tree &incr)\n+{\n+  tree begin, end, range_temp_decl = NULL_TREE;\n+  tree iter_type, begin_expr, end_expr;\n+\n+  if (processing_template_decl)\n+    {\n+      if (check_for_bare_parameter_packs (init))\n+\tinit = error_mark_node;\n+      if (!type_dependent_expression_p (init)\n+\t  /* do_auto_deduction doesn't mess with template init-lists.  */\n+\t  && !BRACE_ENCLOSED_INITIALIZER_P (init))\n+\t{\n+\t  tree d = decl;\n+\t  if (decl != error_mark_node && DECL_HAS_VALUE_EXPR_P (decl))\n+\t    {\n+\t      tree v = DECL_VALUE_EXPR (decl);\n+\t      if (TREE_CODE (v) == ARRAY_REF\n+\t\t  && VAR_P (TREE_OPERAND (v, 0))\n+\t\t  && DECL_DECOMPOSITION_P (TREE_OPERAND (v, 0)))\n+\t\td = TREE_OPERAND (v, 0);\n+\t    }\n+\t  do_range_for_auto_deduction (d, init);\n+\t}\n+      cond = global_namespace;\n+      incr = NULL_TREE;\n+      orig_init = init;\n+      if (this_pre_body)\n+\tthis_pre_body = pop_stmt_list (this_pre_body);\n+      return;\n+    }\n+\n+  init = mark_lvalue_use (init);\n+\n+  if (decl == error_mark_node || init == error_mark_node)\n+    /* If an error happened previously do nothing or else a lot of\n+       unhelpful errors would be issued.  */\n+    begin_expr = end_expr = iter_type = error_mark_node;\n+  else\n+    {\n+      tree range_temp;\n+\n+      if (VAR_P (init)\n+\t  && array_of_runtime_bound_p (TREE_TYPE (init)))\n+\t/* Can't bind a reference to an array of runtime bound.  */\n+\trange_temp = init;\n+      else\n+\t{\n+\t  range_temp = build_range_temp (init);\n+\t  DECL_NAME (range_temp) = NULL_TREE;\n+\t  pushdecl (range_temp);\n+\t  cp_finish_decl (range_temp, init,\n+\t\t\t  /*is_constant_init*/false, NULL_TREE,\n+\t\t\t  LOOKUP_ONLYCONVERTING);\n+\t  range_temp_decl = range_temp;\n+\t  range_temp = convert_from_reference (range_temp);\n+\t}\n+      iter_type = cp_parser_perform_range_for_lookup (range_temp,\n+\t\t\t\t\t\t      &begin_expr, &end_expr);\n+    }\n+\n+  tree end_iter_type = iter_type;\n+  if (cxx_dialect >= cxx17)\n+    end_iter_type = cv_unqualified (TREE_TYPE (end_expr));\n+  end = build_decl (input_location, VAR_DECL, NULL_TREE, end_iter_type);\n+  TREE_USED (end) = 1;\n+  DECL_ARTIFICIAL (end) = 1;\n+  pushdecl (end);\n+  cp_finish_decl (end, end_expr,\n+\t\t  /*is_constant_init*/false, NULL_TREE,\n+\t\t  LOOKUP_ONLYCONVERTING);\n+\n+  /* The new for initialization statement.  */\n+  begin = build_decl (input_location, VAR_DECL, NULL_TREE, iter_type);\n+  TREE_USED (begin) = 1;\n+  DECL_ARTIFICIAL (begin) = 1;\n+  pushdecl (begin);\n+  orig_init = init;\n+  if (CLASS_TYPE_P (iter_type))\n+    init = NULL_TREE;\n+  else\n+    {\n+      init = begin_expr;\n+      begin_expr = NULL_TREE;\n+    }\n+  cp_finish_decl (begin, begin_expr,\n+\t\t  /*is_constant_init*/false, NULL_TREE,\n+\t\t  LOOKUP_ONLYCONVERTING);\n+\n+  /* The new for condition.  */\n+  if (CLASS_TYPE_P (iter_type))\n+    cond = build2 (NE_EXPR, boolean_type_node, begin, end);\n+  else\n+    cond = build_x_binary_op (input_location, NE_EXPR,\n+\t\t\t      begin, ERROR_MARK,\n+\t\t\t      end, ERROR_MARK,\n+\t\t\t      NULL, tf_warning_or_error);\n+\n+  /* The new increment expression.  */\n+  if (CLASS_TYPE_P (iter_type))\n+    incr = build2 (PREINCREMENT_EXPR, iter_type, begin, NULL_TREE);\n+  else\n+    incr = finish_unary_op_expr (input_location,\n+\t\t\t\t PREINCREMENT_EXPR, begin,\n+\t\t\t\t tf_warning_or_error);\n+\n+  orig_decl = decl;\n+  decl = begin;\n+  if (for_block)\n+    {\n+      vec_safe_push (for_block, this_pre_body);\n+      this_pre_body = NULL_TREE;\n+    }\n+\n+  tree decomp_first_name = NULL_TREE;\n+  unsigned decomp_cnt = 0;\n+  if (orig_decl != error_mark_node && DECL_HAS_VALUE_EXPR_P (orig_decl))\n+    {\n+      tree v = DECL_VALUE_EXPR (orig_decl);\n+      if (TREE_CODE (v) == ARRAY_REF\n+\t  && VAR_P (TREE_OPERAND (v, 0))\n+\t  && DECL_DECOMPOSITION_P (TREE_OPERAND (v, 0)))\n+\t{\n+\t  tree d = orig_decl;\n+\t  orig_decl = TREE_OPERAND (v, 0);\n+\t  decomp_cnt = tree_to_uhwi (TREE_OPERAND (v, 1)) + 1;\n+\t  decomp_first_name = d;\n+\t}\n+    }\n+\n+  tree auto_node = type_uses_auto (TREE_TYPE (orig_decl));\n+  if (auto_node)\n+    {\n+      tree t = build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n+\t\t\t\t     tf_none);\n+      if (!error_operand_p (t))\n+\tTREE_TYPE (orig_decl) = do_auto_deduction (TREE_TYPE (orig_decl),\n+\t\t\t\t\t\t   t, auto_node);\n+    }\n+\n+  tree v = make_tree_vec (decomp_cnt + 3);\n+  TREE_VEC_ELT (v, 0) = range_temp_decl;\n+  TREE_VEC_ELT (v, 1) = end;\n+  TREE_VEC_ELT (v, 2) = orig_decl;\n+  for (unsigned i = 0; i < decomp_cnt; i++)\n+    {\n+      TREE_VEC_ELT (v, i + 3) = decomp_first_name;\n+      decomp_first_name = DECL_CHAIN (decomp_first_name);\n+    }\n+  orig_decl = tree_cons (NULL_TREE, NULL_TREE, v);\n+}\n+\n+/* Helper for cp_parser_omp_for_loop, finalize part of range for\n+   inside of the collapsed body.  */\n+\n+void\n+cp_finish_omp_range_for (tree orig, tree begin)\n+{\n+  gcc_assert (TREE_CODE (orig) == TREE_LIST\n+\t      && TREE_CODE (TREE_CHAIN (orig)) == TREE_VEC);\n+  tree decl = TREE_VEC_ELT (TREE_CHAIN (orig), 2);\n+  tree decomp_first_name = NULL_TREE;\n+  unsigned int decomp_cnt = 0;\n+\n+  if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n+    {\n+      decomp_first_name = TREE_VEC_ELT (TREE_CHAIN (orig), 3);\n+      decomp_cnt = TREE_VEC_LENGTH (TREE_CHAIN (orig)) - 3;\n+      cp_maybe_mangle_decomp (decl, decomp_first_name, decomp_cnt);\n+    }\n+\n+  /* The declaration is initialized with *__begin inside the loop body.  */\n+  cp_finish_decl (decl,\n+\t\t  build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n+\t\t\t\t\ttf_warning_or_error),\n+\t\t  /*is_constant_init*/false, NULL_TREE,\n+\t\t  LOOKUP_ONLYCONVERTING);\n+  if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n+    cp_finish_decomp (decl, decomp_first_name, decomp_cnt);\n+}\n+\n /* Parse the restricted form of the for statement allowed by OpenMP.  */\n \n static tree\n cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t\t\ttree *cclauses, bool *if_p)\n {\n   tree init, orig_init, cond, incr, body, decl, pre_body = NULL_TREE, ret;\n-  tree real_decl, initv, condv, incrv, declv;\n+  tree orig_decl;\n+  tree real_decl, initv, condv, incrv, declv, orig_declv;\n   tree this_pre_body, cl, ordered_cl = NULL_TREE;\n   location_t loc_first;\n   bool collapse_err = false;\n@@ -35364,6 +36213,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n   initv = make_tree_vec (count);\n   condv = make_tree_vec (count);\n   incrv = make_tree_vec (count);\n+  orig_declv = NULL_TREE;\n \n   loc_first = cp_lexer_peek_token (parser->lexer)->location;\n \n@@ -35385,9 +36235,71 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       if (!parens.require_open (parser))\n \treturn NULL;\n \n-      init = orig_init = decl = real_decl = NULL;\n+      init = orig_init = decl = real_decl = orig_decl = NULL_TREE;\n       this_pre_body = push_stmt_list ();\n \n+      if (code != OACC_LOOP && cxx_dialect >= cxx11)\n+\t{\n+\t  /* Save tokens so that we can put them back.  */\n+\t  cp_lexer_save_tokens (parser->lexer);\n+\n+\t  /* Look for ':' that is not nested in () or {}.  */\n+\t  bool is_range_for\n+\t    = (cp_parser_skip_to_closing_parenthesis_1 (parser,\n+\t\t\t\t\t\t\t/*recovering=*/false,\n+\t\t\t\t\t\t\tCPP_COLON,\n+\t\t\t\t\t\t\t/*consume_paren=*/\n+\t\t\t\t\t\t\tfalse) == -1);\n+\n+\t  /* Roll back the tokens we skipped.  */\n+\t  cp_lexer_rollback_tokens (parser->lexer);\n+\n+\t  if (is_range_for)\n+\t    {\n+\t      bool saved_colon_corrects_to_scope_p\n+\t\t= parser->colon_corrects_to_scope_p;\n+\n+\t      /* A colon is used in range-based for.  */\n+\t      parser->colon_corrects_to_scope_p = false;\n+\n+\t      /* Parse the declaration.  */\n+\t      cp_parser_simple_declaration (parser,\n+\t\t\t\t\t    /*function_definition_allowed_p=*/\n+\t\t\t\t\t    false, &decl);\n+\t      parser->colon_corrects_to_scope_p\n+\t\t= saved_colon_corrects_to_scope_p;\n+\n+\t      cp_parser_require (parser, CPP_COLON, RT_COLON);\n+\n+\t      init = cp_parser_range_for (parser, NULL_TREE, NULL_TREE, decl,\n+\t\t\t\t\t  false, 0, true);\n+\n+\t      cp_convert_omp_range_for (this_pre_body, for_block, decl,\n+\t\t\t\t\torig_decl, init, orig_init,\n+\t\t\t\t\tcond, incr);\n+\t      if (this_pre_body)\n+\t\t{\n+\t\t  if (pre_body)\n+\t\t    {\n+\t\t      tree t = pre_body;\n+\t\t      pre_body = push_stmt_list ();\n+\t\t      add_stmt (t);\n+\t\t      add_stmt (this_pre_body);\n+\t\t      pre_body = pop_stmt_list (pre_body);\n+\t\t    }\n+\t\t  else\n+\t\t    pre_body = this_pre_body;\n+\t\t}\n+\n+\t      if (ordered_cl)\n+\t\terror_at (OMP_CLAUSE_LOCATION (ordered_cl),\n+\t\t\t  \"%<ordered%> clause with parameter on \"\n+\t\t\t  \"range-based %<for%> loop\");\n+\n+\t      goto parse_close_paren;\n+\t    }\n+\t}\n+\n       add_private_clause\n \t= cp_parser_omp_for_loop_init (parser, this_pre_body, for_block,\n \t\t\t\t       init, orig_init, decl, real_decl);\n@@ -35464,7 +36376,8 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t\terror_at (loc, \"iteration variable %qD \"\n \t\t\t  \"should not be firstprivate\",\n \t\t\t  decl);\n-\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t      else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t\t|| OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION)\n \t\t       && OMP_CLAUSE_DECL (c) == decl)\n \t\terror_at (loc, \"iteration variable %qD should not be reduction\",\n \t\t\t  decl);\n@@ -35493,7 +36406,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n       cond = NULL;\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\tcond = cp_parser_omp_for_cond (parser, decl);\n+\tcond = cp_parser_omp_for_cond (parser, decl, code);\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n       incr = NULL;\n@@ -35513,6 +36426,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t    protected_set_expr_location (incr, input_location);\n \t}\n \n+    parse_close_paren:\n       if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n@@ -35527,6 +36441,14 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t  orig_inits.safe_grow_cleared (i + 1);\n \t  orig_inits[i] = orig_init;\n \t}\n+      if (orig_decl)\n+\t{\n+\t  if (!orig_declv)\n+\t    orig_declv = copy_node (declv);\n+\t  TREE_VEC_ELT (orig_declv, i) = orig_decl;\n+\t}\n+      else if (orig_declv)\n+\tTREE_VEC_ELT (orig_declv, i) = decl;\n \n       if (i == count - 1)\n \tbreak;\n@@ -35575,15 +36497,27 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n   /* Note that the grammar doesn't call for a structured block here,\n      though the loop as a whole is a structured block.  */\n-  body = push_stmt_list ();\n+  if (orig_declv)\n+    {\n+      body = begin_omp_structured_block ();\n+      for (i = 0; i < count; i++)\n+\tif (TREE_VEC_ELT (orig_declv, i) != TREE_VEC_ELT (declv, i))\n+\t  cp_finish_omp_range_for (TREE_VEC_ELT (orig_declv, i),\n+\t\t\t\t   TREE_VEC_ELT (declv, i));\n+    }\n+  else\n+    body = push_stmt_list ();\n   cp_parser_statement (parser, NULL_TREE, false, if_p);\n-  body = pop_stmt_list (body);\n+  if (orig_declv)\n+    body = finish_omp_structured_block (body);\n+  else\n+    body = pop_stmt_list (body);\n \n   if (declv == NULL_TREE)\n     ret = NULL_TREE;\n   else\n-    ret = finish_omp_for (loc_first, code, declv, NULL, initv, condv, incrv,\n-\t\t\t  body, pre_body, &orig_inits, clauses);\n+    ret = finish_omp_for (loc_first, code, declv, orig_declv, initv, condv,\n+\t\t\t  incrv, body, pre_body, &orig_inits, clauses);\n \n   while (nbraces)\n     {\n@@ -35647,7 +36581,9 @@ cp_omp_split_clauses (location_t loc, enum tree_code code,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NONTEMPORAL))\n \n static tree\n cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n@@ -35678,13 +36614,14 @@ cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,\n \t}\n     }\n \n+  keep_next_level (true);\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n   ret = cp_parser_omp_for_loop (parser, OMP_SIMD, clauses, cclauses, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n-  add_stmt (finish_omp_structured_block (sb));\n+  add_stmt (finish_omp_for_block (finish_omp_structured_block (sb), ret));\n \n   return ret;\n }\n@@ -35777,26 +36714,78 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_FOR];\n     }\n \n+  keep_next_level (true);\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n   ret = cp_parser_omp_for_loop (parser, OMP_FOR, clauses, cclauses, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n-  add_stmt (finish_omp_structured_block (sb));\n+  add_stmt (finish_omp_for_block (finish_omp_structured_block (sb), ret));\n \n   return ret;\n }\n \n+static tree cp_parser_omp_taskloop (cp_parser *, cp_token *, char *,\n+\t\t\t\t    omp_clause_mask, tree *, bool *);\n+\n /* OpenMP 2.5:\n    # pragma omp master new-line\n      structured-block  */\n \n static tree\n-cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n+cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok,\n+\t\t      char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t      bool *if_p)\n {\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n-  return c_finish_omp_master (input_location,\n+  tree clauses, sb, ret;\n+  unsigned int save;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  strcat (p_name, \" master\");\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (p, \"taskloop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t   cclauses, if_p);\n+\t  sb = begin_omp_structured_block ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  ret = cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\tcclauses, if_p);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  tree body = finish_omp_structured_block (sb);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  return c_finish_omp_master (loc, body);\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  if (cclauses)\n+    {\n+      clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n+\t\t\t\t\t   false);\n+      cp_omp_split_clauses (loc, OMP_MASTER, mask, clauses, cclauses);\n+    }\n+  else\n+    cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  return c_finish_omp_master (loc,\n \t\t\t      cp_parser_omp_structured_block (parser, if_p));\n }\n \n@@ -36038,16 +37027,34 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n       cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n       return NULL_TREE;\n     }\n-  else if (!flag_openmp)  /* flag_openmp_simd  */\n-    {\n-      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return NULL_TREE;\n-    }\n   else if (cclauses == NULL && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n-      if (strcmp (p, \"sections\") == 0)\n+      if (strcmp (p, \"master\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  block = begin_omp_parallel ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  tree ret = cp_parser_omp_master (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t   cclauses, if_p);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n+\t\t\t\t      block);\n+\t  OMP_PARALLEL_COMBINED (stmt) = 1;\n+\t  if (ret == NULL_TREE)\n+\t    return ret;\n+\t  return stmt;\n+\t}\n+      else if (!flag_openmp)  /* flag_openmp_simd  */\n+\t{\n+\t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\t  return NULL_TREE;\n+\t}\n+      else if (strcmp (p, \"sections\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -36063,6 +37070,11 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n \t  return stmt;\n \t}\n     }\n+  else if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n \n   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n \t\t\t\t       cclauses == NULL);\n@@ -36095,6 +37107,7 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n   tree stmt = make_node (OMP_SINGLE);\n   TREE_TYPE (stmt) = void_type_node;\n+  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n \n   OMP_SINGLE_CLAUSES (stmt)\n     = cp_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,\n@@ -36118,7 +37131,8 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n \n static tree\n cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n@@ -36136,13 +37150,32 @@ cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n }\n \n /* OpenMP 3.0:\n-   # pragma omp taskwait new-line  */\n+   # pragma omp taskwait new-line\n+\n+   OpenMP 5.0:\n+   # pragma omp taskwait taskwait-clause[opt] new-line  */\n+\n+#define OMP_TASKWAIT_CLAUSE_MASK\t\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\n \n static void\n cp_parser_omp_taskwait (cp_parser *parser, cp_token *pragma_tok)\n {\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n-  finish_omp_taskwait ();\n+  tree clauses\n+    = cp_parser_omp_all_clauses (parser, OMP_TASKWAIT_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp taskwait\", pragma_tok);\n+\n+  if (clauses)\n+    {\n+      tree stmt = make_node (OMP_TASK);\n+      TREE_TYPE (stmt) = void_node;\n+      OMP_TASK_CLAUSES (stmt) = clauses;\n+      OMP_TASK_BODY (stmt) = NULL_TREE;\n+      SET_EXPR_LOCATION (stmt, pragma_tok->location);\n+      add_stmt (stmt);\n+    }\n+  else\n+    finish_omp_taskwait ();\n }\n \n /* OpenMP 3.1:\n@@ -36157,15 +37190,24 @@ cp_parser_omp_taskyield (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 4.0:\n    # pragma omp taskgroup new-line\n-     structured-block  */\n+     structured-block\n+\n+   OpenMP 5.0:\n+   # pragma omp taskgroup taskgroup-clause[optseq] new-line  */\n+\n+#define OMP_TASKGROUP_CLAUSE_MASK\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_TASK_REDUCTION))\n \n static tree\n cp_parser_omp_taskgroup (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  tree clauses\n+    = cp_parser_omp_all_clauses (parser, OMP_TASKGROUP_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp taskgroup\", pragma_tok);\n   return c_finish_omp_taskgroup (input_location,\n \t\t\t\t cp_parser_omp_structured_block (parser,\n-\t\t\t\t\t\t\t\t if_p));\n+\t\t\t\t\t\t\t\t if_p),\n+\t\t\t\t clauses);\n }\n \n \n@@ -36338,13 +37380,14 @@ cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];\n     }\n \n+  keep_next_level (true);\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n   ret = cp_parser_omp_for_loop (parser, OMP_DISTRIBUTE, clauses, NULL, if_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n-  add_stmt (finish_omp_structured_block (sb));\n+  add_stmt (finish_omp_for_block (finish_omp_structured_block (sb), ret));\n \n   return ret;\n }\n@@ -36388,6 +37431,7 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n \t  if (!flag_openmp)  /* flag_openmp_simd  */\n \t    return cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n \t\t\t\t\t     cclauses, if_p);\n+\t  keep_next_level (true);\n \t  sb = begin_omp_structured_block ();\n \t  save = cp_parser_begin_omp_structured_block (parser);\n \t  ret = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,\n@@ -36423,6 +37467,7 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n   tree stmt = make_node (OMP_TEAMS);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TEAMS_CLAUSES (stmt) = clauses;\n+  keep_next_level (true);\n   OMP_TEAMS_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n   SET_EXPR_LOCATION (stmt, loc);\n \n@@ -36473,6 +37518,8 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t    *pc = OMP_CLAUSE_CHAIN (*pc);\n \t    continue;\n \t  }\n+      else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_USE_DEVICE_PTR)\n+\tmap_seen = 3;\n       pc = &OMP_CLAUSE_CHAIN (*pc);\n     }\n \n@@ -36481,7 +37528,7 @@ cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n       if (map_seen == 0)\n \terror_at (pragma_tok->location,\n \t\t  \"%<#pragma omp target data%> must contain at least \"\n-\t\t  \"one %<map%> clause\");\n+\t\t  \"one %<map%> or %<use_device_ptr%> clause\");\n       return NULL_TREE;\n     }\n \n@@ -36739,6 +37786,10 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n {\n   tree *pc = NULL, stmt;\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n@@ -38092,6 +39143,147 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n   return false;\n }\n \n+/* OpenMP 5.0\n+   #pragma omp requires clauses[optseq] new-line  */\n+\n+static bool\n+cp_parser_omp_requires (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  bool first = true;\n+  enum omp_requires new_req = (enum omp_requires) 0;\n+\n+  location_t loc = pragma_tok->location;\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+    {\n+      if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      first = false;\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t{\n+\t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t  const char *p = IDENTIFIER_POINTER (id);\n+\t  location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n+\t  enum omp_requires this_req = (enum omp_requires) 0;\n+\n+\t  if (!strcmp (p, \"unified_address\"))\n+\t    this_req = OMP_REQUIRES_UNIFIED_ADDRESS;\n+\t  else if (!strcmp (p, \"unified_shared_memory\"))\n+\t    this_req = OMP_REQUIRES_UNIFIED_SHARED_MEMORY;\n+\t  else if (!strcmp (p, \"dynamic_allocators\"))\n+\t    this_req = OMP_REQUIRES_DYNAMIC_ALLOCATORS;\n+\t  else if (!strcmp (p, \"reverse_offload\"))\n+\t    this_req = OMP_REQUIRES_REVERSE_OFFLOAD;\n+\t  else if (!strcmp (p, \"atomic_default_mem_order\"))\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\n+\t      matching_parens parens;\n+\t      if (parens.require_open (parser))\n+\t\t{\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t\t    {\n+\t\t      id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t      p = IDENTIFIER_POINTER (id);\n+\n+\t\t      if (!strcmp (p, \"seq_cst\"))\n+\t\t\tthis_req\n+\t\t\t  = (enum omp_requires) OMP_MEMORY_ORDER_SEQ_CST;\n+\t\t      else if (!strcmp (p, \"relaxed\"))\n+\t\t\tthis_req\n+\t\t\t  = (enum omp_requires) OMP_MEMORY_ORDER_RELAXED;\n+\t\t      else if (!strcmp (p, \"acq_rel\"))\n+\t\t\tthis_req\n+\t\t\t  = (enum omp_requires) OMP_MEMORY_ORDER_ACQ_REL;\n+\t\t    }\n+\t\t  if (this_req == 0)\n+\t\t    {\n+\t\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t\t\"expected %<seq_cst%>, %<relaxed%> or \"\n+\t\t\t\t\"%<acq_rel%>\");\n+\t\t      if (cp_lexer_nth_token_is (parser->lexer, 2,\n+\t\t\t\t\t\t CPP_CLOSE_PAREN))\n+\t\t\tcp_lexer_consume_token (parser->lexer);\n+\t\t    }\n+\t\t  else\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\n+\t\t  if (!parens.require_close (parser))\n+\t\t    cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t\t   /*recovering=*/true,\n+\t\t\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t\t\t   /*consume_paren=*/\n+\t\t\t\t\t\t\t   true);\n+\n+\t\t  if (this_req == 0)\n+\t\t    {\n+\t\t      cp_parser_require_pragma_eol (parser, pragma_tok);\n+\t\t      return false;\n+\t\t    }\n+\t\t}\n+\t      p = NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      error_at (cloc, \"expected %<unified_address%>, \"\n+\t\t\t      \"%<unified_shared_memory%>, \"\n+\t\t\t      \"%<dynamic_allocators%>, \"\n+\t\t\t       \"%<reverse_offload%> \"\n+\t\t\t       \"or %<atomic_default_mem_order%> clause\");\n+\t      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\t      return false;\n+\t    }\n+\t  if (p)\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  if (this_req)\n+\t    {\n+\t      if ((this_req & ~OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER) != 0)\n+\t\t{\n+\t\t  if ((this_req & new_req) != 0)\n+\t\t    error_at (cloc, \"too many %qs clauses\", p);\n+\t\t  if (this_req != OMP_REQUIRES_DYNAMIC_ALLOCATORS\n+\t\t      && (omp_requires_mask & OMP_REQUIRES_TARGET_USED) != 0)\n+\t\t    error_at (cloc, \"%qs clause used lexically after first \"\n+\t\t\t\t    \"target construct or offloading API\", p);\n+\t\t}\n+\t      else if ((new_req & OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER) != 0)\n+\t\t{\n+\t\t  error_at (cloc, \"too many %qs clauses\",\n+\t\t\t    \"atomic_default_mem_order\");\n+\t\t  this_req = (enum omp_requires) 0;\n+\t\t}\n+\t      else if ((omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER) != 0)\n+\t\t{\n+\t\t  error_at (cloc, \"more than one %<atomic_default_mem_order%>\"\n+\t\t\t\t  \" clause in a single compilation unit\");\n+\t\t  this_req\n+\t\t    = (enum omp_requires)\n+\t\t       (omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER);\n+\t\t}\n+\t      else if ((omp_requires_mask\n+\t\t\t& OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER_USED) != 0)\n+\t\terror_at (cloc, \"%<atomic_default_mem_order%> clause used \"\n+\t\t\t\t\"lexically after first %<atomic%> construct \"\n+\t\t\t\t\"without memory order clause\");\n+\t      new_req = (enum omp_requires) (new_req | this_req);\n+\t      omp_requires_mask\n+\t\t= (enum omp_requires) (omp_requires_mask | this_req);\n+\t      continue;\n+\t    }\n+\t}\n+      break;\n+    }\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  if (new_req == 0)\n+    error_at (loc, \"%<pragma omp requires%> requires at least one clause\");\n+  return false;\n+}\n+\n+\n /* OpenMP 4.5:\n    #pragma omp taskloop taskloop-clause[optseq] new-line\n      for-loop\n@@ -38113,7 +39305,9 @@ cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FINAL)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MERGEABLE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NOGROUP)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n \n static tree\n cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n@@ -38126,6 +39320,10 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n \n   strcat (p_name, \" taskloop\");\n   mask |= OMP_TASKLOOP_CLAUSE_MASK;\n+  /* #pragma omp parallel master taskloop{, simd} disallow in_reduction\n+     clause.  */\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS)) != 0)\n+    mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION);\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -38173,14 +39371,15 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n       clauses = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];\n     }\n \n+  keep_next_level (true);\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n   ret = cp_parser_omp_for_loop (parser, OMP_TASKLOOP, clauses, cclauses,\n \t\t\t\tif_p);\n \n   cp_parser_end_omp_structured_block (parser, save);\n-  add_stmt (finish_omp_structured_block (sb));\n+  add_stmt (finish_omp_for_block (finish_omp_structured_block (sb), ret));\n \n   return ret;\n }\n@@ -38487,7 +39686,9 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t\t\t\tif_p);\n       break;\n     case PRAGMA_OMP_MASTER:\n-      stmt = cp_parser_omp_master (parser, pragma_tok, if_p);\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = cp_parser_omp_master (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t   if_p);\n       break;\n     case PRAGMA_OMP_PARALLEL:\n       strcpy (p_name, \"#pragma omp\");\n@@ -38947,6 +40148,21 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t}\n       break;\n \n+    case PRAGMA_OMP_DEPOBJ:\n+      switch (context)\n+\t{\n+\tcase pragma_compound:\n+\t  cp_parser_omp_depobj (parser, pragma_tok);\n+\t  return false;\n+\tcase pragma_stmt:\n+\t  error_at (pragma_tok->location, \"%<#pragma %s%> may only be \"\n+\t\t    \"used in compound statements\", \"omp depobj\");\n+\t  break;\n+\tdefault:\n+\t  goto bad_stmt;\n+\t}\n+      break;\n+\n     case PRAGMA_OMP_FLUSH:\n       switch (context)\n \t{\n@@ -39114,6 +40330,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n       pop_omp_privatization_clauses (stmt);\n       return true;\n \n+    case PRAGMA_OMP_REQUIRES:\n+      return cp_parser_omp_requires (parser, pragma_tok);\n+\n     case PRAGMA_OMP_ORDERED:\n       if (context != pragma_stmt && context != pragma_compound)\n \tgoto bad_stmt;"}, {"sha": "fe330cd29d5b3fe34b3064a8f5b6534ef1d63793", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 250, "deletions": 49, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -16097,11 +16097,49 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n static tree\n tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n-\t\t\ttree in_decl)\n+\t\t\ttree in_decl, tree *iterator_cache)\n {\n   if (decl == NULL_TREE)\n     return NULL_TREE;\n \n+  /* Handle OpenMP iterators.  */\n+  if (TREE_CODE (decl) == TREE_LIST\n+      && TREE_PURPOSE (decl)\n+      && TREE_CODE (TREE_PURPOSE (decl)) == TREE_VEC)\n+    {\n+      tree ret;\n+      if (iterator_cache[0] == TREE_PURPOSE (decl))\n+\tret = iterator_cache[1];\n+      else\n+\t{\n+\t  tree *tp = &ret;\n+\t  begin_scope (sk_omp, NULL);\n+\t  for (tree it = TREE_PURPOSE (decl); it; it = TREE_CHAIN (it))\n+\t    {\n+\t      *tp = copy_node (it);\n+\t      TREE_VEC_ELT (*tp, 0)\n+\t\t= tsubst_decl (TREE_VEC_ELT (it, 0), args, complain);\n+\t      TREE_VEC_ELT (*tp, 1)\n+\t\t= tsubst_expr (TREE_VEC_ELT (it, 1), args, complain, in_decl,\n+\t\t\t       /*integral_constant_expression_p=*/false);\n+\t      TREE_VEC_ELT (*tp, 2)\n+\t\t= tsubst_expr (TREE_VEC_ELT (it, 2), args, complain, in_decl,\n+\t\t\t       /*integral_constant_expression_p=*/false);\n+\t      TREE_VEC_ELT (*tp, 3)\n+\t\t= tsubst_expr (TREE_VEC_ELT (it, 3), args, complain, in_decl,\n+\t\t\t       /*integral_constant_expression_p=*/false);\n+\t      TREE_CHAIN (*tp) = NULL_TREE;\n+\t      tp = &TREE_CHAIN (*tp);\n+\t    }\n+\t  TREE_VEC_ELT (ret, 5) = poplevel (1, 1, 0);\n+\t  iterator_cache[0] = TREE_PURPOSE (decl);\n+\t  iterator_cache[1] = ret;\n+\t}\n+      return build_tree_list (ret, tsubst_omp_clause_decl (TREE_VALUE (decl),\n+\t\t\t\t\t\t\t   args, complain,\n+\t\t\t\t\t\t\t   in_decl, NULL));\n+    }\n+\n   /* Handle an OpenMP array section represented as a TREE_LIST (or\n      OMP_CLAUSE_DEPEND_KIND).  An OMP_CLAUSE_DEPEND (with a depend\n      kind of OMP_CLAUSE_DEPEND_SINK) can also be represented as a\n@@ -16116,7 +16154,7 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n       tree length = tsubst_expr (TREE_VALUE (decl), args, complain, in_decl,\n \t\t\t\t /*integral_constant_expression_p=*/false);\n       tree chain = tsubst_omp_clause_decl (TREE_CHAIN (decl), args, complain,\n-\t\t\t\t\t   in_decl);\n+\t\t\t\t\t   in_decl, NULL);\n       if (TREE_PURPOSE (decl) == low_bound\n \t  && TREE_VALUE (decl) == length\n \t  && TREE_CHAIN (decl) == chain)\n@@ -16144,6 +16182,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n {\n   tree new_clauses = NULL_TREE, nc, oc;\n   tree linear_no_step = NULL_TREE;\n+  tree iterator_cache[2] = { NULL_TREE, NULL_TREE };\n \n   for (oc = clauses; oc ; oc = OMP_CLAUSE_CHAIN (oc))\n     {\n@@ -16173,11 +16212,12 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n-\t\t\t\t      in_decl);\n+\t\t\t\t      in_decl, iterator_cache);\n \t  break;\n \tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE_IF:\n@@ -16208,6 +16248,8 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (oc))\n \t    {\n \t      tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (oc);\n@@ -16225,21 +16267,21 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t    }\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n-\t\t\t\t      in_decl);\n+\t\t\t\t      in_decl, NULL);\n \t  break;\n \tcase OMP_CLAUSE_GANG:\n \tcase OMP_CLAUSE_ALIGNED:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n-\t\t\t\t      in_decl);\n+\t\t\t\t      in_decl, NULL);\n \t  OMP_CLAUSE_OPERAND (nc, 1)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_LINEAR:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n-\t\t\t\t      in_decl);\n+\t\t\t\t      in_decl, NULL);\n \t  if (OMP_CLAUSE_LINEAR_STEP (oc) == NULL_TREE)\n \t    {\n \t      gcc_assert (!linear_no_step);\n@@ -16248,7 +16290,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t  else if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (oc))\n \t    OMP_CLAUSE_LINEAR_STEP (nc)\n \t      = tsubst_omp_clause_decl (OMP_CLAUSE_LINEAR_STEP (oc), args,\n-\t\t\t\t\tcomplain, in_decl);\n+\t\t\t\t\tcomplain, in_decl, NULL);\n \t  else\n \t    OMP_CLAUSE_LINEAR_STEP (nc)\n \t      = tsubst_expr (OMP_CLAUSE_LINEAR_STEP (oc), args, complain,\n@@ -16289,6 +16331,8 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t  case OMP_CLAUSE_COPYPRIVATE:\n \t  case OMP_CLAUSE_LINEAR:\n \t  case OMP_CLAUSE_REDUCTION:\n+\t  case OMP_CLAUSE_IN_REDUCTION:\n+\t  case OMP_CLAUSE_TASK_REDUCTION:\n \t  case OMP_CLAUSE_USE_DEVICE_PTR:\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n \t    /* tsubst_expr on SCOPE_REF results in returning\n@@ -16403,37 +16447,70 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n \n static tree *omp_parallel_combined_clauses;\n \n+static tree tsubst_decomp_names (tree, tree, tree, tsubst_flags_t, tree,\n+\t\t\t\t tree *, unsigned int *);\n+\n /* Substitute one OMP_FOR iterator.  */\n \n-static void\n-tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n+static bool\n+tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n \t\t\t tree initv, tree condv, tree incrv, tree *clauses,\n \t\t\t tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t bool integral_constant_expression_p)\n {\n #define RECUR(NODE)\t\t\t\t\\\n   tsubst_expr ((NODE), args, complain, in_decl,\t\\\n \t       integral_constant_expression_p)\n-  tree decl, init, cond, incr;\n+  tree decl, init, cond = NULL_TREE, incr = NULL_TREE;\n+  bool ret = false;\n \n   init = TREE_VEC_ELT (OMP_FOR_INIT (t), i);\n   gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n \n-  if (orig_declv && OMP_FOR_ORIG_DECLS (t))\n-    {\n-      tree o = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (t), i);\n-      if (TREE_CODE (o) == TREE_LIST)\n-\tTREE_VEC_ELT (orig_declv, i)\n-\t  = tree_cons (RECUR (TREE_PURPOSE (o)),\n-\t\t       RECUR (TREE_VALUE (o)), NULL_TREE);\n-      else\n-\tTREE_VEC_ELT (orig_declv, i) = RECUR (o);\n-    }\n-\n   decl = TREE_OPERAND (init, 0);\n   init = TREE_OPERAND (init, 1);\n   tree decl_expr = NULL_TREE;\n-  if (init && TREE_CODE (init) == DECL_EXPR)\n+  bool range_for = TREE_VEC_ELT (OMP_FOR_COND (t), i) == global_namespace;\n+  if (range_for)\n+    {\n+      bool decomp = false;\n+      if (decl != error_mark_node && DECL_HAS_VALUE_EXPR_P (decl))\n+\t{\n+\t  tree v = DECL_VALUE_EXPR (decl);\n+\t  if (TREE_CODE (v) == ARRAY_REF\n+\t      && VAR_P (TREE_OPERAND (v, 0))\n+\t      && DECL_DECOMPOSITION_P (TREE_OPERAND (v, 0)))\n+\t    {\n+\t      tree decomp_first = NULL_TREE;\n+\t      unsigned decomp_cnt = 0;\n+\t      tree d = tsubst_decl (TREE_OPERAND (v, 0), args, complain);\n+\t      maybe_push_decl (d);\n+\t      d = tsubst_decomp_names (d, TREE_OPERAND (v, 0), args, complain,\n+\t\t\t\t       in_decl, &decomp_first, &decomp_cnt);\n+\t      decomp = true;\n+\t      if (d == error_mark_node)\n+\t\tdecl = error_mark_node;\n+\t      else\n+\t\tfor (unsigned int i = 0; i < decomp_cnt; i++)\n+\t\t  {\n+\t\t    if (!DECL_HAS_VALUE_EXPR_P (decomp_first))\n+\t\t      {\n+\t\t\ttree v = build_nt (ARRAY_REF, d,\n+\t\t\t\t\t   size_int (decomp_cnt - i - 1),\n+\t\t\t\t\t   NULL_TREE, NULL_TREE);\n+\t\t\tSET_DECL_VALUE_EXPR (decomp_first, v);\n+\t\t\tDECL_HAS_VALUE_EXPR_P (decomp_first) = 1;\n+\t\t      }\n+\t\t    fit_decomposition_lang_decl (decomp_first, d);\n+\t\t    decomp_first = DECL_CHAIN (decomp_first);\n+\t\t  }\n+\t    }\n+\t}\n+      decl = tsubst_decl (decl, args, complain);\n+      if (!decomp)\n+\tmaybe_push_decl (decl);\n+    }\n+  else if (init && TREE_CODE (init) == DECL_EXPR)\n     {\n       /* We need to jump through some hoops to handle declarations in the\n \t init-statement, since we might need to handle auto deduction,\n@@ -16480,14 +16557,44 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n     }\n   init = RECUR (init);\n \n+  if (orig_declv && OMP_FOR_ORIG_DECLS (t))\n+    {\n+      tree o = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (t), i);\n+      if (TREE_CODE (o) == TREE_LIST)\n+\tTREE_VEC_ELT (orig_declv, i)\n+\t  = tree_cons (RECUR (TREE_PURPOSE (o)),\n+\t\t       RECUR (TREE_VALUE (o)),\n+\t\t       NULL_TREE);\n+      else\n+\tTREE_VEC_ELT (orig_declv, i) = RECUR (o);\n+    }\n+\n+  if (range_for)\n+    {\n+      tree this_pre_body = NULL_TREE;\n+      tree orig_init = NULL_TREE;\n+      tree orig_decl = NULL_TREE;\n+      cp_convert_omp_range_for (this_pre_body, NULL, decl, orig_decl, init,\n+\t\t\t\torig_init, cond, incr);\n+      if (orig_decl)\n+\t{\n+\t  if (orig_declv == NULL_TREE)\n+\t    orig_declv = copy_node (declv);\n+\t  TREE_VEC_ELT (orig_declv, i) = orig_decl;\n+\t  ret = true;\n+\t}\n+      else if (orig_declv)\n+\tTREE_VEC_ELT (orig_declv, i) = decl;\n+    }\n+\n   tree auto_node = type_uses_auto (TREE_TYPE (decl));\n-  if (auto_node && init)\n+  if (!range_for && auto_node && init)\n     TREE_TYPE (decl)\n       = do_auto_deduction (TREE_TYPE (decl), init, auto_node, complain);\n \n   gcc_assert (!type_dependent_expression_p (decl));\n \n-  if (!CLASS_TYPE_P (TREE_TYPE (decl)))\n+  if (!CLASS_TYPE_P (TREE_TYPE (decl)) || range_for)\n     {\n       if (decl_expr)\n \t{\n@@ -16498,22 +16605,27 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n \t  DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = init_sav;\n \t}\n \n-      cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));\n-      incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n-      if (TREE_CODE (incr) == MODIFY_EXPR)\n+      if (!range_for)\n \t{\n-\t  tree lhs = RECUR (TREE_OPERAND (incr, 0));\n-\t  tree rhs = RECUR (TREE_OPERAND (incr, 1));\n-\t  incr = build_x_modify_expr (EXPR_LOCATION (incr), lhs,\n-\t\t\t\t      NOP_EXPR, rhs, complain);\n+\t  cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));\n+\t  incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n+\t  if (TREE_CODE (incr) == MODIFY_EXPR)\n+\t    {\n+\t      tree lhs = RECUR (TREE_OPERAND (incr, 0));\n+\t      tree rhs = RECUR (TREE_OPERAND (incr, 1));\n+\t      incr = build_x_modify_expr (EXPR_LOCATION (incr), lhs,\n+\t\t\t\t\t  NOP_EXPR, rhs, complain);\n+\t    }\n+\t  else\n+\t    incr = RECUR (incr);\n+\t  if (orig_declv && !OMP_FOR_ORIG_DECLS (t))\n+\t    TREE_VEC_ELT (orig_declv, i) = decl;\n \t}\n-      else\n-\tincr = RECUR (incr);\n       TREE_VEC_ELT (declv, i) = decl;\n       TREE_VEC_ELT (initv, i) = init;\n       TREE_VEC_ELT (condv, i) = cond;\n       TREE_VEC_ELT (incrv, i) = incr;\n-      return;\n+      return ret;\n     }\n \n   if (decl_expr)\n@@ -16640,10 +16752,13 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree orig_declv,\n       break;\n     }\n \n+  if (orig_declv && !OMP_FOR_ORIG_DECLS (t))\n+    TREE_VEC_ELT (orig_declv, i) = decl;\n   TREE_VEC_ELT (declv, i) = decl;\n   TREE_VEC_ELT (initv, i) = init;\n   TREE_VEC_ELT (condv, i) = cond;\n   TREE_VEC_ELT (incrv, i) = incr;\n+  return false;\n #undef RECUR\n }\n \n@@ -17254,6 +17369,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_TASK:\n+      if (OMP_TASK_BODY (t) == NULL_TREE)\n+\t{\n+\t  tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t), C_ORT_OMP, args,\n+\t\t\t\t    complain, in_decl);\n+\t  t = copy_node (t);\n+\t  OMP_TASK_CLAUSES (t) = tmp;\n+\t  add_stmt (t);\n+\t  break;\n+\t}\n       r = push_omp_privatization_clauses (false);\n       tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t), C_ORT_OMP, args,\n \t\t\t\tcomplain, in_decl);\n@@ -17274,6 +17398,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \ttree orig_declv = NULL_TREE;\n \ttree incrv = NULL_TREE;\n \tenum c_omp_region_type ort = C_ORT_OMP;\n+\tbool any_range_for = false;\n \tint i;\n \n \tif (TREE_CODE (t) == OACC_LOOP)\n@@ -17292,6 +17417,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    incrv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n \t  }\n \n+\tkeep_next_level (true);\n \tstmt = begin_omp_structured_block ();\n \n \tpre_body = push_stmt_list ();\n@@ -17300,14 +17426,31 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n \t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n-\t    tsubst_omp_for_iterator (t, i, declv, orig_declv, initv, condv,\n-\t\t\t\t     incrv, &clauses, args, complain, in_decl,\n-\t\t\t\t     integral_constant_expression_p);\n+\t    any_range_for\n+\t      |= tsubst_omp_for_iterator (t, i, declv, orig_declv, initv,\n+\t\t\t\t\t  condv, incrv, &clauses, args,\n+\t\t\t\t\t  complain, in_decl,\n+\t\t\t\t\t  integral_constant_expression_p);\n \tomp_parallel_combined_clauses = NULL;\n \n-\tbody = push_stmt_list ();\n+\tif (any_range_for)\n+\t  {\n+\t    gcc_assert (orig_declv);\n+\t    body = begin_omp_structured_block ();\n+\t    for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n+\t      if (TREE_VEC_ELT (orig_declv, i) != TREE_VEC_ELT (declv, i)\n+\t\t  && TREE_CODE (TREE_VEC_ELT (orig_declv, i)) == TREE_LIST\n+\t\t  && TREE_CHAIN (TREE_VEC_ELT (orig_declv, i)))\n+\t\tcp_finish_omp_range_for (TREE_VEC_ELT (orig_declv, i),\n+\t\t\t\t\t TREE_VEC_ELT (declv, i));\n+\t  }\n+\telse\n+\t  body = push_stmt_list ();\n \tRECUR (OMP_FOR_BODY (t));\n-\tbody = pop_stmt_list (body);\n+\tif (any_range_for)\n+\t  body = finish_omp_structured_block (body);\n+\telse\n+\t  body = pop_stmt_list (body);\n \n \tif (OMP_FOR_INIT (t) != NULL_TREE)\n \t  t = finish_omp_for (EXPR_LOCATION (t), TREE_CODE (t), declv,\n@@ -17324,7 +17467,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    add_stmt (t);\n \t  }\n \n-\tadd_stmt (finish_omp_structured_block (stmt));\n+\tadd_stmt (finish_omp_for_block (finish_omp_structured_block (stmt),\n+\t\t\t\t\tt));\n \tpop_omp_privatization_clauses (r);\n       }\n       break;\n@@ -17335,13 +17479,24 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n     case OMP_SINGLE:\n     case OMP_TEAMS:\n     case OMP_CRITICAL:\n+    case OMP_TASKGROUP:\n       r = push_omp_privatization_clauses (TREE_CODE (t) == OMP_TEAMS\n \t\t\t\t\t  && OMP_TEAMS_COMBINED (t));\n       tmp = tsubst_omp_clauses (OMP_CLAUSES (t), C_ORT_OMP, args, complain,\n \t\t\t\tin_decl);\n-      stmt = push_stmt_list ();\n-      RECUR (OMP_BODY (t));\n-      stmt = pop_stmt_list (stmt);\n+      if (TREE_CODE (t) == OMP_TEAMS)\n+\t{\n+\t  keep_next_level (true);\n+\t  stmt = begin_omp_structured_block ();\n+\t  RECUR (OMP_BODY (t));\n+\t  stmt = finish_omp_structured_block (stmt);\n+\t}\n+      else\n+\t{\n+\t  stmt = push_stmt_list ();\n+\t  RECUR (OMP_BODY (t));\n+\t  stmt = pop_stmt_list (stmt);\n+\t}\n \n       t = copy_node (t);\n       OMP_BODY (t) = stmt;\n@@ -17350,6 +17505,32 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       pop_omp_privatization_clauses (r);\n       break;\n \n+    case OMP_DEPOBJ:\n+      r = RECUR (OMP_DEPOBJ_DEPOBJ (t));\n+      if (OMP_DEPOBJ_CLAUSES (t) && OMP_DEPOBJ_CLAUSES (t) != error_mark_node)\n+\t{\n+\t  enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_SOURCE;\n+\t  if (TREE_CODE (OMP_DEPOBJ_CLAUSES (t)) == OMP_CLAUSE)\n+\t    {\n+\t      tmp = tsubst_omp_clauses (OMP_DEPOBJ_CLAUSES (t), C_ORT_OMP,\n+\t\t\t\t\targs, complain, in_decl);\n+\t      if (tmp == NULL_TREE)\n+\t\ttmp = error_mark_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      kind = (enum omp_clause_depend_kind)\n+\t\t     tree_to_uhwi (OMP_DEPOBJ_CLAUSES (t));\n+\t      tmp = NULL_TREE;\n+\t    }\n+\t  finish_omp_depobj (EXPR_LOCATION (t), r, kind, tmp);\n+\t}\n+      else\n+\tfinish_omp_depobj (EXPR_LOCATION (t), r,\n+\t\t\t   OMP_CLAUSE_DEPEND_SOURCE,\n+\t\t\t   OMP_DEPOBJ_CLAUSES (t));\n+      break;\n+\n     case OACC_DATA:\n     case OMP_TARGET_DATA:\n     case OMP_TARGET:\n@@ -17441,7 +17622,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case OMP_SECTION:\n     case OMP_MASTER:\n-    case OMP_TASKGROUP:\n       stmt = push_stmt_list ();\n       RECUR (OMP_BODY (t));\n       stmt = pop_stmt_list (stmt);\n@@ -17453,6 +17633,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case OMP_ATOMIC:\n       gcc_assert (OMP_ATOMIC_DEPENDENT_P (t));\n+      tmp = NULL_TREE;\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == OMP_CLAUSE)\n+\ttmp = tsubst_omp_clauses (TREE_OPERAND (t, 0), C_ORT_OMP, args,\n+\t\t\t\t  complain, in_decl);\n       if (TREE_CODE (TREE_OPERAND (t, 1)) != MODIFY_EXPR)\n \t{\n \t  tree op1 = TREE_OPERAND (t, 1);\n@@ -17465,9 +17649,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    }\n \t  lhs = RECUR (TREE_OPERAND (op1, 0));\n \t  rhs = RECUR (TREE_OPERAND (op1, 1));\n-\t  finish_omp_atomic (OMP_ATOMIC, TREE_CODE (op1), lhs, rhs,\n-\t\t\t     NULL_TREE, NULL_TREE, rhs1,\n-\t\t\t     OMP_ATOMIC_SEQ_CST (t));\n+\t  finish_omp_atomic (EXPR_LOCATION (t), OMP_ATOMIC, TREE_CODE (op1),\n+\t\t\t     lhs, rhs, NULL_TREE, NULL_TREE, rhs1, tmp,\n+\t\t\t     OMP_ATOMIC_MEMORY_ORDER (t));\n \t}\n       else\n \t{\n@@ -17504,8 +17688,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t      lhs = RECUR (TREE_OPERAND (op1, 0));\n \t      rhs = RECUR (TREE_OPERAND (op1, 1));\n \t    }\n-\t  finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1,\n-\t\t\t     OMP_ATOMIC_SEQ_CST (t));\n+\t  finish_omp_atomic (EXPR_LOCATION (t), code, opcode, lhs, rhs, v,\n+\t\t\t     lhs1, rhs1, tmp, OMP_ATOMIC_MEMORY_ORDER (t));\n \t}\n       break;\n \n@@ -25865,6 +26049,9 @@ dependent_omp_for_p (tree declv, tree initv, tree condv, tree incrv)\n       if (init && type_dependent_expression_p (init))\n \treturn true;\n \n+      if (cond == global_namespace)\n+\treturn true;\n+\n       if (type_dependent_expression_p (cond))\n \treturn true;\n \n@@ -25891,6 +26078,20 @@ dependent_omp_for_p (tree declv, tree initv, tree condv, tree incrv)\n \t      if (type_dependent_expression_p (TREE_OPERAND (t, 0))\n \t\t  || type_dependent_expression_p (TREE_OPERAND (t, 1)))\n \t\treturn true;\n+\n+\t      /* If this loop has a class iterator with != comparison\n+\t\t with increment other than i++/++i/i--/--i, make sure the\n+\t\t increment is constant.  */\n+\t      if (CLASS_TYPE_P (TREE_TYPE (decl))\n+\t\t  && TREE_CODE (cond) == NE_EXPR)\n+\t\t{\n+\t\t  if (TREE_OPERAND (t, 0) == decl)\n+\t\t    t = TREE_OPERAND (t, 1);\n+\t\t  else\n+\t\t    t = TREE_OPERAND (t, 0);\n+\t\t  if (TREE_CODE (t) != INTEGER_CST)\n+\t\t    return true;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "182d360a5622f7455e96a3a851c87d71345c429a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 652, "deletions": 161, "changes": 813, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"gomp-constants.h\"\n #include \"predict.h\"\n+#include \"memmodel.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -4634,7 +4635,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n     }\n \n   if (ort == C_ORT_OMP\n-      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+      && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n       && TREE_CODE (TREE_CHAIN (t)) == FIELD_DECL)\n     TREE_CHAIN (t) = omp_privatize_field (TREE_CHAIN (t), false);\n   ret = handle_omp_array_sections_1 (c, TREE_CHAIN (t), types,\n@@ -4693,7 +4696,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       if (!integer_nonzerop (length))\n \t{\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t    {\n \t      if (integer_zerop (length))\n \t\t{\n@@ -4759,7 +4764,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t      if (tree_int_cst_equal (size, low_bound))\n \t\t{\n \t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"zero length array section in %qs clause\",\n@@ -4778,7 +4785,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  else if (length == NULL_TREE)\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n \t\tmaybe_zero_len = true;\n \t      if (first_non_one == types.length ())\n \t\tfirst_non_one++;\n@@ -4814,7 +4823,9 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       else if (length == NULL_TREE)\n \t{\n \t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n \t    maybe_zero_len = true;\n \t  if (first_non_one == types.length ())\n \t    first_non_one++;\n@@ -4886,7 +4897,13 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n   bool maybe_zero_len = false;\n   unsigned int first_non_one = 0;\n   auto_vec<tree, 10> types;\n-  tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n+  tree *tp = &OMP_CLAUSE_DECL (c);\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+      && TREE_CODE (*tp) == TREE_LIST\n+      && TREE_PURPOSE (*tp)\n+      && TREE_CODE (TREE_PURPOSE (*tp)) == TREE_VEC)\n+    tp = &TREE_VALUE (*tp);\n+  tree first = handle_omp_array_sections_1 (c, *tp, types,\n \t\t\t\t\t    maybe_zero_len, first_non_one,\n \t\t\t\t\t    ort);\n   if (first == error_mark_node)\n@@ -4895,7 +4912,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n     return false;\n   if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n     {\n-      tree t = OMP_CLAUSE_DECL (c);\n+      tree t = *tp;\n       tree tem = NULL_TREE;\n       if (processing_template_decl)\n \treturn false;\n@@ -4915,7 +4932,7 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t}\n       if (tem)\n \tfirst = build2 (COMPOUND_EXPR, TREE_TYPE (first), tem, first);\n-      OMP_CLAUSE_DECL (c) = first;\n+      *tp = first;\n     }\n   else\n     {\n@@ -4992,7 +5009,9 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \n \t      if (i > first_non_one\n \t\t  && ((length && integer_nonzerop (length))\n-\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION))\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION))\n \t\tcontinue;\n \t      if (length)\n \t\tl = fold_convert (sizetype, length);\n@@ -5020,7 +5039,9 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t\t  tree eltype = TREE_TYPE (types[num - 1]);\n \t\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n \t\t    eltype = TREE_TYPE (eltype);\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t\t    size = size_binop (EXACT_DIV_EXPR, size,\n \t\t\t\t       size_in_bytes (eltype));\n \t\t  size = size_binop (MULT_EXPR, size, l);\n@@ -5036,9 +5057,12 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t{\n \t  if (side_effects)\n \t    size = build2 (COMPOUND_EXPR, sizetype, side_effects, size);\n-\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t    {\n \t      size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t      size = save_expr (size);\n \t      tree index_type = build_index_type (size);\n \t      tree eltype = TREE_TYPE (first);\n \t      while (TREE_CODE (eltype) == ARRAY_TYPE)\n@@ -5576,11 +5600,13 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t\t\t\t  TYPE_SIZE_UNIT (type));\n \t  if (integer_zerop (size))\n \t    {\n-\t      error (\"%qE in %<reduction%> clause is a zero size array\",\n-\t\t     omp_clause_printable_decl (t));\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE in %<reduction%> clause is a zero size array\",\n+\t\t\tomp_clause_printable_decl (t));\n \t      return true;\n \t    }\n \t  size = size_binop (MINUS_EXPR, size, size_one_node);\n+\t  size = save_expr (size);\n \t  tree index_type = build_index_type (size);\n \t  tree atype = build_array_type (type, index_type);\n \t  tree ptype = build_pointer_type (type);\n@@ -5624,8 +5650,9 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n       }\n   else if (TYPE_READONLY (type))\n     {\n-      error (\"%qE has const type for %<reduction%>\",\n-\t     omp_clause_printable_decl (t));\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"%qE has const type for %<reduction%>\",\n+\t\tomp_clause_printable_decl (t));\n       return true;\n     }\n   else if (!processing_template_decl)\n@@ -5699,7 +5726,8 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[0])))\n \t\tcxx_mark_addressable (placeholder);\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[1]))\n-\t\t  && !TYPE_REF_P (TREE_TYPE (OMP_CLAUSE_DECL (c))))\n+\t\t  && (decl_placeholder\n+\t\t      || !TYPE_REF_P (TREE_TYPE (OMP_CLAUSE_DECL (c)))))\n \t\tcxx_mark_addressable (decl_placeholder ? decl_placeholder\n \t\t\t\t      : OMP_CLAUSE_DECL (c));\n \t      tree omp_out = placeholder;\n@@ -5725,7 +5753,9 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t    {\n \t      gcc_assert (TREE_CODE (stmts[3]) == DECL_EXPR\n \t\t\t  && TREE_CODE (stmts[4]) == DECL_EXPR);\n-\t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[3])))\n+\t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[3]))\n+\t\t  && (decl_placeholder\n+\t\t      || !TYPE_REF_P (TREE_TYPE (OMP_CLAUSE_DECL (c)))))\n \t\tcxx_mark_addressable (decl_placeholder ? decl_placeholder\n \t\t\t\t      : OMP_CLAUSE_DECL (c));\n \t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[4])))\n@@ -5786,8 +5816,9 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n     *need_dtor = true;\n   else\n     {\n-      error (\"user defined reduction not found for %qE\",\n-\t     omp_clause_printable_decl (t));\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"user defined reduction not found for %qE\",\n+\t\tomp_clause_printable_decl (t));\n       return true;\n     }\n   if (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF)\n@@ -5868,6 +5899,155 @@ cp_finish_omp_clause_depend_sink (tree sink_clause)\n   return false;\n }\n \n+/* Finish OpenMP iterators ITER.  Return true if they are errorneous\n+   and clauses containing them should be removed.  */\n+\n+static bool\n+cp_omp_finish_iterators (tree iter)\n+{\n+  bool ret = false;\n+  for (tree it = iter; it; it = TREE_CHAIN (it))\n+    {\n+      tree var = TREE_VEC_ELT (it, 0);\n+      tree begin = TREE_VEC_ELT (it, 1);\n+      tree end = TREE_VEC_ELT (it, 2);\n+      tree step = TREE_VEC_ELT (it, 3);\n+      tree orig_step;\n+      tree type = TREE_TYPE (var);\n+      location_t loc = DECL_SOURCE_LOCATION (var);\n+      if (type == error_mark_node)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      if (type_dependent_expression_p (var))\n+\tcontinue;\n+      if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n+\t{\n+\t  error_at (loc, \"iterator %qD has neither integral nor pointer type\",\n+\t\t    var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      else if (TYPE_READONLY (type))\n+\t{\n+\t  error_at (loc, \"iterator %qD has const qualified type\", var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      if (type_dependent_expression_p (begin)\n+\t  || type_dependent_expression_p (end)\n+\t  || type_dependent_expression_p (step))\n+\tcontinue;\n+      else if (error_operand_p (step))\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      else if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (step, loc),\n+\t\t    \"iterator step with non-integral type\");\n+\t  ret = true;\n+\t  continue;\n+\t}\n+\n+      begin = mark_rvalue_use (begin);\n+      end = mark_rvalue_use (end);\n+      step = mark_rvalue_use (step);\n+      begin = cp_build_c_cast (type, begin, tf_warning_or_error);\n+      end = cp_build_c_cast (type, end, tf_warning_or_error);\n+      orig_step = step;\n+      if (!processing_template_decl)\n+\tstep = orig_step = save_expr (step);\n+      tree stype = POINTER_TYPE_P (type) ? sizetype : type;\n+      step = cp_build_c_cast (stype, step, tf_warning_or_error);\n+      if (POINTER_TYPE_P (type) && !processing_template_decl)\n+\t{\n+\t  begin = save_expr (begin);\n+\t  step = pointer_int_sum (loc, PLUS_EXPR, begin, step);\n+\t  step = fold_build2_loc (loc, MINUS_EXPR, sizetype,\n+\t\t\t\t  fold_convert (sizetype, step),\n+\t\t\t\t  fold_convert (sizetype, begin));\n+\t  step = fold_convert (ssizetype, step);\n+\t}\n+      if (!processing_template_decl)\n+\t{\n+\t  begin = maybe_constant_value (begin);\n+\t  end = maybe_constant_value (end);\n+\t  step = maybe_constant_value (step);\n+\t  orig_step = maybe_constant_value (orig_step);\n+\t}\n+      if (integer_zerop (step))\n+\t{\n+\t  error_at (loc, \"iterator %qD has zero step\", var);\n+\t  ret = true;\n+\t  continue;\n+\t}\n+\n+      if (begin == error_mark_node\n+\t  || end == error_mark_node\n+\t  || step == error_mark_node\n+\t  || orig_step == error_mark_node)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+\n+      if (!processing_template_decl)\n+\t{\n+\t  begin = fold_build_cleanup_point_expr (TREE_TYPE (begin), begin);\n+\t  end = fold_build_cleanup_point_expr (TREE_TYPE (end), end);\n+\t  step = fold_build_cleanup_point_expr (TREE_TYPE (step), step);\n+\t  orig_step = fold_build_cleanup_point_expr (TREE_TYPE (orig_step),\n+\t\t\t\t\t\t     orig_step);\n+\t}\n+      hash_set<tree> pset;\n+      tree it2;\n+      for (it2 = TREE_CHAIN (it); it2; it2 = TREE_CHAIN (it2))\n+\t{\n+\t  tree var2 = TREE_VEC_ELT (it2, 0);\n+\t  tree begin2 = TREE_VEC_ELT (it2, 1);\n+\t  tree end2 = TREE_VEC_ELT (it2, 2);\n+\t  tree step2 = TREE_VEC_ELT (it2, 3);\n+\t  location_t loc2 = DECL_SOURCE_LOCATION (var2);\n+\t  if (cp_walk_tree (&begin2, find_omp_placeholder_r, var, &pset))\n+\t    {\n+\t      error_at (EXPR_LOC_OR_LOC (begin2, loc2),\n+\t\t\t\"begin expression refers to outer iterator %qD\", var);\n+\t      break;\n+\t    }\n+\t  else if (cp_walk_tree (&end2, find_omp_placeholder_r, var, &pset))\n+\t    {\n+\t      error_at (EXPR_LOC_OR_LOC (end2, loc2),\n+\t\t\t\"end expression refers to outer iterator %qD\", var);\n+\t      break;\n+\t    }\n+\t  else if (cp_walk_tree (&step2, find_omp_placeholder_r, var, &pset))\n+\t    {\n+\t      error_at (EXPR_LOC_OR_LOC (step2, loc2),\n+\t\t\t\"step expression refers to outer iterator %qD\", var);\n+\t      break;\n+\t    }\n+\t}\n+      if (it2)\n+\t{\n+\t  ret = true;\n+\t  continue;\n+\t}\n+      TREE_VEC_ELT (it, 1) = begin;\n+      TREE_VEC_ELT (it, 2) = end;\n+      if (processing_template_decl)\n+\tTREE_VEC_ELT (it, 3) = orig_step;\n+      else\n+\t{\n+\t  TREE_VEC_ELT (it, 3) = step;\n+\t  TREE_VEC_ELT (it, 4) = orig_step;\n+\t}\n+    }\n+  return ret;\n+}\n+\n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n@@ -5882,14 +6062,19 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   bool copyprivate_seen = false;\n   bool ordered_seen = false;\n   bool oacc_async = false;\n+  tree last_iterators = NULL_TREE;\n+  bool last_iterators_remove = false;\n+  bool reduction_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n   bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n+  /* If ort == C_ORT_OMP_DECLARE_SIMD used as uniform_head instead.  */\n   bitmap_initialize (&map_head, &bitmap_default_obstack);\n   bitmap_initialize (&map_field_head, &bitmap_default_obstack);\n+  /* If ort == C_ORT_OMP used as nontemporal_head instead.  */\n   bitmap_initialize (&oacc_reduction_head, &bitmap_default_obstack);\n \n   if (ort & C_ORT_ACC)\n@@ -5914,6 +6099,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  field_ok = ((ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP);\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_REDUCTION:\n+\t  reduction_seen = true;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  field_ok = ((ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP);\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n@@ -5971,10 +6160,11 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t   || OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_UVAL)\n \t\t  && !TYPE_REF_P (type))\n \t\t{\n-\t\t  error (\"linear clause with %qs modifier applied to \"\n-\t\t\t \"non-reference variable with %qT type\",\n-\t\t\t OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF\n-\t\t\t ? \"ref\" : \"uval\", TREE_TYPE (t));\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"linear clause with %qs modifier applied to \"\n+\t\t\t    \"non-reference variable with %qT type\",\n+\t\t\t    OMP_CLAUSE_LINEAR_KIND (c) == OMP_CLAUSE_LINEAR_REF\n+\t\t\t    ? \"ref\" : \"uval\", TREE_TYPE (t));\n \t\t  remove = true;\n \t\t  break;\n \t\t}\n@@ -5985,8 +6175,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  if (!INTEGRAL_TYPE_P (type)\n \t\t      && !TYPE_PTR_P (type))\n \t\t    {\n-\t\t      error (\"linear clause applied to non-integral non-pointer\"\n-\t\t\t     \" variable with %qT type\", TREE_TYPE (t));\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"linear clause applied to non-integral \"\n+\t\t\t\t\"non-pointer variable with %qT type\",\n+\t\t\t\tTREE_TYPE (t));\n \t\t      remove = true;\n \t\t      break;\n \t\t    }\n@@ -6007,7 +6199,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t       || !TYPE_REF_P (TREE_TYPE (t))\n \t\t       || !INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (t)))))\n \t    {\n-\t      error (\"linear step expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"linear step expression must be integral\");\n \t      remove = true;\n \t      break;\n \t    }\n@@ -6099,8 +6292,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  || (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR\n \t\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_UNIFORM)))\n \t    {\n-\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t     \" clauses\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t\t\" clauses\");\n \t      remove = true;\n \t      break;\n \t    }\n@@ -6110,19 +6304,23 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in clause %qs\", t,\n-\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in clause %qs\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      else\n-\t\terror (\"%qE is not a variable in clause %qs\", t,\n-\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in clause %qs\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (ort == C_ORT_ACC\n \t\t   && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n \t    {\n \t      if (bitmap_bit_p (&oacc_reduction_head, DECL_UID (t)))\n \t\t{\n-\t\t  error (\"%qD appears more than once in reduction clauses\", t);\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD appears more than once in reduction clauses\",\n+\t\t\t    t);\n \t\t  remove = true;\n \t\t}\n \t      else\n@@ -6132,16 +6330,19 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qD appears more than once in data clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n \t\t   && bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears both in data and map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears both in data and map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -6170,8 +6371,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    t = OMP_CLAUSE_DECL (c);\n \t  if (ort != C_ORT_ACC && t == current_class_ptr)\n \t    {\n-\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t     \" clauses\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t\t\" clauses\");\n \t      remove = true;\n \t      break;\n \t    }\n@@ -6182,23 +6384,30 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in clause %<firstprivate%>\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in clause %<firstprivate%>\",\n+\t\t\t  t);\n \t      else\n-\t\terror (\"%qE is not a variable in clause %<firstprivate%>\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in clause %<firstprivate%>\",\n+\t\t\t  t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qD appears more than once in data clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears both in data and map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears both in data and map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -6213,8 +6422,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    t = OMP_CLAUSE_DECL (c);\n \t  if (t == current_class_ptr)\n \t    {\n-\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t     \" clauses\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t\t\" clauses\");\n \t      remove = true;\n \t      break;\n \t    }\n@@ -6225,15 +6435,20 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in clause %<lastprivate%>\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in clause %<lastprivate%>\",\n+\t\t\t  t);\n \t      else\n-\t\terror (\"%qE is not a variable in clause %<lastprivate%>\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in clause %<lastprivate%>\",\n+\t\t\t  t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qD appears more than once in data clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -6270,7 +6485,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      else if (!type_dependent_expression_p (t)\n \t\t       && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t\t{\n-\t\t  error (\"%<gang%> static expression must be integral\");\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<gang%> static expression must be integral\");\n \t\t  remove = true;\n \t\t}\n \t      else\n@@ -6374,30 +6590,6 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \n \tcase OMP_CLAUSE_SCHEDULE:\n-\t  if (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n-\t    {\n-\t      const char *p = NULL;\n-\t      switch (OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n-\t\t{\n-\t\tcase OMP_CLAUSE_SCHEDULE_STATIC: p = \"static\"; break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_DYNAMIC: break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_GUIDED: break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_AUTO: p = \"auto\"; break;\n-\t\tcase OMP_CLAUSE_SCHEDULE_RUNTIME: p = \"runtime\"; break;\n-\t\tdefault: gcc_unreachable ();\n-\t\t}\n-\t      if (p)\n-\t\t{\n-\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%<nonmonotonic%> modifier specified for %qs \"\n-\t\t\t    \"schedule kind\", p);\n-\t\t  OMP_CLAUSE_SCHEDULE_KIND (c)\n-\t\t    = (enum omp_clause_schedule_kind)\n-\t\t      (OMP_CLAUSE_SCHEDULE_KIND (c)\n-\t\t       & ~OMP_CLAUSE_SCHEDULE_NONMONOTONIC);\n-\t\t}\n-\t    }\n-\n \t  t = OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c);\n \t  if (t == NULL)\n \t    ;\n@@ -6406,7 +6598,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"schedule chunk size expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"schedule chunk size expression must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -6436,8 +6629,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%qs length expression must be integral\",\n-\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qs length expression must be integral\",\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else\n@@ -6449,9 +6643,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  if (TREE_CODE (t) != INTEGER_CST\n \t\t      || tree_int_cst_sgn (t) != 1)\n \t\t    {\n-\t\t      error (\"%qs length expression must be positive constant\"\n-\t\t\t     \" integer expression\",\n-\t\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%qs length expression must be positive \"\n+\t\t\t\t\"constant integer expression\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t      remove = true;\n \t\t    }\n \t\t}\n@@ -6468,7 +6663,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<async%> expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<async%> expression must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -6496,7 +6692,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<thread_limit%> expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<thread_limit%> expression must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -6525,7 +6722,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<device%> id must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<device%> id must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -6546,14 +6744,15 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<dist_schedule%> chunk size expression must be \"\n-\t\t     \"integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<dist_schedule%> chunk size expression must be \"\n+\t\t\t\"integral\");\n \t      remove = true;\n \t    }\n \t  else\n \t    {\n \t      t = mark_rvalue_use (t);\n-\t      if (!processing_template_decl)\n+ \t      if (!processing_template_decl)\n \t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t      OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c) = t;\n \t    }\n@@ -6563,8 +6762,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == current_class_ptr && ort != C_ORT_OMP_DECLARE_SIMD)\n \t    {\n-\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t     \" clauses\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t\t\" clauses\");\n \t      remove = true;\n \t      break;\n \t    }\n@@ -6573,9 +6773,11 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in %<aligned%> clause\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in %<aligned%> clause\", t);\n \t      else\n-\t\terror (\"%qE is not a variable in %<aligned%> clause\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in %<aligned%> clause\", t);\n \t      remove = true;\n \t    }\n \t  else if (!type_dependent_expression_p (t)\n@@ -6593,7 +6795,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  else if (bitmap_bit_p (&aligned_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qD appears more than once in %<aligned%> clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in %<aligned%> clauses\",\n+\t\t\tt);\n \t      remove = true;\n \t    }\n \t  else\n@@ -6606,8 +6810,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<aligned%> clause alignment expression must \"\n-\t\t     \"be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<aligned%> clause alignment expression must \"\n+\t\t\t\"be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -6619,15 +6824,45 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  if (TREE_CODE (t) != INTEGER_CST\n \t\t      || tree_int_cst_sgn (t) != 1)\n \t\t    {\n-\t\t      error (\"%<aligned%> clause alignment expression must be \"\n-\t\t\t     \"positive constant integer expression\");\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%<aligned%> clause alignment expression must \"\n+\t\t\t\t\"be positive constant integer expression\");\n \t\t      remove = true;\n \t\t    }\n+\t\t  else\n+\t\t    t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t\t}\n \t      OMP_CLAUSE_ALIGNED_ALIGNMENT (c) = t;\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_NONTEMPORAL:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n+\t\tbreak;\n+\t      if (DECL_P (t))\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in %<nontemporal%> clause\",\n+\t\t\t  t);\n+\t      else\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in %<nontemporal%> clause\",\n+\t\t\t  t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&oacc_reduction_head, DECL_UID (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD appears more than once in %<nontemporal%> \"\n+\t\t\t\"clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&oacc_reduction_head, DECL_UID (t));\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n@@ -6642,33 +6877,108 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tremove = true;\n \t      break;\n \t    }\n+\t  if (TREE_CODE (t) == TREE_LIST\n+\t      && TREE_PURPOSE (t)\n+\t      && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t    {\n+\t      if (TREE_PURPOSE (t) != last_iterators)\n+\t\tlast_iterators_remove\n+\t\t  = cp_omp_finish_iterators (TREE_PURPOSE (t));\n+\t      last_iterators = TREE_PURPOSE (t);\n+\t      t = TREE_VALUE (t);\n+\t      if (last_iterators_remove)\n+\t\tt = error_mark_node;\n+\t    }\n+\t  else\n+\t    last_iterators = NULL_TREE;\n+\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n \t      if (handle_omp_array_sections (c, ort))\n \t\tremove = true;\n+\t      else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<depend%> clause with %<depobj%> dependence \"\n+\t\t\t    \"type on array section\");\n+\t\t  remove = true;\n+\t\t}\n \t      break;\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n-\t  else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n+\t  else if (t == current_class_ptr)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t\t\" clauses\");\n+\t      remove = true;\n+\t    }\n+\t  else if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n+\t    break;\n+\t  else if (!lvalue_p (t))\n \t    {\n-\t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n-\t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in %<depend%> clause\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not lvalue expression nor array section \"\n+\t\t\t  \"in %<depend%> clause\", t);\n \t      else\n-\t\terror (\"%qE is not a variable in %<depend%> clause\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not lvalue expression nor array section \"\n+\t\t\t  \"in %<depend%> clause\", t);\n \t      remove = true;\n \t    }\n-\t  else if (t == current_class_ptr)\n+\t  else if (TREE_CODE (t) == COMPONENT_REF\n+\t\t   && TREE_CODE (TREE_OPERAND (t, 1)) == FIELD_DECL\n+\t\t   && DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t    {\n-\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t     \" clauses\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"bit-field %qE in %qs clause\", t, \"depend\");\n \t      remove = true;\n \t    }\n-\t  else if (!processing_template_decl\n-\t\t   && !cxx_mark_addressable (t))\n-\t    remove = true;\n+\t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t    {\n+\t      if (!c_omp_depend_t_p (TYPE_REF_P (TREE_TYPE (t))\n+\t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n+\t\t\t\t     : TREE_TYPE (t)))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE does not have %<omp_depend_t%> type in \"\n+\t\t\t    \"%<depend%> clause with %<depobj%> dependence \"\n+\t\t\t    \"type\", t);\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n+\t  else if (c_omp_depend_t_p (TYPE_REF_P (TREE_TYPE (t))\n+\t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n+\t\t\t\t     : TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE should not have %<omp_depend_t%> type in \"\n+\t\t\t\"%<depend%> clause with dependence type other than \"\n+\t\t\t\"%<depobj%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  if (!remove)\n+\t    {\n+\t      tree addr = cp_build_addr_expr (t, tf_warning_or_error);\n+\t      if (addr == error_mark_node)\n+\t\tremove = true;\n+\t      else\n+\t\t{\n+\t\t  t = cp_build_indirect_ref (addr, RO_UNARY_STAR,\n+\t\t\t\t\t     tf_warning_or_error);\n+\t\t  if (t == error_mark_node)\n+\t\t    remove = true;\n+\t\t  else if (TREE_CODE (OMP_CLAUSE_DECL (c)) == TREE_LIST\n+\t\t\t   && TREE_PURPOSE (OMP_CLAUSE_DECL (c))\n+\t\t\t   && (TREE_CODE (TREE_PURPOSE (OMP_CLAUSE_DECL (c)))\n+\t\t\t       == TREE_VEC))\n+\t\t    TREE_VALUE (OMP_CLAUSE_DECL (c)) = t;\n+\t\t  else\n+\t\t    OMP_CLAUSE_DECL (c) = t;\n+\t\t}\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_MAP:\n@@ -6707,14 +7017,17 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t\t\t{\n \t\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n-\t\t\t    error (\"%qD appears more than once in motion\"\n-\t\t\t\t   \" clauses\", t);\n+\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      \"%qD appears more than once in motion\"\n+\t\t\t\t      \" clauses\", t);\n \t\t\t  else if (ort == C_ORT_ACC)\n-\t\t\t    error (\"%qD appears more than once in data\"\n-\t\t\t\t   \" clauses\", t);\n+\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      \"%qD appears more than once in data\"\n+\t\t\t\t      \" clauses\", t);\n \t\t\t  else\n-\t\t\t    error (\"%qD appears more than once in map\"\n-\t\t\t\t   \" clauses\", t);\n+\t\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      \"%qD appears more than once in map\"\n+\t\t\t\t      \" clauses\", t);\n \t\t\t  remove = true;\n \t\t\t}\n \t\t      else\n@@ -6790,23 +7103,27 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER))\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in %qs clause\", t,\n-\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not a variable in %qs clause\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      else\n-\t\terror (\"%qE is not a variable in %qs clause\", t,\n-\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not a variable in %qs clause\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))\n \t    {\n-\t      error (\"%qD is threadprivate variable in %qs clause\", t,\n-\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD is threadprivate variable in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (ort != C_ORT_ACC && t == current_class_ptr)\n \t    {\n-\t      error (\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t     \" clauses\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n+\t\t\t\" clauses\");\n \t      remove = true;\n \t      break;\n \t    }\n@@ -6837,7 +7154,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t   && !type_dependent_expression_p (t)\n \t\t   && !INDIRECT_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%qD is not a pointer variable\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD is not a pointer variable\", t);\n \t      remove = true;\n \t    }\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n@@ -6846,15 +7164,18 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t  || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t\t{\n-\t\t  error (\"%qD appears more than once in data clauses\", t);\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qD appears more than once in data clauses\", t);\n \t\t  remove = true;\n \t\t}\n \t      else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t\t{\n \t\t  if (ort == C_ORT_ACC)\n-\t\t    error (\"%qD appears more than once in data clauses\", t);\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"%qD appears more than once in data clauses\", t);\n \t\t  else\n-\t\t    error (\"%qD appears both in data and map clauses\", t);\n+\t\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t      \"%qD appears both in data and map clauses\", t);\n \t\t  remove = true;\n \t\t}\n \t      else\n@@ -6863,20 +7184,25 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n-\t\terror (\"%qD appears more than once in motion clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in motion clauses\", t);\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears more than once in map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n \t      if (ort == C_ORT_ACC)\n-\t\terror (\"%qD appears more than once in data clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears more than once in data clauses\", t);\n \t      else\n-\t\terror (\"%qD appears both in data and map clauses\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD appears both in data and map clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -6991,9 +7317,11 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (processing_template_decl)\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not an argument in %<uniform%> clause\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not an argument in %<uniform%> clause\", t);\n \t      else\n-\t\terror (\"%qE is not an argument in %<uniform%> clause\", t);\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not an argument in %<uniform%> clause\", t);\n \t      remove = true;\n \t      break;\n \t    }\n@@ -7008,7 +7336,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<grainsize%> expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<grainsize%> expression must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -7037,7 +7366,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<priority%> expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<priority%> expression must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -7066,7 +7396,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (!type_dependent_expression_p (t)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%<num_tasks%> expression must be integral\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<hint%> expression must be integral\");\n \t      remove = true;\n \t    }\n \t  else\n@@ -7076,6 +7407,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t{\n \t\t  t = maybe_constant_value (t);\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t  if (TREE_CODE (t) != INTEGER_CST)\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%<hint%> expression must be constant integer \"\n+\t\t\t\t\"expression\");\n+\t\t      remove = true;\n+\t\t    }\n \t\t}\n \t      OMP_CLAUSE_HINT_EXPR (c) = t;\n \t    }\n@@ -7172,8 +7510,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_NOTINBRANCH:\n \t  if (branch_seen)\n \t    {\n-\t      error (\"%<inbranch%> clause is incompatible with \"\n-\t\t     \"%<notinbranch%>\");\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<inbranch%> clause is incompatible with \"\n+\t\t\t\"%<notinbranch%>\");\n \t      remove = true;\n \t    }\n \t  branch_seen = true;\n@@ -7224,6 +7563,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_LINEAR:\n@@ -7276,6 +7617,17 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n+\tcase OMP_CLAUSE_NOGROUP:\n+\t  if (reduction_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<nogroup%> clause must not be used together with \"\n+\t\t\t\"%<reduction%> clause\");\n+\t      *pc = OMP_CLAUSE_CHAIN (c);\n+\t      continue;\n+\t    }\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n \tcase OMP_CLAUSE_NOWAIT:\n \t  if (copyprivate_seen)\n \t    {\n@@ -7310,6 +7662,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  if (finish_omp_reduction_clause (c, &need_default_ctor,\n \t\t\t\t\t   &need_dtor))\n \t    remove = true;\n@@ -7320,7 +7674,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_COPYIN:\n \t  if (!VAR_P (t) || !CP_DECL_THREAD_LOCAL_P (t))\n \t    {\n-\t      error (\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n \t      remove = true;\n \t    }\n \t  break;\n@@ -7349,10 +7704,17 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n \t      break;\n \t    case OMP_CLAUSE_DEFAULT_SHARED:\n-\t      /* const vars may be specified in firstprivate clause.  */\n-\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t      if (VAR_P (t)\n+\t\t  && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t  && TREE_STATIC (t)\n \t\t  && cxx_omp_const_qual_no_mutable (t))\n-\t\tbreak;\n+\t\t{\n+\t\t  tree ctx = CP_DECL_CONTEXT (t);\n+\t\t  /* const qualified static data members without mutable\n+\t\t     member may be specified in firstprivate clause.  */\n+\t\t  if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))\n+\t\t    break;\n+\t\t}\n \t      share_name = \"shared\";\n \t      break;\n \t    case OMP_CLAUSE_DEFAULT_PRIVATE:\n@@ -7363,9 +7725,20 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  if (share_name)\n \t    {\n-\t      error (\"%qE is predetermined %qs for %qs\",\n-\t\t     omp_clause_printable_decl (t), share_name,\n-\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is predetermined %qs for %qs\",\n+\t\t\tomp_clause_printable_decl (t), share_name,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_SHARED\n+\t\t   && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE\n+\t\t   && cxx_omp_const_qual_no_mutable (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<const%> qualified %qE without %<mutable%> member \"\n+\t\t\t\"may appear only in %<shared%> or %<firstprivate%> \"\n+\t\t\t\"clauses\", omp_clause_printable_decl (t));\n \t      remove = true;\n \t    }\n \t}\n@@ -7374,7 +7747,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n       inner_type = type = TREE_TYPE (t);\n       if ((need_complete_type\n \t   || need_copy_assignment\n-\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t  && TYPE_REF_P (inner_type))\n \tinner_type = TREE_TYPE (inner_type);\n       while (TREE_CODE (inner_type) == ARRAY_TYPE)\n@@ -7876,6 +8251,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n     }\n \n   incr = cp_convert (TREE_TYPE (diff), incr, tf_warning_or_error);\n+  incr = cp_fully_fold (incr);\n   bool taskloop_iv_seen = false;\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n@@ -8011,12 +8387,22 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t= pop_stmt_list (OMP_CLAUSE_LASTPRIVATE_STMT (c));\n     }\n \n+  if (TREE_CODE (TREE_VEC_ELT (orig_declv, i)) == TREE_LIST)\n+    {\n+      tree t = TREE_VEC_ELT (orig_declv, i);\n+      gcc_assert (TREE_PURPOSE (t) == NULL_TREE\n+\t\t  && TREE_VALUE (t) == NULL_TREE\n+\t\t  && TREE_CODE (TREE_CHAIN (t)) == TREE_VEC);\n+      TREE_PURPOSE (t) = TREE_VEC_ELT (declv, i);\n+      TREE_VALUE (t) = last;\n+    }\n+  else\n+    TREE_VEC_ELT (orig_declv, i)\n+      = tree_cons (TREE_VEC_ELT (declv, i), last, NULL_TREE);\n   TREE_VEC_ELT (declv, i) = decl;\n   TREE_VEC_ELT (initv, i) = init;\n   TREE_VEC_ELT (condv, i) = cond;\n   TREE_VEC_ELT (incrv, i) = incr;\n-  TREE_VEC_ELT (orig_declv, i)\n-    = tree_cons (TREE_VEC_ELT (orig_declv, i), last, NULL_TREE);\n \n   return false;\n }\n@@ -8098,6 +8484,9 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       if (init && EXPR_HAS_LOCATION (init))\n \telocus = EXPR_LOCATION (init);\n \n+      if (cond == global_namespace)\n+\tcontinue;\n+\n       if (cond == NULL)\n \t{\n \t  error_at (elocus, \"missing controlling predicate\");\n@@ -8120,7 +8509,8 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       tree orig_init;\n       FOR_EACH_VEC_ELT (*orig_inits, i, orig_init)\n \tif (orig_init\n-\t    && !c_omp_check_loop_iv_exprs (locus, declv,\n+\t    && !c_omp_check_loop_iv_exprs (locus, orig_declv\n+\t\t\t\t\t\t  ? orig_declv : declv,\n \t\t\t\t\t   TREE_VEC_ELT (declv, i), orig_init,\n \t\t\t\t\t   NULL_TREE, cp_walk_subtrees))\n \t  fail = true;\n@@ -8253,11 +8643,12 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       i++;\n     }\n \n-  if (IS_EMPTY_STMT (pre_body))\n+  if (pre_body && IS_EMPTY_STMT (pre_body))\n     pre_body = NULL;\n \n   omp_for = c_finish_omp_for (locus, code, declv, orig_declv, initv, condv,\n-\t\t\t      incrv, body, pre_body);\n+\t\t\t      incrv, body, pre_body,\n+\t\t\t      !processing_template_decl);\n \n   /* Check for iterators appearing in lb, b or incr expressions.  */\n   if (omp_for && !c_omp_check_loop_iv (omp_for, orig_declv, cp_walk_subtrees))\n@@ -8369,9 +8760,55 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   return omp_for;\n }\n \n+/* Fix up range for decls.  Those decls were pushed into BIND's BIND_EXPR_VARS\n+   and need to be moved into the BIND_EXPR inside of the OMP_FOR's body.  */\n+\n+tree\n+finish_omp_for_block (tree bind, tree omp_for)\n+{\n+  if (omp_for == NULL_TREE\n+      || !OMP_FOR_ORIG_DECLS (omp_for)\n+      || bind == NULL_TREE\n+      || TREE_CODE (bind) != BIND_EXPR)\n+    return bind;\n+  tree b = NULL_TREE;\n+  for (int i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (omp_for)); i++)\n+    if (TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (omp_for), i)) == TREE_LIST\n+\t&& TREE_CHAIN (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (omp_for), i)))\n+      {\n+\ttree v = TREE_CHAIN (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (omp_for), i));\n+\tgcc_assert (BIND_EXPR_BLOCK (bind)\n+\t\t    && (BIND_EXPR_VARS (bind)\n+\t\t\t== BLOCK_VARS (BIND_EXPR_BLOCK (bind))));\n+\tfor (int j = 2; j < TREE_VEC_LENGTH (v); j++)\n+\t  for (tree *p = &BIND_EXPR_VARS (bind); *p; p = &DECL_CHAIN (*p))\n+\t    {\n+\t      if (*p == TREE_VEC_ELT (v, j))\n+\t\t{\n+\t\t  tree var = *p;\n+\t\t  *p = DECL_CHAIN (*p);\n+\t\t  if (b == NULL_TREE)\n+\t\t    {\n+\t\t      b = make_node (BLOCK);\n+\t\t      b = build3 (BIND_EXPR, void_type_node, NULL_TREE,\n+\t\t\t\t  OMP_FOR_BODY (omp_for), b);\n+\t\t      TREE_SIDE_EFFECTS (b) = 1;\n+\t\t      OMP_FOR_BODY (omp_for) = b;\n+\t\t    }\n+\t\t  DECL_CHAIN (var) = BIND_EXPR_VARS (b);\n+\t\t  BIND_EXPR_VARS (b) = var;\n+\t\t  BLOCK_VARS (BIND_EXPR_BLOCK (b)) = var;\n+\t\t}\n+\t    }\n+\tBLOCK_VARS (BIND_EXPR_BLOCK (bind)) = BIND_EXPR_VARS (bind);\n+      }\n+  return bind;\n+}\n+\n void\n-finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n-\t\t   tree rhs, tree v, tree lhs1, tree rhs1, bool seq_cst)\n+finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n+\t\t   tree lhs, tree rhs, tree v, tree lhs1, tree rhs1,\n+\t\t   tree clauses, enum omp_memory_order mo)\n {\n   tree orig_lhs;\n   tree orig_rhs;\n@@ -8398,6 +8835,15 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n \t\t     || (v && type_dependent_expression_p (v))\n \t\t     || (lhs1 && type_dependent_expression_p (lhs1))\n \t\t     || (rhs1 && type_dependent_expression_p (rhs1)));\n+      if (clauses)\n+\t{\n+\t  gcc_assert (TREE_CODE (clauses) == OMP_CLAUSE\n+\t\t      && OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_HINT\n+\t\t      && OMP_CLAUSE_CHAIN (clauses) == NULL_TREE);\n+\t  if (type_dependent_expression_p (OMP_CLAUSE_HINT_EXPR (clauses))\n+\t      || TREE_CODE (OMP_CLAUSE_HINT_EXPR (clauses)) != INTEGER_CST)\n+\t    dependent_p = true;\n+\t}\n       if (!dependent_p)\n \t{\n \t  lhs = build_non_dependent_expr (lhs);\n@@ -8439,8 +8885,8 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n \t\t   \"expressions for memory\");\n \t  return;\n \t}\n-      stmt = c_finish_omp_atomic (input_location, code, opcode, lhs, rhs,\n-\t\t\t\t  v, lhs1, rhs1, swapped, seq_cst,\n+      stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs,\n+\t\t\t\t  v, lhs1, rhs1, swapped, mo,\n \t\t\t\t  processing_template_decl != 0);\n       if (stmt == error_mark_node)\n \treturn;\n@@ -8449,9 +8895,8 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n     {\n       if (code == OMP_ATOMIC_READ)\n \t{\n-\t  stmt = build_min_nt_loc (EXPR_LOCATION (orig_lhs),\n-\t\t\t\t   OMP_ATOMIC_READ, orig_lhs);\n-\t  OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;\n+\t  stmt = build_min_nt_loc (loc, OMP_ATOMIC_READ, orig_lhs);\n+\t  OMP_ATOMIC_MEMORY_ORDER (stmt) = mo;\n \t  stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n \t}\n       else\n@@ -8465,14 +8910,15 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n \t\t\t\t     COMPOUND_EXPR, orig_rhs1, stmt);\n \t  if (code != OMP_ATOMIC)\n \t    {\n-\t      stmt = build_min_nt_loc (EXPR_LOCATION (orig_lhs1),\n-\t\t\t\t       code, orig_lhs1, stmt);\n-\t      OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;\n+\t      stmt = build_min_nt_loc (loc, code, orig_lhs1, stmt);\n+\t      OMP_ATOMIC_MEMORY_ORDER (stmt) = mo;\n \t      stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n \t    }\n \t}\n-      stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node, stmt);\n-      OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;\n+      stmt = build2 (OMP_ATOMIC, void_type_node,\n+\t\t     clauses ? clauses : integer_zero_node, stmt);\n+      OMP_ATOMIC_MEMORY_ORDER (stmt) = mo;\n+      SET_EXPR_LOCATION (stmt, loc);\n     }\n   finish_expr_stmt (stmt);\n }\n@@ -8488,10 +8934,50 @@ finish_omp_barrier (void)\n }\n \n void\n-finish_omp_flush (void)\n+finish_omp_depobj (location_t loc, tree depobj,\n+\t\t   enum omp_clause_depend_kind kind, tree clause)\n+{\n+  if (!error_operand_p (depobj) && !type_dependent_expression_p (depobj))\n+    {\n+      if (!lvalue_p (depobj))\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (depobj, loc),\n+\t\t    \"%<depobj%> expression is not lvalue expression\");\n+\t  depobj = error_mark_node;\n+\t}\n+    }\n+\n+  if (processing_template_decl)\n+    {\n+      if (clause == NULL_TREE)\n+\tclause = build_int_cst (integer_type_node, kind);\n+      add_stmt (build_min_nt_loc (loc, OMP_DEPOBJ, depobj, clause));\n+      return;\n+    }\n+\n+  if (!error_operand_p (depobj))\n+    {\n+      tree addr = cp_build_addr_expr (depobj, tf_warning_or_error);\n+      if (addr == error_mark_node)\n+\tdepobj = error_mark_node;\n+      else\n+\tdepobj = cp_build_indirect_ref (addr, RO_UNARY_STAR,\n+\t\t\t\t\ttf_warning_or_error);\n+    }\n+\n+  c_finish_omp_depobj (loc, depobj, kind, clause);\n+}\n+\n+void\n+finish_omp_flush (int mo)\n {\n   tree fn = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n   vec<tree, va_gc> *vec = make_tree_vector ();\n+  if (mo != MEMMODEL_LAST)\n+    {\n+      fn = builtin_decl_explicit (BUILT_IN_ATOMIC_THREAD_FENCE);\n+      vec->quick_push (build_int_cst (integer_type_node, mo));\n+    }\n   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n@@ -8540,6 +9026,11 @@ finish_omp_cancel (tree clauses)\n   tree ifc = omp_find_clause (clauses, OMP_CLAUSE_IF);\n   if (ifc != NULL_TREE)\n     {\n+      if (OMP_CLAUSE_IF_MODIFIER (ifc) != ERROR_MARK\n+\t  && OMP_CLAUSE_IF_MODIFIER (ifc) != VOID_CST)\n+\terror_at (OMP_CLAUSE_LOCATION (ifc),\n+\t\t  \"expected %<cancel%> %<if%> clause modifier\");\n+\n       tree type = TREE_TYPE (OMP_CLAUSE_IF_EXPR (ifc));\n       ifc = fold_build2_loc (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,\n \t\t\t     boolean_type_node, OMP_CLAUSE_IF_EXPR (ifc),"}, {"sha": "f5bcec3d69fa9e84ba1b4cf39b9d04bd2d796a46", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,19 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Use\n+\tOMP_CLAUSE_DEFAULTMAP_SET_KIND.\n+\t(gfc_trans_omp_atomic): Set OMP_ATOMIC_MEMORY_ORDER\n+\trather than OMP_ATOMIC_SEQ_CST.\n+\t(gfc_trans_omp_taskgroup): Build OMP_TASKGROUP using\n+\tmake_node instead of build1_loc.\n+\t* types.def (BT_FN_VOID_BOOL, BT_FN_VOID_SIZE_SIZE_PTR,\n+\tBT_FN_UINT_UINT_PTR_PTR, BT_FN_UINT_OMPFN_PTR_UINT_UINT,\n+\tBT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\tBT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\tBT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR): New.\n+\t(BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR): Formatting fix.\n+\n 2018-11-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/46020"}, {"sha": "483ca663663c11dd239986d21d1be8ee426b4dc9", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -2866,6 +2866,8 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n   if (clauses->defaultmap)\n     {\n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_DEFAULTMAP);\n+      OMP_CLAUSE_DEFAULTMAP_SET_KIND (c, OMP_CLAUSE_DEFAULTMAP_TOFROM,\n+\t\t\t\t      OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n   if (clauses->depend_source)\n@@ -3166,7 +3168,9 @@ gfc_trans_omp_atomic (gfc_code *code)\n   enum tree_code op = ERROR_MARK;\n   enum tree_code aop = OMP_ATOMIC;\n   bool var_on_left = false;\n-  bool seq_cst = (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SEQ_CST) != 0;\n+  enum omp_memory_order mo\n+    = ((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SEQ_CST)\n+       ? OMP_MEMORY_ORDER_SEQ_CST : OMP_MEMORY_ORDER_RELAXED);\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n@@ -3198,7 +3202,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n       lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n \n       x = build1 (OMP_ATOMIC_READ, type, lhsaddr);\n-      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n+      OMP_ATOMIC_MEMORY_ORDER (x) = mo;\n       x = convert (TREE_TYPE (vse.expr), x);\n       gfc_add_modify (&block, vse.expr, x);\n \n@@ -3398,7 +3402,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   if (aop == OMP_ATOMIC)\n     {\n       x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n-      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n+      OMP_ATOMIC_MEMORY_ORDER (x) = mo;\n       gfc_add_expr_to_block (&block, x);\n     }\n   else\n@@ -3421,7 +3425,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t  gfc_add_block_to_block (&block, &lse.pre);\n \t}\n       x = build2 (aop, type, lhsaddr, convert (type, x));\n-      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n+      OMP_ATOMIC_MEMORY_ORDER (x) = mo;\n       x = convert (TREE_TYPE (vse.expr), x);\n       gfc_add_modify (&block, vse.expr, x);\n     }\n@@ -4586,8 +4590,12 @@ gfc_trans_omp_task (gfc_code *code)\n static tree\n gfc_trans_omp_taskgroup (gfc_code *code)\n {\n-  tree stmt = gfc_trans_code (code->block->next);\n-  return build1_loc (input_location, OMP_TASKGROUP, void_type_node, stmt);\n+  tree body = gfc_trans_code (code->block->next);\n+  tree stmt = make_node (OMP_TASKGROUP);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TASKGROUP_BODY (stmt) = body;\n+  OMP_TASKGROUP_CLAUSES (stmt) = NULL_TREE;\n+  return stmt;\n }\n \n static tree"}, {"sha": "0eabc3f4d993e39f5e9356e7603a2abb161b34be", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -86,6 +86,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_BOOL, BT_VOID, BT_BOOL)\n DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n@@ -145,9 +146,14 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_SIZE_SIZE_PTR, BT_VOID, BT_SIZE, BT_SIZE,\n+\t\t     BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_PTR_PTR, BT_UINT, BT_UINT, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_4 (BT_FN_UINT_OMPFN_PTR_UINT_UINT,\n+\t\t     BT_UINT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_PTR_WORD_WORD_PTR,\n \t\t     BT_VOID, BT_PTR, BT_WORD, BT_WORD, BT_PTR)\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n@@ -217,14 +223,28 @@ DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR,\n DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n+DEF_FUNCTION_TYPE_8 (BT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_8 (BT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_LONG, BT_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n \t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n \t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR,\n-\t\t      BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n-\t\t      BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_PTR)\n+\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n+\t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_9 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG, BT_PTR, BT_PTR)\n+\n+DEF_FUNCTION_TYPE_10 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t      BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n+\t\t      BT_ULONGLONG, BT_LONG, BT_ULONGLONG, BT_PTR_ULONGLONG,\n+\t\t      BT_PTR_ULONGLONG, BT_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_11 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,\n \t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,"}, {"sha": "40406dfa88f53b5f236f9ce86bcb7d2fb6ddc805", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1724,7 +1724,8 @@ open_base_files (void)\n       \"tree-dfa.h\", \"tree-ssa.h\", \"reload.h\", \"cpplib.h\", \"tree-chrec.h\",\n       \"except.h\", \"output.h\",  \"cfgloop.h\", \"target.h\", \"lto-streamer.h\",\n       \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"symbol-summary.h\",\n-      \"ipa-prop.h\", \"ipa-fnsummary.h\", \"dwarf2out.h\", \"omp-offload.h\", NULL\n+      \"ipa-prop.h\", \"ipa-fnsummary.h\", \"dwarf2out.h\", \"omp-general.h\",\n+      \"omp-offload.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "276e5798baced46fe2a112732abd4d6da139e092", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1554,6 +1554,35 @@ dump_gimple_omp_single (pretty_printer *buffer, gomp_single *gs,\n     }\n }\n \n+/* Dump a GIMPLE_OMP_TASKGROUP tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_taskgroup (pretty_printer *buffer, gimple *gs,\n+\t\t\t   int spc, dump_flags_t flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_taskgroup_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp taskgroup\");\n+      dump_omp_clauses (buffer, gimple_omp_taskgroup_clauses (gs), spc, flags);\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_left_brace (buffer);\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_right_brace (buffer);\n+\t}\n+    }\n+}\n+\n /* Dump a GIMPLE_OMP_TARGET tuple on the pretty_printer BUFFER.  */\n \n static void\n@@ -1712,7 +1741,7 @@ dump_gimple_omp_sections (pretty_printer *buffer, gomp_sections *gs,\n     }\n }\n \n-/* Dump a GIMPLE_OMP_{MASTER,TASKGROUP,ORDERED,SECTION} tuple on the\n+/* Dump a GIMPLE_OMP_{MASTER,ORDERED,SECTION} tuple on the\n    pretty_printer BUFFER.  */\n \n static void\n@@ -2301,6 +2330,8 @@ dump_gimple_omp_task (pretty_printer *buffer, gomp_task *gs, int spc,\n       gimple_seq body;\n       if (gimple_omp_task_taskloop_p (gs))\n \tpp_string (buffer, \"#pragma omp taskloop\");\n+      else if (gimple_omp_task_taskwait_p (gs))\n+\tpp_string (buffer, \"#pragma omp taskwait\");\n       else\n \tpp_string (buffer, \"#pragma omp task\");\n       dump_omp_clauses (buffer, gimple_omp_task_clauses (gs), spc, flags);\n@@ -2353,8 +2384,8 @@ dump_gimple_omp_atomic_load (pretty_printer *buffer, gomp_atomic_load *gs,\n   else\n     {\n       pp_string (buffer, \"#pragma omp atomic_load\");\n-      if (gimple_omp_atomic_seq_cst_p (gs))\n-\tpp_string (buffer, \" seq_cst\");\n+      dump_omp_atomic_memory_order (buffer,\n+\t\t\t\t    gimple_omp_atomic_memory_order (gs));\n       if (gimple_omp_atomic_need_value_p (gs))\n \tpp_string (buffer, \" [needed]\");\n       newline_and_indent (buffer, spc + 2);\n@@ -2385,9 +2416,10 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer,\n     }\n   else\n     {\n-      pp_string (buffer, \"#pragma omp atomic_store \");\n-      if (gimple_omp_atomic_seq_cst_p (gs))\n-\tpp_string (buffer, \"seq_cst \");\n+      pp_string (buffer, \"#pragma omp atomic_store\");\n+      dump_omp_atomic_memory_order (buffer,\n+\t\t\t\t    gimple_omp_atomic_memory_order (gs));\n+      pp_space (buffer);\n       if (gimple_omp_atomic_need_value_p (gs))\n \tpp_string (buffer, \"[needed] \");\n       pp_left_paren (buffer);\n@@ -2569,8 +2601,11 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple *gs, int spc,\n       pp_string (buffer, \"GIMPLE_SECTIONS_SWITCH\");\n       break;\n \n-    case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_TASKGROUP:\n+      dump_gimple_omp_taskgroup (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_GRID_BODY:\n       dump_gimple_omp_block (buffer, gs, spc, flags);"}, {"sha": "41d9f677c4f755182dd5fcbf5ac842db2a531d11", "filename": "gcc/gimple.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -924,7 +924,7 @@ gimple_build_omp_critical (gimple_seq body, tree name, tree clauses)\n \n    BODY is sequence of statements inside the for loop.\n    KIND is the `for' variant.\n-   CLAUSES, are any of the construct's clauses.\n+   CLAUSES are any of the construct's clauses.\n    COLLAPSE is the collapse count.\n    PRE_BODY is the sequence of statements that are loop invariant.  */\n \n@@ -950,7 +950,7 @@ gimple_build_omp_for (gimple_seq body, int kind, tree clauses, size_t collapse,\n /* Build a GIMPLE_OMP_PARALLEL statement.\n \n    BODY is sequence of statements which are executed in parallel.\n-   CLAUSES, are the OMP parallel construct's clauses.\n+   CLAUSES are the OMP parallel construct's clauses.\n    CHILD_FN is the function created for the parallel threads to execute.\n    DATA_ARG are the shared data argument(s).  */\n \n@@ -973,7 +973,7 @@ gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn,\n /* Build a GIMPLE_OMP_TASK statement.\n \n    BODY is sequence of statements which are executed by the explicit task.\n-   CLAUSES, are the OMP parallel construct's clauses.\n+   CLAUSES are the OMP task construct's clauses.\n    CHILD_FN is the function created for the parallel threads to execute.\n    DATA_ARG are the shared data argument(s).\n    COPY_FN is the optional function for firstprivate initialization.\n@@ -1044,12 +1044,14 @@ gimple_build_omp_grid_body (gimple_seq body)\n /* Build a GIMPLE_OMP_TASKGROUP statement.\n \n    BODY is the sequence of statements to be executed by the taskgroup\n-   construct.  */\n+   construct.\n+   CLAUSES are any of the construct's clauses.  */\n \n gimple *\n-gimple_build_omp_taskgroup (gimple_seq body)\n+gimple_build_omp_taskgroup (gimple_seq body, tree clauses)\n {\n   gimple *p = gimple_alloc (GIMPLE_OMP_TASKGROUP, 0);\n+  gimple_omp_taskgroup_set_clauses (p, clauses);\n   if (body)\n     gimple_omp_set_body (p, body);\n \n@@ -1192,12 +1194,13 @@ gimple_build_omp_teams (gimple_seq body, tree clauses)\n /* Build a GIMPLE_OMP_ATOMIC_LOAD statement.  */\n \n gomp_atomic_load *\n-gimple_build_omp_atomic_load (tree lhs, tree rhs)\n+gimple_build_omp_atomic_load (tree lhs, tree rhs, enum omp_memory_order mo)\n {\n   gomp_atomic_load *p\n     = as_a <gomp_atomic_load *> (gimple_alloc (GIMPLE_OMP_ATOMIC_LOAD, 0));\n   gimple_omp_atomic_load_set_lhs (p, lhs);\n   gimple_omp_atomic_load_set_rhs (p, rhs);\n+  gimple_omp_atomic_set_memory_order (p, mo);\n   return p;\n }\n \n@@ -1206,11 +1209,12 @@ gimple_build_omp_atomic_load (tree lhs, tree rhs)\n    VAL is the value we are storing.  */\n \n gomp_atomic_store *\n-gimple_build_omp_atomic_store (tree val)\n+gimple_build_omp_atomic_store (tree val, enum omp_memory_order mo)\n {\n   gomp_atomic_store *p\n     = as_a <gomp_atomic_store *> (gimple_alloc (GIMPLE_OMP_ATOMIC_STORE, 0));\n   gimple_omp_atomic_store_set_val (p, val);\n+  gimple_omp_atomic_set_memory_order (p, mo);\n   return p;\n }\n \n@@ -1935,6 +1939,11 @@ gimple_copy (gimple *stmt)\n \t  gimple_omp_ordered_set_clauses (as_a <gomp_ordered *> (copy), t);\n \t  goto copy_omp_body;\n \n+\tcase GIMPLE_OMP_TASKGROUP:\n+\t  t = unshare_expr (gimple_omp_taskgroup_clauses (stmt));\n+\t  gimple_omp_taskgroup_set_clauses (copy, t);\n+\t  goto copy_omp_body;\n+\n \tcase GIMPLE_OMP_SECTIONS:\n \t  t = unshare_expr (gimple_omp_sections_clauses (stmt));\n \t  gimple_omp_sections_set_clauses (copy, t);\n@@ -1971,7 +1980,6 @@ gimple_copy (gimple *stmt)\n \n \tcase GIMPLE_OMP_SECTION:\n \tcase GIMPLE_OMP_MASTER:\n-\tcase GIMPLE_OMP_TASKGROUP:\n \tcase GIMPLE_OMP_GRID_BODY:\n \tcopy_omp_body:\n \t  new_seq = gimple_seq_copy (gimple_omp_body (stmt));"}, {"sha": "38206e9cd6402457ca48d7c516842cb05d1a98be", "filename": "gcc/gimple.def", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -279,9 +279,10 @@ DEFGSCODE(GIMPLE_OMP_FOR, \"gimple_omp_for\", GSS_OMP_FOR)\n    BODY is the sequence of statements to execute in the master section.  */\n DEFGSCODE(GIMPLE_OMP_MASTER, \"gimple_omp_master\", GSS_OMP)\n \n-/* GIMPLE_OMP_TASKGROUP <BODY> represents #pragma omp taskgroup.\n-   BODY is the sequence of statements to execute in the taskgroup section.  */\n-DEFGSCODE(GIMPLE_OMP_TASKGROUP, \"gimple_omp_taskgroup\", GSS_OMP)\n+/* GIMPLE_OMP_TASKGROUP <BODY, CLAUSES> represents #pragma omp taskgroup.\n+   BODY is the sequence of statements inside the taskgroup section.\n+   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n+DEFGSCODE(GIMPLE_OMP_TASKGROUP, \"gimple_omp_taskgroup\", GSS_OMP_SINGLE_LAYOUT)\n \n /* GIMPLE_OMP_PARALLEL <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents\n \n@@ -366,10 +367,12 @@ DEFGSCODE(GIMPLE_OMP_SINGLE, \"gimple_omp_single\", GSS_OMP_SINGLE_LAYOUT)\n    implement the MAP clauses.  */\n DEFGSCODE(GIMPLE_OMP_TARGET, \"gimple_omp_target\", GSS_OMP_PARALLEL_LAYOUT)\n \n-/* GIMPLE_OMP_TEAMS <BODY, CLAUSES> represents #pragma omp teams\n+/* GIMPLE_OMP_TEAMS <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents\n+   #pragma omp teams\n    BODY is the sequence of statements inside the single section.\n-   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n-DEFGSCODE(GIMPLE_OMP_TEAMS, \"gimple_omp_teams\", GSS_OMP_SINGLE_LAYOUT)\n+   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.\n+   CHILD_FN and DATA_ARG like for GIMPLE_OMP_PARALLEL.  */\n+DEFGSCODE(GIMPLE_OMP_TEAMS, \"gimple_omp_teams\", GSS_OMP_PARALLEL_LAYOUT)\n \n /* GIMPLE_OMP_ORDERED <BODY, CLAUSES> represents #pragma omp ordered.\n    BODY is the sequence of statements to execute in the ordered section."}, {"sha": "145e9ad2fe3ca1e96a2a6afc775def0321320ac8", "filename": "gcc/gimple.h", "status": "modified", "additions": 162, "deletions": 21, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -151,6 +151,7 @@ enum gf_mask {\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_PARALLEL_GRID_PHONY = 1 << 1,\n     GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n+    GF_OMP_TASK_TASKWAIT\t= 1 << 1,\n     GF_OMP_FOR_KIND_MASK\t= (1 << 4) - 1,\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n     GF_OMP_FOR_KIND_DISTRIBUTE\t= 1,\n@@ -183,6 +184,7 @@ enum gf_mask {\n     GF_OMP_TARGET_KIND_OACC_DECLARE = 10,\n     GF_OMP_TARGET_KIND_OACC_HOST_DATA = 11,\n     GF_OMP_TEAMS_GRID_PHONY\t= 1 << 0,\n+    GF_OMP_TEAMS_HOST\t\t= 1 << 1,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n        a thread synchronization via some sort of barrier.  The exact barrier\n@@ -191,8 +193,8 @@ enum gf_mask {\n     GF_OMP_RETURN_NOWAIT\t= 1 << 0,\n \n     GF_OMP_SECTION_LAST\t\t= 1 << 0,\n-    GF_OMP_ATOMIC_NEED_VALUE\t= 1 << 0,\n-    GF_OMP_ATOMIC_SEQ_CST\t= 1 << 1,\n+    GF_OMP_ATOMIC_MEMORY_ORDER  = (1 << 3) - 1,\n+    GF_OMP_ATOMIC_NEED_VALUE\t= 1 << 3,\n     GF_PREDICT_TAKEN\t\t= 1 << 15\n };\n \n@@ -637,7 +639,7 @@ struct GTY((tag(\"GSS_OMP_FOR\")))\n };\n \n \n-/* GIMPLE_OMP_PARALLEL, GIMPLE_OMP_TARGET, GIMPLE_OMP_TASK */\n+/* GIMPLE_OMP_PARALLEL, GIMPLE_OMP_TARGET, GIMPLE_OMP_TASK, GIMPLE_OMP_TEAMS */\n \n struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n   gimple_statement_omp_parallel_layout : public gimple_statement_omp\n@@ -663,7 +665,8 @@ struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n {\n     /* No extra fields; adds invariant:\n          stmt->code == GIMPLE_OMP_PARALLEL\n-\t || stmt->code == GIMPLE_OMP_TASK.  */\n+\t || stmt->code == GIMPLE_OMP_TASK\n+\t || stmt->code == GIMPLE_OMP_TEAMS.  */\n };\n \n /* GIMPLE_OMP_PARALLEL */\n@@ -737,7 +740,7 @@ struct GTY((tag(\"GSS_OMP_CONTINUE\")))\n   tree control_use;\n };\n \n-/* GIMPLE_OMP_SINGLE, GIMPLE_OMP_TEAMS, GIMPLE_OMP_ORDERED */\n+/* GIMPLE_OMP_SINGLE, GIMPLE_OMP_ORDERED, GIMPLE_OMP_TASKGROUP.  */\n \n struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n   gimple_statement_omp_single_layout : public gimple_statement_omp\n@@ -755,8 +758,8 @@ struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n          stmt->code == GIMPLE_OMP_SINGLE.  */\n };\n \n-struct GTY((tag(\"GSS_OMP_SINGLE_LAYOUT\")))\n-  gomp_teams : public gimple_statement_omp_single_layout\n+struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n+  gomp_teams : public gimple_statement_omp_taskreg\n {\n     /* No extra fields; adds invariant:\n          stmt->code == GIMPLE_OMP_TEAMS.  */\n@@ -1121,7 +1124,9 @@ template <>\n inline bool\n is_a_helper <gimple_statement_omp_taskreg *>::test (gimple *gs)\n {\n-  return gs->code == GIMPLE_OMP_PARALLEL || gs->code == GIMPLE_OMP_TASK;\n+  return (gs->code == GIMPLE_OMP_PARALLEL\n+\t  || gs->code == GIMPLE_OMP_TASK\n+\t  || gs->code == GIMPLE_OMP_TEAMS);\n }\n \n template <>\n@@ -1337,7 +1342,9 @@ template <>\n inline bool\n is_a_helper <const gimple_statement_omp_taskreg *>::test (const gimple *gs)\n {\n-  return gs->code == GIMPLE_OMP_PARALLEL || gs->code == GIMPLE_OMP_TASK;\n+  return (gs->code == GIMPLE_OMP_PARALLEL\n+\t  || gs->code == GIMPLE_OMP_TASK\n+\t  || gs->code == GIMPLE_OMP_TEAMS);\n }\n \n template <>\n@@ -1463,7 +1470,7 @@ gomp_task *gimple_build_omp_task (gimple_seq, tree, tree, tree, tree,\n gimple *gimple_build_omp_section (gimple_seq);\n gimple *gimple_build_omp_master (gimple_seq);\n gimple *gimple_build_omp_grid_body (gimple_seq);\n-gimple *gimple_build_omp_taskgroup (gimple_seq);\n+gimple *gimple_build_omp_taskgroup (gimple_seq, tree);\n gomp_continue *gimple_build_omp_continue (tree, tree);\n gomp_ordered *gimple_build_omp_ordered (gimple_seq, tree);\n gimple *gimple_build_omp_return (bool);\n@@ -1472,8 +1479,9 @@ gimple *gimple_build_omp_sections_switch (void);\n gomp_single *gimple_build_omp_single (gimple_seq, tree);\n gomp_target *gimple_build_omp_target (gimple_seq, int, tree);\n gomp_teams *gimple_build_omp_teams (gimple_seq, tree);\n-gomp_atomic_load *gimple_build_omp_atomic_load (tree, tree);\n-gomp_atomic_store *gimple_build_omp_atomic_store (tree);\n+gomp_atomic_load *gimple_build_omp_atomic_load (tree, tree,\n+\t\t\t\t\t\tenum omp_memory_order);\n+gomp_atomic_store *gimple_build_omp_atomic_store (tree, enum omp_memory_order);\n gtransaction *gimple_build_transaction (gimple_seq);\n extern void gimple_seq_add_stmt (gimple_seq *, gimple *);\n extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple *);\n@@ -2193,7 +2201,7 @@ static inline unsigned\n gimple_omp_subcode (const gimple *s)\n {\n   gcc_gimple_checking_assert (gimple_code (s) >= GIMPLE_OMP_ATOMIC_LOAD\n-\t      && gimple_code (s) <= GIMPLE_OMP_TEAMS);\n+\t\t\t      && gimple_code (s) <= GIMPLE_OMP_TEAMS);\n   return s->subcode;\n }\n \n@@ -2331,26 +2339,27 @@ gimple_omp_atomic_set_need_value (gimple *g)\n }\n \n \n-/* Return true if OMP atomic load/store statement G has the\n-   GF_OMP_ATOMIC_SEQ_CST flag set.  */\n+/* Return the memory order of the OMP atomic load/store statement G.  */\n \n-static inline bool\n-gimple_omp_atomic_seq_cst_p (const gimple *g)\n+static inline enum omp_memory_order\n+gimple_omp_atomic_memory_order (const gimple *g)\n {\n   if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n     GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n-  return (gimple_omp_subcode (g) & GF_OMP_ATOMIC_SEQ_CST) != 0;\n+  return (enum omp_memory_order)\n+\t (gimple_omp_subcode (g) & GF_OMP_ATOMIC_MEMORY_ORDER);\n }\n \n \n-/* Set the GF_OMP_ATOMIC_SEQ_CST flag on G.  */\n+/* Set the memory order on G.  */\n \n static inline void\n-gimple_omp_atomic_set_seq_cst (gimple *g)\n+gimple_omp_atomic_set_memory_order (gimple *g, enum omp_memory_order mo)\n {\n   if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n     GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n-  g->subcode |= GF_OMP_ATOMIC_SEQ_CST;\n+  g->subcode = ((g->subcode & ~GF_OMP_ATOMIC_MEMORY_ORDER)\n+\t\t| (mo & GF_OMP_ATOMIC_MEMORY_ORDER));\n }\n \n \n@@ -4915,6 +4924,40 @@ gimple_omp_ordered_set_clauses (gomp_ordered *ord_stmt, tree clauses)\n }\n \n \n+/* Return the clauses associated with OMP_TASKGROUP statement GS.  */\n+\n+static inline tree\n+gimple_omp_taskgroup_clauses (const gimple *gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TASKGROUP);\n+  return\n+    static_cast <const gimple_statement_omp_single_layout *> (gs)->clauses;\n+}\n+\n+\n+/* Return a pointer to the clauses associated with OMP taskgroup statement\n+   GS.  */\n+\n+static inline tree *\n+gimple_omp_taskgroup_clauses_ptr (gimple *gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TASKGROUP);\n+  return &static_cast <gimple_statement_omp_single_layout *> (gs)->clauses;\n+}\n+\n+\n+/* Set CLAUSES to be the clauses associated with OMP taskgroup statement\n+   GS.  */\n+\n+static inline void\n+gimple_omp_taskgroup_set_clauses (gimple *gs, tree clauses)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TASKGROUP);\n+  static_cast <gimple_statement_omp_single_layout *> (gs)->clauses\n+    = clauses;\n+}\n+\n+\n /* Return the kind of the OMP_FOR statemement G.  */\n \n static inline int\n@@ -5441,6 +5484,31 @@ gimple_omp_task_set_taskloop_p (gimple *g, bool taskloop_p)\n }\n \n \n+/* Return true if OMP task statement G has the\n+   GF_OMP_TASK_TASKWAIT flag set.  */\n+\n+static inline bool\n+gimple_omp_task_taskwait_p (const gimple *g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_TASK);\n+  return (gimple_omp_subcode (g) & GF_OMP_TASK_TASKWAIT) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_TASK_TASKWAIT field in G depending on the boolean\n+   value of TASKWAIT_P.  */\n+\n+static inline void\n+gimple_omp_task_set_taskwait_p (gimple *g, bool taskwait_p)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_TASK);\n+  if (taskwait_p)\n+    g->subcode |= GF_OMP_TASK_TASKWAIT;\n+  else\n+    g->subcode &= ~GF_OMP_TASK_TASKWAIT;\n+}\n+\n+\n /* Return the child function used to hold the body of OMP_TASK GS.  */\n \n static inline tree\n@@ -5857,6 +5925,60 @@ gimple_omp_teams_set_clauses (gomp_teams *omp_teams_stmt, tree clauses)\n   omp_teams_stmt->clauses = clauses;\n }\n \n+/* Return the child function used to hold the body of OMP_TEAMS_STMT.  */\n+\n+static inline tree\n+gimple_omp_teams_child_fn (const gomp_teams *omp_teams_stmt)\n+{\n+  return omp_teams_stmt->child_fn;\n+}\n+\n+/* Return a pointer to the child function used to hold the body of\n+   OMP_TEAMS_STMT.  */\n+\n+static inline tree *\n+gimple_omp_teams_child_fn_ptr (gomp_teams *omp_teams_stmt)\n+{\n+  return &omp_teams_stmt->child_fn;\n+}\n+\n+\n+/* Set CHILD_FN to be the child function for OMP_TEAMS_STMT.  */\n+\n+static inline void\n+gimple_omp_teams_set_child_fn (gomp_teams *omp_teams_stmt, tree child_fn)\n+{\n+  omp_teams_stmt->child_fn = child_fn;\n+}\n+\n+\n+/* Return the artificial argument used to send variables and values\n+   from the parent to the children threads in OMP_TEAMS_STMT.  */\n+\n+static inline tree\n+gimple_omp_teams_data_arg (const gomp_teams *omp_teams_stmt)\n+{\n+  return omp_teams_stmt->data_arg;\n+}\n+\n+\n+/* Return a pointer to the data argument for OMP_TEAMS_STMT.  */\n+\n+static inline tree *\n+gimple_omp_teams_data_arg_ptr (gomp_teams *omp_teams_stmt)\n+{\n+  return &omp_teams_stmt->data_arg;\n+}\n+\n+\n+/* Set DATA_ARG to be the data argument for OMP_TEAMS_STMT.  */\n+\n+static inline void\n+gimple_omp_teams_set_data_arg (gomp_teams *omp_teams_stmt, tree data_arg)\n+{\n+  omp_teams_stmt->data_arg = data_arg;\n+}\n+\n /* Return the kernel_phony flag of an OMP_TEAMS_STMT.  */\n \n static inline bool\n@@ -5876,6 +5998,25 @@ gimple_omp_teams_set_grid_phony (gomp_teams *omp_teams_stmt, bool value)\n     omp_teams_stmt->subcode &= ~GF_OMP_TEAMS_GRID_PHONY;\n }\n \n+/* Return the host flag of an OMP_TEAMS_STMT.  */\n+\n+static inline bool\n+gimple_omp_teams_host (const gomp_teams *omp_teams_stmt)\n+{\n+  return (gimple_omp_subcode (omp_teams_stmt) & GF_OMP_TEAMS_HOST) != 0;\n+}\n+\n+/* Set host flag of an OMP_TEAMS_STMT to VALUE.  */\n+\n+static inline void\n+gimple_omp_teams_set_host (gomp_teams *omp_teams_stmt, bool value)\n+{\n+  if (value)\n+    omp_teams_stmt->subcode |= GF_OMP_TEAMS_HOST;\n+  else\n+    omp_teams_stmt->subcode &= ~GF_OMP_TEAMS_HOST;\n+}\n+\n /* Return the clauses associated with OMP_SECTIONS GS.  */\n \n static inline tree"}, {"sha": "61dca240db6de51cfa7b78320c9e14cc22fa3f3c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 877, "deletions": 119, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -105,6 +105,14 @@ enum gimplify_omp_var_data\n   /* Flag for GOVD_MAP: must be present already.  */\n   GOVD_MAP_FORCE_PRESENT = 524288,\n \n+  /* Flag for GOVD_MAP: only allocate.  */\n+  GOVD_MAP_ALLOC_ONLY = 1048576,\n+\n+  /* Flag for GOVD_MAP: only copy back.  */\n+  GOVD_MAP_FROM_ONLY = 2097152,\n+\n+  GOVD_NONTEMPORAL = 4194304,\n+\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -114,34 +122,39 @@ enum gimplify_omp_var_data\n enum omp_region_type\n {\n   ORT_WORKSHARE = 0x00,\n-  ORT_SIMD \t= 0x01,\n+  ORT_TASKGROUP = 0x01,\n+  ORT_SIMD \t= 0x04,\n \n-  ORT_PARALLEL\t= 0x02,\n-  ORT_COMBINED_PARALLEL = 0x03,\n+  ORT_PARALLEL\t= 0x08,\n+  ORT_COMBINED_PARALLEL = ORT_PARALLEL | 1,\n \n-  ORT_TASK\t= 0x04,\n-  ORT_UNTIED_TASK = 0x05,\n+  ORT_TASK\t= 0x10,\n+  ORT_UNTIED_TASK = ORT_TASK | 1,\n+  ORT_TASKLOOP  = ORT_TASK | 2,\n+  ORT_UNTIED_TASKLOOP = ORT_UNTIED_TASK | 2,\n \n-  ORT_TEAMS\t= 0x08,\n-  ORT_COMBINED_TEAMS = 0x09,\n+  ORT_TEAMS\t= 0x20,\n+  ORT_COMBINED_TEAMS = ORT_TEAMS | 1,\n+  ORT_HOST_TEAMS = ORT_TEAMS | 2,\n+  ORT_COMBINED_HOST_TEAMS = ORT_COMBINED_TEAMS | 2,\n \n   /* Data region.  */\n-  ORT_TARGET_DATA = 0x10,\n+  ORT_TARGET_DATA = 0x40,\n \n   /* Data region with offloading.  */\n-  ORT_TARGET\t= 0x20,\n-  ORT_COMBINED_TARGET = 0x21,\n+  ORT_TARGET\t= 0x80,\n+  ORT_COMBINED_TARGET = ORT_TARGET | 1,\n \n   /* OpenACC variants.  */\n-  ORT_ACC\t= 0x40,  /* A generic OpenACC region.  */\n+  ORT_ACC\t= 0x100,  /* A generic OpenACC region.  */\n   ORT_ACC_DATA\t= ORT_ACC | ORT_TARGET_DATA, /* Data construct.  */\n   ORT_ACC_PARALLEL = ORT_ACC | ORT_TARGET,  /* Parallel construct */\n-  ORT_ACC_KERNELS  = ORT_ACC | ORT_TARGET | 0x80,  /* Kernels construct.  */\n-  ORT_ACC_HOST_DATA = ORT_ACC | ORT_TARGET_DATA | 0x80,  /* Host data.  */\n+  ORT_ACC_KERNELS  = ORT_ACC | ORT_TARGET | 2,  /* Kernels construct.  */\n+  ORT_ACC_HOST_DATA = ORT_ACC | ORT_TARGET_DATA | 2,  /* Host data.  */\n \n   /* Dummy OpenMP region, used to disable expansion of\n      DECL_VALUE_EXPRs in taskloop pre body.  */\n-  ORT_NONE\t= 0x100\n+  ORT_NONE\t= 0x200\n };\n \n /* Gimplify hashtable helper.  */\n@@ -176,6 +189,14 @@ struct gimplify_ctx\n   unsigned in_switch_expr : 1;\n };\n \n+enum gimplify_defaultmap_kind\n+{\n+  GDMK_SCALAR,\n+  GDMK_AGGREGATE,\n+  GDMK_ALLOCATABLE,\n+  GDMK_POINTER\n+};\n+\n struct gimplify_omp_ctx\n {\n   struct gimplify_omp_ctx *outer_context;\n@@ -188,9 +209,8 @@ struct gimplify_omp_ctx\n   enum omp_region_type region_type;\n   bool combined_loop;\n   bool distribute;\n-  bool target_map_scalars_firstprivate;\n-  bool target_map_pointers_as_0len_arrays;\n   bool target_firstprivatize_array_bases;\n+  int defaultmap[4];\n };\n \n static struct gimplify_ctx *gimplify_ctxp;\n@@ -413,6 +433,10 @@ new_omp_context (enum omp_region_type region_type)\n     c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;\n   else\n     c->default_kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+  c->defaultmap[GDMK_SCALAR] = GOVD_MAP;\n+  c->defaultmap[GDMK_AGGREGATE] = GOVD_MAP;\n+  c->defaultmap[GDMK_ALLOCATABLE] = GOVD_MAP;\n+  c->defaultmap[GDMK_POINTER] = GOVD_MAP;\n \n   return c;\n }\n@@ -738,6 +762,7 @@ gimple_add_tmp_var (tree tmp)\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n \t  while (ctx\n \t\t && (ctx->region_type == ORT_WORKSHARE\n+\t\t     || ctx->region_type == ORT_TASKGROUP\n \t\t     || ctx->region_type == ORT_SIMD\n \t\t     || ctx->region_type == ORT_ACC))\n \t    ctx = ctx->outer_context;\n@@ -3150,6 +3175,8 @@ maybe_fold_stmt (gimple_stmt_iterator *gsi)\n   for (ctx = gimplify_omp_ctxp; ctx; ctx = ctx->outer_context)\n     if ((ctx->region_type & (ORT_TARGET | ORT_PARALLEL | ORT_TASK)) != 0)\n       return false;\n+    else if ((ctx->region_type & ORT_HOST_TEAMS) == ORT_HOST_TEAMS)\n+      return false;\n   return fold_stmt (gsi);\n }\n \n@@ -6641,12 +6668,13 @@ omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n \t}\n       else if ((ctx->region_type & ORT_TARGET) != 0)\n \t{\n-\t  if (ctx->target_map_scalars_firstprivate)\n+\t  if (ctx->defaultmap[GDMK_SCALAR] & GOVD_FIRSTPRIVATE)\n \t    omp_add_variable (ctx, decl, GOVD_FIRSTPRIVATE);\n \t  else\n \t    omp_add_variable (ctx, decl, GOVD_MAP | GOVD_MAP_TO_ONLY);\n \t}\n       else if (ctx->region_type != ORT_WORKSHARE\n+\t       && ctx->region_type != ORT_TASKGROUP\n \t       && ctx->region_type != ORT_SIMD\n \t       && ctx->region_type != ORT_ACC\n \t       && !(ctx->region_type & ORT_TARGET_DATA))\n@@ -6760,7 +6788,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t replacement is private, else FIRSTPRIVATE since we'll need the\n \t address of the original variable either for SHARED, or for the\n \t copy into or out of the context.  */\n-      if (!(flags & GOVD_LOCAL))\n+      if (!(flags & GOVD_LOCAL) && ctx->region_type != ORT_TASKGROUP)\n \t{\n \t  if (flags & GOVD_MAP)\n \t    nflags = GOVD_MAP | GOVD_MAP_TO_ONLY | GOVD_EXPLICIT;\n@@ -6962,6 +6990,8 @@ omp_default_clause (struct gimplify_omp_ctx *ctx, tree decl,\n \n \tif (ctx->region_type & ORT_PARALLEL)\n \t  rtype = \"parallel\";\n+\telse if ((ctx->region_type & ORT_TASKLOOP) == ORT_TASKLOOP)\n+\t  rtype = \"taskloop\";\n \telse if (ctx->region_type & ORT_TASK)\n \t  rtype = \"task\";\n \telse if (ctx->region_type & ORT_TEAMS)\n@@ -7173,11 +7203,9 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n       if (n == NULL)\n \t{\n \t  unsigned nflags = flags;\n-\t  if (ctx->target_map_pointers_as_0len_arrays\n-\t      || ctx->target_map_scalars_firstprivate)\n+\t  if ((ctx->region_type & ORT_ACC) == 0)\n \t    {\n \t      bool is_declare_target = false;\n-\t      bool is_scalar = false;\n \t      if (is_global_var (decl)\n \t\t  && varpool_node::get_create (decl)->offloadable)\n \t\t{\n@@ -7194,18 +7222,34 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t\t    }\n \t\t  is_declare_target = octx == NULL;\n \t\t}\n-\t      if (!is_declare_target && ctx->target_map_scalars_firstprivate)\n-\t\tis_scalar = lang_hooks.decls.omp_scalar_p (decl);\n-\t      if (is_declare_target)\n-\t\t;\n-\t      else if (ctx->target_map_pointers_as_0len_arrays\n-\t\t       && (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n-\t\t\t   || (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n-\t\t\t       && TREE_CODE (TREE_TYPE (TREE_TYPE (decl)))\n-\t\t\t\t  == POINTER_TYPE)))\n-\t\tnflags |= GOVD_MAP | GOVD_MAP_0LEN_ARRAY;\n-\t      else if (is_scalar)\n-\t\tnflags |= GOVD_FIRSTPRIVATE;\n+\t      if (!is_declare_target)\n+\t\t{\n+\t\t  int gdmk;\n+\t\t  if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n+\t\t      || (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_TYPE (decl)))\n+\t\t\t      == POINTER_TYPE)))\n+\t\t    gdmk = GDMK_POINTER;\n+\t\t  else if (lang_hooks.decls.omp_scalar_p (decl))\n+\t\t    gdmk = GDMK_SCALAR;\n+\t\t  else\n+\t\t    gdmk = GDMK_AGGREGATE;\n+\t\t  if (ctx->defaultmap[gdmk] == 0)\n+\t\t    {\n+\t\t      tree d = lang_hooks.decls.omp_report_decl (decl);\n+\t\t      error (\"%qE not specified in enclosing %<target%>\",\n+\t\t\t     DECL_NAME (d));\n+\t\t      error_at (ctx->location, \"enclosing %<target%>\");\n+\t\t    }\n+\t\t  else if (ctx->defaultmap[gdmk]\n+\t\t\t   & (GOVD_MAP_0LEN_ARRAY | GOVD_FIRSTPRIVATE))\n+\t\t    nflags |= ctx->defaultmap[gdmk];\n+\t\t  else\n+\t\t    {\n+\t\t      gcc_assert (ctx->defaultmap[gdmk] & GOVD_MAP);\n+\t\t      nflags |= ctx->defaultmap[gdmk] & ~GOVD_MAP;\n+\t\t    }\n+\t\t}\n \t    }\n \n \t  struct gimplify_omp_ctx *octx = ctx->outer_context;\n@@ -7236,28 +7280,28 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t\t}\n \t    }\n \n-\t  {\n-\t    tree type = TREE_TYPE (decl);\n-\n-\t    if (nflags == flags\n-\t\t&& gimplify_omp_ctxp->target_firstprivatize_array_bases\n-\t\t&& lang_hooks.decls.omp_privatize_by_reference (decl))\n-\t      type = TREE_TYPE (type);\n-\t    if (nflags == flags\n-\t\t&& !lang_hooks.types.omp_mappable_type (type))\n-\t      {\n-\t\terror (\"%qD referenced in target region does not have \"\n-\t\t       \"a mappable type\", decl);\n-\t\tnflags |= GOVD_MAP | GOVD_EXPLICIT;\n-\t      }\n-\t    else if (nflags == flags)\n-\t      {\n-\t\tif ((ctx->region_type & ORT_ACC) != 0)\n-\t\t  nflags = oacc_default_clause (ctx, decl, flags);\n-\t\telse\n-\t\t  nflags |= GOVD_MAP;\n-\t      }\n-\t  }\n+\t  if ((nflags & ~(GOVD_MAP_TO_ONLY | GOVD_MAP_FROM_ONLY\n+\t\t\t  | GOVD_MAP_ALLOC_ONLY)) == flags)\n+\t    {\n+\t      tree type = TREE_TYPE (decl);\n+\n+\t      if (gimplify_omp_ctxp->target_firstprivatize_array_bases\n+\t\t  && lang_hooks.decls.omp_privatize_by_reference (decl))\n+\t\ttype = TREE_TYPE (type);\n+\t      if (!lang_hooks.types.omp_mappable_type (type))\n+\t\t{\n+\t\t  error (\"%qD referenced in target region does not have \"\n+\t\t\t \"a mappable type\", decl);\n+\t\t  nflags |= GOVD_MAP | GOVD_EXPLICIT;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if ((ctx->region_type & ORT_ACC) != 0)\n+\t\t    nflags = oacc_default_clause (ctx, decl, flags);\n+\t\t  else\n+\t\t    nflags |= GOVD_MAP;\n+\t\t}\n+\t    }\n \tfound_outer:\n \t  omp_add_variable (ctx, decl, nflags);\n \t}\n@@ -7275,6 +7319,7 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n   if (n == NULL)\n     {\n       if (ctx->region_type == ORT_WORKSHARE\n+\t  || ctx->region_type == ORT_TASKGROUP\n \t  || ctx->region_type == ORT_SIMD\n \t  || ctx->region_type == ORT_ACC\n \t  || (ctx->region_type & ORT_TARGET_DATA) != 0)\n@@ -7386,25 +7431,17 @@ omp_is_private (struct gimplify_omp_ctx *ctx, tree decl, int simd)\n \t  else if ((n->value & GOVD_REDUCTION) != 0)\n \t    error (\"iteration variable %qE should not be reduction\",\n \t\t   DECL_NAME (decl));\n-\t  else if (simd == 0 && (n->value & GOVD_LINEAR) != 0)\n+\t  else if (simd != 1 && (n->value & GOVD_LINEAR) != 0)\n \t    error (\"iteration variable %qE should not be linear\",\n \t\t   DECL_NAME (decl));\n-\t  else if (simd == 1 && (n->value & GOVD_LASTPRIVATE) != 0)\n-\t    error (\"iteration variable %qE should not be lastprivate\",\n-\t\t   DECL_NAME (decl));\n-\t  else if (simd && (n->value & GOVD_PRIVATE) != 0)\n-\t    error (\"iteration variable %qE should not be private\",\n-\t\t   DECL_NAME (decl));\n-\t  else if (simd == 2 && (n->value & GOVD_LINEAR) != 0)\n-\t    error (\"iteration variable %qE is predetermined linear\",\n-\t\t   DECL_NAME (decl));\n \t}\n       return (ctx == gimplify_omp_ctxp\n \t      || (ctx->region_type == ORT_COMBINED_PARALLEL\n \t\t  && gimplify_omp_ctxp->outer_context == ctx));\n     }\n \n   if (ctx->region_type != ORT_WORKSHARE\n+      && ctx->region_type != ORT_TASKGROUP\n       && ctx->region_type != ORT_SIMD\n       && ctx->region_type != ORT_ACC)\n     return false;\n@@ -7462,6 +7499,7 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)\n \t}\n     }\n   while (ctx->region_type == ORT_WORKSHARE\n+\t || ctx->region_type == ORT_TASKGROUP\n \t || ctx->region_type == ORT_SIMD\n \t || ctx->region_type == ORT_ACC);\n   return false;\n@@ -7483,6 +7521,452 @@ find_decl_expr (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* If *LIST_P contains any OpenMP depend clauses with iterators,\n+   lower all the depend clauses by populating corresponding depend\n+   array.  Returns 0 if there are no such depend clauses, or\n+   2 if all depend clauses should be removed, 1 otherwise.  */\n+\n+static int\n+gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n+{\n+  tree c;\n+  gimple *g;\n+  size_t n[4] = { 0, 0, 0, 0 };\n+  bool unused[4];\n+  tree counts[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };\n+  tree last_iter = NULL_TREE, last_count = NULL_TREE;\n+  size_t i, j;\n+  location_t first_loc = UNKNOWN_LOCATION;\n+\n+  for (c = *list_p; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n+      {\n+\tswitch (OMP_CLAUSE_DEPEND_KIND (c))\n+\t  {\n+\t  case OMP_CLAUSE_DEPEND_IN:\n+\t    i = 2;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_OUT:\n+\t  case OMP_CLAUSE_DEPEND_INOUT:\n+\t    i = 0;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t    i = 1;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_DEPOBJ:\n+\t    i = 3;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_SOURCE:\n+\t  case OMP_CLAUSE_DEPEND_SINK:\n+\t    continue;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\ttree t = OMP_CLAUSE_DECL (c);\n+\tif (first_loc == UNKNOWN_LOCATION)\n+\t  first_loc = OMP_CLAUSE_LOCATION (c);\n+\tif (TREE_CODE (t) == TREE_LIST\n+\t    && TREE_PURPOSE (t)\n+\t    && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t  {\n+\t    if (TREE_PURPOSE (t) != last_iter)\n+\t      {\n+\t\ttree tcnt = size_one_node;\n+\t\tfor (tree it = TREE_PURPOSE (t); it; it = TREE_CHAIN (it))\n+\t\t  {\n+\t\t    if (gimplify_expr (&TREE_VEC_ELT (it, 1), pre_p, NULL,\n+\t\t\t\t       is_gimple_val, fb_rvalue) == GS_ERROR\n+\t\t\t|| gimplify_expr (&TREE_VEC_ELT (it, 2), pre_p, NULL,\n+\t\t\t\t\t  is_gimple_val, fb_rvalue) == GS_ERROR\n+\t\t\t|| gimplify_expr (&TREE_VEC_ELT (it, 3), pre_p, NULL,\n+\t\t\t\t\t  is_gimple_val, fb_rvalue) == GS_ERROR\n+\t\t\t|| (gimplify_expr (&TREE_VEC_ELT (it, 4), pre_p, NULL,\n+\t\t\t\t\t   is_gimple_val, fb_rvalue)\n+\t\t\t    == GS_ERROR))\n+\t\t      return 2;\n+\t\t    tree var = TREE_VEC_ELT (it, 0);\n+\t\t    tree begin = TREE_VEC_ELT (it, 1);\n+\t\t    tree end = TREE_VEC_ELT (it, 2);\n+\t\t    tree step = TREE_VEC_ELT (it, 3);\n+\t\t    tree orig_step = TREE_VEC_ELT (it, 4);\n+\t\t    tree type = TREE_TYPE (var);\n+\t\t    tree stype = TREE_TYPE (step);\n+\t\t    location_t loc = DECL_SOURCE_LOCATION (var);\n+\t\t    tree endmbegin;\n+\t\t    /* Compute count for this iterator as\n+\t\t       orig_step > 0\n+\t\t       ? (begin < end ? (end - begin + (step - 1)) / step : 0)\n+\t\t       : (begin > end ? (end - begin + (step + 1)) / step : 0)\n+\t\t       and compute product of those for the entire depend\n+\t\t       clause.  */\n+\t\t    if (POINTER_TYPE_P (type))\n+\t\t      endmbegin = fold_build2_loc (loc, POINTER_DIFF_EXPR,\n+\t\t\t\t\t\t   stype, end, begin);\n+\t\t    else\n+\t\t      endmbegin = fold_build2_loc (loc, MINUS_EXPR, type,\n+\t\t\t\t\t\t   end, begin);\n+\t\t    tree stepm1 = fold_build2_loc (loc, MINUS_EXPR, stype,\n+\t\t\t\t\t\t   step,\n+\t\t\t\t\t\t   build_int_cst (stype, 1));\n+\t\t    tree stepp1 = fold_build2_loc (loc, PLUS_EXPR, stype, step,\n+\t\t\t\t\t\t   build_int_cst (stype, 1));\n+\t\t    tree pos = fold_build2_loc (loc, PLUS_EXPR, stype,\n+\t\t\t\t\t\tunshare_expr (endmbegin),\n+\t\t\t\t\t\tstepm1);\n+\t\t    pos = fold_build2_loc (loc, TRUNC_DIV_EXPR, stype,\n+\t\t\t\t\t   pos, step);\n+\t\t    tree neg = fold_build2_loc (loc, PLUS_EXPR, stype,\n+\t\t\t\t\t\tendmbegin, stepp1);\n+\t\t    if (TYPE_UNSIGNED (stype))\n+\t\t      {\n+\t\t\tneg = fold_build1_loc (loc, NEGATE_EXPR, stype, neg);\n+\t\t\tstep = fold_build1_loc (loc, NEGATE_EXPR, stype, step);\n+\t\t      }\n+\t\t    neg = fold_build2_loc (loc, TRUNC_DIV_EXPR, stype,\n+\t\t\t\t\t   neg, step);\n+\t\t    step = NULL_TREE;\n+\t\t    tree cond = fold_build2_loc (loc, LT_EXPR,\n+\t\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t\t begin, end);\n+\t\t    pos = fold_build3_loc (loc, COND_EXPR, stype, cond, pos,\n+\t\t\t\t\t   build_int_cst (stype, 0));\n+\t\t    cond = fold_build2_loc (loc, LT_EXPR, boolean_type_node,\n+\t\t\t\t\t    end, begin);\n+\t\t    neg = fold_build3_loc (loc, COND_EXPR, stype, cond, neg,\n+\t\t\t\t\t   build_int_cst (stype, 0));\n+\t\t    tree osteptype = TREE_TYPE (orig_step);\n+\t\t    cond = fold_build2_loc (loc, GT_EXPR, boolean_type_node,\n+\t\t\t\t\t    orig_step,\n+\t\t\t\t\t    build_int_cst (osteptype, 0));\n+\t\t    tree cnt = fold_build3_loc (loc, COND_EXPR, stype,\n+\t\t\t\t\t\tcond, pos, neg);\n+\t\t    cnt = fold_convert_loc (loc, sizetype, cnt);\n+\t\t    if (gimplify_expr (&cnt, pre_p, NULL, is_gimple_val,\n+\t\t\t\t       fb_rvalue) == GS_ERROR)\n+\t\t      return 2;\n+\t\t    tcnt = size_binop_loc (loc, MULT_EXPR, tcnt, cnt);\n+\t\t  }\n+\t\tif (gimplify_expr (&tcnt, pre_p, NULL, is_gimple_val,\n+\t\t\t\t   fb_rvalue) == GS_ERROR)\n+\t\t  return 2;\n+\t\tlast_iter = TREE_PURPOSE (t);\n+\t\tlast_count = tcnt;\n+\t      }\n+\t    if (counts[i] == NULL_TREE)\n+\t      counts[i] = last_count;\n+\t    else\n+\t      counts[i] = size_binop_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t  PLUS_EXPR, counts[i], last_count);\n+\t  }\n+\telse\n+\t  n[i]++;\n+      }\n+  for (i = 0; i < 4; i++)\n+    if (counts[i])\n+      break;\n+  if (i == 4)\n+    return 0;\n+\n+  tree total = size_zero_node;\n+  for (i = 0; i < 4; i++)\n+    {\n+      unused[i] = counts[i] == NULL_TREE && n[i] == 0;\n+      if (counts[i] == NULL_TREE)\n+\tcounts[i] = size_zero_node;\n+      if (n[i])\n+\tcounts[i] = size_binop (PLUS_EXPR, counts[i], size_int (n[i]));\n+      if (gimplify_expr (&counts[i], pre_p, NULL, is_gimple_val,\n+\t\t\t fb_rvalue) == GS_ERROR)\n+\treturn 2;\n+      total = size_binop (PLUS_EXPR, total, counts[i]);\n+    }\n+\n+  if (gimplify_expr (&total, pre_p, NULL, is_gimple_val, fb_rvalue)\n+      == GS_ERROR)\n+    return 2;\n+  bool is_old = unused[1] && unused[3];\n+  tree totalpx = size_binop (PLUS_EXPR, unshare_expr (total),\n+\t\t\t     size_int (is_old ? 1 : 4));\n+  tree type = build_array_type (ptr_type_node, build_index_type (totalpx));\n+  tree array = create_tmp_var_raw (type);\n+  TREE_ADDRESSABLE (array) = 1;\n+  if (TREE_CODE (totalpx) != INTEGER_CST)\n+    {\n+      if (!TYPE_SIZES_GIMPLIFIED (TREE_TYPE (array)))\n+\tgimplify_type_sizes (TREE_TYPE (array), pre_p);\n+      if (gimplify_omp_ctxp)\n+\t{\n+\t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\t  while (ctx\n+\t\t && (ctx->region_type == ORT_WORKSHARE\n+\t\t     || ctx->region_type == ORT_TASKGROUP\n+\t\t     || ctx->region_type == ORT_SIMD\n+\t\t     || ctx->region_type == ORT_ACC))\n+\t    ctx = ctx->outer_context;\n+\t  if (ctx)\n+\t    omp_add_variable (ctx, array, GOVD_LOCAL | GOVD_SEEN);\n+\t}\n+      gimplify_vla_decl (array, pre_p);\n+    }\n+  else\n+    gimple_add_tmp_var (array);\n+  tree r = build4 (ARRAY_REF, ptr_type_node, array, size_int (0), NULL_TREE,\n+\t\t   NULL_TREE);\n+  tree tem;\n+  if (!is_old)\n+    {\n+      tem = build2 (MODIFY_EXPR, void_type_node, r,\n+\t\t    build_int_cst (ptr_type_node, 0));\n+      gimplify_and_add (tem, pre_p);\n+      r = build4 (ARRAY_REF, ptr_type_node, array, size_int (1), NULL_TREE,\n+\t\t  NULL_TREE);\n+    }\n+  tem = build2 (MODIFY_EXPR, void_type_node, r,\n+\t\tfold_convert (ptr_type_node, total));\n+  gimplify_and_add (tem, pre_p);\n+  for (i = 1; i < (is_old ? 2 : 4); i++)\n+    {\n+      r = build4 (ARRAY_REF, ptr_type_node, array, size_int (i + !is_old),\n+\t\t  NULL_TREE, NULL_TREE);\n+      tem = build2 (MODIFY_EXPR, void_type_node, r, counts[i - 1]);\n+      gimplify_and_add (tem, pre_p);\n+    }\n+\n+  tree cnts[4];\n+  for (j = 4; j; j--)\n+    if (!unused[j - 1])\n+      break;\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (i && (i >= j || unused[i - 1]))\n+\t{\n+\t  cnts[i] = cnts[i - 1];\n+\t  continue;\n+\t}\n+      cnts[i] = create_tmp_var (sizetype);\n+      if (i == 0)\n+\tg = gimple_build_assign (cnts[i], size_int (is_old ? 2 : 5));\n+      else\n+\t{\n+\t  tree t;\n+\t  if (is_old)\n+\t    t = size_binop (PLUS_EXPR, counts[0], size_int (2));\n+\t  else\n+\t    t = size_binop (PLUS_EXPR, cnts[i - 1], counts[i - 1]);\n+\t  if (gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue)\n+\t      == GS_ERROR)\n+\t    return 2;\n+\t  g = gimple_build_assign (cnts[i], t);\n+\t}\n+      gimple_seq_add_stmt (pre_p, g);\n+    }\n+\n+  last_iter = NULL_TREE;\n+  tree last_bind = NULL_TREE;\n+  tree *last_body = NULL;\n+  for (c = *list_p; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n+      {\n+\tswitch (OMP_CLAUSE_DEPEND_KIND (c))\n+\t  {\n+\t  case OMP_CLAUSE_DEPEND_IN:\n+\t    i = 2;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_OUT:\n+\t  case OMP_CLAUSE_DEPEND_INOUT:\n+\t    i = 0;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t    i = 1;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_DEPOBJ:\n+\t    i = 3;\n+\t    break;\n+\t  case OMP_CLAUSE_DEPEND_SOURCE:\n+\t  case OMP_CLAUSE_DEPEND_SINK:\n+\t    continue;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\ttree t = OMP_CLAUSE_DECL (c);\n+\tif (TREE_CODE (t) == TREE_LIST\n+\t    && TREE_PURPOSE (t)\n+\t    && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t  {\n+\t    if (TREE_PURPOSE (t) != last_iter)\n+\t      {\n+\t\tif (last_bind)\n+\t\t  gimplify_and_add (last_bind, pre_p);\n+\t\ttree block = TREE_VEC_ELT (TREE_PURPOSE (t), 5);\n+\t\tlast_bind = build3 (BIND_EXPR, void_type_node,\n+\t\t\t\t    BLOCK_VARS (block), NULL, block);\n+\t\tTREE_SIDE_EFFECTS (last_bind) = 1;\n+\t\tSET_EXPR_LOCATION (last_bind, OMP_CLAUSE_LOCATION (c));\n+\t\ttree *p = &BIND_EXPR_BODY (last_bind);\n+\t\tfor (tree it = TREE_PURPOSE (t); it; it = TREE_CHAIN (it))\n+\t\t  {\n+\t\t    tree var = TREE_VEC_ELT (it, 0);\n+\t\t    tree begin = TREE_VEC_ELT (it, 1);\n+\t\t    tree end = TREE_VEC_ELT (it, 2);\n+\t\t    tree step = TREE_VEC_ELT (it, 3);\n+\t\t    tree orig_step = TREE_VEC_ELT (it, 4);\n+\t\t    tree type = TREE_TYPE (var);\n+\t\t    location_t loc = DECL_SOURCE_LOCATION (var);\n+\t\t    /* Emit:\n+\t\t       var = begin;\n+\t\t       goto cond_label;\n+\t\t       beg_label:\n+\t\t       ...\n+\t\t       var = var + step;\n+\t\t       cond_label:\n+\t\t       if (orig_step > 0) {\n+\t\t\t if (var < end) goto beg_label;\n+\t\t       } else {\n+\t\t\t if (var > end) goto beg_label;\n+\t\t       }\n+\t\t       for each iterator, with inner iterators added to\n+\t\t       the ... above.  */\n+\t\t    tree beg_label = create_artificial_label (loc);\n+\t\t    tree cond_label = NULL_TREE;\n+\t\t    tem = build2_loc (loc, MODIFY_EXPR, void_type_node,\n+\t\t\t\t      var, begin);\n+\t\t    append_to_statement_list_force (tem, p);\n+\t\t    tem = build_and_jump (&cond_label);\n+\t\t    append_to_statement_list_force (tem, p);\n+\t\t    tem = build1 (LABEL_EXPR, void_type_node, beg_label);\n+\t\t    append_to_statement_list (tem, p);\n+\t\t    tree bind = build3 (BIND_EXPR, void_type_node, NULL_TREE,\n+\t\t\t\t\tNULL_TREE, NULL_TREE);\n+\t\t    TREE_SIDE_EFFECTS (bind) = 1;\n+\t\t    SET_EXPR_LOCATION (bind, loc);\n+\t\t    append_to_statement_list_force (bind, p);\n+\t\t    if (POINTER_TYPE_P (type))\n+\t\t      tem = build2_loc (loc, POINTER_PLUS_EXPR, type,\n+\t\t\t\t\tvar, fold_convert_loc (loc, sizetype,\n+\t\t\t\t\t\t\t       step));\n+\t\t    else\n+\t\t      tem = build2_loc (loc, PLUS_EXPR, type, var, step);\n+\t\t    tem = build2_loc (loc, MODIFY_EXPR, void_type_node,\n+\t\t\t\t      var, tem);\n+\t\t    append_to_statement_list_force (tem, p);\n+\t\t    tem = build1 (LABEL_EXPR, void_type_node, cond_label);\n+\t\t    append_to_statement_list (tem, p);\n+\t\t    tree cond = fold_build2_loc (loc, LT_EXPR,\n+\t\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t\t var, end);\n+\t\t    tree pos\n+\t\t      = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t\t\t cond, build_and_jump (&beg_label),\n+\t\t\t\t\t void_node);\n+\t\t    cond = fold_build2_loc (loc, GT_EXPR, boolean_type_node,\n+\t\t\t\t\t    var, end);\n+\t\t    tree neg\n+\t\t      = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t\t\t cond, build_and_jump (&beg_label),\n+\t\t\t\t\t void_node);\n+\t\t    tree osteptype = TREE_TYPE (orig_step);\n+\t\t    cond = fold_build2_loc (loc, GT_EXPR, boolean_type_node,\n+\t\t\t\t\t    orig_step,\n+\t\t\t\t\t    build_int_cst (osteptype, 0));\n+\t\t    tem = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t\t\t   cond, pos, neg);\n+\t\t    append_to_statement_list_force (tem, p);\n+\t\t    p = &BIND_EXPR_BODY (bind);\n+\t\t  }\n+\t\tlast_body = p;\n+\t      }\n+\t    last_iter = TREE_PURPOSE (t);\n+\t    if (TREE_CODE (TREE_VALUE (t)) == COMPOUND_EXPR)\n+\t      {\n+\t\tappend_to_statement_list (TREE_OPERAND (TREE_VALUE (t),\n+\t\t\t\t\t  0), last_body);\n+\t\tTREE_VALUE (t) = TREE_OPERAND (TREE_VALUE (t), 1);\n+\t      }\n+\t    if (error_operand_p (TREE_VALUE (t)))\n+\t      return 2;\n+\t    TREE_VALUE (t) = build_fold_addr_expr (TREE_VALUE (t));\n+\t    r = build4 (ARRAY_REF, ptr_type_node, array, cnts[i],\n+\t\t\tNULL_TREE, NULL_TREE);\n+\t    tem = build2_loc (OMP_CLAUSE_LOCATION (c), MODIFY_EXPR,\n+\t\t\t      void_type_node, r, TREE_VALUE (t));\n+\t    append_to_statement_list_force (tem, last_body);\n+\t    tem = build2_loc (OMP_CLAUSE_LOCATION (c), MODIFY_EXPR,\n+\t\t\t      void_type_node, cnts[i],\n+\t\t\t      size_binop (PLUS_EXPR, cnts[i], size_int (1)));\n+\t    append_to_statement_list_force (tem, last_body);\n+\t    TREE_VALUE (t) = null_pointer_node;\n+\t  }\n+\telse\n+\t  {\n+\t    if (last_bind)\n+\t      {\n+\t\tgimplify_and_add (last_bind, pre_p);\n+\t\tlast_bind = NULL_TREE;\n+\t      }\n+\t    if (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPOUND_EXPR)\n+\t      {\n+\t\tgimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (c), 0), pre_p,\n+\t\t\t       NULL, is_gimple_val, fb_rvalue);\n+\t\tOMP_CLAUSE_DECL (c) = TREE_OPERAND (OMP_CLAUSE_DECL (c), 1);\n+\t      }\n+\t    if (error_operand_p (OMP_CLAUSE_DECL (c)))\n+\t      return 2;\n+\t    OMP_CLAUSE_DECL (c) = build_fold_addr_expr (OMP_CLAUSE_DECL (c));\n+\t    if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n+\t\t\t       is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t      return 2;\n+\t    r = build4 (ARRAY_REF, ptr_type_node, array, cnts[i],\n+\t\t\tNULL_TREE, NULL_TREE);\n+\t    tem = build2 (MODIFY_EXPR, void_type_node, r, OMP_CLAUSE_DECL (c));\n+\t    gimplify_and_add (tem, pre_p);\n+\t    g = gimple_build_assign (cnts[i], size_binop (PLUS_EXPR, cnts[i],\n+\t\t\t\t\t\t\t  size_int (1)));\n+\t    gimple_seq_add_stmt (pre_p, g);\n+\t  }\n+      }\n+  if (last_bind)\n+    gimplify_and_add (last_bind, pre_p);\n+  tree cond = boolean_false_node;\n+  if (is_old)\n+    {\n+      if (!unused[0])\n+\tcond = build2_loc (first_loc, NE_EXPR, boolean_type_node, cnts[0],\n+\t\t\t   size_binop_loc (first_loc, PLUS_EXPR, counts[0],\n+\t\t\t\t\t   size_int (2)));\n+      if (!unused[2])\n+\tcond = build2_loc (first_loc, TRUTH_OR_EXPR, boolean_type_node, cond,\n+\t\t\t   build2_loc (first_loc, NE_EXPR, boolean_type_node,\n+\t\t\t\t       cnts[2],\n+\t\t\t\t       size_binop_loc (first_loc, PLUS_EXPR,\n+\t\t\t\t\t\t       totalpx,\n+\t\t\t\t\t\t       size_int (1))));\n+    }\n+  else\n+    {\n+      tree prev = size_int (5);\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  if (unused[i])\n+\t    continue;\n+\t  prev = size_binop_loc (first_loc, PLUS_EXPR, counts[i], prev);\n+\t  cond = build2_loc (first_loc, TRUTH_OR_EXPR, boolean_type_node, cond,\n+\t\t\t     build2_loc (first_loc, NE_EXPR, boolean_type_node,\n+\t\t\t\t\t cnts[i], unshare_expr (prev)));\n+\t}\n+    }\n+  tem = build3_loc (first_loc, COND_EXPR, void_type_node, cond,\n+\t\t    build_call_expr_loc (first_loc,\n+\t\t\t\t\t builtin_decl_explicit (BUILT_IN_TRAP),\n+\t\t\t\t\t 0), void_node);\n+  gimplify_and_add (tem, pre_p);\n+  c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_DEPEND);\n+  OMP_CLAUSE_DEPEND_KIND (c) = OMP_CLAUSE_DEPEND_LAST;\n+  OMP_CLAUSE_DECL (c) = build_fold_addr_expr (array);\n+  OMP_CLAUSE_CHAIN (c) = *list_p;\n+  *list_p = c;\n+  return 1;\n+}\n+\n /* Scan the OMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n@@ -7495,14 +7979,16 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   tree c;\n   hash_map<tree, tree> *struct_map_to_clause = NULL;\n   tree *prev_list_p = NULL;\n+  int handled_depend_iterators = -1;\n+  int nowait = -1;\n \n   ctx = new_omp_context (region_type);\n   outer_ctx = ctx->outer_context;\n   if (code == OMP_TARGET)\n     {\n       if (!lang_GNU_Fortran ())\n-\tctx->target_map_pointers_as_0len_arrays = true;\n-      ctx->target_map_scalars_firstprivate = true;\n+\tctx->defaultmap[GDMK_POINTER] = GOVD_MAP | GOVD_MAP_0LEN_ARRAY;\n+      ctx->defaultmap[GDMK_SCALAR] = GOVD_FIRSTPRIVATE;\n     }\n   if (!lang_GNU_Fortran ())\n     switch (code)\n@@ -7548,16 +8034,43 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  check_non_private = \"firstprivate\";\n \t  goto do_add;\n \tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+\t    switch (code)\n+\t      {\n+\t      case OMP_DISTRIBUTE:\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"conditional %<lastprivate%> clause on \"\n+\t\t\t  \"%<distribute%> construct\");\n+\t\tOMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n+\t\tbreak;\n+\t      case OMP_TASKLOOP:\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"conditional %<lastprivate%> clause on \"\n+\t\t\t  \"%<taskloop%> construct\");\n+\t\tOMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n \t  flags = GOVD_LASTPRIVATE | GOVD_SEEN | GOVD_EXPLICIT;\n \t  check_non_private = \"lastprivate\";\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (error_operand_p (decl))\n \t    goto do_add;\n-\t  else if (outer_ctx\n-\t\t   && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n-\t\t       || outer_ctx->region_type == ORT_COMBINED_TEAMS)\n-\t\t   && splay_tree_lookup (outer_ctx->variables,\n-\t\t\t\t\t (splay_tree_key) decl) == NULL)\n+\t  if (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n+\t      && !lang_hooks.decls.omp_scalar_p (decl))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"non-scalar variable %qD in conditional \"\n+\t\t\t\"%<lastprivate%> clause\", decl);\n+\t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n+\t    }\n+\t  if (outer_ctx\n+\t      && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n+\t\t  || ((outer_ctx->region_type & ORT_COMBINED_TEAMS)\n+\t\t      == ORT_COMBINED_TEAMS))\n+\t      && splay_tree_lookup (outer_ctx->variables,\n+\t\t\t\t    (splay_tree_key) decl) == NULL)\n \t    {\n \t      omp_add_variable (outer_ctx, decl, GOVD_SHARED | GOVD_SEEN);\n \t      if (outer_ctx->outer_context)\n@@ -7603,7 +8116,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t\t    GOVD_LASTPRIVATE | GOVD_SEEN);\n \t\t\t  octx = octx->outer_context;\n \t\t\t  if (octx\n-\t\t\t      && octx->region_type == ORT_COMBINED_TEAMS\n+\t\t\t      && ((octx->region_type & ORT_COMBINED_TEAMS)\n+\t\t\t\t  == ORT_COMBINED_TEAMS)\n \t\t\t      && (splay_tree_lookup (octx->variables,\n \t\t\t\t\t\t     (splay_tree_key) decl)\n \t\t\t\t  == NULL))\n@@ -7622,10 +8136,40 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  goto do_add;\n \tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_TASK (c))\n+\t    {\n+\t      if (region_type == ORT_WORKSHARE)\n+\t\t{\n+\t\t  if (nowait == -1)\n+\t\t    nowait = omp_find_clause (*list_p,\n+\t\t\t\t\t      OMP_CLAUSE_NOWAIT) != NULL_TREE;\n+\t\t  if (nowait\n+\t\t      && (outer_ctx == NULL\n+\t\t\t  || outer_ctx->region_type != ORT_COMBINED_PARALLEL))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"%<task%> reduction modifier on a construct \"\n+\t\t\t\t\"with a %<nowait%> clause\");\n+\t\t      OMP_CLAUSE_REDUCTION_TASK (c) = 0;\n+\t\t    }\n+\t\t}\n+\t      else if ((region_type & ORT_PARALLEL) != ORT_PARALLEL)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"invalid %<task%> reduction modifier on construct \"\n+\t\t\t    \"other than %<parallel%>, %<for%> or %<sections%>\");\n+\t\t  OMP_CLAUSE_REDUCTION_TASK (c) = 0;\n+\t\t}\n+\t    }\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  flags = GOVD_REDUCTION | GOVD_SEEN | GOVD_EXPLICIT;\n \t  /* OpenACC permits reductions on private variables.  */\n-\t  if (!(region_type & ORT_ACC))\n-\t    check_non_private = \"reduction\";\n+\t  if (!(region_type & ORT_ACC)\n+\t      /* taskgroup is actually not a worksharing region.  */\n+\t      && code != OMP_TASKGROUP)\n+\t    check_non_private = omp_clause_code_name[OMP_CLAUSE_CODE (c)];\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (decl) == MEM_REF)\n \t    {\n@@ -7746,7 +8290,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t   && octx == outer_ctx)\n \t\t    flags = GOVD_SEEN | GOVD_SHARED;\n \t\t  else if (octx\n-\t\t\t   && octx->region_type == ORT_COMBINED_TEAMS)\n+\t\t\t   && ((octx->region_type & ORT_COMBINED_TEAMS)\n+\t\t\t       == ORT_COMBINED_TEAMS))\n \t\t    flags = GOVD_SEEN | GOVD_SHARED;\n \t\t  else if (octx\n \t\t\t   && octx->region_type == ORT_COMBINED_TARGET)\n@@ -8229,6 +8774,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SOURCE)\n \t    break;\n+\t  if (handled_depend_iterators == -1)\n+\t    handled_depend_iterators = gimplify_omp_depend (list_p, pre_p);\n+\t  if (handled_depend_iterators)\n+\t    {\n+\t      if (handled_depend_iterators == 2)\n+\t\tremove = true;\n+\t      break;\n+\t    }\n \t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPOUND_EXPR)\n \t    {\n \t      gimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (c), 0), pre_p,\n@@ -8311,7 +8864,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER)\n \t    flags |= GOVD_MAP_0LEN_ARRAY;\n \t  omp_add_variable (ctx, decl, flags);\n-\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t      && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t    {\n \t      omp_add_variable (ctx, OMP_CLAUSE_REDUCTION_PLACEHOLDER (c),\n@@ -8423,6 +8978,31 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  \" or private in outer context\", DECL_NAME (decl));\n \t    }\n \tdo_notice:\n+\t  if ((region_type & ORT_TASKLOOP) == ORT_TASKLOOP\n+\t      && outer_ctx\n+\t      && outer_ctx->region_type == ORT_COMBINED_PARALLEL\n+\t      && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE))\n+\t    {\n+\t      splay_tree_node on\n+\t\t= splay_tree_lookup (outer_ctx->variables,\n+\t\t\t\t     (splay_tree_key)decl);\n+\t      if (on == NULL || (on->value & GOVD_DATA_SHARE_CLASS) == 0)\n+\t\t{\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      && TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF\n+\t\t      && (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n+\t\t\t  || (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t\t\t      && (TREE_CODE (TREE_TYPE (TREE_TYPE (decl)))\n+\t\t\t\t  == POINTER_TYPE))))\n+\t\t    omp_firstprivatize_variable (outer_ctx, decl);\n+\t\t  else\n+\t\t    omp_add_variable (outer_ctx, decl,\n+\t\t\t\t      GOVD_SEEN | GOVD_SHARED);\n+\t\t  omp_notice_variable (outer_ctx, decl, true);\n+\t\t}\n+\t    }\n \t  if (outer_ctx)\n \t    omp_notice_variable (outer_ctx, decl, true);\n \t  if (check_non_private\n@@ -8453,7 +9033,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      for (int i = 0; i < 2; i++)\n \t\tswitch (i ? OMP_CLAUSE_IF_MODIFIER (c) : code)\n \t\t  {\n+\t\t  case VOID_CST: p[i] = \"cancel\"; break;\n \t\t  case OMP_PARALLEL: p[i] = \"parallel\"; break;\n+\t\t  case OMP_SIMD: p[i] = \"simd\"; break;\n \t\t  case OMP_TASK: p[i] = \"task\"; break;\n \t\t  case OMP_TASKLOOP: p[i] = \"taskloop\"; break;\n \t\t  case OMP_TARGET_DATA: p[i] = \"target data\"; break;\n@@ -8508,6 +9090,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  break;\n \n \tcase OMP_CLAUSE_NOWAIT:\n+\t  nowait = 1;\n+\t  break;\n+\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n@@ -8527,7 +9112,69 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  break;\n \n \tcase OMP_CLAUSE_DEFAULTMAP:\n-\t  ctx->target_map_scalars_firstprivate = false;\n+\t  enum gimplify_defaultmap_kind gdmkmin, gdmkmax;\n+\t  switch (OMP_CLAUSE_DEFAULTMAP_CATEGORY (c))\n+\t    {\n+\t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED:\n+\t      gdmkmin = GDMK_SCALAR;\n+\t      gdmkmax = GDMK_POINTER;\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR:\n+\t      gdmkmin = gdmkmax = GDMK_SCALAR;\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE:\n+\t      gdmkmin = gdmkmax = GDMK_AGGREGATE;\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_ALLOCATABLE:\n+\t      gdmkmin = gdmkmax = GDMK_ALLOCATABLE;\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER:\n+\t      gdmkmin = gdmkmax = GDMK_POINTER;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  for (int gdmk = gdmkmin; gdmk <= gdmkmax; gdmk++)\n+\t    switch (OMP_CLAUSE_DEFAULTMAP_BEHAVIOR (c))\n+\t      {\n+\t      case OMP_CLAUSE_DEFAULTMAP_ALLOC:\n+\t\tctx->defaultmap[gdmk] = GOVD_MAP | GOVD_MAP_ALLOC_ONLY;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEFAULTMAP_TO:\n+\t\tctx->defaultmap[gdmk] = GOVD_MAP | GOVD_MAP_TO_ONLY;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEFAULTMAP_FROM:\n+\t\tctx->defaultmap[gdmk] = GOVD_MAP | GOVD_MAP_FROM_ONLY;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEFAULTMAP_TOFROM:\n+\t\tctx->defaultmap[gdmk] = GOVD_MAP;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEFAULTMAP_FIRSTPRIVATE:\n+\t\tctx->defaultmap[gdmk] = GOVD_FIRSTPRIVATE;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEFAULTMAP_NONE:\n+\t\tctx->defaultmap[gdmk] = 0;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEFAULTMAP_DEFAULT:\n+\t\tswitch (gdmk)\n+\t\t  {\n+\t\t  case GDMK_SCALAR:\n+\t\t    ctx->defaultmap[gdmk] = GOVD_FIRSTPRIVATE;\n+\t\t    break;\n+\t\t  case GDMK_AGGREGATE:\n+\t\t  case GDMK_ALLOCATABLE:\n+\t\t    ctx->defaultmap[gdmk] = GOVD_MAP;\n+\t\t    break;\n+\t\t  case GDMK_POINTER:\n+\t\t    ctx->defaultmap[gdmk] = GOVD_MAP | GOVD_MAP_0LEN_ARRAY;\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t  }\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -8548,6 +9195,16 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    omp_add_variable (ctx, decl, GOVD_ALIGNED);\n \t  break;\n \n+\tcase OMP_CLAUSE_NONTEMPORAL:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (error_operand_p (decl))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  omp_add_variable (ctx, decl, GOVD_NONTEMPORAL);\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEFAULT:\n \t  ctx->default_kind = OMP_CLAUSE_DEFAULT_KIND (c);\n \t  break;\n@@ -8773,7 +9430,7 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     }\n   else if (flags & GOVD_LASTPRIVATE)\n     code = OMP_CLAUSE_LASTPRIVATE;\n-  else if (flags & GOVD_ALIGNED)\n+  else if (flags & (GOVD_ALIGNED | GOVD_NONTEMPORAL))\n     return 0;\n   else\n     gcc_unreachable ();\n@@ -8827,7 +9484,9 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n       /* Not all combinations of these GOVD_MAP flags are actually valid.  */\n       switch (flags & (GOVD_MAP_TO_ONLY\n \t\t       | GOVD_MAP_FORCE\n-\t\t       | GOVD_MAP_FORCE_PRESENT))\n+\t\t       | GOVD_MAP_FORCE_PRESENT\n+\t\t       | GOVD_MAP_ALLOC_ONLY\n+\t\t       | GOVD_MAP_FROM_ONLY))\n \t{\n \tcase 0:\n \t  kind = GOMP_MAP_TOFROM;\n@@ -8838,6 +9497,12 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \tcase GOVD_MAP_TO_ONLY:\n \t  kind = GOMP_MAP_TO;\n \t  break;\n+\tcase GOVD_MAP_FROM_ONLY:\n+\t  kind = GOMP_MAP_FROM;\n+\t  break;\n+\tcase GOVD_MAP_ALLOC_ONLY:\n+\t  kind = GOMP_MAP_ALLOC;\n+\t  break;\n \tcase GOVD_MAP_TO_ONLY | GOVD_MAP_FORCE:\n \t  kind = GOMP_MAP_TO | GOMP_MAP_FLAG_FORCE;\n \t  break;\n@@ -9062,6 +9727,12 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_NONTEMPORAL:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t  remove = n == NULL || !(n->value & GOVD_SEEN);\n+\t  break;\n+\n \tcase OMP_CLAUSE_MAP:\n \t  if (code == OMP_TARGET_EXIT_DATA\n \t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALWAYS_POINTER)\n@@ -9229,6 +9900,8 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  /* OpenACC reductions need a present_or_copy data clause.\n \t     Add one if necessary.  Emit error when the reduction is private.  */\n@@ -9506,18 +10179,32 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   gimple *g;\n   gimple_seq body = NULL;\n \n+  if (OMP_TASK_BODY (expr) == NULL_TREE)\n+    for (tree c = OMP_TASK_CLAUSES (expr); c; c = OMP_CLAUSE_CHAIN (c))\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t  && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_MUTEXINOUTSET)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%<mutexinoutset%> kind in %<depend%> clause on a \"\n+\t\t    \"%<taskwait%> construct\");\n+\t  break;\n+\t}\n+\n   gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p,\n \t\t\t     omp_find_clause (OMP_TASK_CLAUSES (expr),\n \t\t\t\t\t      OMP_CLAUSE_UNTIED)\n \t\t\t     ? ORT_UNTIED_TASK : ORT_TASK, OMP_TASK);\n \n-  push_gimplify_context ();\n+  if (OMP_TASK_BODY (expr))\n+    {\n+      push_gimplify_context ();\n \n-  g = gimplify_and_return_first (OMP_TASK_BODY (expr), &body);\n-  if (gimple_code (g) == GIMPLE_BIND)\n-    pop_gimplify_context (g);\n-  else\n-    pop_gimplify_context (NULL);\n+      g = gimplify_and_return_first (OMP_TASK_BODY (expr), &body);\n+      if (gimple_code (g) == GIMPLE_BIND)\n+\tpop_gimplify_context (g);\n+      else\n+\tpop_gimplify_context (NULL);\n+    }\n \n   gimplify_adjust_omp_clauses (pre_p, body, &OMP_TASK_CLAUSES (expr),\n \t\t\t       OMP_TASK);\n@@ -9526,6 +10213,8 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n \t\t\t     OMP_TASK_CLAUSES (expr),\n \t\t\t     NULL_TREE, NULL_TREE,\n \t\t\t     NULL_TREE, NULL_TREE, NULL_TREE);\n+  if (OMP_TASK_BODY (expr) == NULL_TREE)\n+    gimple_omp_task_set_taskwait_p (g, true);\n   gimplify_seq_add_stmt (pre_p, g);\n   *expr_p = NULL_TREE;\n }\n@@ -9655,7 +10344,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner_for_stmt)); i++)\n \tif (OMP_FOR_ORIG_DECLS (inner_for_stmt)\n \t    && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n-\t\t\t\t\ti)) == TREE_LIST)\n+\t\t\t\t\ti)) == TREE_LIST\n+\t    && TREE_PURPOSE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n+\t\t\t\t\t   i)))\n \t  {\n \t    tree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt), i);\n \t    /* Class iterators aren't allowed on OMP_SIMD, so the only\n@@ -9709,6 +10400,43 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (*data[1]);\n \t    OMP_PARALLEL_CLAUSES (*data[1]) = c;\n \t  }\n+      /* Similarly, take care of C++ range for temporaries, those should\n+\t be firstprivate on OMP_PARALLEL if any.  */\n+      if (data[1])\n+\tfor (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner_for_stmt)); i++)\n+\t  if (OMP_FOR_ORIG_DECLS (inner_for_stmt)\n+\t      && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n+\t\t\t\t\t  i)) == TREE_LIST\n+\t      && TREE_CHAIN (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt),\n+\t\t\t\t\t   i)))\n+\t    {\n+\t      tree orig\n+\t\t= TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner_for_stmt), i);\n+\t      tree v = TREE_CHAIN (orig);\n+\t      tree c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t\t OMP_CLAUSE_FIRSTPRIVATE);\n+\t      /* First add firstprivate clause for the __for_end artificial\n+\t\t decl.  */\n+\t      OMP_CLAUSE_DECL (c) = TREE_VEC_ELT (v, 1);\n+\t      if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n+\t\t  == REFERENCE_TYPE)\n+\t\tOMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE (c) = 1;\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (*data[1]);\n+\t      OMP_PARALLEL_CLAUSES (*data[1]) = c;\n+\t      if (TREE_VEC_ELT (v, 0))\n+\t\t{\n+\t\t  /* And now the same for __for_range artificial decl if it\n+\t\t     exists.  */\n+\t\t  c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n+\t\t  OMP_CLAUSE_DECL (c) = TREE_VEC_ELT (v, 0);\n+\t\t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n+\t\t      == REFERENCE_TYPE)\n+\t\t    OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE (c) = 1;\n+\t\t  OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (*data[1]);\n+\t\t  OMP_PARALLEL_CLAUSES (*data[1]) = c;\n+\t\t}\n+\t    }\n     }\n \n   switch (TREE_CODE (for_stmt))\n@@ -9721,9 +10449,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       break;\n     case OMP_TASKLOOP:\n       if (omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_UNTIED))\n-\tort = ORT_UNTIED_TASK;\n+\tort = ORT_UNTIED_TASKLOOP;\n       else\n-\tort = ORT_TASK;\n+\tort = ORT_TASKLOOP;\n       break;\n     case OMP_SIMD:\n       ort = ORT_SIMD;\n@@ -9935,7 +10663,11 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    {\n \t      tree orig_decl = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (for_stmt), i);\n \t      if (TREE_CODE (orig_decl) == TREE_LIST)\n-\t\torig_decl = TREE_PURPOSE (orig_decl);\n+\t\t{\n+\t\t  orig_decl = TREE_PURPOSE (orig_decl);\n+\t\t  if (!orig_decl)\n+\t\t    orig_decl = decl;\n+\t\t}\n \t      gimplify_omp_ctxp->loop_iter_var.quick_push (orig_decl);\n \t    }\n \t  else\n@@ -10027,7 +10759,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t      else if (omp_check_private (outer, decl, false))\n \t\t\touter = NULL;\n \t\t    }\n-\t\t  else if (((outer->region_type & ORT_TASK) != 0)\n+\t\t  else if (((outer->region_type & ORT_TASKLOOP)\n+\t\t\t    == ORT_TASKLOOP)\n \t\t\t   && outer->combined_loop\n \t\t\t   && !omp_check_private (gimplify_omp_ctxp,\n \t\t\t\t\t\t  decl, false))\n@@ -10066,8 +10799,12 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t\touter = NULL;\n \t\t\t    }\n \t\t\t  if (outer && outer->outer_context\n-\t\t\t      && (outer->outer_context->region_type\n-\t\t\t\t  == ORT_COMBINED_TEAMS))\n+\t\t\t      && ((outer->outer_context->region_type\n+\t\t\t\t   & ORT_COMBINED_TEAMS) == ORT_COMBINED_TEAMS\n+\t\t\t\t  || (((outer->region_type & ORT_TASKLOOP)\n+\t\t\t\t       == ORT_TASKLOOP)\n+\t\t\t\t      && (outer->outer_context->region_type\n+\t\t\t\t\t  == ORT_COMBINED_PARALLEL))))\n \t\t\t    {\n \t\t\t      outer = outer->outer_context;\n \t\t\t      n = splay_tree_lookup (outer->variables,\n@@ -10114,7 +10851,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t      else if (omp_check_private (outer, decl, false))\n \t\t\touter = NULL;\n \t\t    }\n-\t\t  else if (((outer->region_type & ORT_TASK) != 0)\n+\t\t  else if (((outer->region_type & ORT_TASKLOOP)\n+\t\t\t    == ORT_TASKLOOP)\n \t\t\t   && outer->combined_loop\n \t\t\t   && !omp_check_private (gimplify_omp_ctxp,\n \t\t\t\t\t\t  decl, false))\n@@ -10153,8 +10891,12 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t\touter = NULL;\n \t\t\t    }\n \t\t\t  if (outer && outer->outer_context\n-\t\t\t      && (outer->outer_context->region_type\n-\t\t\t\t  == ORT_COMBINED_TEAMS))\n+\t\t\t      && ((outer->outer_context->region_type\n+\t\t\t\t   & ORT_COMBINED_TEAMS) == ORT_COMBINED_TEAMS\n+\t\t\t\t  || (((outer->region_type & ORT_TASKLOOP)\n+\t\t\t\t       == ORT_TASKLOOP)\n+\t\t\t\t      && (outer->outer_context->region_type\n+\t\t\t\t\t  == ORT_COMBINED_PARALLEL))))\n \t\t\t    {\n \t\t\t      outer = outer->outer_context;\n \t\t\t      n = splay_tree_lookup (outer->variables,\n@@ -10496,6 +11238,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  case OMP_CLAUSE_FINAL:\n \t  case OMP_CLAUSE_MERGEABLE:\n \t  case OMP_CLAUSE_PRIORITY:\n+\t  case OMP_CLAUSE_REDUCTION:\n+\t  case OMP_CLAUSE_IN_REDUCTION:\n \t    *gtask_clauses_ptr = c;\n \t    gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);\n \t    break;\n@@ -10676,7 +11420,7 @@ computable_teams_clause (tree *tp, int *walk_subtrees, void *)\n \t\t\t     (splay_tree_key) *tp);\n       if (n == NULL)\n \t{\n-\t  if (gimplify_omp_ctxp->target_map_scalars_firstprivate)\n+\t  if (gimplify_omp_ctxp->defaultmap[GDMK_SCALAR] & GOVD_FIRSTPRIVATE)\n \t    return NULL_TREE;\n \t  return *tp;\n \t}\n@@ -10848,6 +11592,12 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n       break;\n     case OMP_TEAMS:\n       ort = OMP_TEAMS_COMBINED (expr) ? ORT_COMBINED_TEAMS : ORT_TEAMS;\n+      if (gimplify_omp_ctxp == NULL\n+\t  || (gimplify_omp_ctxp->region_type == ORT_TARGET\n+\t      && gimplify_omp_ctxp->outer_context == NULL\n+\t      && lookup_attribute (\"omp declare target\",\n+\t\t\t\t   DECL_ATTRIBUTES (current_function_decl))))\n+\tort = (enum omp_region_type) (ort | ORT_HOST_TEAMS);\n       break;\n     case OACC_HOST_DATA:\n       ort = ORT_ACC_HOST_DATA;\n@@ -10859,7 +11609,8 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n \t\t\t     TREE_CODE (expr));\n   if (TREE_CODE (expr) == OMP_TARGET)\n     optimize_target_teams (expr, pre_p);\n-  if ((ort & (ORT_TARGET | ORT_TARGET_DATA)) != 0)\n+  if ((ort & (ORT_TARGET | ORT_TARGET_DATA)) != 0\n+      || (ort & ORT_HOST_TEAMS) == ORT_HOST_TEAMS)\n     {\n       push_gimplify_context ();\n       gimple *g = gimplify_and_return_first (OMP_BODY (expr), &body);\n@@ -10930,6 +11681,8 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n       break;\n     case OMP_TEAMS:\n       stmt = gimple_build_omp_teams (body, OMP_CLAUSES (expr));\n+      if ((ort & ORT_HOST_TEAMS) == ORT_HOST_TEAMS)\n+\tgimple_omp_teams_set_host (as_a <gomp_teams *> (stmt), true);\n       break;\n     default:\n       gcc_unreachable ();\n@@ -11165,21 +11918,18 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n       != GS_ALL_DONE)\n     return GS_ERROR;\n \n-  loadstmt = gimple_build_omp_atomic_load (tmp_load, addr);\n+  loadstmt = gimple_build_omp_atomic_load (tmp_load, addr,\n+\t\t\t\t\t   OMP_ATOMIC_MEMORY_ORDER (*expr_p));\n   gimplify_seq_add_stmt (pre_p, loadstmt);\n   if (rhs && gimplify_expr (&rhs, pre_p, NULL, is_gimple_val, fb_rvalue)\n       != GS_ALL_DONE)\n     return GS_ERROR;\n \n   if (TREE_CODE (*expr_p) == OMP_ATOMIC_READ)\n     rhs = tmp_load;\n-  storestmt = gimple_build_omp_atomic_store (rhs);\n+  storestmt\n+    = gimple_build_omp_atomic_store (rhs, OMP_ATOMIC_MEMORY_ORDER (*expr_p));\n   gimplify_seq_add_stmt (pre_p, storestmt);\n-  if (OMP_ATOMIC_SEQ_CST (*expr_p))\n-    {\n-      gimple_omp_atomic_set_seq_cst (loadstmt);\n-      gimple_omp_atomic_set_seq_cst (storestmt);\n-    }\n   switch (TREE_CODE (*expr_p))\n     {\n     case OMP_ATOMIC_READ:\n@@ -12126,7 +12876,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase OMP_SECTION:\n \tcase OMP_MASTER:\n-\tcase OMP_TASKGROUP:\n \tcase OMP_ORDERED:\n \tcase OMP_CRITICAL:\n \t  {\n@@ -12142,19 +12891,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      case OMP_MASTER:\n \t        g = gimple_build_omp_master (body);\n \t\tbreak;\n-\t      case OMP_TASKGROUP:\n-\t\t{\n-\t\t  gimple_seq cleanup = NULL;\n-\t\t  tree fn\n-\t\t    = builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_END);\n-\t\t  g = gimple_build_call (fn, 0);\n-\t\t  gimple_seq_add_stmt (&cleanup, g);\n-\t\t  g = gimple_build_try (body, cleanup, GIMPLE_TRY_FINALLY);\n-\t\t  body = NULL;\n-\t\t  gimple_seq_add_stmt (&body, g);\n-\t\t  g = gimple_build_omp_taskgroup (body);\n-\t\t}\n-\t\tbreak;\n \t      case OMP_ORDERED:\n \t\tg = gimplify_omp_ordered (*expr_p, body);\n \t\tbreak;\n@@ -12176,6 +12912,28 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    break;\n \t  }\n \n+\tcase OMP_TASKGROUP:\n+\t  {\n+\t    gimple_seq body = NULL;\n+\n+\t    tree *pclauses = &OMP_TASKGROUP_CLAUSES (*expr_p);\n+\t    gimplify_scan_omp_clauses (pclauses, pre_p, ORT_TASKGROUP,\n+\t\t\t\t       OMP_TASKGROUP);\n+\t    gimplify_adjust_omp_clauses (pre_p, NULL, pclauses, OMP_TASKGROUP);\n+\t    gimplify_and_add (OMP_BODY (*expr_p), &body);\n+\t    gimple_seq cleanup = NULL;\n+\t    tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_END);\n+\t    gimple *g = gimple_build_call (fn, 0);\n+\t    gimple_seq_add_stmt (&cleanup, g);\n+\t    g = gimple_build_try (body, cleanup, GIMPLE_TRY_FINALLY);\n+\t    body = NULL;\n+\t    gimple_seq_add_stmt (&body, g);\n+\t    g = gimple_build_omp_taskgroup (body, *pclauses);\n+\t    gimplify_seq_add_stmt (pre_p, g);\n+\t    ret = GS_ALL_DONE;\n+\t    break;\n+\t  }\n+\n \tcase OMP_ATOMIC:\n \tcase OMP_ATOMIC_READ:\n \tcase OMP_ATOMIC_CAPTURE_OLD:"}, {"sha": "2cb04029862c898dcddb561464180dc81ed8cd8a", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1356,6 +1356,8 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n \t  val = OMP_CLAUSE_PROC_BIND_KIND (t);\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n \t  val = OMP_CLAUSE_REDUCTION_CODE (t);\n \t  break;\n \tdefault:"}, {"sha": "70051635fa0ac4b71af4ee659a976e3a5c337d88", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -75,6 +75,8 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_BARRIER_CANCEL, \"GOMP_barrier_cancel\",\n \t\t  BT_FN_BOOL, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT, \"GOMP_taskwait\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT_DEPEND, \"GOMP_taskwait_depend\",\n+\t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKYIELD, \"GOMP_taskyield\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKGROUP_START, \"GOMP_taskgroup_start\",\n@@ -122,6 +124,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_START,\n \t\t  \"GOMP_loop_nonmonotonic_guided_start\",\n \t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_RUNTIME_START,\n+\t\t  \"GOMP_loop_nonmonotonic_runtime_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_MAYBE_NONMONOTONIC_RUNTIME_START,\n+\t\t  \"GOMP_loop_maybe_nonmonotonic_runtime_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_STATIC_START,\n \t\t  \"GOMP_loop_ordered_static_start\",\n \t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n@@ -154,6 +164,18 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DOACROSS_RUNTIME_START,\n \t\t  \"GOMP_loop_doacross_runtime_start\",\n \t\t  BT_FN_BOOL_UINT_LONGPTR_LONGPTR_LONGPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_START,\n+\t\t  \"GOMP_loop_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_START,\n+\t\t  \"GOMP_loop_ordered_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DOACROSS_START,\n+\t\t  \"GOMP_loop_doacross_start\",\n+\t\t  BT_FN_BOOL_UINT_LONGPTR_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_STATIC_NEXT, \"GOMP_loop_static_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DYNAMIC_NEXT, \"GOMP_loop_dynamic_next\",\n@@ -168,6 +190,12 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_DYNAMIC_NEXT,\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_GUIDED_NEXT,\n \t\t  \"GOMP_loop_nonmonotonic_guided_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_NONMONOTONIC_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_nonmonotonic_runtime_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_MAYBE_NONMONOTONIC_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_maybe_nonmonotonic_runtime_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_STATIC_NEXT,\n \t\t  \"GOMP_loop_ordered_static_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n@@ -204,6 +232,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_START,\n \t\t  \"GOMP_loop_ull_nonmonotonic_guided_start\",\n \t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_RUNTIME_START,\n+\t\t  \"GOMP_loop_ull_nonmonotonic_runtime_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_MAYBE_NONMONOTONIC_RUNTIME_START,\n+\t\t  \"GOMP_loop_ull_maybe_nonmonotonic_runtime_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_START,\n \t\t  \"GOMP_loop_ull_ordered_static_start\",\n \t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n@@ -236,6 +272,18 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_RUNTIME_START,\n \t\t  \"GOMP_loop_ull_doacross_runtime_start\",\n \t\t  BT_FN_BOOL_UINT_ULLPTR_ULLPTR_ULLPTR,\n \t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_START,\n+\t\t  \"GOMP_loop_ull_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_START,\n+\t\t  \"GOMP_loop_ull_ordered_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DOACROSS_START,\n+\t\t  \"GOMP_loop_ull_doacross_start\",\n+\t\t  BT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT,\n \t\t  \"GOMP_loop_ull_static_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n@@ -254,6 +302,12 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_DYNAMIC_NEXT,\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_GUIDED_NEXT,\n \t\t  \"GOMP_loop_ull_nonmonotonic_guided_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_NONMONOTONIC_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_ull_nonmonotonic_runtime_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_MAYBE_NONMONOTONIC_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_ull_maybe_nonmonotonic_runtime_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_NEXT,\n \t\t  \"GOMP_loop_ull_ordered_static_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n@@ -293,6 +347,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_GUIDED,\n \t\t  \"GOMP_parallel_loop_nonmonotonic_guided\",\n \t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_NONMONOTONIC_RUNTIME,\n+\t\t  \"GOMP_parallel_loop_nonmonotonic_runtime\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_MAYBE_NONMONOTONIC_RUNTIME,\n+\t\t  \"GOMP_parallel_loop_maybe_nonmonotonic_runtime\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END, \"GOMP_loop_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END_CANCEL, \"GOMP_loop_end_cancel\",\n@@ -313,6 +375,9 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_DOACROSS_ULL_WAIT, \"GOMP_doacross_ull_wait\",\n \t\t  BT_FN_VOID_ULL_VAR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL, \"GOMP_parallel\",\n \t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_REDUCTIONS,\n+\t\t  \"GOMP_parallel_reductions\",\n+\t\t  BT_FN_UINT_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK, \"GOMP_task\",\n \t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n \t\t  ATTR_NOTHROW_LIST)\n@@ -324,6 +389,8 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKLOOP_ULL, \"GOMP_taskloop_ull\",\n \t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, \"GOMP_sections_start\",\n \t\t  BT_FN_UINT_UINT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS2_START, \"GOMP_sections2_start\",\n+\t\t  BT_FN_UINT_UINT_PTR_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_NEXT, \"GOMP_sections_next\",\n \t\t  BT_FN_UINT, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_SECTIONS,\n@@ -363,5 +430,19 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_ENTER_EXIT_DATA,\n \t\t  BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_UINT_PTR, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TEAMS, \"GOMP_teams\",\n \t\t  BT_FN_VOID_UINT_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TEAMS_REG, \"GOMP_teams_reg\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKGROUP_REDUCTION_REGISTER,\n+\t\t  \"GOMP_taskgroup_reduction_register\",\n+\t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKGROUP_REDUCTION_UNREGISTER,\n+\t\t  \"GOMP_taskgroup_reduction_unregister\",\n+\t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK_REDUCTION_REMAP,\n+\t\t  \"GOMP_task_reduction_remap\",\n+\t\t  BT_FN_VOID_SIZE_SIZE_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_WORKSHARE_TASK_REDUCTION_UNREGISTER,\n+\t\t  \"GOMP_workshare_task_reduction_unregister\",\n+\t\t  BT_FN_VOID_BOOL, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOACC_BUILTIN (BUILT_IN_GOACC_DECLARE, \"GOACC_declare\",\n \t\t   BT_FN_VOID_INT_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)"}, {"sha": "95b89a6dd4572d96b3b318ef50e04a408ffd909e", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 398, "deletions": 51, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -174,6 +174,8 @@ workshare_safe_to_combine_p (basic_block ws_entry_bb)\n     return true;\n \n   gcc_assert (gimple_code (ws_stmt) == GIMPLE_OMP_FOR);\n+  if (gimple_omp_for_kind (ws_stmt) != GF_OMP_FOR_KIND_FOR)\n+    return false;\n \n   omp_extract_for_data (as_a <gomp_for *> (ws_stmt), &fd, NULL);\n \n@@ -202,7 +204,7 @@ workshare_safe_to_combine_p (basic_block ws_entry_bb)\n static tree\n omp_adjust_chunk_size (tree chunk_size, bool simd_schedule)\n {\n-  if (!simd_schedule)\n+  if (!simd_schedule || integer_zerop (chunk_size))\n     return chunk_size;\n \n   poly_uint64 vf = omp_max_vf ();\n@@ -310,6 +312,13 @@ determine_parallel_type (struct omp_region *region)\n   ws_entry_bb = region->inner->entry;\n   ws_exit_bb = region->inner->exit;\n \n+  /* Give up for task reductions on the parallel, while it is implementable,\n+     adding another big set of APIs or slowing down the normal paths is\n+     not acceptable.  */\n+  tree pclauses = gimple_omp_parallel_clauses (last_stmt (par_entry_bb));\n+  if (omp_find_clause (pclauses, OMP_CLAUSE__REDUCTEMP_))\n+    return;\n+\n   if (single_succ (par_entry_bb) == ws_entry_bb\n       && single_succ (ws_exit_bb) == par_exit_bb\n       && workshare_safe_to_combine_p (ws_entry_bb)\n@@ -336,13 +345,14 @@ determine_parallel_type (struct omp_region *region)\n \t  if (c == NULL\n \t      || ((OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n \t\t  == OMP_CLAUSE_SCHEDULE_STATIC)\n-\t      || omp_find_clause (clauses, OMP_CLAUSE_ORDERED))\n-\t    {\n-\t      region->is_combined_parallel = false;\n-\t      region->inner->is_combined_parallel = false;\n-\t      return;\n-\t    }\n+\t      || omp_find_clause (clauses, OMP_CLAUSE_ORDERED)\n+\t      || omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_))\n+\t    return;\n \t}\n+      else if (region->inner->type == GIMPLE_OMP_SECTIONS\n+\t       && omp_find_clause (gimple_omp_sections_clauses (ws_stmt),\n+\t\t\t\t   OMP_CLAUSE__REDUCTEMP_))\n+\treturn;\n \n       region->is_combined_parallel = true;\n       region->inner->is_combined_parallel = true;\n@@ -534,7 +544,7 @@ adjust_context_and_scope (tree entry_block, tree child_fndecl)\n     }\n }\n \n-/* Build the function calls to GOMP_parallel_start etc to actually\n+/* Build the function calls to GOMP_parallel etc to actually\n    generate the parallel operation.  REGION is the parallel region\n    being expanded.  BB is the block where to insert the code.  WS_ARGS\n    will be set if this is a call to a combined parallel+workshare\n@@ -559,7 +569,10 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n   /* Determine what flavor of GOMP_parallel we will be\n      emitting.  */\n   start_ix = BUILT_IN_GOMP_PARALLEL;\n-  if (is_combined_parallel (region))\n+  tree rtmp = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+  if (rtmp)\n+    start_ix = BUILT_IN_GOMP_PARALLEL_REDUCTIONS;\n+  else if (is_combined_parallel (region))\n     {\n       switch (region->inner->type)\n \t{\n@@ -568,12 +581,19 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t  switch (region->inner->sched_kind)\n \t    {\n \t    case OMP_CLAUSE_SCHEDULE_RUNTIME:\n-\t      start_ix2 = 3;\n+\t      if ((region->inner->sched_modifiers\n+\t\t   & OMP_CLAUSE_SCHEDULE_NONMONOTONIC) != 0)\n+\t\tstart_ix2 = 6;\n+\t      else if ((region->inner->sched_modifiers\n+\t\t\t& OMP_CLAUSE_SCHEDULE_MONOTONIC) == 0)\n+\t\tstart_ix2 = 7;\n+\t      else\n+\t\tstart_ix2 = 3;\n \t      break;\n \t    case OMP_CLAUSE_SCHEDULE_DYNAMIC:\n \t    case OMP_CLAUSE_SCHEDULE_GUIDED:\n-\t      if (region->inner->sched_modifiers\n-\t\t  & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n+\t      if ((region->inner->sched_modifiers\n+\t\t   & OMP_CLAUSE_SCHEDULE_MONOTONIC) == 0)\n \t\t{\n \t\t  start_ix2 = 3 + region->inner->sched_kind;\n \t\t  break;\n@@ -716,6 +736,13 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n   t = build_call_expr_loc_vec (UNKNOWN_LOCATION,\n \t\t\t       builtin_decl_explicit (start_ix), args);\n \n+  if (rtmp)\n+    {\n+      tree type = TREE_TYPE (OMP_CLAUSE_DECL (rtmp));\n+      t = build2 (MODIFY_EXPR, type, OMP_CLAUSE_DECL (rtmp),\n+\t\t  fold_convert (type,\n+\t\t\t\tfold_convert (pointer_sized_int_node, t)));\n+    }\n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n \n@@ -792,6 +819,8 @@ expand_task_call (struct omp_region *region, basic_block bb,\n       if (omp_find_clause (tclauses, OMP_CLAUSE_NOGROUP))\n \tiflags |= GOMP_TASK_FLAG_NOGROUP;\n       ull = fd.iter_type == long_long_unsigned_type_node;\n+      if (omp_find_clause (clauses, OMP_CLAUSE_REDUCTION))\n+\tiflags |= GOMP_TASK_FLAG_REDUCTION;\n     }\n   else if (priority)\n     iflags |= GOMP_TASK_FLAG_PRIORITY;\n@@ -866,6 +895,82 @@ expand_task_call (struct omp_region *region, basic_block bb,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n }\n \n+/* Build the function call to GOMP_taskwait_depend to actually\n+   generate the taskwait operation.  BB is the block where to insert the\n+   code.  */\n+\n+static void\n+expand_taskwait_call (basic_block bb, gomp_task *entry_stmt)\n+{\n+  tree clauses = gimple_omp_task_clauses (entry_stmt);\n+  tree depend = omp_find_clause (clauses, OMP_CLAUSE_DEPEND);\n+  if (depend == NULL_TREE)\n+    return;\n+\n+  depend = OMP_CLAUSE_DECL (depend);\n+\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n+  tree t\n+    = build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT_DEPEND),\n+\t\t       1, depend);\n+\n+  force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t    false, GSI_CONTINUE_LINKING);\n+}\n+\n+/* Build the function call to GOMP_teams_reg to actually\n+   generate the host teams operation.  REGION is the teams region\n+   being expanded.  BB is the block where to insert the code.  */\n+\n+static void\n+expand_teams_call (basic_block bb, gomp_teams *entry_stmt)\n+{\n+  tree clauses = gimple_omp_teams_clauses (entry_stmt);\n+  tree num_teams = omp_find_clause (clauses, OMP_CLAUSE_NUM_TEAMS);\n+  if (num_teams == NULL_TREE)\n+    num_teams = build_int_cst (unsigned_type_node, 0);\n+  else\n+    {\n+      num_teams = OMP_CLAUSE_NUM_TEAMS_EXPR (num_teams);\n+      num_teams = fold_convert (unsigned_type_node, num_teams);\n+    }\n+  tree thread_limit = omp_find_clause (clauses, OMP_CLAUSE_THREAD_LIMIT);\n+  if (thread_limit == NULL_TREE)\n+    thread_limit = build_int_cst (unsigned_type_node, 0);\n+  else\n+    {\n+      thread_limit = OMP_CLAUSE_THREAD_LIMIT_EXPR (thread_limit);\n+      thread_limit = fold_convert (unsigned_type_node, thread_limit);\n+    }\n+\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n+  tree t = gimple_omp_teams_data_arg (entry_stmt), t1;\n+  if (t == NULL)\n+    t1 = null_pointer_node;\n+  else\n+    t1 = build_fold_addr_expr (t);\n+  tree child_fndecl = gimple_omp_teams_child_fn (entry_stmt);\n+  tree t2 = build_fold_addr_expr (child_fndecl);\n+\n+  adjust_context_and_scope (gimple_block (entry_stmt), child_fndecl);\n+\n+  vec<tree, va_gc> *args;\n+  vec_alloc (args, 5);\n+  args->quick_push (t2);\n+  args->quick_push (t1);\n+  args->quick_push (num_teams);\n+  args->quick_push (thread_limit);\n+  /* For future extensibility.  */\n+  args->quick_push (build_zero_cst (unsigned_type_node));\n+\n+  t = build_call_expr_loc_vec (UNKNOWN_LOCATION,\n+\t\t\t       builtin_decl_explicit (BUILT_IN_GOMP_TEAMS_REG),\n+\t\t\t       args);\n+\n+  force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t    false, GSI_CONTINUE_LINKING);\n+}\n+\n /* Chain all the DECLs in LIST by their TREE_CHAIN fields.  */\n \n static tree\n@@ -1112,6 +1217,17 @@ expand_omp_taskreg (struct omp_region *region)\n   vec<tree, va_gc> *ws_args;\n \n   entry_stmt = last_stmt (region->entry);\n+  if (gimple_code (entry_stmt) == GIMPLE_OMP_TASK\n+      && gimple_omp_task_taskwait_p (entry_stmt))\n+    {\n+      new_bb = region->entry;\n+      gsi = gsi_last_nondebug_bb (region->entry);\n+      gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_TASK);\n+      gsi_remove (&gsi, true);\n+      expand_taskwait_call (new_bb, as_a <gomp_task *> (entry_stmt));\n+      return;\n+    }\n+\n   child_fn = gimple_omp_taskreg_child_fn (entry_stmt);\n   child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n \n@@ -1137,7 +1253,8 @@ expand_omp_taskreg (struct omp_region *region)\n \n       gsi = gsi_last_nondebug_bb (entry_bb);\n       gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_PARALLEL\n-\t\t  || gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_TASK);\n+\t\t  || gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_TASK\n+\t\t  || gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_TEAMS);\n       gsi_remove (&gsi, true);\n \n       new_bb = entry_bb;\n@@ -1190,8 +1307,8 @@ expand_omp_taskreg (struct omp_region *region)\n \t\t     effectively doing a STRIP_NOPS.  */\n \n \t\t  if (TREE_CODE (arg) == ADDR_EXPR\n-\t\t      && TREE_OPERAND (arg, 0)\n-\t\t\t== gimple_omp_taskreg_data_arg (entry_stmt))\n+\t\t      && (TREE_OPERAND (arg, 0)\n+\t\t\t  == gimple_omp_taskreg_data_arg (entry_stmt)))\n \t\t    {\n \t\t      parcopy_stmt = stmt;\n \t\t      break;\n@@ -1251,12 +1368,13 @@ expand_omp_taskreg (struct omp_region *region)\n       gsi = gsi_last_nondebug_bb (entry_bb);\n       stmt = gsi_stmt (gsi);\n       gcc_assert (stmt && (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n-\t\t\t   || gimple_code (stmt) == GIMPLE_OMP_TASK));\n+\t\t\t   || gimple_code (stmt) == GIMPLE_OMP_TASK\n+\t\t\t   || gimple_code (stmt) == GIMPLE_OMP_TEAMS));\n       e = split_block (entry_bb, stmt);\n       gsi_remove (&gsi, true);\n       entry_bb = e->dest;\n       edge e2 = NULL;\n-      if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n+      if (gimple_code (entry_stmt) != GIMPLE_OMP_TASK)\n \tsingle_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n       else\n \t{\n@@ -1382,6 +1500,8 @@ expand_omp_taskreg (struct omp_region *region)\n   if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n     expand_parallel_call (region, new_bb,\n \t\t\t  as_a <gomp_parallel *> (entry_stmt), ws_args);\n+  else if (gimple_code (entry_stmt) == GIMPLE_OMP_TEAMS)\n+    expand_teams_call (new_bb, as_a <gomp_teams *> (entry_stmt));\n   else\n     expand_task_call (region, new_bb, as_a <gomp_task *> (entry_stmt));\n   if (gimple_in_ssa_p (cfun))\n@@ -2499,6 +2619,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\tstruct omp_for_data *fd,\n \t\t\tenum built_in_function start_fn,\n \t\t\tenum built_in_function next_fn,\n+\t\t\ttree sched_arg,\n \t\t\tgimple *inner_stmt)\n {\n   tree type, istart0, iend0, iend;\n@@ -2546,6 +2667,30 @@ expand_omp_for_generic (struct omp_region *region,\n       && omp_find_clause (gimple_omp_for_clauses (gsi_stmt (gsi)),\n \t\t\t  OMP_CLAUSE_LASTPRIVATE))\n     ordered_lastprivate = false;\n+  tree reductions = NULL_TREE;\n+  tree mem = NULL_TREE;\n+  if (sched_arg)\n+    {\n+      if (fd->have_reductemp)\n+\t{\n+\t  tree c = omp_find_clause (gimple_omp_for_clauses (gsi_stmt (gsi)),\n+\t\t\t\t    OMP_CLAUSE__REDUCTEMP_);\n+\t  reductions = OMP_CLAUSE_DECL (c);\n+\t  gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n+\t  gimple *g = SSA_NAME_DEF_STMT (reductions);\n+\t  reductions = gimple_assign_rhs1 (g);\n+\t  OMP_CLAUSE_DECL (c) = reductions;\n+\t  entry_bb = gimple_bb (g);\n+\t  edge e = split_block (entry_bb, g);\n+\t  if (region->entry == entry_bb)\n+\t    region->entry = e->dest;\n+\t  gsi = gsi_last_bb (entry_bb);\n+\t}\n+      else\n+\treductions = null_pointer_node;\n+      /* For now.  */\n+      mem = null_pointer_node;\n+    }\n   if (fd->collapse > 1 || fd->ordered)\n     {\n       int first_zero_iter1 = -1, first_zero_iter2 = -1;\n@@ -2732,7 +2877,18 @@ expand_omp_for_generic (struct omp_region *region,\n \t    {\n \t      t = fold_convert (fd->iter_type, fd->chunk_size);\n \t      t = omp_adjust_chunk_size (t, fd->simd_schedule);\n-\t      if (fd->ordered)\n+\t      if (sched_arg)\n+\t\t{\n+\t\t  if (fd->ordered)\n+\t\t    t = build_call_expr (builtin_decl_explicit (start_fn),\n+\t\t\t\t\t 8, t0, t1, sched_arg, t, t3, t4,\n+\t\t\t\t\t reductions, mem);\n+\t\t  else\n+\t\t    t = build_call_expr (builtin_decl_explicit (start_fn),\n+\t\t\t\t\t 9, t0, t1, t2, sched_arg, t, t3, t4,\n+\t\t\t\t\t reductions, mem);\n+\t\t}\n+\t      else if (fd->ordered)\n \t\tt = build_call_expr (builtin_decl_explicit (start_fn),\n \t\t\t\t     5, t0, t1, t, t3, t4);\n \t      else\n@@ -2765,7 +2921,11 @@ expand_omp_for_generic (struct omp_region *region,\n \t      tree bfn_decl = builtin_decl_explicit (start_fn);\n \t      t = fold_convert (fd->iter_type, fd->chunk_size);\n \t      t = omp_adjust_chunk_size (t, fd->simd_schedule);\n-\t      t = build_call_expr (bfn_decl, 7, t5, t0, t1, t2, t, t3, t4);\n+\t      if (sched_arg)\n+\t\tt = build_call_expr (bfn_decl, 10, t5, t0, t1, t2, sched_arg,\n+\t\t\t\t     t, t3, t4, reductions, mem);\n+\t      else\n+\t\tt = build_call_expr (bfn_decl, 7, t5, t0, t1, t2, t, t3, t4);\n \t    }\n \t  else\n \t    t = build_call_expr (builtin_decl_explicit (start_fn),\n@@ -2784,6 +2944,17 @@ expand_omp_for_generic (struct omp_region *region,\n       gsi_insert_before (&gsi, gimple_build_assign (arr, clobber),\n \t\t\t GSI_SAME_STMT);\n     }\n+  if (fd->have_reductemp)\n+    {\n+      gimple *g = gsi_stmt (gsi);\n+      gsi_remove (&gsi, true);\n+      release_ssa_name (gimple_assign_lhs (g));\n+\n+      entry_bb = region->entry;\n+      gsi = gsi_last_nondebug_bb (entry_bb);\n+\n+      gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n+    }\n   gsi_insert_after (&gsi, gimple_build_cond_empty (t), GSI_SAME_STMT);\n \n   /* Remove the GIMPLE_OMP_FOR statement.  */\n@@ -3082,9 +3253,6 @@ expand_omp_for_generic (struct omp_region *region,\n   else\n     t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END);\n   gcall *call_stmt = gimple_build_call (t, 0);\n-  if (gimple_omp_return_lhs (gsi_stmt (gsi)))\n-    gimple_call_set_lhs (call_stmt, gimple_omp_return_lhs (gsi_stmt (gsi)));\n-  gsi_insert_after (&gsi, call_stmt, GSI_SAME_STMT);\n   if (fd->ordered)\n     {\n       tree arr = counts[fd->ordered];\n@@ -3093,6 +3261,17 @@ expand_omp_for_generic (struct omp_region *region,\n       gsi_insert_after (&gsi, gimple_build_assign (arr, clobber),\n \t\t\tGSI_SAME_STMT);\n     }\n+  if (gimple_omp_return_lhs (gsi_stmt (gsi)))\n+    {\n+      gimple_call_set_lhs (call_stmt, gimple_omp_return_lhs (gsi_stmt (gsi)));\n+      if (fd->have_reductemp)\n+\t{\n+\t  gimple *g = gimple_build_assign (reductions, NOP_EXPR,\n+\t\t\t\t\t   gimple_call_lhs (call_stmt));\n+\t  gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n+\t}\n+    }\n+  gsi_insert_after (&gsi, call_stmt, GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n \n   /* Connect the new blocks.  */\n@@ -3275,6 +3454,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   bool broken_loop = region->cont == NULL;\n   tree *counts = NULL;\n   tree n1, n2, step;\n+  tree reductions = NULL_TREE;\n \n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n@@ -3358,6 +3538,29 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       gsi = gsi_last_bb (entry_bb);\n     }\n \n+  if (fd->have_reductemp)\n+    {\n+      tree t1 = build_int_cst (long_integer_type_node, 0);\n+      tree t2 = build_int_cst (long_integer_type_node, 1);\n+      tree t3 = build_int_cstu (long_integer_type_node,\n+\t\t\t\t(HOST_WIDE_INT_1U << 31) + 1);\n+      tree clauses = gimple_omp_for_clauses (fd->for_stmt);\n+      clauses = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+      reductions = OMP_CLAUSE_DECL (clauses);\n+      gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n+      gimple *g = SSA_NAME_DEF_STMT (reductions);\n+      reductions = gimple_assign_rhs1 (g);\n+      OMP_CLAUSE_DECL (clauses) = reductions;\n+      gimple_stmt_iterator gsi2 = gsi_for_stmt (g);\n+      tree t\n+\t= build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_LOOP_START),\n+\t\t\t   9, t1, t2, t2, t3, t1, null_pointer_node,\n+\t\t\t   null_pointer_node, reductions, null_pointer_node);\n+      force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\ttrue, GSI_SAME_STMT);\n+      gsi_remove (&gsi2, true);\n+      release_ssa_name (gimple_assign_lhs (g));\n+    }\n   switch (gimple_omp_for_kind (fd->for_stmt))\n     {\n     case GF_OMP_FOR_KIND_FOR:\n@@ -3628,7 +3831,25 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      gsi_insert_after (&gsi, omp_build_barrier (t), GSI_SAME_STMT);\n+      if (fd->have_reductemp)\n+\t{\n+\t  tree fn;\n+\t  if (t)\n+\t    fn = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END_CANCEL);\n+\t  else\n+\t    fn = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END);\n+\t  gcall *g = gimple_build_call (fn, 0);\n+\t  if (t)\n+\t    {\n+\t      gimple_call_set_lhs (g, t);\n+\t      gsi_insert_after (&gsi, gimple_build_assign (reductions,\n+\t\t\t\t\t\t\t   NOP_EXPR, t),\n+\t\t\t\tGSI_SAME_STMT);\n+\t    }\n+\t  gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n+\t}\n+      else\n+\tgsi_insert_after (&gsi, omp_build_barrier (t), GSI_SAME_STMT);\n     }\n   gsi_remove (&gsi, true);\n \n@@ -3765,6 +3986,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   bool broken_loop = region->cont == NULL;\n   tree *counts = NULL;\n   tree n1, n2, step;\n+  tree reductions = NULL_TREE;\n \n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n@@ -3852,6 +4074,29 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       gsi = gsi_last_bb (entry_bb);\n     }\n \n+  if (fd->have_reductemp)\n+    {\n+      tree t1 = build_int_cst (long_integer_type_node, 0);\n+      tree t2 = build_int_cst (long_integer_type_node, 1);\n+      tree t3 = build_int_cstu (long_integer_type_node,\n+\t\t\t\t(HOST_WIDE_INT_1U << 31) + 1);\n+      tree clauses = gimple_omp_for_clauses (fd->for_stmt);\n+      clauses = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+      reductions = OMP_CLAUSE_DECL (clauses);\n+      gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n+      gimple *g = SSA_NAME_DEF_STMT (reductions);\n+      reductions = gimple_assign_rhs1 (g);\n+      OMP_CLAUSE_DECL (clauses) = reductions;\n+      gimple_stmt_iterator gsi2 = gsi_for_stmt (g);\n+      tree t\n+\t= build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_LOOP_START),\n+\t\t\t   9, t1, t2, t2, t3, t1, null_pointer_node,\n+\t\t\t   null_pointer_node, reductions, null_pointer_node);\n+      force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\ttrue, GSI_SAME_STMT);\n+      gsi_remove (&gsi2, true);\n+      release_ssa_name (gimple_assign_lhs (g));\n+    }\n   switch (gimple_omp_for_kind (fd->for_stmt))\n     {\n     case GF_OMP_FOR_KIND_FOR:\n@@ -4155,7 +4400,25 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      gsi_insert_after (&gsi, omp_build_barrier (t), GSI_SAME_STMT);\n+      if (fd->have_reductemp)\n+\t{\n+\t  tree fn;\n+\t  if (t)\n+\t    fn = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END_CANCEL);\n+\t  else\n+\t    fn = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END);\n+\t  gcall *g = gimple_build_call (fn, 0);\n+\t  if (t)\n+\t    {\n+\t      gimple_call_set_lhs (g, t);\n+\t      gsi_insert_after (&gsi, gimple_build_assign (reductions,\n+\t\t\t\t\t\t\t   NOP_EXPR, t),\n+\t\t\t\tGSI_SAME_STMT);\n+\t    }\n+\t  gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n+\t}\n+      else\n+\tgsi_insert_after (&gsi, omp_build_barrier (t), GSI_SAME_STMT);\n     }\n   gsi_remove (&gsi, true);\n \n@@ -5690,39 +5953,72 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n   else\n     {\n       int fn_index, start_ix, next_ix;\n+      unsigned HOST_WIDE_INT sched = 0;\n+      tree sched_arg = NULL_TREE;\n \n       gcc_assert (gimple_omp_for_kind (fd.for_stmt)\n \t\t  == GF_OMP_FOR_KIND_FOR);\n       if (fd.chunk_size == NULL\n \t  && fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC)\n \tfd.chunk_size = integer_zero_node;\n-      gcc_assert (fd.sched_kind != OMP_CLAUSE_SCHEDULE_AUTO);\n       switch (fd.sched_kind)\n \t{\n \tcase OMP_CLAUSE_SCHEDULE_RUNTIME:\n-\t  fn_index = 3;\n+\t  if ((fd.sched_modifiers & OMP_CLAUSE_SCHEDULE_NONMONOTONIC) != 0)\n+\t    {\n+\t      gcc_assert (!fd.have_ordered);\n+\t      fn_index = 6;\n+\t      sched = 4;\n+\t    }\n+\t  else if ((fd.sched_modifiers & OMP_CLAUSE_SCHEDULE_MONOTONIC) == 0\n+\t\t   && !fd.have_ordered)\n+\t    fn_index = 7;\n+\t  else\n+\t    {\n+\t      fn_index = 3;\n+\t      sched = (HOST_WIDE_INT_1U << 31);\n+\t    }\n \t  break;\n \tcase OMP_CLAUSE_SCHEDULE_DYNAMIC:\n \tcase OMP_CLAUSE_SCHEDULE_GUIDED:\n-\t  if ((fd.sched_modifiers & OMP_CLAUSE_SCHEDULE_NONMONOTONIC)\n-\t      && !fd.ordered\n+\t  if ((fd.sched_modifiers & OMP_CLAUSE_SCHEDULE_MONOTONIC) == 0\n \t      && !fd.have_ordered)\n \t    {\n \t      fn_index = 3 + fd.sched_kind;\n+\t      sched = (fd.sched_kind == OMP_CLAUSE_SCHEDULE_GUIDED) + 2;\n \t      break;\n \t    }\n-\t  /* FALLTHRU */\n-\tdefault:\n \t  fn_index = fd.sched_kind;\n+\t  sched = (fd.sched_kind == OMP_CLAUSE_SCHEDULE_GUIDED) + 2;\n+\t  sched += (HOST_WIDE_INT_1U << 31);\n \t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_STATIC:\n+\t  gcc_assert (fd.have_ordered);\n+\t  fn_index = 0;\n+\t  sched = (HOST_WIDE_INT_1U << 31) + 1;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       if (!fd.ordered)\n-\tfn_index += fd.have_ordered * 6;\n+\tfn_index += fd.have_ordered * 8;\n       if (fd.ordered)\n \tstart_ix = ((int)BUILT_IN_GOMP_LOOP_DOACROSS_STATIC_START) + fn_index;\n       else\n \tstart_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_START) + fn_index;\n       next_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_NEXT) + fn_index;\n+      if (fd.have_reductemp)\n+\t{\n+\t  if (fd.ordered)\n+\t    start_ix = (int)BUILT_IN_GOMP_LOOP_DOACROSS_START;\n+\t  else if (fd.have_ordered)\n+\t    start_ix = (int)BUILT_IN_GOMP_LOOP_ORDERED_START;\n+\t  else\n+\t    start_ix = (int)BUILT_IN_GOMP_LOOP_START;\n+\t  sched_arg = build_int_cstu (long_integer_type_node, sched);\n+\t  if (!fd.chunk_size)\n+\t    fd.chunk_size = integer_zero_node;\n+\t}\n       if (fd.iter_type == long_long_unsigned_type_node)\n \t{\n \t  start_ix += ((int)BUILT_IN_GOMP_LOOP_ULL_STATIC_START\n@@ -5731,7 +6027,8 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n \t\t      - (int)BUILT_IN_GOMP_LOOP_STATIC_NEXT);\n \t}\n       expand_omp_for_generic (region, &fd, (enum built_in_function) start_ix,\n-\t\t\t      (enum built_in_function) next_ix, inner_stmt);\n+\t\t\t      (enum built_in_function) next_ix, sched_arg,\n+\t\t\t      inner_stmt);\n     }\n \n   if (gimple_in_ssa_p (cfun))\n@@ -5831,7 +6128,25 @@ expand_omp_sections (struct omp_region *region)\n   sections_stmt = as_a <gomp_sections *> (gsi_stmt (si));\n   gcc_assert (gimple_code (sections_stmt) == GIMPLE_OMP_SECTIONS);\n   vin = gimple_omp_sections_control (sections_stmt);\n-  if (!is_combined_parallel (region))\n+  tree clauses = gimple_omp_sections_clauses (sections_stmt);\n+  tree reductmp = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+  if (reductmp)\n+    {\n+      tree reductions = OMP_CLAUSE_DECL (reductmp);\n+      gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n+      gimple *g = SSA_NAME_DEF_STMT (reductions);\n+      reductions = gimple_assign_rhs1 (g);\n+      OMP_CLAUSE_DECL (reductmp) = reductions;\n+      gimple_stmt_iterator gsi = gsi_for_stmt (g);\n+      t = build_int_cst (unsigned_type_node, len - 1);\n+      u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS2_START);\n+      stmt = gimple_build_call (u, 3, t, reductions, null_pointer_node);\n+      gimple_call_set_lhs (stmt, vin);\n+      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+      gsi_remove (&gsi, true);\n+      release_ssa_name (gimple_assign_lhs (g));\n+    }\n+  else if (!is_combined_parallel (region))\n     {\n       /* If we are not inside a combined parallel+sections region,\n \t call GOMP_sections_start.  */\n@@ -5845,8 +6160,11 @@ expand_omp_sections (struct omp_region *region)\n       u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);\n       stmt = gimple_build_call (u, 0);\n     }\n-  gimple_call_set_lhs (stmt, vin);\n-  gsi_insert_after (&si, stmt, GSI_SAME_STMT);\n+  if (!reductmp)\n+    {\n+      gimple_call_set_lhs (stmt, vin);\n+      gsi_insert_after (&si, stmt, GSI_SAME_STMT);\n+    }\n   gsi_remove (&si, true);\n \n   /* The switch() statement replacing GIMPLE_OMP_SECTIONS_SWITCH goes in\n@@ -6004,6 +6322,12 @@ expand_omp_synch (struct omp_region *region)\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ORDERED\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_CRITICAL\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_TEAMS);\n+  if (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_TEAMS\n+      && gimple_omp_teams_host (as_a <gomp_teams *> (gsi_stmt (si))))\n+    {\n+      expand_omp_taskreg (region);\n+      return;\n+    }\n   gsi_remove (&si, true);\n   single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n \n@@ -6016,6 +6340,24 @@ expand_omp_synch (struct omp_region *region)\n     }\n }\n \n+/* Translate enum omp_memory_order to enum memmodel.  The two enums\n+   are using different numbers so that OMP_MEMORY_ORDER_UNSPECIFIED\n+   is 0.  */\n+\n+static enum memmodel\n+omp_memory_order_to_memmodel (enum omp_memory_order mo)\n+{\n+  switch (mo)\n+    {\n+    case OMP_MEMORY_ORDER_RELAXED: return MEMMODEL_RELAXED;\n+    case OMP_MEMORY_ORDER_ACQUIRE: return MEMMODEL_ACQUIRE;\n+    case OMP_MEMORY_ORDER_RELEASE: return MEMMODEL_RELEASE;\n+    case OMP_MEMORY_ORDER_ACQ_REL: return MEMMODEL_ACQ_REL;\n+    case OMP_MEMORY_ORDER_SEQ_CST: return MEMMODEL_SEQ_CST;\n+    default: gcc_unreachable ();\n+    }\n+}\n+\n /* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n    operation as a normal volatile load.  */\n \n@@ -6047,11 +6389,9 @@ expand_omp_atomic_load (basic_block load_bb, tree addr,\n   type = TREE_TYPE (loaded_val);\n   itype = TREE_TYPE (TREE_TYPE (decl));\n \n-  call = build_call_expr_loc (loc, decl, 2, addr,\n-\t\t\t      build_int_cst (NULL,\n-\t\t\t\t\t     gimple_omp_atomic_seq_cst_p (stmt)\n-\t\t\t\t\t     ? MEMMODEL_SEQ_CST\n-\t\t\t\t\t     : MEMMODEL_RELAXED));\n+  enum omp_memory_order omo = gimple_omp_atomic_memory_order (stmt);\n+  tree mo = build_int_cst (NULL, omp_memory_order_to_memmodel (omo));\n+  call = build_call_expr_loc (loc, decl, 2, addr, mo);\n   if (!useless_type_conversion_p (type, itype))\n     call = fold_build1_loc (loc, VIEW_CONVERT_EXPR, type, call);\n   call = build2_loc (loc, MODIFY_EXPR, void_type_node, loaded_val, call);\n@@ -6122,11 +6462,9 @@ expand_omp_atomic_store (basic_block load_bb, tree addr,\n \n   if (!useless_type_conversion_p (itype, type))\n     stored_val = fold_build1_loc (loc, VIEW_CONVERT_EXPR, itype, stored_val);\n-  call = build_call_expr_loc (loc, decl, 3, addr, stored_val,\n-\t\t\t      build_int_cst (NULL,\n-\t\t\t\t\t     gimple_omp_atomic_seq_cst_p (stmt)\n-\t\t\t\t\t     ? MEMMODEL_SEQ_CST\n-\t\t\t\t\t     : MEMMODEL_RELAXED));\n+  enum omp_memory_order omo = gimple_omp_atomic_memory_order (stmt);\n+  tree mo = build_int_cst (NULL, omp_memory_order_to_memmodel (omo));\n+  call = build_call_expr_loc (loc, decl, 3, addr, stored_val, mo);\n   if (exchange)\n     {\n       if (!useless_type_conversion_p (type, itype))\n@@ -6167,7 +6505,6 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   enum tree_code code;\n   bool need_old, need_new;\n   machine_mode imode;\n-  bool seq_cst;\n \n   /* We expect to find the following sequences:\n \n@@ -6200,7 +6537,9 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n     return false;\n   need_new = gimple_omp_atomic_need_value_p (gsi_stmt (gsi));\n   need_old = gimple_omp_atomic_need_value_p (last_stmt (load_bb));\n-  seq_cst = gimple_omp_atomic_seq_cst_p (last_stmt (load_bb));\n+  enum omp_memory_order omo\n+    = gimple_omp_atomic_memory_order (last_stmt (load_bb));\n+  enum memmodel mo = omp_memory_order_to_memmodel (omo);\n   gcc_checking_assert (!need_old || !need_new);\n \n   if (!operand_equal_p (gimple_assign_lhs (stmt), stored_val, 0))\n@@ -6267,9 +6606,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n      use the RELAXED memory model.  */\n   call = build_call_expr_loc (loc, decl, 3, addr,\n \t\t\t      fold_convert_loc (loc, itype, rhs),\n-\t\t\t      build_int_cst (NULL,\n-\t\t\t\t\t     seq_cst ? MEMMODEL_SEQ_CST\n-\t\t\t\t\t\t     : MEMMODEL_RELAXED));\n+\t\t\t      build_int_cst (NULL, mo));\n \n   if (need_old || need_new)\n     {\n@@ -7921,6 +8258,10 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t    /* #pragma omp ordered depend is also just a stand-alone\n \t       directive.  */\n \t    region = NULL;\n+\t  else if (code == GIMPLE_OMP_TASK\n+\t\t   && gimple_omp_task_taskwait_p (stmt))\n+\t    /* #pragma omp taskwait depend(...) is a stand-alone directive.  */\n+\t    region = NULL;\n \t  /* ..., this directive becomes the parent for a new region.  */\n \t  if (region)\n \t    parent = region;\n@@ -8111,7 +8452,6 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n   switch (code)\n     {\n     case GIMPLE_OMP_PARALLEL:\n-    case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_TEAMS:\n@@ -8124,6 +8464,13 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n       fallthru = true;\n       break;\n \n+    case GIMPLE_OMP_TASK:\n+      cur_region = new_omp_region (bb, code, cur_region);\n+      fallthru = true;\n+      if (gimple_omp_task_taskwait_p (last))\n+\tcur_region = cur_region->outer;\n+      break;\n+\n     case GIMPLE_OMP_ORDERED:\n       cur_region = new_omp_region (bb, code, cur_region);\n       fallthru = true;"}, {"sha": "99d8226ef213d18cd3ffdbf092494d58c6fd2a51", "filename": "gcc/omp-general.c", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -36,6 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n+enum omp_requires omp_requires_mask;\n+\n tree\n omp_find_clause (tree clauses, enum omp_clause_code kind)\n {\n@@ -136,6 +138,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->pre = NULL;\n   fd->have_nowait = distribute || simd;\n   fd->have_ordered = false;\n+  fd->have_reductemp = false;\n   fd->tiling = NULL_TREE;\n   fd->collapse = 1;\n   fd->ordered = 0;\n@@ -186,6 +189,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \tcollapse_iter = &OMP_CLAUSE_TILE_ITERVAR (t);\n \tcollapse_count = &OMP_CLAUSE_TILE_COUNT (t);\n \tbreak;\n+      case OMP_CLAUSE__REDUCTEMP_:\n+\tfd->have_reductemp = true;\n       default:\n \tbreak;\n       }\n@@ -250,13 +255,45 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \n       loop->cond_code = gimple_omp_for_cond (for_stmt, i);\n       loop->n2 = gimple_omp_for_final (for_stmt, i);\n-      gcc_assert (loop->cond_code != NE_EXPR);\n+      gcc_assert (loop->cond_code != NE_EXPR\n+\t\t  || (gimple_omp_for_kind (for_stmt)\n+\t\t      != GF_OMP_FOR_KIND_OACC_LOOP));\n       omp_adjust_for_condition (loc, &loop->cond_code, &loop->n2);\n \n       t = gimple_omp_for_incr (for_stmt, i);\n       gcc_assert (TREE_OPERAND (t, 0) == var);\n       loop->step = omp_get_for_step_from_incr (loc, t);\n \n+      if (loop->cond_code == NE_EXPR)\n+\t{\n+\t  gcc_assert (TREE_CODE (loop->step) == INTEGER_CST);\n+\t  if (TREE_CODE (TREE_TYPE (loop->v)) == INTEGER_TYPE)\n+\t    {\n+\t      if (integer_onep (loop->step))\n+\t\tloop->cond_code = LT_EXPR;\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (integer_minus_onep (loop->step));\n+\t\t  loop->cond_code = GT_EXPR;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      tree unit = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (loop->v)));\n+\t      gcc_assert (TREE_CODE (unit) == INTEGER_CST);\n+\t      if (tree_int_cst_equal (unit, loop->step))\n+\t\tloop->cond_code = LT_EXPR;\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (wi::neg (wi::to_widest (unit))\n+\t\t\t      == wi::to_widest (loop->step));\n+\t\t  loop->cond_code = GT_EXPR;\n+\t\t}\n+\t    }\n+\t}\n+\n+      omp_adjust_for_condition (loc, &loop->cond_code, &loop->n2);\n+\n       if (simd\n \t  || (fd->sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n \t      && !fd->have_ordered))\n@@ -281,9 +318,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      tree n;\n \n \t      if (loop->cond_code == LT_EXPR)\n-\t\tn = fold_build2_loc (loc,\n-\t\t\t\t PLUS_EXPR, TREE_TYPE (loop->v),\n-\t\t\t\t loop->n2, loop->step);\n+\t\tn = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (loop->v),\n+\t\t\t\t     loop->n2, loop->step);\n \t      else\n \t\tn = loop->n1;\n \t      if (TREE_CODE (n) != INTEGER_CST\n@@ -298,15 +334,13 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      if (loop->cond_code == LT_EXPR)\n \t\t{\n \t\t  n1 = loop->n1;\n-\t\t  n2 = fold_build2_loc (loc,\n-\t\t\t\t    PLUS_EXPR, TREE_TYPE (loop->v),\n-\t\t\t\t    loop->n2, loop->step);\n+\t\t  n2 = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (loop->v),\n+\t\t\t\t\tloop->n2, loop->step);\n \t\t}\n \t      else\n \t\t{\n-\t\t  n1 = fold_build2_loc (loc,\n-\t\t\t\t    MINUS_EXPR, TREE_TYPE (loop->v),\n-\t\t\t\t    loop->n2, loop->step);\n+\t\t  n1 = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (loop->v),\n+\t\t\t\t\tloop->n2, loop->step);\n \t\t  n2 = loop->n1;\n \t\t}\n \t      if (TREE_CODE (n1) != INTEGER_CST\n@@ -338,27 +372,31 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      if (POINTER_TYPE_P (itype))\n \t\titype = signed_type_for (itype);\n \t      t = build_int_cst (itype, (loop->cond_code == LT_EXPR ? -1 : 1));\n-\t      t = fold_build2_loc (loc,\n-\t\t\t       PLUS_EXPR, itype,\n-\t\t\t       fold_convert_loc (loc, itype, loop->step), t);\n+\t      t = fold_build2_loc (loc, PLUS_EXPR, itype,\n+\t\t\t\t   fold_convert_loc (loc, itype, loop->step),\n+\t\t\t\t   t);\n \t      t = fold_build2_loc (loc, PLUS_EXPR, itype, t,\n-\t\t\t       fold_convert_loc (loc, itype, loop->n2));\n+\t\t\t\t   fold_convert_loc (loc, itype, loop->n2));\n \t      t = fold_build2_loc (loc, MINUS_EXPR, itype, t,\n-\t\t\t       fold_convert_loc (loc, itype, loop->n1));\n+\t\t\t\t   fold_convert_loc (loc, itype, loop->n1));\n \t      if (TYPE_UNSIGNED (itype) && loop->cond_code == GT_EXPR)\n-\t\tt = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n-\t\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype, t),\n-\t\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype,\n-\t\t\t\t\t      fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t\t\tloop->step)));\n+\t\t{\n+\t\t  tree step = fold_convert_loc (loc, itype, loop->step);\n+\t\t  t = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n+\t\t\t\t       fold_build1_loc (loc, NEGATE_EXPR,\n+\t\t\t\t\t\t\titype, t),\n+\t\t\t\t       fold_build1_loc (loc, NEGATE_EXPR,\n+\t\t\t\t\t\t\titype, step));\n+\t\t}\n \t      else\n \t\tt = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n-\t\t\t\t fold_convert_loc (loc, itype, loop->step));\n+\t\t\t\t     fold_convert_loc (loc, itype,\n+\t\t\t\t\t\t       loop->step));\n \t      t = fold_convert_loc (loc, long_long_unsigned_type_node, t);\n \t      if (count != NULL_TREE)\n-\t\tcount = fold_build2_loc (loc,\n-\t\t\t\t     MULT_EXPR, long_long_unsigned_type_node,\n-\t\t\t\t     count, t);\n+\t\tcount = fold_build2_loc (loc, MULT_EXPR,\n+\t\t\t\t\t long_long_unsigned_type_node,\n+\t\t\t\t\t count, t);\n \t      else\n \t\tcount = t;\n \t      if (TREE_CODE (count) != INTEGER_CST)"}, {"sha": "b847506d45282092e64e55eca4709c61f52c42d7", "filename": "gcc/omp-general.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -62,7 +62,7 @@ struct omp_for_data\n   tree tiling;  /* Tiling values (if non null).  */\n   int collapse;  /* Collapsed loops, 1 for a non-collapsed loop.  */\n   int ordered;\n-  bool have_nowait, have_ordered, simd_schedule;\n+  bool have_nowait, have_ordered, simd_schedule, have_reductemp;\n   unsigned char sched_modifiers;\n   enum omp_clause_schedule_kind sched_kind;\n   struct omp_for_data_loop *loops;\n@@ -89,4 +89,16 @@ extern bool offloading_function_p (tree fn);\n extern int oacc_get_fn_dim_size (tree fn, int axis);\n extern int oacc_get_ifn_dim_arg (const gimple *stmt);\n \n+enum omp_requires {\n+  OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER = 0xf,\n+  OMP_REQUIRES_UNIFIED_ADDRESS = 0x10,\n+  OMP_REQUIRES_UNIFIED_SHARED_MEMORY = 0x20,\n+  OMP_REQUIRES_DYNAMIC_ALLOCATORS = 0x40,\n+  OMP_REQUIRES_REVERSE_OFFLOAD = 0x80,\n+  OMP_REQUIRES_ATOMIC_DEFAULT_MEM_ORDER_USED = 0x100,\n+  OMP_REQUIRES_TARGET_USED = 0x200\n+};\n+\n+extern GTY(()) enum omp_requires omp_requires_mask;\n+\n #endif /* GCC_OMP_GENERAL_H */"}, {"sha": "d443bce169b9f8b040e03d4d21fe4882272250c1", "filename": "gcc/omp-grid.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-grid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-grid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-grid.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1053,8 +1053,8 @@ grid_eliminate_combined_simd_part (gomp_for *parloop)\n   while (*tgt)\n     tgt = &OMP_CLAUSE_CHAIN (*tgt);\n \n-  /* Copy over all clauses, except for linaer clauses, which are turned into\n-     private clauses, and all other simd-specificl clauses, which are\n+  /* Copy over all clauses, except for linear clauses, which are turned into\n+     private clauses, and all other simd-specific clauses, which are\n      ignored.  */\n   tree *pc = gimple_omp_for_clauses_ptr (simd);\n   while (*pc)\n@@ -1083,7 +1083,7 @@ grid_eliminate_combined_simd_part (gomp_for *parloop)\n \t  *pc = OMP_CLAUSE_CHAIN (c);\n \t  OMP_CLAUSE_CHAIN (c) = NULL;\n \t  *tgt = c;\n-\t  tgt = &OMP_CLAUSE_CHAIN(c);\n+\t  tgt = &OMP_CLAUSE_CHAIN (c);\n \t  break;\n \t}\n     }"}, {"sha": "ca78d7abe26ba9dd14d635d3298dc023f2020e6a", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1719, "deletions": 159, "changes": 1878, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -114,6 +114,15 @@ struct omp_context\n      otherwise.  */\n   gimple *simt_stmt;\n \n+  /* For task reductions registered in this context, a vector containing\n+     the length of the private copies block (if constant, otherwise NULL)\n+     and then offsets (if constant, otherwise NULL) for each entry.  */\n+  vec<tree> task_reductions;\n+\n+  /* And a hash map from the reduction clauses to the registered array\n+     elts.  */\n+  hash_map<tree, unsigned> *task_reduction_map;\n+\n   /* Nesting depth of this context.  Used to beautify error messages re\n      invalid gotos.  The outermost ctx is depth 1, with depth 0 being\n      reserved for the main body of the function.  */\n@@ -280,12 +289,23 @@ is_taskloop_ctx (omp_context *ctx)\n }\n \n \n-/* Return true if CTX is for an omp parallel or omp task.  */\n+/* Return true if CTX is for a host omp teams.  */\n+\n+static inline bool\n+is_host_teams_ctx (omp_context *ctx)\n+{\n+  return gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS\n+\t && gimple_omp_teams_host (as_a <gomp_teams *> (ctx->stmt));\n+}\n+\n+/* Return true if CTX is for an omp parallel or omp task or host omp teams\n+   (the last one is strictly not a task region in OpenMP speak, but we\n+   need to treat it similarly).  */\n \n static inline bool\n is_taskreg_ctx (omp_context *ctx)\n {\n-  return is_parallel_ctx (ctx) || is_task_ctx (ctx);\n+  return is_parallel_ctx (ctx) || is_task_ctx (ctx) || is_host_teams_ctx (ctx);\n }\n \n /* Return true if EXPR is variable sized.  */\n@@ -371,7 +391,7 @@ use_pointer_for_field (tree decl, omp_context *shared_ctx)\n \t be passing an address in this case?  Should we simply assert\n \t this to be false, or should we have a cleanup pass that removes\n \t these from the list of mappings?  */\n-      if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n+      if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, shared_ctx)))\n \treturn true;\n \n       /* For variables with DECL_HAS_VALUE_EXPR_P set, we cannot tell\n@@ -522,6 +542,9 @@ build_outer_var_ref (tree var, omp_context *ctx,\n \t\t     enum omp_clause_code code = OMP_CLAUSE_ERROR)\n {\n   tree x;\n+  omp_context *outer = ctx->outer;\n+  while (outer && gimple_code (outer->stmt) == GIMPLE_OMP_TASKGROUP)\n+    outer = outer->outer;\n \n   if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, ctx)))\n     x = var;\n@@ -548,44 +571,43 @@ build_outer_var_ref (tree var, omp_context *ctx,\n \t Similarly for OMP_CLAUSE_PRIVATE with outer ref, that can refer\n \t to private vars in all worksharing constructs.  */\n       x = NULL_TREE;\n-      if (ctx->outer && is_taskreg_ctx (ctx))\n-\tx = lookup_decl (var, ctx->outer);\n-      else if (ctx->outer)\n+      if (outer && is_taskreg_ctx (outer))\n+\tx = lookup_decl (var, outer);\n+      else if (outer)\n \tx = maybe_lookup_decl_in_outer_ctx (var, ctx);\n       if (x == NULL_TREE)\n \tx = var;\n     }\n   else if (code == OMP_CLAUSE_LASTPRIVATE && is_taskloop_ctx (ctx))\n     {\n-      gcc_assert (ctx->outer);\n+      gcc_assert (outer);\n       splay_tree_node n\n-\t= splay_tree_lookup (ctx->outer->field_map,\n+\t= splay_tree_lookup (outer->field_map,\n \t\t\t     (splay_tree_key) &DECL_UID (var));\n       if (n == NULL)\n \t{\n-\t  if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, ctx->outer)))\n+\t  if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, outer)))\n \t    x = var;\n \t  else\n-\t    x = lookup_decl (var, ctx->outer);\n+\t    x = lookup_decl (var, outer);\n \t}\n       else\n \t{\n \t  tree field = (tree) n->value;\n \t  /* If the receiver record type was remapped in the child function,\n \t     remap the field into the new record type.  */\n-\t  x = maybe_lookup_field (field, ctx->outer);\n+\t  x = maybe_lookup_field (field, outer);\n \t  if (x != NULL)\n \t    field = x;\n \n-\t  x = build_simple_mem_ref (ctx->outer->receiver_decl);\n+\t  x = build_simple_mem_ref (outer->receiver_decl);\n \t  x = omp_build_component_ref (x, field);\n-\t  if (use_pointer_for_field (var, ctx->outer))\n+\t  if (use_pointer_for_field (var, outer))\n \t    x = build_simple_mem_ref (x);\n \t}\n     }\n-  else if (ctx->outer)\n+  else if (outer)\n     {\n-      omp_context *outer = ctx->outer;\n       if (gimple_code (outer->stmt) == GIMPLE_OMP_GRID_BODY)\n \t{\n \t  outer = outer->outer;\n@@ -925,6 +947,12 @@ delete_omp_context (splay_tree_value value)\n   if (is_task_ctx (ctx))\n     finalize_task_copyfn (as_a <gomp_task *> (ctx->stmt));\n \n+  if (ctx->task_reduction_map)\n+    {\n+      ctx->task_reductions.release ();\n+      delete ctx->task_reduction_map;\n+    }\n+\n   XDELETE (ctx);\n }\n \n@@ -1011,8 +1039,10 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \n \tcase OMP_CLAUSE_SHARED:\n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  /* Ignore shared directives in teams construct.  */\n-\t  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n+\t  /* Ignore shared directives in teams construct inside of\n+\t     target construct.  */\n+\t  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS\n+\t      && !is_host_teams_ctx (ctx))\n \t    {\n \t      /* Global variables don't need to be copied,\n \t\t the receiver side will use them directly.  */\n@@ -1050,9 +1080,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  goto do_private;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-\t      && TREE_CODE (decl) == MEM_REF)\n+\t  if (TREE_CODE (decl) == MEM_REF)\n \t    {\n \t      tree t = TREE_OPERAND (decl, 0);\n \t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n@@ -1062,14 +1092,52 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\tt = TREE_OPERAND (t, 0);\n \t      install_var_local (t, ctx);\n \t      if (is_taskreg_ctx (ctx)\n-\t\t  && !is_global_var (maybe_lookup_decl_in_outer_ctx (t, ctx))\n-\t\t  && !is_variable_sized (t))\n+\t\t  && (!is_global_var (maybe_lookup_decl_in_outer_ctx (t, ctx))\n+\t\t      || (is_task_ctx (ctx)\n+\t\t\t  && (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n+\t\t\t      || (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n+\t\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_TYPE (t)))\n+\t\t\t\t      == POINTER_TYPE)))))\n+\t\t  && !is_variable_sized (t)\n+\t\t  && (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t\t      || (!OMP_CLAUSE_REDUCTION_TASK (c)\n+\t\t\t  && !is_task_ctx (ctx))))\n \t\t{\n-\t\t  by_ref = use_pointer_for_field (t, ctx);\n-\t\t  install_var_field (t, by_ref, 3, ctx);\n+\t\t  by_ref = use_pointer_for_field (t, NULL);\n+\t\t  if (is_task_ctx (ctx)\n+\t\t      && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n+\t\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (t))) == POINTER_TYPE)\n+\t\t    {\n+\t\t      install_var_field (t, false, 1, ctx);\n+\t\t      install_var_field (t, by_ref, 2, ctx);\n+\t\t    }\n+\t\t  else\n+\t\t    install_var_field (t, by_ref, 3, ctx);\n \t\t}\n \t      break;\n \t    }\n+\t  if (is_task_ctx (ctx)\n+\t      || (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t  && OMP_CLAUSE_REDUCTION_TASK (c)\n+\t\t  && is_parallel_ctx (ctx)))\n+\t    {\n+\t      /* Global variables don't need to be copied,\n+\t\t the receiver side will use them directly.  */\n+\t      if (!is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n+\t\t{\n+\t\t  by_ref = use_pointer_for_field (decl, ctx);\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION)\n+\t\t    install_var_field (decl, by_ref, 3, ctx);\n+\t\t}\n+\t      install_var_local (decl, ctx);\n+\t      break;\n+\t    }\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t      && OMP_CLAUSE_REDUCTION_TASK (c))\n+\t    {\n+\t      install_var_local (decl, ctx);\n+\t      break;\n+\t    }\n \t  goto do_private;\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n@@ -1142,6 +1210,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  goto do_private;\n \n \tcase OMP_CLAUSE__LOOPTEMP_:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n \t  gcc_assert (is_taskreg_ctx (ctx));\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  install_var_field (decl, false, 3, ctx);\n@@ -1323,8 +1392,10 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE__SIMT_:\n \tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -1382,6 +1453,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (decl) != MEM_REF)\n \t    {\n@@ -1393,9 +1465,16 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    scan_array_reductions = true;\n \t  break;\n \n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t    scan_array_reductions = true;\n+\t  break;\n+\n \tcase OMP_CLAUSE_SHARED:\n-\t  /* Ignore shared directives in teams construct.  */\n-\t  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n+\t  /* Ignore shared directives in teams construct inside of\n+\t     target construct.  */\n+\t  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS\n+\t      && !is_host_teams_ctx (ctx))\n \t    break;\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n@@ -1472,6 +1551,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_ALIGNED:\n \tcase OMP_CLAUSE_DEPEND:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_PRIORITY:\n@@ -1482,6 +1562,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_NUM_GANGS:\n@@ -1511,7 +1592,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n   if (scan_array_reductions)\n     {\n       for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\tif ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t     || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n+\t     || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n \t    && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t  {\n \t    scan_omp (&OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c), ctx);\n@@ -1700,7 +1783,7 @@ omp_find_combined_for (gimple_stmt_iterator *gsi_p,\n   return NULL;\n }\n \n-/* Add _LOOPTEMP_ clauses on OpenMP parallel or task.  */\n+/* Add _LOOPTEMP_/_REDUCTEMP_ clauses on OpenMP parallel or task.  */\n \n static void\n add_taskreg_looptemp_clauses (enum gf_mask msk, gimple *stmt,\n@@ -1747,6 +1830,18 @@ add_taskreg_looptemp_clauses (enum gf_mask msk, gimple *stmt,\n \t  gimple_omp_taskreg_set_clauses (stmt, c);\n \t}\n     }\n+  if (msk == GF_OMP_FOR_KIND_TASKLOOP\n+      && omp_find_clause (gimple_omp_task_clauses (stmt),\n+\t\t\t  OMP_CLAUSE_REDUCTION))\n+    {\n+      tree type = build_pointer_type (pointer_sized_int_node);\n+      tree temp = create_tmp_var (type);\n+      tree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__REDUCTEMP_);\n+      insert_decl_map (&outer_ctx->cb, temp, temp);\n+      OMP_CLAUSE_DECL (c) = temp;\n+      OMP_CLAUSE_CHAIN (c) = gimple_omp_task_clauses (stmt);\n+      gimple_omp_task_set_clauses (stmt, c);\n+    }\n }\n \n /* Scan an OpenMP parallel directive.  */\n@@ -1771,6 +1866,23 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \n   if (gimple_omp_parallel_combined_p (stmt))\n     add_taskreg_looptemp_clauses (GF_OMP_FOR_KIND_FOR, stmt, outer_ctx);\n+  for (tree c = omp_find_clause (gimple_omp_parallel_clauses (stmt),\n+\t\t\t\t OMP_CLAUSE_REDUCTION);\n+       c; c = omp_find_clause (OMP_CLAUSE_CHAIN (c), OMP_CLAUSE_REDUCTION))\n+    if (OMP_CLAUSE_REDUCTION_TASK (c))\n+      {\n+\ttree type = build_pointer_type (pointer_sized_int_node);\n+\ttree temp = create_tmp_var (type);\n+\ttree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__REDUCTEMP_);\n+\tif (outer_ctx)\n+\t  insert_decl_map (&outer_ctx->cb, temp, temp);\n+\tOMP_CLAUSE_DECL (c) = temp;\n+\tOMP_CLAUSE_CHAIN (c) = gimple_omp_parallel_clauses (stmt);\n+\tgimple_omp_parallel_set_clauses (stmt, c);\n+\tbreak;\n+      }\n+    else if (OMP_CLAUSE_CHAIN (c) == NULL_TREE)\n+      break;\n \n   ctx = new_omp_context (stmt, outer_ctx);\n   taskreg_contexts.safe_push (ctx);\n@@ -1810,6 +1922,7 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   /* Ignore task directives with empty bodies, unless they have depend\n      clause.  */\n   if (optimize > 0\n+      && gimple_omp_body (stmt)\n       && empty_body_p (gimple_omp_body (stmt))\n       && !omp_find_clause (gimple_omp_task_clauses (stmt), OMP_CLAUSE_DEPEND))\n     {\n@@ -1821,6 +1934,13 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n     add_taskreg_looptemp_clauses (GF_OMP_FOR_KIND_TASKLOOP, stmt, outer_ctx);\n \n   ctx = new_omp_context (stmt, outer_ctx);\n+\n+  if (gimple_omp_task_taskwait_p (stmt))\n+    {\n+      scan_sharing_clauses (gimple_omp_task_clauses (stmt), ctx);\n+      return;\n+    }\n+\n   taskreg_contexts.safe_push (ctx);\n   if (taskreg_nesting_level > 1)\n     ctx->is_nested = true;\n@@ -1897,7 +2017,7 @@ finish_taskreg_scan (omp_context *ctx)\n     return;\n \n   /* If any task_shared_vars were needed, verify all\n-     OMP_CLAUSE_SHARED clauses on GIMPLE_OMP_{PARALLEL,TASK}\n+     OMP_CLAUSE_SHARED clauses on GIMPLE_OMP_{PARALLEL,TASK,TEAMS}\n      statements if use_pointer_for_field hasn't changed\n      because of that.  If it did, update field types now.  */\n   if (task_shared_vars)\n@@ -1942,6 +2062,30 @@ finish_taskreg_scan (omp_context *ctx)\n     }\n \n   if (gimple_code (ctx->stmt) == GIMPLE_OMP_PARALLEL)\n+    {\n+      tree clauses = gimple_omp_parallel_clauses (ctx->stmt);\n+      tree c = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+      if (c)\n+\t{\n+\t  /* Move the _reductemp_ clause first.  GOMP_parallel_reductions\n+\t     expects to find it at the start of data.  */\n+\t  tree f = lookup_field (OMP_CLAUSE_DECL (c), ctx);\n+\t  tree *p = &TYPE_FIELDS (ctx->record_type);\n+\t  while (*p)\n+\t    if (*p == f)\n+\t      {\n+\t\t*p = DECL_CHAIN (*p);\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      p = &DECL_CHAIN (*p);\n+\t  DECL_CHAIN (f) = TYPE_FIELDS (ctx->record_type);\n+\t  TYPE_FIELDS (ctx->record_type) = f;\n+\t}\n+      layout_type (ctx->record_type);\n+      fixup_child_record_type (ctx);\n+    }\n+  else if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n     {\n       layout_type (ctx->record_type);\n       fixup_child_record_type (ctx);\n@@ -1969,33 +2113,50 @@ finish_taskreg_scan (omp_context *ctx)\n \t  /* Move fields corresponding to first and second _looptemp_\n \t     clause first.  There are filled by GOMP_taskloop\n \t     and thus need to be in specific positions.  */\n-\t  tree c1 = gimple_omp_task_clauses (ctx->stmt);\n-\t  c1 = omp_find_clause (c1, OMP_CLAUSE__LOOPTEMP_);\n+\t  tree clauses = gimple_omp_task_clauses (ctx->stmt);\n+\t  tree c1 = omp_find_clause (clauses, OMP_CLAUSE__LOOPTEMP_);\n \t  tree c2 = omp_find_clause (OMP_CLAUSE_CHAIN (c1),\n \t\t\t\t     OMP_CLAUSE__LOOPTEMP_);\n+\t  tree c3 = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n \t  tree f1 = lookup_field (OMP_CLAUSE_DECL (c1), ctx);\n \t  tree f2 = lookup_field (OMP_CLAUSE_DECL (c2), ctx);\n+\t  tree f3 = c3 ? lookup_field (OMP_CLAUSE_DECL (c3), ctx) : NULL_TREE;\n \t  p = &TYPE_FIELDS (ctx->record_type);\n \t  while (*p)\n-\t    if (*p == f1 || *p == f2)\n+\t    if (*p == f1 || *p == f2 || *p == f3)\n \t      *p = DECL_CHAIN (*p);\n \t    else\n \t      p = &DECL_CHAIN (*p);\n \t  DECL_CHAIN (f1) = f2;\n-\t  DECL_CHAIN (f2) = TYPE_FIELDS (ctx->record_type);\n+\t  if (c3)\n+\t    {\n+\t      DECL_CHAIN (f2) = f3;\n+\t      DECL_CHAIN (f3) = TYPE_FIELDS (ctx->record_type);\n+\t    }\n+\t  else\n+\t    DECL_CHAIN (f2) = TYPE_FIELDS (ctx->record_type);\n \t  TYPE_FIELDS (ctx->record_type) = f1;\n \t  if (ctx->srecord_type)\n \t    {\n \t      f1 = lookup_sfield (OMP_CLAUSE_DECL (c1), ctx);\n \t      f2 = lookup_sfield (OMP_CLAUSE_DECL (c2), ctx);\n+\t      if (c3)\n+\t\tf3 = lookup_sfield (OMP_CLAUSE_DECL (c3), ctx);\n \t      p = &TYPE_FIELDS (ctx->srecord_type);\n \t      while (*p)\n-\t\tif (*p == f1 || *p == f2)\n+\t\tif (*p == f1 || *p == f2 || *p == f3)\n \t\t  *p = DECL_CHAIN (*p);\n \t\telse\n \t\t  p = &DECL_CHAIN (*p);\n \t      DECL_CHAIN (f1) = f2;\n \t      DECL_CHAIN (f2) = TYPE_FIELDS (ctx->srecord_type);\n+\t      if (c3)\n+\t\t{\n+\t\t  DECL_CHAIN (f2) = f3;\n+\t\t  DECL_CHAIN (f3) = TYPE_FIELDS (ctx->srecord_type);\n+\t\t}\n+\t      else\n+\t\tDECL_CHAIN (f2) = TYPE_FIELDS (ctx->srecord_type);\n \t      TYPE_FIELDS (ctx->srecord_type) = f1;\n \t    }\n \t}\n@@ -2154,7 +2315,7 @@ scan_omp_for (gomp_for *stmt, omp_context *outer_ctx)\n \n       if (tgt && is_oacc_kernels (tgt))\n \t{\n-\t  /* Strip out reductions, as they are not  handled yet.  */\n+\t  /* Strip out reductions, as they are not handled yet.  */\n \t  tree *prev_ptr = &clauses;\n \n \t  while (tree probe = *prev_ptr)\n@@ -2321,8 +2482,32 @@ static void\n scan_omp_teams (gomp_teams *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx = new_omp_context (stmt, outer_ctx);\n+\n+  if (!gimple_omp_teams_host (stmt))\n+    {\n+      scan_sharing_clauses (gimple_omp_teams_clauses (stmt), ctx);\n+      scan_omp (gimple_omp_body_ptr (stmt), ctx);\n+      return;\n+    }\n+  taskreg_contexts.safe_push (ctx);\n+  gcc_assert (taskreg_nesting_level == 1);\n+  ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n+  ctx->record_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  tree name = create_tmp_var_name (\".omp_data_s\");\n+  name = build_decl (gimple_location (stmt),\n+\t\t     TYPE_DECL, name, ctx->record_type);\n+  DECL_ARTIFICIAL (name) = 1;\n+  DECL_NAMELESS (name) = 1;\n+  TYPE_NAME (ctx->record_type) = name;\n+  TYPE_ARTIFICIAL (ctx->record_type) = 1;\n+  create_omp_child_function (ctx, false);\n+  gimple_omp_teams_set_child_fn (stmt, ctx->cb.dst_fn);\n+\n   scan_sharing_clauses (gimple_omp_teams_clauses (stmt), ctx);\n   scan_omp (gimple_omp_body_ptr (stmt), ctx);\n+\n+  if (TYPE_FIELDS (ctx->record_type) == NULL)\n+    ctx->record_type = ctx->receiver_decl = NULL;\n }\n \n /* Check nesting restrictions.  */\n@@ -2388,9 +2573,13 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\t  return true;\n \t\t}\n \t    }\n+\t  else if (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD\n+\t\t   || gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE)\n+\t    return true;\n \t  error_at (gimple_location (stmt),\n \t\t    \"OpenMP constructs other than %<#pragma omp ordered simd%>\"\n-\t\t    \" may not be nested inside %<simd%> region\");\n+\t\t    \" or %<#pragma omp atomic%> may not be nested inside\"\n+\t\t    \" %<simd%> region\");\n \t  return false;\n \t}\n       else if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n@@ -2814,13 +3003,20 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n       }\n       break;\n     case GIMPLE_OMP_TEAMS:\n-      if (ctx == NULL\n-\t  || gimple_code (ctx->stmt) != GIMPLE_OMP_TARGET\n-\t  || gimple_omp_target_kind (ctx->stmt) != GF_OMP_TARGET_KIND_REGION)\n+      if (ctx == NULL)\n+\tbreak;\n+      else if (gimple_code (ctx->stmt) != GIMPLE_OMP_TARGET\n+\t       || (gimple_omp_target_kind (ctx->stmt)\n+\t\t   != GF_OMP_TARGET_KIND_REGION))\n \t{\n+\t  /* Teams construct can appear either strictly nested inside of\n+\t     target construct with no intervening stmts, or can be encountered\n+\t     only by initial task (so must not appear inside any OpenMP\n+\t     construct.  */\n \t  error_at (gimple_location (stmt),\n-\t\t    \"%<teams%> construct not closely nested inside of \"\n-\t\t    \"%<target%> construct\");\n+\t\t    \"%<teams%> construct must be closely nested inside of \"\n+\t\t    \"%<target%> construct or not nested in any OpenMP \"\n+\t\t    \"construct\");\n \t  return false;\n \t}\n       break;\n@@ -3090,20 +3286,32 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n-    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_GRID_BODY:\n       ctx = new_omp_context (stmt, ctx);\n       scan_omp (gimple_omp_body_ptr (stmt), ctx);\n       break;\n \n+    case GIMPLE_OMP_TASKGROUP:\n+      ctx = new_omp_context (stmt, ctx);\n+      scan_sharing_clauses (gimple_omp_taskgroup_clauses (stmt), ctx);\n+      scan_omp (gimple_omp_body_ptr (stmt), ctx);\n+      break;\n+\n     case GIMPLE_OMP_TARGET:\n       scan_omp_target (as_a <gomp_target *> (stmt), ctx);\n       break;\n \n     case GIMPLE_OMP_TEAMS:\n-      scan_omp_teams (as_a <gomp_teams *> (stmt), ctx);\n+      if (gimple_omp_teams_host (as_a <gomp_teams *> (stmt)))\n+\t{\n+\t  taskreg_nesting_level++;\n+\t  scan_omp_teams (as_a <gomp_teams *> (stmt), ctx);\n+\t  taskreg_nesting_level--;\n+\t}\n+      else\n+\tscan_omp_teams (as_a <gomp_teams *> (stmt), ctx);\n       break;\n \n     case GIMPLE_BIND:\n@@ -3515,6 +3723,30 @@ handle_simd_reference (location_t loc, tree new_vard, gimple_seq *ilist)\n     }\n }\n \n+/* Helper function for lower_rec_input_clauses.  Emit into ilist sequence\n+   code to emit (type) (tskred_temp[idx]).  */\n+\n+static tree\n+task_reduction_read (gimple_seq *ilist, tree tskred_temp, tree type,\n+\t\t     unsigned idx)\n+{\n+  unsigned HOST_WIDE_INT sz\n+    = tree_to_uhwi (TYPE_SIZE_UNIT (pointer_sized_int_node));\n+  tree r = build2 (MEM_REF, pointer_sized_int_node,\n+\t\t   tskred_temp, build_int_cst (TREE_TYPE (tskred_temp),\n+\t\t\t\t\t       idx * sz));\n+  tree v = create_tmp_var (pointer_sized_int_node);\n+  gimple *g = gimple_build_assign (v, r);\n+  gimple_seq_add_stmt (ilist, g);\n+  if (!useless_type_conversion_p (type, pointer_sized_int_node))\n+    {\n+      v = create_tmp_var (type);\n+      g = gimple_build_assign (v, NOP_EXPR, gimple_assign_lhs (g));\n+      gimple_seq_add_stmt (ilist, g);\n+    }\n+  return v;\n+}\n+\n /* Generate code to implement the input clauses, FIRSTPRIVATE and COPYIN,\n    from the receiver (aka child) side and initializers for REFERENCE_TYPE\n    private variables.  Initialization statements go in ILIST, while calls\n@@ -3558,6 +3790,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    sctx.max_vf = 1;\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n \t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF\n \t      || is_variable_sized (OMP_CLAUSE_DECL (c)))\n \t    sctx.max_vf = 1;\n@@ -3570,18 +3803,87 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   if (sctx.is_simt && maybe_ne (sctx.max_vf, 1U))\n     sctx.simt_eargs.safe_push (NULL_TREE);\n \n+  unsigned task_reduction_cnt = 0;\n+  unsigned task_reduction_cntorig = 0;\n+  unsigned task_reduction_cnt_full = 0;\n+  unsigned task_reduction_cntorig_full = 0;\n+  unsigned task_reduction_other_cnt = 0;\n+  tree tskred_atype = NULL_TREE, tskred_avar = NULL_TREE;\n+  tree tskred_base = NULL_TREE, tskred_temp = NULL_TREE;\n   /* Do all the fixed sized types in the first pass, and the variable sized\n      types in the second pass.  This makes sure that the scalar arguments to\n      the variable sized types are processed before we use them in the\n-     variable sized operations.  */\n-  for (pass = 0; pass < 2; ++pass)\n-    {\n+     variable sized operations.  For task reductions we use 4 passes, in the\n+     first two we ignore them, in the third one gather arguments for\n+     GOMP_task_reduction_remap call and in the last pass actually handle\n+     the task reductions.  */\n+  for (pass = 0; pass < ((task_reduction_cnt || task_reduction_other_cnt)\n+\t\t\t ? 4 : 2); ++pass)\n+    {\n+      if (pass == 2 && task_reduction_cnt)\n+\t{\n+\t  tskred_atype\n+\t    = build_array_type_nelts (ptr_type_node, task_reduction_cnt\n+\t\t\t\t\t\t     + task_reduction_cntorig);\n+\t  tskred_avar = create_tmp_var_raw (tskred_atype);\n+\t  gimple_add_tmp_var (tskred_avar);\n+\t  TREE_ADDRESSABLE (tskred_avar) = 1;\n+\t  task_reduction_cnt_full = task_reduction_cnt;\n+\t  task_reduction_cntorig_full = task_reduction_cntorig;\n+\t}\n+      else if (pass == 3 && task_reduction_cnt)\n+\t{\n+\t  x = builtin_decl_explicit (BUILT_IN_GOMP_TASK_REDUCTION_REMAP);\n+\t  gimple *g\n+\t    = gimple_build_call (x, 3, size_int (task_reduction_cnt),\n+\t\t\t\t size_int (task_reduction_cntorig),\n+\t\t\t\t build_fold_addr_expr (tskred_avar));\n+\t  gimple_seq_add_stmt (ilist, g);\n+\t}\n+      if (pass == 3 && task_reduction_other_cnt)\n+\t{\n+\t  /* For reduction clauses, build\n+\t     tskred_base = (void *) tskred_temp[2]\n+\t\t\t   + omp_get_thread_num () * tskred_temp[1]\n+\t     or if tskred_temp[1] is known to be constant, that constant\n+\t     directly.  This is the start of the private reduction copy block\n+\t     for the current thread.  */\n+\t  tree v = create_tmp_var (integer_type_node);\n+\t  x = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+\t  gimple *g = gimple_build_call (x, 0);\n+\t  gimple_call_set_lhs (g, v);\n+\t  gimple_seq_add_stmt (ilist, g);\n+\t  c = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+\t  tskred_temp = OMP_CLAUSE_DECL (c);\n+\t  if (is_taskreg_ctx (ctx))\n+\t    tskred_temp = lookup_decl (tskred_temp, ctx);\n+\t  tree v2 = create_tmp_var (sizetype);\n+\t  g = gimple_build_assign (v2, NOP_EXPR, v);\n+\t  gimple_seq_add_stmt (ilist, g);\n+\t  if (ctx->task_reductions[0])\n+\t    v = fold_convert (sizetype, ctx->task_reductions[0]);\n+\t  else\n+\t    v = task_reduction_read (ilist, tskred_temp, sizetype, 1);\n+\t  tree v3 = create_tmp_var (sizetype);\n+\t  g = gimple_build_assign (v3, MULT_EXPR, v2, v);\n+\t  gimple_seq_add_stmt (ilist, g);\n+\t  v = task_reduction_read (ilist, tskred_temp, ptr_type_node, 2);\n+\t  tskred_base = create_tmp_var (ptr_type_node);\n+\t  g = gimple_build_assign (tskred_base, POINTER_PLUS_EXPR, v, v3);\n+\t  gimple_seq_add_stmt (ilist, g);\n+\t}\n+      task_reduction_cnt = 0;\n+      task_reduction_cntorig = 0;\n+      task_reduction_other_cnt = 0;\n       for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n \t{\n \t  enum omp_clause_code c_kind = OMP_CLAUSE_CODE (c);\n \t  tree var, new_var;\n \t  bool by_ref;\n \t  location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n+\t  bool task_reduction_p = false;\n+\t  bool task_reduction_needs_orig_p = false;\n+\t  tree cond = NULL_TREE;\n \n \t  switch (c_kind)\n \t    {\n@@ -3590,8 +3892,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\tcontinue;\n \t      break;\n \t    case OMP_CLAUSE_SHARED:\n-\t      /* Ignore shared directives in teams construct.  */\n-\t      if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n+\t      /* Ignore shared directives in teams construct inside\n+\t\t of target construct.  */\n+\t      if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS\n+\t\t  && !is_host_teams_ctx (ctx))\n \t\tcontinue;\n \t      if (maybe_lookup_decl (OMP_CLAUSE_DECL (c), ctx) == NULL)\n \t\t{\n@@ -3608,11 +3912,46 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\tlastprivate_firstprivate = true;\n \t      break;\n \t    case OMP_CLAUSE_REDUCTION:\n-\t      if (OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n+\t    case OMP_CLAUSE_IN_REDUCTION:\n+\t      if (is_task_ctx (ctx) || OMP_CLAUSE_REDUCTION_TASK (c))\n+\t\t{\n+\t\t  task_reduction_p = true;\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t\t    {\n+\t\t      task_reduction_other_cnt++;\n+\t\t      if (pass == 2)\n+\t\t\tcontinue;\n+\t\t    }\n+\t\t  else\n+\t\t    task_reduction_cnt++;\n+\t\t  if (OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n+\t\t    {\n+\t\t      var = OMP_CLAUSE_DECL (c);\n+\t\t      /* If var is a global variable that isn't privatized\n+\t\t\t in outer contexts, we don't need to look up the\n+\t\t\t original address, it is always the address of the\n+\t\t\t global variable itself.  */\n+\t\t      if (!DECL_P (var)\n+\t\t\t  || omp_is_reference (var)\n+\t\t\t  || !is_global_var\n+\t\t\t\t(maybe_lookup_decl_in_outer_ctx (var, ctx)))\n+\t\t\t{\n+\t\t\t  task_reduction_needs_orig_p = true;\n+\t\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t\t    task_reduction_cntorig++;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else if (OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n \t\treduction_omp_orig_ref = true;\n \t      break;\n+\t    case OMP_CLAUSE__REDUCTEMP_:\n+\t      if (!is_taskreg_ctx (ctx))\n+\t\tcontinue;\n+\t      /* FALLTHRU */\n \t    case OMP_CLAUSE__LOOPTEMP_:\n-\t      /* Handle _looptemp_ clauses only on parallel/task.  */\n+\t      /* Handle _looptemp_/_reductemp_ clauses only on\n+\t\t parallel/task.  */\n \t      if (fd)\n \t\tcontinue;\n \t      break;\n@@ -3632,7 +3971,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\tlastprivate_firstprivate = true;\n \t      break;\n \t    case OMP_CLAUSE_ALIGNED:\n-\t      if (pass == 0)\n+\t      if (pass != 1)\n \t\tcontinue;\n \t      var = OMP_CLAUSE_DECL (c);\n \t      if (TREE_CODE (TREE_TYPE (var)) == POINTER_TYPE\n@@ -3673,8 +4012,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      continue;\n \t    }\n \n+\t  if (task_reduction_p != (pass >= 2))\n+\t    continue;\n+\n \t  new_var = var = OMP_CLAUSE_DECL (c);\n-\t  if (c_kind == OMP_CLAUSE_REDUCTION && TREE_CODE (var) == MEM_REF)\n+\t  if ((c_kind == OMP_CLAUSE_REDUCTION\n+\t       || c_kind == OMP_CLAUSE_IN_REDUCTION)\n+\t      && TREE_CODE (var) == MEM_REF)\n \t    {\n \t      var = TREE_OPERAND (var, 0);\n \t      if (TREE_CODE (var) == POINTER_PLUS_EXPR)\n@@ -3701,14 +4045,16 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\tcontinue;\n \t    }\n \t  /* C/C++ array section reductions.  */\n-\t  else if (c_kind == OMP_CLAUSE_REDUCTION\n+\t  else if ((c_kind == OMP_CLAUSE_REDUCTION\n+\t\t    || c_kind == OMP_CLAUSE_IN_REDUCTION)\n \t\t   && var != OMP_CLAUSE_DECL (c))\n \t    {\n \t      if (pass == 0)\n \t\tcontinue;\n \n \t      tree bias = TREE_OPERAND (OMP_CLAUSE_DECL (c), 1);\n \t      tree orig_var = TREE_OPERAND (OMP_CLAUSE_DECL (c), 0);\n+\n \t      if (TREE_CODE (orig_var) == POINTER_PLUS_EXPR)\n \t\t{\n \t\t  tree b = TREE_OPERAND (orig_var, 1);\n@@ -3729,6 +4075,47 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    }\n \t\t  orig_var = TREE_OPERAND (orig_var, 0);\n \t\t}\n+\t      if (pass == 2)\n+\t\t{\n+\t\t  tree out = maybe_lookup_decl_in_outer_ctx (var, ctx);\n+\t\t  if (is_global_var (out)\n+\t\t      && TREE_CODE (TREE_TYPE (out)) != POINTER_TYPE\n+\t\t      && (TREE_CODE (TREE_TYPE (out)) != REFERENCE_TYPE\n+\t\t\t  || (TREE_CODE (TREE_TYPE (TREE_TYPE (out)))\n+\t\t\t      != POINTER_TYPE)))\n+\t\t    x = var;\n+\t\t  else\n+\t\t    {\n+\t\t      bool by_ref = use_pointer_for_field (var, NULL);\n+\t\t      x = build_receiver_ref (var, by_ref, ctx);\n+\t\t      if (TREE_CODE (TREE_TYPE (var)) == REFERENCE_TYPE\n+\t\t\t  && (TREE_CODE (TREE_TYPE (TREE_TYPE (var)))\n+\t\t\t      == POINTER_TYPE))\n+\t\t\tx = build_fold_addr_expr (x);\n+\t\t    }\n+\t\t  if (TREE_CODE (orig_var) == INDIRECT_REF)\n+\t\t    x = build_simple_mem_ref (x);\n+\t\t  else if (TREE_CODE (orig_var) == ADDR_EXPR)\n+\t\t    {\n+\t\t      if (var == TREE_OPERAND (orig_var, 0))\n+\t\t\tx = build_fold_addr_expr (x);\n+\t\t    }\n+\t\t  bias = fold_convert (sizetype, bias);\n+\t\t  x = fold_convert (ptr_type_node, x);\n+\t\t  x = fold_build2_loc (clause_loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       TREE_TYPE (x), x, bias);\n+\t\t  unsigned cnt = task_reduction_cnt - 1;\n+\t\t  if (!task_reduction_needs_orig_p)\n+\t\t    cnt += (task_reduction_cntorig_full\n+\t\t\t    - task_reduction_cntorig);\n+\t\t  else\n+\t\t    cnt = task_reduction_cntorig - 1;\n+\t\t  tree r = build4 (ARRAY_REF, ptr_type_node, tskred_avar,\n+\t\t\t\t   size_int (cnt), NULL_TREE, NULL_TREE);\n+\t\t  gimplify_assign (r, x, ilist);\n+\t\t  continue;\n+\t\t}\n+\n \t      if (TREE_CODE (orig_var) == INDIRECT_REF\n \t\t  || TREE_CODE (orig_var) == ADDR_EXPR)\n \t\torig_var = TREE_OPERAND (orig_var, 0);\n@@ -3737,7 +4124,64 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n \t      tree v = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n \t      const char *name = get_name (orig_var);\n-\t      if (TREE_CONSTANT (v))\n+\t      if (pass == 3)\n+\t\t{\n+\t\t  tree xv = create_tmp_var (ptr_type_node);\n+\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t    {\n+\t\t      unsigned cnt = task_reduction_cnt - 1;\n+\t\t      if (!task_reduction_needs_orig_p)\n+\t\t\tcnt += (task_reduction_cntorig_full\n+\t\t\t\t- task_reduction_cntorig);\n+\t\t      else\n+\t\t\tcnt = task_reduction_cntorig - 1;\n+\t\t      x = build4 (ARRAY_REF, ptr_type_node, tskred_avar,\n+\t\t\t\t  size_int (cnt), NULL_TREE, NULL_TREE);\n+\n+\t\t      gimple *g = gimple_build_assign (xv, x);\n+\t\t      gimple_seq_add_stmt (ilist, g);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      unsigned int idx = *ctx->task_reduction_map->get (c);\n+\t\t      tree off;\n+\t\t      if (ctx->task_reductions[1 + idx])\n+\t\t\toff = fold_convert (sizetype,\n+\t\t\t\t\t    ctx->task_reductions[1 + idx]);\n+\t\t      else\n+\t\t\toff = task_reduction_read (ilist, tskred_temp, sizetype,\n+\t\t\t\t\t\t   7 + 3 * idx + 1);\n+\t\t      gimple *g = gimple_build_assign (xv, POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t       tskred_base, off);\n+\t\t      gimple_seq_add_stmt (ilist, g);\n+\t\t    }\n+\t\t  x = fold_convert (build_pointer_type (boolean_type_node),\n+\t\t\t\t    xv);\n+\t\t  if (TREE_CONSTANT (v))\n+\t\t    x = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (x), x,\n+\t\t\t\t     TYPE_SIZE_UNIT (type));\n+\t\t  else\n+\t\t    {\n+\t\t      tree t = maybe_lookup_decl (v, ctx);\n+\t\t      if (t)\n+\t\t\tv = t;\n+\t\t      else\n+\t\t\tv = maybe_lookup_decl_in_outer_ctx (v, ctx);\n+\t\t      gimplify_expr (&v, ilist, NULL, is_gimple_val,\n+\t\t\t\t     fb_rvalue);\n+\t\t      t = fold_build2_loc (clause_loc, PLUS_EXPR,\n+\t\t\t\t\t   TREE_TYPE (v), v,\n+\t\t\t\t\t   build_int_cst (TREE_TYPE (v), 1));\n+\t\t      t = fold_build2_loc (clause_loc, MULT_EXPR,\n+\t\t\t\t\t   TREE_TYPE (v), t,\n+\t\t\t\t\t   TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t\t      x = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (x), x, t);\n+\t\t    }\n+\t\t  cond = create_tmp_var (TREE_TYPE (x));\n+\t\t  gimplify_assign (cond, x, ilist);\n+\t\t  x = xv;\n+\t\t}\n+\t      else if (TREE_CONSTANT (v))\n \t\t{\n \t\t  x = create_tmp_var_raw (type, name);\n \t\t  gimple_add_tmp_var (x);\n@@ -3799,7 +4243,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      tree new_orig_var = lookup_decl (orig_var, ctx);\n \t\t      tree t = build_fold_indirect_ref (new_var);\n \t\t      DECL_IGNORED_P (new_var) = 0;\n-\t\t      TREE_THIS_NOTRAP (t);\n+\t\t      TREE_THIS_NOTRAP (t) = 1;\n \t\t      SET_DECL_VALUE_EXPR (new_orig_var, t);\n \t\t      DECL_HAS_VALUE_EXPR_P (new_orig_var) = 1;\n \t\t    }\n@@ -3824,44 +4268,101 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);\n \t\t  gimplify_assign (new_var, x, ilist);\n \t\t}\n-\t      tree y1 = create_tmp_var (ptype, NULL);\n+\t      /* GOMP_taskgroup_reduction_register memsets the whole\n+\t\t array to zero.  If the initializer is zero, we don't\n+\t\t need to initialize it again, just mark it as ever\n+\t\t used unconditionally, i.e. cond = true.  */\n+\t      if (cond\n+\t\t  && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == NULL_TREE\n+\t\t  && initializer_zerop (omp_reduction_init (c,\n+\t\t\t\t\t\t\t    TREE_TYPE (type))))\n+\t\t{\n+\t\t  gimple *g = gimple_build_assign (build_simple_mem_ref (cond),\n+\t\t\t\t\t\t   boolean_true_node);\n+\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t  continue;\n+\t\t}\n+\t      tree end = create_artificial_label (UNKNOWN_LOCATION);\n+\t      if (cond)\n+\t\t{\n+\t\t  gimple *g;\n+\t\t  if (!is_parallel_ctx (ctx))\n+\t\t    {\n+\t\t      tree condv = create_tmp_var (boolean_type_node);\n+\t\t      g = gimple_build_assign (condv,\n+\t\t\t\t\t       build_simple_mem_ref (cond));\n+\t\t      gimple_seq_add_stmt (ilist, g);\n+\t\t      tree lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t      g = gimple_build_cond (NE_EXPR, condv,\n+\t\t\t\t\t     boolean_false_node, end, lab1);\n+\t\t      gimple_seq_add_stmt (ilist, g);\n+\t\t      gimple_seq_add_stmt (ilist, gimple_build_label (lab1));\n+\t\t    }\n+\t\t  g = gimple_build_assign (build_simple_mem_ref (cond),\n+\t\t\t\t\t   boolean_true_node);\n+\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t}\n+\n+\t      tree y1 = create_tmp_var (ptype);\n \t      gimplify_assign (y1, y, ilist);\n \t      tree i2 = NULL_TREE, y2 = NULL_TREE;\n \t      tree body2 = NULL_TREE, end2 = NULL_TREE;\n \t      tree y3 = NULL_TREE, y4 = NULL_TREE;\n-\t      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) || is_simd)\n+\t      if (task_reduction_needs_orig_p)\n \t\t{\n-\t\t  y2 = create_tmp_var (ptype, NULL);\n-\t\t  gimplify_assign (y2, y, ilist);\n-\t\t  tree ref = build_outer_var_ref (var, ctx);\n-\t\t  /* For ref build_outer_var_ref already performs this.  */\n-\t\t  if (TREE_CODE (d) == INDIRECT_REF)\n-\t\t    gcc_assert (omp_is_reference (var));\n-\t\t  else if (TREE_CODE (d) == ADDR_EXPR)\n-\t\t    ref = build_fold_addr_expr (ref);\n-\t\t  else if (omp_is_reference (var))\n-\t\t    ref = build_fold_addr_expr (ref);\n-\t\t  ref = fold_convert_loc (clause_loc, ptype, ref);\n-\t\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n-\t\t      && OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n+\t\t  y3 = create_tmp_var (ptype);\n+\t\t  tree ref;\n+\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t    ref = build4 (ARRAY_REF, ptr_type_node, tskred_avar,\n+\t\t\t\t  size_int (task_reduction_cnt_full\n+\t\t\t\t\t    + task_reduction_cntorig - 1),\n+\t\t\t\t  NULL_TREE, NULL_TREE);\n+\t\t  else\n \t\t    {\n-\t\t      y3 = create_tmp_var (ptype, NULL);\n-\t\t      gimplify_assign (y3, unshare_expr (ref), ilist);\n+\t\t      unsigned int idx = *ctx->task_reduction_map->get (c);\n+\t\t      ref = task_reduction_read (ilist, tskred_temp, ptype,\n+\t\t\t\t\t\t 7 + 3 * idx);\n \t\t    }\n-\t\t  if (is_simd)\n+\t\t  gimplify_assign (y3, ref, ilist);\n+\t\t}\n+\t      else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) || is_simd)\n+\t\t{\n+\t\t  if (pass != 3)\n \t\t    {\n-\t\t      y4 = create_tmp_var (ptype, NULL);\n-\t\t      gimplify_assign (y4, ref, dlist);\n+\t\t      y2 = create_tmp_var (ptype);\n+\t\t      gimplify_assign (y2, y, ilist);\n+\t\t    }\n+\t\t  if (is_simd || OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n+\t\t    {\n+\t\t      tree ref = build_outer_var_ref (var, ctx);\n+\t\t      /* For ref build_outer_var_ref already performs this.  */\n+\t\t      if (TREE_CODE (d) == INDIRECT_REF)\n+\t\t\tgcc_assert (omp_is_reference (var));\n+\t\t      else if (TREE_CODE (d) == ADDR_EXPR)\n+\t\t\tref = build_fold_addr_expr (ref);\n+\t\t      else if (omp_is_reference (var))\n+\t\t\tref = build_fold_addr_expr (ref);\n+\t\t      ref = fold_convert_loc (clause_loc, ptype, ref);\n+\t\t      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n+\t\t\t  && OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n+\t\t\t{\n+\t\t\t  y3 = create_tmp_var (ptype);\n+\t\t\t  gimplify_assign (y3, unshare_expr (ref), ilist);\n+\t\t\t}\n+\t\t      if (is_simd)\n+\t\t\t{\n+\t\t\t  y4 = create_tmp_var (ptype);\n+\t\t\t  gimplify_assign (y4, ref, dlist);\n+\t\t\t}\n \t\t    }\n \t\t}\n-\t      tree i = create_tmp_var (TREE_TYPE (v), NULL);\n+\t      tree i = create_tmp_var (TREE_TYPE (v));\n \t      gimplify_assign (i, build_int_cst (TREE_TYPE (v), 0), ilist);\n \t      tree body = create_artificial_label (UNKNOWN_LOCATION);\n-\t      tree end = create_artificial_label (UNKNOWN_LOCATION);\n \t      gimple_seq_add_stmt (ilist, gimple_build_label (body));\n \t      if (y2)\n \t\t{\n-\t\t  i2 = create_tmp_var (TREE_TYPE (v), NULL);\n+\t\t  i2 = create_tmp_var (TREE_TYPE (v));\n \t\t  gimplify_assign (i2, build_int_cst (TREE_TYPE (v), 0), dlist);\n \t\t  body2 = create_artificial_label (UNKNOWN_LOCATION);\n \t\t  end2 = create_artificial_label (UNKNOWN_LOCATION);\n@@ -3904,14 +4405,17 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    }\n \t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n \t\t  DECL_HAS_VALUE_EXPR_P (decl_placeholder) = 0;\n-\t\t  x = lang_hooks.decls.omp_clause_dtor\n-\t\t\t\t\t(c, build_simple_mem_ref (y2));\n-\t\t  if (x)\n+\t\t  if (y2)\n \t\t    {\n-\t\t      gimple_seq tseq = NULL;\n-\t\t      dtor = x;\n-\t\t      gimplify_stmt (&dtor, &tseq);\n-\t\t      gimple_seq_add_seq (dlist, tseq);\n+\t\t      x = lang_hooks.decls.omp_clause_dtor\n+\t\t\t\t\t\t(c, build_simple_mem_ref (y2));\n+\t\t      if (x)\n+\t\t\t{\n+\t\t\t  gimple_seq tseq = NULL;\n+\t\t\t  dtor = x;\n+\t\t\t  gimplify_stmt (&dtor, &tseq);\n+\t\t\t  gimple_seq_add_seq (dlist, tseq);\n+\t\t\t}\n \t\t    }\n \t\t}\n \t      else\n@@ -3970,6 +4474,78 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t}\n \t      continue;\n \t    }\n+\t  else if (pass == 2)\n+\t    {\n+\t      if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, ctx)))\n+\t\tx = var;\n+\t      else\n+\t\t{\n+\t\t  bool by_ref = use_pointer_for_field (var, ctx);\n+\t\t  x = build_receiver_ref (var, by_ref, ctx);\n+\t\t}\n+\t      if (!omp_is_reference (var))\n+\t\tx = build_fold_addr_expr (x);\n+\t      x = fold_convert (ptr_type_node, x);\n+\t      unsigned cnt = task_reduction_cnt - 1;\n+\t      if (!task_reduction_needs_orig_p)\n+\t\tcnt += task_reduction_cntorig_full - task_reduction_cntorig;\n+\t      else\n+\t\tcnt = task_reduction_cntorig - 1;\n+\t      tree r = build4 (ARRAY_REF, ptr_type_node, tskred_avar,\n+\t\t\t       size_int (cnt), NULL_TREE, NULL_TREE);\n+\t      gimplify_assign (r, x, ilist);\n+\t      continue;\n+\t    }\n+\t  else if (pass == 3)\n+\t    {\n+\t      tree type = TREE_TYPE (new_var);\n+\t      if (!omp_is_reference (var))\n+\t\ttype = build_pointer_type (type);\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t{\n+\t\t  unsigned cnt = task_reduction_cnt - 1;\n+\t\t  if (!task_reduction_needs_orig_p)\n+\t\t    cnt += (task_reduction_cntorig_full\n+\t\t\t    - task_reduction_cntorig);\n+\t\t  else\n+\t\t    cnt = task_reduction_cntorig - 1;\n+\t\t  x = build4 (ARRAY_REF, ptr_type_node, tskred_avar,\n+\t\t\t      size_int (cnt), NULL_TREE, NULL_TREE);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unsigned int idx = *ctx->task_reduction_map->get (c);\n+\t\t  tree off;\n+\t\t  if (ctx->task_reductions[1 + idx])\n+\t\t    off = fold_convert (sizetype,\n+\t\t\t\t\tctx->task_reductions[1 + idx]);\n+\t\t  else\n+\t\t    off = task_reduction_read (ilist, tskred_temp, sizetype,\n+\t\t\t\t\t       7 + 3 * idx + 1);\n+\t\t  x = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t\t   tskred_base, off);\n+\t\t}\n+\t      x = fold_convert (type, x);\n+\t      tree t;\n+\t      if (omp_is_reference (var))\n+\t\t{\n+\t\t  gimplify_assign (new_var, x, ilist);\n+\t\t  t = new_var;\n+\t\t  new_var = build_simple_mem_ref (new_var);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  t = create_tmp_var (type);\n+\t\t  gimplify_assign (t, x, ilist);\n+\t\t  SET_DECL_VALUE_EXPR (new_var, build_simple_mem_ref (t));\n+\t\t  DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n+\t\t}\n+\t      t = fold_convert (build_pointer_type (boolean_type_node), t);\n+\t      t = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t,\n+\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t      cond = create_tmp_var (TREE_TYPE (t));\n+\t      gimplify_assign (cond, t, ilist);\n+\t    }\n \t  else if (is_variable_sized (var))\n \t    {\n \t      /* For variable sized types, we need to allocate the\n@@ -4003,7 +4579,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  gimplify_assign (ptr, x, ilist);\n \t\t}\n \t    }\n-\t  else if (omp_is_reference (var))\n+\t  else if (omp_is_reference (var)\n+\t\t   && (c_kind != OMP_CLAUSE_FIRSTPRIVATE\n+\t\t       || !OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE (c)))\n \t    {\n \t      /* For references that are being privatized for Fortran,\n \t\t allocate new backing storage for the new pointer\n@@ -4053,7 +4631,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t      new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n \t    }\n-\t  else if (c_kind == OMP_CLAUSE_REDUCTION\n+\t  else if ((c_kind == OMP_CLAUSE_REDUCTION\n+\t\t    || c_kind == OMP_CLAUSE_IN_REDUCTION)\n \t\t   && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t    {\n \t      if (pass == 0)\n@@ -4065,8 +4644,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  switch (OMP_CLAUSE_CODE (c))\n \t    {\n \t    case OMP_CLAUSE_SHARED:\n-\t      /* Ignore shared directives in teams construct.  */\n-\t      if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n+\t      /* Ignore shared directives in teams construct inside\n+\t\t target construct.  */\n+\t      if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS\n+\t\t  && !is_host_teams_ctx (ctx))\n \t\tcontinue;\n \t      /* Shared global vars are just accessed directly.  */\n \t      if (is_global_var (new_var))\n@@ -4170,7 +4751,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    case OMP_CLAUSE_FIRSTPRIVATE:\n \t      if (is_task_ctx (ctx))\n \t\t{\n-\t\t  if (omp_is_reference (var) || is_variable_sized (var))\n+\t\t  if ((omp_is_reference (var)\n+\t\t       && !OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE (c))\n+\t\t      || is_variable_sized (var))\n \t\t    goto do_dtor;\n \t\t  else if (is_global_var (maybe_lookup_decl_in_outer_ctx (var,\n \t\t\t\t\t\t\t\t\t  ctx))\n@@ -4182,6 +4765,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      goto do_dtor;\n \t\t    }\n \t\t}\n+\t      if (OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE (c)\n+\t\t  && omp_is_reference (var))\n+\t\t{\n+\t\t  x = build_outer_var_ref (var, ctx);\n+\t\t  gcc_assert (TREE_CODE (x) == MEM_REF\n+\t\t\t      && integer_zerop (TREE_OPERAND (x, 1)));\n+\t\t  x = TREE_OPERAND (x, 0);\n+\t\t  x = lang_hooks.decls.omp_clause_copy_ctor\n+\t\t\t\t\t\t(c, unshare_expr (new_var), x);\n+\t\t  gimplify_and_add (x, ilist);\n+\t\t  goto do_dtor;\n+\t\t}\n \t    do_firstprivate:\n \t      x = build_outer_var_ref (var, ctx);\n \t      if (is_simd)\n@@ -4273,6 +4868,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      goto do_dtor;\n \n \t    case OMP_CLAUSE__LOOPTEMP_:\n+\t    case OMP_CLAUSE__REDUCTEMP_:\n \t      gcc_assert (is_taskreg_ctx (ctx));\n \t      x = build_outer_var_ref (var, ctx);\n \t      x = build2 (MODIFY_EXPR, TREE_TYPE (new_var), new_var, x);\n@@ -4288,6 +4884,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      break;\n \n \t    case OMP_CLAUSE_REDUCTION:\n+\t    case OMP_CLAUSE_IN_REDUCTION:\n \t      /* OpenACC reductions are initialized using the\n \t\t GOACC_REDUCTION internal function.  */\n \t      if (is_gimple_omp_oacc (ctx->stmt))\n@@ -4296,12 +4893,40 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t{\n \t\t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n \t\t  gimple *tseq;\n-\t\t  x = build_outer_var_ref (var, ctx);\n+\t\t  tree ptype = TREE_TYPE (placeholder);\n+\t\t  if (cond)\n+\t\t    {\n+\t\t      x = error_mark_node;\n+\t\t      if (OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c)\n+\t\t\t  && !task_reduction_needs_orig_p)\n+\t\t\tx = var;\n+\t\t      else if (OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c))\n+\t\t\t{\n+\t\t\t  tree pptype = build_pointer_type (ptype);\n+\t\t\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\t\t    x = build4 (ARRAY_REF, ptr_type_node, tskred_avar,\n+\t\t\t\t\tsize_int (task_reduction_cnt_full\n+\t\t\t\t\t\t  + task_reduction_cntorig - 1),\n+\t\t\t\t\tNULL_TREE, NULL_TREE);\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      unsigned int idx\n+\t\t\t\t= *ctx->task_reduction_map->get (c);\n+\t\t\t      x = task_reduction_read (ilist, tskred_temp,\n+\t\t\t\t\t\t       pptype, 7 + 3 * idx);\n+\t\t\t    }\n+\t\t\t  x = fold_convert (pptype, x);\n+\t\t\t  x = build_simple_mem_ref (x);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      x = build_outer_var_ref (var, ctx);\n \n-\t\t  if (omp_is_reference (var)\n-\t\t      && !useless_type_conversion_p (TREE_TYPE (placeholder),\n-\t\t\t\t\t\t     TREE_TYPE (x)))\n-\t\t    x = build_fold_addr_expr_loc (clause_loc, x);\n+\t\t      if (omp_is_reference (var)\n+\t\t\t  && !useless_type_conversion_p (ptype, TREE_TYPE (x)))\n+\t\t\tx = build_fold_addr_expr_loc (clause_loc, x);\n+\t\t    }\n \t\t  SET_DECL_VALUE_EXPR (placeholder, x);\n \t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n \t\t  tree new_vard = new_var;\n@@ -4365,9 +4990,35 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t     initialization now.  */\n \t\t  else if (omp_is_reference (var) && is_simd)\n \t\t    handle_simd_reference (clause_loc, new_vard, ilist);\n+\n+\t\t  tree lab2 = NULL_TREE;\n+\t\t  if (cond)\n+\t\t    {\n+\t\t      gimple *g;\n+\t\t      if (!is_parallel_ctx (ctx))\n+\t\t\t{\n+\t\t\t  tree condv = create_tmp_var (boolean_type_node);\n+\t\t\t  tree m = build_simple_mem_ref (cond);\n+\t\t\t  g = gimple_build_assign (condv, m);\n+\t\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t\t  tree lab1\n+\t\t\t    = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t\t  lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t\t  g = gimple_build_cond (NE_EXPR, condv,\n+\t\t\t\t\t\t boolean_false_node,\n+\t\t\t\t\t\t lab2, lab1);\n+\t\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t\t  gimple_seq_add_stmt (ilist,\n+\t\t\t\t\t       gimple_build_label (lab1));\n+\t\t\t}\n+\t\t      g = gimple_build_assign (build_simple_mem_ref (cond),\n+\t\t\t\t\t       boolean_true_node);\n+\t\t      gimple_seq_add_stmt (ilist, g);\n+\t\t    }\n \t\t  x = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t(c, unshare_expr (new_var),\n-\t\t\t\t build_outer_var_ref (var, ctx));\n+\t\t\t\t cond ? NULL_TREE\n+\t\t\t\t : build_outer_var_ref (var, ctx));\n \t\t  if (x)\n \t\t    gimplify_and_add (x, ilist);\n \t\t  if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n@@ -4385,6 +5036,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n \t\t    }\n \t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t\t  if (cond)\n+\t\t    {\n+\t\t      if (lab2)\n+\t\t\tgimple_seq_add_stmt (ilist, gimple_build_label (lab2));\n+\t\t      break;\n+\t\t    }\n \t\t  goto do_dtor;\n \t\t}\n \t      else\n@@ -4393,6 +5050,49 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  gcc_assert (TREE_CODE (TREE_TYPE (new_var)) != ARRAY_TYPE);\n \t\t  enum tree_code code = OMP_CLAUSE_REDUCTION_CODE (c);\n \n+\t\t  if (cond)\n+\t\t    {\n+\t\t      gimple *g;\n+\t\t      tree lab2 = NULL_TREE;\n+\t\t      /* GOMP_taskgroup_reduction_register memsets the whole\n+\t\t\t array to zero.  If the initializer is zero, we don't\n+\t\t\t need to initialize it again, just mark it as ever\n+\t\t\t used unconditionally, i.e. cond = true.  */\n+\t\t      if (initializer_zerop (x))\n+\t\t\t{\n+\t\t\t  g = gimple_build_assign (build_simple_mem_ref (cond),\n+\t\t\t\t\t\t   boolean_true_node);\n+\t\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t\t  break;\n+\t\t\t}\n+\n+\t\t      /* Otherwise, emit\n+\t\t\t if (!cond) { cond = true; new_var = x; }  */\n+\t\t      if (!is_parallel_ctx (ctx))\n+\t\t\t{\n+\t\t\t  tree condv = create_tmp_var (boolean_type_node);\n+\t\t\t  tree m = build_simple_mem_ref (cond);\n+\t\t\t  g = gimple_build_assign (condv, m);\n+\t\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t\t  tree lab1\n+\t\t\t    = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t\t  lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t\t  g = gimple_build_cond (NE_EXPR, condv,\n+\t\t\t\t\t\t boolean_false_node,\n+\t\t\t\t\t\t lab2, lab1);\n+\t\t\t  gimple_seq_add_stmt (ilist, g);\n+\t\t\t  gimple_seq_add_stmt (ilist,\n+\t\t\t\t\t       gimple_build_label (lab1));\n+\t\t\t}\n+\t\t      g = gimple_build_assign (build_simple_mem_ref (cond),\n+\t\t\t\t\t       boolean_true_node);\n+\t\t      gimple_seq_add_stmt (ilist, g);\n+\t\t      gimplify_assign (new_var, x, ilist);\n+\t\t      if (lab2)\n+\t\t\tgimple_seq_add_stmt (ilist, gimple_build_label (lab2));\n+\t\t      break;\n+\t\t    }\n+\n \t\t  /* reduction(-:var) sums up the partial results, so it\n \t\t     acts identically to reduction(+:var).  */\n \t\t  if (code == MINUS_EXPR)\n@@ -4456,6 +5156,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    }\n \t}\n     }\n+  if (tskred_avar)\n+    {\n+      tree clobber = build_constructor (TREE_TYPE (tskred_avar), NULL);\n+      TREE_THIS_VOLATILE (clobber) = 1;\n+      gimple_seq_add_stmt (ilist, gimple_build_assign (tskred_avar, clobber));\n+    }\n \n   if (known_eq (sctx.max_vf, 1U))\n     sctx.is_simt = false;\n@@ -4587,8 +5293,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n     {\n       /* Don't add any barrier for #pragma omp simd or\n \t #pragma omp distribute.  */\n-      if (gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n-\t  || gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_FOR)\n+      if (!is_task_ctx (ctx)\n+\t  && (gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n+\t      || gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_FOR))\n \tgimple_seq_add_stmt (ilist, omp_build_barrier (NULL_TREE));\n     }\n \n@@ -5078,7 +5785,8 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n   /* First see if there is exactly one reduction clause.  Use OMP_ATOMIC\n      update in that case, otherwise use a lock.  */\n   for (c = clauses; c && count < 2; c = OMP_CLAUSE_CHAIN (c))\n-    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t&& !OMP_CLAUSE_REDUCTION_TASK (c))\n       {\n \tif (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n \t    || TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF)\n@@ -5099,7 +5807,8 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n       enum tree_code code;\n       location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n-      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t  || OMP_CLAUSE_REDUCTION_TASK (c))\n \tcontinue;\n \n       enum omp_clause_code ccode = OMP_CLAUSE_REDUCTION;\n@@ -5150,6 +5859,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t  ref = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (addr)), addr);\n \t  x = fold_build2_loc (clause_loc, code, TREE_TYPE (ref), ref, new_var);\n \t  x = build2 (OMP_ATOMIC, void_type_node, addr, x);\n+\t  OMP_ATOMIC_MEMORY_ORDER (x) = OMP_MEMORY_ORDER_RELAXED;\n \t  gimplify_and_add (x, stmt_seqp);\n \t  return;\n \t}\n@@ -5158,7 +5868,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t  tree d = OMP_CLAUSE_DECL (c);\n \t  tree type = TREE_TYPE (d);\n \t  tree v = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t  tree i = create_tmp_var (TREE_TYPE (v), NULL);\n+\t  tree i = create_tmp_var (TREE_TYPE (v));\n \t  tree ptype = build_pointer_type (TREE_TYPE (type));\n \t  tree bias = TREE_OPERAND (d, 1);\n \t  d = TREE_OPERAND (d, 0);\n@@ -5222,10 +5932,10 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t    }\n \t  new_var = fold_convert_loc (clause_loc, ptype, new_var);\n \t  ref = fold_convert_loc (clause_loc, ptype, ref);\n-\t  tree m = create_tmp_var (ptype, NULL);\n+\t  tree m = create_tmp_var (ptype);\n \t  gimplify_assign (m, new_var, stmt_seqp);\n \t  new_var = m;\n-\t  m = create_tmp_var (ptype, NULL);\n+\t  m = create_tmp_var (ptype);\n \t  gimplify_assign (m, ref, stmt_seqp);\n \t  ref = m;\n \t  gimplify_assign (i, build_int_cst (TREE_TYPE (v), 0), stmt_seqp);\n@@ -5387,7 +6097,12 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_LASTPRIVATE:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n+\t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n+\t  if (is_task_ctx (ctx) || OMP_CLAUSE_REDUCTION_TASK (c))\n+\t    continue;\n \t  break;\n \tcase OMP_CLAUSE_SHARED:\n \t  if (OMP_CLAUSE_SHARED_FIRSTPRIVATE (c))\n@@ -5405,7 +6120,8 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \t}\n \n       val = OMP_CLAUSE_DECL (c);\n-      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION)\n \t  && TREE_CODE (val) == MEM_REF)\n \t{\n \t  val = TREE_OPERAND (val, 0);\n@@ -5429,7 +6145,13 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n       var = lookup_decl_in_outer_ctx (val, ctx_for_o);\n \n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_COPYIN\n-\t  && is_global_var (var))\n+\t  && is_global_var (var)\n+\t  && (val == OMP_CLAUSE_DECL (c)\n+\t      || !is_task_ctx (ctx)\n+\t      || (TREE_CODE (TREE_TYPE (val)) != POINTER_TYPE\n+\t\t  && (TREE_CODE (TREE_TYPE (val)) != REFERENCE_TYPE\n+\t\t      || (TREE_CODE (TREE_TYPE (TREE_TYPE (val)))\n+\t\t\t  != POINTER_TYPE)))))\n \tcontinue;\n \n       t = omp_member_access_dummy_var (var);\n@@ -5457,7 +6179,8 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \t  continue;\n \t}\n \n-      if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+      if (((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n+\t    && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION)\n \t   || val == OMP_CLAUSE_DECL (c))\n \t  && is_variable_sized (val))\n \tcontinue;\n@@ -5476,6 +6199,7 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n \t  do_in = true;\n \t  break;\n \n@@ -5495,9 +6219,15 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n \t  do_in = true;\n \t  if (val == OMP_CLAUSE_DECL (c))\n-\t    do_out = !(by_ref || omp_is_reference (val));\n+\t    {\n+\t      if (is_task_ctx (ctx))\n+\t\tby_ref = use_pointer_for_field (val, ctx);\n+\t      else\n+\t\tdo_out = !(by_ref || omp_is_reference (val));\n+\t    }\n \t  else\n \t    by_ref = TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE;\n \t  break;\n@@ -5802,30 +6532,55 @@ maybe_catch_exception (gimple_seq body)\n    cancellation in the implicit barrier.  */\n \n static void\n-maybe_add_implicit_barrier_cancel (omp_context *ctx, gimple_seq *body)\n+maybe_add_implicit_barrier_cancel (omp_context *ctx, gimple *omp_return,\n+\t\t\t\t   gimple_seq *body)\n {\n-  gimple *omp_return = gimple_seq_last_stmt (*body);\n   gcc_assert (gimple_code (omp_return) == GIMPLE_OMP_RETURN);\n   if (gimple_omp_return_nowait_p (omp_return))\n     return;\n-  if (ctx->outer\n-      && gimple_code (ctx->outer->stmt) == GIMPLE_OMP_PARALLEL\n-      && ctx->outer->cancellable)\n-    {\n-      tree fndecl = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n-      tree c_bool_type = TREE_TYPE (TREE_TYPE (fndecl));\n-      tree lhs = create_tmp_var (c_bool_type);\n-      gimple_omp_return_set_lhs (omp_return, lhs);\n-      tree fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n-      gimple *g = gimple_build_cond (NE_EXPR, lhs,\n-\t\t\t\t    fold_convert (c_bool_type,\n-\t\t\t\t\t\t  boolean_false_node),\n-\t\t\t\t    ctx->outer->cancel_label, fallthru_label);\n-      gimple_seq_add_stmt (body, g);\n-      gimple_seq_add_stmt (body, gimple_build_label (fallthru_label));\n+  for (omp_context *outer = ctx->outer; outer; outer = outer->outer)\n+    if (gimple_code (outer->stmt) == GIMPLE_OMP_PARALLEL\n+\t&& outer->cancellable)\n+      {\n+\ttree fndecl = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n+\ttree c_bool_type = TREE_TYPE (TREE_TYPE (fndecl));\n+\ttree lhs = create_tmp_var (c_bool_type);\n+\tgimple_omp_return_set_lhs (omp_return, lhs);\n+\ttree fallthru_label = create_artificial_label (UNKNOWN_LOCATION);\n+\tgimple *g = gimple_build_cond (NE_EXPR, lhs,\n+\t\t\t\t       fold_convert (c_bool_type,\n+\t\t\t\t\t\t     boolean_false_node),\n+\t\t\t\t       outer->cancel_label, fallthru_label);\n+\tgimple_seq_add_stmt (body, g);\n+\tgimple_seq_add_stmt (body, gimple_build_label (fallthru_label));\n+      }\n+    else if (gimple_code (outer->stmt) != GIMPLE_OMP_TASKGROUP)\n+      return;\n+}\n+\n+/* Find the first task_reduction or reduction clause or return NULL\n+   if there are none.  */\n+\n+static inline tree\n+omp_task_reductions_find_first (tree clauses, enum tree_code code,\n+\t\t\t\tenum omp_clause_code ccode)\n+{\n+  while (1)\n+    {\n+      clauses = omp_find_clause (clauses, ccode);\n+      if (clauses == NULL_TREE)\n+\treturn NULL_TREE;\n+      if (ccode != OMP_CLAUSE_REDUCTION\n+\t  || code == OMP_TASKLOOP\n+\t  || OMP_CLAUSE_REDUCTION_TASK (clauses))\n+\treturn clauses;\n+      clauses = OMP_CLAUSE_CHAIN (clauses);\n     }\n }\n \n+static void lower_omp_task_reductions (omp_context *, enum tree_code, tree,\n+\t\t\t\t       gimple_seq *, gimple_seq *);\n+\n /* Lower the OpenMP sections directive in the current statement in GSI_P.\n    CTX is the enclosing OMP context for the current statement.  */\n \n@@ -5837,14 +6592,35 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gomp_sections *stmt;\n   gimple *t;\n   gbind *new_stmt, *bind;\n-  gimple_seq ilist, dlist, olist, new_body;\n+  gimple_seq ilist, dlist, olist, tred_dlist = NULL, new_body;\n \n   stmt = as_a <gomp_sections *> (gsi_stmt (*gsi_p));\n \n   push_gimplify_context ();\n \n   dlist = NULL;\n   ilist = NULL;\n+\n+  tree rclauses\n+    = omp_task_reductions_find_first (gimple_omp_sections_clauses (stmt),\n+\t\t\t\t      OMP_SECTIONS, OMP_CLAUSE_REDUCTION);\n+  tree rtmp = NULL_TREE;\n+  if (rclauses)\n+    {\n+      tree type = build_pointer_type (pointer_sized_int_node);\n+      tree temp = create_tmp_var (type);\n+      tree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__REDUCTEMP_);\n+      OMP_CLAUSE_DECL (c) = temp;\n+      OMP_CLAUSE_CHAIN (c) = gimple_omp_sections_clauses (stmt);\n+      gimple_omp_sections_set_clauses (stmt, c);\n+      lower_omp_task_reductions (ctx, OMP_SECTIONS,\n+\t\t\t\t gimple_omp_sections_clauses (stmt),\n+\t\t\t\t &ilist, &tred_dlist);\n+      rclauses = c;\n+      rtmp = make_ssa_name (type);\n+      gimple_seq_add_stmt (&ilist, gimple_build_assign (rtmp, temp));\n+    }\n+\n   lower_rec_input_clauses (gimple_omp_sections_clauses (stmt),\n       \t\t\t   &ilist, &dlist, ctx, NULL);\n \n@@ -5916,7 +6692,11 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t OMP_CLAUSE_NOWAIT) != NULL_TREE;\n   t = gimple_build_omp_return (nowait);\n   gimple_seq_add_stmt (&new_body, t);\n-  maybe_add_implicit_barrier_cancel (ctx, &new_body);\n+  gimple_seq_add_seq (&new_body, tred_dlist);\n+  maybe_add_implicit_barrier_cancel (ctx, t, &new_body);\n+\n+  if (rclauses)\n+    OMP_CLAUSE_DECL (rclauses) = rtmp;\n \n   gimple_bind_set_body (new_stmt, new_body);\n }\n@@ -6078,7 +6858,7 @@ lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t OMP_CLAUSE_NOWAIT) != NULL_TREE;\n   gimple *g = gimple_build_omp_return (nowait);\n   gimple_seq_add_stmt (&bind_body_tail, g);\n-  maybe_add_implicit_barrier_cancel (ctx, &bind_body_tail);\n+  maybe_add_implicit_barrier_cancel (ctx, g, &bind_body_tail);\n   if (ctx->record_type)\n     {\n       gimple_stmt_iterator gsi = gsi_start (bind_body_tail);\n@@ -6140,6 +6920,604 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   BLOCK_VARS (block) = ctx->block_vars;\n }\n \n+/* Helper function for lower_omp_task_reductions.  For a specific PASS\n+   find out the current clause it should be processed, or return false\n+   if all have been processed already.  */\n+\n+static inline bool\n+omp_task_reduction_iterate (int pass, enum tree_code code,\n+\t\t\t    enum omp_clause_code ccode, tree *c, tree *decl,\n+\t\t\t    tree *type, tree *next)\n+{\n+  for (; *c; *c = omp_find_clause (OMP_CLAUSE_CHAIN (*c), ccode))\n+    {\n+      if (ccode == OMP_CLAUSE_REDUCTION\n+\t  && code != OMP_TASKLOOP\n+\t  && !OMP_CLAUSE_REDUCTION_TASK (*c))\n+\tcontinue;\n+      *decl = OMP_CLAUSE_DECL (*c);\n+      *type = TREE_TYPE (*decl);\n+      if (TREE_CODE (*decl) == MEM_REF)\n+\t{\n+\t  if (pass != 1)\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  if (omp_is_reference (*decl))\n+\t    *type = TREE_TYPE (*type);\n+\t  if (pass != (!TREE_CONSTANT (TYPE_SIZE_UNIT (*type))))\n+\t    continue;\n+\t}\n+      *next = omp_find_clause (OMP_CLAUSE_CHAIN (*c), ccode);\n+      return true;\n+    }\n+  *decl = NULL_TREE;\n+  *type = NULL_TREE;\n+  *next = NULL_TREE;\n+  return false;\n+}\n+\n+/* Lower task_reduction and reduction clauses (the latter unless CODE is\n+   OMP_TASKGROUP only with task modifier).  Register mapping of those in\n+   START sequence and reducing them and unregister them in the END sequence.  */\n+\n+static void\n+lower_omp_task_reductions (omp_context *ctx, enum tree_code code, tree clauses,\n+\t\t\t   gimple_seq *start, gimple_seq *end)\n+{\n+  enum omp_clause_code ccode\n+    = (code == OMP_TASKGROUP\n+       ? OMP_CLAUSE_TASK_REDUCTION : OMP_CLAUSE_REDUCTION);\n+  tree cancellable = NULL_TREE;\n+  clauses = omp_task_reductions_find_first (clauses, code, ccode);\n+  if (clauses == NULL_TREE)\n+    return;\n+  if (code == OMP_FOR || code == OMP_SECTIONS)\n+    {\n+      for (omp_context *outer = ctx->outer; outer; outer = outer->outer)\n+\tif (gimple_code (outer->stmt) == GIMPLE_OMP_PARALLEL\n+\t    && outer->cancellable)\n+\t  {\n+\t    cancellable = error_mark_node;\n+\t    break;\n+\t  }\n+\telse if (gimple_code (outer->stmt) != GIMPLE_OMP_TASKGROUP)\n+\t  break;\n+    }\n+  tree record_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  tree *last = &TYPE_FIELDS (record_type);\n+  unsigned cnt = 0;\n+  if (cancellable)\n+    {\n+      tree field = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t\t       ptr_type_node);\n+      tree ifield = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t\t\tinteger_type_node);\n+      *last = field;\n+      DECL_CHAIN (field) = ifield;\n+      last = &DECL_CHAIN (ifield);\n+    }\n+  for (int pass = 0; pass < 2; pass++)\n+    {\n+      tree decl, type, next;\n+      for (tree c = clauses;\n+\t   omp_task_reduction_iterate (pass, code, ccode,\n+\t\t\t\t       &c, &decl, &type, &next); c = next)\n+\t{\n+\t  ++cnt;\n+\t  tree new_type = type;\n+\t  if (ctx->outer)\n+\t    new_type = remap_type (type, &ctx->outer->cb);\n+\t  tree field\n+\t    = build_decl (OMP_CLAUSE_LOCATION (c), FIELD_DECL,\n+\t\t\t  DECL_P (decl) ? DECL_NAME (decl) : NULL_TREE,\n+\t\t\t  new_type);\n+\t  if (DECL_P (decl) && type == TREE_TYPE (decl))\n+\t    {\n+\t      SET_DECL_ALIGN (field, DECL_ALIGN (decl));\n+\t      DECL_USER_ALIGN (field) = DECL_USER_ALIGN (decl);\n+\t      TREE_THIS_VOLATILE (field) = TREE_THIS_VOLATILE (decl);\n+\t    }\n+\t  else\n+\t    SET_DECL_ALIGN (field, TYPE_ALIGN (type));\n+\t  DECL_CONTEXT (field) = record_type;\n+\t  *last = field;\n+\t  last = &DECL_CHAIN (field);\n+\t  tree bfield\n+\t    = build_decl (OMP_CLAUSE_LOCATION (c), FIELD_DECL, NULL_TREE,\n+\t\t\t  boolean_type_node);\n+\t  DECL_CONTEXT (bfield) = record_type;\n+\t  *last = bfield;\n+\t  last = &DECL_CHAIN (bfield);\n+\t}\n+    }\n+  *last = NULL_TREE;\n+  layout_type (record_type);\n+\n+  /* Build up an array which registers with the runtime all the reductions\n+     and deregisters them at the end.  Format documented in libgomp/task.c.  */\n+  tree atype = build_array_type_nelts (pointer_sized_int_node, 7 + cnt * 3);\n+  tree avar = create_tmp_var_raw (atype);\n+  gimple_add_tmp_var (avar);\n+  TREE_ADDRESSABLE (avar) = 1;\n+  tree r = build4 (ARRAY_REF, pointer_sized_int_node, avar, size_zero_node,\n+\t\t   NULL_TREE, NULL_TREE);\n+  tree t = build_int_cst (pointer_sized_int_node, cnt);\n+  gimple_seq_add_stmt (start, gimple_build_assign (r, t));\n+  gimple_seq seq = NULL;\n+  tree sz = fold_convert (pointer_sized_int_node,\n+\t\t\t  TYPE_SIZE_UNIT (record_type));\n+  int cachesz = 64;\n+  sz = fold_build2 (PLUS_EXPR, pointer_sized_int_node, sz,\n+\t\t    build_int_cst (pointer_sized_int_node, cachesz - 1));\n+  sz = fold_build2 (BIT_AND_EXPR, pointer_sized_int_node, sz,\n+\t\t    build_int_cst (pointer_sized_int_node, ~(cachesz - 1)));\n+  ctx->task_reductions.create (1 + cnt);\n+  ctx->task_reduction_map = new hash_map<tree, unsigned>;\n+  ctx->task_reductions.quick_push (TREE_CODE (sz) == INTEGER_CST\n+\t\t\t\t   ? sz : NULL_TREE);\n+  sz = force_gimple_operand (sz, &seq, true, NULL_TREE);\n+  gimple_seq_add_seq (start, seq);\n+  r = build4 (ARRAY_REF, pointer_sized_int_node, avar, size_one_node,\n+\t      NULL_TREE, NULL_TREE);\n+  gimple_seq_add_stmt (start, gimple_build_assign (r, sz));\n+  r = build4 (ARRAY_REF, pointer_sized_int_node, avar, size_int (2),\n+\t      NULL_TREE, NULL_TREE);\n+  t = build_int_cst (pointer_sized_int_node,\n+\t\t     MAX (TYPE_ALIGN_UNIT (record_type), (unsigned) cachesz));\n+  gimple_seq_add_stmt (start, gimple_build_assign (r, t));\n+  r = build4 (ARRAY_REF, pointer_sized_int_node, avar, size_int (3),\n+\t      NULL_TREE, NULL_TREE);\n+  t = build_int_cst (pointer_sized_int_node, -1);\n+  gimple_seq_add_stmt (start, gimple_build_assign (r, t));\n+  r = build4 (ARRAY_REF, pointer_sized_int_node, avar, size_int (4),\n+\t      NULL_TREE, NULL_TREE);\n+  t = build_int_cst (pointer_sized_int_node, 0);\n+  gimple_seq_add_stmt (start, gimple_build_assign (r, t));\n+\n+  /* In end, build a loop that iterates from 0 to < omp_get_num_threads ()\n+     and for each task reduction checks a bool right after the private variable\n+     within that thread's chunk; if the bool is clear, it hasn't been\n+     initialized and thus isn't going to be reduced nor destructed, otherwise\n+     reduce and destruct it.  */\n+  tree idx = create_tmp_var (size_type_node);\n+  gimple_seq_add_stmt (end, gimple_build_assign (idx, size_zero_node));\n+  tree num_thr_sz = create_tmp_var (size_type_node);\n+  tree lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab3 = NULL_TREE;\n+  gimple *g;\n+  if (code == OMP_FOR || code == OMP_SECTIONS)\n+    {\n+      /* For worksharing constructs, only perform it in the master thread,\n+\t with the exception of cancelled implicit barriers - then only handle\n+\t the current thread.  */\n+      tree lab4 = create_artificial_label (UNKNOWN_LOCATION);\n+      t = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+      tree thr_num = create_tmp_var (integer_type_node);\n+      g = gimple_build_call (t, 0);\n+      gimple_call_set_lhs (g, thr_num);\n+      gimple_seq_add_stmt (end, g);\n+      if (cancellable)\n+\t{\n+\t  tree c;\n+\t  tree lab5 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  tree lab6 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  lab3 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  if (code == OMP_FOR)\n+\t    c = gimple_omp_for_clauses (ctx->stmt);\n+\t  else if (code == OMP_SECTIONS)\n+\t    c = gimple_omp_sections_clauses (ctx->stmt);\n+\t  c = OMP_CLAUSE_DECL (omp_find_clause (c, OMP_CLAUSE__REDUCTEMP_));\n+\t  cancellable = c;\n+\t  g = gimple_build_cond (NE_EXPR, c, build_zero_cst (TREE_TYPE (c)),\n+\t\t\t\t lab5, lab6);\n+\t  gimple_seq_add_stmt (end, g);\n+\t  gimple_seq_add_stmt (end, gimple_build_label (lab5));\n+\t  g = gimple_build_assign (idx, NOP_EXPR, thr_num);\n+\t  gimple_seq_add_stmt (end, g);\n+\t  g = gimple_build_assign (num_thr_sz, PLUS_EXPR, idx,\n+\t\t\t\t   build_one_cst (TREE_TYPE (idx)));\n+\t  gimple_seq_add_stmt (end, g);\n+\t  gimple_seq_add_stmt (end, gimple_build_goto (lab3));\n+\t  gimple_seq_add_stmt (end, gimple_build_label (lab6));\n+\t}\n+      g = gimple_build_cond (NE_EXPR, thr_num, integer_zero_node, lab2, lab4);\n+      gimple_seq_add_stmt (end, g);\n+      gimple_seq_add_stmt (end, gimple_build_label (lab4));\n+    }\n+  if (code != OMP_PARALLEL)\n+    {\n+      t = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n+      tree num_thr = create_tmp_var (integer_type_node);\n+      g = gimple_build_call (t, 0);\n+      gimple_call_set_lhs (g, num_thr);\n+      gimple_seq_add_stmt (end, g);\n+      g = gimple_build_assign (num_thr_sz, NOP_EXPR, num_thr);\n+      gimple_seq_add_stmt (end, g);\n+      if (cancellable)\n+\tgimple_seq_add_stmt (end, gimple_build_label (lab3));\n+    }\n+  else\n+    {\n+      tree c = omp_find_clause (gimple_omp_parallel_clauses (ctx->stmt),\n+\t\t\t\tOMP_CLAUSE__REDUCTEMP_);\n+      t = fold_convert (pointer_sized_int_node, OMP_CLAUSE_DECL (c));\n+      t = fold_convert (size_type_node, t);\n+      gimplify_assign (num_thr_sz, t, end);\n+    }\n+  t = build4 (ARRAY_REF, pointer_sized_int_node, avar, size_int (2),\n+\t      NULL_TREE, NULL_TREE);\n+  tree data = create_tmp_var (pointer_sized_int_node);\n+  gimple_seq_add_stmt (end, gimple_build_assign (data, t));\n+  gimple_seq_add_stmt (end, gimple_build_label (lab1));\n+  tree ptr;\n+  if (TREE_CODE (TYPE_SIZE_UNIT (record_type)) == INTEGER_CST)\n+    ptr = create_tmp_var (build_pointer_type (record_type));\n+  else\n+    ptr = create_tmp_var (ptr_type_node);\n+  gimple_seq_add_stmt (end, gimple_build_assign (ptr, NOP_EXPR, data));\n+\n+  tree field = TYPE_FIELDS (record_type);\n+  cnt = 0;\n+  if (cancellable)\n+    field = DECL_CHAIN (DECL_CHAIN (field));\n+  for (int pass = 0; pass < 2; pass++)\n+    {\n+      tree decl, type, next;\n+      for (tree c = clauses;\n+\t   omp_task_reduction_iterate (pass, code, ccode,\n+\t\t\t\t       &c, &decl, &type, &next); c = next)\n+\t{\n+\t  tree var = decl, ref;\n+\t  if (TREE_CODE (decl) == MEM_REF)\n+\t    {\n+\t      var = TREE_OPERAND (var, 0);\n+\t      if (TREE_CODE (var) == POINTER_PLUS_EXPR)\n+\t\tvar = TREE_OPERAND (var, 0);\n+\t      tree v = var;\n+\t      if (TREE_CODE (var) == ADDR_EXPR)\n+\t\tvar = TREE_OPERAND (var, 0);\n+\t      else if (TREE_CODE (var) == INDIRECT_REF)\n+\t\tvar = TREE_OPERAND (var, 0);\n+\t      tree orig_var = var;\n+\t      if (is_variable_sized (var))\n+\t\t{\n+\t\t  gcc_assert (DECL_HAS_VALUE_EXPR_P (var));\n+\t\t  var = DECL_VALUE_EXPR (var);\n+\t\t  gcc_assert (TREE_CODE (var) == INDIRECT_REF);\n+\t\t  var = TREE_OPERAND (var, 0);\n+\t\t  gcc_assert (DECL_P (var));\n+\t\t}\n+\t      t = ref = maybe_lookup_decl_in_outer_ctx (var, ctx);\n+\t      if (orig_var != var)\n+\t\tgcc_assert (TREE_CODE (v) == ADDR_EXPR);\n+\t      else if (TREE_CODE (v) == ADDR_EXPR)\n+\t\tt = build_fold_addr_expr (t);\n+\t      else if (TREE_CODE (v) == INDIRECT_REF)\n+\t\tt = build_fold_indirect_ref (t);\n+\t      if (TREE_CODE (TREE_OPERAND (decl, 0)) == POINTER_PLUS_EXPR)\n+\t\t{\n+\t\t  tree b = TREE_OPERAND (TREE_OPERAND (decl, 0), 1);\n+\t\t  b = maybe_lookup_decl_in_outer_ctx (b, ctx);\n+\t\t  t = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, b);\n+\t\t}\n+\t      if (!integer_zerop (TREE_OPERAND (decl, 1)))\n+\t\tt = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t,\n+\t\t\t\t fold_convert (size_type_node,\n+\t\t\t\t\t       TREE_OPERAND (decl, 1)));\n+\t    }\n+\t  else\n+\t    {\n+\t      t = ref = maybe_lookup_decl_in_outer_ctx (var, ctx);\n+\t      if (!omp_is_reference (decl))\n+\t\tt = build_fold_addr_expr (t);\n+\t    }\n+\t  t = fold_convert (pointer_sized_int_node, t);\n+\t  seq = NULL;\n+\t  t = force_gimple_operand (t, &seq, true, NULL_TREE);\n+\t  gimple_seq_add_seq (start, seq);\n+\t  r = build4 (ARRAY_REF, pointer_sized_int_node, avar,\n+\t\t      size_int (7 + cnt * 3), NULL_TREE, NULL_TREE);\n+\t  gimple_seq_add_stmt (start, gimple_build_assign (r, t));\n+\t  t = unshare_expr (byte_position (field));\n+\t  t = fold_convert (pointer_sized_int_node, t);\n+\t  ctx->task_reduction_map->put (c, cnt);\n+\t  ctx->task_reductions.quick_push (TREE_CODE (t) == INTEGER_CST\n+\t\t\t\t\t   ? t : NULL_TREE);\n+\t  seq = NULL;\n+\t  t = force_gimple_operand (t, &seq, true, NULL_TREE);\n+\t  gimple_seq_add_seq (start, seq);\n+\t  r = build4 (ARRAY_REF, pointer_sized_int_node, avar,\n+\t\t      size_int (7 + cnt * 3 + 1), NULL_TREE, NULL_TREE);\n+\t  gimple_seq_add_stmt (start, gimple_build_assign (r, t));\n+\n+\t  tree bfield = DECL_CHAIN (field);\n+\t  tree cond;\n+\t  if (code == OMP_PARALLEL || code == OMP_FOR || code == OMP_SECTIONS)\n+\t    /* In parallel or worksharing all threads unconditionally\n+\t       initialize all their task reduction private variables.  */\n+\t    cond = boolean_true_node;\n+\t  else if (TREE_TYPE (ptr) == ptr_type_node)\n+\t    {\n+\t      cond = build2 (POINTER_PLUS_EXPR, ptr_type_node, ptr,\n+\t\t\t     unshare_expr (byte_position (bfield)));\n+\t      seq = NULL;\n+\t      cond = force_gimple_operand (cond, &seq, true, NULL_TREE);\n+\t      gimple_seq_add_seq (end, seq);\n+\t      tree pbool = build_pointer_type (TREE_TYPE (bfield));\n+\t      cond = build2 (MEM_REF, TREE_TYPE (bfield), cond,\n+\t\t\t     build_int_cst (pbool, 0));\n+\t    }\n+\t  else\n+\t    cond = build3 (COMPONENT_REF, TREE_TYPE (bfield),\n+\t\t\t   build_simple_mem_ref (ptr), bfield, NULL_TREE);\n+\t  tree lab3 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  tree lab4 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  tree condv = create_tmp_var (boolean_type_node);\n+\t  gimple_seq_add_stmt (end, gimple_build_assign (condv, cond));\n+\t  g = gimple_build_cond (NE_EXPR, condv, boolean_false_node,\n+\t\t\t\t lab3, lab4);\n+\t  gimple_seq_add_stmt (end, g);\n+\t  gimple_seq_add_stmt (end, gimple_build_label (lab3));\n+\t  if (cancellable && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == NULL_TREE)\n+\t    {\n+\t      /* If this reduction doesn't need destruction and parallel\n+\t\t has been cancelled, there is nothing to do for this\n+\t\t reduction, so jump around the merge operation.  */\n+\t      tree lab5 = create_artificial_label (UNKNOWN_LOCATION);\n+\t      g = gimple_build_cond (NE_EXPR, cancellable,\n+\t\t\t\t     build_zero_cst (TREE_TYPE (cancellable)),\n+\t\t\t\t     lab4, lab5);\n+\t      gimple_seq_add_stmt (end, g);\n+\t      gimple_seq_add_stmt (end, gimple_build_label (lab5));\n+\t    }\n+\n+\t  tree new_var;\n+\t  if (TREE_TYPE (ptr) == ptr_type_node)\n+\t    {\n+\t      new_var = build2 (POINTER_PLUS_EXPR, ptr_type_node, ptr,\n+\t\t\t\tunshare_expr (byte_position (field)));\n+\t      seq = NULL;\n+\t      new_var = force_gimple_operand (new_var, &seq, true, NULL_TREE);\n+\t      gimple_seq_add_seq (end, seq);\n+\t      tree pbool = build_pointer_type (TREE_TYPE (field));\n+\t      new_var = build2 (MEM_REF, TREE_TYPE (field), new_var,\n+\t\t\t\tbuild_int_cst (pbool, 0));\n+\t    }\n+\t  else\n+\t    new_var = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t      build_simple_mem_ref (ptr), field, NULL_TREE);\n+\n+\t  enum tree_code rcode = OMP_CLAUSE_REDUCTION_CODE (c);\n+\t  if (TREE_CODE (decl) != MEM_REF && omp_is_reference (decl))\n+\t    ref = build_simple_mem_ref (ref);\n+\t  /* reduction(-:var) sums up the partial results, so it acts\n+\t     identically to reduction(+:var).  */\n+\t  if (rcode == MINUS_EXPR)\n+\t    rcode = PLUS_EXPR;\n+\t  if (TREE_CODE (decl) == MEM_REF)\n+\t    {\n+\t      tree type = TREE_TYPE (new_var);\n+\t      tree v = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+\t      tree i = create_tmp_var (TREE_TYPE (v));\n+\t      tree ptype = build_pointer_type (TREE_TYPE (type));\n+\t      if (DECL_P (v))\n+\t\t{\n+\t\t  v = maybe_lookup_decl_in_outer_ctx (v, ctx);\n+\t\t  tree vv = create_tmp_var (TREE_TYPE (v));\n+\t\t  gimplify_assign (vv, v, start);\n+\t\t  v = vv;\n+\t\t}\n+\t      ref = build4 (ARRAY_REF, pointer_sized_int_node, avar,\n+\t\t\t    size_int (7 + cnt * 3), NULL_TREE, NULL_TREE);\n+\t      new_var = build_fold_addr_expr (new_var);\n+\t      new_var = fold_convert (ptype, new_var);\n+\t      ref = fold_convert (ptype, ref);\n+\t      tree m = create_tmp_var (ptype);\n+\t      gimplify_assign (m, new_var, end);\n+\t      new_var = m;\n+\t      m = create_tmp_var (ptype);\n+\t      gimplify_assign (m, ref, end);\n+\t      ref = m;\n+\t      gimplify_assign (i, build_int_cst (TREE_TYPE (v), 0), end);\n+\t      tree body = create_artificial_label (UNKNOWN_LOCATION);\n+\t      tree endl = create_artificial_label (UNKNOWN_LOCATION);\n+\t      gimple_seq_add_stmt (end, gimple_build_label (body));\n+\t      tree priv = build_simple_mem_ref (new_var);\n+\t      tree out = build_simple_mem_ref (ref);\n+\t      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t\t{\n+\t\t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n+\t\t  tree decl_placeholder\n+\t\t    = OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c);\n+\t\t  tree lab6 = NULL_TREE;\n+\t\t  if (cancellable)\n+\t\t    {\n+\t\t      /* If this reduction needs destruction and parallel\n+\t\t\t has been cancelled, jump around the merge operation\n+\t\t\t to the destruction.  */\n+\t\t      tree lab5 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t      lab6 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t      tree zero = build_zero_cst (TREE_TYPE (cancellable));\n+\t\t      g = gimple_build_cond (NE_EXPR, cancellable, zero,\n+\t\t\t\t\t     lab6, lab5);\n+\t\t      gimple_seq_add_stmt (end, g);\n+\t\t      gimple_seq_add_stmt (end, gimple_build_label (lab5));\n+\t\t    }\n+\t\t  SET_DECL_VALUE_EXPR (placeholder, out);\n+\t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t\t  SET_DECL_VALUE_EXPR (decl_placeholder, priv);\n+\t\t  DECL_HAS_VALUE_EXPR_P (decl_placeholder) = 1;\n+\t\t  lower_omp (&OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c), ctx);\n+\t\t  gimple_seq_add_seq (end,\n+\t\t\t\t      OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c));\n+\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n+\t\t    {\n+\t\t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = NULL;\n+\t\t      OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER (c) = NULL;\n+\t\t    }\n+\t\t  if (cancellable)\n+\t\t    gimple_seq_add_stmt (end, gimple_build_label (lab6));\n+\t\t  tree x = lang_hooks.decls.omp_clause_dtor (c, priv);\n+\t\t  if (x)\n+\t\t    {\n+\t\t      gimple_seq tseq = NULL;\n+\t\t      gimplify_stmt (&x, &tseq);\n+\t\t      gimple_seq_add_seq (end, tseq);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree x = build2 (rcode, TREE_TYPE (out), out, priv);\n+\t\t  out = unshare_expr (out);\n+\t\t  gimplify_assign (out, x, end);\n+\t\t}\n+\t      gimple *g\n+\t\t= gimple_build_assign (new_var, POINTER_PLUS_EXPR, new_var,\n+\t\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t      gimple_seq_add_stmt (end, g);\n+\t      g = gimple_build_assign (ref, POINTER_PLUS_EXPR, ref,\n+\t\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t      gimple_seq_add_stmt (end, g);\n+\t      g = gimple_build_assign (i, PLUS_EXPR, i,\n+\t\t\t\t       build_int_cst (TREE_TYPE (i), 1));\n+\t      gimple_seq_add_stmt (end, g);\n+\t      g = gimple_build_cond (LE_EXPR, i, v, body, endl);\n+\t      gimple_seq_add_stmt (end, g);\n+\t      gimple_seq_add_stmt (end, gimple_build_label (endl));\n+\t    }\n+\t  else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t    {\n+\t      tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n+\t      tree oldv = NULL_TREE;\n+\t      tree lab6 = NULL_TREE;\n+\t      if (cancellable)\n+\t\t{\n+\t\t  /* If this reduction needs destruction and parallel\n+\t\t     has been cancelled, jump around the merge operation\n+\t\t     to the destruction.  */\n+\t\t  tree lab5 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t  lab6 = create_artificial_label (UNKNOWN_LOCATION);\n+\t\t  tree zero = build_zero_cst (TREE_TYPE (cancellable));\n+\t\t  g = gimple_build_cond (NE_EXPR, cancellable, zero,\n+\t\t\t\t\t lab6, lab5);\n+\t\t  gimple_seq_add_stmt (end, g);\n+\t\t  gimple_seq_add_stmt (end, gimple_build_label (lab5));\n+\t\t}\n+\t      if (omp_is_reference (decl)\n+\t\t  && !useless_type_conversion_p (TREE_TYPE (placeholder),\n+\t\t\t\t\t\t TREE_TYPE (ref)))\n+\t\tref = build_fold_addr_expr_loc (OMP_CLAUSE_LOCATION (c), ref);\n+\t      ref = build_fold_addr_expr_loc (OMP_CLAUSE_LOCATION (c), ref);\n+\t      tree refv = create_tmp_var (TREE_TYPE (ref));\n+\t      gimplify_assign (refv, ref, end);\n+\t      ref = build_simple_mem_ref_loc (OMP_CLAUSE_LOCATION (c), refv);\n+\t      SET_DECL_VALUE_EXPR (placeholder, ref);\n+\t      DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t      tree d = maybe_lookup_decl (decl, ctx);\n+\t      gcc_assert (d);\n+\t      if (DECL_HAS_VALUE_EXPR_P (d))\n+\t\toldv = DECL_VALUE_EXPR (d);\n+\t      if (omp_is_reference (var))\n+\t\t{\n+\t\t  tree v = fold_convert (TREE_TYPE (d),\n+\t\t\t\t\t build_fold_addr_expr (new_var));\n+\t\t  SET_DECL_VALUE_EXPR (d, v);\n+\t\t}\n+\t      else\n+\t\tSET_DECL_VALUE_EXPR (d, new_var);\n+\t      DECL_HAS_VALUE_EXPR_P (d) = 1;\n+\t      lower_omp (&OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c), ctx);\n+\t      if (oldv)\n+\t\tSET_DECL_VALUE_EXPR (d, oldv);\n+\t      else\n+\t\t{\n+\t\t  SET_DECL_VALUE_EXPR (d, NULL_TREE);\n+\t\t  DECL_HAS_VALUE_EXPR_P (d) = 0;\n+\t\t}\n+\t      gimple_seq_add_seq (end, OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c));\n+\t      OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n+\t\tOMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = NULL;\n+\t      if (cancellable)\n+\t\tgimple_seq_add_stmt (end, gimple_build_label (lab6));\n+\t      tree x = lang_hooks.decls.omp_clause_dtor (c, new_var);\n+\t      if (x)\n+\t\t{\n+\t\t  gimple_seq tseq = NULL;\n+\t\t  gimplify_stmt (&x, &tseq);\n+\t\t  gimple_seq_add_seq (end, tseq);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      tree x = build2 (rcode, TREE_TYPE (ref), ref, new_var);\n+\t      ref = unshare_expr (ref);\n+\t      gimplify_assign (ref, x, end);\n+\t    }\n+\t  gimple_seq_add_stmt (end, gimple_build_label (lab4));\n+\t  ++cnt;\n+\t  field = DECL_CHAIN (bfield);\n+\t}\n+    }\n+\n+  if (code == OMP_TASKGROUP)\n+    {\n+      t = builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_REDUCTION_REGISTER);\n+      g = gimple_build_call (t, 1, build_fold_addr_expr (avar));\n+      gimple_seq_add_stmt (start, g);\n+    }\n+  else\n+    {\n+      tree c;\n+      if (code == OMP_FOR)\n+\tc = gimple_omp_for_clauses (ctx->stmt);\n+      else if (code == OMP_SECTIONS)\n+\tc = gimple_omp_sections_clauses (ctx->stmt);\n+      else\n+\tc = gimple_omp_taskreg_clauses (ctx->stmt);\n+      c = omp_find_clause (c, OMP_CLAUSE__REDUCTEMP_);\n+      t = fold_convert (TREE_TYPE (OMP_CLAUSE_DECL (c)),\n+\t\t\tbuild_fold_addr_expr (avar));\n+      gimplify_assign (OMP_CLAUSE_DECL (c), t, start);\n+    }\n+\n+  gimple_seq_add_stmt (end, gimple_build_assign (data, PLUS_EXPR, data, sz));\n+  gimple_seq_add_stmt (end, gimple_build_assign (idx, PLUS_EXPR, idx,\n+\t\t\t\t\t\t size_one_node));\n+  g = gimple_build_cond (NE_EXPR, idx, num_thr_sz, lab1, lab2);\n+  gimple_seq_add_stmt (end, g);\n+  gimple_seq_add_stmt (end, gimple_build_label (lab2));\n+  if (code == OMP_FOR || code == OMP_SECTIONS)\n+    {\n+      enum built_in_function bfn\n+\t= BUILT_IN_GOMP_WORKSHARE_TASK_REDUCTION_UNREGISTER;\n+      t = builtin_decl_explicit (bfn);\n+      tree c_bool_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (t)));\n+      tree arg;\n+      if (cancellable)\n+\t{\n+\t  arg = create_tmp_var (c_bool_type);\n+\t  gimple_seq_add_stmt (end, gimple_build_assign (arg, NOP_EXPR,\n+\t\t\t\t\t\t\t cancellable));\n+\t}\n+      else\n+\targ = build_int_cst (c_bool_type, 0);\n+      g = gimple_build_call (t, 1, arg);\n+    }\n+  else\n+    {\n+      t = builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_REDUCTION_UNREGISTER);\n+      g = gimple_build_call (t, 1, build_fold_addr_expr (avar));\n+    }\n+  gimple_seq_add_stmt (end, g);\n+  t = build_constructor (atype, NULL);\n+  TREE_THIS_VOLATILE (t) = 1;\n+  gimple_seq_add_stmt (end, gimple_build_assign (avar, t));\n+}\n \n /* Expand code for an OpenMP taskgroup directive.  */\n \n@@ -6149,21 +7527,31 @@ lower_omp_taskgroup (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple *stmt = gsi_stmt (*gsi_p);\n   gcall *x;\n   gbind *bind;\n+  gimple_seq dseq = NULL;\n   tree block = make_node (BLOCK);\n \n   bind = gimple_build_bind (NULL, NULL, block);\n   gsi_replace (gsi_p, bind, true);\n   gimple_bind_add_stmt (bind, stmt);\n \n+  push_gimplify_context ();\n+\n   x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_START),\n \t\t\t 0);\n   gimple_bind_add_stmt (bind, x);\n \n+  lower_omp_task_reductions (ctx, OMP_TASKGROUP,\n+\t\t\t     gimple_omp_taskgroup_clauses (stmt),\n+\t\t\t     gimple_bind_body_ptr (bind), &dseq);\n+\n   lower_omp (gimple_omp_body_ptr (stmt), ctx);\n   gimple_bind_add_seq (bind, gimple_omp_body (stmt));\n   gimple_omp_set_body (stmt, NULL);\n \n   gimple_bind_add_stmt (bind, gimple_build_omp_return (true));\n+  gimple_bind_add_seq (bind, dseq);\n+\n+  pop_gimplify_context (bind);\n \n   gimple_bind_append_vars (bind, ctx->block_vars);\n   BLOCK_VARS (block) = ctx->block_vars;\n@@ -6752,7 +8140,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   struct omp_for_data fd, *fdp = NULL;\n   gomp_for *stmt = as_a <gomp_for *> (gsi_stmt (*gsi_p));\n   gbind *new_stmt;\n-  gimple_seq omp_for_body, body, dlist;\n+  gimple_seq omp_for_body, body, dlist, tred_ilist = NULL, tred_dlist = NULL;\n+  gimple_seq cnt_list = NULL;\n   gimple_seq oacc_head = NULL, oacc_tail = NULL;\n   size_t i;\n \n@@ -6845,9 +8234,30 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   /* The pre-body and input clauses go before the lowered GIMPLE_OMP_FOR.  */\n   dlist = NULL;\n   body = NULL;\n+  tree rclauses\n+    = omp_task_reductions_find_first (gimple_omp_for_clauses (stmt), OMP_FOR,\n+\t\t\t\t      OMP_CLAUSE_REDUCTION);\n+  tree rtmp = NULL_TREE;\n+  if (rclauses)\n+    {\n+      tree type = build_pointer_type (pointer_sized_int_node);\n+      tree temp = create_tmp_var (type);\n+      tree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__REDUCTEMP_);\n+      OMP_CLAUSE_DECL (c) = temp;\n+      OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (stmt);\n+      gimple_omp_for_set_clauses (stmt, c);\n+      lower_omp_task_reductions (ctx, OMP_FOR,\n+\t\t\t\t gimple_omp_for_clauses (stmt),\n+\t\t\t\t &tred_ilist, &tred_dlist);\n+      rclauses = c;\n+      rtmp = make_ssa_name (type);\n+      gimple_seq_add_stmt (&body, gimple_build_assign (rtmp, temp));\n+    }\n+\n   lower_rec_input_clauses (gimple_omp_for_clauses (stmt), &body, &dlist, ctx,\n \t\t\t   fdp);\n-  gimple_seq_add_seq (&body, gimple_omp_for_pre_body (stmt));\n+  gimple_seq_add_seq (rclauses ? &tred_ilist : &body,\n+\t\t      gimple_omp_for_pre_body (stmt));\n \n   lower_omp (gimple_omp_body_ptr (stmt), ctx);\n \n@@ -6862,20 +8272,24 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     {\n       rhs_p = gimple_omp_for_initial_ptr (stmt, i);\n       if (!is_gimple_min_invariant (*rhs_p))\n-\t*rhs_p = get_formal_tmp_var (*rhs_p, &body);\n+\t*rhs_p = get_formal_tmp_var (*rhs_p, &cnt_list);\n       else if (TREE_CODE (*rhs_p) == ADDR_EXPR)\n \trecompute_tree_invariant_for_addr_expr (*rhs_p);\n \n       rhs_p = gimple_omp_for_final_ptr (stmt, i);\n       if (!is_gimple_min_invariant (*rhs_p))\n-\t*rhs_p = get_formal_tmp_var (*rhs_p, &body);\n+\t*rhs_p = get_formal_tmp_var (*rhs_p, &cnt_list);\n       else if (TREE_CODE (*rhs_p) == ADDR_EXPR)\n \trecompute_tree_invariant_for_addr_expr (*rhs_p);\n \n       rhs_p = &TREE_OPERAND (gimple_omp_for_incr (stmt, i), 1);\n       if (!is_gimple_min_invariant (*rhs_p))\n-\t*rhs_p = get_formal_tmp_var (*rhs_p, &body);\n+\t*rhs_p = get_formal_tmp_var (*rhs_p, &cnt_list);\n     }\n+  if (rclauses)\n+    gimple_seq_add_seq (&tred_ilist, cnt_list);\n+  else\n+    gimple_seq_add_seq (&body, cnt_list);\n \n   /* Once lowered, extract the bounds and clauses.  */\n   omp_extract_for_data (stmt, &fd, NULL);\n@@ -6922,13 +8336,26 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   gimple_seq_add_seq (&body, dlist);\n \n+  if (rclauses)\n+    {\n+      gimple_seq_add_seq (&tred_ilist, body);\n+      body = tred_ilist;\n+    }\n+\n   body = maybe_catch_exception (body);\n \n   if (!phony_loop)\n     {\n       /* Region exit marker goes at the end of the loop body.  */\n-      gimple_seq_add_stmt (&body, gimple_build_omp_return (fd.have_nowait));\n-      maybe_add_implicit_barrier_cancel (ctx, &body);\n+      gimple *g = gimple_build_omp_return (fd.have_nowait);\n+      gimple_seq_add_stmt (&body, g);\n+\n+      gimple_seq_add_seq (&body, tred_dlist);\n+\n+      maybe_add_implicit_barrier_cancel (ctx, g, &body);\n+\n+      if (rclauses)\n+\tOMP_CLAUSE_DECL (rclauses) = rtmp;\n     }\n \n   /* Add OpenACC joining and reduction markers just after the loop.  */\n@@ -7153,6 +8580,40 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n \tt = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \tappend_to_statement_list (t, &list);\n \tbreak;\n+      case OMP_CLAUSE_REDUCTION:\n+      case OMP_CLAUSE_IN_REDUCTION:\n+\tdecl = OMP_CLAUSE_DECL (c);\n+\tif (TREE_CODE (decl) == MEM_REF)\n+\t  {\n+\t    decl = TREE_OPERAND (decl, 0);\n+\t    if (TREE_CODE (decl) == POINTER_PLUS_EXPR)\n+\t      decl = TREE_OPERAND (decl, 0);\n+\t    if (TREE_CODE (decl) == INDIRECT_REF\n+\t\t|| TREE_CODE (decl) == ADDR_EXPR)\n+\t      decl = TREE_OPERAND (decl, 0);\n+\t  }\n+\tkey = (splay_tree_key) decl;\n+\tn = splay_tree_lookup (ctx->field_map, key);\n+\tif (n == NULL)\n+\t  break;\n+\tf = (tree) n->value;\n+\tif (tcctx.cb.decl_map)\n+\t  f = *tcctx.cb.decl_map->get (f);\n+\tn = splay_tree_lookup (ctx->sfield_map, key);\n+\tsf = (tree) n->value;\n+\tif (tcctx.cb.decl_map)\n+\t  sf = *tcctx.cb.decl_map->get (sf);\n+\tsrc = build_simple_mem_ref_loc (loc, sarg);\n+\tsrc = omp_build_component_ref (src, sf);\n+\tif (decl != OMP_CLAUSE_DECL (c)\n+\t    && TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t    && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == POINTER_TYPE)\n+\t  src = build_simple_mem_ref_loc (loc, src);\n+\tdst = build_simple_mem_ref_loc (loc, arg);\n+\tdst = omp_build_component_ref (dst, f);\n+\tt = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n+\tappend_to_statement_list (t, &list);\n+\tbreak;\n       case OMP_CLAUSE__LOOPTEMP_:\n \t/* Fields for first two _looptemp_ clauses are initialized by\n \t   GOMP_taskloop*, the rest are handled like firstprivate.  */\n@@ -7162,6 +8623,7 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n \t    break;\n \t  }\n \t/* FALLTHRU */\n+      case OMP_CLAUSE__REDUCTEMP_:\n       case OMP_CLAUSE_FIRSTPRIVATE:\n \tdecl = OMP_CLAUSE_DECL (c);\n \tif (is_variable_sized (decl))\n@@ -7187,7 +8649,7 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n \t  src = decl;\n \tdst = build_simple_mem_ref_loc (loc, arg);\n \tdst = omp_build_component_ref (dst, f);\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__LOOPTEMP_)\n+\tif (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \telse\n \t  t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n@@ -7279,46 +8741,91 @@ lower_depend_clauses (tree *pclauses, gimple_seq *iseq, gimple_seq *oseq)\n {\n   tree c, clauses;\n   gimple *g;\n-  size_t n_in = 0, n_out = 0, idx = 2, i;\n+  size_t cnt[4] = { 0, 0, 0, 0 }, idx = 2, i;\n \n   clauses = omp_find_clause (*pclauses, OMP_CLAUSE_DEPEND);\n   gcc_assert (clauses);\n   for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n       switch (OMP_CLAUSE_DEPEND_KIND (c))\n \t{\n+\tcase OMP_CLAUSE_DEPEND_LAST:\n+\t  /* Lowering already done at gimplification.  */\n+\t  return;\n \tcase OMP_CLAUSE_DEPEND_IN:\n-\t  n_in++;\n+\t  cnt[2]++;\n \t  break;\n \tcase OMP_CLAUSE_DEPEND_OUT:\n \tcase OMP_CLAUSE_DEPEND_INOUT:\n-\t  n_out++;\n+\t  cnt[0]++;\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t  cnt[1]++;\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND_DEPOBJ:\n+\t  cnt[3]++;\n \t  break;\n \tcase OMP_CLAUSE_DEPEND_SOURCE:\n \tcase OMP_CLAUSE_DEPEND_SINK:\n \t  /* FALLTHRU */\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-  tree type = build_array_type_nelts (ptr_type_node, n_in + n_out + 2);\n+  if (cnt[1] || cnt[3])\n+    idx = 5;\n+  size_t total = cnt[0] + cnt[1] + cnt[2] + cnt[3];\n+  tree type = build_array_type_nelts (ptr_type_node, total + idx);\n   tree array = create_tmp_var (type);\n   TREE_ADDRESSABLE (array) = 1;\n   tree r = build4 (ARRAY_REF, ptr_type_node, array, size_int (0), NULL_TREE,\n \t\t   NULL_TREE);\n-  g = gimple_build_assign (r, build_int_cst (ptr_type_node, n_in + n_out));\n-  gimple_seq_add_stmt (iseq, g);\n-  r = build4 (ARRAY_REF, ptr_type_node, array, size_int (1), NULL_TREE,\n-\t      NULL_TREE);\n-  g = gimple_build_assign (r, build_int_cst (ptr_type_node, n_out));\n+  if (idx == 5)\n+    {\n+      g = gimple_build_assign (r, build_int_cst (ptr_type_node, 0));\n+      gimple_seq_add_stmt (iseq, g);\n+      r = build4 (ARRAY_REF, ptr_type_node, array, size_int (1), NULL_TREE,\n+\t\t  NULL_TREE);\n+    }\n+  g = gimple_build_assign (r, build_int_cst (ptr_type_node, total));\n   gimple_seq_add_stmt (iseq, g);\n-  for (i = 0; i < 2; i++)\n+  for (i = 0; i < (idx == 5 ? 3 : 1); i++)\n+    {\n+      r = build4 (ARRAY_REF, ptr_type_node, array,\n+\t\t  size_int (i + 1 + (idx == 5)), NULL_TREE, NULL_TREE);\n+      g = gimple_build_assign (r, build_int_cst (ptr_type_node, cnt[i]));\n+      gimple_seq_add_stmt (iseq, g);\n+    }\n+  for (i = 0; i < 4; i++)\n     {\n-      if ((i ? n_in : n_out) == 0)\n+      if (cnt[i] == 0)\n \tcontinue;\n       for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n-\t    && ((OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_IN) ^ i))\n+\tif (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n+\t  continue;\n+\telse\n \t  {\n+\t    switch (OMP_CLAUSE_DEPEND_KIND (c))\n+\t      {\n+\t      case OMP_CLAUSE_DEPEND_IN:\n+\t\tif (i != 2)\n+\t\t  continue;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_OUT:\n+\t      case OMP_CLAUSE_DEPEND_INOUT:\n+\t\tif (i != 0)\n+\t\t  continue;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t\tif (i != 1)\n+\t\t  continue;\n+\t\tbreak;\n+\t      case OMP_CLAUSE_DEPEND_DEPOBJ:\n+\t\tif (i != 3)\n+\t\t  continue;\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \t    tree t = OMP_CLAUSE_DECL (c);\n \t    t = fold_convert (ptr_type_node, t);\n \t    gimplify_expr (&t, iseq, NULL, is_gimple_val, fb_rvalue);\n@@ -7329,6 +8836,7 @@ lower_depend_clauses (tree *pclauses, gimple_seq *iseq, gimple_seq *oseq)\n \t  }\n     }\n   c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_DEPEND);\n+  OMP_CLAUSE_DEPEND_KIND (c) = OMP_CLAUSE_DEPEND_LAST;\n   OMP_CLAUSE_DECL (c) = build_fold_addr_expr (array);\n   OMP_CLAUSE_CHAIN (c) = *pclauses;\n   *pclauses = c;\n@@ -7348,13 +8856,22 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   tree child_fn, t;\n   gimple *stmt = gsi_stmt (*gsi_p);\n   gbind *par_bind, *bind, *dep_bind = NULL;\n-  gimple_seq par_body, olist, ilist, par_olist, par_rlist, par_ilist, new_body;\n+  gimple_seq par_body;\n   location_t loc = gimple_location (stmt);\n \n   clauses = gimple_omp_taskreg_clauses (stmt);\n-  par_bind\n-    = as_a <gbind *> (gimple_seq_first_stmt (gimple_omp_body (stmt)));\n-  par_body = gimple_bind_body (par_bind);\n+  if (gimple_code (stmt) == GIMPLE_OMP_TASK\n+      && gimple_omp_task_taskwait_p (stmt))\n+    {\n+      par_bind = NULL;\n+      par_body = NULL;\n+    }\n+  else\n+    {\n+      par_bind\n+\t= as_a <gbind *> (gimple_seq_first_stmt (gimple_omp_body (stmt)));\n+      par_body = gimple_bind_body (par_bind);\n+    }\n   child_fn = ctx->cb.dst_fn;\n   if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n       && !gimple_omp_parallel_combined_p (stmt))\n@@ -7380,14 +8897,49 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t    &dep_ilist, &dep_olist);\n     }\n \n+  if (gimple_code (stmt) == GIMPLE_OMP_TASK\n+      && gimple_omp_task_taskwait_p (stmt))\n+    {\n+      if (dep_bind)\n+\t{\n+\t  gsi_replace (gsi_p, dep_bind, true);\n+\t  gimple_bind_add_seq (dep_bind, dep_ilist);\n+\t  gimple_bind_add_stmt (dep_bind, stmt);\n+\t  gimple_bind_add_seq (dep_bind, dep_olist);\n+\t  pop_gimplify_context (dep_bind);\n+\t}\n+      return;\n+    }\n+\n   if (ctx->srecord_type)\n     create_task_copyfn (as_a <gomp_task *> (stmt), ctx);\n \n+  gimple_seq tskred_ilist = NULL;\n+  gimple_seq tskred_olist = NULL;\n+  if ((is_task_ctx (ctx)\n+       && gimple_omp_task_taskloop_p (ctx->stmt)\n+       && omp_find_clause (gimple_omp_task_clauses (ctx->stmt),\n+\t\t\t   OMP_CLAUSE_REDUCTION))\n+      || (is_parallel_ctx (ctx)\n+\t  && omp_find_clause (gimple_omp_parallel_clauses (stmt),\n+\t\t\t      OMP_CLAUSE__REDUCTEMP_)))\n+    {\n+      if (dep_bind == NULL)\n+\t{\n+\t  push_gimplify_context ();\n+\t  dep_bind = gimple_build_bind (NULL, NULL, make_node (BLOCK));\n+\t}\n+      lower_omp_task_reductions (ctx, is_task_ctx (ctx) ? OMP_TASKLOOP\n+\t\t\t\t\t\t\t: OMP_PARALLEL,\n+\t\t\t\t gimple_omp_taskreg_clauses (ctx->stmt),\n+\t\t\t\t &tskred_ilist, &tskred_olist);\n+    }\n+\n   push_gimplify_context ();\n \n-  par_olist = NULL;\n-  par_ilist = NULL;\n-  par_rlist = NULL;\n+  gimple_seq par_olist = NULL;\n+  gimple_seq par_ilist = NULL;\n+  gimple_seq par_rlist = NULL;\n   bool phony_construct = gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n     && gimple_omp_parallel_grid_phony (as_a <gomp_parallel *> (stmt));\n   if (phony_construct && ctx->record_type)\n@@ -7417,8 +8969,8 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       gimple_omp_taskreg_set_data_arg (stmt, ctx->sender_decl);\n     }\n \n-  olist = NULL;\n-  ilist = NULL;\n+  gimple_seq olist = NULL;\n+  gimple_seq ilist = NULL;\n   lower_send_clauses (clauses, &ilist, &olist, ctx);\n   lower_send_shared_vars (&ilist, &olist, ctx);\n \n@@ -7433,7 +8985,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   /* Once all the expansions are done, sequence all the different\n      fragments inside gimple_omp_body.  */\n \n-  new_body = NULL;\n+  gimple_seq new_body = NULL;\n \n   if (ctx->record_type)\n     {\n@@ -7461,7 +9013,10 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       gimple_omp_set_body (stmt, new_body);\n     }\n \n-  bind = gimple_build_bind (NULL, NULL, gimple_bind_block (par_bind));\n+  if (dep_bind && gimple_bind_block (par_bind) == NULL_TREE)\n+    bind = gimple_build_bind (NULL, NULL, make_node (BLOCK));\n+  else\n+    bind = gimple_build_bind (NULL, NULL, gimple_bind_block (par_bind));\n   gsi_replace (gsi_p, dep_bind ? dep_bind : bind, true);\n   gimple_bind_add_seq (bind, ilist);\n   if (!phony_construct)\n@@ -7475,7 +9030,9 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   if (dep_bind)\n     {\n       gimple_bind_add_seq (dep_bind, dep_ilist);\n+      gimple_bind_add_seq (dep_bind, tskred_ilist);\n       gimple_bind_add_stmt (dep_bind, bind);\n+      gimple_bind_add_seq (dep_bind, tskred_olist);\n       gimple_bind_add_seq (dep_bind, dep_olist);\n       pop_gimplify_context (dep_bind);\n     }\n@@ -8830,7 +10387,10 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     case GIMPLE_OMP_TEAMS:\n       ctx = maybe_lookup_ctx (stmt);\n       gcc_assert (ctx);\n-      lower_omp_teams (gsi_p, ctx);\n+      if (gimple_omp_teams_host (as_a <gomp_teams *> (stmt)))\n+\tlower_omp_taskreg (gsi_p, ctx);\n+      else\n+\tlower_omp_teams (gsi_p, ctx);\n       break;\n     case GIMPLE_OMP_GRID_BODY:\n       ctx = maybe_lookup_ctx (stmt);"}, {"sha": "c227dc95ca10265f1e2b269ee117e93e0435067a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,114 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/atomic-17.c: New test.\n+\t* c-c++-common/gomp/atomic-18.c: New test.\n+\t* c-c++-common/gomp/atomic-19.c: New test.\n+\t* c-c++-common/gomp/atomic-20.c: New test.\n+\t* c-c++-common/gomp/atomic-21.c: New test.\n+\t* c-c++-common/gomp/atomic-22.c: New test.\n+\t* c-c++-common/gomp/clauses-1.c (r2): New variable.\n+\t(foo): Add ntm argument and test if and nontemporal clauses on\n+\tconstructs with simd.\n+\t(bar): Put taskloop simd inside of taskgroup with task_reduction,\n+\tuse in_reduction clause instead of reduction.  Add another\n+\ttaskloop simd without nogroup clause, but with reduction clause and\n+\ta new in_reduction.  Add ntm and i3 arguments.  Test if and\n+\tnontemporal clauses on constructs with simd.  Change if clauses on\n+\tsome constructs from specific to the particular constituents to one\n+\twithout a modifier.  Add new tests for combined host teams and for\n+\tnew parallel master and {,parallel }master taskloop{, simd} combined\n+\tconstructs.\n+\t(baz): New function with host teams tests.\n+\t* gcc.dg/gomp/combined-1.c: Moved to ...\n+\t* c-c++-common/gomp/combined-1.c: ... here.  Adjust expected library\n+\tcall.\n+\t* c-c++-common/gomp/combined-2.c: New test.\n+\t* c-c++-common/gomp/combined-3.c: New test.\n+\t* c-c++-common/gomp/critical-1.c: New test.\n+\t* c-c++-common/gomp/critical-2.c: New test.\n+\t* c-c++-common/gomp/default-1.c: New test.\n+\t* c-c++-common/gomp/defaultmap-1.c: New test.\n+\t* c-c++-common/gomp/defaultmap-2.c: New test.\n+\t* c-c++-common/gomp/defaultmap-3.c: New test.\n+\t* c-c++-common/gomp/depend-5.c: New test.\n+\t* c-c++-common/gomp/depend-6.c: New test.\n+\t* c-c++-common/gomp/depend-iterator-1.c: New test.\n+\t* c-c++-common/gomp/depend-iterator-2.c: New test.\n+\t* c-c++-common/gomp/depobj-1.c: New test.\n+\t* c-c++-common/gomp/flush-1.c: New test.\n+\t* c-c++-common/gomp/flush-2.c: New test.\n+\t* c-c++-common/gomp/for-1.c: New test.\n+\t* c-c++-common/gomp/for-2.c: New test.\n+\t* c-c++-common/gomp/for-3.c: New test.\n+\t* c-c++-common/gomp/for-4.c: New test.\n+\t* c-c++-common/gomp/for-5.c: New test.\n+\t* c-c++-common/gomp/for-6.c: New test.\n+\t* c-c++-common/gomp/for-7.c: New test.\n+\t* c-c++-common/gomp/if-1.c (foo): Add some further tests.\n+\t* c-c++-common/gomp/if-2.c (foo): Likewise.  Expect slightly different\n+\tdiagnostics wording in one case.\n+\t* c-c++-common/gomp/if-3.c: New test.\n+\t* c-c++-common/gomp/master-combined-1.c: New test.\n+\t* c-c++-common/gomp/master-combined-2.c: New test.\n+\t* c-c++-common/gomp/nontemporal-1.c: New test.\n+\t* c-c++-common/gomp/nontemporal-2.c: New test.\n+\t* c-c++-common/gomp/reduction-task-1.c: New test.\n+\t* c-c++-common/gomp/reduction-task-2.c: New test.\n+\t* c-c++-common/gomp/requires-1.c: New test.\n+\t* c-c++-common/gomp/requires-2.c: New test.\n+\t* c-c++-common/gomp/requires-3.c: New test.\n+\t* c-c++-common/gomp/requires-4.c: New test.\n+\t* c-c++-common/gomp/schedule-modifiers-1.c (bar): Don't expect\n+\tdiagnostics for nonmonotonic modifier with static, runtime or auto\n+\tschedule kinds.\n+\t* c-c++-common/gomp/simd7.c: New test.\n+\t* c-c++-common/gomp/target-data-1.c: New test.\n+\t* c-c++-common/gomp/taskloop-reduction-1.c: New test.\n+\t* c-c++-common/gomp/taskwait-depend-1.c: New test.\n+\t* c-c++-common/gomp/teams-1.c: New test.\n+\t* c-c++-common/gomp/teams-2.c: New test.\n+\t* gcc.dg/gomp/appendix-a/a.24.1.c: Update from OpenMP examples.  Add\n+\tshared(c) clause.\n+\t* gcc.dg/gomp/atomic-5.c (f1): Add another expected error.\n+\t* gcc.dg/gomp/clause-1.c: Adjust expected diagnostics for const\n+\tqualified vars without mutable member no longer being predeterined\n+\tshared.\n+\t* gcc.dg/gomp/sharing-1.c: Likewise.\n+\t* g++.dg/gomp/clause-3.C: Likewise.\n+\t* g++.dg/gomp/member-2.C: Likewise.\n+\t* g++.dg/gomp/predetermined-1.C: Likewise.\n+\t* g++.dg/gomp/private-1.C: Likewise.\n+\t* g++.dg/gomp/sharing-1.C: Likewise.\n+\t* g++.dg/gomp/sharing-2.C: Likewise.  Add a few tests with aggregate\n+\tconst static data member without mutable elements.\n+\t* gcc.dg/gomp/for-4.c: Expected nonmonotonic functions in the dumps.\n+\t* gcc.dg/gomp/for-5.c: Likewise.\n+\t* gcc.dg/gomp/for-6.c: Change expected library call.\n+\t* gcc.dg/gomp/pr39495-2.c (foo): Don't expect errors on !=.\n+\t* gcc.dg/gomp/reduction-2.c: New test.\n+\t* gcc.dg/gomp/simd-1.c: New test.\n+\t* gcc.dg/gomp/teams-1.c: Adjust expected diagnostic lines.\n+\t* g++.dg/gomp/atomic-18.C: New test.\n+\t* g++.dg/gomp/atomic-19.C: New test.\n+\t* g++.dg/gomp/atomic-5.C (f1): Adjust expected lines of read-only\n+\tvariable messages.  Add another expected error.\n+\t* g++.dg/gomp/critical-3.C: New test.\n+\t* g++.dg/gomp/depend-iterator-1.C: New test.\n+\t* g++.dg/gomp/depend-iterator-2.C: New test.\n+\t* g++.dg/gomp/depobj-1.C: New test.\n+\t* g++.dg/gomp/doacross-1.C: New test.\n+\t* g++.dg/gomp/for-21.C: New test.\n+\t* g++.dg/gomp/for-4.C: Expected nonmonotonic functions in the dumps.\n+\t* g++.dg/gomp/for-5.C: Likewise.\n+\t* g++.dg/gomp/for-6.C: Change expected library call.\n+\t* g++.dg/gomp/loop-4.C: New test.\n+\t* g++.dg/gomp/pr33372-1.C: Adjust location of the expected\n+\tdiagnostics.\n+\t* g++.dg/gomp/pr33372-3.C: Likewise.\n+\t* g++.dg/gomp/pr39495-2.C (foo): Don't expect errors on !=.\n+\t* g++.dg/gomp/simd-2.C: New test.\n+\t* g++.dg/gomp/tpl-atomic-2.C: Adjust expected diagnostic lines.\n+\n 2018-11-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/pr87874.c (em): Declare uint64_max as"}, {"sha": "d313b29f82dc1a216f99533034751b24fee732e1", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-17.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-17.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,29 @@\n+int i, v;\n+float f;\n+\n+void\n+foo ()\n+{\n+  #pragma omp atomic release, hint (0), update\n+  i = i + 1;\n+  #pragma omp atomic hint(0)seq_cst\n+  i = i + 1;\n+  #pragma omp atomic relaxed,update,hint (0)\n+  i = i + 1;\n+  #pragma omp atomic release\n+  i = i + 1;\n+  #pragma omp atomic relaxed\n+  i = i + 1;\n+  #pragma omp atomic acq_rel capture\n+  v = i = i + 1;\n+  #pragma omp atomic capture,acq_rel , hint (1)\n+  v = i = i + 1;\n+  #pragma omp atomic hint(0),acquire capture\n+  v = i = i + 1;\n+  #pragma omp atomic read acquire\n+  v = i;\n+  #pragma omp atomic release,write\n+  i = v;\n+  #pragma omp atomic hint(1),update,release\n+  f = f + 2.0;\n+}"}, {"sha": "95fbcd1a01893fb9555c6c51dce55cd50ff5bfa7", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-18.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,35 @@\n+int i, v;\n+float f;\n+\n+void\n+foo (int j)\n+{\n+  #pragma omp atomic update,update\t/* { dg-error \"too many atomic clauses\" } */\n+  i = i + 1;\n+  #pragma omp atomic seq_cst release\t/* { dg-error \"too many memory order clauses\" } */\n+  i = i + 1;\n+  #pragma omp atomic read,release\t/* { dg-error \"incompatible with 'acq_rel' or 'release' clauses\" } */\n+  v = i;\n+  #pragma omp atomic acq_rel read\t/* { dg-error \"incompatible with 'acq_rel' or 'release' clauses\" } */\n+  v = i;\n+  #pragma omp atomic write acq_rel\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  i = v;\n+  #pragma omp atomic acquire , write\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  i = v;\n+  #pragma omp atomic update ,acquire\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  i = i + 1;\n+  #pragma omp atomic acq_rel update\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  i = i + 1;\n+  #pragma omp atomic acq_rel,hint(0)\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  i = i + 1;\n+  #pragma omp atomic acquire\t\t/* { dg-error \"incompatible with 'acq_rel' or 'acquire' clauses\" } */\n+  i = i + 1;\n+  #pragma omp atomic capture hint (0) capture\t/* { dg-error \"too many atomic clauses\" } */\n+  v = i = i + 1;\n+  #pragma omp atomic hint(j + 2)\t/* { dg-error \"constant integer expression\" } */\n+  i = i + 1;\n+  #pragma omp atomic hint(f)\t\t/* { dg-error \"integ\" } */\n+  i = i + 1;\n+  #pragma omp atomic foobar\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" } */\n+  i = i + 1;\t\t\t\t/* { dg-error \"expected end of line before\" \"\" { target *-*-* } .-1 } */\n+}"}, {"sha": "b15761e2a5be598383409ec40c2c0013d5cbea19", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-19.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-19.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic release\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic relaxed\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic read relaxed\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic capture relaxed\" 1 \"original\" } } */\n+\n+int i, j, k, l, m, n;\n+\n+void\n+foo ()\n+{\n+  int v;\n+  #pragma omp atomic release\n+  i = i + 1;\n+  #pragma omp requires atomic_default_mem_order (relaxed)\n+  #pragma omp atomic\n+  j = j + 1;\n+  #pragma omp atomic update\n+  k = k + 1;\n+  #pragma omp atomic read\n+  v = l;\n+  #pragma omp atomic write\n+  m = v;\n+  #pragma omp atomic capture\n+  v = n = n + 1;\n+}"}, {"sha": "3343d5e92353438a45e430f8eee6047617a4a0c6", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-20.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-20.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic release\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic seq_cst\" 3 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic read seq_cst\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic capture seq_cst\" 1 \"original\" } } */\n+\n+int i, j, k, l, m, n;\n+\n+void\n+foo ()\n+{\n+  int v;\n+  #pragma omp atomic release\n+  i = i + 1;\n+  #pragma omp requires atomic_default_mem_order (seq_cst)\n+  #pragma omp atomic\n+  j = j + 1;\n+  #pragma omp atomic update\n+  k = k + 1;\n+  #pragma omp atomic read\n+  v = l;\n+  #pragma omp atomic write\n+  m = v;\n+  #pragma omp atomic capture\n+  v = n = n + 1;\n+}"}, {"sha": "8fa97b189e90f2be2c0d9b48847af9885a2606ba", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-21.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-21.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic release\" 4 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic read acquire\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp atomic capture acq_rel\" 1 \"original\" } } */\n+\n+int i, j, k, l, m, n;\n+\n+void\n+foo ()\n+{\n+  int v;\n+  #pragma omp atomic release\n+  i = i + 1;\n+  #pragma omp requires atomic_default_mem_order (acq_rel)\n+  #pragma omp atomic\n+  j = j + 1;\n+  #pragma omp atomic update\n+  k = k + 1;\n+  #pragma omp atomic read\n+  v = l;\n+  #pragma omp atomic write\n+  m = v;\n+  #pragma omp atomic capture\n+  v = n = n + 1;\n+}"}, {"sha": "57b0dcbefaec72b4ca1004e45d4229249fd05762", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-22.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-22.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,12 @@\n+int i, j;\n+\n+void\n+foo ()\n+{\n+  int v;\n+  #pragma omp atomic release\n+  i = i + 1;\n+  #pragma omp atomic read\n+  v = j;\n+  #pragma omp requires atomic_default_mem_order (acq_rel)\t/* { dg-error \"'atomic_default_mem_order' clause used lexically after first 'atomic' construct without memory order clause\" } */\n+}"}, {"sha": "652270cc0bdd381a9e1f5348138928cfe5cdbd34", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-1.c", "status": "modified", "additions": 120, "deletions": 20, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -5,11 +5,11 @@ int t;\n #pragma omp threadprivate (t)\n \n #pragma omp declare target\n-int f, l, ll, r;\n+int f, l, ll, r, r2;\n \n void\n foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n-     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q)\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n {\n   #pragma omp distribute parallel for \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n@@ -19,26 +19,50 @@ foo (int d, int m, int i1, int i2, int p, int *idp, int s,\n     ll++;\n   #pragma omp distribute parallel for simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n-    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n-    lastprivate (l) schedule(static, 4) \\\n+    if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) nontemporal(ntm) \\\n     safelen(8) simdlen(4) aligned(q: 32)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp distribute simd \\\n     private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n-    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r)\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n }\n #pragma omp end declare target\n \n void\n-bar (int d, int m, int i1, int i2, int p, int *idp, int s,\n-     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd)\n+baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int ntm)\n+{\n+  #pragma omp distribute parallel for \\\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute parallel for simd \\\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) nontemporal(ntm) \\\n+    safelen(8) simdlen(4) aligned(q: 32) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp distribute simd \\\n+    private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) \\\n+    safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+}\n+\n+void\n+bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n+     int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm)\n {\n   #pragma omp for simd \\\n     private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) nowait \\\n-    safelen(8) simdlen(4) aligned(q: 32)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel for \\\n@@ -47,9 +71,9 @@ bar (int d, int m, int i1, int i2, int p, int *idp, int s,\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel for simd \\\n-    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n+    private (p) firstprivate (f) if (i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n-    safelen(8) simdlen(4) aligned(q: 32)\n+    safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp parallel sections \\\n@@ -76,7 +100,7 @@ bar (int d, int m, int i1, int i2, int p, int *idp, int s,\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0])\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams \\\n@@ -103,31 +127,38 @@ bar (int d, int m, int i1, int i2, int p, int *idp, int s,\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0])\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm) if (simd: i3)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target teams distribute simd \\\n-    device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+    device(d) map (tofrom: m) if (i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n-    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0])\n+    safelen(8) simdlen(4) aligned(q: 32) nowait depend(inout: dd[0]) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target simd \\\n     device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n     safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) \\\n-     nowait depend(inout: dd[0])\n+     nowait depend(inout: dd[0]) nontemporal(ntm) if(simd:i3)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup task_reduction(+:r2)\n+  #pragma omp taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp taskgroup task_reduction(+:r)\n   #pragma omp taskloop simd \\\n-    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable nogroup priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r)\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(i1) final(fi) mergeable nogroup priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskwait\n   #pragma omp taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) final(fi) priority (pp) \\\n-    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target nowait depend(inout: dd[0])\n@@ -150,14 +181,83 @@ bar (int d, int m, int i1, int i2, int p, int *idp, int s,\n     collapse(1) dist_schedule(static, 16) \\\n     if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n     lastprivate (l) schedule(static, 4) \\\n-    safelen(8) simdlen(4) aligned(q: 32)\n+    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp target\n   #pragma omp teams distribute simd \\\n     private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n     collapse(1) dist_schedule(static, 16) \\\n-    safelen(8) simdlen(4) aligned(q: 32)\n+    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute parallel for \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute parallel for simd \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    if (parallel: i2) num_threads (nth) proc_bind(spread) \\\n+    lastprivate (l) schedule(static, 4) \\\n+    safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp teams distribute simd \\\n+    private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) \\\n+    collapse(1) dist_schedule(static, 16) \\\n+    safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) \\\n+    num_threads (nth) proc_bind(spread) copyin(t)\n+    ;\n+  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp master taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) in_reduction(+:r2)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp master taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp master taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) in_reduction(+:r2)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup task_reduction (+:r2)\n+  #pragma omp master taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp parallel master taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t)\n   for (int i = 0; i < 64; i++)\n     ll++;\n }"}, {"sha": "4d62844cd2a55696bcd9b76856067a66ad98213b", "filename": "gcc/testsuite/c-c++-common/gomp/combined-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fopenmp -fdump-tree-optimized\" } */\n+\n+int a[10];\n+void foo (void)\n+{\n+    int i;\n+#pragma omp parallel for schedule(runtime)\n+    for (i = 0; i < 10; i++)\n+      a[i] = i;\n+#pragma omp parallel\n+#pragma omp for schedule(runtime)\n+    for (i = 0; i < 10; i++)\n+      a[i] = 10 - i;\n+#pragma omp parallel\n+      {\n+#pragma omp for schedule(runtime)\n+\tfor (i = 0; i < 10; i++)\n+\t  a[i] = i;\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_maybe_nonmonotonic_runtime\" 3 \"optimized\" } } */"}, {"sha": "82bc4dfb8b85220a424a8e3c760c077741c9179f", "filename": "gcc/testsuite/c-c++-common/gomp/combined-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fopenmp -fdump-tree-optimized\" } */\n+\n+int a[10];\n+void foo (void)\n+{\n+    int i;\n+#pragma omp parallel for schedule(monotonic:runtime)\n+    for (i = 0; i < 10; i++)\n+      a[i] = i;\n+#pragma omp parallel\n+#pragma omp for schedule(monotonic :runtime)\n+    for (i = 0; i < 10; i++)\n+      a[i] = 10 - i;\n+#pragma omp parallel\n+      {\n+#pragma omp for schedule(monotonic: runtime)\n+\tfor (i = 0; i < 10; i++)\n+\t  a[i] = i;\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_runtime\" 3 \"optimized\" } } */"}, {"sha": "33c988471f2b6ae45fa75f6584c8e64376697be2", "filename": "gcc/testsuite/c-c++-common/gomp/combined-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcombined-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fopenmp -fdump-tree-optimized\" } */\n+\n+int a[10];\n+void foo (void)\n+{\n+    int i;\n+#pragma omp parallel for schedule(nonmonotonic:runtime)\n+    for (i = 0; i < 10; i++)\n+      a[i] = i;\n+#pragma omp parallel\n+#pragma omp for schedule(nonmonotonic :runtime)\n+    for (i = 0; i < 10; i++)\n+      a[i] = 10 - i;\n+#pragma omp parallel\n+      {\n+#pragma omp for schedule(nonmonotonic: runtime)\n+\tfor (i = 0; i < 10; i++)\n+\t  a[i] = i;\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_nonmonotonic_runtime\" 3 \"optimized\" } } */"}, {"sha": "8d607e4d57e274414cac5d57c4f7ce2bb831a5c5", "filename": "gcc/testsuite/c-c++-common/gomp/critical-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcritical-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcritical-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcritical-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,14 @@\n+int i;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp critical\n+  i = i + 1;\n+  #pragma omp critical (foo)\n+  i = i + 1;\n+  #pragma omp critical (foo) hint (0)\n+  i = i + 1;\n+  #pragma omp critical (foo),hint(1)\n+  i = i + 1;\n+}"}, {"sha": "f501cc1816f4a0da2baf290c233562e0a98c5ae6", "filename": "gcc/testsuite/c-c++-common/gomp/critical-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcritical-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcritical-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcritical-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,10 @@\n+int i;\n+\n+void\n+foo (int j)\n+{\n+  #pragma omp critical (foo) hint (j + 1)\t/* { dg-error \"constant integer expression\" } */\n+  i = i + 1;\n+  #pragma omp critical (foo),hint(j)\t\t/* { dg-error \"constant integer expression\" } */\n+  i = i + 1;\n+}"}, {"sha": "6525483c44e75fd1de4e63d4f064f315c3268fc8", "filename": "gcc/testsuite/c-c++-common/gomp/default-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefault-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefault-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefault-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,22 @@\n+void\n+foo (void)\n+{\n+  int x = 0, i;\n+  #pragma omp task default(none)\t/* { dg-error \"enclosing 'task'\" } */\n+  {\n+    x++;\t/* { dg-error \"'x' not specified in enclosing 'task'\" } */\n+  }\n+  #pragma omp taskloop default(none)\t/* { dg-error \"enclosing 'taskloop'\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      x++;\t/* { dg-error \"'x' not specified in enclosing 'taskloop'\" } */\n+    }\n+  #pragma omp teams default(none)\t/* { dg-error \"enclosing 'teams'\" } */\n+  {\n+    x++;\t/* { dg-error \"'x' not specified in enclosing 'teams'\" } */\n+  }\n+  #pragma omp parallel default(none)\t/* { dg-error \"enclosing 'parallel'\" } */\n+  {\n+    x++;\t/* { dg-error \"'x' not specified in enclosing 'parallel'\" } */\n+  }\n+}"}, {"sha": "80a111cc114e38f6f065640e643bd3d270e60a57", "filename": "gcc/testsuite/c-c++-common/gomp/defaultmap-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,30 @@\n+void\n+foo (void)\n+{\n+  #pragma omp target defaultmap(alloc) defaultmap(alloc)\t/* { dg-error \"too many 'defaultmap' clauses with unspecified category\" } */\n+  ;\n+  #pragma omp target defaultmap(to) defaultmap(from)\t\t/* { dg-error \"too many 'defaultmap' clauses with unspecified category\" } */\n+  ;\n+  #pragma omp target defaultmap(tofrom) defaultmap(firstprivate:scalar)\t/* { dg-error \"too many 'defaultmap' clauses with 'scalar' category\" } */\n+  ;\n+  #pragma omp target defaultmap(none:aggregate) defaultmap(alloc:scalar) defaultmap(none:scalar) /* { dg-error \"too many 'defaultmap' clauses with 'scalar' category\" } */\n+  ;\n+  #pragma omp target defaultmap(none : pointer) defaultmap ( none ) /* { dg-error \"too many 'defaultmap' clauses with 'pointer' category\" } */\n+  ;\n+  #pragma omp target defaultmap()\t\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(for)\t\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(blah)\t\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(tofrom:)\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(tofrom scalar)\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(tofrom,scalar)\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(default ;)\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp target defaultmap(default : qux)\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+}"}, {"sha": "75dca2308624e967acf25fd6152592c8edd67a8b", "filename": "gcc/testsuite/c-c++-common/gomp/defaultmap-2.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,131 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+struct S { int s; };\n+void foo (char *);\n+void bar (int, char *, struct S, int *);\n+#pragma omp declare target to (bar)\n+#define N 16\n+\n+void\n+f1 (int sc1, struct S ag1, int *pt1)\n+{\n+  char ar1[N];\n+  foo (ar1);\n+  #pragma omp target\n+  bar (sc1, ar1, ag1, pt1);\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(sc1\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:ar1\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:ag1\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(firstprivate:pt1 .pointer assign\" \"gimple\" } } */\n+}\n+\n+void\n+f2 (int sc2, struct S ag2, int *pt2)\n+{\n+  char ar2[N];\n+  foo (ar2);\n+  #pragma omp target firstprivate (sc2, ar2, ag2, pt2) defaultmap (none)\n+  bar (sc2, ar2, ag2, pt2);\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(sc2\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(ar2\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(ag2\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(pt2\\\\)\" \"gimple\" } } */\n+}\n+\n+void\n+f3 (int sc3, struct S ag3, int *pt3)\n+{\n+  char ar3[N];\n+  foo (ar3);\n+  #pragma omp target defaultmap(none:scalar) defaultmap(none:aggregate) \\\n+\t\t     map (sc3, ar3, ag3, pt3) defaultmap(none:pointer)\n+  bar (sc3, ar3, ag3, pt3);\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:sc3\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:ar3\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:ag3\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:pt3\" \"gimple\" } } */\n+}\n+\n+void\n+f4 (int sc4, struct S ag4, int *pt4)\n+{\n+  char ar4[N];\n+  foo (ar4);\n+  #pragma omp target defaultmap(tofrom:scalar)\n+  bar (sc4, ar4, ag4, pt4);\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:sc4\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:ar4\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:ag4\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(firstprivate:pt4 .pointer assign\" \"gimple\" } } */\n+}\n+\n+void\n+f5 (int sc5, struct S ag5, int *pt5)\n+{\n+  char ar5[N];\n+  foo (ar5);\n+  #pragma omp target defaultmap(to)\n+  bar (sc5, ar5, ag5, pt5);\n+/* { dg-final { scan-tree-dump \"map\\\\(to:sc5\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(to:ar5\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(to:ag5\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(to:pt5\" \"gimple\" } } */\n+}\n+\n+void\n+f6 (int sc6, struct S ag6, int *pt6)\n+{\n+  char ar6[N];\n+  foo (ar6);\n+  #pragma omp target defaultmap(firstprivate)\n+  bar (sc6, ar6, ag6, pt6);\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(sc6\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(ar6\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(ag6\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(pt6\\\\)\" \"gimple\" } } */\n+}\n+\n+void\n+f7 (int sc7, struct S ag7, int *pt7)\n+{\n+  char ar7[N];\n+  foo (ar7);\n+  #pragma omp target defaultmap(alloc: scalar) defaultmap(from: aggregate) defaultmap(default: pointer)\n+  {\n+    int *q = &sc7;\n+    *q = 6;\n+    ag7.s = 5;\n+    int i;\n+    for (i = 0; i < N; ++i)\n+      ar7[i] = 7;\n+    bar (sc7, ar7, ag7, pt7);\n+  }\n+/* { dg-final { scan-tree-dump \"map\\\\(alloc:sc7\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(from:ar7\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(from:ag7\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(firstprivate:pt7 .pointer assign\" \"gimple\" } } */\n+}\n+\n+void\n+f8 (int sc8, struct S ag8, int *pt8)\n+{\n+  char ar8[N];\n+  foo (ar8);\n+  #pragma omp target defaultmap(firstprivate:aggregate) defaultmap(none:scalar) \\\n+\t\t     defaultmap(tofrom:pointer) map(to: sc8)\n+  bar (sc8, ar8, ag8, pt8);\n+/* { dg-final { scan-tree-dump \"map\\\\(to:sc8\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(ar8\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(ag8\\\\)\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"map\\\\(tofrom:pt8\" \"gimple\" } } */\n+}\n+\n+void\n+f9 (int sc9, struct S ag9)\n+{\n+  char ar9[sc9 + 2];\n+  foo (ar9);\n+  #pragma omp target defaultmap(none) map(to: ar9, ag9) firstprivate (sc9)\n+  bar (sc9, ar9, ag9, &sc9);\n+}"}, {"sha": "2f5b303958f4483f93e272ec1dbefc0a2461d010", "filename": "gcc/testsuite/c-c++-common/gomp/defaultmap-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdefaultmap-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+\n+struct S { int s; };\n+void foo (char *);\n+void bar (int, char *, struct S, int *);\n+#pragma omp declare target to (bar)\n+#define N 16\n+\n+void\n+f1 (int sc1, struct S ag1, int *pt1)\n+{\n+  char ar1[N];\n+  foo (ar1);\n+  #pragma omp target defaultmap(default:scalar) defaultmap(to:aggregate) defaultmap(none:pointer)\t/* { dg-error \"enclosing 'target'\" } */\n+  bar (sc1, ar1, ag1, pt1);\t/* { dg-error \"'pt1' not specified in enclosing 'target'\" } */\n+}\n+\n+void\n+f2 (int sc2, struct S ag2, int *pt2)\n+{\n+  char ar2[N];\n+  foo (ar2);\n+  #pragma omp target defaultmap(none:scalar) defaultmap(from:aggregate) defaultmap(default:pointer)\t/* { dg-error \"enclosing 'target'\" } */\n+  bar (sc2, ar2, ag2, pt2);\t/* { dg-error \"'sc2' not specified in enclosing 'target'\" } */\n+}\n+\n+void\n+f3 (int sc3, struct S ag3, int *pt3)\n+{\n+  char ar3[N];\n+  foo (ar3);\n+  #pragma omp target defaultmap(firstprivate:scalar) defaultmap(none:aggregate) defaultmap(to:pointer)\t/* { dg-error \"enclosing 'target'\" } */\n+  bar (sc3, ar3, ag3, pt3);\t/* { dg-error \"'ar3' not specified in enclosing 'target'\" } */\n+}\t\t\t\t/* { dg-error \"'ag3' not specified in enclosing 'target'\" \"\" { target *-*-* } .-1 } */"}, {"sha": "993987f0a31b9033944e672cc72dd651993ca471", "filename": "gcc/testsuite/c-c++-common/gomp/depend-5.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-5.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct T { int c[3]; };\n+struct S { int a; struct T *b; struct T g; };\n+struct S d[10];\n+struct S *e[10];\n+struct S *f;\n+struct S h;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp task depend(inout: d)\n+  ;\n+  #pragma omp task depend(out: d[2])\n+  ;\n+  #pragma omp task depend(in: d[:])\n+  ;\n+  #pragma omp task depend(in: d[2:2])\n+  ;\n+  #pragma omp task depend(in: d[:2])\n+  ;\n+  #pragma omp task depend(inout: d[1].b->c[2])\n+  ;\n+  #pragma omp task depend(out: d[0].a)\n+  ;\n+  #pragma omp task depend(in: e[3]->a)\n+  ;\n+  #pragma omp task depend(inout: e[2]->b->c)\n+  ;\n+  #pragma omp task depend(in: e[1]->b->c[2])\n+  ;\n+  #pragma omp task depend(out: (*f).a)\n+  ;\n+  #pragma omp task depend(inout: f->b->c[0])\n+  ;\n+  #pragma omp task depend(in: f)\n+  ;\n+  #pragma omp task depend(out: *f)\n+  ;\n+  #pragma omp task depend(inout: f[0])\n+  ;\n+  #pragma omp task depend(in: f[0].a)\n+  ;\n+  #pragma omp task depend(inout: h.g.c[2])\n+  ;\n+}"}, {"sha": "4684653a06666323577d2b8286e77faa6d8bf2b2", "filename": "gcc/testsuite/c-c++-common/gomp/depend-6.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-6.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct T { int c[3]; };\n+struct S { int a; struct T *b; struct T g; };\n+struct U { int a : 5; };\n+struct S d[10];\n+struct S *e[10];\n+struct S *f;\n+struct S h;\n+struct U i;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp task depend(in: d[:2].b->c[2])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(inout: d[1:].b->c[2])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(out: d[0:1].a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(in: e[3:2]->a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(inout: e[2:2]->b->c)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(in: e[1]->b->c[2:1])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(out: f + 0)\t\t/* { dg-error \"not lvalue expression\" } */\n+  ;\n+  #pragma omp task depend(inout: f[0:1].a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(inout: h.g.c[2:1])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(in: i.a)\t\t/* { dg-error \"bit-field '\\[^\\n\\r]*' in 'depend' clause\" } */\n+  ;\n+}"}, {"sha": "4fb01c174ec29fb7abb82b78c94f89a63db14e00", "filename": "gcc/testsuite/c-c++-common/gomp/depend-iterator-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-iterator-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-iterator-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-iterator-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,75 @@\n+int arr[64], arr2[64];\n+struct S { int a[4]; } k;\n+short arr4[4];\n+volatile int v;\n+#define TEST_EQ(x,y) ({ int o[x == y ? 1 : -1]; 0; })\n+\n+void\n+foo (unsigned char i, signed char j)\n+{\n+  #pragma omp task depend (iterator (j=6:2:-2) , out : \\\n+\tarr[TEST_EQ (sizeof (j), sizeof (int)), \\\n+\t    TEST_EQ (sizeof (i), sizeof (unsigned char)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (struct S)), j], \\\n+\tarr2[TEST_EQ (((__typeof (j)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (i)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (k.a[0])) -1) < 0, 1), j]) \\\n+\tdepend(out: arr[0]) \\\n+\tdepend (iterator (long long i=__LONG_LONG_MAX__ - 4:__LONG_LONG_MAX__ - 2:2, \\\n+\t\t\t  unsigned short j=~0U-16:~0U-8:3, \\\n+\t\t\t  short *k=&arr4[1]:&arr4[2]:1) , in : \\\n+\tarr[TEST_EQ (sizeof (i), sizeof (long long)), \\\n+\t    TEST_EQ (sizeof (j), sizeof (unsigned short)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (short *)), \\\n+\t    TEST_EQ (sizeof (*k), sizeof (short)), i - __LONG_LONG_MAX__ + 4], \\\n+\tarr2[TEST_EQ (((__typeof (i)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (j)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (*k)) -1) < 0, 1), j - (~0U-16)], \\\n+\tarr2[k - &arr4[0]]) \\\n+\tdepend(in : k)\n+    v++;\n+}\n+\n+void\n+bar (unsigned char i, signed char j)\n+{\n+  int m = j;\n+  int n = j + 2;\n+  #pragma omp task depend (iterator (j=6:2:m) , out : \\\n+\tarr[TEST_EQ (sizeof (j), sizeof (int)), \\\n+\t    TEST_EQ (sizeof (i), sizeof (unsigned char)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (struct S)), j], \\\n+\tarr2[TEST_EQ (((__typeof (j)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (i)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (k.a[0])) -1) < 0, 1), j]) \\\n+\tdepend(out: arr[0]) \\\n+\tdepend (iterator (long long i=__LONG_LONG_MAX__ - 4 - n:__LONG_LONG_MAX__ - 2:2, \\\n+\t\t\t  unsigned short j=~0U-16:~0U-8-n:3, \\\n+\t\t\t  short *k=&arr4[1]:&arr4[n + 2]:1) , in : \\\n+\tarr[TEST_EQ (sizeof (i), sizeof (long long)), \\\n+\t    TEST_EQ (sizeof (j), sizeof (unsigned short)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (short *)), \\\n+\t    TEST_EQ (sizeof (*k), sizeof (short)), i - __LONG_LONG_MAX__ + 4], \\\n+\tarr2[TEST_EQ (((__typeof (i)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (j)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (*k)) -1) < 0, 1), j - (~0U-16)], \\\n+\tarr2[k - &arr4[0]:10]) \\\n+\tdepend(in : k)\n+    v++;\n+}\n+\n+void\n+baz (void)\n+{\n+  #pragma omp parallel\n+  #pragma omp master\n+  {\n+    #pragma omp task depend(iterator(unsigned long int k = 0 : 2) , inout : \\\n+\tarr[TEST_EQ (sizeof (k), sizeof (unsigned long)), \\\n+\t    TEST_EQ (((__typeof (k)) -1) < 0, 0), k]) \\\n+\tdepend(iterator(signed char s = -3 : -12 : -1) , out : \\\n+\tarr[TEST_EQ (sizeof (s), sizeof (signed char)), \\\n+\t    TEST_EQ (((__typeof (s)) -1) < 0, 1), s + 12])\n+      v++;\n+  }\n+}"}, {"sha": "127528271ee968ddfe45674a170bf6dca583a674", "filename": "gcc/testsuite/c-c++-common/gomp/depend-iterator-2.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-iterator-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-iterator-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-iterator-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,97 @@\n+int a, b[64];\n+struct S { int c; } *d, *e;\n+struct T;\n+struct T *f, *g;\n+int *h;\n+\n+void\n+f1 (void)\n+{\n+  #pragma omp task depend (iterator , in : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (for = 0 : 2) , in : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (5 = 0 : 2) , in : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (i : 0 : 2) , in : a)\t/* { dg-error \"expected '='|name a type|expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0, 1 : 2) , in : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = (0, 1) : 2) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (i = 0 : 1 : 2 : 3) , in : a)\t/* { dg-error \"expected '.'\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0 : 2, 3) , in : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0 : 10 : 2, 3) , in : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0:1), iterator (j = 0:1) , in : a)\t/* { dg-error \"invalid depend kind\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0:32) , in : b[i*2:2])\n+  ;\n+  #pragma omp task depend (iterator (struct S i = 0:1), in : a)\t\t/* { dg-error \"iterator 'i' has neither integral nor pointer type\" } */\n+  ;\n+  #pragma omp task depend (iterator (void i = 0:1) , in : a)\t\t/* { dg-error \"iterator 'i' has neither integral nor pointer type\" } */\n+  ;\n+  #pragma omp task depend (iterator (float f = 0.2:0.4) , in : a)\t/* { dg-error \"iterator 'f' has neither integral nor pointer type\" } */\n+  ;\n+  #pragma omp task depend (iterator (struct S *p = d:e:2) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (struct T *p = f:g) , in : a)\t/* { dg-error \"invalid use of\" } */\n+  ;\n+  #pragma omp task depend (iterator (int i = 0:4, \\\n+\t\t\t\t     struct U { int (*p)[i + 2]; } *p = 0:2) , in : a)\t/* { dg-error \"type of iterator 'p' refers to outer iterator 'i'\" \"\" { target c } } */\n+  ;\t\t\t\t\t\t\t\t\t/* { dg-error \"types may not be defined in iterator type|not an integer constant\" \"\" { target c++ } .-1 } */\n+  #pragma omp task depend (iterator (i = 0:4, j = i:16) , in : a)\t/* { dg-error \"begin expression refers to outer iterator 'i'\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0:4, j = 2:i:1) , in : a)\t/* { dg-error \"end expression refers to outer iterator 'i'\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 0:4, j = 2:8:i) , in : a)\t/* { dg-error \"step expression refers to outer iterator 'i'\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = *d:2) , in : a)\t/* { dg-error \"aggregate value used where an integer was expected\" \"\" { target c } } */\n+  ;\t\t\t\t\t\t\t\t/* { dg-error \"invalid cast from type 'S' to type 'int'\" \"\" { target c++ } .-1 } */\n+  #pragma omp task depend (iterator (i = 2:*d:2) , in : a)\t/* { dg-error \"aggregate value used where an integer was expected\" \"\" { target c } } */\n+  ;\t\t\t\t\t\t\t\t/* { dg-error \"invalid cast from type 'S' to type 'int'\" \"\" { target c++ } .-1 } */\n+  #pragma omp task depend (iterator (i = 2:4:*d) , in : a)\t/* { dg-error \"iterator step with non-integral type\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 1.25:2.5:3) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (i = 1:2:3.5) , in : a)\t/* { dg-error \"iterator step with non-integral type\" } */\n+  ;\n+  #pragma omp task depend (iterator (int *p = 23 : h) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (short i=1:3:0) , in : a)\t/* { dg-error \"iterator 'i' has zero step\" } */\n+  ;\n+  #pragma omp task depend (iterator (i = 1 : 3 : 3 - 3) , in : a)\t/* { dg-error \"iterator 'i' has zero step\" } */\n+  ;\n+  #pragma omp task depend (iterator (int *p = &b[6]:&b[9]:4 - 4) , in : a)\t/* { dg-error \"iterator 'p' has zero step\" } */\n+  ;\n+  #pragma omp task depend (iterator (const int i = 0 : 2) , in : a)\t/* { dg-error \"const qualified\" } */\n+  ;\n+  #pragma omp task depend (iterator (const long long unsigned i = 0 : 2) , in : a)\t/* { dg-error \"const qualified\" } */\n+  ;\n+#if !defined (__cplusplus) && __STDC_VERSION__ >= 201112L\n+  #pragma omp task depend (iterator (_Atomic unsigned i = 0 : 2) , in : a)\t/* { dg-error \"_Atomic\" \"\" { target c } } */\n+  ;\n+#endif\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i, j;\n+  #pragma omp for ordered(2)\n+  for (i = 0; i < 64; i++)\n+    for (j = 0; j < 64; j++)\n+      {\n+      #pragma omp ordered depend (iterator (k=0:1) , sink: i - 1, j - 1)\t/* { dg-error \"'iterator' modifier incompatible with 'sink'\" } */\n+      #pragma omp ordered depend (iterator (int l = 0:2:3) , source)\t\t/* { dg-error \"'iterator' modifier incompatible with 'source'\" } */\n+      }\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp task depend (iterator (i = 0:1), iterator (j = 0:1) , in : a)\t/* { dg-error \"invalid depend kind\" } */\n+  ;\n+}"}, {"sha": "688371b623203c0b8c090f46d5043683fa91c978", "filename": "gcc/testsuite/c-c++-common/gomp/depobj-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepobj-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepobj-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepobj-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,63 @@\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+omp_depend_t bar (void);\n+extern const omp_depend_t cdepobj;\n+extern omp_depend_t depobj;\n+extern omp_depend_t depobja[4];\n+extern omp_depend_t *pdepobj;\n+int a, b, i, j;\n+\n+void\n+f1 (void)\n+{\n+  #pragma omp depobj(depobj) depend(in : a)\n+  #pragma omp depobj(depobj) update(inout)\n+  #pragma omp task depend (depobj: depobj)\n+  ;\n+  #pragma omp depobj(depobj) destroy\n+  #pragma omp task depend (iterator (i=1:3) , depobj: *(depobja + i))\n+  ;\n+  #pragma omp depobj(pdepobj[0]) depend(mutexinoutset:a)\n+  #pragma omp depobj(*pdepobj) destroy\n+}\n+\n+void\n+f2 (void)\n+{\n+  omp_depend_t depobjb[4];\n+  #pragma omp depobj\t\t\t\t\t/* { dg-error \"expected\" } */\n+  #pragma omp depobj destroy\t\t\t\t/* { dg-error \"expected\" } */\n+  #pragma omp depobj (depobj)\t\t\t\t/* { dg-error \"expected 'depend', 'destroy' or 'update' clause\" } */\n+  #pragma omp depobj (depobj) foobar\t\t\t/* { dg-error \"expected 'depend', 'destroy' or 'update' clause\" } */\n+  #pragma omp depobj(bar ()) update(inout)\t\t/* { dg-error \"'depobj' expression is not lvalue expression\" } */\n+  #pragma omp depobj (cdepobj) update(in)\t\t/* { dg-error \"'const' qualified 'depobj' expression\" } */\n+  #pragma omp depobj (depobjb) depend(in: a)\t\t/* { dg-error \"type of 'depobj' expression is not 'omp_depend_t'\" } */\n+  #pragma omp depobj (pdepobj) depend(in: a)\t\t/* { dg-error \"type of 'depobj' expression is not 'omp_depend_t'\" } */\n+  #pragma omp depobj (a) destroy\t\t\t/* { dg-error \"type of 'depobj' expression is not 'omp_depend_t'\" } */\n+  #pragma omp depobj (depobj) depend(depobj:a)\t\t/* { dg-error \"does not have 'omp_depend_t' type in 'depend' clause with 'depobj' dependence type\" } */\n+  #pragma omp depobj (depobj) depend(depobj:*depobjb)\t/* { dg-error \"'depobj' dependence type specified in 'depend' clause on 'depobj' construct\" } */\n+  #pragma omp depobj (depobj) update(foobar)\t\t/* { dg-error \"expected 'in', 'out', 'inout' or 'mutexinoutset'\" } */\n+  #pragma omp depobj (depobj) depend(in: *depobja)\t/* { dg-error \"should not have 'omp_depend_t' type in 'depend' clause with dependence type\" } */\n+  #pragma omp depobj (depobj) depend(in: a) depend(in: b)\t/* { dg-error \"expected\" } */\n+  #pragma omp depobj (depobj) depend(in: a) update(out)\t/* { dg-error \"expected\" } */\n+  #pragma omp depobj (depobj) depend(in: a, b)\t\t/* { dg-error \"more than one locator in 'depend' clause on 'depobj' construct\" } */\n+  #pragma omp depobj (depobj) depend(source)\t\t/* { dg-error \"'depend\\\\(source\\\\)' is only allowed in 'omp ordered'\" } */\n+  #pragma omp depobj (depobj) depend(sink: i + 1, j - 1)\t/* { dg-error \"'depend\\\\(sink\\\\)' is only allowed in 'omp ordered'\" } */\n+  #pragma omp depobj (depobj) depend(iterator (i = 0:2) , in : a)\t/* { dg-error \"'iterator' modifier may not be specified on 'depobj' construct\" } */\n+  if (0)\n+    #pragma omp depobj (depobj) destroy\t\t\t/* { dg-error \"'#pragma omp depobj' may only be used in compound statements\" } */\n+    ;\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp task depend (depobj: depobja[1:2])\t/* { dg-error \"'depend' clause with 'depobj' dependence type on array section\" } */\n+  ;\n+  #pragma omp task depend (depobj: a)\t\t\t/* { dg-error \"'a' does not have 'omp_depend_t' type in 'depend' clause with 'depobj' dependence type\" } */\n+  ;\n+  #pragma omp task depend (in: depobj)\t\t\t/* { dg-error \"'depobj' should not have 'omp_depend_t' type in 'depend' clause with dependence type\" } */\n+  ;\n+}"}, {"sha": "7c3e5294a051e78a8b127c246ea3b8874512f3fc", "filename": "gcc/testsuite/c-c++-common/gomp/flush-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fflush-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fflush-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fflush-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+/* { dg-final { scan-tree-dump \"foo \\\\(4\\\\);\\[\\n\\r]*  __atomic_thread_fence \\\\(4\\\\);\\[\\n\\r]*  foo \\\\(4\\\\);\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"foo \\\\(3\\\\);\\[\\n\\r]*  __atomic_thread_fence \\\\(3\\\\);\\[\\n\\r]*  foo \\\\(3\\\\);\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"foo \\\\(2\\\\);\\[\\n\\r]*  __atomic_thread_fence \\\\(2\\\\);\\[\\n\\r]*  foo \\\\(2\\\\);\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"foo \\\\(5\\\\);\\[\\n\\r]*  __sync_synchronize \\\\(\\\\);\\[\\n\\r]*  foo \\\\(5\\\\);\" \"gimple\" } } */\n+\n+void foo (int);\n+\n+void\n+f1 (void)\n+{\n+  foo (4);\n+  #pragma omp flush acq_rel\n+  foo (4);\n+}\n+\n+void\n+f2 (void)\n+{\n+  foo (3);\n+  #pragma omp flush release\n+  foo (3);\n+}\n+\n+void\n+f3 (void)\n+{\n+  foo (2);\n+  #pragma omp flush acquire\n+  foo (2);\n+}\n+\n+void\n+f4 (void)\n+{\n+  foo (5);\n+  #pragma omp flush\n+  foo (5);\n+}"}, {"sha": "00baa8ac67f8f93126172d96b016b69879a7191d", "filename": "gcc/testsuite/c-c++-common/gomp/flush-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fflush-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fflush-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fflush-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,17 @@\n+int a, b;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp flush\n+  #pragma omp flush (a, b)\n+  #pragma omp flush acquire\n+  #pragma omp flush release\n+  #pragma omp flush acq_rel\n+  #pragma omp flush relaxed\t\t/* { dg-error \"expected 'acq_rel', 'release' or 'acquire'\" } */\n+  #pragma omp flush seq_cst\t\t/* { dg-error \"expected 'acq_rel', 'release' or 'acquire'\" } */\n+  #pragma omp flush foobar\t\t/* { dg-error \"expected 'acq_rel', 'release' or 'acquire'\" } */\n+  #pragma omp flush acquire (a, b)\t/* { dg-error \"'flush' list specified together with memory order clause\" } */\n+  #pragma omp flush release (a, b)\t/* { dg-error \"'flush' list specified together with memory order clause\" } */\n+  #pragma omp flush acq_rel (a, b)\t/* { dg-error \"'flush' list specified together with memory order clause\" } */\n+}"}, {"sha": "a0e498b58572b9e22c74d70d27814f5bf52f857c", "filename": "gcc/testsuite/c-c++-common/gomp/for-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,60 @@\n+void bar (int);\n+\n+int a[256];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i != 64; i++)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i--)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 0; i != 64; i = i + 1)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i = i - 1)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 0; i != 64; i = 1 + i)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i = -1 + i)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 0; i != 64; i += 1)\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i -= 1)\n+    bar (i);\n+  #pragma omp single\n+  {\n+    #pragma omp simd\n+    for (i = 0; i != 64; i++)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i--)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 0; i != 64; i = i + 1)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i = i - 1)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 0; i != 64; i = 1 + i)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i = -1 + i)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 0; i != 64; i += 1)\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i -= 1)\n+      a[i] = a[i] + 1;\n+  }\n+}"}, {"sha": "98dfe21d7884fc06146a0eddc66cbd7156268433", "filename": "gcc/testsuite/c-c++-common/gomp/for-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,31 @@\n+void bar (short *);\n+\n+void\n+foo (short *q, short *r, short *s)\n+{\n+  short *p;\n+  #pragma omp for\n+  for (p = q; p != r; p++)\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p--)\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = p + 1)\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = p - 1)\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = 1 + p)\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = -1 + p)\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p += 1)\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p -= 1)\n+    bar (p);\n+}"}, {"sha": "c3c57e4ed47f843888c386c8bca5344c6517a3e3", "filename": "gcc/testsuite/c-c++-common/gomp/for-3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,48 @@\n+void bar (int);\n+\n+int a[256];\n+\n+void\n+foo (int j)\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i != 64; i = i + 4)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i = i - 4)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (i);\n+  #pragma omp for\n+  for (i = 0; i != 64; i = j + i)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i = -16 + i)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (i);\n+  #pragma omp for\n+  for (i = 0; i != 64; i += j)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (i);\n+  #pragma omp for\n+  for (i = 128; i != 64; i -= 8)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (i);\n+  #pragma omp single\n+  {\n+    #pragma omp simd\n+    for (i = 0; i != 64; i = i + 16)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i = i - 2)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 0; i != 64; i = j + i)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i = -j + i)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 0; i != 64; i += 8)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+      a[i] = a[i] + 1;\n+    #pragma omp simd\n+    for (i = 128; i != 64; i -= j)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+      a[i] = a[i] + 1;\n+  }\n+}"}, {"sha": "53d5260a095d38244b96d57f6058d1a92c996764", "filename": "gcc/testsuite/c-c++-common/gomp/for-4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-4.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,25 @@\n+void bar (short *);\n+\n+void\n+foo (short *q, short *r, short *s, long t)\n+{\n+  short *p;\n+  #pragma omp for\n+  for (p = q; p != r; p = p + 5)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = p - 2)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = t + p)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = -t + p)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p += t)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p -= 7)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+}"}, {"sha": "6a1d1db8be3a16ee39a2081d5c8b8f207237543d", "filename": "gcc/testsuite/c-c++-common/gomp/for-5.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-5.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-fopenmp\" }\n+\n+void bar (void *);\n+\n+__attribute__((noinline, noclone)) void\n+foo (void *qx, void *rx, void *sx, int n)\n+{\n+  unsigned short (*q)[n], (*r)[n], (*s)[n], (*p)[n];\n+  q = (typeof (q)) qx;\n+  r = (typeof (r)) rx;\n+  s = (typeof (s)) sx;\n+  int t = 1;\n+  int o = -1;\n+  #pragma omp for\n+  for (p = q; p != r; p += t)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p += o)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = p + t)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = p + o)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = t + p)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = o + p)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p += 2)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p -= 2)\t\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = p + 3)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = p - 3)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = q; p != r; p = 4 + p)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+  #pragma omp for\n+  for (p = s; p != r; p = -5 + p)\t/* { dg-error \"increment is not constant 1 or -1\" } */\n+    bar (p);\n+}"}, {"sha": "274e18918ef23fd7c3d6de3e7e2a8c1c20affc2a", "filename": "gcc/testsuite/c-c++-common/gomp/for-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-6.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(monotonic:runtime)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"ompexp\" } } */"}, {"sha": "5cd0a91e038d8608b66d183ce9a4c297b6eab55f", "filename": "gcc/testsuite/c-c++-common/gomp/for-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ffor-7.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(nonmonotonic:runtime)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_runtime_next\" 1 \"ompexp\" } } */"}, {"sha": "1ae39e6684a0e562ba20a5908e7278fc25755b3e", "filename": "gcc/testsuite/c-c++-common/gomp/if-1.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,6 +12,12 @@ foo (int a, int b, int *p, int *q)\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp parallel for simd if (parallel : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp parallel for simd if (simd : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp parallel for simd if (simd : a) if (parallel:b)\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp task if (a)\n@@ -22,16 +28,37 @@ foo (int a, int b, int *p, int *q)\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp taskloop if (taskloop : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp taskloop simd if (a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp taskloop simd if (taskloop : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp taskloop simd if (simd : a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp taskloop simd if (taskloop:b) if (simd : a)\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp target if (a)\n     ;\n   #pragma omp target if (target: a)\n     ;\n+  #pragma omp target simd if (a)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target simd if (simd : a) if (target: b)\n+  for (i = 0; i < 16; i++)\n+    ;\n   #pragma omp target teams distribute parallel for simd if (a)\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp target teams distribute parallel for simd if (parallel : a) if (target: b)\n+  for (i = 0; i < 16; i++)\n+    ;\n+  #pragma omp target teams distribute parallel for simd if (simd : a) if (target: b)\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp target data if (a) map (p[0:2])\n@@ -44,4 +71,47 @@ foo (int a, int b, int *p, int *q)\n   #pragma omp target exit data if (target exit data: a) map (from: p[0:2])\n   #pragma omp target update if (a) to (q[0:3])\n   #pragma omp target update if (target update:a) to (q[0:3])\n+  #pragma omp parallel\n+  {\n+    #pragma omp cancel parallel if (a)\n+  }\n+ #pragma omp parallel\n+  {\n+    #pragma omp cancel parallel if (cancel:a)\n+  }\n+  #pragma omp for\n+  for (i = 0; i < 16; i++)\n+    {\n+      #pragma omp cancel for if (a)\n+    }\n+  #pragma omp for\n+  for (i = 0; i < 16; i++)\n+    {\n+      #pragma omp cancel for if (cancel: a)\n+    }\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      {\n+\t#pragma omp cancel sections if (a)\n+      }\n+    }\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      {\n+\t#pragma omp cancel sections if (cancel: a)\n+      }\n+    }\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp task\n+    {\n+      #pragma omp cancel taskgroup if (a)\n+    }\n+    #pragma omp task\n+    {\n+      #pragma omp cancel taskgroup if (cancel: a)\n+    }\n+  }\n }"}, {"sha": "0e9daf24b1265e7542d572545e7a029f4a3048f4", "filename": "gcc/testsuite/c-c++-common/gomp/if-2.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -18,6 +18,8 @@ foo (int a, int b, int *p, int *q, int task)\n     ;\n   #pragma omp parallel if (target update:a) /* { dg-error \"expected .parallel. .if. clause modifier rather than .target update.\" } */\n     ;\n+  #pragma omp parallel if (cancel:a) /* { dg-error \"expected .parallel. .if. clause modifier rather than .cancel.\" } */\n+    ;\n   #pragma omp parallel for simd if (target update: a) /* { dg-error \"expected .parallel. .if. clause modifier rather than .target update.\" } */\n   for (i = 0; i < 16; i++)\n     ;\n@@ -27,17 +29,25 @@ foo (int a, int b, int *p, int *q, int task)\n     ;\n   #pragma omp task if (parallel: a) /* { dg-error \"expected .task. .if. clause modifier rather than .parallel.\" } */\n     ;\n+  #pragma omp simd if (cancel: a) /* { dg-error \"expected .simd. .if. clause modifier rather than .cancel.\" } */\n+  for (i = 0; i < 16; i++)\n+    ;\n   #pragma omp taskloop if (task : a) /* { dg-error \"expected .taskloop. .if. clause modifier rather than .task.\" } */\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp target if (taskloop: a) /* { dg-error \"expected .target. .if. clause modifier rather than .taskloop.\" } */\n     ;\n-  #pragma omp target teams distribute parallel for simd if (target exit data : a) /* { dg-error \"expected .parallel. or .target. .if. clause modifier\" } */\n+  #pragma omp target teams distribute parallel for simd if (target exit data : a) /* { dg-error \"expected .target. .if. clause modifier\" } */\n   for (i = 0; i < 16; i++)\n     ;\n   #pragma omp target data if (target: a) map (p[0:2]) /* { dg-error \"expected .target data. .if. clause modifier rather than .target.\" } */\n     ;\n   #pragma omp target enter data if (target data: a) map (to: p[0:2]) /* { dg-error \"expected .target enter data. .if. clause modifier rather than .target data.\" } */\n   #pragma omp target exit data if (target enter data: a) map (from: p[0:2]) /* { dg-error \"expected .target exit data. .if. clause modifier rather than .target enter data.\" } */\n   #pragma omp target update if (target exit data:a) to (q[0:3]) /* { dg-error \"expected .target update. .if. clause modifier rather than .target exit data.\" } */\n+  #pragma omp for\n+  for (i = 0; i < 16; i++)\n+    {\n+      #pragma omp cancel for if (target exit data:a) /* { dg-error \"expected .cancel. .if. clause modifier\" } */\n+    }\n }"}, {"sha": "12c342b987cb3a1e8e5a168b64343c7b57dbd4b6", "filename": "gcc/testsuite/c-c++-common/gomp/if-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fif-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2\" } */\n+\n+#define N 1024\n+\n+void\n+foo (int *x, int *y, int *z, int a)\n+{\n+  int i;\n+  #pragma omp simd if (simd: a > 2) aligned (x, y, z : 16)\n+  for (i = 0; i < N; i++)\n+    x[i] = y[i] + z[i];\n+}"}, {"sha": "b11f5db10de23de32abd9762e6ea37a3bcd884bb", "filename": "gcc/testsuite/c-c++-common/gomp/master-combined-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmaster-combined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmaster-combined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmaster-combined-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,32 @@\n+void bar (int *);\n+\n+void\n+foo (int *a)\n+{\n+  int i, j, k, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0;\n+  #pragma omp parallel master default(none) private (k)\n+  bar (&k);\n+  #pragma omp parallel default(none) firstprivate(a) shared(x, y, z)\n+  {\n+    #pragma omp master taskloop reduction (+:x) default(none) firstprivate(a)\n+    for (i = 0; i < 64; i++)\n+      x += a[i];\n+    #pragma omp master taskloop simd reduction (+:y) default(none) firstprivate(a) private (i)\n+    for (i = 0; i < 64; i++)\n+      y += a[i];\n+    #pragma omp master taskloop simd collapse(2) reduction (+:z) default(none) firstprivate(a) private (i, j)\n+    for (j = 0; j < 1; j++)\n+      for (i = 0; i < 64; ++i)\n+\tz += a[i];\n+  }\n+  #pragma omp parallel master taskloop reduction (+:u) default(none) firstprivate(a)\n+  for (i = 0; i < 64; i++)\n+    u += a[i];\n+  #pragma omp parallel master taskloop simd reduction (+:v) default(none) firstprivate(a)\n+  for (i = 0; i < 64; i++)\n+    v += a[i];\n+  #pragma omp parallel master taskloop simd collapse(2) reduction (+:w) default(none) firstprivate(a)\n+  for (j = 0; j < 1; j++)\n+    for (i = 0; i < 64; ++i)\n+      w += a[i];\n+}"}, {"sha": "4f7b57409aaf1c5ae06c21094ca05d6486469024", "filename": "gcc/testsuite/c-c++-common/gomp/master-combined-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmaster-combined-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmaster-combined-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmaster-combined-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,13 @@\n+void\n+foo (int *a)\n+{\n+  int i, r = 0, s = 0;\n+  #pragma omp taskgroup task_reduction(+:r)\n+  #pragma omp parallel master taskloop in_reduction(+:r)\t/* { dg-error \"'in_reduction' is not valid for '#pragma omp parallel master taskloop'\" } */\n+  for (i = 0; i < 64; i++)\n+    r += a[i];\n+  #pragma omp taskgroup task_reduction(+:s)\n+  #pragma omp parallel master taskloop simd in_reduction(+:s)\t/* { dg-error \"'in_reduction' is not valid for '#pragma omp parallel master taskloop simd'\" } */\n+  for (i = 0; i < 64; i++)\n+    s += a[i];\n+}"}, {"sha": "7f1f18245ddd3e7e363b950d5e21b1948f20de12", "filename": "gcc/testsuite/c-c++-common/gomp/nontemporal-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnontemporal-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnontemporal-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnontemporal-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2\" } */\n+\n+#define N 1024\n+int a[N], b[N], c[N], d[N];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp simd nontemporal (a, b)\n+  for (i = 0; i < N; ++i)\n+    a[i] = b[i] + c[i];\n+  #pragma omp simd nontemporal (d)\n+  for (i = 0; i < N; ++i)\n+    d[i] = 2 * c[i];\n+}"}, {"sha": "950a87dc3fa1f97f9eecc2896a1f553b578c9295", "filename": "gcc/testsuite/c-c++-common/gomp/nontemporal-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnontemporal-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnontemporal-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fnontemporal-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+#define N 1024\n+extern int a[N], b[N], c[N], d[N];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp simd nontemporal (a, b) aligned (a, b, c)\n+  for (i = 0; i < N; ++i)\n+    a[i] = b[i] + c[i];\n+  #pragma omp simd nontemporal (d) nontemporal (d)\t/* { dg-error \"'d' appears more than once in 'nontemporal' clauses\" } */\n+  for (i = 0; i < N; ++i)\n+    d[i] = 2 * c[i];\n+  #pragma omp simd nontemporal (a, b, b)\t\t/* { dg-error \"'b' appears more than once in 'nontemporal' clauses\" } */\n+  for (i = 0; i < N; ++i)\n+    a[i] += b[i] + c[i];\n+}"}, {"sha": "3c509d661769c33033bc10a8154aed498e969095", "filename": "gcc/testsuite/c-c++-common/gomp/reduction-task-1.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-task-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-task-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-task-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,86 @@\n+int v;\n+extern void foo (int);\n+\n+void\n+bar (void)\n+{\n+  int i;\n+  #pragma omp for reduction (task, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp sections reduction (task, +: v)\n+  {\n+    foo (-2);\n+    #pragma omp section\n+    foo (-3);\n+  }\n+  #pragma omp parallel reduction (task, +: v)\n+  foo (-1);\n+  #pragma omp parallel for reduction (task, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp parallel sections reduction (task, +: v)\n+  {\n+    foo (-2);\n+    #pragma omp section\n+    foo (-3);\n+  }\n+  #pragma omp teams distribute parallel for reduction (task, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp for reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp sections reduction (default, +: v)\n+  {\n+    foo (-2);\n+    #pragma omp section\n+    foo (-3);\n+  }\n+  #pragma omp parallel reduction (default, +: v)\n+  foo (-1);\n+  #pragma omp parallel for reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp parallel sections reduction (default, +: v)\n+  {\n+    foo (-2);\n+    #pragma omp section\n+    foo (-3);\n+  }\n+  #pragma omp teams distribute parallel for reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp for reduction (default, +: v) nowait\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp sections nowait reduction (default, +: v)\n+  {\n+    foo (-2);\n+    #pragma omp section\n+    foo (-3);\n+  }\n+  #pragma omp simd reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp for simd reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp parallel for simd reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp teams distribute parallel for simd reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp taskloop reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp taskloop simd reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp teams reduction (default, +: v)\n+  foo (i);\n+  #pragma omp teams distribute reduction (default, +: v)\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+}"}, {"sha": "1e262d325d4e42482e90bcec8d7d893abd2df90e", "filename": "gcc/testsuite/c-c++-common/gomp/reduction-task-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-task-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-task-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freduction-task-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,40 @@\n+int v;\n+extern void foo (int);\n+\n+void\n+bar (void)\n+{\n+  int i;\n+  #pragma omp for reduction (task, +: v) nowait\t/* { dg-error \"'task' reduction modifier on a construct with a 'nowait' clause\" } */\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp sections nowait reduction (task, +: v)\t/* { dg-error \"'task' reduction modifier on a construct with a 'nowait' clause\" } */\n+  {\n+    foo (-2);\n+    #pragma omp section\n+    foo (-3);\n+  }\n+  #pragma omp simd reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct other than 'parallel', 'for' or 'sections'\" } */\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp for simd reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct combined with 'simd'\" } */\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp parallel for simd reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct combined with 'simd'\" } */\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp teams distribute parallel for simd reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct combined with 'simd'\" } */\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp taskloop reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct other than 'parallel', 'for' or 'sections'\" } */\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+  #pragma omp taskloop simd reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct combined with 'simd'\" } */\n+  for (i = 0; i < 64; i++)\n+    v++;\n+  #pragma omp teams reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct other than 'parallel', 'for' or 'sections'\" } */\n+  foo (i);\n+  #pragma omp teams distribute reduction (task, +: v)\t/* { dg-error \"invalid 'task' reduction modifier on construct not combined with 'parallel', 'for' or 'sections'\" } */\n+  for (i = 0; i < 64; i++)\n+    foo (i);\n+}"}, {"sha": "7be6c3826105e902896235a13fdd75f4956803db", "filename": "gcc/testsuite/c-c++-common/gomp/requires-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,15 @@\n+#pragma omp requires unified_address\n+#pragma omp requires unified_shared_memory\n+#pragma omp requires unified_shared_memory unified_address\n+#pragma omp requires dynamic_allocators,reverse_offload\n+\n+int i;\n+\n+void\n+foo ()\n+{\n+  if (0)\n+    #pragma omp requires unified_shared_memory unified_address\n+    i++;\n+  #pragma omp requries atomic_default_mem_order(seq_cst)\n+}"}, {"sha": "d242a322028010ae5a4d55f22b0ea040c4d65874", "filename": "gcc/testsuite/c-c++-common/gomp/requires-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,18 @@\n+#pragma omp requires\t/* { dg-error \"requires at least one clause\" } */\n+#pragma omp requires unified_shared_memory,unified_shared_memory\t/* { dg-error \"too many 'unified_shared_memory' clauses\" } */\n+#pragma omp requires unified_address\tunified_address\t/* { dg-error \"too many 'unified_address' clauses\" } */\n+#pragma omp requires reverse_offload reverse_offload\t/* { dg-error \"too many 'reverse_offload' clauses\" } */\n+#pragma omp requires foobarbaz\t/* { dg-error \"expected 'unified_address', 'unified_shared_memory', 'dynamic_allocators', 'reverse_offload' or 'atomic_default_mem_order' clause\" } */\n+\n+int i;\n+\n+void\n+foo ()\n+{\n+  #pragma omp requires dynamic_allocators , dynamic_allocators\t/* { dg-error \"too many 'dynamic_allocators' clauses\" } */\n+  if (0)\n+    #pragma omp requires atomic_default_mem_order(seq_cst) atomic_default_mem_order(seq_cst)\t/* { dg-error \"too many 'atomic_default_mem_order' clauses\" } */\n+    i++;\n+}\n+\n+#pragma omp requires atomic_default_mem_order (seq_cst)\t/* { dg-error \"more than one 'atomic_default_mem_order' clause in a single compilation unit\" } */"}, {"sha": "e5a6cbbdd2a6bfed806a75f308f4ddd021c7a619", "filename": "gcc/testsuite/c-c++-common/gomp/requires-3.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,3 @@\n+#pragma omp requires atomic_default_mem_order(acquire)\t/* { dg-error \"expected 'seq_cst', 'relaxed' or 'acq_rel'\" } */\n+#pragma omp requires atomic_default_mem_order(release)\t/* { dg-error \"expected 'seq_cst', 'relaxed' or 'acq_rel'\" } */\n+#pragma omp requires atomic_default_mem_order(foobar)\t/* { dg-error \"expected 'seq_cst', 'relaxed' or 'acq_rel'\" } */"}, {"sha": "a3497b141a394a95e52c0747b4f0690ac3329a09", "filename": "gcc/testsuite/c-c++-common/gomp/requires-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-4.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,11 @@\n+#pragma omp requires unified_shared_memory,unified_address,reverse_offload\n+void\n+foo (void)\n+{\n+  #pragma omp target\n+  ;\n+  #pragma omp requires unified_shared_memory\t/* { dg-error \"'unified_shared_memory' clause used lexically after first target construct or offloading API\" } */\n+}\n+\n+#pragma omp requires unified_address\t/* { dg-error \"'unified_address' clause used lexically after first target construct or offloading API\" } */\n+#pragma omp requires reverse_offload\t/* { dg-error \"'reverse_offload' clause used lexically after first target construct or offloading API\" } */"}, {"sha": "82ab25722e741a79b4cc33d97ecfa1c63373a4b7", "filename": "gcc/testsuite/c-c++-common/gomp/schedule-modifiers-1.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-modifiers-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-modifiers-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fschedule-modifiers-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -68,18 +68,26 @@ void\n bar (void)\n {\n   int i;\n-  #pragma omp for schedule (nonmonotonic: static, 2)\t/* { dg-error \".nonmonotonic. modifier specified for .static. schedule kind\" } */\n+  #pragma omp for schedule (nonmonotonic: static, 2)\n   for (i = 0; i < 64; i++)\n     ;\n-  #pragma omp for schedule (nonmonotonic : static)\t/* { dg-error \".nonmonotonic. modifier specified for .static. schedule kind\" } */\n+  #pragma omp for schedule (nonmonotonic : static)\n   for (i = 0; i < 64; i++)\n     ;\n-  #pragma omp for schedule (nonmonotonic : runtime)\t/* { dg-error \".nonmonotonic. modifier specified for .runtime. schedule kind\" } */\n+  #pragma omp for schedule (nonmonotonic : runtime)\n   for (i = 0; i < 64; i++)\n     ;\n-  #pragma omp for schedule (nonmonotonic : auto)\t/* { dg-error \".nonmonotonic. modifier specified for .auto. schedule kind\" } */\n+  #pragma omp for schedule (nonmonotonic : auto)\n   for (i = 0; i < 64; i++)\n     ;\n+  #pragma omp for schedule (nonmonotonic : static) ordered\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    #pragma omp ordered\n+      ;\n+  #pragma omp for ordered schedule (nonmonotonic: static, 4)\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    #pragma omp ordered\n+      ;\n   #pragma omp for schedule (nonmonotonic : dynamic) ordered\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n   for (i = 0; i < 64; i++)\n     #pragma omp ordered\n@@ -95,6 +103,12 @@ bar (void)\n       #pragma omp ordered depend(source)\n     }\n   #pragma omp for ordered(1) schedule(nonmonotonic : guided, 2)\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered depend(source)\n+      #pragma omp ordered depend(sink: i - 1)\n+    }\n+  #pragma omp for schedule(nonmonotonic : runtime) ordered(1)\t/* { dg-error \".nonmonotonic. schedule modifier specified together with .ordered. clause\" } */\n   for (i = 0; i < 64; i++)\n     {\n       #pragma omp ordered depend(source)"}, {"sha": "83d53251d583e7487a34ebb2c42c65b920d635bf", "filename": "gcc/testsuite/c-c++-common/gomp/simd7.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd7.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,21 @@\n+int a[64];\n+\n+#pragma omp declare simd linear(x)\n+int\n+bar (int x, int y)\n+{\n+  int v;\n+  #pragma omp atomic capture\n+  v = a[x] += y;\n+  return v;\n+}\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < 64; i++)\n+    #pragma omp atomic\n+    a[i] += 1;\n+}"}, {"sha": "0d4975bcc03d8296a969b1de690ad53276ba8695", "filename": "gcc/testsuite/c-c++-common/gomp/target-data-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-data-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-data-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-data-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (void)\n+{\n+  int a[4] = { 1, 2, 3, 4 };\n+  #pragma omp target data map(to:a)\n+  #pragma omp target data use_device_ptr(a)\n+  #pragma omp target is_device_ptr(a)\n+  {\n+    a[0]++;\n+  }\n+  #pragma omp target data\t\t/* { dg-error \"must contain at least one\" } */\n+  a[0]++;\n+  #pragma omp target data map(to:a)\n+  #pragma omp target data use_device_ptr(a) use_device_ptr(a) /* { dg-error \"appears more than once in data clauses\" } */\n+  a[0]++;\n+}"}, {"sha": "0df073fde74f1ccc8539a5c1134c15ac9cd84517", "filename": "gcc/testsuite/c-c++-common/gomp/taskloop-reduction-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftaskloop-reduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftaskloop-reduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftaskloop-reduction-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,10 @@\n+int\n+foo (int *a)\n+{\n+  int x = 0;\n+  #pragma omp taskloop reduction (+:x) nogroup\t/* { dg-error \"'nogroup' clause must not be used together with 'reduction' clause\" } */\n+  for (int i = 0; i < 64; i++)\n+    x += a[i];\n+  #pragma omp taskwait\n+  return x;\n+}"}, {"sha": "1fcce7493ef1eecde6c88b005073585d2e53426b", "filename": "gcc/testsuite/c-c++-common/gomp/taskwait-depend-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftaskwait-depend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftaskwait-depend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftaskwait-depend-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,11 @@\n+void\n+foo (int *p)\n+{\n+  #pragma omp taskwait depend(iterator(i = 0:16) , in : p[i]) depend(out : p[32])\n+}\n+\n+void\n+bar (int *p)\n+{\n+  #pragma omp taskwait depend(mutexinoutset : p[0])\t/* { dg-error \"'mutexinoutset' kind in 'depend' clause on a 'taskwait' construct\" } */\n+}"}, {"sha": "0ef3bb9b0735dd82fd478fa4907efa7bf8ec092f", "filename": "gcc/testsuite/c-c++-common/gomp/teams-1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,64 @@\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+int omp_get_num_teams (void);\n+int omp_get_team_num (void);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void bar (int *, int *, int *, int, int, int, int);\n+\n+void\n+foo (void)\n+{\n+  int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6;\n+  #pragma omp teams num_teams (4) shared (b) firstprivate (c, d) private (e, f)\n+  {\n+    f = 7;\n+    bar (&a, &c, &e, b, d, f, 0);\n+  }\n+  bar (&a, (int *) 0, (int *) 0, b, 0, 0, 1);\n+}\n+\n+void\n+baz (void)\n+{\n+  #pragma omp teams\n+  {\n+    #pragma omp distribute\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    #pragma omp distribute simd\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    #pragma omp distribute parallel for\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    #pragma omp distribute parallel for\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    #pragma omp distribute parallel for simd\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    #pragma omp parallel\n+    ;\n+    #pragma omp parallel for\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    #pragma omp parallel for simd\n+    for (int i = 0; i < 64; i++)\n+      ;\n+    int a, b;\n+    #pragma omp parallel sections\n+    {\n+      a = 5;\n+      #pragma omp section\n+      b = 6;\n+    }\n+    int c = omp_get_num_teams ();\n+    int d = omp_get_team_num ();\n+  }\n+}"}, {"sha": "011c284aaaa59a8a4964142fd85ddf6593ac2b86", "filename": "gcc/testsuite/c-c++-common/gomp/teams-2.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fteams-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,119 @@\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  #pragma omp parallel\n+  {\n+    #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+    ;\n+  }\n+  #pragma omp teams\n+  {\n+    #pragma omp teams\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+  }\n+  #pragma omp target\n+  {\n+    #pragma omp parallel\n+    {\n+      #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+      ;\n+    }\n+  }\n+  #pragma omp for\n+  for (i = 0; i < 4; i++)\n+    if (i == 0)\n+      {\n+\t#pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+\t;\n+      }\n+  #pragma omp single\n+  #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+  ;\n+  #pragma omp master\n+  {\n+    #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+    ;\n+  }\n+  #pragma omp critical\n+  #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+  ;\n+  #pragma omp sections\n+  {\n+    #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+    ;\n+    #pragma omp section\n+    {\n+      #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+      ;\n+    }\n+  }\n+  #pragma omp target data map (to: i)\n+  {\n+    #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+    ;\n+  }\n+  #pragma omp task\n+  {\n+    #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+    ;\n+  }\n+  #pragma omp taskgroup\n+  {\n+    #pragma omp teams\t/* { dg-error \"'teams' construct must be closely nested inside of 'target' construct or not nested in any OpenMP construct\" } */\n+    ;\n+  }\n+}\n+\n+void\n+bar (void)\n+{\n+  #pragma omp teams\n+  {\n+    int x, y, v = 4;\n+    #pragma omp target\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp target data map (to: v)\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp for\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    for (int i = 0; i < 64; ++i)\n+      ;\n+    #pragma omp simd\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    for (int i = 0; i < 64; ++i)\n+      ;\n+    #pragma omp for simd\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    for (int i = 0; i < 64; ++i)\n+      ;\n+    #pragma omp single\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp master\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp sections\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    {\n+      x = 1;\n+      #pragma omp section\n+      y = 2;\n+    }\n+    #pragma omp critical\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp target enter data map (to: v)\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp target exit data map (from: v)\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp cancel parallel\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp cancellation point parallel /* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp barrier\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp ordered\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp task\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp taskloop\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    for (int i = 0; i < 64; ++i)\n+      ;\n+    #pragma omp atomic\t\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    v++;\n+    #pragma omp taskgroup\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    ;\n+    #pragma omp taskwait\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+    #pragma omp taskyield\t\t/* { dg-error \"only 'distribute' or 'parallel' regions are allowed to be strictly nested inside 'teams' region\" } */\n+  }\n+}"}, {"sha": "c93e732d8506d28b235b1359760af4a15cb46ad4", "filename": "gcc/testsuite/g++.dg/gomp/atomic-18.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-18.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fdump-tree-original\" }\n+// { dg-final { scan-tree-dump-times \"omp atomic release\" 5 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic seq_cst\" 1 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic relaxed\" 2 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic capture acq_rel\" 3 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic capture acquire\" 1 \"original\" } }\n+// { dg-final { scan-tree-dump-times \"omp atomic read acquire\" 1 \"original\" } }\n+\n+int i, v;\n+float f;\n+\n+template <int N, int M, typename T>\n+void\n+foo (T *p)\n+{\n+  #pragma omp atomic release, hint (N), update\n+  i = i + 1;\n+  #pragma omp atomic hint(0)seq_cst\n+  i = i + 1;\n+  #pragma omp atomic relaxed,update,hint (N)\n+  i = i + 1;\n+  #pragma omp atomic release\n+  i = i + 1;\n+  #pragma omp atomic relaxed\n+  i = i + 1;\n+  #pragma omp atomic acq_rel capture\n+  v = i = i + 1;\n+  #pragma omp atomic capture,acq_rel , hint (M)\n+  v = i = i + 1;\n+  #pragma omp atomic hint(N),acquire capture\n+  v = i = i + 1;\n+  #pragma omp atomic read acquire\n+  v = i;\n+  #pragma omp atomic release,write\n+  i = v;\n+  #pragma omp atomic hint(1),update,release\n+  f = f + 2.0;\n+  #pragma omp requires atomic_default_mem_order (acq_rel)\n+  #pragma omp atomic hint (M - 1) update\n+  *p += 1;\n+  #pragma omp atomic capture, hint (M)\n+  v = *p = *p + 1;\n+}\n+\n+void\n+bar ()\n+{\n+  foo <0, 1, int> (&i);\n+}"}, {"sha": "93f66139cf681f37351a70b9fa96fa0736ee35ff", "filename": "gcc/testsuite/g++.dg/gomp/atomic-19.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-19.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,17 @@\n+int i;\n+\n+template <int N, typename T>\n+void\n+foo (T x)\n+{\n+  #pragma omp atomic hint (x)\t\t// { dg-error \"must be integral\" }\n+  i = i + 1;\n+  #pragma omp atomic hint (N + i)\t// { dg-error \"constant integer expression\" }\n+  i = i + 1;\n+}\n+\n+void\n+bar ()\n+{\n+  foo <0, float> (1.0f);\n+}"}, {"sha": "78f6344361be0ad7378442cc383959f06c131c49", "filename": "gcc/testsuite/g++.dg/gomp/atomic-5.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,18 +12,18 @@ void f1(void)\n     x = x + 1;\n   #pragma omp atomic\n     x = 1;\t\t/* { dg-error \"invalid form\" } */\n-  #pragma omp atomic\n+  #pragma omp atomic\t/* { dg-error \"read-only variable\" } */\n     ++y;\t\t/* { dg-error \"read-only variable\" } */\n-  #pragma omp atomic\n+  #pragma omp atomic\t/* { dg-error \"read-only variable\" } */\n     y--;\t\t/* { dg-error \"read-only variable\" } */\n-  #pragma omp atomic\n-    y += 1;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\t/* { dg-error \"read-only variable\" } */\n+    y += 1;\n   #pragma omp atomic\n     bar();\t\t/* { dg-error \"invalid operator\" } */\n   #pragma omp atomic\n     bar() += 1;\t\t/* { dg-error \"lvalue required\" } */\n   #pragma omp atomic a\t/* { dg-error \"expected end of line\" } */\n-    x++;\n+    x++;\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target *-*-* } .-1 } */\n   #pragma omp atomic\n     ;\t\t\t/* { dg-error \"expected primary-expression\" } */\n   #pragma omp atomic"}, {"sha": "e0edc873483d0c4d50bdb864fb533374536bc921", "filename": "gcc/testsuite/g++.dg/gomp/clause-3.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -86,18 +86,18 @@ foo (int x)\n #pragma omp p for linear (t) // { dg-error \"predetermined 'threadprivate'\" }\n   for (i = 0; i < 10; i++)\n     ;\n-#pragma omp p shared (c) // { dg-error \"predetermined 'shared'\" }\n+#pragma omp p shared (c)\n     ;\n-#pragma omp p private (c) // { dg-error \"predetermined 'shared'\" }\n+#pragma omp p private (c) // { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     ;\n #pragma omp p firstprivate (c)\n     ;\n-#pragma omp p for lastprivate (c) // { dg-error \"predetermined 'shared'\" }\n+#pragma omp p for lastprivate (c) // { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n   for (i = 0; i < 10; i++)\n     ;\n-#pragma omp p reduction (*:c) // { dg-error \"predetermined 'shared'\" }\n+#pragma omp p reduction (*:c) // { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     ;\n-#pragma omp p for linear (c:2) // { dg-error \"predetermined 'shared'\" }\n+#pragma omp p for linear (c:2) // { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n   for (i = 0; i < 10; i++)\n     ;\n }"}, {"sha": "b8dc496198fae1c5c58aca9dca27529d1f518463", "filename": "gcc/testsuite/g++.dg/gomp/critical-3.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-3.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,33 @@\n+int i;\n+\n+template <int N>\n+void\n+foo (void)\n+{\n+  #pragma omp critical (foo), hint (N + 1)\n+  i++;\n+}\n+\n+template <int N>\n+void\n+bar (void)\n+{\n+  #pragma omp critical (bar), hint (N + i)\t// { dg-error \"constant integer expression\" }\n+  i++;\n+}\n+\n+template <typename T>\n+void\n+baz (T x)\n+{\n+  #pragma omp critical (baz) hint (x)\t// { dg-error \"expression must be integral\" }\n+  i++;\n+}\n+\n+void\n+test ()\n+{\n+  foo <0> ();\n+  bar <0> ();\n+  baz (0.0);\n+}"}, {"sha": "6f4aa97ee44620531fd310f3eb1ba8eaeec4d38d", "filename": "gcc/testsuite/g++.dg/gomp/depend-iterator-1.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-iterator-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-iterator-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-iterator-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,86 @@\n+int arr[64], arr2[64];\n+struct S { int a[4]; } k;\n+short arr4[4];\n+volatile int v;\n+#define TEST_EQ(x,y) ({ int o[x == y ? 1 : -1]; 0; })\n+\n+template <typename T, typename U, typename V, typename W, int N>\n+void\n+foo (unsigned char i, signed char j)\n+{\n+  #pragma omp task depend (iterator (T j=6:N:-2) , out : \\\n+\tarr[TEST_EQ (sizeof (j), sizeof (int)), \\\n+\t    TEST_EQ (sizeof (i), sizeof (unsigned char)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (struct S)), j], \\\n+\tarr2[TEST_EQ (((__typeof (j)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (i)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (k.a[0])) -1) < 0, 1), j]) \\\n+\tdepend(out: arr[0]) \\\n+\tdepend (iterator (U i=__LONG_LONG_MAX__ - 4:__LONG_LONG_MAX__ - N:N, \\\n+\t\t\t  V j=~0U-16:~0U-8:3, \\\n+\t\t\t  W *k=&arr4[1]:&arr4[2]:1) , in : \\\n+\tarr[TEST_EQ (sizeof (i), sizeof (long long)), \\\n+\t    TEST_EQ (sizeof (j), sizeof (unsigned short)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (short *)), \\\n+\t    TEST_EQ (sizeof (*k), sizeof (short)), i - __LONG_LONG_MAX__ + 4], \\\n+\tarr2[TEST_EQ (((__typeof (i)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (j)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (*k)) -1) < 0, 1), j - (~0U-16)], \\\n+\tarr2[k - &arr4[0]]) \\\n+\tdepend(in : k)\n+    v++;\n+}\n+\n+template <typename U, typename W, int N>\n+void\n+bar (unsigned char i, signed char j)\n+{\n+  int m = j;\n+  int n = j + 2;\n+  #pragma omp task depend (iterator (j=N:2:m) , out : \\\n+\tarr[TEST_EQ (sizeof (j), sizeof (int)), \\\n+\t    TEST_EQ (sizeof (i), sizeof (unsigned char)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (struct S)), j], \\\n+\tarr2[TEST_EQ (((__typeof (j)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (i)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (k.a[0])) -1) < 0, 1), j]) \\\n+\tdepend(out: arr[0]) \\\n+\tdepend (iterator (U i=__LONG_LONG_MAX__ - 4 - n:__LONG_LONG_MAX__ - 2:2, \\\n+\t\t\t  unsigned short j=~0U-16:~0U-8-n:3, \\\n+\t\t\t  W k=&arr4[N-5]:&arr4[n + 2]:1) , in : \\\n+\tarr[TEST_EQ (sizeof (i), sizeof (long long)), \\\n+\t    TEST_EQ (sizeof (j), sizeof (unsigned short)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (short *)), \\\n+\t    TEST_EQ (sizeof (*k), sizeof (short)), i - __LONG_LONG_MAX__ + 4], \\\n+\tarr2[TEST_EQ (((__typeof (i)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (j)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (*k)) -1) < 0, 1), j - (~0U-16)], \\\n+\tarr2[k - &arr4[0]:10]) \\\n+\tdepend(in : k)\n+    v++;\n+}\n+\n+template <typename T, typename U, int N>\n+void\n+baz (void)\n+{\n+  #pragma omp parallel\n+  #pragma omp master\n+  {\n+    #pragma omp task depend(iterator(T k = N : 2) , inout : \\\n+\tarr[TEST_EQ (sizeof (k), sizeof (unsigned long)), \\\n+\t    TEST_EQ (((__typeof (k)) -1) < N, 0), k]) \\\n+\tdepend(iterator(U s = -3 : -12 : -1 + N) , out : \\\n+\tarr[TEST_EQ (sizeof (s), sizeof (signed char)), \\\n+\t    TEST_EQ (((__typeof (s)) -1) < 0, 1), s + 12])\n+      v++;\n+  }\n+}\n+\n+void\n+test (void)\n+{\n+  foo <int, long long, unsigned short, short, 2> (0, 0);\n+  bar <long long, short *, 6> (0, -2);\n+  baz <unsigned long int, signed char, 0> ();\n+}"}, {"sha": "a0119ebc6940e6fdcd6119195eea95bc3555f51a", "filename": "gcc/testsuite/g++.dg/gomp/depend-iterator-2.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-iterator-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-iterator-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-iterator-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,121 @@\n+int a, b[64];\n+struct S { int c; } *d, *e;\n+struct T;\n+struct T *f, *g;\n+int *h;\n+\n+template <typename U, typename V, typename W, W N>\n+void\n+f1 ()\n+{\n+  #pragma omp task depend (iterator , in : a)\t// { dg-error \"expected\" }\n+  ;\n+  #pragma omp task depend (iterator (for = 0 : 2) , in : a)\t// { dg-error \"expected\" }\n+  ;\n+  #pragma omp task depend (iterator (5 = 0 : 2) , in : a)\t// { dg-error \"expected\" }\n+  ;\n+  #pragma omp task depend (iterator (i : N : 2) , in : a)\t// { dg-error \"expected '='|name a type|expected\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 0, 1 : 2) , in : a)\t// { dg-error \"expected\" }\n+  ;\n+  #pragma omp task depend (iterator (i = (0, 1) : 2) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (i = 0 : 1 : 2 : 3) , in : a)\t// { dg-error \"expected '.'\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 0 : 2, 3) , in : a)\t// { dg-error \"expected\" }\n+  ;\n+  #pragma omp task depend (iterator (i = N : 10 : 2, 3) , in : a)\t// { dg-error \"expected\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 0:1), iterator (j = 0:1) , in : a)\t// { dg-error \"invalid depend kind\" }\n+  ;\n+  #pragma omp task depend (iterator (i = N:32) , in : b[i*2:2])\n+  ;\n+  #pragma omp task depend (iterator (void i = 0:1) , in : a)\t\t// { dg-error \"iterator 'i' has neither integral nor pointer type\" }\n+  ;\n+  #pragma omp task depend (iterator (U *p = d:e:2) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (W i = N:4, \\\n+\t\t\t\t     struct U2 { W *p; } *p = 0:2) , in : a) // { dg-error \"types may not be defined in iterator type\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 0:4, j = i:16) , in : a)\t// { dg-error \"begin expression refers to outer iterator 'i'\" }\n+  ;\n+  #pragma omp task depend (iterator (i = N:4, j = 2:i:1) , in : a)\t// { dg-error \"end expression refers to outer iterator 'i'\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 0:4, j = 2:8:i) , in : a)\t// { dg-error \"step expression refers to outer iterator 'i'\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 1.25:2.5:3) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (i = 1:2:3.5) , in : a)\t\t// { dg-error \"iterator step with non-integral type\" }\n+  ;\n+  #pragma omp task depend (iterator (W *p = 23 : h) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (const int i = N : 2) , in : a)\t// { dg-error \"const qualified\" }\n+  ;\n+  #pragma omp task depend (iterator (const long long unsigned i = 0 : 2) , in : a)\t// { dg-error \"const qualified\" }\n+  ;\n+}\n+\n+template <typename W, int N>\n+void\n+f2 ()\n+{\n+  int i, j;\n+  #pragma omp for ordered(2)\n+  for (i = 0; i < 64; i++)\n+    for (j = 0; j < 64; j++)\n+      {\n+      #pragma omp ordered depend (iterator (k=0:N) , sink: i - 1, j - 1)\t// { dg-error \"'iterator' modifier incompatible with 'sink'\" }\n+      #pragma omp ordered depend (iterator (W l = 0:2:3) , source)\t\t// { dg-error \"'iterator' modifier incompatible with 'source'\" }\n+      }\n+}\n+\n+template <typename U, typename V, typename W, W N, typename X, typename Y>\n+void\n+f3 ()\n+{\n+  #pragma omp task depend (iterator (U i = 0:1), in : a)\t\t// { dg-error \"iterator 'i' has neither integral nor pointer type\" }\n+  ;\n+  #pragma omp task depend (iterator (V f = 0.2:0.4) , in : a)\t// { dg-error \"iterator 'f' has neither integral nor pointer type\" }\n+  ;\n+  #pragma omp task depend (iterator (struct T *p = f:g) , in : a)\t// { dg-error \"invalid use of\" }\n+  ;\n+  #pragma omp task depend (iterator (i = *d:2) , in : a)\t// { dg-error \"invalid cast from type 'S' to type 'int'\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 2:*d:2) , in : a)\t// { dg-error \"invalid cast from type 'S' to type 'int'\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 2:4:*d) , in : a)\t// { dg-error \"iterator step with non-integral type\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 1.25:2.5:3) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (i = 1:2:3.5) , in : a)\t// { dg-error \"iterator step with non-integral type\" }\n+  ;\n+  #pragma omp task depend (iterator (W *p = 23 : h) , in : a)\n+  ;\n+  #pragma omp task depend (iterator (short i=1:3:N) , in : a)\t// { dg-error \"iterator 'i' has zero step\" }\n+  ;\n+  #pragma omp task depend (iterator (i = 1 : 3 : N + 3 - 3) , in : a)\t// { dg-error \"iterator 'i' has zero step\" }\n+  ;\n+  #pragma omp task depend (iterator (int *p = &b[6]:&b[9]:4 - 4) , in : a)\t// { dg-error \"iterator 'p' has zero step\" }\n+  ;\n+  #pragma omp task depend (iterator (X i = N : 2) , in : a)\t// { dg-error \"const qualified\" }\n+  ;\n+  #pragma omp task depend (iterator (Y i = 0 : 2) , in : a)\t// { dg-error \"const qualified\" }\n+  ;\n+}\n+\n+template <int N>\n+void\n+f4 ()\n+{\n+  #pragma omp task depend (iterator (i = 0:1), iterator (j = 0:1) , in : a)\t// { dg-error \"invalid depend kind\" }\n+  ;\n+}\n+\n+void\n+f5 ()\n+{\n+  f1 <struct S, float, int, 0> ();\n+  f2 <int, 1> ();\n+  f3 <struct S, float, int, 0, const int, const long long unsigned> ();\n+  f4 <0> ();\n+}"}, {"sha": "6004f1e6e6d6f4933ff26efa595f2060f8ecf57a", "filename": "gcc/testsuite/g++.dg/gomp/depobj-1.C", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepobj-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepobj-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepobj-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,118 @@\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+omp_depend_t bar (void);\n+extern const omp_depend_t cdepobj;\n+extern omp_depend_t depobj, depobj4;\n+extern omp_depend_t depobja[4];\n+extern omp_depend_t *pdepobj;\n+int a, b, i, j;\n+\n+template <int N>\n+void\n+f1 (bool x)\n+{\n+  #pragma omp depobj(x ? depobj : depobj4) depend(in : x ? a : b)\n+  #pragma omp depobj(x ? depobj : depobj4) update(inout)\n+  #pragma omp task depend (depobj:depobj)\n+  ;\n+  #pragma omp depobj(depobj) destroy\n+  #pragma omp task depend (iterator (i=1:3) , depobj: *(depobja + i))\n+  ;\n+  #pragma omp depobj(pdepobj[0]) depend(mutexinoutset:a)\n+  #pragma omp depobj(*pdepobj) destroy\n+}\n+\n+template <typename T, typename T2>\n+void\n+f2 (T &depobj2, T2 depobj3, T *pdepobj)\n+{\n+  T depobj1;\n+  T depobja[4];\n+  #pragma omp depobj(depobj1) depend(in : --a)\n+  #pragma omp depobj(depobj1) update(inout)\n+  #pragma omp task depend (depobj: depobj1)\n+  ;\n+  #pragma omp depobj(depobj1) destroy\n+  #pragma omp depobj(depobj2) depend(in : a)\n+  #pragma omp depobj(depobj2) update(inout)\n+  #pragma omp task depend (depobj :depobj2)\n+  ;\n+  #pragma omp depobj(depobj2) destroy\n+  #pragma omp depobj(depobj3) depend(in : a)\n+  #pragma omp depobj(depobj3) update(inout)\n+  #pragma omp task depend (depobj  :  depobj3)\n+  ;\n+  #pragma omp depobj(depobj3) destroy\n+  for (int q = 1; q < 3; q++)\n+    {\n+      #pragma omp depobj(depobja[q]) depend (in:a)\n+    }\n+  #pragma omp task depend (iterator (i=1:3) , depobj : *(depobja + i))\n+  ;\n+  for (int q = 1; q < 3; q++)\n+    {\n+      #pragma omp depobj(depobja[q]) destroy\n+    }\n+  #pragma omp depobj(pdepobj[0]) depend(mutexinoutset:a)\n+  #pragma omp depobj(*pdepobj) destroy\n+}\n+\n+void\n+f3 (bool x)\n+{\n+  omp_depend_t depobjx, depobjy;\n+  f1 <0> (x);\n+  f2 <omp_depend_t, omp_depend_t &> (depobjx, depobjy, pdepobj);\n+}\n+\n+template <int N>\n+void\n+f4 (void)\n+{\n+  omp_depend_t depobjb[4];\n+  #pragma omp depobj\t\t\t\t\t// { dg-error \"expected\" }\n+  #pragma omp depobj destroy\t\t\t\t// { dg-error \"expected\" }\n+  #pragma omp depobj (depobj)\t\t\t\t// { dg-error \"expected 'depend', 'destroy' or 'update' clause\" }\n+  #pragma omp depobj (depobj) foobar\t\t\t// { dg-error \"expected 'depend', 'destroy' or 'update' clause\" }\n+  #pragma omp depobj(bar ()) update(inout)\t\t// { dg-error \"'depobj' expression is not lvalue expression\" }\n+  #pragma omp depobj (cdepobj) update(in)\t\t// { dg-error \"'const' qualified 'depobj' expression\" }\n+  #pragma omp depobj (depobjb) depend(in: a)\t\t// { dg-error \"type of 'depobj' expression is not 'omp_depend_t'\" }\n+  #pragma omp depobj (pdepobj) depend(in: a)\t\t// { dg-error \"type of 'depobj' expression is not 'omp_depend_t'\" }\n+  #pragma omp depobj (a) destroy\t\t\t// { dg-error \"type of 'depobj' expression is not 'omp_depend_t'\" }\n+  #pragma omp depobj (depobj) depend(depobj:a)\t\t// { dg-error \"does not have 'omp_depend_t' type in 'depend' clause with 'depobj' dependence type\" }\n+  #pragma omp depobj (depobj) depend(depobj:*depobjb)\t// { dg-error \"'depobj' dependence type specified in 'depend' clause on 'depobj' construct\" }\n+  #pragma omp depobj (depobj) update(foobar)\t\t// { dg-error \"expected 'in', 'out', 'inout' or 'mutexinoutset'\" }\n+  #pragma omp depobj (depobj) depend(in: *depobja)\t// { dg-error \"should not have 'omp_depend_t' type in 'depend' clause with dependence type\" }\n+  #pragma omp depobj (depobj) depend(in: a) depend(in: b)\t// { dg-error \"expected\" }\n+  #pragma omp depobj (depobj) depend(in: a) update(out)\t// { dg-error \"expected\" }\n+  #pragma omp depobj (depobj) depend(in: a, b)\t\t// { dg-error \"more than one locator in 'depend' clause on 'depobj' construct\" }\n+  #pragma omp depobj (depobj) depend(source)\t\t// { dg-error \"'depend\\\\(source\\\\)' is only allowed in 'omp ordered'\" }\n+  #pragma omp depobj (depobj) depend(sink: i + 1, j - 1)\t// { dg-error \"'depend\\\\(sink\\\\)' is only allowed in 'omp ordered'\" }\n+  #pragma omp depobj (depobj) depend(iterator (i = 0:2) , in : a)\t// { dg-error \"'iterator' modifier may not be specified on 'depobj' construct\" }\n+  if (0)\n+    #pragma omp depobj (depobj) destroy\t\t\t// { dg-error \"'#pragma omp depobj' may only be used in compound statements\" }\n+    ;\n+}\n+\n+template <int N>\n+void\n+f5 (void)\n+{\n+  #pragma omp task depend (depobj:depobja[1:2])\t\t// { dg-error \"'depend' clause with 'depobj' dependence type on array section\" }\n+  ;\n+  #pragma omp task depend (depobj : a)\t\t\t// { dg-error \"'a' does not have 'omp_depend_t' type in 'depend' clause with 'depobj' dependence type\" }\n+  ;\n+  #pragma omp task depend (in: depobj)\t\t\t// { dg-error \"'depobj' should not have 'omp_depend_t' type in 'depend' clause with dependence type\" }\n+  ;\n+}\n+\n+void\n+f6 (omp_depend_t &x)\n+{\n+  f4 <0> ();\n+  f5 <0> ();\n+  #pragma omp depobj (x) depend(in: a)\n+  #pragma omp depobj (depobj) depend(in: x)\t\t// { dg-error \"should not have 'omp_depend_t' type in 'depend' clause with dependence type\" }\n+}"}, {"sha": "9381b3aa85deaf668c3ac3fa962254c5b6574f81", "filename": "gcc/testsuite/g++.dg/gomp/doacross-1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdoacross-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdoacross-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdoacross-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fopenmp\" }\n+\n+int a[42];\n+\n+void\n+foo ()\n+{\n+  #pragma omp for ordered (1)\t// { dg-error \"'ordered' clause with parameter on range-based 'for' loop\" }\n+  for (auto x : a)\n+    ;\n+}\n+\n+void\n+bar ()\n+{\n+  #pragma omp for ordered (2)\t// { dg-error \"'ordered' clause with parameter on range-based 'for' loop\" }\n+  for (int i = 0; i < 1; i++)\n+    for (auto x : a)\n+      ;\n+}"}, {"sha": "774f888975934eae2ec7e517953f921b151befc1", "filename": "gcc/testsuite/g++.dg/gomp/for-21.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-21.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,104 @@\n+// { dg-do compile { target c++17 } }\n+\n+void\n+f1 (int a[10][10])\n+{\n+  #pragma omp for collapse (2)\n+  for (int i = 0; i < 10; ++i)\n+    for (auto j : a[i])\t\t// { dg-error \"initializer expression refers to iteration variable 'i'\" }\n+      ;\n+}\n+\n+void\n+f2 (int (&a)[10])\n+{\n+  #pragma omp for collapse (2)\n+  for (auto i : a)\n+    for (int j = i * 2; j < i * 4; j++)\t\t// { dg-error \"initializer expression refers to iteration variable 'i'\" }\n+      ;\n+}\n+\n+struct S { int a, b, c; };\n+\n+void\n+f3 (S (&a)[10])\n+{\n+  #pragma omp for collapse (2)\n+  for (auto [i, j, k] : a)\t\t\t// { dg-error \"use of 'i' before deduction of 'auto'\" \"\" { target *-*-* } .+1 }\n+    for (int l = i; l < j; l += k)\t\t// { dg-error \"use of 'j' before deduction of 'auto'\" }\n+      ;\t\t\t\t\t\t// { dg-error \"use of 'k' before deduction of 'auto'\" \"\" { target *-*-* } .-1 }\n+}\n+\n+template <int N>\n+void\n+f4 (int a[10][10])\n+{\n+  #pragma omp for collapse (2)\n+  for (int i = 0; i < 10; ++i)\t\t// { dg-error \"initializer expression refers to iteration variable 'i'\" }\n+    for (auto j : a[i])\n+      ;\n+}\n+\n+template <int N>\n+void\n+f5 (int (&a)[10])\n+{\n+  #pragma omp for collapse (2)\n+  for (auto i : a)\n+    for (int j = i * 2; j < i * 4; j++)\t\t// { dg-error \"initializer expression refers to iteration variable 'i'\" }\n+      ;\n+}\n+\n+template <int N>\n+void\n+f6 (S (&a)[10])\n+{\n+  #pragma omp for collapse (2)\n+  for (auto [i, j, k] : a)\t\t\t// { dg-error \"use of 'i' before deduction of 'auto'\" \"\" { target *-*-* } .-1 }\n+    for (int l = i; l < j; l += k)\t\t// { dg-error \"use of 'j' before deduction of 'auto'\" }\n+      ;\t\t\t\t\t\t// { dg-error \"use of 'k' before deduction of 'auto'\" \"\" { target *-*-* } .-3 }\n+}\n+\n+template <typename T>\n+void\n+f7 (T a[10][10])\n+{\n+  #pragma omp for collapse (2)\n+  for (T i = 0; i < 10; ++i)\n+    for (auto j : a[i])\t\t// { dg-error \"initializer expression refers to iteration variable 'i'\" }\n+      ;\n+}\n+\n+template <typename T>\n+void\n+f8 (T (&a)[10])\n+{\n+  #pragma omp for collapse (2)\n+  for (auto i : a)\n+    for (T j = i * 2; j < i * 4; j++)\t\t// { dg-error \"initializer expression refers to iteration variable 'i'\" }\n+      ;\n+}\n+\n+template <typename T, typename U>\n+void\n+f9 (U (&a)[10])\n+{\n+  #pragma omp for collapse (2)\n+  for (auto [i, j, k] : a)\t\t\t// { dg-error \"use of 'i' before deduction of 'auto'\" \"\" { target *-*-* } .-1 }\n+    for (T l = i; l < j; l += k)\t\t// { dg-error \"use of 'j' before deduction of 'auto'\" }\n+      ;\t\t\t\t\t\t// { dg-error \"use of 'k' before deduction of 'auto'\" \"\" { target *-*-* } .-3 }\n+}\n+\n+void\n+test ()\n+{\n+  int a[10][10] {};\n+  int b[10] {};\n+  S c[10] {};\n+  f4 <0> (a);\n+  f5 <0> (b);\n+  f6 <0> (c);\n+  f7 (a);\n+  f8 (b);\n+  f9 <int, S> (c);\n+}"}, {"sha": "d3351f5a60971ce777fc0ea33f038f8de9e0b5b0", "filename": "gcc/testsuite/g++.dg/gomp/for-4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-4.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,5 +12,5 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_start\" 1 \"ompexp\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_next\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_next\" 1 \"ompexp\" } } */"}, {"sha": "3bc8d514ad09dcea4cb73e6d9fc192b9d0d2be31", "filename": "gcc/testsuite/g++.dg/gomp/for-5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-5.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,5 +12,5 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_start\" 1 \"ompexp\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_next\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_guided_next\" 1 \"ompexp\" } } */"}, {"sha": "9762be6fd06ec7fe5185a12f91ab329198517346", "filename": "gcc/testsuite/g++.dg/gomp/for-6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-6.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,5 +12,5 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"ompexp\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_maybe_nonmonotonic_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_maybe_nonmonotonic_runtime_next\" 1 \"ompexp\" } } */"}, {"sha": "cd85dbdb9899802c285bf608fad5771262ae9117", "filename": "gcc/testsuite/g++.dg/gomp/loop-4.C", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-4.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,227 @@\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+\n+template <typename T> bool operator == (I<T> &, I<T> &);\n+template <typename T> bool operator == (const I<T> &, const I<T> &);\n+template <typename T> bool operator != (I<T> &, I<T> &);\n+template <typename T> bool operator != (const I<T> &, const I<T> &);\n+template <typename T> bool operator < (I<T> &, I<T> &);\n+template <typename T> bool operator < (const I<T> &, const I<T> &);\n+template <typename T> bool operator <= (I<T> &, I<T> &);\n+template <typename T> bool operator <= (const I<T> &, const I<T> &);\n+template <typename T> bool operator > (I<T> &, I<T> &);\n+template <typename T> bool operator > (const I<T> &, const I<T> &);\n+template <typename T> bool operator >= (I<T> &, I<T> &);\n+template <typename T> bool operator >= (const I<T> &, const I<T> &);\n+template <typename T> typename I<T>::difference_type operator - (I<T> &, I<T> &);\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &, const I<T> &);\n+template <typename T> I<T> operator + (typename I<T>::difference_type, const I<T> &);\n+\n+ptrdiff_t foo (I<int> &);\n+I<int> &bar (I<int> &);\n+I<int> &baz (I<int> *);\n+\n+void\n+f0 ()\n+{\n+  int i;\n+  const int j = 1;\n+  const int k = -1;\n+  const int m = 2;\n+  const int n = -7;\n+  int o = 1;\n+  int p = -1;\n+  #pragma omp for\n+  for (i = 0; i != 64; i += j)\n+    ;\n+  #pragma omp for\n+  for (i = 64; i != 0; i -= j)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i != 64; i -= k)\n+    ;\n+  #pragma omp for\n+  for (i = 64; i != 0; i += k)\n+    ;\n+  #pragma omp for\n+  for (i = 0; i != 64; i += m)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 64; i != 0; i -= m)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 0; i != 64; i -= n)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 64; i != 0; i += n)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 0; i != 64; i += o)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 64; i != 0; i -= o)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 0; i != 64; i -= p)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = 64; i != 0; i += p)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+}\n+\n+void\n+f1 (I<int> &x, I<int> &y, I<int> &u, I<int> &v)\n+{\n+  I<int> i, j;\n+  const int k = 1;\n+  const int l = -1;\n+  const int m = 2;\n+  const int n = -7;\n+  int o = 1;\n+  int p = -1;\n+  #pragma omp for\n+  for (i = x; i != y; i++)\n+    ;\n+  #pragma omp for\n+  for (i = x; y != i; ++i)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i + 1)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = 1 + i)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i--)\n+    ;\n+  #pragma omp for\n+  for (i = y; x != i; --i)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i - 1)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = -1 + i)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i + k)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = k + i)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i - k)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = -k + i)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i - l)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = -l + i)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i + l)\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = l + i)\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i + 2)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = 7 + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i - 2)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = -7 + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i + m)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = m + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i - m)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = -m + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i - n)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = -n + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i + n)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = n + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i + o)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = o + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i - o)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = -o + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = i - p)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = x; i != y; i = -p + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = i + p)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+  #pragma omp for\n+  for (i = y; i != x; i = p + i)\t// { dg-error \"increment is not constant 1 or -1 for != condition\" }\n+    ;\n+}"}, {"sha": "77fc6c339372354d8aec8e82f786ef4ed34f6736", "filename": "gcc/testsuite/g++.dg/gomp/member-2.C", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmember-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -60,17 +60,17 @@ B::m1 ()\n int\n B::m2 ()\n {\n-  #pragma omp parallel private (h)\t// { dg-error \"is predetermined .shared. for .private.\" }\n+  #pragma omp parallel private (h)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     ;\n   #pragma omp parallel firstprivate (h)\n     ;\n-  #pragma omp parallel for lastprivate (h)\t// { dg-error \"is predetermined .shared. for .lastprivate.\" }\n+  #pragma omp parallel for lastprivate (h)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp simd linear (h : 1)\t// { dg-error \"is predetermined .shared. for .linear.\" }\n+  #pragma omp simd linear (h : 1)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel for reduction (+:h)\t// { dg-error \"is predetermined .shared. for .reduction.\" }\n+  #pragma omp parallel for reduction (+:h)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n   #pragma omp parallel for reduction (+:g)\t// { dg-error \"has const type for .reduction.\" }\n@@ -88,7 +88,7 @@ B::m2 ()\n     ;\n   #pragma omp parallel shared (g)\n     ;\n-  #pragma omp parallel shared (h)\t// { dg-error \"is predetermined .shared. for .shared.\" }\n+  #pragma omp parallel shared (h)\n     ;\n   return 0;\n }\n@@ -118,30 +118,30 @@ B::m3 () const\n int\n B::m4 () const\n {\n-  #pragma omp parallel private (a)\t// { dg-error \"is predetermined .shared. for .private.\" }\n+  #pragma omp parallel private (a)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     ;\n   #pragma omp parallel firstprivate (a)\n     ;\n-  #pragma omp parallel for lastprivate (a)\t// { dg-error \"is predetermined .shared. for .lastprivate.\" }\n+  #pragma omp parallel for lastprivate (a)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp simd linear (a : 1)\t// { dg-error \"is predetermined .shared. for .linear.\" }\n+  #pragma omp simd linear (a : 1)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel for reduction (+:a)\t// { dg-error \"is predetermined .shared. for .reduction.\" }\n+  #pragma omp parallel for reduction (+:a)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel private (h)\t// { dg-error \"is predetermined .shared. for .private.\" }\n+  #pragma omp parallel private (h)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     ;\n   #pragma omp parallel firstprivate (h)\n     ;\n-  #pragma omp parallel for lastprivate (h)\t// { dg-error \"is predetermined .shared. for .lastprivate.\" }\n+  #pragma omp parallel for lastprivate (h)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp simd linear (h : 1)\t// { dg-error \"is predetermined .shared. for .linear.\" }\n+  #pragma omp simd linear (h : 1)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel for reduction (+:h)\t// { dg-error \"is predetermined .shared. for .reduction.\" }\n+  #pragma omp parallel for reduction (+:h)\t// { dg-error \"may appear only in .shared. or .firstprivate. clauses\" }\n     for (int i = 0; i < 10; i++)\n       ;\n   #pragma omp parallel for reduction (+:e)\t// { dg-error \"has const type for .reduction.\" }\n@@ -150,7 +150,7 @@ B::m4 () const\n   #pragma omp parallel for reduction (+:g)\t// { dg-error \"has const type for .reduction.\" }\n     for (int i = 0; i < 10; i++)\n       ;\n-  #pragma omp parallel shared (a)\t// { dg-error \"is predetermined .shared. for .shared.\" }\n+  #pragma omp parallel shared (a)\n     ;\n   #pragma omp parallel shared (b)\n     ;\n@@ -162,7 +162,7 @@ B::m4 () const\n     ;\n   #pragma omp parallel shared (g)\n     ;\n-  #pragma omp parallel shared (h)\t// { dg-error \"is predetermined .shared. for .shared.\" }\n+  #pragma omp parallel shared (h)\n     ;\n   return 0;\n }"}, {"sha": "8bb18cc0a5e43c1a7e2f106386ece77c1711bddf", "filename": "gcc/testsuite/g++.dg/gomp/pr33372-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -8,8 +8,8 @@ void f ()\n   extern T n ();\n #pragma omp parallel num_threads(n)\t// { dg-error \"'num_threads' expression must be integral\" }\n   ;\n-#pragma omp parallel for schedule(static, n)\n-  for (int i = 0; i < 10; i++)\t\t// { dg-error \"chunk size expression must be integral\" }\n+#pragma omp parallel for schedule(static, n)\t// { dg-error \"chunk size expression must be integral\" }\n+  for (int i = 0; i < 10; i++)\n     ;\n }\n "}, {"sha": "47a3dfa3f1dda4d2c6189a3dffe5d53861fd4c30", "filename": "gcc/testsuite/g++.dg/gomp/pr33372-3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr33372-3.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -8,8 +8,8 @@ void f ()\n   T n = 6;\n #pragma omp parallel num_threads(n)\t// { dg-error \"'num_threads' expression must be integral\" }\n   ;\n-#pragma omp parallel for schedule(static, n)\n-  for (int i = 0; i < 10; i++)\t\t// { dg-error \"chunk size expression must be integral\" }\n+#pragma omp parallel for schedule(static, n)\t// { dg-error \"chunk size expression must be integral\" }\n+  for (int i = 0; i < 10; i++)\n     ;\n }\n "}, {"sha": "8b31ce8f10f135db3e1f82b61fd771f7048a77b3", "filename": "gcc/testsuite/g++.dg/gomp/pr39495-2.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr39495-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr39495-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr39495-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -13,25 +13,25 @@ foo (void)\n   unsigned int u;\n \n #pragma omp for\n-  for (i = INT_MIN + 6; i != INT_MIN; i--)\t// { dg-error \"invalid controlling predicate\" }\n+  for (i = INT_MIN + 6; i != INT_MIN; i--)\n     ;\n #pragma omp for\n   for (i = INT_MIN + 6; i == INT_MIN; i--)\t// { dg-error \"invalid controlling predicate\" }\n     ;\n #pragma omp for\n-  for (i = INT_MAX - 6; i != INT_MAX; i++)\t// { dg-error \"invalid controlling predicate\" }\n+  for (i = INT_MAX - 6; i != INT_MAX; i++)\n     ;\n #pragma omp for\n   for (i = INT_MAX - 6; i == INT_MAX; i++)\t// { dg-error \"invalid controlling predicate\" }\n     ;\n #pragma omp for\n-  for (u = 6; u != 0; u--)\t\t\t// { dg-error \"invalid controlling predicate\" }\n+  for (u = 6; u != 0; u--)\n     ;\n #pragma omp for\n   for (u = 6; u == 0; u--)\t\t\t// { dg-error \"invalid controlling predicate\" }\n     ;\n #pragma omp for\n-  for (u = UINT_MAX - 6; u != UINT_MAX; u++)\t// { dg-error \"invalid controlling predicate\" }\n+  for (u = UINT_MAX - 6; u != UINT_MAX; u++)\n     ;\n #pragma omp for\n   for (u = UINT_MAX - 6; u == UINT_MAX; u++)\t// { dg-error \"invalid controlling predicate\" }"}, {"sha": "084f04ec90f253cf9980cb5963c6c8459de90c02", "filename": "gcc/testsuite/g++.dg/gomp/predetermined-1.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpredetermined-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpredetermined-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpredetermined-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -15,18 +15,18 @@ const A foo (const A d, const C e)\n   const A f;\n   const B b = { 4 };\n   A g;\n-  #pragma omp parallel default (none)\n-    bar (&a);\n-  #pragma omp parallel default (none)\n-    bar (&b);\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n+    bar (&a);\t\t\t\t// { dg-error \"not specified\" }\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n+    bar (&b);\t\t\t\t// { dg-error \"not specified\" }\n   #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n     bar (&c);\t\t\t\t// { dg-error \"not specified\" }\n-  #pragma omp parallel default (none)\n-    bar (&d);\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n+    bar (&d);\t\t\t\t// { dg-error \"not specified\" }\n   #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n     bar (&e);\t\t\t\t// { dg-error \"not specified\" }\n-  #pragma omp parallel default (none)\n-    bar (&f);\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n+    bar (&f);\t\t\t\t// { dg-error \"not specified\" }\n   #pragma omp parallel default (none)\t// { dg-error \"enclosing 'parallel'\" }\n     bar (&g);\t\t\t\t// { dg-error \"not specified\" }\n   return f;"}, {"sha": "1c24aebbe57c3a6748a38f19b79abe927aa211bd", "filename": "gcc/testsuite/g++.dg/gomp/private-1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fprivate-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fprivate-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fprivate-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -15,17 +15,17 @@ const A foo (const A d, const C e)\n   const A f;\n   const B b = { 4 };\n   A g;\n-  #pragma omp parallel private (a)\t// { dg-error \"predetermined\" }\n+  #pragma omp parallel private (a)\t// { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     bar (&a);\n-  #pragma omp parallel private (b)\t// { dg-error \"predetermined\" }\n+  #pragma omp parallel private (b)\t// { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     bar (&b);\n   #pragma omp parallel private (c)\n     bar (&c);\n-  #pragma omp parallel private (d)\t// { dg-error \"predetermined\" }\n+  #pragma omp parallel private (d)\t// { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     bar (&d);\n   #pragma omp parallel private (e)\n     bar (&e);\n-  #pragma omp parallel private (f)\t// { dg-error \"predetermined\" }\n+  #pragma omp parallel private (f)\t// { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     bar (&f);\n   #pragma omp parallel private (g)\n     bar (&g);"}, {"sha": "ac6908b68ac5d58ca2b09dd476c242df119e943d", "filename": "gcc/testsuite/g++.dg/gomp/sharing-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -61,7 +61,7 @@ main (void)\n       thrglobalvar++;\t/* Predetermined - threadprivate.  */\n       thrlocvar++;\t/* Predetermined - threadprivate.  */\n       foo (i);\t\t/* Predetermined - private (omp for loop variable).  */\n-      foo (constvar.x);\t/* Predetermined - shared (const qualified type).  */\n+      foo (constvar.x);\t/* { dg-error \"not specified in\" } */\n       foo (T::t.i);\t/* Predetermined - shared (static data member).  */\n       foo (*p);\t\t/* *p predetermined - shared (heap allocated */\n       (*p)++;\t\t/* storage).  */"}, {"sha": "23e9133e9b8861d0ddfaa38b50420afa6e6b398b", "filename": "gcc/testsuite/g++.dg/gomp/sharing-2.C", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -5,15 +5,21 @@ struct T\n   int i;\n   mutable int j;\n };\n+struct U\n+{\n+  int i, j;\n+};\n struct S\n {\n   const static int d = 1;\n   const static T e;\n+  const static U f;\n   void foo (int, T);\n };\n \n const int S::d;\n const T S::e = { 2, 3 };\n+const U S::f = { 4, 5 };\n \n void bar (const int &);\n \n@@ -28,20 +34,26 @@ S::foo (const int x, const T y)\n     bar (y.i);\n   #pragma omp parallel firstprivate (e)\t// { dg-error \"is predetermined\" }\n     bar (e.i);\n-  #pragma omp parallel shared (x)\t// { dg-error \"is predetermined\" }\n+  #pragma omp parallel firstprivate (f)\n+    bar (f.i);\n+  #pragma omp parallel shared (x)\n     bar (x);\n   #pragma omp parallel shared (d)\t// { dg-error \"is predetermined\" }\n     bar (d);\n   #pragma omp parallel shared (e)\t// { dg-error \"is predetermined\" }\n     bar (e.i);\n+  #pragma omp parallel shared (f)\t// { dg-error \"is predetermined\" }\n+    bar (f.i);\n   #pragma omp parallel shared (y)\n     bar (y.i);\n-  #pragma omp parallel private (x)\t// { dg-error \"is predetermined\" }\n+  #pragma omp parallel private (x)\t// { dg-error \"may appear only in 'shared' or 'firstprivate' clauses\" }\n     bar (x);\n   #pragma omp parallel private (d)\t// { dg-error \"is predetermined\" }\n     bar (d);\n   #pragma omp parallel private (y)\n     bar (y.i);\n   #pragma omp parallel private (e)\t// { dg-error \"is predetermined\" }\n     bar (e.i);\n+  #pragma omp parallel private (f)\t// { dg-error \"is predetermined\" }\n+    bar (f.i);\n }"}, {"sha": "3903814aaaed8c296ad6384bf51504bbf4d37c71", "filename": "gcc/testsuite/g++.dg/gomp/simd-2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsimd-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsimd-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsimd-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,21 @@\n+int a[32], b[32];\n+\n+void\n+foo (void)\n+{\n+  int i, j;\n+  #pragma omp simd linear(i, j) collapse(2)\t// { dg-error \"iteration variable 'i' should not be linear\" }\n+  for (i = 0; i < 32; ++i)\t\t\t// { dg-error \"iteration variable 'j' should not be linear\" \"\" { target *-*-* } .-1 }\n+    for (j = 0; j < 32; ++j)\n+      a[i] += b[j];\n+}\n+\n+void\n+bar (void)\n+{\n+  static int i, j;\n+  #pragma omp for simd linear(i, j) collapse(2)\t// { dg-error \"iteration variable 'i' should not be linear\" \"\" { target *-*-* } .+1 }\n+  for (i = 0; i < 32; ++i)\t\t\t// { dg-error \"iteration variable 'j' should not be linear\" }\n+    for (j = 0; j < 32; ++j)\n+      a[i] += b[j];\n+}"}, {"sha": "627c6c6e2a9082bebb5f68151d830159585a85ac", "filename": "gcc/testsuite/g++.dg/gomp/tpl-atomic-2.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -6,21 +6,21 @@ struct S { int x; } s;\n // even when the templates are never instantiated.\n template<typename T> void f1()\n {\n-  #pragma omp atomic\n-  s += 1;\t\t// { dg-error \"invalid\" }\n+  #pragma omp atomic\t// { dg-error \"invalid\" }\n+  s += 1;\n }\n \n template<typename T> void f2(float *f)\n {\n-  #pragma omp atomic\n-  *f |= 1;\t\t// { dg-error \"invalid|evaluation\" }\n+  #pragma omp atomic\t// { dg-error \"invalid\" }\n+  *f |= 1;\t\t// { dg-error \"evaluation\" }\n }\n \n // Here the rhs is dependent, but not type dependent.\n template<typename T> void f3(float *f)\n {\n-  #pragma omp atomic\n-  *f |= sizeof (T);\t// { dg-error \"invalid|evaluation\" }\n+  #pragma omp atomic\t// { dg-error \"invalid\" }\n+  *f |= sizeof (T);\t// { dg-error \"evaluation\" }\n }\n \n // And the converse, no error here because we're never fed a T.\n@@ -35,6 +35,6 @@ template<typename T> void f4(T *t)\n // of the semantic analysis concurrent with that.\n template<typename T> void f5(float *f)\n {\n-  #pragma omp atomic\n-  *f |= (T)sizeof(T);\t// { dg-error \"invalid|evaluation\" \"\" { xfail *-*-* } }\n+  #pragma omp atomic\t// { dg-error \"invalid\" \"\" { xfail *-*-* } }\n+  *f |= (T)sizeof(T);\t// { dg-error \"evaluation\" \"\" { xfail *-*-* } }\n }"}, {"sha": "099f03fe89d3ec4a296aec8324fa4c275b4296bc", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.24.1.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -10,14 +10,15 @@ a24 (int a)\n   const int c = 1;\n   int i = 0;\n   int l = 0;\n-#pragma omp parallel default(none) private(a) shared(z) /* { dg-line omp_parallel } */\n+#pragma omp parallel default(none) private(a) shared(z, c) /* { dg-line omp_parallel } */\n   {\n     int j = omp_get_num_threads ();\n-    /* O.K. - j is declared within parallel region */\n-    /* O.K.  -  a is listed in private clause */\n-    /*       -  z is listed in shared clause */\n+\t/* O.K. - j is declared within parallel region */\n+    a = z[j]; /* O.K.  -  a is listed in private clause */\n+\t      /*       -  z is listed in shared clause */\n     x = c;\t\t\t/* O.K.  -  x is threadprivate */\n-    \t\t\t\t/*       -  c has const-qualified type */\n+    \t\t\t\t/*       -  c has const-qualified type and\n+\t\t\t\t\t      is listed in shared clause */\n     z[i] = y;\n     /* { dg-error \"'i' not specified\" \"\" { target *-*-* } .-1 } */\n     /* { dg-error \"enclosing 'parallel'\" \"\" { target *-*-* } omp_parallel } */"}, {"sha": "70cfb35f47006927952ac8484bf4b70d6e5f7bb6", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -27,7 +27,7 @@ void f1(void)\n   #pragma omp atomic\n     bar() += 1;\t\t/* { dg-error \"lvalue required\" } */\n   #pragma omp atomic a\t/* { dg-error \"expected end of line\" } */\n-    x++;\n+    x++;\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target *-*-* } .-1 } */\n   #pragma omp atomic\n     ;\t\t\t/* { dg-error \"expected expression\" } */\n   #pragma omp atomic"}, {"sha": "9d34b04160698c5071b0186de3f780023045c0c4", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -86,18 +86,18 @@ foo (int x)\n #pragma omp p for linear (t) /* { dg-error \"predetermined 'threadprivate\" } */\n   for (i = 0; i < 10; i++)\n     ;\n-#pragma omp p shared (c) /* { dg-error \"predetermined 'shared'\" } */\n+#pragma omp p shared (c)\n     ;\n-#pragma omp p private (c) /* { dg-error \"predetermined 'shared'\" } */\n+#pragma omp p private (c) /* { dg-error \"'const' qualified 'c' may appear only in 'shared' or 'firstprivate' clauses\" } */\n     ;\n #pragma omp p firstprivate (c)\n     ;\n-#pragma omp p for lastprivate (c) /* { dg-error \"predetermined 'shared'\" } */\n+#pragma omp p for lastprivate (c) /* { dg-error \"'const' qualified 'c' may appear only in 'shared' or 'firstprivate' clauses\" } */\n   for (i = 0; i < 10; i++)\n     ;\n-#pragma omp p reduction (*:c) /* { dg-error \"predetermined 'shared'\" } */\n+#pragma omp p reduction (*:c) /* { dg-error \"'const' qualified 'c' may appear only in 'shared' or 'firstprivate' clauses\" } */\n     ;\n-#pragma omp p for linear (c) /* { dg-error \"predetermined 'shared'\" } */\n+#pragma omp p for linear (c) /* { dg-error \"'const' qualified 'c' may appear only in 'shared' or 'firstprivate' clauses\" } */\n   for (i = 0; i < 10; i++)\n     ;\n }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gcc.dg/gomp/combined-1.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,23 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O1 -fopenmp -fdump-tree-optimized\" } */\n-\n-int a[10];\n-int foo (void)\n-{\n-    int i;\n-#pragma omp parallel for schedule(runtime)\n-    for (i = 0; i < 10; i++)\n-      a[i] = i;\n-#pragma omp parallel\n-#pragma omp for schedule(runtime)\n-    for (i = 0; i < 10; i++)\n-      a[i] = 10 - i;\n-#pragma omp parallel\n-      {\n-#pragma omp for schedule(runtime)\n-\tfor (i = 0; i < 10; i++)\n-\t  a[i] = i;\n-      }\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_runtime\" 3 \"optimized\" } } */"}, {"sha": "d3351f5a60971ce777fc0ea33f038f8de9e0b5b0", "filename": "gcc/testsuite/gcc.dg/gomp/for-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,5 +12,5 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_start\" 1 \"ompexp\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_next\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_dynamic_next\" 1 \"ompexp\" } } */"}, {"sha": "3bc8d514ad09dcea4cb73e6d9fc192b9d0d2be31", "filename": "gcc/testsuite/gcc.dg/gomp/for-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,5 +12,5 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_start\" 1 \"ompexp\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_next\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_nonmonotonic_guided_next\" 1 \"ompexp\" } } */"}, {"sha": "9762be6fd06ec7fe5185a12f91ab329198517346", "filename": "gcc/testsuite/gcc.dg/gomp/for-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -12,5 +12,5 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"ompexp\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_maybe_nonmonotonic_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_maybe_nonmonotonic_runtime_next\" 1 \"ompexp\" } } */"}, {"sha": "c0b05cbe9b39182474093a2a75bd2ac3da280c3a", "filename": "gcc/testsuite/gcc.dg/gomp/pr39495-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr39495-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr39495-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr39495-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -13,25 +13,25 @@ foo (void)\n   unsigned int u;\n \n #pragma omp for\n-  for (i = INT_MIN + 6; i != INT_MIN; i--)\t/* { dg-error \"invalid controlling predicate\" } */\n+  for (i = INT_MIN + 6; i != INT_MIN; i--)\n     ;\n #pragma omp for\n   for (i = INT_MIN + 6; i == INT_MIN; i--)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n-  for (i = INT_MAX - 6; i != INT_MAX; i++)\t/* { dg-error \"invalid controlling predicate\" } */\n+  for (i = INT_MAX - 6; i != INT_MAX; i++)\n     ;\n #pragma omp for\n   for (i = INT_MAX - 6; i == INT_MAX; i++)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n-  for (u = 6; u != 0; u--)\t\t\t/* { dg-error \"invalid controlling predicate\" } */\n+  for (u = 6; u != 0; u--)\n     ;\n #pragma omp for\n   for (u = 6; u == 0; u--)\t\t\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n-  for (u = UINT_MAX - 6; u != UINT_MAX; u++)\t/* { dg-error \"invalid controlling predicate\" } */\n+  for (u = UINT_MAX - 6; u != UINT_MAX; u++)\n     ;\n #pragma omp for\n   for (u = UINT_MAX - 6; u == UINT_MAX; u++)\t/* { dg-error \"invalid controlling predicate\" } */"}, {"sha": "f8ac8b6bbfec430dd8b484f40e7baa4cd2d37255", "filename": "gcc/testsuite/gcc.dg/gomp/reduction-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Freduction-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct S {};\n+void foo (void *, void *);\n+void bar (void *, void *);\n+void baz (void *);\n+#pragma omp declare reduction(+:struct S:foo (&omp_out, &omp_in))initializer(bar(&omp_priv, &omp_orig))\n+\n+void\n+test1 (void)\n+{\n+  struct S s;\n+  int i;\n+  #pragma omp parallel reduction(+:s)\n+    baz (&s);\n+  #pragma omp parallel reduction(task, +:s)\t/* { dg-error \"zero sized type 'struct S' in 'reduction' clause\" } */\n+    baz (&s);\n+  #pragma omp taskloop reduction(+:s)\t\t/* { dg-error \"zero sized type 'struct S' in 'reduction' clause\" } */\n+  for (i = 0; i < 1; i++)\n+    baz (&s);\n+  #pragma omp taskloop simd reduction(+:s)\t/* { dg-error \"zero sized type 'struct S' in 'reduction' clause\" } */\n+  for (i = 0; i < 1; i++)\n+    baz (&s);\n+  #pragma omp taskgroup task_reduction(+:s)\t/* { dg-error \"zero sized type 'struct S' in 'task_reduction' clause\" } */\n+  {\n+    #pragma omp task in_reduction(+:s)\t\t/* { dg-error \"zero sized type 'struct S' in 'in_reduction' clause\" } */\n+    baz (&s);\n+  }\n+}"}, {"sha": "79abb64cdd7fd6d0c3c66f22f43dcd6f574f8868", "filename": "gcc/testsuite/gcc.dg/gomp/sharing-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -44,7 +44,7 @@ main (void)\n       thrglobalvar++;\t/* Predetermined - threadprivate.  */\n       thrlocvar++;\t/* Predetermined - threadprivate.  */\n       foo (i);\t\t/* Predetermined - private (omp for loop variable).  */\n-      foo (constvar);\t/* Predetermined - shared (const qualified type).  */\n+      foo (constvar);\t/* { dg-error \"not specified in\" } */\n       foo (*p);\t\t/* *p predetermined - shared (heap allocated */\n       (*p)++;\t\t/* storage).  */\n       bar (p);\t\t/* Explicitly determined - private.  */"}, {"sha": "00aa159eafa8c1296503940abe6f4adb7a0fb941", "filename": "gcc/testsuite/gcc.dg/gomp/simd-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,21 @@\n+int a[32], b[32];\n+\n+void\n+foo (void)\n+{\n+  int i, j;\n+  #pragma omp simd linear(i, j) collapse(2)\t/* { dg-error \"iteration variable 'i' should not be linear\" } */\n+  for (i = 0; i < 32; ++i)\t\t\t/* { dg-error \"iteration variable 'j' should not be linear\" \"\" { target *-*-* } .-1 } */\n+    for (j = 0; j < 32; ++j)\n+      a[i] += b[j];\n+}\n+\n+void\n+bar (void)\n+{\n+  static int i, j;\n+  #pragma omp for simd linear(i, j) collapse(2)\t/* { dg-error \"iteration variable 'i' should not be linear\" } */\n+  for (i = 0; i < 32; ++i)\t\t\t/* { dg-error \"iteration variable 'j' should not be linear\" \"\" { target *-*-* } .-1 } */\n+    for (j = 0; j < 32; ++j)\n+      a[i] += b[j];\n+}"}, {"sha": "db7f50b2cde7381db3426c5dad08784ed52ffadd", "filename": "gcc/testsuite/gcc.dg/gomp/teams-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -23,8 +23,8 @@ foo (int x)\n \n   switch (x) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n-  #pragma omp target teams\n-    { case 0:; } // { dg-warning \"statement will never be executed\" }\n+  #pragma omp target teams // { dg-warning \"statement will never be executed\" }\n+    { case 0:; }\n   }\n }\n "}, {"sha": "cec95e72c54efca9783c7397ba895cd2a32485ba", "filename": "gcc/tree-core.h", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -258,6 +258,12 @@ enum omp_clause_code {\n \t\treductions.  */\n   OMP_CLAUSE_REDUCTION,\n \n+  /* OpenMP clause: task_reduction (operator:variable_list).  */\n+  OMP_CLAUSE_TASK_REDUCTION,\n+\n+  /* OpenMP clause: in_reduction (operator:variable_list).  */\n+  OMP_CLAUSE_IN_REDUCTION,\n+\n   /* OpenMP clause: copyin (variable_list).  */\n   OMP_CLAUSE_COPYIN,\n \n@@ -273,6 +279,9 @@ enum omp_clause_code {\n   /* OpenMP clause: depend ({in,out,inout}:variable-list).  */\n   OMP_CLAUSE_DEPEND,\n \n+  /* OpenMP clause: nontemporal (variable-list).  */\n+  OMP_CLAUSE_NONTEMPORAL,\n+\n   /* OpenMP clause: uniform (argument-list).  */\n   OMP_CLAUSE_UNIFORM,\n \n@@ -331,6 +340,9 @@ enum omp_clause_code {\n   /* Internal clause: temporary for combined loops expansion.  */\n   OMP_CLAUSE__LOOPTEMP_,\n \n+  /* Internal clause: temporary for task reductions.  */\n+  OMP_CLAUSE__REDUCTEMP_,\n+\n   /* OpenACC/OpenMP clause: if (scalar-expression).  */\n   OMP_CLAUSE_IF,\n \n@@ -493,6 +505,36 @@ enum omp_clause_default_kind {\n   OMP_CLAUSE_DEFAULT_LAST\n };\n \n+enum omp_clause_defaultmap_kind {\n+  OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED,\n+  OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR,\n+  OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE,\n+  OMP_CLAUSE_DEFAULTMAP_CATEGORY_ALLOCATABLE,\n+  OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER,\n+  OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK = 7,\n+  OMP_CLAUSE_DEFAULTMAP_ALLOC = 1 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_TO = 2 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_FROM = 3 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_TOFROM = 4 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_FIRSTPRIVATE\n+    = 5 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_NONE = 6 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_DEFAULT\n+    = 7 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1),\n+  OMP_CLAUSE_DEFAULTMAP_MASK = 7 * (OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK + 1)\n+};\n+\n+/* memory-order-clause on OpenMP atomic/flush constructs or\n+   argument of atomic_default_mem_order clause.  */\n+enum omp_memory_order {\n+  OMP_MEMORY_ORDER_UNSPECIFIED,\n+  OMP_MEMORY_ORDER_RELAXED,\n+  OMP_MEMORY_ORDER_ACQUIRE,\n+  OMP_MEMORY_ORDER_RELEASE,\n+  OMP_MEMORY_ORDER_ACQ_REL,\n+  OMP_MEMORY_ORDER_SEQ_CST\n+};\n+\n /* There is a TYPE_QUAL value for each type qualifier.  They can be\n    combined by bitwise-or to form the complete set of qualifiers for a\n    type.  */\n@@ -983,6 +1025,9 @@ struct GTY(()) tree_base {\n     /* Internal function code.  */\n     enum internal_fn ifn;\n \n+    /* OMP_ATOMIC* memory order.  */\n+    enum omp_memory_order omp_atomic_memory_order;\n+\n     /* The following two fields are used for MEM_REF and TARGET_MEM_REF\n        expression trees and specify known data non-dependences.  For\n        two memory references in a function they are known to not\n@@ -1095,7 +1140,7 @@ struct GTY(()) tree_base {\n \t   OMP_CLAUSE_MAP\n \n        OMP_CLAUSE_REDUCTION_OMP_ORIG_REF in\n-\t   OMP_CLAUSE_REDUCTION\n+\t   OMP_CLAUSE_{,TASK_,IN_}REDUCTION\n \n        TRANSACTION_EXPR_RELAXED in\n \t   TRANSACTION_EXPR\n@@ -1123,9 +1168,6 @@ struct GTY(()) tree_base {\n        OMP_PARALLEL_COMBINED in\n            OMP_PARALLEL\n \n-       OMP_ATOMIC_SEQ_CST in\n-\t   OMP_ATOMIC*\n-\n        OMP_CLAUSE_PRIVATE_OUTER_REF in\n \t   OMP_CLAUSE_PRIVATE\n \n@@ -1373,8 +1415,10 @@ enum omp_clause_depend_kind\n   OMP_CLAUSE_DEPEND_IN,\n   OMP_CLAUSE_DEPEND_OUT,\n   OMP_CLAUSE_DEPEND_INOUT,\n+  OMP_CLAUSE_DEPEND_MUTEXINOUTSET,\n   OMP_CLAUSE_DEPEND_SOURCE,\n   OMP_CLAUSE_DEPEND_SINK,\n+  OMP_CLAUSE_DEPEND_DEPOBJ,\n   OMP_CLAUSE_DEPEND_LAST\n };\n \n@@ -1463,6 +1507,7 @@ struct GTY(()) tree_omp_clause {\n     enum tree_code                 reduction_code;\n     enum omp_clause_linear_kind    linear_kind;\n     enum tree_code                 if_modifier;\n+    enum omp_clause_defaultmap_kind defaultmap_kind;\n     /* The dimension a OMP_CLAUSE__GRIDDIM_ clause of a gridified target\n        construct describes.  */\n     unsigned int\t\t   dimension;"}, {"sha": "5aa782b1edbdca06d68f60d5583c18a88ba781e1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1515,7 +1515,8 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \n \tcase GIMPLE_OMP_TASKGROUP:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n-\t  copy = gimple_build_omp_taskgroup (s1);\n+\t  copy = gimple_build_omp_taskgroup\n+\t\t   (s1, gimple_omp_taskgroup_clauses (stmt));\n \t  break;\n \n \tcase GIMPLE_OMP_ORDERED:"}, {"sha": "c964b7a15b2d7b82fa45de03f7536cb0855f4200", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1314,6 +1314,8 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t      convert_nonlocal_reference_op\n \t\t(&OMP_CLAUSE_ALIGNED_ALIGNMENT (clause), &dummy, wi);\n \t    }\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \t  /* Like do_decl_clause, but don't add any suppression.  */\n \t  decl = OMP_CLAUSE_DECL (clause);\n \t  if (VAR_P (decl)\n@@ -1322,8 +1324,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t  if (decl_function_context (decl) != info->context)\n \t    {\n \t      OMP_CLAUSE_DECL (clause) = get_nonlocal_debug_decl (info, decl);\n-\t      if (OMP_CLAUSE_CODE (clause) != OMP_CLAUSE_PRIVATE)\n-\t\tneed_chain = true;\n+\t      need_chain = true;\n \t    }\n \t  break;\n \n@@ -1365,6 +1366,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t  /* The following clauses are only added during OMP lowering; nested\n \t     function decomposition happens before that.  */\n \tcase OMP_CLAUSE__LOOPTEMP_:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \tcase OMP_CLAUSE__GRIDDIM_:\n \t  /* Anything else.  */\n@@ -2000,6 +2002,8 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t      convert_local_reference_op\n \t\t(&OMP_CLAUSE_ALIGNED_ALIGNMENT (clause), &dummy, wi);\n \t    }\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \t  /* Like do_decl_clause, but don't add any suppression.  */\n \t  decl = OMP_CLAUSE_DECL (clause);\n \t  if (VAR_P (decl)\n@@ -2056,6 +2060,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t  /* The following clauses are only added during OMP lowering; nested\n \t     function decomposition happens before that.  */\n \tcase OMP_CLAUSE__LOOPTEMP_:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \tcase OMP_CLAUSE__GRIDDIM_:\n \t  /* Anything else.  */"}, {"sha": "94824a0236f0dd2a3ff546ef6b2a6aff39e15478", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1130,7 +1130,8 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n \n   tmp_load = create_tmp_var (TREE_TYPE (TREE_TYPE (addr)));\n   tmp_load = make_ssa_name (tmp_load);\n-  load = gimple_build_omp_atomic_load (tmp_load, addr);\n+  load = gimple_build_omp_atomic_load (tmp_load, addr,\n+\t\t\t\t       OMP_MEMORY_ORDER_RELAXED);\n   SSA_NAME_DEF_STMT (tmp_load) = load;\n   gsi = gsi_start_bb (new_bb);\n   gsi_insert_after (&gsi, load, GSI_NEW_STMT);\n@@ -1146,7 +1147,9 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n   name = force_gimple_operand_gsi (&gsi, x, true, NULL_TREE, true,\n \t\t\t\t   GSI_CONTINUE_LINKING);\n \n-  gsi_insert_after (&gsi, gimple_build_omp_atomic_store (name), GSI_NEW_STMT);\n+  gimple *store = gimple_build_omp_atomic_store (name,\n+\t\t\t\t\t\t OMP_MEMORY_ORDER_RELAXED);\n+  gsi_insert_after (&gsi, store, GSI_NEW_STMT);\n   return 1;\n }\n "}, {"sha": "99eca4ae4043d3305a2745f46c4a7b1f225761b5", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 160, "deletions": 16, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -392,6 +392,31 @@ dump_array_domain (pretty_printer *pp, tree domain, int spc, dump_flags_t flags)\n }\n \n \n+/* Dump OpenMP iterators ITER.  */\n+\n+static void\n+dump_omp_iterators (pretty_printer *pp, tree iter, int spc, dump_flags_t flags)\n+{\n+  pp_string (pp, \"iterator(\");\n+  for (tree it = iter; it; it = TREE_CHAIN (it))\n+    {\n+      if (it != iter)\n+\tpp_string (pp, \", \");\n+      dump_generic_node (pp, TREE_TYPE (TREE_VEC_ELT (it, 0)), spc, flags,\n+\t\t\t false);\n+      pp_space (pp);\n+      dump_generic_node (pp, TREE_VEC_ELT (it, 0), spc, flags, false);\n+      pp_equal (pp);\n+      dump_generic_node (pp, TREE_VEC_ELT (it, 1), spc, flags, false);\n+      pp_colon (pp);\n+      dump_generic_node (pp, TREE_VEC_ELT (it, 2), spc, flags, false);\n+      pp_colon (pp);\n+      dump_generic_node (pp, TREE_VEC_ELT (it, 3), spc, flags, false);\n+    }\n+  pp_right_paren (pp);\n+}\n+\n+\n /* Dump OpenMP clause CLAUSE.  PP, CLAUSE, SPC and FLAGS are as in\n    dump_generic_node.  */\n \n@@ -413,7 +438,13 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       goto print_remap;\n     case OMP_CLAUSE_LASTPRIVATE:\n       name = \"lastprivate\";\n-      goto print_remap;\n+      if (!OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (clause))\n+\tgoto print_remap;\n+      pp_string (pp, \"lastprivate(conditional:\");\n+      dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n     case OMP_CLAUSE_COPYIN:\n       name = \"copyin\";\n       goto print_remap;\n@@ -432,12 +463,18 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n     case OMP_CLAUSE__LOOPTEMP_:\n       name = \"_looptemp_\";\n       goto print_remap;\n+    case OMP_CLAUSE__REDUCTEMP_:\n+      name = \"_reductemp_\";\n+      goto print_remap;\n     case OMP_CLAUSE_TO_DECLARE:\n       name = \"to\";\n       goto print_remap;\n     case OMP_CLAUSE_LINK:\n       name = \"link\";\n       goto print_remap;\n+    case OMP_CLAUSE_NONTEMPORAL:\n+      name = \"nontemporal\";\n+      goto print_remap;\n   print_remap:\n       pp_string (pp, name);\n       pp_left_paren (pp);\n@@ -446,8 +483,20 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE_TASK_REDUCTION:\n+    case OMP_CLAUSE_IN_REDUCTION:\n+      pp_string (pp, OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_IN_REDUCTION\n+\t\t     ? \"in_\" : \"task_\");\n+      /* FALLTHRU */\n     case OMP_CLAUSE_REDUCTION:\n       pp_string (pp, \"reduction(\");\n+      if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_REDUCTION)\n+\t{\n+\t  if (OMP_CLAUSE_REDUCTION_TASK (clause))\n+\t    pp_string (pp, \"task,\");\n+\t  else if (OMP_CLAUSE_REDUCTION_INSCAN (clause))\n+\t    pp_string (pp, \"inscan,\");\n+\t}\n       if (OMP_CLAUSE_REDUCTION_CODE (clause) != ERROR_MARK)\n \t{\n \t  pp_string (pp,\n@@ -464,7 +513,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       switch (OMP_CLAUSE_IF_MODIFIER (clause))\n \t{\n \tcase ERROR_MARK: break;\n+\tcase VOID_CST: pp_string (pp, \"cancel:\"); break;\n \tcase OMP_PARALLEL: pp_string (pp, \"parallel:\"); break;\n+\tcase OMP_SIMD: pp_string (pp, \"simd:\"); break;\n \tcase OMP_TASK: pp_string (pp, \"task:\"); break;\n \tcase OMP_TASKLOOP: pp_string (pp, \"taskloop:\"); break;\n \tcase OMP_TARGET_DATA: pp_string (pp, \"target data:\"); break;\n@@ -643,18 +694,27 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_string (pp, \"depend(\");\n       switch (OMP_CLAUSE_DEPEND_KIND (clause))\n \t{\n+\tcase OMP_CLAUSE_DEPEND_DEPOBJ:\n+\t  name = \"depobj\";\n+\t  break;\n \tcase OMP_CLAUSE_DEPEND_IN:\n-\t  pp_string (pp, \"in\");\n+\t  name = \"in\";\n \t  break;\n \tcase OMP_CLAUSE_DEPEND_OUT:\n-\t  pp_string (pp, \"out\");\n+\t  name = \"out\";\n \t  break;\n \tcase OMP_CLAUSE_DEPEND_INOUT:\n-\t  pp_string (pp, \"inout\");\n+\t  name = \"inout\";\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND_MUTEXINOUTSET:\n+\t  name = \"mutexinoutset\";\n \t  break;\n \tcase OMP_CLAUSE_DEPEND_SOURCE:\n \t  pp_string (pp, \"source)\");\n \t  return;\n+\tcase OMP_CLAUSE_DEPEND_LAST:\n+\t  name = \"__internal__\";\n+\t  break;\n \tcase OMP_CLAUSE_DEPEND_SINK:\n \t  pp_string (pp, \"sink:\");\n \t  for (tree t = OMP_CLAUSE_DECL (clause); t; t = TREE_CHAIN (t))\n@@ -680,10 +740,21 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      pp_colon (pp);\n-      dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n-\t\t\t spc, flags, false);\n-      pp_right_paren (pp);\n+      {\n+\ttree t = OMP_CLAUSE_DECL (clause);\n+\tif (TREE_CODE (t) == TREE_LIST\n+\t    && TREE_PURPOSE (t)\n+\t    && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t  {\n+\t    dump_omp_iterators (pp, TREE_PURPOSE (t), spc, flags);\n+\t    pp_colon (pp);\n+\t    t = TREE_VALUE (t);\n+\t  }\n+\tpp_string (pp, name);\n+\tpp_colon (pp);\n+\tdump_generic_node (pp, t, spc, flags, false);\n+\tpp_right_paren (pp);\n+      }\n       break;\n \n     case OMP_CLAUSE_MAP:\n@@ -900,7 +971,53 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       break;\n \n     case OMP_CLAUSE_DEFAULTMAP:\n-      pp_string (pp, \"defaultmap(tofrom:scalar)\");\n+      pp_string (pp, \"defaultmap(\");\n+      switch (OMP_CLAUSE_DEFAULTMAP_BEHAVIOR (clause))\n+\t{\n+\tcase OMP_CLAUSE_DEFAULTMAP_ALLOC:\n+\t  pp_string (pp, \"alloc\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_TO:\n+\t  pp_string (pp, \"to\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_FROM:\n+\t  pp_string (pp, \"from\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_TOFROM:\n+\t  pp_string (pp, \"tofrom\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_FIRSTPRIVATE:\n+\t  pp_string (pp, \"firstprivate\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_NONE:\n+\t  pp_string (pp, \"none\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_DEFAULT:\n+\t  pp_string (pp, \"default\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      switch (OMP_CLAUSE_DEFAULTMAP_CATEGORY (clause))\n+\t{\n+\tcase OMP_CLAUSE_DEFAULTMAP_CATEGORY_UNSPECIFIED:\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_CATEGORY_SCALAR:\n+\t  pp_string (pp, \":scalar\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_CATEGORY_AGGREGATE:\n+\t  pp_string (pp, \":aggregate\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_CATEGORY_ALLOCATABLE:\n+\t  pp_string (pp, \":allocatable\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULTMAP_CATEGORY_POINTER:\n+\t  pp_string (pp, \":pointer\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      pp_right_paren (pp);\n       break;\n \n     case OMP_CLAUSE__SIMDUID_:\n@@ -1218,6 +1335,34 @@ dump_block_node (pretty_printer *pp, tree block, int spc, dump_flags_t flags)\n     }\n }\n \n+/* Dump #pragma omp atomic memory order clause.  */\n+\n+void\n+dump_omp_atomic_memory_order (pretty_printer *pp, enum omp_memory_order mo)\n+{\n+  switch (mo)\n+    {\n+    case OMP_MEMORY_ORDER_RELAXED:\n+      pp_string (pp, \" relaxed\");\n+      break;\n+    case OMP_MEMORY_ORDER_SEQ_CST:\n+      pp_string (pp, \" seq_cst\");\n+      break;\n+    case OMP_MEMORY_ORDER_ACQ_REL:\n+      pp_string (pp, \" acq_rel\");\n+      break;\n+    case OMP_MEMORY_ORDER_ACQUIRE:\n+      pp_string (pp, \" acquire\");\n+      break;\n+    case OMP_MEMORY_ORDER_RELEASE:\n+      pp_string (pp, \" release\");\n+      break;\n+    case OMP_MEMORY_ORDER_UNSPECIFIED:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n /* Dump the node NODE on the pretty_printer PP, SPC spaces of\n    indent.  FLAGS specifies details to show in the dump (see TDF_* in\n@@ -2991,7 +3136,8 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       break;\n \n     case OMP_TASK:\n-      pp_string (pp, \"#pragma omp task\");\n+      pp_string (pp, OMP_TASK_BODY (node) ? \"#pragma omp task\"\n+\t\t\t\t\t  : \"#pragma omp taskwait\");\n       dump_omp_clauses (pp, OMP_TASK_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n@@ -3122,6 +3268,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \n     case OMP_TASKGROUP:\n       pp_string (pp, \"#pragma omp taskgroup\");\n+      dump_omp_clauses (pp, OMP_TASKGROUP_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n     case OMP_ORDERED:\n@@ -3144,8 +3291,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \n     case OMP_ATOMIC:\n       pp_string (pp, \"#pragma omp atomic\");\n-      if (OMP_ATOMIC_SEQ_CST (node))\n-\tpp_string (pp, \" seq_cst\");\n+      dump_omp_atomic_memory_order (pp, OMP_ATOMIC_MEMORY_ORDER (node));\n       newline_and_indent (pp, spc + 2);\n       dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_space (pp);\n@@ -3156,8 +3302,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \n     case OMP_ATOMIC_READ:\n       pp_string (pp, \"#pragma omp atomic read\");\n-      if (OMP_ATOMIC_SEQ_CST (node))\n-\tpp_string (pp, \" seq_cst\");\n+      dump_omp_atomic_memory_order (pp, OMP_ATOMIC_MEMORY_ORDER (node));\n       newline_and_indent (pp, spc + 2);\n       dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_space (pp);\n@@ -3166,8 +3311,7 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n     case OMP_ATOMIC_CAPTURE_OLD:\n     case OMP_ATOMIC_CAPTURE_NEW:\n       pp_string (pp, \"#pragma omp atomic capture\");\n-      if (OMP_ATOMIC_SEQ_CST (node))\n-\tpp_string (pp, \" seq_cst\");\n+      dump_omp_atomic_memory_order (pp, OMP_ATOMIC_MEMORY_ORDER (node));\n       newline_and_indent (pp, spc + 2);\n       dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_space (pp);"}, {"sha": "ea4ebee2301be4580321efd4b471cff9dbc3b0cc", "filename": "gcc/tree-pretty-print.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -40,6 +40,8 @@ extern void print_generic_stmt_indented (FILE *, tree, dump_flags_t, int);\n extern void print_generic_expr (FILE *, tree, dump_flags_t = TDF_NONE);\n extern char *print_generic_expr_to_str (tree);\n extern void dump_omp_clauses (pretty_printer *, tree, int, dump_flags_t);\n+extern void dump_omp_atomic_memory_order (pretty_printer *,\n+\t\t\t\t\t  enum omp_memory_order);\n extern int dump_generic_node (pretty_printer *, tree, int, dump_flags_t, bool);\n extern void print_declaration (pretty_printer *, tree, int, dump_flags_t);\n extern int op_code_prio (enum tree_code);"}, {"sha": "811d673bf2e2f7b1e34d2d824defc3736ae60786", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -447,6 +447,8 @@ unpack_ts_omp_clause_value_fields (struct data_in *data_in,\n \t\t\t  OMP_CLAUSE_PROC_BIND_LAST);\n       break;\n     case OMP_CLAUSE_REDUCTION:\n+    case OMP_CLAUSE_TASK_REDUCTION:\n+    case OMP_CLAUSE_IN_REDUCTION:\n       OMP_CLAUSE_REDUCTION_CODE (expr)\n \t= bp_unpack_enum (bp, tree_code, MAX_TREE_CODES);\n       break;"}, {"sha": "ac798a3e9344e6bb349773f68e14f85d966cc487", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -395,6 +395,8 @@ pack_ts_omp_clause_value_fields (struct output_block *ob,\n \t\t    OMP_CLAUSE_PROC_BIND_KIND (expr));\n       break;\n     case OMP_CLAUSE_REDUCTION:\n+    case OMP_CLAUSE_TASK_REDUCTION:\n+    case OMP_CLAUSE_IN_REDUCTION:\n       bp_pack_enum (bp, tree_code, MAX_TREE_CODES,\n \t\t    OMP_CLAUSE_REDUCTION_CODE (expr));\n       break;\n@@ -836,12 +838,18 @@ write_ts_omp_clause_tree_pointers (struct output_block *ob, tree expr,\n   int i;\n   for (i = 0; i < omp_clause_num_ops[OMP_CLAUSE_CODE (expr)]; i++)\n     stream_write_tree (ob, OMP_CLAUSE_OPERAND (expr, i), ref_p);\n-  if (OMP_CLAUSE_CODE (expr) == OMP_CLAUSE_REDUCTION)\n+  switch (OMP_CLAUSE_CODE (expr))\n     {\n+    case OMP_CLAUSE_REDUCTION:\n+    case OMP_CLAUSE_TASK_REDUCTION:\n+    case OMP_CLAUSE_IN_REDUCTION:\n       /* We don't stream these right now, handle it if streaming\n \t of them is needed.  */\n       gcc_assert (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (expr) == NULL);\n       gcc_assert (OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (expr) == NULL);\n+      break;\n+    default:\n+      break;\n     }\n   stream_write_tree (ob, OMP_CLAUSE_CHAIN (expr), ref_p);\n }"}, {"sha": "766e8a9fc29beb3ef1acf584b111d9e5e238c71d", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -282,11 +282,14 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_FIRSTPRIVATE  */\n   2, /* OMP_CLAUSE_LASTPRIVATE  */\n   5, /* OMP_CLAUSE_REDUCTION  */\n+  5, /* OMP_CLAUSE_TASK_REDUCTION  */\n+  5, /* OMP_CLAUSE_IN_REDUCTION  */\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n   3, /* OMP_CLAUSE_LINEAR  */\n   2, /* OMP_CLAUSE_ALIGNED  */\n   1, /* OMP_CLAUSE_DEPEND  */\n+  1, /* OMP_CLAUSE_NONTEMPORAL  */\n   1, /* OMP_CLAUSE_UNIFORM  */\n   1, /* OMP_CLAUSE_TO_DECLARE  */\n   1, /* OMP_CLAUSE_LINK  */\n@@ -302,6 +305,7 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_AUTO  */\n   0, /* OMP_CLAUSE_SEQ  */\n   1, /* OMP_CLAUSE__LOOPTEMP_  */\n+  1, /* OMP_CLAUSE__REDUCTEMP_  */\n   1, /* OMP_CLAUSE_IF  */\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n   1, /* OMP_CLAUSE_SCHEDULE  */\n@@ -355,11 +359,14 @@ const char * const omp_clause_code_name[] =\n   \"firstprivate\",\n   \"lastprivate\",\n   \"reduction\",\n+  \"task_reduction\",\n+  \"in_reduction\",\n   \"copyin\",\n   \"copyprivate\",\n   \"linear\",\n   \"aligned\",\n   \"depend\",\n+  \"nontemporal\",\n   \"uniform\",\n   \"to\",\n   \"link\",\n@@ -375,6 +382,7 @@ const char * const omp_clause_code_name[] =\n   \"auto\",\n   \"seq\",\n   \"_looptemp_\",\n+  \"_reductemp_\",\n   \"if\",\n   \"num_threads\",\n   \"schedule\",\n@@ -11886,6 +11894,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_UNIFORM:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_NONTEMPORAL:\n \tcase OMP_CLAUSE_NUM_TEAMS:\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_DEVICE:\n@@ -11902,6 +11911,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n+\tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */\n@@ -11959,6 +11969,8 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_TASK_REDUCTION:\n+\tcase OMP_CLAUSE_IN_REDUCTION:\n \t  {\n \t    int i;\n \t    for (i = 0; i < 5; i++)"}, {"sha": "b75204ded83a394f9d7cfa13e45f23351a66bad4", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1186,6 +1186,11 @@ DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 3)\n    Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  */\n DEFTREECODE (OMP_SINGLE, \"omp_single\", tcc_statement, 2)\n \n+/* OpenMP - #pragma omp taskgroup\n+   Operand 0: OMP_TASKGROUP_BODY: Taskgroup body.\n+   Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TASKGROUP, \"omp_taskgroup\", tcc_statement, 2)\n+\n /* OpenMP - #pragma omp section\n    Operand 0: OMP_SECTION_BODY: Section body.  */\n DEFTREECODE (OMP_SECTION, \"omp_section\", tcc_statement, 1)\n@@ -1194,10 +1199,6 @@ DEFTREECODE (OMP_SECTION, \"omp_section\", tcc_statement, 1)\n    Operand 0: OMP_MASTER_BODY: Master section body.  */\n DEFTREECODE (OMP_MASTER, \"omp_master\", tcc_statement, 1)\n \n-/* OpenMP - #pragma omp taskgroup\n-   Operand 0: OMP_TASKGROUP_BODY: Taskgroup body.  */\n-DEFTREECODE (OMP_TASKGROUP, \"omp_taskgroup\", tcc_statement, 1)\n-\n /* OpenACC - #pragma acc cache (variable1 ... variableN)\n    Operand 0: OACC_CACHE_CLAUSES: List of variables (transformed into\n \tOMP_CLAUSE__CACHE_ clauses).  */"}, {"sha": "b825cade61e449ed770c355c0dcd69107f7ba750", "filename": "gcc/tree.h", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1306,9 +1306,9 @@ extern tree maybe_wrap_with_location (tree, location_t);\n /* Generic accessors for OMP nodes that keep the body as operand 0, and clauses\n    as operand 1.  */\n #define OMP_BODY(NODE) \\\n-  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_TASKGROUP), 0)\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_MASTER), 0)\n #define OMP_CLAUSES(NODE) \\\n-  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_SINGLE), 1)\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_TASKGROUP), 1)\n \n /* Generic accessors for OMP nodes that keep clauses as operand 0.  */\n #define OMP_STANDALONE_CLAUSES(NODE) \\\n@@ -1369,6 +1369,8 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define OMP_MASTER_BODY(NODE)\t   TREE_OPERAND (OMP_MASTER_CHECK (NODE), 0)\n \n #define OMP_TASKGROUP_BODY(NODE)   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 0)\n+#define OMP_TASKGROUP_CLAUSES(NODE) \\\n+  TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 1)\n \n #define OMP_ORDERED_BODY(NODE)\t   TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 0)\n #define OMP_ORDERED_CLAUSES(NODE)  TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 1)\n@@ -1406,7 +1408,7 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define OMP_CLAUSE_DECL(NODE)      \t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n-\t\t\t\t\t      OMP_CLAUSE__LOOPTEMP_), 0)\n+\t\t\t\t\t      OMP_CLAUSE__REDUCTEMP_), 0)\n #define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n   (LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus)\t\t\\\n   != UNKNOWN_LOCATION)\n@@ -1432,11 +1434,10 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define OMP_TARGET_COMBINED(NODE) \\\n   (OMP_TARGET_CHECK (NODE)->base.private_flag)\n \n-/* True if OMP_ATOMIC* is supposed to be sequentially consistent\n-   as opposed to relaxed.  */\n-#define OMP_ATOMIC_SEQ_CST(NODE) \\\n+/* Memory order for OMP_ATOMIC*.  */\n+#define OMP_ATOMIC_MEMORY_ORDER(NODE) \\\n   (TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \\\n-\t\t     OMP_ATOMIC_CAPTURE_NEW)->base.private_flag)\n+\t\t     OMP_ATOMIC_CAPTURE_NEW)->base.u.omp_atomic_memory_order)\n \n /* True on a PRIVATE clause if its decl is kept around for debugging\n    information only and its DECL_VALUE_EXPR is supposed to point\n@@ -1459,6 +1460,11 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FIRSTPRIVATE)->base.public_flag)\n \n+/* True on a FIRSTPRIVATE clause if only the reference and not what it refers\n+   to should be firstprivatized.  */\n+#define OMP_CLAUSE_FIRSTPRIVATE_NO_REFERENCE(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FIRSTPRIVATE))\n+\n /* True on a LASTPRIVATE clause if a FIRSTPRIVATE clause for the same\n    decl is present in the chain.  */\n #define OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE(NODE) \\\n@@ -1476,6 +1482,10 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV(NODE) \\\n   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE))\n \n+/* True if a LASTPRIVATE clause has CONDITIONAL: modifier.  */\n+#define OMP_CLAUSE_LASTPRIVATE_CONDITIONAL(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE))\n+\n /* True on a SHARED clause if a FIRSTPRIVATE clause for the same\n    decl is present in the chain (this can happen only for taskloop\n    with FIRSTPRIVATE/LASTPRIVATE on it originally.  */\n@@ -1579,24 +1589,38 @@ extern tree maybe_wrap_with_location (tree, location_t);\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDERED), 0)\n \n #define OMP_CLAUSE_REDUCTION_CODE(NODE)\t\\\n-  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->omp_clause.subcode.reduction_code)\n+  (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\\n+     OMP_CLAUSE_IN_REDUCTION)->omp_clause.subcode.reduction_code)\n #define OMP_CLAUSE_REDUCTION_INIT(NODE) \\\n-  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 1)\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\\n+\t\t\t\t\t      OMP_CLAUSE_IN_REDUCTION), 1)\n #define OMP_CLAUSE_REDUCTION_MERGE(NODE) \\\n-  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 2)\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\\n+\t\t\t\t\t      OMP_CLAUSE_IN_REDUCTION), 2)\n #define OMP_CLAUSE_REDUCTION_GIMPLE_INIT(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init\n #define OMP_CLAUSE_REDUCTION_GIMPLE_MERGE(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_merge\n #define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \\\n-  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 3)\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\\n+\t\t\t\t\t      OMP_CLAUSE_IN_REDUCTION), 3)\n #define OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER(NODE) \\\n-  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 4)\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\\n+\t\t\t\t\t      OMP_CLAUSE_IN_REDUCTION), 4)\n \n /* True if a REDUCTION clause may reference the original list item (omp_orig)\n    in its OMP_CLAUSE_REDUCTION_{,GIMPLE_}INIT.  */\n #define OMP_CLAUSE_REDUCTION_OMP_ORIG_REF(NODE) \\\n-  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->base.public_flag)\n+  (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_REDUCTION, \\\n+\t\t\t   OMP_CLAUSE_IN_REDUCTION)->base.public_flag)\n+\n+/* True if a REDUCTION clause has task reduction-modifier.  */\n+#define OMP_CLAUSE_REDUCTION_TASK(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION))\n+\n+/* True if a REDUCTION clause has inscan reduction-modifier.  */\n+#define OMP_CLAUSE_REDUCTION_INSCAN(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION))\n \n /* True if a LINEAR clause doesn't need copy in.  True for iterator vars which\n    are always initialized inside of the loop construct, false otherwise.  */\n@@ -1665,6 +1689,18 @@ extern tree maybe_wrap_with_location (tree, location_t);\n #define OMP_CLAUSE_DEFAULT_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEFAULT)->omp_clause.subcode.default_kind)\n \n+#define OMP_CLAUSE_DEFAULTMAP_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEFAULTMAP)->omp_clause.subcode.defaultmap_kind)\n+#define OMP_CLAUSE_DEFAULTMAP_CATEGORY(NODE) \\\n+  ((enum omp_clause_defaultmap_kind) \\\n+   (OMP_CLAUSE_DEFAULTMAP_KIND (NODE) & OMP_CLAUSE_DEFAULTMAP_CATEGORY_MASK))\n+#define OMP_CLAUSE_DEFAULTMAP_BEHAVIOR(NODE) \\\n+  ((enum omp_clause_defaultmap_kind) \\\n+   (OMP_CLAUSE_DEFAULTMAP_KIND (NODE) & OMP_CLAUSE_DEFAULTMAP_MASK))\n+#define OMP_CLAUSE_DEFAULTMAP_SET_KIND(NODE, BEHAVIOR, CATEGORY) \\\n+  (OMP_CLAUSE_DEFAULTMAP_KIND (NODE) \\\n+   = (enum omp_clause_defaultmap_kind) (CATEGORY | BEHAVIOR))\n+\n #define OMP_CLAUSE_TILE_LIST(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 0)\n #define OMP_CLAUSE_TILE_ITERVAR(NODE) \\"}, {"sha": "d52f998b9b2a751d0d408458d8d0851e995d0cf5", "filename": "include/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,9 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gomp-constants.h (GOMP_TASK_FLAG_REDUCTION,\n+\tGOMP_DEPEND_IN, GOMP_DEPEND_OUT, GOMP_DEPEND_INOUT,\n+\tGOMP_DEPEND_MUTEXINOUTSET): Define.\n+\n 2018-10-19  Jason Merrill  <jason@redhat.com>\n \n \t* demangle.h (enum demangle_component_type): Add"}, {"sha": "d3e64d4e352ae5524461e13e1758df5689b18f4d", "filename": "include/gomp-constants.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -189,6 +189,7 @@ enum gomp_map_kind\n #define GOMP_TASK_FLAG_GRAINSIZE\t(1 << 9)\n #define GOMP_TASK_FLAG_IF\t\t(1 << 10)\n #define GOMP_TASK_FLAG_NOGROUP\t\t(1 << 11)\n+#define GOMP_TASK_FLAG_REDUCTION\t(1 << 12)\n \n /* GOMP_target{_ext,update_ext,enter_exit_data} flags argument.  */\n #define GOMP_TARGET_FLAG_NOWAIT\t\t(1 << 0)\n@@ -251,6 +252,12 @@ enum gomp_map_kind\n    at most and shifted by this many bits.  */\n #define GOMP_TARGET_ARG_VALUE_SHIFT\t\t16\n \n+/* Dependence types in omp_depend_t objects.  */\n+#define GOMP_DEPEND_IN\t\t\t1\n+#define GOMP_DEPEND_OUT\t\t\t2\n+#define GOMP_DEPEND_INOUT\t\t3\n+#define GOMP_DEPEND_MUTEXINOUTSET\t4\n+\n /* HSA specific data structures.  */\n \n /* Identifiers of device-specific target arguments.  */"}, {"sha": "b9d1f96b36a73d2923f8dfe814576d9690a064b1", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,3 +1,342 @@\n+2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* affinity.c (gomp_display_affinity_place): New function.\n+\t* affinity-fmt.c: New file.\n+\t* alloc.c (gomp_aligned_alloc, gomp_aligned_free): New functions.\n+\t* config/linux/affinity.c (gomp_display_affinity_place): New function.\n+\t* config/nvptx/icv-device.c (omp_get_num_teams, omp_get_team_num):\n+\tMove these functions to ...\n+\t* config/nvptx/teams.c: ... here.  New file.\n+\t* config/nvptx/target.c (omp_pause_resource, omp_pause_resource_all):\n+\tNew functions.\n+\t* config/nvptx/team.c (gomp_team_start, gomp_pause_host): New\n+\tfunctions.\n+\t* configure.ac: Check for aligned_alloc, posix_memalign, memalign\n+\tand _aligned_malloc.\n+\t(HAVE_UNAME, HAVE_GETHOSTNAME, HAVE_GETPID): Add new tests.\n+\t* configure.tgt: Add -DUSING_INITIAL_EXEC_TLS to XCFLAGS for Linux.\n+\t* env.c (gomp_display_affinity_var, gomp_affinity_format_var,\n+\tgomp_affinity_format_len): New variables.\n+\t(parse_schedule): Parse monotonic and nonmonotonic modifiers in\n+\tOMP_SCHEDULE variable.  Set GFS_MONOTONIC for monotonic schedules.\n+\t(handle_omp_display_env): Display monotonic/nonmonotonic schedule\n+\tmodifiers.  Display (non-default) chunk sizes.  Print\n+\tOMP_DISPLAY_AFFINITY and OMP_AFFINITY_FORMAT.\n+\t(initialize_env): Don't call pthread_attr_setdetachstate.  Handle\n+\tOMP_DISPLAY_AFFINITY and OMP_AFFINITY_FORMAT env vars.\n+\t* fortran.c: Include stdio.h and string.h.\n+\t(omp_pause_resource, omp_pause_resource_all): Add ialias_redirect.\n+\t(omp_get_schedule_, omp_get_schedule_8_): Mask off GFS_MONOTONIC bit.\n+\t(omp_set_affinity_format_, omp_get_affinity_format_,\n+\tomp_display_affinity_, omp_capture_affinity_, omp_pause_resource_,\n+\tomp_pause_resource_all_): New functions.\n+\t* icv.c (omp_set_schedule): Mask off omp_sched_monotonic bit in\n+\tswitch.\n+\t* icv-device.c (omp_get_num_teams, omp_get_team_num): Move these\n+\tfunctions to ...\n+\t* teams.c: ... here.  New file.\n+\t* libgomp_g.h: Include gstdint.h.\n+\t(GOMP_loop_nonmonotonic_runtime_start,\n+\tGOMP_loop_maybe_nonmonotonic_runtime_start, GOMP_loop_start,\n+\tGOMP_loop_ordered_start, GOMP_loop_nonmonotonic_runtime_next,\n+\tGOMP_loop_maybe_nonmonotonic_runtime_next, GOMP_loop_doacross_start,\n+\tGOMP_parallel_loop_nonmonotonic_runtime,\n+\tGOMP_parallel_loop_maybe_nonmonotonic_runtime,\n+\tGOMP_loop_ull_nonmonotonic_runtime_start,\n+\tGOMP_loop_ull_maybe_nonmonotonic_runtime_start, GOMP_loop_ull_start,\n+\tGOMP_loop_ull_ordered_start, GOMP_loop_ull_nonmonotonic_runtime_next,\n+\tGOMP_loop_ull_maybe_nonmonotonic_runtime_next,\n+\tGOMP_loop_ull_doacross_start, GOMP_parallel_reductions,\n+\tGOMP_taskwait_depend, GOMP_taskgroup_reduction_register,\n+\tGOMP_taskgroup_reduction_unregister, GOMP_task_reduction_remap,\n+\tGOMP_workshare_task_reduction_unregister, GOMP_sections2_start,\n+\tGOMP_teams_reg): Declare.\n+\t* libgomp.h (GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC): Define unless\n+\tgomp_aligned_alloc uses fallback implementation.\n+\t(gomp_aligned_alloc, gomp_aligned_free): Declare.\n+\t(enum gomp_schedule_type): Add GFS_MONOTONIC.\n+\t(struct gomp_doacross_work_share): Add extra field.\n+\t(struct gomp_work_share): Add task_reductions field.\n+\t(struct gomp_taskgroup): Add workshare and reductions fields.\n+\t(GOMP_NEEDS_THREAD_HANDLE): Define if needed.\n+\t(gomp_thread_handle): New typedef.\n+\t(gomp_display_affinity_place, gomp_set_affinity_format,\n+\tgomp_display_string, gomp_display_affinity,\n+\tgomp_display_affinity_thread): Declare.\n+\t(gomp_doacross_init, gomp_doacross_ull_init): Add size_t argument.\n+\t(gomp_parallel_reduction_register, gomp_workshare_taskgroup_start,\n+\tgomp_workshare_task_reduction_register): Declare.\n+\t(gomp_team_start): Add taskgroup argument.\n+\t(gomp_pause_host): Declare.\n+\t(gomp_init_work_share, gomp_work_share_start): Change bool argument\n+\tto size_t.\n+\t(gomp_thread_self, gomp_thread_to_pthread_t): New inline functions.\n+\t* libgomp.map (GOMP_5.0): Export GOMP_loop_start,\n+\tGOMP_loop_ordered_start, GOMP_loop_doacross_start,\n+\tGOMP_loop_ull_start, GOMP_loop_ull_ordered_start,\n+\tGOMP_loop_ull_doacross_start,\n+\tGOMP_workshare_task_reduction_unregister, GOMP_sections2_start,\n+\tGOMP_loop_maybe_nonmonotonic_runtime_next,\n+\tGOMP_loop_maybe_nonmonotonic_runtime_start,\n+\tGOMP_loop_nonmonotonic_runtime_next,\n+\tGOMP_loop_nonmonotonic_runtime_start,\n+\tGOMP_loop_ull_maybe_nonmonotonic_runtime_next,\n+\tGOMP_loop_ull_maybe_nonmonotonic_runtime_start,\n+\tGOMP_loop_ull_nonmonotonic_runtime_next,\n+\tGOMP_loop_ull_nonmonotonic_runtime_start,\n+\tGOMP_parallel_loop_maybe_nonmonotonic_runtime,\n+\tGOMP_parallel_loop_nonmonotonic_runtime, GOMP_parallel_reductions,\n+\tGOMP_taskgroup_reduction_register,\n+\tGOMP_taskgroup_reduction_unregister, GOMP_task_reduction_remap,\n+\tGOMP_teams_reg and GOMP_taskwait_depend.\n+\t(OMP_5.0): Export omp_pause_resource{,_all}{,_},\n+\tomp_{capture,display}_affinity{,_}, and\n+\tomp_[gs]et_affinity_format{,_}.\n+\t* loop.c: Include string.h.\n+\t(GOMP_loop_runtime_next): Add ialias.\n+\t(GOMP_taskgroup_reduction_register): Add ialias_redirect.\n+\t(gomp_loop_static_start, gomp_loop_dynamic_start,\n+\tgomp_loop_guided_start, gomp_loop_ordered_static_start,\n+\tgomp_loop_ordered_dynamic_start, gomp_loop_ordered_guided_start,\n+\tgomp_loop_doacross_static_start, gomp_loop_doacross_dynamic_start,\n+\tgomp_loop_doacross_guided_start): Adjust gomp_work_share_start\n+\tor gomp_doacross_init callers.\n+\t(gomp_adjust_sched, GOMP_loop_start, GOMP_loop_ordered_start,\n+\tGOMP_loop_doacross_start): New functions.\n+\t(GOMP_loop_runtime_start, GOMP_loop_ordered_runtime_start,\n+\tGOMP_loop_doacross_runtime_start, GOMP_parallel_loop_runtime_start):\n+\tMask off GFS_MONOTONIC bit.\n+\t(GOMP_loop_maybe_nonmonotonic_runtime_next,\n+\tGOMP_loop_maybe_nonmonotonic_runtime_start,\n+\tGOMP_loop_nonmonotonic_runtime_next,\n+\tGOMP_loop_nonmonotonic_runtime_start,\n+\tGOMP_parallel_loop_maybe_nonmonotonic_runtime,\n+\tGOMP_parallel_loop_nonmonotonic_runtime): New aliases or wrapper\n+\tfunctions.\n+\t(gomp_parallel_loop_start): Pass NULL as taskgroup to\n+\tgomp_team_start.\n+\t* loop_ull.c: Include string.h.\n+\t(GOMP_loop_ull_runtime_next): Add ialias.\n+\t(GOMP_taskgroup_reduction_register): Add ialias_redirect.\n+\t(gomp_loop_ull_static_start, gomp_loop_ull_dynamic_start,\n+\tgomp_loop_ull_guided_start, gomp_loop_ull_ordered_static_start,\n+\tgomp_loop_ull_ordered_dynamic_start,\n+\tgomp_loop_ull_ordered_guided_start,\n+\tgomp_loop_ull_doacross_static_start,\n+\tgomp_loop_ull_doacross_dynamic_start,\n+\tgomp_loop_ull_doacross_guided_start): Adjust gomp_work_share_start\n+\tand gomp_doacross_ull_init callers.\n+\t(gomp_adjust_sched, GOMP_loop_ull_start, GOMP_loop_ull_ordered_start,\n+\tGOMP_loop_ull_doacross_start): New functions.\n+\t(GOMP_loop_ull_runtime_start,\n+\tGOMP_loop_ull_ordered_runtime_start,\n+\tGOMP_loop_ull_doacross_runtime_start): Mask off GFS_MONOTONIC bit.\n+\t(GOMP_loop_ull_maybe_nonmonotonic_runtime_next,\n+\tGOMP_loop_ull_maybe_nonmonotonic_runtime_start,\n+\tGOMP_loop_ull_nonmonotonic_runtime_next,\n+\tGOMP_loop_ull_nonmonotonic_runtime_start): Likewise.\n+\t* Makefile.am (libgomp_la_SOURCES): Add teams.c and affinity-fmt.c.\n+\t* omp.h.in (enum omp_sched_t): Add omp_sched_monotonic.\n+\t(omp_pause_resource_t, omp_depend_t): New typedefs.\n+\t(enum omp_lock_hint_t): Renamed to ...\n+\t(enum omp_sync_hint_t): ... this.  Define omp_sync_hint_*\n+\tenumerators using numbers and omp_lock_hint_* as their aliases.\n+\t(omp_lock_hint_t): New typedef.  Rename to ...\n+\t(omp_sync_hint_t): ... this.\n+\t(omp_init_lock_with_hint, omp_init_nest_lock_with_hint): Use\n+\tomp_sync_hint_t instead of omp_lock_hint_t.\n+\t(omp_pause_resource, omp_pause_resource_all, omp_set_affinity_format,\n+\tomp_get_affinity_format, omp_display_affinity, omp_capture_affinity):\n+\tDeclare.\n+\t(omp_target_is_present, omp_target_disassociate_ptr):\n+\tChange first argument from void * to const void *.\n+\t(omp_target_memcpy, omp_target_memcpy_rect): Change second argument\n+\tfrom void * to const void *.\n+\t(omp_target_associate_ptr): Change first and second arguments from\n+\tvoid * to const void *.\n+\t* omp_lib.f90.in (omp_pause_resource_kind, omp_pause_soft,\n+\tomp_pause_hard): New parameters.\n+\t(omp_pause_resource, omp_pause_resource_all, omp_set_affinity_format,\n+\tomp_get_affinity_format, omp_display_affinity, omp_capture_affinity):\n+\tNew interfaces.\n+\t* omp_lib.h.in (omp_pause_resource_kind, omp_pause_soft,\n+\tomp_pause_hard): New parameters.\n+\t(omp_pause_resource, omp_pause_resource_all, omp_set_affinity_format,\n+\tomp_get_affinity_format, omp_display_affinity, omp_capture_affinity):\n+\tNew externals.\n+\t* ordered.c (gomp_doacross_init, gomp_doacross_ull_init): Add\n+\tEXTRA argument.  If not needed to prepare array, if extra is 0,\n+\tclear ws->doacross, otherwise allocate just doacross structure and\n+\textra payload.  If array is needed, allocate also extra payload.\n+\t(GOMP_doacross_post, GOMP_doacross_wait, GOMP_doacross_ull_post,\n+\tGOMP_doacross_ull_wait): Handle doacross->array == NULL like\n+\tdoacross == NULL.\n+\t* parallel.c (GOMP_parallel_start): Pass NULL as taskgroup to\n+\tgomp_team_start.\n+\t(GOMP_parallel): Likewise.  Formatting fix.\n+\t(GOMP_parallel_reductions): New function.\n+\t(GOMP_cancellation_point): If taskgroup has workshare\n+\tflag set, check cancelled of prev taskgroup if any.\n+\t(GOMP_cancel): If taskgroup has workshare flag set, set cancelled\n+\ton prev taskgroup if any.\n+\t* sections.c: Include string.h.\n+\t(GOMP_taskgroup_reduction_register): Add ialias_redirect.\n+\t(GOMP_sections_start): Adjust gomp_work_share_start caller.\n+\t(GOMP_sections2_start): New function.\n+\t(GOMP_parallel_sections_start, GOMP_parallel_sections):\n+\tPass NULL as taskgroup to gomp_team_start.\n+\t* single.c (GOMP_single_start, GOMP_single_copy_start): Adjust\n+\tgomp_work_share_start callers.\n+\t* target.c (GOMP_target_update_ext, GOMP_target_enter_exit_data):\n+\tIf taskgroup has workshare flag set, check cancelled on prev\n+\ttaskgroup if any.  Guard all cancellation tests with\n+\tgomp_cancel_var test.\n+\t(omp_target_is_present, omp_target_disassociate_ptr):\n+\tChange ptr argument from void * to const void *.\n+\t(omp_target_memcpy): Change src argument from void * to const void *.\n+\t(omp_target_memcpy_rect): Likewise.\n+\t(omp_target_memcpy_rect_worker): Likewise.  Use const char * casts\n+\tinstead of char * where needed.\n+\t(omp_target_associate_ptr): Change host_ptr and device_ptr arguments\n+\tfrom void * to const void *.\n+\t(omp_pause_resource, omp_pause_resource_all): New functions.\n+\t* task.c (gomp_task_handle_depend): Handle new depend array format\n+\tin addition to the old.  Handle mutexinoutset kinds the same as\n+\tinout for now, handle unspecified kinds.\n+\t(gomp_create_target_task): If taskgroup has workshare flag set, check\n+\tcancelled on prev taskgroup if any.  Guard all cancellation tests with\n+\tgomp_cancel_var test.  Handle new depend array format count in\n+\taddition to the old.\n+\t(GOMP_task): Likewise.  Adjust function comment.\n+\t(gomp_task_run_pre): If taskgroup has workshare flag set, check\n+\tcancelled on prev taskgroup if any.  Guard all cancellation tests with\n+\tgomp_cancel_var test.\n+\t(GOMP_taskwait_depend): New function.\n+\t(gomp_task_maybe_wait_for_dependencies): Handle new depend array\n+\tformat in addition to the old.  Handle mutexinoutset kinds the same as\n+\tinout for now, handle unspecified kinds.  Fix a function comment typo.\n+\t(gomp_taskgroup_init): New function.\n+\t(GOMP_taskgroup_start): Use it.\n+\t(gomp_reduction_register, gomp_create_artificial_team,\n+\tGOMP_taskgroup_reduction_register,\n+\tGOMP_taskgroup_reduction_unregister, GOMP_task_reduction_remap,\n+\tgomp_parallel_reduction_register,\n+\tgomp_workshare_task_reduction_register,\n+\tgomp_workshare_taskgroup_start,\n+\tGOMP_workshare_task_reduction_unregister): New functions.\n+\t* taskloop.c (GOMP_taskloop): If taskgroup has workshare flag set,\n+\tcheck cancelled on prev taskgroup if any.  Guard all cancellation\n+\ttests with gomp_cancel_var test.  Handle GOMP_TASK_FLAG_REDUCTION flag\n+\tby calling GOMP_taskgroup_reduction_register.\n+\t* team.c (gomp_thread_attr): Remove comment.\n+\t(struct gomp_thread_start_data): Add handle field.\n+\t(gomp_thread_start): Call pthread_detach.\n+\t(gomp_new_team): Adjust gomp_init_work_share caller.\n+\t(gomp_free_pool_helper): Call pthread_detach.\n+\t(gomp_team_start): Add taskgroup argument, initialize implicit\n+\ttasks' taskgroup field to that.  Don't call\n+\tpthread_attr_setdetachstate.  Handle OMP_DISPLAY_AFFINITY env var.\n+\t(gomp_team_end): Determine nesting by thr->ts.level != 0\n+\trather than thr->ts.team != NULL.\n+\t(gomp_pause_pool_helper, gomp_pause_host): New functions.\n+\t* work.c (alloc_work_share): Use gomp_aligned_alloc instead of\n+\tgomp_malloc if GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC is defined.\n+\t(gomp_init_work_share): Change ORDERED argument from bool to size_t,\n+\tif more than 1 allocate also extra payload at the end of array.  Never\n+\tkeep ordered_team_ids NULL, set it to inline_ordered_team_ids instead.\n+\t(gomp_work_share_start): Change ORDERED argument from bool to size_t,\n+\treturn true instead of ws.\n+\t* Makefile.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* testsuite/libgomp.c/cancel-for-2.c (foo): Use cancel modifier\n+\tin some cases.\n+\t* testsuite/libgomp.c-c++-common/cancel-parallel-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/cancel-taskgroup-3.c: New test.\n+\t* testsuite/libgomp.c-c++-common/depend-iterator-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/depend-iterator-2.c: New test.\n+\t* testsuite/libgomp.c-c++-common/depend-mutexinout-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/depend-mutexinout-2.c: New test.\n+\t* testsuite/libgomp.c-c++-common/depobj-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/display-affinity-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-10.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-11.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-12.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-13.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-14.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-15.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-2.h: If CONDNE macro is defined,\n+\tdefine a different N(test), don't define N(f0) to N(f14), but instead\n+\tdefine N(f20) to N(f34) using != comparisons.\n+\t* testsuite/libgomp.c-c++-common/for-7.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-8.c: New test.\n+\t* testsuite/libgomp.c-c++-common/for-9.c: New test.\n+\t* testsuite/libgomp.c-c++-common/master-combined-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pause-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pause-2.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pr66199-10.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pr66199-11.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pr66199-12.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pr66199-13.c: New test.\n+\t* testsuite/libgomp.c-c++-common/pr66199-14.c: New test.\n+\t* testsuite/libgomp.c-c++-common/simd-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/taskloop-reduction-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/taskloop-reduction-2.c: New test.\n+\t* testsuite/libgomp.c-c++-common/taskloop-reduction-3.c: New test.\n+\t* testsuite/libgomp.c-c++-common/taskloop-reduction-4.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-11.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-12.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-2.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-3.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-4.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-5.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-6.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-7.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-8.c: New test.\n+\t* testsuite/libgomp.c-c++-common/task-reduction-9.c: New test.\n+\t* testsuite/libgomp.c-c++-common/taskwait-depend-1.c: New test.\n+\t* testsuite/libgomp.c++/depend-1.C: New test.\n+\t* testsuite/libgomp.c++/depend-iterator-1.C: New test.\n+\t* testsuite/libgomp.c++/depobj-1.C: New test.\n+\t* testsuite/libgomp.c++/for-16.C: New test.\n+\t* testsuite/libgomp.c++/for-21.C: New test.\n+\t* testsuite/libgomp.c++/for-22.C: New test.\n+\t* testsuite/libgomp.c++/for-23.C: New test.\n+\t* testsuite/libgomp.c++/for-24.C: New test.\n+\t* testsuite/libgomp.c++/for-25.C: New test.\n+\t* testsuite/libgomp.c++/for-26.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-reduction-1.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-reduction-2.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-reduction-3.C: New test.\n+\t* testsuite/libgomp.c++/taskloop-reduction-4.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-10.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-11.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-12.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-13.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-14.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-15.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-16.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-17.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-18.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-19.C: New test.\n+\t* testsuite/libgomp.c/task-reduction-1.c: New test.\n+\t* testsuite/libgomp.c++/task-reduction-1.C: New test.\n+\t* testsuite/libgomp.c/task-reduction-2.c: New test.\n+\t* testsuite/libgomp.c++/task-reduction-2.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-3.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-4.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-5.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-6.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-7.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-8.C: New test.\n+\t* testsuite/libgomp.c++/task-reduction-9.C: New test.\n+\t* testsuite/libgomp.c/teams-1.c: New test.\n+\t* testsuite/libgomp.c/teams-2.c: New test.\n+\t* testsuite/libgomp.c/thread-limit-4.c: New test.\n+\t* testsuite/libgomp.c/thread-limit-5.c: New test.\n+\t* testsuite/libgomp.fortran/display-affinity-1.f90: New test.\n+\n 2018-11-06  Chung-Lin Tang <cltang@codesourcery.com>\n \n \t* oacc-mem.c (memcpy_tofrom_device): New function, combined from"}, {"sha": "062fded0805a4added66a45e84c9cb4303983024", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -64,7 +64,8 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c error.c \\\n \tparallel.c sections.c single.c task.c team.c work.c lock.c mutex.c \\\n \tproc.c sem.c bar.c ptrlock.c time.c fortran.c affinity.c target.c \\\n \tsplay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c oacc-init.c \\\n-\toacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c\n+\toacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n+\taffinity-fmt.c teams.c\n \n include $(top_srcdir)/plugin/Makefrag.am\n "}, {"sha": "98499b8dc8f60818f24295f95cec5b0abe1d071e", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -216,7 +216,8 @@ am_libgomp_la_OBJECTS = alloc.lo atomic.lo barrier.lo critical.lo \\\n \tsem.lo bar.lo ptrlock.lo time.lo fortran.lo affinity.lo \\\n \ttarget.lo splay-tree.lo libgomp-plugin.lo oacc-parallel.lo \\\n \toacc-host.lo oacc-init.lo oacc-mem.lo oacc-async.lo \\\n-\toacc-plugin.lo oacc-cuda.lo priority_queue.lo $(am__objects_1)\n+\toacc-plugin.lo oacc-cuda.lo priority_queue.lo affinity-fmt.lo \\\n+\tteams.lo $(am__objects_1)\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n AM_V_P = $(am__v_P_@AM_V@)\n am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n@@ -549,7 +550,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n \taffinity.c target.c splay-tree.c libgomp-plugin.c \\\n \toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c \\\n \toacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n-\t$(am__append_3)\n+\taffinity-fmt.c teams.c $(am__append_3)\n \n # Nvidia PTX OpenACC plugin.\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)\n@@ -724,6 +725,7 @@ distclean-compile:\n \t-rm -f *.tab.c\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity-fmt.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atomic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bar.Plo@am__quote@\n@@ -762,6 +764,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/task.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/team.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/teams.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/work.Plo@am__quote@\n "}, {"sha": "08937b69d4e43930916bb40e4b80220d5bb11f8a", "filename": "libgomp/affinity-fmt.c", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Faffinity-fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Faffinity-fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Faffinity-fmt.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,481 @@\n+/* Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgomp.h\"\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_UNAME\n+#include <sys/utsname.h>\n+#endif\n+\n+void\n+gomp_set_affinity_format (const char *format, size_t len)\n+{\n+  if (len < gomp_affinity_format_len)\n+    memcpy (gomp_affinity_format_var, format, len);\n+  else\n+    {\n+      char *p;\n+      if (gomp_affinity_format_len)\n+\tp = gomp_realloc (gomp_affinity_format_var, len + 1);\n+      else\n+\tp = gomp_malloc (len + 1);\n+      memcpy (p, format, len);\n+      gomp_affinity_format_var = p;\n+      gomp_affinity_format_len = len + 1;\n+    }\n+  gomp_affinity_format_var[len] = '\\0';\n+}\n+\n+void\n+omp_set_affinity_format (const char *format)\n+{\n+  gomp_set_affinity_format (format, strlen (format));\n+}\n+\n+size_t\n+omp_get_affinity_format (char *buffer, size_t size)\n+{\n+  size_t len = strlen (gomp_affinity_format_var);\n+  if (size)\n+    {\n+      if (len < size)\n+\tmemcpy (buffer, gomp_affinity_format_var, len + 1);\n+      else\n+\t{\n+\t  memcpy (buffer, gomp_affinity_format_var, size - 1);\n+\t  buffer[size - 1] = '\\0';\n+\t}\n+    }\n+  return len;\n+}\n+\n+void\n+gomp_display_string (char *buffer, size_t size, size_t *ret,\n+\t\t     const char *str, size_t len)\n+{\n+  size_t r = *ret;\n+  if (size && r < size)\n+    {\n+      size_t l = len;\n+      if (size - r < len)\n+\tl = size - r;\n+      memcpy (buffer + r, str, l);\n+    }\n+  *ret += len;\n+  if (__builtin_expect (r > *ret, 0))\n+    gomp_fatal (\"overflow in omp_capture_affinity\");\n+}\n+\n+static void\n+gomp_display_repeat (char *buffer, size_t size, size_t *ret,\n+\t\t     char c, size_t len)\n+{\n+  size_t r = *ret;\n+  if (size && r < size)\n+    {\n+      size_t l = len;\n+      if (size - r < len)\n+\tl = size - r;\n+      memset (buffer + r, c, l);\n+    }\n+  *ret += len;\n+  if (__builtin_expect (r > *ret, 0))\n+    gomp_fatal (\"overflow in omp_capture_affinity\");\n+}\n+\n+static void\n+gomp_display_num (char *buffer, size_t size, size_t *ret,\n+\t\t  bool zero, bool right, size_t sz, char *buf)\n+{\n+  size_t l = strlen (buf);\n+  if (sz == (size_t) -1 || l >= sz)\n+    {\n+      gomp_display_string (buffer, size, ret, buf, l);\n+      return;\n+    }\n+  if (zero)\n+    {\n+      if (buf[0] == '-')\n+\tgomp_display_string (buffer, size, ret, buf, 1);\n+      else if (buf[0] == '0' && buf[1] == 'x')\n+\tgomp_display_string (buffer, size, ret, buf, 2);\n+      gomp_display_repeat (buffer, size, ret, '0', sz - l);\n+      if (buf[0] == '-')\n+\tgomp_display_string (buffer, size, ret, buf + 1, l - 1);\n+      else if (buf[0] == '0' && buf[1] == 'x')\n+\tgomp_display_string (buffer, size, ret, buf + 2, l - 2);\n+      else\n+\tgomp_display_string (buffer, size, ret, buf, l);\n+    }\n+  else if (right)\n+    {\n+      gomp_display_repeat (buffer, size, ret, ' ', sz - l);\n+      gomp_display_string (buffer, size, ret, buf, l);\n+    }\n+  else\n+    {\n+      gomp_display_string (buffer, size, ret, buf, l);\n+      gomp_display_repeat (buffer, size, ret, ' ', sz - l);\n+    }\n+}\n+\n+static void\n+gomp_display_int (char *buffer, size_t size, size_t *ret,\n+\t\t  bool zero, bool right, size_t sz, int num)\n+{\n+  char buf[3 * sizeof (int) + 2];\n+  sprintf (buf, \"%d\", num);\n+  gomp_display_num (buffer, size, ret, zero, right, sz, buf);\n+}\n+\n+static void\n+gomp_display_string_len (char *buffer, size_t size, size_t *ret,\n+\t\t\t bool right, size_t sz, char *str, size_t len)\n+{\n+  if (sz == (size_t) -1 || len >= sz)\n+    {\n+      gomp_display_string (buffer, size, ret, str, len);\n+      return;\n+    }\n+\n+  if (right)\n+    {\n+      gomp_display_repeat (buffer, size, ret, ' ', sz - len);\n+      gomp_display_string (buffer, size, ret, str, len);\n+    }\n+  else\n+    {\n+      gomp_display_string (buffer, size, ret, str, len);\n+      gomp_display_repeat (buffer, size, ret, ' ', sz - len);\n+    }\n+}\n+\n+static void\n+gomp_display_hostname (char *buffer, size_t size, size_t *ret,\n+\t\t       bool right, size_t sz)\n+{\n+#ifdef HAVE_GETHOSTNAME\n+  {\n+    char buf[256];\n+    char *b = buf;\n+    size_t len = 256;\n+    do\n+      {\n+\tb[len - 1] = '\\0';\n+\tif (gethostname (b, len - 1) == 0)\n+\t  {\n+\t    size_t l = strlen (b);\n+\t    if (l < len - 1)\n+\t      {\n+\t\tgomp_display_string_len (buffer, size, ret,\n+\t\t\t\t\t right, sz, b, l);\n+\t\tif (b != buf)\n+\t\t  free (b);\n+\t\treturn;\n+\t      }\n+\t  }\n+\tif (len == 1048576)\n+\t  break;\n+\tlen = len * 2;\n+\tif (len == 512)\n+\t  b = gomp_malloc (len);\n+\telse\n+\t  b = gomp_realloc (b, len);\n+      }\n+    while (1);\n+    if (b != buf)\n+      free (b);\n+  }\n+#endif\n+#ifdef HAVE_UNAME\n+  {\n+    struct utsname buf;\n+    if (uname (&buf) == 0)\n+      {\n+\tgomp_display_string_len (buffer, size, ret, right, sz,\n+\t\t\t\t buf.nodename, strlen (buf.nodename));\n+\treturn;\n+      }\n+  }\n+#endif\n+  gomp_display_string_len (buffer, size, ret, right, sz, \"node\", 4);\n+}\n+\n+struct affinity_types_struct {\n+  char long_str[18];\n+  char long_len;\n+  char short_c; };\n+\n+static struct affinity_types_struct affinity_types[] =\n+{\n+#define AFFINITY_TYPE(l, s) \\\n+  { #l, sizeof (#l) - 1, s }\n+  AFFINITY_TYPE (team_num, 't'),\n+  AFFINITY_TYPE (num_teams, 'T'),\n+  AFFINITY_TYPE (nesting_level, 'L'),\n+  AFFINITY_TYPE (thread_num, 'n'),\n+  AFFINITY_TYPE (num_threads, 'N'),\n+  AFFINITY_TYPE (ancestor_tnum, 'a'),\n+  AFFINITY_TYPE (host, 'H'),\n+  AFFINITY_TYPE (process_id, 'P'),\n+  AFFINITY_TYPE (native_thread_id, 'i'),\n+  AFFINITY_TYPE (thread_affinity, 'A')\n+#undef AFFINITY_TYPE\n+};\n+\n+size_t\n+gomp_display_affinity (char *buffer, size_t size,\n+\t\t       const char *format, gomp_thread_handle handle,\n+\t\t       struct gomp_team_state *ts, unsigned int place)\n+{\n+  size_t ret = 0;\n+  do\n+    {\n+      const char *p = strchr (format, '%');\n+      bool zero = false;\n+      bool right = false;\n+      size_t sz = -1;\n+      char c;\n+      int val;\n+      if (p == NULL)\n+\tp = strchr (format, '\\0');\n+      if (p != format)\n+\tgomp_display_string (buffer, size, &ret,\n+\t\t\t     format, p - format);\n+      if (*p == '\\0')\n+\tbreak;\n+      p++;\n+      if (*p == '%')\n+\t{\n+\t  gomp_display_string (buffer, size, &ret, \"%\", 1);\n+\t  format = p + 1;\n+\t  continue;\n+\t}\n+      if (*p == '0')\n+\t{\n+\t  zero = true;\n+\t  p++;\n+\t  if (*p != '.')\n+\t    gomp_fatal (\"leading zero not followed by dot in affinity format\");\n+\t}\n+      if (*p == '.')\n+\t{\n+\t  right = true;\n+\t  p++;\n+\t}\n+      if (*p >= '1' && *p <= '9')\n+\t{\n+\t  char *end;\n+\t  sz = strtoul (p, &end, 10);\n+\t  p = end;\n+\t}\n+      else if (zero || right)\n+\tgomp_fatal (\"leading zero or right justification in affinity format \"\n+\t\t    \"requires size\");\n+      c = *p;\n+      if (c == '{')\n+\t{\n+\t  int i;\n+\t  for (i = 0;\n+\t       i < sizeof (affinity_types) / sizeof (affinity_types[0]); ++i)\n+\t    if (strncmp (p + 1, affinity_types[i].long_str,\n+\t\t\t affinity_types[i].long_len) == 0\n+\t\t&& p[affinity_types[i].long_len + 1] == '}')\n+\t      {\n+\t\tc = affinity_types[i].short_c;\n+\t\tp += affinity_types[i].long_len + 1;\n+\t\tbreak;\n+\t      }\n+\t  if (c == '{')\n+\t    {\n+\t      char *q = strchr (p + 1, '}');\n+\t      if (q)\n+\t\tgomp_fatal (\"unsupported long type name '%.*s' in affinity \"\n+\t\t\t    \"format\", (int) (q - (p + 1)), p + 1);\n+\t      else\n+\t\tgomp_fatal (\"unterminated long type name '%s' in affinity \"\n+\t\t\t    \"format\", p + 1);\n+\t    }\n+\t}\n+      switch (c)\n+\t{\n+\tcase 't':\n+\t  val = omp_get_team_num ();\n+\t  goto do_int;\n+\tcase 'T':\n+\t  val = omp_get_num_teams ();\n+\t  goto do_int;\n+\tcase 'L':\n+\t  val = ts->level;\n+\t  goto do_int;\n+\tcase 'n':\n+\t  val = ts->team_id;\n+\t  goto do_int;\n+\tcase 'N':\n+\t  val = ts->team ? ts->team->nthreads : 1;\n+\t  goto do_int;\n+\tcase 'a':\n+\t  val = ts->team ? ts->team->prev_ts.team_id : -1;\n+\t  goto do_int;\n+\tcase 'H':\n+\t  gomp_display_hostname (buffer, size, &ret, right, sz);\n+\t  break;\n+\tcase 'P':\n+#ifdef HAVE_GETPID\n+\t  val = getpid ();\n+#else\n+\t  val = 0;\n+#endif\n+\t  goto do_int;\n+\tcase 'i':\n+#if defined(LIBGOMP_USE_PTHREADS) && defined(__GNUC__)\n+\t  /* Handle integral pthread_t.  */\n+\t  if (__builtin_classify_type (handle) == 1)\n+\t    {\n+\t      char buf[3 * (sizeof (handle) + sizeof (int)) + 4];\n+\n+\t      if (sizeof (handle) == sizeof (long))\n+\t\tsprintf (buf, \"0x%lx\", (long) handle);\n+\t      else if (sizeof (handle) == sizeof (long long))\n+\t\tsprintf (buf, \"0x%llx\", (long long) handle);\n+\t      else\n+\t\tsprintf (buf, \"0x%x\", (int) handle);\n+\t      gomp_display_num (buffer, size, &ret, zero, right, sz, buf);\n+\t      break;\n+\t    }\n+\t  /* And pointer pthread_t.  */\n+\t  else if (__builtin_classify_type (handle) == 5)\n+\t    {\n+\t      char buf[3 * (sizeof (uintptr_t) + sizeof (int)) + 4];\n+\n+\t      if (sizeof (uintptr_t) == sizeof (long))\n+\t\tsprintf (buf, \"0x%lx\", (long) (uintptr_t) handle);\n+\t      else if (sizeof (uintptr_t) == sizeof (long long))\n+\t\tsprintf (buf, \"0x%llx\", (long long) (uintptr_t) handle);\n+\t      else\n+\t\tsprintf (buf, \"0x%x\", (int) (uintptr_t) handle);\n+\t      gomp_display_num (buffer, size, &ret, zero, right, sz, buf);\n+\t      break;\n+\t    }\n+#endif\n+\t  val = 0;\n+\t  goto do_int;\n+\tcase 'A':\n+\t  if (sz == (size_t) -1)\n+\t    gomp_display_affinity_place (buffer, size, &ret,\n+\t\t\t\t\t place - 1);\n+\t  else if (right)\n+\t    {\n+\t      size_t len = 0;\n+\t      gomp_display_affinity_place (NULL, 0, &len, place - 1);\n+\t      if (len < sz)\n+\t\tgomp_display_repeat (buffer, size, &ret, ' ', sz - len);\n+\t      gomp_display_affinity_place (buffer, size, &ret, place - 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      size_t start = ret;\n+\t      gomp_display_affinity_place (buffer, size, &ret, place - 1);\n+\t      if (ret - start < sz)\n+\t\tgomp_display_repeat (buffer, size, &ret, ' ', sz - (ret - start));\n+\t    }\n+\t  break;\n+\tdo_int:\n+\t  gomp_display_int (buffer, size, &ret, zero, right, sz, val);\n+\t  break;\n+\tdefault:\n+\t  gomp_fatal (\"unsupported type %c in affinity format\", c);\n+\t}\n+      format = p + 1;\n+    }\n+  while (1);\n+  return ret;\n+}\n+\n+size_t\n+omp_capture_affinity (char *buffer, size_t size, const char *format)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  size_t ret\n+    = gomp_display_affinity (buffer, size,\n+\t\t\t     format && *format\n+\t\t\t     ? format : gomp_affinity_format_var,\n+\t\t\t     gomp_thread_self (), &thr->ts, thr->place);\n+  if (size)\n+    {\n+      if (ret >= size)\n+\tbuffer[size - 1] = '\\0';\n+      else\n+\tbuffer[ret] = '\\0';\n+    }\n+  return ret;\n+}\n+ialias (omp_capture_affinity)\n+\n+void\n+omp_display_affinity (const char *format)\n+{\n+  char buf[512];\n+  char *b;\n+  size_t ret = ialias_call (omp_capture_affinity) (buf, sizeof buf, format);\n+  if (ret < sizeof buf)\n+    {\n+      buf[ret] = '\\n';\n+      fwrite (buf, 1, ret + 1, stderr);\n+      return;\n+    }\n+  b = gomp_malloc (ret + 1);\n+  ialias_call (omp_capture_affinity) (b, ret + 1, format);\n+  b[ret] = '\\n';\n+  fwrite (b, 1, ret + 1, stderr);\n+  free (b);\n+}\n+\n+void\n+gomp_display_affinity_thread (gomp_thread_handle handle,\n+\t\t\t      struct gomp_team_state *ts, unsigned int place)\n+{\n+  char buf[512];\n+  char *b;\n+  size_t ret = gomp_display_affinity (buf, sizeof buf, gomp_affinity_format_var,\n+\t\t\t\t      handle, ts, place);\n+  if (ret < sizeof buf)\n+    {\n+      buf[ret] = '\\n';\n+      fwrite (buf, 1, ret + 1, stderr);\n+      return;\n+    }\n+  b = gomp_malloc (ret + 1);\n+  gomp_display_affinity (b, ret + 1, gomp_affinity_format_var,\n+  \t\t\t handle, ts, place);\n+  b[ret] = '\\n';\n+  fwrite (b, 1, ret + 1, stderr);\n+  free (b);\n+}"}, {"sha": "99a45dcd3a0c6b2344159b9abaa002f24888a044", "filename": "libgomp/affinity.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Faffinity.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -138,5 +138,18 @@ gomp_get_place_proc_ids_8 (int place_num, int64_t *ids)\n   (void) ids;\n }\n \n+void\n+gomp_display_affinity_place (char *buffer, size_t size, size_t *ret,\n+\t\t\t     int place)\n+{\n+  cpu_set_t *cpusetp;\n+  char buf[sizeof (long) * 3 + 4];\n+  if (gomp_available_cpus > 1)\n+    sprintf (buf, \"0-%lu\", gomp_available_cpus - 1);\n+  else\n+    strcpy (buf, \"0\");\n+  gomp_display_string (buffer, size, ret, buf, strlen (buf));\n+}\n+\n ialias(omp_get_place_num_procs)\n ialias(omp_get_place_proc_ids)"}, {"sha": "296f1af1eaa3ce4cbb3be386dbd36e9c65155d17", "filename": "libgomp/alloc.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Falloc.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -57,3 +57,50 @@ gomp_realloc (void *old, size_t size)\n     gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n   return ret;\n }\n+\n+void *\n+gomp_aligned_alloc (size_t al, size_t size)\n+{\n+  void *ret;\n+  if (al < sizeof (void *))\n+    al = sizeof (void *);\n+#ifdef HAVE_ALIGNED_ALLOC\n+  ret = aligned_alloc (al, size);\n+#elif defined(HAVE__ALIGNED_MALLOC)\n+  ret = _aligned_malloc (size, al);\n+#elif defined(HAVE_POSIX_MEMALIGN)\n+  if (posix_memalign (&ret, al, size) != 0)\n+    ret = NULL;\n+#elif defined(HAVE_MEMALIGN)\n+  {\n+    extern void *memalign (size_t, size_t);\n+    ret = memalign (al, size);\n+  }\n+#else\n+  ret = NULL;\n+  if ((al & (al - 1)) == 0 && size)\n+    {\n+      void *p = malloc (size + al);\n+      if (p)\n+\t{\n+\t  void *ap = (void *) (((uintptr_t) p + al) & -al);\n+\t  ((void **) ap)[-1] = p;\n+\t  ret = ap;\n+\t}\n+    }\n+#endif\n+  if (ret == NULL)\n+    gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n+  return ret;\n+}\n+\n+void\n+gomp_aligned_free (void *ptr)\n+{\n+#ifdef GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC\n+  free (ptr);\n+#else\n+  if (ptr)\n+    free (((void **) ptr)[-1]);\n+#endif\n+}"}, {"sha": "52f4ed44412a0d7dde02458f55efcf138b083f87", "filename": "libgomp/config.h.in", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -1,5 +1,8 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Define to 1 if you have the `aligned_alloc' function. */\n+#undef HAVE_ALIGNED_ALLOC\n+\n /* Define to 1 if the target assembler supports .symver directive. */\n #undef HAVE_AS_SYMVER_DIRECTIVE\n \n@@ -33,9 +36,15 @@\n /* Define to 1 if you have the `getgid' function. */\n #undef HAVE_GETGID\n \n+/* Define if gethostname is supported. */\n+#undef HAVE_GETHOSTNAME\n+\n /* Define to 1 if you have the `getloadavg' function. */\n #undef HAVE_GETLOADAVG\n \n+/* Define if getpid is supported. */\n+#undef HAVE_GETPID\n+\n /* Define to 1 if you have the `getuid' function. */\n #undef HAVE_GETUID\n \n@@ -45,9 +54,15 @@\n /* Define to 1 if you have the `dl' library (-ldl). */\n #undef HAVE_LIBDL\n \n+/* Define to 1 if you have the `memalign' function. */\n+#undef HAVE_MEMALIGN\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n+/* Define to 1 if you have the `posix_memalign' function. */\n+#undef HAVE_POSIX_MEMALIGN\n+\n /* Define if pthread_{,attr_}{g,s}etaffinity_np is supported. */\n #undef HAVE_PTHREAD_AFFINITY_NP\n \n@@ -103,9 +118,15 @@\n /* Define to 1 if the target supports thread-local storage. */\n #undef HAVE_TLS\n \n+/* Define if uname is supported and struct utsname has nodename field. */\n+#undef HAVE_UNAME\n+\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define to 1 if you have the `_aligned_malloc' function. */\n+#undef HAVE__ALIGNED_MALLOC\n+\n /* Define to 1 if you have the `__secure_getenv' function. */\n #undef HAVE___SECURE_GETENV\n "}, {"sha": "d2dcc1ea852514ca5cbb58f8fdf9976a736880e1", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -396,6 +396,56 @@ gomp_get_place_proc_ids_8 (int place_num, int64_t *ids)\n       *ids++ = i;\n }\n \n+void\n+gomp_display_affinity_place (char *buffer, size_t size, size_t *ret,\n+\t\t\t     int place)\n+{\n+  cpu_set_t *cpusetp;\n+  char buf[sizeof (long) * 3 + 4];\n+  if (place >= 0 && place < gomp_places_list_len)\n+    cpusetp = (cpu_set_t *) gomp_places_list[place];\n+  else if (gomp_cpusetp)\n+    cpusetp = gomp_cpusetp;\n+  else\n+    {\n+      if (gomp_available_cpus > 1)\n+\tsprintf (buf, \"0-%lu\", gomp_available_cpus - 1);\n+      else\n+\tstrcpy (buf, \"0\");\n+      gomp_display_string (buffer, size, ret, buf, strlen (buf));\n+      return;\n+    }\n+\n+  unsigned long i, max = 8 * gomp_cpuset_size, start;\n+  bool prev_set = false;\n+  start = max;\n+  for (i = 0; i <= max; i++)\n+    {\n+      bool this_set;\n+      if (i == max)\n+\tthis_set = false;\n+      else\n+\tthis_set = CPU_ISSET_S (i, gomp_cpuset_size, cpusetp);\n+      if (this_set != prev_set)\n+\t{\n+\t  prev_set = this_set;\n+\t  if (this_set)\n+\t    {\n+\t      char *p = buf;\n+\t      if (start != max)\n+\t\t*p++ = ',';\n+\t      sprintf (p, \"%lu\", i);\n+\t      start = i;\n+\t    }\n+\t  else if (i == start + 1)\n+\t    continue;\n+\t  else\n+\t    sprintf (buf, \"-%lu\", i - 1);\n+\t  gomp_display_string (buffer, size, ret, buf, strlen (buf));\n+\t}\n+    }\n+}\n+\n ialias(omp_get_place_num_procs)\n ialias(omp_get_place_proc_ids)\n "}, {"sha": "8cb464bb61ccd2fc039800c9af5ca51ebe1ee446", "filename": "libgomp/config/nvptx/icv-device.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -45,20 +45,6 @@ omp_get_num_devices (void)\n   return 0;\n }\n \n-int\n-omp_get_num_teams (void)\n-{\n-  return gomp_num_teams_var + 1;\n-}\n-\n-int\n-omp_get_team_num (void)\n-{\n-  int ctaid;\n-  asm (\"mov.u32 %0, %%ctaid.x;\" : \"=r\" (ctaid));\n-  return ctaid;\n-}\n-\n int\n omp_is_initial_device (void)\n {\n@@ -69,6 +55,4 @@ omp_is_initial_device (void)\n ialias (omp_set_default_device)\n ialias (omp_get_default_device)\n ialias (omp_get_num_devices)\n-ialias (omp_get_num_teams)\n-ialias (omp_get_team_num)\n ialias (omp_is_initial_device)"}, {"sha": "3878227a27fa79443a9d0cf73c6569d18c9f7801", "filename": "libgomp/config/nvptx/target.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ftarget.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -47,3 +47,21 @@ GOMP_teams (unsigned int num_teams, unsigned int thread_limit)\n     }\n   gomp_num_teams_var = num_teams - 1;\n }\n+\n+int\n+omp_pause_resource (omp_pause_resource_t kind, int device_num)\n+{\n+  (void) kind;\n+  (void) device_num;\n+  return -1;\n+}\n+\n+int\n+omp_pause_resource_all (omp_pause_resource_t kind)\n+{\n+  (void) kind;\n+  return -1;\n+}\n+\n+ialias (omp_pause_resource)\n+ialias (omp_pause_resource_all)"}, {"sha": "8b0a0903641bf7035eec122d1788e78bdc706c2f", "filename": "libgomp/config/nvptx/team.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fteam.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -116,7 +116,8 @@ gomp_thread_start (struct gomp_thread_pool *pool)\n \n void\n gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n-\t\t unsigned flags, struct gomp_team *team)\n+\t\t unsigned flags, struct gomp_team *team,\n+\t\t struct gomp_taskgroup *taskgroup)\n {\n   struct gomp_thread *thr, *nthr;\n   struct gomp_task *task;\n@@ -147,6 +148,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   nthreads_var = icv->nthreads_var;\n   gomp_init_task (thr->task, task, icv);\n   team->implicit_task[0].icv.nthreads_var = nthreads_var;\n+  team->implicit_task[0].taskgroup = taskgroup;\n \n   if (nthreads == 1)\n     return;\n@@ -166,6 +168,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       nthr->task = &team->implicit_task[i];\n       gomp_init_task (nthr->task, task, icv);\n       team->implicit_task[i].icv.nthreads_var = nthreads_var;\n+      team->implicit_task[i].taskgroup = taskgroup;\n       nthr->fn = fn;\n       nthr->data = data;\n       team->ordered_release[i] = &nthr->release;\n@@ -174,5 +177,11 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   gomp_simple_barrier_wait (&pool->threads_dock);\n }\n \n+int\n+gomp_pause_host (void)\n+{\n+  return -1;\n+}\n+\n #include \"../../team.c\"\n #endif"}, {"sha": "9bed0320fb829b3b6dc16074b039361928c49b5e", "filename": "libgomp/config/nvptx/teams.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Fteams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfig%2Fnvptx%2Fteams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fteams.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov <amonakov@ispras.ru>\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines OpenMP API entry points that accelerator targets are\n+   expected to replace.  */\n+\n+#include \"libgomp.h\"\n+\n+void\n+GOMP_teams_reg (void (*fn) (void *), void *data, unsigned int num_teams,\n+\t\tunsigned int thread_limit, unsigned int flags)\n+{\n+  (void) fn;\n+  (void) data;\n+  (void) flags;\n+  (void) num_teams;\n+  (void) thread_limit;\n+}\n+\n+int\n+omp_get_num_teams (void)\n+{\n+  return gomp_num_teams_var + 1;\n+}\n+\n+int\n+omp_get_team_num (void)\n+{\n+  int ctaid;\n+  asm (\"mov.u32 %0, %%ctaid.x;\" : \"=r\" (ctaid));\n+  return ctaid;\n+}\n+\n+ialias (omp_get_num_teams)\n+ialias (omp_get_team_num)"}, {"sha": "013e37c0ba5293fe88010b8a8e9d7fb87e72de54", "filename": "libgomp/configure", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -15812,6 +15812,19 @@ _ACEOF\n fi\n done\n \n+for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc\n+do :\n+  as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n+ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n+eval as_val=\\$$as_ac_var\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+done\n+\n \n # Check for broken semaphore implementation on darwin.\n # sem_init returns: sem_init error: Function not implemented.\n@@ -16026,6 +16039,72 @@ fi\n \n fi\n \n+# Check for uname.\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <string.h>\n+   #include <stdlib.h>\n+   #include <sys/utsname.h>\n+int\n+main ()\n+{\n+struct utsname buf;\n+   volatile size_t len = 0;\n+   if (!uname (buf))\n+     len = strlen (buf.nodename);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_UNAME 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\n+# Check for gethostname.\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <unistd.h>\n+int\n+main ()\n+{\n+\n+   char buf[256];\n+   if (gethostname (buf, sizeof (buf) - 1) == 0)\n+     buf[255] = '\\0';\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_GETHOSTNAME 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\n+# Check for getpid.\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <unistd.h>\n+int\n+main ()\n+{\n+int pid = getpid ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_GETPID 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+\n # See if we support thread-local storage.\n \n "}, {"sha": "f75c6226566cd8a8281f155e1112a155ff9c9697", "filename": "libgomp/configure.ac", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -218,6 +218,7 @@ m4_include([plugin/configfrag.ac])\n \n # Check for functions needed.\n AC_CHECK_FUNCS(getloadavg clock_gettime strtoull)\n+AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)\n \n # Check for broken semaphore implementation on darwin.\n # sem_init returns: sem_init error: Function not implemented.\n@@ -265,6 +266,41 @@ if test $ac_cv_func_clock_gettime = no; then\n \t       [Define to 1 if you have the `clock_gettime' function.])])\n fi\n \n+# Check for uname.\n+AC_COMPILE_IFELSE(\n+ [AC_LANG_PROGRAM(\n+  [#include <string.h>\n+   #include <stdlib.h>\n+   #include <sys/utsname.h>],\n+  [struct utsname buf;\n+   volatile size_t len = 0;\n+   if (!uname (buf))\n+     len = strlen (buf.nodename);])],\n+  AC_DEFINE(HAVE_UNAME, 1,\n+[\tDefine if uname is supported and struct utsname has nodename field.]))\n+\n+# Check for gethostname.\n+AC_COMPILE_IFELSE(\n+ [AC_LANG_PROGRAM(\n+  [#include <unistd.h>],\n+  [\n+changequote(,)dnl\n+   char buf[256];\n+   if (gethostname (buf, sizeof (buf) - 1) == 0)\n+     buf[255] = '\\0';\n+changequote([,])dnl\n+  ])],\n+  AC_DEFINE(HAVE_GETHOSTNAME, 1,\n+[\tDefine if gethostname is supported.]))\n+\n+# Check for getpid.\n+AC_COMPILE_IFELSE(\n+ [AC_LANG_PROGRAM(\n+  [#include <unistd.h>],\n+  [int pid = getpid ();])],\n+  AC_DEFINE(HAVE_GETPID, 1,\n+[\tDefine if getpid is supported.]))\n+\n # See if we support thread-local storage.\n GCC_CHECK_TLS\n "}, {"sha": "b88bf72fe3de3735929635c874b8da375c841b1d", "filename": "libgomp/configure.tgt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.tgt?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c", "patch": "@@ -18,7 +18,7 @@ if test $gcc_cv_have_tls = yes ; then\n \t;;\n \n     *-*-linux* | *-*-gnu*)\n-\tXCFLAGS=\"${XCFLAGS} -ftls-model=initial-exec\"\n+\tXCFLAGS=\"${XCFLAGS} -ftls-model=initial-exec -DUSING_INITIAL_EXEC_TLS\"\n \t;;\n \n     *-*-rtems*)"}, {"sha": "2c9a609d6072385f3c1b47bc2d97cee130fa4be8", "filename": "libgomp/env.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "0157baec648dbdb18ec2ac662d624c15ef909766", "filename": "libgomp/fortran.c", "status": "modified", "additions": 102, "deletions": 2, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "9cb394e74dced7bef1303f9aeec961ff9c0471a7", "filename": "libgomp/icv-device.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv-device.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "68c400aec817eb0cc148d3dcfa8fe68a792e823e", "filename": "libgomp/icv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ficv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ficv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "828e9b0095b3128998b10617ee637f4044535b65", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 104, "deletions": 6, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d8e2fd1818b9a754e6da75abd0661a23a9b99b85", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "5b54839b29e5aeb5bee5a71775c25790e01754a0", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "4e0683ba675ad1a748efadbcb287f165d63a9235", "filename": "libgomp/loop.c", "status": "modified", "additions": 312, "deletions": 29, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "ac658023e13baba57575479673f1a8d67e156818", "filename": "libgomp/loop_ull.c", "status": "modified", "additions": 271, "deletions": 15, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Floop_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Floop_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop_ull.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "a18303470c010ca18c7f4039525aad2e6da621dd", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "caecfba749dd76a69aaf6824c4bd8daf41b18e8e", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "2a553435a451580866a4f8f3e0875663c948c0a2", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "521e9122d908ecb483519480367ba0da717c75a6", "filename": "libgomp/ordered.c", "status": "modified", "additions": 53, "deletions": 11, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fordered.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "c7a8c788a3bc629195c243d40e4603d34ce3dd40", "filename": "libgomp/parallel.c", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fparallel.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "3449e0067ddcdb6803a6de92aaa813a477607f88", "filename": "libgomp/sections.c", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fsections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fsections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsections.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d5093c6730c396221bce4109b5d8208be42fe6e6", "filename": "libgomp/single.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsingle.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "8ebc2a370a1656d0a3e3e68664f3048ef668ffb1", "filename": "libgomp/target.c", "status": "modified", "additions": 99, "deletions": 31, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "0c78b3c939cde5e2289b0bf4de69f27a8493426d", "filename": "libgomp/task.c", "status": "modified", "additions": 523, "deletions": 45, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "4621405aa58e599e3a0c5de0623312c40ed434b2", "filename": "libgomp/taskloop.c", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftaskloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftaskloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftaskloop.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "e3e4c4d1ef2771c260ce7239e02422a873bdac8f", "filename": "libgomp/team.c", "status": "modified", "additions": 135, "deletions": 10, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "5aa0eae68d35cc416b6ac93031ad63ea5f89d453", "filename": "libgomp/teams.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fteams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fteams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteams.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "71a24d19f2a47693bb1a1cc28501578e81f6a45d", "filename": "libgomp/testsuite/libgomp.c++/depend-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepend-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepend-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepend-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "2cff5e84334f2e2bae6aa8f0f9aabb499d274a31", "filename": "libgomp/testsuite/libgomp.c++/depend-iterator-1.C", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepend-iterator-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepend-iterator-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepend-iterator-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "91edf8cc34b11209a1637b77b4fe6454d3503308", "filename": "libgomp/testsuite/libgomp.c++/depobj-1.C", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepobj-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepobj-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fdepobj-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "e7e5b857f232538160956cea8f466820108d8e24", "filename": "libgomp/testsuite/libgomp.c++/for-16.C", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-16.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "fc0cb0ab672a50b3e83f6cf742d74f55ca7cdf5e", "filename": "libgomp/testsuite/libgomp.c++/for-21.C", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-21.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "35fcf1f1dce0ba5eab72fb54246efdbc02c609f7", "filename": "libgomp/testsuite/libgomp.c++/for-22.C", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-22.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "e0d7b7afae414488b45201c7a324d338a4aa4ed6", "filename": "libgomp/testsuite/libgomp.c++/for-23.C", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-23.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "cb14addc14fc009feb58f34b189e3b36faec9d5c", "filename": "libgomp/testsuite/libgomp.c++/for-24.C", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-24.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "3fecb4887876864ab0ffc0275767c5c3f31c51d1", "filename": "libgomp/testsuite/libgomp.c++/for-25.C", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-25.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "bb7ae11d3cc0ecbc72349b34c5c16ac91680fb7f", "filename": "libgomp/testsuite/libgomp.c++/for-26.C", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-26.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "b3e228e5310c32044807885a2728cca7a578cc58", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-1.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "0eb94c121bedf32080e0e0401571956c0bec8e7a", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-10.C", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-10.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "542bdd64da1c000f9992a05bff264faff865adfc", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-11.C", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-11.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "02c1a787cbf41e096bf0f5235c29eb8fd56633ee", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-12.C", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-12.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "3d0165dfa92f87b73d19343b259bd88f2a0e7e3d", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-13.C", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-13.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "3f4e79b16c5916f502a6a6914901235ae72bdafb", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-14.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-14.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "8a01e6b240a1990ed96185bc077d0f93246f294d", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-15.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-15.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "5835edcbd5b35a54d3ae8830dc0f8625b7549b77", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-16.C", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-16.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "c00c8e46542e6406fd486129cd60ccc5705ebbaa", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-17.C", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-17.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "99c0e3727d430d9d7b7e1b36d037003ae21d12b3", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-18.C", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-18.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "15945c57cc247de15e1f269ee52b81c238577370", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-19.C", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-19.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "75d2ee37e4fc43dcd215fb88eb491f9c76e620a2", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-2.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "a6eccf6ced6b86f4935ff5d13add9db22ebf266f", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-3.C", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-3.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "1d4da79b3c12214a001ee514f4639651c8a4438b", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-4.C", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-4.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "59583f15c82672c8ce8cc76952b88cc6de629abd", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-5.C", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-5.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d7f69da219b069d1cdcc840c015f4a2c2ad5fe6e", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-6.C", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-6.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "2a4d82ef77bb6b055a6765c519597a20b03136b4", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-7.C", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-7.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "26737a32acbad88f485b124846e3f1a8a1edbc94", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-8.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-8.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "068a7bb7b5d4cf978e7e09505f955e88ba8066e5", "filename": "libgomp/testsuite/libgomp.c++/task-reduction-9.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-reduction-9.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "f7fb9cac9e53f546038aa5b5943d16e4e43bd5f9", "filename": "libgomp/testsuite/libgomp.c++/taskloop-reduction-1.C", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-1.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "f1de5dae2ea269d48b46e63628fd0ee8510ba34e", "filename": "libgomp/testsuite/libgomp.c++/taskloop-reduction-2.C", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-2.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "0588e4744f95951bde1b41ce932bcbdb531dd371", "filename": "libgomp/testsuite/libgomp.c++/taskloop-reduction-3.C", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-3.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "41c7040ff1a678a1da03b54b1e1b755c3b405916", "filename": "libgomp/testsuite/libgomp.c++/taskloop-reduction-4.C", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskloop-reduction-4.C?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "77395e2b0f3e3741586c21be953c44f2e5bb58ef", "filename": "libgomp/testsuite/libgomp.c-c++-common/cancel-parallel-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fcancel-parallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fcancel-parallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fcancel-parallel-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "b9af83595b0ed70a19d3abac410d4072277e7c65", "filename": "libgomp/testsuite/libgomp.c-c++-common/cancel-taskgroup-3.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fcancel-taskgroup-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fcancel-taskgroup-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fcancel-taskgroup-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "03cded42cbd25f02a8e16a9ac67706fdb51296fe", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-iterator-1.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-iterator-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-iterator-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-iterator-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d9cbfdcbe7942c2c25243ac17803277cccd71059", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-iterator-2.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-iterator-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-iterator-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-iterator-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "86322eddbcc6ecae7e57db43b6e62f1382adc71b", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-mutexinout-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-mutexinout-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-mutexinout-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-mutexinout-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "ed92063e2c9868d9abd0d39c93e0d8aa89bf14d9", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-mutexinout-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-mutexinout-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-mutexinout-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-mutexinout-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "a07a0c889c113a74ebc2c58243ac46b89cbd03ec", "filename": "libgomp/testsuite/libgomp.c-c++-common/depobj-1.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepobj-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepobj-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepobj-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "a67bb37f1f0a582488beb204d3f4b1a9908f5e16", "filename": "libgomp/testsuite/libgomp.c-c++-common/display-affinity-1.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdisplay-affinity-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdisplay-affinity-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdisplay-affinity-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "2b339a599ce6ff423f99d618f632f21c52f891de", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-10.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-10.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "e46b4dd04c176fa70917ac251b9632a117ac4884", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-11.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-11.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "e28ba93f8fe6aba1f925020451067212d2f427e7", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-12.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-12.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "a4767278fbb1cca3183cc6664780566c2a68e108", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-13.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-13.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "56440ab740fea320218c875be5006938802b6f31", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-14.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-14.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "512b97256036c29af1d3a32597be9f6ec466049e", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-15.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-15.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "91a604a6c25ee23a3f4d10d06870a9bdcbbebfb4", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-2.h", "status": "modified", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-2.h?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "43461bb5534d07a73154b90ba07005c5f297707f", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-7.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-7.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "ed6bf7111b59fa0cbf4a729dd1f4723a2e7ebd05", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-8.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-8.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "dfd674fee56dca8e22c79f7a0c8380e5a21652e2", "filename": "libgomp/testsuite/libgomp.c-c++-common/for-9.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ffor-9.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "3e6da095122ec9e66f9954469b9c1ad5552cc029", "filename": "libgomp/testsuite/libgomp.c-c++-common/master-combined-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fmaster-combined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fmaster-combined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fmaster-combined-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "5367a72832ef4d511a7b2c8a44c48ee87fd0b0ed", "filename": "libgomp/testsuite/libgomp.c-c++-common/pause-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpause-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "e4781cdc70756e7324c7e01a0aa1ff51d712f541", "filename": "libgomp/testsuite/libgomp.c-c++-common/pause-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpause-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpause-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpause-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "301fa6c25511d968e089e4c096650f450e7a3b1e", "filename": "libgomp/testsuite/libgomp.c-c++-common/pr66199-10.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-10.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "bcb596eef5c06f5bc5b8add197c54f626528abb7", "filename": "libgomp/testsuite/libgomp.c-c++-common/pr66199-11.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-11.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "78eb12ac7aa1bef72b9ee5f7191f6ad254b41dfa", "filename": "libgomp/testsuite/libgomp.c-c++-common/pr66199-12.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-12.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "2f41a3860f4fdc7f1295272908f8cc4c5a1a2f64", "filename": "libgomp/testsuite/libgomp.c-c++-common/pr66199-13.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-13.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "21936bfafaf8f4814c33499277b8d69fcd95a402", "filename": "libgomp/testsuite/libgomp.c-c++-common/pr66199-14.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fpr66199-14.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "cce234d817183aca88aa4de95f3fca87017f9bd3", "filename": "libgomp/testsuite/libgomp.c-c++-common/simd-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fsimd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fsimd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fsimd-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "6c6191d96d59770e35a2690f4e8319d273d1a6af", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "038b0e269e76620eb5764f6964660c4fbe425ce3", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-11.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-11.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "0ad92735ca74ae23a30c831b9a661a698724817f", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-12.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-12.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "aad725c29e34f5c99b059525f29b692d54fe998b", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-2.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "8a90e86e8470ea8f4bbd7507261d692b70526ad2", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-3.c", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "b0e5197623b98fe48c10e88349abb05dacf29cfd", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-4.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-4.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "018dc4fb28e4b3e45e9ecc7f766a91515cdb898f", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-5.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-5.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "09cbea66542634b1c5fd2fbbf41be7e963192c07", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-6.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-6.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "c656f5ff00bdcf63a9483ea7e37888cd9dd57a2b", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-7.c", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-7.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "7b0859db6f01a1b12f7ab8926627f23e7457a23a", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-8.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-8.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "3d71fef867080fdc0c22417eb3d709698e030177", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-reduction-9.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-reduction-9.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d44b471a37258838de8d74d0b5f585a3d57b55fe", "filename": "libgomp/testsuite/libgomp.c-c++-common/taskloop-reduction-1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "8fc05dc668e2ae6727d9dbec22e8346bed833301", "filename": "libgomp/testsuite/libgomp.c-c++-common/taskloop-reduction-2.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "30a832490465eaf3f941512d1ac72fbf394fad47", "filename": "libgomp/testsuite/libgomp.c-c++-common/taskloop-reduction-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-3.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "c1c29b37414f3084312cf326353e91c8b00bbdaf", "filename": "libgomp/testsuite/libgomp.c-c++-common/taskloop-reduction-4.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskloop-reduction-4.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "094b4b3586a336c6cc64f590c8bb8ffef96a53e1", "filename": "libgomp/testsuite/libgomp.c-c++-common/taskwait-depend-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskwait-depend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskwait-depend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftaskwait-depend-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d1d6f86733d9368224e22281f76545c61e4fb477", "filename": "libgomp/testsuite/libgomp.c/cancel-for-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "224d995bd13190a0990ebabceaa6893faa1cf088", "filename": "libgomp/testsuite/libgomp.c/task-reduction-1.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-reduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-reduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-reduction-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "f5d48c36873c4e7667a247564aadb5bd874de38c", "filename": "libgomp/testsuite/libgomp.c/task-reduction-2.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-reduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-reduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-reduction-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "c5df8371b9ee592facdf7e5f5ba04ed519f72d7a", "filename": "libgomp/testsuite/libgomp.c/teams-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fteams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fteams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fteams-1.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "2ddf50875c5eaeff6e780b829ff04853e388261c", "filename": "libgomp/testsuite/libgomp.c/teams-2.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fteams-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fteams-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fteams-2.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "5642e6a87ba4382173c3c54bbe3f6ad5067639b1", "filename": "libgomp/testsuite/libgomp.c/thread-limit-4.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-4.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "d3d22b1e1a622e75c7dad39f79a254382d719622", "filename": "libgomp/testsuite/libgomp.c/thread-limit-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-5.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "4811b6f801b96e6cc12d05e839a63e619688732f", "filename": "libgomp/testsuite/libgomp.fortran/display-affinity-1.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdisplay-affinity-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdisplay-affinity-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdisplay-affinity-1.f90?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}, {"sha": "16fc7076eddf8d6a69024bcc1e4a163c4ec6eee0", "filename": "libgomp/work.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28567c40e2c7c88e424283e8a1a6ff8cb7ba440c/libgomp%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fwork.c?ref=28567c40e2c7c88e424283e8a1a6ff8cb7ba440c"}]}