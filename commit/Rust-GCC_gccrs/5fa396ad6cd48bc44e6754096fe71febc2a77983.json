{"sha": "5fa396ad6cd48bc44e6754096fe71febc2a77983", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhMzk2YWQ2Y2Q0OGJjNDRlNjc1NDA5NmZlNzFmZWJjMmE3Nzk4Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-07-16T16:10:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-07-16T16:10:58Z"}, "message": "profile-count.h (profile_probability::from_reg_br_prob_note, [...]): New functions.\n\n\n\t* profile-count.h (profile_probability::from_reg_br_prob_note,\n\tprofile_probability::to_reg_br_prob_note): New functions.\n\t* doc/rtl.texi (REG_BR_PROB_NOTE): Update documentation.\n\t* reg-notes.h (REG_BR_PROB, REG_BR_PRED): Update docs.\n\t* predict.c (probability_reliable_p): Update.\n\t(edge_probability_reliable_p): Update.\n\t(br_prob_note_reliable_p): Update.\n\t(invert_br_probabilities): Update.\n\t(add_reg_br_prob_note): New function.\n\t(combine_predictions_for_insn): Update.\n\t* asan.c (asan_clear_shadow): Update.\n\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Update.\n\t(update_br_prob_note): Update.\n\t(rtl_verify_edges): Update.\n\t(purge_dead_edges): Update.\n\t(fixup_reorder_chain): Update.\n\t* emit-rtl.c (try_split): Update.\n\t* ifcvt.c (cond_exec_process_insns): Update.\n\t(cond_exec_process_if_block): Update.\n\t(dead_or_predicable): Update.\n\t* internal-fn.c (expand_addsub_overflow): Update.\n\t(expand_neg_overflow): Update.\n\t(expand_mul_overflow): Update.\n\t* loop-doloop.c (doloop_modify): Update.\n\t* loop-unroll.c (compare_and_jump_seq): Update.\n\t* optabs.c (emit_cmp_and_jump_insn_1): Update.\n\t* predict.h: Update.\n\t* reorg.c (mostly_true_jump): Update.\n\t* rtl.h: Update.\n\t* config/aarch64/aarch64.c (aarch64_emit_unlikely_jump): Update.\n\t* config/alpha/alpha.c (emit_unlikely_jump): Update.\n\t* config/arc/arc.c: (emit_unlikely_jump): Update.\n\t* config/arm/arm.c: (emit_unlikely_jump): Update.\n\t* config/bfin/bfin.c (cbranch_predicted_taken_p): Update.\n\t* config/frv/frv.c (frv_print_operand_jump_hint): Update.\n\t* config/i386/i386.c (ix86_expand_split_stack_prologue): Update.\n\t(ix86_print_operand): Update.\n\t(ix86_split_fp_branch): Update.\n\t(predict_jump): Update.\n\t* config/ia64/ia64.c (ia64_print_operand): Update.\n\t* config/mmix/mmix.c (mmix_print_operand): Update.\n\t* config/powerpcspe/powerpcspe.c (output_cbranch): Update.\n\t(rs6000_expand_split_stack_prologue): Update.\n\t* config/rs6000/rs6000.c: Update.\n\t* config/s390/s390.c (s390_expand_vec_strlen): Update.\n\t(s390_expand_vec_movstr): Update.\n\t(s390_expand_cs_tdsi): Update.\n\t(s390_expand_split_stack_prologue): Update.\n\t* config/sh/sh.c (sh_print_operand): Update.\n\t(expand_cbranchsi4): Update.\n\t(expand_cbranchdi4): Update.\n\t* config/sparc/sparc.c (output_v9branch): Update.\n\t* config/spu/spu.c (get_branch_target): Update.\n\t(ea_load_store_inline): Update.\n\t* config/tilegx/tilegx.c (cbranch_predicted_p): Update.\n\t* config/tilepro/tilepro.c: Update.\n\t* gcc.dg/predict-8.c: Update.\n\nFrom-SVN: r250239", "tree": {"sha": "8b2c0f4ba184b9d1af37e1f345be3b518d3f6101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b2c0f4ba184b9d1af37e1f345be3b518d3f6101"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fa396ad6cd48bc44e6754096fe71febc2a77983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa396ad6cd48bc44e6754096fe71febc2a77983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa396ad6cd48bc44e6754096fe71febc2a77983", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa396ad6cd48bc44e6754096fe71febc2a77983/comments", "author": null, "committer": null, "parents": [{"sha": "519087cf749bd002784f09f0ca6f74215fbf5bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519087cf749bd002784f09f0ca6f74215fbf5bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519087cf749bd002784f09f0ca6f74215fbf5bbc"}], "stats": {"total": 447, "additions": 262, "deletions": 185}, "files": [{"sha": "f3bafa52d37fac22578c91f4265c2dbdab86d7e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1,3 +1,63 @@\n+2017-07-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* profile-count.h (profile_probability::from_reg_br_prob_note,\n+\tprofile_probability::to_reg_br_prob_note): New functions.\n+\t* doc/rtl.texi (REG_BR_PROB_NOTE): Update documentation.\n+\t* reg-notes.h (REG_BR_PROB, REG_BR_PRED): Update docs.\n+\t* predict.c (probability_reliable_p): Update.\n+\t(edge_probability_reliable_p): Update.\n+\t(br_prob_note_reliable_p): Update.\n+\t(invert_br_probabilities): Update.\n+\t(add_reg_br_prob_note): New function.\n+\t(combine_predictions_for_insn): Update.\n+\t* asan.c (asan_clear_shadow): Update.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Update.\n+\t(update_br_prob_note): Update.\n+\t(rtl_verify_edges): Update.\n+\t(purge_dead_edges): Update.\n+\t(fixup_reorder_chain): Update.\n+\t* emit-rtl.c (try_split): Update.\n+\t* ifcvt.c (cond_exec_process_insns): Update.\n+\t(cond_exec_process_if_block): Update.\n+\t(dead_or_predicable): Update.\n+\t* internal-fn.c (expand_addsub_overflow): Update.\n+\t(expand_neg_overflow): Update.\n+\t(expand_mul_overflow): Update.\n+\t* loop-doloop.c (doloop_modify): Update.\n+\t* loop-unroll.c (compare_and_jump_seq): Update.\n+\t* optabs.c (emit_cmp_and_jump_insn_1): Update.\n+\t* predict.h: Update.\n+\t* reorg.c (mostly_true_jump): Update.\n+\t* rtl.h: Update.\n+\t* config/aarch64/aarch64.c (aarch64_emit_unlikely_jump): Update.\n+\t* config/alpha/alpha.c (emit_unlikely_jump): Update.\n+\t* config/arc/arc.c: (emit_unlikely_jump): Update.\n+\t* config/arm/arm.c: (emit_unlikely_jump): Update.\n+\t* config/bfin/bfin.c (cbranch_predicted_taken_p): Update.\n+\t* config/frv/frv.c (frv_print_operand_jump_hint): Update.\n+\t* config/i386/i386.c (ix86_expand_split_stack_prologue): Update.\n+\t(ix86_print_operand): Update.\n+\t(ix86_split_fp_branch): Update.\n+\t(predict_jump): Update.\n+\t* config/ia64/ia64.c (ia64_print_operand): Update.\n+\t* config/mmix/mmix.c (mmix_print_operand): Update.\n+\t* config/powerpcspe/powerpcspe.c (output_cbranch): Update.\n+\t(rs6000_expand_split_stack_prologue): Update.\n+\t* config/rs6000/rs6000.c: Update.\n+\t* config/s390/s390.c (s390_expand_vec_strlen): Update.\n+\t(s390_expand_vec_movstr): Update.\n+\t(s390_expand_cs_tdsi): Update.\n+\t(s390_expand_split_stack_prologue): Update.\n+\t* config/sh/sh.c (sh_print_operand): Update.\n+\t(expand_cbranchsi4): Update.\n+\t(expand_cbranchdi4): Update.\n+\t* config/sparc/sparc.c (output_v9branch): Update.\n+\t* config/spu/spu.c (get_branch_target): Update.\n+\t(ea_load_store_inline): Update.\n+\t* config/tilegx/tilegx.c (cbranch_predicted_p): Update.\n+\t* config/tilepro/tilepro.c: Update.\n+\n 2017-07-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimplify.c (mostly_copy_tree_r): Revert latest change."}, {"sha": "a56174a165641b3054fcd86cfc2dc5e3a3b81846", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1208,7 +1208,9 @@ asan_clear_shadow (rtx shadow_mem, HOST_WIDE_INT len)\n   emit_cmp_and_jump_insns (addr, end, LT, NULL_RTX, Pmode, true, top_label);\n   jump = get_last_insn ();\n   gcc_assert (JUMP_P (jump));\n-  add_int_reg_note (jump, REG_BR_PROB, REG_BR_PROB_BASE * 80 / 100);\n+  add_reg_br_prob_note (jump,\n+\t\t\tprofile_probability::guessed_always ()\n+\t\t\t   .apply_scale (80, 100));\n }\n \n void"}, {"sha": "16b07073b917e62227195bb6d28b47e4d0b2efad", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -546,12 +546,10 @@ compute_outgoing_frequencies (basic_block b)\n \t  probability = XINT (note, 0);\n \t  e = BRANCH_EDGE (b);\n \t  e->probability\n-\t\t = profile_probability::from_reg_br_prob_base (probability);\n-\t  e->count = b->count.apply_probability (probability);\n+\t\t = profile_probability::from_reg_br_prob_note (probability);\n+\t  e->count = b->count.apply_probability (e->probability);\n \t  f = FALLTHRU_EDGE (b);\n-\t  f->probability\n-\t\t = profile_probability::from_reg_br_prob_base (REG_BR_PROB_BASE\n-\t\t\t\t\t\t\t       - probability);\n+\t  f->probability = e->probability.invert ();\n \t  f->count = b->count - e->count;\n \t  return;\n \t}"}, {"sha": "8c60eede0b972ebc012bed58afc77589fc44e661", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1504,8 +1504,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t{\n \t  int prob = XINT (note, 0);\n \n-\t  b->probability = profile_probability::from_reg_br_prob_base (prob);\n-\t  b->count = e->count.apply_probability (prob);\n+\t  b->probability = profile_probability::from_reg_br_prob_note (prob);\n+\t  b->count = e->count.apply_probability (b->probability);\n \t  e->probability -= e->probability;\n \t  e->count -= b->count;\n \t}\n@@ -2253,9 +2253,9 @@ update_br_prob_note (basic_block bb)\n     return;\n   note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n   if (!note\n-      || XINT (note, 0) == BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ())\n+      || XINT (note, 0) == BRANCH_EDGE (bb)->probability.to_reg_br_prob_note ())\n     return;\n-  XINT (note, 0) = BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ();\n+  XINT (note, 0) = BRANCH_EDGE (bb)->probability.to_reg_br_prob_note ();\n }\n \n /* Get the last insn associated with block BB (that includes barriers and\n@@ -2456,12 +2456,12 @@ rtl_verify_edges (void)\n \t\t}\n \t    }\n \t  else if (XINT (note, 0)\n-\t           != BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ()\n+\t           != BRANCH_EDGE (bb)->probability.to_reg_br_prob_note ()\n \t           && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t    {\n \t      error (\"verify_flow_info: REG_BR_PROB does not match cfg %i %i\",\n \t\t     XINT (note, 0),\n-\t\t     BRANCH_EDGE (bb)->probability.to_reg_br_prob_base ());\n+\t\t     BRANCH_EDGE (bb)->probability.to_reg_br_prob_note ());\n \t      err = 1;\n \t    }\n \t}\n@@ -3164,9 +3164,9 @@ purge_dead_edges (basic_block bb)\n \n \t  b = BRANCH_EDGE (bb);\n \t  f = FALLTHRU_EDGE (bb);\n-\t  b->probability = profile_probability::from_reg_br_prob_base\n+\t  b->probability = profile_probability::from_reg_br_prob_note\n \t\t\t\t\t (XINT (note, 0));\n-\t  f->probability = profile_probability::always () - b->probability;\n+\t  f->probability = b->probability.invert ();\n \t  b->count = bb->count.apply_probability (b->probability);\n \t  f->count = bb->count.apply_probability (f->probability);\n \t}\n@@ -3792,7 +3792,8 @@ fixup_reorder_chain (void)\n \t\t  rtx note = find_reg_note (bb_end_jump, REG_BR_PROB, 0);\n \n \t\t  if (note\n-\t\t      && XINT (note, 0) < REG_BR_PROB_BASE / 2\n+\t\t      && profile_probability::from_reg_br_prob_note\n+\t\t\t\t (XINT (note, 0)) < profile_probability::even ()\n \t\t      && invert_jump (bb_end_jump,\n \t\t\t\t      (e_fall->dest\n \t\t\t\t       == EXIT_BLOCK_PTR_FOR_FN (cfun)"}, {"sha": "b8a4160d9de8e689ccd26cb9f0ce046ee65e0ef4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -12161,10 +12161,8 @@ aarch64_emit_store_exclusive (machine_mode mode, rtx bval,\n static void\n aarch64_emit_unlikely_jump (rtx insn)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n-\n   rtx_insn *jump = emit_jump_insn (insn);\n-  add_int_reg_note (jump, REG_BR_PROB, very_unlikely);\n+  add_reg_br_prob_note (jump, profile_probability::very_unlikely ());\n }\n \n /* Expand a compare and swap pattern.  */"}, {"sha": "1114e6601b6a8660a895ba16ab0c4d0e696bab84", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -4319,10 +4319,9 @@ alpha_expand_builtin_vector_binop (rtx (*gen) (rtx, rtx, rtx),\n static void\n emit_unlikely_jump (rtx cond, rtx label)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n   rtx x = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, label, pc_rtx);\n   rtx_insn *insn = emit_jump_insn (gen_rtx_SET (pc_rtx, x));\n-  add_int_reg_note (insn, REG_BR_PROB, very_unlikely);\n+  add_reg_br_prob_note (insn, profile_probability::very_unlikely ());\n }\n \n /* A subroutine of the atomic operation splitters.  Emit a load-locked"}, {"sha": "a92ee4c82c053998b7571dbdbfdb81aee81d8b20", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -9979,10 +9979,8 @@ arc_post_atomic_barrier (enum memmodel model)\n static void\n emit_unlikely_jump (rtx insn)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n-\n   rtx_insn *jump = emit_jump_insn (insn);\n-  add_int_reg_note (jump, REG_BR_PROB, very_unlikely);\n+  add_reg_br_prob_note (jump, profile_probability::very_unlikely ());\n }\n \n /* Expand code to perform a 8 or 16-bit compare and swap by doing"}, {"sha": "1b7b382139e281b0812e57c7826eb042a9aac305", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -28271,7 +28271,7 @@ emit_unlikely_jump (rtx insn)\n   int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n \n   rtx_insn *jump = emit_jump_insn (insn);\n-  add_int_reg_note (jump, REG_BR_PROB, very_unlikely);\n+  add_reg_br_prob_note (jump, profile_probability::very_unlikely ());\n }\n \n /* Expand a compare and swap pattern.  */"}, {"sha": "9fe90fc37b4496f9172bed086151e6b7356f4bff", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -2435,9 +2435,8 @@ cbranch_predicted_taken_p (rtx insn)\n \n   if (x)\n     {\n-      int pred_val = XINT (x, 0);\n-\n-      return pred_val >= REG_BR_PROB_BASE / 2;\n+      return profile_probability::from_reg_br_prob_note (XINT (x, 0))\n+\t     >= profile_probability::even ();\n     }\n \n   return 0;"}, {"sha": "c571d63f2c667807635b4714f9c92b49bceb3953", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -2621,7 +2621,6 @@ frv_print_operand_jump_hint (rtx_insn *insn)\n   rtx note;\n   rtx labelref;\n   int ret;\n-  int prob = -1;\n   enum { UNKNOWN, BACKWARD, FORWARD } jump_type = UNKNOWN;\n \n   gcc_assert (JUMP_P (insn));\n@@ -2647,8 +2646,8 @@ frv_print_operand_jump_hint (rtx_insn *insn)\n \n       else\n \t{\n-\t  prob = XINT (note, 0);\n-\t  ret = ((prob >= (REG_BR_PROB_BASE / 2))\n+\t  ret = ((profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t\t  >= profile_probability::even ())\n \t\t ? FRV_JUMP_LIKELY\n \t\t : FRV_JUMP_NOT_LIKELY);\n \t}"}, {"sha": "eac76815287a9f2cde1e384c1c7a4f2b577b7ef6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -15783,8 +15783,7 @@ ix86_expand_split_stack_prologue (void)\n   JUMP_LABEL (jump_insn) = label;\n \n   /* Mark the jump as very likely to be taken.  */\n-  add_int_reg_note (jump_insn, REG_BR_PROB,\n-\t\t    REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100);\n+  add_reg_br_prob_note (jump_insn, profile_probability::very_likely ());\n \n   if (split_stack_fn == NULL_RTX)\n     {\n@@ -19128,7 +19127,8 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    x = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n \t    if (x)\n \t      {\n-\t\tint pred_val = XINT (x, 0);\n+\t\tint pred_val = profile_probability::from_reg_br_prob_note\n+\t\t\t\t (XINT (x, 0)).to_reg_br_prob_base ();\n \n \t\tif (pred_val < REG_BR_PROB_BASE * 45 / 100\n \t\t    || pred_val > REG_BR_PROB_BASE * 55 / 100)\n@@ -23865,8 +23865,8 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n \t\t      (pc_rtx,\n \t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n \t\t\t\t\t     condition, target1, target2)));\n-  if (split_branch_probability >= 0)\n-    add_int_reg_note (i, REG_BR_PROB, split_branch_probability);\n+  if (split_branch_probability.initialized_p ())\n+    add_reg_br_prob_note (i, split_branch_probability);\n }\n \n void\n@@ -26911,7 +26911,7 @@ predict_jump (int prob)\n {\n   rtx_insn *insn = get_last_insn ();\n   gcc_assert (JUMP_P (insn));\n-  add_int_reg_note (insn, REG_BR_PROB, prob);\n+  add_reg_br_prob_note (insn, profile_probability::from_reg_br_prob_base (prob));\n }\n \n /* Helper function for the string operations below.  Dest VARIABLE whether"}, {"sha": "c8e4c74bbdbe5cff7c2c0863a85b12a2290a2ca9", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -5502,7 +5502,8 @@ ia64_print_operand (FILE * file, rtx x, int code)\n \tx = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n \tif (x)\n \t  {\n-\t    int pred_val = XINT (x, 0);\n+\t    int pred_val = profile_probability::from_reg_br_prob_note\n+\t\t\t\t (XINT (x, 0)).to_reg_br_prob_base ();\n \n \t    /* Guess top and bottom 10% statically predicted.  */\n \t    if (pred_val < REG_BR_PROB_BASE / 50"}, {"sha": "9849c19e0766b26e541093e766240d7ee5bec090", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1536,7 +1536,8 @@ mmix_print_operand (FILE *stream, rtx x, int code)\n       if (TARGET_BRANCH_PREDICT)\n \t{\n \t  x = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n-\t  if (x && XINT (x, 0) > REG_BR_PROB_BASE / 2)\n+\t  if (x && profile_probability::from_reg_br_prob_note (XINT (x, 0))\n+\t      > profile_probability::even ())\n \t    putc ('P', stream);\n \t}\n       return;"}, {"sha": "b94afd5ca2e5e46a3565d4fe1bd20d80eb8b26e8", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -25333,7 +25333,8 @@ output_cbranch (rtx op, const char *label, int reversed, rtx_insn *insn)\n   if (note != NULL_RTX)\n     {\n       /* PROB is the difference from 50%.  */\n-      int prob = XINT (note, 0) - REG_BR_PROB_BASE / 2;\n+      int prob = profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t\t   .to_reg_br_prob_base () - REG_BR_PROB_BASE / 2;\n \n       /* Only hint for highly probable/improbable branches on newer cpus when\n \t we have real profile data, as static prediction overrides processor\n@@ -26123,10 +26124,9 @@ rs6000_split_signbit (rtx dest, rtx src)\n static void\n emit_unlikely_jump (rtx cond, rtx label)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n   rtx x = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, label, pc_rtx);\n   rtx_insn *insn = emit_jump_insn (gen_rtx_SET (pc_rtx, x));\n-  add_int_reg_note (insn, REG_BR_PROB, very_unlikely);\n+  add_reg_br_prob_note (insn, profile_probability::very_unlikely ());\n }\n \n /* A subroutine of the atomic operation splitters.  Emit a load-locked\n@@ -32192,8 +32192,7 @@ rs6000_expand_split_stack_prologue (void)\n   insn = emit_jump_insn (gen_rtx_SET (pc_rtx, jump));\n   JUMP_LABEL (insn) = ok_label;\n   /* Mark the jump as very likely to be taken.  */\n-  add_int_reg_note (insn, REG_BR_PROB,\n-\t\t    REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100);\n+  add_reg_br_prob_note (insn, profile_probability::very_likely ());\n \n   lr = gen_rtx_REG (Pmode, LR_REGNO);\n   insn = emit_move_insn (r0, lr);"}, {"sha": "e49a09125dfc1a8a21c8d7141cc509b962dafb99", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -22759,7 +22759,8 @@ output_cbranch (rtx op, const char *label, int reversed, rtx_insn *insn)\n   if (note != NULL_RTX)\n     {\n       /* PROB is the difference from 50%.  */\n-      int prob = XINT (note, 0) - REG_BR_PROB_BASE / 2;\n+      int prob = profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t\t   .to_reg_br_prob_base () - REG_BR_PROB_BASE / 2;\n \n       /* Only hint for highly probable/improbable branches on newer cpus when\n \t we have real profile data, as static prediction overrides processor\n@@ -23528,10 +23529,9 @@ rs6000_split_signbit (rtx dest, rtx src)\n static void\n emit_unlikely_jump (rtx cond, rtx label)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n   rtx x = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, label, pc_rtx);\n   rtx_insn *insn = emit_jump_insn (gen_rtx_SET (pc_rtx, x));\n-  add_int_reg_note (insn, REG_BR_PROB, very_unlikely);\n+  add_reg_br_prob_note (insn, profile_probability::very_unlikely ());\n }\n \n /* A subroutine of the atomic operation splitters.  Emit a load-locked\n@@ -29284,8 +29284,7 @@ rs6000_expand_split_stack_prologue (void)\n   insn = emit_jump_insn (gen_rtx_SET (pc_rtx, jump));\n   JUMP_LABEL (insn) = ok_label;\n   /* Mark the jump as very likely to be taken.  */\n-  add_int_reg_note (insn, REG_BR_PROB,\n-\t\t    REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100);\n+  add_reg_br_prob_note (insn, profile_probability::very_likely ());\n \n   lr = gen_rtx_REG (Pmode, LR_REGNO);\n   insn = emit_move_insn (r0, lr);"}, {"sha": "bbae89be29d51b21645ed317bccccc8bb7b07add", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -5720,8 +5720,6 @@ s390_emit_ccraw_jump (HOST_WIDE_INT mask, enum rtx_code comparison, rtx label)\n void\n s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n-  int very_likely = REG_BR_PROB_BASE - 1;\n   rtx highest_index_to_load_reg = gen_reg_rtx (Pmode);\n   rtx str_reg = gen_reg_rtx (V16QImode);\n   rtx str_addr_base_reg = gen_reg_rtx (Pmode);\n@@ -5792,7 +5790,8 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n \t\t\t\t  GEN_INT (VSTRING_FLAG_ZS | VSTRING_FLAG_CS)));\n \n   add_int_reg_note (s390_emit_ccraw_jump (8, NE, loop_start_label),\n-\t\t    REG_BR_PROB, very_likely);\n+\t\t    REG_BR_PROB,\n+\t\t    profile_probability::very_likely ().to_reg_br_prob_note ());\n   emit_insn (gen_vec_extractv16qi (len, result_reg, GEN_INT (7)));\n \n   /* If the string pointer wasn't aligned we have loaded less then 16\n@@ -5812,8 +5811,8 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n     emit_insn (gen_movsicc (str_idx_reg, cond,\n \t\t\t    highest_index_to_load_reg, str_idx_reg));\n \n-  add_int_reg_note (s390_emit_jump (is_aligned_label, cond), REG_BR_PROB,\n-\t\t    very_unlikely);\n+  add_reg_br_prob_note (s390_emit_jump (is_aligned_label, cond),\n+\t\t        profile_probability::very_unlikely ());\n \n   expand_binop (Pmode, add_optab, str_idx_reg,\n \t\tGEN_INT (-16), str_idx_reg, 1, OPTAB_DIRECT);\n@@ -5829,7 +5828,6 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n void\n s390_expand_vec_movstr (rtx result, rtx dst, rtx src)\n {\n-  int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n   rtx temp = gen_reg_rtx (Pmode);\n   rtx src_addr = XEXP (src, 0);\n   rtx dst_addr = XEXP (dst, 0);\n@@ -5906,7 +5904,8 @@ s390_expand_vec_movstr (rtx result, rtx dst, rtx src)\n   emit_insn (gen_vec_vfenesv16qi (vpos, vsrc, vsrc,\n \t\t\t\t  GEN_INT (VSTRING_FLAG_ZS | VSTRING_FLAG_CS)));\n   add_int_reg_note (s390_emit_ccraw_jump (8, EQ, done_label),\n-\t\t    REG_BR_PROB, very_unlikely);\n+\t\t    REG_BR_PROB, profile_probability::very_unlikely ()\n+\t\t\t\t  .to_reg_br_prob_note ());\n \n   emit_move_insn (gen_rtx_MEM (V16QImode,\n \t\t\t       gen_rtx_PLUS (Pmode, dst_addr_reg, offset)),\n@@ -6929,7 +6928,6 @@ s390_expand_cs_tdsi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n \n   if (do_const_opt)\n     {\n-      const int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n       rtx cc = gen_rtx_REG (CCZmode, CC_REGNUM);\n \n       skip_cs_label = gen_label_rtx ();\n@@ -6950,7 +6948,8 @@ s390_expand_cs_tdsi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n \t  emit_insn (gen_rtx_SET (cc, gen_rtx_COMPARE (CCZmode, output, cmp)));\n \t}\n       s390_emit_jump (skip_cs_label, gen_rtx_NE (VOIDmode, cc, const0_rtx));\n-      add_int_reg_note (get_last_insn (), REG_BR_PROB, very_unlikely);\n+      add_reg_br_prob_note (get_last_insn (), \n+\t\t            profile_probability::very_unlikely ());\n       /* If the jump is not taken, OUTPUT is the expected value.  */\n       cmp = output;\n       /* Reload newval to a register manually, *after* the compare and jump\n@@ -11678,7 +11677,8 @@ s390_expand_split_stack_prologue (void)\n       LABEL_NUSES (call_done)++;\n \n       /* Mark the jump as very unlikely to be taken.  */\n-      add_int_reg_note (insn, REG_BR_PROB, REG_BR_PROB_BASE / 100);\n+      add_reg_br_prob_note (insn, \n+\t\t            profile_probability::very_unlikely ());\n \n       if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n \t{"}, {"sha": "305ab2cd19bc695741fadfcfc235f6d0f7f6543c", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -68,7 +68,7 @@ extern bool sh_expand_strlen  (rtx *);\n extern void sh_expand_setmem (rtx *);\n extern enum rtx_code prepare_cbranch_operands (rtx *, machine_mode mode,\n \t\t\t\t\t       enum rtx_code comparison);\n-extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);\n+extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison);\n extern bool expand_cbranchdi4 (rtx *operands, enum rtx_code comparison);\n extern void sh_emit_scc_to_t (enum rtx_code, rtx, rtx);\n extern void sh_emit_compare_and_branch (rtx *, machine_mode);"}, {"sha": "6f01dcb700c727887610de78134fc185b94c598a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1139,7 +1139,9 @@ sh_print_operand (FILE *stream, rtx x, int code)\n       {\n \trtx note = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n \n-\tif (note && XINT (note, 0) * 2 < REG_BR_PROB_BASE)\n+\tif (note\n+\t    && profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t       < profile_probability::even ())\n \t  fputs (\"/u\", stream);\n \tbreak;\n       }\n@@ -1999,8 +2001,9 @@ prepare_cbranch_operands (rtx *operands, machine_mode mode,\n   return comparison;\n }\n \n-void\n-expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n+static void\n+expand_cbranchsi4 (rtx *operands, enum rtx_code comparison,\n+\t\t   profile_probability probability)\n {\n   rtx (*branch_expander) (rtx) = gen_branch_true;\n   comparison = prepare_cbranch_operands (operands, SImode, comparison);\n@@ -2015,8 +2018,15 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n \t\t\t  gen_rtx_fmt_ee (comparison, SImode,\n \t\t\t\t\t  operands[1], operands[2])));\n   rtx_insn *jump = emit_jump_insn (branch_expander (operands[3]));\n-  if (probability >= 0)\n-    add_int_reg_note (jump, REG_BR_PROB, probability);\n+  if (probability.initialized_p ())\n+    add_reg_br_prob_note (jump, probability);\n+}\n+\n+void\n+expand_cbranchsi4 (rtx *operands, enum rtx_code comparison)\n+{\n+  expand_cbranchsi4 (operands, comparison,\n+\t\t     profile_probability::uninitialized ());\n }\n \n /* ??? How should we distribute probabilities when more than one branch\n@@ -2043,8 +2053,10 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   rtx_code_label *skip_label = NULL;\n   rtx op1h, op1l, op2h, op2l;\n   int num_branches;\n-  int prob, rev_prob;\n-  int msw_taken_prob = -1, msw_skip_prob = -1, lsw_taken_prob = -1;\n+  profile_probability prob, rev_prob;\n+  profile_probability msw_taken_prob = profile_probability::uninitialized (),\n+\t\t      msw_skip_prob = profile_probability::uninitialized (),\n+\t\t      lsw_taken_prob = profile_probability::uninitialized ();\n \n   comparison = prepare_cbranch_operands (operands, DImode, comparison);\n   op1h = gen_highpart_mode (SImode, DImode, operands[1]);\n@@ -2053,34 +2065,28 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   op2l = gen_lowpart (SImode, operands[2]);\n   msw_taken = msw_skip = lsw_taken = LAST_AND_UNUSED_RTX_CODE;\n   prob = split_branch_probability;\n-  rev_prob = REG_BR_PROB_BASE - prob;\n+  rev_prob = prob.invert ();\n   switch (comparison)\n     {\n     case EQ:\n       msw_skip = NE;\n       lsw_taken = EQ;\n-      if (prob >= 0)\n+      if (prob.initialized_p ())\n \t{\n-\t  // If we had more precision, we'd use rev_prob - (rev_prob >> 32) .\n+\t  /* FIXME: This is not optimal.  We do not really know the probablity\n+\t     that values differ by MCW only, but we should probably distribute\n+\t     probabilities more evenly.  */\n \t  msw_skip_prob = rev_prob;\n-\t  if (REG_BR_PROB_BASE <= 65535)\n-\t    lsw_taken_prob = prob ? REG_BR_PROB_BASE : 0;\n-\t  else\n-\t    {\n-\t      lsw_taken_prob\n-\t\t= (prob\n-\t\t   ? (REG_BR_PROB_BASE\n-\t\t      - ((gcov_type) REG_BR_PROB_BASE * rev_prob\n-\t\t\t / ((gcov_type) prob << 32)))\n-\t\t   : 0);\n-\t    }\n+\t  lsw_taken_prob = prob > profile_probability::never ()\n+\t\t\t   ? profile_probability::guessed_always ()\n+\t\t\t   : profile_probability::guessed_never ();\n \t}\n       break;\n     case NE:\n       msw_taken = NE;\n       msw_taken_prob = prob;\n       lsw_taken = NE;\n-      lsw_taken_prob = 0;\n+      lsw_taken_prob = profile_probability::guessed_never ();\n       break;\n     case GTU: case GT:\n       msw_taken = comparison;\n@@ -2133,18 +2139,20 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   if (comparison != EQ && comparison != NE && num_branches > 1)\n     {\n       if (!CONSTANT_P (operands[2])\n-\t  && prob >= (int) (REG_BR_PROB_BASE * 3 / 8U)\n-\t  && prob <= (int) (REG_BR_PROB_BASE * 5 / 8U))\n-\t{\n-\t  msw_taken_prob = prob / 2U;\n-\t  msw_skip_prob\n-\t    = REG_BR_PROB_BASE * rev_prob / (REG_BR_PROB_BASE + rev_prob);\n+\t  && prob.initialized_p ()\n+\t  && prob.to_reg_br_prob_base () >= (int) (REG_BR_PROB_BASE * 3 / 8U)\n+\t  && prob.to_reg_br_prob_base () <= (int) (REG_BR_PROB_BASE * 5 / 8U))\n+\t{\n+\t  msw_taken_prob = prob.apply_scale (1, 2);\n+\t  msw_skip_prob = rev_prob.apply_scale (REG_BR_PROB_BASE,\n+\t\t\t\t\t\trev_prob.to_reg_br_prob_base ()\n+\t\t\t\t\t\t+ REG_BR_PROB_BASE);\n \t  lsw_taken_prob = prob;\n \t}\n       else\n \t{\n \t  msw_taken_prob = prob;\n-\t  msw_skip_prob = REG_BR_PROB_BASE;\n+\t  msw_skip_prob = profile_probability::guessed_always ();\n \t  /* ??? If we have a constant op2h, should we use that when\n \t     calculating lsw_taken_prob?  */\n \t  lsw_taken_prob = prob;"}, {"sha": "733c777ef56a86d47e7651155640ad0b0430fe0a", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1188,7 +1188,7 @@\n    (clobber (reg:SI T_REG))]\n   \"can_create_pseudo_p ()\"\n {\n-  expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE, -1);\n+  expand_cbranchsi4 (operands, LAST_AND_UNUSED_RTX_CODE);\n   DONE;\n })\n "}, {"sha": "f4f318a81a1233808381908edd19594315c8a6c1", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -7999,7 +7999,8 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n       if (*labelno && insn && (note = find_reg_note (insn, REG_BR_PROB, NULL_RTX)))\n \t{\n \t  strcpy (p,\n-\t\t  ((XINT (note, 0) >= REG_BR_PROB_BASE / 2) ^ far)\n+\t\t  ((profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t\t   >= profile_probability::even ()) ^ far)\n \t\t  ? \",pt\" : \",pn\");\n \t  p += 3;\n \t  spaces -= 3;\n@@ -8462,7 +8463,8 @@ output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n   if (insn && (note = find_reg_note (insn, REG_BR_PROB, NULL_RTX)))\n     {\n       strcpy (p,\n-\t      ((XINT (note, 0) >= REG_BR_PROB_BASE / 2) ^ far)\n+\t      ((profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t       >= profile_probability::even ()) ^ far)\n \t      ? \",pt\" : \",pn\");\n       p += 3;\n     }"}, {"sha": "efee614b103974b615226d59bd8567f0433289ca", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -2195,7 +2195,8 @@ get_branch_target (rtx_insn *branch)\n \t    {\n \t      /* If the more probable case is not a fall through, then\n \t         try a branch hint.  */\n-\t      int prob = XINT (note, 0);\n+\t      int prob = profile_probability::from_reg_br_prob_note\n+\t\t\t    (XINT (note, 0)).to_reg_br_prob_base ();\n \t      if (prob > (REG_BR_PROB_BASE * 6 / 10)\n \t\t  && GET_CODE (XEXP (src, 1)) != PC)\n \t\tlab = XEXP (src, 1);\n@@ -4335,8 +4336,7 @@ ea_load_store_inline (rtx mem, bool is_store, rtx ea_addr, rtx data_addr)\n \t\t\t\t      gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n \t\t\t\t\t\t\t    hit_ref, pc_rtx)));\n   /* Say that this branch is very likely to happen.  */\n-  v = REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100 - 1;\n-  add_int_reg_note (insn, REG_BR_PROB, v);\n+  add_reg_br_prob_note (insn, profile_probability::very_likely ());\n \n   ea_load_store (mem, is_store, ea_addr, data_addr);\n   cont_label = gen_label_rtx ();"}, {"sha": "dafb49daf1fd7fd92dd163b45e7a1bdca915b6b4", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -2619,9 +2619,8 @@ cbranch_predicted_p (rtx_insn *insn)\n \n   if (x)\n     {\n-      int pred_val = XINT (x, 0);\n-\n-      return pred_val >= REG_BR_PROB_BASE / 2;\n+      return profile_probability::from_reg_br_prob_note (XINT (x, 0))\n+\t     >= profile_probability::even ();\n     }\n \n   return false;"}, {"sha": "80475b959eee5de1970d17c100030de674c36a3c", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -2419,9 +2419,8 @@ cbranch_predicted_p (rtx_insn *insn)\n \n   if (x)\n     {\n-      int pred_val = XINT (x, 0);\n-\n-      return pred_val >= REG_BR_PROB_BASE / 2;\n+      return profile_probability::from_reg_br_prob_note (XINT (x, 0))\n+\t     >= profile_probability::even ();\n     }\n \n   return false;"}, {"sha": "6e2799a1ce95d96d34ce9741e1ef34969ee4b3ea", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -4022,9 +4022,10 @@ are stored in the @code{REG_NOTES} field of an insn.\n @item REG_BR_PROB\n This is used to specify the ratio of branches to non-branches of a\n branch insn according to the profile data.  The note is represented\n-as an @code{int_list} expression whose integer value is between 0 and\n-REG_BR_PROB_BASE.  Larger values indicate a higher probability that\n-the branch will be taken.\n+as an @code{int_list} expression whose integer value is an encoding\n+of @code{profile_probability} type.  @code{profile_probability} provide\n+member function @code{from_reg_br_prob_note} and @code{to_reg_br_prob_note}\n+to extract and store the probability into the RTL encoding.\n \n @findex REG_BR_PRED\n @item REG_BR_PRED"}, {"sha": "2bc5d5669330de0d99be2b83f577f94334e22791", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"stor-layout.h\"\n #include \"opts.h\"\n+#include \"predict.h\"\n \n struct target_rtl default_target_rtl;\n #if SWITCHABLE_TARGET\n@@ -190,9 +191,8 @@ static reg_attrs *get_reg_attrs (tree, int);\n static rtx gen_const_vector (machine_mode, int);\n static void copy_rtx_if_shared_1 (rtx *orig);\n \n-/* Probability of the conditional branch currently proceeded by try_split.\n-   Set to -1 otherwise.  */\n-int split_branch_probability = -1;\n+/* Probability of the conditional branch currently proceeded by try_split.  */\n+profile_probability split_branch_probability;\n \f\n /* Returns a hash code for X (which is a really a CONST_INT).  */\n \n@@ -3662,7 +3662,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n   rtx_insn *before, *after;\n   rtx note;\n   rtx_insn *seq, *tem;\n-  int probability;\n+  profile_probability probability;\n   rtx_insn *insn_last, *insn;\n   int njumps = 0;\n   rtx_insn *call_insn = NULL;\n@@ -3673,12 +3673,16 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \n   if (any_condjump_p (trial)\n       && (note = find_reg_note (trial, REG_BR_PROB, 0)))\n-    split_branch_probability = XINT (note, 0);\n+    split_branch_probability\n+      = profile_probability::from_reg_br_prob_note (XINT (note, 0));\n+  else\n+    split_branch_probability = profile_probability::uninitialized ();\n+\n   probability = split_branch_probability;\n \n   seq = split_insns (pat, trial);\n \n-  split_branch_probability = -1;\n+  split_branch_probability = profile_probability::uninitialized ();\n \n   if (!seq)\n     return trial;\n@@ -3709,7 +3713,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \t    CROSSING_JUMP_P (insn) = CROSSING_JUMP_P (trial);\n \t  mark_jump_label (PATTERN (insn), insn, 0);\n \t  njumps++;\n-\t  if (probability != -1\n+\t  if (probability.initialized_p ()\n \t      && any_condjump_p (insn)\n \t      && !find_reg_note (insn, REG_BR_PROB, 0))\n \t    {\n@@ -3718,7 +3722,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \t\t is responsible for this step using\n \t\t split_branch_probability variable.  */\n \t      gcc_assert (njumps == 1);\n-\t      add_int_reg_note (insn, REG_BR_PROB, probability);\n+\t      add_reg_br_prob_note (insn, probability);\n \t    }\n \t}\n     }"}, {"sha": "46a13c41c09d930783b0c27938318397179a9e45", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -84,8 +84,6 @@ static rtx_insn *last_active_insn (basic_block, int);\n static rtx_insn *find_active_insn_before (basic_block, rtx_insn *);\n static rtx_insn *find_active_insn_after (basic_block, rtx_insn *);\n static basic_block block_fallthru (basic_block);\n-static int cond_exec_process_insns (ce_if_block *, rtx_insn *, rtx, rtx, int,\n-\t\t\t\t    int);\n static rtx cond_exec_get_condition (rtx_insn *);\n static rtx noce_get_condition (rtx_insn *, rtx_insn **, bool);\n static int noce_operand_ok (const_rtx);\n@@ -335,7 +333,8 @@ cond_exec_process_insns (ce_if_block *ce_info ATTRIBUTE_UNUSED,\n \t\t\t /* if block information */rtx_insn *start,\n \t\t\t /* first insn to look at */rtx end,\n \t\t\t /* last insn to look at */rtx test,\n-\t\t\t /* conditional execution test */int prob_val,\n+\t\t\t /* conditional execution test */profile_probability\n+\t\t\t\t\t\t\t    prob_val,\n \t\t\t /* probability of branch taken. */int mod_ok)\n {\n   int must_be_last = FALSE;\n@@ -410,10 +409,11 @@ cond_exec_process_insns (ce_if_block *ce_info ATTRIBUTE_UNUSED,\n \n       validate_change (insn, &PATTERN (insn), pattern, 1);\n \n-      if (CALL_P (insn) && prob_val >= 0)\n+      if (CALL_P (insn) && prob_val.initialized_p ())\n \tvalidate_change (insn, &REG_NOTES (insn),\n \t\t\t gen_rtx_INT_LIST ((machine_mode) REG_BR_PROB,\n-\t\t\t\t\t   prob_val, REG_NOTES (insn)), 1);\n+\t\t\t\t\t   prob_val.to_reg_br_prob_note (),\n+\t\t\t\t\t   REG_NOTES (insn)), 1);\n \n     insn_done:\n       if (insn == end)\n@@ -472,8 +472,8 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n   int then_mod_ok;\t\t/* whether conditional mods are ok in THEN */\n   rtx true_expr;\t\t/* test for else block insns */\n   rtx false_expr;\t\t/* test for then block insns */\n-  int true_prob_val;\t\t/* probability of else block */\n-  int false_prob_val;\t\t/* probability of then block */\n+  profile_probability true_prob_val;/* probability of else block */\n+  profile_probability false_prob_val;/* probability of then block */\n   rtx_insn *then_last_head = NULL;\t/* Last match at the head of THEN */\n   rtx_insn *else_last_head = NULL;\t/* Last match at the head of ELSE */\n   rtx_insn *then_first_tail = NULL;\t/* First match at the tail of THEN */\n@@ -618,13 +618,13 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n   note = find_reg_note (BB_END (test_bb), REG_BR_PROB, NULL_RTX);\n   if (note)\n     {\n-      true_prob_val = XINT (note, 0);\n-      false_prob_val = REG_BR_PROB_BASE - true_prob_val;\n+      true_prob_val = profile_probability::from_reg_br_prob_note (XINT (note, 0));\n+      false_prob_val = true_prob_val.invert ();\n     }\n   else\n     {\n-      true_prob_val = -1;\n-      false_prob_val = -1;\n+      true_prob_val = profile_probability::uninitialized ();\n+      false_prob_val = profile_probability::uninitialized ();\n     }\n \n   /* If we have && or || tests, do them here.  These tests are in the adjacent\n@@ -5121,7 +5121,9 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \treturn FALSE;\n \n       rtx note = find_reg_note (jump, REG_BR_PROB, NULL_RTX);\n-      int prob_val = (note ? XINT (note, 0) : -1);\n+      profile_probability prob_val\n+\t  = (note ? profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t     : profile_probability::uninitialized ());\n \n       if (reversep)\n \t{\n@@ -5130,8 +5132,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t    return FALSE;\n \t  cond = gen_rtx_fmt_ee (rev, GET_MODE (cond), XEXP (cond, 0),\n \t\t\t         XEXP (cond, 1));\n-\t  if (prob_val >= 0)\n-\t    prob_val = REG_BR_PROB_BASE - prob_val;\n+\t  prob_val = prob_val.invert ();\n \t}\n \n       if (cond_exec_process_insns (NULL, head, end, cond, prob_val, 0)"}, {"sha": "1c9d1ea2c84c2278bacc27393cf44be1d1e573cc", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -741,7 +741,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t  && JUMP_P (last)\n \t\t  && any_condjump_p (last)\n \t\t  && !find_reg_note (last, REG_BR_PROB, 0))\n-\t\tadd_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t\tadd_reg_br_prob_note (last,\n+\t\t\t\t      profile_probability::very_unlikely ());\n \t      emit_jump (done_label);\n \t      goto do_error_label;\n \t    }\n@@ -961,7 +962,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t&& JUMP_P (last)\n \t\t&& any_condjump_p (last)\n \t\t&& !find_reg_note (last, REG_BR_PROB, 0))\n-\t      add_int_reg_note (last, REG_BR_PROB, PROB_UNLIKELY);\n+\t      add_reg_br_prob_note (last, \n+\t\t\t\t    profile_probability::very_unlikely ());\n \t    emit_jump (done_label);\n \t    goto do_error_label;\n \t  }\n@@ -1110,7 +1112,8 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n \t      && JUMP_P (last)\n \t      && any_condjump_p (last)\n \t      && !find_reg_note (last, REG_BR_PROB, 0))\n-\t    add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t    add_reg_br_prob_note (last, \n+\t\t\t\t  profile_probability::very_unlikely ());\n \t  emit_jump (done_label);\n         }\n       else\n@@ -1431,7 +1434,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      && JUMP_P (last)\n \t      && any_condjump_p (last)\n \t      && !find_reg_note (last, REG_BR_PROB, 0))\n-\t    add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t    add_reg_br_prob_note (last, \n+\t\t\t\t  profile_probability::very_unlikely ());\n \t  emit_jump (done_label);\n         }\n       else"}, {"sha": "49861b8e3625a36cc318778fe23cff2598d58ce6", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -419,7 +419,6 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   bool increment_count;\n   basic_block loop_end = desc->out_edge->src;\n   machine_mode mode;\n-  rtx true_prob_val;\n   widest_int iterations;\n \n   jump_insn = BB_END (loop_end);\n@@ -434,10 +433,6 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       fputs (\" iterations).\\n\", dump_file);\n     }\n \n-  /* Get the probability of the original branch. If it exists we would\n-     need to update REG_BR_PROB of the new jump_insn.  */\n-  true_prob_val = find_reg_note (jump_insn, REG_BR_PROB, NULL_RTX);\n-\n   /* Discard original jump to continue loop.  The original compare\n      result may still be live, so it cannot be discarded explicitly.  */\n   delete_insn (jump_insn);\n@@ -580,12 +575,8 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n     add_reg_note (jump_insn, REG_NONNEG, NULL_RTX);\n \n   /* Update the REG_BR_PROB note.  */\n-  if (true_prob_val && desc->in_edge->probability.initialized_p ())\n-    {\n-      /* Seems safer to use the branch probability.  */\n-      add_int_reg_note (jump_insn, REG_BR_PROB,\n-\t\t\tdesc->in_edge->probability.to_reg_br_prob_base ());\n-    }\n+  if (desc->in_edge->probability.initialized_p ())\n+    add_reg_br_prob_note (jump_insn, desc->in_edge->probability);\n }\n \n /* Called through note_stores.  */"}, {"sha": "84145bb4a4f0b31e10c311c2d71f68e3f80f45f6", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -816,7 +816,7 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp,\n       LABEL_NUSES (label)++;\n     }\n   if (prob.initialized_p ())\n-    add_int_reg_note (jump, REG_BR_PROB, prob.to_reg_br_prob_base ());\n+    add_reg_br_prob_note (jump, prob);\n \n   seq = get_insns ();\n   end_sequence ();"}, {"sha": "39051326c7a13e0e31a21e581ac2e74571a39077", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -4003,7 +4003,7 @@ emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label,\n       && JUMP_P (insn)\n       && any_condjump_p (insn)\n       && !find_reg_note (insn, REG_BR_PROB, 0))\n-    add_int_reg_note (insn, REG_BR_PROB, prob.to_reg_br_prob_base ());\n+    add_reg_br_prob_note (insn, prob);\n }\n \n /* Generate code to compare X with Y so that the condition codes are"}, {"sha": "310d9b0acedd88a522e4a01ac7bfbcef74d031e9", "filename": "gcc/predict.c", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -513,43 +513,20 @@ edge_predicted_by_p (edge e, enum br_predictor predictor, bool taken)\n   return false;\n }\n \n-/* Return true when the probability of edge is reliable.\n-\n-   The profile guessing code is good at predicting branch outcome (ie.\n-   taken/not taken), that is predicted right slightly over 75% of time.\n-   It is however notoriously poor on predicting the probability itself.\n-   In general the profile appear a lot flatter (with probabilities closer\n-   to 50%) than the reality so it is bad idea to use it to drive optimization\n-   such as those disabling dynamic branch prediction for well predictable\n-   branches.\n-\n-   There are two exceptions - edges leading to noreturn edges and edges\n-   predicted by number of iterations heuristics are predicted well.  This macro\n-   should be able to distinguish those, but at the moment it simply check for\n-   noreturn heuristic that is only one giving probability over 99% or bellow\n-   1%.  In future we might want to propagate reliability information across the\n-   CFG if we find this information useful on multiple places.   */\n-static bool\n-probability_reliable_p (int prob)\n-{\n-  return (profile_status_for_fn (cfun) == PROFILE_READ\n-\t  || (profile_status_for_fn (cfun) == PROFILE_GUESSED\n-\t      && (prob <= HITRATE (1) || prob >= HITRATE (99))));\n-}\n-\n /* Same predicate as above, working on edges.  */\n bool\n edge_probability_reliable_p (const_edge e)\n {\n-  return e->probability.reliable_p ();\n+  return e->probability.probably_reliable_p ();\n }\n \n /* Same predicate as edge_probability_reliable_p, working on notes.  */\n bool\n br_prob_note_reliable_p (const_rtx note)\n {\n   gcc_assert (REG_NOTE_KIND (note) == REG_BR_PROB);\n-  return probability_reliable_p (XINT (note, 0));\n+  return profile_probability::from_reg_br_prob_note\n+\t\t (XINT (note, 0)).probably_reliable_p ();\n }\n \n static void\n@@ -723,7 +700,8 @@ invert_br_probabilities (rtx insn)\n \n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_BR_PROB)\n-      XINT (note, 0) = REG_BR_PROB_BASE - XINT (note, 0);\n+      XINT (note, 0) = profile_probability::from_reg_br_prob_note\n+\t\t\t (XINT (note, 0)).invert ().to_reg_br_prob_note ();\n     else if (REG_NOTE_KIND (note) == REG_BR_PRED)\n       XEXP (XEXP (note, 0), 1)\n \t= GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (XEXP (note, 0), 1)));\n@@ -870,6 +848,15 @@ set_even_probabilities (basic_block bb,\n       e->probability = profile_probability::never ();\n }\n \n+/* Add REG_BR_PROB note to JUMP with PROB.  */\n+\n+void\n+add_reg_br_prob_note (rtx_insn *jump, profile_probability prob)\n+{\n+  gcc_checking_assert (JUMP_P (jump) && !find_reg_note (jump, REG_BR_PROB, 0));\n+  add_int_reg_note (jump, REG_BR_PROB, prob.to_reg_br_prob_note ());\n+}\n+\n /* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB\n    note if not already present.  Remove now useless REG_BR_PRED notes.  */\n \n@@ -968,26 +955,26 @@ combine_predictions_for_insn (rtx_insn *insn, basic_block bb)\n \n   if (!prob_note)\n     {\n-      add_int_reg_note (insn, REG_BR_PROB, combined_probability);\n+      profile_probability p\n+\t = profile_probability::from_reg_br_prob_base (combined_probability);\n+      add_reg_br_prob_note (insn, p);\n \n       /* Save the prediction into CFG in case we are seeing non-degenerated\n \t conditional jump.  */\n       if (!single_succ_p (bb))\n \t{\n-\t  BRANCH_EDGE (bb)->probability\n-\t    = profile_probability::from_reg_br_prob_base (combined_probability);\n+\t  BRANCH_EDGE (bb)->probability = p;\n \t  FALLTHRU_EDGE (bb)->probability\n \t    = BRANCH_EDGE (bb)->probability.invert ();\n \t}\n     }\n   else if (!single_succ_p (bb))\n     {\n-      int prob = XINT (prob_note, 0);\n+      profile_probability prob = profile_probability::from_reg_br_prob_note\n+\t\t\t\t\t(XINT (prob_note, 0));\n \n-      BRANCH_EDGE (bb)->probability\n-\t = profile_probability::from_reg_br_prob_base (prob);\n-      FALLTHRU_EDGE (bb)->probability\n-\t = BRANCH_EDGE (bb)->probability.invert ();\n+      BRANCH_EDGE (bb)->probability = prob;\n+      FALLTHRU_EDGE (bb)->probability = prob.invert ();\n     }\n   else\n     single_succ_edge (bb)->probability = profile_probability::always ();"}, {"sha": "a6cf1ee70e18d6930e36138def7a745e256dd68a", "filename": "gcc/predict.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -47,6 +47,9 @@ enum prediction\n    TAKEN\n };\n \n+/* In emit-rtl.c.  */\n+extern profile_probability split_branch_probability;\n+\n extern gcov_type get_hot_bb_threshold (void);\n extern void set_hot_bb_threshold (gcov_type);\n extern bool maybe_hot_count_p (struct function *, profile_count);\n@@ -96,4 +99,6 @@ extern void rebuild_frequencies (void);\n extern void report_predictor_hitrates (void);\n extern void force_edge_cold (edge, bool);\n \n+extern void add_reg_br_prob_note (rtx_insn *, profile_probability);\n+\n #endif  /* GCC_PREDICT_H */"}, {"sha": "8fd22b8b68abfec72379ac5034edc68abe9b2f98", "filename": "gcc/profile-count.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -190,6 +190,23 @@ class GTY((user)) profile_probability\n       return RDIV (m_val * REG_BR_PROB_BASE, max_probability);\n     }\n \n+  /* Conversion to and from RTL representation of profile probabilities.  */\n+  static profile_probability from_reg_br_prob_note (int v)\n+    {\n+      profile_probability ret;\n+      ret.m_val = ((unsigned int)v) / 4;\n+      ret.m_quality = (enum profile_quality)(v & 3);\n+      return ret;\n+    }\n+  int to_reg_br_prob_note () const\n+    {\n+      gcc_checking_assert (initialized_p ());\n+      int ret = m_val * 4 + m_quality;\n+      gcc_checking_assert (profile_probability::from_reg_br_prob_note (ret)\n+\t\t\t   == *this);\n+      return ret;\n+    }\n+\n   /* Return VAL1/VAL2.  */\n   static profile_probability probability_in_gcov_type\n \t\t\t\t (gcov_type val1, gcov_type val2)"}, {"sha": "943eff41d307b1a5468edf9f8c6623024b55baff", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -99,20 +99,21 @@ REG_NOTE (DEP_OUTPUT)\n REG_NOTE (DEP_ANTI)\n REG_NOTE (DEP_CONTROL)\n \n-/* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs.  It has an\n+/* REG_BR_PROB is attached to JUMP_INSNs.  It has an\n    integer value (in an INT_LIST).  For jumps, it is the probability\n-   that this is a taken branch.  For calls, it is the probability that\n-   this call won't return.  */\n+   that this is a taken branch. The integer represents a value of\n+   profile_probability type. Use to_reg_br_prob_note and from_reg_br_prob_note\n+   to extract the actual value.  */\n REG_NOTE (BR_PROB)\n \n /* Attached to a call insn; indicates that the call is malloc-like and\n    that the pointer returned cannot alias anything else.  */\n REG_NOTE (NOALIAS)\n \n-/* REG_BR_PRED is attached to JUMP_INSNs and CALL_INSNSs.  It contains\n+/* REG_BR_PRED is attached to JUMP_INSNs.  It contains\n    CONCAT of two integer value.  First specifies the branch predictor\n    that added the note, second specifies the predicted hitrate of\n-   branch in the same format as REG_BR_PROB note uses.  */\n+   branch in a fixed point arithmetic based on REG_BR_PROB_BASE.  */\n REG_NOTE (BR_PRED)\n \n /* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex"}, {"sha": "5914af655b6bbbddc98f23f53c0d1e6e496dc2eb", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -840,7 +840,8 @@ mostly_true_jump (rtx jump_insn)\n   rtx note = find_reg_note (jump_insn, REG_BR_PROB, 0);\n   if (note)\n     {\n-      int prob = XINT (note, 0);\n+      int prob = profile_probability::from_reg_br_prob_note (XINT (note, 0))\n+\t\t\t.to_reg_br_prob_base ();\n \n       if (prob >= REG_BR_PROB_BASE * 9 / 10)\n \treturn 2;"}, {"sha": "e63dcf042cb6eae5bf2b07ab2e055951c2be90be", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -2938,7 +2938,6 @@ extern rtx *find_constant_term_loc (rtx *);\n \n /* In emit-rtl.c  */\n extern rtx_insn *try_split (rtx, rtx_insn *, int);\n-extern int split_branch_probability;\n \n /* In insn-recog.c (generated by genrecog).  */\n extern rtx_insn *split_insns (rtx, rtx_insn *);"}, {"sha": "3ede9d83653e2e54ceb89b94cd3fb80d677a4379", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -1,3 +1,7 @@\n+2017-07-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/predict-8.c: Update.\n+\n 2017-07-16  Volker Reichelt  <v.reichelt@netcologne.de>\n \n \t* g++.dg/cpp1z/direct-enum-init1.C: Revert special enum handling."}, {"sha": "e13cc006f3af52a05eef908e1d17b0e8646ef40a", "filename": "gcc/testsuite/gcc.dg/predict-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa396ad6cd48bc44e6754096fe71febc2a77983/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-8.c?ref=5fa396ad6cd48bc44e6754096fe71febc2a77983", "patch": "@@ -8,4 +8,4 @@ int foo(float a, float b) {\n     return 2;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"REG_BR_PROB 100\" 1 \"expand\"} } */\n+/* { dg-final { scan-rtl-dump-times \"REG_BR_PROB 400 \" 1 \"expand\"} } */"}]}