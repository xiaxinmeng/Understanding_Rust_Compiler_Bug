{"sha": "e60d4d7b386c2dcfa183a10af025c7feb5961633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYwZDRkN2IzODZjMmRjZmExODNhMTBhZjAyNWM3ZmViNTk2MTYzMw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-08-30T07:32:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-30T07:32:33Z"}, "message": "dwarf2out.c (mem_loc_descriptor): New argument MODE.\n\n        * dwarf2out.c (mem_loc_descriptor): New argument MODE.  All callers\n        changed.  Handle autoincrement addressing modes.\n\nFrom-SVN: r28981", "tree": {"sha": "66d3156d1e18f4efae593b2d0a96111892a341d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66d3156d1e18f4efae593b2d0a96111892a341d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e60d4d7b386c2dcfa183a10af025c7feb5961633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e60d4d7b386c2dcfa183a10af025c7feb5961633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e60d4d7b386c2dcfa183a10af025c7feb5961633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e60d4d7b386c2dcfa183a10af025c7feb5961633/comments", "author": null, "committer": null, "parents": [{"sha": "f83a09927c55b74be89ec85a0d98b3aab4846812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83a09927c55b74be89ec85a0d98b3aab4846812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83a09927c55b74be89ec85a0d98b3aab4846812"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "f234092ec6e6f48de3e0ec65c232e7faf4a15aa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e60d4d7b386c2dcfa183a10af025c7feb5961633/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e60d4d7b386c2dcfa183a10af025c7feb5961633/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e60d4d7b386c2dcfa183a10af025c7feb5961633", "patch": "@@ -1,5 +1,8 @@\n Mon Aug 30 01:02:09 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* dwarf2out.c (mem_loc_descriptor): New argument MODE.  All callers\n+\tchanged.  Handle autoincrement addressing modes.\n+\n \t* integrate.c (copy_rtx_and_substitute): Handle internal_arg_pointer\n \tjust like we would the virtual incoming args register when\n \tintegrating."}, {"sha": "f656d275b5fcfa3e98f471ea56e6c4502d2a6a33", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e60d4d7b386c2dcfa183a10af025c7feb5961633/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e60d4d7b386c2dcfa183a10af025c7feb5961633/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e60d4d7b386c2dcfa183a10af025c7feb5961633", "patch": "@@ -2573,7 +2573,7 @@ static int type_is_enum\t\t\tPROTO((tree));\n static dw_loc_descr_ref reg_loc_descriptor PROTO((rtx));\n static dw_loc_descr_ref based_loc_descr\tPROTO((unsigned, long));\n static int is_based_loc\t\t\tPROTO((rtx));\n-static dw_loc_descr_ref mem_loc_descriptor PROTO((rtx));\n+static dw_loc_descr_ref mem_loc_descriptor PROTO((rtx, enum machine_mode mode));\n static dw_loc_descr_ref concat_loc_descriptor PROTO((rtx, rtx));\n static dw_loc_descr_ref loc_descriptor\tPROTO((rtx));\n static unsigned ceiling\t\t\tPROTO((unsigned, unsigned));\n@@ -6581,11 +6581,15 @@ is_based_loc (rtl)\n    When creating memory location descriptors, we are effectively transforming\n    the RTL for a memory-resident object into its Dwarf postfix expression\n    equivalent.  This routine recursively descends an RTL tree, turning\n-   it into Dwarf postfix code as it goes.  */\n+   it into Dwarf postfix code as it goes.\n+\n+   MODE is the mode of the memory reference, needed to handle some\n+   autoincrement addressing modes.  */\n \n static dw_loc_descr_ref\n-mem_loc_descriptor (rtl)\n+mem_loc_descriptor (rtl, mode)\n      register rtx rtl;\n+     enum machine_mode mode;\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n   /* Note that for a dynamically sized array, the location we will generate a \n@@ -6595,6 +6599,13 @@ mem_loc_descriptor (rtl)\n \n   switch (GET_CODE (rtl))\n     {\n+    case POST_INC:\n+    case POST_DEC:\n+      /* POST_INC and POST_DEC can be handled just like a SUBREG.  So we\n+\t just fall into the SUBREG code.  */\n+\n+      /* ... fall through ... */\n+\n     case SUBREG:\n       /* The case of a subreg may arise when we have a local (register)\n          variable or a formal (register) parameter which doesn't quite fill\n@@ -6623,7 +6634,7 @@ mem_loc_descriptor (rtl)\n       break;\n \n     case MEM:\n-      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0));\n+      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n       add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n       break;\n \n@@ -6638,23 +6649,36 @@ mem_loc_descriptor (rtl)\n       mem_loc_result->dw_loc_oprnd1.v.val_addr = addr_to_string (rtl);\n       break;\n \n+    case PRE_INC:\n+    case PRE_DEC:\n+      /* Turn these into a PLUS expression and fall into the PLUS code\n+\t below.  */\n+      rtl = gen_rtx_PLUS (word_mode, XEXP (rtl, 0),\n+\t\t\t  GEN_INT (GET_CODE (rtl) == PRE_INC\n+\t\t\t\t   ? GET_MODE_UNIT_SIZE (mode) \n+\t\t\t\t   : - GET_MODE_UNIT_SIZE (mode)));\n+\t\t\t  \n+      /* ... fall through ... */\n+\n     case PLUS:\n       if (is_based_loc (rtl))\n \tmem_loc_result = based_loc_descr (reg_number (XEXP (rtl, 0)),\n \t\t\t\t\t  INTVAL (XEXP (rtl, 1)));\n       else\n \t{\n-\t  add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 0)));\n-\t  add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 1)));\n+\t  add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 0),\n+\t\t\t\t\t\t\t      mode));\n+\t  add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 1),\n+\t\t\t\t\t\t\t      mode));\n \t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_plus, 0, 0));\n \t}\n       break;\n \n     case MULT:\n       /* If a pseudo-reg is optimized away, it is possible for it to\n \t be replaced with a MEM containing a multiply.  */\n-      add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 0)));\n-      add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 1)));\n+      add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 0), mode));\n+      add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 1), mode));\n       add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));\n       break;\n \n@@ -6721,7 +6745,7 @@ loc_descriptor (rtl)\n       break;\n \n     case MEM:\n-      loc_result = mem_loc_descriptor (XEXP (rtl, 0));\n+      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n       break;\n \n     case CONCAT:"}]}