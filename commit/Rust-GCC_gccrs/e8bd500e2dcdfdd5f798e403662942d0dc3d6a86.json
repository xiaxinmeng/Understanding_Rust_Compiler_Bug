{"sha": "e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThiZDUwMGUyZGNkZmRkNWY3OThlNDAzNjYyOTQyZDBkYzNkNmE4Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-12T11:28:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-12T11:28:03Z"}, "message": "[multiple changes]\n\n2011-12-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* mlib-tgt-specific-xi.adb: (Get_Target_Prefix): Simplify code.\n\n2011-12-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb: Adjust dominant marker for branches of CASE\n\tstatements.\n\n2011-12-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* gsocket.h, s-oscons-tmplt.c: Ensure we do not include any system\n\theader file prior to redefining FD_SETSIZE.\n\n2011-12-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): In\n\ta generic context the aspect expressions may not have been\n\tpreanalyzed if there was no previous freeze point, so the\n\texpressions must be preanalyzed now, and there is no conformance\n\tto check for visibility changes.\n\n2011-12-12  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.adb, a-coinve.adb, a-cobove.adb (Iterator): Use\n\tsubtype Index_Type'Base for Index component (Finalize): Remove\n\tunnecessary access check (First, Last): Cursor return value\n\tdepends on iterator index value (Iterate): Use start position as\n\titerator index value (Next, Previous): Forward to corresponding\n\tcursor-based operation.\n\t* a-cborma.adb (Iterate): Properly initialize iterator object (with 0\n\tas node index).\n\nFrom-SVN: r182226", "tree": {"sha": "b15c5e55f467d82c76370ae169645dc4f5e61bba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b15c5e55f467d82c76370ae169645dc4f5e61bba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/comments", "author": null, "committer": null, "parents": [{"sha": "7520518f731935ae46aeb4f1d276585d7aa8e0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7520518f731935ae46aeb4f1d276585d7aa8e0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7520518f731935ae46aeb4f1d276585d7aa8e0ba"}], "stats": {"total": 528, "additions": 405, "deletions": 123}, "files": [{"sha": "84ea178943e5dcb798c3a70863ed764646792340", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -1,3 +1,36 @@\n+2011-12-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* mlib-tgt-specific-xi.adb: (Get_Target_Prefix): Simplify code.\n+\n+2011-12-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb: Adjust dominant marker for branches of CASE\n+\tstatements.\n+\n+2011-12-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gsocket.h, s-oscons-tmplt.c: Ensure we do not include any system\n+\theader file prior to redefining FD_SETSIZE.\n+\n+2011-12-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): In\n+\ta generic context the aspect expressions may not have been\n+\tpreanalyzed if there was no previous freeze point, so the\n+\texpressions must be preanalyzed now, and there is no conformance\n+\tto check for visibility changes.\n+\n+2011-12-12  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-convec.adb, a-coinve.adb, a-cobove.adb (Iterator): Use\n+\tsubtype Index_Type'Base for Index component (Finalize): Remove\n+\tunnecessary access check (First, Last): Cursor return value\n+\tdepends on iterator index value (Iterate): Use start position as\n+\titerator index value (Next, Previous): Forward to corresponding\n+\tcursor-based operation.\n+\t* a-cborma.adb (Iterate): Properly initialize iterator object (with 0\n+\tas node index).\n+\n 2011-12-12  Robert Dewar  <dewar@adacore.com>\n \n \t* par_sco.adb, scos.ads, put_scos.adb, get_scos.adb: Minor reformatting."}, {"sha": "b39d9ae3a55ca76ddf2e6424a24b6a6e027ba1fb", "filename": "gcc/ada/a-cborma.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -935,7 +935,7 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       return It : constant Iterator :=\n                     (Limited_Controlled with\n                        Container => Container'Unrestricted_Access,\n-                       Node      => Container.First)\n+                       Node      => 0)\n       do\n          B := B + 1;\n       end return;"}, {"sha": "ff2dc3729074552462de263477c9946a6e2d4b2f", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 111, "deletions": 30, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -38,7 +38,7 @@ package body Ada.Containers.Bounded_Vectors is\n      Vector_Iterator_Interfaces.Reversible_Iterator with\n    record\n       Container : Vector_Access;\n-      Index     : Index_Type;\n+      Index     : Index_Type'Base;\n    end record;\n \n    overriding procedure Finalize (Object : in out Iterator);\n@@ -667,14 +667,9 @@ package body Ada.Containers.Bounded_Vectors is\n    --------------\n \n    procedure Finalize (Object : in out Iterator) is\n+      B : Natural renames Object.Container.Busy;\n    begin\n-      if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n+      B := B - 1;\n    end Finalize;\n \n    ----------\n@@ -740,10 +735,24 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Is_Empty (Object.Container.all) then\n-         return No_Element;\n+      --  The value of the iterator object's Index component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Index component is No_Index, this means the iterator object\n+      --  was constructed without a start expression, in which case the\n+      --  (forward) iteration starts from the (logical) beginning of the entire\n+      --  sequence of items (corresponding to Container.First, for a forward\n+      --  iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Index component isn't No_Index, the iterator object was\n+      --  constructed with a start expression, that specifies the position from\n+      --  which the (forward) partial iteration begins.\n+\n+      if Object.Index = No_Index then\n+         return First (Object.Container.all);\n       else\n-         return  Cursor'(Object.Container, Index_Type'First);\n+         return Cursor'(Object.Container, Object.Index);\n       end if;\n    end First;\n \n@@ -1648,12 +1657,24 @@ package body Ada.Containers.Bounded_Vectors is\n      (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+      V : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames V.Busy;\n+\n    begin\n+      --  The value of its Index component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Index\n+      --  component is No_Index (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n       return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Container'Unrestricted_Access,\n-                                Index     => Index_Type'First)\n+                    (Limited_Controlled with\n+                       Container => V,\n+                       Index     => No_Index)\n       do\n          B := B + 1;\n       end return;\n@@ -1662,14 +1683,51 @@ package body Ada.Containers.Bounded_Vectors is\n    function Iterate\n      (Container : Vector;\n       Start     : Cursor)\n-      return Vector_Iterator_Interfaces.Reversible_Iterator'class\n+      return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+      V : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames V.Busy;\n+\n    begin\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start.Container = null then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= V then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong vector\";\n+      end if;\n+\n+      if Start.Index > V.Last then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      --  The value of its Index component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Index\n+      --  component is not No_Index (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n       return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Container'Unrestricted_Access,\n-                                Index     => Start.Index)\n+                    (Limited_Controlled with\n+                       Container => V,\n+                       Index     => Start.Index)\n       do\n          B := B + 1;\n       end return;\n@@ -1690,10 +1748,23 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Is_Empty (Object.Container.all) then\n-         return No_Element;\n+      --  The value of the iterator object's Index component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Index component is No_Index, this means the iterator object\n+      --  was constructed without a start expression, in which case the\n+      --  (reverse) iteration starts from the (logical) beginning of the entire\n+      --  sequence (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Index component is not No_Index, the iterator object was\n+      --  constructed with a start expression, that specifies the position from\n+      --  which the (reverse) partial iteration begins.\n+\n+      if Object.Index = No_Index then\n+         return Last (Object.Container.all);\n       else\n-         return Cursor'(Object.Container, Object.Container.Last);\n+         return Cursor'(Object.Container, Object.Index);\n       end if;\n    end Last;\n \n@@ -1811,11 +1882,16 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Index = Object.Container.Last then\n-         return  No_Element;\n-      else\n-         return (Object.Container, Position.Index + 1);\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong vector\";\n       end if;\n+\n+      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n@@ -1884,11 +1960,16 @@ package body Ada.Containers.Bounded_Vectors is\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Index > Index_Type'First then\n-         return (Object.Container, Position.Index - 1);\n-      else\n+      if Position.Container = null then\n          return No_Element;\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong vector\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    -------------------"}, {"sha": "fed45faddda912713e19419d4fc75c9d9cb8d58a", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 111, "deletions": 26, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -44,7 +44,7 @@ package body Ada.Containers.Indefinite_Vectors is\n      Vector_Iterator_Interfaces.Reversible_Iterator with\n    record\n       Container : Vector_Access;\n-      Index     : Index_Type;\n+      Index     : Index_Type'Base;\n    end record;\n \n    overriding procedure Finalize (Object : in out Iterator);\n@@ -1109,14 +1109,9 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Finalize;\n \n    procedure Finalize (Object : in out Iterator) is\n+      B : Natural renames Object.Container.Busy;\n    begin\n-      if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n+      B := B - 1;\n    end Finalize;\n \n    ----------\n@@ -1185,9 +1180,26 @@ package body Ada.Containers.Indefinite_Vectors is\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n-      C : constant Cursor := (Object.Container, Index_Type'First);\n    begin\n-      return C;\n+      --  The value of the iterator object's Index component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Index component is No_Index, this means the iterator object\n+      --  was constructed without a start expression, in which case the\n+      --  (forward) iteration starts from the (logical) beginning of the entire\n+      --  sequence of items (corresponding to Container.First, for a forward\n+      --  iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Index component isn't No_Index, the iterator object was\n+      --  constructed with a start expression, that specifies the position from\n+      --  which the (forward) partial iteration begins.\n+\n+      if Object.Index = No_Index then\n+         return First (Object.Container.all);\n+      else\n+         return Cursor'(Object.Container, Object.Index);\n+      end if;\n    end First;\n \n    -------------------\n@@ -2552,15 +2564,26 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Iterate;\n \n    function Iterate (Container : Vector)\n-      return Vector_Iterator_Interfaces.Reversible_Iterator'class\n+      return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n+      V : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames V.Busy;\n \n    begin\n+      --  The value of its Index component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Index\n+      --  component is No_Index (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n       return It : constant Iterator :=\n                     (Limited_Controlled with\n-                       Container => Container'Unrestricted_Access,\n-                       Index     => Index_Type'First)\n+                       Container => V,\n+                       Index     => No_Index)\n       do\n          B := B + 1;\n       end return;\n@@ -2569,14 +2592,50 @@ package body Ada.Containers.Indefinite_Vectors is\n    function Iterate\n      (Container : Vector;\n       Start     : Cursor)\n-      return Vector_Iterator_Interfaces.Reversible_Iterator'class\n+      return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n+      V : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames V.Busy;\n \n    begin\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start.Container = null then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= V then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong vector\";\n+      end if;\n+\n+      if Start.Index > V.Last then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      --  The value of its Index component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Index\n+      --  component is not No_Index (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n       return It : constant Iterator :=\n                     (Limited_Controlled with\n-                       Container => Container'Unrestricted_Access,\n+                       Container => V,\n                        Index     => Start.Index)\n       do\n          B := B + 1;\n@@ -2597,9 +2656,25 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n-      C : constant Cursor := (Object.Container, Object.Container.Last);\n    begin\n-      return C;\n+      --  The value of the iterator object's Index component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Index component is No_Index, this means the iterator object\n+      --  was constructed without a start expression, in which case the\n+      --  (reverse) iteration starts from the (logical) beginning of the entire\n+      --  sequence (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Index component is not No_Index, the iterator object was\n+      --  constructed with a start expression, that specifies the position from\n+      --  which the (reverse) partial iteration begins.\n+\n+      if Object.Index = No_Index then\n+         return Last (Object.Container.all);\n+      else\n+         return Cursor'(Object.Container, Object.Index);\n+      end if;\n    end Last;\n \n    -----------------\n@@ -2718,11 +2793,16 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Index = Object.Container.Last then\n-         return  No_Element;\n-      else\n-         return (Object.Container, Position.Index + 1);\n+      if Position.Container = null then\n+         return No_Element;\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong vector\";\n+      end if;\n+\n+      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n@@ -2791,11 +2871,16 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Index > Index_Type'First then\n-         return (Object.Container, Position.Index - 1);\n-      else\n+      if Position.Container = null then\n          return No_Element;\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong vector\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    -------------------"}, {"sha": "c16c2f66edc2c21bcb9705f4642c1768b2a38275", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 107, "deletions": 26, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -41,16 +41,18 @@ package body Ada.Containers.Vectors is\n      Vector_Iterator_Interfaces.Reversible_Iterator with\n    record\n       Container : Vector_Access;\n-      Index     : Index_Type;\n+      Index     : Index_Type'Base;\n    end record;\n \n    overriding procedure Finalize (Object : in out Iterator);\n \n    overriding function First (Object : Iterator) return Cursor;\n    overriding function Last  (Object : Iterator) return Cursor;\n+\n    overriding function Next\n-     (Object : Iterator;\n+     (Object   : Iterator;\n       Position : Cursor) return Cursor;\n+\n    overriding function Previous\n      (Object   : Iterator;\n       Position : Cursor) return Cursor;\n@@ -782,14 +784,9 @@ package body Ada.Containers.Vectors is\n    end Finalize;\n \n    procedure Finalize (Object : in out Iterator) is\n+      B : Natural renames Object.Container.Busy;\n    begin\n-      if Object.Container /= null then\n-         declare\n-            B : Natural renames Object.Container.all.Busy;\n-         begin\n-            B := B - 1;\n-         end;\n-      end if;\n+      B := B - 1;\n    end Finalize;\n \n    ----------\n@@ -855,10 +852,24 @@ package body Ada.Containers.Vectors is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Is_Empty (Object.Container.all) then\n-         return No_Element;\n+      --  The value of the iterator object's Index component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Index component is No_Index, this means the iterator object\n+      --  was constructed without a start expression, in which case the\n+      --  (forward) iteration starts from the (logical) beginning of the entire\n+      --  sequence of items (corresponding to Container.First, for a forward\n+      --  iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Index component isn't No_Index, the iterator object was\n+      --  constructed with a start expression, that specifies the position from\n+      --  which the (forward) partial iteration begins.\n+\n+      if Object.Index = No_Index then\n+         return First (Object.Container.all);\n       else\n-         return (Object.Container, Index_Type'First);\n+         return Cursor'(Object.Container, Object.Index);\n       end if;\n    end First;\n \n@@ -2124,13 +2135,24 @@ package body Ada.Containers.Vectors is\n      (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n+      V : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames V.Busy;\n \n    begin\n+      --  The value of its Index component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Index\n+      --  component is No_Index (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n       return It : constant Iterator :=\n                     (Limited_Controlled with\n-                       Container => Container'Unrestricted_Access,\n-                       Index     => Index_Type'First)\n+                       Container => V,\n+                       Index     => No_Index)\n       do\n          B := B + 1;\n       end return;\n@@ -2141,12 +2163,48 @@ package body Ada.Containers.Vectors is\n       Start     : Cursor)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n+      V : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames V.Busy;\n \n    begin\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start.Container = null then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= V then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong vector\";\n+      end if;\n+\n+      if Start.Index > V.Last then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      --  The value of its Index component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Index\n+      --  component is not No_Index (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n       return It : constant Iterator :=\n                     (Limited_Controlled with\n-                       Container => Container'Unrestricted_Access,\n+                       Container => V,\n                        Index     => Start.Index)\n       do\n          B := B + 1;\n@@ -2168,10 +2226,23 @@ package body Ada.Containers.Vectors is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Is_Empty (Object.Container.all) then\n-         return No_Element;\n+      --  The value of the iterator object's Index component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Index component is No_Index, this means the iterator object\n+      --  was constructed without a start expression, in which case the\n+      --  (reverse) iteration starts from the (logical) beginning of the entire\n+      --  sequence (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Index component is not No_Index, the iterator object was\n+      --  constructed with a start expression, that specifies the position from\n+      --  which the (reverse) partial iteration begins.\n+\n+      if Object.Index = No_Index then\n+         return Last (Object.Container.all);\n       else\n-         return (Object.Container, Object.Container.Last);\n+         return Cursor'(Object.Container, Object.Index);\n       end if;\n    end Last;\n \n@@ -2282,11 +2353,16 @@ package body Ada.Containers.Vectors is\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Index < Object.Container.Last then\n-         return (Object.Container, Position.Index + 1);\n-      else\n+      if Position.Container = null then\n          return No_Element;\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong vector\";\n+      end if;\n+\n+      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n@@ -2338,11 +2414,16 @@ package body Ada.Containers.Vectors is\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n-      if Position.Index > Index_Type'First then\n-         return (Object.Container, Position.Index - 1);\n-      else\n+      if Position.Container = null then\n          return No_Element;\n       end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong vector\";\n+      end if;\n+\n+      return Previous (Position);\n    end Previous;\n \n    procedure Previous (Position : in out Cursor) is"}, {"sha": "713053d6235e30948b06f4cd2f87f30112c14360", "filename": "gcc/ada/gsocket.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fgsocket.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fgsocket.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgsocket.h?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *         Copyright (C) 2004-2010, Free Software Foundation, Inc.          *\n+ *         Copyright (C) 2004-2011, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -58,8 +58,11 @@\n /* For Tru64 */\n #endif\n \n-#include <limits.h>\n-#include <errno.h>\n+/** No system header may be included prior to this point since on some targets\n+ ** we need to redefine FD_SETSIZE.\n+ **/\n+\n+/* Target-specific includes and definitions */\n \n #if defined(__vxworks)\n #include <vxWorks.h>\n@@ -163,6 +166,8 @@\n \n #elif defined(VMS)\n #define FD_SETSIZE 4096\n+#include <sys/types.h>\n+#include <sys/time.h>\n #ifndef IN_RTS\n /* These DEC C headers are not available when building with GCC */\n #include <in.h>\n@@ -173,18 +178,21 @@\n \n #endif\n \n+#include <limits.h>\n+#include <errno.h>\n+\n #if defined (__vxworks) && ! defined (__RTP__)\n #include <sys/times.h>\n #else\n #include <sys/time.h>\n #endif\n \n /*\n- * RTEMS has these .h files but not until you have built and installed\n- * RTEMS. When building a C/C++ toolset, you also build the newlib C library.\n- * So the build procedure for an RTEMS GNAT toolset requires that\n- * you build a C/C++ toolset, then build and install RTEMS with \n- * --enable-multilib, and finally build the Ada part of the toolset.\n+ * RTEMS has these .h files but not until you have built and installed RTEMS.\n+ * When building a C/C++ toolset, you also build the newlib C library, so the\n+ * build procedure for an RTEMS GNAT toolset requires that you build a C/C++\n+ * toolset, then build and install RTEMS with --enable-multilib, and finally\n+ * build the Ada part of the toolset.\n  */\n #if !(defined (VMS) || defined (__MINGW32__))\n #include <sys/socket.h>"}, {"sha": "ac64be4b837c56cc60e1f251654c36d202637ef8", "filename": "gcc/ada/mlib-tgt-specific-xi.adb", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-xi.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -3,11 +3,10 @@\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n --                     M L I B . T G T. S P E C I F I C                     --\n---                           (Bare Board Version)                           --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -139,33 +138,11 @@ package body MLib.Tgt.Specific is\n \n    function Get_Target_Prefix return String is\n       Target_Name : constant String_Ptr := Sdefault.Target_Name;\n-      Index       : Positive            := Target_Name'First;\n \n    begin\n-      while Index < Target_Name'Last\n-        and then Target_Name (Index + 1) /= '-'\n-      loop\n-         Index := Index + 1;\n-      end loop;\n-\n-      if Target_Name (Target_Name'First .. Index) = \"avr\" then\n-         return \"avr-\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"erc32\" then\n-         return \"erc32-elf-\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"leon\" then\n-         return \"leon-elf-\";\n-      elsif Target_Name (Target_Name'First .. Index) = \"powerpc\" then\n-         if Target_Name'Length >= 23 and then\n-           Target_Name (Target_Name'First .. Target_Name'First + 22) =\n-                                              \"powerpc-unknown-eabispe\"\n-         then\n-            return \"powerpc-eabispe-\";\n-         else\n-            return \"powerpc-elf-\";\n-         end if;\n-      else\n-         return \"\";\n-      end if;\n+      --  Target_name is the program prefix without '-' but with a trailing '/'\n+\n+      return Target_Name (Target_Name'First .. Target_Name'Last - 1) & '-';\n    end Get_Target_Prefix;\n \n    --------------------------------------"}, {"sha": "38991ce6be3640f29e0674816fdef6907d76c4d1", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -1410,7 +1410,7 @@ package body Par_SCO is\n                   Set_Statement_Entry;\n \n                   --  Process case branches, all of which are dominated by the\n-                  --  CASE expression.\n+                  --  CASE statement.\n \n                   declare\n                      Alt : Node_Id;\n@@ -1419,7 +1419,7 @@ package body Par_SCO is\n                      while Present (Alt) loop\n                         Traverse_Declarations_Or_Statements\n                           (L => Statements (Alt),\n-                           D => ('S', Expression (N)));\n+                           D => Current_Dominant);\n                         Next (Alt);\n                      end loop;\n                   end;"}, {"sha": "143067c9926730d739d2ad41850f300e063964dc", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -78,6 +78,8 @@ pragma Style_Checks (\"M32766\");\n  **  $ RUN xoscons\n  **/\n \n+/* Feature macro definitions */\n+\n #if defined (__linux__) && !defined (_XOPEN_SOURCE)\n /** For Linux _XOPEN_SOURCE must be defined, otherwise IOV_MAX is not defined\n  **/\n@@ -93,6 +95,10 @@ pragma Style_Checks (\"M32766\");\n #endif\n #endif\n \n+/* Include gsocket.h before any system header so it can redefine FD_SETSIZE */\n+\n+#include \"gsocket.h\"\n+\n #include <stdlib.h>\n #include <string.h>\n #include <limits.h>\n@@ -130,8 +136,6 @@ pragma Style_Checks (\"M32766\");\n # include <vxWorks.h>\n #endif\n \n-#include \"gsocket.h\"\n-\n #ifdef DUMMY\n \n # if defined (TARGET)"}, {"sha": "1c607d97cd7081d8a52dd516897c4a612c2da1a5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8bd500e2dcdfdd5f798e403662942d0dc3d6a86/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e8bd500e2dcdfdd5f798e403662942d0dc3d6a86", "patch": "@@ -5872,7 +5872,20 @@ package body Sem_Ch13 is\n       --  All other cases\n \n       else\n-         Preanalyze_Spec_Expression (End_Decl_Expr, T);\n+         --  In a generic context freeze nodes are not generated, and the\n+         --  aspect expressions have not been preanalyzed, so do it now.\n+         --  There are no conformance checks to perform in this case.\n+\n+         if No (T)\n+           and then Inside_A_Generic\n+         then\n+            Check_Aspect_At_Freeze_Point (ASN);\n+            return;\n+\n+         else\n+            Preanalyze_Spec_Expression (End_Decl_Expr, T);\n+         end if;\n+\n          Err := not Fully_Conformant_Expressions (End_Decl_Expr, Freeze_Expr);\n       end if;\n "}]}