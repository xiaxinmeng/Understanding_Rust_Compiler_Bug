{"sha": "91c41804cbe481a939aa05f11f9a3d3acd64531a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFjNDE4MDRjYmU0ODFhOTM5YWEwNWYxMWY5YTNkM2FjZDY0NTMxYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-11-27T18:47:41Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2006-11-27T18:47:41Z"}, "message": "c-common.c (constant_fits_type_p): Delete.\n\n2006-11-27  Roger Sayle  <roger@eyesopen.com>\n\t    Manuel Lopez-Ibanez <manu@gcc.gnu.org>\n\t    \n\t* c-common.c (constant_fits_type_p): Delete.\n\t(unsigned_conversion_warning): Delete.\n\t(conversion_warning): Integrate Wconversion warning from\n\tunsigned_conversion_warning.\n\t(convert_and_check): Integrate Woverflow warning from\n\tunsigned_conversion_warning.  Reorganize and simplify to avoid\n\tdependence upon the middle-end setting TREE_OVERFLOW on integral\n\tconversions, by using int_fits_type_p directly.\n\nCo-Authored-By: Manuel L\u00f3pez-Ib\u00e1\u00f1ez <manu@gcc.gnu.org>\n\nFrom-SVN: r119258", "tree": {"sha": "5aad359f0e185e1bc8cb2318a9326272bdaa6c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aad359f0e185e1bc8cb2318a9326272bdaa6c5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91c41804cbe481a939aa05f11f9a3d3acd64531a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c41804cbe481a939aa05f11f9a3d3acd64531a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c41804cbe481a939aa05f11f9a3d3acd64531a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c41804cbe481a939aa05f11f9a3d3acd64531a/comments", "author": null, "committer": null, "parents": [{"sha": "dbdbfff135d45b0767ab5617f24343dd3b15b8cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbdbfff135d45b0767ab5617f24343dd3b15b8cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbdbfff135d45b0767ab5617f24343dd3b15b8cd"}], "stats": {"total": 143, "additions": 69, "deletions": 74}, "files": [{"sha": "96a4c6bdc17135446e999ee74211e2534cce6b52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c41804cbe481a939aa05f11f9a3d3acd64531a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c41804cbe481a939aa05f11f9a3d3acd64531a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91c41804cbe481a939aa05f11f9a3d3acd64531a", "patch": "@@ -1,3 +1,15 @@\n+2006-11-27  Roger Sayle  <roger@eyesopen.com>\n+\t    Manuel Lopez-Ibanez <manu@gcc.gnu.org>\n+\t    \n+\t* c-common.c (constant_fits_type_p): Delete.\n+\t(unsigned_conversion_warning): Delete.\n+\t(conversion_warning): Integrate Wconversion warning from\n+\tunsigned_conversion_warning.\n+\t(convert_and_check): Integrate Woverflow warning from\n+\tunsigned_conversion_warning.  Reorganize and simplify to avoid\n+\tdependence upon the middle-end setting TREE_OVERFLOW on integral\n+\tconversions, by using int_fits_type_p directly.\n+\n 2006-11-27  Tobias Burnus  <burnus@net-b.de>\n \n \t* doc/invoke.texi: Fixed typo."}, {"sha": "d7e98deeb2f65c7567514916eddc2b22e74cdde3", "filename": "gcc/c-common.c", "status": "modified", "additions": 57, "deletions": 74, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c41804cbe481a939aa05f11f9a3d3acd64531a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c41804cbe481a939aa05f11f9a3d3acd64531a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=91c41804cbe481a939aa05f11f9a3d3acd64531a", "patch": "@@ -499,7 +499,6 @@ const struct fname_var_t fname_vars[] =\n   {NULL, 0, 0},\n };\n \n-static int constant_fits_type_p (tree, tree);\n static tree check_case_value (tree);\n static bool check_case_bounds (tree, tree, tree *, tree *);\n \n@@ -957,32 +956,6 @@ overflow_warning (tree value)\n     }\n }\n \n-/* Print a warning if a large constant is truncated to unsigned,\n-   or if -Wconversion is used and a constant < 0 is converted to unsigned.\n-   Invoke this function on every expression that might be implicitly\n-   converted to an unsigned type.  */\n-\n-static void\n-unsigned_conversion_warning (tree result, tree operand)\n-{\n-  tree type = TREE_TYPE (result);\n-\n-  if (TREE_CODE (operand) == INTEGER_CST\n-      && TREE_CODE (type) == INTEGER_TYPE\n-      && TYPE_UNSIGNED (type)\n-      && skip_evaluation == 0\n-      && !int_fits_type_p (operand, type))\n-    {\n-      if (!int_fits_type_p (operand, c_common_signed_type (type)))\n-\t/* This detects cases like converting -129 or 256 to unsigned char.  */\n-\twarning (OPT_Woverflow,\n-\t\t \"large integer implicitly truncated to unsigned type\");\n-      else\n-\twarning (OPT_Wconversion,\n-\t\t \"negative integer implicitly converted to unsigned type\");\n-    }\n-}\n-\n /* Print a warning about casts that might indicate violation\n    of strict aliasing rules if -Wstrict-aliasing is used and\n    strict aliasing mode is in effect. OTYPE is the original\n@@ -1100,19 +1073,6 @@ check_main_parameter_types (tree decl)\n }\n \n  \n-/* Nonzero if constant C has a value that is permissible\n-   for type TYPE (an INTEGER_TYPE).  */\n-\n-static int\n-constant_fits_type_p (tree c, tree type)\n-{\n-  if (TREE_CODE (c) == INTEGER_CST)\n-    return int_fits_type_p (c, type);\n-\n-  c = convert (type, c);\n-  return !TREE_OVERFLOW (c);\n-}\n-\n /* Nonzero if vector types T1 and T2 can be converted to each other\n    without an explicit cast.  */\n int\n@@ -1147,15 +1107,17 @@ conversion_warning (tree type, tree expr)\n           if (!real_isinteger (TREE_REAL_CST_PTR (expr), TYPE_MODE (TREE_TYPE (expr))))\n             give_warning = true;\n         }\n-      /* Warn for an integer constant that does not fit into integer\n-         type. However, warnings for negative constants converted to\n-         unsigned types are detected by unsigned_conversion_warning.  */\n+      /* Warn for an integer constant that does not fit into integer type.  */\n       else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n                && TREE_CODE (type) == INTEGER_TYPE\n-               && !int_fits_type_p (expr, type)\n-               && !(TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (TREE_TYPE (expr))))\n-        give_warning = true;\n-\n+               && !int_fits_type_p (expr, type))\n+        {\n+          if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (TREE_TYPE (expr)))\n+            warning (OPT_Wconversion,\n+                     \"negative integer implicitly converted to unsigned type\");\n+          else\n+            give_warning = true;\n+        }\n       else if (TREE_CODE (type) == REAL_TYPE)\n         {\n           /* Warn for an integer constant that does not fit into real type.  */\n@@ -1241,42 +1203,63 @@ conversion_warning (tree type, tree expr)\n tree\n convert_and_check (tree type, tree expr)\n {\n-  tree t = convert (type, expr);\n-  if (TREE_CODE (t) == INTEGER_CST && TREE_OVERFLOW (t))\n-    {\n-      TREE_OVERFLOW (t) = 0;\n+  tree result;\n+\n+  if (TREE_TYPE (expr) == type)\n+    return expr;\n+  \n+  result = convert (type, expr);\n+\n+  if (skip_evaluation)\n+    return result;\n+\n \n+  if (TREE_CODE (expr) == INTEGER_CST\n+      && (TREE_CODE (type) == INTEGER_TYPE\n+          || TREE_CODE (type) == ENUMERAL_TYPE)\n+      && !int_fits_type_p (expr, type))\n+    {\n       /* Do not diagnose overflow in a constant expression merely\n          because a conversion overflowed.  */\n-      TREE_CONSTANT_OVERFLOW (t) = CONSTANT_CLASS_P (expr)\n-        && TREE_CONSTANT_OVERFLOW (expr);\n+      if (TREE_OVERFLOW (result))\n+        {\n+          TREE_CONSTANT_OVERFLOW (result) = TREE_CONSTANT_OVERFLOW (expr);\n+          TREE_OVERFLOW (result) = TREE_OVERFLOW (expr);\n+        }\n       \n-      /* No warning for converting 0x80000000 to int.  */\n-      if (!(TYPE_UNSIGNED (type) < TYPE_UNSIGNED (TREE_TYPE (expr))\n-            && TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n-            && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (expr))))\n+      if (TYPE_UNSIGNED (type))\n         {\n-          /* If EXPR fits in the unsigned version of TYPE,\n-             don't warn unless pedantic.  */\n-          if ((pedantic\n-               || TYPE_UNSIGNED (type)\n-               || !constant_fits_type_p (expr,\n-                                         c_common_unsigned_type (type)))\n-              && skip_evaluation == 0)\n+          /* This detects cases like converting -129 or 256 to\n+             unsigned char.  */\n+          if (!int_fits_type_p (expr, c_common_signed_type (type)))\n+            warning (OPT_Woverflow,\n+                     \"large integer implicitly truncated to unsigned type\");\n+          else if (warn_conversion)\n+            conversion_warning (type, expr);\n+        }\n+      else\n+        {\n+          if (!int_fits_type_p (expr, c_common_unsigned_type (type)))\n             warning (OPT_Woverflow,\n                      \"overflow in implicit constant conversion\");\n+          /* No warning for converting 0x80000000 to int.  */\n+          else if (pedantic\n+                   && (TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE\n+                       || TYPE_PRECISION (TREE_TYPE (expr))\n+                       != TYPE_PRECISION (type)))\n+            warning (OPT_Woverflow,\n+                     \"overflow in implicit constant conversion\");\n+          else if (warn_conversion)\n+            conversion_warning (type, expr);\n         }\n-      else if (warn_conversion && !skip_evaluation)\n-          conversion_warning (type, expr);\n     }\n-  else \n-    {\n-      if (warn_conversion && !skip_evaluation)\n-        conversion_warning (type, expr);\n-\n-      unsigned_conversion_warning (t, expr);\n-    }\n-  return t;\n+  else if (TREE_CODE (result) == INTEGER_CST && TREE_OVERFLOW (result)) \n+    warning (OPT_Woverflow,\n+             \"overflow in implicit constant conversion\");\n+  else if (warn_conversion)\n+    conversion_warning (type, expr);\n+  \n+  return result;\n }\n \f\n /* A node in a list that describes references to variables (EXPR), which are"}]}