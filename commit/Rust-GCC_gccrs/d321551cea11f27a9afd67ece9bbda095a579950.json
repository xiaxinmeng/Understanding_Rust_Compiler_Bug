{"sha": "d321551cea11f27a9afd67ece9bbda095a579950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyMTU1MWNlYTExZjI3YTlhZmQ2N2VjZTliYmRhMDk1YTU3OTk1MA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2019-08-15T18:15:33Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2019-08-15T18:15:33Z"}, "message": "i386: Separate costs of pseudo registers from hard registers\n\nprocessor_costs has costs of RTL expressions with pseudo registers and\nand costs of hard register moves:\n\n1. Costs of RTL expressions are used to generate the most efficient RTL\noperations with pseudo registers.\n\n2. Costs of hard register moves are used by register allocator to\ndecide how to allocate and move hard registers.\n\nSince relative costs of pseudo register load and store versus pseudo\nregister moves in RTL expressions can be different from relative costs\nof hard registers, we should separate costs of RTL expressions with\npseudo registers from costs of hard registers so that register allocator\nand RTL expressions can be improved independently.\n\nThis patch moves costs of hard register moves to the new hard_register\nfield and duplicates costs of moves which are also used for costs of RTL\nexpressions.\n\n\tPR target/90878\n\t* config/i386/i386.c (inline_memory_move_cost): Use hard_register\n\tfor costs of hard register moves.\n\t(ix86_register_move_cost): Likewise.\n\t* config/i386/i386.h (processor_costs): Move costs of hard\n\tregister moves to hard_register.  Add int_load, int_store,\n\txmm_move, ymm_move, zmm_move, sse_to_integer, integer_to_sse,\n\tsse_load, sse_store, sse_unaligned_load and sse_unaligned_store\n\tfor costs of RTL expressions.\n\t* config/i386/x86-tune-costs.h: Move costs of hard register\n\tmoves to hard_register.  Duplicate int_load, int_store,\n\txmm_move, ymm_move, zmm_move, sse_to_integer, integer_to_sse,\n\tsse_load, sse_store for costs of RTL expressions.\n\nFrom-SVN: r274543", "tree": {"sha": "056702cbc19ede82eb3946c4ea0ba9c2de6de03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/056702cbc19ede82eb3946c4ea0ba9c2de6de03f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d321551cea11f27a9afd67ece9bbda095a579950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d321551cea11f27a9afd67ece9bbda095a579950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d321551cea11f27a9afd67ece9bbda095a579950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d321551cea11f27a9afd67ece9bbda095a579950/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d91f618d155a418acd7a7c9188af4c15d2583541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91f618d155a418acd7a7c9188af4c15d2583541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91f618d155a418acd7a7c9188af4c15d2583541"}], "stats": {"total": 1382, "additions": 840, "deletions": 542}, "files": [{"sha": "aa295f09368dbc362893b626127e51e070c438c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d321551cea11f27a9afd67ece9bbda095a579950", "patch": "@@ -1,3 +1,19 @@\n+2019-08-15  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/90878\n+\t* config/i386/i386.c (inline_memory_move_cost): Use hard_register\n+\tfor costs of hard register moves.\n+\t(ix86_register_move_cost): Likewise.\n+\t* config/i386/i386.h (processor_costs): Move costs of hard\n+\tregister moves to hard_register.  Add int_load, int_store,\n+\txmm_move, ymm_move, zmm_move, sse_to_integer, integer_to_sse,\n+\tsse_load, sse_store, sse_unaligned_load and sse_unaligned_store\n+\tfor costs of RTL expressions.\n+\t* config/i386/x86-tune-costs.h: Move costs of hard register\n+\tmoves to hard_register.  Duplicate int_load, int_store,\n+\txmm_move, ymm_move, zmm_move, sse_to_integer, integer_to_sse,\n+\tsse_load, sse_store for costs of RTL expressions.\n+\n 2019-08-15  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (setup_incoming_vararg_bounds): Remove."}, {"sha": "647bcbef0506f4f5ad561535c1e303a9cd045682", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d321551cea11f27a9afd67ece9bbda095a579950", "patch": "@@ -18464,17 +18464,21 @@ inline_memory_move_cost (machine_mode mode, enum reg_class regclass, int in)\n \t    return 100;\n \t}\n       if (in == 2)\n-        return MAX (ix86_cost->fp_load [index], ix86_cost->fp_store [index]);\n-      return in ? ix86_cost->fp_load [index] : ix86_cost->fp_store [index];\n+        return MAX (ix86_cost->hard_register.fp_load [index],\n+\t\t    ix86_cost->hard_register.fp_store [index]);\n+      return in ? ix86_cost->hard_register.fp_load [index]\n+\t\t: ix86_cost->hard_register.fp_store [index];\n     }\n   if (SSE_CLASS_P (regclass))\n     {\n       int index = sse_store_index (mode);\n       if (index == -1)\n \treturn 100;\n       if (in == 2)\n-        return MAX (ix86_cost->sse_load [index], ix86_cost->sse_store [index]);\n-      return in ? ix86_cost->sse_load [index] : ix86_cost->sse_store [index];\n+        return MAX (ix86_cost->hard_register.sse_load [index],\n+\t\t    ix86_cost->hard_register.sse_store [index]);\n+      return in ? ix86_cost->hard_register.sse_load [index]\n+\t\t: ix86_cost->hard_register.sse_store [index];\n     }\n   if (MMX_CLASS_P (regclass))\n     {\n@@ -18491,46 +18495,52 @@ inline_memory_move_cost (machine_mode mode, enum reg_class regclass, int in)\n \t    return 100;\n \t}\n       if (in == 2)\n-        return MAX (ix86_cost->mmx_load [index], ix86_cost->mmx_store [index]);\n-      return in ? ix86_cost->mmx_load [index] : ix86_cost->mmx_store [index];\n+        return MAX (ix86_cost->hard_register.mmx_load [index],\n+\t\t    ix86_cost->hard_register.mmx_store [index]);\n+      return in ? ix86_cost->hard_register.mmx_load [index]\n+\t\t: ix86_cost->hard_register.mmx_store [index];\n     }\n   switch (GET_MODE_SIZE (mode))\n     {\n       case 1:\n \tif (Q_CLASS_P (regclass) || TARGET_64BIT)\n \t  {\n \t    if (!in)\n-\t      return ix86_cost->int_store[0];\n+\t      return ix86_cost->hard_register.int_store[0];\n \t    if (TARGET_PARTIAL_REG_DEPENDENCY\n \t        && optimize_function_for_speed_p (cfun))\n-\t      cost = ix86_cost->movzbl_load;\n+\t      cost = ix86_cost->hard_register.movzbl_load;\n \t    else\n-\t      cost = ix86_cost->int_load[0];\n+\t      cost = ix86_cost->hard_register.int_load[0];\n \t    if (in == 2)\n-\t      return MAX (cost, ix86_cost->int_store[0]);\n+\t      return MAX (cost, ix86_cost->hard_register.int_store[0]);\n \t    return cost;\n \t  }\n \telse\n \t  {\n \t   if (in == 2)\n-\t     return MAX (ix86_cost->movzbl_load, ix86_cost->int_store[0] + 4);\n+\t     return MAX (ix86_cost->hard_register.movzbl_load,\n+\t\t\t ix86_cost->hard_register.int_store[0] + 4);\n \t   if (in)\n-\t     return ix86_cost->movzbl_load;\n+\t     return ix86_cost->hard_register.movzbl_load;\n \t   else\n-\t     return ix86_cost->int_store[0] + 4;\n+\t     return ix86_cost->hard_register.int_store[0] + 4;\n \t  }\n \tbreak;\n       case 2:\n \tif (in == 2)\n-\t  return MAX (ix86_cost->int_load[1], ix86_cost->int_store[1]);\n-\treturn in ? ix86_cost->int_load[1] : ix86_cost->int_store[1];\n+\t  return MAX (ix86_cost->hard_register.int_load[1],\n+\t\t      ix86_cost->hard_register.int_store[1]);\n+\treturn in ? ix86_cost->hard_register.int_load[1]\n+\t\t  : ix86_cost->hard_register.int_store[1];\n       default:\n \tif (in == 2)\n-\t  cost = MAX (ix86_cost->int_load[2], ix86_cost->int_store[2]);\n+\t  cost = MAX (ix86_cost->hard_register.int_load[2],\n+\t\t      ix86_cost->hard_register.int_store[2]);\n \telse if (in)\n-\t  cost = ix86_cost->int_load[2];\n+\t  cost = ix86_cost->hard_register.int_load[2];\n \telse\n-\t  cost = ix86_cost->int_store[2];\n+\t  cost = ix86_cost->hard_register.int_store[2];\n \t/* Multiply with the number of GPR moves needed.  */\n \treturn cost * CEIL ((int) GET_MODE_SIZE (mode), UNITS_PER_WORD);\n     }\n@@ -18600,20 +18610,21 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n        because of missing QImode and HImode moves to, from or between\n        MMX/SSE registers.  */\n     return MAX (8, SSE_CLASS_P (class1)\n-\t\t? ix86_cost->sse_to_integer : ix86_cost->integer_to_sse);\n+\t\t? ix86_cost->hard_register.sse_to_integer\n+\t\t: ix86_cost->hard_register.integer_to_sse);\n \n   if (MAYBE_FLOAT_CLASS_P (class1))\n-    return ix86_cost->fp_move;\n+    return ix86_cost->hard_register.fp_move;\n   if (MAYBE_SSE_CLASS_P (class1))\n     {\n       if (GET_MODE_BITSIZE (mode) <= 128)\n-\treturn ix86_cost->xmm_move;\n+\treturn ix86_cost->hard_register.xmm_move;\n       if (GET_MODE_BITSIZE (mode) <= 256)\n-\treturn ix86_cost->ymm_move;\n-      return ix86_cost->zmm_move;\n+\treturn ix86_cost->hard_register.ymm_move;\n+      return ix86_cost->hard_register.zmm_move;\n     }\n   if (MAYBE_MMX_CLASS_P (class1))\n-    return ix86_cost->mmx_move;\n+    return ix86_cost->hard_register.mmx_move;\n   return 2;\n }\n "}, {"sha": "e0a77e1fb25af1df0e083517d5ede380c0429e71", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d321551cea11f27a9afd67ece9bbda095a579950", "patch": "@@ -237,9 +237,46 @@ struct stringop_algs\n   } size [MAX_STRINGOP_ALGS];\n };\n \n-/* Define the specific costs for a given cpu */\n+/* Define the specific costs for a given cpu.  NB: hard_register is used\n+   by TARGET_REGISTER_MOVE_COST and TARGET_MEMORY_MOVE_COST to compute\n+   hard register move costs by register allocator.  Relative costs of\n+   pseudo register load and store versus pseudo register moves in RTL\n+   expressions for TARGET_RTX_COSTS can be different from relative\n+   costs of hard registers to get the most efficient operations with\n+   pseudo registers.  */\n \n struct processor_costs {\n+  /* Costs used by register allocator.  integer->integer register move\n+     cost is 2.  */\n+  struct\n+    {\n+      const int movzbl_load;\t/* cost of loading using movzbl */\n+      const int int_load[3];\t/* cost of loading integer registers\n+\t\t\t\t   in QImode, HImode and SImode relative\n+\t\t\t\t   to reg-reg move (2).  */\n+      const int int_store[3];\t/* cost of storing integer register\n+\t\t\t\t   in QImode, HImode and SImode */\n+      const int fp_move;\t/* cost of reg,reg fld/fst */\n+      const int fp_load[3];\t/* cost of loading FP register\n+\t\t\t\t   in SFmode, DFmode and XFmode */\n+      const int fp_store[3];\t/* cost of storing FP register\n+\t\t\t\t   in SFmode, DFmode and XFmode */\n+      const int mmx_move;\t/* cost of moving MMX register.  */\n+      const int mmx_load[2];\t/* cost of loading MMX register\n+\t\t\t\t   in SImode and DImode */\n+      const int mmx_store[2];\t/* cost of storing MMX register\n+\t\t\t\t   in SImode and DImode */\n+      const int xmm_move;\t/* cost of moving XMM register.  */\n+      const int ymm_move;\t/* cost of moving XMM register.  */\n+      const int zmm_move;\t/* cost of moving XMM register.  */\n+      const int sse_load[5];\t/* cost of loading SSE register\n+\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+      const int sse_store[5];\t/* cost of storing SSE register\n+\t\t\t\t   in SImode, DImode and TImode.  */\n+      const int sse_to_integer;\t/* cost of moving SSE register to integer.  */\n+      const int integer_to_sse;\t/* cost of moving integer register to SSE. */\n+    } hard_register;\n+\n   const int add;\t\t/* cost of an add instruction */\n   const int lea;\t\t/* cost of a lea instruction */\n   const int shift_var;\t\t/* variable shift costs */\n@@ -254,32 +291,20 @@ struct processor_costs {\n   const int large_insn;\t\t/* insns larger than this cost more */\n   const int move_ratio;\t\t/* The threshold of number of scalar\n \t\t\t\t   memory-to-memory move insns.  */\n-  const int movzbl_load;\t/* cost of loading using movzbl */\n   const int int_load[3];\t/* cost of loading integer registers\n \t\t\t\t   in QImode, HImode and SImode relative\n \t\t\t\t   to reg-reg move (2).  */\n   const int int_store[3];\t/* cost of storing integer register\n \t\t\t\t   in QImode, HImode and SImode */\n-  const int fp_move;\t\t/* cost of reg,reg fld/fst */\n-  const int fp_load[3];\t\t/* cost of loading FP register\n-\t\t\t\t   in SFmode, DFmode and XFmode */\n-  const int fp_store[3];\t/* cost of storing FP register\n-\t\t\t\t   in SFmode, DFmode and XFmode */\n-  const int mmx_move;\t\t/* cost of moving MMX register.  */\n-  const int mmx_load[2];\t/* cost of loading MMX register\n-\t\t\t\t   in SImode and DImode */\n-  const int mmx_store[2];\t/* cost of storing MMX register\n-\t\t\t\t   in SImode and DImode */\n-  const int xmm_move, ymm_move, /* cost of moving XMM and YMM register.  */\n-\t    zmm_move;\n   const int sse_load[5];\t/* cost of loading SSE register\n \t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n-  const int sse_unaligned_load[5];/* cost of unaligned load.  */\n   const int sse_store[5];\t/* cost of storing SSE register\n-\t\t\t\t   in SImode, DImode and TImode.  */\n+\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  const int sse_unaligned_load[5];/* cost of unaligned load.  */\n   const int sse_unaligned_store[5];/* cost of unaligned store.  */\n+  const int xmm_move, ymm_move, /* cost of moving XMM and YMM register.  */\n+\t    zmm_move;\n   const int sse_to_integer;\t/* cost of moving SSE register to integer.  */\n-  const int integer_to_sse;\t/* cost of moving integer register to SSE. */\n   const int gather_static, gather_per_elt; /* Cost of gather load is computed\n \t\t\t\t   as static + per_item * nelts. */\n   const int scatter_static, scatter_per_elt; /* Cost of gather store is"}, {"sha": "ad9ea4bfa089d50ec1b26493ab8c6878f238a776", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 747, "deletions": 501, "changes": 1248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d321551cea11f27a9afd67ece9bbda095a579950/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=d321551cea11f27a9afd67ece9bbda095a579950", "patch": "@@ -36,6 +36,30 @@ static stringop_algs ix86_size_memset[2] = {\n \n const\n struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 2},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {2, 2, 2},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  3,\t\t\t\t\t/* cost of moving MMX register */\n+  {3, 3},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {3, 3},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  3, 3, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_BYTES (2),\t\t\t/* cost of an add instruction */\n   COSTS_N_BYTES (3),\t\t\t/* cost of a lea instruction */\n   COSTS_N_BYTES (2),\t\t\t/* variable shift costs */\n@@ -55,33 +79,20 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (3),\t\t\t/* cost of movzx */\n   0,\t\t\t\t\t/* \"large\" insn */\n   2,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2. */\n-  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {2, 2, 2},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {2, 2, 2},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  3,\t\t\t\t\t/* cost of moving MMX register */\n-  {3, 3},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {3, 3},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  3, 3, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {3, 3, 3, 3, 3},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {3, 3, 3, 3, 3},\t\t\t/* cost of unaligned SSE load\n \t\t\t\t\t   in 128bit, 256bit and 512bit */\n-  {3, 3, 3, 3, 3},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {3, 3, 3, 3, 3},\t\t\t\t/* cost of unaligned SSE store\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of unaligned SSE store\n \t\t\t\t\t   in 128bit, 256bit and 512bit */\n-  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  3, 3, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   5, 0,\t\t\t\t\t/* Gather load static, per_elt.  */\n   5, 0,\t\t\t\t\t/* Gather store static, per_elt.  */\n   0,\t\t\t\t\t/* size of l1 cache  */\n@@ -127,6 +138,30 @@ static stringop_algs i386_memset[2] = {\n \n static const\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {8, 8, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {4, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (3),\t\t\t/* variable shift costs */\n@@ -146,32 +181,18 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {8, 8, 8},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {4, 8},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   0,\t\t\t\t\t/* size of l1 cache  */\n@@ -216,6 +237,30 @@ static stringop_algs i486_memset[2] = {\n \n static const\n struct processor_costs i486_cost = {\t/* 486 specific costs */\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {8, 8, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {4, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (3),\t\t\t/* variable shift costs */\n@@ -235,32 +280,18 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {8, 8, 8},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {4, 8},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   4,\t\t\t\t\t/* size of l1 cache.  486 has 8kB cache\n@@ -307,6 +338,30 @@ static stringop_algs pentium_memset[2] = {\n \n static const\n struct processor_costs pentium_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  8,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n@@ -326,32 +381,18 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  8,\t\t\t\t\t/* cost of moving MMX register */\n-  {8, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {8, 8},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n@@ -389,6 +430,30 @@ struct processor_costs pentium_cost = {\n \n static const\n struct processor_costs lakemont_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  8,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -408,32 +473,18 @@ struct processor_costs lakemont_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  8,\t\t\t\t\t/* cost of moving MMX register */\n-  {8, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {8, 8},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n@@ -486,6 +537,30 @@ static stringop_algs pentiumpro_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs pentiumpro_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -505,32 +580,18 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {2, 2},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {2, 2},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n@@ -574,6 +635,30 @@ static stringop_algs geode_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs geode_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 2},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 6, 6},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (2),\t\t\t/* variable shift costs */\n@@ -593,33 +678,18 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {2, 2, 2},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 6, 6},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {2, 2},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {2, 2},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned loads.  */\n-  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned stores.  */\n-  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   2, 2,\t\t\t\t\t/* Gather load static, per_elt.  */\n   2, 2,\t\t\t\t\t/* Gather store static, per_elt.  */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n@@ -663,6 +733,30 @@ static stringop_algs k6_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs k6_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  3,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 4},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -682,32 +776,18 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  3,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 4},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {2, 2},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {2, 2},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned loads.  */\n-  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned stores.  */\n-  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   2, 2,\t\t\t\t\t/* Gather load static, per_elt.  */\n   2, 2,\t\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -757,6 +837,30 @@ static stringop_algs athlon_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs athlon_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {4, 4},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 4, 12, 12, 24},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 10, 10, 20},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -776,32 +880,18 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 4},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 4, 12, 12, 24},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 12, 12, 24},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 4, 10, 10, 20},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 4, 12, 12, 24},\t\t\t/* cost of unaligned loads.  */\n-  {4, 4, 10, 10, 20},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 4, 10, 10, 20},\t\t\t/* cost of unaligned stores.  */\n-  5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  5,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n@@ -853,6 +943,30 @@ static stringop_algs k8_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs k8_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {3, 3},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 3, 12, 12, 24},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 10, 10, 20},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -872,32 +986,18 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {3, 3},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {4, 3, 12, 12, 24},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 3, 12, 12, 24},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 4, 10, 10, 20},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {4, 3, 12, 12, 24},\t\t\t/* cost of unaligned loads.  */\n-  {4, 4, 10, 10, 20},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {4, 4, 10, 10, 20},\t\t\t/* cost of unaligned stores.  */\n-  5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  5,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n@@ -953,28 +1053,7 @@ static stringop_algs amdfam10_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n struct processor_costs amdfam10_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n-  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n-  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n-   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (5)},\t\t\t/*\t\t\t      other */\n-  0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n-   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n-   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n-   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n-  8,\t\t\t\t\t/* \"large\" insn */\n-  9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -993,11 +1072,10 @@ struct processor_costs amdfam10_cost = {\n   2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n   {4, 4, 3, 6, 12},\t\t\t/* cost of loading SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {4, 4, 3, 7, 12},\t\t\t/* cost of unaligned loads.  */\n   {4, 4, 5, 10, 20},\t\t\t/* cost of storing SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {4, 4, 5, 10, 20},\t\t\t/* cost of unaligned stores.  */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+\n   \t\t\t\t\t/* On K8:\n   \t\t\t\t\t    MOVD reg64, xmmreg Double FSTORE 4\n \t\t\t\t\t    MOVD reg32, xmmreg Double FSTORE 4\n@@ -1006,6 +1084,39 @@ struct processor_costs amdfam10_cost = {\n \t\t\t\t\t\t\t       1/1  1/1\n \t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n \t\t\t\t\t\t\t       1/1  1/1 */\n+  /* End of register allocator costs.  */\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  9,\t\t\t\t\t/* MOVE_RATIO */\n+  {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n+  {4, 4, 3, 6, 12},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {4, 4, 3, 7, 12},\t\t\t/* cost of unaligned loads.  */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of unaligned stores.  */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  3,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   4, 4,\t\t\t\t\t/* Gather load static, per_elt.  */\n   4, 4,\t\t\t\t\t/* Gather store static, per_elt.  */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1062,6 +1173,30 @@ static stringop_algs bdver_memset[2] = {\n              {-1, libcall, false}}}};\n \n const struct processor_costs bdver_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n+\t\t   \t\t\t   in SFmode, DFmode and XFmode */\n+  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n+ \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {12, 12},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 10, 40, 60},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 40, 60},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1081,32 +1216,18 @@ const struct processor_costs bdver_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n-\t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n- \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  4,\t\t\t\t\t/* cost of moving MMX register */\n-  {12, 12},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {10, 10},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {12, 12, 10, 40, 60},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 10, 40, 60},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {10, 10, 10, 40, 60},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {12, 12, 10, 40, 60},\t\t\t/* cost of unaligned loads.  */\n-  {10, 10, 10, 40, 60},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {10, 10, 10, 40, 60},\t\t\t/* cost of unaligned stores.  */\n-  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  16,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   12, 12,\t\t\t\t/* Gather load static, per_elt.  */\n   10, 10,\t\t\t\t/* Gather store static, per_elt.  */\n   16,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1164,6 +1285,37 @@ static stringop_algs znver1_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n \t     {-1, libcall, false}}}};\n struct processor_costs znver1_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+\n+  /* reg-reg moves are done by renaming and thus they are even cheaper than\n+     1 cycle. Becuase reg-reg move cost is 2 and the following tables correspond\n+     to doubles of latencies, we do not model this correctly.  It does not\n+     seem to make practical difference to bump prices up even more.  */\n+  6,\t\t\t\t\t/* cost for loading QImode using\n+\t\t\t\t\t   movzbl.  */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer\n+\t\t\t\t\t   registers.  */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst.  */\n+  {6, 6, 16},\t\t\t\t/* cost of loading fp registers\n+\t\t   \t\t\t   in SFmode, DFmode and XFmode.  */\n+  {8, 8, 16},\t\t\t\t/* cost of storing fp registers\n+ \t\t   \t\t\t   in SFmode, DFmode and XFmode.  */\n+  2,\t\t\t\t\t/* cost of moving MMX register.  */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode.  */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode.  */\n+  2, 3, 6,\t\t\t\t/* cost of moving XMM,YMM,ZMM register.  */\n+  {6, 6, 6, 12, 24},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves.  */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs.  */\n@@ -1186,39 +1338,19 @@ struct processor_costs znver1_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx.  */\n   8,\t\t\t\t\t/* \"large\" insn.  */\n   9,\t\t\t\t\t/* MOVE_RATIO.  */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-\n-  /* reg-reg moves are done by renaming and thus they are even cheaper than\n-     1 cycle. Becuase reg-reg move cost is 2 and the following tables correspond\n-     to doubles of latencies, we do not model this correctly.  It does not\n-     seem to make practical difference to bump prices up even more.  */\n-  6,\t\t\t\t\t/* cost for loading QImode using\n-\t\t\t\t\t   movzbl.  */\n   {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {8, 8, 8},\t\t\t\t/* cost of storing integer\n \t\t\t\t\t   registers.  */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst.  */\n-  {6, 6, 16},\t\t\t\t/* cost of loading fp registers\n-\t\t   \t\t\t   in SFmode, DFmode and XFmode.  */\n-  {8, 8, 16},\t\t\t\t/* cost of storing fp registers\n- \t\t   \t\t\t   in SFmode, DFmode and XFmode.  */\n-  2,\t\t\t\t\t/* cost of moving MMX register.  */\n-  {6, 6},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode.  */\n-  {8, 8},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode.  */\n-  2, 3, 6,\t\t\t\t/* cost of moving XMM,YMM,ZMM register.  */\n-  {6, 6, 6, 12, 24},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  {6, 6, 6, 12, 24},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {6, 6, 6, 12, 24},\t\t\t/* cost of unaligned loads.  */\n-  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n   {8, 8, 8, 16, 32},\t\t\t/* cost of unaligned stores.  */\n-  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves.  */\n+  2, 3, 6,\t\t\t\t/* cost of moving XMM,YMM,ZMM register.  */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   /* VGATHERDPD is 23 uops and throughput is 9, VGATHERDPD is 35 uops,\n      throughput 12.  Approx 9 uops do not depend on vector size and every load\n      is 7 uops.  */\n@@ -1288,31 +1420,7 @@ static stringop_algs znver2_memset[2] = {\n \t     {-1, libcall, false}}}};\n \n struct processor_costs znver2_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n-  COSTS_N_INSNS (1),\t\t\t/* variable shift costs.  */\n-  COSTS_N_INSNS (1),\t\t\t/* constant shift costs.  */\n-  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI.  */\n-   COSTS_N_INSNS (3),\t\t\t/* \t\t\t\t HI.  */\n-   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI.  */\n-   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI.  */\n-   COSTS_N_INSNS (3)},\t\t\t/*\t\t\tother.  */\n-  0,\t\t\t\t\t/* cost of multiply per each bit\n-\t\t\t\t\t   set.  */\n-   /* Depending on parameters, idiv can get faster on ryzen.  This is upper\n-      bound.  */\n-  {COSTS_N_INSNS (16),\t\t\t/* cost of a divide/mod for QI.  */\n-   COSTS_N_INSNS (22),\t\t\t/* \t\t\t    HI.  */\n-   COSTS_N_INSNS (30),\t\t\t/*\t\t\t    SI.  */\n-   COSTS_N_INSNS (45),\t\t\t/*\t\t\t    DI.  */\n-   COSTS_N_INSNS (45)},\t\t\t/*\t\t\t    other.  */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx.  */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx.  */\n-  8,\t\t\t\t\t/* \"large\" insn.  */\n-  9,\t\t\t\t\t/* MOVE_RATIO.  */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2.  */\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n \n   /* reg-reg moves are done by renaming and thus they are even cheaper than\n      1 cycle.  Because reg-reg move cost is 2 and following tables correspond\n@@ -1339,12 +1447,48 @@ struct processor_costs znver2_cost = {\n \t\t\t\t\t   register.  */\n   {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n-  {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned loads.  */\n   {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n-  {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n   6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE\n \t\t\t\t\t   moves.  */\n+  /* End of register allocator costs.  */\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs.  */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs.  */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI.  */\n+   COSTS_N_INSNS (3),\t\t\t/* \t\t\t\t HI.  */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI.  */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI.  */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\tother.  */\n+  0,\t\t\t\t\t/* cost of multiply per each bit\n+\t\t\t\t\t   set.  */\n+   /* Depending on parameters, idiv can get faster on ryzen.  This is upper\n+      bound.  */\n+  {COSTS_N_INSNS (16),\t\t\t/* cost of a divide/mod for QI.  */\n+   COSTS_N_INSNS (22),\t\t\t/* \t\t\t    HI.  */\n+   COSTS_N_INSNS (30),\t\t\t/*\t\t\t    SI.  */\n+   COSTS_N_INSNS (45),\t\t\t/*\t\t\t    DI.  */\n+   COSTS_N_INSNS (45)},\t\t\t/*\t\t\t    other.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx.  */\n+  8,\t\t\t\t\t/* \"large\" insn.  */\n+  9,\t\t\t\t\t/* MOVE_RATIO.  */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer\n+\t\t\t\t\t   registers.  */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n+  2, 2, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM\n+\t\t\t\t\t   register.  */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   /* VGATHERDPD is 23 uops and throughput is 9, VGATHERDPD is 35 uops,\n      throughput 12.  Approx 9 uops do not depend on vector size and every load\n      is 7 uops.  */\n@@ -1416,6 +1560,30 @@ static stringop_algs skylake_memset[2] = {\n \n static const\n struct processor_costs skylake_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 3},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {8, 8, 8, 12, 24},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1)+1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1437,30 +1605,18 @@ struct processor_costs skylake_cost = {\n   COSTS_N_INSNS (0),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 6, 3},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {6, 6},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {6, 6},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {6, 6, 6, 10, 20},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 12, 24},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {6, 6, 6, 10, 20},\t\t\t/* cost of unaligned loads.  */\n-  {8, 8, 8, 12, 24},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n-  2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  2,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   20, 8,\t\t\t\t/* Gather load static, per_elt.  */\n   22, 10,\t\t\t\t/* Gather store static, per_elt.  */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1509,6 +1665,30 @@ static stringop_algs btver1_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n const struct processor_costs btver1_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {6, 8, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 8, 6},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {12, 12, 38},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {10, 10},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {12, 12},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1528,32 +1708,18 @@ const struct processor_costs btver1_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {6, 8, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 8, 6},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {12, 12, 38},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  4,\t\t\t\t\t/* cost of moving MMX register */\n-  {10, 10},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {12, 12},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {10, 10, 12, 48, 96},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {10, 10, 12, 48, 96},\t\t\t/* cost of unaligned loads.  */\n-  {10, 10, 12, 48, 96},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {10, 10, 12, 48, 96},\t\t\t/* cost of unaligned stores.  */\n-  14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  14,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   10, 10,\t\t\t\t/* Gather load static, per_elt.  */\n   10, 10,\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1600,6 +1766,30 @@ static stringop_algs btver2_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n const struct processor_costs btver2_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {8, 8, 6},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {12, 12, 38},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {10, 10},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {12, 12},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1619,32 +1809,18 @@ const struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {8, 8, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {8, 8, 6},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {12, 12, 38},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  4,\t\t\t\t\t/* cost of moving MMX register */\n-  {10, 10},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {12, 12},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {10, 10, 12, 48, 96},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {10, 10, 12, 48, 96},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {10, 10, 12, 48, 96},\t\t\t/* cost of unaligned loads.  */\n-  {10, 10, 12, 48, 96},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {10, 10, 12, 48, 96},\t\t\t/* cost of unaligned stores.  */\n-  14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  14,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   10, 10,\t\t\t\t/* Gather load static, per_elt.  */\n   10, 10,\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1690,28 +1866,7 @@ static stringop_algs pentium4_memset[2] = {\n \n static const\n struct processor_costs pentium4_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n-  COSTS_N_INSNS (3),\t\t\t/* cost of a lea instruction */\n-  COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n-  COSTS_N_INSNS (4),\t\t\t/* constant shift costs */\n-  {COSTS_N_INSNS (15),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t HI */\n-   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (15)},\t\t\t/*\t\t\t      other */\n-  0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (56),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    HI */\n-   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    SI */\n-   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    DI */\n-   COSTS_N_INSNS (56)},\t\t\t/*\t\t\t    other */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n-  16,\t\t\t\t\t/* \"large\" insn */\n-  6,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n   5,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -1730,11 +1885,42 @@ struct processor_costs pentium4_cost = {\n   12, 24, 48,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n   {16, 16, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (4),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (15),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (15)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (56),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (56)},\t\t\t/*\t\t\t    other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  16,\t\t\t\t\t/* \"large\" insn */\n+  6,\t\t\t\t\t/* MOVE_RATIO */\n+  {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {32, 32, 32, 64, 128},\t\t/* cost of unaligned loads.  */\n-  {16, 16, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {32, 32, 32, 64, 128},\t\t/* cost of unaligned stores.  */\n-  20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  12, 24, 48,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  20,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   16, 16,\t\t\t\t/* Gather load static, per_elt.  */\n   16, 16,\t\t\t\t/* Gather store static, per_elt.  */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1783,6 +1969,30 @@ static stringop_algs nocona_memset[2] = {\n \n static const\n struct processor_costs nocona_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n+  12,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {14, 14, 14},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {14, 14, 14},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  14,\t\t\t\t\t/* cost of moving MMX register */\n+  {12, 12},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {12, 12},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  6, 12, 24,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 12, 24, 48},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 12, 24, 48},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1802,32 +2012,18 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  12,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {14, 14, 14},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {14, 14, 14},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  14,\t\t\t\t\t/* cost of moving MMX register */\n-  {12, 12},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {12, 12},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  6, 12, 24,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {12, 12, 12, 24, 48},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 12, 24, 48},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {12, 12, 12, 24, 48},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {24, 24, 24, 48, 96},\t\t\t/* cost of unaligned loads.  */\n-  {12, 12, 12, 24, 48},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {24, 24, 24, 48, 96},\t\t\t/* cost of unaligned stores.  */\n-  20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  6, 12, 24,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  20,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   12, 12,\t\t\t\t/* Gather load static, per_elt.  */\n   12, 12,\t\t\t\t/* Gather store static, per_elt.  */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1874,6 +2070,30 @@ static stringop_algs atom_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs atom_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 18},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {14, 14, 24},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1893,32 +2113,18 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 18},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {14, 14, 24},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {8, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {10, 10},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  8,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   8, 8,\t\t\t\t\t/* Gather load static, per_elt.  */\n   8, 8,\t\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -1965,6 +2171,30 @@ static stringop_algs slm_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs slm_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  8,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {8, 8, 18},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 18},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1984,32 +2214,18 @@ struct processor_costs slm_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {8, 8, 18},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 18},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {8, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {6, 6},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in SImode, DImode and TImode.  */\n   {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n-  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n-  8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  8,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   8, 8,\t\t\t\t\t/* Gather load static, per_elt.  */\n   8, 8,\t\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -2056,6 +2272,30 @@ static stringop_algs intel_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs intel_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 2, 2,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  4, 4,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -2075,32 +2315,18 @@ struct processor_costs intel_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {6, 6},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {6, 6},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 2, 2,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {6, 6, 6, 6, 6},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {10, 10, 10, 10, 10},\t\t\t/* cost of unaligned loads.  */\n-  {6, 6, 6, 6, 6},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {10, 10, 10, 10, 10},\t\t\t/* cost of unaligned loads.  */\n-  4, 4,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 2, 2,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  4,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   6, 6,\t\t\t\t\t/* Gather load static, per_elt.  */\n   6, 6,\t\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -2151,6 +2377,30 @@ static stringop_algs generic_memset[2] = {\n              {-1, libcall, false}}}};\n static const\n struct processor_costs generic_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 12},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 3, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 10, 15},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 10, 15},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   /* Setting cost to 2 makes our current implementation of synth_mult result in\n      use of unnecessary temporary registers causing regression on several\n@@ -2173,32 +2423,18 @@ struct processor_costs generic_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 12},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 12},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {6, 6},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {6, 6},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 3, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {6, 6, 6, 10, 15},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 10, 15},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {6, 6, 6, 10, 15},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {6, 6, 6, 10, 15},\t\t\t/* cost of unaligned loads.  */\n-  {6, 6, 6, 10, 15},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {6, 6, 6, 10, 15},\t\t\t/* cost of unaligned storess.  */\n-  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 3, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   18, 6,\t\t\t\t/* Gather load static, per_elt.  */\n   18, 6,\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n@@ -2251,6 +2487,30 @@ static stringop_algs core_memset[2] = {\n \n static const\n struct processor_costs core_cost = {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  /* End of register allocator costs.  */\n+\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   /* On all chips taken into consideration lea is 2 cycles and more.  With\n      this cost however our current implementation of synth_mult results in\n@@ -2277,32 +2537,18 @@ struct processor_costs core_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {6, 6},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {6, 6},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n   {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned loads.  */\n-  {6, 6, 6, 6, 12},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned stores.  */\n-  2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  2,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n   /* VGATHERDPD is 7 uops, rec throughput 5, while VGATHERDPD is 9 uops,\n      rec. throughput 6.\n      So 5 uops statically and one uops per load.  */"}]}