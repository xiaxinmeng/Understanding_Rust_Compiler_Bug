{"sha": "b7c4aa942fa828038106105524af2c568acca7ac", "node_id": "C_kwDOANBUbNoAKGI3YzRhYTk0MmZhODI4MDM4MTA2MTA1NTI0YWYyYzU2OGFjY2E3YWM", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-07-07T18:41:54Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-07-07T18:41:54Z"}, "message": "backend: initial support for matches on tuples\n\nThis is a first take on compiling matches on more complex expressions,\nstarting with tuples.\n\nThe general idea is to first rearrange the match into a simpler form, in\nwhich only one element of the scrutinee tuple is examined at a time.\nThe remaining elements are then checked by a new match in each arm. By\nrepeating this process, we end up with a series of nested matches each\nchecking one element of the original scrutinee, which is equivalent to\nthe original match expression, and which lowers directly to SWITCH_EXPR\ntree nodes (since these can only switch on one thing).\n\nThe resulting SWITCH_EXPRs may be messy, and unoptimal, but we can rely\non later optimizations in GENERIC and GIMPLE to clean them up for us.", "tree": {"sha": "8d6ba220d7ca4147c0d90ef5dc0e9f3054a7c641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d6ba220d7ca4147c0d90ef5dc0e9f3054a7c641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7c4aa942fa828038106105524af2c568acca7ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c4aa942fa828038106105524af2c568acca7ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c4aa942fa828038106105524af2c568acca7ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c4aa942fa828038106105524af2c568acca7ac/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7784232540214b0fa500fa5682326f8841f170d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7784232540214b0fa500fa5682326f8841f170d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7784232540214b0fa500fa5682326f8841f170d5"}], "stats": {"total": 438, "additions": 438, "deletions": 0}, "files": [{"sha": "3740c801d6f5de0b66a66229f7ab1be66f5b08f7", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c4aa942fa828038106105524af2c568acca7ac/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c4aa942fa828038106105524af2c568acca7ac/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=b7c4aa942fa828038106105524af2c568acca7ac", "patch": "@@ -181,6 +181,321 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n \t\t\t\t\t\tknown_valid, expr.get_locus ());\n }\n \n+// Helper for sort_tuple_patterns.\n+// Determine whether Patterns a and b are really the same pattern.\n+// FIXME: This is a nasty hack to avoid properly implementing a comparison\n+//        for Patterns, which we really probably do want at some point.\n+static bool\n+patterns_mergeable (HIR::Pattern *a, HIR::Pattern *b)\n+{\n+  if (!a || !b)\n+    return false;\n+\n+  HIR::Pattern::PatternType pat_type = a->get_pattern_type ();\n+  if (b->get_pattern_type () != pat_type)\n+    return false;\n+\n+  switch (pat_type)\n+    {\n+      case HIR::Pattern::PatternType::PATH: {\n+\t// FIXME: this is far too naive\n+\tHIR::PathPattern &aref = *static_cast<HIR::PathPattern *> (a);\n+\tHIR::PathPattern &bref = *static_cast<HIR::PathPattern *> (b);\n+\tif (aref.get_num_segments () != bref.get_num_segments ())\n+\t  return false;\n+\n+\tconst auto &asegs = aref.get_segments ();\n+\tconst auto &bsegs = bref.get_segments ();\n+\tfor (size_t i = 0; i < asegs.size (); i++)\n+\t  {\n+\t    if (asegs[i].as_string () != bsegs[i].as_string ())\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+      break;\n+      case HIR::Pattern::PatternType::LITERAL: {\n+\tHIR::LiteralPattern &aref = *static_cast<HIR::LiteralPattern *> (a);\n+\tHIR::LiteralPattern &bref = *static_cast<HIR::LiteralPattern *> (b);\n+\treturn aref.get_literal ().is_equal (bref.get_literal ());\n+      }\n+      break;\n+      case HIR::Pattern::PatternType::IDENTIFIER: {\n+\t// TODO\n+      }\n+      break;\n+    case HIR::Pattern::PatternType::WILDCARD:\n+      return true;\n+      break;\n+\n+      // TODO\n+\n+    default:;\n+    }\n+  return false;\n+}\n+\n+// A little container for rearranging the patterns and cases in a match\n+// expression while simplifying.\n+struct PatternMerge\n+{\n+  std::unique_ptr<HIR::MatchCase> wildcard;\n+  std::vector<std::unique_ptr<HIR::Pattern>> heads;\n+  std::vector<std::vector<HIR::MatchCase>> cases;\n+};\n+\n+// Helper for simplify_tuple_match.\n+// For each tuple pattern in a given match, pull out the first elt of the\n+// tuple and construct a new MatchCase with the remaining tuple elts as the\n+// pattern. Return a mapping from each _unique_ first tuple element to a\n+// vec of cases for a new match.\n+//\n+// FIXME: This used to be a std::map<Pattern, Vec<MatchCase>>, but it doesn't\n+// actually work like we want - the Pattern includes an HIR ID, which is unique\n+// per Pattern object. This means we don't have a good means for comparing\n+// Patterns. It would probably be best to actually implement a means of\n+// properly comparing patterns, and then use an actual map.\n+//\n+static struct PatternMerge\n+sort_tuple_patterns (HIR::MatchExpr &expr)\n+{\n+  rust_assert (expr.get_scrutinee_expr ()->get_expression_type ()\n+\t       == HIR::Expr::ExprType::Tuple);\n+\n+  struct PatternMerge result;\n+  result.wildcard = nullptr;\n+  result.heads = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+  result.cases = std::vector<std::vector<HIR::MatchCase>> ();\n+\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      HIR::MatchArm &case_arm = match_case.get_arm ();\n+\n+      // FIXME: Note we are only dealing with the first pattern in the arm.\n+      // The patterns vector in the arm might hold many patterns, which are the\n+      // patterns separated by the '|' token. Rustc abstracts these as \"Or\"\n+      // patterns, and part of its simplification process is to get rid of them.\n+      // We should get rid of the ORs too, maybe here or earlier than here?\n+      auto pat = case_arm.get_patterns ()[0]->clone_pattern ();\n+\n+      // Record wildcards so we can add them in inner matches.\n+      if (pat->get_pattern_type () == HIR::Pattern::PatternType::WILDCARD)\n+\t{\n+\t  // The *whole* pattern is a wild card (_).\n+\t  result.wildcard\n+\t    = std::unique_ptr<HIR::MatchCase> (new HIR::MatchCase (match_case));\n+\t  continue;\n+\t}\n+\n+      rust_assert (pat->get_pattern_type ()\n+\t\t   == HIR::Pattern::PatternType::TUPLE);\n+\n+      auto ref = *static_cast<HIR::TuplePattern *> (pat.get ());\n+\n+      rust_assert (ref.has_tuple_pattern_items ());\n+\n+      auto items\n+\t= HIR::TuplePattern (ref).get_items ()->clone_tuple_pattern_items ();\n+      if (items->get_pattern_type ()\n+\t  == HIR::TuplePatternItems::TuplePatternItemType::MULTIPLE)\n+\t{\n+\t  auto items_ref\n+\t    = *static_cast<HIR::TuplePatternItemsMultiple *> (items.get ());\n+\n+\t  // Pop the first pattern out\n+\t  auto patterns = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+\t  auto first = items_ref.get_patterns ()[0]->clone_pattern ();\n+\t  for (auto p = items_ref.get_patterns ().begin () + 1;\n+\t       p != items_ref.get_patterns ().end (); p++)\n+\t    {\n+\t      patterns.push_back ((*p)->clone_pattern ());\n+\t    }\n+\n+\t  // if there is only one pattern left, don't make a tuple out of it\n+\t  std::unique_ptr<HIR::Pattern> result_pattern;\n+\t  if (patterns.size () == 1)\n+\t    {\n+\t      result_pattern = std::move (patterns[0]);\n+\t    }\n+\t  else\n+\t    {\n+\t      auto new_items = std::unique_ptr<HIR::TuplePatternItems> (\n+\t\tnew HIR::TuplePatternItemsMultiple (std::move (patterns)));\n+\n+\t      // Construct a TuplePattern from the rest of the patterns\n+\t      result_pattern = std::unique_ptr<HIR::Pattern> (\n+\t\tnew HIR::TuplePattern (ref.get_pattern_mappings (),\n+\t\t\t\t       std::move (new_items),\n+\t\t\t\t       ref.get_locus ()));\n+\t    }\n+\n+\t  // I don't know why we need to make foo separately here but\n+\t  // using the { new_tuple } syntax in new_arm constructor does not\n+\t  // compile.\n+\t  auto foo = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+\t  foo.emplace_back (std::move (result_pattern));\n+\t  HIR::MatchArm new_arm (std::move (foo), Location (), nullptr,\n+\t\t\t\t AST::AttrVec ());\n+\n+\t  HIR::MatchCase new_case (match_case.get_mappings (), new_arm,\n+\t\t\t\t   match_case.get_expr ()->clone_expr ());\n+\n+\t  bool pushed = false;\n+\t  for (size_t i = 0; i < result.heads.size (); i++)\n+\t    {\n+\t      if (patterns_mergeable (result.heads[i].get (), first.get ()))\n+\t\t{\n+\t\t  result.cases[i].push_back (new_case);\n+\t\t  pushed = true;\n+\t\t}\n+\t    }\n+\n+\t  if (!pushed)\n+\t    {\n+\t      result.heads.push_back (std::move (first));\n+\t      result.cases.push_back ({new_case});\n+\t    }\n+\t}\n+      else /* TuplePatternItemType::RANGED */\n+\t{\n+\t  // FIXME\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+// Helper for CompileExpr::visit (HIR::MatchExpr).\n+// Given a MatchExpr where the scrutinee is some kind of tuple, build an\n+// equivalent match where only one element of the tuple is examined at a time.\n+// This resulting match can then be lowered to a SWITCH_EXPR tree directly.\n+//\n+// The approach is as follows:\n+// 1. Split the scrutinee and each pattern into the first (head) and the\n+//    rest (tail).\n+// 2. Build a mapping of unique pattern heads to the cases (tail and expr)\n+//    that shared that pattern head in the original match.\n+//    (This is the job of sort_tuple_patterns ()).\n+// 3. For each unique pattern head, build a new MatchCase where the pattern\n+//    is the unique head, and the expression is a new match where:\n+//    - The scrutinee is the tail of the original scrutinee\n+//    - The cases are are those built by the mapping in step 2, i.e. the\n+//      tails of the patterns and the corresponing expressions from the\n+//      original match expression.\n+// 4. Do this recursively for each inner match, until there is nothing more\n+//    to simplify.\n+// 5. Build the resulting match which scrutinizes the head of the original\n+//    scrutinee, using the cases built in step 3.\n+static HIR::MatchExpr\n+simplify_tuple_match (HIR::MatchExpr &expr)\n+{\n+  if (expr.get_scrutinee_expr ()->get_expression_type ()\n+      != HIR::Expr::ExprType::Tuple)\n+    return expr;\n+\n+  auto ref = *static_cast<HIR::TupleExpr *> (expr.get_scrutinee_expr ().get ());\n+\n+  auto &tail = ref.get_tuple_elems ();\n+  rust_assert (tail.size () > 1);\n+\n+  auto head = std::move (tail[0]);\n+  tail.erase (tail.begin (), tail.begin () + 1);\n+\n+  // e.g.\n+  // match (tupA, tupB, tupC) {\n+  //   (a1, b1, c1) => { blk1 },\n+  //   (a2, b2, c2) => { blk2 },\n+  //   (a1, b3, c3) => { blk3 },\n+  // }\n+  // tail = (tupB, tupC)\n+  // head = tupA\n+\n+  // Make sure the tail is only a tuple if it consists of at least 2 elements.\n+  std::unique_ptr<HIR::Expr> remaining;\n+  if (tail.size () == 1)\n+    remaining = std::move (tail[0]);\n+  else\n+    remaining = std::unique_ptr<HIR::Expr> (\n+      new HIR::TupleExpr (ref.get_mappings (), std::move (tail),\n+\t\t\t  AST::AttrVec (), ref.get_outer_attrs (),\n+\t\t\t  ref.get_locus ()));\n+\n+  // e.g.\n+  // a1 -> [(b1, c1) => { blk1 },\n+  //        (b3, c3) => { blk3 }]\n+  // a2 -> [(b2, c2) => { blk2 }]\n+  struct PatternMerge map = sort_tuple_patterns (expr);\n+\n+  std::vector<HIR::MatchCase> cases;\n+  // Construct the inner match for each unique first elt of the tuple\n+  // patterns\n+  for (size_t i = 0; i < map.heads.size (); i++)\n+    {\n+      auto inner_match_cases = map.cases[i];\n+\n+      // If there is a wildcard at the outer match level, then need to\n+      // propegate the wildcard case into *every* inner match.\n+      // FIXME: It is probably not correct to add this unconditionally, what if\n+      // we have a pattern like (a, _, c)? Then there is already a wildcard in\n+      // the inner matches, and having two will cause two 'default:' blocks\n+      // which is an error.\n+      if (map.wildcard != nullptr)\n+\t{\n+\t  inner_match_cases.push_back (*(map.wildcard.get ()));\n+\t}\n+\n+      // match (tupB, tupC) {\n+      //   (b1, c1) => { blk1 },\n+      //   (b3, c3) => { blk3 }\n+      // }\n+      HIR::MatchExpr inner_match (expr.get_mappings (),\n+\t\t\t\t  remaining->clone_expr (), inner_match_cases,\n+\t\t\t\t  AST::AttrVec (), expr.get_outer_attrs (),\n+\t\t\t\t  expr.get_locus ());\n+\n+      inner_match = simplify_tuple_match (inner_match);\n+\n+      auto outer_arm_pat = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+      outer_arm_pat.emplace_back (map.heads[i]->clone_pattern ());\n+\n+      HIR::MatchArm outer_arm (std::move (outer_arm_pat), expr.get_locus ());\n+\n+      // Need to move the inner match to the heap and put it in a unique_ptr to\n+      // build the actual match case of the outer expression\n+      // auto inner_expr = std::unique_ptr<HIR::Expr> (new HIR::MatchExpr\n+      // (inner_match));\n+      auto inner_expr = inner_match.clone_expr ();\n+\n+      // a1 => match (tupB, tupC) { ... }\n+      HIR::MatchCase outer_case (expr.get_mappings (), outer_arm,\n+\t\t\t\t std::move (inner_expr));\n+\n+      cases.push_back (outer_case);\n+    }\n+\n+  // If there was a wildcard, make sure to include it at the outer match level\n+  // too.\n+  if (map.wildcard != nullptr)\n+    {\n+      cases.push_back (*(map.wildcard.get ()));\n+    }\n+\n+  // match tupA {\n+  //   a1 => match (tupB, tupC) {\n+  //     (b1, c1) => { blk1 },\n+  //     (b3, c3) => { blk3 }\n+  //   }\n+  //   a2 => match (tupB, tupC) {\n+  //     (b2, c2) => { blk2 }\n+  //   }\n+  // }\n+  HIR::MatchExpr outer_match (expr.get_mappings (), std::move (head), cases,\n+\t\t\t      AST::AttrVec (), expr.get_outer_attrs (),\n+\t\t\t      expr.get_locus ());\n+\n+  return outer_match;\n+}\n \n // Helper for CompileExpr::visit (HIR::MatchExpr).\n // Check that the scrutinee of EXPR is a valid kind of expression to match on.\n@@ -315,6 +630,88 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \t  scrutinee_first_record_expr, 0,\n \t  expr.get_scrutinee_expr ()->get_locus ());\n     }\n+  else if (scrutinee_kind == TyTy::TypeKind::TUPLE)\n+    {\n+      // match on tuple becomes a series of nested switches, with one level\n+      // for each element of the tuple from left to right.\n+      auto exprtype = expr.get_scrutinee_expr ()->get_expression_type ();\n+      switch (exprtype)\n+\t{\n+\t  case HIR::Expr::ExprType::Tuple: {\n+\t    // Build an equivalent expression which is nicer to lower.\n+\t    HIR::MatchExpr outer_match = simplify_tuple_match (expr);\n+\n+\t    // We've rearranged the match into something that lowers better\n+\t    // to GENERIC trees.\n+\t    // For actually doing the lowering we need to compile the match\n+\t    // we've just made. But we're half-way through compiling the\n+\t    // original one.\n+\t    // ...\n+\t    // For now, let's just replace the original with the rearranged one\n+\t    // we just made, and compile that instead. What could go wrong? :)\n+\t    //\n+\t    // FIXME: What about when we decide a temporary is needed above?\n+\t    //        We might have already pushed a statement for it that\n+\t    //        we no longer need. Probably need to rearrange the order\n+\t    //        of these steps.\n+\t    expr = outer_match;\n+\n+\t    scrutinee_kind = check_match_scrutinee (expr, ctx);\n+\t    if (scrutinee_kind == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\ttranslated = error_mark_node;\n+\t\treturn;\n+\t      }\n+\n+\t    // Now compile the scrutinee of the simplified match.\n+\t    // FIXME: this part is duplicated from above.\n+\t    match_scrutinee_expr\n+\t      = CompileExpr::Compile (expr.get_scrutinee_expr ().get (), ctx);\n+\n+\t    if (TyTy::is_primitive_type_kind (scrutinee_kind))\n+\t      {\n+\t\tmatch_scrutinee_expr_qualifier_expr = match_scrutinee_expr;\n+\t      }\n+\t    else if (scrutinee_kind == TyTy::TypeKind::ADT)\n+\t      {\n+\t\t// need to access qualifier the field, if we use QUAL_UNION_TYPE\n+\t\t// this would be DECL_QUALIFIER i think. For now this will just\n+\t\t// access the first record field and its respective qualifier\n+\t\t// because it will always be set because this is all a big\n+\t\t// special union\n+\t\ttree scrutinee_first_record_expr\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    match_scrutinee_expr, 0,\n+\t\t    expr.get_scrutinee_expr ()->get_locus ());\n+\t\tmatch_scrutinee_expr_qualifier_expr\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    scrutinee_first_record_expr, 0,\n+\t\t    expr.get_scrutinee_expr ()->get_locus ());\n+\t      }\n+\t    else\n+\t      {\n+\t\t// FIXME: There are other cases, but it better not be a Tuple\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\t  case HIR::Expr::ExprType::Ident: {\n+\t    // FIXME\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::Expr::ExprType::Path: {\n+\t    // FIXME\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n   else\n     {\n       // FIXME: match on other types of expressions not yet implemented."}, {"sha": "1874062891267671b82c1cc3db5f56203dab6acd", "filename": "gcc/testsuite/rust/execute/torture/match_tuple1.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c4aa942fa828038106105524af2c568acca7ac/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_tuple1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c4aa942fa828038106105524af2c568acca7ac/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_tuple1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_tuple1.rs?ref=b7c4aa942fa828038106105524af2c568acca7ac", "patch": "@@ -0,0 +1,41 @@\n+// { dg-output \"x:15\\ny:20\\n\" }\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+enum Foo {\n+    A,\n+    B,\n+}\n+\n+fn inspect(f: Foo, g: u8) -> i32 {\n+    match (f, g) {\n+        (Foo::A, 1) => {\n+            return 5;\n+        }\n+\n+        (Foo::A, 2) => {\n+            return 10;\n+        }\n+\n+        (Foo::B, 2) => {\n+            return 15;\n+        }\n+\n+        _ => {\n+            return 20;\n+        }\n+    }\n+    return 25;\n+}\n+\n+fn main () -> i32 {\n+    let x = inspect (Foo::B, 2);\n+    let y = inspect (Foo::B, 1);\n+\n+    printf (\"x:%d\\n\" as *const str as *const i8, x);\n+    printf (\"y:%d\\n\" as *const str as *const i8, y);\n+\n+    y - x - 5\n+}"}]}