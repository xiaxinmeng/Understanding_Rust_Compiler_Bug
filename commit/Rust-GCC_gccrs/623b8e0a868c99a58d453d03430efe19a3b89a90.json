{"sha": "623b8e0a868c99a58d453d03430efe19a3b89a90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIzYjhlMGE4NjhjOTlhNThkNDUzZDAzNDMwZWZlMTlhM2I4OWE5MA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-05-13T10:44:17Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-05-13T10:44:17Z"}, "message": "Enhance dumps of IVOPTS\n\n\t* tree-ssa-loop-ivopts.c (avg_loop_niter): Fix coding style.\n\t(struct cost_pair): Change inv_expr_id (int) to inv_expr\n\t(iv_inv_expr_ent *).\n\t(struct iv_inv_expr_ent): Comment struct fields.\n\t(sort_iv_inv_expr_ent): New function.\n\t(struct ivopts_data): Rename inv_expr_id to max_inv_expr_id.\n\t(struct iv_ca): Replace used_inv_expr and num_used_inv_expr with\n\ta hash_map between iv_inv_expr_ent and number of usages.\n\t(niter_for_exit): Fix coding style.\n\t(tree_ssa_iv_optimize_init): Use renamed variable.\n\t(determine_base_object): Fix coding style.\n\t(alloc_iv): Likewise.\n\t(find_interesting_uses_outside): Likewise.\n\t(add_candidate_1): Likewise.\n\t(add_standard_iv_candidates): Likewise.\n\t(set_group_iv_cost): Replace inv_expr_id with inv_expr.\n\t(prepare_decl_rtl): Fix coding style.\n\t(get_address_cost): Likewise.\n\t(get_shiftadd_cost): Likewise.\n\t(force_expr_to_var_cost): Likewise.\n\t(compare_aff_trees): Likewise.\n\t(get_expr_id): Restructure the function.\n\t(get_loop_invariant_expr_id): Renamed to\n\tget_loop_invariant_expr.\n\t(get_computation_cost_at): Replace usage of inv_expr_id with\n\tinv_expr.\n\t(get_computation_cost): Likewise.\n\t(determine_group_iv_cost_generic): Likewise.\n\t(determine_group_iv_cost_address): Likewise.\n\t(iv_period): Fix coding style.\n\t(iv_elimination_compare_lt): Likewise.\n\t(may_eliminate_iv): Likewise.\n\t(determine_group_iv_cost_cond):  Replace usage of inv_expr_id with\n\tinv_expr.\n\t(determine_group_iv_costs): Dump invariant expressions.\n\t(iv_ca_recount_cost): Use the newly added hash_map.\n\t(iv_ca_set_remove_invariants): Fix coding style.\n\t(iv_ca_set_add_invariants): Fix coding style.\n\t(iv_ca_set_no_cp): Utilize the newly added hash_map for used\n\tinvariants.\n\t(iv_ca_set_cp): Likewise.\n\t(iv_ca_new): Initialize the newly added hash_map and remove\n\tinitialization of fields.\n\t(iv_ca_free): Delete the hash_map.\n\t(iv_ca_dump): Dump invariant expressions.\n\t(iv_ca_extend): Fix coding style.\n\t(try_add_cand_for): Likewise.\n\t(create_new_ivs): Dump information about # of avg iterations and\n\t# of used invariant expressions.\n\t(rewrite_use_compare): Fix coding style.\n\t(free_loop_data): Set default value for max_inv_expr_id.\n\t* g++.dg/tree-ssa/ivopts-3.C: Change test-case to follow\n\tthe new format of dump output.\n\nFrom-SVN: r236200", "tree": {"sha": "506428cf9979dfa3af8809df49af3b19c930ffe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/506428cf9979dfa3af8809df49af3b19c930ffe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/623b8e0a868c99a58d453d03430efe19a3b89a90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623b8e0a868c99a58d453d03430efe19a3b89a90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/623b8e0a868c99a58d453d03430efe19a3b89a90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623b8e0a868c99a58d453d03430efe19a3b89a90/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da7674f6a6bd485ee250f1dcd53daec68090827e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7674f6a6bd485ee250f1dcd53daec68090827e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da7674f6a6bd485ee250f1dcd53daec68090827e"}], "stats": {"total": 514, "additions": 316, "deletions": 198}, "files": [{"sha": "93ecfc99251e1e73b548e4f4f9023bb4274e5656", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=623b8e0a868c99a58d453d03430efe19a3b89a90", "patch": "@@ -1,3 +1,57 @@\n+2016-05-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (avg_loop_niter): Fix coding style.\n+\t(struct cost_pair): Change inv_expr_id (int) to inv_expr\n+\t(iv_inv_expr_ent *).\n+\t(struct iv_inv_expr_ent): Comment struct fields.\n+\t(sort_iv_inv_expr_ent): New function.\n+\t(struct ivopts_data): Rename inv_expr_id to max_inv_expr_id.\n+\t(struct iv_ca): Replace used_inv_expr and num_used_inv_expr with\n+\ta hash_map between iv_inv_expr_ent and number of usages.\n+\t(niter_for_exit): Fix coding style.\n+\t(tree_ssa_iv_optimize_init): Use renamed variable.\n+\t(determine_base_object): Fix coding style.\n+\t(alloc_iv): Likewise.\n+\t(find_interesting_uses_outside): Likewise.\n+\t(add_candidate_1): Likewise.\n+\t(add_standard_iv_candidates): Likewise.\n+\t(set_group_iv_cost): Replace inv_expr_id with inv_expr.\n+\t(prepare_decl_rtl): Fix coding style.\n+\t(get_address_cost): Likewise.\n+\t(get_shiftadd_cost): Likewise.\n+\t(force_expr_to_var_cost): Likewise.\n+\t(compare_aff_trees): Likewise.\n+\t(get_expr_id): Restructure the function.\n+\t(get_loop_invariant_expr_id): Renamed to\n+\tget_loop_invariant_expr.\n+\t(get_computation_cost_at): Replace usage of inv_expr_id with\n+\tinv_expr.\n+\t(get_computation_cost): Likewise.\n+\t(determine_group_iv_cost_generic): Likewise.\n+\t(determine_group_iv_cost_address): Likewise.\n+\t(iv_period): Fix coding style.\n+\t(iv_elimination_compare_lt): Likewise.\n+\t(may_eliminate_iv): Likewise.\n+\t(determine_group_iv_cost_cond):  Replace usage of inv_expr_id with\n+\tinv_expr.\n+\t(determine_group_iv_costs): Dump invariant expressions.\n+\t(iv_ca_recount_cost): Use the newly added hash_map.\n+\t(iv_ca_set_remove_invariants): Fix coding style.\n+\t(iv_ca_set_add_invariants): Fix coding style.\n+\t(iv_ca_set_no_cp): Utilize the newly added hash_map for used\n+\tinvariants.\n+\t(iv_ca_set_cp): Likewise.\n+\t(iv_ca_new): Initialize the newly added hash_map and remove\n+\tinitialization of fields.\n+\t(iv_ca_free): Delete the hash_map.\n+\t(iv_ca_dump): Dump invariant expressions.\n+\t(iv_ca_extend): Fix coding style.\n+\t(try_add_cand_for): Likewise.\n+\t(create_new_ivs): Dump information about # of avg iterations and\n+\t# of used invariant expressions.\n+\t(rewrite_use_compare): Fix coding style.\n+\t(free_loop_data): Set default value for max_inv_expr_id.\n+\n 2016-05-13  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* cse.c (rest_of_handle_cse): Use cleanup_cfg"}, {"sha": "a27da97d4e83daee658d1abcd2778c8e0c5edb39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=623b8e0a868c99a58d453d03430efe19a3b89a90", "patch": "@@ -1,3 +1,8 @@\n+2016-05-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* g++.dg/tree-ssa/ivopts-3.C: Change test-case to follow\n+\tthe new format of dump output.\n+\n 2016-05-13  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* gcc.dg/pr71084.c: New test."}, {"sha": "eb72581390bf3af9710224959cb3d7f495787e07", "filename": "gcc/testsuite/g++.dg/tree-ssa/ivopts-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fivopts-3.C?ref=623b8e0a868c99a58d453d03430efe19a3b89a90", "patch": "@@ -72,4 +72,4 @@ int main ( int , char** ) {\n \n // Verify that on x86_64 and i?86 we use a single IV for the innermost loop\n \n-// { dg-final { scan-tree-dump \"Selected IV set for loop \\[0-9\\]* at \\[^ \\]*:64, 1 IVs\" \"ivopts\" { target x86_64-*-* i?86-*-* } } }\n+// { dg-final { scan-tree-dump \"Selected IV set for loop \\[0-9\\]* at \\[^ \\]*:64, 3 avg niters, 1 expressions, 1 IVs\" \"ivopts\" { target x86_64-*-* i?86-*-* } } }"}, {"sha": "62b88350008721843edbbed1eec22935ad8567b9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 256, "deletions": 197, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623b8e0a868c99a58d453d03430efe19a3b89a90/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=623b8e0a868c99a58d453d03430efe19a3b89a90", "patch": "@@ -129,7 +129,7 @@ avg_loop_niter (struct loop *loop)\n     {\n       niter = max_stmt_executions_int (loop);\n       if (niter == -1 || niter > AVG_LOOP_NITER (loop))\n-        return AVG_LOOP_NITER (loop);\n+\treturn AVG_LOOP_NITER (loop);\n     }\n \n   return niter;\n@@ -184,6 +184,8 @@ struct comp_cost\n static const comp_cost no_cost = {0, 0, 0};\n static const comp_cost infinite_cost = {INFTY, INFTY, INFTY};\n \n+struct iv_inv_expr_ent;\n+\n /* The candidate - cost pair.  */\n struct cost_pair\n {\n@@ -195,7 +197,7 @@ struct cost_pair\n \t\t\t   the final value of the iv.  For iv elimination,\n \t\t\t   the new bound to compare with.  */\n   enum tree_code comp;\t/* For iv elimination, the comparison.  */\n-  int inv_expr_id;      /* Loop invariant expression id.  */\n+  iv_inv_expr_ent *inv_expr; /* Loop invariant expression.  */\n };\n \n /* Use.  */\n@@ -307,13 +309,36 @@ iv_common_cand_hasher::equal (const iv_common_cand *ccand1,\n }\n \n /* Loop invariant expression hashtable entry.  */\n+\n struct iv_inv_expr_ent\n {\n+  /* Tree expression of the entry.  */\n   tree expr;\n+  /* Unique indentifier.  */\n   int id;\n+  /* Hash value.  */\n   hashval_t hash;\n };\n \n+/* Sort iv_inv_expr_ent pair A and B by id field.  */\n+\n+static int\n+sort_iv_inv_expr_ent (const void *a, const void *b)\n+{\n+  const iv_inv_expr_ent * const *e1 = (const iv_inv_expr_ent * const *) (a);\n+  const iv_inv_expr_ent * const *e2 = (const iv_inv_expr_ent * const *) (b);\n+\n+  unsigned id1 = (*e1)->id;\n+  unsigned id2 = (*e2)->id;\n+\n+  if (id1 < id2)\n+    return -1;\n+  else if (id1 > id2)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n /* Hashtable helpers.  */\n \n struct iv_inv_expr_hasher : free_ptr_hash <iv_inv_expr_ent>\n@@ -363,7 +388,7 @@ struct ivopts_data\n   hash_table<iv_inv_expr_hasher> *inv_expr_tab;\n \n   /* Loop invariant expression id.  */\n-  int inv_expr_id;\n+  int max_inv_expr_id;\n \n   /* The bitmap of indices in version_info whose value was changed.  */\n   bitmap relevant;\n@@ -443,12 +468,8 @@ struct iv_ca\n   /* Number of times each invariant is used.  */\n   unsigned *n_invariant_uses;\n \n-  /* The array holding the number of uses of each loop\n-     invariant expressions created by ivopt.  */\n-  unsigned *used_inv_expr;\n-\n-  /* The number of created loop invariants.  */\n-  unsigned num_used_inv_expr;\n+  /* Hash set with used invariant expression.  */\n+  hash_map <iv_inv_expr_ent *, unsigned> *used_inv_exprs;\n \n   /* Total cost of the assignment.  */\n   comp_cost cost;\n@@ -840,8 +861,8 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n   if (!slot)\n     {\n       /* Try to determine number of iterations.  We cannot safely work with ssa\n-         names that appear in phi nodes on abnormal edges, so that we do not\n-         create overlapping life ranges for them (PR 27283).  */\n+\t names that appear in phi nodes on abnormal edges, so that we do not\n+\t create overlapping life ranges for them (PR 27283).  */\n       desc = XNEW (struct tree_niter_desc);\n       if (!number_of_iterations_exit (data->current_loop,\n \t\t\t\t      exit, desc, true)\n@@ -888,7 +909,7 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->vgroups.create (20);\n   data->vcands.create (20);\n   data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);\n-  data->inv_expr_id = 0;\n+  data->max_inv_expr_id = 0;\n   data->name_expansion_cache = NULL;\n   data->iv_common_cand_tab = new hash_table<iv_common_cand_hasher> (10);\n   data->iv_common_cands.create (20);\n@@ -930,7 +951,7 @@ determine_base_object (tree expr)\n \treturn determine_base_object (TREE_OPERAND (base, 0));\n \n       return fold_convert (ptr_type_node,\n-\t\t           build_fold_addr_expr (base));\n+\t\t\t   build_fold_addr_expr (base));\n \n     case POINTER_PLUS_EXPR:\n       return determine_base_object (TREE_OPERAND (expr, 0));\n@@ -989,7 +1010,7 @@ alloc_iv (struct ivopts_data *data, tree base, tree step,\n      By doing this:\n        1) More accurate cost can be computed for address expressions;\n        2) Duplicate candidates won't be created for bases in different\n-          forms, like &a[0] and &a.  */\n+\t  forms, like &a[0] and &a.  */\n   STRIP_NOPS (expr);\n   if ((TREE_CODE (expr) == ADDR_EXPR && !DECL_P (TREE_OPERAND (expr, 0)))\n       || contain_complex_addr_expr (expr))\n@@ -2265,7 +2286,7 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n       phi = psi.phi ();\n       def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n       if (!virtual_operand_p (def))\n-        find_interesting_uses_op (data, def);\n+\tfind_interesting_uses_op (data, def);\n     }\n }\n \n@@ -2785,8 +2806,8 @@ add_candidate_1 (struct ivopts_data *data,\n \n       if (operand_equal_p (base, cand->iv->base, 0)\n \t  && operand_equal_p (step, cand->iv->step, 0)\n-          && (TYPE_PRECISION (TREE_TYPE (base))\n-              == TYPE_PRECISION (TREE_TYPE (cand->iv->base))))\n+\t  && (TYPE_PRECISION (TREE_TYPE (base))\n+\t      == TYPE_PRECISION (TREE_TYPE (cand->iv->base))))\n \tbreak;\n     }\n \n@@ -2936,14 +2957,14 @@ add_standard_iv_candidates (struct ivopts_data *data)\n \n   /* The same for a double-integer type if it is still fast enough.  */\n   if (TYPE_PRECISION\n-        (long_integer_type_node) > TYPE_PRECISION (integer_type_node)\n+\t(long_integer_type_node) > TYPE_PRECISION (integer_type_node)\n       && TYPE_PRECISION (long_integer_type_node) <= BITS_PER_WORD)\n     add_candidate (data, build_int_cst (long_integer_type_node, 0),\n \t\t   build_int_cst (long_integer_type_node, 1), true, NULL);\n \n   /* The same for a double-integer type if it is still fast enough.  */\n   if (TYPE_PRECISION\n-        (long_long_integer_type_node) > TYPE_PRECISION (long_integer_type_node)\n+\t(long_long_integer_type_node) > TYPE_PRECISION (long_integer_type_node)\n       && TYPE_PRECISION (long_long_integer_type_node) <= BITS_PER_WORD)\n     add_candidate (data, build_int_cst (long_long_integer_type_node, 0),\n \t\t   build_int_cst (long_long_integer_type_node, 1), true, NULL);\n@@ -3329,7 +3350,7 @@ static void\n set_group_iv_cost (struct ivopts_data *data,\n \t\t   struct iv_group *group, struct iv_cand *cand,\n \t\t   comp_cost cost, bitmap depends_on, tree value,\n-\t\t   enum tree_code comp, int inv_expr_id)\n+\t\t   enum tree_code comp, iv_inv_expr_ent *inv_expr)\n {\n   unsigned i, s;\n \n@@ -3346,7 +3367,7 @@ set_group_iv_cost (struct ivopts_data *data,\n       group->cost_map[cand->id].depends_on = depends_on;\n       group->cost_map[cand->id].value = value;\n       group->cost_map[cand->id].comp = comp;\n-      group->cost_map[cand->id].inv_expr_id = inv_expr_id;\n+      group->cost_map[cand->id].inv_expr = inv_expr;\n       return;\n     }\n \n@@ -3367,7 +3388,7 @@ set_group_iv_cost (struct ivopts_data *data,\n   group->cost_map[i].depends_on = depends_on;\n   group->cost_map[i].value = value;\n   group->cost_map[i].comp = comp;\n-  group->cost_map[i].inv_expr_id = inv_expr_id;\n+  group->cost_map[i].inv_expr = inv_expr;\n }\n \n /* Gets cost of (GROUP, CAND) pair.  */\n@@ -3454,7 +3475,7 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n \tcontinue;\n       obj = *expr_p;\n       if (DECL_P (obj) && HAS_RTL_P (obj) && !DECL_RTL_SET_P (obj))\n-        x = produce_memory_decl_rtl (obj, regno);\n+\tx = produce_memory_decl_rtl (obj, regno);\n       break;\n \n     case SSA_NAME:\n@@ -3908,7 +3929,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t    }\n \t}\n       if (i == -1)\n-        off = 0;\n+\toff = 0;\n       data->max_offset = off;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4040,9 +4061,9 @@ get_address_cost (bool symbol_present, bool var_present,\n \t However, the symbol will have to be loaded in any case before the\n \t loop (and quite likely we have it in register already), so it does not\n \t make much sense to penalize them too heavily.  So make some final\n-         tweaks for the SYMBOL_PRESENT modes:\n+\t tweaks for the SYMBOL_PRESENT modes:\n \n-         If VAR_PRESENT is false, and the mode obtained by changing symbol to\n+\t If VAR_PRESENT is false, and the mode obtained by changing symbol to\n \t var is cheaper, use this mode with small penalty.\n \t If VAR_PRESENT is true, try whether the mode with\n \t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n@@ -4159,7 +4180,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \n static bool\n get_shiftadd_cost (tree expr, machine_mode mode, comp_cost cost0,\n-                   comp_cost cost1, tree mult, bool speed, comp_cost *cost)\n+\t\t   comp_cost cost1, tree mult, bool speed, comp_cost *cost)\n {\n   comp_cost res;\n   tree op1 = TREE_OPERAND (expr, 1);\n@@ -4181,10 +4202,10 @@ get_shiftadd_cost (tree expr, machine_mode mode, comp_cost cost0,\n   /* If the target has a cheap shift-and-add or shift-and-sub instruction,\n      use that in preference to a shift insn followed by an add insn.  */\n   sa_cost = (TREE_CODE (expr) != MINUS_EXPR\n-             ? shiftadd_cost (speed, mode, m)\n-             : (mult_in_op1\n-                ? shiftsub1_cost (speed, mode, m)\n-                : shiftsub0_cost (speed, mode, m)));\n+\t     ? shiftadd_cost (speed, mode, m)\n+\t     : (mult_in_op1\n+\t\t? shiftsub1_cost (speed, mode, m)\n+\t\t: shiftsub0_cost (speed, mode, m)));\n \n   res = new_cost (MIN (as_cost, sa_cost), 0);\n   res = add_costs (res, mult_in_op1 ? cost0 : cost1);\n@@ -4316,20 +4337,20 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case NEGATE_EXPR:\n       cost = new_cost (add_cost (speed, mode), 0);\n       if (TREE_CODE (expr) != NEGATE_EXPR)\n-        {\n-          tree mult = NULL_TREE;\n-          comp_cost sa_cost;\n-          if (TREE_CODE (op1) == MULT_EXPR)\n-            mult = op1;\n-          else if (TREE_CODE (op0) == MULT_EXPR)\n-            mult = op0;\n-\n-          if (mult != NULL_TREE\n-              && cst_and_fits_in_hwi (TREE_OPERAND (mult, 1))\n-              && get_shiftadd_cost (expr, mode, cost0, cost1, mult,\n-                                    speed, &sa_cost))\n-            return sa_cost;\n-        }\n+\t{\n+\t  tree mult = NULL_TREE;\n+\t  comp_cost sa_cost;\n+\t  if (TREE_CODE (op1) == MULT_EXPR)\n+\t    mult = op1;\n+\t  else if (TREE_CODE (op0) == MULT_EXPR)\n+\t    mult = op0;\n+\n+\t  if (mult != NULL_TREE\n+\t      && cst_and_fits_in_hwi (TREE_OPERAND (mult, 1))\n+\t      && get_shiftadd_cost (expr, mode, cost0, cost1, mult,\n+\t\t\t\t    speed, &sa_cost))\n+\t    return sa_cost;\n+\t}\n       break;\n \n     CASE_CONVERT:\n@@ -4543,44 +4564,46 @@ compare_aff_trees (aff_tree *aff1, aff_tree *aff2)\n   for (i = 0; i < aff1->n; i++)\n     {\n       if (aff1->elts[i].coef != aff2->elts[i].coef)\n-        return false;\n+\treturn false;\n \n       if (!operand_equal_p (aff1->elts[i].val, aff2->elts[i].val, 0))\n-        return false;\n+\treturn false;\n     }\n   return true;\n }\n \n-/* Stores EXPR in DATA->inv_expr_tab, and assigns it an inv_expr_id.  */\n+/* Stores EXPR in DATA->inv_expr_tab, return pointer to iv_inv_expr_ent.  */\n \n-static int\n-get_expr_id (struct ivopts_data *data, tree expr)\n+static iv_inv_expr_ent *\n+record_inv_expr (struct ivopts_data *data, tree expr)\n {\n   struct iv_inv_expr_ent ent;\n   struct iv_inv_expr_ent **slot;\n \n   ent.expr = expr;\n   ent.hash = iterative_hash_expr (expr, 0);\n   slot = data->inv_expr_tab->find_slot (&ent, INSERT);\n-  if (*slot)\n-    return (*slot)->id;\n \n-  *slot = XNEW (struct iv_inv_expr_ent);\n-  (*slot)->expr = expr;\n-  (*slot)->hash = ent.hash;\n-  (*slot)->id = data->inv_expr_id++;\n-  return (*slot)->id;\n+  if (!*slot)\n+    {\n+      *slot = XNEW (struct iv_inv_expr_ent);\n+      (*slot)->expr = expr;\n+      (*slot)->hash = ent.hash;\n+      (*slot)->id = data->max_inv_expr_id++;\n+    }\n+\n+  return *slot;\n }\n \n-/* Returns the pseudo expr id if expression UBASE - RATIO * CBASE\n+/* Returns the invariant expression if expression UBASE - RATIO * CBASE\n    requires a new compiler generated temporary.  Returns -1 otherwise.\n    ADDRESS_P is a flag indicating if the expression is for address\n    computation.  */\n \n-static int\n-get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n-                            tree cbase, HOST_WIDE_INT ratio,\n-                            bool address_p)\n+static iv_inv_expr_ent *\n+get_loop_invariant_expr (struct ivopts_data *data, tree ubase,\n+\t\t\t tree cbase, HOST_WIDE_INT ratio,\n+\t\t\t bool address_p)\n {\n   aff_tree ubase_aff, cbase_aff;\n   tree expr, ub, cb;\n@@ -4592,15 +4615,15 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n \n   if ((TREE_CODE (ubase) == INTEGER_CST)\n       && (TREE_CODE (cbase) == INTEGER_CST))\n-    return -1;\n+    return NULL;\n \n   /* Strips the constant part. */\n   if (TREE_CODE (ubase) == PLUS_EXPR\n       || TREE_CODE (ubase) == MINUS_EXPR\n       || TREE_CODE (ubase) == POINTER_PLUS_EXPR)\n     {\n       if (TREE_CODE (TREE_OPERAND (ubase, 1)) == INTEGER_CST)\n-        ubase = TREE_OPERAND (ubase, 0);\n+\tubase = TREE_OPERAND (ubase, 0);\n     }\n \n   /* Strips the constant part. */\n@@ -4609,60 +4632,60 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n       || TREE_CODE (cbase) == POINTER_PLUS_EXPR)\n     {\n       if (TREE_CODE (TREE_OPERAND (cbase, 1)) == INTEGER_CST)\n-        cbase = TREE_OPERAND (cbase, 0);\n+\tcbase = TREE_OPERAND (cbase, 0);\n     }\n \n   if (address_p)\n     {\n       if (((TREE_CODE (ubase) == SSA_NAME)\n-           || (TREE_CODE (ubase) == ADDR_EXPR\n-               && is_gimple_min_invariant (ubase)))\n-          && (TREE_CODE (cbase) == INTEGER_CST))\n-        return -1;\n+\t   || (TREE_CODE (ubase) == ADDR_EXPR\n+\t       && is_gimple_min_invariant (ubase)))\n+\t  && (TREE_CODE (cbase) == INTEGER_CST))\n+\treturn NULL;\n \n       if (((TREE_CODE (cbase) == SSA_NAME)\n-           || (TREE_CODE (cbase) == ADDR_EXPR\n-               && is_gimple_min_invariant (cbase)))\n-          && (TREE_CODE (ubase) == INTEGER_CST))\n-        return -1;\n+\t   || (TREE_CODE (cbase) == ADDR_EXPR\n+\t       && is_gimple_min_invariant (cbase)))\n+\t  && (TREE_CODE (ubase) == INTEGER_CST))\n+\treturn NULL;\n     }\n \n   if (ratio == 1)\n     {\n       if (operand_equal_p (ubase, cbase, 0))\n-        return -1;\n+\treturn NULL;\n \n       if (TREE_CODE (ubase) == ADDR_EXPR\n-          && TREE_CODE (cbase) == ADDR_EXPR)\n-        {\n-          tree usym, csym;\n-\n-          usym = TREE_OPERAND (ubase, 0);\n-          csym = TREE_OPERAND (cbase, 0);\n-          if (TREE_CODE (usym) == ARRAY_REF)\n-            {\n-              tree ind = TREE_OPERAND (usym, 1);\n-              if (TREE_CODE (ind) == INTEGER_CST\n-                  && tree_fits_shwi_p (ind)\n-                  && tree_to_shwi (ind) == 0)\n-                usym = TREE_OPERAND (usym, 0);\n-            }\n-          if (TREE_CODE (csym) == ARRAY_REF)\n-            {\n-              tree ind = TREE_OPERAND (csym, 1);\n-              if (TREE_CODE (ind) == INTEGER_CST\n-                  && tree_fits_shwi_p (ind)\n-                  && tree_to_shwi (ind) == 0)\n-                csym = TREE_OPERAND (csym, 0);\n-            }\n-          if (operand_equal_p (usym, csym, 0))\n-            return -1;\n-        }\n+\t  && TREE_CODE (cbase) == ADDR_EXPR)\n+\t{\n+\t  tree usym, csym;\n+\n+\t  usym = TREE_OPERAND (ubase, 0);\n+\t  csym = TREE_OPERAND (cbase, 0);\n+\t  if (TREE_CODE (usym) == ARRAY_REF)\n+\t    {\n+\t      tree ind = TREE_OPERAND (usym, 1);\n+\t      if (TREE_CODE (ind) == INTEGER_CST\n+\t\t  && tree_fits_shwi_p (ind)\n+\t\t  && tree_to_shwi (ind) == 0)\n+\t\tusym = TREE_OPERAND (usym, 0);\n+\t    }\n+\t  if (TREE_CODE (csym) == ARRAY_REF)\n+\t    {\n+\t      tree ind = TREE_OPERAND (csym, 1);\n+\t      if (TREE_CODE (ind) == INTEGER_CST\n+\t\t  && tree_fits_shwi_p (ind)\n+\t\t  && tree_to_shwi (ind) == 0)\n+\t\tcsym = TREE_OPERAND (csym, 0);\n+\t    }\n+\t  if (operand_equal_p (usym, csym, 0))\n+\t    return NULL;\n+\t}\n       /* Now do more complex comparison  */\n       tree_to_aff_combination (ubase, TREE_TYPE (ubase), &ubase_aff);\n       tree_to_aff_combination (cbase, TREE_TYPE (cbase), &cbase_aff);\n       if (compare_aff_trees (&ubase_aff, &cbase_aff))\n-        return -1;\n+\treturn NULL;\n     }\n \n   tree_to_aff_combination (ub, TREE_TYPE (ub), &ubase_aff);\n@@ -4671,7 +4694,7 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n   aff_combination_scale (&cbase_aff, -1 * ratio);\n   aff_combination_add (&ubase_aff, &cbase_aff);\n   expr = aff_combination_to_tree (&ubase_aff);\n-  return get_expr_id (data, expr);\n+  return record_inv_expr (data, expr);\n }\n \n \n@@ -4689,7 +4712,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t struct iv_use *use, struct iv_cand *cand,\n \t\t\t bool address_p, bitmap *depends_on, gimple *at,\n \t\t\t bool *can_autoinc,\n-                         int *inv_expr_id)\n+\t\t\t iv_inv_expr_ent **inv_expr)\n {\n   tree ubase = use->iv->base, ustep = use->iv->step;\n   tree cbase, cstep;\n@@ -4790,17 +4813,17 @@ get_computation_cost_at (struct ivopts_data *data,\n \n       /* Check to see if any adjustment is needed.  */\n       if (cstepi == 0 && stmt_is_after_inc)\n-        {\n-          aff_tree real_cbase_aff;\n-          aff_tree cstep_aff;\n+\t{\n+\t  aff_tree real_cbase_aff;\n+\t  aff_tree cstep_aff;\n \n-          tree_to_aff_combination (cbase, TREE_TYPE (real_cbase),\n-                                   &real_cbase_aff);\n-          tree_to_aff_combination (cstep, TREE_TYPE (cstep), &cstep_aff);\n+\t  tree_to_aff_combination (cbase, TREE_TYPE (real_cbase),\n+\t\t\t\t   &real_cbase_aff);\n+\t  tree_to_aff_combination (cstep, TREE_TYPE (cstep), &cstep_aff);\n \n-          aff_combination_add (&real_cbase_aff, &cstep_aff);\n-          real_cbase = aff_combination_to_tree (&real_cbase_aff);\n-        }\n+\t  aff_combination_add (&real_cbase_aff, &cstep_aff);\n+\t  real_cbase = aff_combination_to_tree (&real_cbase_aff);\n+\t}\n \n       cost = difference_cost (data,\n \t\t\t      ubase, real_cbase,\n@@ -4846,13 +4869,13 @@ get_computation_cost_at (struct ivopts_data *data,\n   /* Record setup cost in scrach field.  */\n   cost.scratch = cost.cost;\n \n-  if (inv_expr_id && depends_on && *depends_on)\n+  if (inv_expr && depends_on && *depends_on)\n     {\n-      *inv_expr_id =\n-          get_loop_invariant_expr_id (data, ubase, cbase, ratio, address_p);\n+      *inv_expr = get_loop_invariant_expr (data, ubase, cbase, ratio,\n+\t\t\t\t\t   address_p);\n       /* Clear depends on.  */\n-      if (*inv_expr_id != -1)\n-        bitmap_clear (*depends_on);\n+      if (inv_expr != NULL)\n+\tbitmap_clear (*depends_on);\n     }\n \n   /* If we are after the increment, the value of the candidate is higher by\n@@ -4929,11 +4952,11 @@ static comp_cost\n get_computation_cost (struct ivopts_data *data,\n \t\t      struct iv_use *use, struct iv_cand *cand,\n \t\t      bool address_p, bitmap *depends_on,\n-                      bool *can_autoinc, int *inv_expr_id)\n+\t\t      bool *can_autoinc, iv_inv_expr_ent **inv_expr)\n {\n   return get_computation_cost_at (data,\n \t\t\t\t  use, cand, address_p, depends_on, use->stmt,\n-\t\t\t\t  can_autoinc, inv_expr_id);\n+\t\t\t\t  can_autoinc, inv_expr);\n }\n \n /* Determines cost of computing the use in GROUP with CAND in a generic\n@@ -4944,7 +4967,7 @@ determine_group_iv_cost_generic (struct ivopts_data *data,\n \t\t\t\t struct iv_group *group, struct iv_cand *cand)\n {\n   comp_cost cost;\n-  int inv_expr_id = -1;\n+  iv_inv_expr_ent *inv_expr = NULL;\n   bitmap depends_on = NULL;\n   struct iv_use *use = group->vuses[0];\n \n@@ -4956,10 +4979,10 @@ determine_group_iv_cost_generic (struct ivopts_data *data,\n     cost = no_cost;\n   else\n     cost = get_computation_cost (data, use, cand, false,\n-\t\t\t\t &depends_on, NULL, &inv_expr_id);\n+\t\t\t\t &depends_on, NULL, &inv_expr);\n \n   set_group_iv_cost (data, group, cand, cost, depends_on,\n-\t\t     NULL_TREE, ERROR_MARK, inv_expr_id);\n+\t\t     NULL_TREE, ERROR_MARK, inv_expr);\n   return !infinite_cost_p (cost);\n }\n \n@@ -4972,12 +4995,12 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n   unsigned i;\n   bitmap depends_on;\n   bool can_autoinc, first = true;\n-  int inv_expr_id = -1;\n+  iv_inv_expr_ent *inv_expr = NULL;\n   struct iv_use *use = group->vuses[0];\n   comp_cost sum_cost = no_cost, cost;\n \n   cost = get_computation_cost (data, use, cand, true,\n-\t\t\t       &depends_on, &can_autoinc, &inv_expr_id);\n+\t\t\t       &depends_on, &can_autoinc, &inv_expr);\n \n   sum_cost = cost;\n   if (!infinite_cost_p (sum_cost) && cand->ainc_use == use)\n@@ -5025,7 +5048,7 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n       sum_cost = add_costs (sum_cost, cost);\n     }\n   set_group_iv_cost (data, group, cand, sum_cost, depends_on,\n-\t\t     NULL_TREE, ERROR_MARK, inv_expr_id);\n+\t\t     NULL_TREE, ERROR_MARK, inv_expr);\n \n   return !infinite_cost_p (sum_cost);\n }\n@@ -5081,8 +5104,8 @@ iv_period (struct iv *iv)\n   pow2div = num_ending_zeros (step);\n \n   period = build_low_bits_mask (type,\n-                                (TYPE_PRECISION (type)\n-                                 - tree_to_uhwi (pow2div)));\n+\t\t\t\t(TYPE_PRECISION (type)\n+\t\t\t\t - tree_to_uhwi (pow2div)));\n \n   return period;\n }\n@@ -5215,7 +5238,7 @@ difference_cannot_overflow_p (struct ivopts_data *data, tree base, tree offset)\n \n static bool\n iv_elimination_compare_lt (struct ivopts_data *data,\n-                           struct iv_cand *cand, enum tree_code *comp_p,\n+\t\t\t   struct iv_cand *cand, enum tree_code *comp_p,\n \t\t\t   struct tree_niter_desc *niter)\n {\n   tree cand_type, a, b, mbz, nit_type = TREE_TYPE (niter->niter), offset;\n@@ -5264,10 +5287,10 @@ iv_elimination_compare_lt (struct ivopts_data *data,\n \n       /* Handle b < a + 1.  */\n       if (TREE_CODE (op1) == PLUS_EXPR && integer_onep (TREE_OPERAND (op1, 1)))\n-        {\n-          a = TREE_OPERAND (op1, 0);\n-          b = TREE_OPERAND (mbz, 0);\n-        }\n+\t{\n+\t  a = TREE_OPERAND (op1, 0);\n+\t  b = TREE_OPERAND (mbz, 0);\n+\t}\n       else\n \treturn false;\n     }\n@@ -5353,15 +5376,15 @@ may_eliminate_iv (struct ivopts_data *data,\n     {\n       /* See cand_value_at.  */\n       if (stmt_after_increment (loop, cand, use->stmt))\n-        {\n-          if (!tree_int_cst_lt (desc->niter, period))\n-            return false;\n-        }\n+\t{\n+\t  if (!tree_int_cst_lt (desc->niter, period))\n+\t    return false;\n+\t}\n       else\n-        {\n-          if (tree_int_cst_lt (period, desc->niter))\n-            return false;\n-        }\n+\t{\n+\t  if (tree_int_cst_lt (period, desc->niter))\n+\t    return false;\n+\t}\n     }\n \n   /* If not, and if this is the only possible exit of the loop, see whether\n@@ -5373,22 +5396,23 @@ may_eliminate_iv (struct ivopts_data *data,\n \n       max_niter = desc->max;\n       if (stmt_after_increment (loop, cand, use->stmt))\n-        max_niter += 1;\n+\tmax_niter += 1;\n       period_value = wi::to_widest (period);\n       if (wi::gtu_p (max_niter, period_value))\n-        {\n-          /* See if we can take advantage of inferred loop bound information.  */\n-          if (data->loop_single_exit_p)\n-            {\n-              if (!max_loop_iterations (loop, &max_niter))\n-                return false;\n-              /* The loop bound is already adjusted by adding 1.  */\n-              if (wi::gtu_p (max_niter, period_value))\n-                return false;\n-            }\n-          else\n-            return false;\n-        }\n+\t{\n+\t  /* See if we can take advantage of inferred loop bound\n+\t     information.  */\n+\t  if (data->loop_single_exit_p)\n+\t    {\n+\t      if (!max_loop_iterations (loop, &max_niter))\n+\t\treturn false;\n+\t      /* The loop bound is already adjusted by adding 1.  */\n+\t      if (wi::gtu_p (max_niter, period_value))\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n     }\n \n   cand_value_at (loop, cand, use->stmt, desc->niter, &bnd);\n@@ -5444,7 +5468,7 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n   bitmap depends_on_elim = NULL, depends_on_express = NULL, depends_on;\n   comp_cost elim_cost, express_cost, cost, bound_cost;\n   bool ok;\n-  int elim_inv_expr_id = -1, express_inv_expr_id = -1, inv_expr_id;\n+  iv_inv_expr_ent *elim_inv_expr = NULL, *express_inv_expr = NULL, *inv_expr;\n   tree *control_var, *bound_cst;\n   enum tree_code comp = ERROR_MARK;\n   struct iv_use *use = group->vuses[0];\n@@ -5456,18 +5480,18 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n     {\n       elim_cost = force_var_cost (data, bound, &depends_on_elim);\n       if (elim_cost.cost == 0)\n-        elim_cost.cost = parm_decl_cost (data, bound);\n+\telim_cost.cost = parm_decl_cost (data, bound);\n       else if (TREE_CODE (bound) == INTEGER_CST)\n-        elim_cost.cost = 0;\n+\telim_cost.cost = 0;\n       /* If we replace a loop condition 'i < n' with 'p < base + n',\n \t depends_on_elim will have 'base' and 'n' set, which implies\n \t that both 'base' and 'n' will be live during the loop.\t More likely,\n \t 'base + n' will be loop invariant, resulting in only one live value\n \t during the loop.  So in that case we clear depends_on_elim and set\n-        elim_inv_expr_id instead.  */\n+\telim_inv_expr_id instead.  */\n       if (depends_on_elim && bitmap_count_bits (depends_on_elim) > 1)\n \t{\n-\t  elim_inv_expr_id = get_expr_id (data, bound);\n+\t  elim_inv_expr = record_inv_expr (data, bound);\n \t  bitmap_clear (depends_on_elim);\n \t}\n       /* The bound is a loop invariant, so it will be only computed\n@@ -5497,7 +5521,7 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n \n   express_cost = get_computation_cost (data, use, cand, false,\n \t\t\t\t       &depends_on_express, NULL,\n-                                       &express_inv_expr_id);\n+\t\t\t\t       &express_inv_expr);\n   fd_ivopts_data = data;\n   walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n \n@@ -5515,7 +5539,7 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n       cost = elim_cost;\n       depends_on = depends_on_elim;\n       depends_on_elim = NULL;\n-      inv_expr_id = elim_inv_expr_id;\n+      inv_expr = elim_inv_expr;\n     }\n   else\n     {\n@@ -5524,11 +5548,11 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n       depends_on_express = NULL;\n       bound = NULL_TREE;\n       comp = ERROR_MARK;\n-      inv_expr_id = express_inv_expr_id;\n+      inv_expr = express_inv_expr;\n     }\n \n   set_group_iv_cost (data, group, cand, cost,\n-\t\t     depends_on, bound, comp, inv_expr_id);\n+\t\t     depends_on, bound, comp, inv_expr);\n \n   if (depends_on_elim)\n     BITMAP_FREE (depends_on_elim);\n@@ -5718,14 +5742,31 @@ determine_group_iv_costs (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"<Group-candidate Costs>:\\n\");\n+      fprintf (dump_file, \"\\n<Invariant Expressions>:\\n\");\n+      auto_vec <iv_inv_expr_ent *> list (data->inv_expr_tab->elements ());\n+\n+      for (hash_table<iv_inv_expr_hasher>::iterator it\n+\t   = data->inv_expr_tab->begin (); it != data->inv_expr_tab->end ();\n+\t   ++it)\n+\tlist.safe_push (*it);\n+\n+      list.qsort (sort_iv_inv_expr_ent);\n+\n+      for (i = 0; i < list.length (); ++i)\n+\t{\n+\t  fprintf (dump_file, \"inv_expr %d: \\t\", i);\n+\t  print_generic_expr (dump_file, list[i]->expr, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      fprintf (dump_file, \"\\n<Group-candidate Costs>:\\n\");\n \n       for (i = 0; i < data->vgroups.length (); i++)\n \t{\n \t  group = data->vgroups[i];\n \n \t  fprintf (dump_file, \"Group %d:\\n\", i);\n-\t  fprintf (dump_file, \"  cand\\tcost\\tcompl.\\tdepends on\\n\");\n+\t  fprintf (dump_file, \"  cand\\tcost\\tcompl.\\tinv.ex.\\tdepends on\\n\");\n \t  for (j = 0; j < group->n_map_members; j++)\n \t    {\n \t      if (!group->cost_map[j].cand\n@@ -5736,12 +5777,14 @@ determine_group_iv_costs (struct ivopts_data *data)\n \t\t       group->cost_map[j].cand->id,\n \t\t       group->cost_map[j].cost.cost,\n \t\t       group->cost_map[j].cost.complexity);\n+\t      if (group->cost_map[j].inv_expr != NULL)\n+\t\tfprintf (dump_file, \"%d\\t\",\n+\t\t\t group->cost_map[j].inv_expr->id);\n+\t      else\n+\t\tfprintf (dump_file, \"\\t\");\n \t      if (group->cost_map[j].depends_on)\n \t\tbitmap_print (dump_file,\n \t\t\t      group->cost_map[j].depends_on, \"\",\"\");\n-\t      if (group->cost_map[j].inv_expr_id != -1)\n-\t\tfprintf (dump_file, \" inv_expr:%d\",\n-\t\t\t group->cost_map[j].inv_expr_id);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n@@ -5942,7 +5985,8 @@ iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n   cost.cost += ivs->cand_cost;\n \n   cost.cost += ivopts_global_cost_for_size (data,\n-                                            ivs->n_regs + ivs->num_used_inv_expr);\n+\t\t\t\t\t    ivs->n_regs\n+\t\t\t\t\t    + ivs->used_inv_exprs->elements ());\n \n   ivs->cost = cost;\n }\n@@ -5962,7 +6006,7 @@ iv_ca_set_remove_invariants (struct iv_ca *ivs, bitmap invs)\n     {\n       ivs->n_invariant_uses[iid]--;\n       if (ivs->n_invariant_uses[iid] == 0)\n-        ivs->n_regs--;\n+\tivs->n_regs--;\n     }\n }\n \n@@ -6000,11 +6044,12 @@ iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n \n   iv_ca_set_remove_invariants (ivs, cp->depends_on);\n \n-  if (cp->inv_expr_id != -1)\n+  if (cp->inv_expr != NULL)\n     {\n-      ivs->used_inv_expr[cp->inv_expr_id]--;\n-      if (ivs->used_inv_expr[cp->inv_expr_id] == 0)\n-        ivs->num_used_inv_expr--;\n+      unsigned *slot = ivs->used_inv_exprs->get (cp->inv_expr);\n+      --(*slot);\n+      if (*slot == 0)\n+\tivs->used_inv_exprs->remove (cp->inv_expr);\n     }\n   iv_ca_recount_cost (data, ivs);\n }\n@@ -6024,7 +6069,7 @@ iv_ca_set_add_invariants (struct iv_ca *ivs, bitmap invs)\n     {\n       ivs->n_invariant_uses[iid]++;\n       if (ivs->n_invariant_uses[iid] == 1)\n-        ivs->n_regs++;\n+\tivs->n_regs++;\n     }\n }\n \n@@ -6064,12 +6109,11 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n       ivs->cand_use_cost = add_costs (ivs->cand_use_cost, cp->cost);\n       iv_ca_set_add_invariants (ivs, cp->depends_on);\n \n-      if (cp->inv_expr_id != -1)\n-        {\n-          ivs->used_inv_expr[cp->inv_expr_id]++;\n-          if (ivs->used_inv_expr[cp->inv_expr_id] == 1)\n-            ivs->num_used_inv_expr++;\n-        }\n+      if (cp->inv_expr != NULL)\n+\t{\n+\t  unsigned *slot = &ivs->used_inv_exprs->get_or_insert (cp->inv_expr);\n+\t  ++(*slot);\n+\t}\n       iv_ca_recount_cost (data, ivs);\n     }\n }\n@@ -6278,9 +6322,8 @@ iv_ca_new (struct ivopts_data *data)\n   nw->cand_use_cost = no_cost;\n   nw->cand_cost = 0;\n   nw->n_invariant_uses = XCNEWVEC (unsigned, data->max_inv_id + 1);\n+  nw->used_inv_exprs = new hash_map <iv_inv_expr_ent *, unsigned> (13);\n   nw->cost = no_cost;\n-  nw->used_inv_expr = XCNEWVEC (unsigned, data->inv_expr_id + 1);\n-  nw->num_used_inv_expr = 0;\n \n   return nw;\n }\n@@ -6294,7 +6337,7 @@ iv_ca_free (struct iv_ca **ivs)\n   free ((*ivs)->n_cand_uses);\n   BITMAP_FREE ((*ivs)->cands);\n   free ((*ivs)->n_invariant_uses);\n-  free ((*ivs)->used_inv_expr);\n+  delete ((*ivs)->used_inv_exprs);\n   free (*ivs);\n   *ivs = NULL;\n }\n@@ -6304,13 +6347,13 @@ iv_ca_free (struct iv_ca **ivs)\n static void\n iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n {\n-  const char *pref = \"  invariants \";\n   unsigned i;\n   comp_cost cost = iv_ca_cost (ivs);\n \n   fprintf (file, \"  cost: %d (complexity %d)\\n\", cost.cost, cost.complexity);\n   fprintf (file, \"  cand_cost: %d\\n  cand_group_cost: %d (complexity %d)\\n\",\n-           ivs->cand_cost, ivs->cand_use_cost.cost, ivs->cand_use_cost.complexity);\n+\t   ivs->cand_cost, ivs->cand_use_cost.cost,\n+\t   ivs->cand_use_cost.complexity);\n   bitmap_print (file, ivs->cands, \"  candidates: \",\"\\n\");\n \n   for (i = 0; i < ivs->upto; i++)\n@@ -6324,12 +6367,24 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n \tfprintf (file, \"   group:%d --> ??\\n\", group->id);\n     }\n \n+  const char *pref = \"\";\n+  fprintf (file, \"  invariant variables: \");\n   for (i = 1; i <= data->max_inv_id; i++)\n     if (ivs->n_invariant_uses[i])\n       {\n \tfprintf (file, \"%s%d\", pref, i);\n \tpref = \", \";\n       }\n+\n+  pref = \"\";\n+  fprintf (file, \"\\n  invariant expressions: \");\n+  for (hash_map<iv_inv_expr_ent *, unsigned>::iterator it\n+       = ivs->used_inv_exprs->begin (); it != ivs->used_inv_exprs->end (); ++it)\n+    {\n+\tfprintf (file, \"%s%d\", pref, (*it).first->id);\n+\tpref = \", \";\n+    }\n+\n   fprintf (file, \"\\n\\n\");\n }\n \n@@ -6366,7 +6421,7 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n \tcontinue;\n \n       if (!min_ncand && !cheaper_cost_pair (new_cp, old_cp))\n-        continue;\n+\tcontinue;\n \n       *delta = iv_ca_delta_add (group, old_cp, new_cp, *delta);\n     }\n@@ -6670,15 +6725,15 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \tcontinue;\n \n       if (iv_ca_cand_used_p (ivs, cand))\n-        continue;\n+\tcontinue;\n \n       cp = get_group_iv_cost (data, group, cand);\n       if (!cp)\n \tcontinue;\n \n       iv_ca_set_cp (data, ivs, group, cp);\n       act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL,\n-                               true);\n+\t\t\t       true);\n       iv_ca_set_no_cp (data, ivs, group);\n       act_delta = iv_ca_delta_add (group, NULL, cp, act_delta);\n \n@@ -6991,12 +7046,16 @@ create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n       if (data->loop_loc != UNKNOWN_LOCATION)\n \tfprintf (dump_file, \" at %s:%d\", LOCATION_FILE (data->loop_loc),\n \t\t LOCATION_LINE (data->loop_loc));\n+      fprintf (dump_file, \", %lu avg niters\",\n+\t       avg_loop_niter (data->current_loop));\n+      fprintf (dump_file, \", %lu expressions\",\n+\t       set->used_inv_exprs->elements ());\n       fprintf (dump_file, \", %lu IVs:\\n\", bitmap_count_bits (set->cands));\n       EXECUTE_IF_SET_IN_BITMAP (set->cands, 0, i, bi)\n-        {\n-          cand = data->vcands[i];\n-          dump_cand (dump_file, cand);\n-        }\n+\t{\n+\t  cand = data->vcands[i];\n+\t  dump_cand (dump_file, cand);\n+\t}\n       fprintf (dump_file, \"\\n\");\n     }\n }\n@@ -7251,10 +7310,10 @@ rewrite_use_compare (struct ivopts_data *data,\n       gimple_seq stmts;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"Replacing exit test: \");\n-          print_gimple_stmt (dump_file, use->stmt, 0, TDF_SLIM);\n-        }\n+\t{\n+\t  fprintf (dump_file, \"Replacing exit test: \");\n+\t  print_gimple_stmt (dump_file, use->stmt, 0, TDF_SLIM);\n+\t}\n       compare = cp->comp;\n       bound = unshare_expr (fold_convert (var_type, bound));\n       op = force_gimple_operand (bound, &stmts, true, NULL_TREE);\n@@ -7542,7 +7601,7 @@ free_loop_data (struct ivopts_data *data)\n   decl_rtl_to_reset.truncate (0);\n \n   data->inv_expr_tab->empty ();\n-  data->inv_expr_id = 0;\n+  data->max_inv_expr_id = 0;\n \n   data->iv_common_cand_tab->empty ();\n   data->iv_common_cands.truncate (0);"}]}