{"sha": "c2cba7a96e04069011ae508e3027bbf128208040", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJjYmE3YTk2ZTA0MDY5MDExYWU1MDhlMzAyN2JiZjEyODIwODA0MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-29T00:44:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-29T00:44:21Z"}, "message": "local-alloc.c (requires_inout): Don't use reserved range for EXTRA_CONSTRAINTS...\n\n        * local-alloc.c (requires_inout): Don't use reserved range for\n        EXTRA_CONSTRAINTS; use anything not matched by REG_CLASS_FROM_LETTER.\n        * recog.c (asm_operand_ok): Likewise.\n        (preprocess_constraints, constrain_operands): Likewise.\n        * regclass.c (record_reg_classes): Likewise.\n        * reload.c (find_reloads): Likewise.\n        * reload1.c (maybe_fix_stack_asms): Likewise.\n        (reload_cse_simplify_operands): Likewise.\n        * stmt.c (expand_asm_operands): Likewise.\n\n        * md.texi: Update constraints documentation.\n        * tm.texi (EXTRA_CONSTRAINT): Update.\n\nFrom-SVN: r36023", "tree": {"sha": "d7a7f8b66cdb1d768634a359009e273bb3b645dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7a7f8b66cdb1d768634a359009e273bb3b645dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2cba7a96e04069011ae508e3027bbf128208040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2cba7a96e04069011ae508e3027bbf128208040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2cba7a96e04069011ae508e3027bbf128208040", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2cba7a96e04069011ae508e3027bbf128208040/comments", "author": null, "committer": null, "parents": [{"sha": "881c6935bf565020e7955fede0b186232aa30bc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881c6935bf565020e7955fede0b186232aa30bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881c6935bf565020e7955fede0b186232aa30bc7"}], "stats": {"total": 271, "additions": 135, "deletions": 136}, "files": [{"sha": "ac75927f35a7d8be1b8e0642121fe51865a525db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -1,3 +1,18 @@\n+2000-08-28  Richard Henderson  <rth@cygnus.com>\n+\n+\t* local-alloc.c (requires_inout): Don't use reserved range for\n+\tEXTRA_CONSTRAINTS; use anything not matched by REG_CLASS_FROM_LETTER.\n+\t* recog.c (asm_operand_ok): Likewise.\n+\t(preprocess_constraints, constrain_operands): Likewise.\n+\t* regclass.c (record_reg_classes): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t* stmt.c (expand_asm_operands): Likewise.\n+\n+\t* md.texi: Update constraints documentation.\n+\t* tm.texi (EXTRA_CONSTRAINT): Update.\n+\n 2000-08-28  Jason Merrill  <jason@redhat.com>\n \n \t* dwarf2out.c (new_loc_descr): Use calloc."}, {"sha": "7e57c82951e68cf2c5737b34804ed6f1f657fe14", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -2210,9 +2210,6 @@ requires_inout (p)\n       case 's':  case 'i':  case 'n':\n       case 'I':  case 'J':  case 'K':  case 'L':\n       case 'M':  case 'N':  case 'O':  case 'P':\n-#ifdef EXTRA_CONSTRAINT\n-      case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n-#endif\n       case 'X':\n \t/* These don't say anything we care about.  */\n \tbreak;\n@@ -2228,9 +2225,12 @@ requires_inout (p)\n \tfound_zero = 1;\n \tbreak;\n \n+      default:\n+\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS)\n+\t  break;\n+\t/* FALLTHRU */\n       case 'p':\n       case 'g': case 'r':\n-      default:\n \treg_allowed = 1;\n \tbreak;\n       }"}, {"sha": "111b991d45de9c76b0ea67a95503f6271ded744f", "filename": "gcc/md.texi", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -728,13 +728,6 @@ postincrement) is allowed.\n A register operand is allowed provided that it is in a general\n register.\n \n-@cindex @samp{d} in constraint\n-@item @samp{d}, @samp{a}, @samp{f}, @dots{}\n-Other letters can be defined in machine-dependent fashion to stand for\n-particular classes of registers.  @samp{d}, @samp{a} and @samp{f} are\n-defined on the 68000/68020 to stand for data, address and floating\n-point registers.\n-\n @cindex constants in constraints\n @cindex @samp{i} in constraint\n @item @samp{i}\n@@ -866,22 +859,21 @@ as the predicate in the @code{match_operand}.  This predicate interprets\n the mode specified in the @code{match_operand} as the mode of the memory\n reference for which the address would be valid.\n \n+@cindex other register constraints\n @cindex extensible constraints\n-@cindex @samp{Q}, in constraint\n-@item @samp{Q}, @samp{R}, @samp{S}, @dots{} @samp{U}\n-Letters in the range @samp{Q} through @samp{U} may be defined in a\n-machine-dependent fashion to stand for arbitrary operand types.\n-@ifset INTERNALS\n-The machine description macro @code{EXTRA_CONSTRAINT} is passed the\n-operand as its first argument and the constraint letter as its\n-second operand.\n+@item @var{other letters}\n+Other letters can be defined in machine-dependent fashion to stand for\n+particular classes of registers or other arbitrary operand types.\n+@samp{d}, @samp{a} and @samp{f} are defined on the 68000/68020 to stand\n+for data, address and floating point registers.\n \n-A typical use for this would be to distinguish certain types of\n-memory references that affect other insn operands.\n+@ifset INTERNALS\n+The machine description macro @code{REG_CLASS_FROM_LETTER} has first\n+cut at the otherwise unused letters.  If it evaluates to @code{NO_REGS},\n+then @code{EXTRA_CONSTRAINT} is evaluated.\n \n-Do not define these constraint letters to accept register references\n-(@code{reg}); the reload pass does not expect this and would not handle\n-it properly.\n+A typical use for @code{EXTRA_CONSTRANT} would be to distinguish certain\n+types of memory references that affect other insn operands.\n @end ifset\n @end table\n "}, {"sha": "76c46177dd507544be660e69f34dca29639a3b89", "filename": "gcc/recog.c", "status": "modified", "additions": 35, "deletions": 64, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -1571,7 +1571,8 @@ asm_operand_ok (op, constraint)\n \n   while (*constraint)\n     {\n-      switch (*constraint++)\n+      char c = *constraint++;\n+      switch (c)\n \t{\n \tcase '=':\n \tcase '+':\n@@ -1731,35 +1732,21 @@ asm_operand_ok (op, constraint)\n \t    return 1;\n \t  break;\n \n+\tdefault:\n+\t  /* For all other letters, we first check for a register class,\n+\t     otherwise it is an EXTRA_CONSTRAINT.  */\n+\t  if (REG_CLASS_FROM_LETTER (c) != NO_REGS)\n+\t    {\n+\t    case 'r':\n+\t      if (GET_MODE (op) == BLKmode)\n+\t\tbreak;\n+\t      if (register_operand (op, VOIDmode))\n+\t\treturn 1;\n+\t    }\n #ifdef EXTRA_CONSTRAINT\n-\tcase 'Q':\n-\t  if (EXTRA_CONSTRAINT (op, 'Q'))\n-\t    return 1;\n-\t  break;\n-\tcase 'R':\n-\t  if (EXTRA_CONSTRAINT (op, 'R'))\n-\t    return 1;\n-\t  break;\n-\tcase 'S':\n-\t  if (EXTRA_CONSTRAINT (op, 'S'))\n-\t    return 1;\n-\t  break;\n-\tcase 'T':\n-\t  if (EXTRA_CONSTRAINT (op, 'T'))\n+\t  if (EXTRA_CONSTRAINT (op, c))\n \t    return 1;\n-\t  break;\n-\tcase 'U':\n-\t  if (EXTRA_CONSTRAINT (op, 'U'))\n-\t    return 1;\n-\t  break;\n #endif\n-\n-\tcase 'r':\n-\tdefault:\n-\t  if (GET_MODE (op) == BLKmode)\n-\t    break;\n-\t  if (register_operand (op, VOIDmode))\n-\t    return 1;\n \t  break;\n \t}\n     }\n@@ -2138,9 +2125,6 @@ preprocess_constraints ()\n \t\tcase 's': case 'i': case 'n':\n \t\tcase 'I': case 'J': case 'K': case 'L':\n \t\tcase 'M': case 'N': case 'O': case 'P':\n-#ifdef EXTRA_CONSTRAINT\n-\t\tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n-#endif\n \t\t  /* These don't say anything we care about.  */\n \t\t  break;\n \n@@ -2372,20 +2356,6 @@ constrain_operands (strict)\n \t\t  win = 1;\n \t\tbreak;\n \n-\t      case 'r':\n-\t\tif (strict < 0\n-\t\t    || (strict == 0\n-\t\t\t&& GET_CODE (op) == REG\n-\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\t    || (strict == 0 && GET_CODE (op) == SCRATCH)\n-\t\t    || (GET_CODE (op) == REG\n-\t\t\t&& ((GENERAL_REGS == ALL_REGS\n-\t\t\t     && REGNO (op) < FIRST_PSEUDO_REGISTER)\n-\t\t\t    || reg_fits_class_p (op, GENERAL_REGS,\n-\t\t\t\t\t\t offset, mode))))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n \t      case 'X':\n \t\t/* This is used for a MATCH_SCRATCH in the cases when\n \t\t   we don't actually need anything.  So anything goes\n@@ -2472,17 +2442,6 @@ constrain_operands (strict)\n \t\t  win = 1;\n \t\tbreak;\n \n-#ifdef EXTRA_CONSTRAINT\n-              case 'Q':\n-              case 'R':\n-              case 'S':\n-              case 'T':\n-              case 'U':\n-\t\tif (EXTRA_CONSTRAINT (op, c))\n-\t\t  win = 1;\n-\t\tbreak;\n-#endif\n-\n \t      case 'V':\n \t\tif (GET_CODE (op) == MEM\n \t\t    && ((strict > 0 && ! offsettable_memref_p (op))\n@@ -2507,15 +2466,27 @@ constrain_operands (strict)\n \t\tbreak;\n \n \t      default:\n-\t\tif (strict < 0\n-\t\t    || (strict == 0\n-\t\t\t&& GET_CODE (op) == REG\n-\t\t\t&& REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\t    || (strict == 0 && GET_CODE (op) == SCRATCH)\n-\t\t    || (GET_CODE (op) == REG\n-\t\t\t&& reg_fits_class_p (op, REG_CLASS_FROM_LETTER (c),\n-\t\t\t\t\t     offset, mode)))\n-\t\t  win = 1;\n+\t\t{\n+\t\t  enum reg_class class;\n+\n+\t\t  class = (c == 'r' ? GENERAL_REGS : REG_CLASS_FROM_LETTER (c));\n+\t\t  if (class != NO_REGS)\n+\t\t    {\n+\t\t      if (strict < 0\n+\t\t\t  || (strict == 0\n+\t\t\t      && GET_CODE (op) == REG\n+\t\t\t      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t\t\t  || (strict == 0 && GET_CODE (op) == SCRATCH)\n+\t\t\t  || (GET_CODE (op) == REG\n+\t\t\t      && reg_fits_class_p (op, class, offset, mode)))\n+\t\t        win = 1;\n+\t\t    }\n+#ifdef EXTRA_CONSTRAINT\n+\t\t  else if (EXTRA_CONSTRAINT (op, c))\n+\t\t    win = 1;\n+#endif\n+\t\t  break;\n+\t\t}\n \t      }\n \n \t  constraints[opno] = p;"}, {"sha": "866f5b8a4f820d940c644c369c96e132a823c80e", "filename": "gcc/regclass.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -1561,17 +1561,6 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\twin = 1;\n \t\tbreak;\n \n-#ifdef EXTRA_CONSTRAINT\n-              case 'Q':\n-              case 'R':\n-              case 'S':\n-              case 'T':\n-              case 'U':\n-\t\tif (EXTRA_CONSTRAINT (op, c))\n-\t\t  win = 1;\n-\t\tbreak;\n-#endif\n-\n \t      case 'g':\n \t\tif (GET_CODE (op) == MEM\n \t\t    || (CONSTANT_P (op)\n@@ -1587,9 +1576,15 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\tbreak;\n \n \t      default:\n-\t\tclasses[i]\n-\t\t  = reg_class_subunion[(int) classes[i]]\n-\t\t    [(int) REG_CLASS_FROM_LETTER (c)];\n+\t\tif (REG_CLASS_FROM_LETTER (c) != NO_REGS)\n+\t\t  classes[i]\n+\t\t    = reg_class_subunion[(int) classes[i]]\n+\t\t      [(int) REG_CLASS_FROM_LETTER (c)];\n+#ifdef EXTRA_CONSTRAINT\n+\t\telse if (EXTRA_CONSTRAINT (op, c))\n+\t\t  win = 1;\n+#endif\n+\t\tbreak;\n \t      }\n \n \t  constraints[i] = p;"}, {"sha": "e2eccf6b1091ca000204001f530df41a64e761e5", "filename": "gcc/reload.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -3142,21 +3142,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  = (int) reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];\n \t\tgoto reg;\n \n+\t      default:\n+\t\tif (REG_CLASS_FROM_LETTER (c) == NO_REGS)\n+\t\t  {\n #ifdef EXTRA_CONSTRAINT\n-\t      case 'Q':\n-\t      case 'R':\n-\t      case 'S':\n-\t      case 'T':\n-\t      case 'U':\n-\t\tif (EXTRA_CONSTRAINT (operand, c))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t    if (EXTRA_CONSTRAINT (operand, c))\n+\t\t      win = 1;\n #endif\n+\t\t    break;\n+\t\t  }\n \n-\t      default:\n \t\tthis_alternative[i]\n \t\t  = (int) reg_class_subunion[this_alternative[i]][(int) REG_CLASS_FROM_LETTER (c)];\n-\n \t      reg:\n \t\tif (GET_MODE (operand) == BLKmode)\n \t\t  break;"}, {"sha": "8c3ef56c29f0bcdf7fd83deeafbc94838da1eb02", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -1276,9 +1276,6 @@ maybe_fix_stack_asms ()\n \t\tcase 'F': case 's': case 'i': case 'n': case 'X': case 'I':\n \t\tcase 'J': case 'K': case 'L': case 'M': case 'N': case 'O':\n \t\tcase 'P':\n-#ifdef EXTRA_CONSTRAINT\n-\t\tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n-#endif\n \t\t  break;\n \n \t\tcase 'p':\n@@ -8189,9 +8186,6 @@ reload_cse_simplify_operands (insn)\n \t\tcase 's':  case 'i':  case 'n':\n \t\tcase 'I':  case 'J':  case 'K':  case 'L':\n \t\tcase 'M':  case 'N':  case 'O':  case 'P':\n-#ifdef EXTRA_CONSTRAINT\n-\t\tcase 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n-#endif\n \t\tcase 'p': case 'X':\n \t\t  /* These don't say anything we care about.  */\n \t\t  break;"}, {"sha": "7b27f87fe803af55e11ec5a95ac75e7d0782e137", "filename": "gcc/stmt.c", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -1508,17 +1508,34 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    break;\n \n \t  case 'g':  case 'X':\n-#ifdef EXTRA_CONSTRAINT\n-\t  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n-#endif\n \t    allows_reg = 1;\n \t    allows_mem = 1;\n \t    break;\n \n \t  case 'p': case 'r':\n-\t  default:\n \t    allows_reg = 1;\n \t    break;\n+\n+\t  default:\n+\t    if (! ISALPHA (constraint[j]))\n+\t      {\n+\t\terror (\"invalid punctuation `%c' in constraint\",\n+\t\t       constraint[j]);\n+\t\treturn;\n+\t      }\n+\t    if (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n+\t      allows_reg = 1;\n+#ifdef EXTRA_CONSTRAINT\n+\t    else\n+\t      {\n+\t\t/* Otherwise we can't assume anything about the nature of\n+\t\t   the constraint except that it isn't purely registers.\n+\t\t   Treat it like \"g\" and hope for the best.  */\n+\t\tallows_reg = 1;\n+\t\tallows_mem = 1;\n+\t      }\n+#endif\n+\t    break;\n \t  }\n \n       /* If an output operand is not a decl or indirect ref and our constraint\n@@ -1681,18 +1698,34 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    /* ... fall through ... */\n \n \t  case 'p':  case 'r':\n-\t  default:\n \t    allows_reg = 1;\n \t    break;\n \n \t  case 'g':  case 'X':\n-#ifdef EXTRA_CONSTRAINT\n-\t  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n-#endif\n-\n \t    allows_reg = 1;\n \t    allows_mem = 1;\n \t    break;\n+\n+\t  default:\n+\t    if (! ISALPHA (constraint[j]))\n+\t      {\n+\t\terror (\"invalid punctuation `%c' in constraint\",\n+\t\t       constraint[j]);\n+\t\treturn;\n+\t      }\n+\t    if (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n+\t      allows_reg = 1;\n+#ifdef EXTRA_CONSTRAINT\n+\t    else\n+\t      {\n+\t\t/* Otherwise we can't assume anything about the nature of\n+\t\t   the constraint except that it isn't purely registers.\n+\t\t   Treat it like \"g\" and hope for the best.  */\n+\t\tallows_reg = 1;\n+\t\tallows_mem = 1;\n+\t      }\n+#endif\n+\t    break;\n \t  }\n \n       if (! allows_reg && allows_mem)"}, {"sha": "838fd7d349e496a7e56a8b3ffc0dfa22dde4d142", "filename": "gcc/tm.texi", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2cba7a96e04069011ae508e3027bbf128208040/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=c2cba7a96e04069011ae508e3027bbf128208040", "patch": "@@ -2180,17 +2180,19 @@ between these kinds.\n @findex EXTRA_CONSTRAINT\n @item EXTRA_CONSTRAINT (@var{value}, @var{c})\n A C expression that defines the optional machine-dependent constraint\n-letters (@samp{Q}, @samp{R}, @samp{S}, @samp{T}, @samp{U}) that can\n-be used to segregate specific types of operands, usually memory\n-references, for the target machine.  Normally this macro will not be\n-defined.  If it is required for a particular target machine, it should\n-return 1 if @var{value} corresponds to the operand type represented by\n-the constraint letter @var{c}.  If @var{c} is not defined as an extra\n+letters that can be used to segregate specific types of operands, usually\n+memory references, for the target machine.  Any letter that is not\n+elsewhere defined and not matched by @code{REG_CLASS_FROM_LETTER}\n+may be used.  Normally this macro will not be defined.\n+\n+If it is required for a particular target machine, it should return 1\n+if @var{value} corresponds to the operand type represented by the\n+constraint letter @var{c}.  If @var{c} is not defined as an extra\n constraint, the value returned should be 0 regardless of @var{value}.\n \n-For example, on the ROMP, load instructions cannot have their output in r0 if\n-the memory reference contains a symbolic address.  Constraint letter\n-@samp{Q} is defined as representing a memory address that does\n+For example, on the ROMP, load instructions cannot have their output\n+in r0 if the memory reference contains a symbolic address.  Constraint\n+letter @samp{Q} is defined as representing a memory address that does\n @emph{not} contain a symbolic address.  An alternative is specified with\n a @samp{Q} constraint on the input and @samp{r} on the output.  The next\n alternative specifies @samp{m} on the input and a register class that"}]}