{"sha": "6f4fd16d75e0eda77a1861a0d6c7c424e5803481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY0ZmQxNmQ3NWUwZWRhNzdhMTg2MWEwZDZjN2M0MjRlNTgwMzQ4MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-21T13:26:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-21T13:26:34Z"}, "message": "expr.c (store_expr): Clean up by renaming want_value to call_param_p.\n\n\t* expr.c (store_expr): Clean up by renaming want_value to\n\tcall_param_p.\n\nFrom-SVN: r89374", "tree": {"sha": "7a11b7268ebc5497e61760c33d1d469db4cfea73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a11b7268ebc5497e61760c33d1d469db4cfea73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f4fd16d75e0eda77a1861a0d6c7c424e5803481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4fd16d75e0eda77a1861a0d6c7c424e5803481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f4fd16d75e0eda77a1861a0d6c7c424e5803481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4fd16d75e0eda77a1861a0d6c7c424e5803481/comments", "author": null, "committer": null, "parents": [{"sha": "c2fb2abee14dd7a8971407b578dcdc79c7e8ff7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2fb2abee14dd7a8971407b578dcdc79c7e8ff7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2fb2abee14dd7a8971407b578dcdc79c7e8ff7e"}], "stats": {"total": 41, "additions": 21, "deletions": 20}, "files": [{"sha": "4c75f70255b81bcdc480dd7a76d30526c4b4141d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd16d75e0eda77a1861a0d6c7c424e5803481/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd16d75e0eda77a1861a0d6c7c424e5803481/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f4fd16d75e0eda77a1861a0d6c7c424e5803481", "patch": "@@ -1,3 +1,8 @@\n+2004-10-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* expr.c (store_expr): Clean up by renaming want_value to\n+\tcall_param_p.\n+\n 2004-10-21  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/linux-unwind.h (sh_fallback_frame_state): Don't"}, {"sha": "d98de0661f3ed9a5d3fa3e1756f4e1062dd3fc88", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd16d75e0eda77a1861a0d6c7c424e5803481/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd16d75e0eda77a1861a0d6c7c424e5803481/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6f4fd16d75e0eda77a1861a0d6c7c424e5803481", "patch": "@@ -3745,27 +3745,23 @@ expand_assignment (tree to, tree from)\n    with no sequence point.  Will other languages need this to\n    be more thorough?\n \n-   If WANT_VALUE & 2 is set, this is a store into a call param on the\n+   If CALL_PARAM_P is nonzero, this is a store into a call param on the\n    stack, and block moves may need to be treated specially.  */\n \n rtx\n-store_expr (tree exp, rtx target, int want_value)\n+store_expr (tree exp, rtx target, int call_param_p)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n   int dont_return_target = 0;\n   int dont_store_target = 0;\n \n-  /* The bit 0 of WANT_VALUE used to be used to request a value of the\n-     expression.  This feature has been removed.  */\n-  gcc_assert ((want_value & 1) == 0);\n-\n   if (VOID_TYPE_P (TREE_TYPE (exp)))\n     {\n       /* C++ can generate ?: expressions with a throw expression in one\n \t branch and an rvalue in the other. Here, we resolve attempts to\n \t store the throw expression's nonexistent result.  */\n-      gcc_assert (!want_value);\n+      gcc_assert (!call_param_p);\n       expand_expr (exp, const0_rtx, VOIDmode, 0);\n       return NULL_RTX;\n     }\n@@ -3774,8 +3770,8 @@ store_expr (tree exp, rtx target, int want_value)\n       /* Perform first part of compound expression, then assign from second\n \t part.  */\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t   want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n-      return store_expr (TREE_OPERAND (exp, 1), target, want_value);\n+\t\t   call_param_p ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n+      return store_expr (TREE_OPERAND (exp, 1), target, call_param_p);\n     }\n   else if (TREE_CODE (exp) == COND_EXPR && GET_MODE (target) == BLKmode)\n     {\n@@ -3789,11 +3785,11 @@ store_expr (tree exp, rtx target, int want_value)\n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n-      store_expr (TREE_OPERAND (exp, 1), target, want_value & 2);\n+      store_expr (TREE_OPERAND (exp, 1), target, call_param_p);\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n-      store_expr (TREE_OPERAND (exp, 2), target, want_value & 2);\n+      store_expr (TREE_OPERAND (exp, 2), target, call_param_p);\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n@@ -3834,7 +3830,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t}\n \n       temp = expand_expr (exp, inner_target, VOIDmode,\n-\t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n+\t\t\t  call_param_p ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n \n       /* If TEMP is a VOIDmode constant, use convert_modes to make\n \t sure that we properly convert it.  */\n@@ -3855,7 +3851,7 @@ store_expr (tree exp, rtx target, int want_value)\n   else\n     {\n       temp = expand_expr_real (exp, target, GET_MODE (target),\n-\t\t\t       (want_value & 2\n+\t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n \t\t\t       &alt_rtl);\n       /* Return TARGET if it's a specified hardware register.\n@@ -3943,7 +3939,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t  if (GET_CODE (size) == CONST_INT\n \t      && INTVAL (size) < TREE_STRING_LENGTH (exp))\n \t    emit_block_move (target, temp, size,\n-\t\t\t     (want_value & 2\n+\t\t\t     (call_param_p\n \t\t\t      ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \t  else\n \t    {\n@@ -3954,15 +3950,15 @@ store_expr (tree exp, rtx target, int want_value)\n \t\t\t      size_int (TREE_STRING_LENGTH (exp)));\n \t      rtx copy_size_rtx\n \t\t= expand_expr (copy_size, NULL_RTX, VOIDmode,\n-\t\t\t       (want_value & 2\n+\t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL));\n \t      rtx label = 0;\n \n \t      /* Copy that much.  */\n \t      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx,\n \t\t\t\t\t       TYPE_UNSIGNED (sizetype));\n \t      emit_block_move (target, temp, copy_size_rtx,\n-\t\t\t       (want_value & 2\n+\t\t\t       (call_param_p\n \t\t\t\t? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n@@ -4006,7 +4002,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t\t\t int_size_in_bytes (TREE_TYPE (exp)));\n       else if (GET_MODE (temp) == BLKmode)\n \temit_block_move (target, temp, expr_size (exp),\n-\t\t\t (want_value & 2\n+\t\t\t (call_param_p\n \t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n       else\n \t{\n@@ -7131,7 +7127,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    /* Store data into beginning of memory target.  */\n \t    store_expr (TREE_OPERAND (exp, 0),\n \t\t\tadjust_address (target, TYPE_MODE (valtype), 0),\n-\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n+\t\t\tmodifier == EXPAND_STACK_PARM);\n \n \t  else\n \t    {\n@@ -7902,13 +7898,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n        op1 = gen_label_rtx ();\n        jumpifnot (TREE_OPERAND (exp, 0), op0);\n        store_expr (TREE_OPERAND (exp, 1), temp,\n- \t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n+ \t\t  modifier == EXPAND_STACK_PARM);\n \n        emit_jump_insn (gen_jump (op1));\n        emit_barrier ();\n        emit_label (op0);\n        store_expr (TREE_OPERAND (exp, 2), temp,\n- \t\t  modifier == EXPAND_STACK_PARM ? 2 : 0);\n+ \t\t  modifier == EXPAND_STACK_PARM);\n \n        emit_label (op1);\n        OK_DEFER_POP;"}]}