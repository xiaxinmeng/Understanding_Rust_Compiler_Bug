{"sha": "2b589241d86c1f2e68d5f2dbceb60f19050bd199", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1ODkyNDFkODZjMWYyZTY4ZDVmMmRiY2ViNjBmMTkwNTBiZDE5OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-02T19:24:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-02T19:24:27Z"}, "message": "i386.c (ix86_split_to_parts): Return number of part required; handle TFmodes.\n\n\n\t* i386.c (ix86_split_to_parts): Return number of part required;\n\thandle TFmodes.\n\t(print_operand, ix86_expand_branch, ix86_expand_fp_movcc): Handle\n\tTFmodes.\n\t(ix86_split_long_move): Use number of part returned\n\tby ix86_split_to_parts\n\t* i386.h (MASK_128BIT_LONG_DOUBLE, TARGET_128BIT_LONG_DOUBLE):\n\tNew macros.\n\t(TARGET_SWITCHES): Add 128bit-long-double and 96bit-long-double\n\t(LONG_DOUBLE_TYPE_SIZE): Change from constant.\n\t(MAX_LONG_DOUBLE_TYPE_SIZE): New macro.\n\t(INTEL_EXTENDED_IEEE_FORMAT): Likewise.\n\t(ALIGN_MODE_128): Add TFmode.\n\t(IS_STACK_MODE): Likewise.\n\t(HARD_REGNO_NREGS): TFmode needs 3 registers.\n\t(HARD_REGNO_OK): Support TFmodes.\n\t(ASM_OUTPUT_LONG_DOUBLE): Handle TFmodes.\n\t* i386.md (scheduler definitions): Use memory operand to determine\n\tfst/fld instructions; use mode attribute to determine real mode of\n\tthe instruction.\n\t(*tf): New patterns, expanders and splitters; based on XFmode patterns.\n\t* invoke.texi (128bit-long-double, 96bit-long-double): Document.\n\nFrom-SVN: r38633", "tree": {"sha": "01c459d5b2a2b1fe5b1b1822b129430cdc4b1578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c459d5b2a2b1fe5b1b1822b129430cdc4b1578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b589241d86c1f2e68d5f2dbceb60f19050bd199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b589241d86c1f2e68d5f2dbceb60f19050bd199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b589241d86c1f2e68d5f2dbceb60f19050bd199", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b589241d86c1f2e68d5f2dbceb60f19050bd199/comments", "author": null, "committer": null, "parents": [{"sha": "9e1458e7d76099127b7991efb60ec26952318e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1458e7d76099127b7991efb60ec26952318e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e1458e7d76099127b7991efb60ec26952318e4b"}], "stats": {"total": 1043, "additions": 995, "deletions": 48}, "files": [{"sha": "f64a0073ba63a4223886b2be09458c1e71b692ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b589241d86c1f2e68d5f2dbceb60f19050bd199", "patch": "@@ -1,3 +1,28 @@\n+Tue Jan  2 20:21:31 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_split_to_parts): Return number of part required;\n+\thandle TFmodes.\n+\t(print_operand, ix86_expand_branch, ix86_expand_fp_movcc): Handle\n+\tTFmodes.\n+\t(ix86_split_long_move): Use number of part returned\n+\tby ix86_split_to_parts\n+\t* i386.h (MASK_128BIT_LONG_DOUBLE, TARGET_128BIT_LONG_DOUBLE):\n+\tNew macros.\n+\t(TARGET_SWITCHES): Add 128bit-long-double and 96bit-long-double\n+\t(LONG_DOUBLE_TYPE_SIZE): Change from constant.\n+\t(MAX_LONG_DOUBLE_TYPE_SIZE): New macro.\n+\t(INTEL_EXTENDED_IEEE_FORMAT): Likewise.\n+\t(ALIGN_MODE_128): Add TFmode.\n+\t(IS_STACK_MODE): Likewise.\n+\t(HARD_REGNO_NREGS): TFmode needs 3 registers.\n+\t(HARD_REGNO_OK): Support TFmodes.\n+\t(ASM_OUTPUT_LONG_DOUBLE): Handle TFmodes.\n+\t* i386.md (scheduler definitions): Use memory operand to determine\n+\tfst/fld instructions; use mode attribute to determine real mode of\n+\tthe instruction.\n+\t(*tf): New patterns, expanders and splitters; based on XFmode patterns.\n+\t* invoke.texi (128bit-long-double, 96bit-long-double): Document.\n+\n 2001-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.def (TRUTH_NOT_EXPR): Improve documentation."}, {"sha": "c8a25c4aeed27c4c7ebb3630b1f104e2919670d1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2b589241d86c1f2e68d5f2dbceb60f19050bd199", "patch": "@@ -404,7 +404,7 @@ static rtx * ix86_pent_find_pair PARAMS ((rtx *, rtx *, enum attr_pent_pair,\n \t\t\t\t\t rtx));\n static void ix86_init_machine_status PARAMS ((struct function *));\n static void ix86_mark_machine_status PARAMS ((struct function *));\n-static void ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n+static int ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_safe_length_prefix PARAMS ((rtx));\n static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT,\n \t\t\t\t\t\t     int *, int *, int *));\n@@ -3337,6 +3337,7 @@ print_operand (file, x, code)\n \t      return;\n \n \t    case 12:\n+\t    case 16:\n \t      putc ('t', file);\n \t      return;\n \n@@ -3466,7 +3467,8 @@ print_operand (file, x, code)\n       fprintf (file, \"%s\", dstr);\n     }\n \n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == XFmode)\n+  else if (GET_CODE (x) == CONST_DOUBLE\n+\t   && (GET_MODE (x) == XFmode || GET_MODE (x) == TFmode))\n     {\n       REAL_VALUE_TYPE r;\n       char dstr[30];\n@@ -4769,6 +4771,7 @@ ix86_prepare_fp_compare_args (code, pop0, pop1)\n \n   if (fpcmp_mode == CCFPUmode\n       || op_mode == XFmode\n+      || op_mode == TFmode\n       || ix86_use_fcomi_compare (code))\n     {\n       op0 = force_reg (op_mode, op0);\n@@ -5048,6 +5051,7 @@ ix86_expand_branch (code, label)\n     case SFmode:\n     case DFmode:\n     case XFmode:\n+    case TFmode:\n       /* Don't expand the comparison early, so that we get better code\n \t when jump or whoever decides to reverse the comparison.  */\n       {\n@@ -5633,13 +5637,13 @@ ix86_expand_fp_movcc (operands)\n    For pushes, it returns just stack offsets; the values will be saved\n    in the right order.  Maximally three parts are generated.  */\n \n-static void\n+static int\n ix86_split_to_parts (operand, parts, mode)\n      rtx operand;\n      rtx *parts;\n      enum machine_mode mode;\n {\n-  int size = GET_MODE_SIZE (mode) / 4;\n+  int size = mode == TFmode ? 3 : GET_MODE_SIZE (mode) / 4;\n \n   if (GET_CODE (operand) == REG && MMX_REGNO_P (REGNO (operand)))\n     abort ();\n@@ -5689,12 +5693,13 @@ ix86_split_to_parts (operand, parts, mode)\n \t  else if (GET_CODE (operand) == CONST_DOUBLE)\n \t    {\n \t      REAL_VALUE_TYPE r;\n-\t      long l[3];\n+\t      long l[4];\n \n \t      REAL_VALUE_FROM_CONST_DOUBLE (r, operand);\n \t      switch (mode)\n \t\t{\n \t\tcase XFmode:\n+\t\tcase TFmode:\n \t\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n \t\t  parts[2] = GEN_INT (l[2]);\n \t\t  break;\n@@ -5712,7 +5717,7 @@ ix86_split_to_parts (operand, parts, mode)\n \t}\n     }\n \n-  return;\n+  return size;\n }\n \n /* Emit insns to perform a move or push of DI, DF, and XF values.\n@@ -5726,25 +5731,22 @@ ix86_split_long_move (operands1)\n {\n   rtx part[2][3];\n   rtx operands[2];\n-  int size = GET_MODE_SIZE (GET_MODE (operands1[0])) / 4;\n+  int size;\n   int push = 0;\n   int collisions = 0;\n \n   /* Make our own copy to avoid clobbering the operands.  */\n   operands[0] = copy_rtx (operands1[0]);\n   operands[1] = copy_rtx (operands1[1]);\n \n-  if (size < 2 || size > 3)\n-    abort ();\n-\n   /* The only non-offsettable memory we handle is push.  */\n   if (push_operand (operands[0], VOIDmode))\n     push = 1;\n   else if (GET_CODE (operands[0]) == MEM\n \t   && ! offsettable_memref_p (operands[0]))\n     abort ();\n \n-  ix86_split_to_parts (operands[0], part[0], GET_MODE (operands1[0]));\n+  size = ix86_split_to_parts (operands[0], part[0], GET_MODE (operands1[0]));\n   ix86_split_to_parts (operands[1], part[1], GET_MODE (operands1[0]));\n \n   /* When emitting push, take care for source operands on the stack.  */\n@@ -5794,7 +5796,15 @@ ix86_split_long_move (operands1)\n   if (push)\n     {\n       if (size == 3)\n-\temit_insn (gen_push (part[1][2]));\n+\t{\n+\t  /* We use only first 12 bytes of TFmode value, but for pushing we\n+\t     are required to adjust stack as if we were pushing real 16byte\n+\t     value.  */\n+\t  if (GET_MODE (operands1[0]) == TFmode)\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (-4)));\n+\t  emit_insn (gen_push (part[1][2]));\n+\t}\n       emit_insn (gen_push (part[1][1]));\n       emit_insn (gen_push (part[1][0]));\n       return 1;"}, {"sha": "8f219cf32471aae1ffabc64dc94db6fac4b0ce9c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2b589241d86c1f2e68d5f2dbceb60f19050bd199", "patch": "@@ -104,6 +104,7 @@ extern int target_flags;\n #define MASK_ACCUMULATE_OUTGOING_ARGS 0x00008000/* Accumulate outgoing args */\n #define MASK_MMX\t\t0x00010000\t/* Support MMX regs/builtins */\n #define MASK_SSE\t\t0x00020000\t/* Support SSE regs/builtins */\n+#define MASK_128BIT_LONG_DOUBLE 0x00040000\t/* long double size is 128bit */\n \n /* Temporary codegen switches */\n #define MASK_INTEL_SYNTAX\t0x00000200\n@@ -144,6 +145,11 @@ extern int target_flags;\n    the 387 to be used, which is compatible with most calling conventions. */\n #define TARGET_FLOAT_RETURNS_IN_80387 (target_flags & MASK_FLOAT_RETURNS)\n \n+/* Long double is 128bit instead of 96bit, even when only 80bits are used.\n+   This mode wastes cache, but avoid missaligned data accesses and simplifies\n+   address calculations.  */\n+#define TARGET_128BIT_LONG_DOUBLE (target_flags & MASK_128BIT_LONG_DOUBLE)\n+\n /* Disable generation of FP sin, cos and sqrt operations for 387.\n    This is because FreeBSD lacks these in the math-emulator-code */\n #define TARGET_NO_FANCY_MATH_387 (target_flags & MASK_NO_FANCY_MATH_387)\n@@ -295,6 +301,10 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n     N_(\"Support MMX and SSE builtins\") },\t\t\t\t      \\\n   { \"no-sse\",\t\t\t-MASK_SSE,\t\t\t\t      \\\n     N_(\"Do not support MMX and SSE builtins\") },\t\t\t      \\\n+  { \"128bit-long-double\",\t MASK_128BIT_LONG_DOUBLE,\t\t      \\\n+    N_(\"sizeof(long double) is 16.\") },\t\t\t\t\t      \\\n+  { \"96bit-long-double\",\t-MASK_128BIT_LONG_DOUBLE,\t\t      \\\n+    N_(\"sizeof(long double) is 12.\") },\t\t\t\t\t      \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t      \\\n   { \"\", TARGET_DEFAULT, 0 }}\n \n@@ -446,9 +456,18 @@ extern int ix86_arch;\n \f\n /* target machine storage layout */\n \n-/* Define for XFmode extended real floating point support.\n-   This will automatically cause REAL_ARITHMETIC to be defined.  */\n-#define LONG_DOUBLE_TYPE_SIZE 96\n+/* Define for XFmode or TFmode extended real floating point support.\n+   This will automatically cause REAL_ARITHMETIC to be defined.\n+ \n+   The XFmode is specified by i386 ABI, while TFmode may be faster\n+   due to alignment and simplifications in the address calculations.\n+ */\n+#define LONG_DOUBLE_TYPE_SIZE (TARGET_128BIT_LONG_DOUBLE ? 128 : 96)\n+#define MAX_LONG_DOUBLE_TYPE_SIZE 128\n+/* Tell real.c that this is the 80-bit Intel extended float format\n+   packaged in a 128-bit or 96bit entity.  */\n+#define INTEL_EXTENDED_IEEE_FORMAT\n+\n \n /* Define if you don't want extended real, but do want to use the\n    software floating point emulator for REAL_ARITHMETIC and\n@@ -515,8 +534,8 @@ extern int ix86_arch;\n \n /* Decide whether a variable of mode MODE must be 128 bit aligned.  */\n #define ALIGN_MODE_128(MODE) \\\n- ((MODE) == XFmode || ((MODE) == TImode) || (MODE) == V4SFmode\t\\\n-  || (MODE) == V4SImode)\n+ ((MODE) == XFmode || (MODE) == TFmode || ((MODE) == TImode) \\\n+  || (MODE) == V4SFmode\t|| (MODE) == V4SImode)\n \n /* The published ABIs say that doubles should be aligned on word\n    boundaries, so lower the aligment for structure fields unless\n@@ -596,7 +615,8 @@ extern int ix86_arch;\n    for details. */\n \n #define STACK_REGS\n-#define IS_STACK_MODE(mode) (mode==DFmode || mode==SFmode || mode==XFmode)\n+#define IS_STACK_MODE(mode) (mode==DFmode || mode==SFmode \\\n+\t\t\t     || mode==XFmode || mode==TFmode)\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n@@ -740,7 +760,9 @@ extern int ix86_arch;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO) ? 1 \\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+   : (MODE == TFmode\t\t\t\t\t\t\t\\\n+      ? 3\t\t\t\t\t\t\t\t\\\n+      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n #define VALID_SSE_REG_MODE(MODE) \\\n     ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode)\n@@ -765,7 +787,7 @@ extern int ix86_arch;\n    : FP_REGNO_P (REGNO)\t\t\t\t\t\t\\\n    ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n        || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n-      && GET_MODE_UNIT_SIZE (MODE) <= (LONG_DOUBLE_TYPE_SIZE == 96 ? 12 : 8))\\\n+      && GET_MODE_UNIT_SIZE (MODE) <= 16)\\\n    : SSE_REGNO_P (REGNO) ? VALID_SSE_REG_MODE (MODE)\t\t\\\n    : MMX_REGNO_P (REGNO) ? VALID_MMX_REG_MODE (MODE)\t\t\\\n    /* Only SSE and MMX regs can hold vector modes.  */\t\t\\\n@@ -2610,9 +2632,12 @@ do { long l[2];\t\t\t\t\t\t\t\t\\\n \n #undef ASM_OUTPUT_LONG_DOUBLE\n #define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\\\n-do { long l[3];\t\t\t\t\t\t\\\n+do { long l[4];\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\\\n-     fprintf (FILE, \"%s\\t0x%lx,0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+     if (TARGET_128BIT_LONG_DOUBLE)\t\t\t\\\n+       fprintf (FILE, \"%s\\t0x%lx,0x%lx,0x%lx,0x0\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+     else \\\n+       fprintf (FILE, \"%s\\t0x%lx,0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */"}, {"sha": "836edc5b3d9516a3e999df4a089d7a83a653ea2c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 895, "deletions": 22, "changes": 917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2b589241d86c1f2e68d5f2dbceb60f19050bd199", "patch": "@@ -373,19 +373,15 @@\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n        (and (eq_attr \"type\" \"fmov\")\n-\t    (ior (and (eq_attr \"memory\" \"store\")\n-\t\t      (match_operand:XF 0 \"memory_operand\" \"\"))\n-\t\t (and (eq_attr \"memory\" \"load\")\n-\t\t      (match_operand:XF 1 \"memory_operand\" \"\")))))\n+\t    (and (eq_attr \"memory\" \"load,store\")\n+\t\t (eq_attr \"mode\" \"XF\"))))\n   3 3)\n \n (define_function_unit \"pent_np\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n        (and (eq_attr \"type\" \"fmov\")\n-\t    (ior (and (eq_attr \"memory\" \"store\")\n-\t\t      (match_operand:XF 0 \"memory_operand\" \"\"))\n-\t\t (and (eq_attr \"memory\" \"load\")\n-\t\t      (match_operand:XF 1 \"memory_operand\" \"\")))))\n+\t    (and (eq_attr \"memory\" \"load,store\")\n+\t\t (eq_attr \"mode\" \"XF\"))))\n   3 3)\n \n (define_function_unit \"fpu\" 1 0\n@@ -833,8 +829,8 @@\n               (match_operand 1 \"memory_operand\" \"\"))\n \t   (const_string \"vector\")\n          (and (eq_attr \"type\" \"fmov\")\n-              (ior (match_operand:XF 0 \"memory_operand\" \"\")\n-                   (match_operand:XF 1 \"memory_operand\" \"\")))\n+\t      (and (eq_attr \"memory\" \"load,store\")\n+\t\t   (eq_attr \"mode\" \"XF\")))\n \t   (const_string \"vector\")]\n \t(const_string \"direct\")))\n \n@@ -929,7 +925,8 @@\n (define_function_unit \"athlon_fp\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n        (and (eq_attr \"type\" \"fmov\")\n-\t    (match_operand:XF 1 \"memory_operand\" \"\")))\n+\t    (and (eq_attr \"memory\" \"load\")\n+\t\t (eq_attr \"mode\" \"XF\"))))\n   10 1)\n \n (define_function_unit \"athlon_fp\" 3 0\n@@ -1255,6 +1252,18 @@\n   DONE;\n }\")\n \n+(define_expand \"cmptf\"\n+  [(set (reg:CC 17)\n+\t(compare:CC (match_operand:TF 0 \"cmp_fp_expander_operand\" \"\")\n+\t\t    (match_operand:TF 1 \"cmp_fp_expander_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  ix86_compare_op0 = operands[0];\n+  ix86_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n (define_expand \"cmpdf\"\n   [(set (reg:CC 17)\n \t(compare:CC (match_operand:DF 0 \"cmp_fp_expander_operand\" \"\")\n@@ -1370,6 +1379,16 @@\n   [(set_attr \"type\" \"fcmp\")\n    (set_attr \"mode\" \"XF\")])\n \n+(define_insn \"*cmpfp_2_tf\"\n+  [(set (reg:CCFP 18)\n+\t(compare:CCFP\n+\t  (match_operand:TF 0 \"register_operand\" \"f\")\n+\t  (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_80387\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"XF\")])\n+\n (define_insn \"*cmpfp_2_xf_1\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n@@ -1381,6 +1400,17 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"XF\")])\n \n+(define_insn \"*cmpfp_2_tf_1\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(unspec:HI\n+\t  [(compare:CCFP\n+\t     (match_operand:TF 1 \"register_operand\" \"f\")\n+\t     (match_operand:TF 2 \"register_operand\" \"f\"))] 9))]\n+  \"TARGET_80387\"\n+  \"* return output_fp_compare (insn, operands, 2, 0);\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"XF\")])\n+\n (define_insn \"*cmpfp_2u\"\n   [(set (reg:CCFPU 18)\n \t(compare:CCFPU\n@@ -2428,6 +2458,12 @@\n   \"\"\n   \"ix86_expand_move (XFmode, operands); DONE;\")\n \n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"ix86_expand_move (TFmode, operands); DONE;\")\n+\n ;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n ;; Size of pushdf using integer insturctions is 3+3*memory operand size\n ;; Pushing using integer instructions is longer except for constants\n@@ -2464,6 +2500,35 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"XF,SI,SI\")])\n \n+(define_insn \"*pushtf_nointeger\"\n+  [(set (match_operand:TF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:TF 1 \"general_no_elim_operand\" \"f,Fo,*r\"))]\n+  \"optimize_size\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n+      operands[0] = gen_rtx_MEM (XFmode, stack_pointer_rtx);\n+      operands[2] = stack_pointer_rtx;\n+      operands[3] = GEN_INT (16);\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n+    case 1:\n+    case 2:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"XF,SI,SI\")])\n+\n (define_insn \"*pushxf_integer\"\n   [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n \t(match_operand:XF 1 \"general_no_elim_operand\" \"f#r,rFo#f\"))]\n@@ -2492,10 +2557,41 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"XF,SI\")])\n \n+(define_insn \"*pushtf_integer\"\n+  [(set (match_operand:TF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:TF 1 \"general_no_elim_operand\" \"f#r,rFo#f\"))]\n+  \"!optimize_size\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n+      operands[0] = gen_rtx_MEM (XFmode, stack_pointer_rtx);\n+      operands[2] = stack_pointer_rtx;\n+      operands[3] = GEN_INT (16);\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n+    case 1:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"XF,SI\")])\n+\n (define_split\n-  [(set (match_operand:XF 0 \"push_operand\" \"\")\n-\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand 0 \"push_operand\" \"\")\n+\t(match_operand 1 \"general_operand\" \"\"))]\n   \"reload_completed\n+   && (GET_MODE (operands[0]) == XFmode\n+       || GET_MODE (operands[0]) == TFmode\n+       || GET_MODE (operands[0]) == DFmode)\n    && (!REG_P (operands[1]) || !FP_REGNO_P (REGNO (operands[1])))\"\n   [(const_int 0)]\n   \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n@@ -2507,6 +2603,13 @@\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -12)))\n    (set (mem:XF (reg:SI 7)) (match_dup 1))])\n \n+(define_split\n+  [(set (match_operand:TF 0 \"push_operand\" \"\")\n+\t(match_operand:TF 1 \"register_operand\" \"\"))]\n+  \"FP_REGNO_P (REGNO (operands[1]))\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n+   (set (mem:TF (reg:SI 7)) (match_dup 1))])\n+\n ;; Do not use integer registers when optimizing for size\n (define_insn \"*movxf_nointeger\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n@@ -2555,6 +2658,53 @@\n   [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n    (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n \n+(define_insn \"*movtf_nointeger\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n+\t(match_operand:TF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && optimize_size\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], TFmode))\" \n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp\\\\t%y0\\\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \\\"fld%z1\\\\t%y1\\\";\n+      else\n+        return \\\"fst\\\\t%y0\\\";\n+\n+    case 1:\n+      /* There is no non-popping store to memory for XFmode.  So if\n+\t we need one, follow the store with a load.  */\n+      if (! find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp%z0\\\\t%y0\\;fld%z0\\\\t%y0\\\";\n+      else\n+        return \\\"fstp%z0\\\\t%y0\\\";\n+\n+    case 2:\n+      switch (standard_80387_constant_p (operands[1]))\n+        {\n+        case 1:\n+\t  return \\\"fldz\\\";\n+\tcase 2:\n+\t  return \\\"fld1\\\";\n+\t}\n+      break;\n+\n+    case 3: case 4:\n+      return \\\"#\\\";\n+    }\n+  abort();\n+}\"\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n+   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n+\n (define_insn \"*movxf_integer\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n \t(match_operand:XF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n@@ -2602,11 +2752,59 @@\n   [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n    (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n \n+(define_insn \"*movtf_integer\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n+\t(match_operand:TF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && !optimize_size\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], TFmode))\" \n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp\\\\t%y0\\\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \\\"fld%z1\\\\t%y1\\\";\n+      else\n+        return \\\"fst\\\\t%y0\\\";\n+\n+    case 1:\n+      /* There is no non-popping store to memory for XFmode.  So if\n+\t we need one, follow the store with a load.  */\n+      if (! find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp%z0\\\\t%y0\\;fld%z0\\\\t%y0\\\";\n+      else\n+        return \\\"fstp%z0\\\\t%y0\\\";\n+\n+    case 2:\n+      switch (standard_80387_constant_p (operands[1]))\n+        {\n+        case 1:\n+\t  return \\\"fldz\\\";\n+\tcase 2:\n+\t  return \\\"fld1\\\";\n+\t}\n+      break;\n+\n+    case 3: case 4:\n+      return \\\"#\\\";\n+    }\n+  abort();\n+}\"\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n+   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n+\n (define_split\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand 1 \"general_operand\" \"\"))]\n   \"reload_completed\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && (GET_MODE (operands[0]) == XFmode || GET_MODE (operands[0]) == TFmode)\n    && ! (FP_REG_P (operands[0]) || \n \t (GET_CODE (operands[0]) == SUBREG\n \t  && FP_REG_P (SUBREG_REG (operands[0]))))\n@@ -2619,10 +2817,11 @@\n   \"if (ix86_split_long_move (operands)) DONE;\")\n \n (define_split\n-  [(set (match_operand:XF 0 \"register_operand\" \"\")\n-\t(match_operand:XF 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"memory_operand\" \"\"))]\n   \"reload_completed\n    && GET_CODE (operands[1]) == MEM\n+   && (GET_MODE (operands[0]) == XFmode || GET_MODE (operands[0]) == TFmode)\n    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n    && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n    && standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0)))\"\n@@ -2645,6 +2844,22 @@\n }\"\n   [(set_attr \"type\" \"fxch\")\n    (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"swaptf\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"+f\")\n+\t(match_operand:TF 1 \"register_operand\" \"+f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return \\\"fxch\\\\t%1\\\";\n+  else\n+    return \\\"fxch\\\\t%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fxch\")\n+   (set_attr \"mode\" \"XF\")])\n \f\n ;; Zero extension instructions\n \n@@ -3033,7 +3248,20 @@\n \t(float_extend:XF (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -12)))\n-   (set (mem:DF (reg:SI 7)) (float_extend:XF (match_dup 1)))])\n+   (set (mem:XF (reg:SI 7)) (float_extend:XF (match_dup 1)))])\n+\n+(define_insn \"*dummy_extendsftf2\"\n+  [(set (match_operand:TF 0 \"push_operand\" \"=<\")\n+\t(float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"f\")))]\n+  \"0\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"push_operand\" \"\")\n+\t(float_extend:TF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"FP_REGNO_P (REGNO (operands[1]))\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n+   (set (mem:TF (reg:SI 7)) (float_extend:XF (match_dup 1)))])\n \n (define_insn \"*dummy_extenddfxf2\"\n   [(set (match_operand:XF 0 \"push_operand\" \"=<\")\n@@ -3046,7 +3274,20 @@\n \t(float_extend:XF (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"FP_REGNO_P (REGNO (operands[1]))\"\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -12)))\n-   (set (mem:DF (reg:SI 7)) (float_extend:XF (match_dup 1)))])\n+   (set (mem:XF (reg:SI 7)) (float_extend:XF (match_dup 1)))])\n+\n+(define_insn \"*dummy_extenddftf2\"\n+  [(set (match_operand:TF 0 \"push_operand\" \"=<\")\n+\t(float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"f\")))]\n+  \"0\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"push_operand\" \"\")\n+\t(float_extend:TF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"FP_REGNO_P (REGNO (operands[1]))\"\n+  [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -16)))\n+   (set (mem:TF (reg:SI 7)) (float_extend:XF (match_dup 1)))])\n \n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n@@ -3133,6 +3374,49 @@\n   [(set_attr \"type\" \"fmov\")\n    (set_attr \"mode\" \"SF,XF\")])\n \n+(define_expand \"extendsftf2\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    operands[1] = force_reg (SFmode, operands[1]);\n+}\")\n+\n+(define_insn \"*extendsftf2_1\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,m\")\n+        (float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f\")))]\n+  \"TARGET_80387\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp\\\\t%y0\\\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \\\"fld%z1\\\\t%y1\\\";\n+      else\n+        return \\\"fst\\\\t%y0\\\";\n+\n+    case 1:\n+      /* There is no non-popping store to memory for XFmode.  So if\n+\t we need one, follow the store with a load.  */\n+      if (! find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp%z0\\\\t%y0\\\\n\\\\tfld%z0\\\\t%y0\\\";\n+      else\n+        return \\\"fstp%z0\\\\t%y0\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"fmov\")\n+   (set_attr \"mode\" \"SF,XF\")])\n+\n (define_expand \"extenddfxf2\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n         (float_extend:XF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n@@ -3176,6 +3460,49 @@\n   [(set_attr \"type\" \"fmov\")\n    (set_attr \"mode\" \"DF,XF\")])\n \n+(define_expand \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    operands[1] = force_reg (DFmode, operands[1]);\n+}\")\n+\n+(define_insn \"*extenddftf2_1\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,m\")\n+        (float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"fm,f\")))]\n+  \"TARGET_80387\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp\\\\t%y0\\\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \\\"fld%z1\\\\t%y1\\\";\n+      else\n+        return \\\"fst\\\\t%y0\\\";\n+\n+    case 1:\n+      /* There is no non-popping store to memory for XFmode.  So if\n+\t we need one, follow the store with a load.  */\n+      if (! find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp%z0\\\\t%y0\\\\n\\\\tfld%z0\\\\t%y0\\\";\n+      else\n+        return \\\"fstp%z0\\\\t%y0\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"fmov\")\n+   (set_attr \"mode\" \"DF,XF\")])\n+\n ;; %%% This seems bad bad news.\n ;; This cannot output into an f-reg because there is no way to be sure\n ;; of truncating in that case.  Otherwise this is just like a simple move\n@@ -3312,6 +3639,72 @@\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n \n+(define_expand \"trunctfsf2\"\n+  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (float_truncate:SF\n+\t\t    (match_operand:TF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))])]\n+  \"TARGET_80387\"\n+  \"operands[2] = assign_386_stack_local (SFmode, 0);\")\n+\n+(define_insn \"*trunctfsf2_1\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,f\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"f,0\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"=m,m\"))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"fst%z0\\\\t%y0\\\";\n+    case 1:\n+      return \\\"fstp%z2\\\\t%y2\\;fld%z2\\\\t%y2\\\";\n+    }\n+  abort ();\n+}\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*truncxfsf2_2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+    return \\\"fstp%z0\\\\t%y0\\\";\n+  else\n+    return \\\"fst%z0\\\\t%y0\\\";\n+}\"\n+  [(set_attr \"type\" \"fmov\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387\"\n+  [(set (match_dup 0) (float_truncate:SF (match_dup 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 2) (float_truncate:SF (match_dup 1)))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n+\n (define_expand \"truncxfdf2\"\n   [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t\t   (float_truncate:DF\n@@ -3377,18 +3770,94 @@\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n \n+(define_expand \"trunctfdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (float_truncate:DF\n+\t\t    (match_operand:TF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))])]\n+  \"TARGET_80387\"\n+  \"operands[2] = assign_386_stack_local (DFmode, 0);\")\n+\n+(define_insn \"*trunctfdf2_1\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,f\")\n+\t(float_truncate:DF\n+\t (match_operand:TF 1 \"register_operand\" \"f,0\")))\n+   (clobber (match_operand:DF 2 \"memory_operand\" \"=m,m\"))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"fst%z0\\\\t%y0\\\";\n+    case 1:\n+      return \\\"fstp%z2\\\\t%y2\\;fld%z2\\\\t%y2\\\";\n+    }\n+  abort ();\n+}\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*truncxfdf2_2\"\n+  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n+\t(float_truncate:DF\n+\t  (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+    return \\\"fstp%z0\\\\t%y0\\\";\n+  else\n+    return \\\"fst%z0\\\\t%y0\\\";\n+}\"\n+  [(set_attr \"type\" \"fmov\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+\t(float_truncate:DF\n+\t (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:DF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387\"\n+  [(set (match_dup 0) (float_truncate:DF (match_dup 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(float_truncate:DF\n+\t (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:DF 2 \"memory_operand\" \"\"))]\n+  \"TARGET_80387 && reload_completed\"\n+  [(set (match_dup 2) (float_truncate:DF (match_dup 1)))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n \f\n ;; %%% Break up all these bad boys.\n \n ;; Signed conversion to DImode.\n \n-(define_expand \"fix_truncxfdi2\"\n+(define_expand \"fix_truncxfdi2\"\n+  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:DI (match_operand:XF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (match_scratch:XF 5 \"\"))])]\n+  \"TARGET_80387\"\n+  \"operands[2] = assign_386_stack_local (SImode, 0);\n+   operands[3] = assign_386_stack_local (DImode, 1);\")\n+\n+(define_expand \"fix_trunctfdi2\"\n   [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:DI (match_operand:XF 1 \"register_operand\" \"\")))\n+\t\t   (fix:DI (match_operand:TF 1 \"register_operand\" \"\")))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_scratch:SI 4 \"\"))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+\t      (clobber (match_scratch:TF 5 \"\"))])]\n   \"TARGET_80387\"\n   \"operands[2] = assign_386_stack_local (SImode, 0);\n    operands[3] = assign_386_stack_local (DImode, 1);\")\n@@ -3454,6 +3923,16 @@\n   \"operands[2] = assign_386_stack_local (SImode, 0);\n    operands[3] = assign_386_stack_local (SImode, 1);\")\n \n+(define_expand \"fix_trunctfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:SI (match_operand:TF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_scratch:SI 4 \"\"))])]\n+  \"TARGET_80387\"\n+  \"operands[2] = assign_386_stack_local (SImode, 0);\n+   operands[3] = assign_386_stack_local (SImode, 1);\")\n+\n (define_expand \"fix_truncdfsi2\"\n   [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t\t   (fix:SI (match_operand:DF 1 \"register_operand\" \"\")))\n@@ -3510,6 +3989,16 @@\n   \"operands[2] = assign_386_stack_local (SImode, 0);\n    operands[3] = assign_386_stack_local (HImode, 1);\")\n \n+(define_expand \"fix_trunctfhi2\"\n+  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:HI (match_operand:TF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_scratch:SI 4 \"\"))])]\n+  \"TARGET_80387\"\n+  \"operands[2] = assign_386_stack_local (SImode, 0);\n+   operands[3] = assign_386_stack_local (HImode, 1);\")\n+\n (define_expand \"fix_truncdfhi2\"\n   [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t\t   (fix:HI (match_operand:DF 1 \"register_operand\" \"\")))\n@@ -3658,6 +4147,17 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+(define_insn \"floathitf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(float:TF (match_operand:HI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_80387\"\n+  \"@\n+   fild%z1\\\\t%1\n+   #\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"fp_int_src\" \"true\")])\n+\n (define_insn \"floatsixf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(float:XF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r\")))]\n@@ -3669,6 +4169,17 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+(define_insn \"floatsitf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(float:TF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_80387\"\n+  \"@\n+   fild%z1\\\\t%1\n+   #\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"fp_int_src\" \"true\")])\n+\n (define_insn \"floatdixf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(float:XF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r\")))]\n@@ -3680,6 +4191,17 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+(define_insn \"floatditf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(float:TF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_80387\"\n+  \"@\n+   fild%z1\\\\t%1\n+   #\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"fp_int_src\" \"true\")])\n+\n ;; %%% Kill these when reload knows how to do it.\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -4733,6 +5255,13 @@\n   \"TARGET_80387\"\n   \"\")\n \n+(define_expand \"addtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(plus:TF (match_operand:TF 1 \"register_operand\" \"\")\n+\t\t (match_operand:TF 2 \"register_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"adddf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(plus:DF (match_operand:DF 1 \"register_operand\" \"\")\n@@ -4931,6 +5460,13 @@\n   \"TARGET_80387\"\n   \"\")\n \n+(define_expand \"subtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(minus:TF (match_operand:TF 1 \"register_operand\" \"\")\n+\t\t  (match_operand:TF 2 \"register_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"\")\n@@ -5105,6 +5641,13 @@\n   \"TARGET_80387\"\n   \"\")\n \n+(define_expand \"multf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(mult:TF (match_operand:TF 1 \"register_operand\" \"\")\n+\t\t (match_operand:TF 2 \"register_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"muldf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"\")\n@@ -5152,6 +5695,13 @@\n   \"TARGET_80387\"\n   \"\")\n \n+(define_expand \"divtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(div:TF (match_operand:TF 1 \"register_operand\" \"\")\n+\t\t(match_operand:TF 2 \"register_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\")\n+\n (define_expand \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n  \t(div:DF (match_operand:DF 1 \"register_operand\" \"\")\n@@ -6381,6 +6931,13 @@\n   \"TARGET_80387\"\n   \"ix86_expand_unary_operator (NEG, XFmode, operands); DONE;\")\n \n+(define_expand \"negtf2\"\n+  [(parallel [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:TF (match_operand:TF 1 \"nonimmediate_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (NEG, TFmode, operands); DONE;\")\n+\n ;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n ;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n ;; to itself.\n@@ -6410,6 +6967,35 @@\n   \"operands[1] = GEN_INT (0x8000);\n    operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n \n+;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n+;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n+;; to itself.\n+(define_insn \"*negtf2_if\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n+\t(neg:TF (match_operand:TF 1 \"nonimmediate_operand\" \"0,0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && ix86_unary_operator_ok (NEG, TFmode, operands)\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && FP_REGNO_P (REGNO (operands[0])) && reload_completed\"\n+  [(set (match_dup 0)\n+\t(neg:TF (match_dup 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n+  [(parallel [(set (match_dup 0) (xor:SI (match_dup 0) (match_dup 1)))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[1] = GEN_INT (0x8000);\n+   operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n+\n ;; Conditionize these after reload. If they matches before reload, we \n ;; lose the clobber and ability to use integer instructions.\n \n@@ -6469,6 +7055,35 @@\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"*negtf2_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_80387 && reload_completed\"\n+  \"fchs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"*negextenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(neg:TF (float_extend:TF\n+\t\t  (match_operand:DF 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_80387\"\n+  \"fchs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"*negextendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(neg:TF (float_extend:TF\n+\t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_80387\"\n+  \"fchs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"ppro_uops\" \"few\")])\n \f\n ;; Absolute value instructions\n \n@@ -6570,6 +7185,13 @@\n   \"TARGET_80387\"\n   \"ix86_expand_unary_operator (ABS, XFmode, operands); DONE;\")\n \n+(define_expand \"abstf2\"\n+  [(parallel [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:TF (match_operand:TF 1 \"nonimmediate_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (ABS, TFmode, operands); DONE;\")\n+\n ;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n ;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n ;; to itself.\n@@ -6599,6 +7221,32 @@\n   \"operands[1] = GEN_INT (~0x8000);\n    operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n \n+(define_insn \"*abstf2_if\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n+\t(abs:TF (match_operand:TF 1 \"nonimmediate_operand\" \"0,0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && ix86_unary_operator_ok (ABS, TFmode, operands)\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && FP_REGNO_P (REGNO (operands[0])) && reload_completed\"\n+  [(set (match_dup 0)\n+\t(abs:TF (match_dup 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && reload_completed && !FP_REGNO_P (REGNO (operands[0]))\"\n+  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[1] = GEN_INT (~0x8000);\n+   operands[0] = gen_rtx_REG (SImode, true_regnum (operands[0]) + 2);\")\n+\n (define_insn \"*abssf2_1\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n@@ -6649,6 +7297,32 @@\n   \"fabs\"\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"*abstf2_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_80387 && reload_completed\"\n+  \"fabs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*absextenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(abs:TF (float_extend:TF\n+\t  (match_operand:DF 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_80387\"\n+  \"fabs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"*absextendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(abs:TF (float_extend:TF\n+\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_80387\"\n+  \"fabs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"XF\")])\n \f\n ;; One complement instructions\n \n@@ -9345,6 +10019,19 @@\n            (const_string \"fop\")))\n    (set_attr \"mode\" \"XF\")])\n \n+(define_insn \"*fop_tf_comm\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:TF 1 \"register_operand\" \"%0\")\n+\t\t\t (match_operand:TF 2 \"register_operand\" \"f\")]))]\n+  \"TARGET_80387 && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (if_then_else (match_operand:TF 3 \"mult_operator\" \"\") \n+           (const_string \"fmul\")\n+           (const_string \"fop\")))\n+   (set_attr \"mode\" \"XF\")])\n+\n (define_insn \"*fop_sf_1\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:SF 3 \"binary_fp_operator\"\n@@ -9504,6 +10191,23 @@\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"XF\")])\n \n+(define_insn \"*fop_tf_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:TF 1 \"register_operand\" \"0,f\")\n+\t\t\t (match_operand:TF 2 \"register_operand\" \"f,0\")]))]\n+  \"TARGET_80387\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"XF\")])\n+\n (define_insn \"*fop_xf_2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n@@ -9522,6 +10226,24 @@\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"ppro_uops\" \"many\")])\n \n+(define_insn \"*fop_tf_2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t   [(float:TF (match_operand:SI 1 \"nonimmediate_operand\" \"m,?r\"))\n+\t    (match_operand:TF 2 \"register_operand\" \"0,0\")]))]\n+  \"TARGET_80387 && TARGET_USE_FIOP\"\n+  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"fp_int_src\" \"true\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"ppro_uops\" \"many\")])\n+\n (define_insn \"*fop_xf_3\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n@@ -9540,6 +10262,24 @@\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"ppro_uops\" \"many\")])\n \n+(define_insn \"*fop_tf_3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t  [(match_operand:TF 1 \"register_operand\" \"0,0\")\n+\t   (float:TF (match_operand:SI 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n+  \"TARGET_80387 && TARGET_USE_FIOP\"\n+  \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"fp_int_src\" \"true\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"ppro_uops\" \"many\")])\n+\n (define_insn \"*fop_xf_4\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n@@ -9556,6 +10296,22 @@\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"SF\")])\n \n+(define_insn \"*fop_tf_4\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t   [(float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"fm,0\"))\n+\t    (match_operand:TF 2 \"register_operand\" \"0,f\")]))]\n+  \"TARGET_80387\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"SF\")])\n+\n (define_insn \"*fop_xf_5\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n@@ -9573,6 +10329,23 @@\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"SF\")])\n \n+(define_insn \"*fop_tf_5\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t  [(match_operand:TF 1 \"register_operand\" \"0,f\")\n+\t   (float_extend:TF\n+\t    (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\"))]))]\n+  \"TARGET_80387\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"SF\")])\n+\n (define_insn \"*fop_xf_6\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n@@ -9589,6 +10362,22 @@\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"DF\")])\n \n+(define_insn \"*fop_tf_6\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t   [(float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"fm,0\"))\n+\t    (match_operand:TF 2 \"register_operand\" \"0,f\")]))]\n+  \"TARGET_80387\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"DF\")])\n+\n (define_insn \"*fop_xf_7\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(match_operator:XF 3 \"binary_fp_operator\"\n@@ -9606,6 +10395,23 @@\n               (const_string \"fop\")))\n    (set_attr \"mode\" \"DF\")])\n \n+(define_insn \"*fop_tf_7\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:TF 3 \"binary_fp_operator\"\n+\t  [(match_operand:TF 1 \"register_operand\" \"0,f\")\n+\t   (float_extend:TF\n+\t    (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0\"))]))]\n+  \"TARGET_80387\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:TF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:TF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"DF\")])\n+\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(match_operator 3 \"binary_fp_operator\"\n@@ -9689,6 +10495,16 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"athlon_decode\" \"direct\")])\n \n+(define_insn \"sqrttf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"0\")))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && (TARGET_IEEE_FP || flag_fast_math) \"\n+  \"fsqrt\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n+\n (define_insn \"*sqrtextenddfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(sqrt:XF (float_extend:XF\n@@ -9699,6 +10515,16 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"athlon_decode\" \"direct\")])\n \n+(define_insn \"*sqrtextenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(sqrt:TF (float_extend:TF\n+\t\t  (match_operand:DF 1 \"register_operand\" \"0\"))))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\"\n+  \"fsqrt\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n+\n (define_insn \"*sqrtextendsfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(sqrt:XF (float_extend:XF\n@@ -9709,6 +10535,16 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"athlon_decode\" \"direct\")])\n \n+(define_insn \"*sqrtextendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(sqrt:TF (float_extend:TF\n+\t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\"\n+  \"fsqrt\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"athlon_decode\" \"direct\")])\n+\n (define_insn \"sindf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n@@ -9742,6 +10578,14 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n+(define_insn \"sintf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(unspec:TF [(match_operand:TF 1 \"register_operand\" \"0\")] 1))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"fsin\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"XF\")])\n+\n (define_insn \"cosdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 2))]\n@@ -9774,6 +10618,14 @@\n   \"fcos\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"costf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(unspec:TF [(match_operand:TF 1 \"register_operand\" \"0\")] 2))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"fcos\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"XF\")])\n \f\n ;; Block operation instructions\n \n@@ -10712,6 +11564,14 @@\n   \"TARGET_CMOVE\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n+(define_expand \"movtfcc\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(if_then_else:TF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:TF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+  \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n+\n (define_insn \"*movxfcc_1\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:XF (match_operator 1 \"fcmov_comparison_operator\" \n@@ -10724,6 +11584,19 @@\n    fcmov%f1\\\\t{%3, %0|%0, %3}\"\n   [(set_attr \"type\" \"fcmov\")\n    (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"*movtfcc_1\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+\t(if_then_else:TF (match_operator 1 \"fcmov_comparison_operator\" \n+\t\t\t\t[(reg 17) (const_int 0)])\n+\t\t      (match_operand:TF 2 \"register_operand\" \"f,0\")\n+\t\t      (match_operand:TF 3 \"register_operand\" \"0,f\")))]\n+  \"TARGET_CMOVE\"\n+  \"@\n+   fcmov%F1\\\\t{%2, %0|%0, %2}\n+   fcmov%f1\\\\t{%3, %0|%0, %3}\"\n+  [(set_attr \"type\" \"fcmov\")\n+   (set_attr \"mode\" \"XF\")])\n \f\n ;; Misc patterns (?)\n "}, {"sha": "c8cdb1a669280535791bca3bf438d8a1dfe85390", "filename": "gcc/invoke.texi", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b589241d86c1f2e68d5f2dbceb60f19050bd199/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=2b589241d86c1f2e68d5f2dbceb60f19050bd199", "patch": "@@ -446,7 +446,8 @@ in the following sections.\n -malign-jumps=@var{num}  -malign-loops=@var{num}\n -malign-functions=@var{num} -mpreferred-stack-boundary=@var{num}\n -mthreads -mno-align-stringops -minline-all-stringops\n--mpush-args -maccumulate-outgoing-args\n+-mpush-args -maccumulate-outgoing-args -m128bit-long-double\n+-m96bit-long-double\n \n @emph{HPPA Options}\n -march=@var{architecture type}\n@@ -6344,9 +6345,22 @@ boundary.  Aligning @code{double} variables on a two word boundary will\n produce code that runs somewhat faster on a @samp{Pentium} at the\n expense of more memory.\n \n-@strong{Warning:} if you use the @samp{-malign-double} switch,\n-structures containing the above types will be aligned differently than\n-the published application binary interface specifications for the 386.\n+@item -m128bit-long-double\n+@itemx -m128bit-long-double\n+Control the size of @code{long double} type. i386 application binary interface\n+specify the size to be 12 bytes, while modern architectures (Pentium and newer)\n+preffer @code{long double} aligned to 8 or 16 byte boundary.  This is\n+impossible to reach with 12 byte long doubles in the array accesses.\n+\n+@strong{Warning:} if you use the @samp{-m128bit-long-double} switch, the\n+structures and arrays containing @code{long double} will change their size as\n+well as function calling convention for function taking @code{long double}\n+will be modified. \n+\n+@item -m96bit-long-double\n+@itemx -m96bit-long-double\n+Set the size of @code{long double} to 96 bytes as requires by the i386\n+application binary interface.  This is the default.\n \n @item -msvr3-shlib\n @itemx -mno-svr3-shlib"}]}