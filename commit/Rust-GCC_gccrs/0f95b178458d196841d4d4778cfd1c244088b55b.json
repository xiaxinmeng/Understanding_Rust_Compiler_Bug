{"sha": "0f95b178458d196841d4d4778cfd1c244088b55b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5NWIxNzg0NThkMTk2ODQxZDRkNDc3OGNmZDFjMjQ0MDg4YjU1Yg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:23:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:23:46Z"}, "message": "exp_aggr.ads, [...]:\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_aggr.ads, exp_aggr.adb: \n\t(Build_Record_Aggr_Code): Add missing initialization of secondary tags\n\tin extension aggregates.\n\t(Flatten): Other conditions being met, an aggregate is static if the\n\tlow bound given by component associations is different from the low\n\tbound of the base index type.\n\t(Packed_Array_Aggregate_Handled): If the component type is itself a\n\tpacked array or record, the front-end must expand into assignments.\n\t(Gen_Ctrl_Actions_For_Aggr): In call to Init_Controller, pass False to\n\tInit_Pr, instead of Ancestor_Is_Expression.\n\t(Gen_Ctrl_Actions_For_Aggr): When processing an aggregate of a\n\tcoextension chain root, either generate a list controller or use the\n\talready existing one.\n\t(Static_Array_Aggregate): New procedure to construct a positional\n\taggregate that can be handled by the backend, when all bounds and\n\tcomponents are compile-time known constants.\n\t(Expand_Record_Aggregate): Force conversion of aggregates of tagged\n\ttypes covering interface types into assignments.\n\t(Replace_Type): move to Build_Record_Aggr_Code.\n\t(Expand_Record_Aggr_Code): if the target of the aggregate is an\n\tinterface type, convert to the definite type of the aggregate itself,\n\tso that needed components are visible.\n\t(Convert_Aggr_In_Object_Decl): If the aggregate has controlled\n\tcomponents and the context is an extended return statement do not\n\tcreate a transient block for it, to prevent premature finalization\n\tbefore the return is executed.\n\t(Gen_Assign): Do not generate a call to deep adjust routine if the\n\tcomponent type is itself an array of controlled (sub)-components\n\tinitialized with an inner aggregate.\n\t(Component_Check): New name for Static_Check. This name is now more\n\tappropriate, and documentation is added which was missing.\n\t(Component_Check): Add test for bit aligned component value\n\t(Component_Not_OK_For_Backend): Renames Has_Delayed_Nested_Aggregate_Or_\n\tTagged_Comps, name is more appropriate given added function below.\n\t(Component_Not_OK_For_Backend): Check for bit aligned component ref.\n\nFrom-SVN: r125392", "tree": {"sha": "cb75da563e6c1787ba67edcfc858e37bd47c9e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb75da563e6c1787ba67edcfc858e37bd47c9e10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f95b178458d196841d4d4778cfd1c244088b55b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f95b178458d196841d4d4778cfd1c244088b55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f95b178458d196841d4d4778cfd1c244088b55b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f95b178458d196841d4d4778cfd1c244088b55b/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c28fe3afee2a7dde65f9aa96560d0170af3aae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c28fe3afee2a7dde65f9aa96560d0170af3aae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c28fe3afee2a7dde65f9aa96560d0170af3aae7"}], "stats": {"total": 770, "additions": 605, "deletions": 165}, "files": [{"sha": "6321dc55d7485e5003c363af69c93f66492b520c", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 592, "deletions": 162, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f95b178458d196841d4d4778cfd1c244088b55b/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f95b178458d196841d4d4778cfd1c244088b55b/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=0f95b178458d196841d4d4778cfd1c244088b55b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,9 +36,9 @@ with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Tss;  use Exp_Tss;\n with Freeze;   use Freeze;\n-with Hostparm; use Hostparm;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n+with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n@@ -54,6 +54,7 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -121,7 +122,7 @@ package body Exp_Aggr is\n    function Build_Record_Aggr_Code\n      (N                             : Node_Id;\n       Typ                           : Entity_Id;\n-      Target                        : Node_Id;\n+      Lhs                           : Node_Id;\n       Flist                         : Node_Id   := Empty;\n       Obj                           : Entity_Id := Empty;\n       Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id;\n@@ -262,17 +263,11 @@ package body Exp_Aggr is\n    function Make_OK_Assignment_Statement\n      (Sloc       : Source_Ptr;\n       Name       : Node_Id;\n-      Expression : Node_Id;\n-      Self_Ref   : Boolean := False) return Node_Id;\n+      Expression : Node_Id) return Node_Id;\n    --  This is like Make_Assignment_Statement, except that Assignment_OK\n    --  is set in the left operand. All assignments built by this unit\n    --  use this routine. This is needed to deal with assignments to\n    --  initialized constants that are done in place.\n-   --  If Self_Ref is true, the aggregate contains an access reference to the\n-   --  enclosing type, obtained from a default initialization. The reference\n-   --  as to be expanded into a reference to  the enclosing object, which is\n-   --  obtained from the Name in the assignment. The value of Self_Ref is\n-   --  inherited from the aggregate itself.\n \n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean;\n    --  Given an array aggregate, this function handles the case of a packed\n@@ -451,61 +446,90 @@ package body Exp_Aggr is\n    --    4. The array type of N does not follow the Fortran layout convention\n    --       or if it does it must be 1 dimensional.\n \n-   --    5. The array component type is tagged, which may necessitate\n-   --       reassignment of proper tags.\n+   --    5. The array component type may not be tagged (which could necessitate\n+   --       reassignment of proper tags).\n \n-   --    6. The array component type might have unaligned bit components\n+   --    6. The array component type must not have unaligned bit components\n+\n+   --    7. None of the components of the aggregate may be bit unaligned\n+   --       components.\n+\n+   --    8. There cannot be delayed components, since we do not know enough\n+   --       at this stage to know if back end processing is possible.\n+\n+   --    9. There cannot be any discriminated record components, since the\n+   --       back end cannot handle this complex case.\n \n    function Backend_Processing_Possible (N : Node_Id) return Boolean is\n       Typ : constant Entity_Id := Etype (N);\n       --  Typ is the correct constrained array subtype of the aggregate\n \n-      function Static_Check (N : Node_Id; Index : Node_Id) return Boolean;\n-      --  Recursively checks that N is fully positional, returns true if so\n+      function Component_Check (N : Node_Id; Index : Node_Id) return Boolean;\n+      --  This routine checks components of aggregate N, enforcing checks\n+      --  1, 7, 8, and 9. In the multi-dimensional case, these checks are\n+      --  performed on subaggregates. The Index value is the current index\n+      --  being checked in the multi-dimensional case.\n \n-      ------------------\n-      -- Static_Check --\n-      ------------------\n+      ---------------------\n+      -- Component_Check --\n+      ---------------------\n \n-      function Static_Check (N : Node_Id; Index : Node_Id) return Boolean is\n+      function Component_Check (N : Node_Id; Index : Node_Id) return Boolean is\n          Expr : Node_Id;\n \n       begin\n-         --  Check for component associations\n+         --  Checks 1: (no component associations)\n \n          if Present (Component_Associations (N)) then\n             return False;\n          end if;\n \n+         --  Checks on components\n+\n          --  Recurse to check subaggregates, which may appear in qualified\n          --  expressions. If delayed, the front-end will have to expand.\n          --  If the component is a discriminated record, treat as non-static,\n          --  as the back-end cannot handle this properly.\n \n          Expr := First (Expressions (N));\n          while Present (Expr) loop\n+\n+            --  Checks 8: (no delayed components)\n+\n             if Is_Delayed_Aggregate (Expr) then\n                return False;\n             end if;\n \n+            --  Checks 9: (no discriminated records)\n+\n             if Present (Etype (Expr))\n               and then Is_Record_Type (Etype (Expr))\n               and then Has_Discriminants (Etype (Expr))\n             then\n                return False;\n             end if;\n \n+            --  Checks 7. Component must not be bit aligned component\n+\n+            if Possible_Bit_Aligned_Component (Expr) then\n+               return False;\n+            end if;\n+\n+            --  Recursion to following indexes for multiple dimension case\n+\n             if Present (Next_Index (Index))\n-               and then not Static_Check (Expr, Next_Index (Index))\n+               and then not Component_Check (Expr, Next_Index (Index))\n             then\n                return False;\n             end if;\n \n+            --  All checks for that component finished, on to next\n+\n             Next (Expr);\n          end loop;\n \n          return True;\n-      end Static_Check;\n+      end Component_Check;\n \n    --  Start of processing for Backend_Processing_Possible\n \n@@ -530,21 +554,20 @@ package body Exp_Aggr is\n          return False;\n       end if;\n \n-      --  Checks 1 (aggregate must be fully positional)\n+      --  Checks on components\n \n-      if not Static_Check (N, First_Index (Typ)) then\n+      if not Component_Check (N, First_Index (Typ)) then\n          return False;\n       end if;\n \n-      --  Checks 5 (if the component type is tagged, then we may need\n-      --    to do tag adjustments; perhaps this should be refined to check for\n-      --    any component associations that actually need tag adjustment,\n-      --    along the lines of the test that is carried out in\n-      --    Has_Delayed_Nested_Aggregate_Or_Tagged_Comps for record aggregates\n+      --  Checks 5 (if the component type is tagged, then we may need to do\n+      --    tag adjustments. Perhaps this should be refined to check for any\n+      --    component associations that actually need tag adjustment, similar\n+      --    to the test in Component_Not_OK_For_Backend for record aggregates\n       --    with tagged components, but not clear whether it's worthwhile ???;\n       --    in the case of the JVM, object tags are handled implicitly)\n \n-      if Is_Tagged_Type (Component_Type (Typ)) and then not Java_VM then\n+      if Is_Tagged_Type (Component_Type (Typ)) and then VM_Target = No_VM then\n          return False;\n       end if;\n \n@@ -556,7 +579,6 @@ package body Exp_Aggr is\n \n       --  Backend processing is possible\n \n-      Set_Compile_Time_Known_Aggregate (N, True);\n       Set_Size_Known_At_Compile_Time (Etype (N), True);\n       return True;\n    end Backend_Processing_Possible;\n@@ -1094,7 +1116,7 @@ package body Exp_Aggr is\n \n             if Present (Comp_Type)\n               and then Is_Tagged_Type (Comp_Type)\n-              and then not Java_VM\n+              and then VM_Target = No_VM\n             then\n                A :=\n                  Make_OK_Assignment_Statement (Loc,\n@@ -1114,11 +1136,24 @@ package body Exp_Aggr is\n                Append_To (L, A);\n             end if;\n \n-            --  Adjust and Attach the component to the proper final list\n-            --  which can be the controller of the outer record object or\n-            --  the final list associated with the scope\n+            --  Adjust and attach the component to the proper final list, which\n+            --  can be the controller of the outer record object or the final\n+            --  list associated with the scope.\n \n-            if Present (Comp_Type)  and then Controlled_Type (Comp_Type) then\n+            --  If the component is itself an array of controlled types, whose\n+            --  value is given by a sub-aggregate, then the attach calls have\n+            --  been generated when individual subcomponent are assigned, and\n+            --  and must not be done again to prevent malformed finalization\n+            --  chains (see comments above, concerning the creation of a block\n+            --  to hold inner finalization actions).\n+\n+            if Present (Comp_Type)\n+              and then Controlled_Type (Comp_Type)\n+              and then\n+                (not Is_Array_Type (Comp_Type)\n+                   or else not Is_Controlled (Component_Type (Comp_Type))\n+                   or else Nkind (Expr) /= N_Aggregate)\n+            then\n                Append_List_To (L,\n                  Make_Adjust_Call (\n                    Ref         => New_Copy_Tree (Indexed_Comp),\n@@ -1253,7 +1288,17 @@ package body Exp_Aggr is\n                           Iteration_Scheme => L_Iteration_Scheme,\n                           Statements       => L_Body));\n \n-         return S;\n+         --  A small optimization: if the aggregate is initialized with a\n+         --  box and the component type has no initialization procedure,\n+         --  remove the useless empty loop.\n+\n+         if Nkind (First (S)) = N_Loop_Statement\n+           and then Is_Empty_List (Statements (First (S)))\n+         then\n+            return New_List (Make_Null_Statement (Loc));\n+         else\n+            return S;\n+         end if;\n       end Gen_Loop;\n \n       ---------------\n@@ -1605,7 +1650,7 @@ package body Exp_Aggr is\n    function Build_Record_Aggr_Code\n      (N                             : Node_Id;\n       Typ                           : Entity_Id;\n-      Target                        : Node_Id;\n+      Lhs                           : Node_Id;\n       Flist                         : Node_Id   := Empty;\n       Obj                           : Entity_Id := Empty;\n       Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id\n@@ -1617,6 +1662,7 @@ package body Exp_Aggr is\n       Comp      : Node_Id;\n       Instr     : Node_Id;\n       Ref       : Node_Id;\n+      Target    : Entity_Id;\n       F         : Node_Id;\n       Comp_Type : Entity_Id;\n       Selector  : Entity_Id;\n@@ -1639,7 +1685,8 @@ package body Exp_Aggr is\n       Attach   : Node_Id;\n \n       Ctrl_Stuff_Done : Boolean := False;\n-      --  Could use comments here ???\n+      --  True if Gen_Ctrl_Actions_For_Aggr has already been called; calls\n+      --  after the first do nothing.\n \n       function Ancestor_Discriminant_Value (Disc : Entity_Id) return Node_Id;\n       --  Returns the value that the given discriminant of an ancestor\n@@ -1659,8 +1706,8 @@ package body Exp_Aggr is\n       --  assumed that both bounds are integer ranges.\n \n       procedure Gen_Ctrl_Actions_For_Aggr;\n-      --  Deal with the various controlled type data structure\n-      --  initializations.\n+      --  Deal with the various controlled type data structure initializations\n+      --  (but only if it hasn't been done already).\n \n       function Get_Constraint_Association (T : Entity_Id) return Node_Id;\n       --  Returns the first discriminant association in the constraint\n@@ -1672,10 +1719,10 @@ package body Exp_Aggr is\n          F       : Node_Id;\n          Attach  : Node_Id;\n          Init_Pr : Boolean) return List_Id;\n-      --  returns the list of statements necessary to initialize the internal\n-      --  controller of the (possible) ancestor typ into target and attach\n-      --  it to finalization list F. Init_Pr conditions the call to the\n-      --  init proc since it may already be done due to ancestor initialization\n+      --  Returns the list of statements necessary to initialize the internal\n+      --  controller of the (possible) ancestor typ into target and attach it\n+      --  to finalization list F. Init_Pr conditions the call to the init proc\n+      --  since it may already be done due to ancestor initialization.\n \n       function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean;\n       --  Check whether Bounds is a range node and its lower and higher bounds\n@@ -1880,7 +1927,7 @@ package body Exp_Aggr is\n       end Get_Constraint_Association;\n \n       ---------------------\n-      -- Init_controller --\n+      -- Init_Controller --\n       ---------------------\n \n       function Init_Controller\n@@ -1972,24 +2019,32 @@ package body Exp_Aggr is\n       -------------------------------\n \n       procedure Gen_Ctrl_Actions_For_Aggr is\n+         Alloc : Node_Id := Empty;\n+\n       begin\n-         if not Ctrl_Stuff_Done then\n-            Ctrl_Stuff_Done := True;\n-         else\n+         --  Do the work only the first time this is called\n+\n+         if Ctrl_Stuff_Done then\n             return;\n          end if;\n \n+         Ctrl_Stuff_Done := True;\n+\n          if Present (Obj)\n-          and then Finalize_Storage_Only (Typ)\n-          and then (Is_Library_Level_Entity (Obj)\n-            or else Entity (Constant_Value (RTE (RE_Garbage_Collected))) =\n-                                                              Standard_True)\n+           and then Finalize_Storage_Only (Typ)\n+           and then\n+             (Is_Library_Level_Entity (Obj)\n+                or else Entity (Constant_Value (RTE (RE_Garbage_Collected))) =\n+                                                          Standard_True)\n+\n+            --  why not Is_True (Expr_Value (RTE (RE_Garbaage_Collected) ???\n          then\n             Attach := Make_Integer_Literal (Loc, 0);\n \n          elsif Nkind (Parent (N)) = N_Qualified_Expression\n            and then Nkind (Parent (Parent (N))) = N_Allocator\n          then\n+            Alloc  := Parent (Parent (N));\n             Attach := Make_Integer_Literal (Loc, 2);\n \n          else\n@@ -2003,19 +2058,37 @@ package body Exp_Aggr is\n          --  potentially transient current scope.\n \n          if Controlled_Type (Typ) then\n-            if Present (Flist) then\n+\n+            --  The current aggregate belongs to an allocator which acts as\n+            --  the root of a coextension chain.\n+\n+            if Present (Alloc)\n+              and then Is_Coextension_Root (Alloc)\n+            then\n+               if No (Associated_Final_Chain (Etype (Alloc))) then\n+                  Build_Final_List (Alloc, Etype (Alloc));\n+               end if;\n+\n+               External_Final_List :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix =>\n+                     New_Reference_To (\n+                       Associated_Final_Chain (Etype (Alloc)), Loc),\n+                   Selector_Name =>\n+                     Make_Identifier (Loc, Name_F));\n+\n+            elsif Present (Flist) then\n                External_Final_List := New_Copy_Tree (Flist);\n \n             elsif Is_Entity_Name (Target)\n               and then Present (Scope (Entity (Target)))\n             then\n-               External_Final_List\n-                 := Find_Final_List (Scope (Entity (Target)));\n+               External_Final_List :=\n+                 Find_Final_List (Scope (Entity (Target)));\n \n             else\n                External_Final_List := Find_Final_List (Current_Scope);\n             end if;\n-\n          else\n             External_Final_List := Empty;\n          end if;\n@@ -2037,11 +2110,26 @@ package body Exp_Aggr is\n             if not Has_Controlled_Component (Typ) then\n                Ref := New_Copy_Tree (Target);\n                Set_Assignment_OK (Ref);\n-               Append_To (L,\n-                 Make_Attach_Call (\n-                   Obj_Ref     => Ref,\n-                   Flist_Ref   => New_Copy_Tree (External_Final_List),\n-                   With_Attach => Attach));\n+\n+               --  This is an aggregate of a coextension. Do not produce a\n+               --  finalization call, but rather attach the reference of the\n+               --  aggregate to its coextension chain.\n+\n+               if Present (Alloc)\n+                 and then Is_Coextension (Alloc)\n+               then\n+                  if No (Coextensions (Alloc)) then\n+                     Set_Coextensions (Alloc, New_Elmt_List);\n+                  end if;\n+\n+                  Append_Elmt (Ref, Coextensions (Alloc));\n+               else\n+                  Append_To (L,\n+                    Make_Attach_Call (\n+                      Obj_Ref     => Ref,\n+                      Flist_Ref   => New_Copy_Tree (External_Final_List),\n+                      With_Attach => Attach));\n+               end if;\n             end if;\n          end if;\n \n@@ -2162,21 +2250,83 @@ package body Exp_Aggr is\n                       Typ     => Init_Typ,\n                       F       => F,\n                       Attach  => Attach,\n-                      Init_Pr => Ancestor_Is_Expression));\n+                      Init_Pr => False));\n+\n+                     --  Note: Init_Pr is False because the ancestor part has\n+                     --  already been initialized either way (by default, if\n+                     --  given by a type name, otherwise from the expression).\n+\n                end if;\n             end;\n          end if;\n       end Gen_Ctrl_Actions_For_Aggr;\n \n+      function Replace_Type (Expr : Node_Id) return Traverse_Result;\n+      --  If the aggregate contains a self-reference, traverse each\n+      --  expression to replace a possible self-reference with a reference\n+      --  to the proper component of the target of the assignment.\n+\n+      ------------------\n+      -- Replace_Type --\n+      ------------------\n+\n+      function Replace_Type (Expr : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (Expr) = N_Attribute_Reference\n+           and  then Is_Entity_Name (Prefix (Expr))\n+           and then Is_Type (Entity (Prefix (Expr)))\n+         then\n+            if Is_Entity_Name (Lhs) then\n+               Rewrite (Prefix (Expr),\n+                 New_Occurrence_Of (Entity (Lhs), Loc));\n+\n+            elsif Nkind (Lhs) = N_Selected_Component then\n+               Rewrite (Expr,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Unrestricted_Access,\n+                   Prefix         => New_Copy_Tree (Prefix (Lhs))));\n+               Set_Analyzed (Parent (Expr), False);\n+\n+            else\n+               Rewrite (Expr,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Unrestricted_Access,\n+                   Prefix         => New_Copy_Tree (Lhs)));\n+               Set_Analyzed (Parent (Expr), False);\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Replace_Type;\n+\n+      procedure Replace_Self_Reference is\n+        new Traverse_Proc (Replace_Type);\n+\n    --  Start of processing for Build_Record_Aggr_Code\n \n    begin\n+      if Has_Self_Reference (N) then\n+         Replace_Self_Reference (N);\n+      end if;\n+\n+      --  If the target of the aggregate is class-wide, we must convert it\n+      --  to the actual type of the aggregate, so that the proper components\n+      --  are visible. We know already that the types are compatible.\n+\n+      if Present (Etype (Lhs))\n+        and then Is_Interface (Etype (Lhs))\n+      then\n+         Target := Unchecked_Convert_To (Typ, Lhs);\n+      else\n+         Target := Lhs;\n+      end if;\n+\n       --  Deal with the ancestor part of extension aggregates\n       --  or with the discriminants of the root type\n \n       if Nkind (N) = N_Extension_Aggregate then\n          declare\n-            A : constant Node_Id := Ancestor_Part (N);\n+            A      : constant Node_Id := Ancestor_Part (N);\n             Assign : List_Id;\n \n          begin\n@@ -2280,7 +2430,7 @@ package body Exp_Aggr is\n                   Build_Record_Aggr_Code (\n                     N                             => Unqualify (A),\n                     Typ                           => Etype (Unqualify (A)),\n-                    Target                        => Target,\n+                    Lhs                           => Target,\n                     Flist                         => Flist,\n                     Obj                           => Obj,\n                     Is_Limited_Ancestor_Expansion => True));\n@@ -2316,15 +2466,14 @@ package body Exp_Aggr is\n                Assign := New_List (\n                  Make_OK_Assignment_Statement (Loc,\n                    Name       => Ref,\n-                   Expression => A,\n-                   Self_Ref   => Has_Self_Reference (N)));\n+                   Expression => A));\n                Set_No_Ctrl_Actions (First (Assign));\n \n                --  Assign the tag now to make sure that the dispatching call in\n-               --  the subsequent deep_adjust works properly (unless Java_VM,\n+               --  the subsequent deep_adjust works properly (unless VM_Target,\n                --  where tags are implicit).\n \n-               if not Java_VM then\n+               if VM_Target = No_VM then\n                   Instr :=\n                     Make_OK_Assignment_Statement (Loc,\n                       Name =>\n@@ -2343,6 +2492,20 @@ package body Exp_Aggr is\n \n                   Set_Assignment_OK (Name (Instr));\n                   Append_To (Assign, Instr);\n+\n+                  --  Ada 2005 (AI-251): If tagged type has progenitors we must\n+                  --  also initialize tags of the secondary dispatch tables.\n+\n+                  if Present (Abstract_Interfaces (Base_Type (Typ)))\n+                    and then not\n+                      Is_Empty_Elmt_List\n+                        (Abstract_Interfaces (Base_Type (Typ)))\n+                  then\n+                     Init_Secondary_Tags\n+                       (Typ        => Base_Type (Typ),\n+                        Target     => Target,\n+                        Stmts_List => Assign);\n+                  end if;\n                end if;\n \n                --  Call Adjust manually\n@@ -2690,19 +2853,18 @@ package body Exp_Aggr is\n                Instr :=\n                  Make_OK_Assignment_Statement (Loc,\n                    Name       => Comp_Expr,\n-                   Expression => Expression (Comp),\n-                   Self_Ref   => Has_Self_Reference (N));\n+                   Expression => Expression (Comp));\n \n                Set_No_Ctrl_Actions (Instr);\n                Append_To (L, Instr);\n \n                --  Adjust the tag if tagged (because of possible view\n-               --  conversions), unless compiling for the Java VM\n-               --  where tags are implicit.\n+               --  conversions), unless compiling for a VM where tags are\n+               --  implicit.\n \n                --    tmp.comp._tag := comp_typ'tag;\n \n-               if Is_Tagged_Type (Comp_Type) and then not Java_VM then\n+               if Is_Tagged_Type (Comp_Type) and then VM_Target = No_VM then\n                   Instr :=\n                     Make_OK_Assignment_Statement (Loc,\n                       Name =>\n@@ -2762,13 +2924,45 @@ package body Exp_Aggr is\n \n                pragma Assert (Present (D_Val));\n \n-               Append_To (L,\n-               Make_Raise_Constraint_Error (Loc,\n-                 Condition =>\n-                   Make_Op_Ne (Loc,\n-                     Left_Opnd => New_Copy_Tree (Node (D_Val)),\n-                     Right_Opnd => Expression (Comp)),\n-                 Reason => CE_Discriminant_Check_Failed));\n+               --  This check cannot performed for components that are\n+               --  constrained by a current instance, because this is not a\n+               --  value that can be compared with the actual constraint.\n+\n+               if Nkind (Node (D_Val)) /= N_Attribute_Reference\n+                 or else not Is_Entity_Name (Prefix (Node (D_Val)))\n+                 or else not Is_Type (Entity (Prefix (Node (D_Val))))\n+               then\n+                  Append_To (L,\n+                  Make_Raise_Constraint_Error (Loc,\n+                    Condition =>\n+                      Make_Op_Ne (Loc,\n+                        Left_Opnd => New_Copy_Tree (Node (D_Val)),\n+                        Right_Opnd => Expression (Comp)),\n+                      Reason => CE_Discriminant_Check_Failed));\n+\n+               else\n+                  --  Find self-reference in previous discriminant\n+                  --  assignment, and replace with proper expression.\n+\n+                  declare\n+                     Ass : Node_Id;\n+\n+                  begin\n+                     Ass := First (L);\n+                     while Present (Ass) loop\n+                        if Nkind (Ass) = N_Assignment_Statement\n+                          and then Nkind (Name (Ass)) = N_Selected_Component\n+                          and then Chars (Selector_Name (Name (Ass))) =\n+                             Chars (Disc)\n+                        then\n+                           Set_Expression\n+                             (Ass, New_Copy_Tree (Expression (Comp)));\n+                           exit;\n+                        end if;\n+                        Next (Ass);\n+                     end loop;\n+                  end;\n+               end if;\n             end;\n          end if;\n \n@@ -2785,7 +2979,7 @@ package body Exp_Aggr is\n       if Ancestor_Is_Expression then\n          null;\n \n-      elsif Is_Tagged_Type (Typ) and then not Java_VM then\n+      elsif Is_Tagged_Type (Typ) and then VM_Target = No_VM then\n          Instr :=\n            Make_OK_Assignment_Statement (Loc,\n              Name =>\n@@ -2878,8 +3072,12 @@ package body Exp_Aggr is\n             --  ??? Dubious actual for Obj: expect 'the original object\n             --  being initialized'\n \n-            Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n-            Insert_Actions_After (Decl, L);\n+            if Has_Task (Typ) then\n+               Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n+               Insert_Actions_After (Decl, L);\n+            else\n+               Insert_Actions_After (Decl, Init_Stmts);\n+            end if;\n          end;\n \n       else\n@@ -3010,7 +3208,15 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      if Requires_Transient_Scope (Typ) then\n+      --  If the context is an extended return statement, it has its own\n+      --  finalization machinery (i.e. works like a transient scope) and\n+      --  we do not want to create an additional one, because objects on\n+      --  the finalization list of the return must be moved to the caller's\n+      --  finalization list to complete the return.\n+\n+      if Requires_Transient_Scope (Typ)\n+        and then Ekind (Current_Scope) /= E_Return_Statement\n+      then\n          Establish_Transient_Scope (Aggr, Sec_Stack =>\n            Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n       end if;\n@@ -3088,22 +3294,33 @@ package body Exp_Aggr is\n       end if;\n \n       --  Just set the Delay flag in the following cases where the\n-      --  transformation will be done top down from above\n+      --  transformation will be done top down from above:\n \n       --    - internal aggregate (transformed when expanding the parent)\n+\n       --    - allocators  (see Convert_Aggr_In_Allocator)\n+\n       --    - object decl (see Convert_Aggr_In_Object_Decl)\n+\n       --    - safe assignments (see Convert_Aggr_Assignments)\n       --      so far only the assignments in the init procs are taken\n       --      into account\n \n+      --    - (Ada 2005) A limited type in a return statement, which will\n+      --       be rewritten as an extended return and may have its own\n+      --       finalization machinery.\n+\n       if Parent_Kind = N_Aggregate\n         or else Parent_Kind = N_Extension_Aggregate\n         or else Parent_Kind = N_Component_Association\n         or else Parent_Kind = N_Allocator\n         or else (Parent_Kind = N_Object_Declaration and then not Unc_Decl)\n         or else (Parent_Kind = N_Assignment_Statement\n                   and then Inside_Init_Proc)\n+        or else\n+          (Is_Limited_Record (Typ)\n+            and then Present (Parent (Parent (N)))\n+            and then Nkind (Parent (Parent (N))) = N_Return_Statement)\n       then\n          Set_Expansion_Delayed (N);\n          return;\n@@ -3144,6 +3361,13 @@ package body Exp_Aggr is\n    is\n       Typ : constant Entity_Id := Etype (N);\n \n+      Static_Components : Boolean := True;\n+\n+      procedure Check_Static_Components;\n+      --  Check whether all components of the aggregate are compile-time\n+      --  known values, and can be passed as is to the back-end without\n+      --  further expansion.\n+\n       function Flatten\n         (N   : Node_Id;\n          Ix  : Node_Id;\n@@ -3156,6 +3380,56 @@ package body Exp_Aggr is\n       --  Return True iff the array N is flat (which is not rivial\n       --  in the case of multidimensionsl aggregates).\n \n+      -----------------------------\n+      -- Check_Static_Components --\n+      -----------------------------\n+\n+      procedure Check_Static_Components is\n+         Expr : Node_Id;\n+\n+      begin\n+         Static_Components := True;\n+\n+         if Nkind (N) = N_String_Literal then\n+            null;\n+\n+         elsif Present (Expressions (N)) then\n+            Expr := First (Expressions (N));\n+            while Present (Expr) loop\n+               if Nkind (Expr) /= N_Aggregate\n+                 or else not Compile_Time_Known_Aggregate (Expr)\n+                 or else Expansion_Delayed (Expr)\n+               then\n+                  Static_Components := False;\n+                  exit;\n+               end if;\n+\n+               Next (Expr);\n+            end loop;\n+         end if;\n+\n+         if Nkind (N) = N_Aggregate\n+           and then  Present (Component_Associations (N))\n+         then\n+            Expr := First (Component_Associations (N));\n+            while Present (Expr) loop\n+               if Nkind (Expression (Expr)) = N_Integer_Literal then\n+                  null;\n+\n+               elsif Nkind (Expression (Expr)) /= N_Aggregate\n+                 or else\n+                   not Compile_Time_Known_Aggregate (Expression (Expr))\n+                 or else Expansion_Delayed (Expression (Expr))\n+               then\n+                  Static_Components := False;\n+                  exit;\n+               end if;\n+\n+               Next (Expr);\n+            end loop;\n+         end if;\n+      end Check_Static_Components;\n+\n       -------------\n       -- Flatten --\n       -------------\n@@ -3177,18 +3451,17 @@ package body Exp_Aggr is\n             return True;\n          end if;\n \n-         --  Only handle bounds starting at the base type low bound\n-         --  for now since the compiler isn't able to handle different low\n-         --  bounds yet. Case such as new String'(3..5 => ' ') will get\n-         --  the wrong bounds, though it seems that the aggregate should\n-         --  retain the bounds set on its Etype (see C64103E and CC1311B).\n+         if not Compile_Time_Known_Value (Lo)\n+           or else not Compile_Time_Known_Value (Hi)\n+         then\n+            return False;\n+         end if;\n \n          Lov := Expr_Value (Lo);\n          Hiv := Expr_Value (Hi);\n \n          if Hiv < Lov\n            or else not Compile_Time_Known_Value (Blo)\n-           or else (Lov /= Expr_Value (Blo))\n          then\n             return False;\n          end if;\n@@ -3418,10 +3691,29 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n+      Check_Static_Components;\n+\n+      --  If the size is known, or all the components are static, try to\n+      --  build a fully positional aggregate.\n+\n+      --  The size of the type  may not be known for an aggregate with\n+      --  discriminated array components, but if the components are static\n+      --  it is still possible to verify statically that the length is\n+      --  compatible with the upper bound of the type, and therefore it is\n+      --  worth flattening such aggregates as well.\n+\n+      --  For now the back-end expands these aggregates into individual\n+      --  assignments to the target anyway, but it is conceivable that\n+      --  it will eventually be able to treat such aggregates statically???\n+\n       if Aggr_Size_OK (Typ)\n-        and then\n-          Flatten (N, First_Index (Typ), First_Index (Base_Type (Typ)))\n+        and then Flatten (N, First_Index (Typ), First_Index (Base_Type (Typ)))\n       then\n+         if Static_Components then\n+            Set_Compile_Time_Known_Aggregate (N);\n+            Set_Expansion_Delayed (N, False);\n+         end if;\n+\n          Analyze_And_Resolve (N, Typ);\n       end if;\n    end Convert_To_Positional;\n@@ -4393,7 +4685,14 @@ package body Exp_Aggr is\n \n       --  At this point we try to convert to positional form\n \n-      Convert_To_Positional (N);\n+      if Ekind (Current_Scope) = E_Package\n+        and then Static_Elaboration_Desired (Current_Scope)\n+      then\n+         Convert_To_Positional (N, Max_Others_Replicate => 100);\n+\n+      else\n+         Convert_To_Positional (N);\n+      end if;\n \n       --  if the result is no longer an aggregate (e.g. it may be a string\n       --  literal, or a temporary which has the needed value), then we are\n@@ -4411,6 +4710,14 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n+      --  If all aggregate components are compile-time known and\n+      --  the aggregate has been flattened, nothing left to do.\n+\n+      if Compile_Time_Known_Aggregate (N) then\n+         Set_Expansion_Delayed (N, False);\n+         return;\n+      end if;\n+\n       --  Now see if back end processing is possible\n \n       if Backend_Processing_Possible (N) then\n@@ -4467,8 +4774,15 @@ package body Exp_Aggr is\n         or else (Parent_Kind = N_Assignment_Statement\n                   and then Inside_Init_Proc)\n       then\n-         Set_Expansion_Delayed (N);\n-         return;\n+         if Static_Array_Aggregate (N)\n+           or else Compile_Time_Known_Aggregate (N)\n+         then\n+            Set_Expansion_Delayed (N, False);\n+            return;\n+         else\n+            Set_Expansion_Delayed (N);\n+            return;\n+         end if;\n       end if;\n \n       --  STEP 4\n@@ -4682,7 +4996,6 @@ package body Exp_Aggr is\n       else\n          Expand_Array_Aggregate (N);\n       end if;\n-\n    exception\n       when RE_Not_Available =>\n          return;\n@@ -4721,17 +5034,16 @@ package body Exp_Aggr is\n       else\n          Set_Etype (N, Typ);\n \n-         --  No tag is needed in the case of Java_VM\n-\n-         if Java_VM then\n-            Expand_Record_Aggregate (N,\n-              Parent_Expr => A);\n-         else\n+         if VM_Target = No_VM then\n             Expand_Record_Aggregate (N,\n               Orig_Tag    =>\n                 New_Occurrence_Of\n                   (Node (First_Elmt (Access_Disp_Table (Typ))), Loc),\n               Parent_Expr => A);\n+         else\n+            --  No tag is needed in the case of a VM\n+            Expand_Record_Aggregate (N,\n+              Parent_Expr => A);\n          end if;\n       end if;\n \n@@ -4754,15 +5066,23 @@ package body Exp_Aggr is\n       Typ      : constant Entity_Id  := Etype (N);\n       Base_Typ : constant Entity_Id  := Base_Type (Typ);\n \n-      function Has_Delayed_Nested_Aggregate_Or_Tagged_Comps return Boolean;\n-      --  Checks the presence of a nested aggregate which needs Late_Expansion\n-      --  or the presence of tagged components which may need tag adjustment.\n+      Static_Components : Boolean := True;\n+      --  Flag to indicate whether all components are compile-time known,\n+      --  and the aggregate can be constructed statically and handled by\n+      --  the back-end.\n \n-      --------------------------------------------------\n-      -- Has_Delayed_Nested_Aggregate_Or_Tagged_Comps --\n-      --------------------------------------------------\n+      function Component_Not_OK_For_Backend return Boolean;\n+      --  Check for presence of component which makes it impossible for the\n+      --  backend to process the aggregate, thus requiring the use of a series\n+      --  of assignment statements. Cases checked for are a nested aggregate\n+      --  needing Late_Expansion, the presence of a tagged component which may\n+      --  need tag adjustment, and a bit unaligned component reference.\n \n-      function Has_Delayed_Nested_Aggregate_Or_Tagged_Comps return Boolean is\n+      ----------------------------------\n+      -- Component_Not_OK_For_Backend --\n+      ----------------------------------\n+\n+      function Component_Not_OK_For_Backend return Boolean is\n          C      : Node_Id;\n          Expr_Q : Node_Id;\n \n@@ -4784,27 +5104,44 @@ package body Exp_Aggr is\n             --  These are cases where the source expression may have\n             --  a tag that could differ from the component tag (e.g.,\n             --  can occur for type conversions and formal parameters).\n-            --  (Tag adjustment is not needed if Java_VM because object\n+            --  (Tag adjustment is not needed if VM_Target because object\n             --  tags are implicit in the JVM.)\n \n             if Is_Tagged_Type (Etype (Expr_Q))\n               and then (Nkind (Expr_Q) = N_Type_Conversion\n-                or else (Is_Entity_Name (Expr_Q)\n-                          and then Ekind (Entity (Expr_Q)) in Formal_Kind))\n-              and then not Java_VM\n+                         or else (Is_Entity_Name (Expr_Q)\n+                                   and then\n+                                    Ekind (Entity (Expr_Q)) in Formal_Kind))\n+              and then VM_Target = No_VM\n             then\n+               Static_Components := False;\n                return True;\n-            end if;\n \n-            if Is_Delayed_Aggregate (Expr_Q) then\n+            elsif Is_Delayed_Aggregate (Expr_Q) then\n+               Static_Components := False;\n+               return True;\n+\n+            elsif Possible_Bit_Aligned_Component (Expr_Q) then\n+               Static_Components := False;\n                return True;\n             end if;\n \n+            if Is_Scalar_Type (Etype (Expr_Q)) then\n+               if not Compile_Time_Known_Value (Expr_Q) then\n+                  Static_Components := False;\n+               end if;\n+\n+            elsif Nkind (Expr_Q) /= N_Aggregate\n+              or else not Compile_Time_Known_Aggregate (Expr_Q)\n+            then\n+               Static_Components := False;\n+            end if;\n+\n             Next (C);\n          end loop;\n \n          return False;\n-      end Has_Delayed_Nested_Aggregate_Or_Tagged_Comps;\n+      end Component_Not_OK_For_Backend;\n \n       --  Remaining Expand_Record_Aggregate variables\n \n@@ -4860,7 +5197,9 @@ package body Exp_Aggr is\n       elsif Has_Default_Init_Comps (N) then\n          Convert_To_Assignments (N, Typ);\n \n-      elsif Has_Delayed_Nested_Aggregate_Or_Tagged_Comps then\n+      --  Check components\n+\n+      elsif Component_Not_OK_For_Backend then\n          Convert_To_Assignments (N, Typ);\n \n       --  If an ancestor is private, some components are not inherited and\n@@ -4875,6 +5214,13 @@ package body Exp_Aggr is\n       elsif Is_Tagged_Type (Typ) and then Has_Discriminants (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n+      --  If the tagged types covers interface types we need to initialize all\n+      --  the hidden components containing the pointers to secondary dispatch\n+      --  tables.\n+\n+      elsif Is_Tagged_Type (Typ) and then Has_Abstract_Interfaces (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n       --  If some components are mutable, the size of the aggregate component\n       --  may be disctinct from the default size of the type component, so\n       --  we need to expand to insure that the back-end copies the proper\n@@ -4893,6 +5239,17 @@ package body Exp_Aggr is\n       --  can be handled by gigi.\n \n       else\n+         if Nkind (N) = N_Aggregate then\n+\n+            --  If the aggregate is static and can be handled by the\n+            --  back-end, nothing left to do.\n+\n+            if Static_Components then\n+               Set_Compile_Time_Known_Aggregate (N);\n+               Set_Expansion_Delayed (N, False);\n+            end if;\n+         end if;\n+\n          --  If no discriminants, nothing special to do\n \n          if not Has_Discriminants (Typ) then\n@@ -5092,7 +5449,7 @@ package body Exp_Aggr is\n \n             if Present (Orig_Tag) then\n                Tag_Value := Orig_Tag;\n-            elsif Java_VM then\n+            elsif VM_Target /= No_VM then\n                Tag_Value := Empty;\n             else\n                Tag_Value :=\n@@ -5154,9 +5511,9 @@ package body Exp_Aggr is\n                end;\n \n             --  For a root type, the tag component is added (unless compiling\n-            --  for the Java VM, where tags are implicit).\n+            --  for the VMs, where tags are implicit).\n \n-            elsif not Java_VM then\n+            elsif VM_Target = No_VM then\n                declare\n                   Tag_Name  : constant Node_Id :=\n                                 New_Occurrence_Of\n@@ -5175,6 +5532,7 @@ package body Exp_Aggr is\n             end if;\n          end if;\n       end if;\n+\n    end Expand_Record_Aggregate;\n \n    ----------------------------\n@@ -5284,50 +5642,11 @@ package body Exp_Aggr is\n    function Make_OK_Assignment_Statement\n      (Sloc       : Source_Ptr;\n       Name       : Node_Id;\n-      Expression : Node_Id;\n-      Self_Ref   : Boolean := False) return Node_Id\n+      Expression : Node_Id) return Node_Id\n    is\n-      function Replace_Type (Expr : Node_Id) return Traverse_Result;\n-      --  If the aggregate contains a self-reference, traverse each\n-      --  expression to replace a possible self-reference with a reference\n-      --  to the proper component of the target of the assignment.\n-\n-      ------------------\n-      -- Replace_Type --\n-      ------------------\n-\n-      function Replace_Type (Expr : Node_Id) return Traverse_Result is\n-      begin\n-         if Nkind (Expr) = N_Attribute_Reference\n-           and  then Is_Entity_Name (Prefix (Expr))\n-           and then Is_Type (Entity (Prefix (Expr)))\n-         then\n-            if Is_Entity_Name (Prefix (Name)) then\n-               Rewrite (Prefix (Expr),\n-                 New_Occurrence_Of (Entity (Prefix (Name)), Sloc));\n-            else\n-               Rewrite (Expr,\n-                 Make_Attribute_Reference (Sloc,\n-                   Attribute_Name => Name_Unrestricted_Access,\n-                   Prefix         => New_Copy_Tree (Prefix (Name))));\n-               Set_Analyzed (Parent (Expr), False);\n-            end if;\n-         end if;\n-         return OK;\n-      end Replace_Type;\n-\n-      procedure Replace_Self_Reference is\n-        new Traverse_Proc (Replace_Type);\n-\n-   --  Start of processing for Make_OK_Assignment_Statement\n-\n    begin\n       Set_Assignment_OK (Name);\n \n-      if Self_Ref then\n-         Replace_Self_Reference (Expression);\n-      end if;\n-\n       return Make_Assignment_Statement (Sloc, Name, Expression);\n    end Make_OK_Assignment_Statement;\n \n@@ -5393,6 +5712,12 @@ package body Exp_Aggr is\n          return False;\n       end if;\n \n+      if not Is_Scalar_Type (Component_Type (Typ))\n+        and then Has_Non_Standard_Rep (Component_Type (Typ))\n+      then\n+         return False;\n+      end if;\n+\n       declare\n          Csiz  : constant Nat := UI_To_Int (Component_Size (Typ));\n \n@@ -5774,4 +6099,109 @@ package body Exp_Aggr is\n       end loop;\n    end Sort_Case_Table;\n \n+   ----------------------------\n+   -- Static_Array_Aggregate --\n+   ----------------------------\n+\n+   function Static_Array_Aggregate (N : Node_Id) return Boolean is\n+      Bounds : constant Node_Id := Aggregate_Bounds (N);\n+\n+      Typ       : constant Entity_Id := Etype (N);\n+      Comp_Type : constant Entity_Id := Component_Type (Typ);\n+      Agg       : Node_Id;\n+      Expr      : Node_Id;\n+      Lo        : Node_Id;\n+      Hi        : Node_Id;\n+\n+   begin\n+      if Is_Tagged_Type (Typ)\n+        or else Is_Controlled (Typ)\n+        or else Is_Packed (Typ)\n+      then\n+         return False;\n+      end if;\n+\n+      if Present (Bounds)\n+        and then Nkind (Bounds) = N_Range\n+        and then Nkind (Low_Bound  (Bounds)) = N_Integer_Literal\n+        and then Nkind (High_Bound (Bounds)) = N_Integer_Literal\n+      then\n+         Lo := Low_Bound  (Bounds);\n+         Hi := High_Bound (Bounds);\n+\n+         if No (Component_Associations (N)) then\n+\n+            --  Verify that all components are static integers.\n+\n+            Expr := First (Expressions (N));\n+            while Present (Expr) loop\n+               if Nkind (Expr) /= N_Integer_Literal then\n+                  return False;\n+               end if;\n+\n+               Next (Expr);\n+            end loop;\n+\n+            return True;\n+\n+         else\n+            --  We allow only a single named association, either a static\n+            --  range or an others_clause, with a static expression.\n+\n+            Expr := First (Component_Associations (N));\n+\n+            if Present (Expressions (N)) then\n+               return False;\n+\n+            elsif Present (Next (Expr)) then\n+               return False;\n+\n+            elsif Present (Next (First (Choices (Expr)))) then\n+               return False;\n+\n+            else\n+               --  The aggregate is static if all components are literals,\n+               --  or else all its components are static aggregates for the\n+               --  component type.\n+\n+               if Is_Array_Type (Comp_Type)\n+                 or else Is_Record_Type (Comp_Type)\n+               then\n+                  if Nkind (Expression (Expr)) /= N_Aggregate\n+                    or else\n+                      not Compile_Time_Known_Aggregate (Expression (Expr))\n+                  then\n+                     return False;\n+                  end if;\n+\n+               elsif Nkind (Expression (Expr)) /= N_Integer_Literal then\n+                  return False;\n+               end if;\n+\n+               --  Create a positional aggregate with the right number of\n+               --  copies of the expression.\n+\n+               Agg := Make_Aggregate (Sloc (N), New_List, No_List);\n+\n+               for I in UI_To_Int (Intval (Lo)) .. UI_To_Int (Intval (Hi))\n+               loop\n+                  Append_To\n+                    (Expressions (Agg), New_Copy (Expression (Expr)));\n+                  Set_Etype (Last (Expressions (Agg)), Component_Type (Typ));\n+               end loop;\n+\n+               Set_Aggregate_Bounds (Agg, Bounds);\n+               Set_Etype (Agg, Typ);\n+               Set_Analyzed (Agg);\n+               Rewrite (N, Agg);\n+               Set_Compile_Time_Known_Aggregate (N);\n+\n+               return True;\n+            end if;\n+         end if;\n+\n+      else\n+         return False;\n+      end if;\n+   end Static_Array_Aggregate;\n end Exp_Aggr;"}, {"sha": "4a265119a90d997e283fa41045ad2d881a2c2d9a", "filename": "gcc/ada/exp_aggr.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f95b178458d196841d4d4778cfd1c244088b55b/gcc%2Fada%2Fexp_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f95b178458d196841d4d4778cfd1c244088b55b/gcc%2Fada%2Fexp_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.ads?ref=0f95b178458d196841d4d4778cfd1c244088b55b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,16 @@ package Exp_Aggr is\n    --  assignment in the newly allocated object.\n \n    procedure Convert_Aggr_In_Assignment (N : Node_Id);\n-   --  ??? documentation needed\n-\n+   --  If the right-hand side of an assignment is an aggregate, expand the\n+   --  statement into a series of individual component assignments. This is\n+   --  done if there are non-static values involved in either the bounds or\n+   --  the components, and the aggregate cannot be handled as a whole by the\n+   --  backend.\n+\n+   function Static_Array_Aggregate (N : Node_Id) return Boolean;\n+   --  N is an array aggregate that may have a component association with\n+   --  an others clause and a range. If bounds are static and the expressions\n+   --  are compile-time known constants, rewrite N as a purely positional\n+   --  aggregate, to be use to initialize variables and components of the type\n+   --  without generating elaboration code.\n end Exp_Aggr;"}]}