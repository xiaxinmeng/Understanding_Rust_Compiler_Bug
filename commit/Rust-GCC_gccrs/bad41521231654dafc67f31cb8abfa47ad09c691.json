{"sha": "bad41521231654dafc67f31cb8abfa47ad09c691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkNDE1MjEyMzE2NTRkYWZjNjdmMzFjYjhhYmZhNDdhZDA5YzY5MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T18:38:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T18:38:56Z"}, "message": "mn10300: Cleanup all arithmetic.\n\nFor addition and logicals, define an operation-plus-flags update pattern\nin preparation for compare elimination.  In addition, clean up the way\nwe compare and validate CC_MODEs.  Define NEG in terms of NOT; this is\nsmaller and allows a non-clobbering destination alternative.\n\nFrom-SVN: r169010", "tree": {"sha": "ace1f21241006fb62f9953f7971b5fd323b64fde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ace1f21241006fb62f9953f7971b5fd323b64fde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bad41521231654dafc67f31cb8abfa47ad09c691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad41521231654dafc67f31cb8abfa47ad09c691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad41521231654dafc67f31cb8abfa47ad09c691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad41521231654dafc67f31cb8abfa47ad09c691/comments", "author": null, "committer": null, "parents": [{"sha": "9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1"}], "stats": {"total": 1701, "additions": 751, "deletions": 950}, "files": [{"sha": "5a85c704db42d24000a9e64634b563213d0d6490", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -1,5 +1,71 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300-modes.def (CCZN, CCZNC): New modes.\n+\t* config/mn10300/mn10300.c (CC_FLAG_Z): New.\n+\t(CC_FLAG_N, CC_FLAG_C, CC_FLAG_V): New.\n+\t(cc_flags_for_mode, cc_flags_for_code): New.\n+\t(mn10300_print_operand) ['B']: Use nc/ns for GE/LT when the\n+\toverflow flag is not valid.  Validate that the flags we need\n+\tfor the comparison are valid.\n+\t(mn10300_output_cmp): Remove.\n+\t(mn10300_output_add): New.\n+\t(mn10300_select_cc_mode): Use cc_flags_for_code.\n+\t(mn10300_split_cbranch): New.\n+\t(mn10300_match_ccmode): New.\n+\t(mn10300_split_and_operand_count): New.\n+\t* config/mn10300/mn10300.h (SELECT_CC_MODE): Pass all of the arguments\n+\tto the function.\n+\t* config/mn10300/mn10300.md (*am33_addsi3, *mn10300_addsi3): Merge...\n+\t(addsi3): ... here.  Use mn10300_output_add.\n+\t(*addsi3_flags): New.\n+\t(*am33_subsi3, *mn10300_subsi3): Merge...\n+\t(subsi3): ... here.  Use attribute isa.\n+\t(*subsi3_flags): New.\n+\t(negsi2): Rewrite from expander to insn_and_split.  Use NOT+INC\n+\twhen possible.\n+\t(*am33_andsi3, *mn10300_andsi3): Merge...\n+\t(andsi3): ... here.\n+\t(*andsi3_flags): New.\n+\t(andsi3 splitters): New.\n+\t(*am33_iorsi3, *mn10300_iorsi3): Merge...\n+\t(iorsi3): ... here.\n+\t(*iorsi3_flags): New.\n+\t(*am33_xorsi3, *mn10300_xorsi3): Merge...\n+\t(xorsi3): ... here.\n+\t(*xorsi3_flags): New.\n+\t(*am33_cmpsi2, *mn10300_cmplsi2): Merge...\n+\t(one_cmplsi2): ... here.\n+\t(*one_cmplsi2_flags): New.\n+\t(*cbranchsi4_cmp): Rename from cbranchsi4_post_reload.  Use \"r\"\n+\tinstead of \"dax\" in constraints.  Use mn10300_split_cbranch.\n+\t(*cmpsi): Rename from cmpsi.  Do not use mn10300_output_cmp.  Do not\n+\tuse matching constraints to eliminate a self-comparison.\n+\t(*integer_conditional_branch): Rename from integer_conditional_branch.\n+\tUse int_mode_flags to match CC_REG.\n+\t(*cbranchsi4_btst, *btstsi): New.\n+\t(*cbranchsf4_cmp): Rename from *cbranchsf4_post_reload.  Use\n+\tmn10300_split_cbranch.\n+\t(*am33_cmpsf): Rename from am33_cmpsf.\n+\t(*float_conditional_branch): Rename from float_conditional_branch.\n+\t(*zero_extendqisi2_am33, *zero_extendqisi2_mn10300): Merge...\n+\t(zero_extendqisi2): ... here.\n+\t(*zero_extendhisi2_am33, *zero_extendhisi2_mn10300): Merge...\n+\t(zero_extendhisi2): ... here.\n+\t(*extendqisi2_am33, *extendqisi2_mn10300): Merge...\n+\t(extendqisi2): ... here.\n+\t(*extendhisi2_am33, *extendhisi2_mn10300): Merge...\n+\t(extendhisi2): ... here.\n+\t(*am33_ashlsi3, *mn10300_ashlsi3): Merge...\n+\t(ashlsi3): ... here.\n+\t(*am33_lshrsi3, *mn10300_lshrsi3): Merge...\n+\t(lshrsi3): ... here.\n+\t(*am33_ashrisi3, *mn10300_ashrsi3): Merge...\n+\t(ashrsi3): ... here.\n+\t(consecutive add peephole): Remove.\n+\t* config/mn10300/predicates.md (label_ref_operand): New.\n+\t(int_mode_flags): New.\n+\t(CCZN_comparison_operator): New.\n+\n \t* config/mn10300/mn10300.md (UNSPEC_EXT): New.\n \t(throughput_42_latency_43): New reservation.\n \t(mulsidi3, umulsidi3): New expanders."}, {"sha": "832663edb2af9ed7a8dcd5eaf829dd4944dfc860", "filename": "gcc/config/mn10300/mn10300-modes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-modes.def?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -19,4 +19,6 @@\n    the Free Software Foundation, , Inc., 51 Franklin Street - Fifth\n    Floor, Boston, MA 02110-1301, USA.  */\n \n+CC_MODE (CCZN);\n+CC_MODE (CCZNC);\n CC_MODE (CC_FLOAT);"}, {"sha": "28a94126fffb44f23792c87bf9faf3eaac9fdd65", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -32,13 +32,16 @@ extern int   mn10300_get_live_callee_saved_regs (void);\n extern bool  mn10300_hard_regno_mode_ok (unsigned int, Mmode);\n extern bool  mn10300_legitimate_constant_p (rtx);\n extern bool  mn10300_modes_tieable (Mmode, Mmode);\n-extern Cstar mn10300_output_cmp (rtx, rtx);\n+extern Cstar mn10300_output_add (rtx[3], bool);\n extern void  mn10300_print_operand (FILE *, rtx, int);\n extern void  mn10300_print_operand_address (FILE *, rtx);\n extern void  mn10300_print_reg_list (FILE *, int);\n-extern Mmode mn10300_select_cc_mode (rtx);\n+extern Mmode mn10300_select_cc_mode (enum rtx_code, rtx, rtx);\n extern int   mn10300_store_multiple_operation (rtx, Mmode);\n extern int   mn10300_symbolic_operand (rtx, Mmode);\n+extern void  mn10300_split_cbranch (Mmode, rtx, rtx);\n+extern int   mn10300_split_and_operand_count (rtx);\n+extern bool  mn10300_match_ccmode (rtx, Mmode);\n #endif /* RTX_CODE */\n \n extern bool  mn10300_regno_in_class_p (unsigned, int, bool);"}, {"sha": "7535253e0f0e8f745124c472f31c57889d45dbf2", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 311, "deletions": 169, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -81,6 +81,14 @@ static const struct default_options mn10300_option_optimization_table[] =\n     { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n     { OPT_LEVELS_NONE, 0, NULL, 0 }\n   };\n+\n+#define CC_FLAG_Z\t1\n+#define CC_FLAG_N\t2\n+#define CC_FLAG_C\t4\n+#define CC_FLAG_V\t8\n+\n+static int cc_flags_for_mode(enum machine_mode);\n+static int cc_flags_for_code(enum rtx_code);\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n \n@@ -134,7 +142,7 @@ mn10300_option_override (void)\n \t when this flag is not enabled by default.  */\n       flag_split_wide_types = 1;\n     }\n-  \n+\n   if (mn10300_tune_string)\n     {\n       if (strcasecmp (mn10300_tune_string, \"mn10300\") == 0)\n@@ -171,95 +179,82 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n     {\n       case 'b':\n       case 'B':\n-\tif (GET_MODE (XEXP (x, 0)) == CC_FLOATmode)\n-\t  {\n-\t    switch (code == 'b' ? GET_CODE (x)\n-\t\t    : reverse_condition_maybe_unordered (GET_CODE (x)))\n-\t      {\n-\t      case NE:\n-\t\tfprintf (file, \"ne\");\n-\t\tbreak;\n-\t      case EQ:\n-\t\tfprintf (file, \"eq\");\n-\t\tbreak;\n-\t      case GE:\n-\t\tfprintf (file, \"ge\");\n-\t\tbreak;\n-\t      case GT:\n-\t\tfprintf (file, \"gt\");\n-\t\tbreak;\n-\t      case LE:\n-\t\tfprintf (file, \"le\");\n-\t\tbreak;\n-\t      case LT:\n-\t\tfprintf (file, \"lt\");\n-\t\tbreak;\n-\t      case ORDERED:\n-\t\tfprintf (file, \"lge\");\n-\t\tbreak;\n-\t      case UNORDERED:\n-\t\tfprintf (file, \"uo\");\n-\t\tbreak;\n-\t      case LTGT:\n-\t\tfprintf (file, \"lg\");\n-\t\tbreak;\n-\t      case UNEQ:\n-\t\tfprintf (file, \"ue\");\n-\t\tbreak;\n-\t      case UNGE:\n-\t\tfprintf (file, \"uge\");\n-\t\tbreak;\n-\t      case UNGT:\n-\t\tfprintf (file, \"ug\");\n-\t\tbreak;\n-\t      case UNLE:\n-\t\tfprintf (file, \"ule\");\n-\t\tbreak;\n-\t      case UNLT:\n-\t\tfprintf (file, \"ul\");\n-\t\tbreak;\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\t    break;\n-\t  }\n-\t/* These are normal and reversed branches.  */\n-\tswitch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n-\t  {\n-\t  case NE:\n-\t    fprintf (file, \"ne\");\n-\t    break;\n-\t  case EQ:\n-\t    fprintf (file, \"eq\");\n-\t    break;\n-\t  case GE:\n-\t    fprintf (file, \"ge\");\n-\t    break;\n-\t  case GT:\n-\t    fprintf (file, \"gt\");\n-\t    break;\n-\t  case LE:\n-\t    fprintf (file, \"le\");\n-\t    break;\n-\t  case LT:\n-\t    fprintf (file, \"lt\");\n-\t    break;\n-\t  case GEU:\n-\t    fprintf (file, \"cc\");\n-\t    break;\n-\t  case GTU:\n-\t    fprintf (file, \"hi\");\n-\t    break;\n-\t  case LEU:\n-\t    fprintf (file, \"ls\");\n-\t    break;\n-\t  case LTU:\n-\t    fprintf (file, \"cs\");\n-\t    break;\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n+\t{\n+\t  enum rtx_code cmp = GET_CODE (x);\n+\t  enum machine_mode mode = GET_MODE (XEXP (x, 0));\n+\t  const char *str;\n+\t  int have_flags;\n+\n+\t  if (code == 'B')\n+\t    cmp = reverse_condition (cmp);\n+\t  have_flags = cc_flags_for_mode (mode);\n+\n+\t  switch (cmp)\n+\t    {\n+\t    case NE:\n+\t      str = \"ne\";\n+\t      break;\n+\t    case EQ:\n+\t      str = \"eq\";\n+\t      break;\n+\t    case GE:\n+\t      /* bge is smaller than bnc.  */\n+\t      str = (have_flags & CC_FLAG_V ? \"ge\" : \"nc\");\n+\t      break;\n+\t    case LT:\n+\t      str = (have_flags & CC_FLAG_V ? \"lt\" : \"ns\");\n+\t      break;\n+\t    case GT:\n+\t      str = \"gt\";\n+\t      break;\n+\t    case LE:\n+\t      str = \"le\";\n+\t      break;\n+\t    case GEU:\n+\t      str = \"cc\";\n+\t      break;\n+\t    case GTU:\n+\t      str = \"hi\";\n+\t      break;\n+\t    case LEU:\n+\t      str = \"ls\";\n+\t      break;\n+\t    case LTU:\n+\t      str = \"cs\";\n+\t      break;\n+\t    case ORDERED:\n+\t      str = \"lge\";\n+\t      break;\n+\t    case UNORDERED:\n+\t      str = \"uo\";\n+\t      break;\n+\t    case LTGT:\n+\t      str = \"lg\";\n+\t      break;\n+\t    case UNEQ:\n+\t      str = \"ue\";\n+\t      break;\n+\t    case UNGE:\n+\t      str = \"uge\";\n+\t      break;\n+\t    case UNGT:\n+\t      str = \"ug\";\n+\t      break;\n+\t    case UNLE:\n+\t      str = \"ule\";\n+\t      break;\n+\t    case UNLT:\n+\t      str = \"ul\";\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  gcc_checking_assert ((cc_flags_for_code (cmp) & ~have_flags) == 0);\n+\t  fputs (str, file);\n+\t}\n \tbreak;\n+\n       case 'C':\n \t/* This is used for the operand to a call instruction;\n \t   if it's a REG, enclose it in parens, else output\n@@ -1709,95 +1704,96 @@ mn10300_function_value_regno_p (const unsigned int regno)\n  return (regno == FIRST_DATA_REGNUM || regno == FIRST_ADDRESS_REGNUM);\n }\n \n-/* Output a compare insn.  */\n+/* Output an addition operation.  */\n \n const char *\n-mn10300_output_cmp (rtx operand, rtx insn)\n+mn10300_output_add (rtx operands[3], bool need_flags)\n {\n-  rtx temp;\n-  int past_call = 0;\n+  rtx dest, src1, src2;\n+  unsigned int dest_regnum, src1_regnum, src2_regnum;\n+  enum reg_class src1_class, src2_class, dest_class;\n \n-  /* We can save a byte if we can find a register which has the value\n-     zero in it.  */\n-  temp = PREV_INSN (insn);\n-  while (optimize && temp)\n-    {\n-      rtx set;\n-\n-      /* We allow the search to go through call insns.  We record\n-\t the fact that we've past a CALL_INSN and reject matches which\n-\t use call clobbered registers.  */\n-      if (LABEL_P (temp)\n-\t  || JUMP_P (temp)\n-\t  || GET_CODE (temp) == BARRIER)\n-\tbreak;\n+  dest = operands[0];\n+  src1 = operands[1];\n+  src2 = operands[2];\n \n-      if (CALL_P (temp))\n-\tpast_call = 1;\n+  dest_regnum = true_regnum (dest);\n+  src1_regnum = true_regnum (src1);\n \n-      if (GET_CODE (temp) == NOTE)\n-\t{\n-\t  temp = PREV_INSN (temp);\n-\t  continue;\n-\t}\n+  dest_class = REGNO_REG_CLASS (dest_regnum);\n+  src1_class = REGNO_REG_CLASS (src1_regnum);\n \n-      /* It must be an insn, see if it is a simple set.  */\n-      set = single_set (temp);\n-      if (!set)\n-\t{\n-\t  temp = PREV_INSN (temp);\n-\t  continue;\n-\t}\n+  if (GET_CODE (src2) == CONST_INT)\n+    {\n+      gcc_assert (dest_regnum == src1_regnum);\n \n-      /* Are we setting a data register to zero (this does not win for\n-\t address registers)?\n-\n-\t If it's a call clobbered register, have we past a call?\n-\n-\t Make sure the register we find isn't the same as ourself;\n-\t the mn10300 can't encode that.\n-\n-\t ??? reg_set_between_p return nonzero anytime we pass a CALL_INSN\n-\t so the code to detect calls here isn't doing anything useful.  */\n-      if (REG_P (SET_DEST (set))\n-\t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n-\t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n-\t  && (REGNO_REG_CLASS (REGNO (SET_DEST (set)))\n-\t      == REGNO_REG_CLASS (REGNO (operand)))\n-\t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) != EXTENDED_REGS\n-\t  && REGNO (SET_DEST (set)) != REGNO (operand)\n-\t  && (!past_call\n-\t      || ! call_really_used_regs [REGNO (SET_DEST (set))]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operand;\n-\t  xoperands[1] = SET_DEST (set);\n+      if (src2 == const1_rtx && !need_flags)\n+\treturn \"inc %0\";\n+      if (INTVAL (src2) == 4 && !need_flags && dest_class != DATA_REGS)\n+        return \"inc4 %0\";\n \n-\t  output_asm_insn (\"cmp %1,%0\", xoperands);\n-\t  return \"\";\n-\t}\n+      gcc_assert (!need_flags || dest_class != SP_REGS);\n+      return \"add %2,%0\";\n+    }\n+  else if (CONSTANT_P (src2))\n+    return \"add %2,%0\";\n+\n+  src2_regnum = true_regnum (src2);\n+  src2_class = REGNO_REG_CLASS (src2_regnum);\n+      \n+  if (dest_regnum == src1_regnum)\n+    return \"add %2,%0\";\n+  if (dest_regnum == src2_regnum)\n+    return \"add %1,%0\";\n+\n+  /* The rest of the cases are reg = reg+reg.  For AM33, we can implement\n+     this directly, as below, but when optimizing for space we can sometimes\n+     do better by using a mov+add.  For MN103, we claimed that we could\n+     implement a three-operand add because the various move and add insns\n+     change sizes across register classes, and we can often do better than\n+     reload in choosing which operand to move.  */\n+  if (TARGET_AM33 && optimize_insn_for_speed_p ())\n+    return \"add %2,%1,%0\";\n+\n+  /* Catch cases where no extended register was used.  */\n+  if (src1_class != EXTENDED_REGS\n+      && src2_class != EXTENDED_REGS\n+      && dest_class != EXTENDED_REGS)\n+    {\n+      /* We have to copy one of the sources into the destination, then\n+         add the other source to the destination.\n+\n+         Carefully select which source to copy to the destination; a\n+         naive implementation will waste a byte when the source classes\n+         are different and the destination is an address register.\n+         Selecting the lowest cost register copy will optimize this\n+         sequence.  */\n+      if (src1_class == dest_class)\n+        return \"mov %1,%0\\n\\tadd %2,%0\";\n+      else\n+\treturn \"mov %2,%0\\n\\tadd %1,%0\";\n+    }\n \n-      if (REGNO_REG_CLASS (REGNO (operand)) == EXTENDED_REGS\n-\t  && REG_P (SET_DEST (set))\n-\t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n-\t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n-\t  && (REGNO_REG_CLASS (REGNO (SET_DEST (set)))\n-\t      != REGNO_REG_CLASS (REGNO (operand)))\n-\t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) == EXTENDED_REGS\n-\t  && REGNO (SET_DEST (set)) != REGNO (operand)\n-\t  && (!past_call\n-\t      || ! call_really_used_regs [REGNO (SET_DEST (set))]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operand;\n-\t  xoperands[1] = SET_DEST (set);\n+  /* At least one register is an extended register.  */\n \n-\t  output_asm_insn (\"cmp %1,%0\", xoperands);\n-\t  return \"\";\n-\t}\n-      temp = PREV_INSN (temp);\n-    }\n-  return \"cmp 0,%0\";\n+  /* The three operand add instruction on the am33 is a win iff the\n+     output register is an extended register, or if both source\n+     registers are extended registers.  */\n+  if (dest_class == EXTENDED_REGS || src1_class == src2_class)\n+    return \"add %2,%1,%0\";\n+\n+  /* It is better to copy one of the sources to the destination, then\n+     perform a 2 address add.  The destination in this case must be\n+     an address or data register and one of the sources must be an\n+     extended register and the remaining source must not be an extended\n+     register.\n+\n+     The best code for this case is to copy the extended reg to the\n+     destination, then emit a two address add.  */\n+  if (src1_class == EXTENDED_REGS)\n+    return \"mov %1,%0\\n\\tadd %2,%0\";\n+  else\n+    return \"mov %2,%0\\n\\tadd %1,%0\";\n }\n \n /* Return 1 if X contains a symbolic expression.  We know these\n@@ -2674,10 +2670,80 @@ mn10300_modes_tieable (enum machine_mode mode1, enum machine_mode mode2)\n   return false;\n }\n \n+static int\n+cc_flags_for_mode (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case CCmode:\n+      return CC_FLAG_Z | CC_FLAG_N | CC_FLAG_C | CC_FLAG_V;\n+    case CCZNCmode:\n+      return CC_FLAG_Z | CC_FLAG_N | CC_FLAG_C;\n+    case CCZNmode:\n+      return CC_FLAG_Z | CC_FLAG_N;\n+    case CC_FLOATmode:\n+      return -1;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static int\n+cc_flags_for_code (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\t/* Z */\n+    case NE:\t/* ~Z */\n+      return CC_FLAG_Z;\n+\n+    case LT:\t/* N */\n+    case GE:\t/* ~N */\n+      return CC_FLAG_N;\n+      break;\n+\n+    case GT:    /* ~(Z|(N^V)) */\n+    case LE:    /* Z|(N^V) */\n+      return CC_FLAG_Z | CC_FLAG_N | CC_FLAG_V;\n+\n+    case GEU:\t/* ~C */\n+    case LTU:\t/* C */\n+      return CC_FLAG_C;\n+\n+    case GTU:\t/* ~(C | Z) */\n+    case LEU:\t/* C | Z */\n+      return CC_FLAG_Z | CC_FLAG_C;\n+\n+    case ORDERED:\n+    case UNORDERED:\n+    case LTGT:\n+    case UNEQ:\n+    case UNGE:\n+    case UNGT:\n+    case UNLE:\n+    case UNLT:\n+      return -1;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n enum machine_mode\n-mn10300_select_cc_mode (rtx x)\n+mn10300_select_cc_mode (enum rtx_code code, rtx x, rtx y ATTRIBUTE_UNUSED)\n {\n-  return (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT) ? CC_FLOATmode : CCmode;\n+  int req;\n+\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    return CC_FLOATmode;\n+\n+  req = cc_flags_for_code (code);\n+\n+  if (req & CC_FLAG_V)\n+    return CCmode;\n+  if (req & CC_FLAG_C)\n+    return CCZNCmode;\n+  return CCZNmode;\n }\n \n static inline bool\n@@ -2811,6 +2877,82 @@ mn10300_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n   return clobbers;\n }\n \f\n+/* A helper function for splitting cbranch patterns after reload.  */\n+\n+void\n+mn10300_split_cbranch (enum machine_mode cmp_mode, rtx cmp_op, rtx label_ref)\n+{\n+  rtx flags, x;\n+\n+  flags = gen_rtx_REG (cmp_mode, CC_REG);\n+  x = gen_rtx_COMPARE (cmp_mode, XEXP (cmp_op, 0), XEXP (cmp_op, 1));\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+  emit_insn (x);\n+\n+  x = gen_rtx_fmt_ee (GET_CODE (cmp_op), VOIDmode, flags, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label_ref, pc_rtx);\n+  x = gen_rtx_SET (VOIDmode, pc_rtx, x);\n+  emit_jump_insn (x);\n+}\n+\n+/* A helper function for matching parallels that set the flags.  */\n+\n+bool\n+mn10300_match_ccmode (rtx insn, enum machine_mode cc_mode)\n+{\n+  rtx op1, flags;\n+  enum machine_mode flags_mode;\n+\n+  gcc_checking_assert (XVECLEN (PATTERN (insn), 0) == 2);\n+\n+  op1 = XVECEXP (PATTERN (insn), 0, 1);\n+  gcc_checking_assert (GET_CODE (SET_SRC (op1)) == COMPARE);\n+\n+  flags = SET_DEST (op1);\n+  flags_mode = GET_MODE (flags);\n+\n+  if (GET_MODE (SET_SRC (op1)) != flags_mode)\n+    return false;\n+  if (GET_MODE_CLASS (flags_mode) != MODE_CC)\n+    return false;\n+\n+  /* Ensure that the mode of FLAGS is compatible with CC_MODE.  */\n+  if (cc_flags_for_mode (flags_mode) & ~cc_flags_for_mode (cc_mode))\n+    return false;\n+\n+  return true;\n+}\n+\n+int\n+mn10300_split_and_operand_count (rtx op)\n+{\n+  HOST_WIDE_INT val = INTVAL (op);\n+  int count;\n+\n+  if (val < 0)\n+    {\n+      /* High bit is set, look for bits clear at the bottom.  */\n+      count = exact_log2 (-val);\n+      if (count < 0)\n+\treturn 0;\n+      /* This is only size win if we can use the asl2 insn.  Otherwise we\n+\t would be replacing 1 6-byte insn with 2 3-byte insns.  */\n+      if (count > (optimize_insn_for_speed_p () ? 2 : 4))\n+\treturn 0;\n+      return -count;\n+    }\n+  else\n+    {\n+      /* High bit is clear, look for bits set at the bottom.  */\n+      count = exact_log2 (val + 1);\n+      count = 32 - count;\n+      /* Again, this is only a size win with asl2.  */\n+      if (count > (optimize_insn_for_speed_p () ? 2 : 4))\n+\treturn 0;\n+      return -count;\n+    }\n+}\n+\f\n /* Initialize the GCC target structure.  */\n \n #undef  TARGET_EXCEPT_UNWIND_INFO"}, {"sha": "21d36338306398808990d25da6c29eee21a34dcb", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -600,7 +600,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n /* Non-global SYMBOL_REFs have SYMBOL_REF_FLAG enabled.  */\n #define MN10300_GLOBAL_P(X) (! SYMBOL_REF_FLAG (X))\n \f\n-#define SELECT_CC_MODE(OP, X, Y)  mn10300_select_cc_mode (X)\n+#define SELECT_CC_MODE(OP, X, Y)  mn10300_select_cc_mode (OP, X, Y)\n #define REVERSIBLE_CC_MODE(MODE)  0\n \f\n /* Nonzero if access to memory by bytes or half words is no faster"}, {"sha": "152477c874cd2c8869e10059b4c7ba7a609f92fc", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 350, "deletions": 778, "changes": 1128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -507,104 +507,6 @@\n \t\t ])]\n )\n \n-\f\n-;; ----------------------------------------------------------------------\n-;; ADD INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_expand \"addsi3\"\n-  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n-\t\t   (plus:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t    (match_operand:SI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*am33_addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=dx,a,x,a,dax,!*y,!dax\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,dax\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,L,daxi,i,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return \\\"inc %0\\\";\n-    case 2:\n-    case 3:\n-      return \\\"inc4 %0\\\";\n-    case 4:\n-    case 5:\n-      return \\\"add %2,%0\\\";\n-    case 6:\n-      {\n-\tenum reg_class src1_class, src2_class, dst_class;\n-\n-\tsrc1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n-\tsrc2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n-\tdst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n-\n-\t/* I'm not sure if this can happen or not.  Might as well be prepared\n-\t  and generate the best possible code if it does happen.  */\n-\tif (true_regnum (operands[0]) == true_regnum (operands[1]))\n-\t  return \\\"add %2,%0\\\";\n-\tif (true_regnum (operands[0]) == true_regnum (operands[2]))\n-\t  return \\\"add %1,%0\\\";\n-\n-\t/* Catch cases where no extended register was used.  These should be\n-\t   handled just like the mn10300.  */\n-\tif (src1_class != EXTENDED_REGS\n-\t    && src2_class != EXTENDED_REGS\n-\t    && dst_class != EXTENDED_REGS)\n-\t  {\n-\t    /* We have to copy one of the sources into the destination, then\n-\t       add the other source to the destination.\n-\n-\t       Carefully select which source to copy to the destination; a\n-\t       naive implementation will waste a byte when the source classes\n-\t       are different and the destination is an address register.\n-\t       Selecting the lowest cost register copy will optimize this\n-\t       sequence.  */\n-\t    if (REGNO_REG_CLASS (true_regnum (operands[1]))\n-\t\t== REGNO_REG_CLASS (true_regnum (operands[0])))\n-\t      return \\\"mov %1,%0\\;add %2,%0\\\";\n-\t    return \\\"mov %2,%0\\;add %1,%0\\\";\n-\t  }\n-\n-\t/* At least one register is an extended register.  */\n-\n-\t/* The three operand add instruction on the am33 is a win iff the\n-\t   output register is an extended register, or if both source\n-\t   registers are extended registers.  */\n-\tif (dst_class == EXTENDED_REGS\n-\t    || src1_class == src2_class)\n-\t  return \\\"add %2,%1,%0\\\";\n-\n-      /* It is better to copy one of the sources to the destination, then\n-\t perform a 2 address add.  The destination in this case must be\n-\t an address or data register and one of the sources must be an\n-\t extended register and the remaining source must not be an extended\n-\t register.\n-\n-\t The best code for this case is to copy the extended reg to the\n-\t destination, then emit a two address add.  */\n-      if (src1_class == EXTENDED_REGS)\n-\treturn \\\"mov %1,%0\\;add %2,%0\\\";\n-      return \\\"mov %2,%0\\;add %1,%0\\\";\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-  }\"\n-  [(set_attr \"timings\" \"11,11,11,11,11,11,22\")]\n-)\n-\n ;; If the flags register is not live, generate CLR instead of MOV 0.\n ;; For MN103, this is only legal for DATA_REGS; for AM33 this is legal\n ;; but not a win for ADDRESS_REGS.\n@@ -629,123 +531,90 @@\n ;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"*mn10300_addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=dx,a,a,dax,!*y,!dax\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,dax\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,daxi,i,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=r,!*y,!r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,  0, r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri,  i, r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return \\\"inc %0\\\";\n-    case 2:\n-      return \\\"inc4 %0\\\";\n-    case 3:\n-    case 4:\n-      return \\\"add %2,%0\\\";\n-    case 5:\n-      /* I'm not sure if this can happen or not.  Might as well be prepared\n-\t and generate the best possible code if it does happen.  */\n-      if (true_regnum (operands[0]) == true_regnum (operands[1]))\n-\treturn \\\"add %2,%0\\\";\n-      if (true_regnum (operands[0]) == true_regnum (operands[2]))\n-\treturn \\\"add %1,%0\\\";\n-\n-      /* We have to copy one of the sources into the destination, then add\n-\t the other source to the destination.\n-\n-\t Carefully select which source to copy to the destination; a naive\n-\t implementation will waste a byte when the source classes are different\n-\t and the destination is an address register.  Selecting the lowest\n-\t cost register copy will optimize this sequence.  */\n-      if (REGNO_REG_CLASS (true_regnum (operands[1]))\n-\t  == REGNO_REG_CLASS (true_regnum (operands[0])))\n-\treturn \\\"mov %1,%0\\;add %2,%0\\\";\n-      return \\\"mov %2,%0\\;add %1,%0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n-  [(set_attr \"timings\" \"11,11,11,11,11,22\")]\n+  { return mn10300_output_add (operands, false); }\n+  [(set_attr \"timings\" \"11,11,22\")]\n+)\n+\n+;; Note that ADD IMM,SP does not set the flags, so omit that here.\n+(define_insn \"*addsi3_flags\"\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=r,!r\")\n+  \t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0, r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri, r\")))\n+   (set (reg CC_REG)\n+   \t(compare (plus:SI (match_dup 1) (match_dup 2))\n+\t\t (const_int 0)))]\n+  \"reload_completed && mn10300_match_ccmode (insn, CCZNCmode)\"\n+  { return mn10300_output_add (operands, true); }\n+  [(set_attr \"timings\" \"11,22\")]\n )\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"subsi3\"\n-  [(parallel [(set (match_operand:SI           0 \"register_operand\")\n-\t\t   (minus:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t     (match_operand:SI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ri,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*am33_subsi3\"\n-  [(set (match_operand:SI           0 \"register_operand\" \"=dax,!dax\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,dax\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-  {\n-    if (true_regnum (operands[0]) == true_regnum (operands[1]))\n-      return \\\"sub %2,%0\\\";\n-    else\n-      {\n-        enum reg_class src1_class, src2_class, dst_class;\n-\n-        src1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n-        src2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n-        dst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n-\n-        /* If no extended registers are used, then the best way to handle\n-\t   this is to copy the first source operand into the destination\n-\t   and emit a two address subtraction.  */\n-        if (src1_class != EXTENDED_REGS\n-\t    && src2_class != EXTENDED_REGS\n-\t    && dst_class != EXTENDED_REGS\n-\t    && true_regnum (operands[0]) != true_regnum (operands[2]))\n-\t  return \\\"mov %1,%0\\;sub %2,%0\\\";\n-        return \\\"sub %2,%1,%0\\\";\n-      }\n-  }\"\n-  [(set_attr \"timings\" \"11,22\")]\n+  \"@\n+   sub %2,%0\n+   sub %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,am33\")\n+   (set_attr \"timings\" \"11,22\")]\n )\n \n-(define_insn \"*mn10300_subsi3\"\n-  [(set (match_operand:SI           0 \"register_operand\" \"=dax\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n-  \"sub %2,%0\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 11) (const_int 22)))]\n+(define_insn \"*subsi3_flags\"\n+  [(set (match_operand:SI           0 \"register_operand\"  \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"ri,r\")))\n+   (set (reg CC_REG)\n+   \t(compare (minus:SI (match_dup 1) (match_dup 2))\n+\t\t (const_int 0)))]\n+  \"reload_completed && mn10300_match_ccmode (insn, CCZNCmode)\"\n+  \"@\n+   sub %2,%0\n+   sub %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,am33\")\n+   (set_attr \"timings\" \"11,22\")]\n )\n \n-(define_expand \"negsi2\"\n-  [(set (match_operand:SI         0 \"register_operand\")\n-        (neg:SI (match_operand:SI 1 \"register_operand\")))]\n+(define_insn_and_split \"negsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,&r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\"  \" 0, r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n {\n-  rtx target = gen_reg_rtx (SImode);\n-\n-  emit_move_insn (target, const0_rtx);\n-  emit_insn (gen_subsi3 (target, target, operands[1]));\n-  emit_move_insn (operands[0], target);\n+  /* Recall that twos-compliment is ones-compliment plus one.  When\n+     allocated in DATA_REGS this is 2+1 bytes; otherwise (for am33)\n+     this is 3+3 bytes.\n+\n+     For AM33, it would have been possible to load zero and use the\n+     three-address subtract to have a total size of 3+4*N bytes for\n+     multiple negations, plus increased throughput.  Not attempted here.  */\n+     \n+  if (true_regnum (operands[0]) == true_regnum (operands[1]))\n+    {\n+      emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));\n+      emit_insn (gen_addsi3 (operands[0], operands[0], const1_rtx));\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[0], const0_rtx);\n+      emit_insn (gen_subsi3 (operands[0], operands[0], operands[1]));\n+    }\n   DONE;\n-}\")\n+})\n \n ;; ----------------------------------------------------------------------\n ;; MULTIPLY INSTRUCTIONS\n@@ -935,221 +804,174 @@\n ;; AND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"andsi3\"\n-  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n-\t\t   (and:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,D,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \" i,D,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*am33_andsi3\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx,dx,!dax\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,dax\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  {\n-    if (CONST_INT_P (operands[2]))\n-      switch (INTVAL (operands[2]))\n-        {\n-        case 0xff:       return \"extbu %0\";\n-        case 0xffff:     return \"exthu %0\";\n-        case 0x7fffffff: return \"add  %0, %0; lsr 1, %0\";\n-        case 0x3fffffff: return \"asl2 %0; lsr 2, %0\";\n-        case 0x1fffffff: return \"add  %0, %0; asl2 %0; lsr 3, %0\";\n-        case 0x0fffffff: return \"asl2 %0; asl2 %0; lsr 4, %0\";\n-        case 0xfffffffe: return \"lsr 1, %0; add  %0, %0\";\n-        case 0xfffffffc: return \"lsr 2, %0; asl2 %0\";\n-        case 0xfffffff8: return \"lsr 3, %0; add  %0, %0; asl2 %0\";\n-        case 0xfffffff0: return \"lsr 4, %0; asl2 %0; asl2 %0\";\n-        }\n-      \n-    if (REG_P (operands[2]) && REG_P (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[2])\n-        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n-      return \"mov %1, %0; and %2, %0\";\n-    if (REG_P (operands[2]) && REG_P (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[2]))\n-      return \"and %1, %2, %0\";\n-    if (REG_P (operands[2]) && REG_P (operands[0])\n-        && true_regnum (operands[2]) == true_regnum (operands[0]))\n-      return \"and %1, %0\";\n-\n-    return \"and %2, %0\";\n-  }\n-  [(set_attr \"timings\" \"33\")]\n+  \"@\n+   and %2,%0\n+   and %2,%0\n+   and %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"timings\" \"22,11,11\")]\n+)\n+\n+(define_insn \"*andsi3_flags\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,D,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \" i,D,r\")))\n+   (set (reg CC_REG)\n+   \t(compare (and:SI (match_dup 1) (match_dup 2))\n+\t\t (const_int 0)))]\n+  \"reload_completed && mn10300_match_ccmode (insn, CCZNmode)\"\n+  \"@\n+   and %2,%0\n+   and %2,%0\n+   and %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"timings\" \"22,11,11\")]\n )\n \n-(define_insn \"*mn10300_andsi3\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx,dx\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+;; Make sure we generate extensions instead of ANDs.\n+\n+(define_split\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t   (const_int 255)))\n+\t      (clobber (reg:CC CC_REG))])]\n   \"\"\n-  {\n-    if (CONST_INT_P (operands[2]))\n-      switch (INTVAL (operands[2]))\n-        {\n-        case 0xff:       return \"extbu %0\";\n-        case 0xffff:     return \"exthu %0\";\n-        case 0x7fffffff: return \"add  %0, %0; lsr 1, %0\";\n-        case 0x3fffffff: return \"asl2 %0; lsr 2, %0\";\n-        case 0x1fffffff: return \"add  %0, %0; asl2 %0; lsr 3, %0\";\n-        case 0x0fffffff: return \"asl2 %0; asl2 %0; lsr 4, %0\";\n-        case 0xfffffffe: return \"lsr 1, %0; add  %0, %0\";\n-        case 0xfffffffc: return \"lsr 2, %0; asl2 %0\";\n-        case 0xfffffff8: return \"lsr 3, %0; add  %0, %0; asl2 %0\";\n-        case 0xfffffff0: return \"lsr 4, %0; asl2 %0; asl2 %0\";\n-\t}\n+  [(set (match_dup 0) (zero_extend:SI (match_dup 1)))]\n+  { operands[1] = gen_lowpart (QImode, operands[1]); }\n+)\n \n-    return \"and %2, %0\";\n-  }\n-  [(set_attr \"timings\" \"33\")]\n+(define_split\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t   (const_int 65535)))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"\"\n+  [(set (match_dup 0) (zero_extend:SI (match_dup 1)))]\n+  { operands[1] = gen_lowpart (HImode, operands[1]); }\n )\n \n+;; Split AND by an appropriate constant into two shifts.  Recall that \n+;; operations with a full 32-bit immediate require an extra cycle, so\n+;; this is a size optimization with no speed penalty.  This only applies\n+;; do DATA_REGS; the shift insns that AM33 adds are too large for a win.\n+\n+(define_split\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (and:SI (match_dup 0)\n+\t\t\t   (match_operand:SI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"reload_completed\n+   && REGNO_DATA_P (true_regnum (operands[0]), 1)\n+   && mn10300_split_and_operand_count (operands[1]) != 0\"\n+  [(const_int 0)]\n+{\n+  int count = mn10300_split_and_operand_count (operands[1]);\n+  if (count > 0)\n+    {\n+      emit_insn (gen_lshrsi3 (operands[0], operands[0], GEN_INT (count)));\n+      emit_insn (gen_ashlsi3 (operands[0], operands[0], GEN_INT (count)));\n+    }\n+  else\n+    {\n+      emit_insn (gen_ashlsi3 (operands[0], operands[0], GEN_INT (-count)));\n+      emit_insn (gen_lshrsi3 (operands[0], operands[0], GEN_INT (-count)));\n+    }\n+  DONE;\n+})\n+\n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"iorsi3\"\n-  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n-\t\t   (ior:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*am33_iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-  {\n-    if (REG_P (operands[2]) && REG_P (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[2])\n-        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n-      return \\\"mov %1,%0\\;or %2,%0\\\";\n-    if (REG_P (operands[2]) && REG_P (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[2]))\n-      return \\\"or %1,%2,%0\\\";\n-    if (REG_P (operands[2]) && REG_P (operands[0])\n-        && true_regnum (operands[2]) == true_regnum (operands[0]))\n-      return \\\"or %1,%0\\\";\n-    return \\\"or %2,%0\\\";\n-  }\"\n-  [(set_attr \"timings\" \"22\")]\n-)\n-\n-(define_insn \"*mn10300_iorsi3\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,D,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \" i,D,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"or %2,%0\"\n-  [(set_attr \"timings\" \"33\")]\n+  \"@\n+   or %2,%0\n+   or %2,%0\n+   or %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"timings\" \"22,11,11\")]\n+)\n+\n+(define_insn \"*iorsi3_flags\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,D,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \" i,D,r\")))\n+   (set (reg CC_REG)\n+   \t(compare (ior:SI (match_dup 1) (match_dup 2))\n+\t\t (const_int 0)))]\n+  \"reload_completed && mn10300_match_ccmode (insn, CCZNmode)\"\n+  \"@\n+   or %2,%0\n+   or %2,%0\n+   or %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"timings\" \"22,11,11\")]\n )\n \n ;; ----------------------------------------------------------------------\n ;; XOR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"xorsi3\"\n-  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n-\t\t   (xor:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*am33_xorsi3\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx,!dax\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-  {\n-    if (REG_P (operands[2]) && REG_P (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[2])\n-        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n-      return \\\"mov %1,%0\\;xor %2,%0\\\";\n-    if (REG_P (operands[2]) && REG_P (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[1])\n-        && true_regnum (operands[0]) != true_regnum (operands[2]))\n-      return \\\"xor %1,%2,%0\\\";\n-    if (REG_P (operands[2]) && REG_P (operands[0])\n-        && true_regnum (operands[2]) == true_regnum (operands[0]))\n-      return \\\"xor %1,%0\\\";\n-    return \\\"xor %2,%0\\\";\n-  }\"\n-  [(set_attr \"timings\" \"22\")]\n-)\n-\n-(define_insn \"*mn10300_xorsi3\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,D,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \" i,D,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"xor %2,%0\"\n-  [(set_attr \"timings\" \"11\")]\n+  \"@\n+   xor %2,%0\n+   xor %2,%0\n+   xor %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"timings\" \"22,11,11\")]\n+)\n+\n+(define_insn \"*xorsi3_flags\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=D,D,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \" i,D,r\")))\n+   (set (reg CC_REG)\n+   \t(compare (xor:SI (match_dup 1) (match_dup 2))\n+\t\t (const_int 0)))]\n+  \"reload_completed && mn10300_match_ccmode (insn, CCZNmode)\"\n+  \"@\n+   xor %2,%0\n+   xor %2,%0\n+   xor %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr \"timings\" \"22,11,11\")]\n )\n \n ;; ----------------------------------------------------------------------\n ;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"one_cmplsi2\"\n-  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n-\t\t   (not:SI (match_operand:SI 1 \"register_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=D\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \" 0\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*am33_cmplsi2\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx,!dax\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0,0\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n   \"not %0\"\n )\n \n-(define_insn \"*mn10300_cmplsi2\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=dx\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n+(define_insn \"*one_cmplsi2_flags\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=D\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \" 0\")))\n+   (set (reg CC_REG)\n+   \t(compare (not:SI (match_dup 1))\n+\t\t (const_int 0)))]\n+  \"reload_completed && mn10300_match_ccmode (insn, CCZNmode)\"\n   \"not %0\"\n )\n \f\n@@ -1165,140 +987,133 @@\n \t      (match_operator                    0 \"ordered_comparison_operator\"\n \t\t\t      [(match_operand:SI 1 \"register_operand\")\n \t\t\t       (match_operand:SI 2 \"nonmemory_operand\")])\n-              (label_ref (match_operand          3 \"\"))\n+              (label_ref (match_operand 3 \"\"))\n               (pc)))]\n   \"\"\n   \"\"\n )\n \n-(define_insn_and_split \"*cbranchsi4_post_reload\"\n+(define_insn_and_split \"*cbranchsi4_cmp\"\n   [(set (pc)\n \t(if_then_else (match_operator           3 \"ordered_comparison_operator\"\n-                       [(match_operand:SI       0 \"register_operand\"  \"dax\")\n-\t\t        (match_operand:SI       1 \"nonmemory_operand\" \"daxi\")])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n+                       [(match_operand:SI       0 \"register_operand\"  \"r\")\n+\t\t        (match_operand:SI       1 \"nonmemory_operand\" \"ri\")])\n+\t\t      (match_operand            2 \"label_ref_operand\" \"\")\n+\t\t      (pc)))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n-  /* We construct the split by hand as otherwise the JUMP_LABEL\n-     attribute is not set correctly on the jump insn.  */\n-  emit_insn (gen_cmpsi (operands[0], operands[1]));\n-  \n-  emit_jump_insn (gen_integer_conditional_branch\n-                      (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n-\t\t\t\t       CCmode,\n-\t\t \t\t       gen_rtx_REG (CCmode, CC_REG),\n-\t\t\t\t  \t            const0_rtx),\n-\t\t\t\t       operands[2]));\n-  \"\n-)\n+{\n+  mn10300_split_cbranch (CCmode, operands[3], operands[2]);\n+  DONE;\n+})\n \n-;; Ordinarily, the cmp instruction will set the Z bit of cc0 to 1 if\n-;; its operands hold equal values, but the operands of a cmp\n-;; instruction must be distinct registers.  In the case where we'd\n-;; like to compare a register to itself, we can achieve this effect\n-;; with a btst 0,d0 instead.  (This will not alter the contents of d0\n-;; but will have the proper effect on cc0.  Using d0 is arbitrary; any\n-;; data register would work.)\n-\n-;; Even though the first alternative would be preferable if it can\n-;; possibly match, reload must not be given the opportunity to attempt\n-;; to use it.  It assumes that such matches can only occur when one of\n-;; the operands is used for input and the other for output.  Since\n-;; this is not the case, it abort()s.  Indeed, such a reload cannot be\n-;; possibly satisfied, so just mark the alternative with a `!', so\n-;; that it is not considered by reload.\n-\n-(define_insn \"cmpsi\"\n-  [(set (reg:CC CC_REG)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax,dax\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"*0,I,daxi\")))]\n-  \"\"\n-  {\n-    if (which_alternative == 0)\n-      return \\\"btst 0,d0\\\";\n-    if (which_alternative == 1)\n-      return mn10300_output_cmp (operands[0], insn);\n-    return \\\"cmp %1,%0\\\";\n-  }\n+(define_insn \"*cmpsi\"\n+  [(set (reg CC_REG)\n+\t(compare (match_operand:SI 0 \"register_operand\"  \"r\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"ri\")))]\n+  \"reload_completed\"\n+{\n+  /* The operands of CMP must be distinct registers.  In the case where\n+     we've failed to optimize the comparison of a register to itself, we\n+     must use another method to set the Z flag.  We can achieve this \n+     effect with a BTST 0,D0.  This will not alter the contents of D0;\n+     the use of d0 is arbitrary; any data register would work.  */\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    return \"btst 0,d0\";\n+  else\n+    return \"cmp %1,%0\";\n+}\n   [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 11) (const_int 22))\n-\t\t\t  (const_int 22)\n-\t\t\t ])\n-  ]\n+     [(if_then_else (eq_attr \"cpu\" \"am34\") (const_int 11) (const_int 22))])]\n )\n \n-(define_insn \"integer_conditional_branch\"\n+(define_insn \"*integer_conditional_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC CC_REG) (const_int 0)])\n+\t\t\t[(match_operand 2 \"int_mode_flags\" \"\")\n+\t\t\t (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n-  \"\"\n+  \"reload_completed\"\n   \"b%b0 %1\"\n )\n \n+(define_insn_and_split \"*cbranchsi4_btst\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 3 \"CCZN_comparison_operator\"\n+\t    [(and:SI (match_operand:SI 0 \"register_operand\" \"D\")\n+\t\t     (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t     (const_int 0)])\n+\t  (match_operand 2 \"label_ref_operand\" \"\")\n+\t  (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  mn10300_split_cbranch (CCZNmode, operands[3], operands[2]);\n+  DONE;\n+})\n+\n+(define_insn \"*btstsi\"\n+  [(set (reg:CCZN CC_REG)\n+\t(compare:CCZN\n+\t  (and:SI (match_operand:SI 0 \"register_operand\" \"D\")\n+\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t  (const_int 0)))]\n+  \"reload_completed\"\n+  \"btst %1,%0\"\n+)\n+\n (define_expand \"cbranchsf4\"\n   [(set (pc)\n       (if_then_else\n             (match_operator                    0 \"ordered_comparison_operator\"\n \t\t\t    [(match_operand:SF 1 \"register_operand\")\n \t\t\t     (match_operand:SF 2 \"nonmemory_operand\")])\n-\t    (label_ref (match_operand          3 \"\"))\n+\t    (label_ref (match_operand 3 \"\"))\n \t    (pc)))]\n   \"TARGET_AM33_2\"\n   \"\"\n )\n \n-(define_insn_and_split \"*cbranchsf4_post_reload\"\n+(define_insn_and_split \"*cbranchsf4_cmp\"\n   [(set (pc)\n \t(if_then_else (match_operator            3 \"ordered_comparison_operator\"\n \t\t\t[(match_operand:SF       0 \"register_operand\"  \"f\")\n \t\t\t (match_operand:SF       1 \"nonmemory_operand\" \"fF\")])\n-\t\t      (label_ref (match_operand  2 \"\" \"\"))\n+\t\t      (match_operand             2 \"label_ref_operand\" \"\")\n \t\t      (pc)))\n    ]\n   \"TARGET_AM33_2\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n-  \"\n-  /* We construct the split by hand as otherwise the JUMP_LABEL\n-     attribute is not set correctly on the jump insn.  */\n-  emit_insn (gen_am33_cmpsf (operands[0], operands[1]));\n-  \n-  emit_jump_insn (gen_float_conditional_branch\n-                     (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n-\t\t\t\t      CC_FLOATmode,\n- \t\t \t       \t      gen_rtx_REG (CC_FLOATmode, CC_REG),\n-\t\t\t\t      const0_rtx),\n-\t\t\t\t      operands[2]));\n-  \"\n-)\n+{\n+  mn10300_split_cbranch (CC_FLOATmode, operands[3], operands[2]);\n+  DONE;\n+})\n \n-(define_insn \"am33_cmpsf\"\n+(define_insn \"*am33_cmpsf\"\n   [(set (reg:CC_FLOAT CC_REG)\n \t(compare:CC_FLOAT (match_operand:SF 0 \"register_operand\"  \"f\")\n \t\t\t  (match_operand:SF 1 \"nonmemory_operand\" \"fF\")))]\n-  \"TARGET_AM33_2\"\n+  \"TARGET_AM33_2 && reload_completed\"\n   \"fcmp %1, %0\"\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 17) (const_int 25)))]\n )\n \n-(define_insn \"float_conditional_branch\"\n+(define_insn \"*float_conditional_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t\t      [(reg:CC_FLOAT CC_REG) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_AM33_2\"\n+  \"TARGET_AM33_2 && reload_completed\"\n   \"fb%b0 %1\"\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 44) (const_int 33)))]\n@@ -1340,7 +1155,6 @@\n    (match_operand:SI 2 \"immediate_operand\")\n    (match_operand 3 \"\" \"\") (match_operand 4 \"\")]\n   \"\"\n-  \"\n {\n   rtx table = gen_reg_rtx (SImode);\n   rtx index = gen_reg_rtx (SImode);\n@@ -1360,7 +1174,7 @@\n \n   emit_jump_insn (gen_tablejump (addr, operands[3]));\n   DONE;\n-}\")\n+})\n \n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n@@ -1470,7 +1284,6 @@\n               (match_operand 1 \"\")\n               (match_operand 2 \"\")])]\n   \"\"\n-  \"\n {\n   int i;\n \n@@ -1482,7 +1295,7 @@\n       emit_move_insn (SET_DEST (set), SET_SRC (set));\n     }\n   DONE;\n-}\")\n+})\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -1494,328 +1307,109 @@\n ;; EXTEND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"      \"=D,D,r\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\")))]\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \" 0,m,r\")))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*zero_extendqisi2_am33\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n-\t(zero_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"0,dax,m,0,dax,m\")))]\n-  \"TARGET_AM33\"\n   \"@\n-  extbu %0\n-  mov %1,%0\\;extbu %0\n-  movbu %1,%0\n-  extbu %0\n-  mov %1,%0\\;extbu %0\n-  movbu %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_insn \"*zero_extendqisi2_mn10300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx\")\n-\t(zero_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"0,d,m\")))]\n-  \"\"\n-  \"@\n-  extbu %0\n-  mov %1,%0\\;extbu %0\n-  movbu %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n-)\n-\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*zero_extendhisi2_am33\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,dax,m,0,dax,m\")))]\n-  \"TARGET_AM33\"\n-  \"@\n-  exthu %0\n-  mov %1,%0\\;exthu %0\n-  movhu %1,%0\n-  exthu %0\n-  mov %1,%0\\;exthu %0\n-  movhu %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t  (const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n+   extbu %0\n+   movbu %1,%0\n+   extbu %1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr_alternative \"timings\"\n+\t\t [(const_int 11)\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 24))\n+\t\t  (const_int 11)\n+\t\t ])]\n )\n \n-(define_insn \"*zero_extendhisi2_mn10300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,dx\")\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"      \"=D,D,r\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,dx,m\")))]\n-  \"\"\n-  \"@\n-  exthu %0\n-  mov %1,%0\\;exthu %0\n-  movhu %1,%0\"\n-  [(set_attr_alternative \"timings\"\n-\t\t\t [(const_int 11)\n-\t\t\t  (const_int 22)\n-\t\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t\t(const_int 13) (const_int 24))\n-\t\t\t ])\n-  ]\n-)\n-\n-;;- sign extension instructions\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"register_operand\")))]\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \" 0,m,r\")))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*extendqisi2_am33\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,!dax,!dax\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"0,dx,0,dax\")))]\n-  \"TARGET_AM33\"\n   \"@\n-  extb %0\n-  mov %1,%0\\;extb %0\n-  extb %0\n-  mov %1,%0\\;extb %0\"\n-  [(set_attr \"timings\" \"11,22,11,22\")]\n-)\n-\n-(define_insn \"*extendqisi2_mn10300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"0,dx\")))]\n-  \"\"\n-  \"@\n-  extb %0\n-  mov %1,%0\\;extb %0\"\n-  [(set_attr \"timings\" \"11,22\")]\n+   exthu %0\n+   movhu %1,%0\n+   exthu %1,%0\"\n+  [(set_attr \"isa\" \"*,*,am33\")\n+   (set_attr_alternative \"timings\"\n+\t\t [(const_int 11)\n+\t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n+\t\t\t\t(const_int 13) (const_int 24))\n+\t\t  (const_int 11)])]\n )\n \n-(define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,r\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"register_operand\")))]\n+\t (match_operand:QI 1 \"register_operand\" \"0,r\")))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*extendhisi2_am33\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,!dax,!dax\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"0,dax,0,dax\")))]\n-  \"TARGET_AM33\"\n   \"@\n-  exth %0\n-  mov %1,%0\\;exth %0\n-  exth %0\n-  mov %1,%0\\;exth %0\"\n-  [(set_attr \"timings\" \"11,22,11,22\")]\n+   extb %0\n+   extb %1,%0\"\n+  [(set_attr \"isa\" \"*,am33\")]\n )\n \n-(define_insn \"*extendhisi2_mn10300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,r\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"0,dx\")))]\n+\t (match_operand:HI 1 \"register_operand\" \"0,r\")))]\n   \"\"\n   \"@\n-  exth %0\n-  mov %1,%0\\;exth %0\"\n-  [(set_attr \"timings\" \"11,22\")]\n+   exth %0\n+   exth %1,%0\"\n+  [(set_attr \"isa\" \"*,am33\")]\n )\n \f\n ;; ----------------------------------------------------------------------\n ;; SHIFTS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"ashlsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n-\t\t   (ashift:SI\n-\t\t    (match_operand:SI 1 \"register_operand\")\n-\t\t    (match_operand:QI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*am33_ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,!dax\")\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=r,D,d,d, D,r\")\n \t(ashift:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,0,dax\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"J,dxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-  {\n-    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n-      return \\\"add %0,%0\\\";\n-\n-    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 2)\n-      return \\\"asl2 %0\\\";\n-\n-    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 3\n-        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n-      return \\\"asl2 %0\\;add %0,%0\\\";\n-\n-    if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 4\n-        && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n-      return \\\"asl2 %0\\;asl2 %0\\\";\n-\n-    if (true_regnum (operands[1]) == true_regnum (operands[0]))\n-      return \\\"asl %S2,%0\\\";\n-\n-    if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-        && true_regnum (operands[0]) != true_regnum (operands[2]))\n-      return \\\"mov %1,%0\\;asl %S2,%0\\\";\n-    return \\\"asl %2,%1,%0\\\";\n-  }\"\n-  [(set_attr \"timings\" \"22\")]\n-)\n-\n-(define_insn \"*mn10300_ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,dx,dx,dx\")\n-\t(ashift:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,0,0,0,0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"J,K,M,L,dxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+\t  (match_operand:SI 1 \"register_operand\"  \" 0,0,0,0, 0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \" J,K,M,L,Di,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n-  add %0,%0\n-  asl2 %0\n-  asl2 %0\\;add %0,%0\n-  asl2 %0\\;asl2 %0\n-  asl %S2,%0\"\n-  [(set_attr \"timings\" \"11,11,22,22,11\")]\n-)\n-\n-(define_expand \"lshrsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n-\t\t   (lshiftrt:SI\n-\t\t    (match_operand:SI 1 \"register_operand\")\n-\t\t    (match_operand:QI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*am33_lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+   add %0,%0\n+   asl2 %0\n+   asl2 %0\\;add %0,%0\n+   asl2 %0\\;asl2 %0\n+   asl %S2,%0\n+   asl %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,*,*,*,*,am33\")\n+   (set_attr \"timings\" \"11,11,22,22,11,11\")]\n+)\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=D,r\")\n \t(lshiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,dax\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-  {\n-    if (true_regnum (operands[1]) == true_regnum (operands[0]))\n-      return \\\"lsr %S2,%0\\\";\n-\n-    if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-        && true_regnum (operands[0]) != true_regnum (operands[2]))\n-      return \\\"mov %1,%0\\;lsr %S2,%0\\\";\n-    return \\\"lsr %2,%1,%0\\\";\n-  }\"\n-  [(set_attr \"timings\" \"22\")]\n-)\n-\n-(define_insn \"*mn10300_lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n-\t(lshiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"\"\n-  \"lsr %S2,%0\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 11) (const_int 22)))]\n-)\n-\n-(define_expand \"ashrsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n-\t\t   (ashiftrt:SI\n-\t\t    (match_operand:SI 1 \"register_operand\")\n-\t\t    (match_operand:QI 2 \"nonmemory_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n+\t  (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"Di,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"\")\n-\n-(define_insn \"*am33_ashrisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n-\t(ashiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,dax\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n-  {\n-    if (true_regnum (operands[1]) == true_regnum (operands[0]))\n-      return \\\"asr %S2,%0\\\";\n-\n-    if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n-        && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n-        && true_regnum (operands[0]) != true_regnum (operands[2]))\n-      return \\\"mov %1,%0\\;asr %S2,%0\\\";\n-    return \\\"asr %2,%1,%0\\\";\n-  }\"\n-  [(set_attr \"timings\" \"22\")]\n+  \"@\n+   lsr %S2,%0\n+   lsr %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,am33\")]\n )\n \n-(define_insn \"*mn10300_ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI  0 \"register_operand\"  \"=D,r\")\n \t(ashiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+\t  (match_operand:SI 1 \"register_operand\"  \" 0,r\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"Di,r\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"asr %S2,%0\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 11) (const_int 22)))]\n+  \"@\n+   asr %S2,%0\n+   asr %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,am33\")]\n )\n \n ;; ----------------------------------------------------------------------\n@@ -2092,28 +1686,6 @@\n   [(set_attr \"timings\" \"66\")]\n )\n \n-;; Try to combine consecutive updates of the stack pointer (or any\n-;; other register for that matter).\n-(define_peephole\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=dxay\")\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (match_operand 1 \"const_int_operand\" \"\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-   (parallel [(set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (match_operand 2 \"const_int_operand\" \"\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n-  \"\"\n-  \"*\n-{\n-  operands[1] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[1]));\n-  return \\\"add %1,%0\\\";\n-}\"\n-)\n-\n (define_expand \"int_label\"\n   [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_INT_LABEL)]\n   \"\" \"\")"}, {"sha": "4badebba69905a28f469694d5ccb594cb33839ab", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad41521231654dafc67f31cb8abfa47ad09c691/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=bad41521231654dafc67f31cb8abfa47ad09c691", "patch": "@@ -42,3 +42,19 @@\n   return XEXP (op, 0) == stack_pointer_rtx\n       || XEXP (op, 1) == stack_pointer_rtx;\n })\n+\n+(define_predicate \"label_ref_operand\"\n+  (match_code \"label_ref\"))\n+\n+(define_special_predicate \"int_mode_flags\"\n+  (match_code \"reg\")\n+{\n+  if (REGNO (op) != CC_REG)\n+    return false;\n+  if (GET_MODE (op) == CC_FLOATmode)\n+    return false;\n+  return GET_MODE_CLASS (GET_MODE (op)) == MODE_CC;\n+})\n+\n+(define_predicate \"CCZN_comparison_operator\"\n+  (match_code \"eq,ne,lt,ge\"))"}]}