{"sha": "c4d91f2eacf4676d3231e687165a7a35e15b2a17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRkOTFmMmVhY2Y0Njc2ZDMyMzFlNjg3MTY1YTdhMzVlMTViMmExNw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2014-10-09T04:38:24Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2014-10-09T04:38:24Z"}, "message": "re PR bootstrap/63432 (profiledbootstrap failure with bootstrap-lto)\n\n2014-10-07  Teresa Johnson  <tejohnson@google.com>\n\n\tPR bootstrap/63432.\n\t* tree-ssa-threadupdate.c (estimated_freqs_path): New function.\n\t(ssa_fix_duplicate_block_edges): Invoke it.\n\t(mark_threaded_blocks): Make two passes to avoid ordering dependences.\n\nFrom-SVN: r216024", "tree": {"sha": "e0554cf51a419efae0e45e1002c05cda4007372b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0554cf51a419efae0e45e1002c05cda4007372b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4d91f2eacf4676d3231e687165a7a35e15b2a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d91f2eacf4676d3231e687165a7a35e15b2a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d91f2eacf4676d3231e687165a7a35e15b2a17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d91f2eacf4676d3231e687165a7a35e15b2a17/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a950eea53943d0103b206e8bb25cd93f7734ccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a950eea53943d0103b206e8bb25cd93f7734ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a950eea53943d0103b206e8bb25cd93f7734ccf"}], "stats": {"total": 91, "additions": 77, "deletions": 14}, "files": [{"sha": "7884a8a4c54c858f78561ddd9594eb58af87035b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d91f2eacf4676d3231e687165a7a35e15b2a17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d91f2eacf4676d3231e687165a7a35e15b2a17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4d91f2eacf4676d3231e687165a7a35e15b2a17", "patch": "@@ -1,3 +1,10 @@\n+2014-10-08  Teresa Johnson  <tejohnson@google.com>\n+\n+\tPR bootstrap/63432.\n+\t* tree-ssa-threadupdate.c (estimated_freqs_path): New function.\n+\t(ssa_fix_duplicate_block_edges): Invoke it.\n+\t(mark_threaded_blocks): Make two passes to avoid ordering dependences.\n+\n 2014-10-08  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/52941"}, {"sha": "125f6f8776d98a0d7235e2b10d41ed7453cb774d", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 70, "deletions": 14, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d91f2eacf4676d3231e687165a7a35e15b2a17/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d91f2eacf4676d3231e687165a7a35e15b2a17/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c4d91f2eacf4676d3231e687165a7a35e15b2a17", "patch": "@@ -959,6 +959,43 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n }\n \n \n+/* Check if the paths through RD all have estimated frequencies but zero\n+   profile counts.  This is more accurate than checking the entry block\n+   for a zero profile count, since profile insanities sometimes creep in.  */\n+\n+static bool\n+estimated_freqs_path (struct redirection_data *rd)\n+{\n+  edge e = rd->incoming_edges->e;\n+  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+  edge ein;\n+  edge_iterator ei;\n+  bool non_zero_freq = false;\n+  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n+    {\n+      if (ein->count)\n+        return false;\n+      non_zero_freq |= ein->src->frequency != 0;\n+    }\n+\n+  for (unsigned int i = 1; i < path->length (); i++)\n+    {\n+      edge epath = (*path)[i]->e;\n+      if (epath->src->count)\n+        return false;\n+      non_zero_freq |= epath->src->frequency != 0;\n+      edge esucc;\n+      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+        {\n+          if (esucc->count)\n+            return false;\n+          non_zero_freq |= esucc->src->frequency != 0;\n+        }\n+    }\n+  return non_zero_freq;\n+}\n+\n+\n /* Invoked for routines that have guessed frequencies and no profile\n    counts to record the block and edge frequencies for paths through RD\n    in the profile count fields of those blocks and edges.  This is because\n@@ -1058,9 +1095,11 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n      data we first take a snapshot of the existing block and edge frequencies\n      by copying them into the empty profile count fields.  These counts are\n      then used to do the incremental updates, and cleared at the end of this\n-     routine.  */\n+     routine.  If the function is marked as having a profile, we still check\n+     to see if the paths through RD are using estimated frequencies because\n+     the routine had zero profile counts.  */\n   bool do_freqs_to_counts = (profile_status_for_fn (cfun) != PROFILE_READ\n-                             || !ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n+                             || estimated_freqs_path (rd));\n   if (do_freqs_to_counts)\n     freqs_to_counts_path (rd);\n \n@@ -2077,35 +2116,52 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \n   /* Now iterate again, converting cases where we want to thread\n      through a joiner block, but only if no other edge on the path\n-     already has a jump thread attached to it.  */\n+     already has a jump thread attached to it.  We do this in two passes,\n+     to avoid situations where the order in the paths vec can hide overlapping\n+     threads (the path is recorded on the incoming edge, so we would miss\n+     cases where the second path starts at a downstream edge on the same\n+     path).  First record all joiner paths, deleting any in the unexpected\n+     case where there is already a path for that incoming edge.  */\n   for (i = 0; i < paths.length (); i++)\n     {\n       vec<jump_thread_edge *> *path = paths[i];\n \n       if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+        {\n+\t  /* Attach the path to the starting edge if none is yet recorded.  */\n+          if ((*path)[0]->e->aux == NULL)\n+            (*path)[0]->e->aux = path;\n+\t  else if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    dump_jump_thread_path (dump_file, *path, false);\n+        }\n+    }\n+  /* Second, look for paths that have any other jump thread attached to\n+     them, and either finish converting them or cancel them.  */\n+  for (i = 0; i < paths.length (); i++)\n+    {\n+      vec<jump_thread_edge *> *path = paths[i];\n+      edge e = (*path)[0]->e;\n+\n+      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK && e->aux == path)\n \t{\n \t  unsigned int j;\n-\n-\t  for (j = 0; j < path->length (); j++)\n+\t  for (j = 1; j < path->length (); j++)\n \t    if ((*path)[j]->e->aux != NULL)\n \t      break;\n \n \t  /* If we iterated through the entire path without exiting the loop,\n-\t     then we are good to go, attach the path to the starting edge.  */\n+\t     then we are good to go, record it.  */\n \t  if (j == path->length ())\n+\t    bitmap_set_bit (tmp, e->dest->index);\n+\t  else\n \t    {\n-\t      edge e = (*path)[0]->e;\n-\t      e->aux = path;\n-\t      bitmap_set_bit (tmp, e->dest->index);\n-\t    }\n-\t  else if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      dump_jump_thread_path (dump_file, *path, false);\n+\t      e->aux = NULL;\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        dump_jump_thread_path (dump_file, *path, false);\n \t    }\n \t}\n     }\n \n-\n   /* If optimizing for size, only thread through block if we don't have\n      to duplicate it or it's an otherwise empty redirection block.  */\n   if (optimize_function_for_size_p (cfun))"}]}