{"sha": "7dbb85a7932149aa5bac38fd77424b15c0248990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RiYjg1YTc5MzIxNDlhYTViYWMzOGZkNzc0MjRiMTVjMDI0ODk5MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-11-09T16:14:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-11-09T16:14:37Z"}, "message": "Add C++ attribute abi_tag and -Wabi-tag option.\n\ngcc/\n\t* attribs.c (lookup_attribute_spec): Handle getting a TREE_LIST.\ngcc/c-family/\n\t* c.opt (Wabi-tag): New.\ngcc/cp/\n\t* tree.c (cxx_attribute_table): Add abi_tag attribute.\n\t(check_abi_tag_redeclaration, handle_abi_tag_attribute): New.\n\t* class.c (find_abi_tags_r, check_abi_tags): New.\n\t(check_bases, check_field_decl): Call check_abi_tags.\n\t* decl.c (redeclaration_error_message): Call\n\tcheck_abi_tag_redeclaration.\n\t* mangle.c (tree_string_cmp, write_abi_tags): New.\n\t(write_unqualified_name): Call write_abi_tags.\ninclude/\n\t* demangle.h (enum demangle_component_type): Add\n\tDEMANGLE_COMPONENT_TAGGED_NAME.\nlibiberty/\n\t* cp-demangle.c (d_dump): Handle DEMANGLE_COMPONENT_TAGGED_NAME.\n\t(d_make_comp, d_find_pack, d_print_comp): Likewise.\n\t(d_abi_tags): New.\n\t(d_name): Call it.\n\nFrom-SVN: r193367", "tree": {"sha": "af7983d092e390f212209b62a57e8d2eac7d8be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af7983d092e390f212209b62a57e8d2eac7d8be6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dbb85a7932149aa5bac38fd77424b15c0248990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbb85a7932149aa5bac38fd77424b15c0248990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dbb85a7932149aa5bac38fd77424b15c0248990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbb85a7932149aa5bac38fd77424b15c0248990/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52dccf7ac9926edabb9574d6440314938a33c143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52dccf7ac9926edabb9574d6440314938a33c143", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52dccf7ac9926edabb9574d6440314938a33c143"}], "stats": {"total": 402, "additions": 387, "deletions": 15}, "files": [{"sha": "37049f910a0880f29bc9b67be4c9c8febff1a8e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1,3 +1,7 @@\n+2012-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* attribs.c (lookup_attribute_spec): Handle getting a TREE_LIST.\n+\n 2012-11-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR tree-optimization/55154"}, {"sha": "0425de9f5b127f65c2bed05f1deb3c55d983c924", "filename": "gcc/attribs.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -325,12 +325,21 @@ lookup_scoped_attribute_spec (const_tree ns, const_tree name)\n \t\t\t substring_hash (attr.str, attr.length));\n }\n \n-/* Return the spec for the attribute named NAME.  */\n+/* Return the spec for the attribute named NAME.  If NAME is a TREE_LIST,\n+   it also specifies the attribute namespace.  */\n \n const struct attribute_spec *\n lookup_attribute_spec (const_tree name)\n {\n-  return lookup_scoped_attribute_spec (get_identifier (\"gnu\"), name);\n+  tree ns;\n+  if (TREE_CODE (name) == TREE_LIST)\n+    {\n+      ns = TREE_PURPOSE (name);\n+      name = TREE_VALUE (name);\n+    }\n+  else\n+    ns = get_identifier (\"gnu\");\n+  return lookup_scoped_attribute_spec (ns, name);\n }\n \n \f"}, {"sha": "b3234d34dd58f036d8b35911bc21e841d3e1e351", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1,3 +1,7 @@\n+2012-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt (Wabi-tag): New.\n+\n 2012-11-09  Andi Kleen  <ak@linux.intel.com>\n \n \tPR 55139"}, {"sha": "fe1fc4d5ac09774532b0aa81a4d223a82c720526", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -257,6 +257,10 @@ Wabi\n C ObjC C++ ObjC++ LTO Var(warn_abi) Warning\n Warn about things that will change when compiling with an ABI-compliant compiler\n \n+Wabi-tag\n+C++ ObjC++ Var(warn_abi_tag) Warning\n+Warn if a subobject has an abi_tag attribute that the complete object type does not have\n+\n Wpsabi\n C ObjC C++ ObjC++ LTO Var(warn_psabi) Init(1) Undocumented\n "}, {"sha": "4d6d954db1f70f4fb7bdb8155e9c3b426d71aae4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1,3 +1,14 @@\n+2012-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.c (cxx_attribute_table): Add abi_tag attribute.\n+\t(check_abi_tag_redeclaration, handle_abi_tag_attribute): New.\n+\t* class.c (find_abi_tags_r, check_abi_tags): New.\n+\t(check_bases, check_field_decl): Call check_abi_tags.\n+\t* decl.c (redeclaration_error_message): Call\n+\tcheck_abi_tag_redeclaration.\n+\t* mangle.c (tree_string_cmp, write_abi_tags): New.\n+\t(write_unqualified_name): Call write_abi_tags.\n+\n 2012-11-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55226"}, {"sha": "d3d9aed7ff786145f39ddeaaec919679cc363f3f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1302,6 +1302,89 @@ handle_using_decl (tree using_decl, tree t)\n     alter_access (t, decl, access);\n }\n \f\n+/* walk_tree callback for check_abi_tags: if the type at *TP involves any\n+   types with abi tags, add the corresponding identifiers to the VEC in\n+   *DATA and set IDENTIFIER_MARKED.  */\n+\n+struct abi_tag_data\n+{\n+  tree t;\n+  tree subob;\n+};\n+\n+static tree\n+find_abi_tags_r (tree *tp, int */*walk_subtrees*/, void *data)\n+{\n+  if (!TAGGED_TYPE_P (*tp))\n+    return NULL_TREE;\n+\n+  if (tree attributes = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (*tp)))\n+    {\n+      struct abi_tag_data *p = static_cast<struct abi_tag_data*>(data);\n+      for (tree list = TREE_VALUE (attributes); list;\n+\t   list = TREE_CHAIN (list))\n+\t{\n+\t  tree tag = TREE_VALUE (list);\n+\t  tree id = get_identifier (TREE_STRING_POINTER (tag));\n+\t  if (!IDENTIFIER_MARKED (id))\n+\t    {\n+\t      if (TYPE_P (p->subob))\n+\t\t{\n+\t\t  warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n+\t\t\t   \"that base %qT has\", p->t, tag, p->subob);\n+\t\t  inform (location_of (p->subob), \"%qT declared here\",\n+\t\t\t  p->subob);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n+\t\t\t   \"that %qT (used in the type of %qD) has\",\n+\t\t\t   p->t, tag, *tp, p->subob);\n+\t\t  inform (location_of (p->subob), \"%qD declared here\",\n+\t\t\t  p->subob);\n+\t\t  inform (location_of (*tp), \"%qT declared here\", *tp);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Check that class T has all the abi tags that subobject SUBOB has, or\n+   warn if not.  */\n+\n+static void\n+check_abi_tags (tree t, tree subob)\n+{\n+  tree attributes = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (t));\n+  if (attributes)\n+    {\n+      for (tree list = TREE_VALUE (attributes); list;\n+\t   list = TREE_CHAIN (list))\n+\t{\n+\t  tree tag = TREE_VALUE (list);\n+\t  tree id = get_identifier (TREE_STRING_POINTER (tag));\n+\t  IDENTIFIER_MARKED (id) = true;\n+\t}\n+    }\n+\n+  tree subtype = TYPE_P (subob) ? subob : TREE_TYPE (subob);\n+  struct abi_tag_data data = { t, subob };\n+\n+  cp_walk_tree_without_duplicates (&subtype, find_abi_tags_r, &data);\n+\n+  if (attributes)\n+    {\n+      for (tree list = TREE_VALUE (attributes); list;\n+\t   list = TREE_CHAIN (list))\n+\t{\n+\t  tree tag = TREE_VALUE (list);\n+\t  tree id = get_identifier (TREE_STRING_POINTER (tag));\n+\t  IDENTIFIER_MARKED (id) = false;\n+\t}\n+    }\n+}\n+\n /* Run through the base classes of T, updating CANT_HAVE_CONST_CTOR_P,\n    and NO_CONST_ASN_REF_P.  Also set flag bits in T based on\n    properties of the bases.  */\n@@ -1431,6 +1514,8 @@ check_bases (tree t,\n \t  if (tm_attr)\n \t    seen_tm_mask |= tm_attr_to_mask (tm_attr);\n \t}\n+\n+      check_abi_tags (t, basetype);\n     }\n \n   /* If one of the base classes had TM attributes, and the current class\n@@ -3147,6 +3232,9 @@ check_field_decl (tree field,\n \t  && !TYPE_HAS_CONST_COPY_ASSIGN (type))\n \t*no_const_asn_ref = 1;\n     }\n+\n+  check_abi_tags (t, field);\n+\n   if (DECL_INITIAL (field) != NULL_TREE)\n     {\n       /* `build_class_init_list' does not recognize"}, {"sha": "be7bc0b0269c74e9ef1b00af5de4e4c15f633537", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -5749,6 +5749,7 @@ extern bool type_has_nontrivial_default_init\t(const_tree);\n extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n+extern bool check_abi_tag_redeclaration\t\t(const_tree, const_tree, const_tree);\n extern tree strip_typedefs\t\t\t(tree);\n extern tree strip_typedefs_expr\t\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,"}, {"sha": "f85901fc6c70dfb795fcebc32ee4a4e0ab80fb2a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -2480,6 +2480,10 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t    }\n \t}\n \n+      check_abi_tag_redeclaration\n+\t(olddecl, lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (olddecl)),\n+\t lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (newdecl)));\n+\n       return NULL;\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)"}, {"sha": "54a4c9c4bca54e3ba3b1429c1b5cb68be730960b", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -173,6 +173,7 @@ static void mangle_call_offset (const tree, const tree);\n static void write_mangled_name (const tree, bool);\n static void write_encoding (const tree);\n static void write_name (tree, const int);\n+static void write_abi_tags (tree);\n static void write_unscoped_name (const tree);\n static void write_unscoped_template_name (const tree);\n static void write_nested_name (const tree);\n@@ -1192,15 +1193,17 @@ write_unqualified_name (const tree decl)\n       return;\n     }\n \n+  bool found = false;\n+\n   if (DECL_NAME (decl) == NULL_TREE)\n     {\n+      found = true;\n       gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n       write_source_name (DECL_ASSEMBLER_NAME (decl));\n-      return;\n     }\n   else if (DECL_DECLARES_FUNCTION_P (decl))\n     {\n-      bool found = true;\n+      found = true;\n       if (DECL_CONSTRUCTOR_P (decl))\n \twrite_special_name_constructor (decl);\n       else if (DECL_DESTRUCTOR_P (decl))\n@@ -1234,14 +1237,13 @@ write_unqualified_name (const tree decl)\n \twrite_literal_operator_name (DECL_NAME (decl));\n       else\n \tfound = false;\n-\n-      if (found)\n-\treturn;\n     }\n \n-  if (VAR_OR_FUNCTION_DECL_P (decl) && ! TREE_PUBLIC (decl)\n-      && DECL_NAMESPACE_SCOPE_P (decl)\n-      && decl_linkage (decl) == lk_internal)\n+  if (found)\n+    /* OK */;\n+  else if (VAR_OR_FUNCTION_DECL_P (decl) && ! TREE_PUBLIC (decl)\n+\t   && DECL_NAMESPACE_SCOPE_P (decl)\n+\t   && decl_linkage (decl) == lk_internal)\n     {\n       MANGLE_TRACE_TREE (\"local-source-name\", decl);\n       write_char ('L');\n@@ -1262,6 +1264,11 @@ write_unqualified_name (const tree decl)\n       else\n         write_source_name (DECL_NAME (decl));\n     }\n+\n+  tree attrs = (TREE_CODE (decl) == TYPE_DECL\n+\t\t? TYPE_ATTRIBUTES (TREE_TYPE (decl))\n+\t\t: DECL_ATTRIBUTES (decl));\n+  write_abi_tags (lookup_attribute (\"abi_tag\", attrs));\n }\n \n /* Write the unqualified-name for a conversion operator to TYPE.  */\n@@ -1291,6 +1298,51 @@ write_source_name (tree identifier)\n   write_identifier (IDENTIFIER_POINTER (identifier));\n }\n \n+/* Compare two TREE_STRINGs like strcmp.  */\n+\n+int\n+tree_string_cmp (const void *p1, const void *p2)\n+{\n+  if (p1 == p2)\n+    return 0;\n+  tree s1 = *(const tree*)p1;\n+  tree s2 = *(const tree*)p2;\n+  return strcmp (TREE_STRING_POINTER (s1),\n+\t\t TREE_STRING_POINTER (s2));\n+}\n+\n+/* ID is the name of a function or type with abi_tags attribute TAGS.\n+   Write out the name, suitably decorated.  */\n+\n+static void\n+write_abi_tags (tree tags)\n+{\n+  if (tags == NULL_TREE)\n+    return;\n+\n+  tags = TREE_VALUE (tags);\n+\n+  VEC(tree,gc)* vec = make_tree_vector();\n+\n+  for (tree t = tags; t; t = TREE_CHAIN (t))\n+    {\n+      tree str = TREE_VALUE (t);\n+      VEC_safe_push (tree, gc, vec, str);\n+    }\n+\n+  VEC_qsort (tree, vec, tree_string_cmp);\n+\n+  unsigned i; tree str;\n+  FOR_EACH_VEC_ELT (tree, vec, i, str)\n+    {\n+      write_string (\"B\");\n+      write_unsigned_number (TREE_STRING_LENGTH (str) - 1);\n+      write_identifier (TREE_STRING_POINTER (str));\n+    }\n+\n+  release_tree_vector (vec);\n+}\n+\n /* Write a user-defined literal operator.\n           ::= li <source-name>    # \"\" <source-name>\n    IDENTIFIER is an LITERAL_IDENTIFIER_NODE.  */"}, {"sha": "5df7b6c8a760b6ad17d2b5eaf052d2d112f8845a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -49,6 +49,7 @@ static tree build_local_temp (tree);\n static tree handle_java_interface_attribute (tree *, tree, tree, int, bool *);\n static tree handle_com_interface_attribute (tree *, tree, tree, int, bool *);\n static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_abi_tag_attribute (tree *, tree, tree, int, bool *);\n \n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  */\n@@ -3000,6 +3001,8 @@ const struct attribute_spec cxx_attribute_table[] =\n     handle_com_interface_attribute, false },\n   { \"init_priority\",  1, 1, true,  false, false,\n     handle_init_priority_attribute, false },\n+  { \"abi_tag\", 1, -1, false, false, false,\n+    handle_abi_tag_attribute, true },\n   { NULL,\t      0, 0, false, false, false, NULL, false }\n };\n \n@@ -3131,6 +3134,96 @@ handle_init_priority_attribute (tree* node,\n     }\n }\n \n+/* DECL is being redeclared; the old declaration had the abi tags in OLD,\n+   and the new one has the tags in NEW_.  Give an error if there are tags\n+   in NEW_ that weren't in OLD.  */\n+\n+bool\n+check_abi_tag_redeclaration (const_tree decl, const_tree old, const_tree new_)\n+{\n+  if (old && TREE_CODE (TREE_VALUE (old)) == TREE_LIST)\n+    old = TREE_VALUE (old);\n+  if (new_ && TREE_CODE (TREE_VALUE (new_)) == TREE_LIST)\n+    new_ = TREE_VALUE (new_);\n+  bool err = false;\n+  for (const_tree t = new_; t; t = TREE_CHAIN (t))\n+    {\n+      tree str = TREE_VALUE (t);\n+      for (const_tree in = old; in; in = TREE_CHAIN (in))\n+\t{\n+\t  tree ostr = TREE_VALUE (in);\n+\t  if (cp_tree_equal (str, ostr))\n+\t    goto found;\n+\t}\n+      error (\"redeclaration of %qD adds abi tag %E\", decl, str);\n+      err = true;\n+    found:;\n+    }\n+  if (err)\n+    {\n+      inform (DECL_SOURCE_LOCATION (decl), \"previous declaration here\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Handle an \"abi_tag\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_abi_tag_attribute (tree* node, tree name, tree args,\n+\t\t\t  int flags, bool* no_add_attrs)\n+{\n+  if (TYPE_P (*node))\n+    {\n+      if (!TAGGED_TYPE_P (*node))\n+\t{\n+\t  error (\"%qE attribute applied to non-class, non-enum type %qT\",\n+\t\t name, *node);\n+\t  goto fail;\n+\t}\n+      else if (!(flags & (int)ATTR_FLAG_TYPE_IN_PLACE))\n+\t{\n+\t  error (\"%qE attribute applied to %qT after its definition\",\n+\t\t name, *node);\n+\t  goto fail;\n+\t}\n+\n+      tree attributes = TYPE_ATTRIBUTES (*node);\n+      tree decl = TYPE_NAME (*node);\n+\n+      /* Make sure all declarations have the same abi tags.  */\n+      if (DECL_SOURCE_LOCATION (decl) != input_location)\n+\t{\n+\t  if (!check_abi_tag_redeclaration (decl,\n+\t\t\t\t\t    lookup_attribute (\"abi_tag\",\n+\t\t\t\t\t\t\t      attributes),\n+\t\t\t\t\t    args))\n+\t    goto fail;\n+\t}\n+    }\n+  else\n+    {\n+      if (TREE_CODE (*node) != FUNCTION_DECL)\n+\t{\n+\t  error (\"%qE attribute applied to non-function %qD\", name, *node);\n+\t  goto fail;\n+\t}\n+      else if (DECL_LANGUAGE (*node) == lang_c)\n+\t{\n+\t  error (\"%qE attribute applied to extern \\\"C\\\" function %qD\",\n+\t\t name, *node);\n+\t  goto fail;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+\n+ fail:\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n /* Return a new PTRMEM_CST of the indicated TYPE.  The MEMBER is the\n    thing pointed to by the constant.  */\n "}, {"sha": "fe09b85ef0b80eadc67bf999361c01e484c0dd43", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -15598,6 +15598,27 @@ You must specify @option{-Wno-pmf-conversions} to use this extension.\n Some attributes only make sense for C++ programs.\n \n @table @code\n+@item abi_tag (\"@var{tag}\", ...)\n+@cindex @code{abi_tag} attribute\n+The @code{abi_tag} attribute can be applied to a function or class\n+declaration.  It modifies the mangled name of the function or class to\n+incorporate the tag name, in order to distinguish the function or\n+class from an earlier version with a different ABI; perhaps the class\n+has changed size, or the function has a different return type that is\n+not encoded in the mangled name.\n+\n+The argument can be a list of strings of arbitrary length.  The\n+strings are sorted on output, so the order of the list is\n+unimportant.\n+\n+A redeclaration of a function or class must not add new ABI tags,\n+since doing so would change the mangled name.\n+\n+The @option{-Wabi-tag} flag enables a warning about a class which does\n+not have all the ABI tags used by its subobjects; for users with code\n+that needs to coexist with an earlier ABI, using this option can help\n+to find all affected types that need to be tagged.\n+\n @item init_priority (@var{priority})\n @cindex @code{init_priority} attribute\n "}, {"sha": "608e017943c6c6ca875caf8e2650def39a0709f5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1,3 +1,8 @@\n+2012-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/abi/abi-tag1.C: New.\n+\t* g++.dg/abi/abi-tag2.C: New.\n+\n 2012-11-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/55154"}, {"sha": "942929cdd35f456acdd22519af09e0726da9ebe1", "filename": "gcc/testsuite/g++.dg/abi/abi-tag1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag1.C?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-Wabi-tag\" }\n+\n+// { dg-final { scan-assembler \"_Z1fB3barB3fooi\" } }\n+void f(int) __attribute ((abi_tag (\"foo\",\"bar\")));\n+\n+struct __attribute ((abi_tag (\"bar\"))) A { };\n+\n+struct B: A { };\t\t// { dg-warning \"bar. abi tag\" }\n+struct D { A* ap; };\t\t// { dg-warning \"bar. abi tag\" }\n+\n+// { dg-final { scan-assembler \"_Z1gB3baz1AB3bar\" } }\n+void g(A) __attribute ((abi_tag (\"baz\")));\n+void g(A) __attribute ((abi_tag (\"baz\")));\n+\n+int main()\n+{\n+  f(42);\n+  g(A());\n+}"}, {"sha": "0e92dcc1dcce422821611d5f258c93364a76d1c2", "filename": "gcc/testsuite/g++.dg/abi/abi-tag2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag2.C?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -0,0 +1,5 @@\n+void f(int);\n+void f(int) __attribute ((abi_tag (\"foo\"))); // { dg-error \"adds abi tag\" }\n+\n+struct C;\n+struct __attribute ((abi_tag (\"foo\"))) C; // { dg-error \"adds abi tag\" }"}, {"sha": "ac2b28ed8ff3f0549892d825eba93607e1f16c4d", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1,3 +1,8 @@\n+2012-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* demangle.h (enum demangle_component_type): Add\n+\tDEMANGLE_COMPONENT_TAGGED_NAME.\n+\n 2012-10-29  Sterling Augustine <saugustine@google.com>\n             Cary Coutant <ccoutant@google.com>\n "}, {"sha": "ed019500393859b525e7de0cdcd3246a3f2dd733", "filename": "include/demangle.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -420,6 +420,8 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,\n   /* A pack expansion.  */\n   DEMANGLE_COMPONENT_PACK_EXPANSION,\n+  /* A name with an ABI tag.  */\n+  DEMANGLE_COMPONENT_TAGGED_NAME,\n   /* A cloned function.  */\n   DEMANGLE_COMPONENT_CLONE\n };"}, {"sha": "af12cd8647012c52a03d36e72ac29ffa22016e29", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -1,3 +1,10 @@\n+2012-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_dump): Handle DEMANGLE_COMPONENT_TAGGED_NAME.\n+\t(d_make_comp, d_find_pack, d_print_comp): Likewise.\n+\t(d_abi_tags): New.\n+\t(d_name): Call it.\n+\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n \t* cp-demangle.c (d_special_name, d_dump): Handle TH and TW."}, {"sha": "86c7747120009e9c55bc3865a4f3f6fd9ca05f95", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dbb85a7932149aa5bac38fd77424b15c0248990/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dbb85a7932149aa5bac38fd77424b15c0248990/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=7dbb85a7932149aa5bac38fd77424b15c0248990", "patch": "@@ -508,6 +508,11 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_NAME:\n       printf (\"name '%.*s'\\n\", dc->u.s_name.len, dc->u.s_name.s);\n       return;\n+    case DEMANGLE_COMPONENT_TAGGED_NAME:\n+      printf (\"tagged name\\n\");\n+      d_dump (dc->u.s_binary.left, indent + 2);\n+      d_dump (dc->u.s_binary.right, indent + 2);\n+      return;\n     case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n       printf (\"template parameter %ld\\n\", dc->u.s_number.number);\n       return;\n@@ -809,6 +814,7 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_QUAL_NAME:\n     case DEMANGLE_COMPONENT_LOCAL_NAME:\n     case DEMANGLE_COMPONENT_TYPED_NAME:\n+    case DEMANGLE_COMPONENT_TAGGED_NAME:\n     case DEMANGLE_COMPONENT_TEMPLATE:\n     case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n@@ -1202,6 +1208,23 @@ d_encoding (struct d_info *di, int top_level)\n     }\n }\n \n+/* <tagged-name> ::= <name> B <source-name> */\n+\n+static struct demangle_component *\n+d_abi_tags (struct d_info *di, struct demangle_component *dc)\n+{\n+  char peek;\n+  while (peek = d_peek_char (di),\n+\t peek == 'B')\n+    {\n+      struct demangle_component *tag;\n+      d_advance (di, 1);\n+      tag = d_source_name (di);\n+      dc = d_make_comp (di, DEMANGLE_COMPONENT_TAGGED_NAME, dc, tag);\n+    }\n+  return dc;\n+}\n+\n /* <name> ::= <nested-name>\n           ::= <unscoped-name>\n           ::= <unscoped-template-name> <template-args>\n@@ -1223,14 +1246,17 @@ d_name (struct d_info *di)\n   switch (peek)\n     {\n     case 'N':\n-      return d_nested_name (di);\n+      dc = d_nested_name (di);\n+      break;\n \n     case 'Z':\n-      return d_local_name (di);\n+      dc = d_local_name (di);\n+      break;\n \n     case 'L':\n     case 'U':\n-      return d_unqualified_name (di);\n+      dc = d_unqualified_name (di);\n+      break;\n \n     case 'S':\n       {\n@@ -1272,7 +1298,7 @@ d_name (struct d_info *di)\n \t\t\t      d_template_args (di));\n \t  }\n \n-\treturn dc;\n+\tbreak;\n       }\n \n     default:\n@@ -1287,8 +1313,12 @@ d_name (struct d_info *di)\n \t  dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,\n \t\t\t    d_template_args (di));\n \t}\n-      return dc;\n+      break;\n     }\n+\n+  if (d_peek_char (di) == 'B')\n+    dc = d_abi_tags (di, dc);\n+  return dc;\n }\n \n /* <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E\n@@ -3745,6 +3775,7 @@ d_find_pack (struct d_print_info *dpi,\n       \n     case DEMANGLE_COMPONENT_LAMBDA:\n     case DEMANGLE_COMPONENT_NAME:\n+    case DEMANGLE_COMPONENT_TAGGED_NAME:\n     case DEMANGLE_COMPONENT_OPERATOR:\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n     case DEMANGLE_COMPONENT_SUB_STD:\n@@ -3830,6 +3861,13 @@ d_print_comp (struct d_print_info *dpi, int options,\n \td_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);\n       return;\n \n+    case DEMANGLE_COMPONENT_TAGGED_NAME:\n+      d_print_comp (dpi, options, d_left (dc));\n+      d_append_string (dpi, \"[abi:\");\n+      d_print_comp (dpi, options, d_right (dc));\n+      d_append_char (dpi, ']');\n+      return;\n+\n     case DEMANGLE_COMPONENT_QUAL_NAME:\n     case DEMANGLE_COMPONENT_LOCAL_NAME:\n       d_print_comp (dpi, options, d_left (dc));"}]}