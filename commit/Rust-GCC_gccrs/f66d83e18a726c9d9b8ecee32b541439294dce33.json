{"sha": "f66d83e18a726c9d9b8ecee32b541439294dce33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY2ZDgzZTE4YTcyNmM5ZDliOGVjZWUzMmI1NDE0MzkyOTRkY2UzMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-11-06T19:41:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-11-06T19:41:37Z"}, "message": "haifa-sched.c (struct haifa_insn_data, h_i_d): New.\n\n        * haifa-sched.c (struct haifa_insn_data, h_i_d): New.\n        (insn_luid, insn_priority, insn_costs, insn_units): Remove.\n        (insn_reg_weight, insn_depend, insn_dep_count): Remove.\n        (insn_blockage, insn_ref_count, line_note, insn_tick): Remove.\n        (cant_move, fed_by_spec_load, is_load_insn): Remove.\n        (schedule_region): Remove unused variable.\n        (schedule_insns): Allocate h_i_d, and not all the separate arrays.\n\nFrom-SVN: r30435", "tree": {"sha": "8b032d552b1150d3656b0ffcec50bcdc707742c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b032d552b1150d3656b0ffcec50bcdc707742c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f66d83e18a726c9d9b8ecee32b541439294dce33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f66d83e18a726c9d9b8ecee32b541439294dce33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f66d83e18a726c9d9b8ecee32b541439294dce33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f66d83e18a726c9d9b8ecee32b541439294dce33/comments", "author": null, "committer": null, "parents": [{"sha": "ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff154f783ff05e834dbfa07ad848dd6d6f6f1717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff154f783ff05e834dbfa07ad848dd6d6f6f1717"}], "stats": {"total": 209, "additions": 92, "deletions": 117}, "files": [{"sha": "57a8b85b46a399c020528dfe5f9ada7422141ff5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f66d83e18a726c9d9b8ecee32b541439294dce33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f66d83e18a726c9d9b8ecee32b541439294dce33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f66d83e18a726c9d9b8ecee32b541439294dce33", "patch": "@@ -1,3 +1,13 @@\n+Sat Nov  6 11:38:39 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (struct haifa_insn_data, h_i_d): New.\n+\t(insn_luid, insn_priority, insn_costs, insn_units): Remove.\n+\t(insn_reg_weight, insn_depend, insn_dep_count): Remove.\n+\t(insn_blockage, insn_ref_count, line_note, insn_tick): Remove.\n+\t(cant_move, fed_by_spec_load, is_load_insn): Remove.\n+\t(schedule_region): Remove unused variable.\n+\t(schedule_insns): Allocate h_i_d, and not all the separate arrays.\n+\n Sat Nov  6 10:00:34 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* local-alloc.c (local_alloc): Use xmalloc/xcalloc, not alloca."}, {"sha": "305a145543c6bfec994a172df32c920d5f2bc3a9", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 82, "deletions": 117, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f66d83e18a726c9d9b8ecee32b541439294dce33/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f66d83e18a726c9d9b8ecee32b541439294dce33/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f66d83e18a726c9d9b8ecee32b541439294dce33", "patch": "@@ -243,10 +243,6 @@ static regset reg_pending_sets;\n static regset reg_pending_clobbers;\n static int reg_pending_sets_all;\n \n-/* Vector indexed by INSN_UID giving the original ordering of the insns.  */\n-static int *insn_luid;\n-#define INSN_LUID(INSN) (insn_luid[INSN_UID (INSN)])\n-\n /* To speed up the test for duplicate dependency links we keep a record\n    of true dependencies created by add_dependence when the average number\n    of instructions in a basic block is very large.\n@@ -261,47 +257,77 @@ static int *insn_luid;\n    insn chain.  */\n static sbitmap *true_dependency_cache;\n \n-/* Vector indexed by INSN_UID giving each instruction a priority.  */\n-static int *insn_priority;\n-#define INSN_PRIORITY(INSN) (insn_priority[INSN_UID (INSN)])\n-\n-static short *insn_costs;\n-#define INSN_COST(INSN)\tinsn_costs[INSN_UID (INSN)]\n-\n-/* Vector indexed by INSN_UID giving an encoding of the function units\n-   used.  */\n-static short *insn_units;\n-#define INSN_UNIT(INSN)\tinsn_units[INSN_UID (INSN)]\n-\n-/* Vector indexed by INSN_UID giving each instruction a\n-   register-weight.  This weight is an estimation of the insn\n-   contribution to registers pressure.  */\n-static int *insn_reg_weight;\n-#define INSN_REG_WEIGHT(INSN) (insn_reg_weight[INSN_UID (INSN)])\n-\n-/* Vector indexed by INSN_UID giving list of insns which\n-   depend upon INSN.  Unlike LOG_LINKS, it represents forward dependences.  */\n-static rtx *insn_depend;\n-#define INSN_DEPEND(INSN) insn_depend[INSN_UID (INSN)]\n-\n-/* Vector indexed by INSN_UID. Initialized to the number of incoming\n-   edges in forward dependence graph (= number of LOG_LINKS).  As\n-   scheduling procedes, dependence counts are decreased.  An\n-   instruction moves to the ready list when its counter is zero.  */\n-static int *insn_dep_count;\n-#define INSN_DEP_COUNT(INSN) (insn_dep_count[INSN_UID (INSN)])\n-\n-/* Vector indexed by INSN_UID giving an encoding of the blockage range\n-   function.  The unit and the range are encoded.  */\n-static unsigned int *insn_blockage;\n-#define INSN_BLOCKAGE(INSN) insn_blockage[INSN_UID (INSN)]\n-#define UNIT_BITS 5\n-#define BLOCKAGE_MASK ((1 << BLOCKAGE_BITS) - 1)\n-#define ENCODE_BLOCKAGE(U, R)\t\t\t\t\\\n-(((U) << BLOCKAGE_BITS\t\t\t\t\t\\\n-  | MIN_BLOCKAGE_COST (R)) << BLOCKAGE_BITS\t\t\\\n- | MAX_BLOCKAGE_COST (R))\n-#define UNIT_BLOCKED(B) ((B) >> (2 * BLOCKAGE_BITS))\n+/* Indexed by INSN_UID, the collection of all data associated with\n+   a single instruction.  */\n+\n+struct haifa_insn_data\n+{\n+  /* A list of insns which depend on the instruction.  Unlike LOG_LINKS,\n+     it represents forward dependancies.  */\n+  rtx depend;\n+\n+  /* The line number note in effect for each insn.  For line number \n+     notes, this indicates whether the note may be reused.  */\n+  rtx line_note;\n+\n+  /* Logical uid gives the original ordering of the insns.  */\n+  int luid;\n+\n+  /* A priority for each insn.  */\n+  int priority;\n+\n+  /* The number of incoming edges in the forward dependency graph.\n+     As scheduling proceds, counts are decreased.  An insn moves to\n+     the ready queue when its counter reaches zero.  */\n+  int dep_count;\n+\n+  /* An encoding of the blockage range function.  Both unit and range\n+     are coded.  */\n+  unsigned int blockage;\n+\n+  /* Number of instructions referring to this insn.  */\n+  int ref_count;\n+\n+  /* The minimum clock tick at which the insn becomes ready.  This is\n+     used to note timing constraints for the insns in the pending list.  */\n+  int tick;\n+\n+  short cost;\n+\n+  /* An encoding of the function units used.  */\n+  short units;\n+\n+  /* This weight is an estimation of the insn's contribution to\n+     register pressure.  */\n+  short reg_weight;\n+\n+  /* Some insns (e.g. call) are not allowed to move across blocks.  */\n+  unsigned int cant_move : 1;\n+\n+  /* Set if there's DEF-USE dependance between some speculatively\n+     moved load insn and this one.  */\n+  unsigned int fed_by_spec_load : 1;\n+  unsigned int is_load_insn : 1;\n+};\n+\n+static struct haifa_insn_data *h_i_d;\n+\n+#define INSN_DEPEND(INSN)\t(h_i_d[INSN_UID (INSN)].depend)\n+#define INSN_LUID(INSN)\t\t(h_i_d[INSN_UID (INSN)].luid)\n+#define INSN_PRIORITY(INSN)\t(h_i_d[INSN_UID (INSN)].priority)\n+#define INSN_DEP_COUNT(INSN)\t(h_i_d[INSN_UID (INSN)].dep_count)\n+#define INSN_COST(INSN)\t\t(h_i_d[INSN_UID (INSN)].cost)\n+#define INSN_UNIT(INSN)\t\t(h_i_d[INSN_UID (INSN)].units)\n+#define INSN_REG_WEIGHT(INSN)\t(h_i_d[INSN_UID (INSN)].reg_weight)\n+\n+#define INSN_BLOCKAGE(INSN)\t(h_i_d[INSN_UID (INSN)].blockage)\n+#define UNIT_BITS\t\t5\n+#define BLOCKAGE_MASK\t\t((1 << BLOCKAGE_BITS) - 1)\n+#define ENCODE_BLOCKAGE(U, R)\t\t\t\\\n+  (((U) << BLOCKAGE_BITS\t\t\t\\\n+    | MIN_BLOCKAGE_COST (R)) << BLOCKAGE_BITS\t\\\n+   | MAX_BLOCKAGE_COST (R))\n+#define UNIT_BLOCKED(B)\t\t((B) >> (2 * BLOCKAGE_BITS))\n #define BLOCKAGE_RANGE(B)                                                \\\n   (((((B) >> BLOCKAGE_BITS) & BLOCKAGE_MASK) << (HOST_BITS_PER_INT / 2)) \\\n    | ((B) & BLOCKAGE_MASK))\n@@ -317,16 +343,12 @@ static unsigned int *insn_blockage;\n #define DONE_PRIORITY_P(INSN) (INSN_PRIORITY (INSN) < 0)\n #define LOW_PRIORITY_P(INSN) ((INSN_PRIORITY (INSN) & 0x7f000000) == 0)\n \n-/* Vector indexed by INSN_UID giving number of insns referring to this\n-   insn.  */\n-static int *insn_ref_count;\n-#define INSN_REF_COUNT(INSN) (insn_ref_count[INSN_UID (INSN)])\n-\n-/* Vector indexed by INSN_UID giving line-number note in effect for each\n-   insn.  For line-number notes, this indicates whether the note may be\n-   reused.  */\n-static rtx *line_note;\n-#define LINE_NOTE(INSN) (line_note[INSN_UID (INSN)])\n+#define INSN_REF_COUNT(INSN)\t(h_i_d[INSN_UID (INSN)].ref_count)\n+#define LINE_NOTE(INSN)\t\t(h_i_d[INSN_UID (INSN)].line_note)\n+#define INSN_TICK(INSN)\t\t(h_i_d[INSN_UID (INSN)].tick)\n+#define CANT_MOVE(insn)\t\t(h_i_d[INSN_UID (insn)].cant_move)\n+#define FED_BY_SPEC_LOAD(insn)\t(h_i_d[INSN_UID (insn)].fed_by_spec_load)\n+#define IS_LOAD_INSN(insn)\t(h_i_d[INSN_UID (insn)].is_load_insn)\n \n /* Vector indexed by basic block number giving the starting line-number\n    for each basic block.  */\n@@ -389,12 +411,6 @@ static int q_size = 0;\n #define NEXT_Q(X) (((X)+1) & (INSN_QUEUE_SIZE-1))\n #define NEXT_Q_AFTER(X, C) (((X)+C) & (INSN_QUEUE_SIZE-1))\n \n-/* Vector indexed by INSN_UID giving the minimum clock tick at which\n-   the insn becomes ready.  This is used to note timing constraints for\n-   insns in the pending list.  */\n-static int *insn_tick;\n-#define INSN_TICK(INSN) (insn_tick[INSN_UID (INSN)])\n-\n /* Forward declarations.  */\n static void add_dependence PROTO ((rtx, rtx, enum reg_note));\n #ifdef HAVE_cc0\n@@ -427,10 +443,6 @@ static char *safe_concat PROTO ((char *, char *, const char *));\n static int insn_issue_delay PROTO ((rtx));\n static void adjust_priority PROTO ((rtx));\n \n-/* Some insns (e.g. call) are not allowed to move across blocks.  */\n-static char *cant_move;\n-#define CANT_MOVE(insn) (cant_move[INSN_UID (insn)])\n-\n /* Control flow graph edges are kept in circular lists.  */\n typedef struct\n   {\n@@ -2301,20 +2313,13 @@ enum INSN_TRAP_CLASS\n #define WORST_CLASS(class1, class2) \\\n ((class1 > class2) ? class1 : class2)\n \n-/* Indexed by INSN_UID, and set if there's DEF-USE dependence between \n-   some speculatively moved load insn and this one.  */\n-char *fed_by_spec_load;\n-char *is_load_insn;\n-\n /* Non-zero if block bb_to is equal to, or reachable from block bb_from.  */\n #define IS_REACHABLE(bb_from, bb_to)\t\t\t\t\t\\\n (bb_from == bb_to                                                       \\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n    || (bitset_member (ancestor_edges[bb_to],\t\t\t\t\\\n \t\t      EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))),\t\\\n \t\t      edgeset_size)))\n-#define FED_BY_SPEC_LOAD(insn) (fed_by_spec_load[INSN_UID (insn)])\n-#define IS_LOAD_INSN(insn) (is_load_insn[INSN_UID (insn)])\n \n /* Non-zero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n@@ -6694,7 +6699,6 @@ schedule_region (rgn)\n   /* Initializations for region data dependence analyisis.  */\n   if (current_nr_blocks > 1)\n     {\n-      rtx *space;\n       int maxreg = max_reg_num ();\n \n       bb_reg_last_uses = (rtx **) xmalloc (current_nr_blocks * sizeof (rtx *));\n@@ -6899,13 +6903,9 @@ schedule_insns (dump_file)\n      pseudos which do not cross calls.  */\n   max_uid = get_max_uid () + 1;\n \n-  cant_move = xcalloc (max_uid, sizeof (char));\n-  fed_by_spec_load = xcalloc (max_uid, sizeof (char));\n-  is_load_insn = xcalloc (max_uid, sizeof (char));\n+  h_i_d = (struct haifa_insn_data *) xcalloc (max_uid, sizeof (*h_i_d));\n \n-  insn_luid = (int *) xmalloc (max_uid * sizeof (int));\n-\n-  insn_luid[0] = 0;\n+  h_i_d[0].luid = 0;\n   luid = 1;\n   for (b = 0; b < n_basic_blocks; b++)\n     for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n@@ -7018,24 +7018,6 @@ schedule_insns (dump_file)\n \t}\n     }\n \n-  /* Allocate data for this pass.  See comments, above,\n-     for what these vectors do.\n-\n-     We use xmalloc instead of alloca, because max_uid can be very large\n-     when there is a lot of function inlining.  If we used alloca, we could\n-     exceed stack limits on some hosts for some inputs.  */\n-  insn_priority = (int *) xcalloc (max_uid, sizeof (int));\n-  insn_reg_weight = (int *) xcalloc (max_uid, sizeof (int));\n-  insn_tick = (int *) xcalloc (max_uid, sizeof (int));\n-  insn_costs = (short *) xcalloc (max_uid, sizeof (short));\n-  insn_units = (short *) xcalloc (max_uid, sizeof (short));\n-  insn_blockage = (unsigned int *) xcalloc (max_uid, sizeof (unsigned int));\n-  insn_ref_count = (int *) xcalloc (max_uid, sizeof (int));\n-\n-  /* Allocate for forward dependencies.  */\n-  insn_dep_count = (int *) xcalloc (max_uid, sizeof (int));\n-  insn_depend = (rtx *) xcalloc (max_uid, sizeof (rtx));\n-\n   deaths_in_region = (int *) xmalloc (sizeof(int) * nr_regions);\n \n   init_alias_analysis ();\n@@ -7044,7 +7026,6 @@ schedule_insns (dump_file)\n     {\n       rtx line;\n \n-      line_note = (rtx *) xcalloc (max_uid, sizeof (rtx));\n       line_note_head = (rtx *) xcalloc (n_basic_blocks, sizeof (rtx));\n \n       /* Save-line-note-head:\n@@ -7177,27 +7158,11 @@ schedule_insns (dump_file)\n   free (rgn_bb_table);\n   free (block_to_bb);\n   free (containing_rgn);\n-  free (cant_move);\n-  free (fed_by_spec_load);\n-  free (is_load_insn);\n-  free (insn_luid);\n-\n-  free (insn_priority);\n-  free (insn_reg_weight);\n-  free (insn_tick);\n-  free (insn_costs);\n-  free (insn_units);\n-  free (insn_blockage);\n-  free (insn_ref_count);\n-\n-  free (insn_dep_count);\n-  free (insn_depend);\n+\n+  free (h_i_d);\n \n   if (write_symbols != NO_DEBUG)\n-    {\n-      free (line_note);\n-      free (line_note_head);\n-    }\n+    free (line_note_head);\n \n   if (edge_table)\n     {"}]}