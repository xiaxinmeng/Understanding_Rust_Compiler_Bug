{"sha": "260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYwYzhiYTM4OWM0YTMxYTdhNGQ3Y2ZlMGZjNTU0OTJiMmYxYjc0Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-07-02T21:25:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-07-02T21:25:28Z"}, "message": "expr.h (emit_stack_probe): Declare.\n\n\t* expr.h (emit_stack_probe): Declare.\n\t* explow.c (emit_stack_probe): Make global.\n\t(anti_adjust_stack_and_probe): Fix comments.\n\t* config/sparc/linux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n\t* config/sparc/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/sparc/sol2.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/sparc/sparc.c: Include except.h.\n\t(sparc_emit_probe_stack_range): New function.\n\t(output_probe_stack_range): Likewise.\n\t(sparc_expand_prologue): Invoke sparc_emit_probe_stack_range if static\n\tbuilt-in stack checking is enabled.\n\t* config/sparc/sparc-protos.h (output_probe_stack_range): Declare.\n\t* config/sparc/sparc.md (UNSPECV_PROBE_STACK_RANGE): New constant.\n\t(probe_stack_range): New insn.\n\nFrom-SVN: r161749", "tree": {"sha": "07029562f5d29447aaea45407baa8ff6842f7694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07029562f5d29447aaea45407baa8ff6842f7694"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/comments", "author": null, "committer": null, "parents": [{"sha": "8c54dc55ef8e29da0f1cd3836dbbe705239c415e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c54dc55ef8e29da0f1cd3836dbbe705239c415e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c54dc55ef8e29da0f1cd3836dbbe705239c415e"}], "stats": {"total": 225, "additions": 211, "deletions": 14}, "files": [{"sha": "60db5de3dbcc5c3b65e699edfd118f69f93d539b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -1,3 +1,20 @@\n+2010-07-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.h (emit_stack_probe): Declare.\n+\t* explow.c (emit_stack_probe): Make global.\n+\t(anti_adjust_stack_and_probe): Fix comments.\n+\t* config/sparc/linux.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n+\t* config/sparc/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/sparc/sol2.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/sparc/sparc.c: Include except.h.\n+\t(sparc_emit_probe_stack_range): New function.\n+\t(output_probe_stack_range): Likewise.\n+\t(sparc_expand_prologue): Invoke sparc_emit_probe_stack_range if static\n+\tbuilt-in stack checking is enabled.\n+\t* config/sparc/sparc-protos.h (output_probe_stack_range): Declare.\n+\t* config/sparc/sparc.md (UNSPECV_PROBE_STACK_RANGE): New constant.\n+\t(probe_stack_range): New insn.\n+\n 2010-07-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR target/43958\n@@ -6,14 +23,14 @@\n \n 2010-07-02  Jan Hubicka  <jh@suse.cz>\n \n-\t* ipa-split.c (verify_non_ssa_vars): Break out from ...; perform DFS walk\n-\tbackwards from entry_bb to check only those basic block of header\n+\t* ipa-split.c (verify_non_ssa_vars): Break out from ...; perform DFS\n+\twalk backwards from entry_bb to check only those basic block of header\n \tthat might lead to execution of split part.\n \t(consider_split) ... here.\n \t(find_return_bb): Allow assignment in return BB.\n \t(find_retval): New.\n-\t(split_function): Fix name of cloned function; take care of updating return\n-\tvalue in return_bb containing move.\n+\t(split_function): Fix name of cloned function; take care of updating\n+\treturn value in return_bb containing move.\n \n 2010-07-02  Andreas Schwab  <schwab@linux-m68k.org>\n "}, {"sha": "530a6ae7065dae4bb0957ddcf07ffaff596e3133", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -161,6 +161,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef CTORS_SECTION_ASM_OP\n #undef DTORS_SECTION_ASM_OP\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n #define MD_UNWIND_SUPPORT \"config/sparc/linux-unwind.h\"\n \n /* Linux currently uses RMO in uniprocessor mode, which is equivalent to"}, {"sha": "369c13c8e3cb7c58f7897f7aa595319371b323da", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -287,6 +287,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef CTORS_SECTION_ASM_OP\n #undef DTORS_SECTION_ASM_OP\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n #define MD_UNWIND_SUPPORT \"config/sparc/linux-unwind.h\"\n \n /* Linux currently uses RMO in uniprocessor mode, which is equivalent to"}, {"sha": "26c9ac7d396ae39bed220177a6f41692f07b19be", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -188,4 +188,7 @@ along with GCC; see the file COPYING3.  If not see\n #define PUSHSECTION_FORMAT\t\"\\t.pushsection\\t\\\"%s\\\"\\n\"\n #endif\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n #define MD_UNWIND_SUPPORT \"config/sparc/sol2-unwind.h\""}, {"sha": "35c99b967ba31cea25dad4068ce499b98401b115", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -75,6 +75,7 @@ extern const char *output_return (rtx);\n extern const char *output_sibcall (rtx, rtx);\n extern const char *output_v8plus_shift (rtx *, rtx, const char *);\n extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);\n+extern const char *output_probe_stack_range (rtx, rtx);\n extern bool emit_scc_insn (rtx []);\n extern void emit_conditional_branch_insn (rtx []);\n extern void print_operand (FILE *, rtx, int);"}, {"sha": "f00b1ccfe5dedab7f090b6308e13e5b19bdcb835", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"function.h\"\n+#include \"except.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"recog.h\"\n@@ -4005,6 +4006,160 @@ sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n #endif\n }\n \n+#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n+\n+#if PROBE_INTERVAL > 4096\n+#error Cannot use indexed addressing mode for stack probing\n+#endif\n+\n+/* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n+   inclusive.  These are offsets from the current stack pointer.\n+\n+   Note that we don't use the REG+REG addressing mode for the probes because\n+   of the stack bias in 64-bit mode.  And it doesn't really buy us anything\n+   so the advantages of having a single code win here.  */\n+\n+static void\n+sparc_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n+{\n+  rtx g1 = gen_rtx_REG (Pmode, 1);\n+\n+  /* See if we have a constant small number of probes to generate.  If so,\n+     that's the easy case.  */\n+  if (size <= PROBE_INTERVAL)\n+    {\n+      emit_move_insn (g1, GEN_INT (first));\n+      emit_insn (gen_rtx_SET (VOIDmode, g1,\n+\t\t\t      gen_rtx_MINUS (Pmode, stack_pointer_rtx, g1)));\n+      emit_stack_probe (plus_constant (g1, -size));\n+    }\n+\n+  /* The run-time loop is made up of 10 insns in the generic case while the\n+     compile-time loop is made up of 4+2*(n-2) insns for n # of intervals.  */\n+  else if (size <= 5 * PROBE_INTERVAL)\n+    {\n+      HOST_WIDE_INT i;\n+\n+      emit_move_insn (g1, GEN_INT (first + PROBE_INTERVAL));\n+      emit_insn (gen_rtx_SET (VOIDmode, g1,\n+\t\t\t      gen_rtx_MINUS (Pmode, stack_pointer_rtx, g1)));\n+      emit_stack_probe (g1);\n+\n+      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until\n+\t it exceeds SIZE.  If only two probes are needed, this will not\n+\t generate any code.  Then probe at FIRST + SIZE.  */\n+      for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, g1,\n+\t\t\t\t  plus_constant (g1, -PROBE_INTERVAL)));\n+\t  emit_stack_probe (g1);\n+\t}\n+\n+      emit_stack_probe (plus_constant (g1, (i - PROBE_INTERVAL) - size));\n+    }\n+\n+  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n+     extra careful with variables wrapping around because we might be at\n+     the very top (or the very bottom) of the address space and we have\n+     to be able to handle this case properly; in particular, we use an\n+     equality test for the loop condition.  */\n+  else\n+    {\n+      HOST_WIDE_INT rounded_size;\n+      rtx g4 = gen_rtx_REG (Pmode, 4);\n+\n+      emit_move_insn (g1, GEN_INT (first));\n+\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      rounded_size = size & -PROBE_INTERVAL;\n+      emit_move_insn (g4, GEN_INT (rounded_size));\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* TEST_ADDR = SP + FIRST.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, g1,\n+\t\t\t      gen_rtx_MINUS (Pmode, stack_pointer_rtx, g1)));\n+\n+      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, g4, gen_rtx_MINUS (Pmode, g1, g4)));\n+\n+\n+      /* Step 3: the loop\n+\n+\t while (TEST_ADDR != LAST_ADDR)\n+\t   {\n+\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t     probe at TEST_ADDR\n+\t   }\n+\n+\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+\t until it is equal to ROUNDED_SIZE.  */\n+\n+      if (TARGET_64BIT)\n+\temit_insn (gen_probe_stack_rangedi (g1, g1, g4));\n+      else\n+\temit_insn (gen_probe_stack_rangesi (g1, g1, g4));\n+\n+\n+      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+\t that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      if (size != rounded_size)\n+\temit_stack_probe (plus_constant (g4, rounded_size - size));\n+    }\n+\n+  /* Make sure nothing is scheduled before we are done.  */\n+  emit_insn (gen_blockage ());\n+}\n+\n+/* Probe a range of stack addresses from REG1 to REG2 inclusive.  These are\n+   absolute addresses.  */\n+\n+const char *\n+output_probe_stack_range (rtx reg1, rtx reg2)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32], end_lab[32];\n+  rtx xops[2];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno);\n+  ASM_GENERATE_INTERNAL_LABEL (end_lab, \"LPSRE\", labelno++);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+   /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */\n+  xops[0] = reg1;\n+  xops[1] = reg2;\n+  output_asm_insn (\"cmp\\t%0, %1\", xops);\n+  if (TARGET_ARCH64)\n+    fputs (\"\\tbe,pn\\t%xcc,\", asm_out_file);\n+  else\n+    fputs (\"\\tbe\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, end_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+  xops[1] = GEN_INT (-PROBE_INTERVAL);\n+  output_asm_insn (\" add\\t%0, %1, %0\", xops);\n+\n+  /* Probe at TEST_ADDR and branch.  */\n+  if (TARGET_ARCH64)\n+    fputs (\"\\tba,pt\\t%xcc,\", asm_out_file);\n+  else\n+    fputs (\"\\tba\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+  xops[1] = GEN_INT (SPARC_STACK_BIAS);\n+  output_asm_insn (\" st\\t%%g0, [%0+%1]\", xops);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, end_lab);\n+\n+  return \"\";\n+}\n+\n /* Save/restore call-saved registers from LOW to HIGH at BASE+OFFSET\n    as needed.  LOW should be double-word aligned for 32-bit registers.\n    Return the new OFFSET.  */\n@@ -4193,6 +4348,9 @@ sparc_expand_prologue (void)\n   /* Advertise that the data calculated just above are now valid.  */\n   sparc_prologue_data_valid_p = true;\n \n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)\n+    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);\n+\n   if (sparc_leaf_function_p)\n     {\n       frame_base_reg = stack_pointer_rtx;"}, {"sha": "301a63c269320c2e37ef833954d443983f5173d3", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -75,6 +75,7 @@\n    (UNSPECV_CAS\t\t\t8)\n    (UNSPECV_SWAP\t\t9)\n    (UNSPECV_LDSTUB\t\t10)\n+   (UNSPECV_PROBE_STACK_RANGE\t11)\n   ])\n \n \n@@ -6340,6 +6341,15 @@\n     = adjust_address (operands[0], GET_MODE (operands[0]), SPARC_STACK_BIAS);\n })\n \n+(define_insn \"probe_stack_range<P:mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")\n+\t\t\t    (match_operand:P 2 \"register_operand\" \"r\")]\n+\t\t\t    UNSPECV_PROBE_STACK_RANGE))]\n+  \"\"\n+  \"* return output_probe_stack_range (operands[0], operands[2]);\"\n+  [(set_attr \"type\" \"multi\")])\n+\n ;; Prepare to return any type including a structure value.\n \n (define_expand \"untyped_return\""}, {"sha": "bd2ab798aa016315448f26b40691dfff6378bc8f", "filename": "gcc/explow.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n \n static rtx break_out_memory_refs (rtx);\n-static void emit_stack_probe (rtx);\n \n \n /* Truncate and perhaps sign-extend C as appropriate for MODE.  */\n@@ -1355,7 +1354,7 @@ set_stack_check_libfunc (const char *libfunc_name)\n \f\n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n \n-static void\n+void\n emit_stack_probe (rtx address)\n {\n   rtx memref = gen_rtx_MEM (word_mode, address);\n@@ -1567,7 +1566,7 @@ anti_adjust_stack_and_probe (rtx size, bool adjust_back)\n       HOST_WIDE_INT isize = INTVAL (size), i;\n       bool first_probe = true;\n \n-      /* Adjust SP and probe to PROBE_INTERVAL + N * PROBE_INTERVAL for\n+      /* Adjust SP and probe at PROBE_INTERVAL + N * PROBE_INTERVAL for\n \t values of N from 1 until it exceeds SIZE.  If only one probe is\n \t needed, this will not generate any code.  Then adjust and probe\n \t to PROBE_INTERVAL + SIZE.  */\n@@ -1623,13 +1622,13 @@ anti_adjust_stack_and_probe (rtx size, bool adjust_back)\n \n       /* Step 3: the loop\n \n-\t  while (SP != LAST_ADDR)\n-\t    {\n-\t      SP = SP + PROBE_INTERVAL\n-\t      probe at SP\n-\t    }\n+\t while (SP != LAST_ADDR)\n+\t   {\n+\t     SP = SP + PROBE_INTERVAL\n+\t     probe at SP\n+\t   }\n \n-\t adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for\n+\t adjusts SP and probes at PROBE_INTERVAL + N * PROBE_INTERVAL for\n \t values of N from 1 until it is equal to ROUNDED_SIZE.  */\n \n       emit_label (loop_lab);\n@@ -1647,7 +1646,7 @@ anti_adjust_stack_and_probe (rtx size, bool adjust_back)\n       emit_label (end_lab);\n \n \n-      /* Step 4: adjust SP and probe to PROBE_INTERVAL + SIZE if we cannot\n+      /* Step 4: adjust SP and probe at PROBE_INTERVAL + SIZE if we cannot\n \t assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */\n \n       /* TEMP = SIZE - ROUNDED_SIZE.  */"}, {"sha": "c71b8edcbb78612418daa4cb174e41fd1c256502", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=260c8ba389c4a31a7a4d7cfe0fc55492b2f1b74f", "patch": "@@ -645,6 +645,9 @@ extern void update_nonlocal_goto_save_area (void);\n    says how many bytes.  */\n extern rtx allocate_dynamic_stack_space (rtx, rtx, int);\n \n+/* Emit one stack probe at ADDRESS, an address within the stack.  */\n+extern void emit_stack_probe (rtx);\n+\n /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n    FIRST is a constant and size is a Pmode RTX.  These are offsets from\n    the current stack pointer.  STACK_GROWS_DOWNWARD says whether to add"}]}