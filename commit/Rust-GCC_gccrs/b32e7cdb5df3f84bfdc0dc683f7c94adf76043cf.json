{"sha": "b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMyZTdjZGI1ZGYzZjg0YmZkYzBkYzY4M2Y3Yzk0YWRmNzYwNDNjZg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-08-25T13:31:56Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-08-25T13:31:56Z"}, "message": "expr.c (expand_expr_real_1): New local treeop0...\n\n        * expr.c (expand_expr_real_1): New local treeop0, treeop1,\n        treeop2 initialized with first three operands of the full expression.\n        Substitute all TREE_OPERAND (exp, [012]) calls with them.\n\nFrom-SVN: r151078", "tree": {"sha": "74ad26bd1985921c04dffc387aac55fd2a7ae05a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74ad26bd1985921c04dffc387aac55fd2a7ae05a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce4a9de3a4eb3cfff2de03f9c552170e0cfd9ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4a9de3a4eb3cfff2de03f9c552170e0cfd9ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce4a9de3a4eb3cfff2de03f9c552170e0cfd9ded"}], "stats": {"total": 297, "additions": 157, "deletions": 140}, "files": [{"sha": "bb5e0b11eaf79c9cc6a4ada6df1b649b8db3caef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "patch": "@@ -1,3 +1,9 @@\n+2009-08-25  Michael Matz  <matz@suse.de>\n+\n+\t* expr.c (expand_expr_real_1): New local treeop0, treeop1,\n+\ttreeop2 initialized with first three operands of the full expression.\n+\tSubstitute all TREE_OPERAND (exp, [012]) calls with them.\n+\n 2009-08-25  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* gcc/gthr-win32.h (__UNUSED_PARAM): Define, if not already present."}, {"sha": "7e316b547ad848115f3d797619e4369b34f27250", "filename": "gcc/expr.c", "status": "modified", "additions": 151, "deletions": 140, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b32e7cdb5df3f84bfdc0dc683f7c94adf76043cf", "patch": "@@ -7220,6 +7220,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   gimple subexp0_def, subexp1_def;\n   tree top0, top1;\n   location_t loc = EXPR_LOCATION (exp);\n+  tree treeop0, treeop1, treeop2;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n \t\t\t\t\t\t\t\t  target, \\\n@@ -7230,6 +7231,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   mode = TYPE_MODE (type);\n   unsignedp = TYPE_UNSIGNED (type);\n \n+  treeop0 = treeop1 = treeop2 = NULL_TREE;\n+  if (!VL_EXP_CLASS_P (exp))\n+    switch (TREE_CODE_LENGTH (code))\n+      {\n+\tdefault:\n+\tcase 3: treeop2 = TREE_OPERAND (exp, 2);\n+\tcase 2: treeop1 = TREE_OPERAND (exp, 1);\n+\tcase 1: treeop0 = TREE_OPERAND (exp, 0);\n+\tcase 0: break;\n+      }\n+\n   ignore = (target == const0_rtx\n \t    || ((CONVERT_EXPR_CODE_P (code)\n \t\t || code == COND_EXPR || code == VIEW_CONVERT_EXPR)\n@@ -7268,22 +7280,22 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       if (TREE_CODE_CLASS (code) == tcc_unary\n \t  || code == COMPONENT_REF || code == INDIRECT_REF)\n-\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\treturn expand_expr (treeop0, const0_rtx, VOIDmode,\n \t\t\t    modifier);\n \n       else if (TREE_CODE_CLASS (code) == tcc_binary\n \t       || TREE_CODE_CLASS (code) == tcc_comparison\n \t       || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (treeop0, const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (treeop1, const0_rtx, VOIDmode, modifier);\n \t  return const0_rtx;\n \t}\n       else if (code == BIT_FIELD_REF)\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (treeop0, const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (treeop1, const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (treeop2, const0_rtx, VOIDmode, modifier);\n \t  return const0_rtx;\n \t}\n \n@@ -7524,7 +7536,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case SAVE_EXPR:\n       {\n-\ttree val = TREE_OPERAND (exp, 0);\n+\ttree val = treeop0;\n \trtx ret = expand_expr_real_1 (val, target, tmode, modifier, alt_rtl);\n \n \tif (!SAVE_EXPR_RESOLVED_P (exp))\n@@ -7539,7 +7551,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t      VAR_DECL, NULL, TREE_TYPE (exp));\n \t    DECL_ARTIFICIAL (val) = 1;\n \t    DECL_IGNORED_P (val) = 1;\n-\t    TREE_OPERAND (exp, 0) = val;\n+\t    treeop0 = val;\n+\t    TREE_OPERAND (exp, 0) = treeop0;\n \t    SAVE_EXPR_RESOLVED_P (exp) = 1;\n \n \t    if (!CONSTANT_P (ret))\n@@ -7551,10 +7564,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       }\n \n     case GOTO_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == LABEL_DECL)\n-\texpand_goto (TREE_OPERAND (exp, 0));\n+      if (TREE_CODE (treeop0) == LABEL_DECL)\n+\texpand_goto (treeop0);\n       else\n-\texpand_computed_goto (TREE_OPERAND (exp, 0));\n+\texpand_computed_goto (treeop0);\n       return const0_rtx;\n \n     case CONSTRUCTOR:\n@@ -7577,7 +7590,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       {\n-\ttree exp1 = TREE_OPERAND (exp, 0);\n+\ttree exp1 = treeop0;\n \n \tif (modifier != EXPAND_WRITE)\n \t  {\n@@ -7645,8 +7658,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case ARRAY_REF:\n \n       {\n-\ttree array = TREE_OPERAND (exp, 0);\n-\ttree index = TREE_OPERAND (exp, 1);\n+\ttree array = treeop0;\n+\ttree index = treeop1;\n \n \t/* Fold an expression like: \"foo\"[2].\n \t   This is not done in fold so it won't happen inside &.\n@@ -7736,7 +7749,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    tree index1 = index;\n \t\t    tree low_bound = array_ref_low_bound (exp);\n \t\t    index1 = fold_convert_loc (loc, sizetype,\n-\t\t\t\t\t       TREE_OPERAND (exp, 1));\n+\t\t\t\t\t       treeop1);\n \n \t\t    /* Optimize the special-case of a zero lower bound.\n \n@@ -7772,14 +7785,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case COMPONENT_REF:\n       /* If the operand is a CONSTRUCTOR, we can just extract the\n \t appropriate field if it is present.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR)\n+      if (TREE_CODE (treeop0) == CONSTRUCTOR)\n \t{\n \t  unsigned HOST_WIDE_INT idx;\n \t  tree field, value;\n \n-\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (treeop0),\n \t\t\t\t    idx, field, value)\n-\t    if (field == TREE_OPERAND (exp, 1)\n+\t    if (field == treeop1\n \t\t/* We can normally use the value of the field in the\n \t\t   CONSTRUCTOR.  However, if this is a bitfield in\n \t\t   an integral mode that we can fit in a HOST_WIDE_INT,\n@@ -8159,18 +8172,18 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case PAREN_EXPR:\n     CASE_CONVERT:\n-      if (TREE_OPERAND (exp, 0) == error_mark_node)\n+      if (treeop0 == error_mark_node)\n \treturn const0_rtx;\n \n       if (TREE_CODE (type) == UNION_TYPE)\n \t{\n-\t  tree valtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t  tree valtype = TREE_TYPE (treeop0);\n \n \t  /* If both input and output are BLKmode, this conversion isn't doing\n \t     anything except possibly changing memory attribute.  */\n \t  if (mode == BLKmode && TYPE_MODE (valtype) == BLKmode)\n \t    {\n-\t      rtx result = expand_expr (TREE_OPERAND (exp, 0), target, tmode,\n+\t      rtx result = expand_expr (treeop0, target, tmode,\n \t\t\t\t\tmodifier);\n \n \t      result = copy_rtx (result);\n@@ -8188,7 +8201,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  if (MEM_P (target))\n \t    /* Store data into beginning of memory target.  */\n-\t    store_expr (TREE_OPERAND (exp, 0),\n+\t    store_expr (treeop0,\n \t\t\tadjust_address (target, TYPE_MODE (valtype), 0),\n \t\t\tmodifier == EXPAND_STACK_PARM,\n \t\t\tfalse);\n@@ -8200,41 +8213,41 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      /* Store this field into a union of the proper type.  */\n \t      store_field (target,\n \t\t\t   MIN ((int_size_in_bytes (TREE_TYPE\n-\t\t\t\t\t\t    (TREE_OPERAND (exp, 0)))\n+\t\t\t\t\t\t    (treeop0))\n \t\t\t\t * BITS_PER_UNIT),\n \t\t\t\t(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n-\t\t\t   0, TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n+\t\t\t   0, TYPE_MODE (valtype), treeop0,\n \t\t\t   type, 0, false);\n \t    }\n \n \t  /* Return the entire union.  */\n \t  return target;\n \t}\n \n-      if (mode == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+      if (mode == TYPE_MODE (TREE_TYPE (treeop0)))\n \t{\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode,\n+\t  op0 = expand_expr (treeop0, target, VOIDmode,\n \t\t\t     modifier);\n \n \t  /* If the signedness of the conversion differs and OP0 is\n \t     a promoted SUBREG, clear that indication since we now\n \t     have to do the proper extension.  */\n-\t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))) != unsignedp\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (treeop0)) != unsignedp\n \t      && GET_CODE (op0) == SUBREG)\n \t    SUBREG_PROMOTED_VAR_P (op0) = 0;\n \n \t  return REDUCE_BIT_FIELD (op0);\n \t}\n \n-      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode,\n+      op0 = expand_expr (treeop0, NULL_RTX, mode,\n \t\t\t modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier);\n       if (GET_MODE (op0) == mode)\n \t;\n \n       /* If OP0 is a constant, just convert it into the proper mode.  */\n       else if (CONSTANT_P (op0))\n \t{\n-\t  tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t  tree inner_type = TREE_TYPE (treeop0);\n \t  enum machine_mode inner_mode = TYPE_MODE (inner_type);\n \n \t  if (modifier == EXPAND_INITIALIZER)\n@@ -8252,11 +8265,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       else if (target == 0)\n \top0 = convert_to_mode (mode, op0,\n \t\t\t       TYPE_UNSIGNED (TREE_TYPE\n-\t\t\t\t\t      (TREE_OPERAND (exp, 0))));\n+\t\t\t\t\t      (treeop0)));\n       else\n \t{\n \t  convert_move (target, op0,\n-\t\t\tTYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t\tTYPE_UNSIGNED (TREE_TYPE (treeop0)));\n \t  op0 = target;\n \t}\n \n@@ -8269,16 +8282,16 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t temporary by fetching an inner memory reference.  */\n       if (mode == BLKmode\n \t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST\n-\t  && TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != BLKmode\n-\t  && handled_component_p (TREE_OPERAND (exp, 0)))\n+\t  && TYPE_MODE (TREE_TYPE (treeop0)) != BLKmode\n+\t  && handled_component_p (treeop0))\n       {\n \tenum machine_mode mode1;\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n \tint unsignedp;\n \tint volatilep = 0;\n \ttree tem\n-\t  = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, &bitpos,\n+\t  = get_inner_reference (treeop0, &bitsize, &bitpos,\n \t\t\t\t &offset, &mode1, &unsignedp, &volatilep,\n \t\t\t\t true);\n \trtx orig_op0;\n@@ -8318,7 +8331,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\tif (op0 == orig_op0)\n \t\t  op0 = copy_rtx (op0);\n \n-\t\tset_mem_attributes (op0, TREE_OPERAND (exp, 0), 0);\n+\t\tset_mem_attributes (op0, treeop0, 0);\n \t\tif (REG_P (XEXP (op0, 0)))\n \t\t  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n@@ -8328,7 +8341,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       }\n \n       if (!op0)\n-\top0 = expand_expr (TREE_OPERAND (exp, 0),\n+\top0 = expand_expr (treeop0,\n \t\t\t   NULL_RTX, VOIDmode, modifier);\n \n       /* If the input and output modes are both the same, we are done.  */\n@@ -8348,7 +8361,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t other.  */\n       else if (SCALAR_INT_MODE_P (GET_MODE (op0)) && SCALAR_INT_MODE_P (mode))\n \top0 = convert_modes (mode, GET_MODE (op0), op0, \n-\t\t\t     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t\t     TYPE_UNSIGNED (TREE_TYPE (treeop0)));\n       /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */\n       else if (!MEM_P (op0))\n@@ -8357,7 +8370,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t     are going to be changing the mode of the MEM, don't call\n \t     force_const_mem for constants because we don't allow pool\n \t     constants to change mode.  */\n-\t  tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t  tree inner_type = TREE_TYPE (treeop0);\n \n \t  gcc_assert (!TREE_ADDRESSABLE (exp));\n \n@@ -8385,7 +8398,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t   && mode != BLKmode\n \t\t   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode))\n \t    {\n-\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t      tree inner_type = TREE_TYPE (treeop0);\n \t      HOST_WIDE_INT temp_size\n \t\t= MAX (int_size_in_bytes (inner_type),\n \t\t       (HOST_WIDE_INT) GET_MODE_SIZE (mode));\n@@ -8419,18 +8432,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Make sure to sign-extend the sizetype offset in a POINTER_PLUS_EXPR\n          if sizetype precision is smaller than pointer precision.  */\n       if (TYPE_PRECISION (sizetype) < TYPE_PRECISION (type))\n-\texp\n-\t  = build2 (PLUS_EXPR, type,\n-\t\t    TREE_OPERAND (exp, 0),\n-\t\t    fold_convert_loc (loc, type,\n-\t\t\t\t      fold_convert_loc (loc, ssizetype,\n-\t\t\t\t\t\t\tTREE_OPERAND (exp, 1))));\n+\ttreeop1 = fold_convert_loc (loc, type,\n+\t\t\t\t    fold_convert_loc (loc, ssizetype,\n+\t\t\t\t\t\t      treeop1));\n     case PLUS_EXPR:\n \n       /* Check if this is a case for multiplication and addition.  */\n       if ((TREE_CODE (type) == INTEGER_TYPE\n \t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n-\t  && (subexp0_def = get_def_for_expr (TREE_OPERAND (exp, 0),\n+\t  && (subexp0_def = get_def_for_expr (treeop0,\n \t\t\t\t\t      MULT_EXPR)))\n \t{\n \t  tree subsubexp0, subsubexp1;\n@@ -8468,7 +8478,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t{\n \t\t  expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n \t\t\t\t   EXPAND_NORMAL);\n-\t\t  op2 = expand_expr (TREE_OPERAND (exp, 1), subtarget,\n+\t\t  op2 = expand_expr (treeop1, subtarget,\n \t\t\t\t     VOIDmode, EXPAND_NORMAL);\n \t\t  temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n \t\t\t\t\t    target, unsignedp);\n@@ -8489,17 +8499,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t sp, ap, or fp is our second argument, in which case we must swap\n \t the innermost first argument and our second argument.  */\n \n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == PLUS_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 1)) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (exp, 1)) == VAR_DECL\n-\t  && (DECL_RTL (TREE_OPERAND (exp, 1)) == frame_pointer_rtx\n-\t      || DECL_RTL (TREE_OPERAND (exp, 1)) == stack_pointer_rtx\n-\t      || DECL_RTL (TREE_OPERAND (exp, 1)) == arg_pointer_rtx))\n+      if (TREE_CODE (treeop0) == PLUS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (treeop0, 1)) == INTEGER_CST\n+\t  && TREE_CODE (treeop1) == VAR_DECL\n+\t  && (DECL_RTL (treeop1) == frame_pointer_rtx\n+\t      || DECL_RTL (treeop1) == stack_pointer_rtx\n+\t      || DECL_RTL (treeop1) == arg_pointer_rtx))\n \t{\n-\t  tree t = TREE_OPERAND (exp, 1);\n+\t  tree t = treeop1;\n \n-\t  TREE_OPERAND (exp, 1) = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-\t  TREE_OPERAND (TREE_OPERAND (exp, 0), 0) = t;\n+\t  treeop1 = TREE_OPERAND (treeop0, 0);\n+\t  TREE_OPERAND (treeop0, 0) = t;\n \t}\n \n       /* If the result is to be ptr_mode and we are adding an integer to\n@@ -8515,40 +8525,40 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t{\n \t  if (modifier == EXPAND_STACK_PARM)\n \t    target = 0;\n-\t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n+\t  if (TREE_CODE (treeop0) == INTEGER_CST\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t      && TREE_CONSTANT (TREE_OPERAND (exp, 1)))\n+\t      && TREE_CONSTANT (treeop1))\n \t    {\n \t      rtx constant_part;\n \n-\t      op1 = expand_expr (TREE_OPERAND (exp, 1), subtarget, VOIDmode,\n+\t      op1 = expand_expr (treeop1, subtarget, VOIDmode,\n \t\t\t\t EXPAND_SUM);\n \t      /* Use immed_double_const to ensure that the constant is\n \t\t truncated according to the mode of OP1, then sign extended\n \t\t to a HOST_WIDE_INT.  Using the constant directly can result\n \t\t in non-canonical RTL in a 64x32 cross compile.  */\n \t      constant_part\n-\t\t= immed_double_const (TREE_INT_CST_LOW (TREE_OPERAND (exp, 0)),\n+\t\t= immed_double_const (TREE_INT_CST_LOW (treeop0),\n \t\t\t\t      (HOST_WIDE_INT) 0,\n-\t\t\t\t      TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 1))));\n+\t\t\t\t      TYPE_MODE (TREE_TYPE (treeop1)));\n \t      op1 = plus_constant (op1, INTVAL (constant_part));\n \t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t\top1 = force_operand (op1, target);\n \t      return REDUCE_BIT_FIELD (op1);\n \t    }\n \n-\t  else if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n+\t  else if (TREE_CODE (treeop1) == INTEGER_CST\n \t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && TREE_CONSTANT (TREE_OPERAND (exp, 0)))\n+\t\t   && TREE_CONSTANT (treeop0))\n \t    {\n \t      rtx constant_part;\n \n-\t      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n+\t      op0 = expand_expr (treeop0, subtarget, VOIDmode,\n \t\t\t\t (modifier == EXPAND_INITIALIZER\n \t\t\t\t ? EXPAND_INITIALIZER : EXPAND_SUM));\n \t      if (! CONSTANT_P (op0))\n \t\t{\n-\t\t  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n+\t\t  op1 = expand_expr (treeop1, NULL_RTX,\n \t\t\t\t     VOIDmode, modifier);\n \t\t  /* Return a PLUS if modifier says it's OK.  */\n \t\t  if (modifier == EXPAND_SUM\n@@ -8561,9 +8571,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t to a HOST_WIDE_INT.  Using the constant directly can result\n \t\t in non-canonical RTL in a 64x32 cross compile.  */\n \t      constant_part\n-\t\t= immed_double_const (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)),\n+\t\t= immed_double_const (TREE_INT_CST_LOW (treeop1),\n \t\t\t\t      (HOST_WIDE_INT) 0,\n-\t\t\t\t      TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t\t\t      TYPE_MODE (TREE_TYPE (treeop0)));\n \t      op0 = plus_constant (op0, INTVAL (constant_part));\n \t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t\top0 = force_operand (op0, target);\n@@ -8578,7 +8588,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if ((modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t  || mode != ptr_mode)\n \t{\n-\t  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t  expand_operands (treeop0, treeop1,\n \t\t\t   subtarget, &op0, &op1, EXPAND_NORMAL);\n \t  if (op0 == const0_rtx)\n \t    return op1;\n@@ -8587,15 +8597,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  goto binop2;\n \t}\n \n-      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+      expand_operands (treeop0, treeop1,\n \t\t       subtarget, &op0, &op1, modifier);\n       return REDUCE_BIT_FIELD (simplify_gen_binary (PLUS, mode, op0, op1));\n \n     case MINUS_EXPR:\n       /* Check if this is a case for multiplication and subtraction.  */\n       if ((TREE_CODE (type) == INTEGER_TYPE\n \t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n-\t  && (subexp1_def = get_def_for_expr (TREE_OPERAND (exp, 1),\n+\t  && (subexp1_def = get_def_for_expr (treeop1,\n \t\t\t\t\t      MULT_EXPR)))\n \t{\n \t  tree subsubexp0, subsubexp1;\n@@ -8633,7 +8643,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t{\n \t\t  expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n \t\t\t\t   EXPAND_NORMAL);\n-\t\t  op2 = expand_expr (TREE_OPERAND (exp, 0), subtarget,\n+\t\t  op2 = expand_expr (treeop0, subtarget,\n \t\t\t\t     VOIDmode, EXPAND_NORMAL);\n \t\t  temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n \t\t\t\t\t    target, unsignedp);\n@@ -8649,10 +8659,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Handle difference of two symbolic constants,\n \t for the sake of an initializer.  */\n       if ((modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n-\t  && really_constant_p (TREE_OPERAND (exp, 0))\n-\t  && really_constant_p (TREE_OPERAND (exp, 1)))\n+\t  && really_constant_p (treeop0)\n+\t  && really_constant_p (treeop1))\n \t{\n-\t  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t  expand_operands (treeop0, treeop1,\n \t\t\t   NULL_RTX, &op0, &op1, modifier);\n \n \t  /* If the last operand is a CONST_INT, use plus_constant of\n@@ -8671,7 +8681,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  || mode != ptr_mode)\n \tgoto binop;\n \n-      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+      expand_operands (treeop0, treeop1,\n \t\t       subtarget, &op0, &op1, modifier);\n \n       /* Convert A - const to A + (-const).  */\n@@ -8693,22 +8703,22 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* If first operand is constant, swap them.\n \t Thus the following special case checks need only\n \t check the second operand.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST)\n+      if (TREE_CODE (treeop0) == INTEGER_CST)\n \t{\n-\t  tree t1 = TREE_OPERAND (exp, 0);\n-\t  TREE_OPERAND (exp, 0) = TREE_OPERAND (exp, 1);\n-\t  TREE_OPERAND (exp, 1) = t1;\n+\t  tree t1 = treeop0;\n+\t  treeop0 = treeop1;\n+\t  treeop1 = t1;\n \t}\n \n       /* Attempt to return something suitable for generating an\n \t indexed address, for machines that support that.  */\n \n       if (modifier == EXPAND_SUM && mode == ptr_mode\n-\t  && host_integerp (TREE_OPERAND (exp, 1), 0))\n+\t  && host_integerp (treeop1, 0))\n \t{\n-\t  tree exp1 = TREE_OPERAND (exp, 1);\n+\t  tree exp1 = treeop1;\n \n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n+\t  op0 = expand_expr (treeop0, subtarget, VOIDmode,\n \t\t\t     EXPAND_SUM);\n \n \t  if (!REG_P (op0))\n@@ -8729,8 +8739,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t in that narrower type with a result in the desired type,\n \t do it that way, and avoid the explicit type-conversion.  */\n \n-      subexp0 = TREE_OPERAND (exp, 0);\n-      subexp1 = TREE_OPERAND (exp, 1);\n+      subexp0 = treeop0;\n+      subexp1 = treeop1;\n       subexp0_def = get_def_for_expr (subexp0, NOP_EXPR);\n       subexp1_def = get_def_for_expr (subexp1, NOP_EXPR);\n       top0 = top1 = NULL_TREE;\n@@ -8848,7 +8858,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Possible optimization: compute the dividend with EXPAND_SUM\n \t then if the divisor is constant can optimize the case\n \t where some terms of the dividend have coeffs divisible by it.  */\n-      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+      expand_operands (treeop0, treeop1,\n \t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n       return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n \n@@ -8861,45 +8871,45 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case ROUND_MOD_EXPR:\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n-      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+      expand_operands (treeop0, treeop1,\n \t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n       return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n \n     case FIXED_CONVERT_EXPR:\n-      op0 = expand_normal (TREE_OPERAND (exp, 0));\n+      op0 = expand_normal (treeop0);\n       if (target == 0 || modifier == EXPAND_STACK_PARM)\n \ttarget = gen_reg_rtx (mode);\n \n-      if ((TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == INTEGER_TYPE\n-\t   && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+      if ((TREE_CODE (TREE_TYPE (treeop0)) == INTEGER_TYPE\n+\t   && TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n           || (TREE_CODE (type) == INTEGER_TYPE && TYPE_UNSIGNED (type)))\n \texpand_fixed_convert (target, op0, 1, TYPE_SATURATING (type));\n       else\n \texpand_fixed_convert (target, op0, 0, TYPE_SATURATING (type));\n       return target;\n \n     case FIX_TRUNC_EXPR:\n-      op0 = expand_normal (TREE_OPERAND (exp, 0));\n+      op0 = expand_normal (treeop0);\n       if (target == 0 || modifier == EXPAND_STACK_PARM)\n \ttarget = gen_reg_rtx (mode);\n       expand_fix (target, op0, unsignedp);\n       return target;\n \n     case FLOAT_EXPR:\n-      op0 = expand_normal (TREE_OPERAND (exp, 0));\n+      op0 = expand_normal (treeop0);\n       if (target == 0 || modifier == EXPAND_STACK_PARM)\n \ttarget = gen_reg_rtx (mode);\n       /* expand_float can't figure out what to do if FROM has VOIDmode.\n \t So give it the correct mode.  With -O, cse will optimize this.  */\n       if (GET_MODE (op0) == VOIDmode)\n-\top0 = copy_to_mode_reg (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n+\top0 = copy_to_mode_reg (TYPE_MODE (TREE_TYPE (treeop0)),\n \t\t\t\top0);\n       expand_float (target, op0,\n-\t\t    TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t\t    TYPE_UNSIGNED (TREE_TYPE (treeop0)));\n       return target;\n \n     case NEGATE_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget,\n+      op0 = expand_expr (treeop0, subtarget,\n \t\t\t VOIDmode, EXPAND_NORMAL);\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n@@ -8911,7 +8921,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return REDUCE_BIT_FIELD (temp);\n \n     case ABS_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget,\n+      op0 = expand_expr (treeop0, subtarget,\n \t\t\t VOIDmode, EXPAND_NORMAL);\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n@@ -8926,7 +8936,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn op0;\n \n       return expand_abs (mode, op0, target, unsignedp,\n-\t\t\t safe_from_p (target, TREE_OPERAND (exp, 0), 1));\n+\t\t\t safe_from_p (target, treeop0, 1));\n \n     case MAX_EXPR:\n     case MIN_EXPR:\n@@ -8938,7 +8948,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  || (REG_P (target)\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n-      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+      expand_operands (treeop0, treeop1,\n \t\t       target, &op0, &op1, EXPAND_NORMAL);\n \n       /* First try to do it with a special MIN or MAX instruction.\n@@ -9044,7 +9054,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return target;\n \n     case BIT_NOT_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget,\n+      op0 = expand_expr (treeop0, subtarget,\n \t\t\t VOIDmode, EXPAND_NORMAL);\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n@@ -9095,13 +9105,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (ALL_FIXED_POINT_MODE_P (mode))\n \tgoto binop;\n \n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n+      if (! safe_from_p (subtarget, treeop1, 1))\n \tsubtarget = 0;\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget,\n+      op0 = expand_expr (treeop0, subtarget,\n \t\t\t VOIDmode, EXPAND_NORMAL);\n-      temp = expand_shift (code, mode, op0, TREE_OPERAND (exp, 1), target,\n+      temp = expand_shift (code, mode, op0, treeop1, target,\n \t\t\t   unsignedp);\n       if (code == LSHIFT_EXPR)\n \ttemp = REDUCE_BIT_FIELD (temp);\n@@ -9139,7 +9149,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (! ignore\n \t  && (target == 0\n \t      || modifier == EXPAND_STACK_PARM\n-\t      || ! safe_from_p (target, exp, 1)\n+\t      || ! safe_from_p (target, treeop0, 1)\n+\t      || ! safe_from_p (target, treeop1, 1)\n \t      /* Make sure we don't have a hard reg (such as function's return\n \t\t value) live across basic blocks, if not optimizing.  */\n \t      || (!optimize && REG_P (target)\n@@ -9161,7 +9172,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case TRUTH_NOT_EXPR:\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), target,\n+      op0 = expand_expr (treeop0, target,\n \t\t\t VOIDmode, EXPAND_NORMAL);\n       /* The parser is careful to generate TRUTH_NOT_EXPR\n \t only with operands that are always zero or one.  */\n@@ -9185,7 +9196,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* A COND_EXPR with its type being VOID_TYPE represents a\n \t conditional jump and is handled in\n \t expand_gimple_cond_expr.  */\n-      gcc_assert (!VOID_TYPE_P (TREE_TYPE (exp)));\n+      gcc_assert (!VOID_TYPE_P (type));\n \n         /* Note that COND_EXPRs whose type is a structure or union\n   \t are required to be constructed to contain assignments of\n@@ -9194,8 +9205,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n         gcc_assert (!TREE_ADDRESSABLE (type)\n \t\t    && !ignore\n-\t\t    && TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node\n-\t\t    && TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node);\n+\t\t    && TREE_TYPE (treeop1) != void_type_node\n+\t\t    && TREE_TYPE (treeop2) != void_type_node);\n \n        /* If we are not to produce a result, we have no target.  Otherwise,\n  \t if a target was specified use it; it will not be used as an\n@@ -9204,7 +9215,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n        if (modifier != EXPAND_STACK_PARM\n  \t  && original_target\n- \t  && safe_from_p (original_target, TREE_OPERAND (exp, 0), 1)\n+ \t  && safe_from_p (original_target, treeop0, 1)\n  \t  && GET_MODE (original_target) == mode\n #ifdef HAVE_conditional_move\n  \t  && (! can_conditionally_move_p (mode)\n@@ -9219,15 +9230,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n        NO_DEFER_POP;\n        op0 = gen_label_rtx ();\n        op1 = gen_label_rtx ();\n-       jumpifnot (TREE_OPERAND (exp, 0), op0);\n-       store_expr (TREE_OPERAND (exp, 1), temp,\n+       jumpifnot (treeop0, op0);\n+       store_expr (treeop1, temp,\n  \t\t  modifier == EXPAND_STACK_PARM,\n \t\t  false);\n \n        emit_jump_insn (gen_jump (op1));\n        emit_barrier ();\n        emit_label (op0);\n-       store_expr (TREE_OPERAND (exp, 2), temp,\n+       store_expr (treeop2, temp,\n  \t\t  modifier == EXPAND_STACK_PARM,\n \t\t  false);\n \n@@ -9241,8 +9252,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case MODIFY_EXPR:\n       {\n-\ttree lhs = TREE_OPERAND (exp, 0);\n-\ttree rhs = TREE_OPERAND (exp, 1);\n+\ttree lhs = treeop0;\n+\ttree rhs = treeop1;\n \tgcc_assert (ignore);\n \n \t/* Check for |= or &= of a bitfield of size one into another bitfield\n@@ -9278,22 +9289,22 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       }\n \n     case RETURN_EXPR:\n-      if (!TREE_OPERAND (exp, 0))\n+      if (!treeop0)\n \texpand_null_return ();\n       else\n-\texpand_return (TREE_OPERAND (exp, 0));\n+\texpand_return (treeop0);\n       return const0_rtx;\n \n     case ADDR_EXPR:\n       return expand_expr_addr_expr (exp, target, tmode, modifier);\n \n     case COMPLEX_EXPR:\n       /* Get the rtx code of the operands.  */\n-      op0 = expand_normal (TREE_OPERAND (exp, 0));\n-      op1 = expand_normal (TREE_OPERAND (exp, 1));\n+      op0 = expand_normal (treeop0);\n+      op1 = expand_normal (treeop1);\n \n       if (!target)\n-\ttarget = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\ttarget = gen_reg_rtx (TYPE_MODE (type));\n \n       /* Move the real (op0) and imaginary (op1) parts to their location.  */\n       write_complex_part (target, op0, false);\n@@ -9302,11 +9313,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return target;\n \n     case REALPART_EXPR:\n-      op0 = expand_normal (TREE_OPERAND (exp, 0));\n+      op0 = expand_normal (treeop0);\n       return read_complex_part (op0, false);\n \n     case IMAGPART_EXPR:\n-      op0 = expand_normal (TREE_OPERAND (exp, 0));\n+      op0 = expand_normal (treeop0);\n       return read_complex_part (op0, true);\n \n     case RESX_EXPR:\n@@ -9354,7 +9365,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return const0_rtx;\n \n     case LABEL_EXPR:\n-      expand_label (TREE_OPERAND (exp, 0));\n+      expand_label (treeop0);\n       return const0_rtx;\n \n     case ASM_EXPR:\n@@ -9364,14 +9375,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR expands to its first argument.  The caller should\n \t have pulled out the size to use in whatever context it needed.  */\n-      return expand_expr_real (TREE_OPERAND (exp, 0), original_target, tmode,\n+      return expand_expr_real (treeop0, original_target, tmode,\n \t\t\t       modifier, alt_rtl);\n \n     case REALIGN_LOAD_EXPR:\n       {\n-        tree oprnd0 = TREE_OPERAND (exp, 0);\n-        tree oprnd1 = TREE_OPERAND (exp, 1);\n-        tree oprnd2 = TREE_OPERAND (exp, 2);\n+        tree oprnd0 = treeop0;\n+        tree oprnd1 = treeop1;\n+        tree oprnd2 = treeop2;\n         rtx op2;\n \n         this_optab = optab_for_tree_code (code, type, optab_default);\n@@ -9385,9 +9396,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case DOT_PROD_EXPR:\n       {\n-\ttree oprnd0 = TREE_OPERAND (exp, 0);\n-\ttree oprnd1 = TREE_OPERAND (exp, 1);\n-\ttree oprnd2 = TREE_OPERAND (exp, 2);\n+\ttree oprnd0 = treeop0;\n+\ttree oprnd1 = treeop1;\n+\ttree oprnd2 = treeop2;\n \trtx op2;\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n@@ -9399,8 +9410,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case WIDEN_SUM_EXPR:\n       {\n-        tree oprnd0 = TREE_OPERAND (exp, 0);\n-        tree oprnd1 = TREE_OPERAND (exp, 1);\n+        tree oprnd0 = treeop0;\n+        tree oprnd1 = treeop1;\n \n         expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         target = expand_widen_pattern_expr (exp, op0, NULL_RTX, op1,\n@@ -9412,7 +9423,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case REDUC_MIN_EXPR:\n     case REDUC_PLUS_EXPR:\n       {\n-        op0 = expand_normal (TREE_OPERAND (exp, 0));\n+        op0 = expand_normal (treeop0);\n         this_optab = optab_for_tree_code (code, type, optab_default);\n         temp = expand_unop (mode, this_optab, op0, target, unsignedp);\n         gcc_assert (temp);\n@@ -9422,7 +9433,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n       {\n-        expand_operands (TREE_OPERAND (exp, 0),  TREE_OPERAND (exp, 1),\n+        expand_operands (treeop0,  treeop1,\n                          NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         this_optab = optab_for_tree_code (code, type, optab_default);\n         temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n@@ -9434,7 +9445,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_INTERLEAVE_HIGH_EXPR:\n     case VEC_INTERLEAVE_LOW_EXPR:\n       {\n-        expand_operands (TREE_OPERAND (exp, 0),  TREE_OPERAND (exp, 1),\n+        expand_operands (treeop0,  treeop1,\n                          NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         this_optab = optab_for_tree_code (code, type, optab_default);\n         temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n@@ -9453,7 +9464,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n       {\n-\top0 = expand_normal (TREE_OPERAND (exp, 0));\n+\top0 = expand_normal (treeop0);\n \tthis_optab = optab_for_tree_code (code, type, optab_default);\n \ttemp = expand_widen_pattern_expr (exp, op0, NULL_RTX, NULL_RTX,\n \t\t\t\t\t  target, unsignedp);\n@@ -9464,14 +9475,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_UNPACK_FLOAT_HI_EXPR:\n     case VEC_UNPACK_FLOAT_LO_EXPR:\n       {\n-\top0 = expand_normal (TREE_OPERAND (exp, 0));\n+\top0 = expand_normal (treeop0);\n \t/* The signedness is determined from input operand.  */\n \tthis_optab = optab_for_tree_code (code,\n-\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (exp, 0)),\n+\t\t\t\t\t  TREE_TYPE (treeop0),\n \t\t\t\t\t  optab_default);\n \ttemp = expand_widen_pattern_expr\n \t  (exp, op0, NULL_RTX, NULL_RTX,\n-\t   target, TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\t   target, TYPE_UNSIGNED (TREE_TYPE (treeop0)));\n \n \tgcc_assert (temp);\n \treturn temp;\n@@ -9480,8 +9491,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:\n       {\n-\ttree oprnd0 = TREE_OPERAND (exp, 0);\n-\ttree oprnd1 = TREE_OPERAND (exp, 1);\n+\ttree oprnd0 = treeop0;\n+\ttree oprnd1 = treeop1;\n \n \texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \ttarget = expand_widen_pattern_expr (exp, op0, op1, NULL_RTX,\n@@ -9493,7 +9504,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n-      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+      mode = TYPE_MODE (TREE_TYPE (treeop0));\n       goto binop;\n \n     case COMPOUND_LITERAL_EXPR:\n@@ -9523,7 +9534,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n   /* Here to do an ordinary binary operator.  */\n  binop:\n-  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+  expand_operands (treeop0, treeop1,\n \t\t   subtarget, &op0, &op1, EXPAND_NORMAL);\n  binop2:\n   this_optab = optab_for_tree_code (code, type, optab_default);"}]}