{"sha": "29049f0b22b4475b4f8e0872b0455d025782e041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkwNDlmMGIyMmI0NDc1YjRmOGUwODcyYjA0NTVkMDI1NzgyZTA0MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T09:47:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T09:47:14Z"}, "message": "[multiple changes]\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference, case Pred):\n\tRemove special test for Float'First, no longer required.\n\t(Expand_N_Attribute_Reference, case Succ): Remove special test\n\tfor Float'First, no longer required.\n\t* s-fatgen.adb (Pred): return infinity unchanged.\n\t(Succ): ditto.\n\n2014-08-04  Claire Dross  <dross@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Associations): Defaults should only be\n\tused if there is no explicit match.\n\t* exp_util.adb (Get_First_Parent_With_Ext_Axioms_For_Entity):\n\tAlso check for pragma external_axiomatization on generic units.\n\nFrom-SVN: r213546", "tree": {"sha": "c9ba49866405f3050bb8de2fdb43f2badcc1cdb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9ba49866405f3050bb8de2fdb43f2badcc1cdb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29049f0b22b4475b4f8e0872b0455d025782e041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29049f0b22b4475b4f8e0872b0455d025782e041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29049f0b22b4475b4f8e0872b0455d025782e041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29049f0b22b4475b4f8e0872b0455d025782e041/comments", "author": null, "committer": null, "parents": [{"sha": "d26d790dca2c2135161666dc955cc39befbaf587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26d790dca2c2135161666dc955cc39befbaf587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d26d790dca2c2135161666dc955cc39befbaf587"}], "stats": {"total": 142, "additions": 60, "deletions": 82}, "files": [{"sha": "b273bfc7fa2a01598ea8f2aed3b1ed81b8f77fb0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=29049f0b22b4475b4f8e0872b0455d025782e041", "patch": "@@ -1,3 +1,19 @@\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, case Pred):\n+\tRemove special test for Float'First, no longer required.\n+\t(Expand_N_Attribute_Reference, case Succ): Remove special test\n+\tfor Float'First, no longer required.\n+\t* s-fatgen.adb (Pred): return infinity unchanged.\n+\t(Succ): ditto.\n+\n+2014-08-04  Claire Dross  <dross@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Associations): Defaults should only be\n+\tused if there is no explicit match.\n+\t* exp_util.adb (Get_First_Parent_With_Ext_Axioms_For_Entity):\n+\tAlso check for pragma external_axiomatization on generic units.\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb (Activate_Overflow_Check): Remove"}, {"sha": "bb1b6b6a4b6e0b5e141f774a9a7a1dcb4fb80d20", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=29049f0b22b4475b4f8e0872b0455d025782e041", "patch": "@@ -4859,10 +4859,9 @@ package body Exp_Attr is\n       -- Pred --\n       ----------\n \n-      --  1. Deal with enumeration types with holes\n-      --  2. For floating-point, generate call to attribute function and deal\n-      --       with range checking if Check_Float_Overflow mode is set.\n-      --  3. For other cases, deal with constraint checking\n+      --  1. Deal with enumeration types with holes.\n+      --  2. For floating-point, generate call to attribute function.\n+      --  3. For other cases, deal with constraint checking.\n \n       when Attribute_Pred => Pred :\n       declare\n@@ -4934,35 +4933,9 @@ package body Exp_Attr is\n \n          --  For floating-point, we transform 'Pred into a call to the Pred\n          --  floating-point attribute function in Fat_xxx (xxx is root type).\n+         --  Note that this function takes care of the overflow case.\n \n          elsif Is_Floating_Point_Type (Ptyp) then\n-\n-            --  Handle case of range check. The Do_Range_Check flag is set only\n-            --  in Check_Float_Overflow mode, and what we need is a specific\n-            --  check against typ'First, since that is the only overflow case.\n-\n-            declare\n-               Expr : constant Node_Id := First (Exprs);\n-            begin\n-               if Do_Range_Check (Expr) then\n-                  Set_Do_Range_Check (Expr, False);\n-                  Insert_Action (N,\n-                    Make_Raise_Constraint_Error (Loc,\n-                      Condition =>\n-                        Make_Op_Eq (Loc,\n-                          Left_Opnd  => Duplicate_Subexpr (Expr),\n-                          Right_Opnd =>\n-                            Make_Attribute_Reference (Loc,\n-                              Attribute_Name => Name_First,\n-                              Prefix         =>\n-                                New_Occurrence_Of (Base_Type (Ptyp), Loc))),\n-                      Reason => CE_Overflow_Check_Failed),\n-                  Suppress => All_Checks);\n-               end if;\n-            end;\n-\n-            --  Transform into call to attribute function\n-\n             Expand_Fpt_Attribute_R (N);\n             Analyze_And_Resolve (N, Typ);\n \n@@ -5889,9 +5862,9 @@ package body Exp_Attr is\n       -- Succ --\n       ----------\n \n-      --  1. Deal with enumeration types with holes\n-      --  2. For floating-point, generate call to attribute function\n-      --  3. For other cases, deal with constraint checking\n+      --  1. Deal with enumeration types with holes.\n+      --  2. For floating-point, generate call to attribute function.\n+      --  3. For other cases, deal with constraint checking.\n \n       when Attribute_Succ => Succ : declare\n          Etyp : constant Entity_Id := Base_Type (Ptyp);\n@@ -5960,33 +5933,6 @@ package body Exp_Attr is\n          --  floating-point attribute function in Fat_xxx (xxx is root type)\n \n          elsif Is_Floating_Point_Type (Ptyp) then\n-\n-            --  Handle case of range check. The Do_Range_Check flag is set only\n-            --  in Check_Float_Overflow mode, and what we need is a specific\n-            --  check against typ'Last, since that is the only overflow case.\n-\n-            declare\n-               Expr : constant Node_Id := First (Exprs);\n-            begin\n-               if Do_Range_Check (Expr) then\n-                  Set_Do_Range_Check (Expr, False);\n-                  Insert_Action (N,\n-                    Make_Raise_Constraint_Error (Loc,\n-                      Condition =>\n-                        Make_Op_Eq (Loc,\n-                          Left_Opnd  => Duplicate_Subexpr (Expr),\n-                          Right_Opnd =>\n-                            Make_Attribute_Reference (Loc,\n-                              Attribute_Name => Name_Last,\n-                              Prefix         =>\n-                                New_Occurrence_Of (Base_Type (Ptyp), Loc))),\n-                      Reason    => CE_Overflow_Check_Failed),\n-                    Suppress => All_Checks);\n-               end if;\n-            end;\n-\n-            --  Transform into call to attribute function\n-\n             Expand_Fpt_Attribute_R (N);\n             Analyze_And_Resolve (N, Typ);\n "}, {"sha": "481fc37115aa85c6a7de64c4e81e40f3fa8f8fdf", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=29049f0b22b4475b4f8e0872b0455d025782e041", "patch": "@@ -3292,8 +3292,8 @@ package body Exp_Util is\n    -------------------------------------------------\n \n    function Get_First_Parent_With_Ext_Axioms_For_Entity\n-     (E : Entity_Id) return Entity_Id is\n-\n+     (E : Entity_Id) return Entity_Id\n+   is\n       Decl : Node_Id;\n \n    begin\n@@ -3305,9 +3305,9 @@ package body Exp_Util is\n          end if;\n       end if;\n \n-      --  E is the package which is externally axiomatized\n+      --  E is the package or generic package which is externally axiomatized\n \n-      if Ekind (E) = E_Package\n+      if Ekind_In (E, E_Package, E_Generic_Package)\n         and then Has_Annotate_Pragma_For_External_Axiomatization (E)\n       then\n          return E;\n@@ -3318,14 +3318,14 @@ package body Exp_Util is\n       elsif Ekind (E) = E_Package\n         and then Present (Generic_Parent (Decl))\n       then\n-         return Get_First_Parent_With_Ext_Axioms_For_Entity\n-           (Generic_Parent (Decl));\n+         return\n+           Get_First_Parent_With_Ext_Axioms_For_Entity (Generic_Parent (Decl));\n \n          --  Otherwise, look at E's scope instead if present\n \n       elsif Present (Scope (E)) then\n-         return Get_First_Parent_With_Ext_Axioms_For_Entity\n-             (Scope (E));\n+         return\n+           Get_First_Parent_With_Ext_Axioms_For_Entity (Scope (E));\n \n          --  Else there is no such axiomatized package\n "}, {"sha": "1f4c49857624b99c861b6420dbd780ca4cb63675", "filename": "gcc/ada/s-fatgen.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.adb?ref=29049f0b22b4475b4f8e0872b0455d025782e041", "patch": "@@ -426,6 +426,11 @@ package body System.Fat_Gen is\n             return X / (X - X);\n          end if;\n \n+      --  For infinities, return unchanged\n+\n+      elsif X < T'First or else X > T'Last then\n+         return X;\n+\n       --  Subtract from the given number a number equivalent to the value\n       --  of its least significant bit. Given that the most significant bit\n       --  represents a value of 1.0 * radix ** (exp - 1), the value we want\n@@ -675,6 +680,11 @@ package body System.Fat_Gen is\n             return X / (X - X);\n          end if;\n \n+      --  For infinities, return unchanged\n+\n+      elsif X < T'First or else X > T'Last then\n+         return X;\n+\n       --  Add to the given number a number equivalent to the value\n       --  of its least significant bit. Given that the most significant bit\n       --  represents a value of 1.0 * radix ** (exp - 1), the value we want"}, {"sha": "ada3adc76b849b068876a3fdfcccee6226d9b991", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29049f0b22b4475b4f8e0872b0455d025782e041/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=29049f0b22b4475b4f8e0872b0455d025782e041", "patch": "@@ -1680,21 +1680,27 @@ package body Sem_Ch12 is\n                         --  If actual is an entity (function or operator),\n                         --  build wrapper for it.\n \n-                        if Present (Match)\n-                          and then Nkind (Match) = N_Operator_Symbol\n-                        then\n-                           --  If the name is a default, find its visible\n-                           --  entity at the point of instantiation.\n+                        if Present (Match) then\n+                           if Nkind (Match) = N_Operator_Symbol then\n+                              --  If the name is a default, find its visible\n+                              --  entity at the point of instantiation.\n+\n+                              if Is_Entity_Name (Match)\n+                                and then No (Entity (Match))\n+                              then\n+                                 Find_Direct_Name (Match);\n+                              end if;\n \n-                           if Is_Entity_Name (Match)\n-                             and then No (Entity (Match))\n-                           then\n-                              Find_Direct_Name (Match);\n-                           end if;\n+                              Append_To\n+                                (Assoc,\n+                                 Build_Wrapper\n+                                   (Defining_Entity (Analyzed_Formal), Match));\n \n-                           Append_To (Assoc,\n-                             Build_Wrapper\n-                               (Defining_Entity (Analyzed_Formal), Match));\n+                           else\n+                              Append_To (Assoc,\n+                                         Instantiate_Formal_Subprogram\n+                                           (Formal, Match, Analyzed_Formal));\n+                           end if;\n \n                         --  Ditto if formal is an operator with a default.\n "}]}