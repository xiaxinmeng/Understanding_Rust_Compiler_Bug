{"sha": "3daacdcd5f20d084294f2cc50f84e3e8769205f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RhYWNkY2Q1ZjIwZDA4NDI5NGYyY2M1MGY4NGUzZTg3NjkyMDVmMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-12-10T16:34:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-12-10T16:34:43Z"}, "message": "re PR tree-optimization/68619 (error: loop with header 6 not in loop tree)\n\n2015-12-10  Jeff Law  <law@redhat.com>\n\n\tPR tree-optimization/68619\n\t* tree-ssa-dom.c (dom_opt_dom_walker::before_dom_children): Propgate\n\treturn value from optimize_stmt.\n\t(dom_opt_dom_walker): Add new argument to dom_walker constructor.\n\t(pass_dominator:execute): If a block has an unreachable edge,\n\tremove all jump threads through any successor of the affected block.\n\t(record_equivalences_from_phis): Ignore alternative if the edge\n\tdoes not have EDGE_EXECUTABLE set.\n\t(single_incoming_edge_ignoring_loop_edges): Similarly.\n\t(optimize_stmt): If a gimple_code has a compile-time constant\n\tcondition, return the edge taken for that constant value.  Also\n\tchange the condition to true/false as necessary.\n\t* domwalk.h (dom_walker::dom_walker): Add new argument\n\tskip_unreachable_blocks.  Don't provide empty constructor body.\n\t(dom_walker::before_dom_children): Change return type.\n\t(dom_walker::bb_reachable): Declare new private method.\n\t(dom_walker::propagate_unreachable_to_edges): Likewise.\n\t(dom_walker::m_unreachable_dom): Declare new private data member.\n\t(dom_walker::m_skip_unreachable_blocks): Likewise.\n\t* domwalk.c: Include dumpfile.h.\n\t(dom_walker::dom_walker): New constructor.  Initialize private data\n\tmembers.  If needed, set EDGE_EXECUTABLE for all edges in the CFG,\n\textracted from tree-ssa-sccvn.c.\n\t(dom_walker::bb_reachable): New method extracted from tree-ssa-sccvn.c\n\t(dom_walker::propagate_unreachable_to_edges): Likewise.\n\t(dom_walker::walk): Only call before_dom_children on reachable\n\tblocks.  If before_dom_children returns an edge, then clear\n\tEDGE_EXECUTABLE for all other outgoing edges from the same block.\n\tFor unreachable blocks, call propagate_unreachable_to_edges.\n\tSimilarly, only call after_dom_children on reachable blocks.  For\n\tunreachable blocks, conditionally clear m_unreachable_dom.\n\t* tree-ssa-sccvn.c (sccvn_dom_walker::unreachable_dom): Remove\n\tprivate data member.\n\t(sccvn_dom_walker::after_dom_children): Use methods from dom_walker\n\tclass.\n\t(run_scc_vn): Likewise.\n\t(sccvn_dom_walker::before_dom_children): Likewise.  Return the taken\n\toutgoing edge if a COND, SWITCH, or GOTO are optimized.\n\t* compare-elim.c (find_comparison_dom_walker::before_dom_children):\n\tChange return type to an edge.  Always return NULL.\n\t* fwprop.c (single_def_use_dom_walker::before_dom_children): Likewise.\n\t* gimple-ssa-strength-reduction.c\n\t(find_candidates_dom_walker::before_dom_children): Likewise.\n\t* ipa-prop.c (analysis_dom_walker::before_dom_children): Likewise.\n\t(ipcp_modif_dom_walker::before_dom_children): Likewise.\n\t* tree-into-ssa.c (rewrite_dom_walker::before_dom_children): Likewise.\n\t(rewrite_update_dom_walker::before_dom_children): Likewise.\n\t(mark_def_dom_children::before_dom_children): Likewise.\n\t* tree-ssa-dse.c (dse_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-loop-im.c\n\t(invariantness_dom_walker::before_dom_children): Likewise.\n\t(move_computations_dom_walker::before_dom_walker): Likewise.\n\t* tree-ssa-phiopt.c\n\t(nontrapping_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-pre.c\n\t(eliminate_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-propagate.c\n\t(substitute_and_fold_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-strlen.c\n\t(strlen_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-uncprop.c\n\t(uncprop_dom_walker::before_dom_children): Likewise.\n\n\tPR tree-optimization/68619\n\t* gcc.dg/tree-ssa/pr68619-1.c: New test.\n\t* gcc.dg/tree-ssa/pr68619-2.c: New test.\n\t* gcc.dg/tree-ssa/pr68619-3.c: New test.\n\t* gcc.dg/tree-ssa/pr68619-4.c: New test.\n\t* gcc.dg/tree-ssa/pr68619-5.c: New test.\n\nFrom-SVN: r231527", "tree": {"sha": "d015d8a16670f07cb924dc37566a552de34a31e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d015d8a16670f07cb924dc37566a552de34a31e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3daacdcd5f20d084294f2cc50f84e3e8769205f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3daacdcd5f20d084294f2cc50f84e3e8769205f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3daacdcd5f20d084294f2cc50f84e3e8769205f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3daacdcd5f20d084294f2cc50f84e3e8769205f1/comments", "author": null, "committer": null, "parents": [{"sha": "9dd920ab7090041bc4983209b0807c69339299f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd920ab7090041bc4983209b0807c69339299f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dd920ab7090041bc4983209b0807c69339299f8"}], "stats": {"total": 876, "additions": 740, "deletions": 136}, "files": [{"sha": "0a77807efe4f149da192402f0eee27345b6f7503", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -1,3 +1,68 @@\n+2015-12-10  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/68619\n+\t* tree-ssa-dom.c (dom_opt_dom_walker::before_dom_children): Propgate\n+\treturn value from optimize_stmt.\n+\t(dom_opt_dom_walker): Add new argument to dom_walker constructor.\n+\t(pass_dominator:execute): If a block has an unreachable edge,\n+\tremove all jump threads through any successor of the affected block.\n+\t(record_equivalences_from_phis): Ignore alternative if the edge\n+\tdoes not have EDGE_EXECUTABLE set.\n+\t(single_incoming_edge_ignoring_loop_edges): Similarly.\n+\t(optimize_stmt): If a gimple_code has a compile-time constant\n+\tcondition, return the edge taken for that constant value.  Also\n+\tchange the condition to true/false as necessary.\n+\t* domwalk.h (dom_walker::dom_walker): Add new argument\n+\tskip_unreachable_blocks.  Don't provide empty constructor body.\n+\t(dom_walker::before_dom_children): Change return type.\n+\t(dom_walker::bb_reachable): Declare new private method.\n+\t(dom_walker::propagate_unreachable_to_edges): Likewise.\n+\t(dom_walker::m_unreachable_dom): Declare new private data member.\n+\t(dom_walker::m_skip_unreachable_blocks): Likewise.\n+\t* domwalk.c: Include dumpfile.h.\n+\t(dom_walker::dom_walker): New constructor.  Initialize private data\n+\tmembers.  If needed, set EDGE_EXECUTABLE for all edges in the CFG,\n+\textracted from tree-ssa-sccvn.c.\n+\t(dom_walker::bb_reachable): New method extracted from tree-ssa-sccvn.c\n+\t(dom_walker::propagate_unreachable_to_edges): Likewise.\n+\t(dom_walker::walk): Only call before_dom_children on reachable\n+\tblocks.  If before_dom_children returns an edge, then clear\n+\tEDGE_EXECUTABLE for all other outgoing edges from the same block.\n+\tFor unreachable blocks, call propagate_unreachable_to_edges.\n+\tSimilarly, only call after_dom_children on reachable blocks.  For\n+\tunreachable blocks, conditionally clear m_unreachable_dom.\n+\t* tree-ssa-sccvn.c (sccvn_dom_walker::unreachable_dom): Remove\n+\tprivate data member.\n+\t(sccvn_dom_walker::after_dom_children): Use methods from dom_walker\n+\tclass.\n+\t(run_scc_vn): Likewise.\n+\t(sccvn_dom_walker::before_dom_children): Likewise.  Return the taken\n+\toutgoing edge if a COND, SWITCH, or GOTO are optimized.\n+\t* compare-elim.c (find_comparison_dom_walker::before_dom_children):\n+\tChange return type to an edge.  Always return NULL.\n+\t* fwprop.c (single_def_use_dom_walker::before_dom_children): Likewise.\n+\t* gimple-ssa-strength-reduction.c\n+\t(find_candidates_dom_walker::before_dom_children): Likewise.\n+\t* ipa-prop.c (analysis_dom_walker::before_dom_children): Likewise.\n+\t(ipcp_modif_dom_walker::before_dom_children): Likewise.\n+\t* tree-into-ssa.c (rewrite_dom_walker::before_dom_children): Likewise.\n+\t(rewrite_update_dom_walker::before_dom_children): Likewise.\n+\t(mark_def_dom_children::before_dom_children): Likewise.\n+\t* tree-ssa-dse.c (dse_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-loop-im.c\n+\t(invariantness_dom_walker::before_dom_children): Likewise.\n+\t(move_computations_dom_walker::before_dom_walker): Likewise.\n+\t* tree-ssa-phiopt.c\n+\t(nontrapping_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-pre.c\n+\t(eliminate_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-propagate.c\n+\t(substitute_and_fold_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-strlen.c\n+\t(strlen_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-uncprop.c\n+\t(uncprop_dom_walker::before_dom_children): Likewise.\n+\n 2015-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/68376"}, {"sha": "5f74db027dbf08333aa457d440143824e1b31552", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -248,7 +248,7 @@ class find_comparison_dom_walker : public dom_walker\n   find_comparison_dom_walker (cdi_direction direction)\n     : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n };\n \n /* Return true if conforming COMPARE with EH_NOTE is redundant with comparison\n@@ -294,7 +294,7 @@ can_eliminate_compare (rtx compare, rtx eh_note, struct comparison *cmp)\n    compare in the BB is live at the end of the block, install the compare\n    in BB->AUX.  Called via dom_walker.walk ().  */\n \n-void\n+edge\n find_comparison_dom_walker::before_dom_children (basic_block bb)\n {\n   struct comparison *last_cmp;\n@@ -426,6 +426,8 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n      remove EH edges.  */\n   if (need_purge)\n     purge_dead_edges (bb);\n+\n+  return NULL;\n }\n \n /* Find all comparisons in the function.  */"}, {"sha": "2481e34ea6e80e88d112ab038a6fff3c78415b40", "filename": "gcc/domwalk.c", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"cfganal.h\"\n #include \"domwalk.h\"\n+#include \"dumpfile.h\"\n \n /* This file implements a generic walker for dominator trees.\n \n@@ -142,6 +143,91 @@ cmp_bb_postorder (const void *a, const void *b)\n   return 1;\n }\n \n+/* Constructor for a dom walker.\n+\n+   If SKIP_UNREACHBLE_BLOCKS is true, then we need to set\n+   EDGE_EXECUTABLE on every edge in the CFG. */\n+dom_walker::dom_walker (cdi_direction direction,\n+\t\t\tbool skip_unreachable_blocks)\n+  : m_dom_direction (direction),\n+    m_skip_unreachable_blocks (skip_unreachable_blocks),\n+    m_unreachable_dom (NULL)\n+{\n+  /* If we are not skipping unreachable blocks, then there is nothing\n+     to do.  */\n+  if (!m_skip_unreachable_blocks)\n+    return;\n+\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->flags |= EDGE_EXECUTABLE;\n+    }\n+}\n+\n+/* Return TRUE if BB is reachable, false otherwise.  */\n+\n+bool\n+dom_walker::bb_reachable (struct function *fun, basic_block bb)\n+{\n+  /* If we're not skipping unreachable blocks, then assume everything\n+     is reachable.  */\n+  if (!m_skip_unreachable_blocks)\n+    return true;\n+\n+  /* If any of the predecessor edges that do not come from blocks dominated\n+     by us are still marked as possibly executable consider this block\n+     reachable.  */\n+  bool reachable = false;\n+  if (!m_unreachable_dom)\n+    {\n+      reachable = bb == ENTRY_BLOCK_PTR_FOR_FN (fun);\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t  reachable |= (e->flags & EDGE_EXECUTABLE);\n+    }\n+\n+  return reachable;\n+}\n+\n+/* BB has been determined to be unreachable.  Propagate that property\n+   to incoming and outgoing edges of BB as appropriate.  */\n+\n+void\n+dom_walker::propagate_unreachable_to_edges (basic_block bb,\n+\t\t\t\t\t    FILE *dump_file,\n+\t\t\t\t\t    int dump_flags)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Marking all outgoing edges of unreachable \"\n+\t     \"BB %d as not executable\\n\", bb->index);\n+\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    e->flags &= ~EDGE_EXECUTABLE;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Marking backedge from BB %d into \"\n+\t\t     \"unreachable BB %d as not executable\\n\",\n+\t\t     e->src->index, bb->index);\n+\t  e->flags &= ~EDGE_EXECUTABLE;\n+\t}\n+    }\n+\n+  if (!m_unreachable_dom)\n+    m_unreachable_dom = bb;\n+}\n+\n /* Recursively walk the dominator tree.\n    BB is the basic block we are currently visiting.  */\n \n@@ -171,9 +257,23 @@ dom_walker::walk (basic_block bb)\n \t  || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n+\n \t  /* Callback for subclasses to do custom things before we have walked\n \t     the dominator children, but before we walk statements.  */\n-\t  before_dom_children (bb);\n+\t  if (this->bb_reachable (cfun, bb))\n+\t    {\n+\t      edge taken_edge = before_dom_children (bb);\n+\t      if (taken_edge)\n+\t\t{\n+\t\t  edge_iterator ei;\n+\t\t  edge e;\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t    if (e != taken_edge)\n+\t\t      e->flags &= ~EDGE_EXECUTABLE;\n+\t\t}\n+\t    }\n+\t  else\n+\t    propagate_unreachable_to_edges (bb, dump_file, dump_flags);\n \n \t  /* Mark the current BB to be popped out of the recursion stack\n \t     once children are processed.  */\n@@ -203,7 +303,10 @@ dom_walker::walk (basic_block bb)\n \n \t  /* Callback allowing subclasses to do custom things after we have\n \t     walked dominator children, but before we walk statements.  */\n-\t  after_dom_children (bb);\n+\t  if (bb_reachable (cfun, bb))\n+\t    after_dom_children (bb);\n+\t  else if (m_unreachable_dom == bb)\n+\t    m_unreachable_dom = NULL;\n \t}\n       if (sp)\n \tbb = worklist[--sp];"}, {"sha": "e631a675155abba967ba2f296fa1b7b58d1aee79", "filename": "gcc/domwalk.h", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -30,13 +30,26 @@ along with GCC; see the file COPYING3.  If not see\n class dom_walker\n {\n public:\n-  dom_walker (cdi_direction direction) : m_dom_direction (direction) {}\n+  /* Use SKIP_UNREACHBLE_BLOCKS = true when your client can discover\n+     that some edges are not executable.\n+\n+     If a client can discover that a COND, SWITCH or GOTO has a static\n+     target in the before_dom_children callback, the taken edge should\n+     be returned.  The generic walker will clear EDGE_EXECUTABLE on all\n+     edges it can determine are not executable.  */\n+  dom_walker (cdi_direction direction, bool skip_unreachable_blocks = false);\n \n   /* Walk the dominator tree.  */\n   void walk (basic_block);\n \n-  /* Function to call before the recursive walk of the dominator children.  */\n-  virtual void before_dom_children (basic_block) {}\n+  /* Function to call before the recursive walk of the dominator children.\n+\n+     Return value is the always taken edge if the block has multiple outgoing\n+     edges, NULL otherwise.  When skipping unreachable blocks, the walker\n+     uses the taken edge information to clear EDGE_EXECUTABLE on the other\n+     edges, exposing unreachable blocks.  A NULL return value means all\n+     outgoing edges should still be considered executable.  */\n+  virtual edge before_dom_children (basic_block) { return NULL; }\n \n   /* Function to call after the recursive walk of the dominator children.  */\n   virtual void after_dom_children (basic_block) {}\n@@ -47,6 +60,18 @@ class dom_walker\n      if it is set to CDI_POST_DOMINATORS, then we walk the post\n      dominator tree.  */\n   const ENUM_BITFIELD (cdi_direction) m_dom_direction : 2;\n+  bool m_skip_unreachable_blocks;\n+  basic_block m_unreachable_dom;\n+\n+  /* Query whether or not the given block is reachable or not.  */\n+  bool bb_reachable (struct function *, basic_block);\n+\n+  /* Given an unreachable block, propagate that property to outgoing\n+     and possibly incoming edges for the block.  Typically called after\n+     determining a block is unreachable in the before_dom_children\n+     callback.  */\n+  void propagate_unreachable_to_edges (basic_block, FILE *, int);\n+\n };\n \n #endif"}, {"sha": "5f61130af5245fe270e7af160fe42a168ec6bb29", "filename": "gcc/fwprop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -208,11 +208,11 @@ class single_def_use_dom_walker : public dom_walker\n public:\n   single_def_use_dom_walker (cdi_direction direction)\n     : dom_walker (direction) {}\n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n };\n \n-void\n+edge\n single_def_use_dom_walker::before_dom_children (basic_block bb)\n {\n   int bb_index = bb->index;\n@@ -245,6 +245,8 @@ single_def_use_dom_walker::before_dom_children (basic_block bb)\n \n   process_uses (df_get_artificial_uses (bb_index), 0);\n   process_defs (df_get_artificial_defs (bb_index), 0);\n+\n+  return NULL;\n }\n \n /* Pop the definitions created in this basic block when leaving its"}, {"sha": "e184a1bcd6eb4b87fa262a4aafe9210050718245", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -1649,12 +1649,12 @@ class find_candidates_dom_walker : public dom_walker\n public:\n   find_candidates_dom_walker (cdi_direction direction)\n     : dom_walker (direction) {}\n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n };\n \n /* Find strength-reduction candidates in block BB.  */\n \n-void\n+edge\n find_candidates_dom_walker::before_dom_children (basic_block bb)\n {\n   bool speed = optimize_bb_for_speed_p (bb);\n@@ -1737,6 +1737,7 @@ find_candidates_dom_walker::before_dom_children (basic_block bb)\n \t    }\n \t}\n     }\n+  return NULL;\n }\n \f\n /* Dump a candidate for debug.  */"}, {"sha": "f96bf970ee10cfca3654751e83cb4d2cbe4b7e16", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -2245,17 +2245,18 @@ class analysis_dom_walker : public dom_walker\n   analysis_dom_walker (struct ipa_func_body_info *fbi)\n     : dom_walker (CDI_DOMINATORS), m_fbi (fbi) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n \n private:\n   struct ipa_func_body_info *m_fbi;\n };\n \n-void\n+edge\n analysis_dom_walker::before_dom_children (basic_block bb)\n {\n   ipa_analyze_params_uses_in_bb (m_fbi, bb);\n   ipa_compute_jump_functions_for_bb (m_fbi, bb);\n+  return NULL;\n }\n \n /* Release body info FBI.  */\n@@ -5098,7 +5099,7 @@ class ipcp_modif_dom_walker : public dom_walker\n     : dom_walker (CDI_DOMINATORS), m_fbi (fbi), m_descriptors (descs),\n       m_aggval (av), m_something_changed (sc), m_cfg_changed (cc) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n \n private:\n   struct ipa_func_body_info *m_fbi;\n@@ -5107,7 +5108,7 @@ class ipcp_modif_dom_walker : public dom_walker\n   bool *m_something_changed, *m_cfg_changed;\n };\n \n-void\n+edge\n ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -5198,7 +5199,7 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n \t  && gimple_purge_dead_eh_edges (gimple_bb (stmt)))\n \t*m_cfg_changed = true;\n     }\n-\n+  return NULL;\n }\n \n /* Update alignment of formal parameters as described in"}, {"sha": "6bcacab080e047bf92408960e8f53fda1b0ef7b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -1,3 +1,12 @@\n+2015-12-10  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/68619\n+\t* gcc.dg/tree-ssa/pr68619-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr68619-2.c: New test.\n+\t* gcc.dg/tree-ssa/pr68619-3.c: New test.\n+\t* gcc.dg/tree-ssa/pr68619-4.c: New test.\n+\t* gcc.dg/tree-ssa/pr68619-5.c: New test.\n+\n 2015-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/68376"}, {"sha": "3e988de9fa54b89d499f90342765aee90fff322c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68619-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-1.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -w\" } */\n+\n+extern void fn2(int);\n+int a, b, c;\n+void fn1() {\n+  int d;\n+  for (; b; b++) {\n+    a = 7;\n+    for (; a;) {\n+    jump:\n+      fn2(d ?: c);\n+      d = 0;\n+    }\n+    d = c;\n+    if (c)\n+      goto jump;\n+  }\n+  goto jump;\n+}"}, {"sha": "cca706e0c4f4d81ddb2eb423ec8cf59dcd354316", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68619-2.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-2.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom2-details -w\" } */\n+\n+typedef union tree_node *tree;\n+struct gcc_options\n+{\n+  int x_flag_finite_math_only;\n+};\n+extern struct gcc_options global_options;\n+enum mode_class\n+{ MODE_RANDOM, MODE_CC, MODE_INT, MODE_PARTIAL_INT, MODE_FRACT, MODE_UFRACT,\n+  MODE_ACCUM, MODE_UACCUM, MODE_FLOAT, MODE_DECIMAL_FLOAT, MODE_COMPLEX_INT,\n+  MODE_COMPLEX_FLOAT, MODE_VECTOR_INT, MODE_VECTOR_FRACT,\n+  MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM,\n+  MODE_VECTOR_FLOAT, MAX_MODE_CLASS\n+};\n+extern const unsigned char mode_class[27];\n+extern const unsigned char mode_inner[27];\n+struct real_value\n+{\n+};\n+struct real_format\n+{\n+  unsigned char has_inf;\n+};\n+extern const struct real_format *real_format_for_mode[5 -\n+\t\t\t\t\t\t      2 + 1 + 15 - 10 + 1];\n+struct tree_type\n+{\n+};\n+union tree_node\n+{\n+  int code;\n+  int mode;\n+  struct tree_type type;\n+};\n+tree\n+omp_reduction_init (tree clause, tree type)\n+{\n+  if ((((type)->code) == 64))\n+    {\n+      struct real_value max;\n+      if (((((mode_class[((((type))->code) ==\n+\t\t\t  32 ?\n+\t\t\t  vector_type_mode (type)\n+\t\t\t  : (type)->mode)]) ==\n+\t     MODE_VECTOR_FLOAT)\n+\t    &&\n+\t    ((real_format_for_mode\n+\t      [((mode_class[((mode_class[((((type))->code) ==\n+\t\t\t\t\t  32 ?\n+\t\t\t\t\t  vector_type_mode (type)\n+\t\t\t\t\t  : (type)->mode)]) ==\n+\t\t\t     12) ? (((((type))->code)\n+\t\t\t\t     ==\n+\t\t\t\t     32 ?\n+\t\t\t\t     vector_type_mode\n+\t\t\t\t     (type)\n+\t\t\t\t     : (type)->mode))\n+\t\t\t    : (mode_inner[((((type))->code) ==\n+\t\t\t\t\t   32 ?\n+\t\t\t\t\t   vector_type_mode (type)\n+\t\t\t\t\t   : (type)->mode)])]) ==\n+\t\t12)\n+\t       ? (((((mode_class[((((type))->code) ==\n+\t\t\t\t  32 ? vector_type_mode (type)\n+\t\t\t\t  : (type)->mode)]) ==\n+\t\t     12) ? (((((type))->code) ==\n+\t\t\t     32 ?\n+\t\t\t     vector_type_mode (type)\n+\t\t\t     : (type)->mode)) : (mode_inner\n+\t\t\t\t\t\t [((((type))->code) ==\n+\t\t\t\t\t\t   32 ?\n+\t\t\t\t\t\t   vector_type_mode (type)\n+\t\t\t\t\t\t   : (type)->mode)])) - 10) +\n+\t\t  (5 - 2 +\n+\t\t   1))\n+\t       : ((((mode_class\n+\t\t     [((((type))->code) ==\n+\t\t       32 ? vector_type_mode (type) : (type)->mode)]) ==\n+\t\t    12) ? (((((type))->code) ==\n+\t\t\t    32 ? vector_type_mode (type) : (type)->\n+\t\t\t    mode)) : (mode_inner[((((type))->code) ==\n+\t\t\t\t\t\t  32 ? vector_type_mode (type)\n+\t\t\t\t\t\t  : (type)->mode)])) -\n+\t\t  2)]))->has_inf) && !global_options.x_flag_finite_math_only))\n+\treal_inf (&max);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Marking all outgoing edges of unreachable\" \"dom2\"} } */\n+"}, {"sha": "354872595fb0f1e16ab4038f8cb7c6f271d9d648", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68619-3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-3.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -w\" } */\n+typedef unsigned int hashval_t;\n+enum ETYPE\n+{\n+  ETYPE_ARRAY, ETYPE_STRUCT, ETYPE_UNION,\n+};\n+struct entry\n+{\n+  enum ETYPE etype:8;\n+  unsigned short len;\n+  const char *attrib;\n+};\n+e_hash (const void *a)\n+{\n+  const struct entry *e = a;\n+  hashval_t ret = 0;\n+  int i;\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+  for (i = 0; i <= e[0].len; ++i)\n+    {\n+      ret = iterative_hash (&e[i], __builtin_offsetof (struct entry, attrib), ret);\n+    }\n+  return ret;\n+}"}, {"sha": "da3cdb9a52434038c7398f95cdc4b64c2ec85ac6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68619-4.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-4.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -w\" } */\n+\n+typedef struct rtx_def *rtx;\n+enum rtx_code\n+{\n+  UNKNOWN, VALUE, DEBUG_EXPR, EXPR_LIST, INSN_LIST, SEQUENCE, ADDRESS,\n+  DEBUG_INSN, INSN, JUMP_INSN, CALL_INSN, BARRIER, CODE_LABEL, NOTE,\n+  COND_EXEC, PARALLEL, ASM_INPUT, ASM_OPERANDS, UNSPEC, UNSPEC_VOLATILE,\n+  ADDR_VEC, ADDR_DIFF_VEC, PREFETCH, SET, USE, CLOBBER, CALL, RETURN,\n+  EH_RETURN, TRAP_IF, CONST_INT, CONST_FIXED, CONST_DOUBLE, CONST_VECTOR,\n+  CONST_STRING, CONST, PC, REG, SCRATCH, SUBREG, STRICT_LOW_PART, CONCAT,\n+  CONCATN, MEM, LABEL_REF, SYMBOL_REF, CC0, IF_THEN_ELSE, COMPARE, PLUS,\n+  MINUS, NEG, MULT, SS_MULT, US_MULT, DIV, SS_DIV, US_DIV, MOD, UDIV, UMOD,\n+  AND, IOR, XOR, NOT, ASHIFT, ROTATE, ASHIFTRT, LSHIFTRT, ROTATERT, SMIN,\n+  SMAX, UMIN, UMAX, PRE_DEC, PRE_INC, POST_DEC, POST_INC, PRE_MODIFY,\n+  POST_MODIFY, NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU, UNORDERED,\n+  ORDERED, UNEQ, UNGE, UNGT, UNLE, UNLT, LTGT, SIGN_EXTEND, ZERO_EXTEND,\n+  TRUNCATE, FLOAT_EXTEND, FLOAT_TRUNCATE, FLOAT, FIX, UNSIGNED_FLOAT,\n+  UNSIGNED_FIX, FRACT_CONVERT, UNSIGNED_FRACT_CONVERT, SAT_FRACT,\n+  UNSIGNED_SAT_FRACT, ABS, SQRT, BSWAP, FFS, CLZ, CTZ, POPCOUNT, PARITY,\n+  SIGN_EXTRACT, ZERO_EXTRACT, HIGH, LO_SUM, VEC_MERGE, VEC_SELECT,\n+  VEC_CONCAT, VEC_DUPLICATE, SS_PLUS, US_PLUS, SS_MINUS, SS_NEG, US_NEG,\n+  SS_ABS, SS_ASHIFT, US_ASHIFT, US_MINUS, SS_TRUNCATE, US_TRUNCATE, FMA,\n+  VAR_LOCATION, DEBUG_IMPLICIT_PTR, ENTRY_VALUE, LAST_AND_UNUSED_RTX_CODE\n+};\n+enum rtx_class\n+{\n+  RTX_COMPARE, RTX_COMM_COMPARE, RTX_BIN_ARITH, RTX_COMM_ARITH, RTX_UNARY,\n+  RTX_EXTRA, RTX_MATCH, RTX_INSN, RTX_OBJ, RTX_CONST_OBJ, RTX_TERNARY,\n+  RTX_BITFIELD_OPS, RTX_AUTOINC\n+};\n+extern const unsigned char rtx_length[((int) LAST_AND_UNUSED_RTX_CODE)];\n+extern const enum rtx_class rtx_class[((int) LAST_AND_UNUSED_RTX_CODE)];\n+union rtunion_def\n+{\n+  rtx rt_rtx;\n+};\n+typedef union rtunion_def rtunion;\n+struct rtx_def\n+{\n+  enum rtx_code code:16;\n+  union u\n+  {\n+    rtunion fld[1];\n+  }\n+  u;\n+};\n+struct cse_reg_info\n+{\n+  unsigned int timestamp;\n+  int reg_qty;\n+  int reg_tick;\n+  int reg_in_table;\n+  unsigned int subreg_ticked;\n+};\n+static struct cse_reg_info *cse_reg_info_table;\n+static unsigned int cse_reg_info_timestamp;\n+\n+static __inline__ struct cse_reg_info *\n+get_cse_reg_info (unsigned int regno)\n+{\n+  struct cse_reg_info *p = &cse_reg_info_table[regno];\n+  if (p->timestamp != cse_reg_info_timestamp)\n+    cse_reg_info_table[regno].timestamp = cse_reg_info_timestamp;\n+}\n+\n+int\n+mention_regs (rtx x)\n+{\n+  enum rtx_code code;\n+  int i, j;\n+  const char *fmt;\n+  int changed = 0;\n+  code = ((x)->code);\n+  if (code == SUBREG\n+      && ((((((x)->u.fld[0]).rt_rtx))->code) == REG))\n+    {\n+      (get_cse_reg_info (i)->reg_in_table) = (get_cse_reg_info (i)->reg_tick);\n+      (get_cse_reg_info (i)->subreg_ticked) =\n+\t(rhs_regno ((((x)->u.fld[0]).rt_rtx)));\n+    }\n+  if ((((rtx_class[(int) (((x)->code))]) & (~1)) == (RTX_COMPARE & (~1))))\n+    {\n+      if (((((((x)->u.fld[0]).rt_rtx))->code) == REG))\n+\tfoop ();\n+    }\n+  for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)\n+\tarf ();\n+}\n+\n+/* Make sure the constant 39 gets propagated into the PHI at the join point.  */\n+/* { dg-final { scan-tree-dump \"PHI <.*, 39\" \"optimized\"} } */\n+"}, {"sha": "7eee1b8877ddaf70213ee4c3101350bb93e5e267", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68619-5.c", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-5.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -0,0 +1,172 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -w\" } */\n+typedef union tree_node *tree;\n+typedef union gimple_statement_d *gimple;\n+enum machine_mode\n+{ VOIDmode, BLKmode, CCmode, CCGCmode, CCGOCmode, CCNOmode, CCAmode, CCCmode,\n+    CCOmode, CCSmode, CCZmode, CCFPmode, CCFPUmode, BImode, QImode, HImode,\n+    SImode, DImode, TImode, OImode, QQmode, HQmode, SQmode, DQmode, TQmode,\n+    UQQmode, UHQmode, USQmode, UDQmode, UTQmode, HAmode, SAmode, DAmode,\n+    TAmode, UHAmode, USAmode, UDAmode, UTAmode, SFmode, DFmode, XFmode,\n+    TFmode, SDmode, DDmode, TDmode, CQImode, CHImode, CSImode, CDImode,\n+    CTImode, COImode, SCmode, DCmode, XCmode, TCmode, V2QImode, V4QImode,\n+    V2HImode, V1SImode, V8QImode, V4HImode, V2SImode, V1DImode, V16QImode,\n+    V8HImode, V4SImode, V2DImode, V1TImode, V32QImode, V16HImode, V8SImode,\n+    V4DImode, V2TImode, V64QImode, V32HImode, V16SImode, V8DImode, V4TImode,\n+    V2SFmode, V4SFmode, V2DFmode, V8SFmode, V4DFmode, V2TFmode, V16SFmode,\n+    V8DFmode, V4TFmode, MAX_MACHINE_MODE, MIN_MODE_RANDOM =\n+    VOIDmode, MAX_MODE_RANDOM = BLKmode, MIN_MODE_CC = CCmode, MAX_MODE_CC =\n+    CCFPUmode, MIN_MODE_INT = QImode, MAX_MODE_INT =\n+    OImode, MIN_MODE_PARTIAL_INT = VOIDmode, MAX_MODE_PARTIAL_INT =\n+    VOIDmode, MIN_MODE_FRACT = QQmode, MAX_MODE_FRACT =\n+    TQmode, MIN_MODE_UFRACT = UQQmode, MAX_MODE_UFRACT =\n+    UTQmode, MIN_MODE_ACCUM = HAmode, MAX_MODE_ACCUM =\n+    TAmode, MIN_MODE_UACCUM = UHAmode, MAX_MODE_UACCUM =\n+    UTAmode, MIN_MODE_FLOAT = SFmode, MAX_MODE_FLOAT =\n+    TFmode, MIN_MODE_DECIMAL_FLOAT = SDmode, MAX_MODE_DECIMAL_FLOAT =\n+    TDmode, MIN_MODE_COMPLEX_INT = CQImode, MAX_MODE_COMPLEX_INT =\n+    COImode, MIN_MODE_COMPLEX_FLOAT = SCmode, MAX_MODE_COMPLEX_FLOAT =\n+    TCmode, MIN_MODE_VECTOR_INT = V2QImode, MAX_MODE_VECTOR_INT =\n+    V4TImode, MIN_MODE_VECTOR_FRACT = VOIDmode, MAX_MODE_VECTOR_FRACT =\n+    VOIDmode, MIN_MODE_VECTOR_UFRACT = VOIDmode, MAX_MODE_VECTOR_UFRACT =\n+    VOIDmode, MIN_MODE_VECTOR_ACCUM = VOIDmode, MAX_MODE_VECTOR_ACCUM =\n+    VOIDmode, MIN_MODE_VECTOR_UACCUM = VOIDmode, MAX_MODE_VECTOR_UACCUM =\n+    VOIDmode, MIN_MODE_VECTOR_FLOAT = V2SFmode, MAX_MODE_VECTOR_FLOAT =\n+    V4TFmode, NUM_MACHINE_MODES = MAX_MACHINE_MODE };\n+enum mode_class\n+{ MODE_RANDOM, MODE_CC, MODE_INT, MODE_PARTIAL_INT, MODE_FRACT, MODE_UFRACT,\n+    MODE_ACCUM, MODE_UACCUM, MODE_FLOAT, MODE_DECIMAL_FLOAT, MODE_COMPLEX_INT,\n+    MODE_COMPLEX_FLOAT, MODE_VECTOR_INT, MODE_VECTOR_FRACT,\n+    MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM,\n+    MODE_VECTOR_FLOAT, MAX_MODE_CLASS };\n+extern const unsigned char mode_class[NUM_MACHINE_MODES];\n+extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n+struct real_format\n+{\n+  unsigned char has_nans;\n+};\n+extern const struct real_format *real_format_for_mode[MAX_MODE_FLOAT -\n+\t\t\t\t\t\t      MIN_MODE_FLOAT + 1 +\n+\t\t\t\t\t\t      MAX_MODE_DECIMAL_FLOAT -\n+\t\t\t\t\t\t      MIN_MODE_DECIMAL_FLOAT +\n+\t\t\t\t\t\t      1];\n+enum tree_code\n+{ ERROR_MARK, IDENTIFIER_NODE, TREE_LIST, TREE_VEC, BLOCK, OFFSET_TYPE,\n+    ENUMERAL_TYPE, BOOLEAN_TYPE, INTEGER_TYPE, REAL_TYPE, POINTER_TYPE,\n+    REFERENCE_TYPE, NULLPTR_TYPE, FIXED_POINT_TYPE, COMPLEX_TYPE, VECTOR_TYPE,\n+    ARRAY_TYPE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, VOID_TYPE,\n+    FUNCTION_TYPE, METHOD_TYPE, LANG_TYPE, INTEGER_CST, REAL_CST, FIXED_CST,\n+    COMPLEX_CST, VECTOR_CST, STRING_CST, FUNCTION_DECL, LABEL_DECL,\n+    FIELD_DECL, VAR_DECL, CONST_DECL, PARM_DECL, TYPE_DECL, RESULT_DECL,\n+    DEBUG_EXPR_DECL, NAMESPACE_DECL, IMPORTED_DECL, TRANSLATION_UNIT_DECL,\n+    COMPONENT_REF, BIT_FIELD_REF, REALPART_EXPR, IMAGPART_EXPR, ARRAY_REF,\n+    ARRAY_RANGE_REF, INDIRECT_REF, OBJ_TYPE_REF, CONSTRUCTOR, COMPOUND_EXPR,\n+    MODIFY_EXPR, INIT_EXPR, TARGET_EXPR, COND_EXPR, VEC_COND_EXPR, BIND_EXPR,\n+    CALL_EXPR, WITH_CLEANUP_EXPR, CLEANUP_POINT_EXPR, PLACEHOLDER_EXPR,\n+    PLUS_EXPR, MINUS_EXPR, MULT_EXPR, POINTER_PLUS_EXPR, TRUNC_DIV_EXPR,\n+    CEIL_DIV_EXPR, FLOOR_DIV_EXPR, ROUND_DIV_EXPR, TRUNC_MOD_EXPR,\n+    CEIL_MOD_EXPR, FLOOR_MOD_EXPR, ROUND_MOD_EXPR, RDIV_EXPR, EXACT_DIV_EXPR,\n+    FIX_TRUNC_EXPR, FLOAT_EXPR, NEGATE_EXPR, MIN_EXPR, MAX_EXPR, ABS_EXPR,\n+    LSHIFT_EXPR, RSHIFT_EXPR, LROTATE_EXPR, RROTATE_EXPR, BIT_IOR_EXPR,\n+    BIT_XOR_EXPR, BIT_AND_EXPR, BIT_NOT_EXPR, TRUTH_ANDIF_EXPR,\n+    TRUTH_ORIF_EXPR, TRUTH_AND_EXPR, TRUTH_OR_EXPR, TRUTH_XOR_EXPR,\n+    TRUTH_NOT_EXPR, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EQ_EXPR, NE_EXPR,\n+    UNORDERED_EXPR, ORDERED_EXPR, UNLT_EXPR, UNLE_EXPR, UNGT_EXPR, UNGE_EXPR,\n+    UNEQ_EXPR, LTGT_EXPR, RANGE_EXPR, PAREN_EXPR, CONVERT_EXPR,\n+    ADDR_SPACE_CONVERT_EXPR, FIXED_CONVERT_EXPR, NOP_EXPR, NON_LVALUE_EXPR,\n+    VIEW_CONVERT_EXPR, COMPOUND_LITERAL_EXPR, SAVE_EXPR, ADDR_EXPR,\n+    FDESC_EXPR, COMPLEX_EXPR, CONJ_EXPR, PREDECREMENT_EXPR, PREINCREMENT_EXPR,\n+    POSTDECREMENT_EXPR, POSTINCREMENT_EXPR, VA_ARG_EXPR, TRY_CATCH_EXPR,\n+    TRY_FINALLY_EXPR, DECL_EXPR, LABEL_EXPR, GOTO_EXPR, RETURN_EXPR,\n+    EXIT_EXPR, LOOP_EXPR, SWITCH_EXPR, CASE_LABEL_EXPR, ASM_EXPR, SSA_NAME,\n+    CATCH_EXPR, EH_FILTER_EXPR, SCEV_KNOWN, SCEV_NOT_KNOWN, POLYNOMIAL_CHREC,\n+    STATEMENT_LIST, ASSERT_EXPR, TREE_BINFO, WITH_SIZE_EXPR,\n+    REALIGN_LOAD_EXPR, TARGET_MEM_REF, MEM_REF, OMP_PARALLEL, OMP_TASK,\n+    OMP_FOR, OMP_SECTIONS, OMP_SINGLE, OMP_SECTION, OMP_MASTER, OMP_ORDERED,\n+    OMP_CRITICAL, OMP_ATOMIC, OMP_CLAUSE, REDUC_MAX_EXPR, REDUC_MIN_EXPR,\n+    REDUC_PLUS_EXPR, DOT_PROD_EXPR, WIDEN_SUM_EXPR, WIDEN_MULT_EXPR,\n+    WIDEN_MULT_PLUS_EXPR, WIDEN_MULT_MINUS_EXPR, FMA_EXPR, VEC_LSHIFT_EXPR,\n+    VEC_RSHIFT_EXPR, VEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_LO_EXPR,\n+    VEC_UNPACK_HI_EXPR, VEC_UNPACK_LO_EXPR, VEC_UNPACK_FLOAT_HI_EXPR,\n+    VEC_UNPACK_FLOAT_LO_EXPR, VEC_PACK_TRUNC_EXPR, VEC_PACK_SAT_EXPR,\n+    VEC_PACK_FIX_TRUNC_EXPR, VEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR,\n+    VEC_INTERLEAVE_HIGH_EXPR, VEC_INTERLEAVE_LOW_EXPR, PREDICT_EXPR,\n+    OPTIMIZATION_NODE, TARGET_OPTION_NODE, LAST_AND_UNUSED_TREE_CODE,\n+    C_MAYBE_CONST_EXPR, EXCESS_PRECISION_EXPR, UNCONSTRAINED_ARRAY_TYPE,\n+    UNCONSTRAINED_ARRAY_REF, NULL_EXPR, PLUS_NOMOD_EXPR, MINUS_NOMOD_EXPR,\n+    ATTR_ADDR_EXPR, STMT_STMT, LOOP_STMT, EXIT_STMT, OFFSET_REF, PTRMEM_CST,\n+    NEW_EXPR, VEC_NEW_EXPR, DELETE_EXPR, VEC_DELETE_EXPR, SCOPE_REF,\n+    MEMBER_REF, TYPE_EXPR, AGGR_INIT_EXPR, VEC_INIT_EXPR, THROW_EXPR,\n+    EMPTY_CLASS_EXPR, BASELINK, TEMPLATE_DECL, TEMPLATE_PARM_INDEX,\n+    TEMPLATE_TEMPLATE_PARM, TEMPLATE_TYPE_PARM, TYPENAME_TYPE, TYPEOF_TYPE,\n+    BOUND_TEMPLATE_TEMPLATE_PARM, UNBOUND_CLASS_TEMPLATE, USING_DECL,\n+    USING_STMT, DEFAULT_ARG, TEMPLATE_ID_EXPR, OVERLOAD, PSEUDO_DTOR_EXPR,\n+    MODOP_EXPR, CAST_EXPR, REINTERPRET_CAST_EXPR, CONST_CAST_EXPR,\n+    STATIC_CAST_EXPR, DYNAMIC_CAST_EXPR, DOTSTAR_EXPR, TYPEID_EXPR,\n+    NOEXCEPT_EXPR, NON_DEPENDENT_EXPR, CTOR_INITIALIZER, TRY_BLOCK,\n+    EH_SPEC_BLOCK, HANDLER, MUST_NOT_THROW_EXPR, CLEANUP_STMT, IF_STMT,\n+    FOR_STMT, RANGE_FOR_STMT, WHILE_STMT, DO_STMT, BREAK_STMT, CONTINUE_STMT,\n+    SWITCH_STMT, EXPR_STMT, TAG_DEFN, OFFSETOF_EXPR, SIZEOF_EXPR, ARROW_EXPR,\n+    ALIGNOF_EXPR, AT_ENCODE_EXPR, STMT_EXPR, UNARY_PLUS_EXPR, STATIC_ASSERT,\n+    TYPE_ARGUMENT_PACK, NONTYPE_ARGUMENT_PACK, TYPE_PACK_EXPANSION,\n+    EXPR_PACK_EXPANSION, ARGUMENT_PACK_SELECT, TRAIT_EXPR, LAMBDA_EXPR,\n+    DECLTYPE_TYPE, TEMPLATE_INFO, URSHIFT_EXPR, COMPARE_EXPR, COMPARE_L_EXPR,\n+    COMPARE_G_EXPR, CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n+    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,\n+    PROTOCOL_INTERFACE_TYPE, KEYWORD_DECL, INSTANCE_METHOD_DECL,\n+    CLASS_METHOD_DECL, PROPERTY_DECL, MESSAGE_SEND_EXPR, CLASS_REFERENCE_EXPR,\n+    PROPERTY_REF, MAX_TREE_CODES };\n+struct tree_base\n+{\n+  enum tree_code code:16;\n+};\n+struct tree_typed\n+{\n+  tree type;\n+};\n+struct tree_type\n+{\n+  enum machine_mode mode:8;\n+};\n+union tree_node\n+{\n+  struct tree_base base;\n+  struct tree_typed typed;\n+  struct tree_type type;\n+};\n+enum tree_code\n+parse_predicate (tree cond, tree * op0, tree * op1)\n+{\n+  gimple s;\n+  tree op;\n+  tree type = (*(&op->typed.type));\n+  enum tree_code code;\n+  return invert_tree_comparison (code,\n+\t\t\t\t ((((mode_class\n+\t\t\t\t     [((((type))->base.code) ==\n+\t\t\t\t       VECTOR_TYPE ? vector_type_mode (type)\n+\t\t\t\t       : (type)->type.mode)]) ==\n+\t\t\t\t    MODE_VECTOR_FLOAT)\n+\t\t\t\t   &&\n+\t\t\t\t   ((real_format_for_mode\n+\t\t\t\t     [(((enum mode_class)\n+\t\t\t\t\tmode_class[(((enum mode_class)\n+\t\t\t\t\t\t     mode_class[((((type))->\n+\t\t\t\t\t\t\t\t  base.\n+\t\t\t\t\t\t\t\t  code) ==\n+\t\t\t\t\t\t\t\t VECTOR_TYPE ?\n+\t\t\t\t\t\t\t\t vector_type_mode\n+\t\t\t\t\t\t\t\t (type)\n+\t\t\t\t\t\t\t\t : (type)->\n+\t\t\t\t\t\t\t\t type.\n+\t\t\t\t\t\t\t\t mode)]) ==\n+\t\t\t\t\t\t    MODE_DECIMAL_FLOAT)\n+\t\t\t\t\t\t   ? (((((type))->base.\n+\t\t\t\t\t\t\tcode) ==\n+\t\t\t\t\t\t       VECTOR_TYPE ?\n+\t\t\t\t\t\t       vector_type_mode (type)\n+\t\t\t\t\t\t       : (type)->type.\n+\t\t\t\t\t\t       mode)) : ((enum\n+\t\t\t\t\t\t\t\t  machine_mode)\n+\t\t\t\t\t\t\t\t mode_inner[((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)])]) == MODE_DECIMAL_FLOAT) ? ((((((enum mode_class) mode_class[((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)]) == MODE_DECIMAL_FLOAT) ? (((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)) : ((enum machine_mode) mode_inner[((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)])) - MIN_MODE_DECIMAL_FLOAT) + (MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1)) : (((((enum mode_class) mode_class[((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)]) == MODE_DECIMAL_FLOAT) ? (((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)) : ((enum machine_mode) mode_inner[((((type))->base.code) == VECTOR_TYPE ? vector_type_mode (type) : (type)->type.mode)])) - MIN_MODE_FLOAT)]))->has_nans)  ));\n+}"}, {"sha": "5486d5c8609c466f73189886b1d9b921a2b97559", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -1391,7 +1391,7 @@ class rewrite_dom_walker : public dom_walker\n public:\n   rewrite_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n };\n \n@@ -1400,7 +1400,7 @@ class rewrite_dom_walker : public dom_walker\n    (BLOCK_DEFS).  Register new definitions for every PHI node in the\n    block.  */\n \n-void\n+edge\n rewrite_dom_walker::before_dom_children (basic_block bb)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1432,6 +1432,8 @@ rewrite_dom_walker::before_dom_children (basic_block bb)\n      reaching definition for the variable and the edge through which that\n      definition is reaching the PHI node.  */\n   rewrite_add_phi_arguments (bb);\n+\n+  return NULL;\n }\n \n \n@@ -2055,7 +2057,7 @@ class rewrite_update_dom_walker : public dom_walker\n public:\n   rewrite_update_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n };\n \n@@ -2064,7 +2066,7 @@ class rewrite_update_dom_walker : public dom_walker\n    for new SSA names produced in this block (BLOCK_DEFS).  Register\n    new definitions for every PHI node in the block.  */\n \n-void\n+edge\n rewrite_update_dom_walker::before_dom_children (basic_block bb)\n {\n   bool is_abnormal_phi;\n@@ -2077,7 +2079,7 @@ rewrite_update_dom_walker::before_dom_children (basic_block bb)\n   block_defs_stack.safe_push (NULL_TREE);\n \n   if (!bitmap_bit_p (blocks_to_update, bb->index))\n-    return;\n+    return NULL;\n \n   /* Mark the LHS if any of the arguments flows through an abnormal\n      edge.  */\n@@ -2133,6 +2135,8 @@ rewrite_update_dom_walker::before_dom_children (basic_block bb)\n \n   /* Step 3.  Update PHI nodes.  */\n   rewrite_update_phi_arguments (bb);\n+\n+  return NULL;\n }\n \n /* Called after visiting block BB.  Unwind BLOCK_DEFS_STACK to restore\n@@ -2210,7 +2214,7 @@ class mark_def_dom_walker : public dom_walker\n   mark_def_dom_walker (cdi_direction direction);\n   ~mark_def_dom_walker ();\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n \n private:\n   /* Notice that this bitmap is indexed using variable UIDs, so it must be\n@@ -2232,14 +2236,15 @@ mark_def_dom_walker::~mark_def_dom_walker ()\n /* Block processing routine for mark_def_sites.  Clear the KILLS bitmap\n    at the start of each block, and call mark_def_sites for each statement.  */\n \n-void\n+edge\n mark_def_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n   bitmap_clear (m_kills);\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     mark_def_sites (bb, gsi_stmt (gsi), m_kills);\n+  return NULL;\n }\n \n /* Initialize internal data needed during renaming.  */"}, {"sha": "88fc517900c5653a6174c2ea4c31fb07b78e4d87", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -99,7 +99,7 @@ struct opt_stats_d\n static struct opt_stats_d opt_stats;\n \n /* Local functions.  */\n-static void optimize_stmt (basic_block, gimple_stmt_iterator,\n+static edge optimize_stmt (basic_block, gimple_stmt_iterator,\n \t\t\t   class const_and_copies *,\n \t\t\t   class avail_exprs_stack *);\n static tree lookup_avail_expr (gimple *, bool, class avail_exprs_stack *);\n@@ -493,12 +493,12 @@ class dom_opt_dom_walker : public dom_walker\n   dom_opt_dom_walker (cdi_direction direction,\n \t\t      class const_and_copies *const_and_copies,\n \t\t      class avail_exprs_stack *avail_exprs_stack)\n-    : dom_walker (direction),\n+    : dom_walker (direction, true),\n       m_const_and_copies (const_and_copies),\n       m_avail_exprs_stack (avail_exprs_stack),\n       m_dummy_cond (NULL) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n private:\n@@ -611,6 +611,36 @@ pass_dominator::execute (function *fun)\n \t\t\t     avail_exprs_stack);\n   walker.walk (fun->cfg->x_entry_block_ptr);\n \n+  /* Look for blocks where we cleared EDGE_EXECUTABLE on an outgoing\n+     edge.  When found, remove jump threads which contain any outgoing\n+     edge from the affected block.  */\n+  if (cfg_altered)\n+    {\n+      FOR_EACH_BB_FN (bb, fun)\n+\t{\n+\t  edge_iterator ei;\n+\t  edge e;\n+\n+\t  /* First see if there are any edges without EDGE_EXECUTABLE\n+\t     set.  */\n+\t  bool found = false;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if ((e->flags & EDGE_EXECUTABLE) == 0)\n+\t\t{\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* If there were any such edges found, then remove jump threads\n+\t     containing any edge leaving BB.  */\n+\t  if (found)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n+\t      remove_jump_threads_including (e);\n+\t}\n+    }\n+\n   {\n     gimple_stmt_iterator gsi;\n     basic_block bb;\n@@ -951,6 +981,11 @@ record_equivalences_from_phis (basic_block bb)\n \t  if (lhs == t)\n \t    continue;\n \n+\t  /* If the associated edge is not marked as executable, then it\n+\t     can be ignored.  */\n+\t  if ((gimple_phi_arg_edge (phi, i)->flags & EDGE_EXECUTABLE) == 0)\n+\t    continue;\n+\n \t  t = dom_valueize (t);\n \n \t  /* If we have not processed an alternative yet, then set\n@@ -997,6 +1032,10 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n       if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n \tcontinue;\n \n+      /* We can safely ignore edges that are not executable.  */\n+      if ((e->flags & EDGE_EXECUTABLE) == 0)\n+\tcontinue;\n+\n       /* If we have already seen a non-loop edge, then we must have\n \t multiple incoming non-loop edges and thus we return NULL.  */\n       if (retval)\n@@ -1294,7 +1333,7 @@ cprop_into_successor_phis (basic_block bb,\n     }\n }\n \n-void\n+edge\n dom_opt_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -1322,12 +1361,15 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \t\t\t\t      m_avail_exprs_stack);\n   m_avail_exprs_stack->pop_to_marker ();\n \n+  edge taken_edge = NULL;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    optimize_stmt (bb, gsi, m_const_and_copies, m_avail_exprs_stack);\n+    taken_edge\n+      = optimize_stmt (bb, gsi, m_const_and_copies, m_avail_exprs_stack);\n \n   /* Now prepare to process dominated blocks.  */\n   record_edge_info (bb);\n   cprop_into_successor_phis (bb, m_const_and_copies);\n+  return taken_edge;\n }\n \n /* We have finished processing the dominator children of BB, perform\n@@ -1694,7 +1736,7 @@ cprop_into_stmt (gimple *stmt)\n       assignment is found, we map the value on the RHS of the assignment to\n       the variable in the LHS in the CONST_AND_COPIES table.  */\n \n-static void\n+static edge\n optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t       class const_and_copies *const_and_copies,\n \t       class avail_exprs_stack *avail_exprs_stack)\n@@ -1703,6 +1745,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n   bool may_optimize_p;\n   bool modified_p = false;\n   bool was_noreturn;\n+  edge retval = NULL;\n \n   old_stmt = stmt = gsi_stmt (si);\n   was_noreturn = is_gimple_call (stmt) && gimple_call_noreturn_p (stmt);\n@@ -1823,7 +1866,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t\t    fprintf (dump_file, \"  Flagged to clear EH edges.\\n\");\n \t\t}\n \t      release_defs (stmt);\n-\t      return;\n+\t      return retval;\n \t    }\n \t}\n     }\n@@ -1849,25 +1892,19 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \n       if (val && TREE_CODE (val) == INTEGER_CST)\n \t{\n-\t  edge taken_edge = find_taken_edge (bb, val);\n-\t  if (taken_edge)\n+\t  retval = find_taken_edge (bb, val);\n+\t  if (retval)\n \t    {\n-\n-\t      /* We need to remove any queued jump threads that\n-\t\t reference outgoing edges from this block.  */\n-\t      edge_iterator ei;\n-\t      edge e;\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tremove_jump_threads_including (e);\n-\n-\t      /* Now clean up the control statement at the end of\n-\t\t BB and remove unexecutable edges.  */\n-\t      remove_ctrl_stmt_and_useless_edges (bb, taken_edge->dest);\n-\n-\t      /* Fixup the flags on the single remaining edge.  */\n-\t      taken_edge->flags\n-\t\t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n-\t      taken_edge->flags |= EDGE_FALLTHRU;\n+\t      /* Fix the condition to be either true or false.  */\n+\t      if (gimple_code (stmt) == GIMPLE_COND)\n+\t\t{\n+\t\t  if (integer_zerop (val))\n+\t\t    gimple_cond_make_false (as_a <gcond *> (stmt));\n+\t\t  else if (integer_onep (val))\n+\t\t    gimple_cond_make_true (as_a <gcond *> (stmt));\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\t\t}\n \n \t      /* Further simplifications may be possible.  */\n \t      cfg_altered = true;\n@@ -1887,6 +1924,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n \tneed_noreturn_fixup.safe_push (stmt);\n     }\n+  return retval;\n }\n \n /* Helper for walk_non_aliased_vuses.  Determine if we arrived at"}, {"sha": "0b05c5e2ab32651840715d5634d074d5bbb7707f", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -316,10 +316,10 @@ class dse_dom_walker : public dom_walker\n public:\n   dse_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n };\n \n-void\n+edge\n dse_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -332,6 +332,7 @@ dse_dom_walker::before_dom_children (basic_block bb)\n       else\n \tgsi_prev (&gsi);\n     }\n+  return NULL;\n }\n \n namespace {"}, {"sha": "9b1b8157b127f54f8b99b6727dffbac3e519d49c", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -958,14 +958,14 @@ class invariantness_dom_walker : public dom_walker\n   invariantness_dom_walker (cdi_direction direction)\n     : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n };\n \n /* Determine the outermost loops in that statements in basic block BB are\n    invariant, and record them to the LIM_DATA associated with the statements.\n    Callback for dom_walker.  */\n \n-void\n+edge\n invariantness_dom_walker::before_dom_children (basic_block bb)\n {\n   enum move_pos pos;\n@@ -976,7 +976,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n   struct lim_aux_data *lim_data;\n \n   if (!loop_outer (bb->loop_father))\n-    return;\n+    return NULL;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Basic block %d (loop %d -- depth %d):\\n\\n\",\n@@ -1094,6 +1094,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n       if (lim_data->cost >= LIM_EXPENSIVE)\n \tset_profitable_level (stmt);\n     }\n+  return NULL;\n }\n \n class move_computations_dom_walker : public dom_walker\n@@ -1102,7 +1103,7 @@ class move_computations_dom_walker : public dom_walker\n   move_computations_dom_walker (cdi_direction direction)\n     : dom_walker (direction), todo_ (0) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n \n   unsigned int todo_;\n };\n@@ -1111,15 +1112,15 @@ class move_computations_dom_walker : public dom_walker\n    data stored in LIM_DATA structures associated with each statement.  Callback\n    for walk_dominator_tree.  */\n \n-void\n+edge\n move_computations_dom_walker::before_dom_children (basic_block bb)\n {\n   struct loop *level;\n   unsigned cost = 0;\n   struct lim_aux_data *lim_data;\n \n   if (!loop_outer (bb->loop_father))\n-    return;\n+    return NULL;\n \n   for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi); )\n     {\n@@ -1265,6 +1266,7 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n       else\n \tgsi_insert_on_edge (e, stmt);\n     }\n+  return NULL;\n }\n \n /* Hoist the statements out of the loops prescribed by data stored in"}, {"sha": "99ab23a62ddd248671d5abab062924ee362d7122", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -1477,7 +1477,7 @@ class nontrapping_dom_walker : public dom_walker\n   nontrapping_dom_walker (cdi_direction direction, hash_set<tree> *ps)\n     : dom_walker (direction), m_nontrapping (ps), m_seen_ssa_names (128) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n private:\n@@ -1496,7 +1496,7 @@ class nontrapping_dom_walker : public dom_walker\n };\n \n /* Called by walk_dominator_tree, when entering the block BB.  */\n-void\n+edge\n nontrapping_dom_walker::before_dom_children (basic_block bb)\n {\n   edge e;\n@@ -1529,6 +1529,7 @@ nontrapping_dom_walker::before_dom_children (basic_block bb)\n \t  add_or_mark_expr (bb, gimple_assign_rhs1 (stmt), false);\n \t}\n     }\n+  return NULL;\n }\n \n /* Called by walk_dominator_tree, when basic block BB is exited.  */"}, {"sha": "21a3a2b41d257c2e2bd8f55358d25fada9aeb375", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -3906,15 +3906,15 @@ class eliminate_dom_walker : public dom_walker\n   eliminate_dom_walker (cdi_direction direction, bool do_pre_)\n       : dom_walker (direction), do_pre (do_pre_) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n   bool do_pre;\n };\n \n /* Perform elimination for the basic-block B during the domwalk.  */\n \n-void\n+edge\n eliminate_dom_walker::before_dom_children (basic_block b)\n {\n   /* Mark new bb.  */\n@@ -4423,6 +4423,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t    }\n \t}\n     }\n+  return NULL;\n }\n \n /* Make no longer available leaders no longer available.  */"}, {"sha": "c52b41c78e536e287e53400a44ad202e06373b5d", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -1123,7 +1123,7 @@ class substitute_and_fold_dom_walker : public dom_walker\n       BITMAP_FREE (need_eh_cleanup);\n     }\n \n-    virtual void before_dom_children (basic_block);\n+    virtual edge before_dom_children (basic_block);\n     virtual void after_dom_children (basic_block) {}\n \n     ssa_prop_get_value_fn get_value_fn;\n@@ -1135,7 +1135,7 @@ class substitute_and_fold_dom_walker : public dom_walker\n     bitmap need_eh_cleanup;\n };\n \n-void\n+edge\n substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n {\n   /* Propagate known values into PHI nodes.  */\n@@ -1293,6 +1293,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t    fprintf (dump_file, \"Not folded\\n\");\n \t}\n     }\n+  return NULL;\n }\n \n "}, {"sha": "84e95639824f7e1aac72331e43650a201dfd7ee5", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 11, "deletions": 70, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -4208,11 +4208,10 @@ class sccvn_dom_walker : public dom_walker\n {\n public:\n   sccvn_dom_walker ()\n-    : dom_walker (CDI_DOMINATORS), fail (false), unreachable_dom (NULL),\n-      cond_stack (vNULL) {}\n+    : dom_walker (CDI_DOMINATORS, true), fail (false), cond_stack (vNULL) {}\n   ~sccvn_dom_walker ();\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n   void record_cond (basic_block,\n@@ -4221,7 +4220,6 @@ class sccvn_dom_walker : public dom_walker\n \t\t     enum tree_code code, tree lhs, tree rhs, bool value);\n \n   bool fail;\n-  basic_block unreachable_dom;\n   vec<std::pair <basic_block, std::pair <vn_nary_op_t, vn_nary_op_t> > >\n     cond_stack;\n };\n@@ -4302,9 +4300,6 @@ sccvn_dom_walker::record_conds (basic_block bb,\n void\n sccvn_dom_walker::after_dom_children (basic_block bb)\n {\n-  if (unreachable_dom == bb)\n-    unreachable_dom = NULL;\n-\n   while (!cond_stack.is_empty ()\n \t && cond_stack.last ().first == bb)\n     {\n@@ -4319,56 +4314,14 @@ sccvn_dom_walker::after_dom_children (basic_block bb)\n \n /* Value number all statements in BB.  */\n \n-void\n+edge\n sccvn_dom_walker::before_dom_children (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n \n   if (fail)\n-    return;\n-\n-  /* If any of the predecessor edges that do not come from blocks dominated\n-     by us are still marked as possibly executable consider this block\n-     reachable.  */\n-  bool reachable = false;\n-  if (!unreachable_dom)\n-    {\n-      reachable = bb == ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (!dominated_by_p (CDI_DOMINATORS, e->src, bb))\n-\t  reachable |= (e->flags & EDGE_EXECUTABLE);\n-    }\n-\n-  /* If the block is not reachable all outgoing edges are not\n-     executable.  Neither are incoming edges with src dominated by us.  */\n-  if (!reachable)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Marking all outgoing edges of unreachable \"\n-\t\t \"BB %d as not executable\\n\", bb->index);\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\te->flags &= ~EDGE_EXECUTABLE;\n-\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  if (dominated_by_p (CDI_DOMINATORS, e->src, bb))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"Marking backedge from BB %d into \"\n-\t\t\t \"unreachable BB %d as not executable\\n\",\n-\t\t\t e->src->index, bb->index);\n-\t      e->flags &= ~EDGE_EXECUTABLE;\n-\t    }\n-\t}\n-\n-      /* Record the most dominating unreachable block.  */\n-      if (!unreachable_dom)\n-\tunreachable_dom = bb;\n-\n-      return;\n-    }\n+    return NULL;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Visiting BB %d\\n\", bb->index);\n@@ -4429,7 +4382,7 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n \t  && !DFS (res))\n \t{\n \t  fail = true;\n-\t  return;\n+\t  return NULL;\n \t}\n     }\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n@@ -4442,20 +4395,20 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n \t    && !DFS (op))\n \t  {\n \t    fail = true;\n-\t    return;\n+\t    return NULL;\n \t  }\n     }\n \n   /* Finally look at the last stmt.  */\n   gimple *stmt = last_stmt (bb);\n   if (!stmt)\n-    return;\n+    return NULL;\n \n   enum gimple_code code = gimple_code (stmt);\n   if (code != GIMPLE_COND\n       && code != GIMPLE_SWITCH\n       && code != GIMPLE_GOTO)\n-    return;\n+    return NULL;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -4498,19 +4451,17 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n       gcc_unreachable ();\n     }\n   if (!val)\n-    return;\n+    return NULL;\n \n   edge taken = find_taken_edge (bb, vn_valueize (val));\n   if (!taken)\n-    return;\n+    return NULL;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Marking all edges out of BB %d but (%d -> %d) as \"\n \t     \"not executable\\n\", bb->index, bb->index, taken->dest->index);\n \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e != taken)\n-      e->flags &= ~EDGE_EXECUTABLE;\n+  return taken;\n }\n \n /* Do SCCVN.  Returns true if it finished, false if we bailed out\n@@ -4520,7 +4471,6 @@ sccvn_dom_walker::before_dom_children (basic_block bb)\n bool\n run_scc_vn (vn_lookup_kind default_vn_walk_kind_)\n {\n-  basic_block bb;\n   size_t i;\n \n   default_vn_walk_kind = default_vn_walk_kind_;\n@@ -4550,15 +4500,6 @@ run_scc_vn (vn_lookup_kind default_vn_walk_kind_)\n \t}\n     }\n \n-  /* Mark all edges as possibly executable.  */\n-  FOR_ALL_BB_FN (bb, cfun)\n-    {\n-      edge_iterator ei;\n-      edge e;\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\te->flags |= EDGE_EXECUTABLE;\n-    }\n-\n   /* Walk all blocks in dominator order, value-numbering stmts\n      SSA defs and decide whether outgoing edges are not executable.  */\n   sccvn_dom_walker walker;"}, {"sha": "f98b8656d21ce26ee5effe91903233c1683664a7", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -2196,14 +2196,14 @@ class strlen_dom_walker : public dom_walker\n public:\n   strlen_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n };\n \n /* Callback for walk_dominator_tree.  Attempt to optimize various\n    string ops by remembering string lenths pointed by pointer SSA_NAMEs.  */\n \n-void\n+edge\n strlen_dom_walker::before_dom_children (basic_block bb)\n {\n   basic_block dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n@@ -2283,6 +2283,7 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n   bb->aux = stridx_to_strinfo;\n   if (vec_safe_length (stridx_to_strinfo) && !strinfo_shared ())\n     (*stridx_to_strinfo)[0] = (strinfo *) bb;\n+  return NULL;\n }\n \n /* Callback for walk_dominator_tree.  Free strinfo vector if it is"}, {"sha": "502614a37d605d5097d35e77d6640aa6a845a594", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3daacdcd5f20d084294f2cc50f84e3e8769205f1/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=3daacdcd5f20d084294f2cc50f84e3e8769205f1", "patch": "@@ -303,7 +303,7 @@ class uncprop_dom_walker : public dom_walker\n public:\n   uncprop_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n \n-  virtual void before_dom_children (basic_block);\n+  virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n private:\n@@ -433,7 +433,7 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n   return retval;\n }\n \n-void\n+edge\n uncprop_dom_walker::before_dom_children (basic_block bb)\n {\n   basic_block parent;\n@@ -462,6 +462,7 @@ uncprop_dom_walker::before_dom_children (basic_block bb)\n     m_equiv_stack.safe_push (NULL_TREE);\n \n   uncprop_into_successor_phis (bb);\n+  return NULL;\n }\n \n namespace {"}]}