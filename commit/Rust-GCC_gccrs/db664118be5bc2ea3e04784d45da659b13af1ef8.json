{"sha": "db664118be5bc2ea3e04784d45da659b13af1ef8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI2NjQxMThiZTViYzJlYTNlMDQ3ODRkNDVkYTY1OWIxM2FmMWVmOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T09:26:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T09:26:48Z"}, "message": "[multiple changes]\n\n2012-05-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-calend.adb (Day_Of_Week): The routine once again treats\n\tall dates as historic.\t(Formatting_Operations.Split): All\n\tcalls to UTC_Time_Offset are now controlled through formal\n\tparameter Is_Historic.\t(Formatting_Operations.Time_Of):\n\tAll calls to UTC_Time_Offset are now handled through\n\tformal parameter Is_Historic.\n\t(Split): Update the call to Formatting_Operations.Split.\n\t(Time_Of): Update the call to Formatting_Operations.Time_Of.\n\t(To_Ada_Time): Update the call to Formatting_Operations.Time_Of.\n\t(To_Strict_Tm): Update the call to Formatting_Operations.Split.\n\t* a-calend.ads (Split): Add new formal Is_Historic along with\n\tcomment on usage. This routine is now exported for the purposes\n\tof GNAT.Calendar.Locale.\n\t(Time_Of): Remove defaults. Add new\n\tformal Is_Historic along with comment on usage. This routine is\n\tnow exported for the purposes of GNAT.Calendar.Locale.\n\t* a-calend-vms.adb (Split): Update the call to\n\tFormatting_Operations.Split.\n\t(Time_Of): Update the call to Formatting_Operations.Time_Of.\n\t* a-calend-vms.ads (Split): Add new formal Is_Historic along\n\twith comment on usage.\t(Time_Of): Remove defaults. Add new\n\tformal Is_Historic along with comment on usage.\n\t* a-calfor.adb (Split): Update the call to\n\tFormatting_Operations.Split.\n\t(Time_Of): Update the call to Formatting_Operations.Time_Of.\n\t* impunit.adb: Include g-calloc to the list of non-RM defined\n\tunits.\n\n2012-05-15  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Add_Source): Always add the source if it is\n\texcluded, to avoid incorrect duplicate checks.\n\n2012-05-15  Yannick Moy  <moy@adacore.com>\n\n\t* sem_aux.ads: Correct typo.\n\t* sem_eval.adb (Compile_Time_Known_Value): Return False in Alfa\n\tmode for a deferred constant when outside of the scope of its\n\tfull view.\n\n2012-05-15  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-comlin.adb, g-comlin.ads (Define_Switch): Allow specifying the name\n\tof the argument, for the automatic help message.\n\t(Getopt): do not systematically initialize switches with string values\n\tto the empty string, when the user has already specified a default.\n\nFrom-SVN: r187504", "tree": {"sha": "f379d457c02670132f951efa9f8c06c306d1a80b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f379d457c02670132f951efa9f8c06c306d1a80b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db664118be5bc2ea3e04784d45da659b13af1ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db664118be5bc2ea3e04784d45da659b13af1ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db664118be5bc2ea3e04784d45da659b13af1ef8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db664118be5bc2ea3e04784d45da659b13af1ef8/comments", "author": null, "committer": null, "parents": [{"sha": "a02f0c5dfa9246a57970aeefe5c7196a17bf7b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02f0c5dfa9246a57970aeefe5c7196a17bf7b1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a02f0c5dfa9246a57970aeefe5c7196a17bf7b1c"}], "stats": {"total": 740, "additions": 432, "deletions": 308}, "files": [{"sha": "e1c40a9584302b2b3990ebed7628186fc63258ae", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -1,3 +1,52 @@\n+2012-05-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-calend.adb (Day_Of_Week): The routine once again treats\n+\tall dates as historic.\t(Formatting_Operations.Split): All\n+\tcalls to UTC_Time_Offset are now controlled through formal\n+\tparameter Is_Historic.\t(Formatting_Operations.Time_Of):\n+\tAll calls to UTC_Time_Offset are now handled through\n+\tformal parameter Is_Historic.\n+\t(Split): Update the call to Formatting_Operations.Split.\n+\t(Time_Of): Update the call to Formatting_Operations.Time_Of.\n+\t(To_Ada_Time): Update the call to Formatting_Operations.Time_Of.\n+\t(To_Strict_Tm): Update the call to Formatting_Operations.Split.\n+\t* a-calend.ads (Split): Add new formal Is_Historic along with\n+\tcomment on usage. This routine is now exported for the purposes\n+\tof GNAT.Calendar.Locale.\n+\t(Time_Of): Remove defaults. Add new\n+\tformal Is_Historic along with comment on usage. This routine is\n+\tnow exported for the purposes of GNAT.Calendar.Locale.\n+\t* a-calend-vms.adb (Split): Update the call to\n+\tFormatting_Operations.Split.\n+\t(Time_Of): Update the call to Formatting_Operations.Time_Of.\n+\t* a-calend-vms.ads (Split): Add new formal Is_Historic along\n+\twith comment on usage.\t(Time_Of): Remove defaults. Add new\n+\tformal Is_Historic along with comment on usage.\n+\t* a-calfor.adb (Split): Update the call to\n+\tFormatting_Operations.Split.\n+\t(Time_Of): Update the call to Formatting_Operations.Time_Of.\n+\t* impunit.adb: Include g-calloc to the list of non-RM defined\n+\tunits.\n+\n+2012-05-15  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Add_Source): Always add the source if it is\n+\texcluded, to avoid incorrect duplicate checks.\n+\n+2012-05-15  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_aux.ads: Correct typo.\n+\t* sem_eval.adb (Compile_Time_Known_Value): Return False in Alfa\n+\tmode for a deferred constant when outside of the scope of its\n+\tfull view.\n+\n+2012-05-15  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-comlin.adb, g-comlin.ads (Define_Switch): Allow specifying the name\n+\tof the argument, for the automatic help message.\n+\t(Getopt): do not systematically initialize switches with string values\n+\tto the empty string, when the user has already specified a default.\n+\n 2012-05-14  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 53063"}, {"sha": "bb8faaf9790a325a414c3e45846dc599c91eab80", "filename": "gcc/ada/a-calend-vms.adb", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -521,18 +521,19 @@ package body Ada.Calendar is\n       --  irrelevant in this case.\n \n       Formatting_Operations.Split\n-        (Date      => Date,\n-         Year      => Year,\n-         Month     => Month,\n-         Day       => Day,\n-         Day_Secs  => Seconds,\n-         Hour      => H,\n-         Minute    => M,\n-         Second    => Se,\n-         Sub_Sec   => Ss,\n-         Leap_Sec  => Le,\n-         Use_TZ    => False,\n-         Time_Zone => 0);\n+        (Date        => Date,\n+         Year        => Year,\n+         Month       => Month,\n+         Day         => Day,\n+         Day_Secs    => Seconds,\n+         Hour        => H,\n+         Minute      => M,\n+         Second      => Se,\n+         Sub_Sec     => Ss,\n+         Leap_Sec    => Le,\n+         Use_TZ      => False,\n+         Is_Historic => True,\n+         Time_Zone   => 0);\n \n       --  Validity checks\n \n@@ -589,6 +590,7 @@ package body Ada.Calendar is\n            Leap_Sec     => False,\n            Use_Day_Secs => True,\n            Use_TZ       => False,\n+           Is_Historic  => True,\n            Time_Zone    => 0);\n    end Time_Of;\n \n@@ -836,6 +838,7 @@ package body Ada.Calendar is\n                 Leap_Sec     => Leap,\n                 Use_Day_Secs => False,    --  Time is given in h:m:s\n                 Use_TZ       => True,     --  Force usage of explicit time zone\n+                Is_Historic  => True,\n                 Time_Zone    => 0));      --  Place the value in UTC\n          --  Step 4: Daylight Savings Time\n \n@@ -980,22 +983,23 @@ package body Ada.Calendar is\n       -----------\n \n       procedure Split\n-        (Date      : Time;\n-         Year      : out Year_Number;\n-         Month     : out Month_Number;\n-         Day       : out Day_Number;\n-         Day_Secs  : out Day_Duration;\n-         Hour      : out Integer;\n-         Minute    : out Integer;\n-         Second    : out Integer;\n-         Sub_Sec   : out Duration;\n-         Leap_Sec  : out Boolean;\n-         Use_TZ    : Boolean;\n-         Time_Zone : Long_Integer)\n+        (Date        : Time;\n+         Year        : out Year_Number;\n+         Month       : out Month_Number;\n+         Day         : out Day_Number;\n+         Day_Secs    : out Day_Duration;\n+         Hour        : out Integer;\n+         Minute      : out Integer;\n+         Second      : out Integer;\n+         Sub_Sec     : out Duration;\n+         Leap_Sec    : out Boolean;\n+         Use_TZ      : Boolean;\n+         Is_Historic : Boolean;\n+         Time_Zone   : Long_Integer)\n       is\n-         --  The flag Use_TZ is present for interfacing purposes\n+         --  Flags Use_TZ and Is_Historic are present for interfacing purposes\n \n-         pragma Unreferenced (Use_TZ);\n+         pragma Unreferenced (Use_TZ, Is_Historic);\n \n          procedure Numtim\n            (Status : out Unsigned_Longword;\n@@ -1104,11 +1108,16 @@ package body Ada.Calendar is\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean := False;\n-         Use_Day_Secs : Boolean := False;\n-         Use_TZ       : Boolean := False;\n-         Time_Zone    : Long_Integer := 0) return Time\n+         Leap_Sec     : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Use_TZ       : Boolean;\n+         Is_Historic  : Boolean;\n+         Time_Zone    : Long_Integer) return Time\n       is\n+         --  Flag Is_Historic is present for interfacing purposes\n+\n+         pragma Unreferenced (Is_Historic);\n+\n          procedure Cvt_Vectim\n            (Status         : out Unsigned_Longword;\n             Input_Time     : Unsigned_Word_Array;"}, {"sha": "d0fdc4a6b91830ae8adf40e8f499214aa9796fbb", "filename": "gcc/ada/a-calend-vms.ads", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.ads?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -218,21 +218,24 @@ private\n       --  within the range of 0 .. 6 (Monday .. Sunday).\n \n       procedure Split\n-        (Date      : Time;\n-         Year      : out Year_Number;\n-         Month     : out Month_Number;\n-         Day       : out Day_Number;\n-         Day_Secs  : out Day_Duration;\n-         Hour      : out Integer;\n-         Minute    : out Integer;\n-         Second    : out Integer;\n-         Sub_Sec   : out Duration;\n-         Leap_Sec  : out Boolean;\n-         Use_TZ    : Boolean;\n-         Time_Zone : Long_Integer);\n-      --  Split a time value into its components. Set Use_TZ to use the local\n-      --  time zone (the value in Time_Zone is ignored) when splitting a time\n-      --  value.\n+        (Date        : Time;\n+         Year        : out Year_Number;\n+         Month       : out Month_Number;\n+         Day         : out Day_Number;\n+         Day_Secs    : out Day_Duration;\n+         Hour        : out Integer;\n+         Minute      : out Integer;\n+         Second      : out Integer;\n+         Sub_Sec     : out Duration;\n+         Leap_Sec    : out Boolean;\n+         Use_TZ      : Boolean;\n+         Is_Historic : Boolean;\n+         Time_Zone   : Long_Integer);\n+      --  Split a time value into its components. If flag Is_Historic is set,\n+      --  this routine would try to use to the best of the OS's abilities the\n+      --  time zone offset that was or will be in effect on Date. Set Use_TZ\n+      --  to use the local time zone (the value in Time_Zone is ignored) when\n+      --  splitting a time value.\n \n       function Time_Of\n         (Year         : Year_Number;\n@@ -243,16 +246,19 @@ private\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean := False;\n-         Use_Day_Secs : Boolean := False;\n-         Use_TZ       : Boolean := False;\n-         Time_Zone    : Long_Integer := 0) return Time;\n+         Leap_Sec     : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Use_TZ       : Boolean;\n+         Is_Historic  : Boolean;\n+         Time_Zone    : Long_Integer) return Time;\n       --  Given all the components of a date, return the corresponding time\n       --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n       --  day duration will be calculated from Hour, Minute, Second and Sub_\n-      --  Sec. Set Use_TZ to use the local time zone (the value in formal\n-      --  Time_Zone is ignored) when building a time value and to verify the\n-      --  validity of a requested leap second.\n+      --  Sec. If flag Is_Historic is set, this routine would try to use to the\n+      --  best of the OS's abilities the time zone offset that was or will be\n+      --  in effect on the input date. Set Use_TZ to use the local time zone\n+      --  (the value in formal Time_Zone is ignored) when building a time value\n+      --  and to verify the validity of a requested leap second.\n \n    end Formatting_Operations;\n "}, {"sha": "3d70cf4f43b4a2fcde97a328e59876a0e7bebac1", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 55, "deletions": 43, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -579,18 +579,19 @@ package body Ada.Calendar is\n       --  ensure that Split picks up the local time zone.\n \n       Formatting_Operations.Split\n-        (Date      => Date,\n-         Year      => Year,\n-         Month     => Month,\n-         Day       => Day,\n-         Day_Secs  => Seconds,\n-         Hour      => H,\n-         Minute    => M,\n-         Second    => Se,\n-         Sub_Sec   => Ss,\n-         Leap_Sec  => Le,\n-         Use_TZ    => False,\n-         Time_Zone => 0);\n+        (Date        => Date,\n+         Year        => Year,\n+         Month       => Month,\n+         Day         => Day,\n+         Day_Secs    => Seconds,\n+         Hour        => H,\n+         Minute      => M,\n+         Second      => Se,\n+         Sub_Sec     => Ss,\n+         Leap_Sec    => Le,\n+         Use_TZ      => False,\n+         Is_Historic => True,\n+         Time_Zone   => 0);\n \n       --  Validity checks\n \n@@ -649,6 +650,7 @@ package body Ada.Calendar is\n            Leap_Sec     => False,\n            Use_Day_Secs => True,\n            Use_TZ       => False,\n+           Is_Historic  => True,\n            Time_Zone    => 0);\n    end Time_Of;\n \n@@ -977,6 +979,7 @@ package body Ada.Calendar is\n                 Leap_Sec     => Leap,\n                 Use_Day_Secs => False,    --  Time is given in h:m:s\n                 Use_TZ       => True,     --  Force usage of explicit time zone\n+                Is_Historic  => True,\n                 Time_Zone    => 0));      --  Place the value in UTC\n \n          --  Step 4: Daylight Savings Time\n@@ -1055,8 +1058,19 @@ package body Ada.Calendar is\n          --  Step 1: Split the input time\n \n          Formatting_Operations.Split\n-           (T, Year, Month, tm_day, Day_Secs,\n-            tm_hour, tm_min, Second, Sub_Sec, Leap_Sec, True, 0);\n+           (Date        => T,\n+            Year        => Year,\n+            Month       => Month,\n+            Day         => tm_day,\n+            Day_Secs    => Day_Secs,\n+            Hour        => tm_hour,\n+            Minute      => tm_min,\n+            Second      => Second,\n+            Sub_Sec     => Sub_Sec,\n+            Leap_Sec    => Leap_Sec,\n+            Use_TZ      => True,\n+            Is_Historic => False,\n+            Time_Zone   => 0);\n \n          --  Step 2: Correct the year and month\n \n@@ -1154,12 +1168,8 @@ package body Ada.Calendar is\n       -----------------\n \n       function Day_Of_Week (Date : Time) return Integer is\n-         Date_N : constant Time_Rep := Time_Rep (Date);\n-\n-         Time_Zone : constant Long_Integer := UTC_Time_Offset (Date, False);\n-         --  Keep the internal usage of UTC_Time_Offset consistent with Time_Of\n-         --  and Split.\n-\n+         Date_N    : constant Time_Rep := Time_Rep (Date);\n+         Time_Zone : constant Long_Integer := UTC_Time_Offset (Date, True);\n          Ada_Low_N : Time_Rep;\n          Day_Count : Long_Integer;\n          Day_Dur   : Time_Dur;\n@@ -1199,18 +1209,19 @@ package body Ada.Calendar is\n       -----------\n \n       procedure Split\n-        (Date      : Time;\n-         Year      : out Year_Number;\n-         Month     : out Month_Number;\n-         Day       : out Day_Number;\n-         Day_Secs  : out Day_Duration;\n-         Hour      : out Integer;\n-         Minute    : out Integer;\n-         Second    : out Integer;\n-         Sub_Sec   : out Duration;\n-         Leap_Sec  : out Boolean;\n-         Use_TZ    : Boolean;\n-         Time_Zone : Long_Integer)\n+        (Date        : Time;\n+         Year        : out Year_Number;\n+         Month       : out Month_Number;\n+         Day         : out Day_Number;\n+         Day_Secs    : out Day_Duration;\n+         Hour        : out Integer;\n+         Minute      : out Integer;\n+         Second      : out Integer;\n+         Sub_Sec     : out Duration;\n+         Leap_Sec    : out Boolean;\n+         Use_TZ      : Boolean;\n+         Is_Historic : Boolean;\n+         Time_Zone   : Long_Integer)\n       is\n          --  The following constants represent the number of nanoseconds\n          --  elapsed since the start of Ada time to and including the non\n@@ -1272,7 +1283,7 @@ package body Ada.Calendar is\n          else\n             declare\n                Off : constant Long_Integer :=\n-                       UTC_Time_Offset (Time (Date_N), False);\n+                       UTC_Time_Offset (Time (Date_N), Is_Historic);\n \n             begin\n                Date_N := Date_N + Time_Rep (Off) * Nano;\n@@ -1388,10 +1399,11 @@ package body Ada.Calendar is\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean := False;\n-         Use_Day_Secs : Boolean := False;\n-         Use_TZ       : Boolean := False;\n-         Time_Zone    : Long_Integer := 0) return Time\n+         Leap_Sec     : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Use_TZ       : Boolean;\n+         Is_Historic  : Boolean;\n+         Time_Zone    : Long_Integer) return Time\n       is\n          Count         : Integer;\n          Elapsed_Leaps : Natural;\n@@ -1493,12 +1505,12 @@ package body Ada.Calendar is\n \n          else\n             declare\n-               Current_Off   : constant Long_Integer :=\n-                                 UTC_Time_Offset (Time (Res_N), False);\n-               Current_Res_N : constant Time_Rep :=\n-                                 Res_N - Time_Rep (Current_Off) * Nano;\n-               Off           : constant Long_Integer :=\n-                                 UTC_Time_Offset (Time (Current_Res_N), False);\n+               Cur_Off   : constant Long_Integer :=\n+                             UTC_Time_Offset (Time (Res_N), Is_Historic);\n+               Cur_Res_N : constant Time_Rep :=\n+                             Res_N - Time_Rep (Cur_Off) * Nano;\n+               Off       : constant Long_Integer :=\n+                             UTC_Time_Offset (Time (Cur_Res_N), Is_Historic);\n \n             begin\n                Res_N := Res_N - Time_Rep (Off) * Nano;"}, {"sha": "668efb9b32ae894e9820598dc7c944fe237d4d72", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 30, "deletions": 49, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -193,33 +193,6 @@ private\n    --  of year - 4 to year + 4. Internally, routines Split and Time_Of add or\n    --  subtract a \"fake\" February 29 to facilitate the arithmetic involved.\n \n-   ------------------------------------\n-   -- Time Zones and UTC_Time_Offset --\n-   ------------------------------------\n-\n-   --  The implementation-defined time zone of Ada.Calendar routines is the\n-   --  local time zone. The term \"local time zone\" can be interpreted in two\n-   --  different ways - either the offset from UTC of the \"now\" or the offset\n-   --  from UTC of some input date.\n-\n-   --  For efficency reasons, Split and Time_Of take the first approach. Since\n-   --  the Ada Reference Manual does not mandate that Split and Time_Of should\n-   --  be concious of historic time zones, this interpretation is acceptable\n-   --  and efficent in terms of performance. Split and Time_Of localize their\n-   --  respective input regardless of whether it represent a past or a future\n-   --  date.\n-\n-   --  UTC_Time_Offset on the other hand must be knowledgeable of historic time\n-   --  zones. To achieve this, the implementation relies on various operating\n-   --  system routines. Note that not all operating systems support time zones.\n-   --  UTC_Time_Offset calculates the offset from UTC as it occurred or will\n-   --  occur on the input date relative to the local time zone. Example:\n-\n-   --     Date         Offset    Reason\n-   --     2012-01-11   -300\n-   --     2011-03-12   -300\n-   --     2011-03-14   -240      Daylight savings is in effect\n-\n    ------------------------\n    -- Local Declarations --\n    ------------------------\n@@ -341,21 +314,25 @@ private\n       --  within the range of 0 .. 6 (Monday .. Sunday).\n \n       procedure Split\n-        (Date      : Time;\n-         Year      : out Year_Number;\n-         Month     : out Month_Number;\n-         Day       : out Day_Number;\n-         Day_Secs  : out Day_Duration;\n-         Hour      : out Integer;\n-         Minute    : out Integer;\n-         Second    : out Integer;\n-         Sub_Sec   : out Duration;\n-         Leap_Sec  : out Boolean;\n-         Use_TZ    : Boolean;\n-         Time_Zone : Long_Integer);\n-      --  Split a time value into its components. Set Use_TZ to use the local\n-      --  time zone (the value in Time_Zone is ignored) when splitting a time\n-      --  value.\n+        (Date        : Time;\n+         Year        : out Year_Number;\n+         Month       : out Month_Number;\n+         Day         : out Day_Number;\n+         Day_Secs    : out Day_Duration;\n+         Hour        : out Integer;\n+         Minute      : out Integer;\n+         Second      : out Integer;\n+         Sub_Sec     : out Duration;\n+         Leap_Sec    : out Boolean;\n+         Use_TZ      : Boolean;\n+         Is_Historic : Boolean;\n+         Time_Zone   : Long_Integer);\n+      pragma Export (Ada, Split, \"__gnat_split\");\n+      --  Split a time value into its components. If flag Is_Historic is set,\n+      --  this routine would try to use to the best of the OS's abilities the\n+      --  time zone offset that was or will be in effect on Date. Set Use_TZ\n+      --  to use the local time zone (the value in Time_Zone is ignored) when\n+      --  splitting a time value.\n \n       function Time_Of\n         (Year         : Year_Number;\n@@ -366,16 +343,20 @@ private\n          Minute       : Integer;\n          Second       : Integer;\n          Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean := False;\n-         Use_Day_Secs : Boolean := False;\n-         Use_TZ       : Boolean := False;\n-         Time_Zone    : Long_Integer := 0) return Time;\n+         Leap_Sec     : Boolean;\n+         Use_Day_Secs : Boolean;\n+         Use_TZ       : Boolean;\n+         Is_Historic  : Boolean;\n+         Time_Zone    : Long_Integer) return Time;\n+      pragma Export (Ada, Time_Of, \"__gnat_time_of\");\n       --  Given all the components of a date, return the corresponding time\n       --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n       --  day duration will be calculated from Hour, Minute, Second and Sub_\n-      --  Sec. Set Use_TZ to use the local time zone (the value in formal\n-      --  Time_Zone is ignored) when building a time value and to verify the\n-      --  validity of a requested leap second.\n+      --  Sec. If flag Is_Historic is set, this routine would try to use to the\n+      --  best of the OS's abilities the time zone offset that was or will be\n+      --  in effect on the input date. Set Use_TZ to use the local time zone\n+      --  (the value in formal Time_Zone is ignored) when building a time value\n+      --  and to verify the validity of a requested leap second.\n \n    end Formatting_Operations;\n "}, {"sha": "1376f9367afe64aa99b6970c1ddc183aadcbbf38", "filename": "gcc/ada/a-calfor.adb", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -421,18 +421,19 @@ package body Ada.Calendar.Formatting is\n \n    begin\n       Formatting_Operations.Split\n-        (Date      => Date,\n-         Year      => Year,\n-         Month     => Month,\n-         Day       => Day,\n-         Day_Secs  => Seconds,\n-         Hour      => H,\n-         Minute    => M,\n-         Second    => Se,\n-         Sub_Sec   => Su,\n-         Leap_Sec  => Leap_Second,\n-         Use_TZ    => True,\n-         Time_Zone => Tz);\n+        (Date        => Date,\n+         Year        => Year,\n+         Month       => Month,\n+         Day         => Day,\n+         Day_Secs    => Seconds,\n+         Hour        => H,\n+         Minute      => M,\n+         Second      => Se,\n+         Sub_Sec     => Su,\n+         Leap_Sec    => Leap_Second,\n+         Use_TZ      => True,\n+         Is_Historic => True,\n+         Time_Zone   => Tz);\n \n       --  Validity checks\n \n@@ -466,18 +467,19 @@ package body Ada.Calendar.Formatting is\n \n    begin\n       Formatting_Operations.Split\n-        (Date      => Date,\n-         Year      => Year,\n-         Month     => Month,\n-         Day       => Day,\n-         Day_Secs  => Dd,\n-         Hour      => Hour,\n-         Minute    => Minute,\n-         Second    => Second,\n-         Sub_Sec   => Sub_Second,\n-         Leap_Sec  => Le,\n-         Use_TZ    => True,\n-         Time_Zone => Tz);\n+        (Date        => Date,\n+         Year        => Year,\n+         Month       => Month,\n+         Day         => Day,\n+         Day_Secs    => Dd,\n+         Hour        => Hour,\n+         Minute      => Minute,\n+         Second      => Second,\n+         Sub_Sec     => Sub_Second,\n+         Leap_Sec    => Le,\n+         Use_TZ      => True,\n+         Is_Historic => True,\n+         Time_Zone   => Tz);\n \n       --  Validity checks\n \n@@ -514,18 +516,19 @@ package body Ada.Calendar.Formatting is\n \n    begin\n       Formatting_Operations.Split\n-       (Date      => Date,\n-        Year      => Year,\n-        Month     => Month,\n-        Day       => Day,\n-        Day_Secs  => Dd,\n-        Hour      => Hour,\n-        Minute    => Minute,\n-        Second    => Second,\n-        Sub_Sec   => Sub_Second,\n-        Leap_Sec  => Leap_Second,\n-        Use_TZ    => True,\n-        Time_Zone => Tz);\n+       (Date        => Date,\n+        Year        => Year,\n+        Month       => Month,\n+        Day         => Day,\n+        Day_Secs    => Dd,\n+        Hour        => Hour,\n+        Minute      => Minute,\n+        Second      => Second,\n+        Sub_Sec     => Sub_Second,\n+        Leap_Sec    => Leap_Second,\n+        Use_TZ      => True,\n+        Is_Historic => True,\n+        Time_Zone   => Tz);\n \n       --  Validity checks\n \n@@ -630,6 +633,7 @@ package body Ada.Calendar.Formatting is\n            Leap_Sec     => Leap_Second,\n            Use_Day_Secs => True,\n            Use_TZ       => True,\n+           Is_Historic  => True,\n            Time_Zone    => Tz);\n    end Time_Of;\n \n@@ -679,6 +683,7 @@ package body Ada.Calendar.Formatting is\n            Leap_Sec     => Leap_Second,\n            Use_Day_Secs => False,\n            Use_TZ       => True,\n+           Is_Historic  => True,\n            Time_Zone    => Tz);\n    end Time_Of;\n "}, {"sha": "8615b024f23df9f3561de9ae6105f0b16f710ccb", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -128,7 +128,8 @@ package body GNAT.Command_Line is\n       Switch      : String := \"\";\n       Long_Switch : String := \"\";\n       Help        : String := \"\";\n-      Section     : String := \"\");\n+      Section     : String := \"\";\n+      Argument    : String := \"ARG\");\n    --  Initialize [Def] with the contents of the other parameters.\n    --  This also checks consistency of the switch parameters, and will raise\n    --  Invalid_Switch if they do not match.\n@@ -1280,11 +1281,12 @@ package body GNAT.Command_Line is\n    ---------------------------\n \n    procedure Initialize_Switch_Def\n-     (Def : out Switch_Definition;\n+     (Def         : out Switch_Definition;\n       Switch      : String := \"\";\n       Long_Switch : String := \"\";\n       Help        : String := \"\";\n-      Section     : String := \"\")\n+      Section     : String := \"\";\n+      Argument    : String := \"ARG\")\n    is\n       P1, P2       : Switch_Parameter_Type := Parameter_None;\n       Last1, Last2 : Integer;\n@@ -1316,6 +1318,10 @@ package body GNAT.Command_Line is\n          Def.Section := new String'(Section);\n       end if;\n \n+      if Argument /= \"ARG\" then\n+         Def.Argument := new String'(Argument);\n+      end if;\n+\n       if Help /= \"\" then\n          Def.Help := new String'(Help);\n       end if;\n@@ -1330,12 +1336,14 @@ package body GNAT.Command_Line is\n       Switch      : String := \"\";\n       Long_Switch : String := \"\";\n       Help        : String := \"\";\n-      Section     : String := \"\")\n+      Section     : String := \"\";\n+      Argument    : String := \"ARG\")\n    is\n       Def : Switch_Definition;\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n-         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Initialize_Switch_Def\n+            (Def, Switch, Long_Switch, Help, Section, Argument);\n          Add (Config, Def);\n       end if;\n    end Define_Switch;\n@@ -1375,12 +1383,14 @@ package body GNAT.Command_Line is\n       Help        : String := \"\";\n       Section     : String := \"\";\n       Initial     : Integer := 0;\n-      Default     : Integer := 1)\n+      Default     : Integer := 1;\n+      Argument    : String := \"ARG\")\n    is\n       Def : Switch_Definition (Switch_Integer);\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n-         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Initialize_Switch_Def\n+            (Def, Switch, Long_Switch, Help, Section, Argument);\n          Def.Integer_Output  := Output.all'Unchecked_Access;\n          Def.Integer_Default := Default;\n          Def.Integer_Initial := Initial;\n@@ -1398,12 +1408,14 @@ package body GNAT.Command_Line is\n       Switch      : String := \"\";\n       Long_Switch : String := \"\";\n       Help        : String := \"\";\n-      Section     : String := \"\")\n+      Section     : String := \"\";\n+      Argument    : String := \"ARG\")\n    is\n       Def : Switch_Definition (Switch_String);\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n-         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Initialize_Switch_Def\n+            (Def, Switch, Long_Switch, Help, Section, Argument);\n          Def.String_Output  := Output.all'Unchecked_Access;\n          Add (Config, Def);\n       end if;\n@@ -3206,17 +3218,31 @@ package body GNAT.Command_Line is\n                   Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n                   Append (Result, \", \"\n                           & Def.Long_Switch (Def.Long_Switch'First .. Last2));\n-                  Append (Result, Param_Name (P2, \"ARG\"));\n+\n+                  if Def.Argument = null then\n+                     Append (Result, Param_Name (P2, \"ARG\"));\n+                  else\n+                     Append (Result, Param_Name (P2, Def.Argument.all));\n+                  end if;\n \n                else\n-                  Append (Result, Param_Name (P1, \"ARG\"));\n+                  if Def.Argument = null then\n+                     Append (Result, Param_Name (P1, \"ARG\"));\n+                  else\n+                     Append (Result, Param_Name (P1, Def.Argument.all));\n+                  end if;\n                end if;\n \n             else  --  Long_Switch necessarily not null\n                Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n                Append (Result,\n                        Def.Long_Switch (Def.Long_Switch'First .. Last2));\n-               Append (Result, Param_Name (P2, \"ARG\"));\n+\n+               if Def.Argument = null then\n+                  Append (Result, Param_Name (P2, \"ARG\"));\n+               else\n+                  Append (Result, Param_Name (P2, Def.Argument.all));\n+               end if;\n             end if;\n          end if;\n \n@@ -3393,7 +3419,9 @@ package body GNAT.Command_Line is\n                  Config.Switches (S).Integer_Initial;\n \n             when Switch_String =>\n-               Config.Switches (S).String_Output.all := new String'(\"\");\n+               if Config.Switches (S).String_Output.all = null then\n+                  Config.Switches (S).String_Output.all := new String'(\"\");\n+               end if;\n          end case;\n       end loop;\n "}, {"sha": "c3479bbfb424e567b61e32f0aef3ba494576a356", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2011, AdaCore                     --\n+--                     Copyright (C) 1999-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -595,7 +595,8 @@ package GNAT.Command_Line is\n       Switch      : String := \"\";\n       Long_Switch : String := \"\";\n       Help        : String := \"\";\n-      Section     : String := \"\");\n+      Section     : String := \"\";\n+      Argument    : String := \"ARG\");\n    --  Indicates a new switch. The format of this switch follows the getopt\n    --  format (trailing ':', '?', etc for defining a switch with parameters).\n    --\n@@ -617,6 +618,9 @@ package GNAT.Command_Line is\n    --\n    --  In_Section indicates in which section the switch is valid (you need to\n    --  first define the section through a call to Define_Section).\n+   --\n+   --  Argument is the name of the argument, as displayed in the automatic\n+   --  help message. It is always capitalized for consistency.\n \n    procedure Define_Switch\n      (Config      : in out Command_Line_Configuration;\n@@ -643,25 +647,31 @@ package GNAT.Command_Line is\n       Help        : String := \"\";\n       Section     : String := \"\";\n       Initial     : Integer := 0;\n-      Default     : Integer := 1);\n+      Default     : Integer := 1;\n+      Argument    : String := \"ARG\");\n    --  See Define_Switch for a description of the parameters.\n    --  When the switch is found on the command line, Getopt will set\n    --  Output.all to the value of the switch's parameter. If the parameter is\n    --  not an integer, Invalid_Parameter is raised.\n    --  Output is always initialized to Initial. If the switch has an optional\n    --  argument which isn't specified by the user, then Output will be set to\n    --  Default.\n+   --  The switch must accept an argument.\n \n    procedure Define_Switch\n      (Config      : in out Command_Line_Configuration;\n       Output      : access GNAT.Strings.String_Access;\n       Switch      : String := \"\";\n       Long_Switch : String := \"\";\n       Help        : String := \"\";\n-      Section     : String := \"\");\n+      Section     : String := \"\";\n+      Argument    : String := \"ARG\");\n    --  Set Output to the value of the switch's parameter when the switch is\n    --  found on the command line.\n-   --  Output is always initialized to the empty string.\n+   --  Output is always initialized to the empty string if it does not have\n+   --  a value already (otherwise it is left as is so that you can specify the\n+   --  default value directly in the declaration of the variable).\n+   --  The switch must accept an argument.\n \n    procedure Set_Usage\n      (Config   : in out Command_Line_Configuration;\n@@ -1096,6 +1106,10 @@ private\n       Section     : GNAT.OS_Lib.String_Access;\n       Help        : GNAT.OS_Lib.String_Access;\n \n+      Argument    : GNAT.OS_Lib.String_Access;\n+      --  null if \"ARG\".\n+      --  Name of the argument for this switch.\n+\n       case Typ is\n          when Switch_Untyped =>\n             null;"}, {"sha": "30ec793cc36c49a53b8ca7f4d45aa924a7eaa9ea", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -246,6 +246,7 @@ package body Impunit is\n     (\"g-byorma\", F),  -- GNAT.Byte_Order_Mark\n     (\"g-bytswa\", F),  -- GNAT.Byte_Swapping\n     (\"g-calend\", F),  -- GNAT.Calendar\n+    (\"g-calloc\", F),  -- GNAT.Calendar.Locale\n     (\"g-catiio\", F),  -- GNAT.Calendar.Time_IO\n     (\"g-casuti\", F),  -- GNAT.Case_Util\n     (\"g-cgi   \", F),  -- GNAT.CGI"}, {"sha": "28d2f0faa1764ffbd7ec9074803ec3c0840dd7bb", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 116, "deletions": 106, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -642,143 +642,153 @@ package body Prj.Nmsc is\n \n       Add_Src := True;\n \n-      if Unit /= No_Name then\n-         Prev_Unit := Units_Htable.Get (Data.Tree.Units_HT, Unit);\n-      end if;\n+      --  Always add the source if it is locally removed, to avoid incorrect\n+      --  duplicate checks.\n \n-      if Prev_Unit /= No_Unit_Index\n-        and then (Kind = Impl or else Kind = Spec)\n-        and then Prev_Unit.File_Names (Kind) /= null\n-      then\n-         --  Suspicious, we need to check later whether this is authorized\n-\n-         Add_Src := False;\n-         Source := Prev_Unit.File_Names (Kind);\n+      if not Locally_Removed then\n+         if Unit /= No_Name then\n+            Prev_Unit := Units_Htable.Get (Data.Tree.Units_HT, Unit);\n+         end if;\n \n-      else\n-         Source := Source_Files_Htable.Get\n-           (Data.Tree.Source_Files_HT, File_Name);\n+         if Prev_Unit /= No_Unit_Index\n+           and then (Kind = Impl or else Kind = Spec)\n+           and then Prev_Unit.File_Names (Kind) /= null\n+         then\n+            --  Suspicious, we need to check later whether this is authorized\n \n-         if Source /= No_Source and then Source.Index = Index then\n             Add_Src := False;\n+            Source := Prev_Unit.File_Names (Kind);\n+\n+         else\n+            Source := Source_Files_Htable.Get\n+              (Data.Tree.Source_Files_HT, File_Name);\n+\n+            if Source /= No_Source and then Source.Index = Index then\n+               Add_Src := False;\n+            end if;\n          end if;\n-      end if;\n \n-      --  Duplication of file/unit in same project is allowed if order of\n-      --  source directories is known, or if there is no compiler for the\n-      --  language.\n+         --  Duplication of file/unit in same project is allowed if order of\n+         --  source directories is known, or if there is no compiler for the\n+         --  language.\n \n-      if Add_Src = False then\n-         Add_Src := True;\n+         if Add_Src = False then\n+            Add_Src := True;\n \n-         if Project = Source.Project then\n-            if Prev_Unit = No_Unit_Index then\n-               if Data.Flags.Allow_Duplicate_Basenames then\n-                  Add_Src := True;\n+            if Project = Source.Project then\n+               if Prev_Unit = No_Unit_Index then\n+                  if Data.Flags.Allow_Duplicate_Basenames then\n+                     Add_Src := True;\n \n-               elsif Lang_Id.Config.Compiler_Driver = Empty_File then\n-                  Add_Src := True;\n+                  elsif Lang_Id.Config.Compiler_Driver = Empty_File then\n+                     Add_Src := True;\n \n-               elsif Source_Dir_Rank /= Source.Source_Dir_Rank then\n-                  Add_Src := False;\n+                  elsif Source_Dir_Rank /= Source.Source_Dir_Rank then\n+                     Add_Src := False;\n+\n+                  else\n+                     Error_Msg_File_1 := File_Name;\n+                     Error_Msg\n+                       (Data.Flags, \"duplicate source file name {\",\n+                        Location, Project);\n+                     Add_Src := False;\n+                  end if;\n \n                else\n-                  Error_Msg_File_1 := File_Name;\n-                  Error_Msg\n-                    (Data.Flags, \"duplicate source file name {\",\n-                     Location, Project);\n-                  Add_Src := False;\n-               end if;\n+                  if Source_Dir_Rank /= Source.Source_Dir_Rank then\n+                     Add_Src := False;\n \n-            else\n-               if Source_Dir_Rank /= Source.Source_Dir_Rank then\n-                  Add_Src := False;\n+                     --  We might be seeing the same file through a different\n+                     --  path (for instance because of symbolic links).\n \n-               --  We might be seeing the same file through a different path\n-               --  (for instance because of symbolic links).\n+                  elsif Source.Path.Name /= Path.Name then\n+                     if not Source.Duplicate_Unit then\n+                        Error_Msg_Name_1 := Unit;\n+                        Error_Msg\n+                          (Data.Flags,\n+                           \"\\duplicate unit %%\",\n+                           Location,\n+                           Project);\n+                        Source.Duplicate_Unit := True;\n+                     end if;\n \n-               elsif Source.Path.Name /= Path.Name then\n-                  if not Source.Duplicate_Unit then\n-                     Error_Msg_Name_1 := Unit;\n-                     Error_Msg\n-                       (Data.Flags, \"\\duplicate unit %%\", Location, Project);\n-                     Source.Duplicate_Unit := True;\n+                     Add_Src := False;\n                   end if;\n-\n-                  Add_Src := False;\n                end if;\n-            end if;\n \n-            --  Do not allow the same unit name in different projects, except\n-            --  if one is extending the other.\n+               --  Do not allow the same unit name in different projects,\n+               --  except if one is extending the other.\n \n-            --  For a file based language, the same file name replaces a file\n-            --  in a project being extended, but it is allowed to have the same\n-            --  file name in unrelated projects.\n+               --  For a file based language, the same file name replaces a\n+               --  file in a project being extended, but it is allowed to have\n+               --  the same file name in unrelated projects.\n \n-         elsif Is_Extending (Project, Source.Project) then\n-            if not Locally_Removed and then Naming_Exception /= Inherited then\n-               Source_To_Replace := Source;\n-            end if;\n+            elsif Is_Extending (Project, Source.Project) then\n+               if not Locally_Removed\n+                  and then Naming_Exception /= Inherited\n+               then\n+                  Source_To_Replace := Source;\n+               end if;\n \n-         elsif Prev_Unit /= No_Unit_Index\n-           and then Prev_Unit.File_Names (Kind) /= null\n-           and then not Source.Locally_Removed\n-           and then not Data.In_Aggregate_Lib\n-         then\n-            --  Path is set if this is a source we found on the disk, in which\n-            --  case we can provide more explicit error message. Path is unset\n-            --  when the source is added from one of the naming exceptions in\n-            --  the project.\n+            elsif Prev_Unit /= No_Unit_Index\n+              and then Prev_Unit.File_Names (Kind) /= null\n+              and then not Source.Locally_Removed\n+              and then not Data.In_Aggregate_Lib\n+            then\n+               --  Path is set if this is a source we found on the disk, in\n+               --  which case we can provide more explicit error message. Path\n+               --  is unset when the source is added from one of the naming\n+               --  exceptions in the project.\n \n-            if Path /= No_Path_Information then\n-               Error_Msg_Name_1 := Unit;\n-               Error_Msg\n-                 (Data.Flags,\n-                  \"unit %% cannot belong to several projects\",\n-                  Location, Project);\n+               if Path /= No_Path_Information then\n+                  Error_Msg_Name_1 := Unit;\n+                  Error_Msg\n+                    (Data.Flags,\n+                     \"unit %% cannot belong to several projects\",\n+                     Location, Project);\n \n-               Error_Msg_Name_1 := Project.Name;\n-               Error_Msg_Name_2 := Name_Id (Path.Display_Name);\n-               Error_Msg\n-                 (Data.Flags, \"\\  project %%, %%\", Location, Project);\n+                  Error_Msg_Name_1 := Project.Name;\n+                  Error_Msg_Name_2 := Name_Id (Path.Display_Name);\n+                  Error_Msg\n+                    (Data.Flags, \"\\  project %%, %%\", Location, Project);\n \n-               Error_Msg_Name_1 := Source.Project.Name;\n-               Error_Msg_Name_2 := Name_Id (Source.Path.Display_Name);\n-               Error_Msg\n-                 (Data.Flags, \"\\  project %%, %%\", Location, Project);\n+                  Error_Msg_Name_1 := Source.Project.Name;\n+                  Error_Msg_Name_2 := Name_Id (Source.Path.Display_Name);\n+                  Error_Msg\n+                    (Data.Flags, \"\\  project %%, %%\", Location, Project);\n \n-            else\n-               Error_Msg_Name_1 := Unit;\n-               Error_Msg_Name_2 := Source.Project.Name;\n-               Error_Msg\n-                 (Data.Flags, \"unit %% already belongs to project %%\",\n-                  Location, Project);\n-            end if;\n+               else\n+                  Error_Msg_Name_1 := Unit;\n+                  Error_Msg_Name_2 := Source.Project.Name;\n+                  Error_Msg\n+                    (Data.Flags, \"unit %% already belongs to project %%\",\n+                     Location, Project);\n+               end if;\n \n-            Add_Src := False;\n+               Add_Src := False;\n \n-         elsif not Source.Locally_Removed\n-           and then not Data.Flags.Allow_Duplicate_Basenames\n-           and then Lang_Id.Config.Kind = Unit_Based\n-           and then Source.Language.Config.Kind = Unit_Based\n-           and then not Data.In_Aggregate_Lib\n-         then\n-            Error_Msg_File_1 := File_Name;\n-            Error_Msg_File_2 := File_Name_Type (Source.Project.Name);\n-            Error_Msg\n-              (Data.Flags,\n-               \"{ is already a source of project {\", Location, Project);\n+            elsif not Source.Locally_Removed\n+              and then not Data.Flags.Allow_Duplicate_Basenames\n+              and then Lang_Id.Config.Kind = Unit_Based\n+              and then Source.Language.Config.Kind = Unit_Based\n+              and then not Data.In_Aggregate_Lib\n+            then\n+               Error_Msg_File_1 := File_Name;\n+               Error_Msg_File_2 := File_Name_Type (Source.Project.Name);\n+               Error_Msg\n+                 (Data.Flags,\n+                  \"{ is already a source of project {\", Location, Project);\n \n-            --  Add the file anyway, to avoid further warnings like \"language\n-            --  unknown\".\n+               --  Add the file anyway, to avoid further warnings like\n+               --  \"language unknown\".\n \n-            Add_Src := True;\n+               Add_Src := True;\n+            end if;\n          end if;\n-      end if;\n \n-      if not Add_Src then\n-         return;\n+         if not Add_Src then\n+            return;\n+         end if;\n       end if;\n \n       --  Add the new file"}, {"sha": "9fd9c659a097a2ad075b3212e1c06776371ee57b", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -99,7 +99,7 @@ package Sem_Aux is\n    function Constant_Value (Ent : Entity_Id) return Node_Id;\n    --  Ent is a variable, constant, named integer, or named real entity. This\n    --  call obtains the initialization expression for the entity. Will return\n-   --  Empty for for a deferred constant whose full view is not available or\n+   --  Empty for a deferred constant whose full view is not available or\n    --  in some other cases of internal entities, which cannot be treated as\n    --  constants from the point of view of constant folding. Empty is also\n    --  returned for variables with no initialization expression."}, {"sha": "0daeb4cee0ce2924d069d59b8c788f34ac7bceec", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db664118be5bc2ea3e04784d45da659b13af1ef8/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=db664118be5bc2ea3e04784d45da659b13af1ef8", "patch": "@@ -1302,7 +1302,16 @@ package body Sem_Eval is\n             if Ekind (E) = E_Enumeration_Literal then\n                return True;\n \n-            elsif Ekind (E) = E_Constant then\n+            --  In Alfa mode, the value of deferred constants should be ignored\n+            --  outside the scope of their full view. This allows parameterized\n+            --  formal verification, in which a deferred constant value if not\n+            --  known from client units.\n+\n+            elsif Ekind (E) = E_Constant\n+              and then not (Alfa_Mode\n+                             and then Present (Full_View (E))\n+                             and then not In_Open_Scopes (Scope (E)))\n+            then\n                V := Constant_Value (E);\n                return Present (V) and then Compile_Time_Known_Value (V);\n             end if;"}]}