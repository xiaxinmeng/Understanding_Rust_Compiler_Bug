{"sha": "eab02febcf4cd68c278d8c517d131d3f7a50933f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFiMDJmZWJjZjRjZDY4YzI3OGQ4YzUxN2QxMzFkM2Y3YTUwOTMzZg==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-09T10:25:44Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-09T10:25:44Z"}, "message": "flow.c (flow_loop_scan): Break out of ...\n\n\t* flow.c (flow_loop_scan): Break out of ...\n\t(flow_loops_find) ... here.\n\t* basic-block.h (flow_loop_scan): New.\n\t(LOOP_ENTRY_EDGES, LOOP_EXIT_EDGES): Add.\n\t(LOOP_EDGES, LOOP_EXITS_DOMS, LOOP_ALL): Redefine.\n\nFrom-SVN: r38822", "tree": {"sha": "a15d6fb57cb13bc26a6ce53829f8821e926dd07f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a15d6fb57cb13bc26a6ce53829f8821e926dd07f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eab02febcf4cd68c278d8c517d131d3f7a50933f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab02febcf4cd68c278d8c517d131d3f7a50933f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab02febcf4cd68c278d8c517d131d3f7a50933f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab02febcf4cd68c278d8c517d131d3f7a50933f/comments", "author": null, "committer": null, "parents": [{"sha": "4b49c3657f581b4f484f7dd380d174a95449cdd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b49c3657f581b4f484f7dd380d174a95449cdd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b49c3657f581b4f484f7dd380d174a95449cdd1"}], "stats": {"total": 130, "additions": 84, "deletions": 46}, "files": [{"sha": "81c6a018b7962ad3227ef0c1e86f9c3ac512334a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab02febcf4cd68c278d8c517d131d3f7a50933f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab02febcf4cd68c278d8c517d131d3f7a50933f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eab02febcf4cd68c278d8c517d131d3f7a50933f", "patch": "@@ -1,3 +1,11 @@\n+2001-01-09  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* flow.c (flow_loop_scan): Break out of ...\n+\t(flow_loops_find) ... here.\n+\t* basic-block.h (flow_loop_scan): New.\n+\t(LOOP_ENTRY_EDGES, LOOP_EXIT_EDGES): Add.\n+\t(LOOP_EDGES, LOOP_EXITS_DOMS, LOOP_ALL): Redefine.\n+\n 2001-01-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* cppinit.c (cpp_cleanup): NULLify macro_buffer and zero"}, {"sha": "c48a54701b38b4db44080e1f79aae441c4144573", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab02febcf4cd68c278d8c517d131d3f7a50933f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab02febcf4cd68c278d8c517d131d3f7a50933f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=eab02febcf4cd68c278d8c517d131d3f7a50933f", "patch": "@@ -428,6 +428,7 @@ extern void flow_loops_dump PARAMS ((const struct loops *, FILE *,\n extern void flow_loop_dump PARAMS ((const struct loop *, FILE *,\n \t\t\t\t    void (*)(const struct loop *,\n \t\t\t\t\t     FILE *, int), int));\n+extern int flow_loop_scan PARAMS ((struct loops *, struct loop *, int));\n \n /* This structure maintains an edge list vector.  */\n struct edge_list \n@@ -485,9 +486,11 @@ enum update_life_extent\n \n #define LOOP_TREE\t\t1 \t/* Build loop hierarchy tree.  */\n #define LOOP_PRE_HEADER\t\t2\t/* Analyse loop pre-header.  */\n-#define LOOP_EDGES\t\t4 \t/* Find entry and exit edges.  */\n-#define LOOP_EXITS_DOMS\t\t8 \t/* Find nodes that dom. all exits.  */\n-#define LOOP_ALL\t       15 \t/* All of the above  */\n+#define LOOP_ENTRY_EDGES\t4 \t/* Find entry edges.  */\n+#define LOOP_EXIT_EDGES\t\t8 \t/* Find exit edges.  */\n+#define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n+#define LOOP_EXITS_DOMS\t       16 \t/* Find nodes that dom. all exits.  */\n+#define LOOP_ALL\t       31 \t/* All of the above  */\n \n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern void update_life_info\tPARAMS ((sbitmap, enum update_life_extent,"}, {"sha": "faed23fdd0cfd7323eab8a2812109c0f18e35326", "filename": "gcc/flow.c", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab02febcf4cd68c278d8c517d131d3f7a50933f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab02febcf4cd68c278d8c517d131d3f7a50933f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=eab02febcf4cd68c278d8c517d131d3f7a50933f", "patch": "@@ -8137,6 +8137,70 @@ flow_loops_level_compute (loops)\n }\n \n \n+/* Scan a single natural loop specified by LOOP collecting information\n+   about it specified by FLAGS.  */\n+\n+int\n+flow_loop_scan (loops, loop, flags)\n+     struct loops *loops;\n+     struct loop *loop;\n+     int flags;\n+{\n+  /* Determine prerequisites.  */\n+  if ((flags & LOOP_EXITS_DOMS) && ! loop->exit_edges)\n+    flags |= LOOP_EXIT_EDGES;\n+\n+  if (flags & LOOP_ENTRY_EDGES)\n+    {\n+      /* Find edges which enter the loop header.\n+\t Note that the entry edges should only\n+\t enter the header of a natural loop.  */\n+      loop->num_entries\n+\t= flow_loop_entry_edges_find (loop->header,\n+\t\t\t\t      loop->nodes,\n+\t\t\t\t      &loop->entry_edges);\n+    }\n+\n+  if (flags & LOOP_EXIT_EDGES)\n+    {\n+      /* Find edges which exit the loop.  */\n+      loop->num_exits\n+\t= flow_loop_exit_edges_find (loop->nodes,\n+\t\t\t\t     &loop->exit_edges);\n+    }\n+\n+  if (flags & LOOP_EXITS_DOMS)\n+    {\n+      int j;\n+\n+      /* Determine which loop nodes dominate all the exits\n+\t of the loop.  */\n+      loop->exits_doms = sbitmap_alloc (n_basic_blocks);\n+      sbitmap_copy (loop->exits_doms, loop->nodes);\n+      for (j = 0; j < loop->num_exits; j++)\n+\tsbitmap_a_and_b (loop->exits_doms, loop->exits_doms,\n+\t\t\t loops->cfg.dom[loop->exit_edges[j]->src->index]);\n+      \n+      /* The header of a natural loop must dominate\n+\t all exits.  */\n+      if (! TEST_BIT (loop->exits_doms, loop->header->index))\n+\tabort ();\n+    }\n+  \n+  if (flags & LOOP_PRE_HEADER)\n+    {\n+      /* Look to see if the loop has a pre-header node.  */\n+      loop->pre_header\n+\t= flow_loop_pre_header_find (loop->header, loops->cfg.dom);\n+\n+      /* Find the blocks within the extended basic block of\n+\t the loop pre-header.  */\n+      flow_loop_pre_header_scan (loop);\n+    }\n+  return 1;\n+}\n+\n+\n /* Find all the natural loops in the function and save in LOOPS structure\n    and recalculate loop_depth information in basic block structures.\n    FLAGS controls which loop information is collected.\n@@ -8213,6 +8277,11 @@ flow_loops_find (loops, flags)\n       rc_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n       flow_depth_first_order_compute (dfs_order, rc_order);\n \n+      /* Save CFG derived information to avoid recomputing it.  */\n+      loops->cfg.dom = dom;\n+      loops->cfg.dfs_order = dfs_order;\n+      loops->cfg.rc_order = rc_order;\n+\n       /* Allocate loop structures.  */\n       loops->array\n \t= (struct loop *) xcalloc (num_loops, sizeof (struct loop));\n@@ -8264,7 +8333,6 @@ flow_loops_find (loops, flags)\n       for (i = 0; i < num_loops; i++)\n \t{\n \t  struct loop *loop = &loops->array[i];\n-\t  int j;\n \n \t  /* Keep track of blocks that are loop headers so\n \t     that we can tell which loops should be merged.  */\n@@ -8286,43 +8354,7 @@ flow_loops_find (loops, flags)\n \t  loop->last\n \t    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));\n \n-\t  if (flags & LOOP_EDGES)\n-\t    {\n-\t      /* Find edges which enter the loop header.\n-\t\t Note that the entry edges should only\n-\t\t enter the header of a natural loop.  */\n-\t      loop->num_entries\n-\t\t= flow_loop_entry_edges_find (loop->header,\n-\t\t\t\t\t      loop->nodes,\n-\t\t\t\t\t      &loop->entry_edges);\n-\n-\t      /* Find edges which exit the loop.  */\n-\t      loop->num_exits\n-\t\t= flow_loop_exit_edges_find (loop->nodes,\n-\t\t\t\t\t     &loop->exit_edges);\n-\n-\t      /* Determine which loop nodes dominate all the exits\n-\t\t of the loop.  */\n-\t      loop->exits_doms = sbitmap_alloc (n_basic_blocks);\n-\t      sbitmap_copy (loop->exits_doms, loop->nodes);\n-\t      for (j = 0; j < loop->num_exits; j++)\n-\t\tsbitmap_a_and_b (loop->exits_doms, loop->exits_doms,\n-\t\t\t\t dom[loop->exit_edges[j]->src->index]);\n-\n-\t      /* The header of a natural loop must dominate\n-\t\t all exits.  */\n-\t      if (! TEST_BIT (loop->exits_doms, loop->header->index))\n-\t\tabort ();\n-\t    }\n-\n-\t  if (flags & LOOP_PRE_HEADER)\n-\t    {\n-\t      /* Look to see if the loop has a pre-header node.  */\n-\t      loop->pre_header\n-\t\t= flow_loop_pre_header_find (loop->header, dom);\n-\n-\t      flow_loop_pre_header_scan (loop);\n-\t    }\n+\t  flow_loop_scan (loops, loop, flags);\n \t}\n \n       /* Natural loops with shared headers may either be disjoint or\n@@ -8338,11 +8370,6 @@ flow_loops_find (loops, flags)\n \n   loops->num = num_loops;\n \n-  /* Save CFG derived information to avoid recomputing it.  */\n-  loops->cfg.dom = dom;\n-  loops->cfg.dfs_order = dfs_order;\n-  loops->cfg.rc_order = rc_order;\n-\n   /* Build the loop hierarchy tree.  */\n   flow_loops_tree_build (loops);\n "}]}