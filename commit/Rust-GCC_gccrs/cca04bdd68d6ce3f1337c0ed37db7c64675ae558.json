{"sha": "cca04bdd68d6ce3f1337c0ed37db7c64675ae558", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NhMDRiZGQ2OGQ2Y2UzZjEzMzdjMGVkMzdkYjdjNjQ2NzVhZTU1OA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-10-14T09:31:29Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-14T09:31:29Z"}, "message": "sync.md (FILD_ATOMIC/FIST_ATOMIC FP load peephole2): Use any_fp_register_operand as operand[3] predicate.\n\n\t* config/i386/sync.md (FILD_ATOMIC/FIST_ATOMIC FP load peephole2):\n\tUse any_fp_register_operand as operand[3] predicate.  Simplify\n\tequality test for operands[2] and operands[4] memory location.\n\t(LDX_ATOMIC/STX_ATOMIC FP load peephole2): Ditto.\n\t(FILD_ATOMIC/FIST_ATOMIC FP load peephole2 with mem blockage): New.\n\t(LDX_ATOMIC/LDX_ATOMIC FP load peephole2 with mem blockage): Ditto.\n\t(FILD_ATOMIC/FIST_ATOMIC FP store peephole2): Use\n\tany_fp_register_operand as operand[1] predicate.  Simplify\n\tequality test for operands[0] and operands[3] memory location.\n\t(LDX_ATOMIC/STX_ATOMIC FP store peephole2): Ditto.\n\t(FILD_ATOMIC/FIST_ATOMIC FP store peephole2 with mem blockage): New.\n\t(LDX_ATOMIC/LDX_ATOMIC FP storepeephole2 with mem blockage): Ditto.\n\nFrom-SVN: r253751", "tree": {"sha": "aed267b21a2d12488a3d6b62b2d5b687e27fd1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed267b21a2d12488a3d6b62b2d5b687e27fd1c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cca04bdd68d6ce3f1337c0ed37db7c64675ae558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca04bdd68d6ce3f1337c0ed37db7c64675ae558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca04bdd68d6ce3f1337c0ed37db7c64675ae558", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca04bdd68d6ce3f1337c0ed37db7c64675ae558/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51ced7e4f45051399a2b7aa59b59f9d655be99a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ced7e4f45051399a2b7aa59b59f9d655be99a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51ced7e4f45051399a2b7aa59b59f9d655be99a7"}], "stats": {"total": 115, "additions": 107, "deletions": 8}, "files": [{"sha": "212df0ff1d2a71317c4379b749abf65c7898deb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca04bdd68d6ce3f1337c0ed37db7c64675ae558/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca04bdd68d6ce3f1337c0ed37db7c64675ae558/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cca04bdd68d6ce3f1337c0ed37db7c64675ae558", "patch": "@@ -1,3 +1,18 @@\n+2017-10-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/sync.md (FILD_ATOMIC/FIST_ATOMIC FP load peephole2):\n+\tUse any_fp_register_operand as operand[3] predicate.  Simplify\n+\tequality test for operands[2] and operands[4] memory location.\n+\t(LDX_ATOMIC/STX_ATOMIC FP load peephole2): Ditto.\n+\t(FILD_ATOMIC/FIST_ATOMIC FP load peephole2 with mem blockage): New.\n+\t(LDX_ATOMIC/LDX_ATOMIC FP load peephole2 with mem blockage): Ditto.\n+\t(FILD_ATOMIC/FIST_ATOMIC FP store peephole2): Use\n+\tany_fp_register_operand as operand[1] predicate.  Simplify\n+\tequality test for operands[0] and operands[3] memory location.\n+\t(LDX_ATOMIC/STX_ATOMIC FP store peephole2): Ditto.\n+\t(FILD_ATOMIC/FIST_ATOMIC FP store peephole2 with mem blockage): New.\n+\t(LDX_ATOMIC/LDX_ATOMIC FP storepeephole2 with mem blockage): Ditto.\n+\n 2017-10-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* target-insns.def: Add memory_blockage."}, {"sha": "eceaa73a6799150439697d845ce1f0bc9140a94b", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca04bdd68d6ce3f1337c0ed37db7c64675ae558/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca04bdd68d6ce3f1337c0ed37db7c64675ae558/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=cca04bdd68d6ce3f1337c0ed37db7c64675ae558", "patch": "@@ -219,29 +219,71 @@\n    (set (match_operand:DI 2 \"memory_operand\")\n \t(unspec:DI [(match_dup 0)]\n \t\t   UNSPEC_FIST_ATOMIC))\n-   (set (match_operand:DF 3 \"fp_register_operand\")\n+   (set (match_operand:DF 3 \"any_fp_register_operand\")\n \t(match_operand:DF 4 \"memory_operand\"))]\n   \"!TARGET_64BIT\n    && peep2_reg_dead_p (2, operands[0])\n-   && rtx_equal_p (operands[4], adjust_address_nv (operands[2], DFmode, 0))\"\n+   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))\"\n   [(set (match_dup 3) (match_dup 5))]\n   \"operands[5] = gen_lowpart (DFmode, operands[1]);\")\n \n+(define_peephole2\n+  [(set (match_operand:DF 0 \"fp_register_operand\")\n+\t(unspec:DF [(match_operand:DI 1 \"memory_operand\")]\n+\t\t   UNSPEC_FILD_ATOMIC))\n+   (set (match_operand:DI 2 \"memory_operand\")\n+\t(unspec:DI [(match_dup 0)]\n+\t\t   UNSPEC_FIST_ATOMIC))\n+   (set (mem:BLK (scratch:SI))\n+\t(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))\n+   (set (match_operand:DF 3 \"any_fp_register_operand\")\n+\t(match_operand:DF 4 \"memory_operand\"))]\n+  \"!TARGET_64BIT\n+   && peep2_reg_dead_p (2, operands[0])\n+   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))\"\n+  [(const_int 0)]\n+{\n+  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));\n+  emit_insn (gen_memory_blockage ());\n+  DONE;\n+})\n+\n (define_peephole2\n   [(set (match_operand:DF 0 \"sse_reg_operand\")\n \t(unspec:DF [(match_operand:DI 1 \"memory_operand\")]\n \t\t   UNSPEC_LDX_ATOMIC))\n    (set (match_operand:DI 2 \"memory_operand\")\n \t(unspec:DI [(match_dup 0)]\n \t\t   UNSPEC_STX_ATOMIC))\n-   (set (match_operand:DF 3 \"fp_register_operand\")\n+   (set (match_operand:DF 3 \"any_fp_register_operand\")\n \t(match_operand:DF 4 \"memory_operand\"))]\n   \"!TARGET_64BIT\n    && peep2_reg_dead_p (2, operands[0])\n-   && rtx_equal_p (operands[4], adjust_address_nv (operands[2], DFmode, 0))\"\n+   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))\"\n   [(set (match_dup 3) (match_dup 5))]\n   \"operands[5] = gen_lowpart (DFmode, operands[1]);\")\n \n+(define_peephole2\n+  [(set (match_operand:DF 0 \"sse_reg_operand\")\n+\t(unspec:DF [(match_operand:DI 1 \"memory_operand\")]\n+\t\t   UNSPEC_LDX_ATOMIC))\n+   (set (match_operand:DI 2 \"memory_operand\")\n+\t(unspec:DI [(match_dup 0)]\n+\t\t   UNSPEC_STX_ATOMIC))\n+   (set (mem:BLK (scratch:SI))\n+\t(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))\n+   (set (match_operand:DF 3 \"any_fp_register_operand\")\n+\t(match_operand:DF 4 \"memory_operand\"))]\n+  \"!TARGET_64BIT\n+   && peep2_reg_dead_p (2, operands[0])\n+   && rtx_equal_p (XEXP (operands[4], 0), XEXP (operands[2], 0))\"\n+  [(const_int 0)]\n+{\n+  emit_move_insn (operands[3], gen_lowpart (DFmode, operands[1]));\n+  emit_insn (gen_memory_blockage ());\n+  DONE;\n+})\n+\n (define_expand \"atomic_store<mode>\"\n   [(set (match_operand:ATOMIC 0 \"memory_operand\")\n \t(unspec:ATOMIC [(match_operand:ATOMIC 1 \"nonimmediate_operand\")\n@@ -331,7 +373,7 @@\n \n (define_peephole2\n   [(set (match_operand:DF 0 \"memory_operand\")\n-\t(match_operand:DF 1 \"fp_register_operand\"))\n+\t(match_operand:DF 1 \"any_fp_register_operand\"))\n    (set (match_operand:DF 2 \"fp_register_operand\")\n \t(unspec:DF [(match_operand:DI 3 \"memory_operand\")]\n \t\t   UNSPEC_FILD_ATOMIC))\n@@ -340,13 +382,34 @@\n \t\t   UNSPEC_FIST_ATOMIC))]\n   \"!TARGET_64BIT\n    && peep2_reg_dead_p (3, operands[2])\n-   && rtx_equal_p (operands[0], adjust_address_nv (operands[3], DFmode, 0))\"\n+   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))\"\n   [(set (match_dup 5) (match_dup 1))]\n   \"operands[5] = gen_lowpart (DFmode, operands[4]);\")\n \n (define_peephole2\n   [(set (match_operand:DF 0 \"memory_operand\")\n-\t(match_operand:DF 1 \"fp_register_operand\"))\n+\t(match_operand:DF 1 \"any_fp_register_operand\"))\n+   (set (mem:BLK (scratch:SI))\n+\t(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))\n+   (set (match_operand:DF 2 \"fp_register_operand\")\n+\t(unspec:DF [(match_operand:DI 3 \"memory_operand\")]\n+\t\t   UNSPEC_FILD_ATOMIC))\n+   (set (match_operand:DI 4 \"memory_operand\")\n+\t(unspec:DI [(match_dup 2)]\n+\t\t   UNSPEC_FIST_ATOMIC))]\n+  \"!TARGET_64BIT\n+   && peep2_reg_dead_p (4, operands[2])\n+   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_memory_blockage ());\n+  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);\n+  DONE;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:DF 0 \"memory_operand\")\n+\t(match_operand:DF 1 \"any_fp_register_operand\"))\n    (set (match_operand:DF 2 \"sse_reg_operand\")\n \t(unspec:DF [(match_operand:DI 3 \"memory_operand\")]\n \t\t   UNSPEC_LDX_ATOMIC))\n@@ -355,10 +418,31 @@\n \t\t   UNSPEC_STX_ATOMIC))]\n   \"!TARGET_64BIT\n    && peep2_reg_dead_p (3, operands[2])\n-   && rtx_equal_p (operands[0], adjust_address_nv (operands[3], DFmode, 0))\"\n+   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))\"\n   [(set (match_dup 5) (match_dup 1))]\n   \"operands[5] = gen_lowpart (DFmode, operands[4]);\")\n \n+(define_peephole2\n+  [(set (match_operand:DF 0 \"memory_operand\")\n+\t(match_operand:DF 1 \"any_fp_register_operand\"))\n+   (set (mem:BLK (scratch:SI))\n+\t(unspec:BLK [(mem:BLK (scratch:SI))] UNSPEC_MEMORY_BLOCKAGE))\n+   (set (match_operand:DF 2 \"sse_reg_operand\")\n+\t(unspec:DF [(match_operand:DI 3 \"memory_operand\")]\n+\t\t   UNSPEC_LDX_ATOMIC))\n+   (set (match_operand:DI 4 \"memory_operand\")\n+\t(unspec:DI [(match_dup 2)]\n+\t\t   UNSPEC_STX_ATOMIC))]\n+  \"!TARGET_64BIT\n+   && peep2_reg_dead_p (4, operands[2])\n+   && rtx_equal_p (XEXP (operands[0], 0), XEXP (operands[3], 0))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_memory_blockage ());\n+  emit_move_insn (gen_lowpart (DFmode, operands[4]), operands[1]);\n+  DONE;\n+})\n+\n ;; ??? You'd think that we'd be able to perform this via FLOAT + FIX_TRUNC\n ;; operations.  But the fix_trunc patterns want way more setup than we want\n ;; to provide.  Note that the scratch is DFmode instead of XFmode in order"}]}