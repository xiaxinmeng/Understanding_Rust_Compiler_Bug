{"sha": "9f55df63154a39d67ef5b24def7044bf87300831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY1NWRmNjMxNTRhMzlkNjdlZjViMjRkZWY3MDQ0YmY4NzMwMDgzMQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-01T01:05:09Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-01T18:50:32Z"}, "message": "Replace conditional_replacement with match and simplify\n\nThis is the first of series of patches to simplify phi-opt\nto use match and simplify in many cases.  This simplification\nwill more things to optimize.\n\nThis is what Richard requested in\nhttps://gcc.gnu.org/pipermail/gcc-patches/2021-May/571197.html\nand I think it is the right thing to do too.\n\nOK? Bootstrapped and tested on x86_64-linux-gnu with no regressions.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/25290\n\t* tree-ssa-phiopt.c (match_simplify_replacement):\n\tNew function.\n\t(tree_ssa_phiopt_worker): Use match_simplify_replacement.\n\t(two_value_replacement): Change the comment about\n\tconditional_replacement.\n\t(conditional_replacement): Delete.", "tree": {"sha": "112db297766b38cf773e61304c08db65f3927116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/112db297766b38cf773e61304c08db65f3927116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f55df63154a39d67ef5b24def7044bf87300831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f55df63154a39d67ef5b24def7044bf87300831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f55df63154a39d67ef5b24def7044bf87300831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f55df63154a39d67ef5b24def7044bf87300831/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea418485c700494c3efdc282854c5f5a08702416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea418485c700494c3efdc282854c5f5a08702416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea418485c700494c3efdc282854c5f5a08702416"}], "stats": {"total": 144, "additions": 39, "deletions": 105}, "files": [{"sha": "969b868397ed4626994355cf3c5b0390a71ab291", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 39, "deletions": 105, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f55df63154a39d67ef5b24def7044bf87300831/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f55df63154a39d67ef5b24def7044bf87300831/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=9f55df63154a39d67ef5b24def7044bf87300831", "patch": "@@ -53,8 +53,8 @@ along with GCC; see the file COPYING3.  If not see\n static unsigned int tree_ssa_phiopt_worker (bool, bool, bool);\n static bool two_value_replacement (basic_block, basic_block, edge, gphi *,\n \t\t\t\t   tree, tree);\n-static bool conditional_replacement (basic_block, basic_block,\n-\t\t\t\t     edge, edge, gphi *, tree, tree);\n+static bool match_simplify_replacement (basic_block, basic_block,\n+\t\t\t\t\tedge, edge, gphi *, tree, tree);\n static gphi *factor_out_conditional_conversion (edge, edge, gphi *, tree, tree,\n \t\t\t\t\t\tgimple *);\n static int value_replacement (basic_block, basic_block,\n@@ -347,8 +347,8 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t  if (!early_p && two_value_replacement (bb, bb1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n \t  else if (!early_p\n-\t\t   && conditional_replacement (bb, bb1, e1, e2, phi,\n-\t\t\t\t\t       arg0, arg1))\n+\t\t   && match_simplify_replacement (bb, bb1, e1, e2, phi,\n+\t\t\t\t\t\t  arg0, arg1))\n \t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n@@ -675,7 +675,7 @@ two_value_replacement (basic_block cond_bb, basic_block middle_bb,\n     }\n \n   /* Defer boolean x ? 0 : {1,-1} or x ? {1,-1} : 0 to\n-     conditional_replacement.  */\n+     match_simplify_replacement.  */\n   if (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE\n       && (integer_zerop (arg0)\n \t  || integer_zerop (arg1)\n@@ -784,137 +784,71 @@ two_value_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n-/*  The function conditional_replacement does the main work of doing the\n-    conditional replacement.  Return true if the replacement is done.\n+/*  The function match_simplify_replacement does the main work of doing the\n+    replacement using match and simplify.  Return true if the replacement is done.\n     Otherwise return false.\n     BB is the basic block where the replacement is going to be done on.  ARG0\n     is argument 0 from PHI.  Likewise for ARG1.  */\n \n static bool\n-conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n-\t\t\t edge e0, edge e1, gphi *phi,\n-\t\t\t tree arg0, tree arg1)\n+match_simplify_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t\t    edge e0, edge e1, gphi *phi,\n+\t\t\t    tree arg0, tree arg1)\n {\n-  tree result;\n   gimple *stmt;\n-  gassign *new_stmt;\n   tree cond;\n   gimple_stmt_iterator gsi;\n   edge true_edge, false_edge;\n-  tree new_var, new_var2;\n-  bool neg = false;\n-  int shift = 0;\n-  tree nonzero_arg;\n-\n-  /* FIXME: Gimplification of complex type is too hard for now.  */\n-  /* We aren't prepared to handle vectors either (and it is a question\n-     if it would be worthwhile anyway).  */\n-  if (!(INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n-\t|| POINTER_TYPE_P (TREE_TYPE (arg0)))\n-      || !(INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t   || POINTER_TYPE_P (TREE_TYPE (arg1))))\n-    return false;\n+  gimple_seq seq = NULL;\n+  tree result;\n \n-  /* The PHI arguments have the constants 0 and 1, or 0 and -1 or\n-     0 and (1 << cst), then convert it to the conditional.  */\n-  if (integer_zerop (arg0))\n-    nonzero_arg = arg1;\n-  else if (integer_zerop (arg1))\n-    nonzero_arg = arg0;\n-  else\n-    return false;\n-  if (integer_pow2p (nonzero_arg))\n-    {\n-      shift = tree_log2 (nonzero_arg);\n-      if (shift && POINTER_TYPE_P (TREE_TYPE (nonzero_arg)))\n-\treturn false;\n-    }\n-  else if (integer_all_onesp (nonzero_arg))\n-    neg = true;\n-  else\n+  if (!empty_block_p (middle_bb))\n     return false;\n \n-  if (!empty_block_p (middle_bb))\n+  /* Special case A ? B : B as this will always simplify to B. */\n+  if (operand_equal_for_phi_arg_p (arg0, arg1))\n     return false;\n \n-  /* At this point we know we have a GIMPLE_COND with two successors.\n+    /* At this point we know we have a GIMPLE_COND with two successors.\n      One successor is BB, the other successor is an empty block which\n      falls through into BB.\n \n-     There is a single PHI node at the join point (BB) and its arguments\n-     are constants (0, 1) or (0, -1) or (0, (1 << shift)).\n-\n-     So, given the condition COND, and the two PHI arguments, we can\n-     rewrite this PHI into non-branching code:\n-\n-       dest = (COND) or dest = COND' or dest = (COND) << shift\n+     There is a single PHI node at the join point (BB).\n \n-     We use the condition as-is if the argument associated with the\n-     true edge has the value one or the argument associated with the\n-     false edge as the value zero.  Note that those conditions are not\n-     the same since only one of the outgoing edges from the GIMPLE_COND\n-     will directly reach BB and thus be associated with an argument.  */\n+     So, given the condition COND, and the two PHI arguments, match and simplify\n+     can happen on (COND) ? arg0 : arg1. */\n \n   stmt = last_stmt (cond_bb);\n-  result = PHI_RESULT (phi);\n \n   /* To handle special cases like floating point comparison, it is easier and\n      less error-prone to build a tree and gimplify it on the fly though it is\n-     less efficient.  */\n-  cond = fold_build2_loc (gimple_location (stmt),\n-\t\t\t  gimple_cond_code (stmt), boolean_type_node,\n-\t\t\t  gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n+     less efficient.\n+     Don't use fold_build2 here as that might create (bool)a instead of just\n+     \"a != 0\".  */\n+  cond = build2_loc (gimple_location (stmt),\n+\t\t     gimple_cond_code (stmt), boolean_type_node,\n+\t\t     gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n \n   /* We need to know which is the true edge and which is the false\n      edge so that we know when to invert the condition below.  */\n   extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n-  if ((e0 == true_edge && integer_zerop (arg0))\n-      || (e0 == false_edge && !integer_zerop (arg0))\n-      || (e1 == true_edge && integer_zerop (arg1))\n-      || (e1 == false_edge && !integer_zerop (arg1)))\n-    cond = fold_build1_loc (gimple_location (stmt),\n-                            TRUTH_NOT_EXPR, TREE_TYPE (cond), cond);\n-\n-  if (neg)\n-    {\n-      cond = fold_convert_loc (gimple_location (stmt),\n-                               TREE_TYPE (result), cond);\n-      cond = fold_build1_loc (gimple_location (stmt),\n-                              NEGATE_EXPR, TREE_TYPE (cond), cond);\n-    }\n-  else if (shift)\n-    {\n-      cond = fold_convert_loc (gimple_location (stmt),\n-\t\t\t       TREE_TYPE (result), cond);\n-      cond = fold_build2_loc (gimple_location (stmt),\n-\t\t\t      LSHIFT_EXPR, TREE_TYPE (cond), cond,\n-\t\t\t      build_int_cst (integer_type_node, shift));\n-    }\n-\n-  /* Insert our new statements at the end of conditional block before the\n-     COND_STMT.  */\n-  gsi = gsi_for_stmt (stmt);\n-  new_var = force_gimple_operand_gsi (&gsi, cond, true, NULL, true,\n-\t\t\t\t      GSI_SAME_STMT);\n+  if (e1 == true_edge || e0 == false_edge)\n+    std::swap (arg0, arg1);\n \n-  if (!useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (new_var)))\n-    {\n-      location_t locus_0, locus_1;\n+  tree type = TREE_TYPE (gimple_phi_result (phi));\n+  result = gimple_simplify (COND_EXPR, type,\n+\t\t\t    cond,\n+\t\t\t    arg0, arg1,\n+\t\t\t    &seq, NULL);\n+  if (!result)\n+    return false;\n \n-      new_var2 = make_ssa_name (TREE_TYPE (result));\n-      new_stmt = gimple_build_assign (new_var2, CONVERT_EXPR, new_var);\n-      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n-      new_var = new_var2;\n+  gsi = gsi_last_bb (cond_bb);\n \n-      /* Set the locus to the first argument, unless is doesn't have one.  */\n-      locus_0 = gimple_phi_arg_location (phi, 0);\n-      locus_1 = gimple_phi_arg_location (phi, 1);\n-      if (locus_0 == UNKNOWN_LOCATION)\n-        locus_0 = locus_1;\n-      gimple_set_location (new_stmt, locus_0);\n-    }\n+  if (seq)\n+    gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n \n-  replace_phi_edge_with_variable (cond_bb, e1, phi, new_var);\n+  replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n \n   /* Note that we optimized this PHI.  */\n   return true;\n@@ -3627,7 +3561,7 @@ gate_hoist_loads (void)\n    Conditional Replacement\n    -----------------------\n \n-   This transformation, implemented in conditional_replacement,\n+   This transformation, implemented in match_simplify_replacement,\n    replaces\n \n      bb0:"}]}