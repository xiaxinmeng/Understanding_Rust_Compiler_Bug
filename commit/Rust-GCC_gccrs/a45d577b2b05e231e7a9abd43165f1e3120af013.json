{"sha": "a45d577b2b05e231e7a9abd43165f1e3120af013", "node_id": "C_kwDOANBUbNoAKGE0NWQ1NzdiMmIwNWUyMzFlN2E5YWJkNDMxNjVmMWUzMTIwYWYwMTM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-02T21:07:37Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T09:36:10Z"}, "message": "libstdc++: Refactor emplace-like functions in std::variant\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/variant (__detail::__variant::__emplace): New\n\tfunction template.\n\t(_Copy_assign_base::operator=): Reorder conditions to match\n\tbulleted list of effects in the standard. Use __emplace instead\n\tof _M_reset followed by _Construct.\n\t(_Move_assign_base::operator=): Likewise.\n\t(__construct_by_index): Remove.\n\t(variant::emplace): Use __emplace instead of _M_reset followed\n\tby __construct_by_index.\n\t(variant::swap): Hoist valueless cases out of visitor. Use\n\t__emplace to replace _M_reset followed by _Construct.", "tree": {"sha": "eec42520221ef34b366211f04a89e0c9b97ad903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec42520221ef34b366211f04a89e0c9b97ad903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a45d577b2b05e231e7a9abd43165f1e3120af013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45d577b2b05e231e7a9abd43165f1e3120af013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45d577b2b05e231e7a9abd43165f1e3120af013", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45d577b2b05e231e7a9abd43165f1e3120af013/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30ab6d9e435dd3158d971cf9353eec8009955cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ab6d9e435dd3158d971cf9353eec8009955cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ab6d9e435dd3158d971cf9353eec8009955cb3"}], "stats": {"total": 179, "additions": 82, "deletions": 97}, "files": [{"sha": "c4c307b7bb2b35f51711a2c17b82d1aad3ab7716", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 82, "deletions": 97, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45d577b2b05e231e7a9abd43165f1e3120af013/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45d577b2b05e231e7a9abd43165f1e3120af013/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=a45d577b2b05e231e7a9abd43165f1e3120af013", "patch": "@@ -590,6 +590,19 @@ namespace __variant\n       __index_type _M_index;\n     };\n \n+  // Implementation of v.emplace<N>(args...).\n+  template<size_t _Np, bool _Triv, typename... _Types, typename... _Args>\n+    _GLIBCXX20_CONSTEXPR\n+    inline void\n+    __emplace(_Variant_storage<_Triv, _Types...>& __v, _Args&&... __args)\n+    {\n+      __v._M_reset();\n+      auto* __addr = std::__addressof(__variant::__get_n<_Np>(__v._M_u));\n+      std::_Construct(__addr, std::forward<_Args>(__args)...);\n+      // Construction didn't throw, so can set the new index now:\n+      __v._M_index = _Np;\n+    }\n+\n   template<typename... _Types>\n     using _Variant_storage_alias =\n \t_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;\n@@ -655,6 +668,7 @@ namespace __variant\n \t  }, __variant_cast<_Types...>(std::move(__rhs)));\n \tthis->_M_index = __rhs._M_index;\n       }\n+\n       _Move_ctor_base(const _Move_ctor_base&) = default;\n       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;\n       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;\n@@ -685,36 +699,24 @@ namespace __variant\n \t__variant::__raw_idx_visit(\n \t  [this](auto&& __rhs_mem, auto __rhs_index) mutable\n \t  {\n-\t    if constexpr (__rhs_index != variant_npos)\n+\t    constexpr size_t __j = __rhs_index;\n+\t    if constexpr (__j == variant_npos)\n+\t      this->_M_reset(); // Make *this valueless.\n+\t    else if (this->_M_index == __j)\n+\t      __variant::__get<__j>(*this) = __rhs_mem;\n+\t    else\n \t      {\n-\t\tif (this->_M_index == __rhs_index)\n-\t\t  __variant::__get<__rhs_index>(*this) = __rhs_mem;\n+\t\tusing _Tj = typename _Nth_type<__j, _Types...>::type;\n+\t\tif constexpr (is_nothrow_copy_constructible_v<_Tj>\n+\t\t\t      || !is_nothrow_move_constructible_v<_Tj>)\n+\t\t  __variant::__emplace<__j>(*this, __rhs_mem);\n \t\telse\n \t\t  {\n-\t\t    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;\n-\t\t    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>\n-\t\t\t|| !is_nothrow_move_constructible_v<__rhs_type>)\n-\t\t      {\n-\t\t\t// The standard says emplace<__rhs_index>(__rhs_mem)\n-\t\t\t// should be used here, but this is equivalent. Either\n-\t\t\t// copy construction doesn't throw, so we have strong\n-\t\t\t// exception safety guarantee, or both copy construction\n-\t\t\t// and move construction can throw, so emplace only\n-\t\t\t// gives basic exception safety anyway.\n-\t\t\tthis->_M_reset();\n-\t\t\tstd::_Construct(std::__addressof(this->_M_u),\n-\t\t\t\t\tin_place_index<__rhs_index>,\n-\t\t\t\t\t__rhs_mem);\n-\t\t\tthis->_M_index = __rhs_index;\n-\t\t      }\n-\t\t    else\n-\t\t      __variant_cast<_Types...>(*this)\n-\t\t\t= variant<_Types...>(std::in_place_index<__rhs_index>,\n-\t\t\t\t\t     __rhs_mem);\n+\t\t    using _Variant = variant<_Types...>;\n+\t\t    _Variant& __self = __variant_cast<_Types...>(*this);\n+\t\t    __self = _Variant(in_place_index<__j>, __rhs_mem);\n \t\t  }\n \t      }\n-\t    else\n-\t      this->_M_reset();\n \t  }, __variant_cast<_Types...>(__rhs));\n \treturn *this;\n       }\n@@ -749,13 +751,23 @@ namespace __variant\n \t__variant::__raw_idx_visit(\n \t  [this](auto&& __rhs_mem, auto __rhs_index) mutable\n \t  {\n-\t    if constexpr (__rhs_index != variant_npos)\n+\t    constexpr size_t __j = __rhs_index;\n+\t    if constexpr (__j != variant_npos)\n \t      {\n-\t\tif (this->_M_index == __rhs_index)\n-\t\t  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);\n+\t\tif (this->_M_index == __j)\n+\t\t  __variant::__get<__j>(*this) = std::move(__rhs_mem);\n \t\telse\n-\t\t  __variant_cast<_Types...>(*this)\n-\t\t    .template emplace<__rhs_index>(std::move(__rhs_mem));\n+\t\t  {\n+\t\t    using _Tj = typename _Nth_type<__j, _Types...>::type;\n+\t\t    if constexpr (is_nothrow_move_constructible_v<_Tj>)\n+\t\t      __variant::__emplace<__j>(*this, std::move(__rhs_mem));\n+\t\t    else\n+\t\t      {\n+\t\t\tusing _Variant = variant<_Types...>;\n+\t\t\t_Variant& __self = __variant_cast<_Types...>(*this);\n+\t\t\t__self.template emplace<__j>(std::move(__rhs_mem));\n+\t\t      }\n+\t\t  }\n \t      }\n \t    else\n \t      this->_M_reset();\n@@ -1164,17 +1176,6 @@ namespace __variant\n \t>;\n     }\n \n-  template<size_t _Np, typename _Variant, typename... _Args>\n-    _GLIBCXX20_CONSTEXPR\n-    inline void\n-    __construct_by_index(_Variant& __v, _Args&&... __args)\n-    {\n-      std::_Construct(std::__addressof(__variant::__get<_Np>(__v)),\n-\t\t      std::forward<_Args>(__args)...);\n-      // Construction didn't throw, so can set the new index now:\n-      __v._M_index = _Np;\n-    }\n-\n } // namespace __variant\n } // namespace __detail\n \n@@ -1415,11 +1416,6 @@ namespace __variant\n \tfriend _GLIBCXX20_CONSTEXPR decltype(auto)\n \t__variant_cast(_Tp&&);\n \n-      template<size_t _Np, typename _Variant, typename... _Args>\n-\tfriend _GLIBCXX20_CONSTEXPR void\n-\t__detail::__variant::__construct_by_index(_Variant& __v,\n-\t\t\t\t\t\t  _Args&&... __args);\n-\n       static_assert(sizeof...(_Types) > 0,\n \t\t    \"variant must have at least one alternative\");\n       static_assert(!(std::is_reference_v<_Types> || ...),\n@@ -1589,17 +1585,14 @@ namespace __variant\n \t  // to avoid becoming valueless.\n \t  if constexpr (is_nothrow_constructible_v<type, _Args...>)\n \t    {\n-\t      this->_M_reset();\n-\t      __variant::__construct_by_index<_Np>(*this,\n-\t\t  std::forward<_Args>(__args)...);\n+\t      __variant::__emplace<_Np>(*this, std::forward<_Args>(__args)...);\n \t    }\n \t  else if constexpr (is_scalar_v<type>)\n \t    {\n \t      // This might invoke a potentially-throwing conversion operator:\n \t      const type __tmp(std::forward<_Args>(__args)...);\n-\t      // But these steps won't throw:\n-\t      this->_M_reset();\n-\t      __variant::__construct_by_index<_Np>(*this, __tmp);\n+\t      // But this won't throw:\n+\t      __variant::__emplace<_Np>(*this, __tmp);\n \t    }\n \t  else if constexpr (__variant::_Never_valueless_alt<type>()\n \t      && _Traits::_S_move_assign)\n@@ -1614,9 +1607,7 @@ namespace __variant\n \t    {\n \t      // This case only provides the basic exception-safety guarantee,\n \t      // i.e. the variant can become valueless.\n-\t      this->_M_reset();\n-\t      __variant::__construct_by_index<_Np>(*this,\n-\t\tstd::forward<_Args>(__args)...);\n+\t      __variant::__emplace<_Np>(*this, std::forward<_Args>(__args)...);\n \t    }\n \t  return std::get<_Np>(*this);\n \t}\n@@ -1636,9 +1627,8 @@ namespace __variant\n \t\t\t\t\t\t   initializer_list<_Up>&,\n \t\t\t\t\t\t   _Args...>)\n \t    {\n-\t      this->_M_reset();\n-\t      __variant::__construct_by_index<_Np>(*this, __il,\n-\t\t  std::forward<_Args>(__args)...);\n+\t      __variant::__emplace<_Np>(*this, __il,\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n \t    }\n \t  else if constexpr (__variant::_Never_valueless_alt<type>()\n \t      && _Traits::_S_move_assign)\n@@ -1653,9 +1643,8 @@ namespace __variant\n \t    {\n \t      // This case only provides the basic exception-safety guarantee,\n \t      // i.e. the variant can become valueless.\n-\t      this->_M_reset();\n-\t      __variant::__construct_by_index<_Np>(*this, __il,\n-\t\tstd::forward<_Args>(__args)...);\n+\t      __variant::__emplace<_Np>(*this, __il,\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n \t    }\n \t  return std::get<_Np>(*this);\n \t}\n@@ -1686,61 +1675,57 @@ namespace __variant\n       noexcept((__is_nothrow_swappable<_Types>::value && ...)\n \t       && is_nothrow_move_constructible_v<variant>)\n       {\n-\t__detail::__variant::__raw_idx_visit(\n+\tstatic_assert((is_move_constructible_v<_Types> && ...));\n+\n+\t// Handle this here to simplify the visitation.\n+\tif (__rhs.valueless_by_exception()) [[__unlikely__]]\n+\t  {\n+\t    if (!this->valueless_by_exception()) [[__likely__]]\n+\t      __rhs.swap(*this);\n+\t    return;\n+\t  }\n+\n+\tnamespace __variant = __detail::__variant;\n+\n+\t__variant::__raw_idx_visit(\n \t  [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable\n \t  {\n-\t    if constexpr (__rhs_index != variant_npos)\n+\t    constexpr size_t __j = __rhs_index;\n+\t    if constexpr (__j != variant_npos)\n \t      {\n-\t\tif (this->index() == __rhs_index)\n+\t\tif (this->index() == __j)\n \t\t  {\n-\t\t    auto& __this_mem =\n-\t\t      std::get<__rhs_index>(*this);\n \t\t    using std::swap;\n-\t\t    swap(__this_mem, __rhs_mem);\n+\t\t    swap(std::get<__j>(*this), __rhs_mem);\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    constexpr size_t __j = __rhs_index;\n-\t\t    if (!this->valueless_by_exception()) [[__likely__]]\n-\t\t      {\n-\t\t\tauto __tmp(std::move(__rhs_mem));\n-\t\t\t__rhs = std::move(*this);\n-\t\t\tthis->_M_reset();\n-\t\t\tstd::_Construct(std::__addressof(this->_M_u),\n-\t\t\t\t\tin_place_index<__j>,\n-\t\t\t\t\tstd::move(__tmp));\n-\t\t\tthis->_M_index = __j;\n-\t\t      }\n+\t\t    auto __tmp(std::move(__rhs_mem));\n+\n+\t\t    if constexpr (_Traits::_S_trivial_move_assign)\n+\t\t      __rhs = std::move(*this);\n \t\t    else\n-\t\t      {\n-\t\t\tthis->_M_reset();\n-\t\t\tstd::_Construct(std::__addressof(this->_M_u),\n-\t\t\t\t\tin_place_index<__j>,\n-\t\t\t\t\tstd::move(__rhs_mem));\n-\t\t\tthis->_M_index = __j;\n-\t\t\t__rhs._M_reset();\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (!this->valueless_by_exception()) [[__likely__]]\n-\t\t  {\n-\t\t    __rhs = std::move(*this);\n-\t\t    this->_M_reset();\n+\t\t      __variant::__raw_idx_visit(\n+\t\t\t[&__rhs](auto&& __this_mem, auto __this_index) mutable\n+\t\t\t{\n+\t\t\t  constexpr size_t __k = __this_index;\n+\t\t\t  if constexpr (__k != variant_npos)\n+\t\t\t    __variant::__emplace<__k>(__rhs,\n+\t\t\t\t\t\t      std::move(__this_mem));\n+\t\t\t}, *this);\n+\n+\t\t    __variant::__emplace<__j>(*this, std::move(__tmp));\n \t\t  }\n \t      }\n \t  }, __rhs);\n       }\n \n-    private:\n-\n #if defined(__clang__) && __clang_major__ <= 7\n     public:\n       using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852\n-    private:\n #endif\n \n+    private:\n       template<size_t _Np, typename _Vp>\n \tfriend constexpr decltype(auto)\n \t__detail::__variant::__get(_Vp&& __v) noexcept;"}]}