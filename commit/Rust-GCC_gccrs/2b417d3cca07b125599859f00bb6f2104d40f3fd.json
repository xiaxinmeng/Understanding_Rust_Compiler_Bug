{"sha": "2b417d3cca07b125599859f00bb6f2104d40f3fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0MTdkM2NjYTA3YjEyNTU5OTg1OWYwMGJiNmYyMTA0ZDQwZjNmZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-03-08T20:53:01Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-03-08T20:53:01Z"}, "message": "(momentary_function_firstobj): New variable.\n\n(init_obstack): Set it.\n(save_tree_status): Save it and set it.\n(restore_tree_status): Use it and restore it.\n(permanent_allocation): New parameter function_end.  Clear\nmomentary_obstack to momentary_function_firstobj if true.\n(preserve_initializer): Set base field of every momentary\nlevel on the momentary stack to new momentary_firstobj.\n(pop_momentary): Only free back to previous base.\n\nFrom-SVN: r6725", "tree": {"sha": "17e5669b597bf6cabc0d7d5ef8f00c2af57cdc41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17e5669b597bf6cabc0d7d5ef8f00c2af57cdc41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b417d3cca07b125599859f00bb6f2104d40f3fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b417d3cca07b125599859f00bb6f2104d40f3fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b417d3cca07b125599859f00bb6f2104d40f3fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b417d3cca07b125599859f00bb6f2104d40f3fd/comments", "author": null, "committer": null, "parents": [{"sha": "b81004531956c7ecfd12cd1c65a93fa72c352367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81004531956c7ecfd12cd1c65a93fa72c352367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81004531956c7ecfd12cd1c65a93fa72c352367"}], "stats": {"total": 40, "additions": 33, "deletions": 7}, "files": [{"sha": "8dd5a1a0e9511b70df06feae3658d95d5e87d476", "filename": "gcc/tree.c", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b417d3cca07b125599859f00bb6f2104d40f3fd/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b417d3cca07b125599859f00bb6f2104d40f3fd/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2b417d3cca07b125599859f00bb6f2104d40f3fd", "patch": "@@ -131,6 +131,10 @@ char *temporary_firstobj;\n char *momentary_firstobj;\n char *temp_decl_firstobj;\n \n+/* This is used to preserve objects (mainly array initializers) that need to\n+   live until the end of the current function, but no further.  */\n+char *momentary_function_firstobj;\n+\n /* Nonzero means all ..._TYPE nodes should be allocated permanently.  */\n \n int all_types_permanent;\n@@ -269,6 +273,7 @@ init_obstacks ()\n   temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n   gcc_obstack_init (&momentary_obstack);\n   momentary_firstobj = (char *) obstack_alloc (&momentary_obstack, 0);\n+  momentary_function_firstobj = momentary_firstobj;\n   gcc_obstack_init (&maybepermanent_obstack);\n   maybepermanent_firstobj\n     = (char *) obstack_alloc (&maybepermanent_obstack, 0);\n@@ -316,6 +321,7 @@ save_tree_status (p)\n   p->momentary_stack = momentary_stack;\n   p->maybepermanent_firstobj = maybepermanent_firstobj;\n   p->momentary_firstobj = momentary_firstobj;\n+  p->momentary_function_firstobj = momentary_function_firstobj;\n   p->function_obstack = function_obstack;\n   p->function_maybepermanent_obstack = function_maybepermanent_obstack;\n   p->current_obstack = current_obstack;\n@@ -336,6 +342,7 @@ save_tree_status (p)\n   rtl_obstack = saveable_obstack = &permanent_obstack;\n \n   momentary_firstobj = (char *) obstack_finish (&momentary_obstack);\n+  momentary_function_firstobj = momentary_firstobj;\n   maybepermanent_firstobj\n     = (char *) obstack_finish (function_maybepermanent_obstack);\n }\n@@ -350,7 +357,7 @@ restore_tree_status (p)\n   all_types_permanent = p->all_types_permanent;\n   momentary_stack = p->momentary_stack;\n \n-  obstack_free (&momentary_obstack, momentary_firstobj);\n+  obstack_free (&momentary_obstack, momentary_function_firstobj);\n \n   /* Free saveable storage used by the function just compiled and not\n      saved.\n@@ -365,6 +372,7 @@ restore_tree_status (p)\n   free (function_obstack);\n \n   momentary_firstobj = p->momentary_firstobj;\n+  momentary_function_firstobj = p->momentary_function_firstobj;\n   maybepermanent_firstobj = p->maybepermanent_firstobj;\n   function_obstack = p->function_obstack;\n   function_maybepermanent_obstack = p->function_maybepermanent_obstack;\n@@ -494,14 +502,21 @@ allocation_temporary_p ()\n \n /* Go back to allocating on the permanent obstack\n    and free everything in the temporary obstack.\n-   This is done in finish_function after fully compiling a function.  */\n+\n+   FUNCTION_END is true only if we have just finished compiling a function.\n+   In that case, we also free preserved initial values on the momentary\n+   obstack.  */\n \n void\n-permanent_allocation ()\n+permanent_allocation (function_end)\n+     int function_end;\n {\n   /* Free up previous temporary obstack data */\n   obstack_free (&temporary_obstack, temporary_firstobj);\n-  obstack_free (&momentary_obstack, momentary_firstobj);\n+  if (function_end)\n+    obstack_free (&momentary_obstack, momentary_function_firstobj);\n+  else\n+    obstack_free (&momentary_obstack, momentary_firstobj);\n   obstack_free (&maybepermanent_obstack, maybepermanent_firstobj);\n   obstack_free (&temp_decl_obstack, temp_decl_firstobj);\n \n@@ -522,12 +537,20 @@ preserve_data ()\n void\n preserve_initializer ()\n {\n+  struct momentary_level *tem;\n+  char *old_momentary;\n+\n   temporary_firstobj\n     = (char *) obstack_alloc (&temporary_obstack, 0);\n-  momentary_firstobj\n-    = (char *) obstack_alloc (&momentary_obstack, 0);\n   maybepermanent_firstobj\n     = (char *) obstack_alloc (function_maybepermanent_obstack, 0);\n+\n+  old_momentary = momentary_firstobj;\n+  momentary_firstobj\n+    = (char *) obstack_alloc (&momentary_obstack, 0);\n+  if (momentary_firstobj != old_momentary)\n+    for (tem = momentary_stack; tem; tem = tem->prev)\n+      tem->base = momentary_firstobj;\n }\n \n /* Start allocating new rtl in current_obstack.\n@@ -733,7 +756,10 @@ pop_momentary ()\n   struct momentary_level *tem = momentary_stack;\n   momentary_stack = tem->prev;\n   expression_obstack = tem->obstack;\n-  obstack_free (&momentary_obstack, tem);\n+  /* We can't free TEM from the momentary_obstack, because there might\n+     be objects above it which have been saved.  We can free back to the\n+     stack of the level we are popping off though.  */\n+  obstack_free (&momentary_obstack, tem->base);\n }\n \n /* Pop back to the previous level of momentary allocation,"}]}