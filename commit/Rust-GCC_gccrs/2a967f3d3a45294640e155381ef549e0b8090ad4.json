{"sha": "2a967f3d3a45294640e155381ef549e0b8090ad4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5NjdmM2QzYTQ1Mjk0NjQwZTE1NTM4MWVmNTQ5ZTBiODA5MGFkNA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-05-20T06:26:45Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-20T06:26:45Z"}, "message": "Makefile.in (OBJS, [...]): Update.\n\n\t* Makefile.in (OBJS, LIBCPP_OBJS, LIBCPP_DEPS,\n\tcpplib.o, cpphash.o, fix-header): Update.\n\t(hashtable.o): New target.\n\t* c-common.h: Include cpplib.h.  Define C_RID_CODE and\n\tstruct c_common_identifier here.\n\t* c-lang.c (c_init_options): Update.  Call set_identifier_size.\n\t* c-lex.c (c_lex): Update.\n\t* c-pragma.h: Update.\n\t* c-tree.h (struct lang_identifier): Contain c_common_identifier.\n\tDelete rid_code.\n\t(C_RID_CODE): Delete.\n\t* cpphash.c: Rewrite to use hashtable.c.\n\t* cpphash.h: Update include guards.\n\t(struct cpp_reader): Remove hashtab.\n\thash_ob and buffer_ob are no longer pointers.  Add hash_table\n\tand our_hashtable.\n\t(HASHSTEP, _cpp_init_hashtable,\t_cpp_lookup_with_hash): Delete.\n\t(_cpp_cleanup_hashtable): Rename _cpp_destroy_hashtable.\n\t(_cpp_cleanup_stacks): Rename _cpp_init_directives.\n\t* cppinit.c (cpp_create_reader): Update.\n\t* cpplex.c (cpp_ideq, parse_identifier, cpp_output_token): Update.\n\t(cpp_interpret_charconst): Eliminate warning.\n\t* cpplib.c (do_pragma, do_endif, push_conditional,\n\tcpp_push_buffer, cpp_pop_buffer): Update.\n\t(_cpp_init_stacks): Rename cpp_init_directives.\n\t(_cpp_cleanup_stacks): Remove.\n\t* cpplib.h: Update include guards.  Include tree-core.h and c-rid.h.\n\t(cpp_hashnode, cpp_token, NODE_LEN, NODE_NAME,\n\t cpp_forall_identifiers, cpp_create_reader): Update.\n\t(C_RID_CODE, cpp_make_node): New.\n\t(c_common_identifier): New identifier node for C front ends.\n\t* cppmain.c (main): Update.\n\t* fix-header.c (read_scan_file): Update.\n\t* flags.h (id_clash_len): Make unsigned.\n\t* ggc.h (ggc_mark_nonnull_tree): New.\n\t* hashtable.c: New.\n\t* hashtable.h: New.\n\t* stringpool.c: Update comments and copyright.  Update to use\n\thashtable.c.\n\t* toplev.c (approx_sqrt): Move to hashtable.c.\n\t(id_clash_len): Make unsigned.\n\t* toplev.h (ident_hash): New.\n\t* tree.c (gcc_obstack_init): Move to hashtable.c.\n\t* tree.h: Include hashtable.h.\n\t(IDENTIFIER_POINTER, IDENTIFIER_LENGTH): Update.\n\t(GCC_IDENT_TO_HT_IDENT, HT_IDENT_TO_GCC_IDENT): New.\n\t(struct tree_identifier): Update.\n\t(make_identifier): New.\ncp:\n\t* cp-tree.h (struct lang_identifier, C_RID_YYCODE): Update.\n\t(C_RID_CODE): Remove.\n\t* lex.c (cxx_init_options): Call set_identifier_size.  Update.\n\t(init_parse): Don't do it here.\nobjc:\n\t* objc-act.c (objc_init_options): Call set_identifier_size. Update.\n\nFrom-SVN: r42334", "tree": {"sha": "31a2cc3c54959e2908bad78e488472f5e3ce3d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31a2cc3c54959e2908bad78e488472f5e3ce3d69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a967f3d3a45294640e155381ef549e0b8090ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a967f3d3a45294640e155381ef549e0b8090ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a967f3d3a45294640e155381ef549e0b8090ad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a967f3d3a45294640e155381ef549e0b8090ad4/comments", "author": null, "committer": null, "parents": [{"sha": "9e800206badd2be563d344e4a0aee83e3ac96f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e800206badd2be563d344e4a0aee83e3ac96f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e800206badd2be563d344e4a0aee83e3ac96f03"}], "stats": {"total": 1468, "additions": 799, "deletions": 669}, "files": [{"sha": "a740a65c60b006989379efb8759fc08c5bc036d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1,3 +1,61 @@\n+2001-05-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* Makefile.in (OBJS, LIBCPP_OBJS, LIBCPP_DEPS,\n+\tcpplib.o, cpphash.o, fix-header): Update.\n+\t(hashtable.o): New target.\n+\t* c-common.h: Include cpplib.h.  Define C_RID_CODE and\n+\tstruct c_common_identifier here.\n+\t* c-lang.c (c_init_options): Update.  Call set_identifier_size.\n+\t* c-lex.c (c_lex): Update.\n+\t* c-pragma.h: Update.\n+\t* c-tree.h (struct lang_identifier): Contain c_common_identifier.\n+\tDelete rid_code.\n+\t(C_RID_CODE): Delete.\n+\t* cpphash.c: Rewrite to use hashtable.c.\n+\t* cpphash.h: Update include guards.\n+\t(struct cpp_reader): Remove hashtab.\n+\thash_ob and buffer_ob are no longer pointers.  Add hash_table\n+\tand our_hashtable.\n+\t(HASHSTEP, _cpp_init_hashtable,\t_cpp_lookup_with_hash): Delete.\n+\t(_cpp_cleanup_hashtable): Rename _cpp_destroy_hashtable.\n+\t(_cpp_cleanup_stacks): Rename _cpp_init_directives.\n+\t* cppinit.c (cpp_create_reader): Update.\n+\t* cpplex.c (cpp_ideq, parse_identifier, cpp_output_token): Update.\n+\t(cpp_interpret_charconst): Eliminate warning.\n+\t* cpplib.c (do_pragma, do_endif, push_conditional,\n+\tcpp_push_buffer, cpp_pop_buffer): Update.\n+\t(_cpp_init_stacks): Rename cpp_init_directives.\n+\t(_cpp_cleanup_stacks): Remove.\n+\t* cpplib.h: Update include guards.  Include tree-core.h and c-rid.h.\n+\t(cpp_hashnode, cpp_token, NODE_LEN, NODE_NAME,\n+\t cpp_forall_identifiers, cpp_create_reader): Update.\n+\t(C_RID_CODE, cpp_make_node): New.\n+\t(c_common_identifier): New identifier node for C front ends.\n+\t* cppmain.c (main): Update.\n+\t* fix-header.c (read_scan_file): Update.\n+\t* flags.h (id_clash_len): Make unsigned.\n+\t* ggc.h (ggc_mark_nonnull_tree): New.\n+\t* hashtable.c: New.\n+\t* hashtable.h: New.\n+\t* stringpool.c: Update comments and copyright.  Update to use\n+\thashtable.c.\n+\t* toplev.c (approx_sqrt): Move to hashtable.c.\n+\t(id_clash_len): Make unsigned.\n+\t* toplev.h (ident_hash): New.\n+\t* tree.c (gcc_obstack_init): Move to hashtable.c.\n+\t* tree.h: Include hashtable.h.\n+\t(IDENTIFIER_POINTER, IDENTIFIER_LENGTH): Update.\n+\t(GCC_IDENT_TO_HT_IDENT, HT_IDENT_TO_GCC_IDENT): New.\n+\t(struct tree_identifier): Update.\n+\t(make_identifier): New.\n+cp:\n+\t* cp-tree.h (struct lang_identifier, C_RID_YYCODE): Update.\n+\t(C_RID_CODE): Remove.\n+\t* lex.c (cxx_init_options): Call set_identifier_size.  Update.\n+\t(init_parse): Don't do it here.\n+objc:\n+\t* objc-act.c (objc_init_options): Call set_identifier_size. Update.\n+\n Sat May 19 18:23:04 2001  Richard Henderson <rth@redhat.com>\n \n \t* except.c (dw2_build_landing_pads): Use word_mode, not Pmode,"}, {"sha": "1c77ccaf4f4b1ae4d2e236db9c4a70dbc8a37f19", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -706,7 +706,7 @@ OBJS =\t\t\t\t\t\t\t\t\t\\\n  dependence.o diagnostic.o doloop.o dominance.o dwarf2asm.o dwarf2out.o\t\\\n  dwarfout.o emit-rtl.o except.o explow.o expmed.o expr.o final.o flow.o\t\\\n  fold-const.o function.o gcse.o genrtl.o ggc-common.o global.o graph.o\t\\\n- haifa-sched.o hash.o ifcvt.o insn-attrtab.o insn-emit.o\t\t\\\n+ haifa-sched.o hash.o hashtable.o ifcvt.o insn-attrtab.o insn-emit.o\t\\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t\\\n  integrate.o intl.o jump.o lcm.o lists.o local-alloc.o loop.o mbchar.o\t\\\n  optabs.o params.o predict.o print-rtl.o print-tree.o profile.o real.o\t\\\n@@ -1294,6 +1294,8 @@ ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \tflags.h toplev.h\n \n+hashtable.o: hashtable.c hashtable.h $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H)\n+\n ggc-none.o: ggc-none.c $(GCONFIG_H) $(SYSTEM_H) $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n@@ -1890,9 +1892,9 @@ PREPROCESSOR_DEFINES = \\\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o \\\n \t\tcpphash.o cpperror.o cppinit.o cppdefault.o \\\n-\t\tmkdeps.o prefix.o version.o mbchar.o\n+\t\thashtable.o mkdeps.o prefix.o version.o mbchar.o\n \n-LIBCPP_DEPS =\tcpplib.h cpphash.h intl.h $(SYSTEM_H)\n+LIBCPP_DEPS =\tcpplib.h cpphash.h hashtable.h intl.h $(OBSTACK_H) $(SYSTEM_H)\n \n # Most of the other archives built/used by this makefile are for\n # targets.  This one is strictly for the host.\n@@ -1911,8 +1913,8 @@ cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS) mbchar.h\n cppmacro.o: cppmacro.c $(CONFIG_H) $(LIBCPP_DEPS)\n-cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n-cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n+cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS)\n+cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n cppinit.o:  cppinit.c  $(CONFIG_H) $(LIBCPP_DEPS) cppdefault.h \\\n \t\tmkdeps.h prefix.h output.h version.h"}, {"sha": "8a5a7593653f81d17e21062f3d69790f52ff1140", "filename": "gcc/c-common.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #define GCC_C_COMMON_H\n \n #include \"splay-tree.h\"\n+#include \"cpplib.h\"\n \n /* Usage of TREE_LANG_FLAG_?:\n    0: COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n@@ -168,6 +169,17 @@ enum c_tree_index\n     CTI_MAX\n };\n \n+#define C_RID_CODE(id)\t(((struct c_common_identifier *) (id))->rid_code)\n+\n+/* Identifier part common to the C front ends.  Inherits from\n+   tree_identifier, despite appearances.  */\n+struct c_common_identifier\n+{\n+  struct tree_common common;\n+  struct cpp_hashnode node;\n+  ENUM_BITFIELD(rid) rid_code: CHAR_BIT;\n+};\n+\n #define wchar_type_node\t\t\tc_global_trees[CTI_WCHAR_TYPE]\n #define signed_wchar_type_node\t\tc_global_trees[CTI_SIGNED_WCHAR_TYPE]\n #define unsigned_wchar_type_node\tc_global_trees[CTI_UNSIGNED_WCHAR_TYPE]"}, {"sha": "cb60002c00e3d48ebc120334f5e98650b8e2c1a0", "filename": "gcc/c-lang.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -59,7 +59,10 @@ c_post_options ()\n static void\n c_init_options ()\n {\n-  parse_in = cpp_create_reader (CLK_GNUC89);\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+\n+  parse_in = cpp_create_reader (ident_hash, CLK_GNUC89);\n \n   /* Mark as \"unspecified\".  */\n   flag_bounds_check = -1;"}, {"sha": "bb09b88d80b85c9beaf94d67e7703414536c17ef", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -997,7 +997,12 @@ c_lex (value)\n       goto retry;\n       \n     case CPP_NAME:\n-      *value = get_identifier ((const char *) NODE_NAME (tok.val.node));\n+      {\n+\ttree node = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok.val.node));\n+\tif (TREE_CODE (node) != IDENTIFIER_NODE)\n+\t  make_identifier (node);\n+\t*value = node;\n+      }\n       break;\n \n     case CPP_INT:"}, {"sha": "e6af073dfad1840b643d9b4ab441c7596ec46f90", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -61,7 +61,7 @@ extern void init_pragma PARAMS ((void));\n \n /* Duplicate prototypes for the register_pragma stuff and the typedef for\n    cpp_reader, to avoid dragging cpplib.h in almost everywhere... */\n-#ifndef __GCC_CPPLIB__\n+#ifndef GCC_CPPLIB_H\n typedef struct cpp_reader cpp_reader;\n \n extern void cpp_register_pragma PARAMS ((cpp_reader *,"}, {"sha": "a33d64d7d270f145c6d43f70ee7481558244f5a0", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -36,10 +36,9 @@ Boston, MA 02111-1307, USA.  */\n \n struct lang_identifier\n {\n-  struct tree_identifier ignore;\n+  struct c_common_identifier ignore;\n   tree global_value, local_value, label_value, implicit_decl;\n   tree error_locus, limbo_value;\n-  enum rid rid_code;\n };\n \n /* Wrapping c_lang_decl in another struct is an unfortunate\n@@ -98,8 +97,6 @@ struct lang_decl\n    and C_RID_YYCODE is the token number wanted by Yacc.  */\n \n #define C_IS_RESERVED_WORD(id) TREE_LANG_FLAG_0 (id)\n-#define C_RID_CODE(id) \\\n-  (((struct lang_identifier *) (id))->rid_code)\n \n /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n struct lang_type"}, {"sha": "233f804fe7e21be16a869346324497be7fbd1e09", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1,3 +1,10 @@\n+2001-05-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cp-tree.h (struct lang_identifier, C_RID_YYCODE): Update.\n+\t(C_RID_CODE): Remove.\n+\t* lex.c (cxx_init_options): Call set_identifier_size.  Update.\n+\t(init_parse): Don't do it here.\n+\n 2001-05-18  Diego Novillo  <dnovillo@redhat.com>\n \n \t* decl2.c (finish_objects): Use the original SYMBOL_REF from the"}, {"sha": "d0b34c9ce31a51ba5c429ca80ded6e911851c4e7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -270,26 +270,22 @@ extern int flag_huge_objects;\n \n struct lang_identifier\n {\n-  struct tree_identifier ignore;\n+  struct c_common_identifier ignore;\n   tree namespace_bindings;\n   tree bindings;\n   tree class_value;\n   tree class_template_info;\n   struct lang_id2 *x;\n-  enum rid rid_code;\n };\n \n /* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n    and C_RID_YYCODE is the token number wanted by Yacc.  */\n \n #define C_IS_RESERVED_WORD(id) TREE_LANG_FLAG_5 (id)\n-#define C_RID_CODE(id) \\\n-  (((struct lang_identifier *) (id))->rid_code)\n \n extern const short rid_to_yy[RID_MAX];\n-#define C_RID_YYCODE(id) \\\n-  rid_to_yy[((struct lang_identifier *) (id))->rid_code]\n+#define C_RID_YYCODE(id) rid_to_yy[C_RID_CODE (id)]\n \n #define LANG_IDENTIFIER_CAST(NODE) \\\n \t((struct lang_identifier*)IDENTIFIER_NODE_CHECK (NODE))\n@@ -1878,7 +1874,7 @@ struct lang_decl\n   } u2;\n };\n \n-#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.pointer)\n+#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.id.str)\n \n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n #define TREE_READONLY_DECL_P(NODE) \\"}, {"sha": "c466a73beb27e439acd6a573b0aafb281f733237", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -258,7 +258,10 @@ cxx_post_options ()\n static void\n cxx_init_options ()\n {\n-  parse_in = cpp_create_reader (CLK_GNUCXX);\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+\n+  parse_in = cpp_create_reader (ident_hash, CLK_GNUCXX);\n \n   /* Default exceptions on.  */\n   flag_exceptions = 1;\n@@ -696,8 +699,6 @@ const char *\n init_parse (filename)\n      const char *filename;\n {\n-  /* Make identifier nodes long enough for the language-specific slots.  */\n-  set_identifier_size (sizeof (struct lang_identifier));\n   decl_printable_name = lang_printable_name;\n \n   input_filename = \"<internal>\";"}, {"sha": "9383c27ccb908d6d61fe91883ce5c565908ebeca", "filename": "gcc/cpphash.c", "status": "modified", "additions": 56, "deletions": 227, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1,4 +1,4 @@\n-/* Part of CPP library.  (Identifier and string tables.)\n+/* Hash tables for the CPP library.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n@@ -27,266 +27,95 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"system.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n-#include \"obstack.h\"\n \n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n+static cpp_hashnode *alloc_node PARAMS ((hash_table *));\n \n-/* Initial hash table size.  (It can grow if necessary.)  This is the\n-   largest prime number smaller than 2**12. */\n-#define HASHSIZE 4093\n+/* Return an identifier node for hashtable.c.  Used by cpplib except\n+   when integrated with the C front ends.  */\n \n-/* This is the structure used for the hash table.  */\n-struct htab\n+static cpp_hashnode *\n+alloc_node (table)\n+     hash_table *table;\n {\n-  struct cpp_hashnode **entries;\n-  size_t size;\n-  size_t nelts;\n-};\n-\n-static void expand_hash PARAMS ((struct htab *));\n-static unsigned long higher_prime_number PARAMS ((unsigned long));\n-\n-/* Set up and tear down internal structures for macro expansion.  */\n-void\n-_cpp_init_hashtable (pfile)\n-     cpp_reader *pfile;\n-{\n-  pfile->hash_ob = xnew (struct obstack);\n-  obstack_init (pfile->hash_ob);\n-\n-  pfile->hashtab = xobnew (pfile->hash_ob, struct htab);\n-\n-  pfile->hashtab->nelts = 0;\n-  pfile->hashtab->size = HASHSIZE;\n-  pfile->hashtab->entries = xcnewvec (cpp_hashnode *, HASHSIZE);\n+  cpp_hashnode *node;\n+  \n+  node = obstack_alloc (&table->pfile->hash_ob, sizeof (cpp_hashnode));\n+  memset ((PTR) node, 0, sizeof (cpp_hashnode));\n+  return node;\n }\n \n+/* Set up the identifier hash table.  Use TABLE if non-null, otherwise\n+   create our own.  */\n+\n void\n-_cpp_cleanup_hashtable (pfile)\n+_cpp_init_hashtable (pfile, table)\n      cpp_reader *pfile;\n+     hash_table *table;\n {\n-  cpp_hashnode **p, **limit;\n-\n-  p = pfile->hashtab->entries;\n-  limit = p + pfile->hashtab->size;\n-  do\n+  if (table == NULL)\n     {\n-      if (*p)\n-\t_cpp_free_definition (*p);\n+      pfile->our_hashtable = 1;\n+      table = ht_create (13);\t/* 8K (=2^13) entries.  */\n+      table->alloc_node = (hashnode (*) PARAMS ((hash_table *))) alloc_node;\n+      gcc_obstack_init (&pfile->hash_ob);\n     }\n-  while (++p < limit);\n \n-  free (pfile->hashtab->entries);\n-  obstack_free (pfile->hash_ob, 0);\n-  free (pfile->hash_ob);\n+  table->pfile = pfile;\n+  pfile->hash_table = table;\n }\n \n-/* The code below is a specialization of Vladimir Makarov's expandable\n-   hash tables (see libiberty/hashtab.c).  The abstraction penalty was\n-   too high to continue using the generic form.  This code knows\n-   intrinsically how to calculate a hash value, and how to compare an\n-   existing entry with a potential new one.  Also, the ability to\n-   delete members from the table has been removed.  */\n+/* Tear down the identifier hash table.  */\n \n-cpp_hashnode *\n-cpp_lookup (pfile, name, len)\n+void\n+_cpp_destroy_hashtable (pfile)\n      cpp_reader *pfile;\n-     const U_CHAR *name;\n-     size_t len;\n {\n-  size_t n = len;\n-  unsigned int r = 0;\n-  const U_CHAR *str = name;\n-  U_CHAR *dest = _cpp_pool_reserve (&pfile->ident_pool, len + 1);\n-\n-  do\n+  if (pfile->our_hashtable)\n     {\n-      r = HASHSTEP (r, *str);\n-      *dest++ = *str++;\n+      free (pfile->hash_table);\n+      obstack_free (&pfile->hash_ob, 0);\n     }\n-  while (--n);\n-  *dest = '\\0';\n-\n-  return _cpp_lookup_with_hash (pfile, len, r);\n }\n \n-/* NAME is a null-terminated identifier of length len.  It is assumed\n-   to have been placed at the front of the identifier pool.  */\n+/* Returns the hash entry for the STR of length LEN, creating one\n+   if necessary.  */\n+\n cpp_hashnode *\n-_cpp_lookup_with_hash (pfile, len, hash)\n+cpp_lookup (pfile, str, len)\n      cpp_reader *pfile;\n-     size_t len;\n-     unsigned int hash;\n-{\n-  unsigned int index;\n-  size_t size;\n-  cpp_hashnode *entry;\n-  cpp_hashnode **entries;\n-  unsigned char *name = POOL_FRONT (&pfile->ident_pool);\n-\n-  entries = pfile->hashtab->entries;\n-  size = pfile->hashtab->size;\n-\n-  hash += len;\n-  index = hash % size;\n-\n-  entry = entries[index];\n-  if (entry)\n-    {\n-      unsigned int hash2;\n-\n-      if (entry->hash == hash && NODE_LEN (entry) == len\n-\t  && !memcmp (NODE_NAME (entry), name, len))\n-\treturn entry;\n-\n-      hash2 = 1 + hash % (size - 2);\n-\n-      for (;;)\n-\t{\n-\t  index += hash2;\n-\t  if (index >= size)\n-\t    index -= size;\n-\t  entry = entries[index];\n-\n-\t  if (entry == NULL)\n-\t    break;\n-\t  if (entry->hash == hash && NODE_LEN (entry) == len\n-\t      && !memcmp (NODE_NAME (entry), name, len))\n-\t    return entry;\n-\t}\n-    }\n-\n-  /* Commit the memory for the identifier.  */\n-  POOL_COMMIT (&pfile->ident_pool, len + 1);\n-\n-  /* Create a new hash node and insert it in the table.  */\n-  entries[index] = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode));\n-\n-  entry = entries[index];\n-  entry->type = NT_VOID;\n-  entry->flags = 0;\n-  entry->directive_index = 0;\n-  entry->arg_index = 0;\n-  NODE_LEN (entry) = len;\n-  entry->hash = hash;\n-  NODE_NAME (entry) = name;\n-  entry->value.macro = 0;\n-\n-  pfile->hashtab->nelts++;\n-  if (size * 3 <= pfile->hashtab->nelts * 4)\n-    expand_hash (pfile->hashtab);\n-\n-  return entry;\n-}\n-\n-static void\n-expand_hash (htab)\n-     struct htab *htab;\n+     const unsigned char *str;\n+     unsigned int len;\n {\n-  cpp_hashnode **oentries;\n-  cpp_hashnode **olimit;\n-  cpp_hashnode **p;\n-  size_t size;\n-\n-  oentries = htab->entries;\n-  olimit = oentries + htab->size;\n-\n-  htab->size = size = higher_prime_number (htab->size * 2);\n-  htab->entries = xcnewvec (cpp_hashnode *, size);\n-\n-  for (p = oentries; p < olimit; p++)\n-    {\n-      if (*p != NULL)\n-\t{\n-\t  unsigned int index;\n-\t  unsigned int hash, hash2;\n-\t  cpp_hashnode *entry = *p;\n-\n-\t  hash = entry->hash;\n-\t  index = hash % size;\n-\n-\t  if (htab->entries[index] == NULL)\n-\t    {\n-\t    insert:\n-\t      htab->entries[index] = entry;\n-\t      continue;\n-\t    }\n-\n-\t  hash2 = 1 + hash % (size - 2);\n-\t  for (;;)\n-\t    {\n-\t      index += hash2;\n-\t      if (index >= size)\n-\t\tindex -= size;\n-\n-\t      if (htab->entries[index] == NULL)\n-\t\tgoto insert;\n-\t    }\n-\t}\n-    }\n-\n-  free (oentries);\n+  /* ht_lookup cannot return NULL.  */\n+  return CPP_HASHNODE (ht_lookup (pfile->hash_table, str, len, HT_ALLOC));\n }\n \n-/* The following function returns the nearest prime number which is\n-   greater than a given source number, N. */\n+/* Determine whether the str STR, of length LEN, is a defined macro.  */\n \n-static unsigned long\n-higher_prime_number (n)\n-     unsigned long n;\n+int\n+cpp_defined (pfile, str, len)\n+     cpp_reader *pfile;\n+     const unsigned char *str;\n+     int len;\n {\n-  unsigned long i;\n-\n-  /* Ensure we have a larger number and then force to odd.  */\n-  n++;  \n-  n |= 0x01; \n+  cpp_hashnode *node;\n \n-  /* All odd numbers < 9 are prime.  */\n-  if (n < 9)\n-    return n;\n+  node = CPP_HASHNODE (ht_lookup (pfile->hash_table, str, len, HT_NO_INSERT));\n \n-  /* Otherwise find the next prime using a sieve.  */\n-\n- next:\n-  for (i = 3; i * i <= n; i += 2)\n-    if (n % i == 0)\n-      {\n-\t n += 2;\n-\t goto next;\n-       }\n-\n-  return n;\n+  /* If it's of type NT_MACRO, it cannot be poisoned.  */\n+  return node && node->type == NT_MACRO;\n }\n \n+/* For all nodes in the hashtable, callback CB with parameters PFILE,\n+   the node, and V.  */\n+\n void\n cpp_forall_identifiers (pfile, cb, v)\n      cpp_reader *pfile;\n-     int (*cb) PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n-     void *v;\n+     cpp_cb cb;\n+     PTR v;\n {\n-    cpp_hashnode **p, **limit;\n-\n-  p = pfile->hashtab->entries;\n-  limit = p + pfile->hashtab->size;\n-  do\n-    {\n-      if (*p)\n-\tif ((*cb) (pfile, *p, v) == 0)\n-\t  break;\n-    }\n-  while (++p < limit);\n-}\n-\n-/* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n-int\n-cpp_defined (pfile, id, len)\n-     cpp_reader *pfile;\n-     const U_CHAR *id;\n-     int len;\n-{\n-  cpp_hashnode *hp = cpp_lookup (pfile, id, len);\n-\n-  /* If it's of type NT_MACRO, it cannot be poisoned.  */\n-  return hp->type == NT_MACRO;\n+  /* We don't need a proxy since the hash table's identifier comes\n+     first in cpp_hashnode.  */\n+  ht_forall (pfile->hash_table, (ht_cb) cb, v);\n }"}, {"sha": "17438c7a4e42ab4db348b366b1c36ce87268dc87", "filename": "gcc/cpphash.h", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -19,11 +19,12 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    that need to be visible across files.  It's called cpphash.h for\n    historical reasons.  */\n \n-#ifndef __GCC_CPPHASH__\n-#define __GCC_CPPHASH__\n+#ifndef GCC_CPPHASH_H\n+#define GCC_CPPHASH_H\n \n-struct directive;\t\t/* These are deliberately incomplete.  */\n-struct htab;\n+#include \"hashtable.h\"\n+\n+struct directive;\t\t/* Deliberately incomplete.  */\n \n /* Test if a sign is valid within a preprocessing number.  */\n #define VALID_SIGN(c, prevc) \\\n@@ -299,9 +300,6 @@ struct cpp_reader\n   /* Current depth in #include directives.  */\n   unsigned int include_depth;\n \n-  /* Hash table of macros and assertions.  See cpphash.c.  */\n-  struct htab *hashtab;\n-\n   /* Tree of other included files.  See cppfiles.c.  */\n   struct splay_tree_s *all_include_files;\n \n@@ -318,11 +316,11 @@ struct cpp_reader\n \n   /* Obstack holding all macro hash nodes.  This never shrinks.\n      See cpphash.c */\n-  struct obstack *hash_ob;\n+  struct obstack hash_ob;\n \n   /* Obstack holding buffer and conditional structures.  This is a\n-     real stack.  See cpplib.c */\n-  struct obstack *buffer_ob;\n+     real stack.  See cpplib.c.  */\n+  struct obstack buffer_ob;\n \n   /* Pragma table - dynamic, because a library user can add to the\n      list of recognized pragmas.  */\n@@ -331,6 +329,9 @@ struct cpp_reader\n   /* Call backs.  */\n   struct cpp_callbacks cb;\n \n+  /* Identifier hash table.  */ \n+  struct ht *hash_table;\n+\n   /* User visible options.  */\n   struct cpp_options opts;\n \n@@ -347,6 +348,9 @@ struct cpp_reader\n   /* Whether to print our version number.  Done this way so\n      we don't get it twice for -v -version.  */\n   unsigned char print_version;\n+\n+  /* Whether cpplib owns the hashtable.  */\n+  unsigned char our_hashtable;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n@@ -384,10 +388,6 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n #define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n #define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n \n-/* Hash step.  The hash calculation is duplicated in cpp_lookup and\n-   parse_name.  */\n-#define HASHSTEP(r, c) ((r) * 67 + (c - 113));\n-\n /* In cpperror.c  */\n enum error_type { WARNING = 0, WARNING_SYSHDR, PEDWARN, ERROR, FATAL, ICE };\n extern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n@@ -403,10 +403,8 @@ extern void _cpp_push_token\t\tPARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t\t\t const cpp_lexer_pos *));\n \n /* In cpphash.c */\n-extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_cleanup_hashtable\tPARAMS ((cpp_reader *));\n-extern cpp_hashnode *_cpp_lookup_with_hash PARAMS ((cpp_reader*, size_t,\n-\t\t\t\t\t\t    unsigned int));\n+extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));\n+extern void _cpp_destroy_hashtable\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\n@@ -445,8 +443,7 @@ extern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));\n extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\n extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n-extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n-extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n+extern void _cpp_init_directives PARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum cpp_fc_reason,\n \t\t\t\t\t const char *, unsigned int));\n@@ -517,4 +514,4 @@ ufputs (s, f)\n   return fputs ((const char *)s, f);\n }\n \n-#endif\n+#endif /* GCC_CPPHASH_H */"}, {"sha": "fda406b4d70459356db993b4ec577d23246a35ef", "filename": "gcc/cppinit.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -491,7 +491,8 @@ init_library ()\n \n /* Initialize a cpp_reader structure. */\n cpp_reader *\n-cpp_create_reader (lang)\n+cpp_create_reader (table, lang)\n+     hash_table *table;\n      enum c_lang lang;\n {\n   struct spec_nodes *s;\n@@ -536,8 +537,13 @@ cpp_create_reader (lang)\n   /* Macro pool initially 8K.  Aligned, permanent pool.  */\n   _cpp_init_pool (&pfile->macro_pool, 8 * 1024, 0, 0);\n \n-  _cpp_init_hashtable (pfile);\n-  _cpp_init_stacks (pfile);\n+  /* Initialise the buffer obstack.  */\n+  gcc_obstack_init (&pfile->buffer_ob);\n+\n+  /* Initialise the hashtable.  */\n+  _cpp_init_hashtable (pfile, table);\n+\n+  _cpp_init_directives (pfile);\n   _cpp_init_includes (pfile);\n   _cpp_init_internal_pragmas (pfile);\n \n@@ -577,11 +583,10 @@ cpp_destroy (pfile)\n     }\n \n   deps_free (pfile->deps);\n+  obstack_free (&pfile->buffer_ob, 0);\n \n+  _cpp_destroy_hashtable (pfile);\n   _cpp_cleanup_includes (pfile);\n-  _cpp_cleanup_stacks (pfile);\n-  _cpp_cleanup_hashtable (pfile);\n-\n   _cpp_free_lookaheads (pfile);\n \n   _cpp_free_pool (&pfile->ident_pool);"}, {"sha": "290d33977ad0409dcfac8854db443ee0cbacc61c", "filename": "gcc/cpplex.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -479,22 +479,14 @@ parse_identifier (pfile, c)\n {\n   cpp_hashnode *result;\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned char *dest, *limit;\n-  unsigned int r = 0, saw_dollar = 0;\n-\n-  dest = POOL_FRONT (&pfile->ident_pool);\n-  limit = POOL_LIMIT (&pfile->ident_pool);\n+  unsigned int saw_dollar = 0, len;\n+  struct obstack *stack = &pfile->hash_table->stack;\n \n   do\n     {\n       do\n \t{\n-\t  /* Need room for terminating null.  */\n-\t  if (dest + 1 >= limit)\n-\t    limit = _cpp_next_chunk (&pfile->ident_pool, 0, &dest);\n-\n-\t  *dest++ = c;\n-\t  r = HASHSTEP (r, c);\n+\t  obstack_1grow (stack, c);\n \n \t  if (c == '$')\n \t    saw_dollar++;\n@@ -524,11 +516,12 @@ parse_identifier (pfile, c)\n     cpp_pedwarn (pfile, \"'$' character(s) in identifier\");\n \n   /* Identifiers are null-terminated.  */\n-  *dest = '\\0';\n+  len = obstack_object_size (stack);\n+  obstack_1grow (stack, '\\0');\n \n   /* This routine commits the memory if necessary.  */\n-  result = _cpp_lookup_with_hash (pfile,\n-\t\t\t\t  dest - POOL_FRONT (&pfile->ident_pool), r);\n+  result = (cpp_hashnode *)\n+    ht_lookup (pfile->hash_table, obstack_finish (stack), len, HT_ALLOCED);\n \n   /* Some identifiers require diagnostics when lexed.  */\n   if (result->flags & NODE_DIAGNOSTIC && !pfile->skipping)\n@@ -1905,7 +1898,8 @@ cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n   const unsigned char *limit = str + token->val.str.len;\n   unsigned int chars_seen = 0;\n   unsigned int width, max_chars, c;\n-  HOST_WIDE_INT result = 0, mask;\n+  unsigned HOST_WIDE_INT mask;\n+  HOST_WIDE_INT result = 0;\n \n #ifdef MULTIBYTE_CHARS\n   (void) local_mbtowc (NULL, NULL, 0);"}, {"sha": "96d296f3b5aab2fb4f988f92c83a5da030c14c85", "filename": "gcc/cpplib.c", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1043,12 +1043,12 @@ do_pragma (pfile)\n   if (tok.type == CPP_NAME)\n     {\n       const cpp_hashnode *node = tok.val.node;\n-      const U_CHAR *name = NODE_NAME (node);\n       size_t len = NODE_LEN (node);\n \n       while (p)\n \t{\n-\t  if (strlen (p->name) == len && !memcmp (p->name, name, len))\n+\t  if (strlen (p->name) == len\n+\t      && !memcmp (p->name, NODE_NAME (node), len))\n \t    {\n \t      if (p->isnspace)\n \t\t{\n@@ -1403,7 +1403,7 @@ do_endif (pfile)\n \n       buffer->if_stack = ifs->next;\n       buffer->was_skipping = ifs->was_skipping;\n-      obstack_free (pfile->buffer_ob, ifs);\n+      obstack_free (&pfile->buffer_ob, ifs);\n     }\n \n   check_eol (pfile);\n@@ -1423,7 +1423,7 @@ push_conditional (pfile, skip, type, cmacro)\n   struct if_stack *ifs;\n   cpp_buffer *buffer = pfile->buffer;\n \n-  ifs = xobnew (pfile->buffer_ob, struct if_stack);\n+  ifs = xobnew (&pfile->buffer_ob, struct if_stack);\n   ifs->pos = pfile->directive_pos;\n   ifs->next = buffer->if_stack;\n   ifs->was_skipping = buffer->was_skipping;\n@@ -1804,7 +1804,7 @@ cpp_push_buffer (pfile, buffer, len, type, filename)\n      enum cpp_buffer_type type;\n      const char *filename;\n {\n-  cpp_buffer *new = xobnew (pfile->buffer_ob, cpp_buffer);\n+  cpp_buffer *new = xobnew (&pfile->buffer_ob, cpp_buffer);\n \n   if (type == BUF_FAKE)\n     {\n@@ -1905,34 +1905,21 @@ cpp_pop_buffer (pfile)\n \t\t   buffer->nominal_fname);\n     }\n \n-  obstack_free (pfile->buffer_ob, buffer);\n+  obstack_free (&pfile->buffer_ob, buffer);\n   return pfile->buffer;\n }\n \n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n void\n-_cpp_init_stacks (pfile)\n+_cpp_init_directives (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int i;\n   cpp_hashnode *node;\n \n-  pfile->buffer_ob = xnew (struct obstack);\n-  obstack_init (pfile->buffer_ob);\n-\n   /* Register the directives.  */\n   for (i = 0; i < (unsigned int) N_DIRECTIVES; i++)\n     {\n       node = cpp_lookup (pfile, dtable[i].name, dtable[i].length);\n       node->directive_index = i + 1;\n     }\n }\n-\n-void\n-_cpp_cleanup_stacks (pfile)\n-     cpp_reader *pfile;\n-{\n-  obstack_free (pfile->buffer_ob, 0);\n-  free (pfile->buffer_ob);\n-}"}, {"sha": "cc42e347c59de12f2dc3a04b14e4460b1b38c209", "filename": "gcc/cpplib.h", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -20,10 +20,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n  In other words, you are welcome to use, share and improve this program.\n  You are forbidden to forbid anyone else to use, share and improve\n  what you give them.   Help stamp out software-hoarding!  */\n-#ifndef __GCC_CPPLIB__\n-#define __GCC_CPPLIB__\n+#ifndef GCC_CPPLIB_H\n+#define GCC_CPPLIB_H\n \n #include <sys/types.h>\n+#include \"hashtable.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n@@ -45,6 +46,7 @@ typedef struct cpp_callbacks cpp_callbacks;\n \n struct answer;\n struct file_name_map_list;\n+struct ht;\n \n /* The first two groups, apart from '=', can appear in preprocessor\n    expressions.  This allows a lookup table to be implemented in\n@@ -177,7 +179,7 @@ struct cpp_token\n \n   union\n   {\n-    struct cpp_hashnode *node;\t/* An identifier.  */\n+    cpp_hashnode *node;\t\t/* An identifier.  */\n     struct cpp_string str;\t/* A string, or number.  */\n     unsigned int arg_no;\t/* Argument no. for a CPP_MACRO_ARG.  */\n     unsigned char c;\t\t/* Character represented by CPP_OTHER.  */\n@@ -466,18 +468,22 @@ enum builtin_type\n   BT_STDC\t\t\t/* `__STDC__' */\n };\n \n-#define NODE_LEN(NODE)\t\t(NODE->len)\n-#define NODE_NAME(NODE)\t\t(NODE->name)\n+#define CPP_HASHNODE(HNODE)\t((cpp_hashnode *) (HNODE))\n+#define HT_NODE(NODE)\t\t((ht_identifier *) (NODE))\n+#define NODE_LEN(NODE)\t\tHT_LEN (&(NODE)->ident)\n+#define NODE_NAME(NODE)\t\tHT_STR (&(NODE)->ident)\n \n+/* The common part of an identifier node shared amongst all 3 C front\n+   ends.  Also used to store CPP identifiers, which are a superset of\n+   identifiers in the grammatical sense.  */\n struct cpp_hashnode\n {\n-  const unsigned char *name;\t\t/* Null-terminated name.  */\n-  unsigned int hash;\t\t\t/* Cached hash value.  */\n-  unsigned short len;\t\t\t/* Length of name excluding null.  */\n+  struct ht_identifier ident;\n   unsigned short arg_index;\t\t/* Macro argument index.  */\n   unsigned char directive_index;\t/* Index into directive table.  */\n-  ENUM_BITFIELD(node_type) type : 8;\t/* Node type.  */\n-  unsigned char flags;\t\t\t/* Node flags.  */\n+  unsigned char rid_code;\t\t/* Rid code - for front ends.  */\n+  ENUM_BITFIELD(node_type) type : 8;\t/* CPP node type.  */\n+  unsigned char flags;\t\t\t/* CPP flags.  */\n \n   union\n   {\n@@ -488,8 +494,12 @@ struct cpp_hashnode\n   } value;\n };\n \n-/* Call this first to get a handle to pass to other functions.  */\n-extern cpp_reader *cpp_create_reader PARAMS ((enum c_lang));\n+/* Call this first to get a handle to pass to other functions.  If you\n+   want cpplib to manage its own hashtable, pass in a NULL pointer.\n+   Or you can pass in an initialised hash table that cpplib will use;\n+   this technique is used by the C front ends.  */\n+extern cpp_reader *cpp_create_reader PARAMS ((struct ht *,\n+\t\t\t\t\t      enum c_lang));\n \n /* Call this to release the handle.  Any use of the handle after this\n    function returns is invalid.  Returns cpp_errors (pfile).  */\n@@ -593,13 +603,16 @@ extern void cpp_output_token\t\tPARAMS ((const cpp_token *, FILE *));\n extern const char *cpp_type2name\tPARAMS ((enum cpp_ttype));\n \n /* In cpphash.c */\n+\n+/* Lookup an identifier in the hashtable.  Puts the identifier in the\n+   table if it is not already there.  */\n extern cpp_hashnode *cpp_lookup\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char *, size_t));\n+\t\t\t\t\t\t const unsigned char *,\n+\t\t\t\t\t\t unsigned int));\n+\n+typedef int (*cpp_cb) PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n extern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t int (*) PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t\t\t  cpp_hashnode *,\n-\t\t\t\t\t\t\t\t  void *)),\n-\t\t\t\t\t\t void *));\n+\t\t\t\t\t\t cpp_cb, void *));\n \n /* In cppmacro.c */\n extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *, int));\n@@ -614,4 +627,4 @@ extern void cpp_make_system_header PARAMS ((cpp_reader *, int, int));\n #ifdef __cplusplus\n }\n #endif\n-#endif /* __GCC_CPPLIB__ */\n+#endif /* GCC_CPPLIB_H */"}, {"sha": "40c61762ed84ce5563b325a3ce143b0c72d6b6e7", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1536,7 +1536,8 @@ check_trad_stringification (pfile, macro, string)\n \t{\n \t  const cpp_hashnode *node = macro->params[i];\n \n-\t  if (NODE_LEN (node) == len && !memcmp (p, NODE_NAME (node), len))\n+\t  if (NODE_LEN (node) == len\n+\t      && !memcmp (p, NODE_NAME (node), len))\n \t    {\n \t      cpp_warning (pfile,\n \t   \"macro argument \\\"%s\\\" would be stringified with -traditional.\","}, {"sha": "0c5dc3d880f2fa7f050a4658ca16e632c5fac028", "filename": "gcc/cppmain.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -74,7 +74,7 @@ main (argc, argv)\n   general_init (argv[0]);\n \n   /* Contruct a reader with default language GNU C89.  */\n-  pfile = cpp_create_reader (CLK_GNUC89);\n+  pfile = cpp_create_reader (NULL, CLK_GNUC89);\n   options = cpp_get_options (pfile);\n   \n   do_preprocessing (argc, argv);"}, {"sha": "8d801281d456fa2085d2da2dc9d7d3b2d2ebf34e", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -621,7 +621,7 @@ read_scan_file (in_fname, argc, argv)\n \n   obstack_init (&scan_file_obstack); \n \n-  scan_in = cpp_create_reader (CLK_GNUC89);\n+  scan_in = cpp_create_reader (NULL, CLK_GNUC89);\n   cb = cpp_get_callbacks (scan_in);\n   cb->file_change = cb_file_change;\n "}, {"sha": "92492ac439e53a8c21217fad90b6a16dda84705e", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -146,7 +146,7 @@ extern int warn_cast_align;\n    characters.  The value N is in `id_clash_len'.  */\n \n extern int warn_id_clash;\n-extern int id_clash_len;\n+extern unsigned int id_clash_len;\n \n /* Nonzero means warn about any objects definitions whose size is larger\n    than N bytes.  Also want about function definitions whose returned"}, {"sha": "2d214a90e858f511f12c783776422cff53dd3997", "filename": "gcc/ggc.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -84,6 +84,13 @@ extern void ggc_mark_rtvec_children PARAMS ((struct rtvec_def *));\n       VARRAY_PUSH_TREE (ggc_pending_trees, t__);\t\\\n   } while (0)\n \n+#define ggc_mark_nonnull_tree(EXPR)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    tree t__ = (EXPR);\t\t\t\t\t\\\n+    if (! ggc_set_mark (t__))\t\t\t\t\\\n+      VARRAY_PUSH_TREE (ggc_pending_trees, t__);\t\\\n+  } while (0)\n+\n #define ggc_mark_rtvec(EXPR)                    \\\n   do {                                          \\\n     rtvec v__ = (EXPR);                         \\"}, {"sha": "f77eb7f132e20b1da33e4b9ad4f34d76360083c5", "filename": "gcc/hashtable.c", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fhashtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fhashtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -0,0 +1,315 @@\n+/* Hash tables.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"hashtable.h\"\n+\n+/* The code below is a specialization of Vladimir Makarov's expandable\n+   hash tables (see libiberty/hashtab.c).  The abstraction penalty was\n+   too high to continue using the generic form.  This code knows\n+   intrinsically how to calculate a hash value, and how to compare an\n+   existing entry with a potential new one.  Also, the ability to\n+   delete members from the table has been removed.  */\n+\n+static unsigned int calc_hash PARAMS ((const unsigned char *, unsigned int));\n+static void ht_expand PARAMS ((hash_table *));\n+\n+/* Let particular systems override the size of a chunk.  */\n+#ifndef OBSTACK_CHUNK_SIZE\n+#define OBSTACK_CHUNK_SIZE 0\n+#endif\n+  /* Let them override the alloc and free routines too.  */\n+#ifndef OBSTACK_CHUNK_ALLOC\n+#define OBSTACK_CHUNK_ALLOC xmalloc\n+#endif\n+#ifndef OBSTACK_CHUNK_FREE\n+#define OBSTACK_CHUNK_FREE free\n+#endif\n+\n+/* Initialise an obstack.  */\n+void\n+gcc_obstack_init (obstack)\n+     struct obstack *obstack;\n+{\n+  _obstack_begin (obstack, OBSTACK_CHUNK_SIZE, 0,\n+\t\t  (void *(*) PARAMS ((long))) OBSTACK_CHUNK_ALLOC,\n+\t\t  (void (*) PARAMS ((void *))) OBSTACK_CHUNK_FREE);\n+}\n+\n+/* Calculate the hash of the string STR of length LEN.  */\n+\n+static unsigned int\n+calc_hash (str, len)\n+     const unsigned char *str;\n+     unsigned int len;\n+{\n+  unsigned int n = len;\n+  unsigned int r = 0;\n+#define HASHSTEP(r, c) ((r) * 67 + (c - 113));\n+\n+  while (n--)\n+    r = HASHSTEP (r, *str++);\n+\n+  return r + len;\n+#undef HASHSTEP\n+}\n+\n+/* Initialize an identifier hashtable.  */\n+\n+hash_table *\n+ht_create (order)\n+     unsigned int order;\n+{\n+  unsigned int nslots = 1 << order;\n+  hash_table *table;\n+\n+  table = (hash_table *) xmalloc (sizeof (hash_table));\n+  memset (table, 0, sizeof (hash_table));\n+\n+  /* Strings need no alignment.  */\n+  gcc_obstack_init (&table->stack);\n+  obstack_alignment_mask (&table->stack) = 0;\n+\n+  table->entries = (hashnode *) xcalloc (nslots, sizeof (hashnode));\n+  table->nslots = nslots;\n+  return table;\n+}\n+\n+/* Returns the hash entry for the a STR of length LEN.  If that string\n+   already exists in the table, returns the existing entry, and, if\n+   INSERT is CPP_ALLOCED, frees the last obstack object.  If the\n+   identifier hasn't been seen before, and INSERT is CPP_NO_INSERT,\n+   returns NULL.  Otherwise insert and returns a new entry.  A new\n+   string is alloced if INSERT is CPP_ALLOC, otherwise INSERT is\n+   CPP_ALLOCED and the item is assumed to be at the top of the\n+   obstack.  */\n+hashnode\n+ht_lookup (table, str, len, insert)\n+     hash_table *table;\n+     const unsigned char *str;\n+     unsigned int len;\n+     enum ht_lookup_option insert;\n+{\n+  unsigned int hash = calc_hash (str, len);\n+  unsigned int hash2;\n+  unsigned int index;\n+  size_t sizemask;\n+  hashnode node;\n+\n+  sizemask = table->nslots - 1;\n+  index = hash & sizemask;\n+\n+  /* hash2 must be odd, so we're guaranteed to visit every possible\n+     location in the table during rehashing.  */\n+  hash2 = ((hash * 17) & sizemask) | 1;\n+  table->searches++;\n+\n+  for (;;)\n+    {\n+      node = table->entries[index];\n+\n+      if (node == NULL)\n+\tbreak;\n+\n+      if (HT_LEN (node) == len && !memcmp (HT_STR (node), str, len))\n+\t{\n+\t  if (insert == HT_ALLOCED)\n+\t    /* The string we search for was placed at the end of the\n+\t       obstack.  Release it.  */\n+\t    obstack_free (&table->stack, (PTR) str);\n+\t  return node;\n+\t}\n+\n+      index = (index + hash2) & sizemask;\n+      table->collisions++;\n+    }\n+\n+  if (insert == HT_NO_INSERT)\n+    return NULL;\n+\n+  node = (*table->alloc_node) (table);\n+  table->entries[index] = node;\n+\n+  HT_LEN (node) = len;\n+  if (insert == HT_ALLOC)\n+    HT_STR (node) = obstack_copy (&table->stack, str, len + 1);\n+  else\n+    HT_STR (node) = str;\n+\n+  if (++table->nelements * 4 >= table->nslots * 3)\n+    /* Must expand the string table.  */\n+    ht_expand (table);\n+\n+  return node;\n+}\n+\n+/* Double the size of a hash table, re-hashing existing entries.  */\n+\n+static void\n+ht_expand (table)\n+     hash_table *table;\n+{\n+  hashnode *nentries, *p, *limit;\n+  unsigned int size, sizemask;\n+\n+  size = table->nslots * 2;\n+  nentries = (hashnode *) xcalloc (size, sizeof (hashnode));\n+  sizemask = size - 1;\n+\n+  p = table->entries;\n+  limit = p + table->nslots;\n+  do\n+    if (*p)\n+      {\n+\tunsigned int index, hash, hash2;\n+\n+\thash = calc_hash (HT_STR (*p), HT_LEN (*p));\n+\thash2 = ((hash * 17) & sizemask) | 1;\n+\tindex = hash & sizemask;\n+\n+\tfor (;;)\n+\t  {\n+\t    if (! nentries[index])\n+\t      {\n+\t\tnentries[index] = *p;\n+\t\tbreak;\n+\t      }\n+\n+\t    index = (index + hash2) & sizemask;\n+\t  }\n+      }\n+  while (++p < limit);\n+\n+  free (table->entries);\n+  table->entries = nentries;\n+  table->nslots = size;\n+}\n+\n+/* For all nodes in TABLE, callback CB with parameters TABLE->PFILE,\n+   the node, and V.  */\n+void\n+ht_forall (table, cb, v)\n+     hash_table *table;\n+     ht_cb cb;\n+     const PTR v;\n+{\n+  hashnode *p, *limit;\n+\n+  p = table->entries;\n+  limit = p + table->nslots;\n+  do\n+    if (*p)\n+      {\n+\tif ((*cb) (table->pfile, *p, v) == 0)\n+\t  break;\n+      }\n+  while (++p < limit);\n+}\n+\n+/* Dump allocation statistics to stderr.  */\n+\n+void\n+ht_dump_statistics (table)\n+     hash_table *table;\n+{\n+  size_t nelts, nids, overhead, headers;\n+  size_t total_bytes, longest, sum_of_squares;\n+  double exp_len, exp_len2, exp2_len;\n+  hashnode *p, *limit;\n+\n+#define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n+\t\t  ? (x) \\\n+\t\t  : ((x) < 1024*1024*10 \\\n+\t\t     ? (x) / 1024 \\\n+\t\t     : (x) / (1024*1024))))\n+#define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n+\n+  total_bytes = longest = sum_of_squares = nids = 0;\n+  p = table->entries;\n+  limit = p + table->nslots;\n+  do\n+    if (*p)\n+      {\n+\tsize_t n = HT_LEN (*p);\n+\n+\ttotal_bytes += n;\n+\tsum_of_squares += n * n;\n+\tif (n > longest)\n+\t  longest = n;\n+\tnids++;\n+      }\n+  while (++p < limit);\n+      \n+  nelts = table->nelements;\n+  overhead = obstack_memory_used (&table->stack) - total_bytes;\n+  headers = table->nslots * sizeof (hashnode);\n+\n+  fprintf (stderr, \"\\nString pool\\nentries\\t\\t%lu\\n\",\n+\t   (unsigned long) nelts);\n+  fprintf (stderr, \"identifiers\\t%lu (%.2f%%)\\n\",\n+\t   (unsigned long) nids, nids * 100.0 / nelts);\n+  fprintf (stderr, \"slots\\t\\t%lu\\n\",\n+\t   (unsigned long) table->nslots);\n+  fprintf (stderr, \"bytes\\t\\t%lu%c (%lu%c overhead)\\n\",\n+\t   SCALE (total_bytes), LABEL (total_bytes),\n+\t   SCALE (overhead), LABEL (overhead));\n+  fprintf (stderr, \"table size\\t%lu%c\\n\",\n+\t   SCALE (headers), LABEL (headers));\n+\n+  exp_len = (double)total_bytes / (double)nelts;\n+  exp2_len = exp_len * exp_len;\n+  exp_len2 = (double) sum_of_squares / (double) nelts;\n+\n+  fprintf (stderr, \"coll/search\\t%.4f\\n\",\n+\t   (double) table->collisions / (double) table->searches);\n+  fprintf (stderr, \"ins/search\\t%.4f\\n\",\n+\t   (double) nelts / (double) table->searches);\n+  fprintf (stderr, \"avg. entry\\t%.2f bytes (+/- %.2f)\\n\",\n+\t   exp_len, approx_sqrt (exp_len2 - exp2_len));\n+  fprintf (stderr, \"longest entry\\t%lu\\n\",\n+\t   (unsigned long) longest);\n+#undef SCALE\n+#undef LABEL\n+}\n+\n+/* Return the approximate positive square root of a number N.  This is for\n+   statistical reports, not code generation.  */\n+double\n+approx_sqrt (x)\n+     double x;\n+{\n+  double s, d;\n+\n+  if (x < 0)\n+    abort ();\n+  if (x == 0)\n+    return 0;\n+\n+  s = x;\n+  do\n+    {\n+      d = (s * s - x) / (2 * s);\n+      s -= d;\n+    }\n+  while (d > .0001);\n+  return s;\n+}"}, {"sha": "5b08fde25b630f7fcf8810f817bbe89ca9a29a30", "filename": "gcc/hashtable.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -0,0 +1,85 @@\n+/* Hash tables.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCC_HASHTABLE_H\n+#define GCC_HASHTABLE_H\n+\n+#include \"obstack.h\"\n+\n+/* This is what each hash table entry points to.  It may be embedded\n+   deeply within another object.  */\n+typedef struct ht_identifier ht_identifier;\n+struct ht_identifier\n+{\n+  unsigned int len;\n+  const unsigned char *str;\n+};\n+\n+#define HT_LEN(NODE) ((NODE)->len)\n+#define HT_STR(NODE) ((NODE)->str)\n+\n+/* We want code outside cpplib, such as the compiler front-ends, to be\n+   able to include this header, and to be able to link with\n+   cpphashtbl.o without pulling in any other parts of cpplib.  */\n+\n+struct cpp_reader;\n+typedef struct ht hash_table;\n+typedef struct ht_identifier *hashnode;\n+\n+enum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC, HT_ALLOCED};\n+\n+/* An identifier hash table for cpplib and the front ends.  */\n+struct ht\n+{\n+  /* Identifiers are allocated from here.  */\n+  struct obstack stack;\n+\n+  hashnode *entries;\n+  /* Call back.  */\n+  hashnode (*alloc_node) PARAMS ((hash_table *));\n+\n+  unsigned int nslots;\t\t/* Total slots in the entries array.  */\n+  unsigned int nelements;\t/* Number of live elements.  */\n+\n+  /* Link to reader, if any.  For the benefit of cpplib.  */\n+  struct cpp_reader *pfile;\n+\n+  /* Table usage statistics.  */\n+  unsigned int searches;\n+  unsigned int collisions;\n+};\n+\n+extern void gcc_obstack_init PARAMS ((struct obstack *));\n+/* Initialise the hashtable with 2 ^ order entries.  */\n+extern hash_table *ht_create PARAMS ((unsigned int order));\n+extern hashnode ht_lookup PARAMS ((hash_table *, const unsigned char *,\n+\t\t\t\t   unsigned int, enum ht_lookup_option));\n+\n+/* For all nodes in TABLE, make a callback.  The callback takes\n+   TABLE->PFILE, the node, and a PTR, and the callback sequence stops\n+   if the callback returns zero.  */\n+typedef int (*ht_cb) PARAMS ((struct cpp_reader *, hashnode, const void *));\n+extern void ht_forall PARAMS ((hash_table *, ht_cb, const void *));\n+\n+/* Dump allocation statistics to stderr.  */\n+extern void ht_dump_statistics PARAMS ((hash_table *));\n+\n+/* Approximate positive square root of a host double.  This is for\n+   statistical reports, not code generation.  */\n+extern double approx_sqrt PARAMS ((double));\n+\n+#endif /* GCC_HASHTABLE_H */"}, {"sha": "81e16191120b95009092568c56b59deb2395feea", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -727,7 +727,10 @@ generate_struct_by_value_array ()\n static void\n objc_init_options ()\n {\n-  parse_in = cpp_create_reader (CLK_OBJC);\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+\n+  parse_in = cpp_create_reader (ident_hash, CLK_OBJC);\n   c_language = clk_objective_c;\n }\n "}, {"sha": "6d440056d508a9f43f0c7ae440833b30cdb78433", "filename": "gcc/stringpool.c", "status": "modified", "additions": 125, "deletions": 287, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1,5 +1,5 @@\n /* String pool for GCC.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,25 +18,25 @@ along with GNU CC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* String pool allocator.  All strings allocated by ggc_alloc_string are\n-   uniquified and stored in an obstack which is never shrunk.  You can\n-   associate a tree with a string if you wish; this is used to implement\n-   get_identifier.\n+/* String text, identifer text and identifier node allocator.  Strings\n+   allocated by ggc_alloc_string are stored in an obstack which is\n+   never shrunk.  Identifiers are uniquely stored in a hash table.\n \n-   We have our own private hash table implementation which is similar\n-   to the one in cpphash.c (actually, it's a further refinement of\n-   that code).  libiberty's hashtab.c is not used because it requires\n-   100% average space overhead per string, which is unacceptable.\n-   Also, this algorithm is faster.  */\n+   We have our own private hash table implementation.  libiberty's\n+   hashtab.c is not used because it requires 100% average space\n+   overhead per string, which is unacceptable.  Also, this algorithm\n+   is faster.  */\n \n #include \"config.h\"\n #include \"system.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n-#include \"obstack.h\"\n+#include \"hashtable.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n \n+#define IS_FE_IDENT(NODE) (TREE_CODE (NODE) == IDENTIFIER_NODE)\n+\n /* The \"\" allocated string.  */\n const char empty_string[] = \"\";\n \n@@ -47,194 +47,33 @@ const char digit_vector[] = {\n   '5', 0, '6', 0, '7', 0, '8', 0, '9', 0\n };\n \n+struct ht *ident_hash;\n static struct obstack string_stack;\n-\n-/* Each hashnode is just a pointer to a TREE_IDENTIFIER.  */\n-typedef struct tree_identifier *sp_hashnode;\n-\n-#define SP_EMPTY(NODE) ((NODE) == NULL)\n-#define SP_LEN(NODE) ((NODE)->length)\n-#define SP_TREE(NODE) ((tree) NODE)\n-#define SP_STR(NODE) ((NODE)->pointer)\n-#define SP_VALID(NODE) (TREE_CODE (SP_TREE (NODE)) == IDENTIFIER_NODE)\n-\n-/* This is the hash table structure.  There's only one.  */\n-struct str_hash\n-{\n-  sp_hashnode *entries;\n-  size_t nslots;\t/* total slots in the entries array */\n-  size_t nelements;\t/* number of live elements */\n-\n-  /* table usage statistics */\n-  unsigned int searches;\n-  unsigned int collisions;\n-};\n-#define INITIAL_HASHSIZE (16*1024)\n-\n-static struct str_hash string_hash = { 0, INITIAL_HASHSIZE, 0, 0, 0 };\n-\n-enum insert_option { INSERT, NO_INSERT };\n-\n-static sp_hashnode alloc_ident PARAMS ((const char *, size_t,\n-\t\t\t\t\tenum insert_option));\n-static inline unsigned int calc_hash PARAMS ((const unsigned char *, size_t));\n-static void mark_string_hash PARAMS ((void *));\n-static void expand_string_table PARAMS ((void));\n-\n-/* Convenience macro for iterating over the hash table.  E is set to\n-   each live entry in turn.  */\n-#define FORALL_IDS(E) \\\n-for (E = string_hash.entries; E < string_hash.entries+string_hash.nslots; E++) \\\n-  if (!SP_EMPTY (*E) && SP_VALID (*E))\n-\n-/* 0 while creating built-in identifiers.  */\n static int do_identifier_warnings;\n \n+static hashnode alloc_node PARAMS ((hash_table *));\n+static int mark_ident PARAMS ((struct cpp_reader *, hashnode, const PTR));\n+static void mark_ident_hash PARAMS ((void *));\n+static int scan_for_clashes PARAMS ((struct cpp_reader *, hashnode,\n+\t\t\t\t     const char *));\n+\n /* Initialize the string pool.  */\n void\n init_stringpool ()\n {\n+  /* Create with 16K (2^14) entries.  */\n+  ident_hash = ht_create (14);\n+  ident_hash->alloc_node = alloc_node;\n   gcc_obstack_init (&string_stack);\n-  ggc_add_root (&string_hash, 1, sizeof string_hash, mark_string_hash);\n-\n-  /* Strings need no alignment.  */\n-  obstack_alignment_mask (&string_stack) = 0;\n-\n-  string_hash.entries = (sp_hashnode *)\n-    xcalloc (string_hash.nslots, sizeof (sp_hashnode));\n+  ggc_add_root (&ident_hash, 1, sizeof ident_hash, mark_ident_hash);\n }\n \n-/* Enable warnings on similar identifiers (if requested).\n-   Done after the built-in identifiers are created.  */\n-void\n-start_identifier_warnings ()\n-{\n-  do_identifier_warnings = 1;\n-}\n-\n-/* Record the size of an identifier node for the language in use.\n-   SIZE is the total size in bytes.\n-   This is called by the language-specific files.  This must be\n-   called before allocating any identifiers.  */\n-void\n-set_identifier_size (size)\n-     int size;\n+/* Allocate a hash node.  */\n+static hashnode\n+alloc_node (table)\n+     hash_table *table ATTRIBUTE_UNUSED;\n {\n-  tree_code_length[(int) IDENTIFIER_NODE]\n-    = (size - sizeof (struct tree_common)) / sizeof (tree);\n-}\n-\n-/* Calculate the hash of the string STR, which is of length LEN.  */\n-static inline unsigned int\n-calc_hash (str, len)\n-     const unsigned char *str;\n-     size_t len;\n-{\n-  size_t n = len;\n-  unsigned int r = 0;\n-#define HASHSTEP(r, c) ((r) * 67 + (c - 113));\n-\n-  while (n--)\n-    r = HASHSTEP (r, *str++);\n-\n-  return r + len;\n-#undef HASHSTEP\n-}\n-\n-/* Internal primitive: returns the header structure for the identifier\n-   of length LENGTH, containing CONTENTS.  If that identifier already\n-   exists in the table, returns the existing entry.  If the identifier\n-   hasn't been seen before and the last argument is INSERT, inserts\n-   and returns a new entry. Otherwise returns NULL.  */\n-static sp_hashnode\n-alloc_ident (contents, length, insert)\n-     const char *contents;\n-     size_t length;\n-     enum insert_option insert;\n-{\n-  unsigned int hash = calc_hash ((const unsigned char *)contents, length);\n-  unsigned int hash2;\n-  unsigned int index;\n-  size_t sizemask;\n-  sp_hashnode entry;\n-\n-  sizemask = string_hash.nslots - 1;\n-  index = hash & sizemask;\n-\n-  /* hash2 must be odd, so we're guaranteed to visit every possible\n-     location in the table during rehashing.  */\n-  hash2 = ((hash * 17) & sizemask) | 1;\n-  string_hash.searches++;\n-\n-  for (;;)\n-    {\n-      entry = string_hash.entries[index];\n-\n-      if (SP_EMPTY (entry))\n-\tbreak;\n-\n-      if ((size_t) SP_LEN (entry) == length\n-\t  && !memcmp (SP_STR (entry), contents, length))\n-\treturn entry;\n-\n-      index = (index + hash2) & sizemask;\n-      string_hash.collisions++;\n-    }\n-\n-  if (insert == NO_INSERT)\n-    return NULL;\n-\n-  entry = (sp_hashnode) make_node (IDENTIFIER_NODE);\n-  string_hash.entries[index] = entry;\n-  SP_STR (entry) = ggc_alloc_string (contents, length);\n-  SP_LEN (entry) = length;\n-  /* This is not yet an identifier.  */\n-  TREE_SET_CODE (entry, ERROR_MARK);\n-\n-  if (++string_hash.nelements * 4 >= string_hash.nslots * 3)\n-    /* Must expand the string table.  */\n-    expand_string_table ();\n-\n-  return entry;\n-}\n-\n-/* Subroutine of alloc_ident which doubles the size of the hash table\n-   and rehashes all the strings into the new table.  Returns the entry\n-   in the new table corresponding to ENTRY.  */\n-static void\n-expand_string_table ()\n-{\n-  sp_hashnode *nentries;\n-  sp_hashnode *e;\n-  size_t size, sizemask;\n-\n-  size = string_hash.nslots * 2;\n-  nentries = (sp_hashnode *) xcalloc (size, sizeof (sp_hashnode));\n-  sizemask = size - 1;\n-\n-  FORALL_IDS (e)\n-    {\n-      unsigned int index, hash, hash2;\n-\n-      hash = calc_hash ((const unsigned char *) SP_STR (*e), SP_LEN (*e));\n-      hash2 = ((hash * 17) & sizemask) | 1;\n-      index = hash & sizemask;\n-\n-      for (;;)\n-\t{\n-\t  if (SP_EMPTY (nentries[index]))\n-\t    {\n-\t      nentries[index] = *e;\n-\t      break;\n-\t    }\n-\n-\t  index = (index + hash2) & sizemask;\n-\t}\n-    }\n-\n-  free (string_hash.entries);\n-  string_hash.entries = nentries;\n-  string_hash.nslots = size;\n+  return GCC_IDENT_TO_HT_IDENT (make_node (IDENTIFIER_NODE));\n }\n \n /* Allocate and return a string constant of length LENGTH, containing\n@@ -260,43 +99,40 @@ ggc_alloc_string (contents, length)\n   return obstack_finish (&string_stack);\n }\n \n+/* NODE is an identifier known to the preprocessor.  Make it known to\n+   the front ends as well.  */\n+\n+void\n+make_identifier (node)\n+     tree node;\n+{\n+  /* If this identifier is longer than the clash-warning length,\n+     do a brute force search of the entire table for clashes.  */\n+  if (warn_id_clash && do_identifier_warnings\n+      && IDENTIFIER_LENGTH (node) >= id_clash_len)\n+    ht_forall (ident_hash, (ht_cb) scan_for_clashes,\n+\t       IDENTIFIER_POINTER (node));\n+\n+  TREE_SET_CODE (node, IDENTIFIER_NODE);\n+#ifdef GATHER_STATISTICS\n+  id_string_size += IDENTIFIER_LENGTH (node);\n+#endif\n+}\n+\n /* Return an IDENTIFIER_NODE whose name is TEXT (a null-terminated string).\n    If an identifier with that name has previously been referred to,\n    the same node is returned this time.  */\n+\n tree\n get_identifier (text)\n      const char *text;\n {\n-  sp_hashnode node;\n-  size_t length = strlen (text);\n-\n-  node = alloc_ident (text, length, INSERT);\n-  if (!SP_VALID (node))\n-    {\n-      /* If this identifier is longer than the clash-warning length,\n-\t do a brute force search of the entire table for clashes.  */\n-      if (warn_id_clash && do_identifier_warnings && length >= (size_t) id_clash_len)\n-\t{\n-\t  sp_hashnode *e;\n-\t  FORALL_IDS (e)\n-\t    {\n-\t      if (SP_LEN (*e) >= id_clash_len\n-\t\t  && !strncmp (SP_STR (*e), text, id_clash_len))\n-\t\t{\n-\t\t  warning (\"\\\"%s\\\" and \\\"%s\\\" identical in first %d characters\",\n-\t\t\t   text, SP_STR (*e), id_clash_len);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      TREE_SET_CODE (node, IDENTIFIER_NODE);\n-#ifdef GATHER_STATISTICS\n-      id_string_size += length;\n-#endif\n-    }\n+  hashnode ht_node = ht_lookup (ident_hash,\n+\t\t\t\t(const unsigned char *) text,\n+\t\t\t\tstrlen (text), HT_ALLOC);\n \n-  return SP_TREE (node);\n+  /* ht_node can't be NULL here.  */\n+  return HT_IDENT_TO_GCC_IDENT (ht_node);\n }\n \n /* If an identifier with the name TEXT (a null-terminated string) has\n@@ -307,90 +143,92 @@ tree\n maybe_get_identifier (text)\n      const char *text;\n {\n-  sp_hashnode node;\n+  hashnode ht_node;\n+  tree node;\n   size_t length = strlen (text);\n \n-  node = alloc_ident (text, length, NO_INSERT);\n-  if (!SP_EMPTY (node) && SP_VALID (node))\n-    return SP_TREE (node);\n+  ht_node = ht_lookup (ident_hash, (const unsigned char *) text,\n+\t\t       length, HT_NO_INSERT);\n+  if (ht_node)\n+    {\n+      node = HT_IDENT_TO_GCC_IDENT (ht_node);\n+      if (IS_FE_IDENT (node))\n+\treturn node;\n+    }\n \n   return NULL_TREE;\n }\n \n+/* If this identifier is longer than the clash-warning length,\n+   do a brute force search of the entire table for clashes.  */\n+\n+static int\n+scan_for_clashes (pfile, h, text)\n+     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     hashnode h;\n+     const char *text;\n+{\n+  tree node = HT_IDENT_TO_GCC_IDENT (h);\n+\n+  if (IS_FE_IDENT (node)\n+      && IDENTIFIER_LENGTH (node) >= id_clash_len\n+      && !memcmp (IDENTIFIER_POINTER (node), text, id_clash_len))\n+    {\n+      warning (\"\\\"%s\\\" and \\\"%s\\\" identical in first %d characters\",\n+\t       text, IDENTIFIER_POINTER (node), id_clash_len);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Record the size of an identifier node for the language in use.\n+   SIZE is the total size in bytes.\n+   This is called by the language-specific files.  This must be\n+   called before allocating any identifiers.  */\n+\n+void\n+set_identifier_size (size)\n+     int size;\n+{\n+  tree_code_length[(int) IDENTIFIER_NODE]\n+    = (size - sizeof (struct tree_common)) / sizeof (tree);\n+}\n+\n+/* Enable warnings on similar identifiers (if requested).\n+   Done after the built-in identifiers are created.  */\n+\n+void\n+start_identifier_warnings ()\n+{\n+  do_identifier_warnings = 1;\n+}\n+\n /* Report some basic statistics about the string pool.  */\n \n void\n stringpool_statistics ()\n {\n-  size_t nelts, nids, overhead, headers;\n-  size_t total_bytes, longest, sum_of_squares;\n-  double exp_len, exp_len2, exp2_len;\n-  sp_hashnode *e;\n-#define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n-\t\t  ? (x) \\\n-\t\t  : ((x) < 1024*1024*10 \\\n-\t\t     ? (x) / 1024 \\\n-\t\t     : (x) / (1024*1024))))\n-#define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n-\n-  total_bytes = longest = sum_of_squares = nids = 0;\n-  FORALL_IDS (e)\n-    {\n-      size_t n = SP_LEN (*e);\n-\n-      total_bytes += n;\n-      sum_of_squares += n*n;\n-      if (n > longest)\n-\tlongest = n;\n-      if (SP_VALID (*e))\n-\tnids++;\n-    }\n-      \n-  nelts = string_hash.nelements;\n-  overhead = obstack_memory_used (&string_stack) - total_bytes;\n-  headers = string_hash.nslots * sizeof (sp_hashnode);\n-\n-  fprintf (stderr,\n-\"\\nString pool\\n\\\n-entries\\t\\t%lu\\n\\\n-identifiers\\t%lu (%.2f%%)\\n\\\n-slots\\t\\t%lu\\n\\\n-bytes\\t\\t%lu%c (%lu%c overhead)\\n\\\n-table size\\t%lu%c\\n\",\n-\t   (unsigned long) nelts,\n-\t   (unsigned long) nids, nids * 100.0 / nelts,\n-\t   (unsigned long) string_hash.nslots,\n-\t   SCALE (total_bytes), LABEL (total_bytes),\n-\t   SCALE (overhead), LABEL (overhead),\n-\t   SCALE (headers), LABEL (headers));\n-\n-  exp_len = (double)total_bytes / (double)nelts;\n-  exp2_len = exp_len * exp_len;\n-  exp_len2 = (double)sum_of_squares / (double)nelts;\n-\n-  fprintf (stderr,\n-\"coll/search\\t%.4f\\n\\\n-ins/search\\t%.4f\\n\\\n-avg. entry\\t%.2f bytes (+/- %.2f)\\n\\\n-longest entry\\t%lu\\n\",\n-\t   (double) string_hash.collisions / (double) string_hash.searches,\n-\t   (double) nelts / (double) string_hash.searches,\n-\t   exp_len, approx_sqrt (exp_len2 - exp2_len),\n-\t   (unsigned long) longest);\n-#undef SCALE\n-#undef LABEL\n+  ht_dump_statistics (ident_hash);\n }\n \n-/* Mark the string hash for GC.  */\n+/* Mark an identifier for GC.  */\n \n-static void\n-mark_string_hash (arg)\n-     void *arg ATTRIBUTE_UNUSED;\n+static int\n+mark_ident (pfile, h, v)\n+     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     hashnode h;\n+     const PTR v ATTRIBUTE_UNUSED;\n {\n-  sp_hashnode *h;\n+  ggc_mark_nonnull_tree (HT_IDENT_TO_GCC_IDENT (h));\n+  return 1;\n+}\n \n-  FORALL_IDS (h)\n-    {\n-      ggc_mark_tree (SP_TREE (*h));\n-    }\n+/* Mark all identifiers for GC.  */\n+\n+static void\n+mark_ident_hash (arg)\n+     PTR arg ATTRIBUTE_UNUSED;\n+{\n+  ht_forall (ident_hash, mark_ident, NULL);\n }"}, {"sha": "74b43dedbfbceac0dea1ead30f28d9af7f10c6dc", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -1421,7 +1421,7 @@ int warn_cast_align;\n    characters.  The value N is in `id_clash_len'.  */\n \n int warn_id_clash;\n-int id_clash_len;\n+unsigned int id_clash_len;\n \n /* Nonzero means warn about any objects definitions whose size is larger\n    than N bytes.  Also want about function definitions whose returned\n@@ -1612,29 +1612,6 @@ floor_log2_wide (x)\n   return log;\n }\n \n-/* Return the approximate positive square root of a number N.  This is for\n-   statistical reports, not code generation.  */\n-double\n-approx_sqrt (x)\n-     double x;\n-{\n-  double s, d;\n-\n-  if (x < 0)\n-    abort ();\n-  if (x == 0)\n-    return 0;\n-\n-  s = x;\n-  do\n-    {\n-      d = (s * s - x) / (2 * s);\n-      s -= d;\n-    }\n-  while (d > .0001);\n-  return s;\n-}\n-\n static int float_handler_set;\n int float_handled;\n jmp_buf float_handler;"}, {"sha": "ef411bbdc23cf3d6b08f37ead19d0168a8883f7f", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -169,6 +169,9 @@ struct lang_hooks\n /* Each front end provides its own.  */\n extern struct lang_hooks lang_hooks;\n \n+/* The hashtable, so that the C front ends can pass it to cpplib.  */\n+extern struct ht *ident_hash;\n+\n /* These functions can be used by targets to set the flags originally\n    implied by -ffast-math and -fno-fast-math.  */\n "}, {"sha": "9245449ca23dbb937f27dab9172fd06b23842642", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -238,26 +238,6 @@ init_obstacks ()\n   lang_set_decl_assembler_name = set_decl_assembler_name;\n }\n \n-void\n-gcc_obstack_init (obstack)\n-     struct obstack *obstack;\n-{\n-  /* Let particular systems override the size of a chunk.  */\n-#ifndef OBSTACK_CHUNK_SIZE\n-#define OBSTACK_CHUNK_SIZE 0\n-#endif\n-  /* Let them override the alloc and free routines too.  */\n-#ifndef OBSTACK_CHUNK_ALLOC\n-#define OBSTACK_CHUNK_ALLOC xmalloc\n-#endif\n-#ifndef OBSTACK_CHUNK_FREE\n-#define OBSTACK_CHUNK_FREE free\n-#endif\n-  _obstack_begin (obstack, OBSTACK_CHUNK_SIZE, 0,\n-\t\t  (void *(*) PARAMS ((long))) OBSTACK_CHUNK_ALLOC,\n-\t\t  (void (*) PARAMS ((void *))) OBSTACK_CHUNK_FREE);\n-}\n-\n \f\n /* Allocate SIZE bytes in the permanent obstack\n    and return a pointer to them.  */"}, {"sha": "e10352f7092f98fa81bcad5aa507bc4d4dbd9cb3", "filename": "gcc/tree.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a967f3d3a45294640e155381ef549e0b8090ad4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2a967f3d3a45294640e155381ef549e0b8090ad4", "patch": "@@ -729,16 +729,27 @@ struct tree_complex\n   union tree_node *imag;\n };\n \f\n+#include \"hashtable.h\"\n+\n /* Define fields and accessors for some special-purpose tree nodes.  */\n \n-#define IDENTIFIER_LENGTH(NODE) (IDENTIFIER_NODE_CHECK (NODE)->identifier.length)\n-#define IDENTIFIER_POINTER(NODE) (IDENTIFIER_NODE_CHECK (NODE)->identifier.pointer)\n+#define IDENTIFIER_LENGTH(NODE) \\\n+\t(IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)\n+#define IDENTIFIER_POINTER(NODE) \\\n+\t((char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)\n+\n+/* Translate a hash table identifier pointer to a tree_identifier\n+   pointer, and vice versa.  */\n+\n+#define HT_IDENT_TO_GCC_IDENT(NODE) \\\n+\t((tree) ((char *) (NODE) - sizeof (struct tree_common)))\n+#define GCC_IDENT_TO_HT_IDENT(NODE) \\\n+\t(&((struct tree_identifier *) (NODE))->id)\n \n struct tree_identifier\n {\n   struct tree_common common;\n-  int length;\n-  const char *pointer;\n+  struct ht_identifier id;\n };\n \n /* In a TREE_LIST node.  */\n@@ -1947,6 +1958,10 @@ extern tree make_tree_vec\t\tPARAMS ((int));\n \n extern tree get_identifier\t\tPARAMS ((const char *));\n \n+/* NODE is an identifier known to the preprocessor.  Make it known to\n+   the front ends as well.  */\n+extern void make_identifier\t\tPARAMS ((tree node));\n+\n /* If an identifier with the name TEXT (a null-terminated string) has\n    previously been referred to, return that node; otherwise return\n    NULL_TREE.  */"}]}