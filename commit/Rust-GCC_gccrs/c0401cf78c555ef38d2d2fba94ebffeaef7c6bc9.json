{"sha": "c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA0MDFjZjc4YzU1NWVmMzhkMmQyZmJhOTRlYmZmZWFlZjdjNmJjOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-30T13:45:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-30T13:45:08Z"}, "message": "runtime: copy internal locking code from Go 1.7 runtime\n    \n    Remove the old locking code written in C.\n    \n    Add a shell script mkrsysinfo.sh to generate the runtime_sysinfo.go\n    file, so that we can get Go copies of the system time structures and\n    other types.\n    \n    Tweak the compiler so that when compiling the runtime package the\n    address operator does not cause local variables to escape.  When the gc\n    compiler compiles the runtime, an escaping local variable is treated as\n    an error.  We should implement that, instead of this change, when escape\n    analysis is turned on.\n    \n    Tweak the compiler so that the generated C header does not include names\n    that start with an underscore followed by a non-upper-case letter,\n    except for the special cases of _defer and _panic.  Otherwise we\n    translate C types to Go in runtime_sysinfo.go and then generate those Go\n    types back as C types in runtime.inc, which is useless and painful for\n    the C code.\n    \n    Change entersyscall and friends to take a dummy argument, as the gc\n    versions do, to simplify calls from the shared code.\n    \n    Reviewed-on: https://go-review.googlesource.com/30079\n\nFrom-SVN: r240657", "tree": {"sha": "d1646c0c4bb59624dfdc04420f835270129cc18e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1646c0c4bb59624dfdc04420f835270129cc18e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/comments", "author": null, "committer": null, "parents": [{"sha": "9e28a77462f81a9a2ab9064d768bd7c9484047e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e28a77462f81a9a2ab9064d768bd7c9484047e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e28a77462f81a9a2ab9064d768bd7c9484047e1"}], "stats": {"total": 2360, "additions": 1541, "deletions": 819}, "files": [{"sha": "092baa22ced61c3de51f6f86b4997f3398d8dac2", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -1,4 +1,4 @@\n-e51657a576367c7a498c94baf985b79066fc082a\n+f3fb9bf2d5a009a707962a416fcd1a8435756218\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "64b0d3c8341b8b568fce931b4c0665f7ff221556", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -3787,6 +3787,13 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n       if ((n->encoding() & ESCAPE_MASK) == int(Node::ESCAPE_NONE))\n \tthis->escapes_ = false;\n \n+      // When compiling the runtime, the address operator does not\n+      // cause local variables to escapes.  When escape analysis\n+      // becomes the default, this should be changed to make it an\n+      // error if we have an address operator that escapes.\n+      if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n+\tthis->escapes_ = false;\n+\n       Named_object* var = NULL;\n       if (this->expr_->var_expression() != NULL)\n \tvar = this->expr_->var_expression()->named_object();"}, {"sha": "30392f76b3fe11e9505d7ab4668edc6d50700c0a", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -4480,6 +4480,19 @@ Gogo::write_c_header()\n        ++p)\n     {\n       Named_object* no = *p;\n+\n+      // Skip names that start with underscore followed by something\n+      // other than an uppercase letter, as when compiling the runtime\n+      // package they are mostly types defined by mkrsysinfo.sh based\n+      // on the C system header files.  We don't need to translate\n+      // types to C and back to Go.  But do accept the special cases\n+      // _defer and _panic.\n+      std::string name = Gogo::unpack_hidden_name(no->name());\n+      if (name[0] == '_'\n+\t  && (name[1] < 'A' || name[1] > 'Z')\n+\t  && (name != \"_defer\" && name != \"_panic\"))\n+\tcontinue;\n+\n       if (no->is_type() && no->type_value()->struct_type() != NULL)\n \ttypes.push_back(no);\n       if (no->is_const() && no->const_value()->type()->integer_type() != NULL)"}, {"sha": "e5150693fab858c3cb63f9fe6aa8c21ad3965846", "filename": "libgo/Makefile.am", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -396,9 +396,9 @@ rtems_task_variable_add_file =\n endif\n \n if LIBGO_IS_LINUX\n-runtime_lock_files = runtime/lock_futex.c runtime/thread-linux.c\n+runtime_thread_files = runtime/thread-linux.c\n else\n-runtime_lock_files = runtime/lock_sema.c runtime/thread-sema.c\n+runtime_thread_files = runtime/thread-sema.c\n endif\n \n if LIBGO_IS_LINUX\n@@ -502,7 +502,6 @@ runtime_files = \\\n \truntime/go-varargs.c \\\n \truntime/env_posix.c \\\n \truntime/heapdump.c \\\n-\t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n \t$(runtime_mem_file) \\\n@@ -518,6 +517,7 @@ runtime_files = \\\n \truntime/runtime.c \\\n \truntime/signal_unix.c \\\n \truntime/thread.c \\\n+\t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \tchan.c \\\n@@ -633,12 +633,8 @@ s-version: Makefile\n \t$(STAMP) $@\n \n runtime_sysinfo.go: s-runtime_sysinfo; @true\n-s-runtime_sysinfo: sysinfo.go\n-\trm -f tmp-runtime_sysinfo.go\n-\techo 'package runtime' > tmp-runtime_sysinfo.go\n-\techo >> tmp-runtime_sysinfo.go\n-\tgrep 'const _sizeof_ucontext_t ' sysinfo.go >> tmp-runtime_sysinfo.go\n-\tgrep 'type _sigset_t ' sysinfo.go >> tmp-runtime_sysinfo.go\n+s-runtime_sysinfo: $(srcdir)/mkrsysinfo.sh gen-sysinfo.go\n+\t$(SHELL) $(srcdir)/mkrsysinfo.sh\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-runtime_sysinfo.go runtime_sysinfo.go\n \t$(STAMP) $@\n "}, {"sha": "bc6832dce0fa8d1456733813641db402128b6322", "filename": "libgo/Makefile.in", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -223,13 +223,13 @@ am__DEPENDENCIES_3 = $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_2) \\\n \t$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_2)\n libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_3)\n-@LIBGO_IS_LINUX_FALSE@am__objects_1 = lock_sema.lo thread-sema.lo\n-@LIBGO_IS_LINUX_TRUE@am__objects_1 = lock_futex.lo thread-linux.lo\n-@HAVE_SYS_MMAN_H_FALSE@am__objects_2 = mem_posix_memalign.lo\n-@HAVE_SYS_MMAN_H_TRUE@am__objects_2 = mem.lo\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_3 = netpoll_kqueue.lo\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@am__objects_3 = netpoll_select.lo\n-@LIBGO_IS_LINUX_TRUE@am__objects_3 = netpoll_epoll.lo\n+@HAVE_SYS_MMAN_H_FALSE@am__objects_1 = mem_posix_memalign.lo\n+@HAVE_SYS_MMAN_H_TRUE@am__objects_1 = mem.lo\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = netpoll_kqueue.lo\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@am__objects_2 = netpoll_select.lo\n+@LIBGO_IS_LINUX_TRUE@am__objects_2 = netpoll_epoll.lo\n+@LIBGO_IS_LINUX_FALSE@am__objects_3 = thread-sema.lo\n+@LIBGO_IS_LINUX_TRUE@am__objects_3 = thread-linux.lo\n @LIBGO_IS_RTEMS_TRUE@am__objects_4 = rtems-task-variable-add.lo\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_5 = getncpu-none.lo\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@am__objects_5 = getncpu-bsd.lo\n@@ -259,13 +259,13 @@ am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n \tgo-typedesc-equal.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n \tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n-\tenv_posix.lo heapdump.lo $(am__objects_1) mcache.lo \\\n-\tmcentral.lo $(am__objects_2) mfixalloc.lo mgc0.lo mheap.lo \\\n-\tmsize.lo $(am__objects_3) panic.lo parfor.lo print.lo proc.lo \\\n-\truntime.lo signal_unix.lo thread.lo yield.lo $(am__objects_4) \\\n-\tchan.lo cpuprof.lo go-iface.lo lfstack.lo malloc.lo mprof.lo \\\n-\tnetpoll.lo rdebug.lo reflect.lo runtime1.lo sema.lo \\\n-\tsigqueue.lo string.lo time.lo $(am__objects_5)\n+\tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n+\t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n+\t$(am__objects_2) panic.lo parfor.lo print.lo proc.lo \\\n+\truntime.lo signal_unix.lo thread.lo $(am__objects_3) yield.lo \\\n+\t$(am__objects_4) chan.lo cpuprof.lo go-iface.lo lfstack.lo \\\n+\tmalloc.lo mprof.lo netpoll.lo rdebug.lo reflect.lo runtime1.lo \\\n+\tsema.lo sigqueue.lo string.lo time.lo $(am__objects_5)\n am_libgo_llgo_la_OBJECTS = $(am__objects_6)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -826,8 +826,8 @@ toolexeclibgounicode_DATA = \\\n @HAVE_SYS_MMAN_H_TRUE@runtime_mem_file = runtime/mem.c\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n-@LIBGO_IS_LINUX_FALSE@runtime_lock_files = runtime/lock_sema.c runtime/thread-sema.c\n-@LIBGO_IS_LINUX_TRUE@runtime_lock_files = runtime/lock_futex.c runtime/thread-linux.c\n+@LIBGO_IS_LINUX_FALSE@runtime_thread_files = runtime/thread-sema.c\n+@LIBGO_IS_LINUX_TRUE@runtime_thread_files = runtime/thread-linux.c\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-none.c\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n@@ -903,7 +903,6 @@ runtime_files = \\\n \truntime/go-varargs.c \\\n \truntime/env_posix.c \\\n \truntime/heapdump.c \\\n-\t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n \t$(runtime_mem_file) \\\n@@ -919,6 +918,7 @@ runtime_files = \\\n \truntime/runtime.c \\\n \truntime/signal_unix.c \\\n \truntime/thread.c \\\n+\t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \tchan.c \\\n@@ -1633,8 +1633,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgobegin_a-go-main.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgobegin_llgo_a-go-main.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgolibbegin_a-go-libmain.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_futex.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcache.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcentral.Plo@am__quote@\n@@ -2179,34 +2177,6 @@ heapdump.lo: runtime/heapdump.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o heapdump.lo `test -f 'runtime/heapdump.c' || echo '$(srcdir)/'`runtime/heapdump.c\n \n-lock_sema.lo: runtime/lock_sema.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lock_sema.lo -MD -MP -MF $(DEPDIR)/lock_sema.Tpo -c -o lock_sema.lo `test -f 'runtime/lock_sema.c' || echo '$(srcdir)/'`runtime/lock_sema.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lock_sema.Tpo $(DEPDIR)/lock_sema.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/lock_sema.c' object='lock_sema.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock_sema.lo `test -f 'runtime/lock_sema.c' || echo '$(srcdir)/'`runtime/lock_sema.c\n-\n-thread-sema.lo: runtime/thread-sema.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread-sema.lo -MD -MP -MF $(DEPDIR)/thread-sema.Tpo -c -o thread-sema.lo `test -f 'runtime/thread-sema.c' || echo '$(srcdir)/'`runtime/thread-sema.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread-sema.Tpo $(DEPDIR)/thread-sema.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/thread-sema.c' object='thread-sema.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread-sema.lo `test -f 'runtime/thread-sema.c' || echo '$(srcdir)/'`runtime/thread-sema.c\n-\n-lock_futex.lo: runtime/lock_futex.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lock_futex.lo -MD -MP -MF $(DEPDIR)/lock_futex.Tpo -c -o lock_futex.lo `test -f 'runtime/lock_futex.c' || echo '$(srcdir)/'`runtime/lock_futex.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lock_futex.Tpo $(DEPDIR)/lock_futex.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/lock_futex.c' object='lock_futex.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock_futex.lo `test -f 'runtime/lock_futex.c' || echo '$(srcdir)/'`runtime/lock_futex.c\n-\n-thread-linux.lo: runtime/thread-linux.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread-linux.lo -MD -MP -MF $(DEPDIR)/thread-linux.Tpo -c -o thread-linux.lo `test -f 'runtime/thread-linux.c' || echo '$(srcdir)/'`runtime/thread-linux.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread-linux.Tpo $(DEPDIR)/thread-linux.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/thread-linux.c' object='thread-linux.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread-linux.lo `test -f 'runtime/thread-linux.c' || echo '$(srcdir)/'`runtime/thread-linux.c\n-\n mcache.lo: runtime/mcache.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mcache.lo -MD -MP -MF $(DEPDIR)/mcache.Tpo -c -o mcache.lo `test -f 'runtime/mcache.c' || echo '$(srcdir)/'`runtime/mcache.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mcache.Tpo $(DEPDIR)/mcache.Plo\n@@ -2333,6 +2303,20 @@ thread.lo: runtime/thread.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread.lo `test -f 'runtime/thread.c' || echo '$(srcdir)/'`runtime/thread.c\n \n+thread-sema.lo: runtime/thread-sema.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread-sema.lo -MD -MP -MF $(DEPDIR)/thread-sema.Tpo -c -o thread-sema.lo `test -f 'runtime/thread-sema.c' || echo '$(srcdir)/'`runtime/thread-sema.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread-sema.Tpo $(DEPDIR)/thread-sema.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/thread-sema.c' object='thread-sema.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread-sema.lo `test -f 'runtime/thread-sema.c' || echo '$(srcdir)/'`runtime/thread-sema.c\n+\n+thread-linux.lo: runtime/thread-linux.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread-linux.lo -MD -MP -MF $(DEPDIR)/thread-linux.Tpo -c -o thread-linux.lo `test -f 'runtime/thread-linux.c' || echo '$(srcdir)/'`runtime/thread-linux.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread-linux.Tpo $(DEPDIR)/thread-linux.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/thread-linux.c' object='thread-linux.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread-linux.lo `test -f 'runtime/thread-linux.c' || echo '$(srcdir)/'`runtime/thread-linux.c\n+\n yield.lo: runtime/yield.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT yield.lo -MD -MP -MF $(DEPDIR)/yield.Tpo -c -o yield.lo `test -f 'runtime/yield.c' || echo '$(srcdir)/'`runtime/yield.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/yield.Tpo $(DEPDIR)/yield.Plo\n@@ -3599,12 +3583,8 @@ s-version: Makefile\n \t$(STAMP) $@\n \n runtime_sysinfo.go: s-runtime_sysinfo; @true\n-s-runtime_sysinfo: sysinfo.go\n-\trm -f tmp-runtime_sysinfo.go\n-\techo 'package runtime' > tmp-runtime_sysinfo.go\n-\techo >> tmp-runtime_sysinfo.go\n-\tgrep 'const _sizeof_ucontext_t ' sysinfo.go >> tmp-runtime_sysinfo.go\n-\tgrep 'type _sigset_t ' sysinfo.go >> tmp-runtime_sysinfo.go\n+s-runtime_sysinfo: $(srcdir)/mkrsysinfo.sh gen-sysinfo.go\n+\t$(SHELL) $(srcdir)/mkrsysinfo.sh\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-runtime_sysinfo.go runtime_sysinfo.go\n \t$(STAMP) $@\n "}, {"sha": "14938da59c161058cdf62f8edd970f6a2c5db377", "filename": "libgo/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -195,6 +195,9 @@\n /* Define to 1 if you have the <sched.h> header file. */\n #undef HAVE_SCHED_H\n \n+/* Define to 1 if you have the <semaphore.h> header file. */\n+#undef HAVE_SEMAPHORE_H\n+\n /* Define to 1 if you have the `sem_timedwait' function. */\n #undef HAVE_SEM_TIMEDWAIT\n "}, {"sha": "e065417fa155b94cd8c6fdfb86e604fa72a69387", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -14714,7 +14714,7 @@ $as_echo \"#define HAVE_GETIPINFO 1\" >>confdefs.h\n   fi\n \n \n-for ac_header in sched.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h\n+for ac_header in sched.h semaphore.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\""}, {"sha": "0f98ae83751682abde95a377f07645c56278a623", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -570,7 +570,7 @@ AC_C_BIGENDIAN\n \n GCC_CHECK_UNWIND_GETIPINFO\n \n-AC_CHECK_HEADERS(sched.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h)\n+AC_CHECK_HEADERS(sched.h semaphore.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h)\n \n AC_CHECK_HEADERS([linux/filter.h linux/if_addr.h linux/if_ether.h linux/if_tun.h linux/netlink.h linux/rtnetlink.h], [], [],\n [#ifdef HAVE_SYS_SOCKET_H"}, {"sha": "711a551d2785bf90bdcbe4526c15655bcf6265a3", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -17,8 +17,6 @@ package runtime\n //var F64toint = f64toint\n //var Sqrt = sqrt\n \n-func entersyscall(int32)\n-func exitsyscall(int32)\n func golockedOSThread() bool\n \n var Entersyscall = entersyscall"}, {"sha": "1ad791111084e75dff3e901f547a024352716d7e", "filename": "libgo/go/runtime/lock_futex.go", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Flock_futex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Flock_futex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flock_futex.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,225 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build dragonfly freebsd linux\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, while we still have C runtime code, use go:linkname to\n+// rename some functions to themselves, so that the compiler will\n+// export them.\n+//\n+//go:linkname lock runtime.lock\n+//go:linkname unlock runtime.unlock\n+//go:linkname noteclear runtime.noteclear\n+//go:linkname notewakeup runtime.notewakeup\n+//go:linkname notesleep runtime.notesleep\n+//go:linkname notetsleep runtime.notetsleep\n+//go:linkname notetsleepg runtime.notetsleepg\n+\n+// This implementation depends on OS-specific implementations of\n+//\n+//\tfutexsleep(addr *uint32, val uint32, ns int64)\n+//\t\tAtomically,\n+//\t\t\tif *addr == val { sleep }\n+//\t\tMight be woken up spuriously; that's allowed.\n+//\t\tDon't sleep longer than ns; ns < 0 means forever.\n+//\n+//\tfutexwakeup(addr *uint32, cnt uint32)\n+//\t\tIf any procs are sleeping on addr, wake up at most cnt.\n+\n+const (\n+\tmutex_unlocked = 0\n+\tmutex_locked   = 1\n+\tmutex_sleeping = 2\n+\n+\tactive_spin     = 4\n+\tactive_spin_cnt = 30\n+\tpassive_spin    = 1\n+)\n+\n+// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping.\n+// mutex_sleeping means that there is presumably at least one sleeping thread.\n+// Note that there can be spinning threads during all states - they do not\n+// affect mutex's state.\n+\n+// We use the uintptr mutex.key and note.key as a uint32.\n+func key32(p *uintptr) *uint32 {\n+\treturn (*uint32)(unsafe.Pointer(p))\n+}\n+\n+func lock(l *mutex) {\n+\tgp := getg()\n+\n+\tif gp.m.locks < 0 {\n+\t\tthrow(\"runtime\u00b7lock: lock count\")\n+\t}\n+\tgp.m.locks++\n+\n+\t// Speculative grab for lock.\n+\tv := atomic.Xchg(key32(&l.key), mutex_locked)\n+\tif v == mutex_unlocked {\n+\t\treturn\n+\t}\n+\n+\t// wait is either MUTEX_LOCKED or MUTEX_SLEEPING\n+\t// depending on whether there is a thread sleeping\n+\t// on this mutex. If we ever change l->key from\n+\t// MUTEX_SLEEPING to some other value, we must be\n+\t// careful to change it back to MUTEX_SLEEPING before\n+\t// returning, to ensure that the sleeping thread gets\n+\t// its wakeup call.\n+\twait := v\n+\n+\t// On uniprocessors, no point spinning.\n+\t// On multiprocessors, spin for ACTIVE_SPIN attempts.\n+\tspin := 0\n+\tif ncpu > 1 {\n+\t\tspin = active_spin\n+\t}\n+\tfor {\n+\t\t// Try for lock, spinning.\n+\t\tfor i := 0; i < spin; i++ {\n+\t\t\tfor l.key == mutex_unlocked {\n+\t\t\t\tif atomic.Cas(key32(&l.key), mutex_unlocked, wait) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tprocyield(active_spin_cnt)\n+\t\t}\n+\n+\t\t// Try for lock, rescheduling.\n+\t\tfor i := 0; i < passive_spin; i++ {\n+\t\t\tfor l.key == mutex_unlocked {\n+\t\t\t\tif atomic.Cas(key32(&l.key), mutex_unlocked, wait) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tosyield()\n+\t\t}\n+\n+\t\t// Sleep.\n+\t\tv = atomic.Xchg(key32(&l.key), mutex_sleeping)\n+\t\tif v == mutex_unlocked {\n+\t\t\treturn\n+\t\t}\n+\t\twait = mutex_sleeping\n+\t\tfutexsleep(key32(&l.key), mutex_sleeping, -1)\n+\t}\n+}\n+\n+func unlock(l *mutex) {\n+\tv := atomic.Xchg(key32(&l.key), mutex_unlocked)\n+\tif v == mutex_unlocked {\n+\t\tthrow(\"unlock of unlocked lock\")\n+\t}\n+\tif v == mutex_sleeping {\n+\t\tfutexwakeup(key32(&l.key), 1)\n+\t}\n+\n+\tgp := getg()\n+\tgp.m.locks--\n+\tif gp.m.locks < 0 {\n+\t\tthrow(\"runtime\u00b7unlock: lock count\")\n+\t}\n+\t// if gp.m.locks == 0 && gp.preempt { // restore the preemption request in case we've cleared it in newstack\n+\t//\tgp.stackguard0 = stackPreempt\n+\t// }\n+}\n+\n+// One-time notifications.\n+func noteclear(n *note) {\n+\tn.key = 0\n+}\n+\n+func notewakeup(n *note) {\n+\told := atomic.Xchg(key32(&n.key), 1)\n+\tif old != 0 {\n+\t\tprint(\"notewakeup - double wakeup (\", old, \")\\n\")\n+\t\tthrow(\"notewakeup - double wakeup\")\n+\t}\n+\tfutexwakeup(key32(&n.key), 1)\n+}\n+\n+func notesleep(n *note) {\n+\tgp := getg()\n+\n+\t// Currently OK to sleep in non-g0 for gccgo.  It happens in\n+\t// stoptheworld because we have not implemented preemption.\n+\t// if gp != gp.m.g0 {\n+\t// \tthrow(\"notesleep not on g0\")\n+\t// }\n+\n+\tfor atomic.Load(key32(&n.key)) == 0 {\n+\t\tgp.m.blocked = true\n+\t\tfutexsleep(key32(&n.key), 0, -1)\n+\t\tgp.m.blocked = false\n+\t}\n+}\n+\n+// May run with m.p==nil if called from notetsleep, so write barriers\n+// are not allowed.\n+//\n+//go:nosplit\n+//go:nowritebarrier\n+func notetsleep_internal(n *note, ns int64) bool {\n+\tgp := getg()\n+\n+\tif ns < 0 {\n+\t\tfor atomic.Load(key32(&n.key)) == 0 {\n+\t\t\tgp.m.blocked = true\n+\t\t\tfutexsleep(key32(&n.key), 0, -1)\n+\t\t\tgp.m.blocked = false\n+\t\t}\n+\t\treturn true\n+\t}\n+\n+\tif atomic.Load(key32(&n.key)) != 0 {\n+\t\treturn true\n+\t}\n+\n+\tdeadline := nanotime() + ns\n+\tfor {\n+\t\tgp.m.blocked = true\n+\t\tfutexsleep(key32(&n.key), 0, ns)\n+\t\tgp.m.blocked = false\n+\t\tif atomic.Load(key32(&n.key)) != 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tnow := nanotime()\n+\t\tif now >= deadline {\n+\t\t\tbreak\n+\t\t}\n+\t\tns = deadline - now\n+\t}\n+\treturn atomic.Load(key32(&n.key)) != 0\n+}\n+\n+func notetsleep(n *note, ns int64) bool {\n+\tgp := getg()\n+\tif gp != gp.m.g0 && gp.m.preemptoff != \"\" {\n+\t\tthrow(\"notetsleep not on g0\")\n+\t}\n+\n+\treturn notetsleep_internal(n, ns)\n+}\n+\n+// same as runtime\u00b7notetsleep, but called on user g (not g0)\n+// calls only nosplit functions between entersyscallblock/exitsyscall\n+func notetsleepg(n *note, ns int64) bool {\n+\tgp := getg()\n+\tif gp == gp.m.g0 {\n+\t\tthrow(\"notetsleepg on g0\")\n+\t}\n+\n+\tentersyscallblock(0)\n+\tok := notetsleep_internal(n, ns)\n+\texitsyscall(0)\n+\treturn ok\n+}"}, {"sha": "eaf938a9bb3891e3e5b751df2a6b4a9e17bc01ef", "filename": "libgo/go/runtime/lock_sema.go", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Flock_sema.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Flock_sema.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flock_sema.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin nacl netbsd openbsd plan9 solaris windows\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, while we still have C runtime code, use go:linkname to\n+// rename some functions to themselves, so that the compiler will\n+// export them.\n+//\n+//go:linkname lock runtime.lock\n+//go:linkname unlock runtime.unlock\n+//go:linkname noteclear runtime.noteclear\n+//go:linkname notewakeup runtime.notewakeup\n+//go:linkname notesleep runtime.notesleep\n+//go:linkname notetsleep runtime.notetsleep\n+//go:linkname notetsleepg runtime.notetsleepg\n+\n+// This implementation depends on OS-specific implementations of\n+//\n+//\tfunc semacreate(mp *m)\n+//\t\tCreate a semaphore for mp, if it does not already have one.\n+//\n+//\tfunc semasleep(ns int64) int32\n+//\t\tIf ns < 0, acquire m's semaphore and return 0.\n+//\t\tIf ns >= 0, try to acquire m's semaphore for at most ns nanoseconds.\n+//\t\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n+//\n+//\tfunc semawakeup(mp *m)\n+//\t\tWake up mp, which is or will soon be sleeping on its semaphore.\n+//\n+const (\n+\tmutex_locked uintptr = 1\n+\n+\tactive_spin     = 4\n+\tactive_spin_cnt = 30\n+\tpassive_spin    = 1\n+)\n+\n+func lock(l *mutex) {\n+\tgp := getg()\n+\tif gp.m.locks < 0 {\n+\t\tthrow(\"runtime\u00b7lock: lock count\")\n+\t}\n+\tgp.m.locks++\n+\n+\t// Speculative grab for lock.\n+\tif atomic.Casuintptr(&l.key, 0, mutex_locked) {\n+\t\treturn\n+\t}\n+\tsemacreate(gp.m)\n+\n+\t// On uniprocessor's, no point spinning.\n+\t// On multiprocessors, spin for ACTIVE_SPIN attempts.\n+\tspin := 0\n+\tif ncpu > 1 {\n+\t\tspin = active_spin\n+\t}\n+Loop:\n+\tfor i := 0; ; i++ {\n+\t\tv := atomic.Loaduintptr(&l.key)\n+\t\tif v&mutex_locked == 0 {\n+\t\t\t// Unlocked. Try to lock.\n+\t\t\tif atomic.Casuintptr(&l.key, v, v|mutex_locked) {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\ti = 0\n+\t\t}\n+\t\tif i < spin {\n+\t\t\tprocyield(active_spin_cnt)\n+\t\t} else if i < spin+passive_spin {\n+\t\t\tosyield()\n+\t\t} else {\n+\t\t\t// Someone else has it.\n+\t\t\t// l->waitm points to a linked list of M's waiting\n+\t\t\t// for this lock, chained through m->nextwaitm.\n+\t\t\t// Queue this M.\n+\t\t\tfor {\n+\t\t\t\tgp.m.nextwaitm = v &^ mutex_locked\n+\t\t\t\tif atomic.Casuintptr(&l.key, v, uintptr(unsafe.Pointer(gp.m))|mutex_locked) {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tv = atomic.Loaduintptr(&l.key)\n+\t\t\t\tif v&mutex_locked == 0 {\n+\t\t\t\t\tcontinue Loop\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif v&mutex_locked != 0 {\n+\t\t\t\t// Queued. Wait.\n+\t\t\t\tsemasleep(-1)\n+\t\t\t\ti = 0\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+//go:nowritebarrier\n+// We might not be holding a p in this code.\n+func unlock(l *mutex) {\n+\tgp := getg()\n+\tvar mp *m\n+\tfor {\n+\t\tv := atomic.Loaduintptr(&l.key)\n+\t\tif v == mutex_locked {\n+\t\t\tif atomic.Casuintptr(&l.key, mutex_locked, 0) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// Other M's are waiting for the lock.\n+\t\t\t// Dequeue an M.\n+\t\t\tmp = (*m)(unsafe.Pointer(v &^ mutex_locked))\n+\t\t\tif atomic.Casuintptr(&l.key, v, mp.nextwaitm) {\n+\t\t\t\t// Dequeued an M.  Wake it.\n+\t\t\t\tsemawakeup(mp)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tgp.m.locks--\n+\tif gp.m.locks < 0 {\n+\t\tthrow(\"runtime\u00b7unlock: lock count\")\n+\t}\n+\t// if gp.m.locks == 0 && gp.preempt { // restore the preemption request in case we've cleared it in newstack\n+\t//\tgp.stackguard0 = stackPreempt\n+\t// }\n+}\n+\n+// One-time notifications.\n+func noteclear(n *note) {\n+\tn.key = 0\n+}\n+\n+func notewakeup(n *note) {\n+\tvar v uintptr\n+\tfor {\n+\t\tv = atomic.Loaduintptr(&n.key)\n+\t\tif atomic.Casuintptr(&n.key, v, mutex_locked) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// Successfully set waitm to locked.\n+\t// What was it before?\n+\tswitch {\n+\tcase v == 0:\n+\t\t// Nothing was waiting. Done.\n+\tcase v == mutex_locked:\n+\t\t// Two notewakeups!  Not allowed.\n+\t\tthrow(\"notewakeup - double wakeup\")\n+\tdefault:\n+\t\t// Must be the waiting m. Wake it up.\n+\t\tsemawakeup((*m)(unsafe.Pointer(v)))\n+\t}\n+}\n+\n+func notesleep(n *note) {\n+\tgp := getg()\n+\n+\t// Currently OK to sleep in non-g0 for gccgo.  It happens in\n+\t// stoptheworld because we have not implemented preemption.\n+\t// if gp != gp.m.g0 {\n+\t//\tthrow(\"notesleep not on g0\")\n+\t// }\n+\n+\tsemacreate(gp.m)\n+\tif !atomic.Casuintptr(&n.key, 0, uintptr(unsafe.Pointer(gp.m))) {\n+\t\t// Must be locked (got wakeup).\n+\t\tif n.key != mutex_locked {\n+\t\t\tthrow(\"notesleep - waitm out of sync\")\n+\t\t}\n+\t\treturn\n+\t}\n+\t// Queued. Sleep.\n+\tgp.m.blocked = true\n+\tsemasleep(-1)\n+\tgp.m.blocked = false\n+}\n+\n+//go:nosplit\n+func notetsleep_internal(n *note, ns int64, gp *g, deadline int64) bool {\n+\t// gp and deadline are logically local variables, but they are written\n+\t// as parameters so that the stack space they require is charged\n+\t// to the caller.\n+\t// This reduces the nosplit footprint of notetsleep_internal.\n+\tgp = getg()\n+\n+\t// Register for wakeup on n->waitm.\n+\tif !atomic.Casuintptr(&n.key, 0, uintptr(unsafe.Pointer(gp.m))) {\n+\t\t// Must be locked (got wakeup).\n+\t\tif n.key != mutex_locked {\n+\t\t\tthrow(\"notetsleep - waitm out of sync\")\n+\t\t}\n+\t\treturn true\n+\t}\n+\tif ns < 0 {\n+\t\t// Queued. Sleep.\n+\t\tgp.m.blocked = true\n+\t\tsemasleep(-1)\n+\t\tgp.m.blocked = false\n+\t\treturn true\n+\t}\n+\n+\tdeadline = nanotime() + ns\n+\tfor {\n+\t\t// Registered. Sleep.\n+\t\tgp.m.blocked = true\n+\t\tif semasleep(ns) >= 0 {\n+\t\t\tgp.m.blocked = false\n+\t\t\t// Acquired semaphore, semawakeup unregistered us.\n+\t\t\t// Done.\n+\t\t\treturn true\n+\t\t}\n+\t\tgp.m.blocked = false\n+\t\t// Interrupted or timed out. Still registered. Semaphore not acquired.\n+\t\tns = deadline - nanotime()\n+\t\tif ns <= 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\t// Deadline hasn't arrived. Keep sleeping.\n+\t}\n+\n+\t// Deadline arrived. Still registered. Semaphore not acquired.\n+\t// Want to give up and return, but have to unregister first,\n+\t// so that any notewakeup racing with the return does not\n+\t// try to grant us the semaphore when we don't expect it.\n+\tfor {\n+\t\tv := atomic.Loaduintptr(&n.key)\n+\t\tswitch v {\n+\t\tcase uintptr(unsafe.Pointer(gp.m)):\n+\t\t\t// No wakeup yet; unregister if possible.\n+\t\t\tif atomic.Casuintptr(&n.key, v, 0) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\tcase mutex_locked:\n+\t\t\t// Wakeup happened so semaphore is available.\n+\t\t\t// Grab it to avoid getting out of sync.\n+\t\t\tgp.m.blocked = true\n+\t\t\tif semasleep(-1) < 0 {\n+\t\t\t\tthrow(\"runtime: unable to acquire - semaphore out of sync\")\n+\t\t\t}\n+\t\t\tgp.m.blocked = false\n+\t\t\treturn true\n+\t\tdefault:\n+\t\t\tthrow(\"runtime: unexpected waitm - semaphore out of sync\")\n+\t\t}\n+\t}\n+}\n+\n+func notetsleep(n *note, ns int64) bool {\n+\tgp := getg()\n+\n+\t// Currently OK to sleep in non-g0 for gccgo.  It happens in\n+\t// stoptheworld because we have not implemented preemption.\n+\t// if gp != gp.m.g0 && gp.m.preemptoff != \"\" {\n+\t//\tthrow(\"notetsleep not on g0\")\n+\t// }\n+\n+\tsemacreate(gp.m)\n+\treturn notetsleep_internal(n, ns, nil, 0)\n+}\n+\n+// same as runtime\u00b7notetsleep, but called on user g (not g0)\n+// calls only nosplit functions between entersyscallblock/exitsyscall\n+func notetsleepg(n *note, ns int64) bool {\n+\tgp := getg()\n+\tif gp == gp.m.g0 {\n+\t\tthrow(\"notetsleepg on g0\")\n+\t}\n+\tsemacreate(gp.m)\n+\tentersyscallblock(0)\n+\tok := notetsleep_internal(n, ns, nil, 0)\n+\texitsyscall(0)\n+\treturn ok\n+}"}, {"sha": "db403e2eb37b4d118ffe7910fb82c9f85def8062", "filename": "libgo/go/runtime/os_darwin.go", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_darwin.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,326 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+type mOS struct {\n+\tmachport uint32 // return address for mach ipc\n+\twaitsema uint32 // semaphore for parking on locks\n+}\n+\n+//go:noescape\n+//extern mach_msg_trap\n+func mach_msg_trap(h unsafe.Pointer, op int32, send_size, rcv_size, rcv_name, timeout, notify uint32) int32\n+\n+//extern mach_reply_port\n+func mach_reply_port() uint32\n+\n+//extern mach_task_self\n+func mach_task_self() uint32\n+\n+func unimplemented(name string) {\n+\tprintln(name, \"not implemented\")\n+\t*(*int)(unsafe.Pointer(uintptr(1231))) = 1231\n+}\n+\n+//go:nosplit\n+func semawakeup(mp *m) {\n+\tmach_semrelease(mp.mos.waitsema)\n+}\n+\n+//go:nosplit\n+func semacreate(mp *m) {\n+\tif mp.mos.waitsema != 0 {\n+\t\treturn\n+\t}\n+\tsystemstack(func() {\n+\t\tmp.mos.waitsema = mach_semcreate()\n+\t})\n+}\n+\n+// Mach IPC, to get at semaphores\n+// Definitions are in /usr/include/mach on a Mac.\n+\n+func macherror(r int32, fn string) {\n+\tprint(\"mach error \", fn, \": \", r, \"\\n\")\n+\tthrow(\"mach error\")\n+}\n+\n+const _DebugMach = false\n+\n+var zerondr machndr\n+\n+func mach_msgh_bits(a, b uint32) uint32 {\n+\treturn a | b<<8\n+}\n+\n+func mach_msg(h *machheader, op int32, send_size, rcv_size, rcv_name, timeout, notify uint32) int32 {\n+\t// TODO: Loop on interrupt.\n+\treturn mach_msg_trap(unsafe.Pointer(h), op, send_size, rcv_size, rcv_name, timeout, notify)\n+}\n+\n+// Mach RPC (MIG)\n+const (\n+\t_MinMachMsg = 48\n+\t_MachReply  = 100\n+)\n+\n+type codemsg struct {\n+\th    machheader\n+\tndr  machndr\n+\tcode int32\n+}\n+\n+func machcall(h *machheader, maxsize int32, rxsize int32) int32 {\n+\t_g_ := getg()\n+\tport := _g_.m.mos.machport\n+\tif port == 0 {\n+\t\tport = mach_reply_port()\n+\t\t_g_.m.mos.machport = port\n+\t}\n+\n+\th.msgh_bits |= mach_msgh_bits(_MACH_MSG_TYPE_COPY_SEND, _MACH_MSG_TYPE_MAKE_SEND_ONCE)\n+\th.msgh_local_port = port\n+\th.msgh_reserved = 0\n+\tid := h.msgh_id\n+\n+\tif _DebugMach {\n+\t\tp := (*[10000]unsafe.Pointer)(unsafe.Pointer(h))\n+\t\tprint(\"send:\\t\")\n+\t\tvar i uint32\n+\t\tfor i = 0; i < h.msgh_size/uint32(unsafe.Sizeof(p[0])); i++ {\n+\t\t\tprint(\" \", p[i])\n+\t\t\tif i%8 == 7 {\n+\t\t\t\tprint(\"\\n\\t\")\n+\t\t\t}\n+\t\t}\n+\t\tif i%8 != 0 {\n+\t\t\tprint(\"\\n\")\n+\t\t}\n+\t}\n+\tret := mach_msg(h, _MACH_SEND_MSG|_MACH_RCV_MSG, h.msgh_size, uint32(maxsize), port, 0, 0)\n+\tif ret != 0 {\n+\t\tif _DebugMach {\n+\t\t\tprint(\"mach_msg error \", ret, \"\\n\")\n+\t\t}\n+\t\treturn ret\n+\t}\n+\tif _DebugMach {\n+\t\tp := (*[10000]unsafe.Pointer)(unsafe.Pointer(h))\n+\t\tvar i uint32\n+\t\tfor i = 0; i < h.msgh_size/uint32(unsafe.Sizeof(p[0])); i++ {\n+\t\t\tprint(\" \", p[i])\n+\t\t\tif i%8 == 7 {\n+\t\t\t\tprint(\"\\n\\t\")\n+\t\t\t}\n+\t\t}\n+\t\tif i%8 != 0 {\n+\t\t\tprint(\"\\n\")\n+\t\t}\n+\t}\n+\tif h.msgh_id != id+_MachReply {\n+\t\tif _DebugMach {\n+\t\t\tprint(\"mach_msg _MachReply id mismatch \", h.msgh_id, \" != \", id+_MachReply, \"\\n\")\n+\t\t}\n+\t\treturn -303 // MIG_REPLY_MISMATCH\n+\t}\n+\t// Look for a response giving the return value.\n+\t// Any call can send this back with an error,\n+\t// and some calls only have return values so they\n+\t// send it back on success too. I don't quite see how\n+\t// you know it's one of these and not the full response\n+\t// format, so just look if the message is right.\n+\tc := (*codemsg)(unsafe.Pointer(h))\n+\tif uintptr(h.msgh_size) == unsafe.Sizeof(*c) && h.msgh_bits&_MACH_MSGH_BITS_COMPLEX == 0 {\n+\t\tif _DebugMach {\n+\t\t\tprint(\"mig result \", c.code, \"\\n\")\n+\t\t}\n+\t\treturn c.code\n+\t}\n+\tif h.msgh_size != uint32(rxsize) {\n+\t\tif _DebugMach {\n+\t\t\tprint(\"mach_msg _MachReply size mismatch \", h.msgh_size, \" != \", rxsize, \"\\n\")\n+\t\t}\n+\t\treturn -307 // MIG_ARRAY_TOO_LARGE\n+\t}\n+\treturn 0\n+}\n+\n+// Semaphores!\n+\n+const (\n+\ttmach_semcreate = 3418\n+\trmach_semcreate = tmach_semcreate + _MachReply\n+\n+\ttmach_semdestroy = 3419\n+\trmach_semdestroy = tmach_semdestroy + _MachReply\n+\n+\t_KERN_ABORTED             = 14\n+\t_KERN_OPERATION_TIMED_OUT = 49\n+)\n+\n+type tmach_semcreatemsg struct {\n+\th      machheader\n+\tndr    machndr\n+\tpolicy int32\n+\tvalue  int32\n+}\n+\n+type rmach_semcreatemsg struct {\n+\th         machheader\n+\tbody      machbody\n+\tsemaphore machport\n+}\n+\n+type tmach_semdestroymsg struct {\n+\th         machheader\n+\tbody      machbody\n+\tsemaphore machport\n+}\n+\n+func mach_semcreate() uint32 {\n+\tvar m [256]uint8\n+\ttx := (*tmach_semcreatemsg)(unsafe.Pointer(&m))\n+\trx := (*rmach_semcreatemsg)(unsafe.Pointer(&m))\n+\n+\ttx.h.msgh_bits = 0\n+\ttx.h.msgh_size = uint32(unsafe.Sizeof(*tx))\n+\ttx.h.msgh_remote_port = mach_task_self()\n+\ttx.h.msgh_id = tmach_semcreate\n+\ttx.ndr = zerondr\n+\n+\ttx.policy = 0 // 0 = SYNC_POLICY_FIFO\n+\ttx.value = 0\n+\n+\tfor {\n+\t\tr := machcall(&tx.h, int32(unsafe.Sizeof(m)), int32(unsafe.Sizeof(*rx)))\n+\t\tif r == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif r == _KERN_ABORTED { // interrupted\n+\t\t\tcontinue\n+\t\t}\n+\t\tmacherror(r, \"semaphore_create\")\n+\t}\n+\tif rx.body.msgh_descriptor_count != 1 {\n+\t\tunimplemented(\"mach_semcreate desc count\")\n+\t}\n+\treturn rx.semaphore.name\n+}\n+\n+func mach_semdestroy(sem uint32) {\n+\tvar m [256]uint8\n+\ttx := (*tmach_semdestroymsg)(unsafe.Pointer(&m))\n+\n+\ttx.h.msgh_bits = _MACH_MSGH_BITS_COMPLEX\n+\ttx.h.msgh_size = uint32(unsafe.Sizeof(*tx))\n+\ttx.h.msgh_remote_port = mach_task_self()\n+\ttx.h.msgh_id = tmach_semdestroy\n+\ttx.body.msgh_descriptor_count = 1\n+\ttx.semaphore.name = sem\n+\ttx.semaphore.disposition = _MACH_MSG_TYPE_MOVE_SEND\n+\ttx.semaphore._type = 0\n+\n+\tfor {\n+\t\tr := machcall(&tx.h, int32(unsafe.Sizeof(m)), 0)\n+\t\tif r == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif r == _KERN_ABORTED { // interrupted\n+\t\t\tcontinue\n+\t\t}\n+\t\tmacherror(r, \"semaphore_destroy\")\n+\t}\n+}\n+\n+//extern semaphore_wait\n+func mach_semaphore_wait(sema uint32) int32\n+\n+//extern semaphore_timedwait\n+func mach_semaphore_timedwait(sema, sec, nsec uint32) int32\n+\n+//extern semaphore_signal\n+func mach_semaphore_signal(sema uint32) int32\n+\n+//extern semaphore_signal_all\n+func mach_semaphore_signal_all(sema uint32) int32\n+\n+func semasleep1(ns int64) int32 {\n+\t_g_ := getg()\n+\n+\tif ns >= 0 {\n+\t\tvar nsecs int32\n+\t\tsecs := timediv(ns, 1000000000, &nsecs)\n+\t\tr := mach_semaphore_timedwait(_g_.m.mos.waitsema, uint32(secs), uint32(nsecs))\n+\t\tif r == _KERN_ABORTED || r == _KERN_OPERATION_TIMED_OUT {\n+\t\t\treturn -1\n+\t\t}\n+\t\tif r != 0 {\n+\t\t\tmacherror(r, \"semaphore_wait\")\n+\t\t}\n+\t\treturn 0\n+\t}\n+\n+\tfor {\n+\t\tr := mach_semaphore_wait(_g_.m.mos.waitsema)\n+\t\tif r == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif r == _KERN_ABORTED { // interrupted\n+\t\t\tcontinue\n+\t\t}\n+\t\tmacherror(r, \"semaphore_wait\")\n+\t}\n+\treturn 0\n+}\n+\n+//go:nosplit\n+func semasleep(ns int64) int32 {\n+\tvar r int32\n+\tsystemstack(func() {\n+\t\tr = semasleep1(ns)\n+\t})\n+\treturn r\n+}\n+\n+//go:nosplit\n+func mach_semrelease(sem uint32) {\n+\tfor {\n+\t\tr := mach_semaphore_signal(sem)\n+\t\tif r == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif r == _KERN_ABORTED { // interrupted\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// mach_semrelease must be completely nosplit,\n+\t\t// because it is called from Go code.\n+\t\t// If we're going to die, start that process on the system stack\n+\t\t// to avoid a Go stack split.\n+\t\tsystemstack(func() { macherror(r, \"semaphore_signal\") })\n+\t}\n+}\n+\n+type machheader struct {\n+\tmsgh_bits        uint32\n+\tmsgh_size        uint32\n+\tmsgh_remote_port uint32\n+\tmsgh_local_port  uint32\n+\tmsgh_reserved    uint32\n+\tmsgh_id          int32\n+}\n+\n+type machndr struct {\n+\tmig_vers     uint8\n+\tif_vers      uint8\n+\treserved1    uint8\n+\tmig_encoding uint8\n+\tint_rep      uint8\n+\tchar_rep     uint8\n+\tfloat_rep    uint8\n+\treserved2    uint8\n+}"}, {"sha": "645298436b5f131cd49f1edba93d7bfd22f02d84", "filename": "libgo/go/runtime/os_dragonfly.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_dragonfly.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_dragonfly.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_dragonfly.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+type mOS struct {\n+\tunused byte\n+}\n+\n+//go:noescape\n+//extern umtx_sleep\n+func sys_umtx_sleep(addr *uint32, val, timeout int32) int32\n+\n+//go:noescape\n+//extern umtx_wakeup\n+func sys_umtx_wakeup(addr *uint32, val int32) int32\n+\n+//go:nosplit\n+func futexsleep(addr *uint32, val uint32, ns int64) {\n+\tsystemstack(func() {\n+\t\tfutexsleep1(addr, val, ns)\n+\t})\n+}\n+\n+func futexsleep1(addr *uint32, val uint32, ns int64) {\n+\tvar timeout int32\n+\tif ns >= 0 {\n+\t\t// The timeout is specified in microseconds - ensure that we\n+\t\t// do not end up dividing to zero, which would put us to sleep\n+\t\t// indefinitely...\n+\t\ttimeout = timediv(ns, 1000, nil)\n+\t\tif timeout == 0 {\n+\t\t\ttimeout = 1\n+\t\t}\n+\t}\n+\n+\t// sys_umtx_sleep will return EWOULDBLOCK (EAGAIN) when the timeout\n+\t// expires or EBUSY if the mutex value does not match.\n+\tret := sys_umtx_sleep(addr, int32(val), timeout)\n+\tif ret >= 0 || ret == -_EINTR || ret == -_EAGAIN || ret == -_EBUSY {\n+\t\treturn\n+\t}\n+\n+\tprint(\"umtx_sleep addr=\", addr, \" val=\", val, \" ret=\", ret, \"\\n\")\n+\t*(*int32)(unsafe.Pointer(uintptr(0x1005))) = 0x1005\n+}\n+\n+//go:nosplit\n+func futexwakeup(addr *uint32, cnt uint32) {\n+\tret := sys_umtx_wakeup(addr, int32(cnt))\n+\tif ret >= 0 {\n+\t\treturn\n+\t}\n+\n+\tsystemstack(func() {\n+\t\tprint(\"umtx_wake_addr=\", addr, \" ret=\", ret, \"\\n\")\n+\t\t*(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006\n+\t})\n+}"}, {"sha": "4512e7699fe7b6de1cccab7ed2bb93bf4ff85aa0", "filename": "libgo/go/runtime/os_freebsd.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_freebsd.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+type mOS struct {\n+\tunused byte\n+}\n+\n+//go:noescape\n+//extern _umtx_op\n+func sys_umtx_op(addr *uint32, mode int32, val uint32, ptr2, ts *timespec) int32\n+\n+// FreeBSD's umtx_op syscall is effectively the same as Linux's futex, and\n+// thus the code is largely similar. See Linux implementation\n+// and lock_futex.go for comments.\n+\n+//go:nosplit\n+func futexsleep(addr *uint32, val uint32, ns int64) {\n+\tsystemstack(func() {\n+\t\tfutexsleep1(addr, val, ns)\n+\t})\n+}\n+\n+func futexsleep1(addr *uint32, val uint32, ns int64) {\n+\tvar tsp *timespec\n+\tif ns >= 0 {\n+\t\tvar ts timespec\n+\t\tts.tv_nsec = 0\n+\t\tts.set_sec(int64(timediv(ns, 1000000000, (*int32)(unsafe.Pointer(&ts.tv_nsec)))))\n+\t\ttsp = &ts\n+\t}\n+\tret := sys_umtx_op(addr, _UMTX_OP_WAIT_UINT_PRIVATE, val, nil, tsp)\n+\tif ret >= 0 || ret == -_EINTR {\n+\t\treturn\n+\t}\n+\tprint(\"umtx_wait addr=\", addr, \" val=\", val, \" ret=\", ret, \"\\n\")\n+\t*(*int32)(unsafe.Pointer(uintptr(0x1005))) = 0x1005\n+}\n+\n+//go:nosplit\n+func futexwakeup(addr *uint32, cnt uint32) {\n+\tret := sys_umtx_op(addr, _UMTX_OP_WAKE_PRIVATE, cnt, nil, nil)\n+\tif ret >= 0 {\n+\t\treturn\n+\t}\n+\n+\tsystemstack(func() {\n+\t\tprint(\"umtx_wake_addr=\", addr, \" ret=\", ret, \"\\n\")\n+\t})\n+}"}, {"sha": "04c690bd42feba990d3014fa85a2ad9c71fb4d9c", "filename": "libgo/go/runtime/os_linux.go", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -9,6 +9,80 @@ import (\n \t\"unsafe\"\n )\n \n+type mOS struct {\n+\tunused byte\n+}\n+\n+func futex(addr unsafe.Pointer, op int32, val uint32, ts, addr2 unsafe.Pointer, val3 uint32) int32 {\n+\treturn int32(syscall(_SYS_futex, uintptr(addr), uintptr(op), uintptr(val), uintptr(ts), uintptr(addr2), uintptr(val3)))\n+}\n+\n+// Linux futex.\n+//\n+//\tfutexsleep(uint32 *addr, uint32 val)\n+//\tfutexwakeup(uint32 *addr)\n+//\n+// Futexsleep atomically checks if *addr == val and if so, sleeps on addr.\n+// Futexwakeup wakes up threads sleeping on addr.\n+// Futexsleep is allowed to wake up spuriously.\n+\n+const (\n+\t_FUTEX_WAIT = 0\n+\t_FUTEX_WAKE = 1\n+)\n+\n+// Atomically,\n+//\tif(*addr == val) sleep\n+// Might be woken up spuriously; that's allowed.\n+// Don't sleep longer than ns; ns < 0 means forever.\n+//go:nosplit\n+func futexsleep(addr *uint32, val uint32, ns int64) {\n+\tvar ts timespec\n+\n+\t// Some Linux kernels have a bug where futex of\n+\t// FUTEX_WAIT returns an internal error code\n+\t// as an errno. Libpthread ignores the return value\n+\t// here, and so can we: as it says a few lines up,\n+\t// spurious wakeups are allowed.\n+\tif ns < 0 {\n+\t\tfutex(unsafe.Pointer(addr), _FUTEX_WAIT, val, nil, nil, 0)\n+\t\treturn\n+\t}\n+\n+\t// It's difficult to live within the no-split stack limits here.\n+\t// On ARM and 386, a 64-bit divide invokes a general software routine\n+\t// that needs more stack than we can afford. So we use timediv instead.\n+\t// But on real 64-bit systems, where words are larger but the stack limit\n+\t// is not, even timediv is too heavy, and we really need to use just an\n+\t// ordinary machine instruction.\n+\tif sys.PtrSize == 8 {\n+\t\tts.set_sec(ns / 1000000000)\n+\t\tts.set_nsec(int32(ns % 1000000000))\n+\t} else {\n+\t\tts.tv_nsec = 0\n+\t\tts.set_sec(int64(timediv(ns, 1000000000, (*int32)(unsafe.Pointer(&ts.tv_nsec)))))\n+\t}\n+\tfutex(unsafe.Pointer(addr), _FUTEX_WAIT, val, unsafe.Pointer(&ts), nil, 0)\n+}\n+\n+// If any procs are sleeping on addr, wake up at most cnt.\n+//go:nosplit\n+func futexwakeup(addr *uint32, cnt uint32) {\n+\tret := futex(unsafe.Pointer(addr), _FUTEX_WAKE, cnt, nil, nil, 0)\n+\tif ret >= 0 {\n+\t\treturn\n+\t}\n+\n+\t// I don't know that futex wakeup can return\n+\t// EAGAIN or EINTR, but if it does, it would be\n+\t// safe to loop and call futex again.\n+\tsystemstack(func() {\n+\t\tprint(\"futexwakeup addr=\", addr, \" returned \", ret, \"\\n\")\n+\t})\n+\n+\t*(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006\n+}\n+\n const (\n \t_AT_NULL   = 0  // End of vector\n \t_AT_PAGESZ = 6  // System physical page size"}, {"sha": "464ce88d9c4d169a5faa9eb6913d111ffd5058d2", "filename": "libgo/go/runtime/os_netbsd.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_netbsd.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+type mOS struct {\n+\twaitsemacount uint32\n+}\n+\n+//go:noescape\n+//extern lwp_park\n+func lwp_park(abstime *timespec, unpark int32, hint, unparkhint unsafe.Pointer) int32\n+\n+//go:noescape\n+//extern lwp_unpark\n+func lwp_unpark(lwp int32, hint unsafe.Pointer) int32\n+\n+//go:nosplit\n+func semacreate(mp *m) {\n+}\n+\n+//go:nosplit\n+func semasleep(ns int64) int32 {\n+\t_g_ := getg()\n+\n+\t// Compute sleep deadline.\n+\tvar tsp *timespec\n+\tif ns >= 0 {\n+\t\tvar ts timespec\n+\t\tvar nsec int32\n+\t\tns += nanotime()\n+\t\tts.set_sec(int64(timediv(ns, 1000000000, &nsec)))\n+\t\tts.set_nsec(nsec)\n+\t\ttsp = &ts\n+\t}\n+\n+\tfor {\n+\t\tv := atomic.Load(&_g_.m.mos.waitsemacount)\n+\t\tif v > 0 {\n+\t\t\tif atomic.Cas(&_g_.m.mos.waitsemacount, v, v-1) {\n+\t\t\t\treturn 0 // semaphore acquired\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Sleep until unparked by semawakeup or timeout.\n+\t\tret := lwp_park(tsp, 0, unsafe.Pointer(&_g_.m.mos.waitsemacount), nil)\n+\t\tif ret == _ETIMEDOUT {\n+\t\t\treturn -1\n+\t\t}\n+\t}\n+}\n+\n+//go:nosplit\n+func semawakeup(mp *m) {\n+\tatomic.Xadd(&mp.mos.waitsemacount, 1)\n+\t// From NetBSD's _lwp_unpark(2) manual:\n+\t// \"If the target LWP is not currently waiting, it will return\n+\t// immediately upon the next call to _lwp_park().\"\n+\tret := lwp_unpark(int32(mp.procid), unsafe.Pointer(&mp.mos.waitsemacount))\n+\tif ret != 0 && ret != _ESRCH {\n+\t\t// semawakeup can be called on signal stack.\n+\t\tsystemstack(func() {\n+\t\t\tprint(\"thrwakeup addr=\", &mp.mos.waitsemacount, \" sem=\", mp.mos.waitsemacount, \" ret=\", ret, \"\\n\")\n+\t\t})\n+\t}\n+}"}, {"sha": "b64d3af385fde70930b64d171348cd2ff98aa35a", "filename": "libgo/go/runtime/os_openbsd.go", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_openbsd.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+type mOS struct {\n+\twaitsemacount uint32\n+}\n+\n+//go:noescape\n+//extern thrsleep\n+func thrsleep(ident uintptr, clock_id int32, tsp *timespec, lock uintptr, abort *uint32) int32\n+\n+//go:noescape\n+//extern thrwakeup\n+func thrwakeup(ident uintptr, n int32) int32\n+\n+//go:nosplit\n+func semacreate(mp *m) {\n+}\n+\n+//go:nosplit\n+func semasleep(ns int64) int32 {\n+\t_g_ := getg()\n+\n+\t// Compute sleep deadline.\n+\tvar tsp *timespec\n+\tif ns >= 0 {\n+\t\tvar ts timespec\n+\t\tvar nsec int32\n+\t\tns += nanotime()\n+\t\tts.set_sec(int64(timediv(ns, 1000000000, &nsec)))\n+\t\tts.set_nsec(nsec)\n+\t\ttsp = &ts\n+\t}\n+\n+\tfor {\n+\t\tv := atomic.Load(&_g_.m.mos.waitsemacount)\n+\t\tif v > 0 {\n+\t\t\tif atomic.Cas(&_g_.m.mos.waitsemacount, v, v-1) {\n+\t\t\t\treturn 0 // semaphore acquired\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Sleep until woken by semawakeup or timeout; or abort if waitsemacount != 0.\n+\t\t//\n+\t\t// From OpenBSD's __thrsleep(2) manual:\n+\t\t// \"The abort argument, if not NULL, points to an int that will\n+\t\t// be examined [...] immediately before blocking. If that int\n+\t\t// is non-zero then __thrsleep() will immediately return EINTR\n+\t\t// without blocking.\"\n+\t\tret := thrsleep(uintptr(unsafe.Pointer(&_g_.m.mos.waitsemacount)), _CLOCK_MONOTONIC, tsp, 0, &_g_.m.mos.waitsemacount)\n+\t\tif ret == _EWOULDBLOCK {\n+\t\t\treturn -1\n+\t\t}\n+\t}\n+}\n+\n+//go:nosplit\n+func semawakeup(mp *m) {\n+\tatomic.Xadd(&mp.mos.waitsemacount, 1)\n+\tret := thrwakeup(uintptr(unsafe.Pointer(&mp.mos.waitsemacount)), 1)\n+\tif ret != 0 && ret != _ESRCH {\n+\t\t// semawakeup can be called on signal stack.\n+\t\tsystemstack(func() {\n+\t\t\tprint(\"thrwakeup addr=\", &mp.mos.waitsemacount, \" sem=\", mp.mos.waitsemacount, \" ret=\", ret, \"\\n\")\n+\t\t})\n+\t}\n+}"}, {"sha": "cf457680f71db17a737f08ccae20ba44869c6938", "filename": "libgo/go/runtime/os_solaris.go", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fos_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_solaris.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+type mOS struct {\n+\twaitsema uintptr // semaphore for parking on locks\n+}\n+\n+//extern malloc\n+func libc_malloc(uintptr) unsafe.Pointer\n+\n+//go:noescape\n+//extern sem_init\n+func sem_init(sem *semt, pshared int32, value uint32) int32\n+\n+//go:noescape\n+//extern sem_wait\n+func sem_wait(sem *semt) int32\n+\n+//go:noescape\n+//extern sem_post\n+func sem_post(sem *semt) int32\n+\n+//go:noescape\n+//extern sem_reltimedwait_np\n+func sem_reltimedwait_np(sem *semt, timeout *timespec) int32\n+\n+//go:nosplit\n+func semacreate(mp *m) {\n+\tif mp.mos.waitsema != 0 {\n+\t\treturn\n+\t}\n+\n+\tvar sem *semt\n+\n+\t// Call libc's malloc rather than malloc. This will\n+\t// allocate space on the C heap. We can't call malloc\n+\t// here because it could cause a deadlock.\n+\tsem = (*semt)(libc_malloc(unsafe.Sizeof(*sem)))\n+\tif sem_init(sem, 0, 0) != 0 {\n+\t\tthrow(\"sem_init\")\n+\t}\n+\tmp.mos.waitsema = uintptr(unsafe.Pointer(sem))\n+}\n+\n+//go:nosplit\n+func semasleep(ns int64) int32 {\n+\t_m_ := getg().m\n+\tif ns >= 0 {\n+\t\tvar ts timespec\n+\t\tts.set_sec(ns / 1000000000)\n+\t\tts.set_nsec(int32(ns % 1000000000))\n+\n+\t\tif sem_reltimedwait_np((*semt)(unsafe.Pointer(_m_.mos.waitsema)), &ts) != 0 {\n+\t\t\terr := errno()\n+\t\t\tif err == _ETIMEDOUT || err == _EAGAIN || err == _EINTR {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\tthrow(\"sem_reltimedwait_np\")\n+\t\t}\n+\t\treturn 0\n+\t}\n+\tfor {\n+\t\tr1 := sem_wait((*semt)(unsafe.Pointer(_m_.mos.waitsema)))\n+\t\tif r1 == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif errno() == _EINTR {\n+\t\t\tcontinue\n+\t\t}\n+\t\tthrow(\"sem_wait\")\n+\t}\n+\treturn 0\n+}\n+\n+//go:nosplit\n+func semawakeup(mp *m) {\n+\tif sem_post((*semt)(unsafe.Pointer(mp.mos.waitsema))) != 0 {\n+\t\tthrow(\"sem_post\")\n+\t}\n+}"}, {"sha": "17447eb48bcaf518774fe40ada5ae95f4bbc4540", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -396,7 +396,7 @@ type g struct {\n \tgcnextsegment unsafe.Pointer\n \tgcnextsp      unsafe.Pointer\n \tgcinitialsp   unsafe.Pointer\n-\tgcregs        _ucontext_t\n+\tgcregs        g_ucontext_t\n \n \tentry    unsafe.Pointer // goroutine entry point\n \tfromgogo bool           // whether entered from gogo function\n@@ -406,7 +406,7 @@ type g struct {\n \n \ttraceback *traceback // stack traceback buffer\n \n-\tcontext      _ucontext_t        // saved context for setcontext\n+\tcontext      g_ucontext_t       // saved context for setcontext\n \tstackcontext [10]unsafe.Pointer // split-stack context\n }\n \n@@ -474,7 +474,7 @@ type m struct {\n \t// Not for gccgo: libcallg  guintptr\n \t// Not for gccgo: syscall   libcall // stores syscall parameters on windows\n \n-\t// Not for gccgo: mOS\n+\tmos mOS\n \n \t// Remaining fields are specific to gccgo.\n \n@@ -485,8 +485,6 @@ type m struct {\n \n \tgcing int32\n \n-\twaitsema uintptr // semaphore on systems that don't use futexes\n-\n \tcgomal *cgoMal // allocations via _cgo_allocate\n }\n \n@@ -771,13 +769,15 @@ const (\n const _TracebackMaxFrames = 100\n \n var (\n-//\temptystring string\n-//\tallglen     uintptr\n-//\tallm        *m\n-//\tallp        [_MaxGomaxprocs + 1]*p\n-//\tgomaxprocs  int32\n-//\tpanicking   uint32\n-//\tncpu        int32\n+\t//\temptystring string\n+\t//\tallglen     uintptr\n+\t//\tallm        *m\n+\t//\tallp        [_MaxGomaxprocs + 1]*p\n+\t//\tgomaxprocs  int32\n+\t//\tpanicking   uint32\n+\n+\tncpu int32\n+\n //\tforcegc     forcegcstate\n //\tsched       schedt\n //\tnewprocs    int32\n@@ -803,13 +803,13 @@ var (\n \n // Types that are only used by gccgo.\n \n-// _ucontext_t is a Go version of the C ucontext_t type, used by getcontext.\n-// _sizeof_ucontext_t is defined by the Makefile from <ucontext.h>.\n+// g_ucontext_t is a Go version of the C ucontext_t type, used by getcontext.\n+// _sizeof_ucontext_t is defined by mkrsysinfo.sh from <ucontext.h>.\n // On some systems getcontext and friends require a value that is\n // aligned to a 16-byte boundary.  We implement this by increasing the\n // required size and picking an appropriate offset when we use the\n // array.\n-type _ucontext_t [(_sizeof_ucontext_t + 15) / unsafe.Sizeof(unsafe.Pointer(nil))]unsafe.Pointer\n+type g_ucontext_t [(_sizeof_ucontext_t + 15) / unsafe.Sizeof(unsafe.Pointer(nil))]unsafe.Pointer\n \n // traceback is used to collect stack traces from other goroutines.\n type traceback struct {"}, {"sha": "bbeac41a4dcc181c14b0a154c9d7a29f90822108", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -38,12 +38,7 @@ func getg() *g\n func mcall(fn func(*g))\n \n // systemstack runs fn on a system stack.\n-// If systemstack is called from the per-OS-thread (g0) stack, or\n-// if systemstack is called from the signal handling (gsignal) stack,\n-// systemstack calls fn directly and returns.\n-// Otherwise, systemstack is being called from the limited stack\n-// of an ordinary goroutine. In this case, systemstack switches\n-// to the per-OS-thread stack, calls fn, and switches back.\n+//\n // It is common to use a func literal as the argument, in order\n // to share inputs and outputs with the code around the call\n // to system stack:\n@@ -54,8 +49,14 @@ func mcall(fn func(*g))\n //\t})\n //\t... use x ...\n //\n-//go:noescape\n-func systemstack(fn func())\n+// For the gc toolchain this permits running a function that requires\n+// additional stack space in a context where the stack can not be\n+// split.  For gccgo, however, stack splitting is not managed by the\n+// Go runtime. In effect, all stacks are system stacks. So this gccgo\n+// version just runs the function.\n+func systemstack(fn func()) {\n+\tfn()\n+}\n \n func badsystemstack() {\n \tthrow(\"systemstack called from unexpected goroutine\")\n@@ -215,6 +216,13 @@ func checkASM() bool {\n \treturn true\n }\n \n+// For gccgo this is in the C code.\n+func osyield()\n+\n+// For gccgo this can be called directly.\n+//extern syscall\n+func syscall(trap uintptr, a1, a2, a3, a4, a5, a6 uintptr) uintptr\n+\n // throw crashes the program.\n // For gccgo unless and until we port panic.go.\n func throw(string)\n@@ -368,3 +376,11 @@ func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n // Here for gccgo until we port lock_*.go.\n func lock(l *mutex)\n func unlock(l *mutex)\n+\n+// Here for gccgo for Solaris.\n+func errno() int\n+\n+// Temporary for gccgo until we port proc.go.\n+func entersyscall(int32)\n+func entersyscallblock(int32)\n+func exitsyscall(int32)"}, {"sha": "b5c2c709c20765a7f6e072155c9a8addd6b1816e", "filename": "libgo/mkrsysinfo.sh", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fmkrsysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fmkrsysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmkrsysinfo.sh?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -0,0 +1,103 @@\n+#!/bin/sh\n+\n+# Copyright 2016 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# Create runtime_sysinfo.go from gen-sysinfo.go and errno.i.\n+\n+OUT=tmp-runtime_sysinfo.go\n+\n+set -e\n+\n+echo 'package runtime' > ${OUT}\n+\n+# Get all the consts and types, skipping ones which could not be\n+# represented in Go and ones which we need to rewrite.  We also skip\n+# function declarations, as we don't need them here.  All the symbols\n+# will all have a leading underscore.\n+grep -v '^// ' gen-sysinfo.go | \\\n+  grep -v '^func' | \\\n+  grep -v '^type _timeval ' | \\\n+  grep -v '^type _timespec_t ' | \\\n+  grep -v '^type _timespec ' | \\\n+  grep -v '^type _epoll_' | \\\n+  grep -v 'in6_addr' | \\\n+  grep -v 'sockaddr_in6' | \\\n+  sed -e 's/\\([^a-zA-Z0-9_]\\)_timeval\\([^a-zA-Z0-9_]\\)/\\1timeval\\2/g' \\\n+      -e 's/\\([^a-zA-Z0-9_]\\)_timespec_t\\([^a-zA-Z0-9_]\\)/\\1timespec\\2/g' \\\n+      -e 's/\\([^a-zA-Z0-9_]\\)_timespec\\([^a-zA-Z0-9_]\\)/\\1timespec\\2/g' \\\n+    >> ${OUT}\n+\n+# The time structures need special handling: we need to name the\n+# types, so that we can cast integers to the right types when\n+# assigning to the structures.\n+timeval=`grep '^type _timeval ' gen-sysinfo.go`\n+timeval_sec=`echo $timeval | sed -n -e 's/^.*tv_sec \\([^ ]*\\);.*$/\\1/p'`\n+timeval_usec=`echo $timeval | sed -n -e 's/^.*tv_usec \\([^ ]*\\);.*$/\\1/p'`\n+echo \"type timeval_sec_t $timeval_sec\" >> ${OUT}\n+echo \"type timeval_usec_t $timeval_usec\" >> ${OUT}\n+echo $timeval | \\\n+  sed -e 's/type _timeval /type timeval /' \\\n+      -e 's/tv_sec *[a-zA-Z0-9_]*/tv_sec timeval_sec_t/' \\\n+      -e 's/tv_usec *[a-zA-Z0-9_]*/tv_usec timeval_usec_t/' >> ${OUT}\n+timespec=`grep '^type _timespec ' gen-sysinfo.go || true`\n+if test \"$timespec\" = \"\"; then\n+  # IRIX 6.5 has __timespec instead.\n+  timespec=`grep '^type ___timespec ' gen-sysinfo.go || true`\n+fi\n+timespec_sec=`echo $timespec | sed -n -e 's/^.*tv_sec \\([^ ]*\\);.*$/\\1/p'`\n+timespec_nsec=`echo $timespec | sed -n -e 's/^.*tv_nsec \\([^ ]*\\);.*$/\\1/p'`\n+echo \"type timespec_sec_t $timespec_sec\" >> ${OUT}\n+echo \"type timespec_nsec_t $timespec_nsec\" >> ${OUT}\n+echo $timespec | \\\n+  sed -e 's/^type ___timespec /type timespec /' \\\n+      -e 's/^type _timespec /type timespec /' \\\n+      -e 's/tv_sec *[a-zA-Z0-9_]*/tv_sec timespec_sec_t/' \\\n+      -e 's/tv_nsec *[a-zA-Z0-9_]*/tv_nsec timespec_nsec_t/' >> ${OUT}\n+echo >> ${OUT}\n+echo \"func (ts *timespec) set_sec(x int64) {\" >> ${OUT}\n+echo \"\tts.tv_sec = timespec_sec_t(x)\" >> ${OUT}\n+echo \"}\" >> ${OUT}\n+echo >> ${OUT}\n+echo \"func (ts *timespec) set_nsec(x int32) {\" >> ${OUT}\n+echo \"\tts.tv_nsec = timespec_nsec_t(x)\" >> ${OUT}\n+echo \"}\" >> ${OUT}\n+\n+# The semt structure, for Solaris.\n+grep '^type _sem_t ' gen-sysinfo.go | \\\n+    sed -e 's/_sem_t/semt/' >> ${OUT}\n+\n+# Solaris 2 needs _u?pad128_t, but its default definition in terms of long\n+# double is commented by -fdump-go-spec.\n+if grep \"^// type _pad128_t\" gen-sysinfo.go > /dev/null 2>&1; then\n+  echo \"type _pad128_t struct { _l [4]int32; }\" >> ${OUT}\n+fi\n+if grep \"^// type _upad128_t\" gen-sysinfo.go > /dev/null 2>&1; then\n+  echo \"type _upad128_t struct { _l [4]uint32; }\" >> ${OUT}\n+fi\n+\n+# The Solaris 11 Update 1 _zone_net_addr_t struct.\n+grep '^type _zone_net_addr_t ' gen-sysinfo.go | \\\n+    sed -e 's/_in6_addr/[16]byte/' \\\n+    >> ${OUT}\n+\n+# The Solaris 12 _flow_arp_desc_t struct.\n+grep '^type _flow_arp_desc_t ' gen-sysinfo.go | \\\n+    sed -e 's/_in6_addr_t/[16]byte/g' \\\n+    >> ${OUT}\n+\n+# The Solaris 12 _flow_l3_desc_t struct.\n+grep '^type _flow_l3_desc_t ' gen-sysinfo.go | \\\n+    sed -e 's/_in6_addr_t/[16]byte/g' \\\n+    >> ${OUT}\n+\n+# The Solaris 12 _mac_ipaddr_t struct.\n+grep '^type _mac_ipaddr_t ' gen-sysinfo.go | \\\n+    sed -e 's/_in6_addr_t/[16]byte/g' \\\n+    >> ${OUT}\n+\n+# The Solaris 12 _mactun_info_t struct.\n+grep '^type _mactun_info_t ' gen-sysinfo.go | \\\n+    sed -e 's/_in6_addr_t/[16]byte/g' \\\n+    >> ${OUT}"}, {"sha": "7d0494c3a6580a8ba606b6f36b6d2ddb5405f26e", "filename": "libgo/runtime/go-cgo.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fgo-cgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fgo-cgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cgo.c?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -45,7 +45,7 @@ syscall_cgocall ()\n   m = runtime_m ();\n   ++m->ncgocall;\n   ++m->ncgo;\n-  runtime_entersyscall ();\n+  runtime_entersyscall (0);\n }\n \n /* Prepare to return to Go code from C/C++ code.  */\n@@ -69,7 +69,7 @@ syscall_cgocalldone ()\n   /* If we are invoked because the C function called _cgo_panic, then\n      _cgo_panic will already have exited syscall mode.  */\n   if (g->atomicstatus == _Gsyscall)\n-    runtime_exitsyscall ();\n+    runtime_exitsyscall (0);\n \n   runtime_unlockOSThread();\n }\n@@ -89,7 +89,7 @@ syscall_cgocallback ()\n       mp->dropextram = true;\n     }\n \n-  runtime_exitsyscall ();\n+  runtime_exitsyscall (0);\n \n   if (runtime_m ()->ncgo == 0)\n     {\n@@ -115,7 +115,7 @@ syscall_cgocallbackdone ()\n {\n   M *mp;\n \n-  runtime_entersyscall ();\n+  runtime_entersyscall (0);\n   mp = runtime_m ();\n   if (mp->dropextram && mp->ncgo == 0)\n     {\n@@ -154,9 +154,9 @@ _cgo_allocate (size_t n)\n {\n   void *ret;\n \n-  runtime_exitsyscall ();\n+  runtime_exitsyscall (0);\n   ret = alloc_saved (n);\n-  runtime_entersyscall ();\n+  runtime_entersyscall (0);\n   return ret;\n }\n \n@@ -171,7 +171,7 @@ _cgo_panic (const char *p)\n   String *ps;\n   struct __go_empty_interface e;\n \n-  runtime_exitsyscall ();\n+  runtime_exitsyscall (0);\n   len = __builtin_strlen (p);\n   data = alloc_saved (len);\n   __builtin_memcpy (data, p, len);"}, {"sha": "33ef073c907e1029a1c92d3c971f0e575b69daba", "filename": "libgo/runtime/lock_futex.c", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e28a77462f81a9a2ab9064d768bd7c9484047e1/libgo%2Fruntime%2Flock_futex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e28a77462f81a9a2ab9064d768bd7c9484047e1/libgo%2Fruntime%2Flock_futex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_futex.c?ref=9e28a77462f81a9a2ab9064d768bd7c9484047e1", "patch": "@@ -1,204 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build dragonfly freebsd linux\n-\n-#include \"runtime.h\"\n-\n-// This implementation depends on OS-specific implementations of\n-//\n-//\truntime_futexsleep(uint32 *addr, uint32 val, int64 ns)\n-//\t\tAtomically,\n-//\t\t\tif(*addr == val) sleep\n-//\t\tMight be woken up spuriously; that's allowed.\n-//\t\tDon't sleep longer than ns; ns < 0 means forever.\n-//\n-//\truntime_futexwakeup(uint32 *addr, uint32 cnt)\n-//\t\tIf any procs are sleeping on addr, wake up at most cnt.\n-\n-enum\n-{\n-\tMUTEX_UNLOCKED = 0,\n-\tMUTEX_LOCKED = 1,\n-\tMUTEX_SLEEPING = 2,\n-\n-\tACTIVE_SPIN = 4,\n-\tACTIVE_SPIN_CNT = 30,\n-\tPASSIVE_SPIN = 1,\n-};\n-\n-// Possible lock states are MUTEX_UNLOCKED, MUTEX_LOCKED and MUTEX_SLEEPING.\n-// MUTEX_SLEEPING means that there is presumably at least one sleeping thread.\n-// Note that there can be spinning threads during all states - they do not\n-// affect mutex's state.\n-void\n-runtime_lock(Lock *l)\n-{\n-\tuint32 i, v, wait, spin;\n-\n-\tif(runtime_m()->locks++ < 0)\n-\t\truntime_throw(\"runtime_lock: lock count\");\n-\n-\t// Speculative grab for lock.\n-\tv = runtime_xchg((uint32*)&l->key, MUTEX_LOCKED);\n-\tif(v == MUTEX_UNLOCKED)\n-\t\treturn;\n-\n-\t// wait is either MUTEX_LOCKED or MUTEX_SLEEPING\n-\t// depending on whether there is a thread sleeping\n-\t// on this mutex.  If we ever change l->key from\n-\t// MUTEX_SLEEPING to some other value, we must be\n-\t// careful to change it back to MUTEX_SLEEPING before\n-\t// returning, to ensure that the sleeping thread gets\n-\t// its wakeup call.\n-\twait = v;\n-\n-\t// On uniprocessor's, no point spinning.\n-\t// On multiprocessors, spin for ACTIVE_SPIN attempts.\n-\tspin = 0;\n-\tif(runtime_ncpu > 1)\n-\t\tspin = ACTIVE_SPIN;\n-\n-\tfor(;;) {\n-\t\t// Try for lock, spinning.\n-\t\tfor(i = 0; i < spin; i++) {\n-\t\t\twhile(l->key == MUTEX_UNLOCKED)\n-\t\t\t\tif(runtime_cas((uint32*)&l->key, MUTEX_UNLOCKED, wait))\n-\t\t\t\t\treturn;\n-\t\t\truntime_procyield(ACTIVE_SPIN_CNT);\n-\t\t}\n-\n-\t\t// Try for lock, rescheduling.\n-\t\tfor(i=0; i < PASSIVE_SPIN; i++) {\n-\t\t\twhile(l->key == MUTEX_UNLOCKED)\n-\t\t\t\tif(runtime_cas((uint32*)&l->key, MUTEX_UNLOCKED, wait))\n-\t\t\t\t\treturn;\n-\t\t\truntime_osyield();\n-\t\t}\n-\n-\t\t// Sleep.\n-\t\tv = runtime_xchg((uint32*)&l->key, MUTEX_SLEEPING);\n-\t\tif(v == MUTEX_UNLOCKED)\n-\t\t\treturn;\n-\t\twait = MUTEX_SLEEPING;\n-\t\truntime_futexsleep((uint32*)&l->key, MUTEX_SLEEPING, -1);\n-\t}\n-}\n-\n-void\n-runtime_unlock(Lock *l)\n-{\n-\tuint32 v;\n-\n-\tv = runtime_xchg((uint32*)&l->key, MUTEX_UNLOCKED);\n-\tif(v == MUTEX_UNLOCKED)\n-\t\truntime_throw(\"unlock of unlocked lock\");\n-\tif(v == MUTEX_SLEEPING)\n-\t\truntime_futexwakeup((uint32*)&l->key, 1);\n-\n-\tif(--runtime_m()->locks < 0)\n-\t\truntime_throw(\"runtime_unlock: lock count\");\n-}\n-\n-// One-time notifications.\n-void\n-runtime_noteclear(Note *n)\n-{\n-\tn->key = 0;\n-}\n-\n-void\n-runtime_notewakeup(Note *n)\n-{\n-\tuint32 old;\n-\n-\told = runtime_xchg((uint32*)&n->key, 1);\n-\tif(old != 0) {\n-\t\truntime_printf(\"notewakeup - double wakeup (%d)\\n\", old);\n-\t\truntime_throw(\"notewakeup - double wakeup\");\n-\t}\n-\truntime_futexwakeup((uint32*)&n->key, 1);\n-}\n-\n-void\n-runtime_notesleep(Note *n)\n-{\n-\tM *m = runtime_m();\n-\n-  /* For gccgo it's OK to sleep in non-g0, and it happens in\n-     stoptheworld because we have not implemented preemption.\n-\n-\tif(runtime_g() != runtime_m()->g0)\n-\t\truntime_throw(\"notesleep not on g0\");\n-  */\n-\twhile(runtime_atomicload((uint32*)&n->key) == 0) {\n-\t\tm->blocked = true;\n-\t\truntime_futexsleep((uint32*)&n->key, 0, -1);\n-\t\tm->blocked = false;\n-\t}\n-}\n-\n-static bool\n-notetsleep(Note *n, int64 ns, int64 deadline, int64 now)\n-{\n-\tM *m = runtime_m();\n-\n-\t// Conceptually, deadline and now are local variables.\n-\t// They are passed as arguments so that the space for them\n-\t// does not count against our nosplit stack sequence.\n-\n-\tif(ns < 0) {\n-\t\twhile(runtime_atomicload((uint32*)&n->key) == 0) {\n-\t\t\tm->blocked = true;\n-\t\t\truntime_futexsleep((uint32*)&n->key, 0, -1);\n-\t\t\tm->blocked = false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tif(runtime_atomicload((uint32*)&n->key) != 0)\n-\t\treturn true;\n-\n-\tdeadline = runtime_nanotime() + ns;\n-\tfor(;;) {\n-\t\tm->blocked = true;\n-\t\truntime_futexsleep((uint32*)&n->key, 0, ns);\n-\t\tm->blocked = false;\n-\t\tif(runtime_atomicload((uint32*)&n->key) != 0)\n-\t\t\tbreak;\n-\t\tnow = runtime_nanotime();\n-\t\tif(now >= deadline)\n-\t\t\tbreak;\n-\t\tns = deadline - now;\n-\t}\n-\treturn runtime_atomicload((uint32*)&n->key) != 0;\n-}\n-\n-bool\n-runtime_notetsleep(Note *n, int64 ns)\n-{\n-\tbool res;\n-\n-\tif(runtime_g() != runtime_m()->g0 && !runtime_m()->gcing)\n-\t\truntime_throw(\"notetsleep not on g0\");\n-\n-\tres = notetsleep(n, ns, 0, 0);\n-\treturn res;\n-}\n-\n-// same as runtime_notetsleep, but called on user g (not g0)\n-// calls only nosplit functions between entersyscallblock/exitsyscall\n-bool\n-runtime_notetsleepg(Note *n, int64 ns)\n-{\n-\tbool res;\n-\n-\tif(runtime_g() == runtime_m()->g0)\n-\t\truntime_throw(\"notetsleepg on g0\");\n-\n-\truntime_entersyscallblock();\n-\tres = notetsleep(n, ns, 0, 0);\n-\truntime_exitsyscall();\n-\treturn res;\n-}"}, {"sha": "06ac6e7f90d265392093d43f89b745f41c8754c0", "filename": "libgo/runtime/lock_sema.c", "status": "removed", "additions": 0, "deletions": 281, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e28a77462f81a9a2ab9064d768bd7c9484047e1/libgo%2Fruntime%2Flock_sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e28a77462f81a9a2ab9064d768bd7c9484047e1/libgo%2Fruntime%2Flock_sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_sema.c?ref=9e28a77462f81a9a2ab9064d768bd7c9484047e1", "patch": "@@ -1,281 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin nacl netbsd openbsd plan9 solaris windows\n-\n-#include \"runtime.h\"\n-\n-// This implementation depends on OS-specific implementations of\n-//\n-//\tuintptr runtime_semacreate(void)\n-//\t\tCreate a semaphore, which will be assigned to m->waitsema.\n-//\t\tThe zero value is treated as absence of any semaphore,\n-//\t\tso be sure to return a non-zero value.\n-//\n-//\tint32 runtime_semasleep(int64 ns)\n-//\t\tIf ns < 0, acquire m->waitsema and return 0.\n-//\t\tIf ns >= 0, try to acquire m->waitsema for at most ns nanoseconds.\n-//\t\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n-//\n-//\tint32 runtime_semawakeup(M *mp)\n-//\t\tWake up mp, which is or will soon be sleeping on mp->waitsema.\n-//\n-\n-enum\n-{\n-\tLOCKED = 1,\n-\n-\tACTIVE_SPIN = 4,\n-\tACTIVE_SPIN_CNT = 30,\n-\tPASSIVE_SPIN = 1,\n-};\n-\n-void\n-runtime_lock(Lock *l)\n-{\n-\tM *m;\n-\tuintptr v;\n-\tuint32 i, spin;\n-\n-\tm = runtime_m();\n-\tif(m->locks++ < 0)\n-\t\truntime_throw(\"runtime_lock: lock count\");\n-\n-\t// Speculative grab for lock.\n-\tif(runtime_casp((void**)&l->key, nil, (void*)LOCKED))\n-\t\treturn;\n-\n-\tif(m->waitsema == 0)\n-\t\tm->waitsema = runtime_semacreate();\n-\n-\t// On uniprocessor's, no point spinning.\n-\t// On multiprocessors, spin for ACTIVE_SPIN attempts.\n-\tspin = 0;\n-\tif(runtime_ncpu > 1)\n-\t\tspin = ACTIVE_SPIN;\n-\n-\tfor(i=0;; i++) {\n-\t\tv = (uintptr)runtime_atomicloadp((void**)&l->key);\n-\t\tif((v&LOCKED) == 0) {\n-unlocked:\n-\t\t\tif(runtime_casp((void**)&l->key, (void*)v, (void*)(v|LOCKED)))\n-\t\t\t\treturn;\n-\t\t\ti = 0;\n-\t\t}\n-\t\tif(i<spin)\n-\t\t\truntime_procyield(ACTIVE_SPIN_CNT);\n-\t\telse if(i<spin+PASSIVE_SPIN)\n-\t\t\truntime_osyield();\n-\t\telse {\n-\t\t\t// Someone else has it.\n-\t\t\t// l->waitm points to a linked list of M's waiting\n-\t\t\t// for this lock, chained through m->nextwaitm.\n-\t\t\t// Queue this M.\n-\t\t\tfor(;;) {\n-\t\t\t\tm->nextwaitm = v&~LOCKED;\n-\t\t\t\tif(runtime_casp((void**)&l->key, (void*)v, (void*)((uintptr)m|LOCKED)))\n-\t\t\t\t\tbreak;\n-\t\t\t\tv = (uintptr)runtime_atomicloadp((void**)&l->key);\n-\t\t\t\tif((v&LOCKED) == 0)\n-\t\t\t\t\tgoto unlocked;\n-\t\t\t}\n-\t\t\tif(v&LOCKED) {\n-\t\t\t\t// Queued.  Wait.\n-\t\t\t\truntime_semasleep(-1);\n-\t\t\t\ti = 0;\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-void\n-runtime_unlock(Lock *l)\n-{\n-\tuintptr v;\n-\tM *mp;\n-\n-\tfor(;;) {\n-\t\tv = (uintptr)runtime_atomicloadp((void**)&l->key);\n-\t\tif(v == LOCKED) {\n-\t\t\tif(runtime_casp((void**)&l->key, (void*)LOCKED, nil))\n-\t\t\t\tbreak;\n-\t\t} else {\n-\t\t\t// Other M's are waiting for the lock.\n-\t\t\t// Dequeue an M.\n-\t\t\tmp = (void*)(v&~LOCKED);\n-\t\t\tif(runtime_cas(&l->key, v, mp->nextwaitm)) {\n-\t\t\t\t// Dequeued an M.  Wake it.\n-\t\t\t\truntime_semawakeup(mp);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif(--runtime_m()->locks < 0)\n-\t\truntime_throw(\"runtime_unlock: lock count\");\n-}\n-\n-// One-time notifications.\n-void\n-runtime_noteclear(Note *n)\n-{\n-\tn->key = 0;\n-}\n-\n-void\n-runtime_notewakeup(Note *n)\n-{\n-\tM *mp;\n-\n-\tdo\n-\t\tmp = runtime_atomicloadp((void**)&n->key);\n-\twhile(!runtime_casp((void**)&n->key, mp, (void*)LOCKED));\n-\n-\t// Successfully set waitm to LOCKED.\n-\t// What was it before?\n-\tif(mp == nil) {\n-\t\t// Nothing was waiting.  Done.\n-\t} else if(mp == (M*)LOCKED) {\n-\t\t// Two notewakeups!  Not allowed.\n-\t\truntime_throw(\"notewakeup - double wakeup\");\n-\t} else {\n-\t\t// Must be the waiting m.  Wake it up.\n-\t\truntime_semawakeup(mp);\n-\t}\n-}\n-\n-void\n-runtime_notesleep(Note *n)\n-{\n-\tM *m;\n-\n-\tm = runtime_m();\n-\n-  /* For gccgo it's OK to sleep in non-g0, and it happens in\n-     stoptheworld because we have not implemented preemption.\n-\n-\tif(runtime_g() != m->g0)\n-\t\truntime_throw(\"notesleep not on g0\");\n-  */\n-\n-\tif(m->waitsema == 0)\n-\t\tm->waitsema = runtime_semacreate();\n-\tif(!runtime_casp((void**)&n->key, nil, m)) {  // must be LOCKED (got wakeup)\n-\t\tif(n->key != LOCKED)\n-\t\t\truntime_throw(\"notesleep - waitm out of sync\");\n-\t\treturn;\n-\t}\n-\t// Queued.  Sleep.\n-\tm->blocked = true;\n-\truntime_semasleep(-1);\n-\tm->blocked = false;\n-}\n-\n-static bool\n-notetsleep(Note *n, int64 ns, int64 deadline, M *mp)\n-{\n-\tM *m;\n-\n-\tm = runtime_m();\n-\n-\t// Conceptually, deadline and mp are local variables.\n-\t// They are passed as arguments so that the space for them\n-\t// does not count against our nosplit stack sequence.\n-\n-\t// Register for wakeup on n->waitm.\n-\tif(!runtime_casp((void**)&n->key, nil, m)) {  // must be LOCKED (got wakeup already)\n-\t\tif(n->key != LOCKED)\n-\t\t\truntime_throw(\"notetsleep - waitm out of sync\");\n-\t\treturn true;\n-\t}\n-\n-\tif(ns < 0) {\n-\t\t// Queued.  Sleep.\n-\t\tm->blocked = true;\n-\t\truntime_semasleep(-1);\n-\t\tm->blocked = false;\n-\t\treturn true;\n-\t}\n-\n-\tdeadline = runtime_nanotime() + ns;\n-\tfor(;;) {\n-\t\t// Registered.  Sleep.\n-\t\tm->blocked = true;\n-\t\tif(runtime_semasleep(ns) >= 0) {\n-\t\t\tm->blocked = false;\n-\t\t\t// Acquired semaphore, semawakeup unregistered us.\n-\t\t\t// Done.\n-\t\t\treturn true;\n-\t\t}\n-\t\tm->blocked = false;\n-\n-\t\t// Interrupted or timed out.  Still registered.  Semaphore not acquired.\n-\t\tns = deadline - runtime_nanotime();\n-\t\tif(ns <= 0)\n-\t\t\tbreak;\n-\t\t// Deadline hasn't arrived.  Keep sleeping.\n-\t}\n-\n-\t// Deadline arrived.  Still registered.  Semaphore not acquired.\n-\t// Want to give up and return, but have to unregister first,\n-\t// so that any notewakeup racing with the return does not\n-\t// try to grant us the semaphore when we don't expect it.\n-\tfor(;;) {\n-\t\tmp = runtime_atomicloadp((void**)&n->key);\n-\t\tif(mp == m) {\n-\t\t\t// No wakeup yet; unregister if possible.\n-\t\t\tif(runtime_casp((void**)&n->key, mp, nil))\n-\t\t\t\treturn false;\n-\t\t} else if(mp == (M*)LOCKED) {\n-\t\t\t// Wakeup happened so semaphore is available.\n-\t\t\t// Grab it to avoid getting out of sync.\n-\t\t\tm->blocked = true;\n-\t\t\tif(runtime_semasleep(-1) < 0)\n-\t\t\t\truntime_throw(\"runtime: unable to acquire - semaphore out of sync\");\n-\t\t\tm->blocked = false;\n-\t\t\treturn true;\n-\t\t} else\n-\t\t\truntime_throw(\"runtime: unexpected waitm - semaphore out of sync\");\n-\t}\n-}\n-\n-bool\n-runtime_notetsleep(Note *n, int64 ns)\n-{\n-\tM *m;\n-\tbool res;\n-\n-\tm = runtime_m();\n-\n-\tif(runtime_g() != m->g0 && !m->gcing)\n-\t\truntime_throw(\"notetsleep not on g0\");\n-\n-\tif(m->waitsema == 0)\n-\t\tm->waitsema = runtime_semacreate();\n-\n-\tres = notetsleep(n, ns, 0, nil);\n-\treturn res;\n-}\n-\n-// same as runtime_notetsleep, but called on user g (not g0)\n-// calls only nosplit functions between entersyscallblock/exitsyscall\n-bool\n-runtime_notetsleepg(Note *n, int64 ns)\n-{\n-\tM *m;\n-\tbool res;\n-\n-\tm = runtime_m();\n-\n-\tif(runtime_g() == m->g0)\n-\t\truntime_throw(\"notetsleepg on g0\");\n-\n-\tif(m->waitsema == 0)\n-\t\tm->waitsema = runtime_semacreate();\n-\n-\truntime_entersyscallblock();\n-\tres = notetsleep(n, ns, 0, nil);\n-\truntime_exitsyscall();\n-\treturn res;\n-}"}, {"sha": "a924b8adfa2742b729a56f7ad758fb1dabf2d01c", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -99,7 +99,7 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \t\t// returns a non-pointer, so memory allocation occurs\n \t\t// after syscall.Cgocall but before syscall.CgocallDone.\n \t\t// We treat it as a callback.\n-\t\truntime_exitsyscall();\n+\t\truntime_exitsyscall(0);\n \t\tm = runtime_m();\n \t\tincallback = true;\n \t\tflag |= FlagNoInvokeGC;\n@@ -171,7 +171,7 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \t\t\t\t\tm->mallocing = 0;\n \t\t\t\t\tm->locks--;\n \t\t\t\t\tif(incallback)\n-\t\t\t\t\t\truntime_entersyscall();\n+\t\t\t\t\t\truntime_entersyscall(0);\n \t\t\t\t\treturn v;\n \t\t\t\t}\n \t\t\t}\n@@ -256,7 +256,7 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \t\truntime_gc(0);\n \n \tif(incallback)\n-\t\truntime_entersyscall();\n+\t\truntime_entersyscall(0);\n \n \treturn v;\n }"}, {"sha": "dac32eb678e738e8aae84ca2cb8fb816236adc10", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -2021,11 +2021,11 @@ goexit0(G *gp)\n // make g->sched refer to the caller's stack segment, because\n // entersyscall is going to return immediately after.\n \n-void runtime_entersyscall(void) __attribute__ ((no_split_stack));\n+void runtime_entersyscall(int32) __attribute__ ((no_split_stack));\n static void doentersyscall(void) __attribute__ ((no_split_stack, noinline));\n \n void\n-runtime_entersyscall()\n+runtime_entersyscall(int32 dummy __attribute__ ((unused)))\n {\n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n@@ -2095,7 +2095,7 @@ doentersyscall()\n \n // The same as runtime_entersyscall(), but with a hint that the syscall is blocking.\n void\n-runtime_entersyscallblock(void)\n+runtime_entersyscallblock(int32 dummy __attribute__ ((unused)))\n {\n \tP *p;\n \n@@ -2133,7 +2133,7 @@ runtime_entersyscallblock(void)\n // This is called only from the go syscall library, not\n // from the low-level system calls used by the runtime.\n void\n-runtime_exitsyscall(void)\n+runtime_exitsyscall(int32 dummy __attribute__ ((unused)))\n {\n \tG *gp;\n \n@@ -2254,6 +2254,28 @@ exitsyscall0(G *gp)\n \tschedule();  // Never returns.\n }\n \n+void syscall_entersyscall(void)\n+  __asm__(GOSYM_PREFIX \"syscall.Entersyscall\");\n+\n+void syscall_entersyscall(void) __attribute__ ((no_split_stack));\n+\n+void\n+syscall_entersyscall()\n+{\n+  runtime_entersyscall(0);\n+}\n+\n+void syscall_exitsyscall(void)\n+  __asm__(GOSYM_PREFIX \"syscall.Exitsyscall\");\n+\n+void syscall_exitsyscall(void) __attribute__ ((no_split_stack));\n+\n+void\n+syscall_exitsyscall()\n+{\n+  runtime_exitsyscall(0);\n+}\n+\n // Called from syscall package before fork.\n void syscall_runtime_BeforeFork(void)\n   __asm__(GOSYM_PREFIX \"syscall.runtime_BeforeFork\");\n@@ -2323,33 +2345,6 @@ runtime_malg(int32 stacksize, byte** ret_stack, uintptr* ret_stacksize)\n \treturn newg;\n }\n \n-/* For runtime package testing.  */\n-\n-\n-// Create a new g running fn with siz bytes of arguments.\n-// Put it on the queue of g's waiting to run.\n-// The compiler turns a go statement into a call to this.\n-// Cannot split the stack because it assumes that the arguments\n-// are available sequentially after &fn; they would not be\n-// copied if a stack split occurred.  It's OK for this to call\n-// functions that split the stack.\n-void runtime_testing_entersyscall(int32)\n-  __asm__ (GOSYM_PREFIX \"runtime.entersyscall\");\n-void\n-runtime_testing_entersyscall(int32 dummy __attribute__ ((unused)))\n-{\n-\truntime_entersyscall();\n-}\n-\n-void runtime_testing_exitsyscall(int32)\n-  __asm__ (GOSYM_PREFIX \"runtime.exitsyscall\");\n-\n-void\n-runtime_testing_exitsyscall(int32 dummy __attribute__ ((unused)))\n-{\n-\truntime_exitsyscall();\n-}\n-\n G*\n __go_go(void (*fn)(void*), void* arg)\n {"}, {"sha": "8e6f1f5052468bd5eb54a74249d49f9d8128157e", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+#include <errno.h>\n #include <signal.h>\n #include <unistd.h>\n \n@@ -210,3 +211,12 @@ go_closefd(int32 fd)\n {\n   return runtime_close(fd);\n }\n+\n+intgo go_errno(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.errno\");\n+\n+intgo\n+go_errno()\n+{\n+  return (intgo)errno;\n+}"}, {"sha": "d1aad1e2d73010e3e1d5937c3631c8b60b727687", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -108,8 +108,16 @@ struct FuncVal\n #include \"array.h\"\n #include \"interface.h\"\n \n+// Rename Go types generated by mkrsysinfo.sh from C types, to avoid\n+// the name conflict.\n+#define timeval go_timeval\n+#define timespec go_timespec\n+\n #include \"runtime.inc\"\n \n+#undef timeval\n+#undef timespec\n+\n /*\n  * Per-CPU declaration.\n  */\n@@ -392,9 +400,12 @@ void\truntime_parkunlock(Lock*, const char*);\n void\truntime_tsleep(int64, const char*);\n M*\truntime_newm(void);\n void\truntime_goexit(void);\n-void\truntime_entersyscall(void) __asm__ (GOSYM_PREFIX \"syscall.Entersyscall\");\n-void\truntime_entersyscallblock(void);\n-void\truntime_exitsyscall(void) __asm__ (GOSYM_PREFIX \"syscall.Exitsyscall\");\n+void\truntime_entersyscall(int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.entersyscall\");\n+void\truntime_entersyscallblock(int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.entersyscallblock\");\n+void\truntime_exitsyscall(int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.exitsyscall\");\n G*\t__go_go(void (*pfn)(void*), void*);\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n@@ -476,21 +487,16 @@ void\truntime_unlock(Lock*)\n  * notesleep/notetsleep are generally called on g0,\n  * notetsleepg is similar to notetsleep but is called on user g.\n  */\n-void\truntime_noteclear(Note*);\n-void\truntime_notesleep(Note*);\n-void\truntime_notewakeup(Note*);\n-bool\truntime_notetsleep(Note*, int64);  // false - timeout\n-bool\truntime_notetsleepg(Note*, int64);  // false - timeout\n-\n-/*\n- * low-level synchronization for implementing the above\n- */\n-uintptr\truntime_semacreate(void);\n-int32\truntime_semasleep(int64);\n-void\truntime_semawakeup(M*);\n-// or\n-void\truntime_futexsleep(uint32*, uint32, int64);\n-void\truntime_futexwakeup(uint32*, uint32);\n+void\truntime_noteclear(Note*)\n+  __asm__ (GOSYM_PREFIX \"runtime.noteclear\");\n+void\truntime_notesleep(Note*)\n+  __asm__ (GOSYM_PREFIX \"runtime.notesleep\");\n+void\truntime_notewakeup(Note*)\n+  __asm__ (GOSYM_PREFIX \"runtime.notewakeup\");\n+bool\truntime_notetsleep(Note*, int64)  // false - timeout\n+  __asm__ (GOSYM_PREFIX \"runtime.notetsleep\");\n+bool\truntime_notetsleepg(Note*, int64)  // false - timeout\n+  __asm__ (GOSYM_PREFIX \"runtime.notetsleepg\");\n \n /*\n  * Lock-free stack.\n@@ -578,8 +584,10 @@ void\truntime_newErrorCString(const char*, Eface*)\n void\truntime_semacquire(uint32 volatile *, bool);\n void\truntime_semrelease(uint32 volatile *);\n int32\truntime_gomaxprocsfunc(int32 n);\n-void\truntime_procyield(uint32);\n-void\truntime_osyield(void);\n+void\truntime_procyield(uint32)\n+  __asm__(GOSYM_PREFIX \"runtime.procyield\");\n+void\truntime_osyield(void)\n+  __asm__(GOSYM_PREFIX \"runtime.osyield\");\n void\truntime_lockOSThread(void);\n void\truntime_unlockOSThread(void);\n bool\truntime_lockedOSThread(void);"}, {"sha": "63a2b7551f6718e333917bde2a8b9abda38adb0c", "filename": "libgo/runtime/thread-linux.c", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fthread-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fthread-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-linux.c?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -7,69 +7,11 @@\n #include \"signal_unix.h\"\n \n // Linux futex.\n-//\n-//\tfutexsleep(uint32 *addr, uint32 val)\n-//\tfutexwakeup(uint32 *addr)\n-//\n-// Futexsleep atomically checks if *addr == val and if so, sleeps on addr.\n-// Futexwakeup wakes up threads sleeping on addr.\n-// Futexsleep is allowed to wake up spuriously.\n \n-#include <errno.h>\n-#include <string.h>\n-#include <time.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n #include <unistd.h>\n #include <syscall.h>\n #include <linux/futex.h>\n \n-typedef struct timespec Timespec;\n-\n-// Atomically,\n-//\tif(*addr == val) sleep\n-// Might be woken up spuriously; that's allowed.\n-// Don't sleep longer than ns; ns < 0 means forever.\n-void\n-runtime_futexsleep(uint32 *addr, uint32 val, int64 ns)\n-{\n-\tTimespec ts;\n-\tint32 nsec;\n-\n-\t// Some Linux kernels have a bug where futex of\n-\t// FUTEX_WAIT returns an internal error code\n-\t// as an errno.  Libpthread ignores the return value\n-\t// here, and so can we: as it says a few lines up,\n-\t// spurious wakeups are allowed.\n-\n-\tif(ns < 0) {\n-\t\tsyscall(__NR_futex, addr, FUTEX_WAIT, val, nil, nil, 0);\n-\t\treturn;\n-\t}\n-\tts.tv_sec = runtime_timediv(ns, 1000000000LL, &nsec);\n-\tts.tv_nsec = nsec;\n-\tsyscall(__NR_futex, addr, FUTEX_WAIT, val, &ts, nil, 0);\n-}\n-\n-// If any procs are sleeping on addr, wake up at most cnt.\n-void\n-runtime_futexwakeup(uint32 *addr, uint32 cnt)\n-{\n-\tint64 ret;\n-\n-\tret = syscall(__NR_futex, addr, FUTEX_WAKE, cnt, nil, nil, 0);\n-\n-\tif(ret >= 0)\n-\t\treturn;\n-\n-\t// I don't know that futex wakeup can return\n-\t// EAGAIN or EINTR, but if it does, it would be\n-\t// safe to loop and call futex again.\n-\truntime_printf(\"futexwakeup addr=%p returned %D\\n\", addr, ret);\n-\t*(int32*)0x1006 = 0x1006;\n-}\n-\n void\n runtime_osinit(void)\n {"}, {"sha": "b74b1dab1123beb5c638a6602bee3f01569cbfe7", "filename": "libgo/runtime/thread-sema.c", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fthread-sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fruntime%2Fthread-sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-sema.c?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -10,131 +10,6 @@\n #include <time.h>\n #include <semaphore.h>\n \n-/* If we don't have sem_timedwait, use pthread_cond_timedwait instead.\n-   We don't always use condition variables because on some systems\n-   pthread_mutex_lock and pthread_mutex_unlock must be called by the\n-   same thread.  That is never true of semaphores.  */\n-\n-struct go_sem\n-{\n-  sem_t sem;\n-\n-#ifndef HAVE_SEM_TIMEDWAIT\n-  int timedwait;\n-  pthread_mutex_t mutex;\n-  pthread_cond_t cond;\n-#endif\n-};\n-\n-/* Create a semaphore.  */\n-\n-uintptr\n-runtime_semacreate(void)\n-{\n-  struct go_sem *p;\n-\n-  /* Call malloc rather than runtime_malloc.  This will allocate space\n-     on the C heap.  We can't call runtime_malloc here because it\n-     could cause a deadlock.  */\n-  p = malloc (sizeof (struct go_sem));\n-  if (sem_init (&p->sem, 0, 0) != 0)\n-    runtime_throw (\"sem_init\");\n-\n-#ifndef HAVE_SEM_TIMEDWAIT\n-  if (pthread_mutex_init (&p->mutex, NULL) != 0)\n-    runtime_throw (\"pthread_mutex_init\");\n-  if (pthread_cond_init (&p->cond, NULL) != 0)\n-    runtime_throw (\"pthread_cond_init\");\n-#endif\n-\n-  return (uintptr) p;\n-}\n-\n-/* Acquire m->waitsema.  */\n-\n-int32\n-runtime_semasleep (int64 ns)\n-{\n-  M *m;\n-  struct go_sem *sem;\n-  int r;\n-\n-  m = runtime_m ();\n-  sem = (struct go_sem *) m->waitsema;\n-  if (ns >= 0)\n-    {\n-      int64 abs;\n-      struct timespec ts;\n-      int err;\n-\n-      abs = ns + runtime_nanotime ();\n-      ts.tv_sec = abs / 1000000000LL;\n-      ts.tv_nsec = abs % 1000000000LL;\n-\n-      err = 0;\n-\n-#ifdef HAVE_SEM_TIMEDWAIT\n-      r = sem_timedwait (&sem->sem, &ts);\n-      if (r != 0)\n-\terr = errno;\n-#else\n-      if (pthread_mutex_lock (&sem->mutex) != 0)\n-\truntime_throw (\"pthread_mutex_lock\");\n-\n-      while ((r = sem_trywait (&sem->sem)) != 0)\n-\t{\n-\t  r = pthread_cond_timedwait (&sem->cond, &sem->mutex, &ts);\n-\t  if (r != 0)\n-\t    {\n-\t      err = r;\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (pthread_mutex_unlock (&sem->mutex) != 0)\n-\truntime_throw (\"pthread_mutex_unlock\");\n-#endif\n-\n-      if (err != 0)\n-\t{\n-\t  if (err == ETIMEDOUT || err == EAGAIN || err == EINTR)\n-\t    return -1;\n-\t  runtime_throw (\"sema_timedwait\");\n-\t}\n-      return 0;\n-    }\n-\n-  while (sem_wait (&sem->sem) != 0)\n-    {\n-      if (errno == EINTR)\n-\tcontinue;\n-      runtime_throw (\"sem_wait\");\n-    }\n-\n-  return 0;\n-}\n-\n-/* Wake up mp->waitsema.  */\n-\n-void\n-runtime_semawakeup (M *mp)\n-{\n-  struct go_sem *sem;\n-\n-  sem = (struct go_sem *) mp->waitsema;\n-  if (sem_post (&sem->sem) != 0)\n-    runtime_throw (\"sem_post\");\n-\n-#ifndef HAVE_SEM_TIMEDWAIT\n-  if (pthread_mutex_lock (&sem->mutex) != 0)\n-    runtime_throw (\"pthread_mutex_lock\");\n-  if (pthread_cond_broadcast (&sem->cond) != 0)\n-    runtime_throw (\"pthread_cond_broadcast\");\n-  if (pthread_mutex_unlock (&sem->mutex) != 0)\n-    runtime_throw (\"pthread_mutex_unlock\");\n-#endif\n-}\n-\n void\n runtime_osinit (void)\n {"}, {"sha": "09c0f496a6e635439be5a3931ede4189f21287a5", "filename": "libgo/sysinfo.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fsysinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9/libgo%2Fsysinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsysinfo.c?ref=c0401cf78c555ef38d2d2fba94ebffeaef7c6bc9", "patch": "@@ -152,6 +152,9 @@\n #if defined(HAVE_SCHED_H)\n #include <sched.h>\n #endif\n+#if defined(HAVE_SEMAPHORE_H)\n+#include <semaphore.h>\n+#endif\n \n /* Constants that may only be defined as expressions on some systems,\n    expressions too complex for -fdump-go-spec to handle.  These are"}]}