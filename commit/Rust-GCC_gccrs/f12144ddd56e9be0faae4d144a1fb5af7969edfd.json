{"sha": "f12144ddd56e9be0faae4d144a1fb5af7969edfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEyMTQ0ZGRkNTZlOWJlMGZhYWU0ZDE0NGExZmI1YWY3OTY5ZWRmZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-07-19T17:42:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-07-19T17:42:58Z"}, "message": "emit-rtl.c (mem_attrs_eq_p): New function, split out from...\n\ngcc/\n\t* emit-rtl.c (mem_attrs_eq_p): New function, split out from...\n\t(mem_attrs_htab_eq): ...here.\n\t(find_mem_attrs): Replace with...\n\t(set_mem_attrs): ...this function.  Take a mem_attrs structure\n\trather than individual fields.\n\t(set_mem_attributes_minus_bitpos, set_mem_alias_set)\n\t(set_mem_addr_space, set_mem_align, set_mem_expr, set_mem_offset)\n\t(set_mem_size, change_address, adjust_address_1, offset_address)\n\t(widen_memory_access, get_spill_slot_decl, set_mem_attrs_for_spill):\n\tUpdate accordingly.\n\nFrom-SVN: r176475", "tree": {"sha": "ee3b631247c6731ab4438c0881bb71e431210a29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee3b631247c6731ab4438c0881bb71e431210a29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f12144ddd56e9be0faae4d144a1fb5af7969edfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12144ddd56e9be0faae4d144a1fb5af7969edfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f12144ddd56e9be0faae4d144a1fb5af7969edfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12144ddd56e9be0faae4d144a1fb5af7969edfd/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c3f523e1c52ec1f2777978b7838f44a5fb04d2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c3f523e1c52ec1f2777978b7838f44a5fb04d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c3f523e1c52ec1f2777978b7838f44a5fb04d2c"}], "stats": {"total": 392, "additions": 206, "deletions": 186}, "files": [{"sha": "08f9a2979a534182cde456f6e4d8e90d3455404d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12144ddd56e9be0faae4d144a1fb5af7969edfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12144ddd56e9be0faae4d144a1fb5af7969edfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f12144ddd56e9be0faae4d144a1fb5af7969edfd", "patch": "@@ -1,3 +1,16 @@\n+2011-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* emit-rtl.c (mem_attrs_eq_p): New function, split out from...\n+\t(mem_attrs_htab_eq): ...here.\n+\t(find_mem_attrs): Replace with...\n+\t(set_mem_attrs): ...this function.  Take a mem_attrs structure\n+\trather than individual fields.\n+\t(set_mem_attributes_minus_bitpos, set_mem_alias_set)\n+\t(set_mem_addr_space, set_mem_align, set_mem_expr, set_mem_offset)\n+\t(set_mem_size, change_address, adjust_address_1, offset_address)\n+\t(widen_memory_access, get_spill_slot_decl, set_mem_attrs_for_spill):\n+\tUpdate accordingly.\n+\n 2011-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* rtl.h (MEM_ALIAS_SET, MEM_EXPR, MEM_OFFSET, MEM_ADDR_SPACE)"}, {"sha": "8c843a75a040f8b8b9e33a561eb36ab6b0788bbe", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 193, "deletions": 186, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12144ddd56e9be0faae4d144a1fb5af7969edfd/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12144ddd56e9be0faae4d144a1fb5af7969edfd/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f12144ddd56e9be0faae4d144a1fb5af7969edfd", "patch": "@@ -261,16 +261,11 @@ mem_attrs_htab_hash (const void *x)\n \t  ^ (size_t) iterative_hash_expr (p->expr, 0));\n }\n \n-/* Returns nonzero if the value represented by X (which is really a\n-   mem_attrs *) is the same as that given by Y (which is also really a\n-   mem_attrs *).  */\n+/* Return true if the given memory attributes are equal.  */\n \n-static int\n-mem_attrs_htab_eq (const void *x, const void *y)\n+static bool\n+mem_attrs_eq_p (const struct mem_attrs *p, const struct mem_attrs *q)\n {\n-  const mem_attrs *const p = (const mem_attrs *) x;\n-  const mem_attrs *const q = (const mem_attrs *) y;\n-\n   return (p->alias == q->alias && p->offset == q->offset\n \t  && p->size == q->size && p->align == q->align\n \t  && p->addrspace == q->addrspace\n@@ -279,43 +274,38 @@ mem_attrs_htab_eq (const void *x, const void *y)\n \t\t  && operand_equal_p (p->expr, q->expr, 0))));\n }\n \n-/* Allocate a new mem_attrs structure and insert it into the hash table if\n-   one identical to it is not already in the table.  We are doing this for\n-   MEM of mode MODE.  */\n+/* Returns nonzero if the value represented by X (which is really a\n+   mem_attrs *) is the same as that given by Y (which is also really a\n+   mem_attrs *).  */\n \n-static mem_attrs *\n-find_mem_attrs (alias_set_type alias, tree expr, rtx offset, rtx size,\n-\t\tunsigned int align, addr_space_t addrspace,\n-\t\tenum machine_mode mode)\n+static int\n+mem_attrs_htab_eq (const void *x, const void *y)\n {\n-  mem_attrs attrs;\n-  void **slot;\n+  return mem_attrs_eq_p ((const mem_attrs *) x, (const mem_attrs *) y);\n+}\n \n-  /* If everything is the default, we can just return zero.\n-     This must match what the corresponding MEM_* macros return when the\n-     field is not present.  */\n-  if (alias == 0 && expr == 0 && offset == 0 && addrspace == 0\n-      && (size == 0\n-\t  || (mode != BLKmode && GET_MODE_SIZE (mode) == INTVAL (size)))\n-      && (STRICT_ALIGNMENT && mode != BLKmode\n-\t  ? align == GET_MODE_ALIGNMENT (mode) : align == BITS_PER_UNIT))\n-    return 0;\n+/* Set MEM's memory attributes so that they are the same as ATTRS.  */\n \n-  attrs.alias = alias;\n-  attrs.expr = expr;\n-  attrs.offset = offset;\n-  attrs.size = size;\n-  attrs.align = align;\n-  attrs.addrspace = addrspace;\n+static void\n+set_mem_attrs (rtx mem, mem_attrs *attrs)\n+{\n+  void **slot;\n \n-  slot = htab_find_slot (mem_attrs_htab, &attrs, INSERT);\n+  /* If everything is the default, we can just clear the attributes.  */\n+  if (mem_attrs_eq_p (attrs, mode_mem_attrs[(int) GET_MODE (mem)]))\n+    {\n+      MEM_ATTRS (mem) = 0;\n+      return;\n+    }\n+\n+  slot = htab_find_slot (mem_attrs_htab, attrs, INSERT);\n   if (*slot == 0)\n     {\n       *slot = ggc_alloc_mem_attrs ();\n-      memcpy (*slot, &attrs, sizeof (mem_attrs));\n+      memcpy (*slot, attrs, sizeof (mem_attrs));\n     }\n \n-  return (mem_attrs *) *slot;\n+  MEM_ATTRS (mem) = (mem_attrs *) *slot;\n }\n \n /* Returns a hash code for X (which is a really a reg_attrs *).  */\n@@ -1553,13 +1543,9 @@ void\n set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t\t\t HOST_WIDE_INT bitpos)\n {\n-  alias_set_type alias;\n-  tree expr = NULL;\n-  rtx offset = NULL_RTX;\n-  rtx size = NULL_RTX;\n-  unsigned int align = BITS_PER_UNIT;\n   HOST_WIDE_INT apply_bitpos = 0;\n   tree type;\n+  struct mem_attrs attrs, *defattrs, *refattrs;\n \n   /* It can happen that type_for_mode was given a mode for which there\n      is no language-level type.  In which case it returns NULL, which\n@@ -1577,9 +1563,11 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n      set_mem_attributes.  */\n   gcc_assert (!DECL_P (t) || ref != DECL_RTL_IF_SET (t));\n \n+  memset (&attrs, 0, sizeof (attrs));\n+\n   /* Get the alias set from the expression or type (perhaps using a\n      front-end routine) and use it.  */\n-  alias = get_alias_set (t);\n+  attrs.alias = get_alias_set (t);\n \n   MEM_VOLATILE_P (ref) |= TYPE_VOLATILE (type);\n   MEM_IN_STRUCT_P (ref)\n@@ -1594,28 +1582,35 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n     MEM_SCALAR_P (ref) = 1;\n \n   /* Default values from pre-existing memory attributes if present.  */\n-  if (MEM_ATTRS (ref))\n+  refattrs = MEM_ATTRS (ref);\n+  if (refattrs)\n     {\n       /* ??? Can this ever happen?  Calling this routine on a MEM that\n \t already carries memory attributes should probably be invalid.  */\n-      expr = MEM_EXPR (ref);\n-      offset = MEM_OFFSET (ref);\n-      size = MEM_SIZE (ref);\n-      align = MEM_ALIGN (ref);\n+      attrs.expr = refattrs->expr;\n+      attrs.offset = refattrs->offset;\n+      attrs.size = refattrs->size;\n+      attrs.align = refattrs->align;\n     }\n \n   /* Otherwise, default values from the mode of the MEM reference.  */\n-  else if (GET_MODE (ref) != BLKmode)\n+  else\n     {\n+      defattrs = mode_mem_attrs[(int) GET_MODE (ref)];\n+      gcc_assert (!defattrs->expr);\n+      gcc_assert (!defattrs->offset);\n+\n       /* Respect mode size.  */\n-      size = GEN_INT (GET_MODE_SIZE (GET_MODE (ref)));\n+      attrs.size = defattrs->size;\n       /* ??? Is this really necessary?  We probably should always get\n \t the size from the type below.  */\n \n       /* Respect mode alignment for STRICT_ALIGNMENT targets if T is a type;\n          if T is an object, always compute the object alignment below.  */\n-      if (STRICT_ALIGNMENT && TYPE_P (t))\n-\talign = GET_MODE_ALIGNMENT (GET_MODE (ref));\n+      if (TYPE_P (t))\n+\tattrs.align = defattrs->align;\n+      else\n+\tattrs.align = BITS_PER_UNIT;\n       /* ??? If T is a type, respecting mode alignment may *also* be wrong\n \t e.g. if the type carries an alignment attribute.  Should we be\n \t able to simply always use TYPE_ALIGN?  */\n@@ -1624,7 +1619,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n   /* We can set the alignment from the type if we are making an object,\n      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */\n   if (objectp || TREE_CODE (t) == INDIRECT_REF || TYPE_ALIGN_OK (type))\n-    align = MAX (align, TYPE_ALIGN (type));\n+    attrs.align = MAX (attrs.align, TYPE_ALIGN (type));\n \n   else if (TREE_CODE (t) == MEM_REF)\n     {\n@@ -1634,36 +1629,37 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t      || CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))))\n \t{\n \t  if (DECL_P (TREE_OPERAND (op0, 0)))\n-\t    align = DECL_ALIGN (TREE_OPERAND (op0, 0));\n+\t    attrs.align = DECL_ALIGN (TREE_OPERAND (op0, 0));\n \t  else if (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0)))\n \t    {\n-\t      align = TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (op0, 0)));\n+\t      attrs.align = TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (op0, 0)));\n #ifdef CONSTANT_ALIGNMENT\n-\t      align = CONSTANT_ALIGNMENT (TREE_OPERAND (op0, 0), align);\n+\t      attrs.align = CONSTANT_ALIGNMENT (TREE_OPERAND (op0, 0),\n+\t\t\t\t\t\tattrs.align);\n #endif\n \t    }\n \t  if (TREE_INT_CST_LOW (TREE_OPERAND (t, 1)) != 0)\n \t    {\n \t      unsigned HOST_WIDE_INT ioff\n \t\t= TREE_INT_CST_LOW (TREE_OPERAND (t, 1));\n \t      unsigned HOST_WIDE_INT aoff = (ioff & -ioff) * BITS_PER_UNIT;\n-\t      align = MIN (aoff, align);\n+\t      attrs.align = MIN (aoff, attrs.align);\n \t    }\n \t}\n       else\n \t/* ??? This isn't fully correct, we can't set the alignment from the\n \t   type in all cases.  */\n-\talign = MAX (align, TYPE_ALIGN (type));\n+\tattrs.align = MAX (attrs.align, TYPE_ALIGN (type));\n     }\n \n   else if (TREE_CODE (t) == TARGET_MEM_REF)\n     /* ??? This isn't fully correct, we can't set the alignment from the\n        type in all cases.  */\n-    align = MAX (align, TYPE_ALIGN (type));\n+    attrs.align = MAX (attrs.align, TYPE_ALIGN (type));\n \n   /* If the size is known, we can set that.  */\n   if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))\n-    size = GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1));\n+    attrs.size = GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1));\n \n   /* If T is not a type, we may be able to deduce some more information about\n      the expression.  */\n@@ -1700,22 +1696,22 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       /* If this is a decl, set the attributes of the MEM from it.  */\n       if (DECL_P (t))\n \t{\n-\t  expr = t;\n-\t  offset = const0_rtx;\n+\t  attrs.expr = t;\n+\t  attrs.offset = const0_rtx;\n \t  apply_bitpos = bitpos;\n-\t  size = (DECL_SIZE_UNIT (t)\n-\t\t  && host_integerp (DECL_SIZE_UNIT (t), 1)\n-\t\t  ? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n-\t  align = DECL_ALIGN (t);\n+\t  attrs.size = (DECL_SIZE_UNIT (t)\n+\t\t\t&& host_integerp (DECL_SIZE_UNIT (t), 1)\n+\t\t\t? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n+\t  attrs.align = DECL_ALIGN (t);\n \t  align_computed = true;\n \t}\n \n       /* If this is a constant, we know the alignment.  */\n       else if (CONSTANT_CLASS_P (t))\n \t{\n-\t  align = TYPE_ALIGN (type);\n+\t  attrs.align = TYPE_ALIGN (type);\n #ifdef CONSTANT_ALIGNMENT\n-\t  align = CONSTANT_ALIGNMENT (t, align);\n+\t  attrs.align = CONSTANT_ALIGNMENT (t, attrs.align);\n #endif\n \t  align_computed = true;\n \t}\n@@ -1727,8 +1723,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       else if (TREE_CODE (t) == COMPONENT_REF\n \t       && ! DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t{\n-\t  expr = t;\n-\t  offset = const0_rtx;\n+\t  attrs.expr = t;\n+\t  attrs.offset = const0_rtx;\n \t  apply_bitpos = bitpos;\n \t  /* ??? Any reason the field size would be different than\n \t     the size we got from the type?  */\n@@ -1768,27 +1764,27 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n \t  if (DECL_P (t2))\n \t    {\n-\t      expr = t2;\n-\t      offset = NULL;\n+\t      attrs.expr = t2;\n+\t      attrs.offset = NULL;\n \t      if (host_integerp (off_tree, 1))\n \t\t{\n \t\t  HOST_WIDE_INT ioff = tree_low_cst (off_tree, 1);\n \t\t  HOST_WIDE_INT aoff = (ioff & -ioff) * BITS_PER_UNIT;\n-\t\t  align = DECL_ALIGN (t2);\n-\t\t  if (aoff && (unsigned HOST_WIDE_INT) aoff < align)\n-\t            align = aoff;\n+\t\t  attrs.align = DECL_ALIGN (t2);\n+\t\t  if (aoff && (unsigned HOST_WIDE_INT) aoff < attrs.align)\n+\t            attrs.align = aoff;\n \t\t  align_computed = true;\n-\t\t  offset = GEN_INT (ioff);\n+\t\t  attrs.offset = GEN_INT (ioff);\n \t\t  apply_bitpos = bitpos;\n \t\t}\n \t    }\n \t  else if (TREE_CODE (t2) == COMPONENT_REF)\n \t    {\n-\t      expr = t2;\n-\t      offset = NULL;\n+\t      attrs.expr = t2;\n+\t      attrs.offset = NULL;\n \t      if (host_integerp (off_tree, 1))\n \t\t{\n-\t\t  offset = GEN_INT (tree_low_cst (off_tree, 1));\n+\t\t  attrs.offset = GEN_INT (tree_low_cst (off_tree, 1));\n \t\t  apply_bitpos = bitpos;\n \t\t}\n \t      /* ??? Any reason the field size would be different than\n@@ -1798,8 +1794,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  /* If this is an indirect reference, record it.  */\n \t  else if (TREE_CODE (t) == MEM_REF)\n \t    {\n-\t      expr = t;\n-\t      offset = const0_rtx;\n+\t      attrs.expr = t;\n+\t      attrs.offset = const0_rtx;\n \t      apply_bitpos = bitpos;\n \t    }\n \t}\n@@ -1808,15 +1804,15 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       else if (TREE_CODE (t) == MEM_REF \n \t       || TREE_CODE (t) == TARGET_MEM_REF)\n \t{\n-\t  expr = t;\n-\t  offset = const0_rtx;\n+\t  attrs.expr = t;\n+\t  attrs.offset = const0_rtx;\n \t  apply_bitpos = bitpos;\n \t}\n \n       if (!align_computed && !INDIRECT_REF_P (t))\n \t{\n \t  unsigned int obj_align = get_object_alignment (t, BIGGEST_ALIGNMENT);\n-\t  align = MAX (align, obj_align);\n+\t  attrs.align = MAX (attrs.align, obj_align);\n \t}\n     }\n \n@@ -1825,15 +1821,14 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n      object to contain the negative offset.  */\n   if (apply_bitpos)\n     {\n-      offset = plus_constant (offset, -(apply_bitpos / BITS_PER_UNIT));\n-      if (size)\n-\tsize = plus_constant (size, apply_bitpos / BITS_PER_UNIT);\n+      attrs.offset = plus_constant (attrs.offset,\n+\t\t\t\t    -(apply_bitpos / BITS_PER_UNIT));\n+      if (attrs.size)\n+\tattrs.size = plus_constant (attrs.size, apply_bitpos / BITS_PER_UNIT);\n     }\n \n   /* Now set the attributes we computed above.  */\n-  MEM_ATTRS (ref)\n-    = find_mem_attrs (alias, expr, offset, size, align,\n-\t\t      TYPE_ADDR_SPACE (type), GET_MODE (ref));\n+  set_mem_attrs (ref, &attrs);\n \n   /* If this is already known to be a scalar or aggregate, we are done.  */\n   if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))\n@@ -1858,63 +1853,73 @@ set_mem_attributes (rtx ref, tree t, int objectp)\n void\n set_mem_alias_set (rtx mem, alias_set_type set)\n {\n+  struct mem_attrs attrs;\n+\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n   gcc_checking_assert (alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)));\n-\n-  MEM_ATTRS (mem) = find_mem_attrs (set, MEM_EXPR (mem), MEM_OFFSET (mem),\n-\t\t\t\t    MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t\t\t    MEM_ADDR_SPACE (mem), GET_MODE (mem));\n+  attrs = *get_mem_attrs (mem);\n+  attrs.alias = set;\n+  set_mem_attrs (mem, &attrs);\n }\n \n /* Set the address space of MEM to ADDRSPACE (target-defined).  */\n \n void\n set_mem_addr_space (rtx mem, addr_space_t addrspace)\n {\n-  MEM_ATTRS (mem) = find_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n-\t\t\t\t    MEM_OFFSET (mem), MEM_SIZE (mem),\n-\t\t\t\t    MEM_ALIGN (mem), addrspace, GET_MODE (mem));\n+  struct mem_attrs attrs;\n+\n+  attrs = *get_mem_attrs (mem);\n+  attrs.addrspace = addrspace;\n+  set_mem_attrs (mem, &attrs);\n }\n \n /* Set the alignment of MEM to ALIGN bits.  */\n \n void\n set_mem_align (rtx mem, unsigned int align)\n {\n-  MEM_ATTRS (mem) = find_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n-\t\t\t\t    MEM_OFFSET (mem), MEM_SIZE (mem), align,\n-\t\t\t\t    MEM_ADDR_SPACE (mem), GET_MODE (mem));\n+  struct mem_attrs attrs;\n+\n+  attrs = *get_mem_attrs (mem);\n+  attrs.align = align;\n+  set_mem_attrs (mem, &attrs);\n }\n \n /* Set the expr for MEM to EXPR.  */\n \n void\n set_mem_expr (rtx mem, tree expr)\n {\n-  MEM_ATTRS (mem)\n-    = find_mem_attrs (MEM_ALIAS_SET (mem), expr, MEM_OFFSET (mem),\n-\t\t      MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t      MEM_ADDR_SPACE (mem), GET_MODE (mem));\n+  struct mem_attrs attrs;\n+\n+  attrs = *get_mem_attrs (mem);\n+  attrs.expr = expr;\n+  set_mem_attrs (mem, &attrs);\n }\n \n /* Set the offset of MEM to OFFSET.  */\n \n void\n set_mem_offset (rtx mem, rtx offset)\n {\n-  MEM_ATTRS (mem) = find_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n-\t\t\t\t    offset, MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t\t\t    MEM_ADDR_SPACE (mem), GET_MODE (mem));\n+  struct mem_attrs attrs;\n+\n+  attrs = *get_mem_attrs (mem);\n+  attrs.offset = offset;\n+  set_mem_attrs (mem, &attrs);\n }\n \n /* Set the size of MEM to SIZE.  */\n \n void\n set_mem_size (rtx mem, rtx size)\n {\n-  MEM_ATTRS (mem) = find_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n-\t\t\t\t    MEM_OFFSET (mem), size, MEM_ALIGN (mem),\n-\t\t\t\t    MEM_ADDR_SPACE (mem), GET_MODE (mem));\n+  struct mem_attrs attrs;\n+\n+  attrs = *get_mem_attrs (mem);\n+  attrs.size = size;\n+  set_mem_attrs (mem, &attrs);\n }\n \f\n /* Return a memory reference like MEMREF, but with its mode changed to MODE\n@@ -1961,31 +1966,28 @@ change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n rtx\n change_address (rtx memref, enum machine_mode mode, rtx addr)\n {\n-  rtx new_rtx = change_address_1 (memref, mode, addr, 1), size;\n+  rtx new_rtx = change_address_1 (memref, mode, addr, 1);\n   enum machine_mode mmode = GET_MODE (new_rtx);\n-  unsigned int align;\n+  struct mem_attrs attrs, *defattrs;\n \n-  size = mmode == BLKmode ? 0 : GEN_INT (GET_MODE_SIZE (mmode));\n-  align = mmode == BLKmode ? BITS_PER_UNIT : GET_MODE_ALIGNMENT (mmode);\n+  attrs = *get_mem_attrs (memref);\n+  defattrs = mode_mem_attrs[(int) mmode];\n+  attrs.expr = defattrs->expr;\n+  attrs.offset = defattrs->offset;\n+  attrs.size = defattrs->size;\n+  attrs.align = defattrs->align;\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (new_rtx == memref)\n     {\n-      if (MEM_ATTRS (memref) == 0\n-\t  || (MEM_EXPR (memref) == NULL\n-\t      && MEM_OFFSET (memref) == NULL\n-\t      && MEM_SIZE (memref) == size\n-\t      && MEM_ALIGN (memref) == align))\n+      if (mem_attrs_eq_p (get_mem_attrs (memref), &attrs))\n \treturn new_rtx;\n \n       new_rtx = gen_rtx_MEM (mmode, XEXP (memref, 0));\n       MEM_COPY_ATTRIBUTES (new_rtx, memref);\n     }\n \n-  MEM_ATTRS (new_rtx)\n-    = find_mem_attrs (MEM_ALIAS_SET (memref), 0, 0, size, align,\n-\t\t      MEM_ADDR_SPACE (memref), mmode);\n-\n+  set_mem_attrs (new_rtx, &attrs);\n   return new_rtx;\n }\n \n@@ -2001,16 +2003,17 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n {\n   rtx addr = XEXP (memref, 0);\n   rtx new_rtx;\n-  rtx memoffset = MEM_OFFSET (memref);\n-  rtx size = 0;\n-  unsigned int memalign = MEM_ALIGN (memref);\n-  addr_space_t as = MEM_ADDR_SPACE (memref);\n-  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n+  enum machine_mode address_mode;\n   int pbits;\n+  struct mem_attrs attrs, *defattrs;\n+  unsigned HOST_WIDE_INT max_align;\n+\n+  attrs = *get_mem_attrs (memref);\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (mode == GET_MODE (memref) && !offset\n-      && (!validate || memory_address_addr_space_p (mode, addr, as)))\n+      && (!validate || memory_address_addr_space_p (mode, addr,\n+\t\t\t\t\t\t    attrs.addrspace)))\n     return memref;\n \n   /* ??? Prefer to create garbage instead of creating shared rtl.\n@@ -2020,6 +2023,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n   /* Convert a possibly large offset to a signed value within the\n      range of the target address space.  */\n+  address_mode = targetm.addr_space.address_mode (attrs.addrspace);\n   pbits = GET_MODE_BITSIZE (address_mode);\n   if (HOST_BITS_PER_WIDE_INT > pbits)\n     {\n@@ -2051,27 +2055,26 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n   /* Compute the new values of the memory attributes due to this adjustment.\n      We add the offsets and update the alignment.  */\n-  if (memoffset)\n-    memoffset = GEN_INT (offset + INTVAL (memoffset));\n+  if (attrs.offset)\n+    attrs.offset = GEN_INT (offset + INTVAL (attrs.offset));\n \n   /* Compute the new alignment by taking the MIN of the alignment and the\n      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET\n      if zero.  */\n   if (offset != 0)\n-    memalign\n-      = MIN (memalign,\n-\t     (unsigned HOST_WIDE_INT) (offset & -offset) * BITS_PER_UNIT);\n+    {\n+      max_align = (offset & -offset) * BITS_PER_UNIT;\n+      attrs.align = MIN (attrs.align, max_align);\n+    }\n \n   /* We can compute the size in a number of ways.  */\n-  if (GET_MODE (new_rtx) != BLKmode)\n-    size = GEN_INT (GET_MODE_SIZE (GET_MODE (new_rtx)));\n-  else if (MEM_SIZE (memref))\n-    size = plus_constant (MEM_SIZE (memref), -offset);\n+  defattrs = mode_mem_attrs[(int) GET_MODE (new_rtx)];\n+  if (defattrs->size)\n+    attrs.size = defattrs->size;\n+  else if (attrs.size)\n+    attrs.size = plus_constant (attrs.size, -offset);\n \n-  MEM_ATTRS (new_rtx) = find_mem_attrs (MEM_ALIAS_SET (memref),\n-\t\t\t\t\tMEM_EXPR (memref),\n-\t\t\t\t\tmemoffset, size, memalign, as,\n-\t\t\t\t\tGET_MODE (new_rtx));\n+  set_mem_attrs (new_rtx, &attrs);\n \n   /* At some point, we should validate that this offset is within the object,\n      if all the appropriate values are known.  */\n@@ -2099,9 +2102,11 @@ rtx\n offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new_rtx, addr = XEXP (memref, 0);\n-  addr_space_t as = MEM_ADDR_SPACE (memref);\n-  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n+  enum machine_mode address_mode;\n+  struct mem_attrs attrs;\n \n+  attrs = *get_mem_attrs (memref);\n+  address_mode = targetm.addr_space.address_mode (attrs.addrspace);\n   new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);\n \n   /* At this point we don't know _why_ the address is invalid.  It\n@@ -2111,7 +2116,8 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n      being able to recognize the magic around pic_offset_table_rtx.\n      This stuff is fragile, and is yet another example of why it is\n      bad to expose PIC machinery too early.  */\n-  if (! memory_address_addr_space_p (GET_MODE (memref), new_rtx, as)\n+  if (! memory_address_addr_space_p (GET_MODE (memref), new_rtx,\n+\t\t\t\t     attrs.addrspace)\n       && GET_CODE (addr) == PLUS\n       && XEXP (addr, 0) == pic_offset_table_rtx)\n     {\n@@ -2128,10 +2134,10 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n-  MEM_ATTRS (new_rtx)\n-    = find_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref), 0, 0,\n-\t\t      MIN (MEM_ALIGN (memref), pow2 * BITS_PER_UNIT),\n-\t\t      as, GET_MODE (new_rtx));\n+  attrs.offset = 0;\n+  attrs.size = mode_mem_attrs[(int) GET_MODE (new_rtx)]->size;\n+  attrs.align = MIN (attrs.align, pow2 * BITS_PER_UNIT);\n+  set_mem_attrs (new_rtx, &attrs);\n   return new_rtx;\n }\n \n@@ -2166,78 +2172,77 @@ rtx\n widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n {\n   rtx new_rtx = adjust_address_1 (memref, mode, offset, 1, 1);\n-  tree expr = MEM_EXPR (new_rtx);\n-  rtx memoffset = MEM_OFFSET (new_rtx);\n+  struct mem_attrs attrs;\n   unsigned int size = GET_MODE_SIZE (mode);\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (new_rtx == memref)\n     return new_rtx;\n \n+  attrs = *get_mem_attrs (new_rtx);\n+\n   /* If we don't know what offset we were at within the expression, then\n      we can't know if we've overstepped the bounds.  */\n-  if (! memoffset)\n-    expr = NULL_TREE;\n+  if (! attrs.offset)\n+    attrs.expr = NULL_TREE;\n \n-  while (expr)\n+  while (attrs.expr)\n     {\n-      if (TREE_CODE (expr) == COMPONENT_REF)\n+      if (TREE_CODE (attrs.expr) == COMPONENT_REF)\n \t{\n-\t  tree field = TREE_OPERAND (expr, 1);\n-\t  tree offset = component_ref_field_offset (expr);\n+\t  tree field = TREE_OPERAND (attrs.expr, 1);\n+\t  tree offset = component_ref_field_offset (attrs.expr);\n \n \t  if (! DECL_SIZE_UNIT (field))\n \t    {\n-\t      expr = NULL_TREE;\n+\t      attrs.expr = NULL_TREE;\n \t      break;\n \t    }\n \n \t  /* Is the field at least as large as the access?  If so, ok,\n \t     otherwise strip back to the containing structure.  */\n \t  if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST\n \t      && compare_tree_int (DECL_SIZE_UNIT (field), size) >= 0\n-\t      && INTVAL (memoffset) >= 0)\n+\t      && INTVAL (attrs.offset) >= 0)\n \t    break;\n \n \t  if (! host_integerp (offset, 1))\n \t    {\n-\t      expr = NULL_TREE;\n+\t      attrs.expr = NULL_TREE;\n \t      break;\n \t    }\n \n-\t  expr = TREE_OPERAND (expr, 0);\n-\t  memoffset\n-\t    = (GEN_INT (INTVAL (memoffset)\n+\t  attrs.expr = TREE_OPERAND (attrs.expr, 0);\n+\t  attrs.offset\n+\t    = (GEN_INT (INTVAL (attrs.offset)\n \t\t\t+ tree_low_cst (offset, 1)\n \t\t\t+ (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n \t\t\t   / BITS_PER_UNIT)));\n \t}\n       /* Similarly for the decl.  */\n-      else if (DECL_P (expr)\n-\t       && DECL_SIZE_UNIT (expr)\n-\t       && TREE_CODE (DECL_SIZE_UNIT (expr)) == INTEGER_CST\n-\t       && compare_tree_int (DECL_SIZE_UNIT (expr), size) >= 0\n-\t       && (! memoffset || INTVAL (memoffset) >= 0))\n+      else if (DECL_P (attrs.expr)\n+\t       && DECL_SIZE_UNIT (attrs.expr)\n+\t       && TREE_CODE (DECL_SIZE_UNIT (attrs.expr)) == INTEGER_CST\n+\t       && compare_tree_int (DECL_SIZE_UNIT (attrs.expr), size) >= 0\n+\t       && (! attrs.offset || INTVAL (attrs.offset) >= 0))\n \tbreak;\n       else\n \t{\n \t  /* The widened memory access overflows the expression, which means\n \t     that it could alias another expression.  Zap it.  */\n-\t  expr = NULL_TREE;\n+\t  attrs.expr = NULL_TREE;\n \t  break;\n \t}\n     }\n \n-  if (! expr)\n-    memoffset = NULL_RTX;\n+  if (! attrs.expr)\n+    attrs.offset = NULL_RTX;\n \n   /* The widened memory may alias other stuff, so zap the alias set.  */\n   /* ??? Maybe use get_alias_set on any remaining expression.  */\n-\n-  MEM_ATTRS (new_rtx) = find_mem_attrs (0, expr, memoffset, GEN_INT (size),\n-\t\t\t\t\tMEM_ALIGN (new_rtx),\n-\t\t\t\t\tMEM_ADDR_SPACE (new_rtx), mode);\n-\n+  attrs.alias = 0;\n+  attrs.size = GEN_INT (size);\n+  set_mem_attrs (new_rtx, &attrs);\n   return new_rtx;\n }\n \f\n@@ -2249,6 +2254,7 @@ get_spill_slot_decl (bool force_build_p)\n {\n   tree d = spill_slot_decl;\n   rtx rd;\n+  struct mem_attrs attrs;\n \n   if (d || !force_build_p)\n     return d;\n@@ -2262,8 +2268,10 @@ get_spill_slot_decl (bool force_build_p)\n \n   rd = gen_rtx_MEM (BLKmode, frame_pointer_rtx);\n   MEM_NOTRAP_P (rd) = 1;\n-  MEM_ATTRS (rd) = find_mem_attrs (new_alias_set (), d, const0_rtx,\n-\t\t\t\t   NULL_RTX, 0, ADDR_SPACE_GENERIC, BLKmode);\n+  attrs = *mode_mem_attrs[(int) BLKmode];\n+  attrs.alias = new_alias_set ();\n+  attrs.expr = d;\n+  set_mem_attrs (rd, &attrs);\n   SET_DECL_RTL (d, rd);\n \n   return d;\n@@ -2278,25 +2286,24 @@ get_spill_slot_decl (bool force_build_p)\n void\n set_mem_attrs_for_spill (rtx mem)\n {\n-  alias_set_type alias;\n-  rtx addr, offset;\n-  tree expr;\n+  struct mem_attrs attrs;\n+  rtx addr;\n \n-  expr = get_spill_slot_decl (true);\n-  alias = MEM_ALIAS_SET (DECL_RTL (expr));\n+  attrs = *get_mem_attrs (mem);\n+  attrs.expr = get_spill_slot_decl (true);\n+  attrs.alias = MEM_ALIAS_SET (DECL_RTL (attrs.expr));\n+  attrs.addrspace = ADDR_SPACE_GENERIC;\n \n   /* We expect the incoming memory to be of the form:\n \t(mem:MODE (plus (reg sfp) (const_int offset)))\n      with perhaps the plus missing for offset = 0.  */\n   addr = XEXP (mem, 0);\n-  offset = const0_rtx;\n+  attrs.offset = const0_rtx;\n   if (GET_CODE (addr) == PLUS\n       && CONST_INT_P (XEXP (addr, 1)))\n-    offset = XEXP (addr, 1);\n+    attrs.offset = XEXP (addr, 1);\n \n-  MEM_ATTRS (mem) = find_mem_attrs (alias, expr, offset,\n-\t\t\t\t    MEM_SIZE (mem), MEM_ALIGN (mem),\n-\t\t\t\t    ADDR_SPACE_GENERIC, GET_MODE (mem));\n+  set_mem_attrs (mem, &attrs);\n   MEM_NOTRAP_P (mem) = 1;\n }\n \f"}]}