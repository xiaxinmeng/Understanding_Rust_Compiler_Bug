{"sha": "ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyN2Y0MGY0ODhjNTkwZDc5NjAzNmZmOWFkMGVlNTcyZDhkOGJmZQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2019-08-22T15:19:58Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2019-08-22T15:19:58Z"}, "message": "[ARM] Remove remaining Neon DImode support\n\nRemove the remaining Neon adddi3, subdi3 and negdi2 patterns.  As a result\nadddi3, subdi3 and negdi2 can now always be expanded early irrespectively of\nwhether Neon is available.  Also expand the extenddi patterns at the same\ntime.  Several Neon arch attributes are no longer used and removed.\n\nCode generation is improved in all cases, saving another 400-500 instructions\nfrom the PR77308 testcase (total improvement is over 1700 instructions with\n-mcpu=cortex-a57 -O2).\n\nBootstrap & regress OK on arm-none-linux-gnueabihf --with-cpu=cortex-a57\n\n    gcc/\n\t* config/arm/arm.md (neon_for_64bits): Remove.\n\t(avoid_neon_for_64bits): Remove.\n\t(arm_adddi3): Always split early.\n\t(arm_subdi3): Always split early.\n\t(negdi2): Remove Neon expansion.\n\t(split zero_extend): Split before reload.\n\t(split sign_extend): Split before reload.\n\nFrom-SVN: r274825", "tree": {"sha": "e646144acbbf0a85890212faf40b4e5fcfa29c3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e646144acbbf0a85890212faf40b4e5fcfa29c3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/comments", "author": null, "committer": null, "parents": [{"sha": "5c7c6c5fc13503b2b71aee34d57370ae03531809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c7c6c5fc13503b2b71aee34d57370ae03531809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c7c6c5fc13503b2b71aee34d57370ae03531809"}], "stats": {"total": 189, "additions": 32, "deletions": 157}, "files": [{"sha": "8984d0e566bd27b081d7058717df1e68f65ce3de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "patch": "@@ -1,3 +1,13 @@\n+2019-08-22  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/arm/arm.md (neon_for_64bits): Remove.\n+\t(avoid_neon_for_64bits): Remove.\n+\t(arm_adddi3): Always split early.\n+\t(arm_subdi3): Always split early.\n+\t(negdi2): Remove Neon expansion.\n+\t(split zero_extend): Split before reload.\n+\t(split sign_extend): Split before reload.\n+\n 2019-08-22  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/arm/iterators.md (qhs_extenddi_cstr): Update."}, {"sha": "ed49c4beda138633a84b58fe345cf5ba99103ab7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 22, "deletions": 68, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "patch": "@@ -125,7 +125,7 @@\n ; arm_arch6.  \"v6t2\" for Thumb-2 with arm_arch6 and \"v8mb\" for ARMv8-M\n ; Baseline.  This attribute is used to compute attribute \"enabled\",\n ; use type \"any\" to enable an alternative in all cases.\n-(define_attr \"arch\" \"any,a,t,32,t1,t2,v6,nov6,v6t2,v8mb,neon_for_64bits,avoid_neon_for_64bits,iwmmxt,iwmmxt2,armv6_or_vfpv3,neon\"\n+(define_attr \"arch\" \"any,a,t,32,t1,t2,v6,nov6,v6t2,v8mb,iwmmxt,iwmmxt2,armv6_or_vfpv3,neon\"\n   (const_string \"any\"))\n \n (define_attr \"arch_enabled\" \"no,yes\"\n@@ -168,16 +168,6 @@\n \t      (match_test \"TARGET_THUMB1 && arm_arch8\"))\n \t (const_string \"yes\")\n \n-\t (and (eq_attr \"arch\" \"avoid_neon_for_64bits\")\n-\t      (match_test \"TARGET_NEON\")\n-\t      (not (match_test \"TARGET_PREFER_NEON_64BITS\")))\n-\t (const_string \"yes\")\n-\n-\t (and (eq_attr \"arch\" \"neon_for_64bits\")\n-\t      (match_test \"TARGET_NEON\")\n-\t      (match_test \"TARGET_PREFER_NEON_64BITS\"))\n-\t (const_string \"yes\")\n-\n \t (and (eq_attr \"arch\" \"iwmmxt2\")\n \t      (match_test \"TARGET_REALLY_IWMMXT2\"))\n \t (const_string \"yes\")\n@@ -450,13 +440,8 @@\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n-  if (TARGET_THUMB1)\n-    {\n-      if (!REG_P (operands[1]))\n-        operands[1] = force_reg (DImode, operands[1]);\n-      if (!REG_P (operands[2]))\n-        operands[2] = force_reg (DImode, operands[2]);\n-     }\n+  if (TARGET_THUMB1 && !REG_P (operands[2]))\n+    operands[2] = force_reg (DImode, operands[2]);\n   \"\n )\n \n@@ -465,9 +450,9 @@\n \t(plus:DI (match_operand:DI 1 \"arm_general_register_operand\" \"%0, 0, r, 0, r\")\n \t\t (match_operand:DI 2 \"arm_general_adddi_operand\"    \"r,  0, r, Dd, Dd\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT && !TARGET_NEON\"\n+  \"TARGET_32BIT\"\n   \"#\"\n-  \"TARGET_32BIT && ((!TARGET_NEON && !TARGET_IWMMXT) || reload_completed)\"\n+  \"TARGET_32BIT\"\n   [(parallel [(set (reg:CC_C CC_REGNUM)\n \t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n \t\t\t\t (match_dup 1)))\n@@ -1304,24 +1289,16 @@\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n-  if (TARGET_THUMB1)\n-    {\n-      if (!REG_P (operands[1]))\n-        operands[1] = force_reg (DImode, operands[1]);\n-      if (!REG_P (operands[2]))\n-        operands[2] = force_reg (DImode, operands[2]);\n-     }\t\n-  \"\n-)\n+\")\n \n (define_insn_and_split \"*arm_subdi3\"\n   [(set (match_operand:DI           0 \"arm_general_register_operand\" \"=&r,&r,&r\")\n \t(minus:DI (match_operand:DI 1 \"arm_general_register_operand\" \"0,r,0\")\n \t\t  (match_operand:DI 2 \"arm_general_register_operand\" \"r,0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT && !TARGET_NEON\"\n+  \"TARGET_32BIT\"\n   \"#\"  ; \"subs\\\\t%Q0, %Q1, %Q2\\;sbc\\\\t%R0, %R1, %R2\"\n-  \"&& (!TARGET_IWMMXT || reload_completed)\"\n+  \"TARGET_32BIT\"\n   [(parallel [(set (reg:CC CC_REGNUM)\n \t\t   (compare:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])\n@@ -4184,13 +4161,6 @@\n \t (neg:DI (match_operand:DI 1 \"s_register_operand\")))\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n-  {\n-    if (TARGET_NEON)\n-      {\n-        emit_insn (gen_negdi2_neon (operands[0], operands[1]));\n-\tDONE;\n-      }\n-  }\n )\n \n ;; The constraints here are to prevent a *partial* overlap (where %Q0 == %R1).\n@@ -4202,7 +4172,7 @@\n   \"TARGET_32BIT\"\n   \"#\"\t; rsbs %Q0, %Q1, #0; rsc %R0, %R1, #0\t       (ARM)\n \t; negs %Q0, %Q1    ; sbc %R0, %R1, %R1, lsl #1 (Thumb-2)\n-  \"&& reload_completed\"\n+  \"TARGET_32BIT\"\n   [(parallel [(set (reg:CC CC_REGNUM)\n \t\t   (compare:CC (const_int 0) (match_dup 1)))\n \t      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])\n@@ -4734,52 +4704,36 @@\n (define_split\n   [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n         (zero_extend:DI (match_operand 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_32BIT && reload_completed && !IS_VFP_REGNUM (REGNO (operands[0]))\"\n+  \"TARGET_32BIT\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n   rtx lo_part = gen_lowpart (SImode, operands[0]);\n   machine_mode src_mode = GET_MODE (operands[1]);\n \n-  if (REG_P (operands[0])\n-      && !reg_overlap_mentioned_p (operands[0], operands[1]))\n-    emit_clobber (operands[0]);\n-  if (!REG_P (lo_part) || src_mode != SImode\n-      || !rtx_equal_p (lo_part, operands[1]))\n-    {\n-      if (src_mode == SImode)\n-        emit_move_insn (lo_part, operands[1]);\n-      else\n-        emit_insn (gen_rtx_SET (lo_part,\n-\t\t\t\tgen_rtx_ZERO_EXTEND (SImode, operands[1])));\n-      operands[1] = lo_part;\n-    }\n+  if (src_mode == SImode)\n+    emit_move_insn (lo_part, operands[1]);\n+  else\n+    emit_insn (gen_rtx_SET (lo_part,\n+\t\t\t    gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n   operands[0] = gen_highpart (SImode, operands[0]);\n   operands[1] = const0_rtx;\n })\n \n (define_split\n   [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n         (sign_extend:DI (match_operand 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_32BIT && reload_completed && !IS_VFP_REGNUM (REGNO (operands[0]))\"\n+  \"TARGET_32BIT\"\n   [(set (match_dup 0) (ashiftrt:SI (match_dup 1) (const_int 31)))]\n {\n   rtx lo_part = gen_lowpart (SImode, operands[0]);\n   machine_mode src_mode = GET_MODE (operands[1]);\n \n-  if (REG_P (operands[0])\n-      && !reg_overlap_mentioned_p (operands[0], operands[1]))\n-    emit_clobber (operands[0]);\n-\n-  if (!REG_P (lo_part) || src_mode != SImode\n-      || !rtx_equal_p (lo_part, operands[1]))\n-    {\n-      if (src_mode == SImode)\n-        emit_move_insn (lo_part, operands[1]);\n-      else\n-        emit_insn (gen_rtx_SET (lo_part,\n-\t\t\t\tgen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-      operands[1] = lo_part;\n-    }\n+  if (src_mode == SImode)\n+    emit_move_insn (lo_part, operands[1]);\n+  else\n+    emit_insn (gen_rtx_SET (lo_part,\n+\t\t\t    gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n+  operands[1] = lo_part;\n   operands[0] = gen_highpart (SImode, operands[0]);\n })\n "}, {"sha": "0c1ee746b6ada4f83040cd1717f17bef03dc2264", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef27f40f488c590d796036ff9ad0ee572d8d8bfe/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=ef27f40f488c590d796036ff9ad0ee572d8d8bfe", "patch": "@@ -527,32 +527,6 @@\n     (const_string \"neon_add<q>\")))]\n )\n \n-(define_insn \"adddi3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,?&r,?&r,?w,?&r,?&r,?&r\")\n-        (plus:DI (match_operand:DI 1 \"s_register_operand\" \"%w,0,0,w,r,0,r\")\n-                 (match_operand:DI 2 \"arm_adddi_operand\"     \"w,r,0,w,r,Dd,Dd\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_NEON\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: /* fall through */\n-    case 3: return \"vadd.i64\\t%P0, %P1, %P2\";\n-    case 1: return \"#\";\n-    case 2: return \"#\";\n-    case 4: return \"#\";\n-    case 5: return \"#\";\n-    case 6: return \"#\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"neon_add,multiple,multiple,neon_add,\\\n-\t\t     multiple,multiple,multiple\")\n-   (set_attr \"conds\" \"*,clob,clob,*,clob,clob,clob\")\n-   (set_attr \"length\" \"*,8,8,*,8,8,8\")\n-   (set_attr \"arch\" \"neon_for_64bits,*,*,avoid_neon_for_64bits,*,*,*\")]\n-)\n-\n (define_insn \"*sub<mode>3_neon\"\n   [(set (match_operand:VDQ 0 \"s_register_operand\" \"=w\")\n         (minus:VDQ (match_operand:VDQ 1 \"s_register_operand\" \"w\")\n@@ -587,29 +561,6 @@\n  [(set_attr \"type\" \"neon_sub<q>\")]\n )\n \n-(define_insn \"subdi3_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=w,?&r,?&r,?&r,?w\")\n-        (minus:DI (match_operand:DI 1 \"s_register_operand\" \"w,0,r,0,w\")\n-                  (match_operand:DI 2 \"s_register_operand\" \"w,r,0,0,w\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_NEON\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: /* fall through */\n-    case 4: return \"vsub.i64\\t%P0, %P1, %P2\";\n-    case 1: /* fall through */ \n-    case 2: /* fall through */\n-    case 3: return  \"subs\\\\t%Q0, %Q1, %Q2\\;sbc\\\\t%R0, %R1, %R2\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"neon_sub,multiple,multiple,multiple,neon_sub\")\n-   (set_attr \"conds\" \"*,clob,clob,clob,*\")\n-   (set_attr \"length\" \"*,8,8,8,*\")\n-   (set_attr \"arch\" \"neon_for_64bits,*,*,*,avoid_neon_for_64bits\")]\n-)\n-\n (define_insn \"*mul<mode>3_neon\"\n   [(set (match_operand:VDQW 0 \"s_register_operand\" \"=w\")\n         (mult:VDQW (match_operand:VDQW 1 \"s_register_operand\" \"w\")\n@@ -886,46 +837,6 @@\n                     (const_string \"neon_neg<q>\")))]\n )\n \n-(define_insn \"negdi2_neon\"\n-  [(set (match_operand:DI 0 \"s_register_operand\"\t \"=&w, w,r,&r\")\n-\t(neg:DI (match_operand:DI 1 \"s_register_operand\" \"  w, w,0, r\")))\n-   (clobber (match_scratch:DI 2\t\t\t\t \"= X,&w,X, X\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_NEON\"\n-  \"#\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-; Split negdi2_neon for vfp registers\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(neg:DI (match_operand:DI 1 \"s_register_operand\" \"\")))\n-   (clobber (match_scratch:DI 2 \"\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_NEON && reload_completed && IS_VFP_REGNUM (REGNO (operands[0]))\"\n-  [(set (match_dup 2) (const_int 0))\n-   (parallel [(set (match_dup 0) (minus:DI (match_dup 2) (match_dup 1)))\n-\t      (clobber (reg:CC CC_REGNUM))])]\n-  {\n-    if (!REG_P (operands[2]))\n-      operands[2] = operands[0];\n-  }\n-)\n-\n-; Split negdi2_neon for core registers\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(neg:DI (match_operand:DI 1 \"s_register_operand\" \"\")))\n-   (clobber (match_scratch:DI 2 \"\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT && reload_completed\n-   && arm_general_register_operand (operands[0], DImode)\"\n-  [(parallel [(set (match_dup 0) (neg:DI (match_dup 1)))\n-\t      (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"<absneg_str><mode>2\"\n   [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n     (ABSNEG:VH (match_operand:VH 1 \"s_register_operand\" \"w\")))]"}]}