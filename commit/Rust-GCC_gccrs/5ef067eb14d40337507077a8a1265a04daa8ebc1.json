{"sha": "5ef067eb14d40337507077a8a1265a04daa8ebc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVmMDY3ZWIxNGQ0MDMzNzUwNzA3N2E4YTEyNjVhMDRkYWE4ZWJjMQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-05-16T18:23:19Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-05-16T18:59:39Z"}, "message": "coroutines: Implicitly movable objects should use move CTORs for co_return.\n\nThis is a case where the standard contains conflicting information.\nafter discussion between implementators, the accepted intent is of\n[class.copy.elision].  This amends the handling of co_return statements\nto follow that.\n\ngcc/cp/ChangeLog:\n\n2020-05-16  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc (finish_co_return_stmt): Implement rules\n\tfrom [class.copy.elision] /3.\n\ngcc/testsuite/ChangeLog:\n\n2020-05-16  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/co-return-syntax-10-movable.C: New test.", "tree": {"sha": "d4247ec8bedb4a0a57bf11c3c6b85787de9b9421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4247ec8bedb4a0a57bf11c3c6b85787de9b9421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ef067eb14d40337507077a8a1265a04daa8ebc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ef067eb14d40337507077a8a1265a04daa8ebc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ef067eb14d40337507077a8a1265a04daa8ebc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ef067eb14d40337507077a8a1265a04daa8ebc1/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5b461d453043c6b6dda50db0439e4c78b241f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b461d453043c6b6dda50db0439e4c78b241f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b461d453043c6b6dda50db0439e4c78b241f03"}], "stats": {"total": 185, "additions": 150, "deletions": 35}, "files": [{"sha": "7ac074a19b6ff09077f3e00faf5f51c5591f517a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5ef067eb14d40337507077a8a1265a04daa8ebc1", "patch": "@@ -1,3 +1,8 @@\n+2020-05-16  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc (finish_co_return_stmt): Implement rules\n+\tfrom [class.copy.elision] /3.\n+\n 2020-05-16  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/57943"}, {"sha": "facfafaaa86c7332beb94b14f16f30968cae63ad", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 74, "deletions": 35, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=5ef067eb14d40337507077a8a1265a04daa8ebc1", "patch": "@@ -969,16 +969,23 @@ finish_co_yield_expr (location_t kw, tree expr)\n   return op;\n }\n \n-/* Check that it's valid to have a co_return keyword here.\n+/* Check and build a co_return statememt.\n+   First that it's valid to have a co_return keyword here.\n    If it is, then check and build the p.return_{void(),value(expr)}.\n-   These are built against the promise proxy, but saved for expand time.  */\n+   These are built against a proxy for the promise, which will be filled\n+   in with the actual frame version when the function is transformed.  */\n \n tree\n finish_co_return_stmt (location_t kw, tree expr)\n {\n-  if (expr == error_mark_node)\n+  if (expr)\n+    STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n+  if (error_operand_p (expr))\n     return error_mark_node;\n \n+  /* If it fails the following test, the function is not permitted to be a\n+     coroutine, so the co_return statement is erroneous.  */\n   if (!coro_common_keyword_context_valid_p (current_function_decl, kw,\n \t\t\t\t\t    \"co_return\"))\n     return error_mark_node;\n@@ -987,49 +994,62 @@ finish_co_return_stmt (location_t kw, tree expr)\n      already.  */\n   DECL_COROUTINE_P (current_function_decl) = 1;\n \n-  if (processing_template_decl)\n-    {\n-      current_function_returns_value = 1;\n+  /* This function will appear to have no return statement, even if it\n+     is declared to return non-void (most likely).  This is correct - we\n+     synthesize the return for the ramp in the compiler.  So suppress any\n+     extraneous warnings during substitution.  */\n+  TREE_NO_WARNING (current_function_decl) = true;\n \n-      if (check_for_bare_parameter_packs (expr))\n-\treturn error_mark_node;\n+  if (processing_template_decl\n+      && check_for_bare_parameter_packs (expr))\n+    return error_mark_node;\n \n-      tree functype = TREE_TYPE (current_function_decl);\n-      /* If we don't know the promise type, we can't proceed, return the\n-\t expression as it is.  */\n-      if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n-\t{\n-\t  expr\n-\t    = build2_loc (kw, CO_RETURN_EXPR, void_type_node, expr, NULL_TREE);\n-\t  expr = maybe_cleanup_point_expr_void (expr);\n-\t  expr = add_stmt (expr);\n-\t  return expr;\n-\t}\n+  /* If we don't know the promise type, we can't proceed, build the\n+     co_return with the expression unchanged.  */\n+  tree functype = TREE_TYPE (current_function_decl);\n+  if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n+    {\n+      /* co_return expressions are always void type, regardless of the\n+\t expression type.  */\n+      expr = build2_loc (kw, CO_RETURN_EXPR, void_type_node,\n+\t\t\t expr, NULL_TREE);\n+      expr = maybe_cleanup_point_expr_void (expr);\n+      return add_stmt (expr);\n     }\n \n   if (!coro_promise_type_found_p (current_function_decl, kw))\n     return error_mark_node;\n \n-  if (error_operand_p (expr))\n-    return error_mark_node;\n-\n   /* Suppress -Wreturn-type for co_return, we need to check indirectly\n      whether the promise type has a suitable return_void/return_value.  */\n   TREE_NO_WARNING (current_function_decl) = true;\n \n   if (!processing_template_decl && warn_sequence_point)\n     verify_sequence_points (expr);\n \n+  if (expr)\n+    {\n+      /* If we had an id-expression obfuscated by force_paren_expr, we need\n+\t to undo it so we can try to treat it as an rvalue below.  */\n+      expr = maybe_undo_parenthesized_ref (expr);\n+\n+      if (processing_template_decl)\n+\texpr = build_non_dependent_expr (expr);\n+\n+      if (error_operand_p (expr))\n+\treturn error_mark_node;\n+    }\n+\n   /* If the promise object doesn't have the correct return call then\n      there's a mis-match between the co_return <expr> and this.  */\n-  tree co_ret_call = NULL_TREE;\n+  tree co_ret_call = error_mark_node;\n   if (expr == NULL_TREE || VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n       tree crv_meth\n \t= lookup_promise_method (current_function_decl,\n \t\t\t\t coro_return_void_identifier, kw,\n \t\t\t\t /*musthave=*/true);\n-      if (!crv_meth || crv_meth == error_mark_node)\n+      if (crv_meth == error_mark_node)\n \treturn error_mark_node;\n \n       co_ret_call = build_new_method_call (\n@@ -1042,13 +1062,37 @@ finish_co_return_stmt (location_t kw, tree expr)\n \t= lookup_promise_method (current_function_decl,\n \t\t\t\t coro_return_value_identifier, kw,\n \t\t\t\t /*musthave=*/true);\n-      if (!crv_meth || crv_meth == error_mark_node)\n+      if (crv_meth == error_mark_node)\n \treturn error_mark_node;\n \n-      vec<tree, va_gc> *args = make_tree_vector_single (expr);\n-      co_ret_call = build_new_method_call (\n-\tget_coroutine_promise_proxy (current_function_decl), crv_meth, &args,\n-\tNULL_TREE, LOOKUP_NORMAL, NULL, tf_warning_or_error);\n+      /* [class.copy.elision] / 3.\n+\t An implicitly movable entity is a variable of automatic storage\n+\t duration that is either a non-volatile object or an rvalue reference\n+\t to a non-volatile object type.  For such objects in the context of\n+\t the co_return, the overload resolution should be carried out first\n+\t treating the object as an rvalue, if that fails, then we fall back\n+\t to regular overload resolution.  */\n+\n+      if (treat_lvalue_as_rvalue_p (expr, /*parm_ok*/true)\n+\t  && CLASS_TYPE_P (TREE_TYPE (expr))\n+\t  && !TYPE_VOLATILE (TREE_TYPE (expr)))\n+\t{\n+\t  vec<tree, va_gc> *args = make_tree_vector_single (move (expr));\n+\t  /* It's OK if this fails... */\n+\t  co_ret_call = build_new_method_call\n+\t    (get_coroutine_promise_proxy (current_function_decl), crv_meth,\n+\t     &args, NULL_TREE, LOOKUP_NORMAL|LOOKUP_PREFER_RVALUE,\n+\t     NULL, tf_none);\n+\t}\n+\n+      if (co_ret_call == error_mark_node)\n+\t{\n+\t  vec<tree, va_gc> *args = make_tree_vector_single (expr);\n+\t  /* ... but this must succeed if we didn't get the move variant.  */\n+\t  co_ret_call = build_new_method_call\n+\t    (get_coroutine_promise_proxy (current_function_decl), crv_meth,\n+\t     &args, NULL_TREE, LOOKUP_NORMAL, NULL, tf_warning_or_error);\n+\t}\n     }\n \n   /* Makes no sense for a co-routine really. */\n@@ -1057,13 +1101,8 @@ finish_co_return_stmt (location_t kw, tree expr)\n \t\t\"function declared %<noreturn%> has a\"\n \t\t\" %<co_return%> statement\");\n \n-  if (!co_ret_call || co_ret_call == error_mark_node)\n-    return error_mark_node;\n-\n   expr = build2_loc (kw, CO_RETURN_EXPR, void_type_node, expr, co_ret_call);\n-  expr = maybe_cleanup_point_expr_void (expr);\n-  expr = add_stmt (expr);\n-  return expr;\n+  return finish_expr_stmt (expr);\n }\n \n /* We need to validate the arguments to __builtin_coro_promise, since the"}, {"sha": "9d757c47e19214c35c6012e3302d6c767225c5ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ef067eb14d40337507077a8a1265a04daa8ebc1", "patch": "@@ -1,3 +1,7 @@\n+2020-05-16  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/co-return-syntax-10-movable.C: New test.\n+\n 2020-05-16  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/57943"}, {"sha": "e2c47a9ec1b2fb1c26195552334f59e3e1958779", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-10-movable.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-10-movable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ef067eb14d40337507077a8a1265a04daa8ebc1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-10-movable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-10-movable.C?ref=5ef067eb14d40337507077a8a1265a04daa8ebc1", "patch": "@@ -0,0 +1,67 @@\n+// Check that we obey the extra rules for implicitly movable co_return\n+// objects [class.copy.elision]/3.\n+\n+#include \"coro.h\"\n+\n+#include  <utility>\n+\n+template <typename T>\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) { }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) { s.handle = nullptr;  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    return *this;\n+  }\n+  ~coro1() {\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct promise_type {\n+  T value;\n+  promise_type() {}\n+  ~promise_type() {}\n+\n+  auto get_return_object () { return handle_type::from_promise (*this);}\n+  coro::suspend_always initial_suspend () const { return {}; }\n+  coro::suspend_always final_suspend () const {  return {}; }\n+\n+  void return_value(T&& v) noexcept { value = std::move(v); }\n+  \n+  T get_value (void) { return value; }\n+  void unhandled_exception() { }\n+  };\n+};\n+\n+struct MoveOnlyType \n+{\n+  int value_;\n+\n+  explicit MoveOnlyType() noexcept : value_(0) {}\n+  explicit MoveOnlyType(int value) noexcept : value_(value) {}\n+\n+  MoveOnlyType(MoveOnlyType&& other) noexcept\n+      : value_(std::exchange(other.value_, -1)) {}\n+\n+  MoveOnlyType& operator=(MoveOnlyType&& other) noexcept {\n+    value_ = std::exchange(other.value_, -1);\n+    return *this;\n+  }\n+\n+  ~MoveOnlyType() { value_ = -2; }\n+};\n+\n+coro1<MoveOnlyType> \n+my_coro ()\n+{\n+  MoveOnlyType x{10};\n+  co_return x;\n+}"}]}