{"sha": "badd9e6941c34112f782bf955877fe041dd20cc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkZDllNjk0MWMzNDExMmY3ODJiZjk1NTg3N2ZlMDQxZGQyMGNjNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-07-16T17:31:13Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-07-16T17:31:13Z"}, "message": "expr.c (gfc_ref_this_image): New function.\n\n2011-07-16  Tobias Burnus  <burnus@net-b.de>\n\n        * expr.c (gfc_ref_this_image): New function.\n        (gfc_is_coindexed): Use it.\n        * gfortran.h (gfc_ref_this_image): New prototype.\n        * resolve.c (resolve_deallocate_expr,\n        resolve_allocate_expr): Support alloc scalar coarrays.\n        * trans-array.c (gfc_conv_array_ref, gfc_array_init_size,\n        gfc_conv_descriptor_cosize, gfc_array_allocate,\n        gfc_trans_deferred_array): Ditto.\n        * trans-expr.c (gfc_conv_variable) Ditto.:\n        * trans-stmt.c (gfc_trans_deallocate): Ditto.\n        * trans-types.c (gfc_get_element_type, gfc_get_array_type_bounds\n        gfc_get_array_descr_info): Ditto.\n        * trans-decl.c (gfc_get_symbol_decl): Ditto.\n\n2011-07-16  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_14.f90: Remove dg-error \"sorry not\n        * implemented\".\n        * gfortran.dg/coarray_7.f90: Ditto.\n        * gfortran.dg/coarray/scalar_alloc_1.f90: New.\n        * gfortran.dg/coarray/scalar_alloc_2.f90: New.\n\nFrom-SVN: r176358", "tree": {"sha": "b24dfbdc16df4c03a65f16b253941afeb464c428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b24dfbdc16df4c03a65f16b253941afeb464c428"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/badd9e6941c34112f782bf955877fe041dd20cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badd9e6941c34112f782bf955877fe041dd20cc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/badd9e6941c34112f782bf955877fe041dd20cc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badd9e6941c34112f782bf955877fe041dd20cc4/comments", "author": null, "committer": null, "parents": [{"sha": "0fa714476569f264d2b40130d06ba2b16cecdb3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa714476569f264d2b40130d06ba2b16cecdb3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fa714476569f264d2b40130d06ba2b16cecdb3e"}], "stats": {"total": 315, "additions": 257, "deletions": 58}, "files": [{"sha": "4321c2fb061a15d0ddd05306ccd8f8a00a3f0894", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -1,3 +1,19 @@\n+2011-07-16  Tobias Burnus  <burnus@net-b.de>\n+\t\n+\t* expr.c (gfc_ref_this_image): New function.\n+\t(gfc_is_coindexed): Use it.\n+\t* gfortran.h (gfc_ref_this_image): New prototype.\n+\t* resolve.c (resolve_deallocate_expr,\n+\tresolve_allocate_expr): Support alloc scalar coarrays.\n+\t* trans-array.c (gfc_conv_array_ref, gfc_array_init_size,\n+\tgfc_conv_descriptor_cosize, gfc_array_allocate,\n+\tgfc_trans_deferred_array): Ditto.\n+\t* trans-expr.c (gfc_conv_variable) Ditto.:\n+\t* trans-stmt.c (gfc_trans_deallocate): Ditto.\n+\t* trans-types.c (gfc_get_element_type, gfc_get_array_type_bounds\n+\tgfc_get_array_descr_info): Ditto.\n+\t* trans-decl.c (gfc_get_symbol_decl): Ditto.\n+\n 2011-07-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/49698\n@@ -26,7 +42,7 @@\n \t* trans.c (gfc_allocate_with_status): Call _gfortran_caf_register\n \twith NULL arguments for (new) stat=/errmsg= arguments.\n \n-2011-07-06  Daniel Carrera <dcarrera@gmail.com>\n+2011-07-06  Daniel Carrera  <dcarrera@gmail.com>\n \n \t* trans-array.c (gfc_array_allocate): Rename allocatable_array to\n \tallocatable. Rename function gfc_allocate_array_with_status to"}, {"sha": "3bf1e94bda88317d679dd22658d32e5c800d5569", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -4125,19 +4125,29 @@ gfc_expr_replace_comp (gfc_expr *expr, gfc_component *dest)\n }\n \n \n+bool\n+gfc_ref_this_image (gfc_ref *ref)\n+{\n+  int n;\n+\n+  gcc_assert (ref->type == REF_ARRAY && ref->u.ar.codimen > 0);\n+\n+  for (n = ref->u.ar.dimen; n < ref->u.ar.dimen + ref->u.ar.codimen; n++)\n+    if (ref->u.ar.dimen_type[n] != DIMEN_THIS_IMAGE)\n+      return false;\n+\n+  return true;\n+}\n+\n+\n bool\n gfc_is_coindexed (gfc_expr *e)\n {\n   gfc_ref *ref;\n \n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n-      {\n-\tint n;\n-\tfor (n = ref->u.ar.dimen; n < ref->u.ar.dimen + ref->u.ar.codimen; n++)\n-\t  if (ref->u.ar.dimen_type[n] != DIMEN_THIS_IMAGE)\n-\t    return true;\n-      }\n+      return !gfc_ref_this_image (ref);\n \n   return false;\n }"}, {"sha": "eb01b0e3d470decc5a65cdd6978ecf7e05ccf0a1", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -2733,6 +2733,7 @@ void gfc_expr_replace_comp (gfc_expr *, gfc_component *);\n \n bool gfc_is_proc_ptr_comp (gfc_expr *, gfc_component **);\n \n+bool gfc_ref_this_image (gfc_ref *ref);\n bool gfc_is_coindexed (gfc_expr *);\n int gfc_get_corank (gfc_expr *);\n bool gfc_has_ultimate_allocatable (gfc_expr *);"}, {"sha": "07104b85ea4bb118f127d3923d13970ef2c500ed", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -6460,7 +6460,9 @@ resolve_deallocate_expr (gfc_expr *e)\n       switch (ref->type)\n \t{\n \tcase REF_ARRAY:\n-\t  if (ref->u.ar.type != AR_FULL)\n+\t  if (ref->u.ar.type != AR_FULL\n+\t      && !(ref->u.ar.type == AR_ELEMENT && ref->u.ar.as->rank == 0\n+\t           && ref->u.ar.codimen && gfc_ref_this_image (ref)))\n \t    allocatable = 0;\n \t  break;\n \n@@ -6983,13 +6985,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       goto failure;\n     }\n \n-  if (codimension && ar->as->rank == 0)\n-    {\n-      gfc_error (\"Sorry, allocatable scalar coarrays are not yet supported \"\n-\t\t \"at %L\", &e->where);\n-      goto failure;\n-    }\n-\n success:\n   return SUCCESS;\n "}, {"sha": "4ec892b74c7dbed171cc3aa831b8d7d83e406d79", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -2623,12 +2623,20 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n   if (ar->dimen == 0)\n     {\n       gcc_assert (ar->codimen);\n-      if (GFC_ARRAY_TYPE_P (TREE_TYPE (se->expr))\n-\t  && TREE_CODE (TREE_TYPE (se->expr)) == POINTER_TYPE)\n-\tse->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n \n-      /* Use the actual tree type and not the wrapped coarray. */\n-      se->expr = fold_convert (TYPE_MAIN_VARIANT (TREE_TYPE (se->expr)), se->expr);\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se->expr)))\n+\tse->expr = build_fold_indirect_ref (gfc_conv_array_data (se->expr));\n+      else\n+\t{\n+\t  if (GFC_ARRAY_TYPE_P (TREE_TYPE (se->expr))\n+\t      && TREE_CODE (TREE_TYPE (se->expr)) == POINTER_TYPE)\n+\t    se->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n+\t\n+\t  /* Use the actual tree type and not the wrapped coarray. */\n+\t  se->expr = fold_convert (TYPE_MAIN_VARIANT (TREE_TYPE (se->expr)),\n+\t\t\t\t   se->expr);\n+\t}\n+\n       return;\n     }\n \n@@ -4139,7 +4147,11 @@ gfc_conv_descriptor_cosize (tree desc, int rank, int corank)\n \toverflow += size == 0 ? 0: (MAX/size < stride ? 1: 0);\n \tstride = stride * size;\n       }\n+    for (n = rank; n < rank+corank; n++)\n+      (Set lcobound/ucobound as above.)\n     element_size = sizeof (array element);\n+    if (!rank)\n+      return element_size\n     stride = (size_t) stride;\n     overflow += element_size == 0 ? 0: (MAX/element_size < stride ? 1: 0);\n     stride = stride * element_size;\n@@ -4309,6 +4321,10 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n   /* Convert to size_t.  */\n   element_size = fold_convert (size_type_node, tmp);\n+\n+  if (rank == 0)\n+    return element_size;\n+\n   stride = fold_convert (size_type_node, stride);\n \n   /* First check for overflow. Since an array of type character can\n@@ -4370,18 +4386,18 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n {\n   tree tmp;\n   tree pointer;\n-  tree offset;\n+  tree offset = NULL_TREE;\n   tree size;\n   tree msg;\n-  tree error;\n+  tree error = NULL_TREE;\n   tree overflow; /* Boolean storing whether size calculation overflows.  */\n-  tree var_overflow;\n+  tree var_overflow = NULL_TREE;\n   tree cond;\n   stmtblock_t elseblock;\n   gfc_expr **lower;\n   gfc_expr **upper;\n   gfc_ref *ref, *prev_ref = NULL;\n-  bool allocatable, coarray;\n+  bool allocatable, coarray, dimension;\n \n   ref = expr->ref;\n \n@@ -4401,20 +4417,17 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n     {\n       allocatable = expr->symtree->n.sym->attr.allocatable;\n       coarray = expr->symtree->n.sym->attr.codimension;\n+      dimension = expr->symtree->n.sym->attr.dimension;\n     }\n   else\n     {\n       allocatable = prev_ref->u.c.component->attr.allocatable;\n       coarray = prev_ref->u.c.component->attr.codimension;\n+      dimension = prev_ref->u.c.component->attr.dimension;\n     }\n \n-  /* Return if this is a scalar coarray.  */\n-  if ((!prev_ref && !expr->symtree->n.sym->attr.dimension)\n-      || (prev_ref && !prev_ref->u.c.component->attr.dimension))\n-    {\n-      gcc_assert (coarray);\n-      return false;\n-    }\n+  if (!dimension)\n+    gcc_assert (coarray);\n \n   /* Figure out the size of the array.  */\n   switch (ref->u.ar.type)\n@@ -4449,16 +4462,20 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n \t\t\t      &se->pre, &overflow);\n+  if (dimension)\n+    {\n \n-  var_overflow = gfc_create_var (integer_type_node, \"overflow\");\n-  gfc_add_modify (&se->pre, var_overflow, overflow);\n+      var_overflow = gfc_create_var (integer_type_node, \"overflow\");\n+      gfc_add_modify (&se->pre, var_overflow, overflow);\n \n-  /* Generate the block of code handling overflow.  */\n-  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n+      /* Generate the block of code handling overflow.  */\n+      msg = gfc_build_addr_expr (pchar_type_node,\n+\t\tgfc_build_localized_cstring_const\n   \t\t\t(\"Integer overflow when calculating the amount of \"\n   \t\t\t \"memory to allocate\"));\n-  error = build_call_expr_loc (input_location,\n-  \t\t\t   gfor_fndecl_runtime_error, 1, msg);\n+      error = build_call_expr_loc (input_location, gfor_fndecl_runtime_error,\n+\t\t\t\t   1, msg);\n+    }\n \n   if (pstat != NULL_TREE && !integer_zerop (pstat))\n     {\n@@ -4495,14 +4512,20 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n \n   gfc_add_expr_to_block (&elseblock, tmp);\n \n-  cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t\t\tvar_overflow, integer_zero_node));\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, \n-\t\t\t error, gfc_finish_block (&elseblock));\n+  if (dimension)\n+    {\n+      cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t   boolean_type_node, var_overflow, integer_zero_node));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, \n+\t\t\t     error, gfc_finish_block (&elseblock));\n+    }\n+  else\n+    tmp = gfc_finish_block (&elseblock);\n \n   gfc_add_expr_to_block (&se->pre, tmp);\n \n-  gfc_conv_descriptor_offset_set (&se->pre, se->expr, offset);\n+  if (dimension)\n+    gfc_conv_descriptor_offset_set (&se->pre, se->expr, offset);\n \n   if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)\n \t&& expr->ts.u.derived->attr.alloc_comp)\n@@ -7446,7 +7469,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n       gfc_add_expr_to_block (&cleanup, tmp);\n     }\n \n-  if (sym->attr.allocatable && sym->attr.dimension\n+  if (sym->attr.allocatable && (sym->attr.dimension || sym->attr.codimension)\n       && !sym->attr.save && !sym->attr.result)\n     {\n       tmp = gfc_trans_dealloc_allocated (sym->backend_decl);"}, {"sha": "96aefa33c4dab15f421196b174da91a93ba2a993", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -1425,15 +1425,18 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       && (sym->attr.save || sym->ns->proc_name->attr.is_main_program\n \t  || gfc_option.flag_max_stack_var_size == 0\n \t  || sym->attr.data || sym->ns->proc_name->attr.flavor == FL_MODULE)\n-      && (gfc_option.coarray != GFC_FCOARRAY_LIB || !sym->attr.codimension))\n+      && (gfc_option.coarray != GFC_FCOARRAY_LIB\n+\t  || !sym->attr.codimension || sym->attr.allocatable))\n     {\n       /* Add static initializer. For procedures, it is only needed if\n \t SAVE is specified otherwise they need to be reinitialized\n \t every time the procedure is entered. The TREE_STATIC is\n \t in this case due to -fmax-stack-var-size=.  */\n       DECL_INITIAL (decl) = gfc_conv_initializer (sym->value, &sym->ts,\n \t\t\t\t\t\t  TREE_TYPE (decl),\n-\t\t\t\t\t\t  sym->attr.dimension,\n+\t\t\t\t\t\t  sym->attr.dimension\n+\t\t\t\t\t\t  || (sym->attr.codimension\n+\t\t\t\t\t\t      && sym->attr.allocatable),\n \t\t\t\t\t\t  sym->attr.pointer\n \t\t\t\t\t\t  || sym->attr.allocatable,\n \t\t\t\t\t\t  sym->attr.proc_pointer);"}, {"sha": "55a0fc499dffbea7127a831de2b8bf713a809df0", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -691,8 +691,9 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t}\n       else if (!sym->attr.value)\n \t{\n-          /* Dereference non-character scalar dummy arguments.  */\n-\t  if (sym->attr.dummy && !sym->attr.dimension)\n+\t  /* Dereference non-character scalar dummy arguments.  */\n+\t  if (sym->attr.dummy && !sym->attr.dimension\n+\t      && !(sym->attr.codimension && sym->attr.allocatable))\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n@@ -711,7 +712,8 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t      && (sym->attr.dummy\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result\n-\t\t  || !sym->attr.dimension))\n+\t\t  || (!sym->attr.dimension\n+\t\t      && (!sym->attr.codimension || !sym->attr.allocatable))))\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \t}"}, {"sha": "1da3a067ea5243571a4a4e131a33d3074409a6af", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -5104,7 +5104,7 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (expr->rank)\n+      if (expr->rank || gfc_expr_attr (expr).codimension)\n \t{\n \t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n \t    {"}, {"sha": "d7f1dd51683d5e63cbd8730e7ca4f275a6394540", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -1125,8 +1125,9 @@ gfc_get_element_type (tree type)\n       gcc_assert (TREE_CODE (element) == POINTER_TYPE);\n       element = TREE_TYPE (element);\n \n-      gcc_assert (TREE_CODE (element) == ARRAY_TYPE);\n-      element = TREE_TYPE (element);\n+      /* For arrays, which are not scalar coarrays.  */\n+      if (TREE_CODE (element) == ARRAY_TYPE)\n+\telement = TREE_TYPE (element);\n     }\n \n   return element;\n@@ -1770,6 +1771,16 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n   /* TODO: known offsets for descriptors.  */\n   GFC_TYPE_ARRAY_OFFSET (fat_type) = NULL_TREE;\n \n+  if (dimen == 0)\n+    {\n+      arraytype =  build_pointer_type (etype);\n+      if (restricted)\n+\tarraytype = build_qualified_type (arraytype, TYPE_QUAL_RESTRICT);\n+\n+      GFC_TYPE_ARRAY_DATAPTR_TYPE (fat_type) = arraytype;\n+      return fat_type;\n+    }\n+\n   /* We define data as an array with the correct size if possible.\n      Much better than doing pointer arithmetic.  */\n   if (stride)\n@@ -2835,8 +2846,11 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   etype = GFC_TYPE_ARRAY_DATAPTR_TYPE (type);\n   gcc_assert (POINTER_TYPE_P (etype));\n   etype = TREE_TYPE (etype);\n-  gcc_assert (TREE_CODE (etype) == ARRAY_TYPE);\n-  etype = TREE_TYPE (etype);\n+\n+  /* If the type is not a scalar coarray.  */\n+  if (TREE_CODE (etype) == ARRAY_TYPE)\n+    etype = TREE_TYPE (etype);\n+\n   /* Can't handle variable sized elements yet.  */\n   if (int_size_in_bytes (etype) <= 0)\n     return false;"}, {"sha": "258128b513cf65459164ebde419491376a09ee5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -1,3 +1,10 @@\n+2011-07-11  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_14.f90: Remove dg-error \"sorry not implemented\".\n+\t* gfortran.dg/coarray_7.f90: Ditto.\n+\t* gfortran.dg/coarray/scalar_alloc_1.f90: New.\n+\t* gfortran.dg/coarray/scalar_alloc_2.f90: New.\n+\n 2011-07-16  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* gcc.c-torture/execute/ieee/mul-subnormal-single-1.x: Add tic6x-*-*"}, {"sha": "528dd3e092f23f31face9474d7abebb4ed04b265", "filename": "gcc/testsuite/gfortran.dg/coarray/scalar_alloc_1.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fscalar_alloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fscalar_alloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fscalar_alloc_1.f90?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do run }\n+!\n+implicit none\n+integer, allocatable :: A[:], B[:,:]\n+integer :: n1, n2, n3\n+\n+if (allocated (a)) call abort ()\n+if (allocated (b)) call abort ()\n+\n+allocate(a[*])\n+a = 5 + this_image ()\n+if (a[this_image ()] /= 5 + this_image ()) call abort\n+\n+a[this_image ()] = 8 - 2*this_image ()\n+if (a[this_image ()] /= 8 - 2*this_image ()) call abort\n+\n+if (lcobound(a, dim=1) /= 1 .or. ucobound(a,dim=1) /= num_images()) &\n+  call abort ()\n+deallocate(a)\n+\n+allocate(a[4:*])\n+a[this_image ()] = 8 - 2*this_image ()\n+\n+if (lcobound(a, dim=1) /= 4 .or. ucobound(a,dim=1) /= 3 + num_images()) &\n+  call abort ()\n+\n+n1 = -1\n+n2 = 5\n+n3 = 3\n+allocate (B[n1:n2, n3:*])\n+if (any (lcobound(b) /= [-1, 3]) .or. lcobound(B, dim=2) /= n3) &\n+  call abort()\n+call sub(A, B)\n+\n+if (allocated (a)) call abort ()\n+if (.not.allocated (b)) call abort ()\n+\n+call two(.true.)\n+call two(.false.)\n+\n+! automatically deallocate \"B\"\n+contains\n+  subroutine sub(x, y)\n+    integer, allocatable :: x[:], y[:,:]\n+\n+    if (any (lcobound(y) /= [-1, 3]) .or. lcobound(y, dim=2) /= n3) &\n+      call abort()\n+    if (lcobound(x, dim=1) /= 4 .or. ucobound(x,dim=1) /= 3 + num_images()) &\n+      call abort ()\n+    if (x[this_image ()] /= 8 - 2*this_image ()) call abort\n+    deallocate(x)\n+  end subroutine sub\n+\n+  subroutine two(init)\n+    logical, intent(in) :: init\n+    integer, allocatable, SAVE :: a[:]\n+\n+    if (init) then\n+      if (allocated(a)) call abort()\n+      allocate(a[*])\n+      a = 45\n+   else\n+      if (.not. allocated(a)) call abort()\n+      if (a /= 45) call abort()\n+      deallocate(a)\n+    end if\n+  end subroutine two\n+end"}, {"sha": "50c3dfb2ea8ca10f58cf4161bb5ac9e4a1f13432", "filename": "gcc/testsuite/gfortran.dg/coarray/scalar_alloc_2.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fscalar_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fscalar_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fscalar_alloc_2.f90?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+!\n+! Check whether registering allocatable coarrays works\n+!\n+type position\n+  real :: x, y, z\n+end type position\n+\n+integer, allocatable :: a[:]\n+type(position), allocatable :: p[:]\n+\n+allocate(a[*])\n+a = 7\n+\n+allocate(p[*])\n+p%x = 11\n+p%y = 13\n+p%z = 15\n+\n+if (a /= 7) call abort()\n+a = 88\n+if (a /= 88) call abort()\n+\n+if (p%x /= 11) call abort()\n+p%x = 17\n+if (p%x /= 17) call abort()\n+\n+ block\n+   integer, allocatable :: b[:]\n+\n+   allocate(b[*])\n+   b = 8494\n+   \n+   if (b /= 8494) call abort()\n+ end block\n+\n+if (a /= 88) call abort()\n+call test ()\n+end\n+\n+subroutine test()\n+  type velocity\n+    real :: x, y, z\n+  end type velocity\n+\n+  real, allocatable :: z[:]\n+  type(velocity), allocatable :: v[:]\n+\n+  allocate(z[*])\n+  z = sqrt(2.0)\n+\n+  allocate(v[*])\n+  v%x = 21\n+  v%y = 23\n+  v%z = 25\n+\n+  if (z /= sqrt(2.0)) call abort()\n+  if (v%x /= 21) call abort()\n+\n+end subroutine test"}, {"sha": "49188d60e155e435b7b24fd246c719e59ec14a3f", "filename": "gcc/testsuite/gfortran.dg/coarray_14.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_14.f90?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -49,7 +49,7 @@ program myTest\n end type t\n type(t), allocatable :: a[:]\n  allocate (t :: a) ! { dg-error \"Coarray specification required in ALLOCATE statement\" }\n-allocate (t :: a[*]) ! { dg-error \"allocatable scalar coarrays are not yet supported\" }\n+allocate (t :: a[*]) ! OK\n end program myTest\n \n ! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "abbd64dd5441252a7d7018207e79f06d87bea82a", "filename": "gcc/testsuite/gfortran.dg/coarray_7.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd9e6941c34112f782bf955877fe041dd20cc4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90?ref=badd9e6941c34112f782bf955877fe041dd20cc4", "patch": "@@ -90,7 +90,7 @@ subroutine alloc()\n \n allocate(b(1)) ! { dg-error \"Coarray specification\" }\n allocate(a[3]%a(5)) ! { dg-error \"Coindexed allocatable\" }\n-allocate(c[*]) ! { dg-error \"Sorry\" }\n+allocate(c[*]) ! OK\n allocate(a%a(5)) ! OK\n end subroutine alloc\n \n@@ -151,9 +151,9 @@ subroutine allocateTest()\n   integer :: n, q\n   n = 1\n   q = 1\n-  allocate(a[q,*]) ! { dg-error \"Sorry\" }\n-  allocate(b[q,*]) ! { dg-error \"Sorry\" }\n-  allocate(c[q,*]) ! { dg-error \"Sorry\" }\n+  allocate(a[q,*]) ! OK\n+  allocate(b[q,*]) ! OK\n+  allocate(c[q,*]) ! OK\n end subroutine allocateTest\n \n "}]}