{"sha": "f283421d4a4c4f1a81b861d552ed2851991886be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI4MzQyMWQ0YTRjNGYxYTgxYjg2MWQ1NTJlZDI4NTE5OTE4ODZiZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-05-09T02:03:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-05-09T02:03:07Z"}, "message": "loop.c (get_condition): Don't combine when either compare is MODE_CC.\n\n* loop.c (get_condition): Don't combine when either compare is MODE_CC.\n* alpha.c (alpha_emit_conditional_branch): New function.  Taken from\nthe body of beq; additionally set the mode of the branch to CCmode for\nFP compares and not fast_math.\n(alpha_emit_conditional_move): Always use a compare insn for FP\nwhen not fast_math, as well as setting CCmode on the cmov.\n* alpha.md (beq, bne, blt, et al): Call alpha_emit_conditional_branch.\n\nFrom-SVN: r19645", "tree": {"sha": "367306fb261bfcbd826cba6c30e8a72eef7f3f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/367306fb261bfcbd826cba6c30e8a72eef7f3f20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f283421d4a4c4f1a81b861d552ed2851991886be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f283421d4a4c4f1a81b861d552ed2851991886be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f283421d4a4c4f1a81b861d552ed2851991886be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f283421d4a4c4f1a81b861d552ed2851991886be/comments", "author": null, "committer": null, "parents": [{"sha": "760801691294e8684d7aeae69b5bc317393c0d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760801691294e8684d7aeae69b5bc317393c0d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/760801691294e8684d7aeae69b5bc317393c0d63"}], "stats": {"total": 341, "additions": 180, "deletions": 161}, "files": [{"sha": "df8b7e029bed10c3572c6e30e1c87e65a5883072", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f283421d4a4c4f1a81b861d552ed2851991886be", "patch": "@@ -1,3 +1,15 @@\n+Sat May  9 02:02:15 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* loop.c (get_condition): Don't combine when either compare is MODE_CC.\n+\t* alpha.c (alpha_emit_conditional_branch): New function.  Taken from\n+\tthe body of beq; additionally set the mode of the branch to CCmode for\n+\tFP compares and not fast_math.  \n+\t(alpha_emit_conditional_move): Always use a compare insn for FP\n+\twhen not fast_math, as well as setting CCmode on the cmov.\n+\t* alpha.md (beq, bne, blt, et al): Call alpha_emit_conditional_branch.\n+\n+\t* machmode.h (COMPLEX_MODE_P): New macro.\n+\n Sat May  9 01:53:23 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* haifa-sched.c (print_exp): Fix typo."}, {"sha": "a36581255598726d6db6c32159a25a86bbcc2f7a", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f283421d4a4c4f1a81b861d552ed2851991886be", "patch": "@@ -1223,6 +1223,120 @@ alpha_emit_set_long_const (target, c)\n }\n #endif /* HOST_BITS_PER_WIDE_INT == 64 */\n \n+/* Generate the comparison for a conditional branch.  */\n+\n+rtx\n+alpha_emit_conditional_branch (code)\n+     enum rtx_code code;\n+{\n+  enum rtx_code cmp_code, branch_code;\n+  enum machine_mode cmp_mode, branch_mode = VOIDmode;\n+  rtx op0 = alpha_compare_op0, op1 = alpha_compare_op1;\n+  rtx tem;\n+\n+  /* The general case: fold the comparison code to the types of compares\n+     that we have, choosing the branch as necessary.  */\n+  switch (code)\n+    {\n+    case EQ:  case LE:  case LT:  case LEU:  case LTU:\n+      /* We have these compares: */\n+      cmp_code = code, branch_code = NE;\n+      break;\n+\n+    case NE:\n+      /* This must be reversed. */\n+      cmp_code = EQ, branch_code = EQ;\n+      break;\n+\n+    case GE:  case GT: case GEU:  case GTU:\n+      /* For FP, we swap them, for INT, we reverse them.  */\n+      if (alpha_compare_fp_p)\n+\t{\n+\t  cmp_code = swap_condition (code);\n+\t  branch_code = NE;\n+\t  tem = op0, op0 = op1, op1 = tem;\n+\t}\n+      else\n+\t{\n+\t  cmp_code = reverse_condition (code);\n+\t  branch_code = EQ;\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (alpha_compare_fp_p)\n+    {\n+      cmp_mode = DFmode;\n+      if (flag_fast_math)\n+\t{\n+\t  /* When we are not as concerned about non-finite values, and we\n+\t     are comparing against zero, we can branch directly.  */\n+\t  if (op1 == CONST0_RTX (DFmode))\n+\t    cmp_code = NIL, branch_code = code;\n+\t  else if (op0 == CONST0_RTX (DFmode))\n+\t    {\n+\t      /* Undo the swap we probably did just above.  */\n+\t      tem = op0, op0 = op1, op1 = tem;\n+\t      cmp_code = NIL, branch_code = swap_condition (cmp_code);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* ??? We mark the the branch mode to be CCmode to prevent the\n+\t     compare and branch from being combined, since the compare \n+\t     insn follows IEEE rules that the branch does not.  */\n+\t  branch_mode = CCmode;\n+\t}\n+    }\n+  else\n+    {\n+      cmp_mode = DImode;\n+\n+      /* The following optimizations are only for signed compares.  */\n+      if (code != LEU && code != LTU && code != GEU && code != GTU)\n+\t{\n+\t  /* Whee.  Compare and branch against 0 directly.  */\n+\t  if (op1 == const0_rtx)\n+\t    cmp_code = NIL, branch_code = code;\n+\n+\t  /* We want to use cmpcc/bcc when we can, since there is a zero delay\n+\t     bypass between logicals and br/cmov on EV5.  But we don't want to\n+\t     force valid immediate constants into registers needlessly.  */\n+\t  else if (GET_CODE (op1) == CONST_INT)\n+\t    {\n+\t      HOST_WIDE_INT v = INTVAL (op1), n = -v;\n+\n+\t      if (! CONST_OK_FOR_LETTER_P (v, 'I')\n+\t\t  && (CONST_OK_FOR_LETTER_P (n, 'K')\n+\t\t      || CONST_OK_FOR_LETTER_P (n, 'L')))\n+\t\t{\n+\t\t  cmp_code = PLUS, branch_code = code;\n+\t\t  op1 = GEN_INT (n);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Force op0 into a register.  */\n+  if (GET_CODE (op0) != REG)\n+    op0 = force_reg (cmp_mode, op0);\n+\n+  /* Emit an initial compare instruction, if necessary.  */\n+  tem = op0;\n+  if (cmp_code != NIL)\n+    {\n+      tem = gen_reg_rtx (cmp_mode);\n+      emit_move_insn (tem, gen_rtx_fmt_ee (cmp_code, cmp_mode, op0, op1));\n+    }\n+\n+  /* Return the branch comparison.  */\n+  return gen_rtx_fmt_ee (branch_code, branch_mode, tem, CONST0_RTX (cmp_mode));\n+}\n+\n+\n /* Rewrite a comparison against zero CMP of the form\n    (CODE (cc0) (const_int 0)) so it can be written validly in\n    a conditional move (if_then_else CMP ...).\n@@ -1241,6 +1355,7 @@ alpha_emit_conditional_move (cmp, mode)\n   enum machine_mode cmp_mode\n     = (GET_MODE (op0) == VOIDmode ? DImode : GET_MODE (op0));\n   enum machine_mode cmp_op_mode = alpha_compare_fp_p ? DFmode : DImode;\n+  enum machine_mode cmov_mode = VOIDmode;\n   rtx tem;\n \n   if (alpha_compare_fp_p != FLOAT_MODE_P (mode))\n@@ -1249,6 +1364,7 @@ alpha_emit_conditional_move (cmp, mode)\n   /* We may be able to use a conditional move directly.\n      This avoids emitting spurious compares. */\n   if (signed_comparison_operator (cmp, cmp_op_mode)\n+      && (!alpha_compare_fp_p || flag_fast_math)\n       && (op0 == CONST0_RTX (cmp_mode) || op1 == CONST0_RTX (cmp_mode)))\n     return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n \n@@ -1281,9 +1397,15 @@ alpha_emit_conditional_move (cmp, mode)\n       abort ();\n     }\n \n+  /* ??? We mark the the branch mode to be CCmode to prevent the compare\n+     and cmov from being combined, since the compare insn follows IEEE\n+     rules that the cmov does not.  */\n+  if (alpha_compare_fp_p && !flag_fast_math)\n+    cmov_mode = CCmode;\n+\n   tem = gen_reg_rtx (cmp_op_mode);\n   emit_move_insn (tem, gen_rtx_fmt_ee (code, cmp_op_mode, op0, op1));\n-  return gen_rtx_fmt_ee (cmov_code, VOIDmode, tem, CONST0_RTX (cmp_op_mode));\n+  return gen_rtx_fmt_ee (cmov_code, cmov_mode, tem, CONST0_RTX (cmp_op_mode));\n }\n \f\n /* Use ext[wlq][lh] as the Architecture Handbook describes for extracting"}, {"sha": "7990f20e747e87461af53352ceea6a1fcb06a2ae", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 30, "deletions": 158, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=f283421d4a4c4f1a81b861d552ed2851991886be", "patch": "@@ -2855,212 +2855,84 @@\n }\")\n \n (define_expand \"beq\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  enum machine_mode mode;\n-  enum rtx_code compare_code = EQ, branch_code = NE;\n-\n-  if (alpha_compare_fp_p)\n-    mode = DFmode;\n-  else\n-    {\n-      mode = DImode;\n-      /* We want to use cmpeq/bne when we can, since there is a zero-delay\n-\t bypass between logicals and br/cmov on the 21164.  But we don't\n-\t want to force valid immediate constants into registers needlessly.  */\n-      if (GET_CODE (alpha_compare_op1) == CONST_INT\n-\t  && ((INTVAL (alpha_compare_op1) >= -0x8000\n-\t       && INTVAL (alpha_compare_op1) < 0)\n-\t      || (INTVAL (alpha_compare_op1) > 0xff\n-\t\t  && INTVAL (alpha_compare_op1) < 0x8000)))\n-\t{\n-\t  compare_code = PLUS, branch_code = EQ;\n-\t  alpha_compare_op1 = GEN_INT (- INTVAL (alpha_compare_op1));\n-\t}\n-    }\n-\n-  operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx_fmt_ee (compare_code, mode,\n-\t\t\t\talpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_fmt_ee (branch_code, VOIDmode,\n-\t\t\t\toperands[1], CONST0_RTX (mode));\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (EQ); }\")\n \n (define_expand \"bne\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  enum machine_mode mode;\n-  enum rtx_code compare_code = EQ, branch_code = EQ;\n-\n-  if (alpha_compare_fp_p)\n-    mode = DFmode;\n-  else\n-    {\n-      mode = DImode;\n-      /* We want to use cmpeq/bne when we can, since there is a zero-delay\n-\t bypass between logicals and br/cmov on the 21164.  But we don't\n-\t want to force valid immediate constants into registers needlessly.  */\n-      if (GET_CODE (alpha_compare_op1) == CONST_INT\n-\t  && ((INTVAL (alpha_compare_op1) >= -0x8000\n-\t       && INTVAL (alpha_compare_op1) < 0)\n-\t      || (INTVAL (alpha_compare_op1) > 0xff\n-\t\t  && INTVAL (alpha_compare_op1) < 0x8000)))\n-\t{\n-\t  compare_code = PLUS, branch_code = NE;\n-\t  alpha_compare_op1 = GEN_INT (- INTVAL (alpha_compare_op1));\n-\t}\n-    }\n-\n-  operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx_fmt_ee (compare_code, mode,\n-\t\t\t\talpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_fmt_ee (branch_code, VOIDmode,\n-\t\t\t\toperands[1], CONST0_RTX (mode));\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (NE); }\")\n \n (define_expand \"blt\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  enum machine_mode mode = alpha_compare_fp_p ? DFmode : DImode;\n-  operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx_LT (mode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (mode));\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (LT); }\")\n \n (define_expand \"ble\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  enum machine_mode mode = alpha_compare_fp_p ? DFmode : DImode;\n-  operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx_LE (mode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (mode));\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (LE); }\")\n \n (define_expand \"bgt\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare_fp_p)\n-    {\n-      operands[1] = gen_reg_rtx (DFmode);\n-      operands[2] = gen_rtx_LT (DFmode, alpha_compare_op1, alpha_compare_op0);\n-      operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (DFmode));\n-    }\n-  else\n-    {\n-      operands[1] = gen_reg_rtx (DImode);\n-      operands[2] = gen_rtx_LE (DImode, alpha_compare_op0, alpha_compare_op1);\n-      operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n-    }\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (GT); }\")\n \n (define_expand \"bge\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare_fp_p)\n-    {\n-      operands[1] = gen_reg_rtx (DFmode);\n-      operands[2] = gen_rtx_LE (DFmode, alpha_compare_op1, alpha_compare_op0);\n-      operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (DFmode));\n-    }\n-  else\n-    {\n-      operands[1] = gen_reg_rtx (DImode);\n-      operands[2] = gen_rtx_LT (DImode, alpha_compare_op0, alpha_compare_op1);\n-      operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n-    }\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (GE); }\")\n \n (define_expand \"bltu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx_LTU (DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_NE (VOIDmode, operands[1], const0_rtx);\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (LTU); }\")\n \n (define_expand \"bleu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx_LEU (DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_NE (VOIDmode, operands[1], const0_rtx);\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (LEU); }\")\n \n (define_expand \"bgtu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx_LEU (DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (GTU); }\")\n \n (define_expand \"bgeu\"\n-  [(set (match_dup 1) (match_dup 2))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx_LTU (DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n-}\")\n+  \"{ operands[1] = alpha_emit_conditional_branch (GEU); }\")\n \n (define_expand \"seq\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")"}, {"sha": "6765b20e61c090bcdafed235c5e5a71d88ca06b0", "filename": "gcc/loop.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f283421d4a4c4f1a81b861d552ed2851991886be/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f283421d4a4c4f1a81b861d552ed2851991886be", "patch": "@@ -6978,13 +6978,15 @@ get_condition (jump, earliest)\n   rtx op0, op1;\n   int reverse_code = 0;\n   int did_reverse_condition = 0;\n+  enum machine_mode mode;\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n   if (GET_CODE (jump) != JUMP_INSN\n       || ! condjump_p (jump) || simplejump_p (jump))\n     return 0;\n \n   code = GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 0));\n+  mode = GET_MODE (XEXP (SET_SRC (PATTERN (jump)), 0));\n   op0 = XEXP (XEXP (SET_SRC (PATTERN (jump)), 0), 0);\n   op1 = XEXP (XEXP (SET_SRC (PATTERN (jump)), 0), 1);\n \n@@ -7051,6 +7053,13 @@ get_condition (jump, earliest)\n \t{\n \t  enum machine_mode inner_mode = GET_MODE (SET_SRC (set));\n \n+\t  /* ??? We may not combine comparisons done in a CCmode with\n+\t     comparisons not done in a CCmode.  This is to aid targets\n+\t     like Alpha that have an IEEE compliant EQ instruction, and\n+\t     a non-IEEE compliant BEQ instruction.  The use of CCmode is\n+\t     actually artificial, simply to prevent the combination, but\n+\t     should not affect other platforms.  */\n+\n \t  if ((GET_CODE (SET_SRC (set)) == COMPARE\n \t       || (((code == NE\n \t\t     || (code == LT\n@@ -7066,7 +7075,9 @@ get_condition (jump, earliest)\n \t\t\t && FLOAT_STORE_FLAG_VALUE < 0)\n #endif\n \t\t     ))\n-\t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<')))\n+\t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<'))\n+\t      && ((GET_MODE_CLASS (mode) == MODE_CC)\n+\t\t  != (GET_MODE_CLASS (inner_mode) == MODE_CC)))\n \t    x = SET_SRC (set);\n \t  else if (((code == EQ\n \t\t     || (code == GE\n@@ -7082,7 +7093,9 @@ get_condition (jump, earliest)\n \t\t\t && FLOAT_STORE_FLAG_VALUE < 0)\n #endif\n \t\t     ))\n-\t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<')\n+\t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<'\n+\t           && ((GET_MODE_CLASS (mode) == MODE_CC)\n+\t\t       != (GET_MODE_CLASS (inner_mode) == MODE_CC)))\n \t    {\n \t      /* We might have reversed a LT to get a GE here.  But this wasn't\n \t\t actually the comparison of data, so we don't flag that we"}]}