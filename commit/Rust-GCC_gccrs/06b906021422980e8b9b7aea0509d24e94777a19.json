{"sha": "06b906021422980e8b9b7aea0509d24e94777a19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiOTA2MDIxNDIyOTgwZThiOWI3YWVhMDUwOWQyNGU5NDc3N2ExOQ==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2014-05-13T08:50:51Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2014-05-13T08:50:51Z"}, "message": "target.def (mode_switching): New hook vector.\n\n2014-05-13  Christian Bruel  <christian.bruel@st.com>\n\n\t* target.def (mode_switching): New hook vector.\n\t(mode_emit, mode_needed, mode_after, mode_entry): New hooks.\n\t(mode_exit, modepriority_to_mode): Likewise.\n\t* mode-switching.c (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Hookify.\n\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n\t(default_priority_to_mode): Define.\n\t* targhooks.h (default_priority_to_mode): Declare.\n\t* target.h: Include tm.h and hard-reg-set.h.\n\t* doc/tm.texi.in (EMIT_MODE_SET, MODE_NEEDED, MODE_AFTER, MODE_ENTRY)\n\t(MODE_EXIT, MODE_PRIORITY_TO_MODE): Delete and hookify.\n\t* doc/tm.texi Regenerate.\n\t* config/sh/sh.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Delete\n\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n\t* config/sh/sh.c (sh_emit_mode_set, sh_mode_priority): Hookify.\n\t(sh_mode_needed, sh_mode_after, sh_mode_entry, sh_mode_exit): Likewise.\n\t* config/i386/i386.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Delete\n\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n\t* config/i386/i386-protos.h (ix86_mode_needed, ix86_mode_after)\n\t(ix86_mode_entrym, ix86_emit_mode_set): Remove external declaration.\n\t* config/i386/i386.c (ix86_mode_needed, ix86_mode_after, ix86_mode_exit,\n\t(ix86_mode_entry, ix86_mode_priority, ix86_emit_mode_set): Hookify.\n\t* config/epiphany/epiphany.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY):\n\tDelete\n\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n\t* config/sh/sh.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Delete\n\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n\t* config/sh/sh.c (sh4_emit_mode_set, sh4_mode_needed): Hookify.\n\t(sh4_mode_after, sh4_mode_entry, sh4_mode_exit): Likewise.\n\t* config/epiphany/epiphany-protos.h (epiphany_mode_needed)\n\t(emit_set_fp_mode, epiphany_mode_entry_exit, epiphany_mode_after)\n\t(epiphany_mode_priority_to_mode): Remove declaration.\n\t* config/epiphany/epiphany.c (emit_set_fp_mode): Hookify.\n\t(epiphany_mode_needed, epiphany_mode_priority_to_mode): Likewise.\n\t(epiphany_mode_entry, epiphany_mode_exit, epiphany_mode_after):\n\tLikewise.\n\t(epiphany_mode_priority_to_mode): Change priority type. Hookify.\n\t(epiphany_mode_needed, epiphany_mode_entry_exit): Hookify.\n\t(epiphany_mode_after, epiphany_mode_entry, emit_set_fp_mode): Hookify.\n\nFrom-SVN: r210354", "tree": {"sha": "2492f596015f55629c1fed3420c824e3fc566559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2492f596015f55629c1fed3420c824e3fc566559"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06b906021422980e8b9b7aea0509d24e94777a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b906021422980e8b9b7aea0509d24e94777a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b906021422980e8b9b7aea0509d24e94777a19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b906021422980e8b9b7aea0509d24e94777a19/comments", "author": null, "committer": null, "parents": [{"sha": "455464ab334ad9fad4a1d2513581ecd21fd92c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455464ab334ad9fad4a1d2513581ecd21fd92c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455464ab334ad9fad4a1d2513581ecd21fd92c2b"}], "stats": {"total": 529, "additions": 296, "deletions": 233}, "files": [{"sha": "456f74061f3ab0587469c6e9540a48f2737fa504", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -1,3 +1,44 @@\n+2014-05-13  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* target.def (mode_switching): New hook vector.\n+\t(mode_emit, mode_needed, mode_after, mode_entry): New hooks.\n+\t(mode_exit, modepriority_to_mode): Likewise.\n+\t* mode-switching.c (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Hookify.\n+\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n+\t(default_priority_to_mode): Define.\n+\t* targhooks.h (default_priority_to_mode): Declare.\n+\t* target.h: Include tm.h and hard-reg-set.h.\n+\t* doc/tm.texi.in (EMIT_MODE_SET, MODE_NEEDED, MODE_AFTER, MODE_ENTRY)\n+\t(MODE_EXIT, MODE_PRIORITY_TO_MODE): Delete and hookify.\n+\t* doc/tm.texi Regenerate.\n+\t* config/sh/sh.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Delete\n+\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n+\t* config/sh/sh.c (sh_emit_mode_set, sh_mode_priority): Hookify.\n+\t(sh_mode_needed, sh_mode_after, sh_mode_entry, sh_mode_exit): Likewise.\n+\t* config/i386/i386.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Delete\n+\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n+\t* config/i386/i386-protos.h (ix86_mode_needed, ix86_mode_after)\n+\t(ix86_mode_entrym, ix86_emit_mode_set): Remove external declaration.\n+\t* config/i386/i386.c (ix86_mode_needed, ix86_mode_after, ix86_mode_exit,\n+\t(ix86_mode_entry, ix86_mode_priority, ix86_emit_mode_set): Hookify.\n+\t* config/epiphany/epiphany.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY):\n+\tDelete\n+\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n+\t* config/sh/sh.h (MODE_NEEDED, MODE_AFTER, MODE_ENTRY): Delete\n+\t(MODE_EXIT, MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n+\t* config/sh/sh.c (sh4_emit_mode_set, sh4_mode_needed): Hookify.\n+\t(sh4_mode_after, sh4_mode_entry, sh4_mode_exit): Likewise.\n+\t* config/epiphany/epiphany-protos.h (epiphany_mode_needed)\n+\t(emit_set_fp_mode, epiphany_mode_entry_exit, epiphany_mode_after)\n+\t(epiphany_mode_priority_to_mode): Remove declaration.\n+\t* config/epiphany/epiphany.c (emit_set_fp_mode): Hookify.\n+\t(epiphany_mode_needed, epiphany_mode_priority_to_mode): Likewise.\n+\t(epiphany_mode_entry, epiphany_mode_exit, epiphany_mode_after):\n+\tLikewise.\n+\t(epiphany_mode_priority_to_mode): Change priority type. Hookify.\n+\t(epiphany_mode_needed, epiphany_mode_entry_exit): Hookify.\n+\t(epiphany_mode_after, epiphany_mode_entry, emit_set_fp_mode): Hookify.\n+\n 2014-05-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/61060"}, {"sha": "bfa4802144308ffd1f5525231d77fd1e6e0ef26c", "filename": "gcc/config/epiphany/epiphany-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -45,9 +45,7 @@ extern void emit_set_fp_mode (int entity, int mode, HARD_REG_SET regs_live);\n extern void epiphany_insert_mode_switch_use (rtx insn, int, int);\n extern void epiphany_expand_set_fp_mode (rtx *operands);\n extern int epiphany_mode_needed (int entity, rtx insn);\n-extern int epiphany_mode_entry_exit (int entity, bool);\n extern int epiphany_mode_after (int entity, int last_mode, rtx insn);\n-extern int epiphany_mode_priority_to_mode (int entity, unsigned priority);\n extern bool epiphany_epilogue_uses (int regno);\n extern bool epiphany_optimize_mode_switching (int entity);\n extern bool epiphany_is_interrupt_p (tree);"}, {"sha": "7ee5d0a8019de8b77641b2e6448264a152816e85", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -152,6 +152,20 @@ static rtx frame_insn (rtx);\n /* We further restrict the minimum to be a multiple of eight.  */\n #define TARGET_MIN_ANCHOR_OFFSET (optimize_size ? 0 : -2040)\n \n+/* Mode switching hooks.  */\n+\n+#define TARGET_MODE_EMIT emit_set_fp_mode\n+\n+#define TARGET_MODE_NEEDED epiphany_mode_needed\n+\n+#define TARGET_MODE_PRIORITY epiphany_mode_priority\n+\n+#define TARGET_MODE_ENTRY epiphany_mode_entry\n+\n+#define TARGET_MODE_EXIT epiphany_mode_exit\n+\n+#define TARGET_MODE_AFTER epiphany_mode_after\n+\n #include \"target-def.h\"\n \n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -2319,8 +2333,8 @@ epiphany_optimize_mode_switching (int entity)\n   gcc_unreachable ();\n }\n \n-int\n-epiphany_mode_priority_to_mode (int entity, unsigned priority)\n+static int\n+epiphany_mode_priority (int entity, int priority)\n {\n   if (entity == EPIPHANY_MSW_ENTITY_AND || entity == EPIPHANY_MSW_ENTITY_OR\n       || entity== EPIPHANY_MSW_ENTITY_CONFIG)\n@@ -2428,7 +2442,7 @@ epiphany_mode_needed (int entity, rtx insn)\n   }\n }\n \n-int\n+static int\n epiphany_mode_entry_exit (int entity, bool exit)\n {\n   int normal_mode = epiphany_normal_fp_mode ;\n@@ -2515,6 +2529,18 @@ epiphany_mode_after (int entity, int last_mode, rtx insn)\n   return last_mode;\n }\n \n+static int\n+epiphany_mode_entry (int entity)\n+{\n+  return epiphany_mode_entry_exit (entity, false);\n+}\n+\n+static int\n+epiphany_mode_exit (int entity)\n+{\n+  return epiphany_mode_entry_exit (entity, true);\n+}\n+\n void\n emit_set_fp_mode (int entity, int mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)\n {"}, {"sha": "f64652e4895c0d75c299ff9ed821745191206620", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -899,19 +899,6 @@ enum epiphany_function_type\n   { 2, 2, 2, \\\n     FP_MODE_NONE, FP_MODE_NONE, FP_MODE_NONE, FP_MODE_NONE, FP_MODE_NONE }\n \n-#define MODE_NEEDED(ENTITY, INSN) epiphany_mode_needed((ENTITY), (INSN))\n-\n-#define MODE_PRIORITY_TO_MODE(ENTITY, N) \\\n-  (epiphany_mode_priority_to_mode ((ENTITY), (N)))\n-\n-#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \\\n-  emit_set_fp_mode ((ENTITY), (MODE), (HARD_REGS_LIVE))\n-\n-#define MODE_ENTRY(ENTITY) (epiphany_mode_entry_exit ((ENTITY), false))\n-#define MODE_EXIT(ENTITY) (epiphany_mode_entry_exit ((ENTITY), true))\n-#define MODE_AFTER(ENTITY, LAST_MODE, INSN) \\\n-  (epiphany_mode_after ((ENTITY), (LAST_MODE), (INSN)))\n-\n #define TARGET_INSERT_MODE_SWITCH_USE epiphany_insert_mode_switch_use\n \n /* Mode switching entities.  */"}, {"sha": "cc80d103c5509e432efd2289dce02465584840e9", "filename": "gcc/config/epiphany/mode-switch-use.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -58,7 +58,7 @@ insert_uses (void)\n \t{\n \t  if (!INSN_P (insn))\n \t    continue;\n-\t  mode = MODE_NEEDED (e, insn);\n+\t  mode = epiphany_mode_needed (e, insn);\n \t  if (mode == no_mode)\n \t    continue;\n \t  if (target_insert_mode_switch_use)"}, {"sha": "39462bd6211d95bf1255c5d6a18c78499976c348", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -166,17 +166,8 @@ extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n extern bool ix86_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n \n-extern int ix86_mode_needed (int, rtx);\n-extern int ix86_mode_after (int, int, rtx);\n-extern int ix86_mode_entry (int);\n-extern int ix86_mode_exit (int);\n-\n extern bool ix86_libc_has_function (enum function_class fn_class);\n \n-#ifdef HARD_CONST\n-extern void ix86_emit_mode_set (int, int, HARD_REG_SET);\n-#endif\n-\n extern void x86_order_regs_for_local_alloc (void);\n extern void x86_function_profiler (FILE *, int);\n extern void x86_emit_floatuns (rtx [2]);"}, {"sha": "99f0657a9cfeeeabad677998a13babdd6a7108ce", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -16148,7 +16148,7 @@ ix86_i387_mode_needed (int entity, rtx insn)\n /* Return mode that entity must be switched into\n    prior to the execution of insn.  */\n \n-int\n+static int\n ix86_mode_needed (int entity, rtx insn)\n {\n   switch (entity)\n@@ -16246,7 +16246,7 @@ ix86_avx_u128_mode_entry (void)\n /* Return a mode that ENTITY is assumed to be\n    switched to at function entry.  */\n \n-int\n+static int\n ix86_mode_entry (int entity)\n {\n   switch (entity)\n@@ -16279,7 +16279,7 @@ ix86_avx_u128_mode_exit (void)\n /* Return a mode that ENTITY is assumed to be\n    switched to at function exit.  */\n \n-int\n+static int\n ix86_mode_exit (int entity)\n {\n   switch (entity)\n@@ -16296,6 +16296,12 @@ ix86_mode_exit (int entity)\n     }\n }\n \n+static int\n+ix86_mode_priority (int entity ATTRIBUTE_UNUSED, int n)\n+{\n+  return n;\n+}\n+\n /* Output code to initialize control word copies used by trunc?f?i and\n    rounding patterns.  CURRENT_MODE is set to current control word,\n    while NEW_MODE is set to new control word.  */\n@@ -16411,7 +16417,11 @@ ix86_avx_emit_vzeroupper (HARD_REG_SET regs_live)\n \n /* Generate one or more insns to set ENTITY to MODE.  */\n \n-void\n+/* Generate one or more insns to set ENTITY to MODE.  HARD_REG_LIVE\n+   is the set of hard registers live at the point where the insn(s)\n+   are to be inserted.  */\n+\n+static void\n ix86_emit_mode_set (int entity, int mode, HARD_REG_SET regs_live)\n {\n   switch (entity)\n@@ -47157,6 +47167,24 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #define TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P \\\n   ix86_float_exceptions_rounding_supported_p\n \n+#undef TARGET_MODE_EMIT\n+#define TARGET_MODE_EMIT ix86_emit_mode_set\n+\n+#undef TARGET_MODE_NEEDED\n+#define TARGET_MODE_NEEDED ix86_mode_needed\n+\n+#undef TARGET_MODE_AFTER\n+#define TARGET_MODE_AFTER ix86_mode_after\n+\n+#undef TARGET_MODE_ENTRY\n+#define TARGET_MODE_ENTRY ix86_mode_entry\n+\n+#undef TARGET_MODE_EXIT\n+#define TARGET_MODE_EXIT ix86_mode_exit\n+\n+#undef TARGET_MODE_PRIORITY\n+#define TARGET_MODE_PRIORITY ix86_mode_priority\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "6e2ac156bdb677a80815348854052235f9eadb1d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -2312,43 +2312,6 @@ enum avx_u128_state\n #define NUM_MODES_FOR_MODE_SWITCHING \\\n   { AVX_U128_ANY, I387_CW_ANY, I387_CW_ANY, I387_CW_ANY, I387_CW_ANY }\n \n-/* ENTITY is an integer specifying a mode-switched entity.  If\n-   `OPTIMIZE_MODE_SWITCHING' is defined, you must define this macro to\n-   return an integer value not larger than the corresponding element\n-   in `NUM_MODES_FOR_MODE_SWITCHING', to denote the mode that ENTITY\n-   must be switched into prior to the execution of INSN.  */\n-\n-#define MODE_NEEDED(ENTITY, I) ix86_mode_needed ((ENTITY), (I))\n-\n-/* If this macro is defined, it is evaluated for every INSN during\n-   mode switching.  It determines the mode that an insn results in (if\n-   different from the incoming mode).  */\n-\n-#define MODE_AFTER(ENTITY, MODE, I) ix86_mode_after ((ENTITY), (MODE), (I))\n-\n-/* If this macro is defined, it is evaluated for every ENTITY that\n-   needs mode switching.  It should evaluate to an integer, which is\n-   a mode that ENTITY is assumed to be switched to at function entry.  */\n-\n-#define MODE_ENTRY(ENTITY) ix86_mode_entry (ENTITY)\n-\n-/* If this macro is defined, it is evaluated for every ENTITY that\n-   needs mode switching.  It should evaluate to an integer, which is\n-   a mode that ENTITY is assumed to be switched to at function exit.  */\n-\n-#define MODE_EXIT(ENTITY) ix86_mode_exit (ENTITY)\n-\n-/* This macro specifies the order in which modes for ENTITY are\n-   processed.  0 is the highest priority.  */\n-\n-#define MODE_PRIORITY_TO_MODE(ENTITY, N) (N)\n-\n-/* Generate one or more insns to set ENTITY to MODE.  HARD_REG_LIVE\n-   is the set of hard registers live at the point where the insn(s)\n-   are to be inserted.  */\n-\n-#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \\\n-  ix86_emit_mode_set ((ENTITY), (MODE), (HARD_REGS_LIVE))\n \f\n /* Avoid renaming of stack registers, as doing so in combination with\n    scheduling just increases amount of live registers at time and in"}, {"sha": "31ea83d1c317f539ad01b895852b7d9247623a62", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -202,6 +202,13 @@ static void push_regs (HARD_REG_SET *, int);\n static int calc_live_regs (HARD_REG_SET *);\n static HOST_WIDE_INT rounded_frame_size (int);\n static bool sh_frame_pointer_required (void);\n+static void sh_emit_mode_set (int, int, HARD_REG_SET);\n+static int sh_mode_needed (int, rtx);\n+static int sh_mode_after (int, int, rtx);\n+static int sh_mode_entry (int);\n+static int sh_mode_exit (int);\n+static int sh_mode_priority (int entity, int n);\n+\n static rtx mark_constant_pool_use (rtx);\n static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree,\n \t\t\t\t\t\t   int, bool *);\n@@ -564,6 +571,24 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED sh_frame_pointer_required\n \n+#undef TARGET_MODE_EMIT\n+#define TARGET_MODE_EMIT sh_emit_mode_set\n+\n+#undef TARGET_MODE_NEEDED\n+#define TARGET_MODE_NEEDED sh_mode_needed\n+\n+#undef TARGET_MODE_AFTER\n+#define TARGET_MODE_AFTER sh_mode_after\n+\n+#undef TARGET_MODE_ENTRY\n+#define TARGET_MODE_ENTRY sh_mode_entry\n+\n+#undef TARGET_MODE_EXIT\n+#define TARGET_MODE_EXIT sh_mode_exit\n+\n+#undef TARGET_MODE_PRIORITY\n+#define TARGET_MODE_PRIORITY sh_mode_priority\n+\n /* Return regmode weight for insn.  */\n #define INSN_REGMODE_WEIGHT(INSN, MODE)\\\n   regmode_weight[((MODE) == SImode) ? 0 : 1][INSN_UID (INSN)]\n@@ -13549,4 +13574,45 @@ sh_try_omit_signzero_extend (rtx extended_op, rtx insn)\n   return NULL_RTX;\n }\n \n+static void\n+sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,\n+\t\t  HARD_REG_SET regs_live)\n+{\n+  fpscr_set_from_mem (mode, regs_live);\n+}\n+\n+static int\n+sh_mode_needed (int entity ATTRIBUTE_UNUSED, rtx insn)\n+{\n+  return recog_memoized (insn) >= 0  ? get_attr_fp_mode (insn) : FP_MODE_NONE;\n+}\n+\n+static int\n+sh_mode_after (int entity ATTRIBUTE_UNUSED, int mode, rtx insn)\n+{\n+  if (TARGET_HITACHI && recog_memoized (insn) >= 0 &&\n+      get_attr_fp_set (insn) != FP_SET_NONE)\n+    return (int) get_attr_fp_set (insn);\n+  else\n+    return mode;\n+}\n+\n+static int\n+sh_mode_entry (int entity ATTRIBUTE_UNUSED)\n+{\n+  return NORMAL_MODE (entity);\n+}\n+\n+static int\n+sh_mode_exit (int entity ATTRIBUTE_UNUSED)\n+{\n+  return sh_cfun_attr_renesas_p () ? FP_MODE_NONE : NORMAL_MODE (entity);\n+}\n+\n+static int\n+sh_mode_priority (int entity ATTRIBUTE_UNUSED, int n)\n+{\n+  return ((TARGET_FPU_SINGLE != 0) ^ (n) ? FP_MODE_SINGLE : FP_MODE_DOUBLE);\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "e42b8d31b6820eaad0ec728aad8bb6e5a095ec5f", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -2218,32 +2218,9 @@ extern int current_function_interrupt;\n    ? (TARGET_FMOVD ? FP_MODE_DOUBLE : FP_MODE_NONE) \\\n    : ACTUAL_NORMAL_MODE (ENTITY))\n \n-#define MODE_ENTRY(ENTITY) NORMAL_MODE (ENTITY)\n-\n-#define MODE_EXIT(ENTITY) \\\n-  (sh_cfun_attr_renesas_p () ? FP_MODE_NONE : NORMAL_MODE (ENTITY))\n-\n #define EPILOGUE_USES(REGNO) ((TARGET_SH2E || TARGET_SH4) \\\n \t\t\t      && (REGNO) == FPSCR_REG)\n \n-#define MODE_NEEDED(ENTITY, INSN)\t\t\t\t\t\\\n-  (recog_memoized (INSN) >= 0\t\t\t\t\t\t\\\n-   ? get_attr_fp_mode (INSN)\t\t\t\t\t\t\\\n-   : FP_MODE_NONE)\n-\n-#define MODE_AFTER(ENTITY, MODE, INSN)\t\t\\\n-     (TARGET_HITACHI\t\t\t\t\\\n-      && recog_memoized (INSN) >= 0\t\t\\\n-      && get_attr_fp_set (INSN) != FP_SET_NONE\t\\\n-      ? (int) get_attr_fp_set (INSN)\t\t\\\n-      : (MODE))\n-\n-#define MODE_PRIORITY_TO_MODE(ENTITY, N) \\\n-  ((TARGET_FPU_SINGLE != 0) ^ (N) ? FP_MODE_SINGLE : FP_MODE_DOUBLE)\n-\n-#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \\\n-  fpscr_set_from_mem ((MODE), (HARD_REGS_LIVE))\n-\n #define MD_CAN_REDIRECT_BRANCH(INSN, SEQ) \\\n   sh_can_redirect_branch ((INSN), (SEQ))\n "}, {"sha": "1a26bcd04488351fa17977e5da969953100f10e2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 21, "deletions": 43, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -9725,9 +9725,9 @@ You can have multiple entities that are mode-switched, and select at run time\n which entities actually need it.  @code{OPTIMIZE_MODE_SWITCHING} should\n return nonzero for any @var{entity} that needs mode-switching.\n If you define this macro, you also have to define\n-@code{NUM_MODES_FOR_MODE_SWITCHING}, @code{MODE_NEEDED},\n-@code{MODE_PRIORITY_TO_MODE} and @code{EMIT_MODE_SET}.\n-@code{MODE_AFTER}, @code{MODE_ENTRY}, and @code{MODE_EXIT}\n+@code{NUM_MODES_FOR_MODE_SWITCHING}, @code{TARGET_MODE_NEEDED},\n+@code{TARGET_MODE_PRIORITY} and @code{TARGET_MODE_EMIT}.\n+@code{TARGET_MODE_AFTER}, @code{TARGET_MODE_ENTRY}, and @code{TARGET_MODE_EXIT}\n are optional.\n @end defmac\n \n@@ -9744,51 +9744,29 @@ represented as numbers 0 @dots{} N @minus{} 1.  N is used to specify that no mod\n switch is needed / supplied.\n @end defmac\n \n-@defmac MODE_NEEDED (@var{entity}, @var{insn})\n-@var{entity} is an integer specifying a mode-switched entity.  If\n-@code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to\n-return an integer value not larger than the corresponding element in\n-@code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must\n-be switched into prior to the execution of @var{insn}.\n-@end defmac\n+@deftypefn {Target Hook} void TARGET_MODE_EMIT (int @var{entity}, int @var{mode}, HARD_REG_SET @var{regs_live})\n+Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.\n+@end deftypefn\n \n-@defmac MODE_AFTER (@var{entity}, @var{mode}, @var{insn})\n-@var{entity} is an integer specifying a mode-switched entity.  If\n-this macro is defined, it is evaluated for every @var{insn} during\n-mode switching.  It determines the mode that an insn results in (if\n-different from the incoming mode).\n-@end defmac\n+@deftypefn {Target Hook} int TARGET_MODE_NEEDED (int @var{entity}, rtx @var{insn})\n+@var{entity} is an integer specifying a mode-switched entity. If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.\n+@end deftypefn\n \n-@defmac MODE_ENTRY (@var{entity})\n-If this macro is defined, it is evaluated for every @var{entity} that needs\n-mode switching.  It should evaluate to an integer, which is a mode that\n-@var{entity} is assumed to be switched to at function entry.  If @code{MODE_ENTRY}\n-is defined then @code{MODE_EXIT} must be defined.\n-@end defmac\n+@deftypefn {Target Hook} int TARGET_MODE_AFTER (int @var{entity}, int @var{mode}, rtx @var{insn})\n+@var{entity} is an integer specifying a mode-switched entity.  If this macro is defined, it is evaluated for every @var{insn} during mode switching.  It determines the mode that an insn results in (if different from the incoming mode).\n+@end deftypefn\n \n-@defmac MODE_EXIT (@var{entity})\n-If this macro is defined, it is evaluated for every @var{entity} that needs\n-mode switching.  It should evaluate to an integer, which is a mode that\n-@var{entity} is assumed to be switched to at function exit.  If @code{MODE_EXIT}\n-is defined then @code{MODE_ENTRY} must be defined.\n-@end defmac\n+@deftypefn {Target Hook} int TARGET_MODE_ENTRY (int @var{entity})\n+If this macro is defined, it is evaluated for every @var{entity} that needs mode switching.  It should evaluate to an integer, which is a mode that @var{entity} is assumed to be switched to at function entry.  If @code{TARGET_MODE_ENTRY} is defined then @code{TARGET_MODE_EXIT} must be defined.\n+@end deftypefn\n \n-@defmac MODE_PRIORITY_TO_MODE (@var{entity}, @var{n})\n-This macro specifies the order in which modes for @var{entity} are processed.\n-0 is the highest priority, @code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1} the\n-lowest.  The value of the macro should be an integer designating a mode\n-for @var{entity}.  For any fixed @var{entity}, @code{mode_priority_to_mode}\n-(@var{entity}, @var{n}) shall be a bijection in 0 @dots{}\n-@code{num_modes_for_mode_switching[@var{entity}] - 1}.\n-@end defmac\n+@deftypefn {Target Hook} int TARGET_MODE_EXIT (int @var{entity})\n+If this macro is defined, it is evaluated for every @var{entity} that needs mode switching.  It should evaluate to an integer, which is a mode that @var{entity} is assumed to be switched to at function exit.  If @code{TARGET_MODE_EXIT} is defined then @code{TARGET_MODE_ENTRY} must be defined.\n+@end deftypefn\n \n-@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})\n-Generate one or more insns to set @var{entity} to @var{mode}.\n-@var{hard_reg_live} is the set of hard registers live at the point where\n-the insn(s) are to be inserted.\n-Sets of a lower numbered entity will be emitted before sets of a higher\n-numbered entity to a mode of the same or lower priority.\n-@end defmac\n+@deftypefn {Target Hook} int TARGET_MODE_PRIORITY (int @var{entity}, int @var{n})\n+This macro specifies the order in which modes for @var{entity} are processed. 0 is the highest priority, @code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1} the lowest.  The value of the macro should be an integer designating a mode for @var{entity}.  For any fixed @var{entity}, @code{mode_priority} (@var{entity}, @var{n}) shall be a bijection in 0 @dots{} @code{num_modes_for_mode_switching[@var{entity}] - 1}.\n+@end deftypefn\n \n @node Target Attributes\n @section Defining target-specific uses of @code{__attribute__}"}, {"sha": "9c81f201664e186a4a1dc4fa1c6b8996299142d0", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 9, "deletions": 43, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -7383,9 +7383,9 @@ You can have multiple entities that are mode-switched, and select at run time\n which entities actually need it.  @code{OPTIMIZE_MODE_SWITCHING} should\n return nonzero for any @var{entity} that needs mode-switching.\n If you define this macro, you also have to define\n-@code{NUM_MODES_FOR_MODE_SWITCHING}, @code{MODE_NEEDED},\n-@code{MODE_PRIORITY_TO_MODE} and @code{EMIT_MODE_SET}.\n-@code{MODE_AFTER}, @code{MODE_ENTRY}, and @code{MODE_EXIT}\n+@code{NUM_MODES_FOR_MODE_SWITCHING}, @code{TARGET_MODE_NEEDED},\n+@code{TARGET_MODE_PRIORITY} and @code{TARGET_MODE_EMIT}.\n+@code{TARGET_MODE_AFTER}, @code{TARGET_MODE_ENTRY}, and @code{TARGET_MODE_EXIT}\n are optional.\n @end defmac\n \n@@ -7402,51 +7402,17 @@ represented as numbers 0 @dots{} N @minus{} 1.  N is used to specify that no mod\n switch is needed / supplied.\n @end defmac\n \n-@defmac MODE_NEEDED (@var{entity}, @var{insn})\n-@var{entity} is an integer specifying a mode-switched entity.  If\n-@code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to\n-return an integer value not larger than the corresponding element in\n-@code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must\n-be switched into prior to the execution of @var{insn}.\n-@end defmac\n+@hook TARGET_MODE_EMIT\n \n-@defmac MODE_AFTER (@var{entity}, @var{mode}, @var{insn})\n-@var{entity} is an integer specifying a mode-switched entity.  If\n-this macro is defined, it is evaluated for every @var{insn} during\n-mode switching.  It determines the mode that an insn results in (if\n-different from the incoming mode).\n-@end defmac\n+@hook TARGET_MODE_NEEDED\n \n-@defmac MODE_ENTRY (@var{entity})\n-If this macro is defined, it is evaluated for every @var{entity} that needs\n-mode switching.  It should evaluate to an integer, which is a mode that\n-@var{entity} is assumed to be switched to at function entry.  If @code{MODE_ENTRY}\n-is defined then @code{MODE_EXIT} must be defined.\n-@end defmac\n+@hook TARGET_MODE_AFTER\n \n-@defmac MODE_EXIT (@var{entity})\n-If this macro is defined, it is evaluated for every @var{entity} that needs\n-mode switching.  It should evaluate to an integer, which is a mode that\n-@var{entity} is assumed to be switched to at function exit.  If @code{MODE_EXIT}\n-is defined then @code{MODE_ENTRY} must be defined.\n-@end defmac\n+@hook TARGET_MODE_ENTRY\n \n-@defmac MODE_PRIORITY_TO_MODE (@var{entity}, @var{n})\n-This macro specifies the order in which modes for @var{entity} are processed.\n-0 is the highest priority, @code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1} the\n-lowest.  The value of the macro should be an integer designating a mode\n-for @var{entity}.  For any fixed @var{entity}, @code{mode_priority_to_mode}\n-(@var{entity}, @var{n}) shall be a bijection in 0 @dots{}\n-@code{num_modes_for_mode_switching[@var{entity}] - 1}.\n-@end defmac\n+@hook TARGET_MODE_EXIT\n \n-@defmac EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})\n-Generate one or more insns to set @var{entity} to @var{mode}.\n-@var{hard_reg_live} is the set of hard registers live at the point where\n-the insn(s) are to be inserted.\n-Sets of a lower numbered entity will be emitted before sets of a higher\n-numbered entity to a mode of the same or lower priority.\n-@end defmac\n+@hook TARGET_MODE_PRIORITY\n \n @node Target Attributes\n @section Defining target-specific uses of @code{__attribute__}"}, {"sha": "b70b2e59581539a1931cbfcc0500bf6f54eef632", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -195,13 +195,6 @@ reg_becomes_live (rtx reg, const_rtx setter ATTRIBUTE_UNUSED, void *live)\n     add_to_hard_reg_set ((HARD_REG_SET *) live, GET_MODE (reg), regno);\n }\n \n-/* Make sure if MODE_ENTRY is defined the MODE_EXIT is defined\n-   and vice versa.  */\n-#if defined (MODE_ENTRY) != defined (MODE_EXIT)\n- #error \"Both MODE_ENTRY and MODE_EXIT must be defined\"\n-#endif\n-\n-#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n /* Split the fallthrough edge to the exit block, so that we can note\n    that there NORMAL_MODE is required.  Return the new block if it's\n    inserted before the exit block.  Otherwise return null.  */\n@@ -349,9 +342,11 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t    for (j = n_entities - 1; j >= 0; j--)\n \t\t      {\n \t\t\tint e = entity_map[j];\n-\t\t\tint mode = MODE_NEEDED (e, return_copy);\n+\t\t\tint mode =\n+\t\t\t  targetm.mode_switching.needed (e, return_copy);\n \n-\t\t\tif (mode != num_modes[e] && mode != MODE_EXIT (e))\n+\t\t\tif (mode != num_modes[e]\n+\t\t\t    && mode != targetm.mode_switching.exit (e))\n \t\t\t  break;\n \t\t      }\n \t\t    if (j >= 0)\n@@ -450,7 +445,6 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \n   return pre_exit;\n }\n-#endif\n \n /* Find all insns that need a particular mode setting, and insert the\n    necessary mode switches.  Return true if we did work.  */\n@@ -472,7 +466,8 @@ optimize_mode_switching (void)\n   int n_entities;\n   int max_num_modes = 0;\n   bool emitted ATTRIBUTE_UNUSED = false;\n-  basic_block post_entry ATTRIBUTE_UNUSED, pre_exit ATTRIBUTE_UNUSED;\n+  basic_block post_entry = 0;\n+  basic_block pre_exit = 0;\n \n   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n     if (OPTIMIZE_MODE_SWITCHING (e))\n@@ -482,9 +477,9 @@ optimize_mode_switching (void)\n \t/* Create the list of segments within each basic block.\n \t   If NORMAL_MODE is defined, allow for two extra\n \t   blocks split from the entry and exit block.  */\n-#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n-\tentry_exit_extra = 3;\n-#endif\n+\tif (targetm.mode_switching.entry && targetm.mode_switching.exit)\n+\t  entry_exit_extra = 3;\n+\n \tbb_info[n_entities]\n \t  = XCNEWVEC (struct bb_info,\n \t\t      last_basic_block_for_fn (cfun) + entry_exit_extra);\n@@ -496,12 +491,17 @@ optimize_mode_switching (void)\n   if (! n_entities)\n     return 0;\n \n-#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n-  /* Split the edge from the entry block, so that we can note that\n-     there NORMAL_MODE is supplied.  */\n-  post_entry = split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n-  pre_exit = create_pre_exit (n_entities, entity_map, num_modes);\n-#endif\n+  /* Make sure if MODE_ENTRY is defined the MODE_EXIT is defined and vice versa.  */\n+  gcc_assert ((targetm.mode_switching.entry && targetm.mode_switching.exit)\n+\t      || (!targetm.mode_switching.entry && !targetm.mode_switching.exit));\n+\n+  if (targetm.mode_switching.entry && targetm.mode_switching.exit)\n+    {\n+      /* Split the edge from the entry block, so that we can note that\n+\t there NORMAL_MODE is supplied.  */\n+      post_entry = split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+      pre_exit = create_pre_exit (n_entities, entity_map, num_modes);\n+    }\n \n   df_analyze ();\n \n@@ -556,7 +556,7 @@ optimize_mode_switching (void)\n \t    {\n \t      if (INSN_P (insn))\n \t\t{\n-\t\t  int mode = MODE_NEEDED (e, insn);\n+\t\t  int mode = targetm.mode_switching.needed (e, insn);\n \t\t  rtx link;\n \n \t\t  if (mode != no_mode && mode != last_mode)\n@@ -567,9 +567,10 @@ optimize_mode_switching (void)\n \t\t      add_seginfo (info + bb->index, ptr);\n \t\t      bitmap_clear_bit (transp[bb->index], j);\n \t\t    }\n-#ifdef MODE_AFTER\n-\t\t  last_mode = MODE_AFTER (e, last_mode, insn);\n-#endif\n+\n+\t\t  if (targetm.mode_switching.after)\n+\t\t    last_mode = targetm.mode_switching.after (e, last_mode, insn);\n+\n \t\t  /* Update LIVE_NOW.  */\n \t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n@@ -595,30 +596,30 @@ optimize_mode_switching (void)\n \t\tbitmap_clear_bit (transp[bb->index], j);\n \t    }\n \t}\n-#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n-      {\n-\tint mode = MODE_ENTRY (e);\n-\n-\tif (mode != no_mode)\n-\t  {\n-\t    bb = post_entry;\n-\n-\t    /* By always making this nontransparent, we save\n-\t       an extra check in make_preds_opaque.  We also\n-\t       need this to avoid confusing pre_edge_lcm when\n-\t       antic is cleared but transp and comp are set.  */\n-\t    bitmap_clear_bit (transp[bb->index], j);\n-\n-\t    /* Insert a fake computing definition of MODE into entry\n-\t       blocks which compute no mode. This represents the mode on\n-\t       entry.  */\n-\t    info[bb->index].computing = mode;\n+      if (targetm.mode_switching.entry && targetm.mode_switching.exit)\n+\t{\n+\t  int mode = targetm.mode_switching.entry (e);\n \n-\t    if (pre_exit)\n-\t      info[pre_exit->index].seginfo->mode = MODE_EXIT (e);\n-\t  }\n-      }\n-#endif /* NORMAL_MODE */\n+\t  if (mode != no_mode)\n+\t    {\n+\t      bb = post_entry;\n+\n+\t      /* By always making this nontransparent, we save\n+\t\t an extra check in make_preds_opaque.  We also\n+\t\t need this to avoid confusing pre_edge_lcm when\n+\t\t antic is cleared but transp and comp are set.  */\n+\t      bitmap_clear_bit (transp[bb->index], j);\n+\n+\t      /* Insert a fake computing definition of MODE into entry\n+\t\t blocks which compute no mode. This represents the mode on\n+\t\t entry.  */\n+\t      info[bb->index].computing = mode;\n+\n+\t      if (pre_exit)\n+\t\tinfo[pre_exit->index].seginfo->mode =\n+\t\t  targetm.mode_switching.exit (e);\n+\t    }\n+\t}\n     }\n \n   kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n@@ -633,7 +634,8 @@ optimize_mode_switching (void)\n       bitmap_vector_clear (comp, last_basic_block_for_fn (cfun));\n       for (j = n_entities - 1; j >= 0; j--)\n \t{\n-\t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n+\t  int m = current_mode[j] =\n+\t    targetm.mode_switching.priority (entity_map[j], i);\n \t  struct bb_info *info = bb_info[j];\n \n \t  FOR_EACH_BB_FN (bb, cfun)\n@@ -688,7 +690,7 @@ optimize_mode_switching (void)\n \n \t      rtl_profile_for_edge (eg);\n \t      start_sequence ();\n-\t      EMIT_MODE_SET (entity_map[j], mode, live_at_edge);\n+\t      targetm.mode_switching.emit (entity_map[j], mode, live_at_edge);\n \t      mode_set = get_insns ();\n \t      end_sequence ();\n \t      default_rtl_profile ();\n@@ -736,7 +738,9 @@ optimize_mode_switching (void)\n \n \t\t  rtl_profile_for_bb (bb);\n \t\t  start_sequence ();\n-\t\t  EMIT_MODE_SET (entity_map[j], ptr->mode, ptr->regs_live);\n+\t\t  targetm.mode_switching.emit (entity_map[j],\n+\t\t\t\t\t       ptr->mode,\n+\t\t\t\t\t       ptr->regs_live);\n \t\t  mode_set = get_insns ();\n \t\t  end_sequence ();\n \n@@ -777,12 +781,10 @@ optimize_mode_switching (void)\n   if (need_commit)\n     commit_edge_insertions ();\n \n-#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n-  cleanup_cfg (CLEANUP_NO_INSN_DEL);\n-#else\n-  if (!need_commit && !emitted)\n+  if (targetm.mode_switching.entry && targetm.mode_switching.exit)\n+    cleanup_cfg (CLEANUP_NO_INSN_DEL);\n+  else if (!need_commit && !emitted)\n     return 0;\n-#endif\n \n   return 1;\n }"}, {"sha": "dd167bb6afb6fcb851923c2a0c721cb57f6e260b", "filename": "gcc/target.def", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -5373,5 +5373,43 @@ bool, false)\n \n /* Leave the boolean fields at the end.  */\n \n+/* Functions related to mode switching.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_MODE_\"\n+HOOK_VECTOR (TARGET_TOGGLE_, mode_switching)\n+\n+DEFHOOK\n+(emit,\n+ \"Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.\",\n+ void, (int entity, int mode, HARD_REG_SET regs_live), NULL)\n+\n+DEFHOOK\n+(needed,\n+ \"@var{entity} is an integer specifying a mode-switched entity. If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.\",\n+ int, (int entity, rtx insn), NULL)\n+\n+DEFHOOK\n+(after,\n+ \"@var{entity} is an integer specifying a mode-switched entity.  If this macro is defined, it is evaluated for every @var{insn} during mode switching.  It determines the mode that an insn results in (if different from the incoming mode).\",\n+ int, (int entity, int mode, rtx insn), NULL)\n+\n+DEFHOOK\n+(entry,\n+ \"If this macro is defined, it is evaluated for every @var{entity} that needs mode switching.  It should evaluate to an integer, which is a mode that @var{entity} is assumed to be switched to at function entry.  If @code{TARGET_MODE_ENTRY} is defined then @code{TARGET_MODE_EXIT} must be defined.\",\n+ int, (int entity), NULL)\n+\n+DEFHOOK\n+(exit,\n+ \"If this macro is defined, it is evaluated for every @var{entity} that needs mode switching.  It should evaluate to an integer, which is a mode that @var{entity} is assumed to be switched to at function exit.  If @code{TARGET_MODE_EXIT} is defined then @code{TARGET_MODE_ENTRY} must be defined.\",\n+ int, (int entity), NULL)\n+\n+DEFHOOK\n+(priority,\n+ \"This macro specifies the order in which modes for @var{entity} are processed. 0 is the highest priority, @code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1} the lowest.  The value of the macro should be an integer designating a mode for @var{entity}.  For any fixed @var{entity}, @code{mode_priority} (@var{entity}, @var{n}) shall be a bijection in 0 @dots{} @code{num_modes_for_mode_switching[@var{entity}] - 1}.\",\n+ int, (int entity, int n), NULL)\n+\n+HOOK_VECTOR_END (mode_switching)\n+\n /* Close the 'struct gcc_target' definition.  */\n HOOK_VECTOR_END (C90_EMPTY_HACK)\n+"}, {"sha": "7be94b8255847dada8a351dfc4e42a75b7c6ed7f", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b906021422980e8b9b7aea0509d24e94777a19/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=06b906021422980e8b9b7aea0509d24e94777a19", "patch": "@@ -51,6 +51,8 @@\n #include \"insn-modes.h\"\n #include \"insn-codes.h\"\n #include \"wide-int.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n \n #ifdef ENABLE_CHECKING\n "}]}