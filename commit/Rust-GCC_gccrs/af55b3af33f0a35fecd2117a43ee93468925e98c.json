{"sha": "af55b3af33f0a35fecd2117a43ee93468925e98c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY1NWIzYWYzM2YwYTM1ZmVjZDIxMTdhNDNlZTkzNDY4OTI1ZTk4Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-08-22T22:22:40Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-08-22T22:22:40Z"}, "message": "PR libstdc++/78448 limit vector::max_size and deque::max_size\n\nThe container requirements imply that max_size() can't exceed the\nmaximum value of the container's difference_type. Enforce this for\nstd::vector and std::deque, and add checks to ensure the container\ndoesn't grow larger than that.\n\n\tPR libstdc++/78448\n\t* include/bits/deque.tcc (deque::_M_range_initialize): Use\n\t_S_check_init_len to check size.\n\t(deque::_M_push_back_aux, deque::_M_push_front_aux): Throw length\n\terror if size would exceed max_size().\n\t* include/bits/stl_deque.h (_Deque_base::size_type): Remove typedef.\n\t(_Deque_base(_Deque_base&&, const allocator_type&, size_t)): Use\n\tsize_t instead of size_type.\n\t(deq(size_type, const allocator_type&)\n\t(deq(size_type, const value_type&, const allocator_type&)\n\t(deque::_M_initialize_dispatch): Use _S_check_init_len to check size.\n\t(deque::max_size): Call _S_max_size.\n\t(deque::_S_check_init_len, deque::_S_max_size): New functions.\n\t* include/bits/stl_vector.h (vector(size_type, const allocator_type&))\n\t(vector(size_type, const value_type&, const allocator_type&))\n\t(vector::_M_initialize_dispatch, vector::_M_range_initialize): Use\n\t_S_check_init_len to check size.\n\t(vector::max_size): Call _S_max_size.\n\t(vector::_M_check_len): Prevent max from being expanded as a\n\tfunction-like macro.\n\t(vector::_S_check_init_len, vector::_S_max_size): New functions.\n\t* include/bits/vector.tcc (vector::_M_assign_aux): Use\n\t_S_check_init_len to check size.\n\t* testsuite/23_containers/deque/capacity/max_size.cc: New test.\n\t* testsuite/23_containers/vector/capacity/max_size.cc: New test.\n\nFrom-SVN: r263789", "tree": {"sha": "785f0ac85050c6509f0136d708bdea530a8bc76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/785f0ac85050c6509f0136d708bdea530a8bc76a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af55b3af33f0a35fecd2117a43ee93468925e98c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af55b3af33f0a35fecd2117a43ee93468925e98c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af55b3af33f0a35fecd2117a43ee93468925e98c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af55b3af33f0a35fecd2117a43ee93468925e98c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2532f0f5e60f7de0a06f3f824f6be618649c216b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2532f0f5e60f7de0a06f3f824f6be618649c216b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2532f0f5e60f7de0a06f3f824f6be618649c216b"}], "stats": {"total": 396, "additions": 381, "deletions": 15}, "files": [{"sha": "dfe3a52443a10e23e74713fb235cca8f9445faec", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -1,3 +1,31 @@\n+2018-08-22  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/78448\n+\t* include/bits/deque.tcc (deque::_M_range_initialize): Use\n+\t_S_check_init_len to check size.\n+\t(deque::_M_push_back_aux, deque::_M_push_front_aux): Throw length\n+\terror if size would exceed max_size().\n+\t* include/bits/stl_deque.h (_Deque_base::size_type): Remove typedef.\n+\t(_Deque_base(_Deque_base&&, const allocator_type&, size_t)): Use\n+\tsize_t instead of size_type.\n+\t(deq(size_type, const allocator_type&)\n+\t(deq(size_type, const value_type&, const allocator_type&)\n+\t(deque::_M_initialize_dispatch): Use _S_check_init_len to check size.\n+\t(deque::max_size): Call _S_max_size.\n+\t(deque::_S_check_init_len, deque::_S_max_size): New functions.\n+\t* include/bits/stl_vector.h (vector(size_type, const allocator_type&))\n+\t(vector(size_type, const value_type&, const allocator_type&))\n+\t(vector::_M_initialize_dispatch, vector::_M_range_initialize): Use\n+\t_S_check_init_len to check size.\n+\t(vector::max_size): Call _S_max_size.\n+\t(vector::_M_check_len): Prevent max from being expanded as a\n+\tfunction-like macro.\n+\t(vector::_S_check_init_len, vector::_S_max_size): New functions.\n+\t* include/bits/vector.tcc (vector::_M_assign_aux): Use\n+\t_S_check_init_len to check size.\n+\t* testsuite/23_containers/deque/capacity/max_size.cc: New test.\n+\t* testsuite/23_containers/vector/capacity/max_size.cc: New test.\n+\n 2018-08-22  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \tPR libstdc++/68222"}, {"sha": "a22948a9753fe4ff4d4be0588c82232786d6b230", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -443,7 +443,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n                           std::forward_iterator_tag)\n       {\n         const size_type __n = std::distance(__first, __last);\n-        this->_M_initialize_map(__n);\n+        this->_M_initialize_map(_S_check_init_len(__n, _M_get_Tp_allocator()));\n \n         _Map_pointer __cur_node;\n         __try\n@@ -484,6 +484,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_push_back_aux(const value_type& __t)\n #endif\n       {\n+\tif (size() == max_size())\n+\t  __throw_length_error(\n+\t      __N(\"cannot create std::deque larger than max_size()\"));\n+\n \t_M_reserve_map_at_back();\n \t*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();\n \t__try\n@@ -519,6 +523,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_push_front_aux(const value_type& __t)\n #endif\n       {\n+\tif (size() == max_size())\n+\t  __throw_length_error(\n+\t      __N(\"cannot create std::deque larger than max_size()\"));\n+\n \t_M_reserve_map_at_front();\n \t*(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();\n \t__try"}, {"sha": "555be16dcd5663f5c5b6b1a1278012b6acc5506d", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -493,7 +493,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     public:\n       typedef _Alloc\t\t  allocator_type;\n-      typedef typename _Alloc_traits::size_type size_type;\n \n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n@@ -535,7 +534,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})\n       { }\n \n-      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)\n+      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_t __n)\n       : _M_impl(__a)\n       {\n \tif (__x.get_allocator() == __a)\n@@ -930,7 +929,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       explicit\n       deque(size_type __n, const allocator_type& __a = allocator_type())\n-      : _Base(__a, __n)\n+      : _Base(__a, _S_check_init_len(__n, __a))\n       { _M_default_initialize(); }\n \n       /**\n@@ -943,7 +942,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       deque(size_type __n, const value_type& __value,\n \t    const allocator_type& __a = allocator_type())\n-      : _Base(__a, __n)\n+      : _Base(__a, _S_check_init_len(__n, __a))\n       { _M_fill_initialize(__value); }\n #else\n       /**\n@@ -957,7 +956,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       explicit\n       deque(size_type __n, const value_type& __value = value_type(),\n \t    const allocator_type& __a = allocator_type())\n-      : _Base(__a, __n)\n+      : _Base(__a, _S_check_init_len(__n, __a))\n       { _M_fill_initialize(__value); }\n #endif\n \n@@ -1298,7 +1297,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /**  Returns the size() of the largest possible %deque.  */\n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n-      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }\n+      { return _S_max_size(_M_get_Tp_allocator()); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -1875,10 +1874,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvoid\n \t_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n \t{\n-\t  _M_initialize_map(static_cast<size_type>(__n));\n+\t  _M_initialize_map(_S_check_init_len(static_cast<size_type>(__n),\n+\t\t\t\t\t      _M_get_Tp_allocator()));\n \t  _M_fill_initialize(__x);\n \t}\n \n+      static size_t\n+      _S_check_init_len(size_t __n, const allocator_type& __a)\n+      {\n+\tif (__n > _S_max_size(__a))\n+\t  __throw_length_error(\n+\t      __N(\"cannot create std::deque larger than max_size()\"));\n+\treturn __n;\n+      }\n+\n+      static size_type\n+      _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT\n+      {\n+\tconst size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max;\n+\tconst size_t __allocmax = _Alloc_traits::max_size(__a);\n+\treturn (std::min)(__diffmax, __allocmax);\n+      }\n+\n       // called by the range constructor to implement [23.1.1]/9\n       template<typename _InputIterator>\n \tvoid"}, {"sha": "6bb75b7f8fd556cce0fa47e948d49fcf757f411e", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -459,7 +459,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       explicit\n       vector(size_type __n, const allocator_type& __a = allocator_type())\n-      : _Base(__n, __a)\n+      : _Base(_S_check_init_len(__n, __a), __a)\n       { _M_default_initialize(__n); }\n \n       /**\n@@ -472,7 +472,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n-      : _Base(__n, __a)\n+      : _Base(_S_check_init_len(__n, __a), __a)\n       { _M_fill_initialize(__n, __value); }\n #else\n       /**\n@@ -486,7 +486,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       explicit\n       vector(size_type __n, const value_type& __value = value_type(),\n \t     const allocator_type& __a = allocator_type())\n-      : _Base(__n, __a)\n+      : _Base(_S_check_init_len(__n, __a), __a)\n       { _M_fill_initialize(__n, __value); }\n #endif\n \n@@ -872,7 +872,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /**  Returns the size() of the largest possible %vector.  */\n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n-      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }\n+      { return _S_max_size(_M_get_Tp_allocator()); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -1485,7 +1485,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvoid\n \t_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n \t{\n-\t  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));\n+\t  this->_M_impl._M_start = _M_allocate(_S_check_init_len(\n+\t\tstatic_cast<size_type>(__n), _M_get_Tp_allocator()));\n \t  this->_M_impl._M_end_of_storage =\n \t    this->_M_impl._M_start + static_cast<size_type>(__n);\n \t  _M_fill_initialize(static_cast<size_type>(__n), __value);\n@@ -1528,7 +1529,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t    std::forward_iterator_tag)\n \t{\n \t  const size_type __n = std::distance(__first, __last);\n-\t  this->_M_impl._M_start = this->_M_allocate(__n);\n+\t  this->_M_impl._M_start\n+\t    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n \t  this->_M_impl._M_finish =\n \t    std::__uninitialized_copy_a(__first, __last,\n@@ -1707,10 +1709,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tif (max_size() - size() < __n)\n \t  __throw_length_error(__N(__s));\n \n-\tconst size_type __len = size() + std::max(size(), __n);\n+\tconst size_type __len = size() + (std::max)(size(), __n);\n \treturn (__len < size() || __len > max_size()) ? max_size() : __len;\n       }\n \n+      // Called by constructors to check initial size.\n+      static size_type\n+      _S_check_init_len(size_type __n, const allocator_type& __a)\n+      {\n+\tif (__n > _S_max_size(_Tp_alloc_type(__a)))\n+\t  __throw_length_error(\n+\t      __N(\"cannot create std::vector larger than max_size()\"));\n+\treturn __n;\n+      }\n+\n+      static size_type\n+      _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT\n+      {\n+\tconst size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max;\n+\tconst size_t __allocmax = _Alloc_traits::max_size(__a);\n+\treturn (std::min)(__diffmax, __allocmax);\n+      }\n+\n       // Internal erase functions follow.\n \n       // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,"}, {"sha": "a1d114a0a9a7f2620b9946e8a7404cf1501f04cc", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -293,6 +293,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n \tif (__len > capacity())\n \t  {\n+\t    _S_check_init_len(__len, _M_get_Tp_allocator());\n \t    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n \t    _GLIBCXX_ASAN_ANNOTATE_REINIT;\n \t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,"}, {"sha": "3dabdd055447e10ec1142ef4ec929dfa7be17db9", "filename": "libstdc++-v3/testsuite/23_containers/deque/capacity/max_size.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcapacity%2Fmax_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcapacity%2Fmax_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcapacity%2Fmax_size.cc?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+#include <deque>\n+#include <stdexcept>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::deque<char>;\n+\n+typedef test_type::size_type size_type;\n+typedef test_type::difference_type difference_type;\n+\n+const difference_type diffmax = std::numeric_limits<difference_type>::max();\n+\n+void\n+test01()\n+{\n+  test_type v;\n+  VERIFY( v.max_size() <= diffmax );\n+}\n+\n+void\n+test02()\n+{\n+  size_type n = size_type(diffmax) + 1;\n+  VERIFY( n > test_type().max_size() );\n+\n+  try {\n+    test_type v(n);\n+    VERIFY( false );\n+  } catch (const std::length_error&) { }\n+\n+  try {\n+    test_type v(n, 'x');\n+    VERIFY( false );\n+  } catch (const std::length_error&) { }\n+\n+  try {\n+    test_type v(n, 'x', test_type::allocator_type());\n+    VERIFY( false );\n+  } catch (const std::length_error&) { }\n+}\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+template<typename T, typename U, bool = (sizeof(T) > sizeof(long long))>\n+  struct Base_\n+  {\n+    typedef T difference_type;\n+    typedef U size_type;\n+  };\n+\n+template<typename T, typename U>\n+  struct Base_<T, U, false>\n+  {\n+    typedef long long difference_type;\n+    typedef unsigned long long size_type;\n+  };\n+\n+typedef Base_<__GLIBCXX_TYPE_INT_N_0, unsigned __GLIBCXX_TYPE_INT_N_0> Base;\n+#else\n+struct Base\n+{\n+  typedef long long difference_type;\n+  typedef unsigned long long size_type;\n+};\n+#endif\n+\n+// An iterator with a difference_type larger than ptrdiff_t\n+struct Iter : Base\n+{\n+  typedef std::random_access_iterator_tag iterator_category;\n+  typedef char value_type;\n+  typedef const char* pointer;\n+  typedef const char& reference;\n+  using Base::difference_type;\n+\n+  Iter() : n(0) { }\n+  Iter(size_type n) : n(n) { }\n+\n+  reference operator*() const { return value; }\n+  pointer operator->() const { return &value; }\n+\n+  Iter& operator++() { ++n; return *this; }\n+  Iter operator++(int) { Iter tmp(*this); ++n; return tmp; }\n+  Iter& operator--() { --n; return *this; }\n+  Iter operator--(int) { Iter tmp(*this); --n; return tmp; }\n+\n+  Iter& operator+=(difference_type d) { n += d; return *this; }\n+  Iter& operator-=(difference_type d) { n -= d; return *this; }\n+\n+  difference_type operator-(const Iter& rhs) const { return n - rhs.n; }\n+\n+  reference operator[](difference_type d) const { return value; }\n+\n+  bool operator==(const Iter& rhs) const { return n == rhs.n; }\n+  bool operator!=(const Iter& rhs) const { return n != rhs.n; }\n+  bool operator<(const Iter& rhs) const { return n < rhs.n; }\n+  bool operator>(const Iter& rhs) const { return n > rhs.n; }\n+  bool operator<=(const Iter& rhs) const { return n <= rhs.n; }\n+  bool operator>=(const Iter& rhs) const { return n >= rhs.n; }\n+\n+private:\n+  size_type n;\n+  static const char value = 'x';\n+};\n+\n+Iter operator+(Iter i, Iter::difference_type n) { return i += n; }\n+Iter operator+(Iter::difference_type n, Iter i) { return i += n; }\n+Iter operator-(Iter::difference_type n, Iter i) { return i -= n; }\n+\n+void\n+test03()\n+{\n+  Iter first, last(Iter::size_type(diffmax) + 1);\n+  VERIFY( std::distance(first, last) > test_type().max_size() );\n+\n+  try {\n+    test_type vec(first, last);\n+    VERIFY(false);\n+  } catch (const std::length_error&) { }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "499cd7660f976db8247541fd49616f3cf7b5f5dd", "filename": "libstdc++-v3/testsuite/23_containers/vector/capacity/max_size.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcapacity%2Fmax_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af55b3af33f0a35fecd2117a43ee93468925e98c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcapacity%2Fmax_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcapacity%2Fmax_size.cc?ref=af55b3af33f0a35fecd2117a43ee93468925e98c", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+#include <vector>\n+#include <stdexcept>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::vector<char>;\n+\n+typedef test_type::size_type size_type;\n+typedef test_type::difference_type difference_type;\n+\n+const difference_type diffmax = std::numeric_limits<difference_type>::max();\n+\n+void\n+test01()\n+{\n+  test_type v;\n+  VERIFY( v.max_size() <= diffmax );\n+}\n+\n+void\n+test02()\n+{\n+  size_type n = size_type(diffmax) + 1;\n+  VERIFY( n > test_type().max_size() );\n+\n+  try {\n+    test_type v(n);\n+    VERIFY( false );\n+  } catch (const std::length_error&) { }\n+\n+  try {\n+    test_type v(n, 'x');\n+    VERIFY( false );\n+  } catch (const std::length_error&) { }\n+\n+  try {\n+    test_type v(n, 'x', test_type::allocator_type());\n+    VERIFY( false );\n+  } catch (const std::length_error&) { }\n+}\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+template<typename T, typename U, bool = (sizeof(T) > sizeof(long long))>\n+  struct Base_\n+  {\n+    typedef T difference_type;\n+    typedef U size_type;\n+  };\n+\n+template<typename T, typename U>\n+  struct Base_<T, U, false>\n+  {\n+    typedef long long difference_type;\n+    typedef unsigned long long size_type;\n+  };\n+\n+typedef Base_<__GLIBCXX_TYPE_INT_N_0, unsigned __GLIBCXX_TYPE_INT_N_0> Base;\n+#else\n+struct Base\n+{\n+  typedef long long difference_type;\n+  typedef unsigned long long size_type;\n+};\n+#endif\n+\n+// An iterator with a difference_type larger than ptrdiff_t\n+struct Iter : Base\n+{\n+  typedef std::random_access_iterator_tag iterator_category;\n+  typedef char value_type;\n+  typedef const char* pointer;\n+  typedef const char& reference;\n+  using Base::difference_type;\n+\n+  Iter() : n(0) { }\n+  Iter(size_type n) : n(n) { }\n+\n+  reference operator*() const { return value; }\n+  pointer operator->() const { return &value; }\n+\n+  Iter& operator++() { ++n; return *this; }\n+  Iter operator++(int) { Iter tmp(*this); ++n; return tmp; }\n+  Iter& operator--() { --n; return *this; }\n+  Iter operator--(int) { Iter tmp(*this); --n; return tmp; }\n+\n+  Iter& operator+=(difference_type d) { n += d; return *this; }\n+  Iter& operator-=(difference_type d) { n -= d; return *this; }\n+\n+  difference_type operator-(const Iter& rhs) const { return n - rhs.n; }\n+\n+  reference operator[](difference_type d) const { return value; }\n+\n+  bool operator==(const Iter& rhs) const { return n == rhs.n; }\n+  bool operator!=(const Iter& rhs) const { return n != rhs.n; }\n+  bool operator<(const Iter& rhs) const { return n < rhs.n; }\n+  bool operator>(const Iter& rhs) const { return n > rhs.n; }\n+  bool operator<=(const Iter& rhs) const { return n <= rhs.n; }\n+  bool operator>=(const Iter& rhs) const { return n >= rhs.n; }\n+\n+private:\n+  size_type n;\n+  static const char value = 'x';\n+};\n+\n+Iter operator+(Iter i, Iter::difference_type n) { return i += n; }\n+Iter operator+(Iter::difference_type n, Iter i) { return i += n; }\n+Iter operator-(Iter::difference_type n, Iter i) { return i -= n; }\n+\n+void\n+test03()\n+{\n+  Iter first, last(Iter::size_type(diffmax) + 1);\n+  VERIFY( std::distance(first, last) > test_type().max_size() );\n+\n+  try {\n+    test_type vec(first, last);\n+    VERIFY(false);\n+  } catch (const std::length_error&) { }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}