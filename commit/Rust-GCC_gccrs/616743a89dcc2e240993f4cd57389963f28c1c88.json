{"sha": "616743a89dcc2e240993f4cd57389963f28c1c88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE2NzQzYTg5ZGNjMmUyNDA5OTNmNGNkNTczODk5NjNmMjhjMWM4OA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2014-12-17T16:25:21Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2014-12-17T16:25:21Z"}, "message": "Complete information generated through the array descriptor language hook\n\ngcc/\n\t* dwarf2out.h (enum array_descr_ordering): New.\n\t(array_descr_dimen): Add a bounds_type structure field.\n\t(struct array_descr_info): Add a field to hold index type information\n\tand another one to hold ordering information.\n\t* dwarf2out.c (gen_type_die_with_usage): Get the main variant before\n\tinvoking the array descriptor language hook.  Initialize the\n\tarray_descr_info structure before calling the lang-hook.\n\t(gen_descr_array_type_die): Use gen_type_die if not processing the main\n\ttype variant.  Replace Fortran-specific code with generic one using\n\tthis new field.  Add a GNAT descriptive type, if any.  Output type\n\tinformation for the array bound subrange, if any.\n\ngcc/fortran\n\t* trans-types.c (gfc_get_array_descr_info): Describe all Fortran arrays\n\twith column major ordering.\n\nFrom-SVN: r218823", "tree": {"sha": "8a6807260b675ee552ea6bd67e5074f9aaecba7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a6807260b675ee552ea6bd67e5074f9aaecba7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/616743a89dcc2e240993f4cd57389963f28c1c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616743a89dcc2e240993f4cd57389963f28c1c88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/616743a89dcc2e240993f4cd57389963f28c1c88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616743a89dcc2e240993f4cd57389963f28c1c88/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b86d271ef6e4ca0b63d5a209d3f5bffbcf7bbf21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b86d271ef6e4ca0b63d5a209d3f5bffbcf7bbf21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b86d271ef6e4ca0b63d5a209d3f5bffbcf7bbf21"}], "stats": {"total": 84, "additions": 66, "deletions": 18}, "files": [{"sha": "bfa03b06ddad77ce6d400d9658c2ec3c927e074a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=616743a89dcc2e240993f4cd57389963f28c1c88", "patch": "@@ -1,3 +1,17 @@\n+2014-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* dwarf2out.h (enum array_descr_ordering): New.\n+\t(array_descr_dimen): Add a bounds_type structure field.\n+\t(struct array_descr_info): Add a field to hold index type information\n+\tand another one to hold ordering information.\n+\t* dwarf2out.c (gen_type_die_with_usage): Get the main variant before\n+\tinvoking the array descriptor language hook.  Initialize the\n+\tarray_descr_info structure before calling the lang-hook.\n+\t(gen_descr_array_type_die): Use gen_type_die if not processing the main\n+\ttype variant.  Replace Fortran-specific code with generic one using\n+\tthis new field.  Add a GNAT descriptive type, if any.  Output type\n+\tinformation for the array bound subrange, if any.\n+\n 2014-12-17  H.J. Lu  <hongjiu.lu@intel.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>"}, {"sha": "f92d31a9fcd1df05477c86f222b3a6277fab7457", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=616743a89dcc2e240993f4cd57389963f28c1c88", "patch": "@@ -17460,18 +17460,25 @@ static void\n gen_descr_array_type_die (tree type, struct array_descr_info *info,\n \t\t\t  dw_die_ref context_die)\n {\n-  dw_die_ref scope_die = scope_die_for (type, context_die);\n-  dw_die_ref array_die;\n+  const dw_die_ref scope_die = scope_die_for (type, context_die);\n+  const dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die, type);\n   int dim;\n \n-  array_die = new_die (DW_TAG_array_type, scope_die, type);\n   add_name_attribute (array_die, type_tag (type));\n   equate_type_number_to_die (type, array_die);\n \n-  /* For Fortran multidimensional arrays use DW_ORD_col_major ordering.  */\n-  if (is_fortran ()\n-      && info->ndimensions >= 2)\n-    add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_col_major);\n+  if (info->ndimensions > 1)\n+    switch (info->ordering)\n+      {\n+      case array_descr_ordering_row_major:\n+\tadd_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);\n+\tbreak;\n+      case array_descr_ordering_column_major:\n+\tadd_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_col_major);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n \n   if (info->data_location)\n     add_descr_info_field (array_die, DW_AT_data_location, info->data_location,\n@@ -17483,11 +17490,17 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n     add_descr_info_field (array_die, DW_AT_allocated, info->allocated,\n \t\t\t  info->base_decl);\n \n+  add_gnat_descriptive_type_attribute (array_die, type, context_die);\n+\n   for (dim = 0; dim < info->ndimensions; dim++)\n     {\n       dw_die_ref subrange_die\n \t= new_die (DW_TAG_subrange_type, array_die, NULL);\n \n+      if (info->dimen[dim].bounds_type)\n+\tadd_type_attribute (subrange_die,\n+\t\t\t    info->dimen[dim].bounds_type, 0,\n+\t\t\t    context_die);\n       if (info->dimen[dim].lower_bound)\n \t{\n \t  /* If it is the default value, omit it.  */\n@@ -20097,17 +20110,6 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       return;\n     }\n \n-  /* If this is an array type with hidden descriptor, handle it first.  */\n-  if (!TREE_ASM_WRITTEN (type)\n-      && lang_hooks.types.get_array_descr_info\n-      && lang_hooks.types.get_array_descr_info (type, &info)\n-      && (dwarf_version >= 3 || !dwarf_strict))\n-    {\n-      gen_descr_array_type_die (type, &info, context_die);\n-      TREE_ASM_WRITTEN (type) = 1;\n-      return;\n-    }\n-\n   /* We are going to output a DIE to represent the unqualified version\n      of this type (i.e. without any const or volatile qualifiers) so\n      get the main variant (i.e. the unqualified version) of this type\n@@ -20116,6 +20118,20 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n   if (TREE_CODE (type) != VECTOR_TYPE)\n     type = type_main_variant (type);\n \n+  /* If this is an array type with hidden descriptor, handle it first.  */\n+  if (!TREE_ASM_WRITTEN (type)\n+      && lang_hooks.types.get_array_descr_info\n+      && (dwarf_version >= 3 || !dwarf_strict))\n+    {\n+      memset (&info, 0, sizeof (info));\n+      if (lang_hooks.types.get_array_descr_info (type, &info))\n+\t{\n+\t  gen_descr_array_type_die (type, &info, context_die);\n+\t  TREE_ASM_WRITTEN (type) = 1;\n+\t  return;\n+\t}\n+    }\n+\n   if (TREE_ASM_WRITTEN (type))\n     return;\n "}, {"sha": "a8d68bb1155e0a5d72c1b6c3a6830620a0083955", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=616743a89dcc2e240993f4cd57389963f28c1c88", "patch": "@@ -261,16 +261,28 @@ extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));\n extern void dwarf2out_vms_debug_main_pointer (void);\n #endif\n \n+enum array_descr_ordering\n+{\n+  array_descr_ordering_default,\n+  array_descr_ordering_row_major,\n+  array_descr_ordering_column_major\n+};\n+\n struct array_descr_info\n {\n   int ndimensions;\n+  enum array_descr_ordering ordering;\n   tree element_type;\n   tree base_decl;\n   tree data_location;\n   tree allocated;\n   tree associated;\n   struct array_descr_dimen\n     {\n+      /* GCC uses sizetype for array indices, so lower_bound and upper_bound\n+\t will likely be \"sizetype\" values. However, bounds may have another\n+\t type in the original source code.  */\n+      tree bounds_type;\n       tree lower_bound;\n       tree upper_bound;\n       tree stride;"}, {"sha": "edbe42afecd8dd34ff9a13543e59b88d9cdc3936", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=616743a89dcc2e240993f4cd57389963f28c1c88", "patch": "@@ -1,3 +1,8 @@\n+2014-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* trans-types.c (gfc_get_array_descr_info): Describe all Fortran arrays\n+\twith column major ordering.\n+\n 2014-12-17  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/54687"}, {"sha": "cdc5897532f42cd08fe9112919c689d9a2f0beba", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616743a89dcc2e240993f4cd57389963f28c1c88/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=616743a89dcc2e240993f4cd57389963f28c1c88", "patch": "@@ -3044,6 +3044,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n \n   memset (info, '\\0', sizeof (*info));\n   info->ndimensions = rank;\n+  info->ordering = array_descr_ordering_column_major;\n   info->element_type = etype;\n   ptype = build_pointer_type (gfc_array_index_type);\n   base_decl = GFC_TYPE_ARRAY_BASE_DECL (type, indirect);"}]}