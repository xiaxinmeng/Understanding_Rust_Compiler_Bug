{"sha": "8f66e7dc9e7521eac72412652725b5a54c5286d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY2NmU3ZGM5ZTc1MjFlYWM3MjQxMjY1MjcyNWI1YTU0YzUyODZkNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2016-03-16T23:53:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-03-16T23:53:10Z"}, "message": "Revert r231575\n\n  PR middle-end/70240\n  PR middle-end/68215\n  2015-12-11  Eric Botcazou  <ebotcazou@adacore.com>\n  * tree-vect-generic.c (tree_vec_extract): Remove GSI parameter.\n  Do not gimplify the result.\n  (do_unop): Adjust call to tree_vec_extract.\n  (do_binop): Likewise.\n  (do_compare): Likewise.\n  (do_plus_minus): Likewise.\n  (do_negate): Likewise.\n  (expand_vector_condition): Likewise.\n  (do_cond): Likewise.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r234272", "tree": {"sha": "5f42ac47edf699b910d306192c61be2e190ac36d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f42ac47edf699b910d306192c61be2e190ac36d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f66e7dc9e7521eac72412652725b5a54c5286d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f66e7dc9e7521eac72412652725b5a54c5286d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f66e7dc9e7521eac72412652725b5a54c5286d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f66e7dc9e7521eac72412652725b5a54c5286d4/comments", "author": null, "committer": null, "parents": [{"sha": "e93ed60e7b1c1f3eb257439ffb867872eeec1367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93ed60e7b1c1f3eb257439ffb867872eeec1367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93ed60e7b1c1f3eb257439ffb867872eeec1367"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "d7640c7d1d98c0b7764f6374e54e9a37f0485a4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f66e7dc9e7521eac72412652725b5a54c5286d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f66e7dc9e7521eac72412652725b5a54c5286d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f66e7dc9e7521eac72412652725b5a54c5286d4", "patch": "@@ -7,6 +7,20 @@\n \t* gimplify.c (gimplify_expr) [VEC_COND_EXPR]: Gimplify the\n \tfirst operand as is_gimple_condexpr.\n \n+\tPR middle-end/70240\n+\tPR middle-end/68215\n+\tRevert r231575\n+\t2015-12-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\t* tree-vect-generic.c (tree_vec_extract): Remove GSI parameter.\n+\tDo not gimplify the result.\n+\t(do_unop): Adjust call to tree_vec_extract.\n+\t(do_binop): Likewise.\n+\t(do_compare): Likewise.\n+\t(do_plus_minus): Likewise.\n+\t(do_negate): Likewise.\n+\t(expand_vector_condition): Likewise.\n+\t(do_cond): Likewise.\n+\n 2016-03-16  Richard Henderson  <rth@redhat.com>\n \n \tPR target/70048"}, {"sha": "cb15a952db129ed782a3550d3d76762023228dcc", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f66e7dc9e7521eac72412652725b5a54c5286d4/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f66e7dc9e7521eac72412652725b5a54c5286d4/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=8f66e7dc9e7521eac72412652725b5a54c5286d4", "patch": "@@ -103,7 +103,8 @@ typedef tree (*elem_op_func) (gimple_stmt_iterator *,\n \t\t\t      tree);\n \n static inline tree\n-tree_vec_extract (tree type, tree t, tree bitsize, tree bitpos)\n+tree_vec_extract (gimple_stmt_iterator *gsi, tree type,\n+\t\t  tree t, tree bitsize, tree bitpos)\n {\n   if (TREE_CODE (t) == SSA_NAME)\n     {\n@@ -114,29 +115,30 @@ tree_vec_extract (tree type, tree t, tree bitsize, tree bitpos)\n \t\t  && gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR)))\n \tt = gimple_assign_rhs1 (def_stmt);\n     }\n-\n   if (bitpos)\n     {\n       if (TREE_CODE (type) == BOOLEAN_TYPE)\n \t{\n \t  tree itype\n \t    = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 0);\n-\t  tree field = fold_build3 (BIT_FIELD_REF, itype, t, bitsize, bitpos);\n-\t  return fold_build2 (NE_EXPR, type, field, build_zero_cst (itype));\n+\t  tree field = gimplify_build3 (gsi, BIT_FIELD_REF, itype, t,\n+\t\t\t\t\tbitsize, bitpos);\n+\t  return gimplify_build2 (gsi, NE_EXPR, type, field,\n+\t\t\t\t  build_zero_cst (itype));\n \t}\n- \n-      return fold_build3 (BIT_FIELD_REF, type, t, bitsize, bitpos);\n+      else\n+\treturn gimplify_build3 (gsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n     }\n-\n-  return fold_build1 (VIEW_CONVERT_EXPR, type, t);\n+  else\n+    return gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, t);\n }\n \n static tree\n do_unop (gimple_stmt_iterator *gsi, tree inner_type, tree a,\n \t tree b ATTRIBUTE_UNUSED, tree bitpos, tree bitsize,\n \t enum tree_code code, tree type ATTRIBUTE_UNUSED)\n {\n-  a = tree_vec_extract (inner_type, a, bitsize, bitpos);\n+  a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n   return gimplify_build1 (gsi, code, inner_type, a);\n }\n \n@@ -146,9 +148,9 @@ do_binop (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n \t  tree type ATTRIBUTE_UNUSED)\n {\n   if (TREE_CODE (TREE_TYPE (a)) == VECTOR_TYPE)\n-    a = tree_vec_extract (inner_type, a, bitsize, bitpos);\n+    a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n   if (TREE_CODE (TREE_TYPE (b)) == VECTOR_TYPE)\n-    b = tree_vec_extract (inner_type, b, bitsize, bitpos);\n+    b = tree_vec_extract (gsi, inner_type, b, bitsize, bitpos);\n   return gimplify_build2 (gsi, code, inner_type, a, b);\n }\n \n@@ -167,8 +169,8 @@ do_compare (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n   tree cst_true = build_all_ones_cst (stype);\n   tree cmp;\n \n-  a = tree_vec_extract (inner_type, a, bitsize, bitpos);\n-  b = tree_vec_extract (inner_type, b, bitsize, bitpos);\n+  a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (gsi, inner_type, b, bitsize, bitpos);\n \n   cmp = build2 (code, boolean_type_node, a, b);\n   return gimplify_build3 (gsi, COND_EXPR, stype, cmp, cst_true, cst_false);\n@@ -200,8 +202,8 @@ do_plus_minus (gimple_stmt_iterator *gsi, tree word_type, tree a, tree b,\n   low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n   high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n \n-  a = tree_vec_extract (word_type, a, bitsize, bitpos);\n-  b = tree_vec_extract (word_type, b, bitsize, bitpos);\n+  a = tree_vec_extract (gsi, word_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (gsi, word_type, b, bitsize, bitpos);\n \n   signs = gimplify_build2 (gsi, BIT_XOR_EXPR, word_type, a, b);\n   b_low = gimplify_build2 (gsi, BIT_AND_EXPR, word_type, b, low_bits);\n@@ -233,7 +235,7 @@ do_negate (gimple_stmt_iterator *gsi, tree word_type, tree b,\n   low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n   high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n \n-  b = tree_vec_extract (word_type, b, bitsize, bitpos);\n+  b = tree_vec_extract (gsi, word_type, b, bitsize, bitpos);\n \n   b_low = gimplify_build2 (gsi, BIT_AND_EXPR, word_type, b, low_bits);\n   signs = gimplify_build1 (gsi, BIT_NOT_EXPR, word_type, b);\n@@ -889,16 +891,16 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n        i++, index = int_const_binop (PLUS_EXPR, index, width))\n     {\n       tree aa, result;\n-      tree bb = tree_vec_extract (inner_type, b, width, index);\n-      tree cc = tree_vec_extract (inner_type, c, width, index);\n+      tree bb = tree_vec_extract (gsi, inner_type, b, width, index);\n+      tree cc = tree_vec_extract (gsi, inner_type, c, width, index);\n       if (a_is_comparison)\n \t{\n-\t  tree aa1 = tree_vec_extract (comp_inner_type, a1, width, index);\n-\t  tree aa2 = tree_vec_extract (comp_inner_type, a2, width, index);\n+\t  tree aa1 = tree_vec_extract (gsi, comp_inner_type, a1, width, index);\n+\t  tree aa2 = tree_vec_extract (gsi, comp_inner_type, a2, width, index);\n \t  aa = build2 (TREE_CODE (a), cond_type, aa1, aa2);\n \t}\n       else\n-\taa = tree_vec_extract (cond_type, a, width, index);\n+\taa = tree_vec_extract (gsi, cond_type, a, width, index);\n       result = gimplify_build3 (gsi, COND_EXPR, inner_type, aa, bb, cc);\n       constructor_elt ce = {NULL_TREE, result};\n       v->quick_push (ce);\n@@ -1448,9 +1450,9 @@ do_cond (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n \t tree type ATTRIBUTE_UNUSED)\n {\n   if (TREE_CODE (TREE_TYPE (a)) == VECTOR_TYPE)\n-    a = tree_vec_extract (inner_type, a, bitsize, bitpos);\n+    a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n   if (TREE_CODE (TREE_TYPE (b)) == VECTOR_TYPE)\n-    b = tree_vec_extract (inner_type, b, bitsize, bitpos);\n+    b = tree_vec_extract (gsi, inner_type, b, bitsize, bitpos);\n   tree cond = gimple_assign_rhs1 (gsi_stmt (*gsi));\n   return gimplify_build3 (gsi, code, inner_type, unshare_expr (cond), a, b);\n }"}]}