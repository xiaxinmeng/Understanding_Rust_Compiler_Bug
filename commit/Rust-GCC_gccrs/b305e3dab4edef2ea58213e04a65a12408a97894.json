{"sha": "b305e3dab4edef2ea58213e04a65a12408a97894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMwNWUzZGFiNGVkZWYyZWE1ODIxM2UwNGE2NWExMjQwOGE5Nzg5NA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2011-01-25T21:24:23Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2011-01-25T21:24:23Z"}, "message": "Remove the lambda framework and make -ftree-loop-linear an alias of -floop-interchange.\n\n2011-01-17  Sebastian Pop  <sebastian.pop@amd.com>\n\ntoplev/\n\t* MAINTAINERS (linear loop transforms): Removed.\n\ntoplev/gcc/\n\t* Makefile.in (LAMBDA_H): Removed.\n\t(TREE_DATA_REF_H): Remove dependence on LAMBDA_H.\n\t(OBJS-common): Remove dependence on lambda-code.o, lambda-mat.o,\n\tlambda-trans.o, and tree-loop-linear.o.\n\t(lto-symtab.o): Remove dependence on LAMBDA_H.\n\t(tree-loop-linear.o): Remove rule.\n\t(lambda-mat.o): Same.\n\t(lambda-trans.o): Same.\n\t(lambda-code.o): Same.\n\t(tree-vect-loop.o): Add missing dependence on TREE_DATA_REF_H.\n\t(tree-vect-slp.o): Same.\n\t* hwint.h (gcd): Moved here.\n\t(least_common_multiple): Same.\n\t* lambda-code.c: Removed.\n\t* lambda-mat.c: Removed.\n\t* lambda-trans.c: Removed.\n\t* lambda.h: Removed.\n\t* tree-loop-linear.c: Removed.\n\t* lto-symtab.c: Do not include lambda.h.\n\t* omega.c (gcd): Removed.\n\t* passes.c (init_optimization_passes): Remove pass_linear_transform.\n\t* tree-data-ref.c (print_lambda_vector): Moved here.\n\t(lambda_vector_copy): Same.\n\t(lambda_matrix_copy): Same.\n\t(lambda_matrix_id): Same.\n\t(lambda_vector_first_nz): Same.\n\t(lambda_matrix_row_add): Same.\n\t(lambda_matrix_row_exchange): Same.\n\t(lambda_vector_mult_const): Same.\n\t(lambda_vector_negate): Same.\n\t(lambda_matrix_row_negate): Same.\n\t(lambda_vector_equal): Same.\n\t(lambda_matrix_right_hermite): Same.\n\t* tree-data-ref.h: Do not include lambda.h.\n\t(lambda_vector): Moved here.\n\t(lambda_matrix): Same.\n\t(dependence_level): Same.\n\t(lambda_transform_legal_p): Removed declaration.\n\t(lambda_collect_parameters): Same.\n\t(lambda_compute_access_matrices): Same.\n\t(lambda_vector_gcd): Same.\n\t(lambda_vector_new): Same.\n\t(lambda_vector_clear): Same.\n\t(lambda_vector_lexico_pos): Same.\n\t(lambda_vector_zerop): Same.\n\t(lambda_matrix_new): Same.\n\t* tree-flow.h (least_common_multiple): Removed declaration.\n\t* tree-parloops.c (lambda_trans_matrix): Moved here.\n\t(LTM_MATRIX): Same.\n\t(LTM_ROWSIZE): Same.\n\t(LTM_COLSIZE): Same.\n\t(LTM_DENOMINATOR): Same.\n\t(lambda_trans_matrix_new): Same.\n\t(lambda_matrix_vector_mult): Same.\n\t(lambda_transform_legal_p): Same.\n\t* tree-pass.h (pass_linear_transform): Removed declaration.\n\t* tree-ssa-loop.c (tree_linear_transform): Removed.\n\t(gate_tree_linear_transform): Removed.\n\t(pass_linear_transform): Removed.\n\t(gate_graphite_transforms): Make flag_tree_loop_linear an alias of\n\tflag_loop_interchange.\n\ntoplev/gcc/testsuite/\n\t* gfortran.dg/graphite/interchange-4.f: New.\n\t* gfortran.dg/graphite/interchange-5.f: New.\n\n\t* gcc.dg/tree-ssa/ltrans-1.c: Removed.\n\t* gcc.dg/tree-ssa/ltrans-2.c: Removed.\n\t* gcc.dg/tree-ssa/ltrans-3.c: Removed.\n\t* gcc.dg/tree-ssa/ltrans-4.c: Removed.\n\t* gcc.dg/tree-ssa/ltrans-5.c: Removed.\n\t* gcc.dg/tree-ssa/ltrans-6.c: Removed.\n\t* gcc.dg/tree-ssa/ltrans-8.c: Removed.\n\t* gfortran.dg/ltrans-7.f90: Removed.\n\t* gcc.dg/tree-ssa/data-dep-1.c: Removed.\n\n\t* gcc.dg/pr18792.c: -> gcc.dg/graphite/pr18792.c\n\t* gcc.dg/pr19910.c: -> gcc.dg/graphite/pr19910.c\n\t* gcc.dg/tree-ssa/20041110-1.c: -> gcc.dg/graphite/pr20041110-1.c\n\t* gcc.dg/tree-ssa/pr20256.c: -> gcc.dg/graphite/pr20256.c\n\t* gcc.dg/pr23625.c: -> gcc.dg/graphite/pr23625.c\n\t* gcc.dg/tree-ssa/pr23820.c: -> gcc.dg/graphite/pr23820.c\n\t* gcc.dg/tree-ssa/pr24309.c: -> gcc.dg/graphite/pr24309.c\n\t* gcc.dg/tree-ssa/pr26435.c: -> gcc.dg/graphite/pr26435.c\n\t* gcc.dg/pr29330.c: -> gcc.dg/graphite/pr29330.c\n\t* gcc.dg/pr29581-1.c: -> gcc.dg/graphite/pr29581-1.c\n\t* gcc.dg/pr29581-2.c: -> gcc.dg/graphite/pr29581-2.c\n\t* gcc.dg/pr29581-3.c: -> gcc.dg/graphite/pr29581-3.c\n\t* gcc.dg/pr29581-4.c: -> gcc.dg/graphite/pr29581-4.c\n\t* gcc.dg/tree-ssa/loop-27.c: -> gcc.dg/graphite/pr30565.c\n\t* gcc.dg/tree-ssa/pr31183.c: -> gcc.dg/graphite/pr31183.c\n\t* gcc.dg/tree-ssa/pr33576.c: -> gcc.dg/graphite/pr33576.c\n\t* gcc.dg/tree-ssa/pr33766.c: -> gcc.dg/graphite/pr33766.c\n\t* gcc.dg/pr34016.c: -> gcc.dg/graphite/pr34016.c\n\t* gcc.dg/tree-ssa/pr34017.c: -> gcc.dg/graphite/pr34017.c\n\t* gcc.dg/tree-ssa/pr34123.c: -> gcc.dg/graphite/pr34123.c\n\t* gcc.dg/tree-ssa/pr36287.c: -> gcc.dg/graphite/pr36287.c\n\t* gcc.dg/tree-ssa/pr37686.c: -> gcc.dg/graphite/pr37686.c\n\t* gcc.dg/pr42917.c: -> gcc.dg/graphite/pr42917.c\n\t* gfortran.dg/loop_nest_1.f90: -> gfortran.dg/graphite/pr29290.f90\n\t* gfortran.dg/pr29581.f90: -> gfortran.dg/graphite/pr29581.f90\n\t* gfortran.dg/pr36286.f90: -> gfortran.dg/graphite/pr36286.f90\n\t* gfortran.dg/pr36922.f: -> gfortran.dg/graphite/pr36922.f\n\t* gfortran.dg/pr39516.f: -> gfortran.dg/graphite/pr39516.f\n\nFrom-SVN: r169251", "tree": {"sha": "95b39b6193ad1bd1417d5ce2c4c7944ac0abc0ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b39b6193ad1bd1417d5ce2c4c7944ac0abc0ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b305e3dab4edef2ea58213e04a65a12408a97894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b305e3dab4edef2ea58213e04a65a12408a97894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b305e3dab4edef2ea58213e04a65a12408a97894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b305e3dab4edef2ea58213e04a65a12408a97894/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237"}], "stats": {"total": 5447, "additions": 632, "deletions": 4815}, "files": [{"sha": "ad8d8f936e1d99a318131c06c194307b7766508c", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -1,3 +1,7 @@\n+2011-01-25  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* MAINTAINERS (linear loop transforms): Removed.\n+\n 2011-01-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/cloog.m4 (CLOOG_REQUESTED): Use $2 if --without-cloog."}, {"sha": "cffbdb0dd46be14e14ed2c415c159265d4da239e", "filename": "MAINTAINERS", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -221,7 +221,6 @@ mudflap\t\t\tFrank Ch. Eigler\tfche@redhat.com\n tree browser/unparser\tSebastian Pop\t\tsebastian.pop@amd.com\n scev, data dependence\tDaniel Berlin\t\tdberlin@dberlin.org\n scev, data dependence\tSebastian Pop\t\tsebastian.pop@amd.com\n-linear loop transforms\tDaniel Berlin\t\tdberlin@dberlin.org\n profile feedback\tJan Hubicka\t\tjh@suse.cz\n type-safe vectors\tNathan Sidwell\t\tnathan@codesourcery.com\n alias analysis\t\tDaniel Berlin\t\tdberlin@dberlin.org"}, {"sha": "514ab55f82fd5d6443dd7c3b9df8b5d72efc876d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -1,3 +1,67 @@\n+2011-01-25  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* Makefile.in (LAMBDA_H): Removed.\n+\t(TREE_DATA_REF_H): Remove dependence on LAMBDA_H.\n+\t(OBJS-common): Remove dependence on lambda-code.o, lambda-mat.o,\n+\tlambda-trans.o, and tree-loop-linear.o.\n+\t(lto-symtab.o): Remove dependence on LAMBDA_H.\n+\t(tree-loop-linear.o): Remove rule.\n+\t(lambda-mat.o): Same.\n+\t(lambda-trans.o): Same.\n+\t(lambda-code.o): Same.\n+\t(tree-vect-loop.o): Add missing dependence on TREE_DATA_REF_H.\n+\t(tree-vect-slp.o): Same.\n+\t* hwint.h (gcd): Moved here.\n+\t(least_common_multiple): Same.\n+\t* lambda-code.c: Removed.\n+\t* lambda-mat.c: Removed.\n+\t* lambda-trans.c: Removed.\n+\t* lambda.h: Removed.\n+\t* tree-loop-linear.c: Removed.\n+\t* lto-symtab.c: Do not include lambda.h.\n+\t* omega.c (gcd): Removed.\n+\t* passes.c (init_optimization_passes): Remove pass_linear_transform.\n+\t* tree-data-ref.c (print_lambda_vector): Moved here.\n+\t(lambda_vector_copy): Same.\n+\t(lambda_matrix_copy): Same.\n+\t(lambda_matrix_id): Same.\n+\t(lambda_vector_first_nz): Same.\n+\t(lambda_matrix_row_add): Same.\n+\t(lambda_matrix_row_exchange): Same.\n+\t(lambda_vector_mult_const): Same.\n+\t(lambda_vector_negate): Same.\n+\t(lambda_matrix_row_negate): Same.\n+\t(lambda_vector_equal): Same.\n+\t(lambda_matrix_right_hermite): Same.\n+\t* tree-data-ref.h: Do not include lambda.h.\n+\t(lambda_vector): Moved here.\n+\t(lambda_matrix): Same.\n+\t(dependence_level): Same.\n+\t(lambda_transform_legal_p): Removed declaration.\n+\t(lambda_collect_parameters): Same.\n+\t(lambda_compute_access_matrices): Same.\n+\t(lambda_vector_gcd): Same.\n+\t(lambda_vector_new): Same.\n+\t(lambda_vector_clear): Same.\n+\t(lambda_vector_lexico_pos): Same.\n+\t(lambda_vector_zerop): Same.\n+\t(lambda_matrix_new): Same.\n+\t* tree-flow.h (least_common_multiple): Removed declaration.\n+\t* tree-parloops.c (lambda_trans_matrix): Moved here.\n+\t(LTM_MATRIX): Same.\n+\t(LTM_ROWSIZE): Same.\n+\t(LTM_COLSIZE): Same.\n+\t(LTM_DENOMINATOR): Same.\n+\t(lambda_trans_matrix_new): Same.\n+\t(lambda_matrix_vector_mult): Same.\n+\t(lambda_transform_legal_p): Same.\n+\t* tree-pass.h (pass_linear_transform): Removed declaration.\n+\t* tree-ssa-loop.c (tree_linear_transform): Removed.\n+\t(gate_tree_linear_transform): Removed.\n+\t(pass_linear_transform): Removed.\n+\t(gate_graphite_transforms): Make flag_tree_loop_linear an alias of\n+\tflag_loop_interchange.\n+\n 2011-01-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47265"}, {"sha": "48b49e9fa517df9b86a773ecd701445977b27ca4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -966,8 +966,7 @@ DIAGNOSTIC_H = diagnostic.h $(DIAGNOSTIC_CORE_H) $(PRETTY_PRINT_H)\n C_PRETTY_PRINT_H = c-family/c-pretty-print.h $(PRETTY_PRINT_H) \\\n \t$(C_COMMON_H) $(TREE_H)\n SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n-LAMBDA_H = lambda.h $(TREE_H) $(VEC_H) $(GGC_H)\n-TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h graphds.h $(SCEV_H)\n+TREE_DATA_REF_H = tree-data-ref.h omega.h graphds.h $(SCEV_H)\n TREE_INLINE_H = tree-inline.h vecir.h\n REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n@@ -1279,9 +1278,6 @@ OBJS-common = \\\n \tira-emit.o \\\n \tira-lives.o \\\n \tjump.o \\\n-\tlambda-code.o \\\n-\tlambda-mat.o \\\n-\tlambda-trans.o \\\n \tlanghooks.o \\\n \tlcm.o \\\n \tlists.o \\\n@@ -1379,7 +1375,6 @@ OBJS-common = \\\n \ttree-into-ssa.o \\\n \ttree-iterator.o \\\n \ttree-loop-distribution.o \\\n-\ttree-loop-linear.o \\\n \ttree-nested.o \\\n \ttree-nrv.o \\\n \ttree-object-size.o \\\n@@ -2331,7 +2326,7 @@ lto-section-out.o : lto-section-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) $(EXCEPT_H) pointer-set.h \\\n    $(BITMAP_H) langhooks.h $(LTO_STREAMER_H) lto-compress.h\n lto-symtab.o: lto-symtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_H) $(GIMPLE_H) $(GGC_H) $(LAMBDA_H) $(HASHTAB_H) \\\n+   $(TREE_H) $(GIMPLE_H) $(GGC_H) $(HASHTAB_H) \\\n    $(LTO_STREAMER_H) $(LINKER_PLUGIN_API_H) gt-lto-symtab.h\n lto-opts.o: lto-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n    $(HASHTAB_H) $(GGC_H) $(BITMAP_H) $(FLAGS_H) $(OPTS_H) $(OPTIONS_H) \\\n@@ -2711,7 +2706,7 @@ tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \\\n    $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(EXPR_H) $(RECOG_H) $(OPTABS_H) \\\n    $(DIAGNOSTIC_CORE_H) $(SCEV_H) $(TREE_VECTORIZER_H) tree-pretty-print.h \\\n-   gimple-pretty-print.h $(TARGET_H)\n+   gimple-pretty-print.h $(TARGET_H) $(TREE_DATA_REF_H)\n tree-vect-loop-manip.o: tree-vect-loop-manip.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(EXPR_H) $(DIAGNOSTIC_CORE_H) \\\n@@ -2726,7 +2721,7 @@ tree-vect-slp.o: tree-vect-slp.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n    $(EXPR_H) $(RECOG_H) $(OPTABS_H) $(TREE_VECTORIZER_H) tree-pretty-print.h \\\n-   gimple-pretty-print.h\n+   gimple-pretty-print.h $(TREE_DATA_REF_H)\n tree-vect-stmts.o: tree-vect-stmts.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n@@ -2742,8 +2737,6 @@ tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) $(TIMEVAR_H) \\\n    tree-pretty-print.h\n-tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H) $(LAMBDA_H)\n tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)\n tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -3462,12 +3455,6 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h $(EXCEPT_H) $(TM_P_H) \\\n    $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h $(TIMEVAR_H) \\\n    $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)\n-lambda-mat.o : lambda-mat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_FLOW_H) \\\n-   $(LAMBDA_H)\n-lambda-trans.o : lambda-trans.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_FLOW_H) $(LAMBDA_H)\n-lambda-code.o : lambda-code.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(LAMBDA_H) $(TREE_PASS_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) \\\n    $(DIAGNOSTIC_CORE_H)\n pointer-set.o: pointer-set.c pointer-set.h $(CONFIG_H) $(SYSTEM_H)"}, {"sha": "1eadd45da73ace7e9ef1745cb4efe664dff23b11", "filename": "gcc/hwint.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -228,4 +228,33 @@ exact_log2 (unsigned HOST_WIDE_INT x)\n \n #endif /* GCC_VERSION >= 3004 */\n \n+/* Compute the greatest common divisor of two numbers using\n+   Euclid's algorithm.  */\n+\n+static inline int\n+gcd (int a, int b)\n+{\n+  int x, y, z;\n+\n+  x = abs (a);\n+  y = abs (b);\n+\n+  while (x > 0)\n+    {\n+      z = y % x;\n+      y = x;\n+      x = z;\n+    }\n+\n+  return y;\n+}\n+\n+/* Compute the least common multiple of two numbers A and B .  */\n+\n+static inline int\n+least_common_multiple (int a, int b)\n+{\n+  return (abs (a) * abs (b) / gcd (a, b));\n+}\n+\n #endif /* ! GCC_HWINT_H */"}, {"sha": "f46207145c84fea072caee439be360fe424c7ed9", "filename": "gcc/lambda-code.c", "status": "removed", "additions": 0, "deletions": 2855, "changes": 2855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,2855 +0,0 @@\n-/*  Loop transformation code generation\n-    Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-    Free Software Foundation, Inc.\n-    Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-    This file is part of GCC.\n-\n-    GCC is free software; you can redistribute it and/or modify it under\n-    the terms of the GNU General Public License as published by the Free\n-    Software Foundation; either version 3, or (at your option) any later\n-    version.\n-\n-    GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-    WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-    for more details.\n-\n-    You should have received a copy of the GNU General Public License\n-    along with GCC; see the file COPYING3.  If not see\n-    <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree-flow.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-chrec.h\"\n-#include \"tree-data-ref.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"lambda.h\"\n-#include \"tree-pass.h\"\n-\n-/* This loop nest code generation is based on non-singular matrix\n-   math.\n-\n- A little terminology and a general sketch of the algorithm.  See \"A singular\n- loop transformation framework based on non-singular matrices\" by Wei Li and\n- Keshav Pingali for formal proofs that the various statements below are\n- correct.\n-\n- A loop iteration space represents the points traversed by the loop.  A point in the\n- iteration space can be represented by a vector of size <loop depth>.  You can\n- therefore represent the iteration space as an integral combinations of a set\n- of basis vectors.\n-\n- A loop iteration space is dense if every integer point between the loop\n- bounds is a point in the iteration space.  Every loop with a step of 1\n- therefore has a dense iteration space.\n-\n- for i = 1 to 3, step 1 is a dense iteration space.\n-\n- A loop iteration space is sparse if it is not dense.  That is, the iteration\n- space skips integer points that are within the loop bounds.\n-\n- for i = 1 to 3, step 2 is a sparse iteration space, because the integer point\n- 2 is skipped.\n-\n- Dense source spaces are easy to transform, because they don't skip any\n- points to begin with.  Thus we can compute the exact bounds of the target\n- space using min/max and floor/ceil.\n-\n- For a dense source space, we take the transformation matrix, decompose it\n- into a lower triangular part (H) and a unimodular part (U).\n- We then compute the auxiliary space from the unimodular part (source loop\n- nest . U = auxiliary space) , which has two important properties:\n-  1. It traverses the iterations in the same lexicographic order as the source\n-  space.\n-  2. It is a dense space when the source is a dense space (even if the target\n-  space is going to be sparse).\n-\n- Given the auxiliary space, we use the lower triangular part to compute the\n- bounds in the target space by simple matrix multiplication.\n- The gaps in the target space (IE the new loop step sizes) will be the\n- diagonals of the H matrix.\n-\n- Sparse source spaces require another step, because you can't directly compute\n- the exact bounds of the auxiliary and target space from the sparse space.\n- Rather than try to come up with a separate algorithm to handle sparse source\n- spaces directly, we just find a legal transformation matrix that gives you\n- the sparse source space, from a dense space, and then transform the dense\n- space.\n-\n- For a regular sparse space, you can represent the source space as an integer\n- lattice, and the base space of that lattice will always be dense.  Thus, we\n- effectively use the lattice to figure out the transformation from the lattice\n- base space, to the sparse iteration space (IE what transform was applied to\n- the dense space to make it sparse).  We then compose this transform with the\n- transformation matrix specified by the user (since our matrix transformations\n- are closed under composition, this is okay).  We can then use the base space\n- (which is dense) plus the composed transformation matrix, to compute the rest\n- of the transform using the dense space algorithm above.\n-\n- In other words, our sparse source space (B) is decomposed into a dense base\n- space (A), and a matrix (L) that transforms A into B, such that A.L = B.\n- We then compute the composition of L and the user transformation matrix (T),\n- so that T is now a transform from A to the result, instead of from B to the\n- result.\n- IE A.(LT) = result instead of B.T = result\n- Since A is now a dense source space, we can use the dense source space\n- algorithm above to compute the result of applying transform (LT) to A.\n-\n- Fourier-Motzkin elimination is used to compute the bounds of the base space\n- of the lattice.  */\n-\n-static bool perfect_nestify (struct loop *, VEC(tree,heap) *,\n-\t\t\t     VEC(tree,heap) *, VEC(int,heap) *,\n-\t\t\t     VEC(tree,heap) *);\n-/* Lattice stuff that is internal to the code generation algorithm.  */\n-\n-typedef struct lambda_lattice_s\n-{\n-  /* Lattice base matrix.  */\n-  lambda_matrix base;\n-  /* Lattice dimension.  */\n-  int dimension;\n-  /* Origin vector for the coefficients.  */\n-  lambda_vector origin;\n-  /* Origin matrix for the invariants.  */\n-  lambda_matrix origin_invariants;\n-  /* Number of invariants.  */\n-  int invariants;\n-} *lambda_lattice;\n-\n-#define LATTICE_BASE(T) ((T)->base)\n-#define LATTICE_DIMENSION(T) ((T)->dimension)\n-#define LATTICE_ORIGIN(T) ((T)->origin)\n-#define LATTICE_ORIGIN_INVARIANTS(T) ((T)->origin_invariants)\n-#define LATTICE_INVARIANTS(T) ((T)->invariants)\n-\n-static bool lle_equal (lambda_linear_expression, lambda_linear_expression,\n-\t\t       int, int);\n-static lambda_lattice lambda_lattice_new (int, int, struct obstack *);\n-static lambda_lattice lambda_lattice_compute_base (lambda_loopnest,\n-                                                   struct obstack *);\n-\n-static bool can_convert_to_perfect_nest (struct loop *);\n-\n-/* Create a new lambda loop in LAMBDA_OBSTACK.  */\n-\n-static lambda_loop\n-lambda_loop_new (struct obstack * lambda_obstack)\n-{\n-  lambda_loop result = (lambda_loop)\n-    obstack_alloc (lambda_obstack, sizeof (struct lambda_loop_s));\n-  memset (result, 0, sizeof (struct lambda_loop_s));\n-  return result;\n-}\n-\n-/* Create a new lambda body vector.  */\n-\n-lambda_body_vector\n-lambda_body_vector_new (int size, struct obstack * lambda_obstack)\n-{\n-  lambda_body_vector ret;\n-\n-  ret = (lambda_body_vector) obstack_alloc (lambda_obstack,\n-\t\t\t\t\t    sizeof (*ret));\n-  LBV_COEFFICIENTS (ret) = lambda_vector_new (size);\n-  LBV_SIZE (ret) = size;\n-  LBV_DENOMINATOR (ret) = 1;\n-  return ret;\n-}\n-\n-/* Compute the new coefficients for the vector based on the\n-  *inverse* of the transformation matrix.  */\n-\n-lambda_body_vector\n-lambda_body_vector_compute_new (lambda_trans_matrix transform,\n-                                lambda_body_vector vect,\n-                                struct obstack * lambda_obstack)\n-{\n-  lambda_body_vector temp;\n-  int depth;\n-\n-  /* Make sure the matrix is square.  */\n-  gcc_assert (LTM_ROWSIZE (transform) == LTM_COLSIZE (transform));\n-\n-  depth = LTM_ROWSIZE (transform);\n-\n-  temp = lambda_body_vector_new (depth, lambda_obstack);\n-  LBV_DENOMINATOR (temp) =\n-    LBV_DENOMINATOR (vect) * LTM_DENOMINATOR (transform);\n-  lambda_vector_matrix_mult (LBV_COEFFICIENTS (vect), depth,\n-\t\t\t     LTM_MATRIX (transform), depth,\n-\t\t\t     LBV_COEFFICIENTS (temp));\n-  LBV_SIZE (temp) = LBV_SIZE (vect);\n-  return temp;\n-}\n-\n-/* Print out a lambda body vector.  */\n-\n-void\n-print_lambda_body_vector (FILE * outfile, lambda_body_vector body)\n-{\n-  print_lambda_vector (outfile, LBV_COEFFICIENTS (body), LBV_SIZE (body));\n-}\n-\n-/* Return TRUE if two linear expressions are equal.  */\n-\n-static bool\n-lle_equal (lambda_linear_expression lle1, lambda_linear_expression lle2,\n-\t   int depth, int invariants)\n-{\n-  int i;\n-\n-  if (lle1 == NULL || lle2 == NULL)\n-    return false;\n-  if (LLE_CONSTANT (lle1) != LLE_CONSTANT (lle2))\n-    return false;\n-  if (LLE_DENOMINATOR (lle1) != LLE_DENOMINATOR (lle2))\n-    return false;\n-  for (i = 0; i < depth; i++)\n-    if (LLE_COEFFICIENTS (lle1)[i] != LLE_COEFFICIENTS (lle2)[i])\n-      return false;\n-  for (i = 0; i < invariants; i++)\n-    if (LLE_INVARIANT_COEFFICIENTS (lle1)[i] !=\n-\tLLE_INVARIANT_COEFFICIENTS (lle2)[i])\n-      return false;\n-  return true;\n-}\n-\n-/* Create a new linear expression with dimension DIM, and total number\n-   of invariants INVARIANTS.  */\n-\n-lambda_linear_expression\n-lambda_linear_expression_new (int dim, int invariants,\n-                              struct obstack * lambda_obstack)\n-{\n-  lambda_linear_expression ret;\n-\n-  ret = (lambda_linear_expression)obstack_alloc (lambda_obstack,\n-                                                 sizeof (*ret));\n-  LLE_COEFFICIENTS (ret) = lambda_vector_new (dim);\n-  LLE_CONSTANT (ret) = 0;\n-  LLE_INVARIANT_COEFFICIENTS (ret) = lambda_vector_new (invariants);\n-  LLE_DENOMINATOR (ret) = 1;\n-  LLE_NEXT (ret) = NULL;\n-\n-  return ret;\n-}\n-\n-/* Print out a linear expression EXPR, with SIZE coefficients, to OUTFILE.\n-   The starting letter used for variable names is START.  */\n-\n-static void\n-print_linear_expression (FILE * outfile, lambda_vector expr, int size,\n-\t\t\t char start)\n-{\n-  int i;\n-  bool first = true;\n-  for (i = 0; i < size; i++)\n-    {\n-      if (expr[i] != 0)\n-\t{\n-\t  if (first)\n-\t    {\n-\t      if (expr[i] < 0)\n-\t\tfprintf (outfile, \"-\");\n-\t      first = false;\n-\t    }\n-\t  else if (expr[i] > 0)\n-\t    fprintf (outfile, \" + \");\n-\t  else\n-\t    fprintf (outfile, \" - \");\n-\t  if (abs (expr[i]) == 1)\n-\t    fprintf (outfile, \"%c\", start + i);\n-\t  else\n-\t    fprintf (outfile, \"%d%c\", abs (expr[i]), start + i);\n-\t}\n-    }\n-}\n-\n-/* Print out a lambda linear expression structure, EXPR, to OUTFILE. The\n-   depth/number of coefficients is given by DEPTH, the number of invariants is\n-   given by INVARIANTS, and the character to start variable names with is given\n-   by START.  */\n-\n-void\n-print_lambda_linear_expression (FILE * outfile,\n-\t\t\t\tlambda_linear_expression expr,\n-\t\t\t\tint depth, int invariants, char start)\n-{\n-  fprintf (outfile, \"\\tLinear expression: \");\n-  print_linear_expression (outfile, LLE_COEFFICIENTS (expr), depth, start);\n-  fprintf (outfile, \" constant: %d \", LLE_CONSTANT (expr));\n-  fprintf (outfile, \"  invariants: \");\n-  print_linear_expression (outfile, LLE_INVARIANT_COEFFICIENTS (expr),\n-\t\t\t   invariants, 'A');\n-  fprintf (outfile, \"  denominator: %d\\n\", LLE_DENOMINATOR (expr));\n-}\n-\n-/* Print a lambda loop structure LOOP to OUTFILE.  The depth/number of\n-   coefficients is given by DEPTH, the number of invariants is\n-   given by INVARIANTS, and the character to start variable names with is given\n-   by START.  */\n-\n-void\n-print_lambda_loop (FILE * outfile, lambda_loop loop, int depth,\n-\t\t   int invariants, char start)\n-{\n-  int step;\n-  lambda_linear_expression expr;\n-\n-  gcc_assert (loop);\n-\n-  expr = LL_LINEAR_OFFSET (loop);\n-  step = LL_STEP (loop);\n-  fprintf (outfile, \"  step size = %d \\n\", step);\n-\n-  if (expr)\n-    {\n-      fprintf (outfile, \"  linear offset: \\n\");\n-      print_lambda_linear_expression (outfile, expr, depth, invariants,\n-\t\t\t\t      start);\n-    }\n-\n-  fprintf (outfile, \"  lower bound: \\n\");\n-  for (expr = LL_LOWER_BOUND (loop); expr != NULL; expr = LLE_NEXT (expr))\n-    print_lambda_linear_expression (outfile, expr, depth, invariants, start);\n-  fprintf (outfile, \"  upper bound: \\n\");\n-  for (expr = LL_UPPER_BOUND (loop); expr != NULL; expr = LLE_NEXT (expr))\n-    print_lambda_linear_expression (outfile, expr, depth, invariants, start);\n-}\n-\n-/* Create a new loop nest structure with DEPTH loops, and INVARIANTS as the\n-   number of invariants.  */\n-\n-lambda_loopnest\n-lambda_loopnest_new (int depth, int invariants,\n-                     struct obstack * lambda_obstack)\n-{\n-  lambda_loopnest ret;\n-  ret = (lambda_loopnest)obstack_alloc (lambda_obstack, sizeof (*ret));\n-\n-  LN_LOOPS (ret) = (lambda_loop *)\n-      obstack_alloc (lambda_obstack, depth * sizeof(LN_LOOPS(ret)));\n-  LN_DEPTH (ret) = depth;\n-  LN_INVARIANTS (ret) = invariants;\n-\n-  return ret;\n-}\n-\n-/* Print a lambda loopnest structure, NEST, to OUTFILE.  The starting\n-   character to use for loop names is given by START.  */\n-\n-void\n-print_lambda_loopnest (FILE * outfile, lambda_loopnest nest, char start)\n-{\n-  int i;\n-  for (i = 0; i < LN_DEPTH (nest); i++)\n-    {\n-      fprintf (outfile, \"Loop %c\\n\", start + i);\n-      print_lambda_loop (outfile, LN_LOOPS (nest)[i], LN_DEPTH (nest),\n-\t\t\t LN_INVARIANTS (nest), 'i');\n-      fprintf (outfile, \"\\n\");\n-    }\n-}\n-\n-/* Allocate a new lattice structure of DEPTH x DEPTH, with INVARIANTS number\n-   of invariants.  */\n-\n-static lambda_lattice\n-lambda_lattice_new (int depth, int invariants, struct obstack * lambda_obstack)\n-{\n-  lambda_lattice ret\n-      = (lambda_lattice)obstack_alloc (lambda_obstack, sizeof (*ret));\n-  LATTICE_BASE (ret) = lambda_matrix_new (depth, depth, lambda_obstack);\n-  LATTICE_ORIGIN (ret) = lambda_vector_new (depth);\n-  LATTICE_ORIGIN_INVARIANTS (ret) = lambda_matrix_new (depth, invariants,\n-\t\t\t\t\t\t       lambda_obstack);\n-  LATTICE_DIMENSION (ret) = depth;\n-  LATTICE_INVARIANTS (ret) = invariants;\n-  return ret;\n-}\n-\n-/* Compute the lattice base for NEST.  The lattice base is essentially a\n-   non-singular transform from a dense base space to a sparse iteration space.\n-   We use it so that we don't have to specially handle the case of a sparse\n-   iteration space in other parts of the algorithm.  As a result, this routine\n-   only does something interesting (IE produce a matrix that isn't the\n-   identity matrix) if NEST is a sparse space.  */\n-\n-static lambda_lattice\n-lambda_lattice_compute_base (lambda_loopnest nest,\n-                             struct obstack * lambda_obstack)\n-{\n-  lambda_lattice ret;\n-  int depth, invariants;\n-  lambda_matrix base;\n-\n-  int i, j, step;\n-  lambda_loop loop;\n-  lambda_linear_expression expression;\n-\n-  depth = LN_DEPTH (nest);\n-  invariants = LN_INVARIANTS (nest);\n-\n-  ret = lambda_lattice_new (depth, invariants, lambda_obstack);\n-  base = LATTICE_BASE (ret);\n-  for (i = 0; i < depth; i++)\n-    {\n-      loop = LN_LOOPS (nest)[i];\n-      gcc_assert (loop);\n-      step = LL_STEP (loop);\n-      /* If we have a step of 1, then the base is one, and the\n-         origin and invariant coefficients are 0.  */\n-      if (step == 1)\n-\t{\n-\t  for (j = 0; j < depth; j++)\n-\t    base[i][j] = 0;\n-\t  base[i][i] = 1;\n-\t  LATTICE_ORIGIN (ret)[i] = 0;\n-\t  for (j = 0; j < invariants; j++)\n-\t    LATTICE_ORIGIN_INVARIANTS (ret)[i][j] = 0;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, we need the lower bound expression (which must\n-\t     be an affine function)  to determine the base.  */\n-\t  expression = LL_LOWER_BOUND (loop);\n-\t  gcc_assert (expression && !LLE_NEXT (expression)\n-\t\t      && LLE_DENOMINATOR (expression) == 1);\n-\n-\t  /* The lower triangular portion of the base is going to be the\n-\t     coefficient times the step */\n-\t  for (j = 0; j < i; j++)\n-\t    base[i][j] = LLE_COEFFICIENTS (expression)[j]\n-\t      * LL_STEP (LN_LOOPS (nest)[j]);\n-\t  base[i][i] = step;\n-\t  for (j = i + 1; j < depth; j++)\n-\t    base[i][j] = 0;\n-\n-\t  /* Origin for this loop is the constant of the lower bound\n-\t     expression.  */\n-\t  LATTICE_ORIGIN (ret)[i] = LLE_CONSTANT (expression);\n-\n-\t  /* Coefficient for the invariants are equal to the invariant\n-\t     coefficients in the expression.  */\n-\t  for (j = 0; j < invariants; j++)\n-\t    LATTICE_ORIGIN_INVARIANTS (ret)[i][j] =\n-\t      LLE_INVARIANT_COEFFICIENTS (expression)[j];\n-\t}\n-    }\n-  return ret;\n-}\n-\n-/* Compute the least common multiple of two numbers A and B .  */\n-\n-int\n-least_common_multiple (int a, int b)\n-{\n-  return (abs (a) * abs (b) / gcd (a, b));\n-}\n-\n-/* Perform Fourier-Motzkin elimination to calculate the bounds of the\n-   auxiliary nest.\n-   Fourier-Motzkin is a way of reducing systems of linear inequalities so that\n-   it is easy to calculate the answer and bounds.\n-   A sketch of how it works:\n-   Given a system of linear inequalities, ai * xj >= bk, you can always\n-   rewrite the constraints so they are all of the form\n-   a <= x, or x <= b, or x >= constant for some x in x1 ... xj (and some b\n-   in b1 ... bk, and some a in a1...ai)\n-   You can then eliminate this x from the non-constant inequalities by\n-   rewriting these as a <= b, x >= constant, and delete the x variable.\n-   You can then repeat this for any remaining x variables, and then we have\n-   an easy to use variable <= constant (or no variables at all) form that we\n-   can construct our bounds from.\n-\n-   In our case, each time we eliminate, we construct part of the bound from\n-   the ith variable, then delete the ith variable.\n-\n-   Remember the constant are in our vector a, our coefficient matrix is A,\n-   and our invariant coefficient matrix is B.\n-\n-   SIZE is the size of the matrices being passed.\n-   DEPTH is the loop nest depth.\n-   INVARIANTS is the number of loop invariants.\n-   A, B, and a are the coefficient matrix, invariant coefficient, and a\n-   vector of constants, respectively.  */\n-\n-static lambda_loopnest\n-compute_nest_using_fourier_motzkin (int size,\n-\t\t\t\t    int depth,\n-\t\t\t\t    int invariants,\n-\t\t\t\t    lambda_matrix A,\n-\t\t\t\t    lambda_matrix B,\n-                                    lambda_vector a,\n-                                    struct obstack * lambda_obstack)\n-{\n-\n-  int multiple, f1, f2;\n-  int i, j, k;\n-  lambda_linear_expression expression;\n-  lambda_loop loop;\n-  lambda_loopnest auxillary_nest;\n-  lambda_matrix swapmatrix, A1, B1;\n-  lambda_vector swapvector, a1;\n-  int newsize;\n-\n-  A1 = lambda_matrix_new (128, depth, lambda_obstack);\n-  B1 = lambda_matrix_new (128, invariants, lambda_obstack);\n-  a1 = lambda_vector_new (128);\n-\n-  auxillary_nest = lambda_loopnest_new (depth, invariants, lambda_obstack);\n-\n-  for (i = depth - 1; i >= 0; i--)\n-    {\n-      loop = lambda_loop_new (lambda_obstack);\n-      LN_LOOPS (auxillary_nest)[i] = loop;\n-      LL_STEP (loop) = 1;\n-\n-      for (j = 0; j < size; j++)\n-\t{\n-\t  if (A[j][i] < 0)\n-\t    {\n-\t      /* Any linear expression in the matrix with a coefficient less\n-\t\t than 0 becomes part of the new lower bound.  */\n-              expression = lambda_linear_expression_new (depth, invariants,\n-                                                         lambda_obstack);\n-\n-\t      for (k = 0; k < i; k++)\n-\t\tLLE_COEFFICIENTS (expression)[k] = A[j][k];\n-\n-\t      for (k = 0; k < invariants; k++)\n-\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = -1 * B[j][k];\n-\n-\t      LLE_DENOMINATOR (expression) = -1 * A[j][i];\n-\t      LLE_CONSTANT (expression) = -1 * a[j];\n-\n-\t      /* Ignore if identical to the existing lower bound.  */\n-\t      if (!lle_equal (LL_LOWER_BOUND (loop),\n-\t\t\t      expression, depth, invariants))\n-\t\t{\n-\t\t  LLE_NEXT (expression) = LL_LOWER_BOUND (loop);\n-\t\t  LL_LOWER_BOUND (loop) = expression;\n-\t\t}\n-\n-\t    }\n-\t  else if (A[j][i] > 0)\n-\t    {\n-\t      /* Any linear expression with a coefficient greater than 0\n-\t\t becomes part of the new upper bound.  */\n-              expression = lambda_linear_expression_new (depth, invariants,\n-                                                         lambda_obstack);\n-\t      for (k = 0; k < i; k++)\n-\t\tLLE_COEFFICIENTS (expression)[k] = -1 * A[j][k];\n-\n-\t      for (k = 0; k < invariants; k++)\n-\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = B[j][k];\n-\n-\t      LLE_DENOMINATOR (expression) = A[j][i];\n-\t      LLE_CONSTANT (expression) = a[j];\n-\n-\t      /* Ignore if identical to the existing upper bound.  */\n-\t      if (!lle_equal (LL_UPPER_BOUND (loop),\n-\t\t\t      expression, depth, invariants))\n-\t\t{\n-\t\t  LLE_NEXT (expression) = LL_UPPER_BOUND (loop);\n-\t\t  LL_UPPER_BOUND (loop) = expression;\n-\t\t}\n-\n-\t    }\n-\t}\n-\n-      /* This portion creates a new system of linear inequalities by deleting\n-\t the i'th variable, reducing the system by one variable.  */\n-      newsize = 0;\n-      for (j = 0; j < size; j++)\n-\t{\n-\t  /* If the coefficient for the i'th variable is 0, then we can just\n-\t     eliminate the variable straightaway.  Otherwise, we have to\n-\t     multiply through by the coefficients we are eliminating.  */\n-\t  if (A[j][i] == 0)\n-\t    {\n-\t      lambda_vector_copy (A[j], A1[newsize], depth);\n-\t      lambda_vector_copy (B[j], B1[newsize], invariants);\n-\t      a1[newsize] = a[j];\n-\t      newsize++;\n-\t    }\n-\t  else if (A[j][i] > 0)\n-\t    {\n-\t      for (k = 0; k < size; k++)\n-\t\t{\n-\t\t  if (A[k][i] < 0)\n-\t\t    {\n-\t\t      multiple = least_common_multiple (A[j][i], A[k][i]);\n-\t\t      f1 = multiple / A[j][i];\n-\t\t      f2 = -1 * multiple / A[k][i];\n-\n-\t\t      lambda_vector_add_mc (A[j], f1, A[k], f2,\n-\t\t\t\t\t    A1[newsize], depth);\n-\t\t      lambda_vector_add_mc (B[j], f1, B[k], f2,\n-\t\t\t\t\t    B1[newsize], invariants);\n-\t\t      a1[newsize] = f1 * a[j] + f2 * a[k];\n-\t\t      newsize++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      swapmatrix = A;\n-      A = A1;\n-      A1 = swapmatrix;\n-\n-      swapmatrix = B;\n-      B = B1;\n-      B1 = swapmatrix;\n-\n-      swapvector = a;\n-      a = a1;\n-      a1 = swapvector;\n-\n-      size = newsize;\n-    }\n-\n-  return auxillary_nest;\n-}\n-\n-/* Compute the loop bounds for the auxiliary space NEST.\n-   Input system used is Ax <= b.  TRANS is the unimodular transformation.\n-   Given the original nest, this function will\n-   1. Convert the nest into matrix form, which consists of a matrix for the\n-   coefficients, a matrix for the\n-   invariant coefficients, and a vector for the constants.\n-   2. Use the matrix form to calculate the lattice base for the nest (which is\n-   a dense space)\n-   3. Compose the dense space transform with the user specified transform, to\n-   get a transform we can easily calculate transformed bounds for.\n-   4. Multiply the composed transformation matrix times the matrix form of the\n-   loop.\n-   5. Transform the newly created matrix (from step 4) back into a loop nest\n-   using Fourier-Motzkin elimination to figure out the bounds.  */\n-\n-static lambda_loopnest\n-lambda_compute_auxillary_space (lambda_loopnest nest,\n-                                lambda_trans_matrix trans,\n-                                struct obstack * lambda_obstack)\n-{\n-  lambda_matrix A, B, A1, B1;\n-  lambda_vector a, a1;\n-  lambda_matrix invertedtrans;\n-  int depth, invariants, size;\n-  int i, j;\n-  lambda_loop loop;\n-  lambda_linear_expression expression;\n-  lambda_lattice lattice;\n-\n-  depth = LN_DEPTH (nest);\n-  invariants = LN_INVARIANTS (nest);\n-\n-  /* Unfortunately, we can't know the number of constraints we'll have\n-     ahead of time, but this should be enough even in ridiculous loop nest\n-     cases. We must not go over this limit.  */\n-  A = lambda_matrix_new (128, depth, lambda_obstack);\n-  B = lambda_matrix_new (128, invariants, lambda_obstack);\n-  a = lambda_vector_new (128);\n-\n-  A1 = lambda_matrix_new (128, depth, lambda_obstack);\n-  B1 = lambda_matrix_new (128, invariants, lambda_obstack);\n-  a1 = lambda_vector_new (128);\n-\n-  /* Store the bounds in the equation matrix A, constant vector a, and\n-     invariant matrix B, so that we have Ax <= a + B.\n-     This requires a little equation rearranging so that everything is on the\n-     correct side of the inequality.  */\n-  size = 0;\n-  for (i = 0; i < depth; i++)\n-    {\n-      loop = LN_LOOPS (nest)[i];\n-\n-      /* First we do the lower bound.  */\n-      if (LL_STEP (loop) > 0)\n-\texpression = LL_LOWER_BOUND (loop);\n-      else\n-\texpression = LL_UPPER_BOUND (loop);\n-\n-      for (; expression != NULL; expression = LLE_NEXT (expression))\n-\t{\n-\t  /* Fill in the coefficient.  */\n-\t  for (j = 0; j < i; j++)\n-\t    A[size][j] = LLE_COEFFICIENTS (expression)[j];\n-\n-\t  /* And the invariant coefficient.  */\n-\t  for (j = 0; j < invariants; j++)\n-\t    B[size][j] = LLE_INVARIANT_COEFFICIENTS (expression)[j];\n-\n-\t  /* And the constant.  */\n-\t  a[size] = LLE_CONSTANT (expression);\n-\n-\t  /* Convert (2x+3y+2+b)/4 <= z to 2x+3y-4z <= -2-b.  IE put all\n-\t     constants and single variables on   */\n-\t  A[size][i] = -1 * LLE_DENOMINATOR (expression);\n-\t  a[size] *= -1;\n-\t  for (j = 0; j < invariants; j++)\n-\t    B[size][j] *= -1;\n-\n-\t  size++;\n-\t  /* Need to increase matrix sizes above.  */\n-\t  gcc_assert (size <= 127);\n-\n-\t}\n-\n-      /* Then do the exact same thing for the upper bounds.  */\n-      if (LL_STEP (loop) > 0)\n-\texpression = LL_UPPER_BOUND (loop);\n-      else\n-\texpression = LL_LOWER_BOUND (loop);\n-\n-      for (; expression != NULL; expression = LLE_NEXT (expression))\n-\t{\n-\t  /* Fill in the coefficient.  */\n-\t  for (j = 0; j < i; j++)\n-\t    A[size][j] = LLE_COEFFICIENTS (expression)[j];\n-\n-\t  /* And the invariant coefficient.  */\n-\t  for (j = 0; j < invariants; j++)\n-\t    B[size][j] = LLE_INVARIANT_COEFFICIENTS (expression)[j];\n-\n-\t  /* And the constant.  */\n-\t  a[size] = LLE_CONSTANT (expression);\n-\n-\t  /* Convert z <= (2x+3y+2+b)/4 to -2x-3y+4z <= 2+b.  */\n-\t  for (j = 0; j < i; j++)\n-\t    A[size][j] *= -1;\n-\t  A[size][i] = LLE_DENOMINATOR (expression);\n-\t  size++;\n-\t  /* Need to increase matrix sizes above.  */\n-\t  gcc_assert (size <= 127);\n-\n-\t}\n-    }\n-\n-  /* Compute the lattice base x = base * y + origin, where y is the\n-     base space.  */\n-  lattice = lambda_lattice_compute_base (nest, lambda_obstack);\n-\n-  /* Ax <= a + B then becomes ALy <= a+B - A*origin.  L is the lattice base  */\n-\n-  /* A1 = A * L */\n-  lambda_matrix_mult (A, LATTICE_BASE (lattice), A1, size, depth, depth);\n-\n-  /* a1 = a - A * origin constant.  */\n-  lambda_matrix_vector_mult (A, size, depth, LATTICE_ORIGIN (lattice), a1);\n-  lambda_vector_add_mc (a, 1, a1, -1, a1, size);\n-\n-  /* B1 = B - A * origin invariant.  */\n-  lambda_matrix_mult (A, LATTICE_ORIGIN_INVARIANTS (lattice), B1, size, depth,\n-\t\t      invariants);\n-  lambda_matrix_add_mc (B, 1, B1, -1, B1, size, invariants);\n-\n-  /* Now compute the auxiliary space bounds by first inverting U, multiplying\n-     it by A1, then performing Fourier-Motzkin.  */\n-\n-  invertedtrans = lambda_matrix_new (depth, depth, lambda_obstack);\n-\n-  /* Compute the inverse of U.  */\n-  lambda_matrix_inverse (LTM_MATRIX (trans),\n-\t\t\t invertedtrans, depth, lambda_obstack);\n-\n-  /* A = A1 inv(U).  */\n-  lambda_matrix_mult (A1, invertedtrans, A, size, depth, depth);\n-\n-  return compute_nest_using_fourier_motzkin (size, depth, invariants,\n-                                             A, B1, a1, lambda_obstack);\n-}\n-\n-/* Compute the loop bounds for the target space, using the bounds of\n-   the auxiliary nest AUXILLARY_NEST, and the triangular matrix H.\n-   The target space loop bounds are computed by multiplying the triangular\n-   matrix H by the auxiliary nest, to get the new loop bounds.  The sign of\n-   the loop steps (positive or negative) is then used to swap the bounds if\n-   the loop counts downwards.\n-   Return the target loopnest.  */\n-\n-static lambda_loopnest\n-lambda_compute_target_space (lambda_loopnest auxillary_nest,\n-                             lambda_trans_matrix H, lambda_vector stepsigns,\n-                             struct obstack * lambda_obstack)\n-{\n-  lambda_matrix inverse, H1;\n-  int determinant, i, j;\n-  int gcd1, gcd2;\n-  int factor;\n-\n-  lambda_loopnest target_nest;\n-  int depth, invariants;\n-  lambda_matrix target;\n-\n-  lambda_loop auxillary_loop, target_loop;\n-  lambda_linear_expression expression, auxillary_expr, target_expr, tmp_expr;\n-\n-  depth = LN_DEPTH (auxillary_nest);\n-  invariants = LN_INVARIANTS (auxillary_nest);\n-\n-  inverse = lambda_matrix_new (depth, depth, lambda_obstack);\n-  determinant = lambda_matrix_inverse (LTM_MATRIX (H), inverse, depth,\n-\t\t\t\t       lambda_obstack);\n-\n-  /* H1 is H excluding its diagonal.  */\n-  H1 = lambda_matrix_new (depth, depth, lambda_obstack);\n-  lambda_matrix_copy (LTM_MATRIX (H), H1, depth, depth);\n-\n-  for (i = 0; i < depth; i++)\n-    H1[i][i] = 0;\n-\n-  /* Computes the linear offsets of the loop bounds.  */\n-  target = lambda_matrix_new (depth, depth, lambda_obstack);\n-  lambda_matrix_mult (H1, inverse, target, depth, depth, depth);\n-\n-  target_nest = lambda_loopnest_new (depth, invariants, lambda_obstack);\n-\n-  for (i = 0; i < depth; i++)\n-    {\n-\n-      /* Get a new loop structure.  */\n-      target_loop = lambda_loop_new (lambda_obstack);\n-      LN_LOOPS (target_nest)[i] = target_loop;\n-\n-      /* Computes the gcd of the coefficients of the linear part.  */\n-      gcd1 = lambda_vector_gcd (target[i], i);\n-\n-      /* Include the denominator in the GCD.  */\n-      gcd1 = gcd (gcd1, determinant);\n-\n-      /* Now divide through by the gcd.  */\n-      for (j = 0; j < i; j++)\n-\ttarget[i][j] = target[i][j] / gcd1;\n-\n-      expression = lambda_linear_expression_new (depth, invariants,\n-                                                 lambda_obstack);\n-      lambda_vector_copy (target[i], LLE_COEFFICIENTS (expression), depth);\n-      LLE_DENOMINATOR (expression) = determinant / gcd1;\n-      LLE_CONSTANT (expression) = 0;\n-      lambda_vector_clear (LLE_INVARIANT_COEFFICIENTS (expression),\n-\t\t\t   invariants);\n-      LL_LINEAR_OFFSET (target_loop) = expression;\n-    }\n-\n-  /* For each loop, compute the new bounds from H.  */\n-  for (i = 0; i < depth; i++)\n-    {\n-      auxillary_loop = LN_LOOPS (auxillary_nest)[i];\n-      target_loop = LN_LOOPS (target_nest)[i];\n-      LL_STEP (target_loop) = LTM_MATRIX (H)[i][i];\n-      factor = LTM_MATRIX (H)[i][i];\n-\n-      /* First we do the lower bound.  */\n-      auxillary_expr = LL_LOWER_BOUND (auxillary_loop);\n-\n-      for (; auxillary_expr != NULL;\n-\t   auxillary_expr = LLE_NEXT (auxillary_expr))\n-\t{\n-          target_expr = lambda_linear_expression_new (depth, invariants,\n-                                                      lambda_obstack);\n-\t  lambda_vector_matrix_mult (LLE_COEFFICIENTS (auxillary_expr),\n-\t\t\t\t     depth, inverse, depth,\n-\t\t\t\t     LLE_COEFFICIENTS (target_expr));\n-\t  lambda_vector_mult_const (LLE_COEFFICIENTS (target_expr),\n-\t\t\t\t    LLE_COEFFICIENTS (target_expr), depth,\n-\t\t\t\t    factor);\n-\n-\t  LLE_CONSTANT (target_expr) = LLE_CONSTANT (auxillary_expr) * factor;\n-\t  lambda_vector_copy (LLE_INVARIANT_COEFFICIENTS (auxillary_expr),\n-\t\t\t      LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t      invariants);\n-\t  lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t\t    LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t\t    invariants, factor);\n-\t  LLE_DENOMINATOR (target_expr) = LLE_DENOMINATOR (auxillary_expr);\n-\n-\t  if (!lambda_vector_zerop (LLE_COEFFICIENTS (target_expr), depth))\n-\t    {\n-\t      LLE_CONSTANT (target_expr) = LLE_CONSTANT (target_expr)\n-\t\t* determinant;\n-\t      lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS\n-\t\t\t\t\t(target_expr),\n-\t\t\t\t\tLLE_INVARIANT_COEFFICIENTS\n-\t\t\t\t\t(target_expr), invariants,\n-\t\t\t\t\tdeterminant);\n-\t      LLE_DENOMINATOR (target_expr) =\n-\t\tLLE_DENOMINATOR (target_expr) * determinant;\n-\t    }\n-\t  /* Find the gcd and divide by it here, rather than doing it\n-\t     at the tree level.  */\n-\t  gcd1 = lambda_vector_gcd (LLE_COEFFICIENTS (target_expr), depth);\n-\t  gcd2 = lambda_vector_gcd (LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t\t    invariants);\n-\t  gcd1 = gcd (gcd1, gcd2);\n-\t  gcd1 = gcd (gcd1, LLE_CONSTANT (target_expr));\n-\t  gcd1 = gcd (gcd1, LLE_DENOMINATOR (target_expr));\n-\t  for (j = 0; j < depth; j++)\n-\t    LLE_COEFFICIENTS (target_expr)[j] /= gcd1;\n-\t  for (j = 0; j < invariants; j++)\n-\t    LLE_INVARIANT_COEFFICIENTS (target_expr)[j] /= gcd1;\n-\t  LLE_CONSTANT (target_expr) /= gcd1;\n-\t  LLE_DENOMINATOR (target_expr) /= gcd1;\n-\t  /* Ignore if identical to existing bound.  */\n-\t  if (!lle_equal (LL_LOWER_BOUND (target_loop), target_expr, depth,\n-\t\t\t  invariants))\n-\t    {\n-\t      LLE_NEXT (target_expr) = LL_LOWER_BOUND (target_loop);\n-\t      LL_LOWER_BOUND (target_loop) = target_expr;\n-\t    }\n-\t}\n-      /* Now do the upper bound.  */\n-      auxillary_expr = LL_UPPER_BOUND (auxillary_loop);\n-\n-      for (; auxillary_expr != NULL;\n-\t   auxillary_expr = LLE_NEXT (auxillary_expr))\n-\t{\n-          target_expr = lambda_linear_expression_new (depth, invariants,\n-                                                      lambda_obstack);\n-\t  lambda_vector_matrix_mult (LLE_COEFFICIENTS (auxillary_expr),\n-\t\t\t\t     depth, inverse, depth,\n-\t\t\t\t     LLE_COEFFICIENTS (target_expr));\n-\t  lambda_vector_mult_const (LLE_COEFFICIENTS (target_expr),\n-\t\t\t\t    LLE_COEFFICIENTS (target_expr), depth,\n-\t\t\t\t    factor);\n-\t  LLE_CONSTANT (target_expr) = LLE_CONSTANT (auxillary_expr) * factor;\n-\t  lambda_vector_copy (LLE_INVARIANT_COEFFICIENTS (auxillary_expr),\n-\t\t\t      LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t      invariants);\n-\t  lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t\t    LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t\t    invariants, factor);\n-\t  LLE_DENOMINATOR (target_expr) = LLE_DENOMINATOR (auxillary_expr);\n-\n-\t  if (!lambda_vector_zerop (LLE_COEFFICIENTS (target_expr), depth))\n-\t    {\n-\t      LLE_CONSTANT (target_expr) = LLE_CONSTANT (target_expr)\n-\t\t* determinant;\n-\t      lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS\n-\t\t\t\t\t(target_expr),\n-\t\t\t\t\tLLE_INVARIANT_COEFFICIENTS\n-\t\t\t\t\t(target_expr), invariants,\n-\t\t\t\t\tdeterminant);\n-\t      LLE_DENOMINATOR (target_expr) =\n-\t\tLLE_DENOMINATOR (target_expr) * determinant;\n-\t    }\n-\t  /* Find the gcd and divide by it here, instead of at the\n-\t     tree level.  */\n-\t  gcd1 = lambda_vector_gcd (LLE_COEFFICIENTS (target_expr), depth);\n-\t  gcd2 = lambda_vector_gcd (LLE_INVARIANT_COEFFICIENTS (target_expr),\n-\t\t\t\t    invariants);\n-\t  gcd1 = gcd (gcd1, gcd2);\n-\t  gcd1 = gcd (gcd1, LLE_CONSTANT (target_expr));\n-\t  gcd1 = gcd (gcd1, LLE_DENOMINATOR (target_expr));\n-\t  for (j = 0; j < depth; j++)\n-\t    LLE_COEFFICIENTS (target_expr)[j] /= gcd1;\n-\t  for (j = 0; j < invariants; j++)\n-\t    LLE_INVARIANT_COEFFICIENTS (target_expr)[j] /= gcd1;\n-\t  LLE_CONSTANT (target_expr) /= gcd1;\n-\t  LLE_DENOMINATOR (target_expr) /= gcd1;\n-\t  /* Ignore if equal to existing bound.  */\n-\t  if (!lle_equal (LL_UPPER_BOUND (target_loop), target_expr, depth,\n-\t\t\t  invariants))\n-\t    {\n-\t      LLE_NEXT (target_expr) = LL_UPPER_BOUND (target_loop);\n-\t      LL_UPPER_BOUND (target_loop) = target_expr;\n-\t    }\n-\t}\n-    }\n-  for (i = 0; i < depth; i++)\n-    {\n-      target_loop = LN_LOOPS (target_nest)[i];\n-      /* If necessary, exchange the upper and lower bounds and negate\n-         the step size.  */\n-      if (stepsigns[i] < 0)\n-\t{\n-\t  LL_STEP (target_loop) *= -1;\n-\t  tmp_expr = LL_LOWER_BOUND (target_loop);\n-\t  LL_LOWER_BOUND (target_loop) = LL_UPPER_BOUND (target_loop);\n-\t  LL_UPPER_BOUND (target_loop) = tmp_expr;\n-\t}\n-    }\n-  return target_nest;\n-}\n-\n-/* Compute the step signs of TRANS, using TRANS and stepsigns.  Return the new\n-   result.  */\n-\n-static lambda_vector\n-lambda_compute_step_signs (lambda_trans_matrix trans,\n-                           lambda_vector stepsigns,\n-                           struct obstack * lambda_obstack)\n-{\n-  lambda_matrix matrix, H;\n-  int size;\n-  lambda_vector newsteps;\n-  int i, j, factor, minimum_column;\n-  int temp;\n-\n-  matrix = LTM_MATRIX (trans);\n-  size = LTM_ROWSIZE (trans);\n-  H = lambda_matrix_new (size, size, lambda_obstack);\n-\n-  newsteps = lambda_vector_new (size);\n-  lambda_vector_copy (stepsigns, newsteps, size);\n-\n-  lambda_matrix_copy (matrix, H, size, size);\n-\n-  for (j = 0; j < size; j++)\n-    {\n-      lambda_vector row;\n-      row = H[j];\n-      for (i = j; i < size; i++)\n-\tif (row[i] < 0)\n-\t  lambda_matrix_col_negate (H, size, i);\n-      while (lambda_vector_first_nz (row, size, j + 1) < size)\n-\t{\n-\t  minimum_column = lambda_vector_min_nz (row, size, j);\n-\t  lambda_matrix_col_exchange (H, size, j, minimum_column);\n-\n-\t  temp = newsteps[j];\n-\t  newsteps[j] = newsteps[minimum_column];\n-\t  newsteps[minimum_column] = temp;\n-\n-\t  for (i = j + 1; i < size; i++)\n-\t    {\n-\t      factor = row[i] / row[j];\n-\t      lambda_matrix_col_add (H, size, j, i, -1 * factor);\n-\t    }\n-\t}\n-    }\n-  return newsteps;\n-}\n-\n-/* Transform NEST according to TRANS, and return the new loopnest.\n-   This involves\n-   1. Computing a lattice base for the transformation\n-   2. Composing the dense base with the specified transformation (TRANS)\n-   3. Decomposing the combined transformation into a lower triangular portion,\n-   and a unimodular portion.\n-   4. Computing the auxiliary nest using the unimodular portion.\n-   5. Computing the target nest using the auxiliary nest and the lower\n-   triangular portion.  */\n-\n-lambda_loopnest\n-lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans,\n-                           struct obstack * lambda_obstack)\n-{\n-  lambda_loopnest auxillary_nest, target_nest;\n-\n-  int depth, invariants;\n-  int i, j;\n-  lambda_lattice lattice;\n-  lambda_trans_matrix trans1, H, U;\n-  lambda_loop loop;\n-  lambda_linear_expression expression;\n-  lambda_vector origin;\n-  lambda_matrix origin_invariants;\n-  lambda_vector stepsigns;\n-  int f;\n-\n-  depth = LN_DEPTH (nest);\n-  invariants = LN_INVARIANTS (nest);\n-\n-  /* Keep track of the signs of the loop steps.  */\n-  stepsigns = lambda_vector_new (depth);\n-  for (i = 0; i < depth; i++)\n-    {\n-      if (LL_STEP (LN_LOOPS (nest)[i]) > 0)\n-\tstepsigns[i] = 1;\n-      else\n-\tstepsigns[i] = -1;\n-    }\n-\n-  /* Compute the lattice base.  */\n-  lattice = lambda_lattice_compute_base (nest, lambda_obstack);\n-  trans1 = lambda_trans_matrix_new (depth, depth, lambda_obstack);\n-\n-  /* Multiply the transformation matrix by the lattice base.  */\n-\n-  lambda_matrix_mult (LTM_MATRIX (trans), LATTICE_BASE (lattice),\n-\t\t      LTM_MATRIX (trans1), depth, depth, depth);\n-\n-  /* Compute the Hermite normal form for the new transformation matrix.  */\n-  H = lambda_trans_matrix_new (depth, depth, lambda_obstack);\n-  U = lambda_trans_matrix_new (depth, depth, lambda_obstack);\n-  lambda_matrix_hermite (LTM_MATRIX (trans1), depth, LTM_MATRIX (H),\n-\t\t\t LTM_MATRIX (U));\n-\n-  /* Compute the auxiliary loop nest's space from the unimodular\n-     portion.  */\n-  auxillary_nest = lambda_compute_auxillary_space (nest, U,\n-\t\t\t\t\t\t   lambda_obstack);\n-\n-  /* Compute the loop step signs from the old step signs and the\n-     transformation matrix.  */\n-  stepsigns = lambda_compute_step_signs (trans1, stepsigns,\n-\t\t\t\t\t lambda_obstack);\n-\n-  /* Compute the target loop nest space from the auxiliary nest and\n-     the lower triangular matrix H.  */\n-  target_nest = lambda_compute_target_space (auxillary_nest, H, stepsigns,\n-                                             lambda_obstack);\n-  origin = lambda_vector_new (depth);\n-  origin_invariants = lambda_matrix_new (depth, invariants, lambda_obstack);\n-  lambda_matrix_vector_mult (LTM_MATRIX (trans), depth, depth,\n-\t\t\t     LATTICE_ORIGIN (lattice), origin);\n-  lambda_matrix_mult (LTM_MATRIX (trans), LATTICE_ORIGIN_INVARIANTS (lattice),\n-\t\t      origin_invariants, depth, depth, invariants);\n-\n-  for (i = 0; i < depth; i++)\n-    {\n-      loop = LN_LOOPS (target_nest)[i];\n-      expression = LL_LINEAR_OFFSET (loop);\n-      if (lambda_vector_zerop (LLE_COEFFICIENTS (expression), depth))\n-\tf = 1;\n-      else\n-\tf = LLE_DENOMINATOR (expression);\n-\n-      LLE_CONSTANT (expression) += f * origin[i];\n-\n-      for (j = 0; j < invariants; j++)\n-\tLLE_INVARIANT_COEFFICIENTS (expression)[j] +=\n-\t  f * origin_invariants[i][j];\n-    }\n-\n-  return target_nest;\n-\n-}\n-\n-/* Convert a gcc tree expression EXPR to a lambda linear expression, and\n-   return the new expression.  DEPTH is the depth of the loopnest.\n-   OUTERINDUCTIONVARS is an array of the induction variables for outer loops\n-   in this nest.  INVARIANTS is the array of invariants for the loop.  EXTRA\n-   is the amount we have to add/subtract from the expression because of the\n-   type of comparison it is used in.  */\n-\n-static lambda_linear_expression\n-gcc_tree_to_linear_expression (int depth, tree expr,\n-\t\t\t       VEC(tree,heap) *outerinductionvars,\n-                               VEC(tree,heap) *invariants, int extra,\n-                               struct obstack * lambda_obstack)\n-{\n-  lambda_linear_expression lle = NULL;\n-  switch (TREE_CODE (expr))\n-    {\n-    case INTEGER_CST:\n-      {\n-        lle = lambda_linear_expression_new (depth, 2 * depth, lambda_obstack);\n-\tLLE_CONSTANT (lle) = TREE_INT_CST_LOW (expr);\n-\tif (extra != 0)\n-\t  LLE_CONSTANT (lle) += extra;\n-\n-\tLLE_DENOMINATOR (lle) = 1;\n-      }\n-      break;\n-    case SSA_NAME:\n-      {\n-\ttree iv, invar;\n-\tsize_t i;\n-\tFOR_EACH_VEC_ELT (tree, outerinductionvars, i, iv)\n-\t  if (iv != NULL)\n-\t    {\n-\t      if (SSA_NAME_VAR (iv) == SSA_NAME_VAR (expr))\n-\t\t{\n-                  lle = lambda_linear_expression_new (depth, 2 * depth,\n-                                                      lambda_obstack);\n-\t\t  LLE_COEFFICIENTS (lle)[i] = 1;\n-\t\t  if (extra != 0)\n-\t\t    LLE_CONSTANT (lle) = extra;\n-\n-\t\t  LLE_DENOMINATOR (lle) = 1;\n-\t\t}\n-\t    }\n-\tFOR_EACH_VEC_ELT (tree, invariants, i, invar)\n-\t  if (invar != NULL)\n-\t    {\n-\t      if (SSA_NAME_VAR (invar) == SSA_NAME_VAR (expr))\n-\t\t{\n-                  lle = lambda_linear_expression_new (depth, 2 * depth,\n-                                                      lambda_obstack);\n-\t\t  LLE_INVARIANT_COEFFICIENTS (lle)[i] = 1;\n-\t\t  if (extra != 0)\n-\t\t    LLE_CONSTANT (lle) = extra;\n-\t\t  LLE_DENOMINATOR (lle) = 1;\n-\t\t}\n-\t    }\n-      }\n-      break;\n-    default:\n-      return NULL;\n-    }\n-\n-  return lle;\n-}\n-\n-/* Return the depth of the loopnest NEST */\n-\n-static int\n-depth_of_nest (struct loop *nest)\n-{\n-  size_t depth = 0;\n-  while (nest)\n-    {\n-      depth++;\n-      nest = nest->inner;\n-    }\n-  return depth;\n-}\n-\n-\n-/* Return true if OP is invariant in LOOP and all outer loops.  */\n-\n-static bool\n-invariant_in_loop_and_outer_loops (struct loop *loop, tree op)\n-{\n-  if (is_gimple_min_invariant (op))\n-    return true;\n-  if (loop_depth (loop) == 0)\n-    return true;\n-  if (!expr_invariant_in_loop_p (loop, op))\n-    return false;\n-  if (!invariant_in_loop_and_outer_loops (loop_outer (loop), op))\n-    return false;\n-  return true;\n-}\n-\n-/* Generate a lambda loop from a gcc loop LOOP.  Return the new lambda loop,\n-   or NULL if it could not be converted.\n-   DEPTH is the depth of the loop.\n-   INVARIANTS is a pointer to the array of loop invariants.\n-   The induction variable for this loop should be stored in the parameter\n-   OURINDUCTIONVAR.\n-   OUTERINDUCTIONVARS is an array of induction variables for outer loops.  */\n-\n-static lambda_loop\n-gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n-\t\t\t VEC(tree,heap) ** invariants,\n-\t\t\t tree * ourinductionvar,\n-\t\t\t VEC(tree,heap) * outerinductionvars,\n-\t\t\t VEC(tree,heap) ** lboundvars,\n-\t\t\t VEC(tree,heap) ** uboundvars,\n-\t\t\t VEC(int,heap) ** steps,\n-                         struct obstack * lambda_obstack)\n-{\n-  gimple phi;\n-  gimple exit_cond;\n-  tree access_fn, inductionvar;\n-  tree step;\n-  lambda_loop lloop = NULL;\n-  lambda_linear_expression lbound, ubound;\n-  tree test_lhs, test_rhs;\n-  int stepint;\n-  int extra = 0;\n-  tree lboundvar, uboundvar, uboundresult;\n-\n-  /* Find out induction var and exit condition.  */\n-  inductionvar = find_induction_var_from_exit_cond (loop);\n-  exit_cond = get_loop_exit_condition (loop);\n-\n-  if (inductionvar == NULL || exit_cond == NULL)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Cannot determine exit condition or induction variable for loop.\\n\");\n-      return NULL;\n-    }\n-\n-  if (SSA_NAME_DEF_STMT (inductionvar) == NULL)\n-    {\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n-\n-      return NULL;\n-    }\n-\n-  phi = SSA_NAME_DEF_STMT (inductionvar);\n-  if (gimple_code (phi) != GIMPLE_PHI)\n-    {\n-      tree op = SINGLE_SSA_TREE_OPERAND (phi, SSA_OP_USE);\n-      if (!op)\n-\t{\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n-\n-\t  return NULL;\n-\t}\n-\n-      phi = SSA_NAME_DEF_STMT (op);\n-      if (gimple_code (phi) != GIMPLE_PHI)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n-\t  return NULL;\n-\t}\n-    }\n-\n-  /* The induction variable name/version we want to put in the array is the\n-     result of the induction variable phi node.  */\n-  *ourinductionvar = PHI_RESULT (phi);\n-  access_fn = instantiate_parameters\n-    (loop, analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n-  if (access_fn == chrec_dont_know)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Access function for induction variable phi is unknown\\n\");\n-\n-      return NULL;\n-    }\n-\n-  step = evolution_part_in_loop_num (access_fn, loop->num);\n-  if (!step || step == chrec_dont_know)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Cannot determine step of loop.\\n\");\n-\n-      return NULL;\n-    }\n-  if (TREE_CODE (step) != INTEGER_CST)\n-    {\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Step of loop is not integer.\\n\");\n-      return NULL;\n-    }\n-\n-  stepint = TREE_INT_CST_LOW (step);\n-\n-  /* Only want phis for induction vars, which will have two\n-     arguments.  */\n-  if (gimple_phi_num_args (phi) != 2)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: PHI node for induction variable has >2 arguments\\n\");\n-      return NULL;\n-    }\n-\n-  /* Another induction variable check. One argument's source should be\n-     in the loop, one outside the loop.  */\n-  if (flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, 0)->src)\n-      && flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, 1)->src))\n-    {\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: PHI edges both inside loop, or both outside loop.\\n\");\n-\n-      return NULL;\n-    }\n-\n-  if (flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, 0)->src))\n-    {\n-      lboundvar = PHI_ARG_DEF (phi, 1);\n-      lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n-\t\t\t\t\t      outerinductionvars, *invariants,\n-                                              0, lambda_obstack);\n-    }\n-  else\n-    {\n-      lboundvar = PHI_ARG_DEF (phi, 0);\n-      lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n-\t\t\t\t\t      outerinductionvars, *invariants,\n-                                              0, lambda_obstack);\n-    }\n-\n-  if (!lbound)\n-    {\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Cannot convert lower bound to linear expression\\n\");\n-\n-      return NULL;\n-    }\n-  /* One part of the test may be a loop invariant tree.  */\n-  VEC_reserve (tree, heap, *invariants, 1);\n-  test_lhs = gimple_cond_lhs (exit_cond);\n-  test_rhs = gimple_cond_rhs (exit_cond);\n-\n-  if (TREE_CODE (test_rhs) == SSA_NAME\n-      && invariant_in_loop_and_outer_loops (loop, test_rhs))\n-    VEC_quick_push (tree, *invariants, test_rhs);\n-  else if (TREE_CODE (test_lhs) == SSA_NAME\n-\t   && invariant_in_loop_and_outer_loops (loop, test_lhs))\n-    VEC_quick_push (tree, *invariants, test_lhs);\n-\n-  /* The non-induction variable part of the test is the upper bound variable.\n-   */\n-  if (test_lhs == inductionvar)\n-    uboundvar = test_rhs;\n-  else\n-    uboundvar = test_lhs;\n-\n-  /* We only size the vectors assuming we have, at max, 2 times as many\n-     invariants as we do loops (one for each bound).\n-     This is just an arbitrary number, but it has to be matched against the\n-     code below.  */\n-  gcc_assert (VEC_length (tree, *invariants) <= (unsigned int) (2 * depth));\n-\n-\n-  /* We might have some leftover.  */\n-  if (gimple_cond_code (exit_cond) == LT_EXPR)\n-    extra = -1 * stepint;\n-  else if (gimple_cond_code (exit_cond) == NE_EXPR)\n-    extra = -1 * stepint;\n-  else if (gimple_cond_code (exit_cond) == GT_EXPR)\n-    extra = -1 * stepint;\n-  else if (gimple_cond_code (exit_cond) == EQ_EXPR)\n-    extra = 1 * stepint;\n-\n-  ubound = gcc_tree_to_linear_expression (depth, uboundvar,\n-\t\t\t\t\t  outerinductionvars,\n-                                          *invariants, extra, lambda_obstack);\n-  uboundresult = build2 (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n-\t\t\t build_int_cst (TREE_TYPE (uboundvar), extra));\n-  VEC_safe_push (tree, heap, *uboundvars, uboundresult);\n-  VEC_safe_push (tree, heap, *lboundvars, lboundvar);\n-  VEC_safe_push (int, heap, *steps, stepint);\n-  if (!ubound)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Unable to convert loop: Cannot convert upper bound to linear expression\\n\");\n-      return NULL;\n-    }\n-\n-  lloop = lambda_loop_new (lambda_obstack);\n-  LL_STEP (lloop) = stepint;\n-  LL_LOWER_BOUND (lloop) = lbound;\n-  LL_UPPER_BOUND (lloop) = ubound;\n-  return lloop;\n-}\n-\n-/* Given a LOOP, find the induction variable it is testing against in the exit\n-   condition.  Return the induction variable if found, NULL otherwise.  */\n-\n-tree\n-find_induction_var_from_exit_cond (struct loop *loop)\n-{\n-  gimple expr = get_loop_exit_condition (loop);\n-  tree ivarop;\n-  tree test_lhs, test_rhs;\n-  if (expr == NULL)\n-    return NULL_TREE;\n-  if (gimple_code (expr) != GIMPLE_COND)\n-    return NULL_TREE;\n-  test_lhs = gimple_cond_lhs (expr);\n-  test_rhs = gimple_cond_rhs (expr);\n-\n-  /* Find the side that is invariant in this loop. The ivar must be the other\n-     side.  */\n-\n-  if (expr_invariant_in_loop_p (loop, test_lhs))\n-      ivarop = test_rhs;\n-  else if (expr_invariant_in_loop_p (loop, test_rhs))\n-      ivarop = test_lhs;\n-  else\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (ivarop) != SSA_NAME)\n-    return NULL_TREE;\n-  return ivarop;\n-}\n-\n-DEF_VEC_P(lambda_loop);\n-DEF_VEC_ALLOC_P(lambda_loop,heap);\n-\n-/* Generate a lambda loopnest from a gcc loopnest LOOP_NEST.\n-   Return the new loop nest.\n-   INDUCTIONVARS is a pointer to an array of induction variables for the\n-   loopnest that will be filled in during this process.\n-   INVARIANTS is a pointer to an array of invariants that will be filled in\n-   during this process.  */\n-\n-lambda_loopnest\n-gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n-\t\t\t\t VEC(tree,heap) **inductionvars,\n-                                 VEC(tree,heap) **invariants,\n-                                 struct obstack * lambda_obstack)\n-{\n-  lambda_loopnest ret = NULL;\n-  struct loop *temp = loop_nest;\n-  int depth = depth_of_nest (loop_nest);\n-  size_t i;\n-  VEC(lambda_loop,heap) *loops = NULL;\n-  VEC(tree,heap) *uboundvars = NULL;\n-  VEC(tree,heap) *lboundvars  = NULL;\n-  VEC(int,heap) *steps = NULL;\n-  lambda_loop newloop;\n-  tree inductionvar = NULL;\n-  bool perfect_nest = perfect_nest_p (loop_nest);\n-\n-  if (!perfect_nest && !can_convert_to_perfect_nest (loop_nest))\n-    goto fail;\n-\n-  while (temp)\n-    {\n-      newloop = gcc_loop_to_lambda_loop (temp, depth, invariants,\n-\t\t\t\t\t &inductionvar, *inductionvars,\n-\t\t\t\t\t &lboundvars, &uboundvars,\n-                                         &steps, lambda_obstack);\n-      if (!newloop)\n-\tgoto fail;\n-\n-      VEC_safe_push (tree, heap, *inductionvars, inductionvar);\n-      VEC_safe_push (lambda_loop, heap, loops, newloop);\n-      temp = temp->inner;\n-    }\n-\n-  if (!perfect_nest)\n-    {\n-      if (!perfect_nestify (loop_nest, lboundvars, uboundvars, steps,\n-\t\t\t    *inductionvars))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Not a perfect loop nest and couldn't convert to one.\\n\");\n-\t  goto fail;\n-\t}\n-      else if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"Successfully converted loop nest to perfect loop nest.\\n\");\n-    }\n-\n-  ret = lambda_loopnest_new (depth, 2 * depth, lambda_obstack);\n-\n-  FOR_EACH_VEC_ELT (lambda_loop, loops, i, newloop)\n-    LN_LOOPS (ret)[i] = newloop;\n-\n- fail:\n-  VEC_free (lambda_loop, heap, loops);\n-  VEC_free (tree, heap, uboundvars);\n-  VEC_free (tree, heap, lboundvars);\n-  VEC_free (int, heap, steps);\n-\n-  return ret;\n-}\n-\n-/* Convert a lambda body vector LBV to a gcc tree, and return the new tree.\n-   STMTS_TO_INSERT is a pointer to a tree where the statements we need to be\n-   inserted for us are stored.  INDUCTION_VARS is the array of induction\n-   variables for the loop this LBV is from.  TYPE is the tree type to use for\n-   the variables and trees involved.  */\n-\n-static tree\n-lbv_to_gcc_expression (lambda_body_vector lbv,\n-\t\t       tree type, VEC(tree,heap) *induction_vars,\n-\t\t       gimple_seq *stmts_to_insert)\n-{\n-  int k;\n-  tree resvar;\n-  tree expr = build_linear_expr (type, LBV_COEFFICIENTS (lbv), induction_vars);\n-\n-  k = LBV_DENOMINATOR (lbv);\n-  gcc_assert (k != 0);\n-  if (k != 1)\n-    expr = fold_build2 (CEIL_DIV_EXPR, type, expr, build_int_cst (type, k));\n-\n-  resvar = create_tmp_var (type, \"lbvtmp\");\n-  add_referenced_var (resvar);\n-  return force_gimple_operand (fold (expr), stmts_to_insert, true, resvar);\n-}\n-\n-/* Convert a linear expression from coefficient and constant form to a\n-   gcc tree.\n-   Return the tree that represents the final value of the expression.\n-   LLE is the linear expression to convert.\n-   OFFSET is the linear offset to apply to the expression.\n-   TYPE is the tree type to use for the variables and math.\n-   INDUCTION_VARS is a vector of induction variables for the loops.\n-   INVARIANTS is a vector of the loop nest invariants.\n-   WRAP specifies what tree code to wrap the results in, if there is more than\n-   one (it is either MAX_EXPR, or MIN_EXPR).\n-   STMTS_TO_INSERT Is a pointer to the statement list we fill in with\n-   statements that need to be inserted for the linear expression.  */\n-\n-static tree\n-lle_to_gcc_expression (lambda_linear_expression lle,\n-\t\t       lambda_linear_expression offset,\n-\t\t       tree type,\n-\t\t       VEC(tree,heap) *induction_vars,\n-\t\t       VEC(tree,heap) *invariants,\n-\t\t       enum tree_code wrap, gimple_seq *stmts_to_insert)\n-{\n-  int k;\n-  tree resvar;\n-  tree expr = NULL_TREE;\n-  VEC(tree,heap) *results = NULL;\n-\n-  gcc_assert (wrap == MAX_EXPR || wrap == MIN_EXPR);\n-\n-  /* Build up the linear expressions.  */\n-  for (; lle != NULL; lle = LLE_NEXT (lle))\n-    {\n-      expr = build_linear_expr (type, LLE_COEFFICIENTS (lle), induction_vars);\n-      expr = fold_build2 (PLUS_EXPR, type, expr,\n-\t\t\t  build_linear_expr (type,\n-\t\t\t\t\t     LLE_INVARIANT_COEFFICIENTS (lle),\n-\t\t\t\t\t     invariants));\n-\n-      k = LLE_CONSTANT (lle);\n-      if (k)\n-\texpr = fold_build2 (PLUS_EXPR, type, expr, build_int_cst (type, k));\n-\n-      k = LLE_CONSTANT (offset);\n-      if (k)\n-\texpr = fold_build2 (PLUS_EXPR, type, expr, build_int_cst (type, k));\n-\n-      k = LLE_DENOMINATOR (lle);\n-      if (k != 1)\n-\texpr = fold_build2 (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n-\t\t\t    type, expr, build_int_cst (type, k));\n-\n-      expr = fold (expr);\n-      VEC_safe_push (tree, heap, results, expr);\n-    }\n-\n-  gcc_assert (expr);\n-\n-  /* We may need to wrap the results in a MAX_EXPR or MIN_EXPR.  */\n-  if (VEC_length (tree, results) > 1)\n-    {\n-      size_t i;\n-      tree op;\n-\n-      expr = VEC_index (tree, results, 0);\n-      for (i = 1; VEC_iterate (tree, results, i, op); i++)\n-\texpr = fold_build2 (wrap, type, expr, op);\n-    }\n-\n-  VEC_free (tree, heap, results);\n-\n-  resvar = create_tmp_var (type, \"lletmp\");\n-  add_referenced_var (resvar);\n-  return force_gimple_operand (fold (expr), stmts_to_insert, true, resvar);\n-}\n-\n-/* Remove the induction variable defined at IV_STMT.  */\n-\n-void\n-remove_iv (gimple iv_stmt)\n-{\n-  gimple_stmt_iterator si = gsi_for_stmt (iv_stmt);\n-\n-  if (gimple_code (iv_stmt) == GIMPLE_PHI)\n-    {\n-      unsigned i;\n-\n-      for (i = 0; i < gimple_phi_num_args (iv_stmt); i++)\n-\t{\n-\t  gimple stmt;\n-\t  imm_use_iterator imm_iter;\n-\t  tree arg = gimple_phi_arg_def (iv_stmt, i);\n-\t  bool used = false;\n-\n-\t  if (TREE_CODE (arg) != SSA_NAME)\n-\t    continue;\n-\n-\t  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, arg)\n-\t    if (stmt != iv_stmt && !is_gimple_debug (stmt))\n-\t      used = true;\n-\n-\t  if (!used)\n-\t    remove_iv (SSA_NAME_DEF_STMT (arg));\n-\t}\n-\n-      remove_phi_node (&si, true);\n-    }\n-  else\n-    {\n-      gsi_remove (&si, true);\n-      release_defs (iv_stmt);\n-    }\n-}\n-\n-/* Transform a lambda loopnest NEW_LOOPNEST, which had TRANSFORM applied to\n-   it, back into gcc code.  This changes the\n-   loops, their induction variables, and their bodies, so that they\n-   match the transformed loopnest.\n-   OLD_LOOPNEST is the loopnest before we've replaced it with the new\n-   loopnest.\n-   OLD_IVS is a vector of induction variables from the old loopnest.\n-   INVARIANTS is a vector of loop invariants from the old loopnest.\n-   NEW_LOOPNEST is the new lambda loopnest to replace OLD_LOOPNEST with.\n-   TRANSFORM is the matrix transform that was applied to OLD_LOOPNEST to get\n-   NEW_LOOPNEST.  */\n-\n-void \n-lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n-\t\t\t\t VEC(tree,heap) *old_ivs,\n-\t\t\t\t VEC(tree,heap) *invariants,\n-\t\t\t\t VEC(gimple,heap) **remove_ivs,\n-\t\t\t\t lambda_loopnest new_loopnest,\n-                                 lambda_trans_matrix transform,\n-                                 struct obstack * lambda_obstack)\n-{\n-  struct loop *temp;\n-  size_t i = 0;\n-  unsigned j;\n-  size_t depth = 0;\n-  VEC(tree,heap) *new_ivs = NULL;\n-  tree oldiv;\n-  gimple_stmt_iterator bsi;\n-\n-  transform = lambda_trans_matrix_inverse (transform, lambda_obstack);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Inverse of transformation matrix:\\n\");\n-      print_lambda_trans_matrix (dump_file, transform);\n-    }\n-  depth = depth_of_nest (old_loopnest);\n-  temp = old_loopnest;\n-\n-  while (temp)\n-    {\n-      lambda_loop newloop;\n-      basic_block bb;\n-      edge exit;\n-      tree ivvar, ivvarinced;\n-      gimple exitcond;\n-      gimple_seq stmts;\n-      enum tree_code testtype;\n-      tree newupperbound, newlowerbound;\n-      lambda_linear_expression offset;\n-      tree type;\n-      bool insert_after;\n-      gimple inc_stmt;\n-\n-      oldiv = VEC_index (tree, old_ivs, i);\n-      type = TREE_TYPE (oldiv);\n-\n-      /* First, build the new induction variable temporary  */\n-\n-      ivvar = create_tmp_var (type, \"lnivtmp\");\n-      add_referenced_var (ivvar);\n-\n-      VEC_safe_push (tree, heap, new_ivs, ivvar);\n-\n-      newloop = LN_LOOPS (new_loopnest)[i];\n-\n-      /* Linear offset is a bit tricky to handle.  Punt on the unhandled\n-         cases for now.  */\n-      offset = LL_LINEAR_OFFSET (newloop);\n-\n-      gcc_assert (LLE_DENOMINATOR (offset) == 1 &&\n-\t\t  lambda_vector_zerop (LLE_COEFFICIENTS (offset), depth));\n-\n-      /* Now build the  new lower bounds, and insert the statements\n-         necessary to generate it on the loop preheader.  */\n-      stmts = NULL;\n-      newlowerbound = lle_to_gcc_expression (LL_LOWER_BOUND (newloop),\n-\t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n-\t\t\t\t\t     type,\n-\t\t\t\t\t     new_ivs,\n-\t\t\t\t\t     invariants, MAX_EXPR, &stmts);\n-\n-      if (stmts)\n-\t{\n-\t  gsi_insert_seq_on_edge (loop_preheader_edge (temp), stmts);\n-\t  gsi_commit_edge_inserts ();\n-\t}\n-      /* Build the new upper bound and insert its statements in the\n-         basic block of the exit condition */\n-      stmts = NULL;\n-      newupperbound = lle_to_gcc_expression (LL_UPPER_BOUND (newloop),\n-\t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n-\t\t\t\t\t     type,\n-\t\t\t\t\t     new_ivs,\n-\t\t\t\t\t     invariants, MIN_EXPR, &stmts);\n-      exit = single_exit (temp);\n-      exitcond = get_loop_exit_condition (temp);\n-      bb = gimple_bb (exitcond);\n-      bsi = gsi_after_labels (bb);\n-      if (stmts)\n-\tgsi_insert_seq_before (&bsi, stmts, GSI_NEW_STMT);\n-\n-      /* Create the new iv.  */\n-\n-      standard_iv_increment_position (temp, &bsi, &insert_after);\n-      create_iv (newlowerbound,\n-\t\t build_int_cst (type, LL_STEP (newloop)),\n-\t\t ivvar, temp, &bsi, insert_after, &ivvar,\n-\t\t NULL);\n-\n-      /* Unfortunately, the incremented ivvar that create_iv inserted may not\n-\t dominate the block containing the exit condition.\n-\t So we simply create our own incremented iv to use in the new exit\n-\t test,  and let redundancy elimination sort it out.  */\n-      inc_stmt = gimple_build_assign_with_ops (PLUS_EXPR, SSA_NAME_VAR (ivvar),\n-\t\t\t\t\t       ivvar,\n-\t\t\t\t\t       build_int_cst (type, LL_STEP (newloop)));\n-\n-      ivvarinced = make_ssa_name (SSA_NAME_VAR (ivvar), inc_stmt);\n-      gimple_assign_set_lhs (inc_stmt, ivvarinced);\n-      bsi = gsi_for_stmt (exitcond);\n-      gsi_insert_before (&bsi, inc_stmt, GSI_SAME_STMT);\n-\n-      /* Replace the exit condition with the new upper bound\n-         comparison.  */\n-\n-      testtype = LL_STEP (newloop) >= 0 ? LE_EXPR : GE_EXPR;\n-\n-      /* We want to build a conditional where true means exit the loop, and\n-\t false means continue the loop.\n-\t So swap the testtype if this isn't the way things are.*/\n-\n-      if (exit->flags & EDGE_FALSE_VALUE)\n-\ttesttype = swap_tree_comparison (testtype);\n-\n-      gimple_cond_set_condition (exitcond, testtype, newupperbound, ivvarinced);\n-      update_stmt (exitcond);\n-      VEC_replace (tree, new_ivs, i, ivvar);\n-\n-      i++;\n-      temp = temp->inner;\n-    }\n-\n-  /* Rewrite uses of the old ivs so that they are now specified in terms of\n-     the new ivs.  */\n-\n-  FOR_EACH_VEC_ELT (tree, old_ivs, i, oldiv)\n-    {\n-      imm_use_iterator imm_iter;\n-      use_operand_p use_p;\n-      tree oldiv_def;\n-      gimple oldiv_stmt = SSA_NAME_DEF_STMT (oldiv);\n-      gimple stmt;\n-\n-      if (gimple_code (oldiv_stmt) == GIMPLE_PHI)\n-        oldiv_def = PHI_RESULT (oldiv_stmt);\n-      else\n-\toldiv_def = SINGLE_SSA_TREE_OPERAND (oldiv_stmt, SSA_OP_DEF);\n-      gcc_assert (oldiv_def != NULL_TREE);\n-\n-      FOR_EACH_IMM_USE_STMT (stmt, imm_iter, oldiv_def)\n-        {\n-\t  tree newiv;\n-\t  gimple_seq stmts;\n-\t  lambda_body_vector lbv, newlbv;\n-\n-\t  if (is_gimple_debug (stmt))\n-\t    continue;\n-\n-\t  /* Compute the new expression for the induction\n-\t     variable.  */\n-\t  depth = VEC_length (tree, new_ivs);\n-          lbv = lambda_body_vector_new (depth, lambda_obstack);\n-\t  LBV_COEFFICIENTS (lbv)[i] = 1;\n-\n-          newlbv = lambda_body_vector_compute_new (transform, lbv,\n-                                                   lambda_obstack);\n-\n-\t  stmts = NULL;\n-\t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n-\t\t\t\t\t new_ivs, &stmts);\n-\n-\t  if (stmts && gimple_code (stmt) != GIMPLE_PHI)\n-\t    {\n-\t      bsi = gsi_for_stmt (stmt);\n-\t      gsi_insert_seq_before (&bsi, stmts, GSI_SAME_STMT);\n-\t    }\n-\n-\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t    propagate_value (use_p, newiv);\n-\n-\t  if (stmts && gimple_code (stmt) == GIMPLE_PHI)\n-\t    for (j = 0; j < gimple_phi_num_args (stmt); j++)\n-\t      if (gimple_phi_arg_def (stmt, j) == newiv)\n-\t\tgsi_insert_seq_on_edge (gimple_phi_arg_edge (stmt, j), stmts);\n-\n-\t  update_stmt (stmt);\n-\t}\n-\n-      /* Remove the now unused induction variable.  */\n-      VEC_safe_push (gimple, heap, *remove_ivs, oldiv_stmt);\n-    }\n-  VEC_free (tree, heap, new_ivs);\n-}\n-\n-/* Return TRUE if this is not interesting statement from the perspective of\n-   determining if we have a perfect loop nest.  */\n-\n-static bool\n-not_interesting_stmt (gimple stmt)\n-{\n-  /* Note that COND_EXPR's aren't interesting because if they were exiting the\n-     loop, we would have already failed the number of exits tests.  */\n-  if (gimple_code (stmt) == GIMPLE_LABEL\n-      || gimple_code (stmt) == GIMPLE_GOTO\n-      || gimple_code (stmt) == GIMPLE_COND\n-      || is_gimple_debug (stmt))\n-    return true;\n-  return false;\n-}\n-\n-/* Return TRUE if PHI uses DEF for it's in-the-loop edge for LOOP.  */\n-\n-static bool\n-phi_loop_edge_uses_def (struct loop *loop, gimple phi, tree def)\n-{\n-  unsigned i;\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    if (flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, i)->src))\n-      if (PHI_ARG_DEF (phi, i) == def)\n-\treturn true;\n-  return false;\n-}\n-\n-/* Return TRUE if STMT is a use of PHI_RESULT.  */\n-\n-static bool\n-stmt_uses_phi_result (gimple stmt, tree phi_result)\n-{\n-  tree use = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_USE);\n-\n-  /* This is conservatively true, because we only want SIMPLE bumpers\n-     of the form x +- constant for our pass.  */\n-  return (use == phi_result);\n-}\n-\n-/* STMT is a bumper stmt for LOOP if the version it defines is used in the\n-   in-loop-edge in a phi node, and the operand it uses is the result of that\n-   phi node.\n-   I.E. i_29 = i_3 + 1\n-        i_3 = PHI (0, i_29);  */\n-\n-static bool\n-stmt_is_bumper_for_loop (struct loop *loop, gimple stmt)\n-{\n-  gimple use;\n-  tree def;\n-  imm_use_iterator iter;\n-  use_operand_p use_p;\n-\n-  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n-  if (!def)\n-    return false;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, def)\n-    {\n-      use = USE_STMT (use_p);\n-      if (gimple_code (use) == GIMPLE_PHI)\n-\t{\n-\t  if (phi_loop_edge_uses_def (loop, use, def))\n-\t    if (stmt_uses_phi_result (stmt, PHI_RESULT (use)))\n-\t      return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-\n-/* Return true if LOOP is a perfect loop nest.\n-   Perfect loop nests are those loop nests where all code occurs in the\n-   innermost loop body.\n-   If S is a program statement, then\n-\n-   i.e.\n-   DO I = 1, 20\n-       S1\n-       DO J = 1, 20\n-       ...\n-       END DO\n-   END DO\n-   is not a perfect loop nest because of S1.\n-\n-   DO I = 1, 20\n-      DO J = 1, 20\n-        S1\n-\t...\n-      END DO\n-   END DO\n-   is a perfect loop nest.\n-\n-   Since we don't have high level loops anymore, we basically have to walk our\n-   statements and ignore those that are there because the loop needs them (IE\n-   the induction variable increment, and jump back to the top of the loop).  */\n-\n-bool\n-perfect_nest_p (struct loop *loop)\n-{\n-  basic_block *bbs;\n-  size_t i;\n-  gimple exit_cond;\n-\n-  /* Loops at depth 0 are perfect nests.  */\n-  if (!loop->inner)\n-    return true;\n-\n-  bbs = get_loop_body (loop);\n-  exit_cond = get_loop_exit_condition (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      if (bbs[i]->loop_father == loop)\n-\t{\n-\t  gimple_stmt_iterator bsi;\n-\n-\t  for (bsi = gsi_start_bb (bbs[i]); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t    {\n-\t      gimple stmt = gsi_stmt (bsi);\n-\n-\t      if (gimple_code (stmt) == GIMPLE_COND\n-\t\t  && exit_cond != stmt)\n-\t\tgoto non_perfectly_nested;\n-\n-\t      if (stmt == exit_cond\n-\t\t  || not_interesting_stmt (stmt)\n-\t\t  || stmt_is_bumper_for_loop (loop, stmt))\n-\t\tcontinue;\n-\n-\t    non_perfectly_nested:\n-\t      free (bbs);\n-\t      return false;\n-\t    }\n-\t}\n-    }\n-\n-  free (bbs);\n-\n-  return perfect_nest_p (loop->inner);\n-}\n-\n-/* Replace the USES of X in STMT, or uses with the same step as X with Y.\n-   YINIT is the initial value of Y, REPLACEMENTS is a hash table to\n-   avoid creating duplicate temporaries and FIRSTBSI is statement\n-   iterator where new temporaries should be inserted at the beginning\n-   of body basic block.  */\n-\n-static void\n-replace_uses_equiv_to_x_with_y (struct loop *loop, gimple stmt, tree x,\n-\t\t\t\tint xstep, tree y, tree yinit,\n-\t\t\t\thtab_t replacements,\n-\t\t\t\tgimple_stmt_iterator *firstbsi)\n-{\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-      tree step = NULL_TREE;\n-      tree scev, init, val, var;\n-      gimple setstmt;\n-      struct tree_map *h, in;\n-      void **loc;\n-\n-      /* Replace uses of X with Y right away.  */\n-      if (use == x)\n-\t{\n-\t  SET_USE (use_p, y);\n-\t  continue;\n-\t}\n-\n-      scev = instantiate_parameters (loop,\n-\t\t\t\t     analyze_scalar_evolution (loop, use));\n-\n-      if (scev == NULL || scev == chrec_dont_know)\n-\tcontinue;\n-\n-      step = evolution_part_in_loop_num (scev, loop->num);\n-      if (step == NULL\n-\t  || step == chrec_dont_know\n-\t  || TREE_CODE (step) != INTEGER_CST\n-\t  || int_cst_value (step) != xstep)\n-\tcontinue;\n-\n-      /* Use REPLACEMENTS hash table to cache already created\n-\t temporaries.  */\n-      in.hash = htab_hash_pointer (use);\n-      in.base.from = use;\n-      h = (struct tree_map *) htab_find_with_hash (replacements, &in, in.hash);\n-      if (h != NULL)\n-\t{\n-\t  SET_USE (use_p, h->to);\n-\t  continue;\n-\t}\n-\n-      /* USE which has the same step as X should be replaced\n-\t with a temporary set to Y + YINIT - INIT.  */\n-      init = initial_condition_in_loop_num (scev, loop->num);\n-      gcc_assert (init != NULL && init != chrec_dont_know);\n-      if (TREE_TYPE (use) == TREE_TYPE (y))\n-\t{\n-\t  val = fold_build2 (MINUS_EXPR, TREE_TYPE (y), init, yinit);\n-\t  val = fold_build2 (PLUS_EXPR, TREE_TYPE (y), y, val);\n-\t  if (val == y)\n- \t    {\n-\t      /* If X has the same type as USE, the same step\n-\t\t and same initial value, it can be replaced by Y.  */\n-\t      SET_USE (use_p, y);\n-\t      continue;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  val = fold_build2 (MINUS_EXPR, TREE_TYPE (y), y, yinit);\n-\t  val = fold_convert (TREE_TYPE (use), val);\n-\t  val = fold_build2 (PLUS_EXPR, TREE_TYPE (use), val, init);\n-\t}\n-\n-      /* Create a temporary variable and insert it at the beginning\n-\t of the loop body basic block, right after the PHI node\n-\t which sets Y.  */\n-      var = create_tmp_var (TREE_TYPE (use), \"perfecttmp\");\n-      add_referenced_var (var);\n-      val = force_gimple_operand_gsi (firstbsi, val, false, NULL,\n-\t\t\t\t      true, GSI_SAME_STMT);\n-      setstmt = gimple_build_assign (var, val);\n-      var = make_ssa_name (var, setstmt);\n-      gimple_assign_set_lhs (setstmt, var);\n-      gsi_insert_before (firstbsi, setstmt, GSI_SAME_STMT);\n-      update_stmt (setstmt);\n-      SET_USE (use_p, var);\n-      h = ggc_alloc_tree_map ();\n-      h->hash = in.hash;\n-      h->base.from = use;\n-      h->to = var;\n-      loc = htab_find_slot_with_hash (replacements, h, in.hash, INSERT);\n-      gcc_assert ((*(struct tree_map **)loc) == NULL);\n-      *(struct tree_map **) loc = h;\n-    }\n-}\n-\n-/* Return true if STMT is an exit PHI for LOOP */\n-\n-static bool\n-exit_phi_for_loop_p (struct loop *loop, gimple stmt)\n-{\n-  if (gimple_code (stmt) != GIMPLE_PHI\n-      || gimple_phi_num_args (stmt) != 1\n-      || gimple_bb (stmt) != single_exit (loop)->dest)\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Return true if STMT can be put back into the loop INNER, by\n-   copying it to the beginning of that loop and changing the uses.  */\n-\n-static bool\n-can_put_in_inner_loop (struct loop *inner, gimple stmt)\n-{\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-\n-  gcc_assert (is_gimple_assign (stmt));\n-  if (gimple_vuse (stmt)\n-      || !stmt_invariant_in_loop_p (inner, stmt))\n-    return false;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_assign_lhs (stmt))\n-    {\n-      if (!exit_phi_for_loop_p (inner, USE_STMT (use_p)))\n-\t{\n-\t  basic_block immbb = gimple_bb (USE_STMT (use_p));\n-\n-\t  if (!flow_bb_inside_loop_p (inner, immbb))\n-\t    return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Return true if STMT can be put *after* the inner loop of LOOP.  */\n-\n-static bool\n-can_put_after_inner_loop (struct loop *loop, gimple stmt)\n-{\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-\n-  if (gimple_vuse (stmt))\n-    return false;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_assign_lhs (stmt))\n-    {\n-      if (!exit_phi_for_loop_p (loop, USE_STMT (use_p)))\n-\t{\n-\t  basic_block immbb = gimple_bb (USE_STMT (use_p));\n-\n-\t  if (!dominated_by_p (CDI_DOMINATORS,\n-\t\t\t       immbb,\n-\t\t\t       loop->inner->header)\n-\t      && !can_put_in_inner_loop (loop->inner, stmt))\n-\t    return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Return true when the induction variable IV is simple enough to be\n-   re-synthesized.  */\n-\n-static bool\n-can_duplicate_iv (tree iv, struct loop *loop)\n-{\n-  tree scev = instantiate_parameters\n-    (loop, analyze_scalar_evolution (loop, iv));\n-\n-  if (!automatically_generated_chrec_p (scev))\n-    {\n-      tree step = evolution_part_in_loop_num (scev, loop->num);\n-\n-      if (step && step != chrec_dont_know && TREE_CODE (step) == INTEGER_CST)\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-/* If this is a scalar operation that can be put back into the inner\n-   loop, or after the inner loop, through copying, then do so. This\n-   works on the theory that any amount of scalar code we have to\n-   reduplicate into or after the loops is less expensive that the win\n-   we get from rearranging the memory walk the loop is doing so that\n-   it has better cache behavior.  */\n-\n-static bool\n-cannot_convert_modify_to_perfect_nest (gimple stmt, struct loop *loop)\n-{\n-  use_operand_p use_a, use_b;\n-  imm_use_iterator imm_iter;\n-  ssa_op_iter op_iter, op_iter1;\n-  tree op0 = gimple_assign_lhs (stmt);\n-\n-  /* The statement should not define a variable used in the inner\n-     loop.  */\n-  if (TREE_CODE (op0) == SSA_NAME\n-      && !can_duplicate_iv (op0, loop))\n-    FOR_EACH_IMM_USE_FAST (use_a, imm_iter, op0)\n-      if (gimple_bb (USE_STMT (use_a))->loop_father == loop->inner)\n-\treturn true;\n-\n-  FOR_EACH_SSA_USE_OPERAND (use_a, stmt, op_iter, SSA_OP_USE)\n-    {\n-      gimple node;\n-      tree op = USE_FROM_PTR (use_a);\n-\n-      /* The variables should not be used in both loops.  */\n-      if (!can_duplicate_iv (op, loop))\n-\tFOR_EACH_IMM_USE_FAST (use_b, imm_iter, op)\n-\t  if (gimple_bb (USE_STMT (use_b))->loop_father == loop->inner)\n-\t    return true;\n-\n-      /* The statement should not use the value of a scalar that was\n-\t modified in the loop.  */\n-      node = SSA_NAME_DEF_STMT (op);\n-      if (gimple_code (node) == GIMPLE_PHI)\n-\tFOR_EACH_PHI_ARG (use_b, node, op_iter1, SSA_OP_USE)\n-\t  {\n-\t    tree arg = USE_FROM_PTR (use_b);\n-\n-\t    if (TREE_CODE (arg) == SSA_NAME)\n-\t      {\n-\t\tgimple arg_stmt = SSA_NAME_DEF_STMT (arg);\n-\n-\t\tif (gimple_bb (arg_stmt)\n-\t\t    && (gimple_bb (arg_stmt)->loop_father == loop->inner))\n-\t\t  return true;\n-\t      }\n-\t  }\n-    }\n-\n-  return false;\n-}\n-/* Return true when BB contains statements that can harm the transform\n-   to a perfect loop nest.  */\n-\n-static bool\n-cannot_convert_bb_to_perfect_nest (basic_block bb, struct loop *loop)\n-{\n-  gimple_stmt_iterator bsi;\n-  gimple exit_condition = get_loop_exit_condition (loop);\n-\n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-    {\n-      gimple stmt = gsi_stmt (bsi);\n-\n-      if (stmt == exit_condition\n-\t  || not_interesting_stmt (stmt)\n-\t  || stmt_is_bumper_for_loop (loop, stmt))\n-\tcontinue;\n-\n-      if (is_gimple_assign (stmt))\n-\t{\n-\t  if (cannot_convert_modify_to_perfect_nest (stmt, loop))\n-\t    return true;\n-\n-\t  if (can_duplicate_iv (gimple_assign_lhs (stmt), loop))\n-\t    continue;\n-\n-\t  if (can_put_in_inner_loop (loop->inner, stmt)\n-\t      || can_put_after_inner_loop (loop, stmt))\n-\t    continue;\n-\t}\n-\n-      /* If the bb of a statement we care about isn't dominated by the\n-\t header of the inner loop, then we can't handle this case\n-\t right now.  This test ensures that the statement comes\n-\t completely *after* the inner loop.  */\n-      if (!dominated_by_p (CDI_DOMINATORS,\n-\t\t\t   gimple_bb (stmt),\n-\t\t\t   loop->inner->header))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-\n-/* Return TRUE if LOOP is an imperfect nest that we can convert to a\n-   perfect one.  At the moment, we only handle imperfect nests of\n-   depth 2, where all of the statements occur after the inner loop.  */\n-\n-static bool\n-can_convert_to_perfect_nest (struct loop *loop)\n-{\n-  basic_block *bbs;\n-  size_t i;\n-  gimple_stmt_iterator si;\n-\n-  /* Can't handle triply nested+ loops yet.  */\n-  if (!loop->inner || loop->inner->inner)\n-    return false;\n-\n-  bbs = get_loop_body (loop);\n-  for (i = 0; i < loop->num_nodes; i++)\n-    if (bbs[i]->loop_father == loop\n-\t&& cannot_convert_bb_to_perfect_nest (bbs[i], loop))\n-      goto fail;\n-\n-  /* We also need to make sure the loop exit only has simple copy phis in it,\n-     otherwise we don't know how to transform it into a perfect nest.  */\n-  for (si = gsi_start_phis (single_exit (loop)->dest);\n-       !gsi_end_p (si);\n-       gsi_next (&si))\n-    if (gimple_phi_num_args (gsi_stmt (si)) != 1)\n-      goto fail;\n-\n-  free (bbs);\n-  return true;\n-\n- fail:\n-  free (bbs);\n-  return false;\n-}\n-\n-\n-DEF_VEC_I(source_location);\n-DEF_VEC_ALLOC_I(source_location,heap);\n-\n-/* Transform the loop nest into a perfect nest, if possible.\n-   LOOP is the loop nest to transform into a perfect nest\n-   LBOUNDS are the lower bounds for the loops to transform\n-   UBOUNDS are the upper bounds for the loops to transform\n-   STEPS is the STEPS for the loops to transform.\n-   LOOPIVS is the induction variables for the loops to transform.\n-\n-   Basically, for the case of\n-\n-   FOR (i = 0; i < 50; i++)\n-    {\n-     FOR (j =0; j < 50; j++)\n-     {\n-        <whatever>\n-     }\n-     <some code>\n-    }\n-\n-   This function will transform it into a perfect loop nest by splitting the\n-   outer loop into two loops, like so:\n-\n-   FOR (i = 0; i < 50; i++)\n-   {\n-     FOR (j = 0; j < 50; j++)\n-     {\n-         <whatever>\n-     }\n-   }\n-\n-   FOR (i = 0; i < 50; i ++)\n-   {\n-    <some code>\n-   }\n-\n-   Return FALSE if we can't make this loop into a perfect nest.  */\n-\n-static bool\n-perfect_nestify (struct loop *loop,\n-\t\t VEC(tree,heap) *lbounds,\n-\t\t VEC(tree,heap) *ubounds,\n-\t\t VEC(int,heap) *steps,\n-\t\t VEC(tree,heap) *loopivs)\n-{\n-  basic_block *bbs;\n-  gimple exit_condition;\n-  gimple cond_stmt;\n-  basic_block preheaderbb, headerbb, bodybb, latchbb, olddest;\n-  int i;\n-  gimple_stmt_iterator bsi, firstbsi;\n-  bool insert_after;\n-  edge e;\n-  struct loop *newloop;\n-  gimple phi;\n-  tree uboundvar;\n-  gimple stmt;\n-  tree oldivvar, ivvar, ivvarinced;\n-  VEC(tree,heap) *phis = NULL;\n-  VEC(source_location,heap) *locations = NULL;\n-  htab_t replacements = NULL;\n-\n-  /* Create the new loop.  */\n-  olddest = single_exit (loop)->dest;\n-  preheaderbb = split_edge (single_exit (loop));\n-  headerbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n-\n-  /* Push the exit phi nodes that we are moving.  */\n-  for (bsi = gsi_start_phis (olddest); !gsi_end_p (bsi); gsi_next (&bsi))\n-    {\n-      phi = gsi_stmt (bsi);\n-      VEC_reserve (tree, heap, phis, 2);\n-      VEC_reserve (source_location, heap, locations, 1);\n-      VEC_quick_push (tree, phis, PHI_RESULT (phi));\n-      VEC_quick_push (tree, phis, PHI_ARG_DEF (phi, 0));\n-      VEC_quick_push (source_location, locations,\n-\t\t      gimple_phi_arg_location (phi, 0));\n-    }\n-  e = redirect_edge_and_branch (single_succ_edge (preheaderbb), headerbb);\n-\n-  /* Remove the exit phis from the old basic block.  */\n-  for (bsi = gsi_start_phis (olddest); !gsi_end_p (bsi); )\n-    remove_phi_node (&bsi, false);\n-\n-  /* and add them back to the new basic block.  */\n-  while (VEC_length (tree, phis) != 0)\n-    {\n-      tree def;\n-      tree phiname;\n-      source_location locus;\n-      def = VEC_pop (tree, phis);\n-      phiname = VEC_pop (tree, phis);\n-      locus = VEC_pop (source_location, locations);\n-      phi = create_phi_node (phiname, preheaderbb);\n-      add_phi_arg (phi, def, single_pred_edge (preheaderbb), locus);\n-    }\n-  flush_pending_stmts (e);\n-  VEC_free (tree, heap, phis);\n-\n-  bodybb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n-  latchbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n-  make_edge (headerbb, bodybb, EDGE_FALLTHRU);\n-  cond_stmt = gimple_build_cond (NE_EXPR, integer_one_node, integer_zero_node,\n-\t\t\t\t NULL_TREE, NULL_TREE);\n-  bsi = gsi_start_bb (bodybb);\n-  gsi_insert_after (&bsi, cond_stmt, GSI_NEW_STMT);\n-  e = make_edge (bodybb, olddest, EDGE_FALSE_VALUE);\n-  make_edge (bodybb, latchbb, EDGE_TRUE_VALUE);\n-  make_edge (latchbb, headerbb, EDGE_FALLTHRU);\n-\n-  /* Update the loop structures.  */\n-  newloop = duplicate_loop (loop, olddest->loop_father);\n-  newloop->header = headerbb;\n-  newloop->latch = latchbb;\n-  add_bb_to_loop (latchbb, newloop);\n-  add_bb_to_loop (bodybb, newloop);\n-  add_bb_to_loop (headerbb, newloop);\n-  set_immediate_dominator (CDI_DOMINATORS, bodybb, headerbb);\n-  set_immediate_dominator (CDI_DOMINATORS, headerbb, preheaderbb);\n-  set_immediate_dominator (CDI_DOMINATORS, preheaderbb,\n-\t\t\t   single_exit (loop)->src);\n-  set_immediate_dominator (CDI_DOMINATORS, latchbb, bodybb);\n-  set_immediate_dominator (CDI_DOMINATORS, olddest,\n-\t\t\t   recompute_dominator (CDI_DOMINATORS, olddest));\n-  /* Create the new iv.  */\n-  oldivvar = VEC_index (tree, loopivs, 0);\n-  ivvar = create_tmp_var (TREE_TYPE (oldivvar), \"perfectiv\");\n-  add_referenced_var (ivvar);\n-  standard_iv_increment_position (newloop, &bsi, &insert_after);\n-  create_iv (VEC_index (tree, lbounds, 0),\n-\t     build_int_cst (TREE_TYPE (oldivvar), VEC_index (int, steps, 0)),\n-\t     ivvar, newloop, &bsi, insert_after, &ivvar, &ivvarinced);\n-\n-  /* Create the new upper bound.  This may be not just a variable, so we copy\n-     it to one just in case.  */\n-\n-  exit_condition = get_loop_exit_condition (newloop);\n-  uboundvar = create_tmp_var (TREE_TYPE (VEC_index (tree, ubounds, 0)),\n-\t\t\t      \"uboundvar\");\n-  add_referenced_var (uboundvar);\n-  stmt = gimple_build_assign (uboundvar, VEC_index (tree, ubounds, 0));\n-  uboundvar = make_ssa_name (uboundvar, stmt);\n-  gimple_assign_set_lhs (stmt, uboundvar);\n-\n-  if (insert_after)\n-    gsi_insert_after (&bsi, stmt, GSI_SAME_STMT);\n-  else\n-    gsi_insert_before (&bsi, stmt, GSI_SAME_STMT);\n-  update_stmt (stmt);\n-  gimple_cond_set_condition (exit_condition, GE_EXPR, uboundvar, ivvarinced);\n-  update_stmt (exit_condition);\n-  replacements = htab_create_ggc (20, tree_map_hash,\n-\t\t\t\t  tree_map_eq, NULL);\n-  bbs = get_loop_body_in_dom_order (loop);\n-  /* Now move the statements, and replace the induction variable in the moved\n-     statements with the correct loop induction variable.  */\n-  oldivvar = VEC_index (tree, loopivs, 0);\n-  firstbsi = gsi_start_bb (bodybb);\n-  for (i = loop->num_nodes - 1; i >= 0 ; i--)\n-    {\n-      gimple_stmt_iterator tobsi = gsi_last_bb (bodybb);\n-      if (bbs[i]->loop_father == loop)\n-\t{\n-\t  /* If this is true, we are *before* the inner loop.\n-\t     If this isn't true, we are *after* it.\n-\n-\t     The only time can_convert_to_perfect_nest returns true when we\n-\t     have statements before the inner loop is if they can be moved\n-\t     into the inner loop.\n-\n-\t     The only time can_convert_to_perfect_nest returns true when we\n-\t     have statements after the inner loop is if they can be moved into\n-\t     the new split loop.  */\n-\n-\t  if (dominated_by_p (CDI_DOMINATORS, loop->inner->header, bbs[i]))\n-\t    {\n-\t      gimple_stmt_iterator header_bsi\n-\t\t= gsi_after_labels (loop->inner->header);\n-\n-\t      for (bsi = gsi_start_bb (bbs[i]); !gsi_end_p (bsi);)\n-\t\t{\n-\t\t  gimple stmt = gsi_stmt (bsi);\n-\n-\t\t  if (stmt == exit_condition\n-\t\t      || not_interesting_stmt (stmt)\n-\t\t      || stmt_is_bumper_for_loop (loop, stmt))\n-\t\t    {\n-\t\t      gsi_next (&bsi);\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  gsi_move_before (&bsi, &header_bsi);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Note that the bsi only needs to be explicitly incremented\n-\t\t when we don't move something, since it is automatically\n-\t\t incremented when we do.  */\n-\t      for (bsi = gsi_start_bb (bbs[i]); !gsi_end_p (bsi);)\n-\t\t{\n-\t\t  gimple stmt = gsi_stmt (bsi);\n-\n-\t\t  if (stmt == exit_condition\n-\t\t      || not_interesting_stmt (stmt)\n-\t\t      || stmt_is_bumper_for_loop (loop, stmt))\n-\t\t    {\n-\t\t      gsi_next (&bsi);\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  replace_uses_equiv_to_x_with_y\n-\t\t    (loop, stmt, oldivvar, VEC_index (int, steps, 0), ivvar,\n-\t\t     VEC_index (tree, lbounds, 0), replacements, &firstbsi);\n-\n-\t\t  gsi_move_before (&bsi, &tobsi);\n-\n-\t\t  /* If the statement has any virtual operands, they may\n-\t\t     need to be rewired because the original loop may\n-\t\t     still reference them.  */\n-\t\t  if (gimple_vuse (stmt))\n-\t\t    mark_sym_for_renaming (gimple_vop (cfun));\n-\t\t}\n-\t    }\n-\n-\t}\n-    }\n-\n-  free (bbs);\n-  htab_delete (replacements);\n-  return perfect_nest_p (loop);\n-}\n-\n-/* Return true if TRANS is a legal transformation matrix that respects\n-   the dependence vectors in DISTS and DIRS.  The conservative answer\n-   is false.\n-\n-   \"Wolfe proves that a unimodular transformation represented by the\n-   matrix T is legal when applied to a loop nest with a set of\n-   lexicographically non-negative distance vectors RDG if and only if\n-   for each vector d in RDG, (T.d >= 0) is lexicographically positive.\n-   i.e.: if and only if it transforms the lexicographically positive\n-   distance vectors to lexicographically positive vectors.  Note that\n-   a unimodular matrix must transform the zero vector (and only it) to\n-   the zero vector.\" S.Muchnick.  */\n-\n-bool\n-lambda_transform_legal_p (lambda_trans_matrix trans,\n-\t\t\t  int nb_loops,\n-\t\t\t  VEC (ddr_p, heap) *dependence_relations)\n-{\n-  unsigned int i, j;\n-  lambda_vector distres;\n-  struct data_dependence_relation *ddr;\n-\n-  gcc_assert (LTM_COLSIZE (trans) == nb_loops\n-\t      && LTM_ROWSIZE (trans) == nb_loops);\n-\n-  /* When there are no dependences, the transformation is correct.  */\n-  if (VEC_length (ddr_p, dependence_relations) == 0)\n-    return true;\n-\n-  ddr = VEC_index (ddr_p, dependence_relations, 0);\n-  if (ddr == NULL)\n-    return true;\n-\n-  /* When there is an unknown relation in the dependence_relations, we\n-     know that it is no worth looking at this loop nest: give up.  */\n-  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-    return false;\n-\n-  distres = lambda_vector_new (nb_loops);\n-\n-  /* For each distance vector in the dependence graph.  */\n-  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n-    {\n-      /* Don't care about relations for which we know that there is no\n-\t dependence, nor about read-read (aka. output-dependences):\n-\t these data accesses can happen in any order.  */\n-      if (DDR_ARE_DEPENDENT (ddr) == chrec_known\n-\t  || (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr))))\n-\tcontinue;\n-\n-      /* Conservatively answer: \"this transformation is not valid\".  */\n-      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-\treturn false;\n-\n-      /* If the dependence could not be captured by a distance vector,\n-\t conservatively answer that the transform is not valid.  */\n-      if (DDR_NUM_DIST_VECTS (ddr) == 0)\n-\treturn false;\n-\n-      /* Compute trans.dist_vect */\n-      for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n-\t{\n-\t  lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops,\n-\t\t\t\t     DDR_DIST_VECT (ddr, j), distres);\n-\n-\t  if (!lambda_vector_lexico_pos (distres, nb_loops))\n-\t    return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n-\n-/* Collects parameters from affine function ACCESS_FUNCTION, and push\n-   them in PARAMETERS.  */\n-\n-static void\n-lambda_collect_parameters_from_af (tree access_function,\n-\t\t\t\t   struct pointer_set_t *param_set,\n-\t\t\t\t   VEC (tree, heap) **parameters)\n-{\n-  if (access_function == NULL)\n-    return;\n-\n-  if (TREE_CODE (access_function) == SSA_NAME\n-      && pointer_set_contains (param_set, access_function) == 0)\n-    {\n-      pointer_set_insert (param_set, access_function);\n-      VEC_safe_push (tree, heap, *parameters, access_function);\n-    }\n-  else\n-    {\n-      int i, num_operands = tree_operand_length (access_function);\n-\n-      for (i = 0; i < num_operands; i++)\n-\tlambda_collect_parameters_from_af (TREE_OPERAND (access_function, i),\n-\t\t\t\t\t   param_set, parameters);\n-    }\n-}\n-\n-/* Collects parameters from DATAREFS, and push them in PARAMETERS.  */\n-\n-void\n-lambda_collect_parameters (VEC (data_reference_p, heap) *datarefs,\n-\t\t\t   VEC (tree, heap) **parameters)\n-{\n-  unsigned i, j;\n-  struct pointer_set_t *parameter_set = pointer_set_create ();\n-  data_reference_p data_reference;\n-\n-  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, data_reference)\n-    for (j = 0; j < DR_NUM_DIMENSIONS (data_reference); j++)\n-      lambda_collect_parameters_from_af (DR_ACCESS_FN (data_reference, j),\n-\t\t\t\t\t parameter_set, parameters);\n-  pointer_set_destroy (parameter_set);\n-}\n-\n-/* Translates BASE_EXPR to vector CY.  AM is needed for inferring\n-   indexing positions in the data access vector.  CST is the analyzed\n-   integer constant.  */\n-\n-static bool\n-av_for_af_base (tree base_expr, lambda_vector cy, struct access_matrix *am,\n-\t\tint cst)\n-{\n-  bool result = true;\n-\n-  switch (TREE_CODE (base_expr))\n-    {\n-    case INTEGER_CST:\n-      /* Constant part.  */\n-      cy[AM_CONST_COLUMN_INDEX (am)] += int_cst_value (base_expr) * cst;\n-      return true;\n-\n-    case SSA_NAME:\n-      {\n-\tint param_index =\n-\t  access_matrix_get_index_for_parameter (base_expr, am);\n-\n-\tif (param_index >= 0)\n-\t  {\n-\t    cy[param_index] = cst + cy[param_index];\n-\t    return true;\n-\t  }\n-\n-\treturn false;\n-      }\n-\n-    case PLUS_EXPR:\n-      return av_for_af_base (TREE_OPERAND (base_expr, 0), cy, am, cst)\n-\t&& av_for_af_base (TREE_OPERAND (base_expr, 1), cy, am, cst);\n-\n-    case MINUS_EXPR:\n-      return av_for_af_base (TREE_OPERAND (base_expr, 0), cy, am, cst)\n-\t&& av_for_af_base (TREE_OPERAND (base_expr, 1), cy, am, -1 * cst);\n-\n-    case MULT_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (base_expr, 0)) == INTEGER_CST)\n-\tresult = av_for_af_base (TREE_OPERAND (base_expr, 1),\n-\t\t\t\t cy, am, cst *\n-\t\t\t\t int_cst_value (TREE_OPERAND (base_expr, 0)));\n-      else if (TREE_CODE (TREE_OPERAND (base_expr, 1)) == INTEGER_CST)\n-\tresult = av_for_af_base (TREE_OPERAND (base_expr, 0),\n-\t\t\t\t cy, am, cst *\n-\t\t\t\t int_cst_value (TREE_OPERAND (base_expr, 1)));\n-      else\n-\tresult = false;\n-\n-      return result;\n-\n-    case NEGATE_EXPR:\n-      return av_for_af_base (TREE_OPERAND (base_expr, 0), cy, am, -1 * cst);\n-\n-    default:\n-      return false;\n-    }\n-\n-  return result;\n-}\n-\n-/* Translates ACCESS_FUN to vector CY.  AM is needed for inferring\n-   indexing positions in the data access vector.  */\n-\n-static bool\n-av_for_af (tree access_fun, lambda_vector cy, struct access_matrix *am)\n-{\n-  switch (TREE_CODE (access_fun))\n-    {\n-    case POLYNOMIAL_CHREC:\n-      {\n-\ttree left = CHREC_LEFT (access_fun);\n-\ttree right = CHREC_RIGHT (access_fun);\n-\tunsigned var;\n-\n-\tif (TREE_CODE (right) != INTEGER_CST)\n-\t  return false;\n-\n-\tvar = am_vector_index_for_loop (am, CHREC_VARIABLE (access_fun));\n-\tcy[var] = int_cst_value (right);\n-\n-\tif (TREE_CODE (left) == POLYNOMIAL_CHREC)\n-\t  return av_for_af (left, cy, am);\n-\telse\n-\t  return av_for_af_base (left, cy, am, 1);\n-      }\n-\n-    case INTEGER_CST:\n-      /* Constant part.  */\n-      return av_for_af_base (access_fun, cy, am, 1);\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Initializes the access matrix for DATA_REFERENCE.  */\n-\n-static bool\n-build_access_matrix (data_reference_p data_reference,\n-\t\t     VEC (tree, heap) *parameters,\n-\t\t     VEC (loop_p, heap) *nest,\n-\t\t     struct obstack * lambda_obstack)\n-{\n-  struct access_matrix *am = (struct access_matrix *)\n-    obstack_alloc(lambda_obstack, sizeof (struct access_matrix));\n-  unsigned i, ndim = DR_NUM_DIMENSIONS (data_reference);\n-  unsigned nivs = VEC_length (loop_p, nest);\n-  unsigned lambda_nb_columns;\n-\n-  AM_LOOP_NEST (am) = nest;\n-  AM_NB_INDUCTION_VARS (am) = nivs;\n-  AM_PARAMETERS (am) = parameters;\n-\n-  lambda_nb_columns = AM_NB_COLUMNS (am);\n-  AM_MATRIX (am) = VEC_alloc (lambda_vector, gc, ndim);\n-\n-  for (i = 0; i < ndim; i++)\n-    {\n-      lambda_vector access_vector = lambda_vector_new (lambda_nb_columns);\n-      tree access_function = DR_ACCESS_FN (data_reference, i);\n-\n-      if (!av_for_af (access_function, access_vector, am))\n-\treturn false;\n-\n-      VEC_quick_push (lambda_vector, AM_MATRIX (am), access_vector);\n-    }\n-\n-  DR_ACCESS_MATRIX (data_reference) = am;\n-  return true;\n-}\n-\n-/* Returns false when one of the access matrices cannot be built.  */\n-\n-bool\n-lambda_compute_access_matrices (VEC (data_reference_p, heap) *datarefs,\n-\t\t\t\tVEC (tree, heap) *parameters,\n-\t\t\t\tVEC (loop_p, heap) *nest,\n-\t\t\t\tstruct obstack * lambda_obstack)\n-{\n-  data_reference_p dataref;\n-  unsigned ix;\n-\n-  FOR_EACH_VEC_ELT (data_reference_p, datarefs, ix, dataref)\n-    if (!build_access_matrix (dataref, parameters, nest, lambda_obstack))\n-      return false;\n-\n-  return true;\n-}"}, {"sha": "c57fb58c99b4cb81de2757e16f16e41678f4d845", "filename": "gcc/lambda-mat.c", "status": "removed", "additions": 0, "deletions": 608, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,608 +0,0 @@\n-/* Integer matrix math routines\n-   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree-flow.h\"\n-#include \"lambda.h\"\n-\n-/* Allocate a matrix of M rows x  N cols.  */\n-\n-lambda_matrix\n-lambda_matrix_new (int m, int n, struct obstack * lambda_obstack)\n-{\n-  lambda_matrix mat;\n-  int i;\n-\n-  mat = (lambda_matrix) obstack_alloc (lambda_obstack,\n-\t\t\t\t       sizeof (lambda_vector *) * m);\n-\n-  for (i = 0; i < m; i++)\n-    mat[i] = lambda_vector_new (n);\n-\n-  return mat;\n-}\n-\n-/* Copy the elements of M x N matrix MAT1 to MAT2.  */\n-\n-void\n-lambda_matrix_copy (lambda_matrix mat1, lambda_matrix mat2,\n-\t\t    int m, int n)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    lambda_vector_copy (mat1[i], mat2[i], n);\n-}\n-\n-/* Store the N x N identity matrix in MAT.  */\n-\n-void\n-lambda_matrix_id (lambda_matrix mat, int size)\n-{\n-  int i, j;\n-\n-  for (i = 0; i < size; i++)\n-    for (j = 0; j < size; j++)\n-      mat[i][j] = (i == j) ? 1 : 0;\n-}\n-\n-/* Return true if MAT is the identity matrix of SIZE */\n-\n-bool\n-lambda_matrix_id_p (lambda_matrix mat, int size)\n-{\n-  int i, j;\n-  for (i = 0; i < size; i++)\n-    for (j = 0; j < size; j++)\n-      {\n-\tif (i == j)\n-\t  {\n-\t    if (mat[i][j] != 1)\n-\t      return false;\n-\t  }\n-\telse\n-\t  {\n-\t    if (mat[i][j] != 0)\n-\t      return false;\n-\t  }\n-      }\n-  return true;\n-}\n-\n-/* Negate the elements of the M x N matrix MAT1 and store it in MAT2.  */\n-\n-void\n-lambda_matrix_negate (lambda_matrix mat1, lambda_matrix mat2, int m, int n)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    lambda_vector_negate (mat1[i], mat2[i], n);\n-}\n-\n-/* Take the transpose of matrix MAT1 and store it in MAT2.\n-   MAT1 is an M x N matrix, so MAT2 must be N x M.  */\n-\n-void\n-lambda_matrix_transpose (lambda_matrix mat1, lambda_matrix mat2, int m, int n)\n-{\n-  int i, j;\n-\n-  for (i = 0; i < n; i++)\n-    for (j = 0; j < m; j++)\n-      mat2[i][j] = mat1[j][i];\n-}\n-\n-\n-/* Add two M x N matrices together: MAT3 = MAT1+MAT2.  */\n-\n-void\n-lambda_matrix_add (lambda_matrix mat1, lambda_matrix mat2,\n-\t\t   lambda_matrix mat3, int m, int n)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    lambda_vector_add (mat1[i], mat2[i], mat3[i], n);\n-}\n-\n-/* MAT3 = CONST1 * MAT1 + CONST2 * MAT2.  All matrices are M x N.  */\n-\n-void\n-lambda_matrix_add_mc (lambda_matrix mat1, int const1,\n-\t\t      lambda_matrix mat2, int const2,\n-\t\t      lambda_matrix mat3, int m, int n)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    lambda_vector_add_mc (mat1[i], const1, mat2[i], const2, mat3[i], n);\n-}\n-\n-/* Multiply two matrices: MAT3 = MAT1 * MAT2.\n-   MAT1 is an M x R matrix, and MAT2 is R x N.  The resulting MAT2\n-   must therefore be M x N.  */\n-\n-void\n-lambda_matrix_mult (lambda_matrix mat1, lambda_matrix mat2,\n-\t\t    lambda_matrix mat3, int m, int r, int n)\n-{\n-\n-  int i, j, k;\n-\n-  for (i = 0; i < m; i++)\n-    {\n-      for (j = 0; j < n; j++)\n-\t{\n-\t  mat3[i][j] = 0;\n-\t  for (k = 0; k < r; k++)\n-\t    mat3[i][j] += mat1[i][k] * mat2[k][j];\n-\t}\n-    }\n-}\n-\n-/* Delete rows r1 to r2 (not including r2).  */\n-\n-void\n-lambda_matrix_delete_rows (lambda_matrix mat, int rows, int from, int to)\n-{\n-  int i;\n-  int dist;\n-  dist = to - from;\n-\n-  for (i = to; i < rows; i++)\n-    mat[i - dist] = mat[i];\n-\n-  for (i = rows - dist; i < rows; i++)\n-    mat[i] = NULL;\n-}\n-\n-/* Swap rows R1 and R2 in matrix MAT.  */\n-\n-void\n-lambda_matrix_row_exchange (lambda_matrix mat, int r1, int r2)\n-{\n-  lambda_vector row;\n-\n-  row = mat[r1];\n-  mat[r1] = mat[r2];\n-  mat[r2] = row;\n-}\n-\n-/* Add a multiple of row R1 of matrix MAT with N columns to row R2:\n-   R2 = R2 + CONST1 * R1.  */\n-\n-void\n-lambda_matrix_row_add (lambda_matrix mat, int n, int r1, int r2, int const1)\n-{\n-  int i;\n-\n-  if (const1 == 0)\n-    return;\n-\n-  for (i = 0; i < n; i++)\n-    mat[r2][i] += const1 * mat[r1][i];\n-}\n-\n-/* Negate row R1 of matrix MAT which has N columns.  */\n-\n-void\n-lambda_matrix_row_negate (lambda_matrix mat, int n, int r1)\n-{\n-  lambda_vector_negate (mat[r1], mat[r1], n);\n-}\n-\n-/* Multiply row R1 of matrix MAT with N columns by CONST1.  */\n-\n-void\n-lambda_matrix_row_mc (lambda_matrix mat, int n, int r1, int const1)\n-{\n-  int i;\n-\n-  for (i = 0; i < n; i++)\n-    mat[r1][i] *= const1;\n-}\n-\n-/* Exchange COL1 and COL2 in matrix MAT. M is the number of rows.  */\n-\n-void\n-lambda_matrix_col_exchange (lambda_matrix mat, int m, int col1, int col2)\n-{\n-  int i;\n-  int tmp;\n-  for (i = 0; i < m; i++)\n-    {\n-      tmp = mat[i][col1];\n-      mat[i][col1] = mat[i][col2];\n-      mat[i][col2] = tmp;\n-    }\n-}\n-\n-/* Add a multiple of column C1 of matrix MAT with M rows to column C2:\n-   C2 = C2 + CONST1 * C1.  */\n-\n-void\n-lambda_matrix_col_add (lambda_matrix mat, int m, int c1, int c2, int const1)\n-{\n-  int i;\n-\n-  if (const1 == 0)\n-    return;\n-\n-  for (i = 0; i < m; i++)\n-    mat[i][c2] += const1 * mat[i][c1];\n-}\n-\n-/* Negate column C1 of matrix MAT which has M rows.  */\n-\n-void\n-lambda_matrix_col_negate (lambda_matrix mat, int m, int c1)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    mat[i][c1] *= -1;\n-}\n-\n-/* Multiply column C1 of matrix MAT with M rows by CONST1.  */\n-\n-void\n-lambda_matrix_col_mc (lambda_matrix mat, int m, int c1, int const1)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    mat[i][c1] *= const1;\n-}\n-\n-/* Compute the inverse of the N x N matrix MAT and store it in INV.\n-\n-   We don't _really_ compute the inverse of MAT.  Instead we compute\n-   det(MAT)*inv(MAT), and we return det(MAT) to the caller as the function\n-   result.  This is necessary to preserve accuracy, because we are dealing\n-   with integer matrices here.\n-\n-   The algorithm used here is a column based Gauss-Jordan elimination on MAT\n-   and the identity matrix in parallel.  The inverse is the result of applying\n-   the same operations on the identity matrix that reduce MAT to the identity\n-   matrix.\n-\n-   When MAT is a 2 x 2 matrix, we don't go through the whole process, because\n-   it is easily inverted by inspection and it is a very common case.  */\n-\n-static int lambda_matrix_inverse_hard (lambda_matrix, lambda_matrix, int,\n-\t\t\t\t       struct obstack *);\n-\n-int\n-lambda_matrix_inverse (lambda_matrix mat, lambda_matrix inv, int n,\n-\t\t       struct obstack * lambda_obstack)\n-{\n-  if (n == 2)\n-    {\n-      int a, b, c, d, det;\n-      a = mat[0][0];\n-      b = mat[1][0];\n-      c = mat[0][1];\n-      d = mat[1][1];\n-      inv[0][0] =  d;\n-      inv[0][1] = -c;\n-      inv[1][0] = -b;\n-      inv[1][1] =  a;\n-      det = (a * d - b * c);\n-      if (det < 0)\n-\t{\n-\t  det *= -1;\n-\t  inv[0][0] *= -1;\n-\t  inv[1][0] *= -1;\n-\t  inv[0][1] *= -1;\n-\t  inv[1][1] *= -1;\n-\t}\n-      return det;\n-    }\n-  else\n-    return lambda_matrix_inverse_hard (mat, inv, n, lambda_obstack);\n-}\n-\n-/* If MAT is not a special case, invert it the hard way.  */\n-\n-static int\n-lambda_matrix_inverse_hard (lambda_matrix mat, lambda_matrix inv, int n,\n-\t\t\t    struct obstack * lambda_obstack)\n-{\n-  lambda_vector row;\n-  lambda_matrix temp;\n-  int i, j;\n-  int determinant;\n-\n-  temp = lambda_matrix_new (n, n, lambda_obstack);\n-  lambda_matrix_copy (mat, temp, n, n);\n-  lambda_matrix_id (inv, n);\n-\n-  /* Reduce TEMP to a lower triangular form, applying the same operations on\n-     INV which starts as the identity matrix.  N is the number of rows and\n-     columns.  */\n-  for (j = 0; j < n; j++)\n-    {\n-      row = temp[j];\n-\n-      /* Make every element in the current row positive.  */\n-      for (i = j; i < n; i++)\n-\tif (row[i] < 0)\n-\t  {\n-\t    lambda_matrix_col_negate (temp, n, i);\n-\t    lambda_matrix_col_negate (inv, n, i);\n-\t  }\n-\n-      /* Sweep the upper triangle.  Stop when only the diagonal element in the\n-\t current row is nonzero.  */\n-      while (lambda_vector_first_nz (row, n, j + 1) < n)\n-\t{\n-\t  int min_col = lambda_vector_min_nz (row, n, j);\n-\t  lambda_matrix_col_exchange (temp, n, j, min_col);\n-\t  lambda_matrix_col_exchange (inv, n, j, min_col);\n-\n-\t  for (i = j + 1; i < n; i++)\n-\t    {\n-\t      int factor;\n-\n-\t      factor = -1 * row[i];\n-\t      if (row[j] != 1)\n-\t\tfactor /= row[j];\n-\n-\t      lambda_matrix_col_add (temp, n, j, i, factor);\n-\t      lambda_matrix_col_add (inv, n, j, i, factor);\n-\t    }\n-\t}\n-    }\n-\n-  /* Reduce TEMP from a lower triangular to the identity matrix.  Also compute\n-     the determinant, which now is simply the product of the elements on the\n-     diagonal of TEMP.  If one of these elements is 0, the matrix has 0 as an\n-     eigenvalue so it is singular and hence not invertible.  */\n-  determinant = 1;\n-  for (j = n - 1; j >= 0; j--)\n-    {\n-      int diagonal;\n-\n-      row = temp[j];\n-      diagonal = row[j];\n-\n-      /* The matrix must not be singular.  */\n-      gcc_assert (diagonal);\n-\n-      determinant = determinant * diagonal;\n-\n-      /* If the diagonal is not 1, then multiply the each row by the\n-         diagonal so that the middle number is now 1, rather than a\n-         rational.  */\n-      if (diagonal != 1)\n-\t{\n-\t  for (i = 0; i < j; i++)\n-\t    lambda_matrix_col_mc (inv, n, i, diagonal);\n-\t  for (i = j + 1; i < n; i++)\n-\t    lambda_matrix_col_mc (inv, n, i, diagonal);\n-\n-\t  row[j] = diagonal = 1;\n-\t}\n-\n-      /* Sweep the lower triangle column wise.  */\n-      for (i = j - 1; i >= 0; i--)\n-\t{\n-\t  if (row[i])\n-\t    {\n-\t      int factor = -row[i];\n-\t      lambda_matrix_col_add (temp, n, j, i, factor);\n-\t      lambda_matrix_col_add (inv, n, j, i, factor);\n-\t    }\n-\n-\t}\n-    }\n-\n-  return determinant;\n-}\n-\n-/* Decompose a N x N matrix MAT to a product of a lower triangular H\n-   and a unimodular U matrix such that MAT = H.U.  N is the size of\n-   the rows of MAT.  */\n-\n-void\n-lambda_matrix_hermite (lambda_matrix mat, int n,\n-\t\t       lambda_matrix H, lambda_matrix U)\n-{\n-  lambda_vector row;\n-  int i, j, factor, minimum_col;\n-\n-  lambda_matrix_copy (mat, H, n, n);\n-  lambda_matrix_id (U, n);\n-\n-  for (j = 0; j < n; j++)\n-    {\n-      row = H[j];\n-\n-      /* Make every element of H[j][j..n] positive.  */\n-      for (i = j; i < n; i++)\n-\t{\n-\t  if (row[i] < 0)\n-\t    {\n-\t      lambda_matrix_col_negate (H, n, i);\n-\t      lambda_vector_negate (U[i], U[i], n);\n-\t    }\n-\t}\n-\n-      /* Stop when only the diagonal element is nonzero.  */\n-      while (lambda_vector_first_nz (row, n, j + 1) < n)\n-\t{\n-\t  minimum_col = lambda_vector_min_nz (row, n, j);\n-\t  lambda_matrix_col_exchange (H, n, j, minimum_col);\n-\t  lambda_matrix_row_exchange (U, j, minimum_col);\n-\n-\t  for (i = j + 1; i < n; i++)\n-\t    {\n-\t      factor = row[i] / row[j];\n-\t      lambda_matrix_col_add (H, n, j, i, -1 * factor);\n-\t      lambda_matrix_row_add (U, n, i, j, factor);\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Given an M x N integer matrix A, this function determines an M x\n-   M unimodular matrix U, and an M x N echelon matrix S such that\n-   \"U.A = S\".  This decomposition is also known as \"right Hermite\".\n-\n-   Ref: Algorithm 2.1 page 33 in \"Loop Transformations for\n-   Restructuring Compilers\" Utpal Banerjee.  */\n-\n-void\n-lambda_matrix_right_hermite (lambda_matrix A, int m, int n,\n-\t\t\t     lambda_matrix S, lambda_matrix U)\n-{\n-  int i, j, i0 = 0;\n-\n-  lambda_matrix_copy (A, S, m, n);\n-  lambda_matrix_id (U, m);\n-\n-  for (j = 0; j < n; j++)\n-    {\n-      if (lambda_vector_first_nz (S[j], m, i0) < m)\n-\t{\n-\t  ++i0;\n-\t  for (i = m - 1; i >= i0; i--)\n-\t    {\n-\t      while (S[i][j] != 0)\n-\t\t{\n-\t\t  int sigma, factor, a, b;\n-\n-\t\t  a = S[i-1][j];\n-\t\t  b = S[i][j];\n-\t\t  sigma = (a * b < 0) ? -1: 1;\n-\t\t  a = abs (a);\n-\t\t  b = abs (b);\n-\t\t  factor = sigma * (a / b);\n-\n-\t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n-\t\t  lambda_matrix_row_exchange (S, i, i-1);\n-\n-\t\t  lambda_matrix_row_add (U, m, i, i-1, -factor);\n-\t\t  lambda_matrix_row_exchange (U, i, i-1);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Given an M x N integer matrix A, this function determines an M x M\n-   unimodular matrix V, and an M x N echelon matrix S such that \"A =\n-   V.S\".  This decomposition is also known as \"left Hermite\".\n-\n-   Ref: Algorithm 2.2 page 36 in \"Loop Transformations for\n-   Restructuring Compilers\" Utpal Banerjee.  */\n-\n-void\n-lambda_matrix_left_hermite (lambda_matrix A, int m, int n,\n-\t\t\t     lambda_matrix S, lambda_matrix V)\n-{\n-  int i, j, i0 = 0;\n-\n-  lambda_matrix_copy (A, S, m, n);\n-  lambda_matrix_id (V, m);\n-\n-  for (j = 0; j < n; j++)\n-    {\n-      if (lambda_vector_first_nz (S[j], m, i0) < m)\n-\t{\n-\t  ++i0;\n-\t  for (i = m - 1; i >= i0; i--)\n-\t    {\n-\t      while (S[i][j] != 0)\n-\t\t{\n-\t\t  int sigma, factor, a, b;\n-\n-\t\t  a = S[i-1][j];\n-\t\t  b = S[i][j];\n-\t\t  sigma = (a * b < 0) ? -1: 1;\n-\t\t  a = abs (a);\n-      b = abs (b);\n-\t\t  factor = sigma * (a / b);\n-\n-\t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n-\t\t  lambda_matrix_row_exchange (S, i, i-1);\n-\n-\t\t  lambda_matrix_col_add (V, m, i-1, i, factor);\n-\t\t  lambda_matrix_col_exchange (V, m, i, i-1);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* When it exists, return the first nonzero row in MAT after row\n-   STARTROW.  Otherwise return rowsize.  */\n-\n-int\n-lambda_matrix_first_nz_vec (lambda_matrix mat, int rowsize, int colsize,\n-\t\t\t    int startrow)\n-{\n-  int j;\n-  bool found = false;\n-\n-  for (j = startrow; (j < rowsize) && !found; j++)\n-    {\n-      if ((mat[j] != NULL)\n-\t  && (lambda_vector_first_nz (mat[j], colsize, startrow) < colsize))\n-\tfound = true;\n-    }\n-\n-  if (found)\n-    return j - 1;\n-  return rowsize;\n-}\n-\n-/* Multiply a vector VEC by a matrix MAT.\n-   MAT is an M*N matrix, and VEC is a vector with length N.  The result\n-   is stored in DEST which must be a vector of length M.  */\n-\n-void\n-lambda_matrix_vector_mult (lambda_matrix matrix, int m, int n,\n-\t\t\t   lambda_vector vec, lambda_vector dest)\n-{\n-  int i, j;\n-\n-  lambda_vector_clear (dest, m);\n-  for (i = 0; i < m; i++)\n-    for (j = 0; j < n; j++)\n-      dest[i] += matrix[i][j] * vec[j];\n-}\n-\n-/* Print out an M x N matrix MAT to OUTFILE.  */\n-\n-void\n-print_lambda_matrix (FILE * outfile, lambda_matrix matrix, int m, int n)\n-{\n-  int i;\n-\n-  for (i = 0; i < m; i++)\n-    print_lambda_vector (outfile, matrix[i], n);\n-  fprintf (outfile, \"\\n\");\n-}\n-"}, {"sha": "ba1449977ea0dddf5163bee1bdbd8cd584e8a826", "filename": "gcc/lambda-trans.c", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,80 +0,0 @@\n-/* Lambda matrix transformations.\n-   Copyright (C) 2003, 2004, 2007, 2008, 2010 Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree-flow.h\"\n-#include \"lambda.h\"\n-\n-/* Allocate a new transformation matrix.  */\n-\n-lambda_trans_matrix\n-lambda_trans_matrix_new (int colsize, int rowsize,\n-\t\t\t struct obstack * lambda_obstack)\n-{\n-  lambda_trans_matrix ret;\n-\n-  ret = (lambda_trans_matrix)\n-    obstack_alloc (lambda_obstack, sizeof (struct lambda_trans_matrix_s));\n-  LTM_MATRIX (ret) = lambda_matrix_new (rowsize, colsize, lambda_obstack);\n-  LTM_ROWSIZE (ret) = rowsize;\n-  LTM_COLSIZE (ret) = colsize;\n-  LTM_DENOMINATOR (ret) = 1;\n-  return ret;\n-}\n-\n-/* Return true if MAT is an identity matrix.  */\n-\n-bool\n-lambda_trans_matrix_id_p (lambda_trans_matrix mat)\n-{\n-  if (LTM_ROWSIZE (mat) != LTM_COLSIZE (mat))\n-    return false;\n-  return lambda_matrix_id_p (LTM_MATRIX (mat), LTM_ROWSIZE (mat));\n-}\n-\n-\n-/* Compute the inverse of the transformation matrix MAT.  */\n-\n-lambda_trans_matrix\n-lambda_trans_matrix_inverse (lambda_trans_matrix mat,\n-\t\t\t     struct obstack * lambda_obstack)\n-{\n-  lambda_trans_matrix inverse;\n-  int determinant;\n-\n-  inverse = lambda_trans_matrix_new (LTM_ROWSIZE (mat), LTM_COLSIZE (mat),\n-\t\t\t\t     lambda_obstack);\n-  determinant = lambda_matrix_inverse (LTM_MATRIX (mat), LTM_MATRIX (inverse),\n-\t\t\t\t       LTM_ROWSIZE (mat), lambda_obstack);\n-  LTM_DENOMINATOR (inverse) = determinant;\n-  return inverse;\n-}\n-\n-\n-/* Print out a transformation matrix.  */\n-\n-void\n-print_lambda_trans_matrix (FILE *outfile, lambda_trans_matrix mat)\n-{\n-  print_lambda_matrix (outfile, LTM_MATRIX (mat), LTM_ROWSIZE (mat),\n-\t\t       LTM_COLSIZE (mat));\n-}"}, {"sha": "382b71f7e0d724c6e1c6c96f1cda65cf2222b4e6", "filename": "gcc/lambda.h", "status": "removed", "additions": 0, "deletions": 524, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,524 +0,0 @@\n-/* Lambda matrix and vector interface.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LAMBDA_H\n-#define LAMBDA_H\n-\n-#include \"vec.h\"\n-\n-/* An integer vector.  A vector formally consists of an element of a vector\n-   space. A vector space is a set that is closed under vector addition\n-   and scalar multiplication.  In this vector space, an element is a list of\n-   integers.  */\n-typedef int *lambda_vector;\n-DEF_VEC_P(lambda_vector);\n-DEF_VEC_ALLOC_P(lambda_vector,heap);\n-DEF_VEC_ALLOC_P(lambda_vector,gc);\n-\n-typedef VEC(lambda_vector, heap) *lambda_vector_vec_p;\n-DEF_VEC_P (lambda_vector_vec_p);\n-DEF_VEC_ALLOC_P (lambda_vector_vec_p, heap);\n-\n-/* An integer matrix.  A matrix consists of m vectors of length n (IE\n-   all vectors are the same length).  */\n-typedef lambda_vector *lambda_matrix;\n-\n-DEF_VEC_P (lambda_matrix);\n-DEF_VEC_ALLOC_P (lambda_matrix, heap);\n-\n-/* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE\n-   matrix.  Rather than use floats, we simply keep a single DENOMINATOR that\n-   represents the denominator for every element in the matrix.  */\n-typedef struct lambda_trans_matrix_s\n-{\n-  lambda_matrix matrix;\n-  int rowsize;\n-  int colsize;\n-  int denominator;\n-} *lambda_trans_matrix;\n-#define LTM_MATRIX(T) ((T)->matrix)\n-#define LTM_ROWSIZE(T) ((T)->rowsize)\n-#define LTM_COLSIZE(T) ((T)->colsize)\n-#define LTM_DENOMINATOR(T) ((T)->denominator)\n-\n-/* A vector representing a statement in the body of a loop.\n-   The COEFFICIENTS vector contains a coefficient for each induction variable\n-   in the loop nest containing the statement.\n-   The DENOMINATOR represents the denominator for each coefficient in the\n-   COEFFICIENT vector.\n-\n-   This structure is used during code generation in order to rewrite the old\n-   induction variable uses in a statement in terms of the newly created\n-   induction variables.  */\n-typedef struct lambda_body_vector_s\n-{\n-  lambda_vector coefficients;\n-  int size;\n-  int denominator;\n-} *lambda_body_vector;\n-#define LBV_COEFFICIENTS(T) ((T)->coefficients)\n-#define LBV_SIZE(T) ((T)->size)\n-#define LBV_DENOMINATOR(T) ((T)->denominator)\n-\n-/* Piecewise linear expression.\n-   This structure represents a linear expression with terms for the invariants\n-   and induction variables of a loop.\n-   COEFFICIENTS is a vector of coefficients for the induction variables, one\n-   per loop in the loop nest.\n-   CONSTANT is the constant portion of the linear expression\n-   INVARIANT_COEFFICIENTS is a vector of coefficients for the loop invariants,\n-   one per invariant.\n-   DENOMINATOR is the denominator for all of the coefficients and constants in\n-   the expression.\n-   The linear expressions can be linked together using the NEXT field, in\n-   order to represent MAX or MIN of a group of linear expressions.  */\n-typedef struct lambda_linear_expression_s\n-{\n-  lambda_vector coefficients;\n-  int constant;\n-  lambda_vector invariant_coefficients;\n-  int denominator;\n-  struct lambda_linear_expression_s *next;\n-} *lambda_linear_expression;\n-\n-#define LLE_COEFFICIENTS(T) ((T)->coefficients)\n-#define LLE_CONSTANT(T) ((T)->constant)\n-#define LLE_INVARIANT_COEFFICIENTS(T) ((T)->invariant_coefficients)\n-#define LLE_DENOMINATOR(T) ((T)->denominator)\n-#define LLE_NEXT(T) ((T)->next)\n-\n-struct obstack;\n-\n-lambda_linear_expression lambda_linear_expression_new (int, int,\n-                                                       struct obstack *);\n-void print_lambda_linear_expression (FILE *, lambda_linear_expression, int,\n-\t\t\t\t     int, char);\n-\n-/* Loop structure.  Our loop structure consists of a constant representing the\n-   STEP of the loop, a set of linear expressions representing the LOWER_BOUND\n-   of the loop, a set of linear expressions representing the UPPER_BOUND of\n-   the loop, and a set of linear expressions representing the LINEAR_OFFSET of\n-   the loop.  The linear offset is a set of linear expressions that are\n-   applied to *both* the lower bound, and the upper bound.  */\n-typedef struct lambda_loop_s\n-{\n-  lambda_linear_expression lower_bound;\n-  lambda_linear_expression upper_bound;\n-  lambda_linear_expression linear_offset;\n-  int step;\n-} *lambda_loop;\n-\n-#define LL_LOWER_BOUND(T) ((T)->lower_bound)\n-#define LL_UPPER_BOUND(T) ((T)->upper_bound)\n-#define LL_LINEAR_OFFSET(T) ((T)->linear_offset)\n-#define LL_STEP(T)   ((T)->step)\n-\n-/* Loop nest structure.\n-   The loop nest structure consists of a set of loop structures (defined\n-   above) in LOOPS, along with an integer representing the DEPTH of the loop,\n-   and an integer representing the number of INVARIANTS in the loop.  Both of\n-   these integers are used to size the associated coefficient vectors in the\n-   linear expression structures.  */\n-typedef struct lambda_loopnest_s\n-{\n-  lambda_loop *loops;\n-  int depth;\n-  int invariants;\n-} *lambda_loopnest;\n-\n-#define LN_LOOPS(T) ((T)->loops)\n-#define LN_DEPTH(T) ((T)->depth)\n-#define LN_INVARIANTS(T) ((T)->invariants)\n-\n-lambda_loopnest lambda_loopnest_new (int, int, struct obstack *);\n-lambda_loopnest lambda_loopnest_transform (lambda_loopnest,\n-                                           lambda_trans_matrix,\n-                                           struct obstack *);\n-struct loop;\n-bool perfect_nest_p (struct loop *);\n-void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n-\n-void print_lambda_loop (FILE *, lambda_loop, int, int, char);\n-\n-lambda_matrix lambda_matrix_new (int, int, struct obstack *);\n-\n-void lambda_matrix_id (lambda_matrix, int);\n-bool lambda_matrix_id_p (lambda_matrix, int);\n-void lambda_matrix_copy (lambda_matrix, lambda_matrix, int, int);\n-void lambda_matrix_negate (lambda_matrix, lambda_matrix, int, int);\n-void lambda_matrix_transpose (lambda_matrix, lambda_matrix, int, int);\n-void lambda_matrix_add (lambda_matrix, lambda_matrix, lambda_matrix, int,\n-\t\t\tint);\n-void lambda_matrix_add_mc (lambda_matrix, int, lambda_matrix, int,\n-\t\t\t   lambda_matrix, int, int);\n-void lambda_matrix_mult (lambda_matrix, lambda_matrix, lambda_matrix,\n-\t\t\t int, int, int);\n-void lambda_matrix_delete_rows (lambda_matrix, int, int, int);\n-void lambda_matrix_row_exchange (lambda_matrix, int, int);\n-void lambda_matrix_row_add (lambda_matrix, int, int, int, int);\n-void lambda_matrix_row_negate (lambda_matrix mat, int, int);\n-void lambda_matrix_row_mc (lambda_matrix, int, int, int);\n-void lambda_matrix_col_exchange (lambda_matrix, int, int, int);\n-void lambda_matrix_col_add (lambda_matrix, int, int, int, int);\n-void lambda_matrix_col_negate (lambda_matrix, int, int);\n-void lambda_matrix_col_mc (lambda_matrix, int, int, int);\n-int lambda_matrix_inverse (lambda_matrix, lambda_matrix, int, struct obstack *);\n-void lambda_matrix_hermite (lambda_matrix, int, lambda_matrix, lambda_matrix);\n-void lambda_matrix_left_hermite (lambda_matrix, int, int, lambda_matrix, lambda_matrix);\n-void lambda_matrix_right_hermite (lambda_matrix, int, int, lambda_matrix, lambda_matrix);\n-int lambda_matrix_first_nz_vec (lambda_matrix, int, int, int);\n-void lambda_matrix_project_to_null (lambda_matrix, int, int, int,\n-\t\t\t\t    lambda_vector);\n-void print_lambda_matrix (FILE *, lambda_matrix, int, int);\n-\n-lambda_trans_matrix lambda_trans_matrix_new (int, int, struct obstack *);\n-bool lambda_trans_matrix_nonsingular_p (lambda_trans_matrix);\n-bool lambda_trans_matrix_fullrank_p (lambda_trans_matrix);\n-int lambda_trans_matrix_rank (lambda_trans_matrix);\n-lambda_trans_matrix lambda_trans_matrix_basis (lambda_trans_matrix);\n-lambda_trans_matrix lambda_trans_matrix_padding (lambda_trans_matrix);\n-lambda_trans_matrix lambda_trans_matrix_inverse (lambda_trans_matrix,\n-\t\t\t\t\t\t struct obstack *);\n-void print_lambda_trans_matrix (FILE *, lambda_trans_matrix);\n-void lambda_matrix_vector_mult (lambda_matrix, int, int, lambda_vector,\n-\t\t\t\tlambda_vector);\n-bool lambda_trans_matrix_id_p (lambda_trans_matrix);\n-\n-lambda_body_vector lambda_body_vector_new (int, struct obstack *);\n-lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix,\n-                                                   lambda_body_vector,\n-                                                   struct obstack *);\n-void print_lambda_body_vector (FILE *, lambda_body_vector);\n-lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loop *,\n-\t\t\t\t\t\t VEC(tree,heap) **,\n-                                                 VEC(tree,heap) **,\n-                                                 struct obstack *);\n-void lambda_loopnest_to_gcc_loopnest (struct loop *,\n-\t\t\t\t      VEC(tree,heap) *, VEC(tree,heap) *,\n-\t\t\t\t      VEC(gimple,heap) **,\n-                                      lambda_loopnest, lambda_trans_matrix,\n-                                      struct obstack *);\n-void remove_iv (gimple);\n-tree find_induction_var_from_exit_cond (struct loop *);\n-\n-static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);\n-static inline void lambda_vector_mult_const (lambda_vector, lambda_vector, int, int);\n-static inline void lambda_vector_add (lambda_vector, lambda_vector,\n-\t\t\t\t      lambda_vector, int);\n-static inline void lambda_vector_add_mc (lambda_vector, int, lambda_vector, int,\n-\t\t\t\t\t lambda_vector, int);\n-static inline void lambda_vector_copy (lambda_vector, lambda_vector, int);\n-static inline bool lambda_vector_zerop (lambda_vector, int);\n-static inline void lambda_vector_clear (lambda_vector, int);\n-static inline bool lambda_vector_equal (lambda_vector, lambda_vector, int);\n-static inline int lambda_vector_min_nz (lambda_vector, int, int);\n-static inline int lambda_vector_first_nz (lambda_vector, int, int);\n-static inline void print_lambda_vector (FILE *, lambda_vector, int);\n-\n-/* Allocate a new vector of given SIZE.  */\n-\n-static inline lambda_vector\n-lambda_vector_new (int size)\n-{\n-  return (lambda_vector) ggc_alloc_cleared_atomic (sizeof (int) * size);\n-}\n-\n-\n-\n-/* Multiply vector VEC1 of length SIZE by a constant CONST1,\n-   and store the result in VEC2.  */\n-\n-static inline void\n-lambda_vector_mult_const (lambda_vector vec1, lambda_vector vec2,\n-\t\t\t  int size, int const1)\n-{\n-  int i;\n-\n-  if (const1 == 0)\n-    lambda_vector_clear (vec2, size);\n-  else\n-    for (i = 0; i < size; i++)\n-      vec2[i] = const1 * vec1[i];\n-}\n-\n-/* Negate vector VEC1 with length SIZE and store it in VEC2.  */\n-\n-static inline void\n-lambda_vector_negate (lambda_vector vec1, lambda_vector vec2,\n-\t\t      int size)\n-{\n-  lambda_vector_mult_const (vec1, vec2, size, -1);\n-}\n-\n-/* VEC3 = VEC1+VEC2, where all three the vectors are of length SIZE.  */\n-\n-static inline void\n-lambda_vector_add (lambda_vector vec1, lambda_vector vec2,\n-\t\t   lambda_vector vec3, int size)\n-{\n-  int i;\n-  for (i = 0; i < size; i++)\n-    vec3[i] = vec1[i] + vec2[i];\n-}\n-\n-/* VEC3 = CONSTANT1*VEC1 + CONSTANT2*VEC2.  All vectors have length SIZE.  */\n-\n-static inline void\n-lambda_vector_add_mc (lambda_vector vec1, int const1,\n-\t\t      lambda_vector vec2, int const2,\n-\t\t      lambda_vector vec3, int size)\n-{\n-  int i;\n-  for (i = 0; i < size; i++)\n-    vec3[i] = const1 * vec1[i] + const2 * vec2[i];\n-}\n-\n-/* Copy the elements of vector VEC1 with length SIZE to VEC2.  */\n-\n-static inline void\n-lambda_vector_copy (lambda_vector vec1, lambda_vector vec2,\n-\t\t    int size)\n-{\n-  memcpy (vec2, vec1, size * sizeof (*vec1));\n-}\n-\n-/* Return true if vector VEC1 of length SIZE is the zero vector.  */\n-\n-static inline bool\n-lambda_vector_zerop (lambda_vector vec1, int size)\n-{\n-  int i;\n-  for (i = 0; i < size; i++)\n-    if (vec1[i] != 0)\n-      return false;\n-  return true;\n-}\n-\n-/* Clear out vector VEC1 of length SIZE.  */\n-\n-static inline void\n-lambda_vector_clear (lambda_vector vec1, int size)\n-{\n-  memset (vec1, 0, size * sizeof (*vec1));\n-}\n-\n-/* Return true if two vectors are equal.  */\n-\n-static inline bool\n-lambda_vector_equal (lambda_vector vec1, lambda_vector vec2, int size)\n-{\n-  int i;\n-  for (i = 0; i < size; i++)\n-    if (vec1[i] != vec2[i])\n-      return false;\n-  return true;\n-}\n-\n-/* Return the minimum nonzero element in vector VEC1 between START and N.\n-   We must have START <= N.  */\n-\n-static inline int\n-lambda_vector_min_nz (lambda_vector vec1, int n, int start)\n-{\n-  int j;\n-  int min = -1;\n-\n-  gcc_assert (start <= n);\n-  for (j = start; j < n; j++)\n-    {\n-      if (vec1[j])\n-\tif (min < 0 || vec1[j] < vec1[min])\n-\t  min = j;\n-    }\n-  gcc_assert (min >= 0);\n-\n-  return min;\n-}\n-\n-/* Return the first nonzero element of vector VEC1 between START and N.\n-   We must have START <= N.   Returns N if VEC1 is the zero vector.  */\n-\n-static inline int\n-lambda_vector_first_nz (lambda_vector vec1, int n, int start)\n-{\n-  int j = start;\n-  while (j < n && vec1[j] == 0)\n-    j++;\n-  return j;\n-}\n-\n-\n-/* Multiply a vector by a matrix.  */\n-\n-static inline void\n-lambda_vector_matrix_mult (lambda_vector vect, int m, lambda_matrix mat,\n-\t\t\t   int n, lambda_vector dest)\n-{\n-  int i, j;\n-  lambda_vector_clear (dest, n);\n-  for (i = 0; i < n; i++)\n-    for (j = 0; j < m; j++)\n-      dest[i] += mat[j][i] * vect[j];\n-}\n-\n-/* Compare two vectors returning an integer less than, equal to, or\n-   greater than zero if the first argument is considered to be respectively\n-   less than, equal to, or greater than the second.\n-   We use the lexicographic order.  */\n-\n-static inline int\n-lambda_vector_compare (lambda_vector vec1, int length1, lambda_vector vec2,\n-                       int length2)\n-{\n-  int min_length;\n-  int i;\n-\n-  if (length1 < length2)\n-    min_length = length1;\n-  else\n-    min_length = length2;\n-\n-  for (i = 0; i < min_length; i++)\n-    if (vec1[i] < vec2[i])\n-      return -1;\n-    else if (vec1[i] > vec2[i])\n-      return 1;\n-    else\n-      continue;\n-\n-  return length1 - length2;\n-}\n-\n-/* Print out a vector VEC of length N to OUTFILE.  */\n-\n-static inline void\n-print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n-{\n-  int i;\n-\n-  for (i = 0; i < n; i++)\n-    fprintf (outfile, \"%3d \", vector[i]);\n-  fprintf (outfile, \"\\n\");\n-}\n-\n-/* Compute the greatest common divisor of two numbers using\n-   Euclid's algorithm.  */\n-\n-static inline int\n-gcd (int a, int b)\n-{\n-  int x, y, z;\n-\n-  x = abs (a);\n-  y = abs (b);\n-\n-  while (x > 0)\n-    {\n-      z = y % x;\n-      y = x;\n-      x = z;\n-    }\n-\n-  return y;\n-}\n-\n-/* Compute the greatest common divisor of a VECTOR of SIZE numbers.  */\n-\n-static inline int\n-lambda_vector_gcd (lambda_vector vector, int size)\n-{\n-  int i;\n-  int gcd1 = 0;\n-\n-  if (size > 0)\n-    {\n-      gcd1 = vector[0];\n-      for (i = 1; i < size; i++)\n-\tgcd1 = gcd (gcd1, vector[i]);\n-    }\n-  return gcd1;\n-}\n-\n-/* Returns true when the vector V is lexicographically positive, in\n-   other words, when the first nonzero element is positive.  */\n-\n-static inline bool\n-lambda_vector_lexico_pos (lambda_vector v,\n-\t\t\t  unsigned n)\n-{\n-  unsigned i;\n-  for (i = 0; i < n; i++)\n-    {\n-      if (v[i] == 0)\n-\tcontinue;\n-      if (v[i] < 0)\n-\treturn false;\n-      if (v[i] > 0)\n-\treturn true;\n-    }\n-  return true;\n-}\n-\n-/* Given a vector of induction variables IVS, and a vector of\n-   coefficients COEFS, build a tree that is a linear combination of\n-   the induction variables.  */\n-\n-static inline tree\n-build_linear_expr (tree type, lambda_vector coefs, VEC (tree, heap) *ivs)\n-{\n-  unsigned i;\n-  tree iv;\n-  tree expr = build_zero_cst (type);\n-\n-  for (i = 0; VEC_iterate (tree, ivs, i, iv); i++)\n-    {\n-      int k = coefs[i];\n-\n-      if (k == 1)\n-\texpr = fold_build2 (PLUS_EXPR, type, expr, iv);\n-\n-      else if (k != 0)\n-\texpr = fold_build2 (PLUS_EXPR, type, expr,\n-\t\t\t    fold_build2 (MULT_EXPR, type, iv,\n-\t\t\t\t\t build_int_cst (type, k)));\n-    }\n-\n-  return expr;\n-}\n-\n-/* Returns the dependence level for a vector DIST of size LENGTH.\n-   LEVEL = 0 means a lexicographic dependence, i.e. a dependence due\n-   to the sequence of statements, not carried by any loop.  */\n-\n-\n-static inline unsigned\n-dependence_level (lambda_vector dist_vect, int length)\n-{\n-  int i;\n-\n-  for (i = 0; i < length; i++)\n-    if (dist_vect[i] != 0)\n-      return i + 1;\n-\n-  return 0;\n-}\n-\n-#endif /* LAMBDA_H  */"}, {"sha": "757327686534adc76e4d499a3f9831a31bda9a77", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -25,7 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"ggc.h\"\n-#include \"lambda.h\"\t/* gcd */\n #include \"hashtab.h\"\n #include \"plugin-api.h\"\n #include \"lto-streamer.h\""}, {"sha": "1717f8e45240d8896d8fb099d987602a7092a512", "filename": "gcc/omega.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -181,24 +181,6 @@ omega_no_procedure (omega_pb pb ATTRIBUTE_UNUSED)\n \n void (*omega_when_reduced) (omega_pb) = omega_no_procedure;\n \n-/* Compute the greatest common divisor of A and B.  */\n-\n-static inline int\n-gcd (int b, int a)\n-{\n-  if (b == 1)\n-    return 1;\n-\n-  while (b != 0)\n-    {\n-      int t = b;\n-      b = a % b;\n-      a = t;\n-    }\n-\n-  return a;\n-}\n-\n /* Print to FILE from PB equation E with all its coefficients\n    multiplied by C.  */\n "}, {"sha": "90d61e346ecbf2f4b604b2704a62ab0915deb6b5", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -887,7 +887,6 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_record_bounds);\n \t  NEXT_PASS (pass_check_data_deps);\n \t  NEXT_PASS (pass_loop_distribution);\n-\t  NEXT_PASS (pass_linear_transform);\n \t  NEXT_PASS (pass_copy_prop);\n \t  NEXT_PASS (pass_graphite);\n \t    {"}, {"sha": "3234f95485d884f4a79b9563657d280141645820", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -1,3 +1,48 @@\n+2011-01-25  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gfortran.dg/graphite/interchange-4.f: New.\n+\t* gfortran.dg/graphite/interchange-5.f: New.\n+\n+\t* gcc.dg/tree-ssa/ltrans-1.c: Removed.\n+\t* gcc.dg/tree-ssa/ltrans-2.c: Removed.\n+\t* gcc.dg/tree-ssa/ltrans-3.c: Removed.\n+\t* gcc.dg/tree-ssa/ltrans-4.c: Removed.\n+\t* gcc.dg/tree-ssa/ltrans-5.c: Removed.\n+\t* gcc.dg/tree-ssa/ltrans-6.c: Removed.\n+\t* gcc.dg/tree-ssa/ltrans-8.c: Removed.\n+\t* gfortran.dg/ltrans-7.f90: Removed.\n+\t* gcc.dg/tree-ssa/data-dep-1.c: Removed.\n+\n+\t* gcc.dg/pr18792.c: -> gcc.dg/graphite/pr18792.c\n+\t* gcc.dg/pr19910.c: -> gcc.dg/graphite/pr19910.c\n+\t* gcc.dg/tree-ssa/20041110-1.c: -> gcc.dg/graphite/pr20041110-1.c\n+\t* gcc.dg/tree-ssa/pr20256.c: -> gcc.dg/graphite/pr20256.c\n+\t* gcc.dg/pr23625.c: -> gcc.dg/graphite/pr23625.c\n+\t* gcc.dg/tree-ssa/pr23820.c: -> gcc.dg/graphite/pr23820.c\n+\t* gcc.dg/tree-ssa/pr24309.c: -> gcc.dg/graphite/pr24309.c\n+\t* gcc.dg/tree-ssa/pr26435.c: -> gcc.dg/graphite/pr26435.c\n+\t* gcc.dg/pr29330.c: -> gcc.dg/graphite/pr29330.c\n+\t* gcc.dg/pr29581-1.c: -> gcc.dg/graphite/pr29581-1.c\n+\t* gcc.dg/pr29581-2.c: -> gcc.dg/graphite/pr29581-2.c\n+\t* gcc.dg/pr29581-3.c: -> gcc.dg/graphite/pr29581-3.c\n+\t* gcc.dg/pr29581-4.c: -> gcc.dg/graphite/pr29581-4.c\n+\t* gcc.dg/tree-ssa/loop-27.c: -> gcc.dg/graphite/pr30565.c\n+\t* gcc.dg/tree-ssa/pr31183.c: -> gcc.dg/graphite/pr31183.c\n+\t* gcc.dg/tree-ssa/pr33576.c: -> gcc.dg/graphite/pr33576.c\n+\t* gcc.dg/tree-ssa/pr33766.c: -> gcc.dg/graphite/pr33766.c\n+\t* gcc.dg/pr34016.c: -> gcc.dg/graphite/pr34016.c\n+\t* gcc.dg/tree-ssa/pr34017.c: -> gcc.dg/graphite/pr34017.c\n+\t* gcc.dg/tree-ssa/pr34123.c: -> gcc.dg/graphite/pr34123.c\n+\t* gcc.dg/tree-ssa/pr36287.c: -> gcc.dg/graphite/pr36287.c\n+\t* gcc.dg/tree-ssa/pr37686.c: -> gcc.dg/graphite/pr37686.c\n+\t* gcc.dg/pr42917.c: -> gcc.dg/graphite/pr42917.c\n+\t* gcc.dg/tree-ssa/data-dep-1.c\n+\t* gfortran.dg/loop_nest_1.f90: -> gfortran.dg/graphite/pr29290.f90\n+\t* gfortran.dg/pr29581.f90: -> gfortran.dg/graphite/pr29581.f90\n+\t* gfortran.dg/pr36286.f90: -> gfortran.dg/graphite/pr36286.f90\n+\t* gfortran.dg/pr36922.f: -> gfortran.dg/graphite/pr36922.f\n+\t* gfortran.dg/pr39516.f: -> gfortran.dg/graphite/pr39516.f\n+\n 2011-01-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47265"}, {"sha": "4e93fe145f365627b46d770a3ca214ef8f2fd11b", "filename": "gcc/testsuite/gcc.dg/graphite/pr18792.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr18792.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr18792.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr18792.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr18792.c"}, {"sha": "1ee0d213b8aaada81751229fbc246d84f9e3abc6", "filename": "gcc/testsuite/gcc.dg/graphite/pr19910.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr19910.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr19910.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr19910.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr19910.c"}, {"sha": "825b2b41fa9aa43395bb088b3197b7a6a1cb3597", "filename": "gcc/testsuite/gcc.dg/graphite/pr20041110-1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr20041110-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr20041110-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr20041110-1.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/20041110-1.c"}, {"sha": "29c8ebd14e22f43ae7b95140f14cdefa579e20b9", "filename": "gcc/testsuite/gcc.dg/graphite/pr20256.c", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr20256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr20256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr20256.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-linear\" } */\n /* { dg-require-effective-target size32plus } */\n \n int foo()\n@@ -20,6 +20,3 @@ int foo()\n \n   return s;\n }\n-\n-/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect loop nest\" 0 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20256.c"}, {"sha": "aaeddb2886d25704b37e8739375569e4e300c0c2", "filename": "gcc/testsuite/gcc.dg/graphite/pr23625.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr23625.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr23625.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr23625.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr23625.c"}, {"sha": "ee855e139418b5fd7faff3553789599b1fca0438", "filename": "gcc/testsuite/gcc.dg/graphite/pr23820.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr23820.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr23820.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr23820.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23820.c"}, {"sha": "b50e7a8ca7a17a92c517a355cb0ca4f477a59a24", "filename": "gcc/testsuite/gcc.dg/graphite/pr24309.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr24309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr24309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr24309.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr24309.c"}, {"sha": "4e5e5f74d7ad172a8df611359fad351f4c6987e9", "filename": "gcc/testsuite/gcc.dg/graphite/pr26435.c", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr26435.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr26435.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr26435.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-linear\" } */\n /* { dg-require-effective-target size32plus } */\n \n int foo(int *p, int n)\n@@ -15,6 +15,3 @@ int foo(int *p, int n)\n \n   return k;\n }\n-\n-/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect loop nest\" 0 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr26435.c"}, {"sha": "dff42077946a2bee6cf67f28a9c32f6cc9c30abf", "filename": "gcc/testsuite/gcc.dg/graphite/pr29330.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29330.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29330.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29330.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr29330.c"}, {"sha": "e540073552544039bc19ef0805d919a76b9cbbd6", "filename": "gcc/testsuite/gcc.dg/graphite/pr29581-1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-1.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr29581-1.c"}, {"sha": "c99d78ce2f1d6b84b9b3c845588bf5d4151bd27a", "filename": "gcc/testsuite/gcc.dg/graphite/pr29581-2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-2.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr29581-2.c"}, {"sha": "c9d72ce281ff4e9390e65c61646ddff288597d2d", "filename": "gcc/testsuite/gcc.dg/graphite/pr29581-3.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-3.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr29581-3.c"}, {"sha": "c2d894c8d201f4b23c5412ce9fc854759f931b08", "filename": "gcc/testsuite/gcc.dg/graphite/pr29581-4.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr29581-4.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr29581-4.c"}, {"sha": "802b7c2aa2bac3a41234399b58ccaeaa47081810", "filename": "gcc/testsuite/gcc.dg/graphite/pr30565.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr30565.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr30565.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr30565.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-27.c"}, {"sha": "000d7b5bfc3b16a6125d51cc8070b3da7c578b2c", "filename": "gcc/testsuite/gcc.dg/graphite/pr31183.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr31183.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr31183.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr31183.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr31183.c"}, {"sha": "2470762f7a792fd4eea7f9a94b4c13b7b49386e8", "filename": "gcc/testsuite/gcc.dg/graphite/pr33576.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr33576.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr33576.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr33576.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr33576.c"}, {"sha": "f6bb50615a0e78184a49c9190fd59b91f0f8367a", "filename": "gcc/testsuite/gcc.dg/graphite/pr33766.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr33766.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr33766.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr33766.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr33766.c"}, {"sha": "5ca84bb6206919fe5b115cd2883e14e0e70d9e56", "filename": "gcc/testsuite/gcc.dg/graphite/pr34016.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34016.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34016.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34016.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/pr34016.c"}, {"sha": "ee279b7c8df897bb7632be5323aea9ddd28588f5", "filename": "gcc/testsuite/gcc.dg/graphite/pr34017.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34017.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34017.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34017.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr34017.c"}, {"sha": "81dbf3aacdcbe1210b501d6d2d50c1aa7f2af57d", "filename": "gcc/testsuite/gcc.dg/graphite/pr34123.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34123.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34123.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr34123.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr34123.c"}, {"sha": "51b77c7157d6cd07dab0d3862424772685134b2d", "filename": "gcc/testsuite/gcc.dg/graphite/pr36287.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr36287.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr36287.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr36287.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr36287.c"}, {"sha": "a5094bf97544560278a794744d13eca05ce31fe0", "filename": "gcc/testsuite/gcc.dg/graphite/pr37686.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37686.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37686.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37686.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gcc.dg/tree-ssa/pr37686.c"}, {"sha": "eddff3b5844927172e343e0327a552343e253fcc", "filename": "gcc/testsuite/gcc.dg/graphite/pr42917.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr42917.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr42917.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr42917.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -ftree-loop-linear -fcompare-debug\" } */\n+\n+extern int A[];\n+\n+void\n+foo ()\n+{\n+  int i, j;\n+  for (i = 0; i < 4; i++)\n+    for (j = 255; j >= 0; j--)\n+      A[j] = 0;\n+}"}, {"sha": "d8db32ea2da1c318294aba2ec65d1beeefa44246", "filename": "gcc/testsuite/gcc.dg/pr42917.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42917.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42917.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42917.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,16 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O1 -ftree-loop-linear -fcompare-debug -fdump-tree-ltrans\" } */\n-\n-extern int A[];\n-\n-void\n-foo ()\n-{\n-  int i, j;\n-  for (i = 0; i < 4; i++)\n-    for (j = 255; j >= 0; j--)\n-      A[j] = 0;\n-}\n-\n-/* { dg-final { scan-tree-dump \"Successfully transformed loop\" \"ltrans\" } } */\n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "12e42b7491d2c8a6da4a23085adeac80ae377e5e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/data-dep-1.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdata-dep-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdata-dep-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdata-dep-1.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do compile { target int32plus } } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-\n-int foo (int n, int m)\n-{\n-  int a[10000][10000];\n-  int i, j, k;\n-\n-  for(k = 0; k < 1234; k++)\n-    for(j = 0; j < 5; j++)\n-      for(i = 0; i < 67; i++)\n-\t{\n-\t  a[j+i-(-m+n+3)][i-k+4] = a[k+j][i];\n-\t}\n-\n-  return a[0][0];\n-}\n-\n-\n-/* For the data dependence analysis of the outermost loop, the\n-   evolution of \"k+j\" should be instantiated in the outermost loop \"k\"\n-   and the evolution should be taken in the innermost loop \"i\".  The\n-   pattern below ensures that the evolution is not computed in the\n-   outermost \"k\" loop: the 4 comes from the instantiation of the\n-   number of iterations of loop \"j\".  */\n-\n-/* { dg-final { scan-tree-dump-times \"4, \\\\+, 1\" 0 \"ltrans\" } } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "bff58f6a41dacc66e83d093377047aaee509bd77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-1.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,24 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32} } } */\n-/* { dg-require-effective-target size32plus } */\n-\n-double u[1782225];\n-int foo(int N, int *res)\n-{\n-  int i, j;\n-  double sum = 0.0;\n-  /* This loop should be converted to a perfect nest and\n-     interchanged. */\n-  for (i = 0; i < N; i++)\n-    {\n-      for (j = 0; j < N; j++)\n-\tsum = sum + u[i + 1335 * j];\n-      \n-      u[1336 * i] *= 2;\n-    }\n-  *res = sum + N;\n-}\n-/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect loop nest\" 1 \"ltrans\"} } */ \n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "9548bf217067acb77f92097f5278bb1b3dae1c02", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-2.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-2.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,26 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-require-effective-target size32plus } */\n-\n-double u[1782225];\n-int foo(int N, int *res)\n-{\n-  unsigned int i, j;\n-  double sum = 0;\n-  \n-  /* This loop should be converted to a perfect nest and\n-     interchanged.  */\n-  for (i = 0; i < N; i++)\n-    {\n-      for (j = 0; j < N; j++)\n-\t{\n-\t  sum = sum + u[i + 1335 * j];\n-\t  if (j == N - 1)\n-\t    u[1336 * i] *= 2;\n-\t}\n-    }\n-  *res = sum + N;\n-}\n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} {\n-   xfail *-*-*} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "d7dd211e9bc6f57bd31bb74f4c61955dbcbb917c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-3.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-3.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,22 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32} } } */\n-/* { dg-require-effective-target size32plus } */\n-\n-double u[1782225];\n-int foo(int N, int *res)\n-{\n-  unsigned int i, j;\n-  double sum = 0;\n-      for (i = 0; i < N; i++)\n-\t{\n-\t  for (j = 0; j < N; j++)\n-\t    {\n-\t      sum = sum + u[i + 1335 * j];\n-\t    }\n-\t}\n-      *res = sum + N;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\" } } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "6682538a2edc83065d0215f06f71e9b6dc49494f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-4.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-4.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,21 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32} } } */\n-/* { dg-require-effective-target size32plus } */\n-\n-double u[1782225];\n-int foo(int N, int *res)\n-{\n-  int i, j;\n-  double sum = 0;\n-  for (i = 0; i < N; i++)\t\n-    for (j = 0; j < N; j++)\n-      sum = sum + u[i + 1335 * j];\n-  \n-  for (i = 0; i < N; i++)\n-    u[1336 * i] *= 2;\n-  *res = sum + N;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "3540723dc5692ebebcf4a66b601ce0ab2c191279", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-5.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-5.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,18 +0,0 @@\n-/* { dg-do compile { target { size32plus } } } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32} } } */\n-\n-int foo ()\n-{\n-  int A[100][1111];\n-  int i, j;\n-\n-  for( i = 0; i < 1111; i++)\n-    for( j = 0; j < 100; j++)\n-      A[j][i] = 5 * A[j][i];\n-\n-  return A[10][10];\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "e6a290a6a13218ce323ec8100ce591904042db1f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-6.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-6.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,22 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32} } } */\n-/* { dg-require-effective-target size32plus } */\n-\n-\n-\n-int medium_loop_interchange(int A[100][200])\n-{\n-  int i,j;\n-\n-  /* This loop should be interchanged. */\n-\n-  for(j = 0; j < 200; j++)\n-    for(i = 0; i < 100; i++)\n-      A[i][j] = A[i][j] + A[i][j];\n-\n-  return A[1][1];\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "67569d8a316f255e272e47efc16093327381e27a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-8.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,15 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n-/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32} } } */\n-double foo(double *a)\n-{\n-       int i,j;\n-       double r = 0.0;\n-      for (i=0; i<100; ++i)\n-               for (j=0; j<1000; ++j)\n-                      r += a[j*100+i];\n-       return r;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n-/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "3d42811bc56426be0a3ab7749a0ee4c12d8a15f5", "filename": "gcc/testsuite/gfortran.dg/graphite/interchange-4.f", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-4.f?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -0,0 +1,29 @@\n+      subroutine s231 (ntimes,ld,n,ctime,dtime,a,b,c,d,e,aa,bb,cc)\n+c\n+c     loop interchange\n+c     loop with multiple dimension recursion\n+c\n+      integer ntimes, ld, n, i, nl, j\n+      double precision a(n), b(n), c(n), d(n), e(n), aa(ld,n),\n+     +                 bb(ld,n), cc(ld,n)\n+      double precision chksum, cs2d\n+      real t1, t2, second, ctime, dtime\n+\n+      call init(ld,n,a,b,c,d,e,aa,bb,cc,'s231 ')\n+      t1 = second()\n+      do 1 nl = 1,ntimes/n\n+      do 10 i=1,n\n+         do 20 j=2,n\n+            aa(i,j) = aa(i,j-1) + bb(i,j)\n+   20    continue\n+   10 continue\n+      call dummy(ld,n,a,b,c,d,e,aa,bb,cc,1.d0)\n+   1  continue\n+      t2 = second() - t1 - ctime - ( dtime * float(ntimes/n) )\n+      chksum = cs2d(n,aa)\n+      call check (chksum,(ntimes/n)*n*(n-1),n,t2,'s231 ')\n+      return\n+      end\n+\n+! { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } }\n+! { dg-final { cleanup-tree-dump \"graphite\" } }"}, {"sha": "658f10a74d7936d46763a1ab1dfa0894c21a0a7e", "filename": "gcc/testsuite/gfortran.dg/graphite/interchange-5.f", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-5.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-5.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-5.f?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -0,0 +1,30 @@\n+      subroutine s235 (ntimes,ld,n,ctime,dtime,a,b,c,d,e,aa,bb,cc)\n+c\n+c     loop interchanging\n+c     imperfectly nested loops\n+c\n+      integer ntimes, ld, n, i, nl, j\n+      double precision a(n), b(n), c(n), d(n), e(n), aa(ld,n),\n+     +                 bb(ld,n), cc(ld,n)\n+      double precision chksum, cs1d, cs2d\n+      real t1, t2, second, ctime, dtime\n+\n+      call init(ld,n,a,b,c,d,e,aa,bb,cc,'s235 ')\n+      t1 = second()\n+      do 1 nl = 1,ntimes/n\n+      do 10 i = 1,n\n+         a(i) =  a(i) + b(i) * c(i)\n+         do 20 j = 2,n\n+            aa(i,j) = aa(i,j-1) +  bb(i,j) * a(i)\n+  20     continue\n+  10  continue\n+      call dummy(ld,n,a,b,c,d,e,aa,bb,cc,1.d0)\n+  1   continue\n+      t2 = second() - t1 - ctime - ( dtime * float(ntimes/n) )\n+      chksum = cs2d(n,aa) + cs1d(n,a)\n+      call check (chksum,(ntimes/n)*n*(n-1),n,t2,'s235 ')\n+      return\n+      end\n+\n+! { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } }\n+! { dg-final { cleanup-tree-dump \"graphite\" } }"}, {"sha": "8968d88c4705705543e4904f2d0fbe1f2a617bd6", "filename": "gcc/testsuite/gfortran.dg/graphite/pr29290.f90", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29290.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29290.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29290.f90?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gfortran.dg/loop_nest_1.f90"}, {"sha": "3e4a39efb63243963287536fb487180289012105", "filename": "gcc/testsuite/gfortran.dg/graphite/pr29581.f90", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29581.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29581.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr29581.f90?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gfortran.dg/pr29581.f90"}, {"sha": "bcdef08507340dd4adc1d2df1ab258ee5717a41b", "filename": "gcc/testsuite/gfortran.dg/graphite/pr36286.f90", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr36286.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr36286.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr36286.f90?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gfortran.dg/pr36286.f90"}, {"sha": "6aa95beb6968ce91c616b492ba19818a35a26fe5", "filename": "gcc/testsuite/gfortran.dg/graphite/pr36922.f", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr36922.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr36922.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr36922.f?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gfortran.dg/pr36922.f"}, {"sha": "3d6104a8ebf068900a45b9fc9feb6b862e3130df", "filename": "gcc/testsuite/gfortran.dg/graphite/pr39516.f", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr39516.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr39516.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr39516.f?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "previous_filename": "gcc/testsuite/gfortran.dg/pr39516.f"}, {"sha": "583edf216ba0026dae69db3829bf9c384ee066fd", "filename": "gcc/testsuite/gfortran.dg/ltrans-7.f90", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgfortran.dg%2Fltrans-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftestsuite%2Fgfortran.dg%2Fltrans-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fltrans-7.f90?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,31 +0,0 @@\n-! { dg-do compile }\n-! { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" }\n-! { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all -march=i486\" { target { i?86-*-* && ilp32 } } }\n-\n-Program FOO\n-  IMPLICIT INTEGER\t(I-N)\n-  IMPLICIT REAL*8\t(A-H, O-Z)\n-  PARAMETER (N1=1335, N2=1335)\n-  COMMON U(N1,N2), V(N1,N2), P(N1,N2)\n-\n-  PC = 0.0D0\n-  UC = 0.0D0\n-  VC = 0.0D0\n-\n-  do I = 1, M\n-     do J = 1, M\n-        PC = PC + abs(P(I,J))\n-        UC = UC + abs(U(I,J))\n-        VC = VC + abs(V(I,J))\n-     end do\n-     U(I,I) = U(I,I) * ( mod (I, 100) /100.)\n-  end do\n-\n-  write(6,366) PC, UC, VC\n-366  format(/, ' PC = ',E12.4,/,' UC = ',E12.4,/,' VC = ',E12.4,/)\n-\n-end Program FOO\n-\n-! Please do not XFAIL.\n-! { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\" } }\n-! { dg-final { cleanup-tree-dump \"ltrans\" } }"}, {"sha": "9e5df7d2c752e6861f4804e18b172852e1188bdf", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -340,6 +340,18 @@ print_dir_vectors (FILE *outf, VEC (lambda_vector, heap) *dir_vects,\n     print_direction_vector (outf, v, length);\n }\n \n+/* Print out a vector VEC of length N to OUTFILE.  */\n+\n+static inline void\n+print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    fprintf (outfile, \"%3d \", vector[i]);\n+  fprintf (outfile, \"\\n\");\n+}\n+\n /* Print a vector of distance vectors.  */\n \n void\n@@ -2064,6 +2076,168 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n   affine_fn_free (overlaps_b_xyz);\n }\n \n+/* Copy the elements of vector VEC1 with length SIZE to VEC2.  */\n+\n+static void\n+lambda_vector_copy (lambda_vector vec1, lambda_vector vec2,\n+\t\t    int size)\n+{\n+  memcpy (vec2, vec1, size * sizeof (*vec1));\n+}\n+\n+/* Copy the elements of M x N matrix MAT1 to MAT2.  */\n+\n+static void\n+lambda_matrix_copy (lambda_matrix mat1, lambda_matrix mat2,\n+\t\t    int m, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    lambda_vector_copy (mat1[i], mat2[i], n);\n+}\n+\n+/* Store the N x N identity matrix in MAT.  */\n+\n+static void\n+lambda_matrix_id (lambda_matrix mat, int size)\n+{\n+  int i, j;\n+\n+  for (i = 0; i < size; i++)\n+    for (j = 0; j < size; j++)\n+      mat[i][j] = (i == j) ? 1 : 0;\n+}\n+\n+/* Return the first nonzero element of vector VEC1 between START and N.\n+   We must have START <= N.   Returns N if VEC1 is the zero vector.  */\n+\n+static int\n+lambda_vector_first_nz (lambda_vector vec1, int n, int start)\n+{\n+  int j = start;\n+  while (j < n && vec1[j] == 0)\n+    j++;\n+  return j;\n+}\n+\n+/* Add a multiple of row R1 of matrix MAT with N columns to row R2:\n+   R2 = R2 + CONST1 * R1.  */\n+\n+static void\n+lambda_matrix_row_add (lambda_matrix mat, int n, int r1, int r2, int const1)\n+{\n+  int i;\n+\n+  if (const1 == 0)\n+    return;\n+\n+  for (i = 0; i < n; i++)\n+    mat[r2][i] += const1 * mat[r1][i];\n+}\n+\n+/* Swap rows R1 and R2 in matrix MAT.  */\n+\n+static void\n+lambda_matrix_row_exchange (lambda_matrix mat, int r1, int r2)\n+{\n+  lambda_vector row;\n+\n+  row = mat[r1];\n+  mat[r1] = mat[r2];\n+  mat[r2] = row;\n+}\n+\n+/* Multiply vector VEC1 of length SIZE by a constant CONST1,\n+   and store the result in VEC2.  */\n+\n+static void\n+lambda_vector_mult_const (lambda_vector vec1, lambda_vector vec2,\n+\t\t\t  int size, int const1)\n+{\n+  int i;\n+\n+  if (const1 == 0)\n+    lambda_vector_clear (vec2, size);\n+  else\n+    for (i = 0; i < size; i++)\n+      vec2[i] = const1 * vec1[i];\n+}\n+\n+/* Negate vector VEC1 with length SIZE and store it in VEC2.  */\n+\n+static void\n+lambda_vector_negate (lambda_vector vec1, lambda_vector vec2,\n+\t\t      int size)\n+{\n+  lambda_vector_mult_const (vec1, vec2, size, -1);\n+}\n+\n+/* Negate row R1 of matrix MAT which has N columns.  */\n+\n+static void\n+lambda_matrix_row_negate (lambda_matrix mat, int n, int r1)\n+{\n+  lambda_vector_negate (mat[r1], mat[r1], n);\n+}\n+\n+/* Return true if two vectors are equal.  */\n+\n+static bool\n+lambda_vector_equal (lambda_vector vec1, lambda_vector vec2, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    if (vec1[i] != vec2[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Given an M x N integer matrix A, this function determines an M x\n+   M unimodular matrix U, and an M x N echelon matrix S such that\n+   \"U.A = S\".  This decomposition is also known as \"right Hermite\".\n+\n+   Ref: Algorithm 2.1 page 33 in \"Loop Transformations for\n+   Restructuring Compilers\" Utpal Banerjee.  */\n+\n+static void\n+lambda_matrix_right_hermite (lambda_matrix A, int m, int n,\n+\t\t\t     lambda_matrix S, lambda_matrix U)\n+{\n+  int i, j, i0 = 0;\n+\n+  lambda_matrix_copy (A, S, m, n);\n+  lambda_matrix_id (U, m);\n+\n+  for (j = 0; j < n; j++)\n+    {\n+      if (lambda_vector_first_nz (S[j], m, i0) < m)\n+\t{\n+\t  ++i0;\n+\t  for (i = m - 1; i >= i0; i--)\n+\t    {\n+\t      while (S[i][j] != 0)\n+\t\t{\n+\t\t  int sigma, factor, a, b;\n+\n+\t\t  a = S[i-1][j];\n+\t\t  b = S[i][j];\n+\t\t  sigma = (a * b < 0) ? -1: 1;\n+\t\t  a = abs (a);\n+\t\t  b = abs (b);\n+\t\t  factor = sigma * (a / b);\n+\n+\t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n+\t\t  lambda_matrix_row_exchange (S, i, i-1);\n+\n+\t\t  lambda_matrix_row_add (U, m, i, i-1, -factor);\n+\t\t  lambda_matrix_row_exchange (U, i, i-1);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Determines the overlapping elements due to accesses CHREC_A and\n    CHREC_B, that are affine functions.  This function cannot handle\n    symbolic evolution functions, ie. when initial conditions are"}, {"sha": "85c2386e7d69b99109772e7c19a683b26bb0cf6b", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 111, "deletions": 11, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -23,7 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_DATA_REF_H\n \n #include \"graphds.h\"\n-#include \"lambda.h\"\n #include \"omega.h\"\n #include \"tree-chrec.h\"\n \n@@ -96,6 +95,19 @@ struct dr_alias\n   bitmap vops;\n };\n \n+/* An integer vector.  A vector formally consists of an element of a vector\n+   space. A vector space is a set that is closed under vector addition\n+   and scalar multiplication.  In this vector space, an element is a list of\n+   integers.  */\n+typedef int *lambda_vector;\n+DEF_VEC_P(lambda_vector);\n+DEF_VEC_ALLOC_P(lambda_vector,heap);\n+DEF_VEC_ALLOC_P(lambda_vector,gc);\n+\n+/* An integer matrix.  A matrix consists of m vectors of length n (IE\n+   all vectors are the same length).  */\n+typedef lambda_vector *lambda_matrix;\n+\n /* Each vector of the access matrix represents a linear access\n    function for a subscript.  First elements correspond to the\n    leftmost indices, ie. for a[i][j] the first vector corresponds to\n@@ -494,6 +506,22 @@ ddrs_have_anti_deps (VEC (ddr_p, heap) *dependence_relations)\n   return false;\n }\n \n+/* Returns the dependence level for a vector DIST of size LENGTH.\n+   LEVEL = 0 means a lexicographic dependence, i.e. a dependence due\n+   to the sequence of statements, not carried by any loop.  */\n+\n+static inline unsigned\n+dependence_level (lambda_vector dist_vect, int length)\n+{\n+  int i;\n+\n+  for (i = 0; i < length; i++)\n+    if (dist_vect[i] != 0)\n+      return i + 1;\n+\n+  return 0;\n+}\n+\n /* Return the dependence level for the DDR relation.  */\n \n static inline unsigned\n@@ -629,16 +657,6 @@ rdg_has_similar_memory_accesses (struct graph *rdg, int v1, int v2)\n \t\t\t\t       RDG_STMT (rdg, v2));\n }\n \n-/* In lambda-code.c  */\n-bool lambda_transform_legal_p (lambda_trans_matrix, int,\n-\t\t\t       VEC (ddr_p, heap) *);\n-void lambda_collect_parameters (VEC (data_reference_p, heap) *,\n-\t\t\t\tVEC (tree, heap) **);\n-bool lambda_compute_access_matrices (VEC (data_reference_p, heap) *,\n-\t\t\t\t     VEC (tree, heap) *,\n-\t\t\t\t     VEC (loop_p, heap) *,\n-\t\t\t\t     struct obstack *);\n-\n /* In tree-data-ref.c  */\n void split_constant_offset (tree , tree *, tree *);\n \n@@ -656,4 +674,86 @@ DEF_VEC_ALLOC_P (rdgc, heap);\n DEF_VEC_P (bitmap);\n DEF_VEC_ALLOC_P (bitmap, heap);\n \n+/* Compute the greatest common divisor of a VECTOR of SIZE numbers.  */\n+\n+static inline int\n+lambda_vector_gcd (lambda_vector vector, int size)\n+{\n+  int i;\n+  int gcd1 = 0;\n+\n+  if (size > 0)\n+    {\n+      gcd1 = vector[0];\n+      for (i = 1; i < size; i++)\n+\tgcd1 = gcd (gcd1, vector[i]);\n+    }\n+  return gcd1;\n+}\n+\n+/* Allocate a new vector of given SIZE.  */\n+\n+static inline lambda_vector\n+lambda_vector_new (int size)\n+{\n+  return (lambda_vector) ggc_alloc_cleared_atomic (sizeof (int) * size);\n+}\n+\n+/* Clear out vector VEC1 of length SIZE.  */\n+\n+static inline void\n+lambda_vector_clear (lambda_vector vec1, int size)\n+{\n+  memset (vec1, 0, size * sizeof (*vec1));\n+}\n+\n+/* Returns true when the vector V is lexicographically positive, in\n+   other words, when the first nonzero element is positive.  */\n+\n+static inline bool\n+lambda_vector_lexico_pos (lambda_vector v,\n+\t\t\t  unsigned n)\n+{\n+  unsigned i;\n+  for (i = 0; i < n; i++)\n+    {\n+      if (v[i] == 0)\n+\tcontinue;\n+      if (v[i] < 0)\n+\treturn false;\n+      if (v[i] > 0)\n+\treturn true;\n+    }\n+  return true;\n+}\n+\n+/* Return true if vector VEC1 of length SIZE is the zero vector.  */\n+\n+static inline bool\n+lambda_vector_zerop (lambda_vector vec1, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    if (vec1[i] != 0)\n+      return false;\n+  return true;\n+}\n+\n+/* Allocate a matrix of M rows x  N cols.  */\n+\n+static inline lambda_matrix\n+lambda_matrix_new (int m, int n, struct obstack *lambda_obstack)\n+{\n+  lambda_matrix mat;\n+  int i;\n+\n+  mat = (lambda_matrix) obstack_alloc (lambda_obstack,\n+\t\t\t\t       sizeof (lambda_vector *) * m);\n+\n+  for (i = 0; i < m; i++)\n+    mat[i] = lambda_vector_new (n);\n+\n+  return mat;\n+}\n+\n #endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "172085908979817339a2dc2e3fa6190ad751e3bc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -856,6 +856,4 @@ void warn_function_noreturn (tree);\n \n void swap_tree_operands (gimple, tree *, tree *);\n \n-int least_common_multiple (int, int);\n-\n #endif /* _TREE_FLOW_H  */"}, {"sha": "5b19c17622cfb5297a4a72028f807339c69923d2", "filename": "gcc/tree-loop-linear.c", "status": "removed", "additions": 0, "deletions": 423, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=6bdfdb96eeec5da99a6aa4ca592af1d6b9cef237", "patch": "@@ -1,423 +0,0 @@\n-/* Linear Loop transforms\n-   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Daniel Berlin <dberlin@dberlin.org>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree-flow.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-chrec.h\"\n-#include \"tree-data-ref.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"tree-pass.h\"\n-#include \"lambda.h\"\n-\n-/* Linear loop transforms include any composition of interchange,\n-   scaling, skewing, and reversal.  They are used to change the\n-   iteration order of loop nests in order to optimize data locality of\n-   traversals, or remove dependences that prevent\n-   parallelization/vectorization/etc.\n-\n-   TODO: Determine reuse vectors/matrix and use it to determine optimal\n-   transform matrix for locality purposes.\n-   TODO: Completion of partial transforms.  */\n-\n-/* Gather statistics for loop interchange.  LOOP is the loop being\n-   considered. The first loop in the considered loop nest is\n-   FIRST_LOOP, and consequently, the index of the considered loop is\n-   obtained by LOOP->DEPTH - FIRST_LOOP->DEPTH\n-\n-   Initializes:\n-   - DEPENDENCE_STEPS the sum of all the data dependence distances\n-   carried by loop LOOP,\n-\n-   - NB_DEPS_NOT_CARRIED_BY_LOOP the number of dependence relations\n-   for which the loop LOOP is not carrying any dependence,\n-\n-   - ACCESS_STRIDES the sum of all the strides in LOOP.\n-\n-   Example: for the following loop,\n-\n-   | loop_1 runs 1335 times\n-   |   loop_2 runs 1335 times\n-   |     A[{{0, +, 1}_1, +, 1335}_2]\n-   |     B[{{0, +, 1}_1, +, 1335}_2]\n-   |   endloop_2\n-   |   A[{0, +, 1336}_1]\n-   | endloop_1\n-\n-   gather_interchange_stats (in loop_1) will return\n-   DEPENDENCE_STEPS = 3002\n-   NB_DEPS_NOT_CARRIED_BY_LOOP = 5\n-   ACCESS_STRIDES = 10694\n-\n-   gather_interchange_stats (in loop_2) will return\n-   DEPENDENCE_STEPS = 3000\n-   NB_DEPS_NOT_CARRIED_BY_LOOP = 7\n-   ACCESS_STRIDES = 8010\n-*/\n-\n-static void\n-gather_interchange_stats (VEC (ddr_p, heap) *dependence_relations ATTRIBUTE_UNUSED,\n-\t\t\t  VEC (data_reference_p, heap) *datarefs ATTRIBUTE_UNUSED,\n-\t\t\t  struct loop *loop ATTRIBUTE_UNUSED,\n-\t\t\t  struct loop *first_loop ATTRIBUTE_UNUSED,\n-\t\t\t  unsigned int *dependence_steps ATTRIBUTE_UNUSED,\n-\t\t\t  unsigned int *nb_deps_not_carried_by_loop ATTRIBUTE_UNUSED,\n-\t\t\t  double_int *access_strides ATTRIBUTE_UNUSED)\n-{\n-  unsigned int i, j;\n-  struct data_dependence_relation *ddr;\n-  struct data_reference *dr;\n-\n-  *dependence_steps = 0;\n-  *nb_deps_not_carried_by_loop = 0;\n-  *access_strides = double_int_zero;\n-\n-  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n-    {\n-      /* If we don't know anything about this dependence, or the distance\n-\t vector is NULL, or there is no dependence, then there is no reuse of\n-\t data.  */\n-      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n-\t  || DDR_ARE_DEPENDENT (ddr) == chrec_known\n-\t  || DDR_NUM_DIST_VECTS (ddr) == 0)\n-\tcontinue;\n-\n-      for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n-\t{\n-\t  int dist = DDR_DIST_VECT (ddr, j)[loop_depth (loop) - loop_depth (first_loop)];\n-\n-\t  if (dist == 0)\n-\t    (*nb_deps_not_carried_by_loop) += 1;\n-\n-\t  else if (dist < 0)\n-\t    (*dependence_steps) += -dist;\n-\n-\t  else\n-\t    (*dependence_steps) += dist;\n-\t}\n-    }\n-\n-  /* Compute the access strides.  */\n-  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n-    {\n-      unsigned int it;\n-      tree ref = DR_REF (dr);\n-      gimple stmt = DR_STMT (dr);\n-      struct loop *stmt_loop = loop_containing_stmt (stmt);\n-      struct loop *inner_loop = first_loop->inner;\n-\n-      if (inner_loop != stmt_loop\n-\t  && !flow_loop_nested_p (inner_loop, stmt_loop))\n-\tcontinue;\n-\n-      for (it = 0; it < DR_NUM_DIMENSIONS (dr);\n-\t   it++, ref = TREE_OPERAND (ref, 0))\n-\t{\n-\t  int num = am_vector_index_for_loop (DR_ACCESS_MATRIX (dr), loop->num);\n-\t  int istride = AM_GET_ACCESS_MATRIX_ELEMENT (DR_ACCESS_MATRIX (dr), it, num);\n-\t  tree array_size = TYPE_SIZE (TREE_TYPE (ref));\n-\t  double_int dstride;\n-\n-\t  if (array_size == NULL_TREE\n-\t      || TREE_CODE (array_size) != INTEGER_CST)\n-\t    continue;\n-\n-\t  dstride = double_int_mul (tree_to_double_int (array_size),\n-\t\t\t\t    shwi_to_double_int (istride));\n-\t  (*access_strides) = double_int_add (*access_strides, dstride);\n-\t}\n-    }\n-}\n-\n-/* Attempt to apply interchange transformations to TRANS to maximize the\n-   spatial and temporal locality of the loop.\n-   Returns the new transform matrix.  The smaller the reuse vector\n-   distances in the inner loops, the fewer the cache misses.\n-   FIRST_LOOP is the loop->num of the first loop in the analyzed loop\n-   nest.  */\n-\n-\n-static lambda_trans_matrix\n-try_interchange_loops (lambda_trans_matrix trans,\n-\t\t       unsigned int depth,\n-\t\t       VEC (ddr_p, heap) *dependence_relations,\n-\t\t       VEC (data_reference_p, heap) *datarefs,\n-\t\t       struct loop *first_loop)\n-{\n-  bool res;\n-  struct loop *loop_i;\n-  struct loop *loop_j;\n-  unsigned int dependence_steps_i, dependence_steps_j;\n-  double_int access_strides_i, access_strides_j;\n-  double_int small, large, nb_iter;\n-  double_int l1_cache_size, l2_cache_size;\n-  int cmp;\n-  unsigned int nb_deps_not_carried_by_i, nb_deps_not_carried_by_j;\n-  struct data_dependence_relation *ddr;\n-\n-  if (VEC_length (ddr_p, dependence_relations) == 0)\n-    return trans;\n-\n-  /* When there is an unknown relation in the dependence_relations, we\n-     know that it is no worth looking at this loop nest: give up.  */\n-  ddr = VEC_index (ddr_p, dependence_relations, 0);\n-  if (ddr == NULL || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-    return trans;\n-\n-  l1_cache_size = uhwi_to_double_int (L1_CACHE_SIZE * 1024);\n-  l2_cache_size = uhwi_to_double_int (L2_CACHE_SIZE * 1024);\n-\n-  /* LOOP_I is always the outer loop.  */\n-  for (loop_j = first_loop->inner;\n-       loop_j;\n-       loop_j = loop_j->inner)\n-    for (loop_i = first_loop;\n-\t loop_depth (loop_i) < loop_depth (loop_j);\n-\t loop_i = loop_i->inner)\n-      {\n-\tgather_interchange_stats (dependence_relations, datarefs,\n-\t\t\t\t  loop_i, first_loop,\n-\t\t\t\t  &dependence_steps_i,\n-\t\t\t\t  &nb_deps_not_carried_by_i,\n-\t\t\t\t  &access_strides_i);\n-\tgather_interchange_stats (dependence_relations, datarefs,\n-\t\t\t\t  loop_j, first_loop,\n-\t\t\t\t  &dependence_steps_j,\n-\t\t\t\t  &nb_deps_not_carried_by_j,\n-\t\t\t\t  &access_strides_j);\n-\n-\t/* Heuristics for loop interchange profitability:\n-\n-\t   0. Don't transform if the smallest stride is larger than\n-\t      the L2 cache, or if the largest stride multiplied by the\n-\t      number of iterations is smaller than the L1 cache.\n-\n-\t   1. (spatial locality) Inner loops should have smallest\n-              dependence steps.\n-\n-\t   2. (spatial locality) Inner loops should contain more\n-\t   dependence relations not carried by the loop.\n-\n-\t   3. (temporal locality) Inner loops should have smallest\n-\t      array access strides.\n-\t*/\n-\n-\tcmp = double_int_ucmp (access_strides_i, access_strides_j);\n-\tsmall = cmp < 0 ? access_strides_i : access_strides_j;\n-\tlarge = cmp < 0 ? access_strides_j : access_strides_i;\n-\n-\tif (double_int_ucmp (small, l2_cache_size) > 0)\n-\t  continue;\n-\n-\tres = cmp < 0 ?\n-\t  estimated_loop_iterations (loop_j, false, &nb_iter):\n-\t  estimated_loop_iterations (loop_i, false, &nb_iter);\n-\n-\tif (res\n-\t    && double_int_ucmp (double_int_mul (large, nb_iter),\n-\t\t\t\tl1_cache_size) < 0)\n-\t  continue;\n-\n-\tif (dependence_steps_i < dependence_steps_j\n-\t    || nb_deps_not_carried_by_i > nb_deps_not_carried_by_j\n-\t    || cmp < 0)\n-\t  {\n-\t    lambda_matrix_row_exchange (LTM_MATRIX (trans),\n-\t\t\t\t\tloop_depth (loop_i) - loop_depth (first_loop),\n-\t\t\t\t\tloop_depth (loop_j) - loop_depth (first_loop));\n-\t    /* Validate the resulting matrix.  When the transformation\n-\t       is not valid, reverse to the previous transformation.  */\n-\t    if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n-\t      lambda_matrix_row_exchange (LTM_MATRIX (trans),\n-\t\t\t\t\t  loop_depth (loop_i) - loop_depth (first_loop),\n-\t\t\t\t\t  loop_depth (loop_j) - loop_depth (first_loop));\n-\t  }\n-      }\n-\n-  return trans;\n-}\n-\n-/* Return the number of nested loops in LOOP_NEST, or 0 if the loops\n-   are not perfectly nested.  */\n-\n-unsigned int\n-perfect_loop_nest_depth (struct loop *loop_nest)\n-{\n-  struct loop *temp;\n-  unsigned int depth = 1;\n-\n-  /* If it's not a loop nest, we don't want it.  We also don't handle\n-     sibling loops properly, which are loops of the following form:\n-\n-     | for (i = 0; i < 50; i++)\n-     |   {\n-     |     for (j = 0; j < 50; j++)\n-     |       {\n-     |        ...\n-     |       }\n-     |     for (j = 0; j < 50; j++)\n-     |       {\n-     |        ...\n-     |       }\n-     |   }\n-  */\n-\n-  if (!loop_nest->inner || !single_exit (loop_nest))\n-    return 0;\n-\n-  for (temp = loop_nest->inner; temp; temp = temp->inner)\n-    {\n-      /* If we have a sibling loop or multiple exit edges, jump ship.  */\n-      if (temp->next || !single_exit (temp))\n-\treturn 0;\n-\n-      depth++;\n-    }\n-\n-  return depth;\n-}\n-\n-/* Perform a set of linear transforms on loops.  */\n-\n-void\n-linear_transform_loops (void)\n-{\n-  bool modified = false;\n-  loop_iterator li;\n-  VEC(tree,heap) *oldivs = NULL;\n-  VEC(tree,heap) *invariants = NULL;\n-  VEC(tree,heap) *lambda_parameters = NULL;\n-  VEC(gimple,heap) *remove_ivs = VEC_alloc (gimple, heap, 3);\n-  struct loop *loop_nest;\n-  gimple oldiv_stmt;\n-  unsigned i;\n-\n-  FOR_EACH_LOOP (li, loop_nest, 0)\n-    {\n-      unsigned int depth = 0;\n-      VEC (ddr_p, heap) *dependence_relations;\n-      VEC (data_reference_p, heap) *datarefs;\n-\n-      lambda_loopnest before, after;\n-      lambda_trans_matrix trans;\n-      struct obstack lambda_obstack;\n-      struct loop *loop;\n-      VEC (loop_p, heap) *nest;\n-      VEC (loop_p, heap) *ln;\n-\n-      depth = perfect_loop_nest_depth (loop_nest);\n-      if (depth == 0)\n-\tcontinue;\n-\n-      nest = VEC_alloc (loop_p, heap, 3);\n-      for (loop = loop_nest; loop; loop = loop->inner)\n-\tVEC_safe_push (loop_p, heap, nest, loop);\n-\n-      gcc_obstack_init (&lambda_obstack);\n-      VEC_truncate (tree, oldivs, 0);\n-      VEC_truncate (tree, invariants, 0);\n-      VEC_truncate (tree, lambda_parameters, 0);\n-\n-      datarefs = VEC_alloc (data_reference_p, heap, 10);\n-      dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);\n-      ln = VEC_alloc (loop_p, heap, 3);\n-      if (!compute_data_dependences_for_loop (loop_nest, true, &ln, &datarefs,\n-\t\t\t\t\t      &dependence_relations))\n-\tgoto free_and_continue;\n-\n-      lambda_collect_parameters (datarefs, &lambda_parameters);\n-      if (!lambda_compute_access_matrices (datarefs, lambda_parameters,\n-\t\t\t\t\t   nest, &lambda_obstack))\n-\tgoto free_and_continue;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tdump_ddrs (dump_file, dependence_relations);\n-\n-      /* Build the transformation matrix.  */\n-      trans = lambda_trans_matrix_new (depth, depth, &lambda_obstack);\n-      lambda_matrix_id (LTM_MATRIX (trans), depth);\n-      trans = try_interchange_loops (trans, depth, dependence_relations,\n-\t\t\t\t     datarefs, loop_nest);\n-\n-      if (lambda_trans_matrix_id_p (trans))\n-\t{\n-\t  if (dump_file)\n-\t   fprintf (dump_file, \"Won't transform loop. Optimal transform is the identity transform\\n\");\n-\t  goto free_and_continue;\n-\t}\n-\n-      /* Check whether the transformation is legal.  */\n-      if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Can't transform loop, transform is illegal:\\n\");\n-\t  goto free_and_continue;\n-\t}\n-\n-      before = gcc_loopnest_to_lambda_loopnest (loop_nest, &oldivs,\n-                                                &invariants, &lambda_obstack);\n-\n-      if (!before)\n-\tgoto free_and_continue;\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Before:\\n\");\n-\t  print_lambda_loopnest (dump_file, before, 'i');\n-\t}\n-\n-      after = lambda_loopnest_transform (before, trans, &lambda_obstack);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"After:\\n\");\n-\t  print_lambda_loopnest (dump_file, after, 'u');\n-\t}\n-\n-      lambda_loopnest_to_gcc_loopnest (loop_nest, oldivs, invariants,\n-\t\t\t\t       &remove_ivs,\n-                                       after, trans, &lambda_obstack);\n-      modified = true;\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n-\n-    free_and_continue:\n-      obstack_free (&lambda_obstack, NULL);\n-      free_dependence_relations (dependence_relations);\n-      free_data_refs (datarefs);\n-      VEC_free (loop_p, heap, nest);\n-      VEC_free (loop_p, heap, ln);\n-    }\n-\n-  FOR_EACH_VEC_ELT (gimple, remove_ivs, i, oldiv_stmt)\n-    remove_iv (oldiv_stmt);\n-\n-  VEC_free (tree, heap, oldivs);\n-  VEC_free (tree, heap, invariants);\n-  VEC_free (gimple, heap, remove_ivs);\n-  scev_reset ();\n-\n-  if (modified)\n-    rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_full_phi);\n-}"}, {"sha": "9a11f80d4b01198c60075b8d071059af9b35eb09", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -240,6 +240,125 @@ name_to_copy_elt_hash (const void *aa)\n   return (hashval_t) a->version;\n }\n \n+/* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE\n+   matrix.  Rather than use floats, we simply keep a single DENOMINATOR that\n+   represents the denominator for every element in the matrix.  */\n+typedef struct lambda_trans_matrix_s\n+{\n+  lambda_matrix matrix;\n+  int rowsize;\n+  int colsize;\n+  int denominator;\n+} *lambda_trans_matrix;\n+#define LTM_MATRIX(T) ((T)->matrix)\n+#define LTM_ROWSIZE(T) ((T)->rowsize)\n+#define LTM_COLSIZE(T) ((T)->colsize)\n+#define LTM_DENOMINATOR(T) ((T)->denominator)\n+\n+/* Allocate a new transformation matrix.  */\n+\n+static lambda_trans_matrix\n+lambda_trans_matrix_new (int colsize, int rowsize,\n+\t\t\t struct obstack * lambda_obstack)\n+{\n+  lambda_trans_matrix ret;\n+\n+  ret = (lambda_trans_matrix)\n+    obstack_alloc (lambda_obstack, sizeof (struct lambda_trans_matrix_s));\n+  LTM_MATRIX (ret) = lambda_matrix_new (rowsize, colsize, lambda_obstack);\n+  LTM_ROWSIZE (ret) = rowsize;\n+  LTM_COLSIZE (ret) = colsize;\n+  LTM_DENOMINATOR (ret) = 1;\n+  return ret;\n+}\n+\n+/* Multiply a vector VEC by a matrix MAT.\n+   MAT is an M*N matrix, and VEC is a vector with length N.  The result\n+   is stored in DEST which must be a vector of length M.  */\n+\n+static void\n+lambda_matrix_vector_mult (lambda_matrix matrix, int m, int n,\n+\t\t\t   lambda_vector vec, lambda_vector dest)\n+{\n+  int i, j;\n+\n+  lambda_vector_clear (dest, m);\n+  for (i = 0; i < m; i++)\n+    for (j = 0; j < n; j++)\n+      dest[i] += matrix[i][j] * vec[j];\n+}\n+\n+/* Return true if TRANS is a legal transformation matrix that respects\n+   the dependence vectors in DISTS and DIRS.  The conservative answer\n+   is false.\n+\n+   \"Wolfe proves that a unimodular transformation represented by the\n+   matrix T is legal when applied to a loop nest with a set of\n+   lexicographically non-negative distance vectors RDG if and only if\n+   for each vector d in RDG, (T.d >= 0) is lexicographically positive.\n+   i.e.: if and only if it transforms the lexicographically positive\n+   distance vectors to lexicographically positive vectors.  Note that\n+   a unimodular matrix must transform the zero vector (and only it) to\n+   the zero vector.\" S.Muchnick.  */\n+\n+static bool\n+lambda_transform_legal_p (lambda_trans_matrix trans,\n+\t\t\t  int nb_loops,\n+\t\t\t  VEC (ddr_p, heap) *dependence_relations)\n+{\n+  unsigned int i, j;\n+  lambda_vector distres;\n+  struct data_dependence_relation *ddr;\n+\n+  gcc_assert (LTM_COLSIZE (trans) == nb_loops\n+\t      && LTM_ROWSIZE (trans) == nb_loops);\n+\n+  /* When there are no dependences, the transformation is correct.  */\n+  if (VEC_length (ddr_p, dependence_relations) == 0)\n+    return true;\n+\n+  ddr = VEC_index (ddr_p, dependence_relations, 0);\n+  if (ddr == NULL)\n+    return true;\n+\n+  /* When there is an unknown relation in the dependence_relations, we\n+     know that it is no worth looking at this loop nest: give up.  */\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+    return false;\n+\n+  distres = lambda_vector_new (nb_loops);\n+\n+  /* For each distance vector in the dependence graph.  */\n+  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n+    {\n+      /* Don't care about relations for which we know that there is no\n+\t dependence, nor about read-read (aka. output-dependences):\n+\t these data accesses can happen in any order.  */\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known\n+\t  || (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr))))\n+\tcontinue;\n+\n+      /* Conservatively answer: \"this transformation is not valid\".  */\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\treturn false;\n+\n+      /* If the dependence could not be captured by a distance vector,\n+\t conservatively answer that the transform is not valid.  */\n+      if (DDR_NUM_DIST_VECTS (ddr) == 0)\n+\treturn false;\n+\n+      /* Compute trans.dist_vect */\n+      for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)\n+\t{\n+\t  lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops,\n+\t\t\t\t     DDR_DIST_VECT (ddr, j), distres);\n+\n+\t  if (!lambda_vector_lexico_pos (distres, nb_loops))\n+\t    return false;\n+\t}\n+    }\n+  return true;\n+}\n \n /* Data dependency analysis. Returns true if the iterations of LOOP\n    are independent on each other (that is, if we can execute them"}, {"sha": "6c551ae76976617af147ab093691eb7433645f2f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -274,7 +274,7 @@ struct dump_file_info\n /* Insert PHI nodes everywhere they are needed.  No pruning of the\n    IDF is done.  This is used by passes that need the PHI nodes for\n    O_j even if it means that some arguments will come from the default\n-   definition of O_j's symbol (e.g., pass_linear_transform).\n+   definition of O_j's symbol.\n \n    WARNING: If you need to use this flag, chances are that your pass\n    may be doing something wrong.  Inserting PHI nodes for an old name\n@@ -431,7 +431,6 @@ extern struct gimple_opt_pass pass_rename_ssa_copies;\n extern struct gimple_opt_pass pass_rest_of_compilation;\n extern struct gimple_opt_pass pass_sink_code;\n extern struct gimple_opt_pass pass_fre;\n-extern struct gimple_opt_pass pass_linear_transform;\n extern struct gimple_opt_pass pass_check_data_deps;\n extern struct gimple_opt_pass pass_copy_prop;\n extern struct gimple_opt_pass pass_vrp;"}, {"sha": "5534b6a515aeb9a421a491f8873e9bbf59e00a7f", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b305e3dab4edef2ea58213e04a65a12408a97894/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=b305e3dab4edef2ea58213e04a65a12408a97894", "patch": "@@ -246,45 +246,6 @@ struct gimple_opt_pass pass_vectorize =\n  }\n };\n \n-/* Loop nest optimizations.  */\n-\n-static unsigned int\n-tree_linear_transform (void)\n-{\n-  if (number_of_loops () <= 1)\n-    return 0;\n-\n-  linear_transform_loops ();\n-  return 0;\n-}\n-\n-static bool\n-gate_tree_linear_transform (void)\n-{\n-  return flag_tree_loop_linear != 0;\n-}\n-\n-struct gimple_opt_pass pass_linear_transform =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"ltrans\",\t\t\t\t/* name */\n-  gate_tree_linear_transform,\t\t/* gate */\n-  tree_linear_transform,       \t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_LINEAR_TRANSFORM,  \t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func\n-    | TODO_update_ssa_only_virtuals\n-    | TODO_ggc_collect\t\t\t/* todo_flags_finish */\n- }\n-};\n-\n /* GRAPHITE optimizations.  */\n \n static unsigned int\n@@ -305,12 +266,17 @@ gate_graphite_transforms (void)\n      is turned on.  */\n   if (flag_loop_block\n       || flag_loop_interchange\n+      || flag_tree_loop_linear\n       || flag_loop_strip_mine\n       || flag_graphite_identity\n       || flag_loop_parallelize_all\n       || flag_loop_flatten)\n     flag_graphite = 1;\n \n+  /* Make flag_tree_loop_linear an alias of flag_loop_interchange.  */\n+  if (flag_tree_loop_linear)\n+    flag_loop_interchange = flag_tree_loop_linear;\n+\n   return flag_graphite != 0;\n }\n "}]}