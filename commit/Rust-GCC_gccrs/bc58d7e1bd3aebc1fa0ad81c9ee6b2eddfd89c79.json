{"sha": "bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1OGQ3ZTFiZDNhZWJjMWZhMGFkODFjOWVlNmIyZWRkZmQ4OWM3OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-21T21:58:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-21T21:58:50Z"}, "message": "timevar.def (TV_WHOPR_WPA_FIXUP): Remove.\n\n\n\t* timevar.def (TV_WHOPR_WPA_FIXUP): Remove.\n\t* lto-section-in.c (lto_section_name): Remove wpa_fixup.\n\t* lto-wpa-fixup.c: Remove.\n\t* Makefile.in (lto-wpa-fixup.o): Remove.\n\t* passes.c (init_optimization_passes): Remove pass_ipa_lto_wpa_fixup.\n\t(execute_all_ipa_transforms): Set cgraph_state to CGRAPH_STATE_IPA_SSA.\n\t* lto-streamer.c (lto_get_section_name): Remove wpa_fixup section.\n\t\n\t* lto.c (lto_fixup_tree): Do not call wpa fixup.\n\t(materialize_cgraph): Likewise.\n\nFrom-SVN: r158622", "tree": {"sha": "1322de7c8a1c5d0b32a7b386725bce3c024e3502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1322de7c8a1c5d0b32a7b386725bce3c024e3502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/comments", "author": null, "committer": null, "parents": [{"sha": "2b65cd83e9a09a18d44984ca261b40b84d2eaeab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b65cd83e9a09a18d44984ca261b40b84d2eaeab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b65cd83e9a09a18d44984ca261b40b84d2eaeab"}], "stats": {"total": 344, "additions": 26, "deletions": 318}, "files": [{"sha": "cc8702bdcf29d2a988e661f241e3d98c94bf9ab8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -1,3 +1,13 @@\n+2010-04-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* timevar.def (TV_WHOPR_WPA_FIXUP): Remove.\n+\t* lto-section-in.c (lto_section_name): Remove wpa_fixup.\n+\t* lto-wpa-fixup.c: Remove.\n+\t* Makefile.in (lto-wpa-fixup.o): Remove.\n+\t* passes.c (init_optimization_passes): Remove pass_ipa_lto_wpa_fixup.\n+\t(execute_all_ipa_transforms): Set cgraph_state to CGRAPH_STATE_IPA_SSA.\n+\t* lto-streamer.c (lto_get_section_name): Remove wpa_fixup section.\n+\n 2010-04-21  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-pass.h (ipa_opt_pass_d): Rename function_read_summary;"}, {"sha": "3d9aac8376f84fcda89619af8b4a6161dfd555be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -1258,7 +1258,6 @@ OBJS-common = \\\n \tlto-symtab.o \\\n \tlto-opts.o \\\n \tlto-streamer.o \\\n-\tlto-wpa-fixup.o \\\n \tlto-compress.o \\\n \tmcf.o \\\n \tmode-switching.o \\\n@@ -2251,10 +2250,6 @@ lto-opts.o: lto-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n lto-streamer.o: lto-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n    $(TM_H) $(TREE_H) $(GIMPLE_H) $(BITMAP_H) $(LTO_STREAMER_H) $(FLAGS_H) \\\n    $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(LTO_SYMTAB_H) $(TOPLEV_H)\n-lto-wpa-fixup.o: lto-wpa-fixup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n-   $(TM_H) $(TOPLEV_H) $(TREE_H) $(EXPR_H) $(FLAGS_H) $(CGRAPH_H) \\\n-   $(FUNCTION_H) $(DIAGNOSTIC_H) $(BITMAP_H) $(TIMEVAR_H) \\\n-   $(TREE_FLOW_H) $(TREE_PASS_H) $(LTO_STREAMER_H)\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(TOPLEV_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n    langhooks.h $(TARGET_H) $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\"}, {"sha": "4f2ae4ff37fddac3b608008ce7156ab07c01da90", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -55,7 +55,6 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"ipa_pure_const\",\n   \"ipa_reference\",\n   \"symtab\",\n-  \"wpa_fixup\",\n   \"opts\"\n };\n "}, {"sha": "46d61548e12aaa2deff3ee6b9641217948bd1b28", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -169,9 +169,6 @@ lto_get_section_name (int section_type, const char *name)\n     case LTO_section_ipa_reference:\n       return concat (LTO_SECTION_NAME_PREFIX, \".reference\", NULL);\n \n-    case LTO_section_wpa_fixup:\n-      return concat (LTO_SECTION_NAME_PREFIX, \".wpa_fixup\", NULL);\n-\n     case LTO_section_opts:\n       return concat (LTO_SECTION_NAME_PREFIX, \".opts\", NULL);\n "}, {"sha": "46d66e5b192cac53410a3cbe02bd6c5289de25ff", "filename": "gcc/lto-wpa-fixup.c", "status": "removed", "additions": 0, "deletions": 283, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b65cd83e9a09a18d44984ca261b40b84d2eaeab/gcc%2Flto-wpa-fixup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b65cd83e9a09a18d44984ca261b40b84d2eaeab/gcc%2Flto-wpa-fixup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wpa-fixup.c?ref=2b65cd83e9a09a18d44984ca261b40b84d2eaeab", "patch": "@@ -1,283 +0,0 @@\n-/* Write and read any fix-up information generated by the WPA mode.\n-\n-   Copyright 2009 Free Software Foundation, Inc.\n-   Contributed by Doug Kwan <dougkwan@google.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"toplev.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"flags.h\"\n-#include \"cgraph.h\"\n-#include \"function.h\"\n-#include \"diagnostic.h\"\n-#include \"vec.h\"\n-#include \"bitmap.h\"\n-#include \"timevar.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-pass.h\"\n-#include \"lto-streamer.h\"\n-\n-/* LTO fix-up.\n-\n-   In WPA mode, LTO cannot access function bodies.  Some modifications in\n-   IR require additional updates in function bodies,  which are not possible\n-   in WPA mode.  So we write out information about these modifications for\n-   LTRANS to fix up the function bodies accordingly.  */\n-\n-/* The vectors records function DECLs having multiple copies with different\n-   exception throwing attributes.  We do not mark a DECL if all copies of it\n-   have the same exception throwing attribute. */\n-static bitmap lto_nothrow_fndecls;\n-\n-/* We need to fix up GIMPLE bodies due to changes in exception setting.\n-   Consider this example:\n-\n-   a.h:\n-   class a {\n-   public:\n-     a();\n-     ~a();\n-   };\n-\n-   main.cc:\n-   #include \"a.h\"\n-\n-   int\n-   main (int argc, char **argv)\n-   {\n-     a x;\n-     return 0;\n-   }\n-\n-   a.cc:\n-   #include \"a.h\"\n-   a::a() {}\n-   a::~a() {}\n-\n-   When main.cc is compiled, gcc only sees the constructor declaration, so\n-   the constructor and hence the call to it are marked as exception throwing.\n-   When a.cc is compiled, the body of the constructor is available and is\n-   obviously not exception throwing. Thus DECL of a::a in a.o has the NOTHROW\n-   attribute.  When LTO runs, two DECLs of a::a with different exception\n-   attributes are merged.  We want the merged DECL to be not exception\n-   throwing for better generated code.  To do that, we need to fix up any\n-   function calls that have been marked as exception throwing.  */\n-\n-/* Fix up all the call statements whose target fndecls might have changed\n-   to NOTHROW.   Note that this problem is not WPA specific.  We can also\n-   run into this problem in normal LTO with multiple input files.  */\n-\n-void\n-lto_fixup_nothrow_decls (void)\n-{\n-  struct cgraph_node *node;\n-  struct cgraph_edge *edge;\n-  struct function *caller_function;\n-  gimple call_stmt;\n-\n-  /* Quit if we are in WPA mode or have not marked any DECLs.  */\n-  if (flag_wpa || !lto_nothrow_fndecls)\n-    return;\n-\n-  /* For each node that has been marked, go over all call edges to it.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (bitmap_bit_p (lto_nothrow_fndecls, DECL_UID (node->decl)))\n-      {\n-\tgcc_assert (TREE_NOTHROW (node->decl));\n-\tfor (edge = node->callers; edge; edge = edge->next_caller)\n-\t  {\n-\t    caller_function = DECL_STRUCT_FUNCTION (edge->caller->decl);\n-\t    call_stmt = edge->call_stmt;\n-\t    gcc_assert (call_stmt);\n-\t    if (lookup_stmt_eh_lp_fn (caller_function, call_stmt) != 0)\n-\t      remove_stmt_from_eh_lp_fn (caller_function, call_stmt);\n-\t  }\n-      }\n-}\n-\n-/* Mark FNDECL as becoming not exception throwing.  */\n-\n-void\n-lto_mark_nothrow_fndecl (tree fndecl)\n-{\n-  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n-  if (!lto_nothrow_fndecls)\n-    lto_nothrow_fndecls = lto_bitmap_alloc ();\n-\n-  bitmap_set_bit (lto_nothrow_fndecls, DECL_UID (fndecl));\n-}\n-\n-/* Write out fix-up information.  Currently the only WPA fix-up\n-   information is the list of DECLs marked as not exception throwing. SET\n-   is a cgraph node set whose fix-up information is to be written.  */\n-\n-static void\n-lto_output_wpa_fixup (cgraph_node_set set)\n-{\n-  struct lto_simple_output_block *ob;\n-  cgraph_node_set_iterator csi;\n-  tree fndecl;\n-  bitmap seen_decls;\n-  VEC(tree, heap) *decls = NULL;\n-  unsigned HOST_WIDE_INT i, count;\n-\n-  ob = lto_create_simple_output_block (LTO_section_wpa_fixup);\n-\n-  /* Accumulate the DECLs to be written out.  Since we do not want\n-     duplicates, we need to use a bitmap and a vector to save the\n-     DECLs we want.  Note that we need to check if lto_nothrow_fndecls\n-     is NULL.  This happens when no DECL has been marked.  */\n-  seen_decls = lto_bitmap_alloc ();\n-  if (lto_nothrow_fndecls)\n-    for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-      {\n-\tstruct cgraph_edge *e;\n-\tstruct cgraph_node *n;\n-\n-\tn = csi_node (csi);\n-\tfndecl = n->decl;\n-\n-\t/* Check if the N's function is in the set of nothrow functions.  */\n-\tif (!bitmap_bit_p (seen_decls, DECL_UID (fndecl)))\n-\t  {\n-\t    bitmap_set_bit (seen_decls, (DECL_UID (fndecl)));\n-\t    if (bitmap_bit_p (lto_nothrow_fndecls, DECL_UID (fndecl)))\n-\t      VEC_safe_push (tree, heap, decls, fndecl);\n-\t  }\n-\n-\t/* Now check the callees and also add them if they are nothrow.  This\n-\t   is needed because node N may end up in a different partition than\n-\t   its callees.  In which case, when the file holding N is compiled,\n-\t   the calls it makes to nothrow functions will not be fixed up,\n-\t   causing verification issues.  */\n-\tfor (e = n->callees; e; e = e->next_callee)\n-\t  {\n-\t    fndecl = e->callee->decl;\n-\t    if (!bitmap_bit_p (seen_decls, DECL_UID (fndecl)))\n-\t      {\n-\t\tbitmap_set_bit (seen_decls, (DECL_UID (fndecl)));\n-\t\tif (bitmap_bit_p (lto_nothrow_fndecls, DECL_UID (fndecl)))\n-\t\t  VEC_safe_push (tree, heap, decls, fndecl);\n-\t      }\n-\t  }\n-      }\n-\n-  /* Write out number of DECLs, followed by the DECLs.  */\n-  count = VEC_length (tree, decls);\n-  lto_output_uleb128_stream (ob->main_stream, count);\n-  for (i = 0; i < count; i++)\n-    {\n-      fndecl = VEC_index (tree, decls, i);\n-      lto_output_fn_decl_index (ob->decl_state, ob->main_stream, fndecl);\n-    }\n-\n-  /* Release resources.  */\n-  lto_destroy_simple_output_block (ob);\n-  VEC_free(tree, heap, decls);\n-  lto_bitmap_free (seen_decls);\n-}\n-\n-/* Read in WPA fix-up information from one file. FILE_DATA points to\n-   DECL information of the file where as IB is the input block for the\n-   WPA fix-up section.  */\n-\n-static void\n-lto_input_wpa_fixup_1 (struct lto_file_decl_data *file_data,\n-\t\t   struct lto_input_block *ib)\n-{\n-  unsigned HOST_WIDE_INT i, count, decl_index;\n-  tree fndecl;\n-\n-  count = lto_input_uleb128 (ib);\n-  for (i = 0; i < count; i++)\n-    {\n-      decl_index = lto_input_uleb128 (ib);\n-      fndecl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-      lto_mark_nothrow_fndecl (fndecl);\n-    }\n-}\n-\n-/* Read in WPA fix-up information. */\n-\n-static void\n-lto_input_wpa_fixup (void)\n-{\n-  struct lto_file_decl_data ** file_data_vec\n-    = lto_get_file_decl_data ();\n-  struct lto_file_decl_data * file_data;\n-  int i = 0;\n-\n-  /* Fix up information is only used in LTRANS mode.  */\n-  if (!flag_ltrans)\n-    return;\n-\n-  while ((file_data = file_data_vec[i++]))\n-    {\n-      const char *data;\n-      size_t len;\n-      struct lto_input_block *ib\n-\t= lto_create_simple_input_block (file_data, LTO_section_wpa_fixup,\n-\t\t\t\t\t &data, &len);\n-\n-      lto_input_wpa_fixup_1 (file_data, ib);\n-      lto_destroy_simple_input_block (file_data, LTO_section_wpa_fixup, ib,\n-\t\t\t\t      data, len);\n-    }\n-}\n-\n-/* Gate function for all lto streaming passes.  */\n-\n-static bool\n-gate_wpa_fixup (void)\n-{\n-  return (flag_wpa || flag_ltrans) && gate_lto_out ();\n-}\n-\n-struct ipa_opt_pass_d pass_ipa_lto_wpa_fixup =\n-{\n- {\n-  IPA_PASS,\n-  \"lto_wpa_fixup\",\t\t\t/* name */\n-  gate_wpa_fixup,\t\t        /* gate */\n-  NULL,\t\t                        /* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_WHOPR_WPA_FIXUP,\t\t        /* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,            \t\t\t/* todo_flags_start */\n-  TODO_dump_func                        /* todo_flags_finish */\n- },\n- NULL,\t\t                        /* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n- lto_output_wpa_fixup,\t\t\t/* write_optimization_summary */\n- lto_input_wpa_fixup,\t\t\t/* read_optimization_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n- 0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t                /* function_transform */\n- NULL\t\t\t\t\t/* variable_transform */\n-};\n-"}, {"sha": "2ce58d742f3659c31f5136886d12bf01d03ba1d8", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -1,3 +1,8 @@\n+2010-04-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_fixup_tree): Do not call wpa fixup.\n+\t(materialize_cgraph): Likewise.\n+\n 2010-04-21  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_wpa_write_files): Update."}, {"sha": "115d1cc56781973aa648248ebde42126ec5a5efb", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -1561,28 +1561,6 @@ lto_fixup_tree (tree *tp, int *walk_subtrees, void *data)\n \n       if (t != prevailing)\n \t{\n-\t  if (TREE_CODE (t) == FUNCTION_DECL\n-\t      && TREE_NOTHROW (prevailing) != TREE_NOTHROW (t))\n-\t    {\n-\t      /* If the prevailing definition does not throw but the\n-\t\t declaration (T) was considered throwing, then we\n-\t\t simply add PREVAILING to the list of throwing\n-\t\t functions.  However, if the opposite is true, then\n-\t\t the call to PREVAILING was generated assuming that\n-\t\t the function didn't throw, which means that CFG\n-\t\t cleanup may have removed surrounding try/catch\n-\t\t regions.\n-\n-\t\t Note that we currently accept these cases even when\n-\t\t they occur within a single file.  It's certainly a\n-\t\t user error, but we silently allow the compiler to\n-\t\t remove surrounding try/catch regions.  Perhaps we\n-\t\t could emit a warning here, instead of silently\n-\t\t accepting the conflicting declaration.  */\n-\t      if (TREE_NOTHROW (prevailing))\n-\t\tlto_mark_nothrow_fndecl (prevailing);\n-\t    }\n-\n \t   /* Also replace t with prevailing defintion.  We don't want to\n \t      insert the other defintion in the seen set as we want to\n \t      replace all instances of it.  */\n@@ -1974,8 +1952,6 @@ materialize_cgraph (void)\n   for (i = 0; VEC_iterate (tree, lto_global_var_decls, i, decl); i++)\n     rest_of_decl_compilation (decl, 1, 0);\n \n-  /* Fix up any calls to DECLs that have become not exception throwing.  */\n-  lto_fixup_nothrow_decls ();\n   if (!quiet_flag)\n     fprintf (stderr, \"\\n\");\n "}, {"sha": "0c93ef6d7d0f22ecf685a9aed2bc55ca50806805", "filename": "gcc/passes.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -814,7 +814,6 @@ init_optimization_passes (void)\n \n   p = &all_lto_gen_passes;\n   NEXT_PASS (pass_ipa_lto_gimple_out);\n-  NEXT_PASS (pass_ipa_lto_wpa_fixup);\n   NEXT_PASS (pass_ipa_lto_finish_out);  /* This must be the last LTO pass.  */\n   *p = NULL;\n \n@@ -1487,10 +1486,20 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n void\n execute_all_ipa_transforms (void)\n {\n+  enum cgraph_state old_state = cgraph_state;\n   struct cgraph_node *node;\n   if (!cfun)\n     return;\n   node = cgraph_node (current_function_decl);\n+\n+  /* Statement verification skip verification of nothorw when\n+     state is IPA_SSA because we do not modify function bodies\n+     after setting the flag on function.  Instead we leave it\n+     to fixup_cfg to do such a transformation.  We need to temporarily\n+     change the cgraph state so statement verifier before\n+     transform do not fire.  */\n+  cgraph_state = CGRAPH_STATE_IPA_SSA;\n+\n   if (node->ipa_transforms_to_apply)\n     {\n       unsigned int i;\n@@ -1504,6 +1513,7 @@ execute_all_ipa_transforms (void)\n       VEC_free (ipa_opt_pass, heap, node->ipa_transforms_to_apply);\n       node->ipa_transforms_to_apply = NULL;\n     }\n+  cgraph_state = old_state;\n }\n \n /* Execute PASS. */"}, {"sha": "63530b8e9730ba620f797bc3e700bb050bf9e804", "filename": "gcc/timevar.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=bc58d7e1bd3aebc1fa0ad81c9ee6b2eddfd89c79", "patch": "@@ -57,7 +57,6 @@ DEFTIMEVAR (TV_LTO                   , \"lto\")\n DEFTIMEVAR (TV_WHOPR_WPA             , \"whopr wpa\")\n DEFTIMEVAR (TV_WHOPR_WPA_IO          , \"whopr wpa I/O\")\n DEFTIMEVAR (TV_WHOPR_LTRANS          , \"whopr ltrans\")\n-DEFTIMEVAR (TV_WHOPR_WPA_FIXUP       , \"whopr wpa fixup\")\n DEFTIMEVAR (TV_WHOPR_WPA_LTRANS_EXEC , \"whopr wpa->ltrans\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")"}]}