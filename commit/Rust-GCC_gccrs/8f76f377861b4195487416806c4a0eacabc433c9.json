{"sha": "8f76f377861b4195487416806c4a0eacabc433c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY3NmYzNzc4NjFiNDE5NTQ4NzQxNjgwNmM0YTBlYWNhYmM0MzNjOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-25T08:18:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-25T08:18:42Z"}, "message": "Prefer open-coding vector integer division\n\nvect_recog_divmod_pattern currently bails out if the target has\nnative support for integer division, but I think in practice\nit's always going to be better to open-code it anyway, just as\nwe usually open-code scalar divisions by constants.\n\nI think the only currently affected targets are MIPS MSA and\npowerpcspe (which is currently marked obsolete).  For:\n\n  void\n  foo (int *x)\n  {\n    for (int i = 0; i < 100; ++i)\n      x[i] /= 2;\n  }\n\nthe MSA port previously preferred to use division for powers of 2:\n\n        .set    noreorder\n        bnz.w   $w1,1f\n        div_s.w $w0,$w0,$w1\n        break   7\n        .set    reorder\n1:\n\n(or just the div_s.w for -mno-check-zero-division), but after the patch\nit open-codes them using shifts:\n\n        clt_s.w $w1,$w0,$w2\n        subv.w  $w0,$w0,$w1\n        srai.w  $w0,$w0,1\n\nMSA doesn't define a high-part pattern, so it still uses a division\ninstruction for the non-power-of-2 case.\n\nRichard B pointed out that this would disable SLP of division by\ndifferent amounts, but I think in practice that's a price worth paying,\nsince the current cost model can't really tell whether using a general\nvector division is better than using open-coded scalar divisions.\nThe fix would be either to support SLP of mixed open-coded divisions\nor to improve the cost model and try SLP again without the patterns.\nThe patch adds an XFAILed test for this.\n\n2018-05-23  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-patterns.c: Include predict.h.\n\t(vect_recog_divmod_pattern): Restrict check for division support\n\tto when optimizing for size.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-div-1.c: New XFAILed test.\n\nFrom-SVN: r260711", "tree": {"sha": "bf586692b116d22b1e515fb4c7f3bb8fc7f2774a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf586692b116d22b1e515fb4c7f3bb8fc7f2774a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f76f377861b4195487416806c4a0eacabc433c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f76f377861b4195487416806c4a0eacabc433c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f76f377861b4195487416806c4a0eacabc433c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f76f377861b4195487416806c4a0eacabc433c9/comments", "author": null, "committer": null, "parents": [{"sha": "0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d2b3bca81acf226e6c10defbc6072de4cf7e75c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d2b3bca81acf226e6c10defbc6072de4cf7e75c"}], "stats": {"total": 50, "additions": 42, "deletions": 8}, "files": [{"sha": "67938386d67cb06b64c32c94cae61e526a292a86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f76f377861b4195487416806c4a0eacabc433c9", "patch": "@@ -1,3 +1,9 @@\n+2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-patterns.c: Include predict.h.\n+\t(vect_recog_divmod_pattern): Restrict check for division support\n+\tto when optimizing for size.\n+\n 2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* doc/sourcebuild.texi (vect_double_cond_arith: Document."}, {"sha": "66296db447e21f437521f28339812e232a8f065a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f76f377861b4195487416806c4a0eacabc433c9", "patch": "@@ -1,3 +1,7 @@\n+2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/bb-slp-div-1.c: New XFAILed test.\n+\n 2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* lib/target-supports.exp"}, {"sha": "65d83a437b6a7705faf9929c023f104064b6e6f4", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-div-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-div-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-div-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-div-1.c?ref=8f76f377861b4195487416806c4a0eacabc433c9", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-msve-vector-bits=256\" { target aarch64_sve } } */\n+\n+int x[8];\n+\n+void\n+f (void)\n+{\n+  x[0] /= 2;\n+  x[1] /= 3;\n+  x[2] /= 4;\n+  x[3] /= 5;\n+  x[4] /= 6;\n+  x[5] /= 7;\n+  x[6] /= 8;\n+  x[7] /= 9;\n+}\n+\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" { xfail *-*-* } } } */"}, {"sha": "6da784cdc3af039e091f3a26941a658b50c2540f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f76f377861b4195487416806c4a0eacabc433c9/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=8f76f377861b4195487416806c4a0eacabc433c9", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"cgraph.h\"\n #include \"omp-simd-clone.h\"\n+#include \"predict.h\"\n \n /* Pattern recognition functions  */\n static gimple *vect_recog_widen_sum_pattern (vec<gimple *> *, tree *,\n@@ -2674,15 +2675,19 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n   if (vectype == NULL_TREE)\n     return NULL;\n \n-  /* If the target can handle vectorized division or modulo natively,\n-     don't attempt to optimize this.  */\n-  optab = optab_for_tree_code (rhs_code, vectype, optab_default);\n-  if (optab != unknown_optab)\n+  if (optimize_bb_for_size_p (gimple_bb (last_stmt)))\n     {\n-      machine_mode vec_mode = TYPE_MODE (vectype);\n-      int icode = (int) optab_handler (optab, vec_mode);\n-      if (icode != CODE_FOR_nothing)\n-\treturn NULL;\n+      /* If the target can handle vectorized division or modulo natively,\n+\t don't attempt to optimize this, since native division is likely\n+\t to give smaller code.  */\n+      optab = optab_for_tree_code (rhs_code, vectype, optab_default);\n+      if (optab != unknown_optab)\n+\t{\n+\t  machine_mode vec_mode = TYPE_MODE (vectype);\n+\t  int icode = (int) optab_handler (optab, vec_mode);\n+\t  if (icode != CODE_FOR_nothing)\n+\t    return NULL;\n+\t}\n     }\n \n   prec = TYPE_PRECISION (itype);"}]}