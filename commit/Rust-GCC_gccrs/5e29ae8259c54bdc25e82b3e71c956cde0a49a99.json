{"sha": "5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyOWFlODI1OWM1NGJkYzI1ZTgyYjNlNzFjOTU2Y2RlMGE0OWE5OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T10:55:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T10:55:42Z"}, "message": "[multiple changes]\n\n2012-12-05  Robert Dewar  <dewar@adacore.com>\n\n\t* lib-writ.adb (Write_ALI): Output T lines.\n\t* lib-writ.ads: Minor reformatting. Add documentation of T lines.\n\t* opt.ads (Generate_Target_Dependent_Info): New flag.\n\t* switch-c.adb (Scan_Switches): Recognize -gnatet switch\n\t(target dependent info).\n\t* ttypes.ads: Add four letter codes to declarations (for target\n\tdependent info).\n\t* usage.adb: Add line for -gnatet switch.\n\n2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_prag.adb (Expand_N_Pragma): Add a call to expand\n\tpragma Loop_Variant.\n\t(Expand_Pragma_Loop_Assertion): Removed.\n\t(Expand_Pragma_Loop_Variant): New routine.\n\t* par-prag.adb: Remove Pragma_Loop_Assertion and add two new\n\tPragma_Loop_Invariant and Pragma_Loop_Variant entries.\n\t* sem_attr.adb (Analyze_Attribute): Update the code which\n\tlocates the enclosing pragma.\n\t* sem_prag.adb (Analyze_Pragma): Remove the code which analyzes\n\tpragma Loop_Assertion as the pragma is now obsolete. Add the\n\tmachinery to checks the semantics of pragmas Loop_Invariant\n\tand Loop_Variant.\n\t(Check_Loop_Invariant_Variant_Placement): New routine.\n\t* snames.ads-tmpl: Remove name Loop_Assertion. Add new names\n\tLoop_Invariant and Loop_Variant.  Rename Name_Decreasing\n\tto Name_Decreases and Name_Increasing to Name_Increases.\n\tRemove the pragma Id for Loop_Assertion and add two new Ids for\n\tLoop_Invariant and Loop_Variant.\n\nFrom-SVN: r194203", "tree": {"sha": "125bcd0e1d28de72c61c9d14eb0e0ef10da3b17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/125bcd0e1d28de72c61c9d14eb0e0ef10da3b17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/comments", "author": null, "committer": null, "parents": [{"sha": "b9daa96e707ca488636eccded3255657ad0ef2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9daa96e707ca488636eccded3255657ad0ef2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9daa96e707ca488636eccded3255657ad0ef2bf"}], "stats": {"total": 640, "additions": 381, "deletions": 259}, "files": [{"sha": "6550c58943a8d8a4c1876ca67e8fb6e02b5d4b75", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -1,3 +1,35 @@\n+2012-12-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* lib-writ.adb (Write_ALI): Output T lines.\n+\t* lib-writ.ads: Minor reformatting. Add documentation of T lines.\n+\t* opt.ads (Generate_Target_Dependent_Info): New flag.\n+\t* switch-c.adb (Scan_Switches): Recognize -gnatet switch\n+\t(target dependent info).\n+\t* ttypes.ads: Add four letter codes to declarations (for target\n+\tdependent info).\n+\t* usage.adb: Add line for -gnatet switch.\n+\n+2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_prag.adb (Expand_N_Pragma): Add a call to expand\n+\tpragma Loop_Variant.\n+\t(Expand_Pragma_Loop_Assertion): Removed.\n+\t(Expand_Pragma_Loop_Variant): New routine.\n+\t* par-prag.adb: Remove Pragma_Loop_Assertion and add two new\n+\tPragma_Loop_Invariant and Pragma_Loop_Variant entries.\n+\t* sem_attr.adb (Analyze_Attribute): Update the code which\n+\tlocates the enclosing pragma.\n+\t* sem_prag.adb (Analyze_Pragma): Remove the code which analyzes\n+\tpragma Loop_Assertion as the pragma is now obsolete. Add the\n+\tmachinery to checks the semantics of pragmas Loop_Invariant\n+\tand Loop_Variant.\n+\t(Check_Loop_Invariant_Variant_Placement): New routine.\n+\t* snames.ads-tmpl: Remove name Loop_Assertion. Add new names\n+\tLoop_Invariant and Loop_Variant.  Rename Name_Decreasing\n+\tto Name_Decreases and Name_Increasing to Name_Increases.\n+\tRemove the pragma Id for Loop_Assertion and add two new Ids for\n+\tLoop_Invariant and Loop_Variant.\n+\n 2012-12-05  Robert Dewar  <dewar@adacore.com>\n \n \t* gnatchop.adb, sem_attr.ads, sem_ch4.adb, sem_ch6.adb, exp_disp.adb,"}, {"sha": "94ca24202e042b220aae5e93e44d9ef420127fe1", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 46, "deletions": 107, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -69,7 +69,7 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Import_Export_Exception (N : Node_Id);\n    procedure Expand_Pragma_Inspection_Point        (N : Node_Id);\n    procedure Expand_Pragma_Interrupt_Priority      (N : Node_Id);\n-   procedure Expand_Pragma_Loop_Assertion          (N : Node_Id);\n+   procedure Expand_Pragma_Loop_Variant            (N : Node_Id);\n    procedure Expand_Pragma_Psect_Object            (N : Node_Id);\n    procedure Expand_Pragma_Relative_Deadline       (N : Node_Id);\n \n@@ -191,8 +191,8 @@ package body Exp_Prag is\n             when Pragma_Interrupt_Priority =>\n                Expand_Pragma_Interrupt_Priority (N);\n \n-            when Pragma_Loop_Assertion =>\n-               Expand_Pragma_Loop_Assertion (N);\n+            when Pragma_Loop_Variant =>\n+               Expand_Pragma_Loop_Variant (N);\n \n             when Pragma_Psect_Object =>\n                Expand_Pragma_Psect_Object (N);\n@@ -795,20 +795,19 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Interrupt_Priority;\n \n-   ----------------------------------\n-   -- Expand_Pragma_Loop_Assertion --\n-   ----------------------------------\n+   --------------------------------\n+   -- Expand_Pragma_Loop_Variant --\n+   --------------------------------\n \n-   --  Pragma Loop_Assertion is expanded in the following manner:\n+   --  Pragma Loop_Variant is expanded in the following manner:\n \n    --  Original code\n \n    --     for | while ... loop\n    --        <preceding source statements>\n-   --        pragma Loop_Assertion\n-   --           (Invariant => Invar_Expr,\n-   --            Variant   => (Increasing => Incr_Expr,\n-   --                          Decreasing => Decr_Expr));\n+   --        pragma Loop_Variant\n+   --                 (Increases => Incr_Expr,\n+   --                  Decreases => Decr_Expr);\n    --        <succeeding source statements>\n    --     end loop;\n \n@@ -823,8 +822,6 @@ package body Exp_Prag is\n    --     for | while ... loop\n    --        <preceding source statements>\n \n-   --        pragma Assert (<Invar_Expr>);\n-\n    --        if Flag then\n    --           Old_1 := Curr_1;\n    --           Old_2 := Curr_2;\n@@ -846,35 +843,33 @@ package body Exp_Prag is\n    --        <succeeding source statements>\n    --     end loop;\n \n-   procedure Expand_Pragma_Loop_Assertion (N : Node_Id) is\n+   procedure Expand_Pragma_Loop_Variant (N : Node_Id) is\n+      Last_Var    : constant Node_Id    :=\n+                      Last (Pragma_Argument_Associations (N));\n       Loc         : constant Source_Ptr := Sloc (N);\n       Curr_Assign : List_Id   := No_List;\n       Flag_Id     : Entity_Id := Empty;\n       If_Stmt     : Node_Id   := Empty;\n       Loop_Scop   : Entity_Id;\n       Loop_Stmt   : Node_Id;\n       Old_Assign  : List_Id   := No_List;\n+      Variant     : Node_Id;\n \n-      procedure Process_Increase_Decrease\n-        (Variant : Node_Id;\n-         Is_Last : Boolean);\n+      procedure Process_Variant (Variant : Node_Id; Is_Last : Boolean);\n       --  Process a single increasing / decreasing termination variant. Flag\n       --  Is_Last should be set when processing the last variant.\n \n-      -------------------------------\n-      -- Process_Increase_Decrease --\n-      -------------------------------\n+      ---------------------\n+      -- Process_Variant --\n+      ---------------------\n \n-      procedure Process_Increase_Decrease\n-        (Variant : Node_Id;\n-         Is_Last : Boolean)\n-      is\n+      procedure Process_Variant (Variant : Node_Id; Is_Last : Boolean) is\n          function Make_Op\n            (Loc      : Source_Ptr;\n             Curr_Val : Node_Id;\n             Old_Val  : Node_Id) return Node_Id;\n          --  Generate a comparison between Curr_Val and Old_Val depending on\n-         --  the argument name (Increases / Decreases).\n+         --  the change mode (Increases / Decreases) of the variant.\n \n          -------------\n          -- Make_Op --\n@@ -885,26 +880,26 @@ package body Exp_Prag is\n             Curr_Val : Node_Id;\n             Old_Val  : Node_Id) return Node_Id\n          is\n-            Modif : constant Node_Id := First (Choices (Variant));\n          begin\n-            if Chars (Modif) = Name_Increasing then\n+            if Chars (Variant) = Name_Increases then\n                return Make_Op_Gt (Loc, Curr_Val, Old_Val);\n \n-            else pragma Assert (Chars (Modif) = Name_Decreasing);\n+            else pragma Assert (Chars (Variant) = Name_Decreases);\n                return Make_Op_Lt (Loc, Curr_Val, Old_Val);\n             end if;\n          end Make_Op;\n \n          --  Local variables\n \n          Expr     : constant Node_Id := Expression (Variant);\n+         Expr_Typ : constant Entity_Id := Etype (Expr);\n          Loc      : constant Source_Ptr := Sloc (Expr);\n          Loop_Loc : constant Source_Ptr := Sloc (Loop_Stmt);\n          Curr_Id  : Entity_Id;\n          Old_Id   : Entity_Id;\n          Prag     : Node_Id;\n \n-      --  Start of processing for Process_Increase_Decrease\n+      --  Start of processing for Process_Variant\n \n       begin\n          --  All temporaries generated in this routine must be inserted before\n@@ -959,8 +954,7 @@ package body Exp_Prag is\n          Insert_Action (Loop_Stmt,\n            Make_Object_Declaration (Loop_Loc,\n              Defining_Identifier => Curr_Id,\n-             Object_Definition   =>\n-               New_Reference_To (Etype (Expr), Loop_Loc)));\n+             Object_Definition   => New_Reference_To (Expr_Typ, Loop_Loc)));\n \n          --  Generate:\n          --    Old : <type of Expr>;\n@@ -970,8 +964,7 @@ package body Exp_Prag is\n          Insert_Action (Loop_Stmt,\n            Make_Object_Declaration (Loop_Loc,\n              Defining_Identifier => Old_Id,\n-             Object_Definition   =>\n-               New_Reference_To (Etype (Expr), Loop_Loc)));\n+             Object_Definition   => New_Reference_To (Expr_Typ, Loop_Loc)));\n \n          --  Restore original scope after all temporaries have been analyzed\n \n@@ -1066,12 +1059,7 @@ package body Exp_Prag is\n                     Right_Opnd => New_Reference_To (Old_Id, Loc)),\n                 Then_Statements => New_List (Prag)));\n          end if;\n-      end Process_Increase_Decrease;\n-\n-      --  Local variables\n-\n-      Arg   : Node_Id;\n-      Invar : Node_Id := Empty;\n+      end Process_Variant;\n \n    --  Start of processing for Expand_Pragma_Loop_Assertion\n \n@@ -1093,76 +1081,29 @@ package body Exp_Prag is\n \n       Loop_Scop := Entity (Identifier (Loop_Stmt));\n \n-      --  Process all pragma arguments\n-\n-      Arg := First (Pragma_Argument_Associations (N));\n-      while Present (Arg) loop\n-\n-         --  Termination variants appear as components in an aggregate\n+      --  Create the circuitry which verifies individual variants\n \n-         if Chars (Arg) = Name_Variant then\n-            declare\n-               Variants : constant Node_Id := Expression (Arg);\n-               Last_Var : constant Node_Id :=\n-                            Last (Component_Associations (Variants));\n-               Variant  : Node_Id;\n-\n-            begin\n-               Variant := First (Component_Associations (Variants));\n-               while Present (Variant) loop\n-                  Process_Increase_Decrease\n-                    (Variant => Variant,\n-                     Is_Last => Variant = Last_Var);\n-\n-                  Next (Variant);\n-               end loop;\n-            end;\n+      Variant := First (Pragma_Argument_Associations (N));\n+      while Present (Variant) loop\n+         Process_Variant (Variant, Is_Last => Variant = Last_Var);\n \n-         --  Invariant\n-\n-         else\n-            Invar := Expression (Arg);\n-         end if;\n-\n-         Next (Arg);\n+         Next (Variant);\n       end loop;\n \n-      --  Verify the invariant expression, generate:\n-      --    pragma Assert (<Invar>);\n-\n-      --  Use the Sloc of the invariant for better error reporting\n-\n-      if Present (Invar) then\n-         declare\n-            Invar_Loc : constant Source_Ptr := Sloc (Invar);\n-         begin\n-            Insert_Action (N,\n-              Make_Pragma (Invar_Loc,\n-                Chars                        => Name_Assert,\n-                Pragma_Argument_Associations => New_List (\n-                  Make_Pragma_Argument_Association (Invar_Loc,\n-                    Expression => Relocate_Node (Invar)))));\n-         end;\n-      end if;\n-\n       --  Construct the segment which stores the old values of all expressions.\n       --  Generate:\n       --    if Flag then\n       --       <Old_Assign>\n       --    end if;\n \n-      if Present (Old_Assign) then\n-         Insert_Action (N,\n-           Make_If_Statement (Loc,\n-             Condition       => New_Reference_To (Flag_Id, Loc),\n-             Then_Statements => Old_Assign));\n-      end if;\n+      Insert_Action (N,\n+        Make_If_Statement (Loc,\n+          Condition       => New_Reference_To (Flag_Id, Loc),\n+          Then_Statements => Old_Assign));\n \n       --  Update the values of all expressions\n \n-      if Present (Curr_Assign) then\n-         Insert_Actions (N, Curr_Assign);\n-      end if;\n+      Insert_Actions (N, Curr_Assign);\n \n       --  Add the assertion circuitry to test all changes in expressions.\n       --  Generate:\n@@ -1172,22 +1113,20 @@ package body Exp_Prag is\n       --       Flag := True;\n       --    end if;\n \n-      if Present (If_Stmt) then\n-         Insert_Action (N,\n-           Make_If_Statement (Loc,\n-             Condition       => New_Reference_To (Flag_Id, Loc),\n-             Then_Statements => New_List (If_Stmt),\n-             Else_Statements => New_List (\n-               Make_Assignment_Statement (Loc,\n-                 Name       => New_Reference_To (Flag_Id, Loc),\n-                 Expression => New_Reference_To (Standard_True, Loc)))));\n-      end if;\n+      Insert_Action (N,\n+        Make_If_Statement (Loc,\n+          Condition       => New_Reference_To (Flag_Id, Loc),\n+          Then_Statements => New_List (If_Stmt),\n+          Else_Statements => New_List (\n+            Make_Assignment_Statement (Loc,\n+              Name       => New_Reference_To (Flag_Id, Loc),\n+              Expression => New_Reference_To (Standard_True, Loc)))));\n \n       --  Note: the pragma has been completely transformed into a sequence of\n       --  corresponding declarations and statements. We leave it in the tree\n       --  for documentation purposes. It will be ignored by the backend.\n \n-   end Expand_Pragma_Loop_Assertion;\n+   end Expand_Pragma_Loop_Variant;\n \n    --------------------------------\n    -- Expand_Pragma_Psect_Object --"}, {"sha": "7f743e23aa917b43df182888f1de1697ff8bfe54", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -49,6 +49,7 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n with Uname;    use Uname;\n \n with System.Case_Util; use System.Case_Util;\n@@ -1440,6 +1441,93 @@ package body Lib.Writ is\n          Output_Alfa;\n       end if;\n \n+      --  Output target dependent information if needed\n+\n+      if Generate_Target_Dependent_Info then\n+         Gen_TDI : declare\n+            subtype Str4 is String (1 .. 4);\n+\n+            procedure Gen_TDI_Bool (Code : Str4; Val : Boolean);\n+            --  Generate T line for Bool value\n+\n+            procedure Gen_TDI_Nat (Code : Str4; Val : Int);\n+            --  Generate T line for Pos or Nat value\n+\n+            ------------------\n+            -- Gen_TDI_Bool --\n+            ------------------\n+\n+            procedure Gen_TDI_Bool (Code : Str4; Val : Boolean) is\n+            begin\n+               Write_Info_Initiate ('T');\n+               Write_Info_Char (' ');\n+               Write_Info_Str (Code);\n+\n+               if Val then\n+                  Write_Info_Str (\" TRUE\");\n+               else\n+                  Write_Info_Str (\" FALSE\");\n+               end if;\n+\n+               Write_Info_EOL;\n+            end Gen_TDI_Bool;\n+\n+            -----------------\n+            -- Gen_TDI_Nat --\n+            -----------------\n+\n+            procedure Gen_TDI_Nat (Code : Str4; Val : Int) is\n+            begin\n+               Write_Info_Initiate ('T');\n+               Write_Info_Char (' ');\n+               Write_Info_Str (Code);\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (Val);\n+\n+               Write_Info_EOL;\n+            end Gen_TDI_Nat;\n+\n+         --  Start of processing for Gen_TDI\n+\n+         begin\n+            Gen_TDI_Nat  (\"SINS\", Standard_Short_Short_Integer_Size);\n+            Gen_TDI_Nat  (\"SINW\", Standard_Short_Short_Integer_Width);\n+            Gen_TDI_Nat  (\"SHIS\", Standard_Short_Integer_Size);\n+            Gen_TDI_Nat  (\"SHIW\", Standard_Short_Integer_Width);\n+            Gen_TDI_Nat  (\"INTS\", Standard_Integer_Size);\n+            Gen_TDI_Nat  (\"INTW\", Standard_Integer_Width);\n+            Gen_TDI_Nat  (\"LINS\", Standard_Long_Integer_Size);\n+            Gen_TDI_Nat  (\"LINW\", Standard_Long_Integer_Width);\n+            Gen_TDI_Nat  (\"LLIS\", Standard_Long_Long_Integer_Size);\n+            Gen_TDI_Nat  (\"LLIW\", Standard_Long_Long_Integer_Width);\n+            Gen_TDI_Nat  (\"SFLS\", Standard_Short_Float_Size);\n+            Gen_TDI_Nat  (\"SFLD\", Standard_Short_Float_Digits);\n+            Gen_TDI_Nat  (\"FLTS\", Standard_Float_Size);\n+            Gen_TDI_Nat  (\"FLTD\", Standard_Float_Digits);\n+            Gen_TDI_Nat  (\"LFLS\", Standard_Long_Float_Size);\n+            Gen_TDI_Nat  (\"LFLD\", Standard_Long_Float_Digits);\n+            Gen_TDI_Nat  (\"LLFS\", Standard_Long_Long_Float_Size);\n+            Gen_TDI_Nat  (\"LLFD\", Standard_Long_Long_Float_Digits);\n+            Gen_TDI_Nat  (\"CHAS\", Standard_Character_Size);\n+            Gen_TDI_Nat  (\"WCHS\", Standard_Wide_Character_Size);\n+            Gen_TDI_Nat  (\"WWCS\", Standard_Wide_Wide_Character_Size);\n+            Gen_TDI_Nat  (\"ADRS\", System_Address_Size);\n+            Gen_TDI_Nat  (\"MBMP\", System_Max_Binary_Modulus_Power);\n+            Gen_TDI_Nat  (\"MNMP\", System_Max_Nonbinary_Modulus_Power);\n+            Gen_TDI_Nat  (\"SUNI\", System_Storage_Unit);\n+            Gen_TDI_Nat  (\"WRDS\", System_Word_Size);\n+            Gen_TDI_Nat  (\"TICK\", System_Tick_Nanoseconds);\n+            Gen_TDI_Nat  (\"WCTS\", Interfaces_Wchar_T_Size);\n+            Gen_TDI_Nat  (\"MAXA\", Maximum_Alignment);\n+            Gen_TDI_Nat  (\"ALLA\", System_Allocator_Alignment);\n+            Gen_TDI_Nat  (\"MUNF\", Max_Unaligned_Field);\n+            Gen_TDI_Bool (\"BEND\", Bytes_Big_Endian);\n+            Gen_TDI_Bool (\"STRA\", Target_Strict_Alignment);\n+            Gen_TDI_Nat  (\"DFLA\", Target_Double_Float_Alignment);\n+            Gen_TDI_Nat  (\"DSCA\", Target_Double_Scalar_Alignment);\n+         end Gen_TDI;\n+      end if;\n+\n       --  Output final blank line and we are done. This final blank line is\n       --  probably junk, but we don't feel like making an incompatible change!\n "}, {"sha": "3867c5f26439ec30fc8088ab14ce5a15bb6bdcab", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -801,21 +801,40 @@ package Lib.Writ is\n    --------------------------\n \n    --  The cross-reference data follows the dependency lines. See the spec of\n-   --  Lib.Xref for details on the format of this data.\n+   --  Lib.Xref in file lib-xref.ads for details on the format of this data.\n \n    ---------------------------------\n    -- Source Coverage Obligations --\n    ---------------------------------\n \n    --  The Source Coverage Obligation (SCO) information follows the cross-\n-   --  reference data. See the spec of Par_SCO for full details of the format.\n+   --  reference data. See the spec of Par_SCO in file par_sco.ads for full\n+   --  details of the format.\n \n    ----------------------\n    -- Alfa Information --\n    ----------------------\n \n    --  The Alfa information follows the SCO information. See the spec of Alfa\n-   --  for full details of the format.\n+   --  in file alfa.ads for full details of the format.\n+\n+   -------------------------------------\n+   -- T  Target Dependent Information --\n+   -------------------------------------\n+\n+   --  This section is present if the option to generate target dependent\n+   --  information is present (this flag is set by the -gnatT switch). The\n+   --  format of T lines is:\n+\n+   --    T key val\n+\n+   --  There is one line for each constant declared in the Ttypes package\n+\n+   --    key   is the four letter code (which can be found as a comment on each\n+   --          of the constant declarations in Ttypes).\n+\n+   --    val   is the value of the constant, which is either a non-negative\n+   --          decimal constant, or TRUE or FALSE for a Boolean value.\n \n    ----------------------\n    -- Global Variables --"}, {"sha": "b8d169700dcfaeec781faf013d687d7b26d0d3a2", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -658,6 +658,11 @@ package Opt is\n    --  True when switch -fdebug-instances is used. When True, a table of\n    --  instances is included in SCOs.\n \n+   Generate_Target_Dependent_Info : Boolean := False;\n+   --  GNAT\n+   --  When true (-gnatet switch used). True if target dependent info is to be\n+   --  generated in the ali file.\n+\n    Generating_Code : Boolean := False;\n    --  GNAT\n    --  True if the frontend finished its work and has called the backend to"}, {"sha": "9d974f3b09afddc765b9282581d3e546bfec789f", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -1189,7 +1189,8 @@ begin\n            Pragma_Lock_Free                      |\n            Pragma_Locking_Policy                 |\n            Pragma_Long_Float                     |\n-           Pragma_Loop_Assertion                 |\n+           Pragma_Loop_Invariant                 |\n+           Pragma_Loop_Variant                   |\n            Pragma_Machine_Attribute              |\n            Pragma_Main                           |\n            Pragma_Main_Storage                   |"}, {"sha": "7803d36555827b02790023b7d80536ae209c40dc", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -3795,15 +3795,17 @@ package body Sem_Attr is\n          Stmt := N;\n          while Present (Stmt) loop\n \n-            --  Locate the enclosing Loop_Assertion pragma (if any). Note that\n-            --  when Loop_Assertion is expanded, we must look for an Assertion\n-            --  pragma.\n+            --  Locate the enclosing Loop_Invariant / Loop_Variant pragma (if\n+            --  any). Note that when these two are expanded, we must look for\n+            --  an Assertion pragma.\n \n             if Nkind (Original_Node (Stmt)) = N_Pragma\n               and then\n                 (Pragma_Name (Original_Node (Stmt)) = Name_Assert\n                    or else\n-                 Pragma_Name (Original_Node (Stmt)) = Name_Loop_Assertion)\n+                 Pragma_Name (Original_Node (Stmt)) = Name_Loop_Invariant\n+                   or else\n+                 Pragma_Name (Original_Node (Stmt)) = Name_Loop_Variant)\n             then\n                In_Loop_Assertion := True;\n "}, {"sha": "3e70492fb96d5c3fb8510358788f04af3356558d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 94, "deletions": 98, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -618,6 +618,10 @@ package body Sem_Prag is\n       --  Common processing for first argument of pragma Interrupt_Handler or\n       --  pragma Attach_Handler.\n \n+      procedure Check_Loop_Invariant_Variant_Placement;\n+      --  Verify whether pragma Loop_Invariant or pragma Loop_Variant appear\n+      --  immediately within the statements of the related loop.\n+\n       procedure Check_Is_In_Decl_Part_Or_Package_Spec;\n       --  Check that pragma appears in a declarative part, or in a package\n       --  specification, i.e. that it does not occur in a statement sequence\n@@ -1912,6 +1916,44 @@ package body Sem_Prag is\n          end if;\n       end Check_Interrupt_Or_Attach_Handler;\n \n+      --------------------------------------------\n+      -- Check_Loop_Invariant_Variant_Placement --\n+      --------------------------------------------\n+\n+      procedure Check_Loop_Invariant_Variant_Placement is\n+         Loop_Stmt : Node_Id;\n+\n+      begin\n+         --  Locate the enclosing loop statement (if any)\n+\n+         Loop_Stmt := N;\n+         while Present (Loop_Stmt) loop\n+            if Nkind (Loop_Stmt) = N_Loop_Statement then\n+               exit;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Nkind_In (Loop_Stmt, N_Entry_Body,\n+                                       N_Package_Body,\n+                                       N_Package_Declaration,\n+                                       N_Protected_Body,\n+                                       N_Subprogram_Body,\n+                                       N_Task_Body)\n+            then\n+               Error_Pragma (\"pragma % must appear inside a loop statement\");\n+               return;\n+\n+            else\n+               Loop_Stmt := Parent (Loop_Stmt);\n+            end if;\n+         end loop;\n+\n+         if List_Containing (N) /= Statements (Loop_Stmt) then\n+            Error_Pragma\n+              (\"pragma % must occur immediately in the statements of a loop\");\n+         end if;\n+      end Check_Loop_Invariant_Variant_Placement;\n+\n       -------------------------------------------\n       -- Check_Is_In_Decl_Part_Or_Package_Spec --\n       -------------------------------------------\n@@ -11453,74 +11495,62 @@ package body Sem_Prag is\n          end Long_Float;\n \n          --------------------\n-         -- Loop_Assertion --\n+         -- Loop_Invariant --\n          --------------------\n \n-         --  pragma Loop_Assertion\n-         --        (  [Invariant =>] boolean_Expression );\n-         --     |  ( [[Invariant =>] boolean_Expression ,]\n-         --            Variant   =>\n-         --              ( TERMINATION_VARIANT {, TERMINATION_VARIANT ) );\n-\n-         --  TERMINATION_VARIANT ::= CHANGE_MODIFIER => discrete_EXPRESSION\n-\n-         --  CHANGE_MODIFIER ::= Increasing | Decreasing\n+         --  pragma Loop_Invariant ( boolean_EXPRESSION );\n \n-         when Pragma_Loop_Assertion => Loop_Assertion : declare\n-            procedure Check_Variant (Arg : Node_Id);\n-            --  Verify the legality of a variant\n-\n-            -------------------\n-            -- Check_Variant --\n-            -------------------\n+         when Pragma_Loop_Invariant => Loop_Invariant : declare\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+            Check_Loop_Invariant_Variant_Placement;\n \n-            procedure Check_Variant (Arg : Node_Id) is\n-               Expr : constant Node_Id := Expression (Arg);\n+            --  Completely ignore if disabled\n \n-            begin\n-               --  Variants appear in aggregate form\n+            if Check_Disabled (Pname) then\n+               Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n+               return;\n+            end if;\n \n-               if Nkind (Expr) = N_Aggregate then\n-                  declare\n-                     Comp  : Node_Id;\n-                     Extra : Node_Id;\n-                     Modif : Node_Id;\n+            Preanalyze_And_Resolve (Expression (Arg1), Any_Boolean);\n \n-                  begin\n-                     Comp := First (Component_Associations (Expr));\n-                     while Present (Comp) loop\n-                        Modif := First (Choices (Comp));\n-                        Extra := Next (Modif);\n+            --  Transform pagma Loop_Invariant into an equivalent pragma Check.\n+            --  Generate:\n+            --    pragma Check (Loop_Invaraint, Arg1);\n \n-                        Check_Arg_Is_One_Of\n-                          (Modif, Name_Decreasing, Name_Increasing);\n+            Rewrite (N,\n+              Make_Pragma (Loc,\n+                Chars                        => Name_Check,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Name_Loop_Invariant)),\n+                  Relocate_Node (Arg1))));\n \n-                        if Present (Extra) then\n-                           Error_Pragma_Arg\n-                             (\"only one modifier allowed in argument\", Expr);\n-                        end if;\n+            Analyze (N);\n+         end Loop_Invariant;\n \n-                        Preanalyze_And_Resolve\n-                          (Expression (Comp), Any_Discrete);\n+         ------------------\n+         -- Loop_Variant --\n+         ------------------\n \n-                        Next (Comp);\n-                     end loop;\n-                  end;\n-               else\n-                  Error_Pragma_Arg\n-                    (\"expression on variant must be an aggregate\", Expr);\n-               end if;\n-            end Check_Variant;\n+         --  pragma Loop_Variant\n+         --         ( LOOP_VARIANT_ITEM {, LOOP_VARIANT_ITEM } );\n \n-            --  Local variables\n+         --  LOOP_VARIANT_ITEM ::= CHANGE_DIRECTION => discrete_EXPRESSION\n \n-            Stmt : Node_Id;\n+         --  CHANGE_DIRECTION ::= Increases | Decreases\n \n-         --  Start of processing for Loop_Assertion\n+         when Pragma_Loop_Variant => Loop_Variant : declare\n+            Variant : Node_Id;\n \n          begin\n             GNAT_Pragma;\n             S14_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_Loop_Invariant_Variant_Placement;\n \n             --  Completely ignore if disabled\n \n@@ -11530,56 +11560,21 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            --  Verify that the pragma appears inside a loop\n-\n-            Stmt := N;\n-            while Present (Stmt) and then Nkind (Stmt) /= N_Loop_Statement loop\n-               Stmt := Parent (Stmt);\n-            end loop;\n-\n-            if No (Stmt) then\n-               Error_Pragma (\"pragma % must appear inside a loop\");\n-            end if;\n-\n-            Check_At_Least_N_Arguments (1);\n-            Check_At_Most_N_Arguments  (2);\n-\n-            --  Process the first argument\n-\n-            if Chars (Arg1) = Name_Variant then\n-               Check_Variant (Arg1);\n-\n-            elsif Chars (Arg1) = No_Name\n-              or else Chars (Arg1) = Name_Invariant\n-            then\n-               Preanalyze_And_Resolve (Expression (Arg1), Any_Boolean);\n-\n-            else\n-               Error_Pragma_Arg (\"argument not allowed in pragma %\", Arg1);\n-            end if;\n-\n-            --  Process the second argument\n+            --  Process all increasing / decreasing expressions\n \n-            if Present (Arg2) then\n-               if Chars (Arg2) = Name_Variant then\n-                  if Chars (Arg1) = Name_Variant then\n-                     Error_Pragma (\"only one variant allowed in pragma %\");\n-                  else\n-                     Check_Variant (Arg2);\n-                  end if;\n+            Variant := First (Pragma_Argument_Associations (N));\n+            while Present (Variant) loop\n+               if Chars (Variant) /= Name_Decreases\n+                 and then Chars (Variant) /= Name_Increases\n+               then\n+                  Error_Pragma_Arg (\"wrong change modifier\", Variant);\n+               end if;\n \n-               elsif Chars (Arg2) = Name_Invariant then\n-                  if Chars (Arg1) = Name_Variant then\n-                     Error_Pragma_Arg (\"invariant must precede variant\", Arg2);\n-                  else\n-                     Error_Pragma (\"only one invariant allowed in pragma %\");\n-                  end if;\n+               Preanalyze_And_Resolve (Expression (Variant), Any_Discrete);\n \n-               else\n-                  Error_Pragma_Arg (\"argument not allowed in pragma %\", Arg2);\n-               end if;\n-            end if;\n-         end Loop_Assertion;\n+               Next (Variant);\n+            end loop;\n+         end Loop_Variant;\n \n          -----------------------\n          -- Machine_Attribute --\n@@ -15707,7 +15702,8 @@ package body Sem_Prag is\n       Pragma_Lock_Free                      => -1,\n       Pragma_Locking_Policy                 => -1,\n       Pragma_Long_Float                     => -1,\n-      Pragma_Loop_Assertion                 => -1,\n+      Pragma_Loop_Invariant                 => -1,\n+      Pragma_Loop_Variant                   => -1,\n       Pragma_Machine_Attribute              => -1,\n       Pragma_Main                           => -1,\n       Pragma_Main_Storage                   => -1,"}, {"sha": "05168b37a4ad7565690acf33a2823ebe493901b9", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -405,7 +405,8 @@ package Snames is\n    Name_License                        : constant Name_Id := N + $; -- GNAT\n    Name_Locking_Policy                 : constant Name_Id := N + $;\n    Name_Long_Float                     : constant Name_Id := N + $; -- VMS\n-   Name_Loop_Assertion                 : constant Name_Id := N + $; -- GNAT\n+   Name_Loop_Invariant                 : constant Name_Id := N + $; -- GNAT\n+   Name_Loop_Variant                   : constant Name_Id := N + $; -- GNAT\n    Name_No_Run_Time                    : constant Name_Id := N + $; -- GNAT\n    Name_No_Strict_Aliasing             : constant Name_Id := N + $; -- GNAT\n    Name_Normalize_Scalars              : constant Name_Id := N + $;\n@@ -671,7 +672,7 @@ package Snames is\n    Name_Component_Size_4               : constant Name_Id := N + $;\n    Name_Copy                           : constant Name_Id := N + $;\n    Name_D_Float                        : constant Name_Id := N + $;\n-   Name_Decreasing                     : constant Name_Id := N + $;\n+   Name_Decreases                      : constant Name_Id := N + $;\n    Name_Descriptor                     : constant Name_Id := N + $;\n    Name_Disable                        : constant Name_Id := N + $;\n    Name_Dot_Replacement                : constant Name_Id := N + $;\n@@ -691,7 +692,7 @@ package Snames is\n    Name_GPL                            : constant Name_Id := N + $;\n    Name_IEEE_Float                     : constant Name_Id := N + $;\n    Name_Ignore                         : constant Name_Id := N + $;\n-   Name_Increasing                     : constant Name_Id := N + $;\n+   Name_Increases                      : constant Name_Id := N + $;\n    Name_Info                           : constant Name_Id := N + $;\n    Name_Internal                       : constant Name_Id := N + $;\n    Name_Link_Name                      : constant Name_Id := N + $;\n@@ -1686,7 +1687,8 @@ package Snames is\n       Pragma_License,\n       Pragma_Locking_Policy,\n       Pragma_Long_Float,\n-      Pragma_Loop_Assertion,\n+      Pragma_Loop_Invariant,\n+      Pragma_Loop_Variant,\n       Pragma_No_Run_Time,\n       Pragma_No_Strict_Aliasing,\n       Pragma_Normalize_Scalars,"}, {"sha": "920b2a5773a60a684905525b6554411735427310", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -614,6 +614,12 @@ package body Switch.C is\n                      Generate_SCO := True;\n                      Ptr := Ptr + 1;\n \n+                  --  -gnatet (generate target dependent information)\n+\n+                  when 't' =>\n+                     Generate_Target_Dependent_Info := True;\n+                     Ptr := Ptr + 1;\n+\n                   --  -gnateV (validity checks on parameters)\n \n                   when 'V' =>"}, {"sha": "be0162d6b444d628eb257d34622232c86c79fb6e", "filename": "gcc/ada/ttypes.ads", "status": "modified", "additions": 69, "deletions": 42, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fttypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fttypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypes.ads?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,11 +38,10 @@ package Ttypes is\n    --  types on the host and types on the target, since in the general\n    --  case of a cross-compiler these will be different.\n \n-   --  This package and its companion Ttypef provide definitions of values\n-   --  that describe the properties of the target types. All instances of\n-   --  target dependencies, including the definitions of such packages as\n-   --  Standard and System depend directly or indirectly on the definitions\n-   --  in the Ttypes and Ttypef packages.\n+   --  This package provides definitions of values that describe the properties\n+   --  of the target types. All instances of target dependencies, including the\n+   --  definitions of such packages as Standard and System depend directly or\n+   --  indirectly on the definitions in the Ttypes packages.\n \n    --  In the source of the compiler, references to attributes such as\n    --  Integer'Size will give information regarding the host types (i.e.\n@@ -93,6 +92,18 @@ package Ttypes is\n    --  than referencing System.Storage_Unit, or Standard'Storage_Unit, both of\n    --  which would yield the host value.\n \n+   ----------------------------------------------\n+   -- Target-Dependent Information in ALI File --\n+   ----------------------------------------------\n+\n+   --  If the flag Generate_Target_Dependent_Info is set (e.g. by use of the\n+   --  -gnatT switch), then the ALI file contains T lines representing each of\n+   --  the constants defined in this package (see Lib-Writ spec for details).\n+\n+   --  These T lines use a code consisting of four upper case letters to\n+   --  identify the constant whose value is output. These four letter codes\n+   --  may be found as a comment in the declaration of each constant.\n+\n    ---------------------------------------------------\n    -- Target-Dependent Values for Types in Standard --\n    ---------------------------------------------------\n@@ -102,55 +113,65 @@ package Ttypes is\n    --  example, on some machines, Short_Float may be the same as Float, and\n    --  Long_Long_Float may be the same as Long_Float.\n \n-   Standard_Short_Short_Integer_Size  : constant Pos := Get_Char_Size;\n-   Standard_Short_Short_Integer_Width : constant Pos :=\n+   Standard_Short_Short_Integer_Size  : constant Pos :=               -- SINS\n+                                          Get_Char_Size;\n+   Standard_Short_Short_Integer_Width : constant Pos :=               -- SINW\n                                           Width_From_Size\n                                            (Standard_Short_Short_Integer_Size);\n \n-   Standard_Short_Integer_Size        : constant Pos := Get_Short_Size;\n-   Standard_Short_Integer_Width       : constant Pos :=\n+   Standard_Short_Integer_Size        : constant Pos :=               -- SHIS\n+                                          Get_Short_Size;\n+   Standard_Short_Integer_Width       : constant Pos :=               -- SHIW\n                                           Width_From_Size\n                                             (Standard_Short_Integer_Size);\n \n-   Standard_Integer_Size              : constant Pos := Get_Int_Size;\n-   Standard_Integer_Width             : constant Pos :=\n+   Standard_Integer_Size              : constant Pos :=               -- INTS\n+                                          Get_Int_Size;\n+   Standard_Integer_Width             : constant Pos :=               -- INTW\n                                           Width_From_Size\n                                             (Standard_Integer_Size);\n \n-   Standard_Long_Integer_Size         : constant Pos := Get_Long_Size;\n-   Standard_Long_Integer_Width        : constant Pos :=\n+   Standard_Long_Integer_Size         : constant Pos :=               -- LINS\n+                                          Get_Long_Size;\n+   Standard_Long_Integer_Width        : constant Pos :=               -- LINW\n                                           Width_From_Size\n                                             (Standard_Long_Integer_Size);\n \n-   Standard_Long_Long_Integer_Size    : constant Pos := Get_Long_Long_Size;\n-   Standard_Long_Long_Integer_Width   : constant Pos :=\n+   Standard_Long_Long_Integer_Size    : constant Pos :=               -- LLIS\n+                                          Get_Long_Long_Size;\n+   Standard_Long_Long_Integer_Width   : constant Pos :=               -- LLIW\n                                           Width_From_Size\n                                             (Standard_Long_Long_Integer_Size);\n \n-   Standard_Short_Float_Size          : constant Pos := Get_Float_Size;\n-   Standard_Short_Float_Digits        : constant Pos :=\n+   Standard_Short_Float_Size          : constant Pos :=               -- SFLS\n+                                          Get_Float_Size;\n+   Standard_Short_Float_Digits        : constant Pos :=               -- SFLD\n                                           Digits_From_Size\n                                             (Standard_Short_Float_Size);\n \n-   Standard_Float_Size                : constant Pos := Get_Float_Size;\n-   Standard_Float_Digits              : constant Pos :=\n+   Standard_Float_Size                : constant Pos :=               -- FLTS\n+                                          Get_Float_Size;\n+   Standard_Float_Digits              : constant Pos :=               -- FLTD\n                                           Digits_From_Size\n                                             (Standard_Float_Size);\n \n-   Standard_Long_Float_Size           : constant Pos := Get_Double_Size;\n-   Standard_Long_Float_Digits         : constant Pos :=\n+   Standard_Long_Float_Size           : constant Pos :=               -- LFLS\n+                                          Get_Double_Size;\n+   Standard_Long_Float_Digits         : constant Pos :=               -- LFLD\n                                           Digits_From_Size\n                                             (Standard_Long_Float_Size);\n \n-   Standard_Long_Long_Float_Size      : constant Pos := Get_Long_Double_Size;\n-   Standard_Long_Long_Float_Digits    : constant Pos :=\n+   Standard_Long_Long_Float_Size      : constant Pos :=               -- LLFS\n+                                          Get_Long_Double_Size;\n+   Standard_Long_Long_Float_Digits    : constant Pos :=               -- LLFD\n                                           Digits_From_Size\n                                             (Standard_Long_Long_Float_Size);\n \n-   Standard_Character_Size            : constant Pos := Get_Char_Size;\n+   Standard_Character_Size            : constant Pos :=               -- CHAS\n+                                          Get_Char_Size;\n \n-   Standard_Wide_Character_Size       : constant Pos := 16;\n-   Standard_Wide_Wide_Character_Size  : constant Pos := 32;\n+   Standard_Wide_Character_Size       : constant Pos := 16;           -- WCHS\n+   Standard_Wide_Wide_Character_Size  : constant Pos := 32;           -- WWCS\n    --  Standard wide character sizes\n \n    --  Note: there is no specific control over the representation of\n@@ -166,18 +187,19 @@ package Ttypes is\n    -- Target-Dependent Values for Types in System --\n    -------------------------------------------------\n \n-   System_Address_Size : constant Pos := Get_Pointer_Size;\n+   System_Address_Size : constant Pos := Get_Pointer_Size;            -- ADRS\n    --  System.Address'Size (also size of all thin pointers)\n \n-   System_Max_Binary_Modulus_Power : constant Pos :=\n+   System_Max_Binary_Modulus_Power : constant Pos :=                  -- MBMP\n                                        Standard_Long_Long_Integer_Size;\n \n-   System_Max_Nonbinary_Modulus_Power : constant Pos := Standard_Integer_Size;\n+   System_Max_Nonbinary_Modulus_Power : constant Pos :=               -- MNMP\n+                                          Standard_Integer_Size;\n \n-   System_Storage_Unit : constant Pos := Get_Bits_Per_Unit;\n-   System_Word_Size    : constant Pos := Get_Bits_Per_Word;\n+   System_Storage_Unit : constant Pos := Get_Bits_Per_Unit;           -- SUNI\n+   System_Word_Size    : constant Pos := Get_Bits_Per_Word;           -- WRDS\n \n-   System_Tick_Nanoseconds : constant Pos := 1_000_000_000;\n+   System_Tick_Nanoseconds : constant Pos := 1_000_000_000;           -- TICK\n    --  Value of System.Tick in nanoseconds. At the moment, this is a fixed\n    --  constant (with value of 1.0 seconds), but later we should add this\n    --  value to the GCC configuration file so that its value can be made\n@@ -187,25 +209,25 @@ package Ttypes is\n    -- Target-Dependent Values for Types in Interfaces --\n    -----------------------------------------------------\n \n-   Interfaces_Wchar_T_Size : constant Pos := Get_Wchar_T_Size;\n+   Interfaces_Wchar_T_Size : constant Pos := Get_Wchar_T_Size;        -- WCTS\n \n    ----------------------------------------\n    -- Other Target-Dependent Definitions --\n    ----------------------------------------\n \n-   Maximum_Alignment : constant Pos := Get_Maximum_Alignment;\n+   Maximum_Alignment : constant Pos := Get_Maximum_Alignment;        -- MAXA\n    --  The maximum alignment, in storage units, that an object or type may\n    --  require on the target machine.\n \n-   System_Allocator_Alignment : constant Pos :=\n+   System_Allocator_Alignment : constant Pos :=                      -- ALLA\n                                   Get_System_Allocator_Alignment;\n    --  The alignment in storage units of addresses returned by malloc\n \n-   Max_Unaligned_Field : constant Pos := Get_Max_Unaligned_Field;\n+   Max_Unaligned_Field : constant Pos := Get_Max_Unaligned_Field;    -- MUNF\n    --  The maximum supported size in bits for a field that is not aligned\n    --  on a storage unit boundary.\n \n-   Bytes_Big_Endian : Boolean := Get_Bytes_BE /= 0;\n+   Bytes_Big_Endian : Boolean := Get_Bytes_BE /= 0;                  -- BEND\n    --  Important note: for Ada purposes, the important setting is the bytes\n    --  endianness (Bytes_Big_Endian), not the bits value (Bits_Big_Endian).\n    --  This is because Ada bit addressing must be compatible with the byte\n@@ -215,15 +237,20 @@ package Ttypes is\n    --  and thus relevant only to the back end. Note that this is a variable\n    --  rather than a constant, since it can be modified (flipped) by -gnatd8.\n \n-   Target_Strict_Alignment : Boolean := Get_Strict_Alignment /= 0;\n-   --  True if instructions will fail if data is misaligned\n+   Target_Strict_Alignment : Boolean :=                               -- STRA\n+                               Get_Strict_Alignment /= 0;\n+   --  True if instructions will fail if data is misaligned. Note that this\n+   --  is a variable rather than a constant since it can be modified (set to\n+   --  True) if the debug flag -gnatd.A is used.\n \n-   Target_Double_Float_Alignment : Nat := Get_Double_Float_Alignment;\n+   Target_Double_Float_Alignment : constant Nat :=                    -- DFLA\n+                                     Get_Double_Float_Alignment;\n    --  The default alignment of \"double\" floating-point types, i.e. floating\n    --  point types whose size is equal to 64 bits, or 0 if this alignment is\n    --  not specifically capped.\n \n-   Target_Double_Scalar_Alignment : Nat := Get_Double_Scalar_Alignment;\n+   Target_Double_Scalar_Alignment : constant Nat :=                   -- DSCA\n+                                      Get_Double_Scalar_Alignment;\n    --  The default alignment of \"double\" or larger scalar types, i.e. scalar\n    --  types whose size is greater or equal to 64 bits, or 0 if this alignment\n    --  is not specifically capped."}, {"sha": "6b6605d8eb6e8587e607b90624f60c074293e29f", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e29ae8259c54bdc25e82b3e71c956cde0a49a99/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=5e29ae8259c54bdc25e82b3e71c956cde0a49a99", "patch": "@@ -232,6 +232,11 @@ begin\n    Write_Switch_Char (\"eS\");\n    Write_Line (\"Generate SCO (Source Coverage Obligation) information\");\n \n+   --  Line for -gnatet switch\n+\n+   Write_Switch_Char (\"et\");\n+   Write_Line (\"Generate target dependent information in ALI file\");\n+\n    --  Line for -gnateV switch\n \n    Write_Switch_Char (\"eV\");"}]}