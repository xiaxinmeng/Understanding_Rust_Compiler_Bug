{"sha": "91004436daaf8d54daa467908d1b634a1a352707", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwMDQ0MzZkYWFmOGQ1NGRhYTQ2NzkwOGQxYjYzNGExYTM1MjcwNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-13T19:11:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-13T19:11:07Z"}, "message": "libstdc++: Avoid more 32-bit time_t overflows in futex calls\n\nThis fixes another overflow in code converting a std::chrono::seconds\nduration to a time_t. This time in the new code using a futex wait with\nan absolute timeout (so this one doesn't need to be backported to the\nrelease branches).\n\nA timeout after the epochalypse would overflow the tv_sec field,\nproducing an incorrect value. If that incorrect value happened to be\nnegative, the syscall would return with EINVAL and then the caller would\nkeep retrying, spinning until the timeout was reached.  If the value\nhappened to be positive, we would wake up too soon and incorrectly\nreport a timeout\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++11/futex.cc (relative_timespec): Add [[unlikely]]\n\tattributes.\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until)\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until_steady):\n\tCheck for overflow.\n\t* testsuite/30_threads/future/members/wait_until_overflow.cc:\n\tNew test.", "tree": {"sha": "2f449da8e4fab14f7f038e609453b7392393e863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f449da8e4fab14f7f038e609453b7392393e863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91004436daaf8d54daa467908d1b634a1a352707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91004436daaf8d54daa467908d1b634a1a352707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91004436daaf8d54daa467908d1b634a1a352707", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91004436daaf8d54daa467908d1b634a1a352707/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "500e7efee91cc66f91f993f53039983f131f7075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500e7efee91cc66f91f993f53039983f131f7075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500e7efee91cc66f91f993f53039983f131f7075"}], "stats": {"total": 84, "additions": 70, "deletions": 14}, "files": [{"sha": "15959cebee57c6c785437ac27525cdf7d84a3a8f", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91004436daaf8d54daa467908d1b634a1a352707/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91004436daaf8d54daa467908d1b634a1a352707/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=91004436daaf8d54daa467908d1b634a1a352707", "patch": "@@ -51,6 +51,8 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  using __gnu_cxx::__int_traits;\n+\n namespace\n {\n   std::atomic<bool> futex_clock_realtime_unavailable;\n@@ -74,10 +76,10 @@ namespace\n     auto rel_s = abs_s.count() - now_s;\n \n     // Avoid overflows\n-    if (rel_s > __gnu_cxx::__int_traits<time_t>::__max)\n-      rel_s = __gnu_cxx::__int_traits<time_t>::__max;\n-    else if (rel_s < __gnu_cxx::__int_traits<time_t>::__min)\n-      rel_s = __gnu_cxx::__int_traits<time_t>::__min;\n+    if (rel_s > __int_traits<time_t>::__max) [[unlikely]]\n+      rel_s = __int_traits<time_t>::__max;\n+    else if (rel_s < __int_traits<time_t>::__min) [[unlikely]]\n+      rel_s = __int_traits<time_t>::__min;\n \n     // Convert the absolute timeout value to a relative timeout\n     rt.tv_sec = rel_s;\n@@ -111,14 +113,17 @@ namespace\n       {\n \tif (!futex_clock_realtime_unavailable.load(std::memory_order_relaxed))\n \t  {\n-\t    struct timespec rt;\n-\t    rt.tv_sec = __s.count();\n-\t    rt.tv_nsec = __ns.count();\n-\n \t    // futex sets errno=EINVAL for absolute timeouts before the epoch.\n-\t    if (__builtin_expect(rt.tv_sec < 0, false))\n+\t    if (__s.count() < 0)\n \t      return false;\n \n+\t    struct timespec rt;\n+\t    if (__s.count() > __int_traits<time_t>::__max) [[unlikely]]\n+\t      rt.tv_sec = __int_traits<time_t>::__max;\n+\t    else\n+\t      rt.tv_sec = __s.count();\n+\t    rt.tv_nsec = __ns.count();\n+\n \t    if (syscall (SYS_futex, __addr,\n \t\t\t futex_wait_bitset_op | futex_clock_realtime_flag,\n \t\t\t __val, &rt, nullptr, futex_bitset_match_any) == -1)\n@@ -184,14 +189,17 @@ namespace\n       {\n \tif (!futex_clock_monotonic_unavailable.load(std::memory_order_relaxed))\n \t  {\n-\t    struct timespec rt;\n-\t    rt.tv_sec = __s.count();\n-\t    rt.tv_nsec = __ns.count();\n-\n \t    // futex sets errno=EINVAL for absolute timeouts before the epoch.\n-\t    if (__builtin_expect(rt.tv_sec < 0, false))\n+\t    if (__s.count() < 0) [[unlikely]]\n \t      return false;\n \n+\t    struct timespec rt;\n+\t    if (__s.count() > __int_traits<time_t>::__max) [[unlikely]]\n+\t      rt.tv_sec = __int_traits<time_t>::__max;\n+\t    else\n+\t      rt.tv_sec = __s.count();\n+\t    rt.tv_nsec = __ns.count();\n+\n \t    if (syscall (SYS_futex, __addr,\n \t\t\t futex_wait_bitset_op | futex_clock_monotonic_flag,\n \t\t\t __val, &rt, nullptr, futex_bitset_match_any) == -1)"}, {"sha": "8d6a5148ce3c751d821ac624ca682102211d805a", "filename": "libstdc++-v3/testsuite/30_threads/future/members/wait_until_overflow.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91004436daaf8d54daa467908d1b634a1a352707/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fwait_until_overflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91004436daaf8d54daa467908d1b634a1a352707/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fwait_until_overflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fwait_until_overflow.cc?ref=91004436daaf8d54daa467908d1b634a1a352707", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do run }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <chrono>\n+#include <climits>\n+#include <testsuite_hooks.h>\n+\n+namespace chrono = std::chrono;\n+\n+void test01()\n+{\n+  std::future<void> fut = std::async(std::launch::async, [] {\n+    std::this_thread::sleep_for(chrono::seconds(4));\n+  });\n+\n+  // A time in the distant future, but which overflows 32-bit time_t:\n+  auto then = chrono::system_clock::now() + chrono::seconds(UINT_MAX + 2LL);\n+  auto status = fut.wait_until(then);\n+  // The wait_until call should have waited for the result to be ready.\n+  // If converting the time_point to time_t overflows, it will timeout.\n+  VERIFY(status == std::future_status::ready);\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}