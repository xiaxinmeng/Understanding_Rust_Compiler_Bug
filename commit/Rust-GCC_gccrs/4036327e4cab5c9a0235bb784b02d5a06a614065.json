{"sha": "4036327e4cab5c9a0235bb784b02d5a06a614065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzNjMyN2U0Y2FiNWM5YTAyMzViYjc4NGIwMmQ1YTA2YTYxNDA2NQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-05-04T13:41:34Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-05-14T15:38:24Z"}, "message": "arm: Factorize several occurrences of the same code into reg_needs_saving_p\n\nThe same code pattern occurs in several functions, so it seems cleaner\nto move it into a dedicated function.\n\n2020-05-14  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/arm.c (reg_needs_saving_p): New function.\n\t(use_return_insn): Use reg_needs_saving_p.\n\t(arm_get_vfp_saved_size): Likewise.\n\t(arm_compute_frame_layout): Likewise.\n\t(arm_save_coproc_regs): Likewise.\n\t(thumb1_expand_epilogue): Likewise.\n\t(arm_expand_epilogue_apcs_frame): Likewise.\n\t(arm_expand_epilogue): Likewise.", "tree": {"sha": "4b9785dc66667ce1525c1b6f591c93070576d69b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b9785dc66667ce1525c1b6f591c93070576d69b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4036327e4cab5c9a0235bb784b02d5a06a614065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4036327e4cab5c9a0235bb784b02d5a06a614065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4036327e4cab5c9a0235bb784b02d5a06a614065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4036327e4cab5c9a0235bb784b02d5a06a614065/comments", "author": null, "committer": null, "parents": [{"sha": "f664bd07f081d08a3c30b95eab01e7ed1329700c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f664bd07f081d08a3c30b95eab01e7ed1329700c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f664bd07f081d08a3c30b95eab01e7ed1329700c"}], "stats": {"total": 55, "additions": 33, "deletions": 22}, "files": [{"sha": "156fd6cc8dc310fe5da557d7edea6cf3d63c9d37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4036327e4cab5c9a0235bb784b02d5a06a614065/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4036327e4cab5c9a0235bb784b02d5a06a614065/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4036327e4cab5c9a0235bb784b02d5a06a614065", "patch": "@@ -1,3 +1,14 @@\n+2020-05-14  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* config/arm/arm.c (reg_needs_saving_p): New function.\n+\t(use_return_insn): Use reg_needs_saving_p.\n+\t(arm_get_vfp_saved_size): Likewise.\n+\t(arm_compute_frame_layout): Likewise.\n+\t(arm_save_coproc_regs): Likewise.\n+\t(thumb1_expand_epilogue): Likewise.\n+\t(arm_expand_epilogue_apcs_frame): Likewise.\n+\t(arm_expand_epilogue): Likewise.\n+\n 2020-05-14  Christophe Lyon  <christophe.lyon@linaro.org>\n \n         * config/arm/arm.c (thumb1_expand_prologue): Update error message."}, {"sha": "3dab6145987395817bac42b7ebf4dc745a99cae2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4036327e4cab5c9a0235bb784b02d5a06a614065/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4036327e4cab5c9a0235bb784b02d5a06a614065/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4036327e4cab5c9a0235bb784b02d5a06a614065", "patch": "@@ -4188,6 +4188,16 @@ arm_trampoline_adjust_address (rtx addr)\n   return addr;\n }\n \f\n+/* Return 1 if REG needs to be saved.   */\n+static inline bool reg_needs_saving_p (unsigned reg)\n+{\n+  if (!df_regs_ever_live_p (reg)\n+      || call_used_or_fixed_reg_p (reg))\n+    return false;\n+  else\n+    return true;\n+}\n+\n /* Return 1 if it is possible to return using a single instruction.\n    If SIBLING is non-null, this is a test for a return before a sibling\n    call.  SIBLING is the call insn, so we can examine its register usage.  */\n@@ -4317,12 +4327,12 @@ use_return_insn (int iscond, rtx sibling)\n      since this also requires an insn.  */\n   if (TARGET_VFP_BASE)\n     for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n-      if (df_regs_ever_live_p (regno) && !call_used_or_fixed_reg_p (regno))\n+      if (reg_needs_saving_p (regno))\n \treturn 0;\n \n   if (TARGET_REALLY_IWMMXT)\n     for (regno = FIRST_IWMMXT_REGNUM; regno <= LAST_IWMMXT_REGNUM; regno++)\n-      if (df_regs_ever_live_p (regno) && ! call_used_or_fixed_reg_p (regno))\n+      if (reg_needs_saving_p (regno))\n \treturn 0;\n \n   return 1;\n@@ -20937,7 +20947,6 @@ thumb1_compute_save_core_reg_mask (void)\n   return mask;\n }\n \n-\n /* Return the number of bytes required to save VFP registers.  */\n static int\n arm_get_vfp_saved_size (void)\n@@ -20955,10 +20964,7 @@ arm_get_vfp_saved_size (void)\n \t   regno < LAST_VFP_REGNUM;\n \t   regno += 2)\n \t{\n-\t  if ((!df_regs_ever_live_p (regno)\n-\t       || call_used_or_fixed_reg_p (regno))\n-\t      && (!df_regs_ever_live_p (regno + 1)\n-\t\t  || call_used_or_fixed_reg_p (regno + 1)))\n+\t  if (!reg_needs_saving_p (regno) && !reg_needs_saving_p (regno + 1))\n \t    {\n \t      if (count > 0)\n \t\t{\n@@ -22483,8 +22489,7 @@ arm_compute_frame_layout (void)\n \t  for (regno = FIRST_IWMMXT_REGNUM;\n \t       regno <= LAST_IWMMXT_REGNUM;\n \t       regno++)\n-\t    if (df_regs_ever_live_p (regno)\n-\t\t&& !call_used_or_fixed_reg_p (regno))\n+\t    if (reg_needs_saving_p (regno))\n \t      saved += 8;\n \t}\n \n@@ -22705,8 +22710,9 @@ arm_save_coproc_regs(void)\n   unsigned start_reg;\n   rtx insn;\n \n+  if (TARGET_REALLY_IWMMXT)\n   for (reg = LAST_IWMMXT_REGNUM; reg >= FIRST_IWMMXT_REGNUM; reg--)\n-    if (df_regs_ever_live_p (reg) && !call_used_or_fixed_reg_p (reg))\n+    if (reg_needs_saving_p (reg))\n       {\n \tinsn = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n \tinsn = gen_rtx_MEM (V2SImode, insn);\n@@ -22721,9 +22727,7 @@ arm_save_coproc_regs(void)\n \n       for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n \t{\n-\t  if ((!df_regs_ever_live_p (reg) || call_used_or_fixed_reg_p (reg))\n-\t      && (!df_regs_ever_live_p (reg + 1)\n-\t\t  || call_used_or_fixed_reg_p (reg + 1)))\n+\t  if (!reg_needs_saving_p (reg) && !reg_needs_saving_p (reg + 1))\n \t    {\n \t      if (start_reg != reg)\n \t\tsaved_size += vfp_emit_fstmd (start_reg,\n@@ -27018,7 +27022,7 @@ thumb1_expand_epilogue (void)\n   /* Emit a clobber for each insn that will be restored in the epilogue,\n      so that flow2 will get register lifetimes correct.  */\n   for (regno = 0; regno < 13; regno++)\n-    if (df_regs_ever_live_p (regno) && !call_used_or_fixed_reg_p (regno))\n+    if (reg_needs_saving_p (regno))\n       emit_clobber (gen_rtx_REG (SImode, regno));\n \n   if (! df_regs_ever_live_p (LR_REGNUM))\n@@ -27084,9 +27088,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n \n       for (i = FIRST_VFP_REGNUM; i < LAST_VFP_REGNUM; i += 2)\n         /* Look for a case where a reg does not need restoring.  */\n-        if ((!df_regs_ever_live_p (i) || call_used_or_fixed_reg_p (i))\n-            && (!df_regs_ever_live_p (i + 1)\n-                || call_used_or_fixed_reg_p (i + 1)))\n+\tif (!reg_needs_saving_p (i) && !reg_needs_saving_p (i + 1))\n           {\n             if (start_reg != i)\n               arm_emit_vfp_multi_reg_pop (start_reg,\n@@ -27113,7 +27115,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n       int lrm_count = (num_regs % 2) ? (num_regs + 2) : (num_regs + 1);\n \n       for (i = LAST_IWMMXT_REGNUM; i >= FIRST_IWMMXT_REGNUM; i--)\n-        if (df_regs_ever_live_p (i) && !call_used_or_fixed_reg_p (i))\n+\tif (reg_needs_saving_p (i))\n           {\n             rtx addr = gen_frame_mem (V2SImode,\n                                  plus_constant (Pmode, hard_frame_pointer_rtx,\n@@ -27318,9 +27320,7 @@ arm_expand_epilogue (bool really_return)\n          unlike pop, vldm can only do consecutive regs.  */\n       for (i = LAST_VFP_REGNUM - 1; i >= FIRST_VFP_REGNUM; i -= 2)\n         /* Look for a case where a reg does not need restoring.  */\n-        if ((!df_regs_ever_live_p (i) || call_used_or_fixed_reg_p (i))\n-            && (!df_regs_ever_live_p (i + 1)\n-                || call_used_or_fixed_reg_p (i + 1)))\n+\tif (!reg_needs_saving_p (i) && !reg_needs_saving_p (i + 1))\n           {\n             /* Restore the regs discovered so far (from reg+2 to\n                end_reg).  */\n@@ -27342,7 +27342,7 @@ arm_expand_epilogue (bool really_return)\n \n   if (TARGET_IWMMXT)\n     for (i = FIRST_IWMMXT_REGNUM; i <= LAST_IWMMXT_REGNUM; i++)\n-      if (df_regs_ever_live_p (i) && !call_used_or_fixed_reg_p (i))\n+      if (reg_needs_saving_p (i))\n         {\n           rtx_insn *insn;\n           rtx addr = gen_rtx_MEM (V2SImode,"}]}