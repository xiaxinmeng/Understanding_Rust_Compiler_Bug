{"sha": "0af37ad4422052be4b7f779737e14c80e57d0ad9", "node_id": "C_kwDOANBUbNoAKDBhZjM3YWQ0NDIyMDUyYmU0YjdmNzc5NzM3ZTE0YzgwZTU3ZDBhZDk", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-07T19:19:30Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-07T19:19:30Z"}, "message": "analyzer: fix leak suppression at end of 'main' [PR101983]\n\nPR analyzer/101983 reports what I thought were false positives\nfrom -Wanalyzer-malloc-leak, but on closer inspection, the\nanalyzer is correctly reporting heap-allocated buffers that are\nno longer reachable.\n\nHowever, these \"leaks\" occur at the end of \"main\".  The analyzer already\nhas some logic to avoid reporting leaks at the end of main, where the\nleak is detected at the end of the EXIT basic block.  However, in this case,\nthe leak is detected at the clobber in BB 2 here:\n  <bb 2> :\n  func (&res);\n  res ={v} {CLOBBER(eol)};\n  _4 = 0;\n\n  <bb 3> :\n<L0>:\n  return _4;\n\nwhere we have a chain BB 2 -> BB 3 -> EXIT BB.\n\nThis patch generalizes the \"are we at the end of 'main'\" detection to\nhandle such cases, silencing -Wanalyzer-malloc-leak on them.\n\nThere's a remaining issue where the analyzer unhelpfully describes one\nof the leaking values as '<unknown>', rather than 'res.a', but I'm\nleaving that for a followup (covered by PR analyzer/99771).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/101983\n\t* engine.cc (returning_from_function_p): New.\n\t(impl_region_model_context::on_state_leak): Use it when rejecting\n\tleaks at the return from \"main\".\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/101983\n\t* gcc.dg/analyzer/pr101983-main.c: New test.\n\t* gcc.dg/analyzer/pr101983-not-main.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "a158d8cba01a01d7529b311ca8f0da57849c0917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a158d8cba01a01d7529b311ca8f0da57849c0917"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0af37ad4422052be4b7f779737e14c80e57d0ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af37ad4422052be4b7f779737e14c80e57d0ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0af37ad4422052be4b7f779737e14c80e57d0ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af37ad4422052be4b7f779737e14c80e57d0ad9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3ca3e7993696affe95a3ea24c2b133c14a056e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3ca3e7993696affe95a3ea24c2b133c14a056e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3ca3e7993696affe95a3ea24c2b133c14a056e4"}], "stats": {"total": 126, "additions": 124, "deletions": 2}, "files": [{"sha": "8c3133e2444ec0056d75c0de9b7a89cc9a3f1fac", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af37ad4422052be4b7f779737e14c80e57d0ad9/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af37ad4422052be4b7f779737e14c80e57d0ad9/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=0af37ad4422052be4b7f779737e14c80e57d0ad9", "patch": "@@ -740,6 +740,51 @@ readability_comparator (const void *p1, const void *p2)\n   return 0;\n }\n \n+/* Return true is SNODE is the EXIT node of a function, or is one\n+   of the final snodes within its function.\n+\n+   Specifically, handle the final supernodes before the EXIT node,\n+   for the case of clobbers that happen immediately before exiting.\n+   We need a run of snodes leading to the return_p snode, where all edges are\n+   intraprocedural, and every snode has just one successor.\n+\n+   We use this when suppressing leak reports at the end of \"main\".  */\n+\n+static bool\n+returning_from_function_p (const supernode *snode)\n+{\n+  if (!snode)\n+    return false;\n+\n+  unsigned count = 0;\n+  const supernode *iter = snode;\n+  while (true)\n+    {\n+      if (iter->return_p ())\n+\treturn true;\n+      if (iter->m_succs.length () != 1)\n+\treturn false;\n+      const superedge *sedge = iter->m_succs[0];\n+      if (sedge->get_kind () != SUPEREDGE_CFG_EDGE)\n+\treturn false;\n+      iter = sedge->m_dest;\n+\n+      /* Impose a limit to ensure we terminate for pathological cases.\n+\n+\t We only care about the final 3 nodes, due to cases like:\n+\t   BB:\n+\t     (clobber causing leak)\n+\n+\t   BB:\n+\t   <label>:\n+\t   return _val;\n+\n+\t   EXIT BB.*/\n+      if (++count > 3)\n+\treturn false;\n+    }\n+}\n+\n /* Find the best tree for SVAL and call SM's on_leak vfunc with it.\n    If on_leak returns a pending_diagnostic, queue it up to be reported,\n    so that we potentially complain about a leak of SVAL in the given STATE.  */\n@@ -794,8 +839,7 @@ impl_region_model_context::on_state_leak (const state_machine &sm,\n   gcc_assert (m_enode_for_diag);\n \n   /* Don't complain about leaks when returning from \"main\".  */\n-  if (m_enode_for_diag->get_supernode ()\n-      && m_enode_for_diag->get_supernode ()->return_p ())\n+  if (returning_from_function_p (m_enode_for_diag->get_supernode ()))\n     {\n       tree fndecl = m_enode_for_diag->get_function ()->decl;\n       if (id_equal (DECL_NAME (fndecl), \"main\"))"}, {"sha": "a84353be35a46220ee9b4615278d3a2ba9fed07a", "filename": "gcc/testsuite/gcc.dg/analyzer/pr101983-main.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af37ad4422052be4b7f779737e14c80e57d0ad9/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101983-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af37ad4422052be4b7f779737e14c80e57d0ad9/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101983-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101983-main.c?ref=0af37ad4422052be4b7f779737e14c80e57d0ad9", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex -fno-analyzer-call-summaries\" } */\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+struct list {\n+\tstruct list* next;\n+\tvoid *a;\n+};\n+\n+void func(struct list **res)\n+{\n+\tstruct list *cur = NULL;\n+\tdo {\n+\t\tstruct list *n = malloc(sizeof(struct list));\n+\t\tvoid *a = malloc(1);\n+\t\tif (n == NULL || a == NULL) {\n+\t\t\tif (n != NULL) free(n);\n+\t\t\tif (a != NULL) free(a);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (cur == NULL) {\n+\t\t\t*res = cur = n;\n+\t\t} else {\n+\t\t\tcur->next = n;\n+\t\t\tcur = n;\n+\t\t}\n+\t\tn->a = a;\n+\t} while (true);\n+}\n+\n+int main()\n+{\n+\tstruct list *res;\n+\tfunc(&res);\n+}"}, {"sha": "fbf3a393ebb6dadb42177987e528960b1b4d13c8", "filename": "gcc/testsuite/gcc.dg/analyzer/pr101983-not-main.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af37ad4422052be4b7f779737e14c80e57d0ad9/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101983-not-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af37ad4422052be4b7f779737e14c80e57d0ad9/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101983-not-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101983-not-main.c?ref=0af37ad4422052be4b7f779737e14c80e57d0ad9", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex -fno-analyzer-call-summaries\" } */\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+struct list {\n+\tstruct list* next;\n+\tvoid *a;\n+};\n+\n+void func(struct list **res)\n+{\n+\tstruct list *cur = NULL;\n+\tdo {\n+\t\tstruct list *n = malloc(sizeof(struct list));\n+\t\tvoid *a = malloc(1);\n+\t\tif (n == NULL || a == NULL) {\n+\t\t\tif (n != NULL) free(n);\n+\t\t\tif (a != NULL) free(a);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (cur == NULL) {\n+\t\t\t*res = cur = n;\n+\t\t} else {\n+\t\t\tcur->next = n;\n+\t\t\tcur = n;\n+\t\t}\n+\t\tn->a = a;\n+\t} while (true);\n+}\n+\n+int not_main()\n+{\n+\tstruct list *res;\n+\tfunc(&res);\n+} /* { dg-warning \"leak of 'res'\" \"leak of res\" } */\n+/* { dg-warning \"leak of '<unknown>'\" \"leak of res->a\" { target *-*-* } .-1 } */\n+/* TODO: we should emit 'res->a' rather than '<unknown>' here.  */"}]}