{"sha": "31cfd832864298ea34c52625312e2a0ed0478e3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjZmQ4MzI4NjQyOThlYTM0YzUyNjI1MzEyZTJhMGVkMDQ3OGUzZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2016-12-03T09:44:35Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2016-12-03T09:44:35Z"}, "message": "re PR libfortran/78379 (Processor-specific versions for matmul)\n\n2016-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n        PR fortran/78379\n        * config/i386/cpuinfo.c:  Move denums for processor vendors,\n        processor type, processor subtypes and declaration of\n        struct __processor_model into\n        * config/i386/cpuinfo.h:  New header file.\n        * Makefile.am:  Add dependence of m4/matmul_internal_m4 to\n        mamtul files..\n        * Makefile.in:  Regenerated.\n        * acinclude.m4:  Check for AVX, AVX2 and AVX512F.\n        * config.h.in:  Add HAVE_AVX, HAVE_AVX2 and HAVE_AVX512F.\n        * configure:  Regenerated.\n        * configure.ac:  Use checks for AVX, AVX2 and AVX_512F.\n        * m4/matmul_internal.m4:  New file. working part of matmul.m4.\n        * m4/matmul.m4:  Implement architecture-specific switching\n        for AVX, AVX2 and AVX512F by including matmul_internal.m4\n        multiple times.\n        * generated/matmul_c10.c: Regenerated.\n        * generated/matmul_c16.c: Regenerated.\n        * generated/matmul_c4.c: Regenerated.\n        * generated/matmul_c8.c: Regenerated.\n        * generated/matmul_i1.c: Regenerated.\n        * generated/matmul_i16.c: Regenerated.\n        * generated/matmul_i2.c: Regenerated.\n        * generated/matmul_i4.c: Regenerated.\n        * generated/matmul_i8.c: Regenerated.\n        * generated/matmul_r10.c: Regenerated.\n        * generated/matmul_r16.c: Regenerated.\n        * generated/matmul_r4.c: Regenerated.\n        * generated/matmul_r8.c: Regenerated.\n\nFrom-SVN: r243219", "tree": {"sha": "805ee1fcef7331c2ec85a41609a98bd0d41c110c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/805ee1fcef7331c2ec85a41609a98bd0d41c110c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31cfd832864298ea34c52625312e2a0ed0478e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31cfd832864298ea34c52625312e2a0ed0478e3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31cfd832864298ea34c52625312e2a0ed0478e3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31cfd832864298ea34c52625312e2a0ed0478e3d/comments", "author": null, "committer": null, "parents": [{"sha": "802583a210c22cdbabb63d660633af09f0039a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802583a210c22cdbabb63d660633af09f0039a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/802583a210c22cdbabb63d660633af09f0039a32"}], "stats": {"total": 30582, "additions": 29976, "deletions": 606}, "files": [{"sha": "efadedf850fb82b2cbdabbfc0c8b9e42390793f7", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -1,3 +1,11 @@\n+2016-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/78379\n+\t* config/i386/cpuinfo.c:  Move denums for processor vendors,\n+\tprocessor type, processor subtypes and declaration of\n+\tstruct __processor_model into\n+\t* config/i386/cpuinfo.h:  New header file.\n+\n 2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n "}, {"sha": "9f30cb88334c4d0aeb1ef3f466e4d1d8a51030a2", "filename": "libgcc/config/i386/cpuinfo.c", "status": "modified", "additions": 2, "deletions": 90, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"cpuid.h\"\n #include \"tsystem.h\"\n #include \"auto-target.h\"\n+#include \"cpuinfo.h\"\n \n #ifdef HAVE_INIT_PRIORITY\n #define CONSTRUCTOR_PRIORITY (101)\n@@ -36,97 +37,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n int __cpu_indicator_init (void)\n   __attribute__ ((constructor CONSTRUCTOR_PRIORITY));\n \n-/* Processor Vendor and Models. */\n \n-enum processor_vendor\n-{\n-  VENDOR_INTEL = 1,\n-  VENDOR_AMD,\n-  VENDOR_OTHER,\n-  VENDOR_MAX\n-};\n-\n-/* Any new types or subtypes have to be inserted at the end. */\n-\n-enum processor_types\n-{\n-  INTEL_BONNELL = 1,\n-  INTEL_CORE2,\n-  INTEL_COREI7,\n-  AMDFAM10H,\n-  AMDFAM15H,\n-  INTEL_SILVERMONT,\n-  INTEL_KNL,\n-  AMD_BTVER1,\n-  AMD_BTVER2,  \n-  AMDFAM17H,\n-  CPU_TYPE_MAX\n-};\n-\n-enum processor_subtypes\n-{\n-  INTEL_COREI7_NEHALEM = 1,\n-  INTEL_COREI7_WESTMERE,\n-  INTEL_COREI7_SANDYBRIDGE,\n-  AMDFAM10H_BARCELONA,\n-  AMDFAM10H_SHANGHAI,\n-  AMDFAM10H_ISTANBUL,\n-  AMDFAM15H_BDVER1,\n-  AMDFAM15H_BDVER2,\n-  AMDFAM15H_BDVER3,\n-  AMDFAM15H_BDVER4,\n-  AMDFAM17H_ZNVER1,\n-  INTEL_COREI7_IVYBRIDGE,\n-  INTEL_COREI7_HASWELL,\n-  INTEL_COREI7_BROADWELL,\n-  INTEL_COREI7_SKYLAKE,\n-  INTEL_COREI7_SKYLAKE_AVX512,\n-  CPU_SUBTYPE_MAX\n-};\n-\n-/* ISA Features supported. New features have to be inserted at the end.  */\n-\n-enum processor_features\n-{\n-  FEATURE_CMOV = 0,\n-  FEATURE_MMX,\n-  FEATURE_POPCNT,\n-  FEATURE_SSE,\n-  FEATURE_SSE2,\n-  FEATURE_SSE3,\n-  FEATURE_SSSE3,\n-  FEATURE_SSE4_1,\n-  FEATURE_SSE4_2,\n-  FEATURE_AVX,\n-  FEATURE_AVX2,\n-  FEATURE_SSE4_A,\n-  FEATURE_FMA4,\n-  FEATURE_XOP,\n-  FEATURE_FMA,\n-  FEATURE_AVX512F,\n-  FEATURE_BMI,\n-  FEATURE_BMI2,\n-  FEATURE_AES,\n-  FEATURE_PCLMUL,\n-  FEATURE_AVX512VL,\n-  FEATURE_AVX512BW,\n-  FEATURE_AVX512DQ,\n-  FEATURE_AVX512CD,\n-  FEATURE_AVX512ER,\n-  FEATURE_AVX512PF,\n-  FEATURE_AVX512VBMI,\n-  FEATURE_AVX512IFMA,\n-  FEATURE_AVX5124VNNIW,\n-  FEATURE_AVX5124FMAPS\n-};\n-\n-struct __processor_model\n-{\n-  unsigned int __cpu_vendor;\n-  unsigned int __cpu_type;\n-  unsigned int __cpu_subtype;\n-  unsigned int __cpu_features[1];\n-} __cpu_model = { };\n+struct __processor_model __cpu_model = { };\n \n \n /* Get the specific type of AMD CPU.  */"}, {"sha": "cf848e690aecbcb7c9e882410aa341f36afdfdd1", "filename": "libgcc/config/i386/cpuinfo.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -0,0 +1,116 @@\n+/* Get CPU type and Features for x86 processors.\n+   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n+   Contributed by Sriraman Tallam (tmsriram@google.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Processor Vendor and Models. */\n+\n+enum processor_vendor\n+{\n+  VENDOR_INTEL = 1,\n+  VENDOR_AMD,\n+  VENDOR_OTHER,\n+  VENDOR_MAX\n+};\n+\n+/* Any new types or subtypes have to be inserted at the end. */\n+\n+enum processor_types\n+{\n+  INTEL_BONNELL = 1,\n+  INTEL_CORE2,\n+  INTEL_COREI7,\n+  AMDFAM10H,\n+  AMDFAM15H,\n+  INTEL_SILVERMONT,\n+  INTEL_KNL,\n+  AMD_BTVER1,\n+  AMD_BTVER2,  \n+  AMDFAM17H,\n+  CPU_TYPE_MAX\n+};\n+\n+enum processor_subtypes\n+{\n+  INTEL_COREI7_NEHALEM = 1,\n+  INTEL_COREI7_WESTMERE,\n+  INTEL_COREI7_SANDYBRIDGE,\n+  AMDFAM10H_BARCELONA,\n+  AMDFAM10H_SHANGHAI,\n+  AMDFAM10H_ISTANBUL,\n+  AMDFAM15H_BDVER1,\n+  AMDFAM15H_BDVER2,\n+  AMDFAM15H_BDVER3,\n+  AMDFAM15H_BDVER4,\n+  AMDFAM17H_ZNVER1,\n+  INTEL_COREI7_IVYBRIDGE,\n+  INTEL_COREI7_HASWELL,\n+  INTEL_COREI7_BROADWELL,\n+  INTEL_COREI7_SKYLAKE,\n+  INTEL_COREI7_SKYLAKE_AVX512,\n+  CPU_SUBTYPE_MAX\n+};\n+\n+/* ISA Features supported. New features have to be inserted at the end.  */\n+\n+enum processor_features\n+{\n+  FEATURE_CMOV = 0,\n+  FEATURE_MMX,\n+  FEATURE_POPCNT,\n+  FEATURE_SSE,\n+  FEATURE_SSE2,\n+  FEATURE_SSE3,\n+  FEATURE_SSSE3,\n+  FEATURE_SSE4_1,\n+  FEATURE_SSE4_2,\n+  FEATURE_AVX,\n+  FEATURE_AVX2,\n+  FEATURE_SSE4_A,\n+  FEATURE_FMA4,\n+  FEATURE_XOP,\n+  FEATURE_FMA,\n+  FEATURE_AVX512F,\n+  FEATURE_BMI,\n+  FEATURE_BMI2,\n+  FEATURE_AES,\n+  FEATURE_PCLMUL,\n+  FEATURE_AVX512VL,\n+  FEATURE_AVX512BW,\n+  FEATURE_AVX512DQ,\n+  FEATURE_AVX512CD,\n+  FEATURE_AVX512ER,\n+  FEATURE_AVX512PF,\n+  FEATURE_AVX512VBMI,\n+  FEATURE_AVX512IFMA,\n+  FEATURE_AVX5124VNNIW,\n+  FEATURE_AVX5124FMAPS\n+};\n+\n+extern struct __processor_model\n+{\n+  unsigned int __cpu_vendor;\n+  unsigned int __cpu_type;\n+  unsigned int __cpu_subtype;\n+  unsigned int __cpu_features[1];\n+} __cpu_model;"}, {"sha": "03ff0633d183932e900005086ad63d872a97849c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -1,3 +1,31 @@\n+2016-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/78379\n+\t* Makefile.am:  Add dependence of m4/matmul_internal_m4 to\n+\tmamtul files..\n+\t* Makefile.in:  Regenerated.\n+\t* acinclude.m4:  Check for AVX, AVX2 and AVX512F.\n+\t* config.h.in:  Add HAVE_AVX, HAVE_AVX2 and HAVE_AVX512F.\n+\t* configure:  Regenerated.\n+\t* configure.ac:  Use checks for AVX, AVX2 and AVX_512F.\n+\t* m4/matmul_internal.m4:  New file. working part of matmul.m4.\n+\t* m4/matmul.m4:  Implement architecture-specific switching\n+\tfor AVX, AVX2 and AVX512F by including matmul_internal.m4\n+\tmultiple times.\n+\t* generated/matmul_c10.c: Regenerated.\n+        * generated/matmul_c16.c: Regenerated.\n+        * generated/matmul_c4.c: Regenerated.\n+        * generated/matmul_c8.c: Regenerated.\n+        * generated/matmul_i1.c: Regenerated.\n+        * generated/matmul_i16.c: Regenerated.\n+        * generated/matmul_i2.c: Regenerated.\n+        * generated/matmul_i4.c: Regenerated.\n+        * generated/matmul_i8.c: Regenerated.\n+        * generated/matmul_r10.c: Regenerated.\n+        * generated/matmul_r16.c: Regenerated.\n+        * generated/matmul_r4.c: Regenerated.\n+        * generated/matmul_r8.c: Regenerated.\n+\n 2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* caf/single.c (_gfortran_caf_get_by_ref): Prevent compile time"}, {"sha": "6137d88c997a97d9fee5f8b3ec12a9102bde035b", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -987,7 +987,7 @@ $(i_product_c): m4/product.m4 $(I_M4_DEPS1)\n $(i_sum_c): m4/sum.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 sum.m4 > $@\n \n-$(i_matmul_c): m4/matmul.m4 $(I_M4_DEPS)\n+$(i_matmul_c): m4/matmul.m4 m4/matmul_internal.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmul.m4 > $@\n \n $(i_matmull_c): m4/matmull.m4 $(I_M4_DEPS)"}, {"sha": "4d95723ae59abf66b13dd2a77afe50397fa364ba", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -6053,7 +6053,7 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_sum_c): m4/sum.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 sum.m4 > $@\n \n-@MAINTAINER_MODE_TRUE@$(i_matmul_c): m4/matmul.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@$(i_matmul_c): m4/matmul.m4 m4/matmul_internal.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 matmul.m4 > $@\n \n @MAINTAINER_MODE_TRUE@$(i_matmull_c): m4/matmull.m4 $(I_M4_DEPS)"}, {"sha": "9a7f461af3c4f362a13719d1959c511722d04d13", "filename": "libgfortran/acinclude.m4", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Facinclude.m4?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -393,3 +393,54 @@ AC_DEFUN([LIBGFOR_CHECK_STRERROR_R], [\n \t\t  [Define if strerror_r takes two arguments and is available in <string.h>.]),)\n   CFLAGS=\"$ac_save_CFLAGS\"\n ])\n+\n+dnl Check for AVX\n+\n+AC_DEFUN([LIBGFOR_CHECK_AVX], [\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx\"\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+  void _mm256_zeroall (void)\n+        {\n+           __builtin_ia32_vzeroall ();\n+        }]], [[]])],\n+\tAC_DEFINE(HAVE_AVX, 1,\n+\t[Define if AVX instructions can be compiled.]),\n+\t[])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+])\n+\n+dnl Check for AVX2\n+\n+AC_DEFUN([LIBGFOR_CHECK_AVX2], [\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx2\"\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+  typedef long long __v4di __attribute__ ((__vector_size__ (32)));\n+\t__v4di\n+\tmm256_is32_andnotsi256  (__v4di __X, __v4di __Y)\n+        {\n+\t   return __builtin_ia32_andnotsi256 (__X, __Y);\n+        }]], [[]])],\n+\tAC_DEFINE(HAVE_AVX2, 1,\n+\t[Define if AVX2 instructions can be compiled.]),\n+\t[])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+])\n+\n+dnl Check for AVX512f\n+\n+AC_DEFUN([LIBGFOR_CHECK_AVX512F], [\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx512f\"\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+\ttypedef double __m512d __attribute__ ((__vector_size__ (64)));\n+\t__m512d _mm512_add (__m512d a)\n+\t{\n+\t  return __builtin_ia32_addpd512_mask (a, a, a, 1, 4);\n+        }]], [[]])],\n+\tAC_DEFINE(HAVE_AVX512F, 1,\n+\t[Define if AVX512f instructions can be compiled.]),\n+\t[])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+])"}, {"sha": "b762d0990b65f419b4b5b602ae7feeba234013a2", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -78,6 +78,15 @@\n /* Define to 1 if the target supports __attribute__((visibility(...))). */\n #undef HAVE_ATTRIBUTE_VISIBILITY\n \n+/* Define if AVX instructions can be compiled. */\n+#undef HAVE_AVX\n+\n+/* Define if AVX2 instructions can be compiled. */\n+#undef HAVE_AVX2\n+\n+/* Define if AVX512f instructions can be compiled. */\n+#undef HAVE_AVX512F\n+\n /* Define to 1 if you have the `cabs' function. */\n #undef HAVE_CABS\n "}, {"sha": "45ef93550f26b2e53cd7c913eaaeddb4e9256b65", "filename": "libgfortran/configure", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -26174,6 +26174,93 @@ $as_echo \"#define HAVE_CRLF 1\" >>confdefs.h\n \n fi\n \n+# Check whether we support AVX extensions\n+\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+  void _mm256_zeroall (void)\n+        {\n+           __builtin_ia32_vzeroall ();\n+        }\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_AVX 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+\n+\n+# Check wether we support AVX2 extensions\n+\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx2\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+  typedef long long __v4di __attribute__ ((__vector_size__ (32)));\n+\t__v4di\n+\tmm256_is32_andnotsi256  (__v4di __X, __v4di __Y)\n+        {\n+\t   return __builtin_ia32_andnotsi256 (__X, __Y);\n+        }\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_AVX2 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+\n+\n+# Check wether we support AVX512f extensions\n+\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"-O2 -mavx512f\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\ttypedef double __m512d __attribute__ ((__vector_size__ (64)));\n+\t__m512d _mm512_add (__m512d a)\n+\t{\n+\t  return __builtin_ia32_addpd512_mask (a, a, a, 1, 4);\n+        }\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+\n+$as_echo \"#define HAVE_AVX512F 1\" >>confdefs.h\n+\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+\n+\n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n # tests run on this system so they can be shared between configure"}, {"sha": "bb84bafefb72b1211a07eb6404fb34face8f4cdd", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -609,6 +609,15 @@ LIBGFOR_CHECK_UNLINK_OPEN_FILE\n # Check whether line terminator is LF or CRLF\n LIBGFOR_CHECK_CRLF\n \n+# Check whether we support AVX extensions\n+LIBGFOR_CHECK_AVX\n+\n+# Check wether we support AVX2 extensions\n+LIBGFOR_CHECK_AVX2\n+\n+# Check wether we support AVX512f extensions\n+LIBGFOR_CHECK_AVX512F\n+\n AC_CACHE_SAVE\n \n if test ${multilib} = yes; then"}, {"sha": "bf40e375b8205fc6e8f454cbfc83fd1b17b887c2", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_c10 (gfc_array_c10 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c10);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_c10_avx (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_c10_avx (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_10 * restrict abase;\n+  const GFC_COMPLEX_10 * restrict bbase;\n+  GFC_COMPLEX_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_c10_avx2 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_c10_avx2 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_10 * restrict abase;\n+  const GFC_COMPLEX_10 * restrict bbase;\n+  GFC_COMPLEX_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_c10_avx512f (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_c10_avx512f (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_10 * restrict abase;\n+  const GFC_COMPLEX_10 * restrict bbase;\n+  GFC_COMPLEX_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_c10_vanilla (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_10 * restrict abase;\n+  const GFC_COMPLEX_10 * restrict bbase;\n+  GFC_COMPLEX_10 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict abase_x;\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 *restrict dest_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_10) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_10 *restrict bbase_y;\n+\t  GFC_COMPLEX_10 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_10)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_10) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_c10 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_c10_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_c10_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_c10_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_c10_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_c10 (gfc_array_c10 * const restrict retarray, \n \tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "6e4545da8f6773c14a4b6ce425728b390098d24b", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_c16 (gfc_array_c16 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c16);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_c16_avx (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_c16_avx (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_16 * restrict abase;\n+  const GFC_COMPLEX_16 * restrict bbase;\n+  GFC_COMPLEX_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_c16_avx2 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_c16_avx2 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_16 * restrict abase;\n+  const GFC_COMPLEX_16 * restrict bbase;\n+  GFC_COMPLEX_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_c16_avx512f (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_c16_avx512f (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_16 * restrict abase;\n+  const GFC_COMPLEX_16 * restrict bbase;\n+  GFC_COMPLEX_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_c16_vanilla (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_16 * restrict abase;\n+  const GFC_COMPLEX_16 * restrict bbase;\n+  GFC_COMPLEX_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict abase_x;\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 *restrict dest_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_16 *restrict bbase_y;\n+\t  GFC_COMPLEX_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_c16 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_c16_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_c16_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_c16_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_c16_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_c16 (gfc_array_c16 * const restrict retarray, \n \tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "6f7d5c2115e8cafb973816f6d6c9f0da6763ec94", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_c4 (gfc_array_c4 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c4);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_c4_avx (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_c4_avx (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_4 * restrict abase;\n+  const GFC_COMPLEX_4 * restrict bbase;\n+  GFC_COMPLEX_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_c4_avx2 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_c4_avx2 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_4 * restrict abase;\n+  const GFC_COMPLEX_4 * restrict bbase;\n+  GFC_COMPLEX_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_c4_avx512f (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_c4_avx512f (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_4 * restrict abase;\n+  const GFC_COMPLEX_4 * restrict bbase;\n+  GFC_COMPLEX_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_c4_vanilla (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_4 * restrict abase;\n+  const GFC_COMPLEX_4 * restrict bbase;\n+  GFC_COMPLEX_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict abase_x;\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 *restrict dest_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_4 *restrict bbase_y;\n+\t  GFC_COMPLEX_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_c4 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_c4_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_c4_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_c4_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_c4_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_c4 (gfc_array_c4 * const restrict retarray, \n \tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "06916c334e10ded07765b79066674b69fc62da4c", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_c8 (gfc_array_c8 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c8);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_c8_avx (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_c8_avx (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_8 * restrict abase;\n+  const GFC_COMPLEX_8 * restrict bbase;\n+  GFC_COMPLEX_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_c8_avx2 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_c8_avx2 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_8 * restrict abase;\n+  const GFC_COMPLEX_8 * restrict bbase;\n+  GFC_COMPLEX_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_c8_avx512f (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_c8_avx512f (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_8 * restrict abase;\n+  const GFC_COMPLEX_8 * restrict bbase;\n+  GFC_COMPLEX_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_c8_vanilla (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_8 * restrict abase;\n+  const GFC_COMPLEX_8 * restrict bbase;\n+  GFC_COMPLEX_8 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict abase_x;\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 *restrict dest_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_8) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_8 *restrict bbase_y;\n+\t  GFC_COMPLEX_8 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_8)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_8) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_c8 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_c8_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_c8_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_c8_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_c8_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_c8 (gfc_array_c8 * const restrict retarray, \n \tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "2cce9d13b9f31866fc9dcbd10b2aa24609ec16e3", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_i1 (gfc_array_i1 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i1);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_i1_avx (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_i1_avx (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_i1_avx2 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_i1_avx2 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_i1_avx512f (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_i1_avx512f (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_i1_vanilla (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_1 * restrict abase;\n+  const GFC_INTEGER_1 * restrict bbase;\n+  GFC_INTEGER_1 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_1 *restrict abase_x;\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 *restrict dest_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_1) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_1 *restrict bbase_y;\n+\t  GFC_INTEGER_1 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_1)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_1) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_1 *restrict abase_x;\n+      const GFC_INTEGER_1 *restrict bbase_y;\n+      GFC_INTEGER_1 *restrict dest_y;\n+      GFC_INTEGER_1 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_1) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_i1_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_i1_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_i1_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_i1_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_i1 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "76a605fb759d4c01cf22a99da9b0a50e1e3d9f00", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_i16 (gfc_array_i16 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i16);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_i16_avx (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_i16_avx (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_16 * restrict abase;\n+  const GFC_INTEGER_16 * restrict bbase;\n+  GFC_INTEGER_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_i16_avx2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_i16_avx2 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_16 * restrict abase;\n+  const GFC_INTEGER_16 * restrict bbase;\n+  GFC_INTEGER_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_i16_avx512f (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_i16_avx512f (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_16 * restrict abase;\n+  const GFC_INTEGER_16 * restrict bbase;\n+  GFC_INTEGER_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_i16_vanilla (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_16 * restrict abase;\n+  const GFC_INTEGER_16 * restrict bbase;\n+  GFC_INTEGER_16 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_16 *restrict abase_x;\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 *restrict dest_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_16) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_16 *restrict bbase_y;\n+\t  GFC_INTEGER_16 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_16)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_16) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_i16_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_i16_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_i16_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_i16_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "324197a013d46e2d89db3fceeb1175c93e90ba85", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_i2 (gfc_array_i2 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i2);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_i2_avx (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_i2_avx (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_i2_avx2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_i2_avx2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_i2_avx512f (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_i2_avx512f (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_i2_vanilla (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_2 * restrict abase;\n+  const GFC_INTEGER_2 * restrict bbase;\n+  GFC_INTEGER_2 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_2 *restrict abase_x;\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 *restrict dest_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_2) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_2 *restrict bbase_y;\n+\t  GFC_INTEGER_2 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_2)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_2) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_2 *restrict abase_x;\n+      const GFC_INTEGER_2 *restrict bbase_y;\n+      GFC_INTEGER_2 *restrict dest_y;\n+      GFC_INTEGER_2 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_2) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_i2_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_i2_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_i2_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_i2_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_i2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "bd31c7cebe5b0113bf4864cbd268969d004be6fa", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 2233, "deletions": 0, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d", "patch": "@@ -75,6 +75,2233 @@ extern void matmul_i4 (gfc_array_i4 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i4);\n \n+\n+\n+\n+/* Put exhaustive list of possible architectures here here, ORed together.  */\n+\n+#if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n+\n+#ifdef HAVE_AVX\n+static void\n+matmul_i4_avx (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx\")));\n+static void\n+matmul_i4_avx (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_4 * restrict abase;\n+  const GFC_INTEGER_4 * restrict bbase;\n+  GFC_INTEGER_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX */\n+\n+#ifdef HAVE_AVX2\n+static void\n+matmul_i4_avx2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+static void\n+matmul_i4_avx2 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_4 * restrict abase;\n+  const GFC_INTEGER_4 * restrict bbase;\n+  GFC_INTEGER_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif /* HAVE_AVX2 */\n+\n+#ifdef HAVE_AVX512F\n+static void\n+matmul_i4_avx512f (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx512f\")));\n+static void\n+matmul_i4_avx512f (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_4 * restrict abase;\n+  const GFC_INTEGER_4 * restrict bbase;\n+  GFC_INTEGER_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif  /* HAVE_AVX512F */\n+\n+/* Function to fall back to if there is no special processor-specific version.  */\n+static void\n+matmul_i4_vanilla (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_INTEGER_4 * restrict abase;\n+  const GFC_INTEGER_4 * restrict bbase;\n+  GFC_INTEGER_4 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"dimension of array B incorrect in MATMUL intrinsic\");\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+\t in case it is we want it to cause a segfault, rather than\n+\t an incorrect result. */\n+      bystride = 0xDEADBEEF;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_INTEGER_4 *restrict abase_x;\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 *restrict dest_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_INTEGER_4) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_INTEGER_4 *restrict bbase_y;\n+\t  GFC_INTEGER_4 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_INTEGER_4)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_INTEGER_4) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+\n+/* Compiling main function, with selection code for the processor.  */\n+\n+/* Currently, this is i386 only.  Adjust for other architectures.  */\n+\n+#include <config/i386/cpuinfo.h>\n+void matmul_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  static void (*matmul_p) (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) = NULL;\n+\n+  if (matmul_p == NULL)\n+    {\n+      matmul_p = matmul_i4_vanilla;\n+      if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n+\t{\n+          /* Run down the available processors in order of preference.  */\n+#ifdef HAVE_AVX512F\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n+\t    {\n+\t      matmul_p = matmul_i4_avx512f;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif  /* HAVE_AVX512F */\n+\n+#ifdef HAVE_AVX2\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t    {\n+\t      matmul_p = matmul_i4_avx2;\n+\t      goto tailcall;\n+\t    }\n+\n+#endif\n+\n+#ifdef HAVE_AVX\n+      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n+ \t    {\n+              matmul_p = matmul_i4_avx;\n+\t      goto tailcall;\n+\t    }\n+#endif  /* HAVE_AVX */\n+        }\n+   }\n+\n+tailcall:\n+   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+}\n+\n+#else  /* Just the vanilla function.  */\n+\n void\n matmul_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n@@ -607,4 +2834,10 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n }\n+#undef POW3\n+#undef min\n+#undef max\n+\n #endif\n+#endif\n+"}, {"sha": "c4d0327b7aa67594c18078ca3a3678d09b1c0a86", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}, {"sha": "b9fb10b0f67bd66b8a8fecd4fc0643b3b5845e4a", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 2237, "deletions": 0, "changes": 2237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}, {"sha": "65ac801b2340a9994b8ebfbfcdb091dc5bd0c464", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 2237, "deletions": 0, "changes": 2237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}, {"sha": "2a85d6b3bccc65370876f351046eb752d37f51ef", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 2237, "deletions": 0, "changes": 2237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}, {"sha": "78bf52ef6fe9d8b0b8cdf0de192d54d4d1ee6bdf", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 2237, "deletions": 0, "changes": 2237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}, {"sha": "4e5bf60620905e9a92fc08ab06c49b151cb50ce6", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 82, "deletions": 514, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}, {"sha": "d35968b3be57b4c6f9840c985277666d6270e85d", "filename": "libgfortran/m4/matmul_internal.m4", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fm4%2Fmatmul_internal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31cfd832864298ea34c52625312e2a0ed0478e3d/libgfortran%2Fm4%2Fmatmul_internal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul_internal.m4?ref=31cfd832864298ea34c52625312e2a0ed0478e3d"}]}