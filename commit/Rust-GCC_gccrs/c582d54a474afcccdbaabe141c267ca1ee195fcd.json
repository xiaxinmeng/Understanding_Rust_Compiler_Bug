{"sha": "c582d54a474afcccdbaabe141c267ca1ee195fcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU4MmQ1NGE0NzRhZmNjY2RiYWFiZTE0MWMyNjdjYTFlZTE5NWZjZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-22T11:35:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-22T11:35:58Z"}, "message": "alias.c (reg_base_value): Turn into varray.\n\n\n\t* alias.c (reg_base_value): Turn into varray.\n\t(reg_base_value_size): Kill.\n\t(old_reg_base_value): New deletable varray.\n\t(alias_invariant_size): New variable.\n\t(REG_BASE_VALUE): Update to use varray.\n\t(find_base_value): Likewise.\n\t(record_set): Likewise.\n\t(record_base_value): Likewise.\n\t(memrefs_conflict_p): Likewise.\n\t(record_set): Likewise\n\t(record_base_value): Likewise.\n\t(memrefs_conflict_p): Use alias_invariant_size.\n\t(init_alias_analysis): Use varray; set alias_invariant_size;\n\trescale other arrays to be sized by maxreg.\n\t(end_alias_analysis): Save reg_base_value; clear alias_invariant_size.\n\nFrom-SVN: r76349", "tree": {"sha": "43cf04739c20a68832ea083d53c405fbe3c9949f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43cf04739c20a68832ea083d53c405fbe3c9949f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c582d54a474afcccdbaabe141c267ca1ee195fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c582d54a474afcccdbaabe141c267ca1ee195fcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c582d54a474afcccdbaabe141c267ca1ee195fcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c582d54a474afcccdbaabe141c267ca1ee195fcd/comments", "author": null, "committer": null, "parents": [{"sha": "8a98812c685222768f27f9abb7255352d94eb9ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a98812c685222768f27f9abb7255352d94eb9ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a98812c685222768f27f9abb7255352d94eb9ab"}], "stats": {"total": 118, "additions": 79, "deletions": 39}, "files": [{"sha": "a1238b80ee4e40b7363c364cb0846d4628ffd453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c582d54a474afcccdbaabe141c267ca1ee195fcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c582d54a474afcccdbaabe141c267ca1ee195fcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c582d54a474afcccdbaabe141c267ca1ee195fcd", "patch": "@@ -1,3 +1,21 @@\n+2004-01-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* alias.c (reg_base_value): Turn into varray.\n+\t(reg_base_value_size): Kill.\n+\t(old_reg_base_value): New deletable varray.\n+\t(alias_invariant_size): New variable.\n+\t(REG_BASE_VALUE): Update to use varray.\n+\t(find_base_value): Likewise.\n+\t(record_set): Likewise.\n+\t(record_base_value): Likewise.\n+\t(memrefs_conflict_p): Likewise.\n+\t(record_set): Likewise\n+\t(record_base_value): Likewise.\n+\t(memrefs_conflict_p): Use alias_invariant_size.\n+\t(init_alias_analysis): Use varray; set alias_invariant_size;\n+\trescale other arrays to be sized by maxreg.\n+\t(end_alias_analysis): Save reg_base_value; clear alias_invariant_size.\n+\n 2004-01-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sparc.c (function_arg_slotno): Use"}, {"sha": "5fd88120ae44b69ffba2b790fc0fec40515f4195", "filename": "gcc/alias.c", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c582d54a474afcccdbaabe141c267ca1ee195fcd/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c582d54a474afcccdbaabe141c267ca1ee195fcd/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c582d54a474afcccdbaabe141c267ca1ee195fcd", "patch": "@@ -157,17 +157,21 @@ static void memory_modified_1 (rtx, rtx, void *);\n    current function performs nonlocal memory memory references for the\n    purposes of marking the function as a constant function.  */\n \n-static GTY((length (\"reg_base_value_size\"))) rtx *reg_base_value;\n+static GTY(()) varray_type reg_base_value;\n static rtx *new_reg_base_value;\n-static unsigned int reg_base_value_size; /* size of reg_base_value array */\n+\n+/* We preserve the copy of old array around to avoid amount of garbage\n+   produced.  About 8% of garbage produced were attributed to this\n+   array.  */\n+static GTY((deletable (\"\"))) varray_type old_reg_base_value;\n \n /* Static hunks of RTL used by the aliasing code; these are initialized\n    once per function to avoid unnecessary RTL allocations.  */\n static GTY (()) rtx static_reg_base_value[FIRST_PSEUDO_REGISTER];\n \n #define REG_BASE_VALUE(X) \\\n-  (REGNO (X) < reg_base_value_size \\\n-   ? reg_base_value[REGNO (X)] : 0)\n+  (reg_base_value && REGNO (X) < VARRAY_SIZE (reg_base_value) \\\n+   ? VARRAY_RTX (reg_base_value, REGNO (X)) : 0)\n \n /* Vector of known invariant relationships between registers.  Set in\n    loop unrolling.  Indexed by register number, if nonzero the value\n@@ -178,6 +182,7 @@ static GTY (()) rtx static_reg_base_value[FIRST_PSEUDO_REGISTER];\n    Because this array contains only pseudo registers it has no effect\n    after reload.  */\n static rtx *alias_invariant;\n+unsigned int alias_invariant_size;\n \n /* Vector indexed by N giving the initial (unchanging) value known for\n    pseudo-register N.  This array is initialized in\n@@ -778,16 +783,16 @@ find_base_value (rtx src)\n \t The test above is not sufficient because the scheduler may move\n \t a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */\n       if ((regno >= FIRST_PSEUDO_REGISTER || fixed_regs[regno])\n-\t  && regno < reg_base_value_size)\n+\t  && regno < VARRAY_SIZE (reg_base_value))\n \t{\n \t  /* If we're inside init_alias_analysis, use new_reg_base_value\n \t     to reduce the number of relaxation iterations.  */\n \t  if (new_reg_base_value && new_reg_base_value[regno]\n \t      && REG_N_SETS (regno) == 1)\n \t    return new_reg_base_value[regno];\n \n-\t  if (reg_base_value[regno])\n-\t    return reg_base_value[regno];\n+\t  if (VARRAY_RTX (reg_base_value, regno))\n+\t    return VARRAY_RTX (reg_base_value, regno);\n \t}\n \n       return 0;\n@@ -931,7 +936,7 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n \n   regno = REGNO (dest);\n \n-  if (regno >= reg_base_value_size)\n+  if (regno >= VARRAY_SIZE (reg_base_value))\n     abort ();\n \n   /* If this spans multiple hard registers, then we must indicate that every\n@@ -1030,21 +1035,20 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n void\n record_base_value (unsigned int regno, rtx val, int invariant)\n {\n-  if (regno >= reg_base_value_size)\n-    return;\n-\n-  if (invariant && alias_invariant)\n+  if (invariant && alias_invariant && regno < alias_invariant_size)\n     alias_invariant[regno] = val;\n \n+  if (regno >= VARRAY_SIZE (reg_base_value))\n+    VARRAY_GROW (reg_base_value, max_reg_num ());\n+\n   if (GET_CODE (val) == REG)\n     {\n-      if (REGNO (val) < reg_base_value_size)\n-\treg_base_value[regno] = reg_base_value[REGNO (val)];\n-\n+      VARRAY_RTX (reg_base_value, regno)\n+\t = REG_BASE_VALUE (val);\n       return;\n     }\n-\n-  reg_base_value[regno] = find_base_value (val);\n+  VARRAY_RTX (reg_base_value, regno)\n+     = find_base_value (val);\n }\n \n /* Clear alias info for a register.  This is used if an RTL transformation\n@@ -1682,8 +1686,8 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t    unsigned int r_x = REGNO (x), r_y = REGNO (y);\n \t    rtx i_x, i_y;\t/* invariant relationships of X and Y */\n \n-\t    i_x = r_x >= reg_base_value_size ? 0 : alias_invariant[r_x];\n-\t    i_y = r_y >= reg_base_value_size ? 0 : alias_invariant[r_y];\n+\t    i_x = r_x >= alias_invariant_size ? 0 : alias_invariant[r_x];\n+\t    i_y = r_y >= alias_invariant_size ? 0 : alias_invariant[r_y];\n \n \t    if (i_x == 0 && i_y == 0)\n \t      break;\n@@ -2710,7 +2714,7 @@ memory_modified_in_insn_p (rtx mem, rtx insn)\n void\n init_alias_analysis (void)\n {\n-  int maxreg = max_reg_num ();\n+  unsigned int maxreg = max_reg_num ();\n   int changed, pass;\n   int i;\n   unsigned int ui;\n@@ -2730,17 +2734,31 @@ init_alias_analysis (void)\n   /* Overallocate reg_base_value to allow some growth during loop\n      optimization.  Loop unrolling can create a large number of\n      registers.  */\n-  reg_base_value_size = maxreg * 2;\n-  reg_base_value = ggc_alloc_cleared (reg_base_value_size * sizeof (rtx));\n+  if (old_reg_base_value)\n+    {\n+      reg_base_value = old_reg_base_value;\n+      /* If varray gets large zeroing cost may get important.  */\n+      if (VARRAY_SIZE (reg_base_value) > 256\n+          && VARRAY_SIZE (reg_base_value) > 4 * maxreg)\n+\tVARRAY_GROW (reg_base_value, maxreg);\n+      VARRAY_CLEAR (reg_base_value);\n+      if (VARRAY_SIZE (reg_base_value) < maxreg)\n+\tVARRAY_GROW (reg_base_value, maxreg);\n+    }\n+  else\n+    {\n+      VARRAY_RTX_INIT (reg_base_value, maxreg, \"reg_base_value\");\n+    }\n \n-  new_reg_base_value = xmalloc (reg_base_value_size * sizeof (rtx));\n-  reg_seen = xmalloc (reg_base_value_size);\n+  new_reg_base_value = xmalloc (maxreg * sizeof (rtx));\n+  reg_seen = xmalloc (maxreg);\n   if (! reload_completed && flag_old_unroll_loops)\n     {\n       /* ??? Why are we realloc'ing if we're just going to zero it?  */\n       alias_invariant = xrealloc (alias_invariant,\n-\t\t\t\t  reg_base_value_size * sizeof (rtx));\n-      memset (alias_invariant, 0, reg_base_value_size * sizeof (rtx));\n+\t\t\t\t  maxreg * sizeof (rtx));\n+      memset (alias_invariant, 0, maxreg * sizeof (rtx));\n+      alias_invariant_size = maxreg;\n     }\n \n   /* The basic idea is that each pass through this loop will use the\n@@ -2777,10 +2795,10 @@ init_alias_analysis (void)\n       copying_arguments = true;\n \n       /* Wipe the potential alias information clean for this pass.  */\n-      memset (new_reg_base_value, 0, reg_base_value_size * sizeof (rtx));\n+      memset (new_reg_base_value, 0, maxreg * sizeof (rtx));\n \n       /* Wipe the reg_seen array clean.  */\n-      memset (reg_seen, 0, reg_base_value_size);\n+      memset (reg_seen, 0, maxreg);\n \n       /* Mark all hard registers which may contain an address.\n \t The stack, frame and argument pointers may contain an address.\n@@ -2868,21 +2886,24 @@ init_alias_analysis (void)\n \t}\n \n       /* Now propagate values from new_reg_base_value to reg_base_value.  */\n-      for (ui = 0; ui < reg_base_value_size; ui++)\n+      if (maxreg != (unsigned int) max_reg_num())\n+\tabort ();\n+      for (ui = 0; ui < maxreg; ui++)\n \t{\n \t  if (new_reg_base_value[ui]\n-\t      && new_reg_base_value[ui] != reg_base_value[ui]\n-\t      && ! rtx_equal_p (new_reg_base_value[ui], reg_base_value[ui]))\n+\t      && new_reg_base_value[ui] != VARRAY_RTX (reg_base_value, ui)\n+\t      && ! rtx_equal_p (new_reg_base_value[ui],\n+\t\t\t\tVARRAY_RTX (reg_base_value, ui)))\n \t    {\n-\t      reg_base_value[ui] = new_reg_base_value[ui];\n+\t      VARRAY_RTX (reg_base_value, ui) = new_reg_base_value[ui];\n \t      changed = 1;\n \t    }\n \t}\n     }\n   while (changed && ++pass < MAX_ALIAS_LOOP_PASSES);\n \n   /* Fill in the remaining entries.  */\n-  for (i = FIRST_PSEUDO_REGISTER; i < maxreg; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < (int)maxreg; i++)\n     if (reg_known_value[i] == 0)\n       reg_known_value[i] = regno_reg_rtx[i];\n \n@@ -2901,16 +2922,17 @@ init_alias_analysis (void)\n     {\n       changed = 0;\n       pass++;\n-      for (ui = 0; ui < reg_base_value_size; ui++)\n+      for (ui = 0; ui < maxreg; ui++)\n \t{\n-\t  rtx base = reg_base_value[ui];\n+\t  rtx base = VARRAY_RTX (reg_base_value, ui);\n \t  if (base && GET_CODE (base) == REG)\n \t    {\n \t      unsigned int base_regno = REGNO (base);\n \t      if (base_regno == ui)\t\t/* register set from itself */\n-\t\treg_base_value[ui] = 0;\n+\t\tVARRAY_RTX (reg_base_value, ui) = 0;\n \t      else\n-\t\treg_base_value[ui] = reg_base_value[base_regno];\n+\t\tVARRAY_RTX (reg_base_value, ui)\n+\t\t  = VARRAY_RTX (reg_base_value, base_regno);\n \t      changed = 1;\n \t    }\n \t}\n@@ -2928,17 +2950,17 @@ init_alias_analysis (void)\n void\n end_alias_analysis (void)\n {\n+  old_reg_base_value = reg_base_value;\n   free (reg_known_value + FIRST_PSEUDO_REGISTER);\n   reg_known_value = 0;\n   reg_known_value_size = 0;\n   free (reg_known_equiv_p + FIRST_PSEUDO_REGISTER);\n   reg_known_equiv_p = 0;\n-  reg_base_value = 0;\n-  reg_base_value_size = 0;\n   if (alias_invariant)\n     {\n       free (alias_invariant);\n       alias_invariant = 0;\n+      alias_invariant_size = 0;\n     }\n }\n "}]}