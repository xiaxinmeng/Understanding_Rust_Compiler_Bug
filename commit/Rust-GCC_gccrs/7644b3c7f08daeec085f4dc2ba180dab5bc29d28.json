{"sha": "7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY0NGIzYzdmMDhkYWVlYzA4NWY0ZGMyYmExODBkYWI1YmMyOWQyOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-08T00:05:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-08T00:05:57Z"}, "message": "dwarf2: Extract cfi creation to a new pass.\n\n        * tree-pass.h (pass_dwarf2_frame): Declare.\n        * passes.c (init_optimization_passes): Add it.\n        * dwarf2cfi.c (dwarf2out_frame_debug): Make static.\n        (create_cfi_notes): Rename from dwarf2out_frame_debug_after_prologue;\n        make static, do not call add_cfis_to_fde.\n        (dwarf2out_frame_debug_init, dwarf2cfi_function_init,\n        dwarf2out_frame_init): Merge into...\n        (execute_dwarf2_frame): ... here.  New function.\n        (dwarf2out_do_frame, dwarf2out_do_cfi_asm): Make boolean.  Change\n        saved_do_cfi_asm to a tri-state variable.\n        (gate_dwarf2_frame, pass_dwarf2_frame): New.\n        * dwarf2out.c (dwarf2out_begin_prologue): Only allocate the fde\n        if it has yet to be done.  Don't call dwarf2cfi_function_init.\n        * dwarf2out.h, debug.h: Update decls.\n        * final.c (final_start_function): Don't call\n        dwarf2out_frame_debug_init or dwarf2out_frame_debug_after_prologue.\n        * lto-streamer-in.c (lto_init_eh): Don't call dwarf2out_frame_init.\n        * toplev.c (lang_dependent_init): Likewise.\n\nFrom-SVN: r176019", "tree": {"sha": "423b5bc61bca007f2d488d591b3421ca41386eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/423b5bc61bca007f2d488d591b3421ca41386eaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/comments", "author": null, "committer": null, "parents": [{"sha": "a518b99616d4d007e289654332c934e7c3ec8d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a518b99616d4d007e289654332c934e7c3ec8d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a518b99616d4d007e289654332c934e7c3ec8d52"}], "stats": {"total": 242, "additions": 135, "deletions": 107}, "files": [{"sha": "bfa3eb7069b9866feebd270bc7d63be90ce6bb4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -1,3 +1,24 @@\n+2011-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-pass.h (pass_dwarf2_frame): Declare.\n+\t* passes.c (init_optimization_passes): Add it.\n+\t* dwarf2cfi.c (dwarf2out_frame_debug): Make static.\n+\t(create_cfi_notes): Rename from dwarf2out_frame_debug_after_prologue;\n+\tmake static, do not call add_cfis_to_fde.\n+\t(dwarf2out_frame_debug_init, dwarf2cfi_function_init,\n+\tdwarf2out_frame_init): Merge into...\n+\t(execute_dwarf2_frame): ... here.  New function.\n+\t(dwarf2out_do_frame, dwarf2out_do_cfi_asm): Make boolean.  Change\n+\tsaved_do_cfi_asm to a tri-state variable.\n+\t(gate_dwarf2_frame, pass_dwarf2_frame): New.\n+\t* dwarf2out.c (dwarf2out_begin_prologue): Only allocate the fde\n+\tif it has yet to be done.  Don't call dwarf2cfi_function_init.\n+\t* dwarf2out.h, debug.h: Update decls.\n+\t* final.c (final_start_function): Don't call\n+\tdwarf2out_frame_debug_init or dwarf2out_frame_debug_after_prologue.\n+\t* lto-streamer-in.c (lto_init_eh): Don't call dwarf2out_frame_init.\n+\t* toplev.c (lang_dependent_init): Likewise.\n+\n 2011-07-07  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2out.c (fde_table, fde_table_allocated, fde_table_in_use,"}, {"sha": "833c44a2a596ba51555b686692a3a0f934f1c2a6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -1,3 +1,8 @@\n+2011-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc-interface/misc.c (gnat_init_gcc_eh): Don't call\n+\tdwarf2out_frame_init.\n+\n 2011-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_init): Tweak previous change."}, {"sha": "92426fd48b9943c4b5dab981a10a9f3385737a4c", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -339,11 +339,6 @@ gnat_init (void)\n void\n gnat_init_gcc_eh (void)\n {\n-#ifdef DWARF2_UNWIND_INFO\n-  /* lang_dependent_init already called dwarf2out_frame_init if true.  */\n-  int dwarf2out_frame_initialized = dwarf2out_do_frame ();\n-#endif\n-\n   /* We shouldn't do anything if the No_Exceptions_Handler pragma is set,\n      though. This could for instance lead to the emission of tables with\n      references to symbols (such as the Ada eh personality routine) within\n@@ -370,11 +365,6 @@ gnat_init_gcc_eh (void)\n   flag_non_call_exceptions = 1;\n \n   init_eh ();\n-\n-#ifdef DWARF2_UNWIND_INFO\n-  if (!dwarf2out_frame_initialized && dwarf2out_do_frame ())\n-    dwarf2out_frame_init ();\n-#endif\n }\n \n /* Print language-specific items in declaration NODE.  */"}, {"sha": "828ede2304e2b93f76eeba17af7d573b4091ac7a", "filename": "gcc/debug.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -178,12 +178,11 @@ extern void dwarf2out_begin_prologue (unsigned int, const char *);\n extern void dwarf2out_vms_end_prologue (unsigned int, const char *);\n extern void dwarf2out_vms_begin_epilogue (unsigned int, const char *);\n extern void dwarf2out_end_epilogue (unsigned int, const char *);\n-extern void dwarf2out_frame_init (void);\n extern void dwarf2out_frame_finish (void);\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n-extern int dwarf2out_do_frame (void);\n-extern int dwarf2out_do_cfi_asm (void);\n+extern bool dwarf2out_do_frame (void);\n+extern bool dwarf2out_do_cfi_asm (void);\n extern void dwarf2out_switch_text_section (void);\n \n const char *remap_debug_filename (const char *);"}, {"sha": "44655bb51bcb45ea4aff32cc657a90facc8c5840", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 97, "deletions": 64, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -2173,7 +2173,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n    If AFTER_P is false, we're being called before the insn is emitted,\n    otherwise after.  Call instructions get invoked twice.  */\n \n-void\n+static void\n dwarf2out_frame_debug (rtx insn, bool after_p)\n {\n   rtx note, n;\n@@ -2318,33 +2318,6 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n   cfi_insn = NULL;\n }\n \n-/* Called once at the start of final to initialize some data for the\n-   current function.  */\n-\n-void\n-dwarf2out_frame_debug_init (void)\n-{\n-  regs_saved_in_regs = NULL;\n-  queued_reg_saves = NULL;\n-\n-  if (barrier_args_size)\n-    {\n-      XDELETEVEC (barrier_args_size);\n-      barrier_args_size = NULL;\n-    }\n-\n-  /* Set up state for generating call frame debug info.  */\n-  lookup_cfa (&cfa);\n-  gcc_assert (cfa.reg\n-\t      == (unsigned long)DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n-\n-  old_cfa = cfa;\n-  cfa.reg = STACK_POINTER_REGNUM;\n-  cfa_store = cfa;\n-  cfa_temp.reg = -1;\n-  cfa_temp.offset = 0;\n-}\n-\n /* Examine CFI and return true if a cfi label and set_loc is needed\n    beforehand.  Even when generating CFI assembler instructions, we\n    still have to add the cfi to the list so that lookup_cfa works\n@@ -2440,11 +2413,10 @@ add_cfis_to_fde (void)\n     }\n }\n \n-/* After the (optional) text prologue has been written, emit CFI insns\n-   and update the FDE for frame-related instructions.  */\n+/* Scan the function and create the initial set of CFI notes.  */\n  \n-void\n-dwarf2out_frame_debug_after_prologue (void)\n+static void\n+create_cfi_notes (void)\n {\n   rtx insn;\n \n@@ -2499,8 +2471,6 @@ dwarf2out_frame_debug_after_prologue (void)\n \n       dwarf2out_frame_debug (insn, true);\n     }\n-\n-  add_cfis_to_fde ();\n }\n \n /* Determine if we need to save and restore CFI information around this\n@@ -2599,47 +2569,70 @@ dwarf2out_frame_debug_restore_state (void)\n   old_cfa = old_cfa_remember;\n   cfa_remember.in_use = 0;\n }\n+\f\n \n-/* Run once per function.  */\n+/* Annotate the function with NOTE_INSN_CFI notes to record the CFI\n+   state at each location within the function.  These notes will be\n+   emitted during pass_final.  */\n \n-void\n-dwarf2cfi_function_init (void)\n+static unsigned int\n+execute_dwarf2_frame (void)\n {\n-  args_size = old_args_size = 0;\n-}\n+  /* The first time we're called, compute the incoming frame state.  */\n+  if (cie_cfi_vec == NULL)\n+    {\n+      dw_cfa_location loc;\n \n-/* Run once.  */\n+      memset(&old_cfa, 0, sizeof (old_cfa));\n+      old_cfa.reg = INVALID_REGNUM;\n \n-void\n-dwarf2out_frame_init (void)\n-{\n-  dw_cfa_location loc;\n+      /* On entry, the Canonical Frame Address is at SP.  */\n+      memset(&loc, 0, sizeof (loc));\n+      loc.reg = STACK_POINTER_REGNUM;\n+      loc.offset = INCOMING_FRAME_SP_OFFSET;\n+      def_cfa_1 (true, &loc);\n \n-  /* Generate the CFA instructions common to all FDE's.  Do it now for the\n-     sake of lookup_cfa.  */\n+      if (targetm.debug_unwind_info () == UI_DWARF2\n+          || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n+\tinitial_return_save (INCOMING_RETURN_ADDR_RTX);\n+    }\n \n-  memset(&old_cfa, 0, sizeof (old_cfa));\n-  old_cfa.reg = INVALID_REGNUM;\n+  /* Set up state for generating call frame debug info.  */\n+  lookup_cfa (&cfa);\n+  gcc_assert (cfa.reg\n+\t      == (unsigned long)DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n \n-  /* On entry, the Canonical Frame Address is at SP.  */\n-  memset(&loc, 0, sizeof (loc));\n-  loc.reg = STACK_POINTER_REGNUM;\n-  loc.offset = INCOMING_FRAME_SP_OFFSET;\n-  def_cfa_1 (true, &loc);\n+  old_cfa = cfa;\n+  cfa.reg = STACK_POINTER_REGNUM;\n+  cfa_store = cfa;\n+  cfa_temp.reg = -1;\n+  cfa_temp.offset = 0;\n+\n+  dwarf2out_alloc_current_fde ();\n+\n+  /* Do the work.  */\n+  create_cfi_notes ();\n+  add_cfis_to_fde ();\n+\n+  /* Reset all function-specific information, particularly for GC.  */\n+  XDELETEVEC (barrier_args_size);\n+  barrier_args_size = NULL;\n+  regs_saved_in_regs = NULL;\n+  queued_reg_saves = NULL;\n+  args_size = old_args_size = 0;\n \n-  if (targetm.debug_unwind_info () == UI_DWARF2\n-      || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n-    initial_return_save (INCOMING_RETURN_ADDR_RTX);\n+  return 0;\n }\n \f\n \n-/* Save the result of dwarf2out_do_frame across PCH.  */\n-static GTY(()) bool saved_do_cfi_asm = 0;\n+/* Save the result of dwarf2out_do_frame across PCH.\n+   This variable is tri-state, with 0 unset, >0 true, <0 false.  */\n+static GTY(()) signed char saved_do_cfi_asm = 0;\n \n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n-int\n+bool\n dwarf2out_do_frame (void)\n {\n   /* We want to emit correct CFA location expressions or lists, so we\n@@ -2648,7 +2641,7 @@ dwarf2out_do_frame (void)\n   if (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n     return true;\n \n-  if (saved_do_cfi_asm)\n+  if (saved_do_cfi_asm > 0)\n     return true;\n \n   if (targetm.debug_unwind_info () == UI_DWARF2)\n@@ -2663,16 +2656,21 @@ dwarf2out_do_frame (void)\n \n /* Decide whether to emit frame unwind via assembler directives.  */\n \n-int\n+bool\n dwarf2out_do_cfi_asm (void)\n {\n   int enc;\n \n #ifdef MIPS_DEBUGGING_INFO\n   return false;\n #endif\n-  if (saved_do_cfi_asm)\n-    return true;\n+\n+  if (saved_do_cfi_asm != 0)\n+    return saved_do_cfi_asm > 0;\n+\n+  /* Assume failure for a moment.  */\n+  saved_do_cfi_asm = -1;\n+\n   if (!flag_dwarf2_cfi_asm || !dwarf2out_do_frame ())\n     return false;\n   if (!HAVE_GAS_CFI_PERSONALITY_DIRECTIVE)\n@@ -2694,8 +2692,43 @@ dwarf2out_do_cfi_asm (void)\n       && targetm_common.except_unwind_info (&global_options) != UI_DWARF2)\n     return false;\n \n-  saved_do_cfi_asm = true;\n+  /* Success!  */\n+  saved_do_cfi_asm = 1;\n   return true;\n }\n \n+static bool\n+gate_dwarf2_frame (void)\n+{\n+#ifndef HAVE_prologue\n+  /* Targets which still implement the prologue in assembler text\n+     cannot use the generic dwarf2 unwinding.  */\n+  return false;\n+#endif\n+\n+  /* ??? What to do for UI_TARGET unwinding?  They might be able to benefit\n+     from the optimized shrink-wrapping annotations that we will compute.\n+     For now, only produce the CFI notes for dwarf2.  */\n+  return dwarf2out_do_frame ();\n+}\n+\n+struct rtl_opt_pass pass_dwarf2_frame =\n+{\n+ {\n+  RTL_PASS,\n+  \"dwarf2\",\t\t\t/* name */\n+  gate_dwarf2_frame,\t\t/* gate */\n+  execute_dwarf2_frame,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_FINAL,\t\t\t/* tv_id */\n+  0,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t/* todo_flags_finish */\n+ }\n+};\n+\n #include \"gt-dwarf2cfi.h\""}, {"sha": "337650d863d7eeb1d0193aa0069f9650bf09a42c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -1605,15 +1605,20 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   if (!do_frame)\n     return;\n \n+  /* Cater to the various TARGET_ASM_OUTPUT_MI_THUNK implementations that\n+     emit insns as rtx but bypass the bulk of rest_of_compilation, which\n+     would include pass_dwarf2_frame.  If we've not created the FDE yet,\n+     do so now.  */\n+  fde = cfun->fde;\n+  if (fde == NULL)\n+    fde = dwarf2out_alloc_current_fde ();\n+\n   /* Initialize the bits of CURRENT_FDE that were not available earlier.  */\n-  fde = dwarf2out_alloc_current_fde ();\n   fde->dw_fde_begin = dup_label;\n   fde->dw_fde_current_label = dup_label;\n   fde->in_std_section = (fnsec == text_section\n \t\t\t || (cold_text_section && fnsec == cold_text_section));\n \n-  dwarf2cfi_function_init ();\n-\n   /* We only want to output line number information for the genuine dwarf2\n      prologue case, not the eh frame case.  */\n #ifdef DWARF2_DEBUGGING_INFO"}, {"sha": "7122dee3296af9dc2360331b19e94c11ead2618c", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -229,7 +229,6 @@ extern enum machine_mode get_address_mode (rtx mem);\n extern dw_fde_ref dwarf2out_alloc_current_fde (void);\n \n /* Interface from dwarf2cfi.c to dwarf2out.c.  */\n-extern void dwarf2cfi_function_init (void);\n extern void lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc,\n \t\t\t  dw_cfa_location *remember);\n extern bool cfa_equal_p (const dw_cfa_location *, const dw_cfa_location *);\n@@ -243,9 +242,6 @@ extern enum dw_cfi_oprnd_type dw_cfi_oprnd2_desc\n   (enum dwarf_call_frame_info cfi);\n \n extern void dwarf2out_decl (tree);\n-extern void dwarf2out_frame_debug (rtx, bool);\n-extern void dwarf2out_frame_debug_init (void);\n-extern void dwarf2out_frame_debug_after_prologue (void);\n extern void dwarf2out_emit_cfi (dw_cfi_ref cfi);\n \n extern void debug_dwarf (void);"}, {"sha": "483a6452d27a018bbca355e0bcab716ed2659448", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -1560,11 +1560,6 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n   if (targetm.profile_before_prologue () && crtl->profile)\n     profile_function (file);\n \n-#if defined (HAVE_prologue)\n-  if (dwarf2out_do_frame ())\n-    dwarf2out_frame_debug_init ();\n-#endif\n-\n   /* If debugging, assign block numbers to all of the blocks in this\n      function.  */\n   if (write_symbols)\n@@ -1589,11 +1584,6 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n   /* First output the function prologue: code to set up the stack frame.  */\n   targetm.asm_out.function_prologue (file, get_frame_size ());\n \n-#if defined (HAVE_prologue)\n-  if (dwarf2out_do_frame ())\n-    dwarf2out_frame_debug_after_prologue ();\n-#endif\n-\n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n #ifdef HAVE_prologue"}, {"sha": "d24903309c8488d3a131fcd7c5fa0d692e5c6945", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -657,14 +657,6 @@ lto_init_eh (void)\n   flag_exceptions = 1;\n   init_eh ();\n \n-  /* Initialize dwarf2 tables.  Since dwarf2out_do_frame() returns\n-     true only when exceptions are enabled, this initialization is\n-     never done during lang_dependent_init.  */\n-#if defined DWARF2_DEBUGGING_INFO || defined DWARF2_UNWIND_INFO\n-  if (dwarf2out_do_frame ())\n-    dwarf2out_frame_init ();\n-#endif\n-\n   eh_initialized_p = true;\n }\n "}, {"sha": "c7e77cbbbc1e179cf474c627a3d25c44f07293a7", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -1506,6 +1506,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_convert_to_eh_region_ranges);\n \t  NEXT_PASS (pass_shorten_branches);\n \t  NEXT_PASS (pass_set_nothrow_function_flags);\n+\t  NEXT_PASS (pass_dwarf2_frame);\n \t  NEXT_PASS (pass_final);\n \t}\n       NEXT_PASS (pass_df_finish);"}, {"sha": "4591c30264dbf8c8a916e25ae905750a554a9616", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -1741,11 +1741,6 @@ lang_dependent_init (const char *name)\n \t predefined types.  */\n       timevar_push (TV_SYMOUT);\n \n-#if defined DWARF2_DEBUGGING_INFO || defined DWARF2_UNWIND_INFO\n-      if (dwarf2out_do_frame ())\n-\tdwarf2out_frame_init ();\n-#endif\n-\n       /* Now we have the correct original filename, we can initialize\n \t debug output.  */\n       (*debug_hooks->init) (name);"}, {"sha": "f5de1f6c9b2dc8959339d11d91d12455a6d82bba", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7644b3c7f08daeec085f4dc2ba180dab5bc29d28/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=7644b3c7f08daeec085f4dc2ba180dab5bc29d28", "patch": "@@ -567,6 +567,7 @@ extern struct rtl_opt_pass pass_split_before_regstack;\n extern struct rtl_opt_pass pass_convert_to_eh_region_ranges;\n extern struct rtl_opt_pass pass_shorten_branches;\n extern struct rtl_opt_pass pass_set_nothrow_function_flags;\n+extern struct rtl_opt_pass pass_dwarf2_frame;\n extern struct rtl_opt_pass pass_final;\n extern struct rtl_opt_pass pass_rtl_seqabstr;\n extern struct gimple_opt_pass pass_release_ssa_names;"}]}