{"sha": "51c042567c98b0a181246523acad810cbf1b35f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFjMDQyNTY3Yzk4YjBhMTgxMjQ2NTIzYWNhZDgxMGNiZjFiMzVmNQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-20T06:14:53Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-20T06:14:53Z"}, "message": "cppinit.c (init_standard_includes): The returned buffer is already malloc-ed.\n\n\t* cppinit.c (init_standard_includes): The returned buffer\n\tis already malloc-ed.\n\t* gcc.c (add_prefix): Similarly.\n\t* prefix.c (translate_name): Update to support clear buffer\n\townership rules.\n\t(update_path): Similarly.  Be sure to free any newly allocated\n\tkey.  UPDATE_PATH_HOST_CANONICALIZE takes only one argument.\n\t(tr): New function.\n\t* prefix.h (update_path): Update prototype and document.\n\t* config/i386/xm-djgpp.h (UPDATE_PATH_HOST_CANONICALIZE): Clean\n\tup and update to new buffer ownership rules.\n\t* doc/gcc.texi (UPDATE_PATH_HOST_CANONICALIZE): Update.\n\nFrom-SVN: r45043", "tree": {"sha": "a03bfc505ec1118b3947c2fbbf52975e90cc2d08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a03bfc505ec1118b3947c2fbbf52975e90cc2d08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51c042567c98b0a181246523acad810cbf1b35f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c042567c98b0a181246523acad810cbf1b35f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51c042567c98b0a181246523acad810cbf1b35f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c042567c98b0a181246523acad810cbf1b35f5/comments", "author": null, "committer": null, "parents": [{"sha": "247a370b4f2f91d4b82c66902d46649e57b1ec91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247a370b4f2f91d4b82c66902d46649e57b1ec91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/247a370b4f2f91d4b82c66902d46649e57b1ec91"}], "stats": {"total": 218, "additions": 123, "deletions": 95}, "files": [{"sha": "c7c501e37577710ed269f8c1d2590c388d48d35a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -1,3 +1,18 @@\n+2001-08-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppinit.c (init_standard_includes): The returned buffer\n+\tis already malloc-ed.\n+\t* gcc.c (add_prefix): Similarly.\n+\t* prefix.c (translate_name): Update to support clear buffer\n+\townership rules.\n+\t(update_path): Similarly.  Be sure to free any newly allocated\n+\tkey.  UPDATE_PATH_HOST_CANONICALIZE takes only one argument.\n+\t(tr): New function.\n+\t* prefix.h (update_path): Update prototype and document.\n+\t* config/i386/xm-djgpp.h (UPDATE_PATH_HOST_CANONICALIZE): Clean\n+\tup and update to new buffer ownership rules.\n+\t* doc/gcc.texi (UPDATE_PATH_HOST_CANONICALIZE): Update.\n+\n Mon Aug 20 01:44:50 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* final.c (compute_alignments): New function."}, {"sha": "cad1abf64c1c9a2c3353d70bcc99670cb35df804", "filename": "gcc/config/i386/xm-djgpp.h", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fconfig%2Fi386%2Fxm-djgpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fconfig%2Fi386%2Fxm-djgpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-djgpp.h?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -82,27 +82,17 @@ Boston, MA 02111-1307, USA.  */\n     md_exec_prefix = update_path (md_exec_prefix, NULL); \\\n   } while (0)\n \n-/* Canonicalize paths containing '/dev/env/', especially those in\n-   prefix.c.  */\n-#define UPDATE_PATH_HOST_CANONICALIZE(PATH, KEY) \\\n-  do { \\\n-    if (strncmp (PATH, \"/dev/env/\", sizeof(\"/dev/env/\") - 1) == 0) \\\n-      { \\\n-        static char *djdir; \\\n-        static int djdir_len; \\\n-        static char fixed_path[FILENAME_MAX + 1]; \\\n-        char *new_path; \\\n-        /* The default prefixes all use '/dev/env/DJDIR', so optimize \\\n-           for this. All other uses of '/dev/env/' go through \\\n-           libc's canonicalization function.  */ \\\n-        _fixpath (PATH, fixed_path); \\\n-        /* _fixpath removes any trailing '/', so add it back.  */ \\\n-        strcat (fixed_path, \"/\"); \\\n-        new_path = xstrdup (fixed_path); \\\n-        PATH = new_path; \\\n-        return PATH; \\\n-      } \\\n-    /* If DIR_SEPARATOR_2 isn't in PATH, nothing more need be done.  */ \\\n-    if (strchr (PATH, DIR_SEPARATOR_2) == NULL) \\\n-      return PATH; \\\n-  } while (0)\n+/* Canonicalize paths containing '/dev/env/'; used in prefix.c.\n+   _fixpath is a djgpp-specific function to canonicalize a path.\n+   \"/dev/env/DJDIR\" evaluates to \"c:/djgpp\" if DJDIR is \"c:/djgpp\" for\n+   example.  It removes any trailing '/', so add it back.  */\n+#define UPDATE_PATH_HOST_CANONICALIZE(PATH) \\\n+  if (memcmp ((PATH), \"/dev/env/\", sizeof(\"/dev/env/\") - 1) == 0) \\\n+    {\t\t\t\t\t\t\\\n+      static char fixed_path[FILENAME_MAX + 1];\t\\\n+\t\t\t\t\t\t\\\n+      _fixpath ((PATH), fixed_path);\t\t\\\n+      strcat (fixed_path, \"/\");\t\t\t\\\n+      free (PATH);\t\t\t\t\\\n+      (PATH) = xstrdup (fixed_path);\t\t\\\n+    } "}, {"sha": "4a78a938987ea89a352dc470a7dd868e6889cd8e", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -861,7 +861,7 @@ init_standard_includes (pfile)\n \t  || (CPP_OPTION (pfile, cplusplus)\n \t      && !CPP_OPTION (pfile, no_standard_cplusplus_includes)))\n \t{\n-\t  char *str = xstrdup (update_path (p->fname, p->component));\n+\t  char *str = update_path (p->fname, p->component);\n \t  append_include_chain (pfile, str, SYSTEM, p->cxx_aware);\n \t}\n     }"}, {"sha": "befee3643bbb4d01066ca188ac260968c80afc59", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -4059,12 +4059,13 @@ If defined, a C statement (sans semicolon) that performs host-dependent\n initialization when a compilation driver is being initialized.\n \n @findex UPDATE_PATH_HOST_CANONICALIZE\n-@item UPDATE_PATH_HOST_CANONICALIZE (@var{path}, @var{key})\n+@item UPDATE_PATH_HOST_CANONICALIZE (@var{path})\n If defined, a C statement (sans semicolon) that performs host-dependent\n-canonicalization when a path used in a compilation driver or preprocessor is\n-canonicalized.  @var{path} is the path to be canonicalized, and @var{key} is\n-a translation prefix when its value isn't @code{NULL}.  If the C statement\n-does canonicalize @var{path}, the new path should be returned.\n+canonicalization when a path used in a compilation driver or\n+preprocessor is canonicalized.  @var{path} is a malloc-ed path to be\n+canonicalized.  If the C statement does canonicalize @var{path} into a\n+different buffer, the old path should be freed and the new buffer should\n+have been allocated with malloc.\n @end table\n \n @findex bzero"}, {"sha": "47cfa2e95ff33f1d2c77042b2757b1ba71fff817", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -2607,7 +2607,7 @@ add_prefix (pprefix, prefix, component, priority, require_machine_suffix, warn)\n     pprefix->max_len = len;\n \n   pl = (struct prefix_list *) xmalloc (sizeof (struct prefix_list));\n-  pl->prefix = save_string (prefix, len);\n+  pl->prefix = prefix;\n   pl->require_machine_suffix = require_machine_suffix;\n   pl->used_flag_ptr = warn;\n   pl->priority = priority;"}, {"sha": "1ad88cfe8ec1abb7254d887f77cf6681b10e7e67", "filename": "gcc/prefix.c", "status": "modified", "additions": 82, "deletions": 63, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -74,8 +74,9 @@ Boston, MA 02111-1307, USA.  */\n static const char *std_prefix = PREFIX;\n \n static const char *get_key_value\tPARAMS ((char *));\n-static const char *translate_name\tPARAMS ((const char *));\n+static char *translate_name\t\tPARAMS ((char *));\n static char *save_string\t\tPARAMS ((const char *, int));\n+static void tr\t\t\t\tPARAMS ((char *, int, int));\n \n #if defined(_WIN32) && defined(ENABLE_WIN32_REGISTRY)\n static char *lookup_key\t\tPARAMS ((char *));\n@@ -230,101 +231,119 @@ lookup_key (key)\n }\n #endif\n \n-/* If NAME starts with a '@' or '$', apply the translation rules above\n-   and return a new name.  Otherwise, return the given name.  */\n+/* If NAME, a malloc-ed string, starts with a '@' or '$', apply the\n+   translation rules above and return a newly malloc-ed name.\n+   Otherwise, return the given name.  */\n \n-static const char *\n+static char *\n translate_name (name)\n-  const char *name;\n+     char *name;\n {\n-  char code = name[0];\n-  char *key;\n-  const char *prefix = 0;\n+  char code;\n+  char *key, *old_name;\n+  const char *prefix;\n   int keylen;\n \n-  if (code != '@' && code != '$')\n-    return name;\n-\n-  for (keylen = 0;\n-       (name[keylen + 1] != 0 && !IS_DIR_SEPARATOR (name[keylen + 1]));\n-       keylen++)\n-    ;\n+  for (;;)\n+    {\n+      code = name[0];\n+      if (code != '@' && code != '$')\n+\tbreak;\n+\n+      for (keylen = 0;\n+\t   (name[keylen + 1] != 0 && !IS_DIR_SEPARATOR (name[keylen + 1]));\n+\t   keylen++)\n+\t;\n+\n+      key = (char *) alloca (keylen + 1);\n+      strncpy (key, &name[1], keylen);\n+      key[keylen] = 0;\n+\n+      if (code == '@')\n+\t{\n+\t  prefix = get_key_value (key);\n+\t  if (prefix == 0)\n+\t    prefix = std_prefix;\n+\t}\n+      else\n+\tprefix = getenv (key);\n \n-  key = (char *) alloca (keylen + 1);\n-  strncpy (key, &name[1], keylen);\n-  key[keylen] = 0;\n+      if (prefix == 0)\n+\tprefix = PREFIX;\n \n-  name = &name[keylen + 1];\n+      /* We used to strip trailing DIR_SEPARATORs here, but that can\n+\t sometimes yield a result with no separator when one was coded\n+\t and intended by the user, causing two path components to run\n+\t together.  */\n \n-  if (code == '@')\n-    {\n-      prefix = get_key_value (key);\n-      if (prefix == 0)\n-\tprefix = std_prefix;\n+      old_name = name;\n+      name = concat (prefix, &name[keylen + 1], NULL);\n+      free (old_name);\n     }\n-  else\n-    prefix = getenv (key);\n \n-  if (prefix == 0)\n-    prefix = PREFIX;\n-\n-  /* We used to strip trailing DIR_SEPARATORs here, but that can\n-     sometimes yield a result with no separator when one was coded\n-     and intended by the user, causing two path components to run\n-     together.  */\n+  return name;\n+}\n \n-  return concat (prefix, name, NULL);\n+/* In a NUL-terminated STRING, replace character C1 with C2 in-place.  */\n+static void\n+tr (string, c1, c2)\n+     char *string;\n+     int c1, c2;\n+{\n+  do\n+    {\n+      if (*string == c1)\n+\t*string = c2;\n+    }\n+  while (*string++);\n }\n \n-/* Update PATH using KEY if PATH starts with PREFIX.  */\n+/* Update PATH using KEY if PATH starts with PREFIX.  The returned\n+   string is always malloc-ed, and the caller is responsible for\n+   freeing it.  */\n \n-const char *\n+char *\n update_path (path, key)\n   const char *path;\n   const char *key;\n {\n+  char *result;\n+\n   if (! strncmp (path, std_prefix, strlen (std_prefix)) && key != 0)\n     {\n-      if (key[0] != '$')\n-\tkey = concat (\"@\", key, NULL);\n-\n-      path = concat (key, &path[strlen (std_prefix)], NULL);\n+      bool free_key = false;\n \n-      while (path[0] == '@' || path[0] == '$')\n-\tpath = translate_name (path);\n+      if (key[0] != '$')\n+\t{\n+\t  key = concat (\"@\", key, NULL);\n+\t  free_key = true;\n+\t}\n+\n+      result = concat (key, &path[strlen (std_prefix)], NULL);\n+      if (free_key)\n+\tfree ((char *) key);\n+      result = translate_name (result);\n     }\n+  else\n+    result = xstrdup (path);\n \n #ifdef UPDATE_PATH_HOST_CANONICALIZE\n-/* Perform host dependant canonicalization when needed.  */\n-UPDATE_PATH_HOST_CANONICALIZE (path, key);\n+  /* Perform host dependent canonicalization when needed.  */\n+  UPDATE_PATH_HOST_CANONICALIZE (path);\n #endif\n \n #ifdef DIR_SEPARATOR_2\n   /* Convert DIR_SEPARATOR_2 to DIR_SEPARATOR.  */\n-  if (DIR_SEPARATOR != DIR_SEPARATOR_2)\n-    {\n-      char *new_path = xstrdup (path);\n-      path = new_path;\n-      do {\n-\tif (*new_path == DIR_SEPARATOR_2)\n-\t  *new_path = DIR_SEPARATOR;\n-      } while (*new_path++);\n-    }\n+  if (DIR_SEPARATOR_2 != DIR_SEPARATOR)\n+    tr (result, DIR_SEPARATOR_2, DIR_SEPARATOR);\n #endif\n-      \n+\n #if defined (DIR_SEPARATOR) && !defined (DIR_SEPARATOR_2)\n   if (DIR_SEPARATOR != '/')\n-    {\n-      char *new_path = xstrdup (path);\n-      path = new_path;\n-      do {\n-\tif (*new_path == '/')\n-\t  *new_path = DIR_SEPARATOR;\n-      } while (*new_path++);\n-    }\n+    tr (result, '/', DIR_SEPARATOR);\n #endif\n \n-  return path;\n+  return result;\n }\n \n /* Reset the standard prefix */"}, {"sha": "b712900cd829fb8a263e0288bcc86750f7cef3fa", "filename": "gcc/prefix.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fprefix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c042567c98b0a181246523acad810cbf1b35f5/gcc%2Fprefix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.h?ref=51c042567c98b0a181246523acad810cbf1b35f5", "patch": "@@ -22,7 +22,10 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_PREFIX_H\n #define GCC_PREFIX_H\n \n-extern const char *update_path PARAMS ((const char *, const char *));\n+/* Update PATH using KEY if PATH starts with PREFIX.  The returned\n+   string is always malloc-ed, and the caller is responsible for\n+   freeing it.  */\n+extern char *update_path PARAMS ((const char *path, const char *key));\n extern void set_std_prefix PARAMS ((const char *, int));\n \n #endif /* ! GCC_PREFIX_H */"}]}