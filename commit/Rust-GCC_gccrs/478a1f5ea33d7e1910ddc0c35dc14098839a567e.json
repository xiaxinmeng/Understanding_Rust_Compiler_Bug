{"sha": "478a1f5ea33d7e1910ddc0c35dc14098839a567e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4YTFmNWVhMzNkN2UxOTEwZGRjMGMzNWRjMTQwOTg4MzlhNTY3ZQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2005-02-27T04:22:06Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-02-27T04:22:06Z"}, "message": "elf.h, som.h (ASM_OUTPUT_EXTERNAL): Use assemble_name_raw instead of trying to save and restore TREE_SYMBOL_REFERENCED.\n\n\t* pa/elf.h, pa/som.h (ASM_OUTPUT_EXTERNAL): Use assemble_name_raw\n\tinstead of trying to save and restore TREE_SYMBOL_REFERENCED.\n\t* pa/pa64-hpux.h (ASM_OUTPUT_TYPE_DIRECTIVE): Define.\n\t(ASM_OUTPUT_EXTERNAL): Don't save and restore TREE_SYMBOL_REFERENCED.\n\nFrom-SVN: r95605", "tree": {"sha": "cc617f29a3ce79128e6bfcdfba8ab7ff0bb3d12d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc617f29a3ce79128e6bfcdfba8ab7ff0bb3d12d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478a1f5ea33d7e1910ddc0c35dc14098839a567e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478a1f5ea33d7e1910ddc0c35dc14098839a567e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478a1f5ea33d7e1910ddc0c35dc14098839a567e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478a1f5ea33d7e1910ddc0c35dc14098839a567e/comments", "author": null, "committer": null, "parents": [{"sha": "9811fd1712fbef6d68dcdc955ddca896c669992d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9811fd1712fbef6d68dcdc955ddca896c669992d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9811fd1712fbef6d68dcdc955ddca896c669992d"}], "stats": {"total": 120, "additions": 68, "deletions": 52}, "files": [{"sha": "4552e188b9aef13ce1d22ac1b1f06270077db21a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=478a1f5ea33d7e1910ddc0c35dc14098839a567e", "patch": "@@ -1,3 +1,10 @@\n+2005-02-26  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa/elf.h, pa/som.h (ASM_OUTPUT_EXTERNAL): Use assemble_name_raw\n+\tinstead of trying to save and restore TREE_SYMBOL_REFERENCED.\n+\t* pa/pa64-hpux.h (ASM_OUTPUT_TYPE_DIRECTIVE): Define.\n+\t(ASM_OUTPUT_EXTERNAL): Don't save and restore TREE_SYMBOL_REFERENCED.\n+\n 2005-02-26  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.ac: Rename cc_for_cross_gnattools to host_cc_for_libada."}, {"sha": "fe48c3d0fa847d922e6576281f82b581c9881d99", "filename": "gcc/config/pa/elf.h", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2Fconfig%2Fpa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2Fconfig%2Fpa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Felf.h?ref=478a1f5ea33d7e1910ddc0c35dc14098839a567e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for ELF assembler support.\n-   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -45,27 +45,26 @@ do {  \\\n     } \\\n    } while (0)\n \n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.\n-\n-   We call assemble_name, which in turn sets TREE_SYMBOL_REFERENCED.  This\n-   macro will restore the original value of TREE_SYMBOL_REFERENCED to avoid\n-   placing useless function definitions in the output file.\n-\n-   Also note that the SOM based tools need the symbol imported as a CODE\n-   symbol, while the ELF based tools require the symbol to be imported as\n-   an ENTRY symbol.  What a crock.  */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n-  do { int save_referenced;\t\t\t\t\t\\\n-       save_referenced = TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)); \\\n-       fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n-\t assemble_name (FILE, NAME);\t\t\t\t\\\n-       if (FUNCTION_NAME_P (NAME))     \t\t\t\t\\\n-\t fputs (\",ENTRY\\n\", FILE);\t\t\t\t\\\n-       else\t\t\t\t\t\t\t\\\n-\t fputs (\",DATA\\n\", FILE);\t\t\t\t\\\n-       TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)) = save_referenced; \\\n+/* This is how to output a command to make the user-level label\n+   named NAME defined for reference from other files.  We use\n+   assemble_name_raw instead of assemble_name since a symbol in\n+   a .IMPORT directive that isn't otherwise referenced is not\n+   placed in the symbol table of the assembled object.\n+\n+   Failure to import a function reference can cause the HP linker\n+   to segmentation fault!\n+\n+   Note that the SOM based tools need the symbol imported as a\n+   CODE symbol, while the ELF based tools require the symbol to\n+   be imported as an ENTRY symbol.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) \\\n+  do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n+       assemble_name_raw (FILE, NAME);\t\t\t\t\t\\\n+       if (FUNCTION_NAME_P (NAME))     \t\t\t\t\t\\\n+\t fputs (\",ENTRY\\n\", FILE);\t\t\t\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+\t fputs (\",DATA\\n\", FILE);\t\t\t\t\t\\\n      } while (0)\n \n /* The bogus HP assembler requires ALL external references to be"}, {"sha": "5de502d49c19ced5828e479cba7c50122a7e0c92", "filename": "gcc/config/pa/pa64-hpux.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=478a1f5ea33d7e1910ddc0c35dc14098839a567e", "patch": "@@ -174,6 +174,20 @@ Boston, MA 02111-1307, USA.  */\n /* This is how we globalize a label.  */\n #define GLOBAL_ASM_OP\t\"\\t.globl\\t\"\n \n+/* Hacked version from defaults.h that uses assemble_name_raw\n+   instead of assemble_name.  A symbol in a type directive that\n+   isn't otherwise referenced doesn't cause the symbol to be\n+   placed in the symbol table of the assembled object.  */\n+#undef ASM_OUTPUT_TYPE_DIRECTIVE\n+#define ASM_OUTPUT_TYPE_DIRECTIVE(STREAM, NAME, TYPE)\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  fputs (TYPE_ASM_OP, STREAM);\t\t\t\t\t\\\n+  assemble_name_raw (STREAM, NAME);\t\t\t\t\\\n+  fputs (\", \", STREAM);\t\t\t\t\t\t\\\n+  fprintf (STREAM, TYPE_OPERAND_FMT, TYPE);\t\t\t\\\n+  putc ('\\n', STREAM);\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Hacked version from elfos.h that doesn't output a label.  */\n #undef ASM_DECLARE_FUNCTION_NAME\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\\\n@@ -186,15 +200,12 @@ do {\t\t\t\t\t\t\t\t\\\n    dynamic loader to work correctly.  This is equivalent to the\n    HP assembler's .IMPORT directive but relates more directly to\n    ELF object file types.  */\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int save_referenced;\t\t\t\t\t\t\t\\\n-  save_referenced = TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL));\\\n-  if (FUNCTION_NAME_P (NAME))\t\t\t\t\t\t\\\n-    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n-  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)) = save_referenced;\\\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (FUNCTION_NAME_P (NAME))\t\t\t\t\t\\\n+    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\\\n } while (0)\n \n /* We need set the type for external libcalls.  Also note that not all"}, {"sha": "2585bb4d1593afdf5babc18de0e99e5d55121e31", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1f5ea33d7e1910ddc0c35dc14098839a567e/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=478a1f5ea33d7e1910ddc0c35dc14098839a567e", "patch": "@@ -216,27 +216,26 @@ do {\t\t\t\t\t\t\t\t\\\n    So, we force exception information into the data section.  */\n #define TARGET_ASM_EXCEPTION_SECTION data_section\n \n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.\n-\n-   We call assemble_name, which in turn sets TREE_SYMBOL_REFERENCED.  This\n-   macro will restore the original value of TREE_SYMBOL_REFERENCED to avoid\n-   placing useless function definitions in the output file.\n-\n-   Also note that the SOM based tools need the symbol imported as a CODE\n-   symbol, while the ELF based tools require the symbol to be imported as\n-   an ENTRY symbol.  What a crock.  */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n-  do { int save_referenced;\t\t\t\t\t\\\n-       save_referenced = TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)); \\\n-       fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\\\n-       assemble_name (FILE, NAME);\t\t\t\t\\\n-       if (FUNCTION_NAME_P (NAME))     \t\t\t\t\\\n-\t fputs (\",CODE\\n\", FILE);\t\t\t\t\\\n-       else\t\t\t\t\t\t\t\\\n-\t fputs (\",DATA\\n\", FILE);\t\t\t\t\\\n-       TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)) = save_referenced; \\\n+/* This is how to output a command to make the user-level label\n+   named NAME defined for reference from other files.  We use\n+   assemble_name_raw instead of assemble_name since a symbol in\n+   a .IMPORT directive that isn't otherwise referenced is not\n+   placed in the symbol table of the assembled object.\n+\n+   Failure to import a function reference can cause the HP linker\n+   to segmentation fault!\n+\n+   Note that the SOM based tools need the symbol imported as a\n+   CODE symbol, while the ELF based tools require the symbol to\n+   be imported as an ENTRY symbol.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) \\\n+  do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n+       assemble_name_raw (FILE, NAME);\t\t\t\t\t\\\n+       if (FUNCTION_NAME_P (NAME))\t\t\t\t\t\\\n+\t fputs (\",CODE\\n\", FILE);\t\t\t\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+\t fputs (\",DATA\\n\", FILE);\t\t\t\t\t\\\n      } while (0)\n \n /* The bogus HP assembler requires ALL external references to be"}]}