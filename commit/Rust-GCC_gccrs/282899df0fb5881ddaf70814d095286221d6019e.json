{"sha": "282899df0fb5881ddaf70814d095286221d6019e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgyODk5ZGYwZmI1ODgxZGRhZjcwODE0ZDA5NTI4NjIyMWQ2MDE5ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T13:54:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T13:54:07Z"}, "message": "gcse.c (INSN_CUID, [...]): Use gcc_assert and gcc_unreachable.\n\n\t* gcse.c (INSN_CUID, insert_set_in_table, find_avail_set,\n\tcprop_insn, do_local_cprop, local_cprop_pass, find_bypass_set,\n\tprocess_insert_insn, insert_insn_end_bb, pre_insert_copy_insn,\n\thoist_code, extract_mentioned_regs_helper, compute_store_table,\n\tinsert_store): Use gcc_assert and gcc_unreachable.\n\t* ggc-common.c (ggc_splay_alloc, ggc_splay_dont_free,\n\tgt_pch_note_object, gt_pch_note_reorder, relocate_ptrs,\n\tggc_record_overhead): Likewise.\n\t* ggc-page.c (alloc_page, free_page, ggc_set_mark, ggc_marked_p,\n\tinit_ggc, ggc_push_context, ggc_recalculate_in_use_p,\n\tggc_pop_context, clear_marks, validate_free_objects,\n\tggc_pch_read): Likewise.\n\t* ggc-zone.c (ggc_allocated_p, free_chunk, ggc_set_mark,\n\tggc_marked_p, ggc_get_size, init_ggc, destroy_ggc_zone,\n\tggc_push_context, check_cookies, ggc_collect,\n\tggc_print_statistics): Likewise.\n\t* gimple-low.c (lower_function_body, lower_stmt,\n\tlower_bind_expr): Likewise.\n\t* gimplify.c (gimple_tree_eq, push_gimplify_context,\n\tpop_gimplify_context, gimple_pop_condition, create_tmp_var,\n\tdeclare_tmp_vars, gimple_add_tmp_var, annotate_all_with_locus,\n\tmostly_copy_tree_r, gimplify_return_expr, gimplify_switch_expr,\n\tgimplify_case_label_expr, gimplify_exit_block_expr,\n\tcanonicalize_component_ref, gimplify_compound_lval,\n\tgimplify_self_mod_expr, gimplify_call_expr,\n\tgimplify_init_ctor_eval, gimplify_init_constructor,\n\tgimplify_modify_expr, gimplify_save_expr, gimplify_target_expr,\n\tgimplify_expr, check_pointer_types_r,\n\tforce_gimple_operand): Likewise.\n\t* global.c (global_alloc, build_insn_chain): Likewise.\n\t* graph.c (clean_graph_dump_file,\n\tfinish_graph_dump_file): Likewise.\n\tgcov-io.c (gcov_open): Use GCOV_CHECK.\n\nFrom-SVN: r87240", "tree": {"sha": "186a20ffec3fade2a9f7714afe4a71cd22d79511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/186a20ffec3fade2a9f7714afe4a71cd22d79511"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/282899df0fb5881ddaf70814d095286221d6019e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282899df0fb5881ddaf70814d095286221d6019e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282899df0fb5881ddaf70814d095286221d6019e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282899df0fb5881ddaf70814d095286221d6019e/comments", "author": null, "committer": null, "parents": [{"sha": "2a88ebca7670b70c245035a99fd17051f329820f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a88ebca7670b70c245035a99fd17051f329820f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a88ebca7670b70c245035a99fd17051f329820f"}], "stats": {"total": 654, "additions": 288, "deletions": 366}, "files": [{"sha": "652fbfb92f37cab88b09d5cd19735212aada6cf9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -1,11 +1,48 @@\n+2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcse.c (INSN_CUID, insert_set_in_table, find_avail_set,\n+\tcprop_insn, do_local_cprop, local_cprop_pass, find_bypass_set,\n+\tprocess_insert_insn, insert_insn_end_bb, pre_insert_copy_insn,\n+\thoist_code, extract_mentioned_regs_helper, compute_store_table,\n+\tinsert_store): Use gcc_assert and gcc_unreachable.\n+\t* ggc-common.c (ggc_splay_alloc, ggc_splay_dont_free,\n+\tgt_pch_note_object, gt_pch_note_reorder, relocate_ptrs,\n+\tggc_record_overhead): Likewise.\n+\t* ggc-page.c (alloc_page, free_page, ggc_set_mark, ggc_marked_p,\n+\tinit_ggc, ggc_push_context, ggc_recalculate_in_use_p,\n+\tggc_pop_context, clear_marks, validate_free_objects,\n+\tggc_pch_read): Likewise.\n+\t* ggc-zone.c (ggc_allocated_p, free_chunk, ggc_set_mark,\n+\tggc_marked_p, ggc_get_size, init_ggc, destroy_ggc_zone,\n+\tggc_push_context, check_cookies, ggc_collect,\n+\tggc_print_statistics): Likewise.\n+\t* gimple-low.c (lower_function_body, lower_stmt,\n+\tlower_bind_expr): Likewise.\n+\t* gimplify.c (gimple_tree_eq, push_gimplify_context,\n+\tpop_gimplify_context, gimple_pop_condition, create_tmp_var,\n+\tdeclare_tmp_vars, gimple_add_tmp_var, annotate_all_with_locus,\n+\tmostly_copy_tree_r, gimplify_return_expr, gimplify_switch_expr,\n+\tgimplify_case_label_expr, gimplify_exit_block_expr,\n+\tcanonicalize_component_ref, gimplify_compound_lval,\n+\tgimplify_self_mod_expr, gimplify_call_expr,\n+\tgimplify_init_ctor_eval, gimplify_init_constructor,\n+\tgimplify_modify_expr, gimplify_save_expr, gimplify_target_expr,\n+\tgimplify_expr, check_pointer_types_r,\n+\tforce_gimple_operand): Likewise.\n+\t* global.c (global_alloc, build_insn_chain): Likewise.\n+\t* graph.c (clean_graph_dump_file,\n+\tfinish_graph_dump_file): Likewise.\n+\tgcov-io.c (gcov_open): Use GCOV_CHECK.\n+\n 2004-09-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/frv/frv.c (acc_operand, accg_operand): Use REGNO.\n \n 2004-09-09  Jan Hubicka  <jh@suse.cz>\n \n \tmiddle-end/17128\n-\t* tree-inline.c (expand_call_inline): Make overactive sanity check happy.\n+\t* tree-inline.c (expand_call_inline): Make overactive sanity check\n+\thappy.\n \n 2004-09-09  Jan Hubicka  <jh@suse.cz>\n \n@@ -6796,7 +6833,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n+\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "640a55a976f236f5c27f82031838ef2dbb54495c", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -74,8 +74,7 @@ gcov_open (const char *name, int mode)\n   s_flock.l_pid = getpid ();\n #endif\n   \n-  if (gcov_var.file)\n-    abort ();\n+  GCOV_CHECK (!gcov_var.file);\n   gcov_var.start = 0;\n   gcov_var.offset = gcov_var.length = 0;\n   gcov_var.overread = -1u;"}, {"sha": "3e0ede4cfa1f591ee0363fb50654c0ad09f7011e", "filename": "gcc/gcse.c", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -389,7 +389,8 @@ static int max_uid;\n \n /* Get the cuid of an insn.  */\n #ifdef ENABLE_CHECKING\n-#define INSN_CUID(INSN) (INSN_UID (INSN) > max_uid ? (abort (), 0) : uid_cuid[INSN_UID (INSN)])\n+#define INSN_CUID(INSN) \\\n+  (gcc_assert (INSN_UID (INSN) <= max_uid), uid_cuid[INSN_UID (INSN)])\n #else\n #define INSN_CUID(INSN) (uid_cuid[INSN_UID (INSN)])\n #endif\n@@ -1644,9 +1645,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n   struct expr *cur_expr, *last_expr = NULL;\n   struct occr *cur_occr, *last_occr = NULL;\n \n-  if (GET_CODE (x) != SET\n-      || ! REG_P (SET_DEST (x)))\n-    abort ();\n+  gcc_assert (GET_CODE (x) == SET && REG_P (SET_DEST (x)));\n \n   hash = hash_set (REGNO (SET_DEST (x)), table->size);\n \n@@ -2796,8 +2795,7 @@ find_avail_set (int regno, rtx insn)\n       if (set == 0)\n \tbreak;\n \n-      if (GET_CODE (set->expr) != SET)\n-\tabort ();\n+      gcc_assert (GET_CODE (set->expr) == SET);\n \n       src = SET_SRC (set->expr);\n \n@@ -3013,8 +3011,7 @@ cprop_insn (rtx insn, int alter_jumps)\n \n       pat = set->expr;\n       /* ??? We might be able to handle PARALLELs.  Later.  */\n-      if (GET_CODE (pat) != SET)\n-\tabort ();\n+      gcc_assert (GET_CODE (pat) == SET);\n \n       src = SET_SRC (pat);\n \n@@ -3155,8 +3152,11 @@ do_local_cprop (rtx x, rtx insn, int alter_jumps, rtx *libcall_sp)\n \t     or fix delete_trivially_dead_insns to preserve the setting insn,\n \t     or make it delete the REG_EUAQL note, and fix up all passes that\n \t     require the REG_EQUAL note there.  */\n-\t  if (!adjust_libcall_notes (x, newcnst, insn, libcall_sp))\n-\t    abort ();\n+\t  bool adjusted;\n+\n+\t  adjusted = adjust_libcall_notes (x, newcnst, insn, libcall_sp);\n+\t  gcc_assert (adjusted);\n+\t  \n \t  if (gcse_file != NULL)\n \t    {\n \t      fprintf (gcse_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n@@ -3245,8 +3245,7 @@ local_cprop_pass (int alter_jumps)\n \n \t  if (note)\n \t    {\n-\t      if (libcall_sp == libcall_stack)\n-\t\tabort ();\n+\t      gcc_assert (libcall_sp != libcall_stack);\n \t      *--libcall_sp = XEXP (note, 0);\n \t    }\n \t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n@@ -3520,8 +3519,7 @@ find_bypass_set (int regno, int bb)\n       if (set == 0)\n \tbreak;\n \n-      if (GET_CODE (set->expr) != SET)\n-\tabort ();\n+      gcc_assert (GET_CODE (set->expr) == SET);\n \n       src = SET_SRC (set->expr);\n       if (gcse_constant_p (src))\n@@ -4004,8 +4002,13 @@ process_insert_insn (struct expr *expr)\n   /* Otherwise, make a new insn to compute this expression and make sure the\n      insn will be recognized (this also adds any needed CLOBBERs).  Copy the\n      expression to make sure we don't have any sharing issues.  */\n-  else if (insn_invalid_p (emit_insn (gen_rtx_SET (VOIDmode, reg, exp))))\n-    abort ();\n+  else\n+    {\n+      rtx insn = emit_insn (gen_rtx_SET (VOIDmode, reg, exp));\n+\n+      gcc_assert (!insn_invalid_p (insn));\n+    }\n+  \n \n   pat = get_insns ();\n   end_sequence ();\n@@ -4031,8 +4034,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n   rtx pat, pat_end;\n \n   pat = process_insert_insn (expr);\n-  if (pat == NULL_RTX || ! INSN_P (pat))\n-    abort ();\n+  gcc_assert (pat && INSN_P (pat));\n \n   pat_end = pat;\n   while (NEXT_INSN (pat_end) != NULL_RTX)\n@@ -4052,10 +4054,9 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n       /* It should always be the case that we can put these instructions\n \t anywhere in the basic block with performing PRE optimizations.\n \t Check this.  */\n-      if (NONJUMP_INSN_P (insn) && pre\n-\t  && !TEST_BIT (antloc[bb->index], expr->bitmap_index)\n-\t  && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n-\tabort ();\n+      gcc_assert (!NONJUMP_INSN_P (insn) || !pre\n+\t\t  || TEST_BIT (antloc[bb->index], expr->bitmap_index)\n+\t\t  || TEST_BIT (transp[bb->index], expr->bitmap_index));\n \n       /* If this is a jump table, then we can't insert stuff here.  Since\n \t we know the previous real insn must be the tablejump, we insert\n@@ -4097,10 +4098,9 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \t anywhere in the basic block with performing PRE optimizations.\n \t Check this.  */\n \n-      if (pre\n-\t  && !TEST_BIT (antloc[bb->index], expr->bitmap_index)\n-\t  && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n-\tabort ();\n+      gcc_assert (!pre\n+\t\t  || TEST_BIT (antloc[bb->index], expr->bitmap_index)\n+\t\t  || TEST_BIT (transp[bb->index], expr->bitmap_index));\n \n       /* Since different machines initialize their parameter registers\n \t in different orders, assume nothing.  Collect the set of all\n@@ -4257,10 +4257,13 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n   int i;\n \n   /* This block matches the logic in hash_scan_insn.  */\n-  if (GET_CODE (pat) == SET)\n-    set = pat;\n-  else if (GET_CODE (pat) == PARALLEL)\n+  switch (GET_CODE (pat))\n     {\n+    case SET:\n+      set = pat;\n+      break;\n+\n+    case PARALLEL:\n       /* Search through the parallel looking for the set whose\n \t source was the expression that we're interested in.  */\n       set = NULL_RTX;\n@@ -4274,9 +4277,11 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n \t      break;\n \t    }\n \t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   if (REG_P (SET_DEST (set)))\n     {\n@@ -4970,15 +4975,10 @@ hoist_code (void)\n \t\t      while (BLOCK_FOR_INSN (occr->insn) != dominated && occr)\n \t\t\toccr = occr->next;\n \n-\t\t      /* Should never happen.  */\n-\t\t      if (!occr)\n-\t\t\tabort ();\n-\n+\t\t      gcc_assert (occr);\n \t\t      insn = occr->insn;\n-\n \t\t      set = single_set (insn);\n-\t\t      if (! set)\n-\t\t\tabort ();\n+\t\t      gcc_assert (set);\n \n \t\t      /* Create a pseudo-reg to store the result of reaching\n \t\t\t expressions into.  Get the mode for the new pseudo\n@@ -5556,7 +5556,7 @@ extract_mentioned_regs_helper (rtx x, rtx accum)\n     case POST_DEC:\n     case POST_INC:\n       /* We do not run this function with arguments having side effects.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case PC:\n     case CC0: /*FIXME*/\n@@ -5830,8 +5830,7 @@ compute_store_table (void)\n #ifdef ENABLE_CHECKING\n       /* last_set_in should now be all-zero.  */\n       for (regno = 0; regno < max_gcse_regno; regno++)\n-\tif (last_set_in[regno] != 0)\n-\t  abort ();\n+\tgcc_assert (!last_set_in[regno]);\n #endif\n \n       /* Clear temporary marks.  */\n@@ -6204,8 +6203,8 @@ insert_store (struct ls_expr * expr, edge e)\n     if (!(tmp->flags & EDGE_FAKE))\n       {\n \tint index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);\n-\tif (index == EDGE_INDEX_NO_EDGE)\n-\t  abort ();\n+\t\n+\tgcc_assert (index != EDGE_INDEX_NO_EDGE);\n \tif (! TEST_BIT (pre_insert_map[index], expr->index))\n \t  break;\n       }"}, {"sha": "ccda55c8c539387815faf2a72df9dddea103baf5", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -197,16 +197,14 @@ ggc_calloc (size_t s1, size_t s2)\n void *\n ggc_splay_alloc (int sz, void *nl)\n {\n-  if (nl != NULL)\n-    abort ();\n+  gcc_assert (!nl);\n   return ggc_alloc (sz);\n }\n \n void\n ggc_splay_dont_free (void * x ATTRIBUTE_UNUSED, void *nl)\n {\n-  if (nl != NULL)\n-    abort ();\n+  gcc_assert (!nl);\n }\n \n /* Print statistics that are independent of the collector in use.  */\n@@ -266,9 +264,8 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n \t\t\t      INSERT);\n   if (*slot != NULL)\n     {\n-      if ((*slot)->note_ptr_fn != note_ptr_fn\n-\t  || (*slot)->note_ptr_cookie != note_ptr_cookie)\n-\tabort ();\n+      gcc_assert ((*slot)->note_ptr_fn == note_ptr_fn\n+\t\t  && (*slot)->note_ptr_cookie == note_ptr_cookie);\n       return 0;\n     }\n \n@@ -295,9 +292,7 @@ gt_pch_note_reorder (void *obj, void *note_ptr_cookie,\n     return;\n \n   data = htab_find_with_hash (saving_htab, obj, POINTER_HASH (obj));\n-  if (data == NULL\n-      || data->note_ptr_cookie != note_ptr_cookie)\n-    abort ();\n+  gcc_assert (data && data->note_ptr_cookie == note_ptr_cookie);\n \n   data->reorder_fn = reorder_fn;\n }\n@@ -376,8 +371,7 @@ relocate_ptrs (void *ptr_p, void *state_p)\n     return;\n \n   result = htab_find_with_hash (saving_htab, *ptr, POINTER_HASH (*ptr));\n-  if (result == NULL)\n-    abort ();\n+  gcc_assert (result);\n   *ptr = result->new_addr;\n }\n \n@@ -873,8 +867,7 @@ ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n   if (!ptr_hash)\n     ptr_hash = htab_create (10, hash_ptr, eq_ptr, NULL);\n   slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr), INSERT);\n-  if (*slot)\n-    abort ();\n+  gcc_assert (!*slot);\n   *slot = p;\n \n   loc->times++;"}, {"sha": "a5eb8915a239fd8455b15ee0a73eb91bef79b458", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 26, "deletions": 61, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -821,8 +821,7 @@ alloc_page (unsigned order)\n \t      enda -= G.pagesize;\n \t      tail_slop += G.pagesize;\n \t    }\n-\t  if (tail_slop < sizeof (page_group))\n-\t    abort ();\n+\t  gcc_assert (tail_slop >= sizeof (page_group));\n \t  group = (page_group *)enda;\n \t  tail_slop -= sizeof (page_group);\n \t}\n@@ -930,22 +929,16 @@ free_page (page_entry *entry)\n   if (G.by_depth_in_use > 1)\n     {\n       page_entry *top = G.by_depth[G.by_depth_in_use-1];\n-\n-      /* If they are at the same depth, put top element into freed\n-\t slot.  */\n-      if (entry->context_depth == top->context_depth)\n-\t{\n-\t  int i = entry->index_by_depth;\n-\t  G.by_depth[i] = top;\n-\t  G.save_in_use[i] = G.save_in_use[G.by_depth_in_use-1];\n-\t  top->index_by_depth = i;\n-\t}\n-      else\n-\t{\n-\t  /* We cannot free a page from a context deeper than the\n-\t     current one.  */\n-\t  abort ();\n-\t}\n+      int i = entry->index_by_depth;\n+\n+      /* We cannot free a page from a context deeper than the current\n+\t one.  */\n+      gcc_assert (entry->context_depth == top->context_depth);\n+      \n+      /* Put top element into freed slot.  */\n+      G.by_depth[i] = top;\n+      G.save_in_use[i] = G.save_in_use[G.by_depth_in_use-1];\n+      top->index_by_depth = i;\n     }\n   --G.by_depth_in_use;\n \n@@ -1259,10 +1252,7 @@ ggc_set_mark (const void *p)\n   /* Look up the page on which the object is alloced.  If the object\n      wasn't allocated by the collector, we'll probably die.  */\n   entry = lookup_page_table_entry (p);\n-#ifdef ENABLE_CHECKING\n-  if (entry == NULL)\n-    abort ();\n-#endif\n+  gcc_assert (entry);\n \n   /* Calculate the index of the object on the page; this is its bit\n      position in the in_use_p bitmap.  */\n@@ -1298,10 +1288,7 @@ ggc_marked_p (const void *p)\n   /* Look up the page on which the object is alloced.  If the object\n      wasn't allocated by the collector, we'll probably die.  */\n   entry = lookup_page_table_entry (p);\n-#ifdef ENABLE_CHECKING\n-  if (entry == NULL)\n-    abort ();\n-#endif\n+  gcc_assert (entry);\n \n   /* Calculate the index of the object on the page; this is its bit\n      position in the in_use_p bitmap.  */\n@@ -1474,8 +1461,7 @@ init_ggc (void)\n \t   can't get something useful, give up.  */\n \n \tp = alloc_anon (NULL, G.pagesize);\n-\tif ((size_t)p & (G.pagesize - 1))\n-\t  abort ();\n+\tgcc_assert (!((size_t)p & (G.pagesize - 1)));\n       }\n \n     /* We have a good page, might as well hold onto it...  */\n@@ -1556,8 +1542,7 @@ ggc_push_context (void)\n   ++G.context_depth;\n \n   /* Die on wrap.  */\n-  if (G.context_depth >= HOST_BITS_PER_LONG)\n-    abort ();\n+  gcc_assert (G.context_depth < HOST_BITS_PER_LONG);\n }\n \n /* Merge the SAVE_IN_USE_P and IN_USE_P arrays in P so that IN_USE_P\n@@ -1593,8 +1578,7 @@ ggc_recalculate_in_use_p (page_entry *p)\n \tp->num_free_objects -= (j & 1);\n     }\n \n-  if (p->num_free_objects >= num_objects)\n-    abort ();\n+  gcc_assert (p->num_free_objects < num_objects);\n }\n \n /* Decrement the `GC context'.  All objects allocated since the\n@@ -1634,18 +1618,12 @@ ggc_pop_context (void)\n \t recalculate the in use bits.  */\n       for (i = G.depth[depth]; i < e; ++i)\n \t{\n-\t  page_entry *p;\n-\n-#ifdef ENABLE_CHECKING\n-\t  p = G.by_depth[i];\n+\t  page_entry *p = G.by_depth[i];\n \n \t  /* Check that all of the pages really are at the depth that\n \t     we expect.  */\n-\t  if (p->context_depth != depth)\n-\t    abort ();\n-\t  if (p->index_by_depth != i)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (p->context_depth == depth);\n+\t  gcc_assert (p->index_by_depth == i);\n \n \t  prefetch (&save_in_use_p_i (i+8));\n \t  prefetch (&save_in_use_p_i (i+16));\n@@ -1667,12 +1645,8 @@ ggc_pop_context (void)\n \n       /* Check that all of the pages really are at the depth we\n \t expect.  */\n-#ifdef ENABLE_CHECKING\n-      if (p->context_depth <= depth)\n-\tabort ();\n-      if (p->index_by_depth != i)\n-\tabort ();\n-#endif\n+      gcc_assert (p->context_depth > depth);\n+      gcc_assert (p->index_by_depth == i);\n       p->context_depth = depth;\n     }\n \n@@ -1684,12 +1658,8 @@ ggc_pop_context (void)\n       page_entry *p;\n \n       for (p = G.pages[order]; p != NULL; p = p->next)\n-\t{\n-\t  if (p->context_depth > depth)\n-\t    abort ();\n-\t  else if (p->context_depth == depth && save_in_use_p (p))\n-\t    abort ();\n-\t}\n+\tgcc_assert (p->context_depth < depth ||\n+\t\t    (p->context_depth == depth && !save_in_use_p (p)));\n     }\n #endif\n }\n@@ -1710,11 +1680,8 @@ clear_marks (void)\n \t  size_t num_objects = OBJECTS_IN_PAGE (p);\n \t  size_t bitmap_size = BITMAP_SIZE (num_objects + 1);\n \n-#ifdef ENABLE_CHECKING\n \t  /* The data should be page-aligned.  */\n-\t  if ((size_t) p->page & (G.pagesize - 1))\n-\t    abort ();\n-#endif\n+\t  gcc_assert (!((size_t) p->page & (G.pagesize - 1)));\n \n \t  /* Pages that aren't in the topmost context are not collected;\n \t     nevertheless, we need their in-use bit vectors to store GC\n@@ -1944,8 +1911,7 @@ validate_free_objects (void)\n \n       /* Make certain it isn't visible from any root.  Notice that we\n \t do this check before sweep_pages merges save_in_use_p.  */\n-      if (pe->in_use_p[word] & (1UL << bit))\n-\tabort ();\n+      gcc_assert (!(pe->in_use_p[word] & (1UL << bit)));\n \n       /* If the object comes from an outer context, then retain the\n \t free_object entry, so that we can verify that the address\n@@ -2341,8 +2307,7 @@ ggc_pch_read (FILE *f, void *addr)\n   /* No object read from a PCH file should ever be freed.  So, set the\n      context depth to 1, and set the depth of all the currently-allocated\n      pages to be 1 too.  PCH pages will have depth 0.  */\n-  if (G.context_depth != 0)\n-    abort ();\n+  gcc_assert (!G.context_depth);\n   G.context_depth = 1;\n   for (i = 0; i < NUM_ORDERS; i++)\n     {"}, {"sha": "311fff6da017c19e3a9ad4f9d3358f435c9be97d", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -368,8 +368,7 @@ ggc_allocated_p (const void *p)\n   struct alloc_chunk *chunk;\n   chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n #ifdef COOKIE_CHECKING\n-  if (chunk->magic != CHUNK_MAGIC)\n-    abort ();\n+  gcc_assert (chunk->magic == CHUNK_MAGIC);\n #endif\n   if (chunk->type == 1)\n     return true;  \n@@ -578,13 +577,11 @@ free_chunk (struct alloc_chunk *chunk, size_t size, struct alloc_zone *zone)\n   size_t bin = 0;\n \n   bin = SIZE_BIN_DOWN (size);\n-  if (bin == 0)\n-    abort ();\n+  gcc_assert (bin);\n   if (bin > NUM_FREE_BINS)\n     bin = 0;\n #ifdef COOKIE_CHECKING\n-  if (chunk->magic != CHUNK_MAGIC && chunk->magic != DEADCHUNK_MAGIC)\n-    abort ();\n+  gcc_assert (chunk->magic == CHUNK_MAGIC || chunk->magic == DEADCHUNK_MAGIC);\n   chunk->magic = DEADCHUNK_MAGIC;\n #endif\n   chunk->u.next_free = zone->free_chunks[bin];\n@@ -830,8 +827,7 @@ ggc_set_mark (const void *p)\n \n   chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n #ifdef COOKIE_CHECKING\n-  if (chunk->magic != CHUNK_MAGIC)\n-    abort ();\n+  gcc_assert (chunk->magic == CHUNK_MAGIC);\n #endif\n   if (chunk->mark)\n     return 1;\n@@ -854,8 +850,7 @@ ggc_marked_p (const void *p)\n \n   chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n #ifdef COOKIE_CHECKING\n-  if (chunk->magic != CHUNK_MAGIC)\n-    abort ();\n+  gcc_assert (chunk->magic == CHUNK_MAGIC);\n #endif\n   return chunk->mark;\n }\n@@ -869,8 +864,7 @@ ggc_get_size (const void *p)\n \n   chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n #ifdef COOKIE_CHECKING\n-  if (chunk->magic != CHUNK_MAGIC)\n-    abort ();\n+  gcc_assert (chunk->magic == CHUNK_MAGIC);\n #endif\n   if (chunk->large)\n     return chunk->size * 1024;\n@@ -895,8 +889,7 @@ init_ggc (void)\n   G.lg_pagesize = exact_log2 (G.pagesize);\n #ifdef HAVE_MMAP_DEV_ZERO\n   G.dev_zero_fd = open (\"/dev/zero\", O_RDONLY);\n-  if (G.dev_zero_fd == -1)\n-    abort ();\n+  gcc_assert (G.dev_zero_fd != -1);\n #endif\n \n #if 0\n@@ -920,8 +913,7 @@ init_ggc (void)\n \t   can't get something useful, give up.  */\n \n \tp = alloc_anon (NULL, G.pagesize, &main_zone);\n-\tif ((size_t)p & (G.pagesize - 1))\n-\t  abort ();\n+\tgcc_assert (!((size_t)p & (G.pagesize - 1)));\n       }\n \n     /* We have a good page, might as well hold onto it...  */\n@@ -953,13 +945,11 @@ destroy_ggc_zone (struct alloc_zone * dead_zone)\n   struct alloc_zone *z;\n \n   for (z = G.zones; z && z->next_zone != dead_zone; z = z->next_zone)\n-    /* Just find that zone.  */ ;\n+    /* Just find that zone.  */\n+    continue;\n \n-#ifdef ENABLE_CHECKING\n   /* We should have found the zone in the list.  Anything else is fatal.  */\n-  if (!z)\n-    abort ();\n-#endif\n+  gcc_assert (z);\n \n   /* z is dead, baby. z is dead.  */\n   z->dead= true;\n@@ -975,8 +965,7 @@ ggc_push_context (void)\n   for (zone = G.zones; zone; zone = zone->next_zone)\n     ++(zone->context_depth);\n   /* Die on wrap.  */\n-  if (main_zone.context_depth >= HOST_BITS_PER_LONG)\n-    abort ();\n+  gcc_assert (main_zone.context_depth < HOST_BITS_PER_LONG);\n }\n \n /* Decrement the `GC context'.  All objects allocated since the\n@@ -1204,8 +1193,8 @@ check_cookies (void)\n \t      struct alloc_chunk *end = (struct alloc_chunk *)(p->page + G.pagesize);\n \t      do\n \t\t{\n-\t\t  if (chunk->magic != CHUNK_MAGIC && chunk->magic != DEADCHUNK_MAGIC)\n-\t\t    abort ();\n+\t\t  gcc_assert (chunk->magic == CHUNK_MAGIC\n+\t\t\t      || chunk->magic == DEADCHUNK_MAGIC);\n \t\t  chunk = (struct alloc_chunk *)(chunk->u.data + chunk->size);\n \t\t}\n \t      while (chunk < end);\n@@ -1334,8 +1323,7 @@ ggc_collect (void)\n \t  printf (\"Zone `%s' is dead and will be freed.\\n\", dead_zone->name);\n \n \t  /* The zone must be empty.  */\n-\t  if (dead_zone->allocated != 0)\n-\t    abort ();\n+\t  gcc_assert (!dead_zone->allocated);\n \n \t  /* Unchain the dead zone, release all its pages and free it.  */\n \t  zone->next_zone = zone->next_zone->next_zone;\n@@ -1415,10 +1403,7 @@ ggc_print_statistics (void)\n \t      in_use += p->bytes - CHUNK_OVERHEAD;\n \t      chunk = (struct alloc_chunk *) p->page;\n \t      overhead += CHUNK_OVERHEAD;\n-\t      if (!chunk->type)\n-\t\tabort ();\n-\t      if (chunk->mark)\n-\t\tabort ();\n+\t      gcc_assert (chunk->type && !chunk->mark);\n \t      continue;\n \t    }\n \n@@ -1429,8 +1414,7 @@ ggc_print_statistics (void)\n \t      overhead += CHUNK_OVERHEAD;\n \t      if (chunk->type)\n \t\tin_use += chunk->size;\n-\t      if (chunk->mark)\n-\t\tabort ();\n+\t      gcc_assert (!chunk->mark);\n \t    }\n \t}\n       fprintf (stderr, \"%20s %10lu%c %10lu%c %10lu%c\\n\",\n@@ -1439,8 +1423,7 @@ ggc_print_statistics (void)\n \t       SCALE (in_use), LABEL (in_use),\n \t       SCALE (overhead), LABEL (overhead));\n \n-      if (in_use != zone->allocated)\n-\tabort ();\n+      gcc_assert (in_use == zone->allocated);\n \n       total_overhead += overhead;\n       total_allocated += zone->allocated;"}, {"sha": "c6f6f7611e2a39792feeada69e5573026adc92ef", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -69,8 +69,7 @@ lower_function_body (void)\n   tree_stmt_iterator i;\n   tree t, x;\n \n-  if (TREE_CODE (bind) != BIND_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (bind) == BIND_EXPR);\n \n   data.block = DECL_INITIAL (current_function_decl);\n   BLOCK_SUBBLOCKS (data.block) = NULL_TREE;\n@@ -117,8 +116,7 @@ lower_function_body (void)\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n     }\n \n-  if (data.block != DECL_INITIAL (current_function_decl))\n-    abort ();\n+  gcc_assert (data.block == DECL_INITIAL (current_function_decl));\n   BLOCK_SUBBLOCKS (data.block)\n     = blocks_nreverse (BLOCK_SUBBLOCKS (data.block));\n \n@@ -200,9 +198,12 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n       break;\n \n     default:\n+#ifdef ENABLE_CHECKING\n       print_node_brief (stderr, \"\", stmt, 0);\n+      internal_error (\"unexpected node\");\n+#endif\n     case COMPOUND_EXPR:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   tsi_next (tsi);\n@@ -224,15 +225,13 @@ lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n \t  /* The outermost block of the original function may not be the\n \t     outermost statement chain of the gimplified function.  So we\n \t     may see the outermost block just inside the function.  */\n-\t  if (new_block != DECL_INITIAL (current_function_decl))\n-\t    abort ();\n+\t  gcc_assert (new_block == DECL_INITIAL (current_function_decl));\n \t  new_block = NULL;\n \t}\n       else\n \t{\n \t  /* We do not expect to handle duplicate blocks.  */\n-\t  if (TREE_ASM_WRITTEN (new_block))\n-\t    abort ();\n+\t  gcc_assert (!TREE_ASM_WRITTEN (new_block));\n \t  TREE_ASM_WRITTEN (new_block) = 1;\n \n \t  /* Block tree may get clobbered by inlining.  Normally this would\n@@ -252,8 +251,7 @@ lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n \n   if (new_block)\n     {\n-      if (data->block != new_block)\n-\tabort ();\n+      gcc_assert (data->block == new_block);\n \n       BLOCK_SUBBLOCKS (new_block)\n \t= blocks_nreverse (BLOCK_SUBBLOCKS (new_block));"}, {"sha": "c657f6af77a3f0c1f260f230f4221caa9562ce4a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 130, "deletions": 170, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -103,8 +103,7 @@ gimple_tree_eq (const void *p1, const void *p2)\n \n   /* Only allow them to compare equal if they also hash equal; otherwise\n      results are nondeterminate, and we fail bootstrap comparison.  */\n-  if (gimple_tree_hash (p1) != gimple_tree_hash (p2))\n-    abort ();\n+  gcc_assert (gimple_tree_hash (p1) == gimple_tree_hash (p2));\n \n   return 1;\n }\n@@ -114,8 +113,7 @@ gimple_tree_eq (const void *p1, const void *p2)\n void\n push_gimplify_context (void)\n {\n-  if (gimplify_ctxp)\n-    abort ();\n+  gcc_assert (!gimplify_ctxp);\n   gimplify_ctxp\n     = (struct gimplify_ctx *) xcalloc (1, sizeof (struct gimplify_ctx));\n   if (optimize)\n@@ -134,8 +132,7 @@ pop_gimplify_context (tree body)\n {\n   tree t;\n \n-  if (!gimplify_ctxp || gimplify_ctxp->current_bind_expr)\n-    abort ();\n+  gcc_assert (gimplify_ctxp && !gimplify_ctxp->current_bind_expr);\n \n   for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n     DECL_GIMPLE_FORMAL_TEMP_P (t) = 0;\n@@ -202,13 +199,12 @@ gimple_pop_condition (tree *pre_p)\n {\n   int conds = --(gimplify_ctxp->conditions);\n \n+  gcc_assert (conds >= 0);\n   if (conds == 0)\n     {\n       append_to_statement_list (gimplify_ctxp->conditional_cleanups, pre_p);\n       gimplify_ctxp->conditional_cleanups = NULL_TREE;\n     }\n-  else if (conds < 0)\n-    abort ();\n }\n \n /* A subroutine of append_to_statement_list{,_force}.  */\n@@ -357,14 +353,11 @@ create_tmp_var (tree type, const char *prefix)\n {\n   tree tmp_var;\n \n-#if defined ENABLE_CHECKING\n   /* We don't allow types that are addressable (meaning we can't make copies),\n      incomplete, or of variable size.  */\n-  if (TREE_ADDRESSABLE (type)\n-      || !COMPLETE_TYPE_P (type)\n-      || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n-    abort ();\n-#endif\n+  gcc_assert (!TREE_ADDRESSABLE (type)\n+\t      && COMPLETE_TYPE_P (type)\n+\t      && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST);\n \n   tmp_var = create_tmp_var_raw (type, prefix);\n   gimple_add_tmp_var (tmp_var);\n@@ -517,8 +510,7 @@ declare_tmp_vars (tree vars, tree scope)\n       while (TREE_CODE (scope) == COMPOUND_EXPR)\n \tscope = TREE_OPERAND (scope, 0);\n \n-      if (TREE_CODE (scope) != BIND_EXPR)\n-\tabort ();\n+      gcc_assert (TREE_CODE (scope) == BIND_EXPR);\n \n       temps = nreverse (last);\n       TREE_CHAIN (last) = BIND_EXPR_VARS (scope);\n@@ -529,8 +521,7 @@ declare_tmp_vars (tree vars, tree scope)\n void\n gimple_add_tmp_var (tree tmp)\n {\n-  if (TREE_CHAIN (tmp) || DECL_SEEN_IN_BIND_EXPR_P (tmp))\n-    abort ();\n+  gcc_assert (!TREE_CHAIN (tmp) && !DECL_SEEN_IN_BIND_EXPR_P (tmp));\n \n   DECL_CONTEXT (tmp) = current_function_decl;\n   DECL_SEEN_IN_BIND_EXPR_P (tmp) = 1;\n@@ -585,13 +576,10 @@ annotate_all_with_locus (tree *stmt_p, location_t locus)\n     {\n       tree t = tsi_stmt (i);\n \n-#ifdef ENABLE_CHECKING\n-\t  /* Assuming we've already been gimplified, we shouldn't\n-\t     see nested chaining constructs anymore.  */\n-\t  if (TREE_CODE (t) == STATEMENT_LIST\n-\t      || TREE_CODE (t) == COMPOUND_EXPR)\n-\t    abort ();\n-#endif\n+      /* Assuming we've already been gimplified, we shouldn't\n+\t  see nested chaining constructs anymore.  */\n+      gcc_assert (TREE_CODE (t) != STATEMENT_LIST\n+\t\t  && TREE_CODE (t) != COMPOUND_EXPR);\n \n       annotate_one_with_locus (t, locus);\n     }\n@@ -616,10 +604,11 @@ mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n \t uses.  So just avert our eyes and cross our fingers.  Silly Java.  */\n       || code == BLOCK)\n     *walk_subtrees = 0;\n-  else if (code == BIND_EXPR)\n-    abort ();\n   else\n-    copy_tree_r (tp, walk_subtrees, data);\n+    {\n+      gcc_assert (code != BIND_EXPR);\n+      copy_tree_r (tp, walk_subtrees, data);\n+    }\n \n   return NULL_TREE;\n }\n@@ -924,12 +913,10 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n       if (TREE_CODE (result_decl) == INDIRECT_REF)\n \t/* See through a return by reference.  */\n \tresult_decl = TREE_OPERAND (result_decl, 0);\n-#ifdef ENABLE_CHECKING\n-      if ((TREE_CODE (ret_expr) != MODIFY_EXPR\n-\t   && TREE_CODE (ret_expr) != INIT_EXPR)\n-\t  || TREE_CODE (result_decl) != RESULT_DECL)\n-\tabort ();\n-#endif\n+\n+      gcc_assert ((TREE_CODE (ret_expr) == MODIFY_EXPR\n+\t\t   || TREE_CODE (ret_expr) == INIT_EXPR)\n+\t\t  && TREE_CODE (result_decl) == RESULT_DECL);\n     }\n \n   /* If aggregate_value_p is true, then we can return the bare RESULT_DECL.\n@@ -1150,8 +1137,7 @@ gimplify_switch_expr (tree *expr_p, tree *pre_p)\n \n       /* If someone can be bothered to fill in the labels, they can\n \t be bothered to null out the body too.  */\n-      if (SWITCH_LABELS (switch_expr))\n-\tabort ();\n+      gcc_assert (!SWITCH_LABELS (switch_expr));\n \n       saved_labels = gimplify_ctxp->case_labels;\n       VARRAY_TREE_INIT (gimplify_ctxp->case_labels, 8, \"case_labels\");\n@@ -1201,8 +1187,8 @@ gimplify_switch_expr (tree *expr_p, tree *pre_p)\n \n       SWITCH_BODY (switch_expr) = NULL;\n     }\n-  else if (!SWITCH_LABELS (switch_expr))\n-    abort ();\n+  else\n+    gcc_assert (SWITCH_LABELS (switch_expr));\n \n   return ret;\n }\n@@ -1211,10 +1197,9 @@ static enum gimplify_status\n gimplify_case_label_expr (tree *expr_p)\n {\n   tree expr = *expr_p;\n-  if (gimplify_ctxp->case_labels)\n-    VARRAY_PUSH_TREE (gimplify_ctxp->case_labels, expr);\n-  else\n-    abort ();\n+\n+  gcc_assert (gimplify_ctxp->case_labels);\n+  VARRAY_PUSH_TREE (gimplify_ctxp->case_labels, expr);\n   *expr_p = build (LABEL_EXPR, void_type_node, CASE_LABEL (expr));\n   return GS_ALL_DONE;\n }\n@@ -1248,10 +1233,7 @@ gimplify_exit_block_expr (tree *expr_p)\n \n   /* First operand must be a LABELED_BLOCK_EXPR, which should\n      already be lowered (or partially lowered) when we get here.  */\n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (labeled_block) != LABELED_BLOCK_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (labeled_block) == LABELED_BLOCK_EXPR);\n \n   label = LABELED_BLOCK_LABEL (labeled_block);\n   *expr_p = build1 (GOTO_EXPR, void_type_node, label);\n@@ -1325,8 +1307,7 @@ canonicalize_component_ref (tree *expr_p)\n   tree expr = *expr_p;\n   tree type;\n \n-  if (TREE_CODE (expr) != COMPONENT_REF)\n-    abort ();\n+  gcc_assert (TREE_CODE (expr) == COMPONENT_REF);\n \n   if (INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n     type = TREE_TYPE (get_unwidened (expr, NULL_TREE));\n@@ -1485,10 +1466,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n        p = &TREE_OPERAND (*p, 0))\n     VARRAY_PUSH_GENERIC_PTR_NOGC (stack, *p);\n \n-#if defined ENABLE_CHECKING\n-  if (VARRAY_ACTIVE_SIZE (stack) == 0)\n-    abort ();\n-#endif\n+  gcc_assert (VARRAY_ACTIVE_SIZE (stack));\n \n   /* Now STACK is a stack of pointers to all the refs we've walked through\n      and P points to the innermost expression.\n@@ -1651,13 +1629,8 @@ gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n   code = TREE_CODE (*expr_p);\n \n-#if defined ENABLE_CHECKING\n-  if (code != POSTINCREMENT_EXPR\n-      && code != POSTDECREMENT_EXPR\n-      && code != PREINCREMENT_EXPR\n-      && code != PREDECREMENT_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR\n+\t      || code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR);\n \n   /* Prefix or postfix?  */\n   if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n@@ -1772,10 +1745,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   tree arglist;\n   enum gimplify_status ret;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (*expr_p) != CALL_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);\n \n   /* For reliable diagnostics during inlining, it is necessary that \n      every call_expr be annotated with file and line.  */\n@@ -2449,11 +2419,9 @@ gimplify_init_ctor_eval (tree object, tree list, tree *pre_p, bool cleared)\n \t{\n \t  /* ??? Here's to hoping the front end fills in all of the indicies,\n \t     so we don't have to figure out what's missing ourselves.  */\n-\t  if (!purpose)\n-\t    abort ();\n+\t  gcc_assert (purpose);\n \t  /* ??? Need to handle this.  */\n-\t  if (TREE_CODE (purpose) == RANGE_EXPR)\n-\t    abort ();\n+\t  gcc_assert (TREE_CODE (purpose) != RANGE_EXPR);\n \n \t  cref = build (ARRAY_REF, array_elt_type, unshare_expr (object),\n \t\t\tpurpose, NULL_TREE, NULL_TREE);\n@@ -2668,8 +2636,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    if (elt_list)\n \t      {\n \t\ti = TREE_VALUE (elt_list);\n-\t\tif (TREE_CHAIN (elt_list))\n-\t\t  abort ();\n+\t\tgcc_assert (!TREE_CHAIN (elt_list));\n \t      }\n \t  }\n \tif (r == NULL || i == NULL)\n@@ -2720,7 +2687,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \n     default:\n       /* So how did we get a CONSTRUCTOR for a scalar type?  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (ret == GS_ERROR)\n@@ -2827,10 +2794,8 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   tree *to_p = &TREE_OPERAND (*expr_p, 0);\n   enum gimplify_status ret = GS_UNHANDLED;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (*expr_p) != MODIFY_EXPR && TREE_CODE (*expr_p) != INIT_EXPR)\n-    abort ();\n-#endif\n+  gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR\n+\t      || TREE_CODE (*expr_p) == INIT_EXPR);\n \n   /* The distinction between MODIFY_EXPR and INIT_EXPR is no longer useful.  */\n   if (TREE_CODE (*expr_p) == INIT_EXPR)\n@@ -2886,8 +2851,7 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n     {\n       /* If we've somehow already got an SSA_NAME on the LHS, then\n \t we're probably modifying it twice.  Not good.  */\n-      if (TREE_CODE (*to_p) == SSA_NAME)\n-\tabort ();\n+      gcc_assert (TREE_CODE (*to_p) != SSA_NAME);\n       *to_p = make_ssa_name (*to_p, *expr_p);\n     }\n \n@@ -3035,11 +2999,7 @@ gimplify_save_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   enum gimplify_status ret = GS_ALL_DONE;\n   tree val;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (*expr_p) != SAVE_EXPR)\n-    abort ();\n-#endif\n-\n+  gcc_assert (TREE_CODE (*expr_p) == SAVE_EXPR);\n   val = TREE_OPERAND (*expr_p, 0);\n \n   /* If the SAVE_EXPR has not been resolved, then evaluate it once.  */\n@@ -3432,9 +3392,9 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       TREE_OPERAND (targ, 3) = init;\n       TARGET_EXPR_INITIAL (targ) = NULL_TREE;\n     }\n-  else if (!DECL_SEEN_IN_BIND_EXPR_P (temp))\n+  else\n     /* We should have expanded this before.  */\n-    abort ();\n+    gcc_assert (DECL_SEEN_IN_BIND_EXPR_P (temp));\n \n   *expr_p = temp;\n   return GS_OK;\n@@ -3593,7 +3553,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase TREE_LIST:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tcase COMPOUND_EXPR:\n \t  ret = gimplify_compound_expr (expr_p, pre_p, fallback != fb_none);\n@@ -3729,10 +3689,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n \tcase LABEL_EXPR:\n \t  ret = GS_ALL_DONE;\n-#ifdef ENABLE_CHECKING\n-\t  if (decl_function_context (LABEL_EXPR_LABEL (*expr_p)) != current_function_decl)\n-\t    abort ();\n-#endif\n+\t  gcc_assert (decl_function_context (LABEL_EXPR_LABEL (*expr_p))\n+\t\t      == current_function_decl);\n \t  break;\n \n \tcase CASE_LABEL_EXPR:\n@@ -3788,8 +3746,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n \tcase NON_LVALUE_EXPR:\n \t  /* This should have been stripped above.  */\n-\t  abort ();\n-\t  break;\n+\t  gcc_unreachable ();\n \n \tcase ASM_EXPR:\n \t  ret = gimplify_asm_expr (expr_p, pre_p, post_p);\n@@ -3866,10 +3823,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t      && decl_function_context (tmp) == current_function_decl\n \t      && !DECL_SEEN_IN_BIND_EXPR_P (tmp))\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (!errorcount && !sorrycount)\n-\t\tabort ();\n-#endif\n+\t      gcc_assert (errorcount || sorrycount);\n \t      ret = GS_ERROR;\n \t      break;\n \t    }\n@@ -3892,49 +3846,58 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tdefault:\n-\t  /* If this is a comparison of objects of aggregate type, handle\n-\t     it specially (by converting to a call to memcmp).  It would be\n-\t     nice to only have to do this for variable-sized objects, but\n-\t     then we'd have to allow the same nest of reference nodes we\n-\t     allow for MODIFY_EXPR and that's too complex.  */\n-\t  if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '<'\n-\t      && (AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 1)))))\n-\t    ret = gimplify_variable_sized_compare (expr_p);\n-\n-\t  /* If *EXPR_P does not need to be special-cased, handle it\n-\t     according to its class.  */\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '1')\n-\t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n-\t\t\t\t post_p, is_gimple_val, fb_rvalue);\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '2'\n-\t\t   || TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '<'\n-\t\t   || TREE_CODE (*expr_p) == TRUTH_AND_EXPR\n-\t\t   || TREE_CODE (*expr_p) == TRUTH_OR_EXPR\n-\t\t   || TREE_CODE (*expr_p) == TRUTH_XOR_EXPR)\n+\t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {\n-\t      enum gimplify_status r0, r1;\n-\n-\t      r0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n-\t\t\t\t  post_p, is_gimple_val, fb_rvalue);\n-\t      r1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p,\n-\t\t\t\t  post_p, is_gimple_val, fb_rvalue);\n+\t    case '<':\n+\t      /* If this is a comparison of objects of aggregate type,\n+\t     \t handle it specially (by converting to a call to\n+\t     \t memcmp).  It would be nice to only have to do this\n+\t     \t for variable-sized objects, but then we'd have to\n+\t     \t allow the same nest of reference nodes we allow for\n+\t     \t MODIFY_EXPR and that's too complex.  */\n+\t      if (!AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 1))))\n+\t\tgoto expr_2;\n+\t      ret = gimplify_variable_sized_compare (expr_p);\n+\t      break;\n+\t      \n+\t    /* If *EXPR_P does not need to be special-cased, handle it\n+\t       according to its class.  */\n+\t    case '1':\n+\t      ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n+\t\t\t\t   post_p, is_gimple_val, fb_rvalue);\n+\t      break;\n \n-\t      ret = MIN (r0, r1);\n-\t    }\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == 'd'\n-\t\t   || TREE_CODE_CLASS (TREE_CODE (*expr_p)) == 'c')\n-\t    {\n+\t    case '2':\n+\t    expr_2:\n+\t      {\n+\t\tenum gimplify_status r0, r1;\n+\t\t\n+\t\tr0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n+\t\t\t\t    post_p, is_gimple_val, fb_rvalue);\n+\t\tr1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p,\n+\t\t\t\t    post_p, is_gimple_val, fb_rvalue);\n+\t\t\n+\t\tret = MIN (r0, r1);\n+\t\tbreak;\n+\t      }\n+\t      \n+\t    case 'd':\n+\t    case 'c':\n \t      ret = GS_ALL_DONE;\n-\t      break;\n+\t      goto dont_recalculate;\n+\t      \n+\t    default:\n+\t      gcc_assert (TREE_CODE (*expr_p) == TRUTH_AND_EXPR\n+\t\t\t  || TREE_CODE (*expr_p) == TRUTH_OR_EXPR\n+\t\t\t  || TREE_CODE (*expr_p) == TRUTH_XOR_EXPR);\n+\t      goto expr_2;\n \t    }\n-\t  else\n-\t    /* Fail if we don't know how to handle this tree code.  */\n-\t    abort ();\n \n \t  recalculate_side_effects (*expr_p);\n+\tdont_recalculate:\n \t  break;\n \t}\n-\n+      \n       /* If we replaced *expr_p, gimplify again.  */\n       if (ret == GS_OK && (*expr_p == NULL || *expr_p == save_expr))\n \tret = GS_ALL_DONE;\n@@ -3950,12 +3913,9 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       goto out;\n     }\n \n-#ifdef ENABLE_CHECKING\n   /* This was only valid as a return value from the langhook, which\n      we handled.  Make sure it doesn't escape from any other context.  */\n-  if (ret == GS_UNHANDLED)\n-    abort ();\n-#endif\n+  gcc_assert (ret != GS_UNHANDLED);\n \n   if (fallback == fb_none && *expr_p && !is_gimple_stmt (*expr_p))\n     {\n@@ -3969,21 +3929,26 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t     has side effects.  Recurse through the operands to find it.  */\n \t  enum tree_code code = TREE_CODE (*expr_p);\n \n-\t  if (code == COMPONENT_REF\n-\t      || code == REALPART_EXPR || code == IMAGPART_EXPR)\n-\t    gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t   gimple_test_f, fallback);\n-\t  else if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+\t  switch (code)\n \t    {\n+\t    case COMPONENT_REF:\n+\t    case REALPART_EXPR: case IMAGPART_EXPR:\n+\t      gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t     gimple_test_f, fallback);\n+\t      break;\n+\n+\t    case ARRAY_REF: case ARRAY_RANGE_REF:\n \t      gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n \t\t\t     gimple_test_f, fallback);\n \t      gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n-\t\t\t   gimple_test_f, fallback);\n+\t\t\t     gimple_test_f, fallback);\n+\t      break;\n+\n+\t    default:\n+\t       /* Anything else with side-effects must be converted to\n+\t       \t  a valid statement before we get here.  */\n+\t      gcc_unreachable ();\n \t    }\n-\t  else\n-\t    /* Anything else with side-effects\n-\t       must be converted to a valid statement before we get here.  */\n-\t    abort ();\n \n \t  *expr_p = NULL;\n \t}\n@@ -4049,10 +4014,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n     }\n   else if ((fallback & fb_rvalue) && is_gimple_formal_tmp_rhs (*expr_p))\n     {\n-#if defined ENABLE_CHECKING\n-      if (VOID_TYPE_P (TREE_TYPE (*expr_p)))\n-\tabort ();\n-#endif\n+      gcc_assert (!VOID_TYPE_P (TREE_TYPE (*expr_p)));\n \n       /* An rvalue will do.  Assign the gimplified expression into a new\n \t temporary TMP and replace the original expression with TMP.  */\n@@ -4068,26 +4030,27 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       if (TREE_CODE (*expr_p) != SSA_NAME)\n \tDECL_GIMPLE_FORMAL_TEMP_P (*expr_p) = 1;\n     }\n-  else if (fallback & fb_mayfail)\n+  else\n     {\n-      /* If this is an asm statement, and the user asked for the impossible,\n-\t don't abort.  Fail and let gimplify_asm_expr issue an error.  */\n+#ifdef ENABLE_CHECKING\n+      if (!(fallback & fb_mayfail))\n+\t{\n+\t  fprintf (stderr, \"gimplification failed:\\n\");\n+\t  print_generic_expr (stderr, *expr_p, 0);\n+\t  debug_tree (*expr_p);\n+\t  internal_error (\"gimplification failed\");\n+\t}\n+#endif\n+      gcc_assert (fallback & fb_mayfail);\n+      /* If this is an asm statement, and the user asked for the\n+\t impossible, don't abort.  Fail and let gimplify_asm_expr\n+\t issue an error.  */\n       ret = GS_ERROR;\n       goto out;\n     }\n-  else\n-    {\n-      fprintf (stderr, \"gimplification failed:\\n\");\n-      print_generic_expr (stderr, *expr_p, 0);\n-      debug_tree (*expr_p);\n-      abort ();\n-    }\n \n-#if defined ENABLE_CHECKING\n   /* Make sure the temporary matches our predicate.  */\n-  if (!(*gimple_test_f) (*expr_p))\n-    abort ();\n-#endif\n+  gcc_assert ((*gimple_test_f) (*expr_p));\n \n   if (internal_post)\n     {\n@@ -4212,8 +4175,7 @@ check_pointer_types_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       otype = TREE_TYPE (t);\n       ptype = TREE_TYPE (TREE_OPERAND (t, 0));\n       dtype = TREE_TYPE (ptype);\n-      if (!cpt_same_type (otype, dtype))\n-\tabort ();\n+      gcc_assert (cpt_same_type (otype, dtype));\n       break;\n \n     case ADDR_EXPR:\n@@ -4226,11 +4188,10 @@ check_pointer_types_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t     a pointer to the array type.  We must allow this in order to\n \t     properly represent assigning the address of an array in C into\n \t     pointer to the element type.  */\n-\t  if (TREE_CODE (otype) == ARRAY_TYPE\n-\t      && POINTER_TYPE_P (ptype)\n-\t      && cpt_same_type (TREE_TYPE (otype), dtype))\n-\t    break;\n-\t  abort ();\n+\t  gcc_assert (TREE_CODE (otype) == ARRAY_TYPE\n+\t\t      && POINTER_TYPE_P (ptype)\n+\t\t      && cpt_same_type (TREE_TYPE (otype), dtype));\n+\t  break;\n \t}\n       break;\n \n@@ -4373,8 +4334,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n \n   ret = gimplify_expr (&expr, stmts, NULL,\n \t\t       gimple_test_f, fb_rvalue);\n-  if (ret == GS_ERROR)\n-    abort ();\n+  gcc_assert (ret != GS_ERROR);\n \n   for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n     add_referenced_tmp_var (t);"}, {"sha": "e8184acd37e07fc832f006d8bbe09c54d32d1ab7", "filename": "gcc/global.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -469,12 +469,12 @@ global_alloc (FILE *file)\n \t&& (! current_function_has_nonlocal_label\n \t    || REG_N_CALLS_CROSSED (i) == 0))\n       {\n-\tif (reg_renumber[i] < 0 && reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n+\tif (reg_renumber[i] < 0\n+\t    && reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n \t  reg_allocno[i] = reg_allocno[reg_may_share[i]];\n \telse\n \t  reg_allocno[i] = max_allocno++;\n-\tif (REG_LIVE_LENGTH (i) == 0)\n-\t  abort ();\n+\tgcc_assert (REG_LIVE_LENGTH (i));\n       }\n     else\n       reg_allocno[i] = -1;\n@@ -1886,14 +1886,15 @@ build_insn_chain (rtx first)\n \t the previous real insn is a JUMP_INSN.  */\n       if (b == EXIT_BLOCK_PTR)\n \t{\n-\t  for (first = NEXT_INSN (first) ; first; first = NEXT_INSN (first))\n-\t    if (INSN_P (first)\n-\t\t&& GET_CODE (PATTERN (first)) != USE\n-\t\t&& ! ((GET_CODE (PATTERN (first)) == ADDR_VEC\n-\t\t       || GET_CODE (PATTERN (first)) == ADDR_DIFF_VEC)\n-\t\t      && prev_real_insn (first) != 0\n-\t\t      && JUMP_P (prev_real_insn (first))))\n-\t      abort ();\n+#ifdef ENABLE_CHECKING\n+\t  for (first = NEXT_INSN (first); first; first = NEXT_INSN (first))\n+\t    gcc_assert (!INSN_P (first)\n+\t\t\t|| GET_CODE (PATTERN (first)) == USE\n+\t\t\t|| ((GET_CODE (PATTERN (first)) == ADDR_VEC\n+\t\t\t     || GET_CODE (PATTERN (first)) == ADDR_DIFF_VEC)\n+\t\t\t    && prev_real_insn (first) != 0\n+\t\t\t    && JUMP_P (prev_real_insn (first))));\n+#endif\n \t  break;\n \t}\n     }"}, {"sha": "8fa2e4fe2db0b644a84637a2a726336e5e7b6c97", "filename": "gcc/graph.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282899df0fb5881ddaf70814d095286221d6019e/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=282899df0fb5881ddaf70814d095286221d6019e", "patch": "@@ -398,14 +398,8 @@ clean_graph_dump_file (const char *base)\n   if (fp == NULL)\n     fatal_error (\"can't open %s: %m\", buf);\n \n-  switch (graph_dump_format)\n-    {\n-    case vcg:\n-      fputs (\"graph: {\\nport_sharing: no\\n\", fp);\n-      break;\n-    case no_graph:\n-      abort ();\n-    }\n+  gcc_assert (graph_dump_format == vcg);\n+  fputs (\"graph: {\\nport_sharing: no\\n\", fp);\n \n   fclose (fp);\n }\n@@ -426,15 +420,8 @@ finish_graph_dump_file (const char *base)\n   fp = fopen (buf, \"a\");\n   if (fp != NULL)\n     {\n-      switch (graph_dump_format)\n-\t{\n-\tcase vcg:\n-\t  fputs (\"}\\n\", fp);\n-\t  break;\n-\tcase no_graph:\n-\t  abort ();\n-\t}\n-\n+      gcc_assert (graph_dump_format == vcg);\n+      fputs (\"}\\n\", fp);\n       fclose (fp);\n     }\n }"}]}