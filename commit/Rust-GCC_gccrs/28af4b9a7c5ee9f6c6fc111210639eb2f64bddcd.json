{"sha": "28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhhZjRiOWE3YzVlZTlmNmM2ZmMxMTEyMTA2MzllYjJmNjRiZGRjZA==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-02-25T16:26:37Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-02-25T16:27:50Z"}, "message": "slp: Don't traverse tree on (nil) nodes.\n\nThe given testcase shows that one of the children of the complex MUL contains a\nPHI node.  This results in the vectorizer having a child that's (nil).\n\nThe pattern matcher handles this correctly, but optimize_load_redistribution_1\nneeds to not traverse/inspect the NULL nodes.\n\nThis however does high-light a missed opportunity.  This testcase seems to\nresult in a different canonicalization than normally.\n\nNormally the expressions are right leaning.  But sometimes, especially when type\ncasts are introduced the trees suddenly become left leaning. For instance this\ntestcase (even without type casts) won't detect the FMA form because the addition\ngets the MUL node in the left and not right node as it expects.\n\nChecking all forms would be quite expensive so for GCC 12 it probably makes sense to make\nforms with type casts in them have the same form as those without?\n\ngcc/ChangeLog:\n\n\t* tree-vect-slp.c (optimize_load_redistribution_1): Abort on NULL nodes.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/vect/simd-complex-num-null-node.cc: New test.", "tree": {"sha": "8a6adf20170e670f7a62af20661646610e55938e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a6adf20170e670f7a62af20661646610e55938e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "557a0d3b1b389c46d5a8aa24e27abed4c401d17e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557a0d3b1b389c46d5a8aa24e27abed4c401d17e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557a0d3b1b389c46d5a8aa24e27abed4c401d17e"}], "stats": {"total": 80, "additions": 79, "deletions": 1}, "files": [{"sha": "eddf0ad8710138c3b5ac31706df02109d8164329", "filename": "gcc/testsuite/g++.dg/vect/simd-complex-num-null-node.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-complex-num-null-node.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-complex-num-null-node.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-complex-num-null-node.cc?ref=28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do compile { target { aarch64-*-* } } } */\n+/* { dg-skip-if \"incorrect syntax for c++98\" { *-*-* } { \"-std=c++98\" } { \"\" } } */\n+/* { dg-additional-options \"-w -O3 -march=armv8.3-a -fdump-tree-vect-all\" } */\n+/* { dg-require-effective-target le } */\n+\n+typedef struct {\n+  float b;\n+  float c;\n+} d;\n+namespace {\n+typedef int e;\n+template <typename, typename> struct f;\n+template <template <typename> class g, typename h, typename k, typename... l>\n+struct f<g<k, l...>, h> {\n+  using m = g<h>;\n+};\n+} // namespace\n+namespace aa {\n+template <typename k> class o {\n+public:\n+  typedef k p;\n+};\n+} // namespace aa\n+namespace ab {\n+template <typename k> using r = aa::o<k>;\n+template <typename k> class ac : public r<k> {};\n+struct s {\n+  template <typename k, typename h> struct ad : f<k, h> {};\n+};\n+template <typename t, typename h> using ae = typename s::ad<t, h>::m;\n+template <typename t> struct af {\n+  typedef typename t::p p;\n+  template <typename k> using u = ae<t, k>;\n+};\n+} // namespace ab\n+namespace aa {\n+template <typename t> struct ag {\n+  typedef ab::af<t> v;\n+  typedef typename v::p &ah;\n+  template <typename k> struct ai { typedef typename v::u<k> aj; };\n+};\n+} // namespace aa\n+namespace ab {\n+template <typename k, typename t> struct w {\n+  typedef typename aa::ag<t>::ai<k>::aj x;\n+  struct y {};\n+  typedef t ak;\n+  w(e, ak);\n+  y a;\n+};\n+template <typename k, typename t = ac<k>> class al : w<k, t> {\n+  typedef w<k, t> am;\n+  typedef typename am::x x;\n+  typedef aa::ag<x> an;\n+\n+public:\n+  typedef typename an::ah ah;\n+  typedef e ao;\n+  typedef t ak;\n+  al(ao ap, ak aq = ak()) : am(ar(ap, aq), aq) {}\n+  ah operator[](ao);\n+  ao ar(ao ap, ak) { return ap; }\n+};\n+} // namespace ab\n+void as(int n, d *a, d *q) {\n+  ab::al<d> z(n);\n+  d acc;\n+  for (int j = 0; j < n; ++j) {\n+    auto at = a[j];\n+    auto au = q[j];\n+    acc.b += at.b * au.b - at.c * au.c;\n+    acc.c += at.b * au.c + at.c * au.b;\n+  }\n+  z[0] = acc;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_MUL\" 1 \"vect\" } } */"}, {"sha": "0d24be796e8cb4bd0cfd73d72b1a3793c34958e8", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=28af4b9a7c5ee9f6c6fc111210639eb2f64bddcd", "patch": "@@ -2298,7 +2298,7 @@ optimize_load_redistribution_1 (scalar_stmts_to_slp_tree_map_t *bst_map,\n   unsigned i;\n \n   /* For now, we don't know anything about externals so do not do anything.  */\n-  if (SLP_TREE_DEF_TYPE (root) != vect_internal_def)\n+  if (!root || SLP_TREE_DEF_TYPE (root) != vect_internal_def)\n     return NULL;\n   else if (SLP_TREE_CODE (root) == VEC_PERM_EXPR)\n     {"}]}