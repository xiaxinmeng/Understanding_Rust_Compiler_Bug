{"sha": "a2c9173331914eff3d728c07afaeee71892689ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJjOTE3MzMzMTkxNGVmZjNkNzI4YzA3YWZhZWVlNzE4OTI2ODliYQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T18:09:48Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-22T12:11:45Z"}, "message": "Add relational support to fold_using_range\n\nEnable a relation oracle in ranger, and add full range-op relation support\nto fold_using_range.\n\n\t* gimple-range-cache.cc (ranger_cache::ranger_cache): Create a\n\trelation_oracle if dominators exist.\n\t(ranger_cache::~ranger_cache): Dispose of oracle.\n\t(ranger_cache::dump_bb): Dump oracle.\n\t* gimple-range.cc (fur_source::fur_source): New.\n\t(fur_source::get_operand): Use mmeber query.\n\t(fur_source::get_phi_operand): Use member_query.\n\t(fur_source::query_relation): New.\n\t(fur_source::register_dependency): Delete.\n\t(fur_source::register_relation): New.\n\t(fur_edge::fur_edge): Adjust.\n\t(fur_edge::get_phi_operand): Fix comment.\n\t(fur_edge::query): Delete.\n\t(fur_stmt::fur_stmt): Adjust.\n\t(fur_stmt::query): Delete.\n\t(fur_depend::fur_depend): Adjust.\n\t(fur_depend::register_relation): New.\n\t(fur_depend::register_relation): New.\n\t(fur_list::fur_list): Adjust.\n\t(fur_list::get_operand): Use member query.\n\t(fold_using_range::range_of_range_op): Process and query relations.\n\t(fold_using_range::range_of_address): Adjust dependency call.\n\t(fold_using_range::range_of_phi): Ditto.\n\t(gimple_ranger::gimple_ranger): New.  Use ranger_ache oracle.\n\t(fold_using_range::relation_fold_and_or): New.\n\t(fold_using_range::postfold_gcond_edges): New.\n\t* gimple-range.h (class gimple_ranger): Adjust.\n\t(class fur_source): Adjust members.\n\t(class fur_stmt): Ditto.\n\t(class fold_using_range): Ditto.", "tree": {"sha": "8912aa396388e124d9f9f769da0ae9e91f0d5d51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8912aa396388e124d9f9f769da0ae9e91f0d5d51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2c9173331914eff3d728c07afaeee71892689ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c9173331914eff3d728c07afaeee71892689ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c9173331914eff3d728c07afaeee71892689ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c9173331914eff3d728c07afaeee71892689ba/comments", "author": null, "committer": null, "parents": [{"sha": "80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dd13f5c3bdc7899ee6e863e05b254815ec0cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80dd13f5c3bdc7899ee6e863e05b254815ec0cef"}], "stats": {"total": 387, "additions": 324, "deletions": 63}, "files": [{"sha": "4347485cf983390e681663cf6d12075c93948b78", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c9173331914eff3d728c07afaeee71892689ba/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c9173331914eff3d728c07afaeee71892689ba/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=a2c9173331914eff3d728c07afaeee71892689ba", "patch": "@@ -714,6 +714,12 @@ ranger_cache::ranger_cache ()\n   m_update_list.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   m_update_list.truncate (0);\n   m_temporal = new temporal_cache;\n+  // If DOM info is available, spawn an oracle as well.\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+      m_oracle = new relation_oracle ();\n+    else\n+      m_oracle = NULL;\n+\n   unsigned x, lim = last_basic_block_for_fn (cfun);\n   // Calculate outgoing range info upfront.  This will fully populate the\n   // m_maybe_variant bitmap which will help eliminate processing of names\n@@ -728,6 +734,8 @@ ranger_cache::ranger_cache ()\n \n ranger_cache::~ranger_cache ()\n {\n+  if (m_oracle)\n+    delete m_oracle;\n   delete m_temporal;\n   m_workback.release ();\n   m_update_list.release ();\n@@ -750,6 +758,8 @@ ranger_cache::dump_bb (FILE *f, basic_block bb)\n {\n   m_gori.gori_map::dump (f, bb, false);\n   m_on_entry.dump (f, bb);\n+  if (m_oracle)\n+    m_oracle->dump (f, bb);\n }\n \n // Get the global range for NAME, and return in R.  Return false if the"}, {"sha": "385cecf330b967ee39e69a4bbb9703a33f3a9f16", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 297, "deletions": 58, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c9173331914eff3d728c07afaeee71892689ba/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c9173331914eff3d728c07afaeee71892689ba/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=a2c9173331914eff3d728c07afaeee71892689ba", "patch": "@@ -47,14 +47,25 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"gimple-range.h\"\n \n-// Evaluate expression EXPR using the source information the class was\n-// instantiated with.  Place the result in R, and return TRUE.  If a range\n-// cannot be calculated, return FALSE.\n+// Construct a fur_source, and set the m_query field.\n+\n+fur_source::fur_source (range_query *q)\n+{\n+  if (q)\n+    m_query = q;\n+  else if (cfun)\n+    m_query = get_range_query (cfun);\n+  else\n+    m_query = get_global_range_query ();\n+  m_gori = NULL;\n+}\n+\n+// Invoke range_of_expr on EXPR.\n \n bool\n fur_source::get_operand (irange &r, tree expr)\n {\n-  return get_range_query (cfun)->range_of_expr (r, expr);\n+  return m_query->range_of_expr (r, expr);\n }\n \n // Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n@@ -63,23 +74,36 @@ fur_source::get_operand (irange &r, tree expr)\n bool\n fur_source::get_phi_operand (irange &r, tree expr, edge e)\n {\n-  return get_range_query (cfun)->range_on_edge (r, e, expr);\n+  return m_query->range_on_edge (r, e, expr);\n+}\n+\n+// Default is no relation.\n+\n+relation_kind\n+fur_source::query_relation (tree op1 ATTRIBUTE_UNUSED,\n+\t\t\t    tree op2 ATTRIBUTE_UNUSED)\n+{\n+  return VREL_NONE;\n }\n \n-// Default is to not register any dependencies from fold_using_range.\n+// Default registers nothing.\n \n void\n-fur_source::register_dependency (tree lhs ATTRIBUTE_UNUSED,\n-\t\t\t\t tree rhs ATTRIBUTE_UNUSED)\n+fur_source::register_relation (gimple *s ATTRIBUTE_UNUSED,\n+\t\t\t       relation_kind k ATTRIBUTE_UNUSED,\n+\t\t\t       tree op1 ATTRIBUTE_UNUSED,\n+\t\t\t       tree op2 ATTRIBUTE_UNUSED)\n {\n }\n \n-// Default object is the current range query.\n+// Default registers nothing.\n \n-range_query *\n-fur_source::query ()\n+void\n+fur_source::register_relation (edge e ATTRIBUTE_UNUSED,\n+\t\t\t       relation_kind k ATTRIBUTE_UNUSED,\n+\t\t\t       tree op1 ATTRIBUTE_UNUSED,\n+\t\t\t       tree op2 ATTRIBUTE_UNUSED)\n {\n-  return get_range_query (cfun);\n }\n \n // This version of fur_source will pick a range up off an edge.\n@@ -90,22 +114,16 @@ class fur_edge : public fur_source\n   fur_edge (edge e, range_query *q = NULL);\n   virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n   virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n-  virtual range_query *query () OVERRIDE;\n private:\n-  range_query *m_query;\n   edge m_edge;\n };\n \n // Instantiate an edge based fur_source.\n \n inline\n-fur_edge::fur_edge (edge e, range_query *q)\n+fur_edge::fur_edge (edge e, range_query *q) : fur_source (q)\n {\n   m_edge = e;\n-  if (q)\n-    m_query = q;\n-  else\n-    m_query = get_range_query (cfun);\n }\n \n // Get the value of EXPR on edge m_edge.\n@@ -122,31 +140,19 @@ fur_edge::get_operand (irange &r, tree expr)\n bool\n fur_edge::get_phi_operand (irange &r, tree expr, edge e)\n {\n-  // edge to edge recalculations not supoprted yet, until we sort it out.\n+  // Edge to edge recalculations not supoprted yet, until we sort it out.\n   gcc_checking_assert (e == m_edge);\n   return m_query->range_on_edge (r, e, expr);\n }\n \n-// Return the current range_query object.\n-\n-range_query *\n-fur_edge::query ()\n-{\n-  return m_query;\n-}\n-\n // Instantiate a stmt based fur_source.\n \n-fur_stmt::fur_stmt (gimple *s, range_query *q)\n+fur_stmt::fur_stmt (gimple *s, range_query *q) : fur_source (q)\n {\n   m_stmt = s;\n-  if (q)\n-    m_query = q;\n-  else\n-    m_query = get_global_range_query ();\n }\n \n-// Retrieve range of EXPR as it occurs as a use on stmt M_STMT.\n+// Retreive range of EXPR as it occurs as a use on stmt M_STMT.\n \n bool\n fur_stmt::get_operand (irange &r, tree expr)\n@@ -165,12 +171,12 @@ fur_stmt::get_phi_operand (irange &r, tree expr, edge e)\n   return e_src.get_operand (r, expr);\n }\n \n-// Return the current range_query object.\n+// Return relation based from m_stmt.\n \n-range_query *\n-fur_stmt::query ()\n+relation_kind\n+fur_stmt::query_relation (tree op1, tree op2)\n {\n-  return m_query;\n+  return m_query->query_relation (m_stmt, op1, op2);\n }\n \n // This version of fur_source will pick a range from a stmt, and also register\n@@ -180,27 +186,44 @@ class fur_depend : public fur_stmt\n {\n public:\n   fur_depend (gimple *s, gori_compute *gori, range_query *q = NULL);\n-  virtual void register_dependency (tree lhs, tree rhs) OVERRIDE;\n+  virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n+\t\t\t\t  tree op2) OVERRIDE;\n+  virtual void register_relation (edge e, relation_kind k, tree op1,\n+\t\t\t\t  tree op2) OVERRIDE;\n private:\n-  gori_compute *m_gori;\n+  relation_oracle *m_oracle;\n };\n \n-// Instantiate a stmt based fur_source with a GORI object\n+// Instantiate a stmt based fur_source with a GORI object.\n \n inline\n fur_depend::fur_depend (gimple *s, gori_compute *gori, range_query *q)\n   : fur_stmt (s, q)\n {\n   gcc_checking_assert (gori);\n   m_gori = gori;\n+  // Set relations if there is an oracle in the range_query.\n+  // This will enable registering of relationships as they are discovered.\n+  m_oracle = q->oracle ();\n+\n+}\n+\n+// Register a relation on a stmt if there is an oracle.\n+\n+void\n+fur_depend::register_relation (gimple *s, relation_kind k, tree op1, tree op2)\n+{\n+  if (m_oracle)\n+    m_oracle->register_relation (s, k, op1, op2);\n }\n \n-// find and add any dependnecy between LHS and RHS\n+// Register a relation on an edge if there is an oracle.\n \n void\n-fur_depend::register_dependency (tree lhs, tree rhs)\n+fur_depend::register_relation (edge e, relation_kind k, tree op1, tree op2)\n {\n-  m_gori->register_dependency (lhs, rhs);\n+  if (m_oracle)\n+    m_oracle->register_relation (e, k, op1, op2);\n }\n \n // This version of fur_source will pick a range up from a list of ranges\n@@ -223,7 +246,7 @@ class fur_list : public fur_source\n \n // One range supplied for unary operations.\n \n-fur_list::fur_list (irange &r1)\n+fur_list::fur_list (irange &r1) : fur_source (NULL)\n {\n   m_list = m_local;\n   m_index = 0;\n@@ -233,7 +256,7 @@ fur_list::fur_list (irange &r1)\n \n // Two ranges supplied for binary operations.\n \n-fur_list::fur_list (irange &r1, irange &r2)\n+fur_list::fur_list (irange &r1, irange &r2) : fur_source (NULL)\n {\n   m_list = m_local;\n   m_index = 0;\n@@ -244,7 +267,7 @@ fur_list::fur_list (irange &r1, irange &r2)\n \n // Arbitrary number of ranges in a vector.\n \n-fur_list::fur_list (unsigned num, irange *list)\n+fur_list::fur_list (unsigned num, irange *list) : fur_source (NULL)\n {\n   m_list = list;\n   m_index = 0;\n@@ -257,7 +280,7 @@ bool\n fur_list::get_operand (irange &r, tree expr)\n {\n   if (m_index >= m_limit)\n-    return get_range_query (cfun)->range_of_expr (r, expr);\n+    return m_query->range_of_expr (r, expr);\n   r = m_list[m_index++];\n   gcc_checking_assert (range_compatible_p (TREE_TYPE (expr), r.type ()));\n   return true;\n@@ -290,7 +313,6 @@ fold_range (irange &r, gimple *s, irange &r1, irange &r2)\n   return f.fold_stmt (r, s, src);\n }\n \n-\n // Fold stmt S into range R using NUM_ELEMENTS from VECTOR as the initial\n // operands encountered.\n \n@@ -636,18 +658,50 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t  // Fold range, and register any dependency if available.\n \t  int_range<2> r2 (type);\n \t  handler->fold_range (r, type, range1, r2);\n-\t  if (lhs)\n-\t    src.register_dependency (lhs, op1);\n+\t  if (lhs && gimple_range_ssa_p (op1))\n+\t    {\n+\t      if (src.gori ())\n+\t\tsrc.gori ()->register_dependency (lhs, op1);\n+\t      relation_kind rel;\n+\t      rel = handler->lhs_op1_relation (r, range1, range1);\n+\t      if (rel != VREL_NONE)\n+\t\tsrc.register_relation (s, rel, lhs, op1);\n+\t    }\n \t}\n       else if (src.get_operand (range2, op2))\n \t{\n+\t  relation_kind rel = src.query_relation (op1, op2);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) && rel != VREL_NONE)\n+\t    {\n+\t      fprintf (dump_file, \" folding with relation \");\n+\t      print_relation (dump_file, rel);\n+\t      fputc ('\\n', dump_file);\n+\t    }\n \t  // Fold range, and register any dependency if available.\n-\t  handler->fold_range (r, type, range1, range2);\n+\t  handler->fold_range (r, type, range1, range2, rel);\n+\t  relation_fold_and_or (r, s, src);\n \t  if (lhs)\n \t    {\n-\t      src.register_dependency (lhs, op1);\n-\t      src.register_dependency (lhs, op2);\n+\t      if (src.gori ())\n+\t\t{\n+\t\t  src.gori ()->register_dependency (lhs, op1);\n+\t\t  src.gori ()->register_dependency (lhs, op2);\n+\t\t}\n+\t      if (gimple_range_ssa_p (op1))\n+\t\t{\n+\t\t  rel = handler->lhs_op1_relation (r, range1, range2);\n+\t\t  if (rel != VREL_NONE)\n+\t\t    src.register_relation (s, rel, lhs, op1);\n+\t\t}\n+\t      if (gimple_range_ssa_p (op2))\n+\t\t{\n+\t\t  rel= handler->lhs_op2_relation (r, range1, range2);\n+\t\t  if (rel != VREL_NONE)\n+\t\t    src.register_relation (s, rel, lhs, op2);\n+\t\t}\n \t    }\n+\t  else if (is_a<gcond *> (s))\n+\t    postfold_gcond_edges (as_a<gcond *> (s), src);\n \t}\n       else\n \tr.set_varying (type);\n@@ -686,8 +740,8 @@ fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n     {\n       tree ssa = TREE_OPERAND (base, 0);\n       tree lhs = gimple_get_lhs (stmt);\n-      if (lhs && gimple_range_ssa_p (ssa))\n-\tsrc.register_dependency (lhs, ssa);\n+      if (lhs && gimple_range_ssa_p (ssa) && src.gori ())\n+\tsrc.gori ()->register_dependency (lhs, ssa);\n       gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n       src.get_operand (r, ssa);\n       range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n@@ -764,8 +818,8 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n       edge e = gimple_phi_arg_edge (phi, x);\n \n       // Register potential dependencies for stale value tracking.\n-      if (gimple_range_ssa_p (arg))\n-\tsrc.register_dependency (phi_def, arg);\n+      if (gimple_range_ssa_p (arg) && src.gori ())\n+\tsrc.gori ()->register_dependency (phi_def, arg);\n \n       // Get the range of the argument on its edge.\n       src.get_phi_operand (arg_range, arg, e);\n@@ -1149,6 +1203,12 @@ fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n   return true;\n }\n \n+gimple_ranger::gimple_ranger ()\n+{\n+  // If the cache has a relation oracle, use it.\n+  m_oracle = m_cache.oracle ();\n+}\n+\n bool\n gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n@@ -1464,6 +1524,185 @@ fold_using_range::range_of_ssa_name_with_loop_info (irange &r, tree name,\n     r.set_varying (type);\n }\n \n+// -----------------------------------------------------------------------\n+\n+// Check if an && or || expression can be folded based on relations. ie\n+//   c_2 = a_6 > b_7\n+//   c_3 = a_6 < b_7\n+//   c_4 = c_2 && c_3\n+// c_2 and c_3 can never be true at the same time,\n+// Therefore c_4 can always resolve to false based purely on the relations.\n+\n+void\n+fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n+\t\t\t\t\tfur_source &src)\n+{\n+  // No queries or already folded.\n+  if (!src.gori () || !src.query ()->oracle () || lhs_range.singleton_p ())\n+    return;\n+\n+  // Only care about AND and OR expressions.\n+  enum tree_code code = gimple_expr_code (s);\n+  bool is_and = false;\n+  if (code == BIT_AND_EXPR || code == TRUTH_AND_EXPR)\n+    is_and = true;\n+  else if (code != BIT_IOR_EXPR && code != TRUTH_OR_EXPR)\n+    return;\n+\n+  tree lhs = gimple_get_lhs (s);\n+  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n+  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n+\n+  // Deal with || and && only when there is a full set of symbolics.\n+  if (!lhs || !ssa1 || !ssa2\n+      || (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n+      || (TREE_CODE (TREE_TYPE (ssa1)) != BOOLEAN_TYPE)\n+      || (TREE_CODE (TREE_TYPE (ssa2)) != BOOLEAN_TYPE))\n+    return;\n+\n+  // Now we know its a boolean AND or OR expression with boolean operands.\n+  // Ideally we search dependencies for common names, and see what pops out.\n+  // until then, simply try to resolve direct dependencies.\n+\n+  // Both names will need to have 2 direct dependencies.\n+  tree ssa1_dep2 = src.gori ()->depend2 (ssa1);\n+  tree ssa2_dep2 = src.gori ()->depend2 (ssa2);\n+  if (!ssa1_dep2 || !ssa2_dep2)\n+    return;\n+\n+  tree ssa1_dep1 = src.gori ()->depend1 (ssa1);\n+  tree ssa2_dep1 = src.gori ()->depend1 (ssa2);\n+  // Make sure they are the same dependencies, and detect the order of the\n+  // relationship.\n+  bool reverse_op2 = true;\n+  if (ssa1_dep1 == ssa2_dep1 && ssa1_dep2 == ssa2_dep2)\n+    reverse_op2 = false;\n+  else if (ssa1_dep1 != ssa2_dep2 || ssa1_dep2 != ssa2_dep1)\n+    return;\n+\n+  range_operator *handler1 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa1));\n+  range_operator *handler2 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa2));\n+\n+  int_range<2> bool_one (boolean_true_node, boolean_true_node);\n+\n+  relation_kind relation1 = handler1->op1_op2_relation (bool_one);\n+  relation_kind relation2 = handler2->op1_op2_relation (bool_one);\n+  if (relation1 == VREL_NONE || relation2 == VREL_NONE)\n+    return;\n+\n+  if (reverse_op2)\n+    relation2 = relation_negate (relation2);\n+\n+  // x && y is false if the relation intersection of the true cases is NULL.\n+  if (is_and && relation_intersect (relation1, relation2) == VREL_EMPTY)\n+    lhs_range = int_range<2> (boolean_false_node, boolean_false_node);\n+  // x || y is true if the union of the true cases is NO-RELATION..\n+  // ie, one or the other being true covers the full range of possibilties.\n+  else if (!is_and && relation_union (relation1, relation2) == VREL_NONE)\n+    lhs_range = bool_one;\n+  else\n+    return;\n+\n+  range_cast (lhs_range, TREE_TYPE (lhs));\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  Relation adjustment: \");\n+      print_generic_expr (dump_file, ssa1, TDF_SLIM);\n+      fprintf (dump_file, \"  and \");\n+      print_generic_expr (dump_file, ssa2, TDF_SLIM);\n+      fprintf (dump_file, \"  combine to produce \");\n+      lhs_range.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+    }\n+\n+  return;\n+}\n+\n+// Register any outgoing edge relations from a conditional branch.\n+\n+void\n+fold_using_range::postfold_gcond_edges (gcond *s, fur_source &src)\n+{\n+  int_range_max r;\n+  tree name;\n+  range_operator *handler;\n+  basic_block bb = gimple_bb (s);\n+\n+  edge e0 = EDGE_SUCC (bb, 0);\n+  if (!single_pred_p (e0->dest))\n+    e0 = NULL;\n+\n+  edge e1 = EDGE_SUCC (bb, 1);\n+  if (!single_pred_p (e1->dest))\n+    e1 = NULL;\n+\n+  // At least one edge needs to be single pred.\n+  if (!e0 && !e1)\n+    return;\n+\n+  // First, register the gcond itself.  This will catch statements like\n+  // if (a_2 < b_5)\n+  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n+  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n+  if (ssa1 && ssa2)\n+    {\n+      handler = gimple_range_handler (s);\n+      gcc_checking_assert (handler);\n+      if (e0)\n+\t{\n+\t  gcond_edge_range (r, e0);\n+\t  relation_kind relation = handler->op1_op2_relation (r);\n+\t  if (relation != VREL_NONE)\n+\t    src.register_relation (e0, relation, ssa1, ssa2);\n+\t}\n+      if (e1)\n+\t{\n+\t  gcond_edge_range (r, e1);\n+\t  relation_kind relation = handler->op1_op2_relation (r);\n+\t  if (relation != VREL_NONE)\n+\t    src.register_relation (e1, relation, ssa1, ssa2);\n+\t}\n+    }\n+\n+  // Outgoing relations of GORI exports require a gori engine.\n+  if (!src.gori ())\n+    return;\n+\n+  range_query *q = src.query ();\n+  // Now look for other relations in the exports.  This will find stmts\n+  // leading to the condition such as:\n+  // c_2 = a_4 < b_7\n+  // if (c_2)\n+\n+  FOR_EACH_GORI_EXPORT_NAME (*(src.gori ()), bb, name)\n+    {\n+      if (TREE_CODE (TREE_TYPE (name)) != BOOLEAN_TYPE)\n+\tcontinue;\n+      gimple *stmt = SSA_NAME_DEF_STMT (name);\n+      handler = gimple_range_handler (stmt);\n+      if (!handler)\n+\tcontinue;\n+      tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n+      tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n+      if (ssa1 && ssa2)\n+\t{\n+\t  if (e0 && src.gori ()->outgoing_edge_range_p (r, e0, name, *q)\n+\t      && r.singleton_p ())\n+\t    {\n+\t      relation_kind relation = handler->op1_op2_relation (r);\n+\t      if (relation != VREL_NONE)\n+\t\tsrc.register_relation (e0, relation, ssa1, ssa2);\n+\t    }\n+\t  if (e1 && src.gori ()->outgoing_edge_range_p (r, e1, name, *q)\n+\t      && r.singleton_p ())\n+\t    {\n+\t      relation_kind relation = handler->op1_op2_relation (r);\n+\t      if (relation != VREL_NONE)\n+\t\tsrc.register_relation (e1, relation, ssa1, ssa2);\n+\t    }\n+\t}\n+    }\n+}\n // --------------------------------------------------------------------------\n // trace_ranger implementation.\n "}, {"sha": "87911b95d8664e2b583e0257bf9eb5f98becb7b0", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c9173331914eff3d728c07afaeee71892689ba/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c9173331914eff3d728c07afaeee71892689ba/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=a2c9173331914eff3d728c07afaeee71892689ba", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n class gimple_ranger : public range_query\n {\n public:\n+  gimple_ranger ();\n   virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL) OVERRIDE;\n   virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) OVERRIDE;\n   virtual bool range_on_edge (irange &r, edge e, tree name) OVERRIDE;\n@@ -74,15 +75,25 @@ class gimple_ranger : public range_query\n \n // Source of all operands for fold_using_range and gori_compute.\n // It abstracts out the source of an operand so it can come from a stmt or\n-// and edge or anywhere a derived classof fur_source wants.\n+// and edge or anywhere a derived class of fur_source wants.\n+// THe default simply picks up ranges from the current range_query.\n \n class fur_source\n {\n public:\n+  fur_source (range_query *q = NULL);\n+  inline range_query *query () { return m_query; }\n+  inline class gori_compute *gori () { return m_gori; };\n   virtual bool get_operand (irange &r, tree expr);\n   virtual bool get_phi_operand (irange &r, tree expr, edge e);\n-  virtual void register_dependency (tree lhs, tree rhs);\n-  virtual range_query *query ();\n+  virtual relation_kind query_relation (tree op1, tree op2);\n+  virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n+\t\t\t\t  tree op2);\n+  virtual void register_relation (edge e, relation_kind k, tree op1,\n+\t\t\t\t  tree op2);\n+protected:\n+  range_query *m_query;\n+  gori_compute *m_gori;\n };\n \n // fur_stmt is the specification for drawing an operand from range_query Q\n@@ -94,9 +105,8 @@ class fur_stmt : public fur_source\n   fur_stmt (gimple *s, range_query *q = NULL);\n   virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n   virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n-  virtual range_query *query () OVERRIDE;\n+  virtual relation_kind query_relation (tree op1, tree op2) OVERRIDE;\n private:\n-  range_query *m_query;\n   gimple *m_stmt;\n };\n \n@@ -132,6 +142,8 @@ class fold_using_range\n   bool range_of_phi (irange &r, gphi *phi, fur_source &src);\n   void range_of_ssa_name_with_loop_info (irange &, tree, class loop *, gphi *,\n \t\t\t\t\t fur_source &src);\n+  void relation_fold_and_or (irange& lhs_range, gimple *s, fur_source &src);\n+  void postfold_gcond_edges (gcond *s, fur_source &src);\n };\n \n "}]}