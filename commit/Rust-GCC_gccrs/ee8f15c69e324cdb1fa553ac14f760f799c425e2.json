{"sha": "ee8f15c69e324cdb1fa553ac14f760f799c425e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU4ZjE1YzY5ZTMyNGNkYjFmYTU1M2FjMTRmNzYwZjc5OWM0MjVlMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-09-20T04:56:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-09-20T04:56:54Z"}, "message": "common.opt (-fstack-clash-protection): New option.\n\n\t* common.opt (-fstack-clash-protection): New option.\n\t* flag-types.h (enum stack_check_type): Note difference between\n\t-fstack-check= and -fstack-clash-protection.\n\t* params.def (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE): New PARAM.\n\t(PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL): Likewise.\n\t* toplev.c (process_options): Issue warnings/errors for cases\n\tnot handled with -fstack-clash-protection.\n\t* doc/invoke.texi (-fstack-clash-protection): Document new option.\n\t(-fstack-check): Note additional problem with -fstack-check=generic.\n\tNote that -fstack-check is primarily for Ada and refer users\n\tto -fstack-clash-protection for stack-clash-protection.\n\tDocument new params for stack clash protection.\n\n\t* gcc.dg/stack-check-2.c: New test.\n\t* lib/target-supports.exp\n\t(check_effective_target_supports_stack_clash_protection): New function.\n\t(check_effective_target_frame_pointer_for_non_leaf): Likewise.\n\t(check_effective_target_caller_implicit_probes): Likewise.\n\nFrom-SVN: r252994", "tree": {"sha": "2808704ba1fbdc80b9f1cc9c3962f746872013ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2808704ba1fbdc80b9f1cc9c3962f746872013ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee8f15c69e324cdb1fa553ac14f760f799c425e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8f15c69e324cdb1fa553ac14f760f799c425e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee8f15c69e324cdb1fa553ac14f760f799c425e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8f15c69e324cdb1fa553ac14f760f799c425e2/comments", "author": null, "committer": null, "parents": [{"sha": "8fca13953b551bb75af0a31d737a297de97676a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fca13953b551bb75af0a31d737a297de97676a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fca13953b551bb75af0a31d737a297de97676a7"}], "stats": {"total": 249, "additions": 246, "deletions": 3}, "files": [{"sha": "a1aa3f6327d4e97ed91890d4e5100da6cf5b82dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -1,3 +1,18 @@\n+2017-09-19  Jeff Law  <law@redhat.com>\n+\n+\t* common.opt (-fstack-clash-protection): New option.\n+\t* flag-types.h (enum stack_check_type): Note difference between\n+\t-fstack-check= and -fstack-clash-protection.\n+\t* params.def (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE): New PARAM.\n+\t(PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL): Likewise.\n+\t* toplev.c (process_options): Issue warnings/errors for cases\n+\tnot handled with -fstack-clash-protection.\n+\t* doc/invoke.texi (-fstack-clash-protection): Document new option.\n+\t(-fstack-check): Note additional problem with -fstack-check=generic.\n+\tNote that -fstack-check is primarily for Ada and refer users\n+\tto -fstack-clash-protection for stack-clash-protection.\n+\tDocument new params for stack clash protection.\n+\n 2017-09-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*scc_bt<mode>): New insn_and_split pattern."}, {"sha": "f22661cfbba7f9e7a4265a545838993674985007", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -2320,13 +2320,18 @@ Common Report Var(flag_variable_expansion_in_unroller) Optimization\n Apply variable expansion when loops are unrolled.\n \n fstack-check=\n-Common Report RejectNegative Joined\n+Common Report RejectNegative Joined Optimization\n -fstack-check=[no|generic|specific]\tInsert stack checking code into the program.\n \n fstack-check\n Common Alias(fstack-check=, specific, no)\n Insert stack checking code into the program.  Same as -fstack-check=specific.\n \n+fstack-clash-protection\n+Common Report Var(flag_stack_clash_protection) Optimization\n+Insert code to probe each page of stack space as it is allocated to protect\n+from stack-clash style attacks.\n+\n fstack-limit\n Common Var(common_deferred_options) Defer\n "}, {"sha": "f0f9559b0243975f3fb2f72e9df23ac1209fc3c0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -10187,6 +10187,21 @@ compilation without.  The value for compilation with profile feedback\n needs to be more conservative (higher) in order to make tracer\n effective.\n \n+@item stack-clash-protection-guard-size\n+Specify the size of the operating system provided stack guard as\n+2 raised to @var{num} bytes.  The default value is 12 (4096 bytes).\n+Acceptable values are between 12 and 30.  Higher values may reduce the\n+number of explicit probes, but a value larger than the operating system\n+provided guard will leave code vulnerable to stack clash style attacks.\n+\n+@item stack-clash-protection-probe-interval\n+Stack clash protection involves probing stack space as it is allocated.  This\n+param controls the maximum distance between probes into the stack as 2 raised\n+to @var{num} bytes.  Acceptable values are between 10 and 16 and defaults to\n+12.  Higher values may reduce the number of explicit probes, but a value\n+larger than the operating system provided guard will leave code vulnerable to\n+stack clash style attacks.\n+\n @item max-cse-path-length\n \n The maximum number of basic blocks on path that CSE considers.\n@@ -11412,7 +11427,8 @@ target support in the compiler but comes with the following drawbacks:\n @enumerate\n @item\n Modified allocation strategy for large objects: they are always\n-allocated dynamically if their size exceeds a fixed threshold.\n+allocated dynamically if their size exceeds a fixed threshold.  Note this\n+may change the semantics of some code.\n \n @item\n Fixed limit on the size of the static frame of functions: when it is\n@@ -11427,6 +11443,25 @@ generic implementation, code performance is hampered.\n Note that old-style stack checking is also the fallback method for\n @samp{specific} if no target support has been added in the compiler.\n \n+@samp{-fstack-check=} is designed for Ada's needs to detect infinite recursion\n+and stack overflows.  @samp{specific} is an excellent choice when compiling\n+Ada code.  It is not generally sufficient to protect against stack-clash\n+attacks.  To protect against those you want @samp{-fstack-clash-protection}.\n+\n+@item -fstack-clash-protection\n+@opindex fstack-clash-protection\n+Generate code to prevent stack clash style attacks.  When this option is\n+enabled, the compiler will only allocate one page of stack space at a time\n+and each page is accessed immediately after allocation.  Thus, it prevents\n+allocations from jumping over any stack guard page provided by the\n+operating system.\n+\n+Most targets do not fully support stack clash protection.  However, on\n+those targets @option{-fstack-clash-protection} will protect dynamic stack\n+allocations.  @option{-fstack-clash-protection} may also provide limited\n+protection for static stack allocations if the target supports\n+@option{-fstack-check=specific}.\n+\n @item -fstack-limit-register=@var{reg}\n @itemx -fstack-limit-symbol=@var{sym}\n @itemx -fno-stack-limit"}, {"sha": "1f439d35b07b6c1dbb84686ad8fe2d6083f0086a", "filename": "gcc/flag-types.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -166,7 +166,14 @@ enum permitted_flt_eval_methods\n   PERMITTED_FLT_EVAL_METHODS_C11\n };\n \n-/* Type of stack check.  */\n+/* Type of stack check.\n+\n+   Stack checking is designed to detect infinite recursion and stack\n+   overflows for Ada programs.  Furthermore stack checking tries to ensure\n+   in that scenario that enough stack space is left to run a signal handler.\n+\n+   -fstack-check= does not prevent stack-clash style attacks.  For that\n+   you want -fstack-clash-protection.  */\n enum stack_check_type\n {\n   /* Do not check the stack.  */"}, {"sha": "860e79e32093ced9b60148295c2fd6b99eebf940", "filename": "gcc/params.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -213,6 +213,16 @@ DEFPARAM(PARAM_STACK_FRAME_GROWTH,\n \t \"Maximal stack frame growth due to inlining (in percent).\",\n \t 1000, 0, 0)\n \n+DEFPARAM(PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE,\n+\t \"stack-clash-protection-guard-size\",\n+\t \"Size of the stack guard expressed as a power of two.\",\n+\t 12, 12, 30)\n+\n+DEFPARAM(PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL,\n+\t \"stack-clash-protection-probe-interval\",\n+\t \"Interval in which to probe the stack expressed as a power of two.\",\n+\t 12, 10, 16)\n+\n /* The GCSE optimization will be disabled if it would require\n    significantly more memory than this value.  */\n DEFPARAM(PARAM_MAX_GCSE_MEMORY,"}, {"sha": "a77b54604e623558b4be346e07ecb8d508ae936d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -1,3 +1,11 @@\n+2017-09-19  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/stack-check-2.c: New test.\n+\t* lib/target-supports.exp\n+\t(check_effective_target_supports_stack_clash_protection): New function.\n+\t(check_effective_target_frame_pointer_for_non_leaf): Likewise.\n+\t(check_effective_target_caller_implicit_probes): Likewise.\n+\n 2017-09-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/bt-5.c: New test."}, {"sha": "196c4bbfbdda19ff40030e1283cb02b75d3e2b06", "filename": "gcc/testsuite/gcc.dg/stack-check-2.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-2.c?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -0,0 +1,66 @@\n+/* The goal here is to ensure that we never consider a call to a noreturn\n+   function as a potential tail call.\n+\n+   Right now GCC discovers potential tail calls by looking at the\n+   predecessors of the exit block.  A call to a non-return function\n+   has no successors and thus can never match that first filter.\n+\n+   But that could change one day and we want to catch it.  The problem\n+   is the compiler could potentially optimize a tail call to a nonreturn\n+   function, even if the caller has a frame.  That breaks the assumption\n+   that calls probe *sp when saving the return address that some targets\n+   depend on to elide stack probes.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection -fdump-tree-tailc -fdump-tree-optimized\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+extern void foo (void) __attribute__ ((__noreturn__));\n+\n+\n+void\n+test_direct_1 (void)\n+{\n+  foo ();\n+}\n+\n+void\n+test_direct_2 (void)\n+{\n+  return foo ();\n+}\n+\n+void (*indirect)(void)__attribute__ ((noreturn));\n+\n+\n+void\n+test_indirect_1 ()\n+{\n+  (*indirect)();\n+}\n+\n+void\n+test_indirect_2 (void)\n+{\n+  return (*indirect)();;\n+}\n+\n+\n+typedef void (*pvfn)() __attribute__ ((noreturn));\n+\n+void (*indirect_casted)(void);\n+\n+void\n+test_indirect_casted_1 ()\n+{\n+  (*(pvfn)indirect_casted)();\n+}\n+\n+void\n+test_indirect_casted_2 (void)\n+{\n+  return (*(pvfn)indirect_casted)();\n+}\n+/* { dg-final { scan-tree-dump-not \"tail call\" \"tailc\" } } */\n+/* { dg-final { scan-tree-dump-not \"tail call\" \"optimized\" } } */\n+"}, {"sha": "feed524680d8a73a270e93a7466a83c0fcc95b1d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -8621,3 +8621,80 @@ proc check_effective_target_autoincdec { } {\n     }\n     return 0\n }\n+\n+# Return 1 if the target has support for stack probing designed\n+# to avoid stack-clash style attacks.\n+#\n+# This is used to restrict the stack-clash mitigation tests to\n+# just those targets that have been explicitly supported.\n+# \n+# In addition to the prologue work on those targets, each target's\n+# properties should be described in the functions below so that\n+# tests do not become a mess of unreadable target conditions.\n+# \n+proc check_effective_target_supports_stack_clash_protection { } {\n+\n+   # Temporary until the target bits are fully ACK'd.\n+#  if { [istarget aarch*-*-*] || [istarget x86_64-*-*]\n+#       || [istarget i?86-*-*] || [istarget s390*-*-*]\n+#       || [istarget powerpc*-*-*] || [istarget rs6000*-*-*] } {\n+#\treturn 1\n+#  }\n+  return 0\n+}\n+\n+# Return 1 if the target creates a frame pointer for non-leaf functions\n+# Note we ignore cases where we apply tail call optimization here.\n+proc check_effective_target_frame_pointer_for_non_leaf { } {\n+  if { [istarget aarch*-*-*] } {\n+\treturn 1\n+  }\n+  return 0\n+}\n+\n+# Return 1 if the target's calling sequence or its ABI\n+# create implicit stack probes at or prior to function entry.\n+proc check_effective_target_caller_implicit_probes { } {\n+\n+  # On x86/x86_64 the call instruction itself pushes the return\n+  # address onto the stack.  That is an implicit probe of *sp.\n+  if { [istarget x86_64-*-*] || [istarget i?86-*-*] } {\n+\treturn 1\n+  }\n+\n+  # On PPC, the ABI mandates that the address of the outer\n+  # frame be stored at *sp.  Thus each allocation of stack\n+  # space is itself an implicit probe of *sp.\n+  if { [istarget powerpc*-*-*] || [istarget rs6000*-*-*] } {\n+\treturn 1\n+  }\n+\n+  # s390's ABI has a register save area allocated by the\n+  # caller for use by the callee.  The mere existence does\n+  # not constitute a probe by the caller, but when the slots\n+  # used by the callee those stores are implicit probes.\n+  if { [istarget s390*-*-*] } {\n+\treturn 1\n+  }\n+\n+  # Not strictly true on aarch64, but we have agreed that we will\n+  # consider any function that pushes SP more than 3kbytes into\n+  # the guard page as broken.  This essentially means that we can\n+  # consider the aarch64 as having a caller implicit probe at\n+  # *(sp + 1k).\n+  if { [istarget aarch64*-*-*] } {\n+\treturn 1;\n+  }\n+\n+  return 0\n+}\n+\n+# Targets that potentially realign the stack pointer often cause residual\n+# stack allocations and make it difficult to elimination loops or residual\n+# allocations for dynamic stack allocations\n+proc check_effective_target_callee_realigns_stack { } {\n+  if { [istarget x86_64-*-*] || [istarget i?86-*-*] } {\n+\treturn 1\n+  }\n+  return 0\n+}"}, {"sha": "6f48e10850d22636c58405c137bbf89db6032d28", "filename": "gcc/toplev.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8f15c69e324cdb1fa553ac14f760f799c425e2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ee8f15c69e324cdb1fa553ac14f760f799c425e2", "patch": "@@ -1605,6 +1605,26 @@ process_options (void)\n       flag_associative_math = 0;\n     }\n \n+  /* -fstack-clash-protection is not currently supported on targets\n+     where the stack grows up.  */\n+  if (flag_stack_clash_protection && !STACK_GROWS_DOWNWARD)\n+    {\n+      warning_at (UNKNOWN_LOCATION, 0,\n+\t\t  \"%<-fstack-clash-protection%> is not supported on targets \"\n+\t\t  \"where the stack grows from lower to higher addresses\");\n+      flag_stack_clash_protection = 0;\n+    }\n+\n+  /* We can not support -fstack-check= and -fstack-clash-protection at\n+     the same time.  */\n+  if (flag_stack_check != NO_STACK_CHECK && flag_stack_clash_protection)\n+    {\n+      warning_at (UNKNOWN_LOCATION, 0,\n+\t\t  \"%<-fstack-check=%> and %<-fstack-clash_protection%> are \"\n+\t\t  \"mutually exclusive.  Disabling %<-fstack-check=%>\");\n+      flag_stack_check = NO_STACK_CHECK;\n+    }\n+\n   /* With -fcx-limited-range, we do cheap and quick complex arithmetic.  */\n   if (flag_cx_limited_range)\n     flag_complex_method = 0;"}]}