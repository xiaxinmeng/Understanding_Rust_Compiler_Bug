{"sha": "1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiN2RmYzNiM2MxNTA2YzBmYzNjZWYzM2I4NTcxZjJlZWZkNTQ5Yw==", "commit": {"author": {"name": "Mostafa Hagog", "email": "mustafa@il.ibm.com", "date": "2005-04-03T08:44:33Z"}, "committer": {"name": "Mostafa Hagog", "email": "hagog@gcc.gnu.org", "date": "2005-04-03T08:44:33Z"}, "message": "cfghooks.c (lv_flush_pending_stmts, [...]): New.\n\n2005-03-30 Mostafa Hagog <mustafa@il.ibm.com>\n\n        * cfghooks.c (lv_flush_pending_stmts,\n        cfg_hook_duplicate_loop_to_header_edge, extract_cond_bb_edges,\n        lv_adjust_loop_header_phi, lv_add_condition_to_bb): New.\n        * cfghooks.h (cfg_hook_duplicate_loop_to_header_edge,\n        lv_add_condition_to_bb,\n        lv_adjust_loop_header_phi, extract_cond_bb_edges,\n        flush_pending_stmts): New in cfg_hooks structure.\n        (cfg_hook_duplicate_loop_to_header_edge, lv_flush_pending_stmts,\n        extract_cond_bb_edges, lv_adjust_loop_header_phi,\n        lv_add_condition_to_bb): New declarations.\n        * cfgloop.h (duplicate_loop_to_header_edge): Change return type to\n        bool.\n        (loop_version): Declare.\n        * cfgloopmanip.c (cfghooks.h): Include.\n        (duplicate_loop_to_header_edge): Change return type to bool.\n        (loop_version, lv_adjust_loop_entry_edge): Move here.\n        * cfgrtl.c (cfgloop.h): Include.\n        (rtl_verify_flow_info_1): Fix.\n        (rtl_lv_add_condition_to_bb, rtl_extract_cond_bb_edges): New.\n        (rtl_cfg_hooks, cfg_layout_rtl_cfg_hook): Add hooks to\n        initialization.\n        * tree-cfg.c (tree_lv_adjust_loop_header_phi,\n        tree_lv_add_condition_to_bb): New.\n        (tree_cfg_hooks): Add new hooks to initialization.\n        * tree-ssa-loop-manip.c (lv_adjust_loop_header_phi,\n        lv_adjust_loop_entry_edge, tree_ssa_loop_version): Remove.\n\nFrom-SVN: r97481", "tree": {"sha": "0b472172f6a31148aad4e01247e8d9a83810ecd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b472172f6a31148aad4e01247e8d9a83810ecd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/comments", "author": null, "committer": null, "parents": [{"sha": "2be74e4108a753c5b5117e4de6b6bbe2c8f01b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be74e4108a753c5b5117e4de6b6bbe2c8f01b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be74e4108a753c5b5117e4de6b6bbe2c8f01b36"}], "stats": {"total": 601, "additions": 415, "deletions": 186}, "files": [{"sha": "16ac20a6ee011c21708088728ad9c0cc1b80224d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -1,3 +1,32 @@\n+2005-04-03 Mostafa Hagog <mustafa@il.ibm.com>\n+\n+\t* cfghooks.c (lv_flush_pending_stmts,\n+\tcfg_hook_duplicate_loop_to_header_edge, extract_cond_bb_edges,\n+\tlv_adjust_loop_header_phi, lv_add_condition_to_bb): New.\n+\t* cfghooks.h (cfg_hook_duplicate_loop_to_header_edge,\n+\tlv_add_condition_to_bb,\n+\tlv_adjust_loop_header_phi, extract_cond_bb_edges,\n+\tflush_pending_stmts): New in cfg_hooks structure.\n+\t(cfg_hook_duplicate_loop_to_header_edge, lv_flush_pending_stmts,\n+\textract_cond_bb_edges, lv_adjust_loop_header_phi,\n+\tlv_add_condition_to_bb): New declarations.\n+\t* cfgloop.h (duplicate_loop_to_header_edge): Change return type to\n+\tbool.\n+\t(loop_version): Declare.\n+\t* cfgloopmanip.c (cfghooks.h): Include.\n+\t(duplicate_loop_to_header_edge): Change return type to bool.\n+\t(loop_version, lv_adjust_loop_entry_edge): Move here.\n+\t* cfgrtl.c (cfgloop.h): Include.\n+\t(rtl_verify_flow_info_1): Fix.\n+\t(rtl_lv_add_condition_to_bb, rtl_extract_cond_bb_edges): New.\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hook): Add hooks to\n+\tinitialization.\n+\t* tree-cfg.c (tree_lv_adjust_loop_header_phi,\n+\ttree_lv_add_condition_to_bb): New.\n+\t(tree_cfg_hooks): Add new hooks to initialization.\n+\t* tree-ssa-loop-manip.c (lv_adjust_loop_header_phi,\n+\tlv_adjust_loop_entry_edge, tree_ssa_loop_version): Remove.\n+\n 2005-04-03  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/stormy16/stormy16.h (PREDICATE_CODES): Add SUBREG to"}, {"sha": "eb21afe6fa1aab94c91d29cfe6ec7c975eec8cf0", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -823,3 +823,66 @@ execute_on_shrinking_pred (edge e)\n   if (cfg_hooks->execute_on_shrinking_pred)\n     cfg_hooks->execute_on_shrinking_pred (e);\n }\n+\n+/* This is used inside loop versioning when we want to insert \n+   stmts/insns on the edges, which have a different behaviour \n+   in tree's and in RTL, so we made a CFG hook.  */\n+void\n+lv_flush_pending_stmts (edge e)\n+{\n+  if (cfg_hooks->flush_pending_stmts)\n+    cfg_hooks->flush_pending_stmts (e);\n+}\n+\n+/* Loop versioning uses the duplicate_loop_to_header_edge to create\n+   a new version of the loop basic-blocks, the parameters here are\n+   exactly the same as in duplicate_loop_to_header_edge or\n+   tree_duplicate_loop_to_header_edge; while in tree-ssa there is\n+   additional work to maintain ssa information that's why there is\n+   a need to call the tree_duplicate_loop_to_header_edge rather\n+   than duplicate_loop_to_header_edge when we are in tree mode.  */\n+bool\n+cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n+\t\t\t\t\tstruct loops *loops, unsigned int ndupl,\n+\t\t\t\t\tsbitmap wont_exit, edge orig,\n+\t\t\t\t\tedge *to_remove,\n+\t\t\t\t\tunsigned int *n_to_remove, int flags)\n+{\n+  gcc_assert (cfg_hooks->cfg_hook_duplicate_loop_to_header_edge);\n+  return cfg_hooks->cfg_hook_duplicate_loop_to_header_edge (loop, e, loops, \t\t\t\t\t\t\t    \n+\t\t\t\t\t\t\t    ndupl, wont_exit,\n+\t\t\t\t\t\t\t    orig, to_remove,\n+\t\t\t\t\t\t\t    n_to_remove, flags);\n+}\n+\n+/* Conditional jumps are represented differently in trees and RTL,\n+   this hook takes a basic block that is known to have a cond jump\n+   at its end and extracts the taken and not taken eges out of it\n+   and store it in E1 and E2 respectively.  */\n+void\n+extract_cond_bb_edges (basic_block b, edge *e1, edge *e2)\n+{\n+  gcc_assert (cfg_hooks->extract_cond_bb_edges);\n+  cfg_hooks->extract_cond_bb_edges (b, e1, e2);\n+}\n+\n+/* Responsible for updating the ssa info (PHI nodes) on the\n+   new conidtion basic block that guargs the versioned loop.  */\n+void\n+lv_adjust_loop_header_phi (basic_block first, basic_block second,\n+\t\t\t   basic_block new, edge e)\n+{\n+  if (cfg_hooks->lv_adjust_loop_header_phi)\n+    cfg_hooks->lv_adjust_loop_header_phi (first, second, new, e);\n+}\n+\n+/* Conditions in trees and RTL are different so we need\n+   a different handling when we add the condition to the\n+   versioning code.  */\n+void\n+lv_add_condition_to_bb (basic_block first, basic_block second,\n+\t\t\tbasic_block new, void *cond)\n+{\n+  gcc_assert (cfg_hooks->lv_add_condition_to_bb);\n+  cfg_hooks->lv_add_condition_to_bb (first, second, new, cond);\n+}  "}, {"sha": "a05a0154c92601edd40bdb75c18159589fc6a702", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -108,6 +108,33 @@ struct cfg_hooks\n   /* This function is called immediately before edge E is removed from\n      the edge vector E->dest->preds.  */\n   void (*execute_on_shrinking_pred) (edge);\n+\n+  /* A hook for duplicating loop in CFG, currently this is used\n+     in loop versioning.  */\n+  bool (*cfg_hook_duplicate_loop_to_header_edge) (struct loop *loop, edge e,\n+\t\t\t\t\t\t  struct loops *loops,\n+\t\t\t\t\t\t  unsigned int ndupl,\n+\t\t\t\t\t\t  sbitmap wont_exit,\n+\t\t\t\t\t\t  edge orig, edge *to_remove,\n+\t\t\t\t\t\t  unsigned int *n_to_remove,\n+\t\t\t\t\t\t  int flags);\n+\n+  /* Add conition to new basic block and update CFG used in loop\n+     versioning.  */\n+  void (*lv_add_condition_to_bb) (basic_block, basic_block, basic_block,\n+  \t\t\t\t  void *);\n+  /* Update the PHI nodes in case of loop versioning.  */\n+  void (*lv_adjust_loop_header_phi) (basic_block, basic_block,\n+\t\t\t\t     basic_block, edge);\n+\t\t\t\t    \n+  /* Given a condition BB extract the true/false taken/not taken edges\n+     (depending if we are on tree's or RTL). */\n+  void (*extract_cond_bb_edges) (basic_block, edge *, edge *);\n+\n+  \n+  /* Add PHI arguments queued in PENDINT_STMT list on edge E to edge\n+     E->dest (only in tree-ssa loop versioning.  */\n+  void (*flush_pending_stmts) (edge);\n };\n \n extern void verify_flow_info (void);\n@@ -136,6 +163,20 @@ extern bool block_ends_with_condjump_p (basic_block bb);\n extern int flow_call_edges_add (sbitmap);\n extern void execute_on_growing_pred (edge);\n extern void execute_on_shrinking_pred (edge);\n+extern bool cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge,\n+\t\t\t\t\t\t    struct loops *loops,\n+\t\t\t\t\t\t    unsigned int ndupl,\n+\t\t\t\t\t\t    sbitmap wont_exit,\n+\t\t\t\t\t\t    edge orig, edge *to_remove,\n+\t\t\t\t\t\t    unsigned int *n_to_remove,\n+\t\t\t\t\t\t    int flags);\n+\n+extern void lv_flush_pending_stmts (edge);\n+extern void extract_cond_bb_edges (basic_block, edge *, edge*);\n+extern void lv_adjust_loop_header_phi (basic_block, basic_block, basic_block,\n+\t\t\t\t       edge);\n+extern void lv_add_condition_to_bb (basic_block, basic_block, basic_block,\n+\t\t\t\t    void *);\n \n /* Hooks containers.  */\n extern struct cfg_hooks tree_cfg_hooks;"}, {"sha": "7a5d57fbff0d6b52c705a4e30fb9536a2d188d09", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -298,11 +298,13 @@ extern bool can_duplicate_loop_p (struct loop *loop);\n \n extern struct loop * duplicate_loop (struct loops *, struct loop *,\n \t\t\t\t     struct loop *);\n-extern int duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n-\t\t\t\t\t  unsigned, sbitmap, edge, edge *,\n-\t\t\t\t\t  unsigned *, int);\n+extern bool duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n+\t\t\t\t\t   unsigned, sbitmap, edge, edge *,\n+\t\t\t\t\t   unsigned *, int);\n extern struct loop *loopify (struct loops *, edge, edge,\n \t\t\t     basic_block, edge, edge, bool);\n+struct loop * loop_version (struct loops *, struct loop *, void *,\n+\t\t\t    basic_block *);\t\t\t     \n extern bool remove_path (struct loops *, edge);\n extern edge split_loop_bb (basic_block, void *);\n "}, {"sha": "50fad382f65dd9aa84a1ddaa85050a01cbc09367", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -28,6 +28,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n+#include \"cfghooks.h\"\n #include \"output.h\"\n \n static void duplicate_subloops (struct loops *, struct loop *, struct loop *);\n@@ -837,7 +838,7 @@ update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n    original LOOP body, the other copies are numbered in order given by control\n    flow through them) into TO_REMOVE array.  Returns false if duplication is\n    impossible.  */\n-int\n+bool\n duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t\t\t       unsigned int ndupl, sbitmap wont_exit,\n \t\t\t       edge orig, edge *to_remove,\n@@ -1354,6 +1355,135 @@ create_loop_notes (void)\n   flow_loops_free (&loops);\n }\n \n+/* This function is called from loop_version.  It splits the entry edge\n+   of the loop we want to version, adds the versioning condition, and\n+   adjust the edges to the two versions of the loop appropriately.\n+   e is an incoming edge. Returns the basic block containing the\n+   condition.\n+\n+   --- edge e ---- > [second_head]\n+\n+   Split it and insert new conditional expression and adjust edges.\n+\n+    --- edge e ---> [cond expr] ---> [first_head]\n+                        |\n+                        +---------> [second_head]\n+*/\n+\n+static basic_block\n+lv_adjust_loop_entry_edge (basic_block first_head,\n+\t\t\t   basic_block second_head,\n+\t\t\t   edge e,\n+\t\t\t   tree cond_expr)\n+{\n+  basic_block new_head = NULL;\n+  edge e1;\n+\n+  gcc_assert (e->dest == second_head);\n+\n+  /* Split edge 'e'. This will create a new basic block, where we can\n+     insert conditional expr.  */\n+  new_head = split_edge (e);\n+\n+\n+  lv_add_condition_to_bb (first_head, second_head, new_head,\n+\t\t\t  cond_expr);\n+\n+  e1 = make_edge (new_head, first_head, EDGE_TRUE_VALUE);\n+  set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n+  set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);\n+\n+  /* Adjust loop header phi nodes.  */\n+  lv_adjust_loop_header_phi (first_head, second_head, new_head, e1);\n+\n+  return new_head;\n+}\n+\n+/* Main entry point for Loop Versioning transformation.\n+   \n+This transformation given a condition and a loop, creates\n+-if (condition) { loop_copy1 } else { loop_copy2 },\n+where loop_copy1 is the loop transformed in one way, and loop_copy2\n+is the loop transformed in another way (or unchanged). 'condition'\n+may be a run time test for things that were not resolved by static\n+analysis (overlapping ranges (anti-aliasing), alignment, etc.).  */\n+\n+struct loop *\n+loop_version (struct loops *loops, struct loop * loop, \n+\t      void *cond_expr, basic_block *condition_bb)\n+{\n+  basic_block first_head, second_head;\n+  edge entry, latch_edge, exit, true_edge, false_edge;\n+  int irred_flag;\n+  struct loop *nloop;\n+\n+  /* CHECKME: Loop versioning does not handle nested loop at this point.  */\n+  if (loop->inner)\n+    return NULL;\n+\n+  /* Record entry and latch edges for the loop */\n+  entry = loop_preheader_edge (loop);\n+  irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;\n+  entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+  \n+  /* Note down head of loop as first_head.  */\n+  first_head = entry->dest;\n+\n+  /* Duplicate loop.  */\n+  if (!cfg_hook_duplicate_loop_to_header_edge (loop, entry, loops, 1,\n+  \t\t\t\t\t       NULL, NULL, NULL, NULL, 0))\n+    return NULL;\n+\n+  /* After duplication entry edge now points to new loop head block.\n+     Note down new head as second_head.  */\n+  second_head = entry->dest;\n+\n+  /* Split loop entry edge and insert new block with cond expr.  */\n+  *condition_bb =  lv_adjust_loop_entry_edge (first_head, second_head,\n+\t\t\t\t\t      entry, cond_expr);\n+  if (!*condition_bb)\n+    {\n+      entry->flags |= irred_flag;\n+      return NULL;\n+    }\n+\n+  latch_edge = single_succ_edge (loop->latch->rbi->copy);\n+  \n+  extract_cond_bb_edges (*condition_bb, &true_edge, &false_edge);\n+  nloop = loopify (loops,\n+\t\t   latch_edge,\n+\t\t   single_pred_edge (loop->header->rbi->copy),\n+\t\t   *condition_bb, true_edge, false_edge,\n+\t\t   false /* Do not redirect all edges.  */);\n+\n+  exit = loop->single_exit;\n+  if (exit)\n+    nloop->single_exit = find_edge (exit->src->rbi->copy, exit->dest);\n+\n+  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */ \n+  lv_flush_pending_stmts (latch_edge);\n+\n+  /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */ \n+  extract_cond_bb_edges (*condition_bb, &true_edge, &false_edge);\n+  lv_flush_pending_stmts (false_edge);\n+  /* Adjust irreducible flag.  */\n+  if (irred_flag)\n+    {\n+      (*condition_bb)->flags |= BB_IRREDUCIBLE_LOOP;\n+      loop_preheader_edge (loop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      loop_preheader_edge (nloop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      single_pred_edge ((*condition_bb))->flags |= EDGE_IRREDUCIBLE_LOOP;\n+    }\n+\n+  /* At this point condition_bb is loop predheader with two successors, \n+     first_head and second_head.   Make sure that loop predheader has only \n+     one successor.  */\n+  loop_split_edge_with (loop_preheader_edge (loop), NULL);\n+  loop_split_edge_with (loop_preheader_edge (nloop), NULL);\n+\n+  return nloop;\n+}\n+\n /* The structure of LOOPS might have changed.  Some loops might get removed\n    (and their headers and latches were set to NULL), loop exists might get\n    removed (thus the loop nesting may be wrong), and some blocks and edges"}, {"sha": "d0a50e46a8e03ab0fdab0fdd7dfd9b1339c383fc", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -57,7 +57,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"expr.h\"\n #include \"target.h\"\n-\n+#include \"cfgloop.h\"\n \n /* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n /* ??? Should probably be using LABEL_NUSES instead.  It would take a\n@@ -2028,7 +2028,7 @@ rtl_verify_flow_info_1 (void)\n \t  err = 1;\n \t}\n       if (n_branch != 1 && any_condjump_p (BB_END (bb))\n-\t  && JUMP_LABEL (BB_END (bb)) != BB_HEAD (fallthru->dest))\n+\t  && JUMP_LABEL (BB_END (bb)) == BB_HEAD (fallthru->dest))\n \t{\n \t  error (\"Wrong amount of branch edges after conditional jump %i\", bb->index);\n \t  err = 1;\n@@ -2997,6 +2997,66 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   return blocks_split;\n }\n \n+/* Add COMP_RTX as a condition at end of COND_BB.  FIRST_HEAD is\n+   the conditional branch traget, SECOND_HEAD should be the fall-thru\n+   there is no need to handle this here the loop versioning code handles\n+   this.  the reason for SECON_HEAD is that it is needed for condition\n+   in trees, and this should be of the same type since it is a hook.  */\n+static void\n+rtl_lv_add_condition_to_bb (basic_block first_head ,\n+\t\t\t    basic_block second_head ATTRIBUTE_UNUSED, \n+\t\t\t    basic_block cond_bb, void *comp_rtx)  \n+{\n+  rtx label, seq, jump;\n+  rtx op0 = XEXP ((rtx)comp_rtx, 0);\n+  rtx op1 = XEXP ((rtx)comp_rtx, 1);\n+  enum rtx_code comp = GET_CODE ((rtx)comp_rtx);\n+  enum machine_mode mode;\n+\n+\n+  label = block_label (first_head);\n+  mode = GET_MODE (op0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op1);\n+\n+  start_sequence ();\n+  op0 = force_operand (op0, NULL_RTX);\n+  op1 = force_operand (op1, NULL_RTX);\n+  do_compare_rtx_and_jump (op0, op1, comp, 0,\n+\t\t\t   mode, NULL_RTX, NULL_RTX, label);\n+  jump = get_last_insn ();\n+  JUMP_LABEL (jump) = label;\n+  LABEL_NUSES (label)++;\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  /* Add the new cond , in the new head.  */\n+  emit_insn_after(seq, BB_END(cond_bb));\n+}\n+\n+\n+/* Given a block B with unconditional branch at its end, get the\n+   store the return the branch edge and the fall-thru edge in\n+   BRANCH_EDGE and FALLTHRU_EDGE respectively.  */\n+static void\n+rtl_extract_cond_bb_edges (basic_block b, edge *branch_edge,\n+\t\t\t   edge *fallthru_edge)\n+{\n+  edge e = EDGE_SUCC (b, 0);\n+\n+  if (e->flags & EDGE_FALLTHRU)\n+    {\n+      *fallthru_edge = e;\n+      *branch_edge = EDGE_SUCC (b, 1);\n+    }\n+  else\n+    {\n+      *branch_edge = e;\n+      *fallthru_edge = EDGE_SUCC (b, 1);\n+    }\n+}\n+\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   \"rtl\",\n@@ -3021,7 +3081,12 @@ struct cfg_hooks rtl_cfg_hooks = {\n   rtl_block_ends_with_condjump_p,\n   rtl_flow_call_edges_add,\n   NULL, /* execute_on_growing_pred */\n-  NULL /* execute_on_shrinking_pred */\n+  NULL, /* execute_on_shrinking_pred */\n+  NULL, /* duplicate loop for trees */\n+  NULL, /* lv_add_condition_to_bb */\n+  NULL, /* lv_adjust_loop_header_phi*/\n+  NULL, /* extract_cond_bb_edges */\n+  NULL \t\t/* flush_pending_stmts */\n };\n \n /* Implementation of CFG manipulation for cfg layout RTL, where\n@@ -3059,6 +3124,11 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   rtl_block_ends_with_condjump_p,\n   rtl_flow_call_edges_add,\n   NULL, /* execute_on_growing_pred */\n-  NULL /* execute_on_shrinking_pred */\n+  NULL, /* execute_on_shrinking_pred */\n+  duplicate_loop_to_header_edge, /* duplicate loop for trees */\n+  rtl_lv_add_condition_to_bb, /* lv_add_condition_to_bb */\n+  NULL, /* lv_adjust_loop_header_phi*/\n+  rtl_extract_cond_bb_edges, /* extract_cond_bb_edges */\n+  NULL \t\t/* flush_pending_stmts */  \n };\n "}, {"sha": "d913759ba8de216535b1beec4186e9c494396a29", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -5687,6 +5687,71 @@ tree_execute_on_shrinking_pred (edge e)\n     remove_phi_args (e);\n }\n \n+/*---------------------------------------------------------------------------\n+  Helper functions for Loop versioning\n+  ---------------------------------------------------------------------------*/\n+\n+/* Adjust phi nodes for 'first' basic block.  'second' basic block is a copy\n+   of 'first'. Both of them are dominated by 'new_head' basic block. When\n+   'new_head' was created by 'second's incoming edge it received phi arguments\n+   on the edge by split_edge(). Later, additional edge 'e' was created to\n+   connect 'new_head' and 'first'. Now this routine adds phi args on this \n+   additional edge 'e' that new_head to second edge received as part of edge \n+   splitting.\n+*/\n+\n+static void\n+tree_lv_adjust_loop_header_phi (basic_block first, basic_block second,\n+\t\t\t\tbasic_block new_head, edge e)\n+{\n+  tree phi1, phi2;\n+\n+  /* Browse all 'second' basic block phi nodes and add phi args to\n+     edge 'e' for 'first' head. PHI args are always in correct order.  */\n+\n+  for (phi2 = phi_nodes (second), phi1 = phi_nodes (first); \n+       phi2 && phi1; \n+       phi2 = PHI_CHAIN (phi2),  phi1 = PHI_CHAIN (phi1))\n+    {\n+      edge e2 = find_edge (new_head, second);\n+\n+      if (e2)\n+\t{\n+\t  tree def = PHI_ARG_DEF (phi2, e2->dest_idx);\n+\t  add_phi_arg (phi1, def, e);\n+\t}\n+    }\n+}\n+\n+/* Adds a if else statement to COND_BB with condition COND_EXPR.  \n+   SECOND_HEAD is the destination of the THEN and FIRST_HEAD is \n+   the destination of the ELSE part.  */\n+static void\n+tree_lv_add_condition_to_bb (basic_block first_head, basic_block second_head,\n+                            basic_block cond_bb, void *cond_e)\n+{\n+  block_stmt_iterator bsi;\n+  tree goto1 = NULL_TREE;\n+  tree goto2 = NULL_TREE;\n+  tree new_cond_expr = NULL_TREE;\n+  tree cond_expr = (tree) cond_e;\n+  edge e0;\n+\n+  /* Build new conditional expr */\n+  goto1 = build1 (GOTO_EXPR, void_type_node, tree_block_label (first_head));\n+  goto2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (second_head));\n+  new_cond_expr = build3 (COND_EXPR, void_type_node, cond_expr, goto1, goto2);\n+\n+  /* Add new cond in cond_bb.  */ \n+  bsi = bsi_start (cond_bb); \n+  bsi_insert_after (&bsi, new_cond_expr, BSI_NEW_STMT);\n+  /* Adjust edges appropriately to connect new head with first head\n+     as well as second head.  */\n+  e0 = single_succ_edge (cond_bb);\n+  e0->flags &= ~EDGE_FALLTHRU;\n+  e0->flags |= EDGE_FALSE_VALUE;\n+}\n+\n struct cfg_hooks tree_cfg_hooks = {\n   \"tree\",\n   tree_verify_flow_info,\n@@ -5711,6 +5776,11 @@ struct cfg_hooks tree_cfg_hooks = {\n   tree_flow_call_edges_add,     /* flow_call_edges_add */\n   tree_execute_on_growing_pred,\t/* execute_on_growing_pred */\n   tree_execute_on_shrinking_pred, /* execute_on_shrinking_pred */\n+  tree_duplicate_loop_to_header_edge, /* duplicate loop for trees */\n+  tree_lv_add_condition_to_bb, /* lv_add_condition_to_bb */\n+  tree_lv_adjust_loop_header_phi, /* lv_adjust_loop_header_phi*/\n+  extract_true_false_edges_from_block, /* extract_cond_bb_edges */\n+  flush_pending_stmts \t\t/* flush_pending_stmts */  \n };\n \n "}, {"sha": "1bb4c4c3aa1cd11a9d5048180c4d6a2dbeb27fe5", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -677,179 +677,3 @@ tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   return true;\n }\n \n-/*---------------------------------------------------------------------------\n-  Loop versioning\n-  ---------------------------------------------------------------------------*/\n- \n-/* Adjust phi nodes for 'first' basic block.  'second' basic block is a copy\n-   of 'first'. Both of them are dominated by 'new_head' basic block. When\n-   'new_head' was created by 'second's incoming edge it received phi arguments\n-   on the edge by split_edge(). Later, additional edge 'e' was created to\n-   connect 'new_head' and 'first'. Now this routine adds phi args on this \n-   additional edge 'e' that new_head to second edge received as part of edge \n-   splitting.\n-*/\n-\n-static void\n-lv_adjust_loop_header_phi (basic_block first, basic_block second,\n-\t\t\t   basic_block new_head, edge e)\n-{\n-  tree phi1, phi2;\n-\n-  /* Browse all 'second' basic block phi nodes and add phi args to\n-     edge 'e' for 'first' head. PHI args are always in correct order.  */\n-\n-  for (phi2 = phi_nodes (second), phi1 = phi_nodes (first); \n-       phi2 && phi1; \n-       phi2 = PHI_CHAIN (phi2),  phi1 = PHI_CHAIN (phi1))\n-    {\n-      edge e2 = find_edge (new_head, second);\n-\n-      if (e2)\n-\t{\n-\t  tree def = PHI_ARG_DEF (phi2, e2->dest_idx);\n-\t  add_phi_arg (phi1, def, e);\n-\t}\n-    }\n-}\n-\n-/* Adjust entry edge for lv.\n-   \n-  e is an incoming edge. \n-\n-  --- edge e ---- > [second_head]\n-\n-  Split it and insert new conditional expression and adjust edges.\n-   \n-   --- edge e ---> [cond expr] ---> [first_head]\n-                        |\n-                        +---------> [second_head]\n-\n-*/\n-   \n-static basic_block\n-lv_adjust_loop_entry_edge (basic_block first_head,\n-\t\t\t   basic_block second_head,\n-\t\t\t   edge e,\n-\t\t\t   tree cond_expr)\n-{ \n-  block_stmt_iterator bsi;\n-  basic_block new_head = NULL;\n-  tree goto1 = NULL_TREE;\n-  tree goto2 = NULL_TREE;\n-  tree new_cond_expr = NULL_TREE;\n-  edge e0, e1;\n-\n-  gcc_assert (e->dest == second_head);\n-\n-  /* Split edge 'e'. This will create a new basic block, where we can\n-     insert conditional expr.  */\n-  new_head = split_edge (e);\n-\n-  /* Build new conditional expr */\n-  goto1 = build1 (GOTO_EXPR, void_type_node, tree_block_label (first_head));\n-  goto2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (second_head));\n-  new_cond_expr = build3 (COND_EXPR, void_type_node, cond_expr, goto1, goto2);\n-\n-  /* Add new cond. in new head.  */ \n-  bsi = bsi_start (new_head); \n-  bsi_insert_after (&bsi, new_cond_expr, BSI_NEW_STMT);\n-\n-  /* Adjust edges appropriately to connect new head with first head\n-     as well as second head.  */\n-  e0 = single_succ_edge (new_head);\n-  e0->flags &= ~EDGE_FALLTHRU;\n-  e0->flags |= EDGE_FALSE_VALUE;\n-  e1 = make_edge (new_head, first_head, EDGE_TRUE_VALUE);\n-  set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n-  set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);\n-\n-  /* Adjust loop header phi nodes.  */\n-  lv_adjust_loop_header_phi (first_head, second_head, new_head, e1);\n-\n-  return new_head;\n-}\n-\n-/* Main entry point for Loop Versioning transformation.\n-   \n-This transformation given a condition and a loop, creates\n--if (condition) { loop_copy1 } else { loop_copy2 },\n-where loop_copy1 is the loop transformed in one way, and loop_copy2\n-is the loop transformed in another way (or unchanged). 'condition'\n-may be a run time test for things that were not resolved by static\n-analysis (overlapping ranges (anti-aliasing), alignment, etc.).  */\n-\n-struct loop *\n-tree_ssa_loop_version (struct loops *loops, struct loop * loop, \n-\t\t       tree cond_expr, basic_block *condition_bb)\n-{\n-  edge entry, latch_edge, exit, true_edge, false_edge;\n-  basic_block first_head, second_head;\n-  int irred_flag;\n-  struct loop *nloop;\n-\n-  /* CHECKME: Loop versioning does not handle nested loop at this point.  */\n-  if (loop->inner)\n-    return NULL;\n-\n-  /* Record entry and latch edges for the loop */\n-  entry = loop_preheader_edge (loop);\n-\n-  /* Note down head of loop as first_head.  */\n-  first_head = entry->dest;\n-\n-  /* Duplicate loop.  */\n-  irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;\n-  entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-  if (!tree_duplicate_loop_to_header_edge (loop, entry, loops, 1,\n-\t\t\t\t\t   NULL, NULL, NULL, NULL, 0))\n-    {\n-      entry->flags |= irred_flag;\n-      return NULL;\n-    }\n-\n-  /* After duplication entry edge now points to new loop head block.\n-     Note down new head as second_head.  */\n-  second_head = entry->dest;\n-\n-  /* Split loop entry edge and insert new block with cond expr.  */\n-  *condition_bb = lv_adjust_loop_entry_edge (first_head, second_head, entry, \n-\t\t\t\t\t    cond_expr); \n-\n-  latch_edge = single_succ_edge (loop->latch->rbi->copy);\n-  \n-  extract_true_false_edges_from_block (*condition_bb, &true_edge, &false_edge);\n-  nloop = loopify (loops, \n-\t\t   latch_edge,\n-\t\t   single_pred_edge (loop->header->rbi->copy),\n-\t\t   *condition_bb, true_edge, false_edge,\n-\t\t   false /* Do not redirect all edges.  */);\n-\n-  exit = loop->single_exit;\n-  if (exit)\n-    nloop->single_exit = find_edge (exit->src->rbi->copy, exit->dest);\n-\n-  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */ \n-  flush_pending_stmts (latch_edge);\n-\n-  /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */ \n-  extract_true_false_edges_from_block (*condition_bb, &true_edge, &false_edge);\n-  flush_pending_stmts (false_edge);\n-\n-  /* Adjust irreducible flag.  */\n-  if (irred_flag)\n-    {\n-      (*condition_bb)->flags |= BB_IRREDUCIBLE_LOOP;\n-      loop_preheader_edge (loop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      loop_preheader_edge (nloop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      single_pred_edge ((*condition_bb))->flags |= EDGE_IRREDUCIBLE_LOOP;\n-    }\n-\n-  /* At this point condition_bb is loop predheader with two successors, \n-     first_head and second_head.   Make sure that loop predheader has only \n-     one successor.  */\n-  loop_split_edge_with (loop_preheader_edge (loop), NULL);\n-  loop_split_edge_with (loop_preheader_edge (nloop), NULL);\n-\n-  return nloop;\n-}"}, {"sha": "03631b82636fe5ac2891641cab87e71c9ee9b53d", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=1cb7dfc3b3c1506c0fc3cef33b8571f2eefd549c", "patch": "@@ -283,6 +283,6 @@ tree_unswitch_loop (struct loops *loops, struct loop *loop,\n   gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n   gcc_assert (loop->inner == NULL);\n \n-  return tree_ssa_loop_version (loops, loop, unshare_expr (cond), \n-\t\t\t\t&condition_bb);\n+  return loop_version (loops, loop, unshare_expr (cond), \n+\t\t       &condition_bb);\n }"}]}