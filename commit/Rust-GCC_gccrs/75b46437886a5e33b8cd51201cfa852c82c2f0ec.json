{"sha": "75b46437886a5e33b8cd51201cfa852c82c2f0ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzViNDY0Mzc4ODZhNWUzM2I4Y2Q1MTIwMWNmYTg1MmM4MmMyZjBlYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-07T12:26:20Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-07T12:26:20Z"}, "message": "(build_enumerator): Choose type properly for wide constants.\n\n(finish_enum): Always set type of the enumerators to the enum type.\n\nFrom-SVN: r5271", "tree": {"sha": "605373f3d8a62e79ed9ffde89292614ddd8b25f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/605373f3d8a62e79ed9ffde89292614ddd8b25f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75b46437886a5e33b8cd51201cfa852c82c2f0ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b46437886a5e33b8cd51201cfa852c82c2f0ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b46437886a5e33b8cd51201cfa852c82c2f0ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b46437886a5e33b8cd51201cfa852c82c2f0ec/comments", "author": null, "committer": null, "parents": [{"sha": "ebf3718c05126972690fac163f22367af272a715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf3718c05126972690fac163f22367af272a715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf3718c05126972690fac163f22367af272a715"}], "stats": {"total": 36, "additions": 22, "deletions": 14}, "files": [{"sha": "539828e1c6743fe85d875e207e056ececfd4cbb7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b46437886a5e33b8cd51201cfa852c82c2f0ec/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b46437886a5e33b8cd51201cfa852c82c2f0ec/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=75b46437886a5e33b8cd51201cfa852c82c2f0ec", "patch": "@@ -5551,17 +5551,18 @@ finish_enum (enumtype, values)\n   /* An enum can have some negative values; then it is signed.  */\n   TREE_UNSIGNED (enumtype) = ! tree_int_cst_lt (minnode, integer_zero_node);\n \n-  /* If the enumerators might not fit in an int, change their type now.  */\n-  /* It seems more useful in the debugger to leave these as int\n-     unless the enumerator is wider than int.  */\n-  if (TYPE_PRECISION (enumtype) <= TYPE_PRECISION (integer_type_node))\n-    for (pair = values; pair; pair = TREE_CHAIN (pair))\n-      {\n-\tTREE_TYPE (TREE_PURPOSE (pair)) = enumtype;\n-\tDECL_SIZE (TREE_PURPOSE (pair)) = TYPE_SIZE (enumtype);\n-\tif (TREE_CODE (TREE_PURPOSE (pair)) != FUNCTION_DECL)\n-\t  DECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n-      }\n+  /* Change the type of the enumerators to be the enum type.\n+     Formerly this was done only for enums that fit in an int,\n+     but the comment said it was done only for enums wider than int.\n+     It seems necessary to do this for wide enums,\n+     and best not to change what's done for ordinary narrower ones.  */\n+  for (pair = values; pair; pair = TREE_CHAIN (pair))\n+    {\n+      TREE_TYPE (TREE_PURPOSE (pair)) = enumtype;\n+      DECL_SIZE (TREE_PURPOSE (pair)) = TYPE_SIZE (enumtype);\n+      if (TREE_CODE (TREE_PURPOSE (pair)) != FUNCTION_DECL)\n+\tDECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n+    }\n \n   /* Replace the decl nodes in VALUES with their names.  */\n   for (pair = values; pair; pair = TREE_CHAIN (pair))\n@@ -5600,7 +5601,7 @@ tree\n build_enumerator (name, value)\n      tree name, value;\n {\n-  register tree decl;\n+  register tree decl, type;\n \n   /* Validate and default VALUE.  */\n \n@@ -5645,9 +5646,16 @@ build_enumerator (name, value)\n \n   /* Now create a declaration for the enum value name.  */\n \n-  decl = build_decl (CONST_DECL, name, integer_type_node);\n+  type = TREE_TYPE (value);\n+  type = type_for_size (MAX (TYPE_PRECISION (type),\n+\t\t\t     TYPE_PRECISION (integer_type_node)),\n+\t\t\t((flag_traditional\n+\t\t\t  || TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node))\n+\t\t\t && TREE_UNSIGNED (type)));\n+\n+  decl = build_decl (CONST_DECL, name, type);\n   DECL_INITIAL (decl) = value;\n-  TREE_TYPE (value) = integer_type_node;\n+  TREE_TYPE (value) = type;\n   pushdecl (decl);\n \n   return saveable_tree_cons (decl, value, NULL_TREE);"}]}