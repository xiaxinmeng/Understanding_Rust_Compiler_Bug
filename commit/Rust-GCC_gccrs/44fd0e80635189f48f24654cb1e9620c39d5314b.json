{"sha": "44fd0e80635189f48f24654cb1e9620c39d5314b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmZDBlODA2MzUxODlmNDhmMjQ2NTRjYjFlOTYyMGMzOWQ1MzE0Yg==", "commit": {"author": {"name": "Ollie Wild", "email": "aaw@google.com", "date": "2007-08-17T21:42:38Z"}, "committer": {"name": "Ollie Wild", "email": "aaw@gcc.gnu.org", "date": "2007-08-17T21:42:38Z"}, "message": "re PR c++/31749 (ICE with invalid redeclaration of builtin)\n\n\tPR c++/31749\n\n\tgcc/cp/\n\t* name-lookup.c (do_nonmember_using_decl): Shift implicit type\n\tdeclarations into appropriate slots for comparison.  Fix type\n\tcomparison.\n\n\tgcc/testsuite/\n\t* g++.dg/lookup/builtin3.C: New test.\n\t* g++.dg/lookup/builtin4.C: New test.\n\t* g++.dg/lookup/using19.C: New test.\n\nFrom-SVN: r127600", "tree": {"sha": "a410ca7db354fe2d0df4c2e7bd1f54cb516b92c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a410ca7db354fe2d0df4c2e7bd1f54cb516b92c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44fd0e80635189f48f24654cb1e9620c39d5314b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fd0e80635189f48f24654cb1e9620c39d5314b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fd0e80635189f48f24654cb1e9620c39d5314b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fd0e80635189f48f24654cb1e9620c39d5314b/comments", "author": {"login": "olliewild", "id": 11523068, "node_id": "MDQ6VXNlcjExNTIzMDY4", "avatar_url": "https://avatars.githubusercontent.com/u/11523068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olliewild", "html_url": "https://github.com/olliewild", "followers_url": "https://api.github.com/users/olliewild/followers", "following_url": "https://api.github.com/users/olliewild/following{/other_user}", "gists_url": "https://api.github.com/users/olliewild/gists{/gist_id}", "starred_url": "https://api.github.com/users/olliewild/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olliewild/subscriptions", "organizations_url": "https://api.github.com/users/olliewild/orgs", "repos_url": "https://api.github.com/users/olliewild/repos", "events_url": "https://api.github.com/users/olliewild/events{/privacy}", "received_events_url": "https://api.github.com/users/olliewild/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ab78e532da9b7786956514de5319fc6f9f6450a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ab78e532da9b7786956514de5319fc6f9f6450a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ab78e532da9b7786956514de5319fc6f9f6450a"}], "stats": {"total": 228, "additions": 157, "deletions": 71}, "files": [{"sha": "9556496041fc8a5e379f22652bce384e7d4de3a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=44fd0e80635189f48f24654cb1e9620c39d5314b", "patch": "@@ -1,3 +1,10 @@\n+2007-08-17  Ollie Wild  <aaw@google.com>\n+\n+\tPR c++/31749\n+\t* name-lookup.c (do_nonmember_using_decl): Shift implicit type\n+\tdeclarations into appropriate slots for comparison.  Fix type\n+\tcomparison.\n+\n 2007-08-17  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/32112"}, {"sha": "5f7e718d32830f15668260b1113b772c06deeb61", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 92, "deletions": 71, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=44fd0e80635189f48f24654cb1e9620c39d5314b", "patch": "@@ -2099,6 +2099,20 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n       return;\n     }\n \n+  /* Shift the old and new bindings around so we're comparing class and\n+     enumeration names to each other.  */\n+  if (oldval && DECL_IMPLICIT_TYPEDEF_P (oldval))\n+    {\n+      oldtype = oldval;\n+      oldval = NULL_TREE;\n+    }\n+\n+  if (decls.value && DECL_IMPLICIT_TYPEDEF_P (decls.value))\n+    {\n+      decls.type = decls.value;\n+      decls.value = NULL_TREE;\n+    }\n+\n   /* It is impossible to overload a built-in function; any explicit\n      declaration eliminates the built-in declaration.  So, if OLDVAL\n      is a built-in, then we can just pretend it isn't there.  */\n@@ -2108,87 +2122,91 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n       && !DECL_HIDDEN_FRIEND_P (oldval))\n     oldval = NULL_TREE;\n \n-  /* Check for using functions.  */\n-  if (decls.value && is_overloaded_fn (decls.value))\n+  if (decls.value)\n     {\n-      tree tmp, tmp1;\n-\n-      if (oldval && !is_overloaded_fn (oldval))\n-\t{\n-\t  if (!DECL_IMPLICIT_TYPEDEF_P (oldval))\n-\t    error (\"%qD is already declared in this scope\", name);\n-\t  oldval = NULL_TREE;\n-\t}\n-\n-      *newval = oldval;\n-      for (tmp = decls.value; tmp; tmp = OVL_NEXT (tmp))\n+      /* Check for using functions.  */\n+      if (is_overloaded_fn (decls.value))\n \t{\n-\t  tree new_fn = OVL_CURRENT (tmp);\n+\t  tree tmp, tmp1;\n \n-\t  /* [namespace.udecl]\n+\t  if (oldval && !is_overloaded_fn (oldval))\n+\t    {\n+\t      error (\"%qD is already declared in this scope\", name);\n+\t      oldval = NULL_TREE;\n+\t    }\n \n-\t     If a function declaration in namespace scope or block\n-\t     scope has the same name and the same parameter types as a\n-\t     function introduced by a using declaration the program is\n-\t     ill-formed.  */\n-\t  for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n+\t  *newval = oldval;\n+\t  for (tmp = decls.value; tmp; tmp = OVL_NEXT (tmp))\n \t    {\n-\t      tree old_fn = OVL_CURRENT (tmp1);\n-\n-\t      if (new_fn == old_fn)\n-\t\t/* The function already exists in the current namespace.  */\n-\t\tbreak;\n-\t      else if (OVL_USED (tmp1))\n-\t\tcontinue; /* this is a using decl */\n-\t      else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n-\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n+\t      tree new_fn = OVL_CURRENT (tmp);\n+\n+\t      /* [namespace.udecl]\n+\n+\t\t If a function declaration in namespace scope or block\n+\t\t scope has the same name and the same parameter types as a\n+\t\t function introduced by a using declaration the program is\n+\t\t ill-formed.  */\n+\t      for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n \t\t{\n-\t\t  gcc_assert (!DECL_ANTICIPATED (old_fn)\n-\t\t\t      || DECL_HIDDEN_FRIEND_P (old_fn));\n+\t\t  tree old_fn = OVL_CURRENT (tmp1);\n \n-\t\t  /* There was already a non-using declaration in\n-\t\t     this scope with the same parameter types. If both\n-\t\t     are the same extern \"C\" functions, that's ok.  */\n-\t\t  if (decls_match (new_fn, old_fn))\n+\t\t  if (new_fn == old_fn)\n+\t\t    /* The function already exists in the current namespace.  */\n \t\t    break;\n-\t\t  else\n+\t\t  else if (OVL_USED (tmp1))\n+\t\t    continue; /* this is a using decl */\n+\t\t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n+\t\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n \t\t    {\n-\t\t      error (\"%qD is already declared in this scope\", name);\n-\t\t      break;\n+\t\t      gcc_assert (!DECL_ANTICIPATED (old_fn)\n+\t\t\t\t  || DECL_HIDDEN_FRIEND_P (old_fn));\n+\n+\t\t      /* There was already a non-using declaration in\n+\t\t\t this scope with the same parameter types. If both\n+\t\t\t are the same extern \"C\" functions, that's ok.  */\n+\t\t      if (decls_match (new_fn, old_fn))\n+\t\t\tbreak;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  error (\"%qD is already declared in this scope\", name);\n+\t\t\t  break;\n+\t\t\t}\n \t\t    }\n \t\t}\n-\t    }\n-\n-\t  /* If we broke out of the loop, there's no reason to add\n-\t     this function to the using declarations for this\n-\t     scope.  */\n-\t  if (tmp1)\n-\t    continue;\n \n-\t  /* If we are adding to an existing OVERLOAD, then we no\n-\t     longer know the type of the set of functions.  */\n-\t  if (*newval && TREE_CODE (*newval) == OVERLOAD)\n-\t    TREE_TYPE (*newval) = unknown_type_node;\n-\t  /* Add this new function to the set.  */\n-\t  *newval = build_overload (OVL_CURRENT (tmp), *newval);\n-\t  /* If there is only one function, then we use its type.  (A\n-\t     using-declaration naming a single function can be used in\n-\t     contexts where overload resolution cannot be\n-\t     performed.)  */\n-\t  if (TREE_CODE (*newval) != OVERLOAD)\n-\t    {\n-\t      *newval = ovl_cons (*newval, NULL_TREE);\n-\t      TREE_TYPE (*newval) = TREE_TYPE (OVL_CURRENT (tmp));\n+\t      /* If we broke out of the loop, there's no reason to add\n+\t\t this function to the using declarations for this\n+\t\t scope.  */\n+\t      if (tmp1)\n+\t\tcontinue;\n+\n+\t      /* If we are adding to an existing OVERLOAD, then we no\n+\t\t longer know the type of the set of functions.  */\n+\t      if (*newval && TREE_CODE (*newval) == OVERLOAD)\n+\t\tTREE_TYPE (*newval) = unknown_type_node;\n+\t      /* Add this new function to the set.  */\n+\t      *newval = build_overload (OVL_CURRENT (tmp), *newval);\n+\t      /* If there is only one function, then we use its type.  (A\n+\t\t using-declaration naming a single function can be used in\n+\t\t contexts where overload resolution cannot be\n+\t\t performed.)  */\n+\t      if (TREE_CODE (*newval) != OVERLOAD)\n+\t\t{\n+\t\t  *newval = ovl_cons (*newval, NULL_TREE);\n+\t\t  TREE_TYPE (*newval) = TREE_TYPE (OVL_CURRENT (tmp));\n+\t\t}\n+\t      OVL_USED (*newval) = 1;\n \t    }\n-\t  OVL_USED (*newval) = 1;\n+\t}\n+      else\n+\t{\n+\t  *newval = decls.value;\n+\t  if (oldval && !decls_match (*newval, oldval))\n+\t    error (\"%qD is already declared in this scope\", name);\n \t}\n     }\n   else\n-    {\n-      *newval = decls.value;\n-      if (oldval && !decls_match (*newval, oldval))\n-\terror (\"%qD is already declared in this scope\", name);\n-    }\n+    *newval = oldval;\n \n   if (decls.type && TREE_CODE (decls.type) == TREE_LIST)\n     {\n@@ -2198,13 +2216,16 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n   else\n     {\n       *newtype = decls.type;\n-      if (oldtype && *newtype && !same_type_p (oldtype, *newtype))\n-\t{\n-\t  error (\"using declaration %qD introduced ambiguous type %qT\",\n-\t\t name, oldtype);\n-\t  return;\n-\t}\n+      if (oldtype && *newtype && !decls_match (oldtype, *newtype))\n+\terror (\"%qD is already declared in this scope\", name);\n     }\n+\n+    /* If *newval is empty, shift any class or enumeration name down.  */\n+    if (!*newval)\n+      {\n+\t*newval = *newtype;\n+\t*newtype = NULL_TREE;\n+      }\n }\n \n /* Process a using-declaration at function scope.  */"}, {"sha": "2a637d5f372b66eb6815cd6d5a926b879b200e6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44fd0e80635189f48f24654cb1e9620c39d5314b", "patch": "@@ -1,3 +1,10 @@\n+2007-08-17  Ollie Wild  <aaw@google.com>\n+\n+\tPR c++/31749\n+\t* g++.dg/lookup/builtin3.C: New test.\n+\t* g++.dg/lookup/builtin4.C: New test.\n+\t* g++.dg/lookup/using19.C: New test.\n+\n 2007-08-17  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/32190"}, {"sha": "3a29d878313e2712760cae8ee7dc2cd894355111", "filename": "gcc/testsuite/g++.dg/lookup/builtin3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fbuiltin3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fbuiltin3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fbuiltin3.C?ref=44fd0e80635189f48f24654cb1e9620c39d5314b", "patch": "@@ -0,0 +1,15 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n+// { dg-do compile }\n+\n+// PR 31749: ICE with redeclaration of builtin\n+\n+namespace std\n+{\n+  union abort;\n+}\n+\n+void abort();\n+\n+using std::abort;"}, {"sha": "b1785dcc7fbef9bbe99b94b6e41410eefdb83d51", "filename": "gcc/testsuite/g++.dg/lookup/builtin4.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fbuiltin4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fbuiltin4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fbuiltin4.C?ref=44fd0e80635189f48f24654cb1e9620c39d5314b", "patch": "@@ -0,0 +1,15 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n+// { dg-do compile }\n+\n+// PR 31749: ICE with redeclaration of builtin\n+\n+namespace std\n+{\n+  union abort;\n+}\n+\n+union abort;\n+\n+using std::abort; // { dg-error \"\" }"}, {"sha": "973998bc02195d40b8a2adc0caa28a1fe35a85f5", "filename": "gcc/testsuite/g++.dg/lookup/using19.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd0e80635189f48f24654cb1e9620c39d5314b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing19.C?ref=44fd0e80635189f48f24654cb1e9620c39d5314b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+\n+// C++ Standard, 7.3.3, clause 10:\n+// \"Since a using-declaration is a declaration, the restrictions on\n+// declarations of the same name in the same declarative region (3.3) also\n+// apply to using-declarations.\"\n+\n+namespace M\n+{\n+  union A;\n+  void B();\n+}\n+\n+void A();\n+union B;\n+\n+using M::A;\n+using M::B;"}]}