{"sha": "8a39029d19e1f7ec50a7203d53137940f447314e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzOTAyOWQxOWUxZjdlYzUwYTcyMDNkNTMxMzc5NDBmNDQ3MzE0ZQ==", "commit": {"author": {"name": "Thiemo Seufer", "email": "ths@networkno.de", "date": "2005-12-07T14:56:38Z"}, "committer": {"name": "Matthias Klose", "email": "doko@gcc.gnu.org", "date": "2005-12-07T14:56:38Z"}, "message": "ffitarget.h: Remove obsolete sgidefs.h include.\n\n2005-12-07  Thiemo Seufer  <ths@networkno.de>\n\n\t* src/mips/ffitarget.h: Remove obsolete sgidefs.h include. Add\n\tmissing parentheses.\n\t* src/mips/o32.S (ffi_call_O32): Code formatting. Define\n\tand use A3_OFF, FP_OFF, RA_OFF. Micro-optimizations.\n\t(ffi_closure_O32): Likewise, but with newly defined A3_OFF2,\n\tA2_OFF2, A1_OFF2, A0_OFF2, RA_OFF2, FP_OFF2, S0_OFF2, GP_OFF2,\n\tV1_OFF2, V0_OFF2, FA_1_1_OFF2, FA_1_0_OFF2, FA_0_1_OFF2,\n\tFA_0_0_OFF2.\n\t* src/mips/ffi.c (ffi_prep_args): Code formatting. Fix\n\tendianness bugs.\n\t(ffi_prep_closure): Improve trampoline instruction scheduling.\n\t(ffi_closure_mips_inner_O32): Fix endianness bugs.\n\nFrom-SVN: r108165", "tree": {"sha": "e996b1f82107188b5821be52d44fd449b3f12f84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e996b1f82107188b5821be52d44fd449b3f12f84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a39029d19e1f7ec50a7203d53137940f447314e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a39029d19e1f7ec50a7203d53137940f447314e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a39029d19e1f7ec50a7203d53137940f447314e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a39029d19e1f7ec50a7203d53137940f447314e/comments", "author": null, "committer": null, "parents": [{"sha": "7f416ffb2875d45370783e94ccab44403d44a1c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f416ffb2875d45370783e94ccab44403d44a1c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f416ffb2875d45370783e94ccab44403d44a1c4"}], "stats": {"total": 351, "additions": 195, "deletions": 156}, "files": [{"sha": "307e04b54efba2bfebd0a7462b1b94469f772d9b", "filename": "libffi/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=8a39029d19e1f7ec50a7203d53137940f447314e", "patch": "@@ -1,3 +1,18 @@\n+2005-12-07  Thiemo Seufer  <ths@networkno.de>\n+\n+\t* src/mips/ffitarget.h: Remove obsolete sgidefs.h include. Add\n+\tmissing parentheses.\n+\t* src/mips/o32.S (ffi_call_O32): Code formatting. Define\n+\tand use A3_OFF, FP_OFF, RA_OFF. Micro-optimizations.\n+\t(ffi_closure_O32): Likewise, but with newly defined A3_OFF2,\n+\tA2_OFF2, A1_OFF2, A0_OFF2, RA_OFF2, FP_OFF2, S0_OFF2, GP_OFF2,\n+\tV1_OFF2, V0_OFF2, FA_1_1_OFF2, FA_1_0_OFF2, FA_0_1_OFF2,\n+\tFA_0_0_OFF2.\n+\t* src/mips/ffi.c (ffi_prep_args): Code formatting. Fix\n+\tendianness bugs.\n+\t(ffi_prep_closure): Improve trampoline instruction scheduling.\n+\t(ffi_closure_mips_inner_O32): Fix endianness bugs.\n+\n 2005-12-03  Alan Modra  <amodra@bigpond.net.au>\n \n \t* src/powerpc/ffi.c: Formatting."}, {"sha": "73bc952187d0e72374f913ce5fd6721c9606a620", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 116, "deletions": 93, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=8a39029d19e1f7ec50a7203d53137940f447314e", "patch": "@@ -50,17 +50,17 @@ static void ffi_prep_args(char *stack,\n \t\t\t  int bytes,\n \t\t\t  int flags)\n {\n-  register int i;\n-  register void **p_argv;\n-  register char *argp;\n-  register ffi_type **p_arg;\n+  int i;\n+  void **p_argv;\n+  char *argp;\n+  ffi_type **p_arg;\n \n #if _MIPS_SIM == _ABIN32\n   /* If more than 8 double words are used, the remainder go\n      on the stack. We reorder stuff on the stack here to \n      support this easily. */\n-  if (bytes > 8 * FFI_SIZEOF_ARG)\n-    argp = &stack[bytes - (8 * FFI_SIZEOF_ARG)];\n+  if (bytes > 8 * sizeof(ffi_arg))\n+    argp = &stack[bytes - (8 * sizeof(ffi_arg))];\n   else\n     argp = stack;\n #else\n@@ -85,102 +85,93 @@ static void ffi_prep_args(char *stack,\n   for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n     {\n       size_t z;\n-      unsigned short a;\n+      unsigned int a;\n \n-      /* Align if necessary */\n+      /* Align if necessary.  */\n       a = (*p_arg)->alignment;\n-      if (a < FFI_SIZEOF_ARG)\n-        a = FFI_SIZEOF_ARG;\n+      if (a < sizeof(ffi_arg))\n+        a = sizeof(ffi_arg);\n       \n-      if ((a - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, a);\n-\tFIX_ARGP;\n-      }\n+      if ((a - 1) & (unsigned int) argp)\n+\t{\n+\t  argp = (char *) ALIGN(argp, a);\n+\t  FIX_ARGP;\n+\t}\n \n-#if _MIPS_SIM == _ABIO32\n-#define OFFSET 0\n-#else\n-#define OFFSET sizeof(int)\n-#endif      \n+      z = (*p_arg)->size;\n+      if (z <= sizeof(ffi_arg))\n+\t{\n+\t  z = sizeof(ffi_arg);\n \n-\t  z = (*p_arg)->size;\n-\t  if (z < sizeof(ffi_arg))\n+\t  switch ((*p_arg)->type)\n \t    {\n-\t      z = sizeof(ffi_arg);\n+\t      case FFI_TYPE_SINT8:\n+\t\t*(ffi_arg *)argp = *(SINT8 *)(* p_argv);\n+\t\tbreak;\n \n-\t      switch ((*p_arg)->type)\n-\t\t{\n-\t\tcase FFI_TYPE_SINT8:\n-\t\t  *(SINT32 *) &argp[OFFSET] = (SINT32)*(SINT8 *)(* p_argv);\n-\t\t  break;\n-\t\t  \n-\t\tcase FFI_TYPE_UINT8:\n-\t\t  *(UINT32 *) &argp[OFFSET] = (UINT32)*(UINT8 *)(* p_argv);\n-\t\t  break;\n+\t      case FFI_TYPE_UINT8:\n+\t\t*(ffi_arg *)argp = *(UINT8 *)(* p_argv);\n+\t\tbreak;\n \t\t  \n-\t\tcase FFI_TYPE_SINT16:\n-\t\t  *(SINT32 *) &argp[OFFSET] = (SINT32)*(SINT16 *)(* p_argv);\n-\t\t  break;\n+\t      case FFI_TYPE_SINT16:\n+\t\t*(ffi_arg *)argp = *(SINT16 *)(* p_argv);\n+\t\tbreak;\n \t\t  \n-\t\tcase FFI_TYPE_UINT16:\n-\t\t  *(UINT32 *) &argp[OFFSET] = (UINT32)*(UINT16 *)(* p_argv);\n-\t\t  break;\n+\t      case FFI_TYPE_UINT16:\n+\t\t*(ffi_arg *)argp = *(UINT16 *)(* p_argv);\n+\t\tbreak;\n \t\t  \n-\t\tcase FFI_TYPE_SINT32:\n-\t\t  *(SINT32 *) &argp[OFFSET] = (SINT32)*(SINT32 *)(* p_argv);\n-\t\t  break;\n+\t      case FFI_TYPE_SINT32:\n+\t\t*(ffi_arg *)argp = *(SINT32 *)(* p_argv);\n+\t\tbreak;\n \t\t  \n-\t\tcase FFI_TYPE_UINT32:\n-\t\tcase FFI_TYPE_POINTER:\n-\t\t  *(UINT32 *) &argp[OFFSET] = (UINT32)*(UINT32 *)(* p_argv);\n-\t\t  break;\n-\n-\t\t  /* This can only happen with 64bit slots */\n-\t\tcase FFI_TYPE_FLOAT:\n-\t\t  *(float *) argp = *(float *)(* p_argv);\n-\t\t  break;\n-\n-\t\t  /* Handle small structures */\n-\t\tcase FFI_TYPE_STRUCT:\n-\t\t  memcpy(argp, *p_argv, (*p_arg)->size);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  FFI_ASSERT(0);\n-\t\t}\n+\t      case FFI_TYPE_UINT32:\n+\t      case FFI_TYPE_POINTER:\n+\t\t*(ffi_arg *)argp = *(UINT32 *)(* p_argv);\n+\t\tbreak;\n+\n+\t      /* This can only happen with 64bit slots.  */\n+\t      case FFI_TYPE_FLOAT:\n+\t\t*(float *) argp = *(float *)(* p_argv);\n+\t\tbreak;\n+\n+\t      /* Handle small structures.  */\n+\t      case FFI_TYPE_STRUCT:\n+\t      default:\n+\t\tmemcpy(argp, *p_argv, (*p_arg)->size);\n+\t\tbreak;\n \t    }\n-\t  else\n-\t    {\n-#if _MIPS_SIM == _ABIO32\t      \n-\t      memcpy(argp, *p_argv, z);\n+\t}\n+      else\n+\t{\n+#if _MIPS_SIM == _ABIO32\n+\t  memcpy(argp, *p_argv, z);\n #else\n+\t  {\n+\t    unsigned end = (unsigned) argp+z;\n+\t    unsigned cap = (unsigned) stack+bytes;\n+\n+\t    /* Check if the data will fit within the register space.\n+\t       Handle it if it doesn't.  */\n+\n+\t    if (end <= cap)\n+\t      memcpy(argp, *p_argv, z);\n+\t    else\n \t      {\n-\t\tunsigned end = (unsigned) argp+z;\n-\t\tunsigned cap = (unsigned) stack+bytes;\n-\n-\t\t/* Check if the data will fit within the register\n-\t\t   space. Handle it if it doesn't. */\n-\n-\t\tif (end <= cap)\n-\t\t  memcpy(argp, *p_argv, z);\n-\t\telse\n-\t\t  {\n-\t\t    unsigned portion = end - cap;\n-\n-\t\t    memcpy(argp, *p_argv, portion);\n-\t\t    argp = stack;\n-\t\t    memcpy(argp, \n-\t\t\t   (void*)((unsigned)(*p_argv)+portion), z - portion);\n-\t\t  }\n+\t\tunsigned portion = end - cap;\n+\n+\t\tmemcpy(argp, *p_argv, portion);\n+\t\targp = stack;\n+\t\tmemcpy(argp,\n+\t\t       (void*)((unsigned)(*p_argv)+portion), z - portion);\n \t      }\n+\t  }\n #endif\n-\t    }\n-\t  p_argv++;\n-\t  argp += z;\n-\t  FIX_ARGP;\n+      }\n+      p_argv++;\n+      argp += z;\n+      FIX_ARGP;\n     }\n-  \n-  return;\n }\n \n #if _MIPS_SIM == _ABIN32\n@@ -524,8 +515,8 @@ ffi_prep_closure (ffi_closure *closure,\n #endif /* FFI_MIPS_O32 */\n \n   tramp[0] = 0x3c190000 | (fn >> 16);     /* lui  $25,high(fn) */\n-  tramp[1] = 0x3c080000 | (ctx >> 16);    /* lui  $8,high(ctx) */\n-  tramp[2] = 0x37390000 | (fn & 0xffff);  /* ori  $25,low(fn)  */\n+  tramp[1] = 0x37390000 | (fn & 0xffff);  /* ori  $25,low(fn)  */\n+  tramp[2] = 0x3c080000 | (ctx >> 16);    /* lui  $8,high(ctx) */\n   tramp[3] = 0x03200008;                  /* jr   $25          */\n   tramp[4] = 0x35080000 | (ctx & 0xffff); /* ori  $8,low(ctx)  */\n \n@@ -558,16 +549,18 @@ ffi_prep_closure (ffi_closure *closure,\n  */\n int\n ffi_closure_mips_inner_O32 (ffi_closure *closure,\n-\t\t\t    void *rvalue, unsigned long *ar,\n+\t\t\t    void *rvalue, ffi_arg *ar,\n \t\t\t    double *fpr)\n {\n   ffi_cif *cif;\n-  void **avalue;\n+  void **avaluep;\n+  ffi_arg *avalue;\n   ffi_type **arg_types;\n   int i, avn, argn, seen_int;\n \n   cif = closure->cif;\n-  avalue = alloca (cif->nargs * sizeof (void *));\n+  avalue = alloca (cif->nargs * sizeof (ffi_arg));\n+  avaluep = alloca (cif->nargs * sizeof (ffi_arg));\n \n   seen_int = (cif->abi == FFI_O32_SOFT_FLOAT);\n   argn = 0;\n@@ -588,21 +581,51 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n \t  (arg_types[i]->type == FFI_TYPE_FLOAT ||\n \t   arg_types[i]->type == FFI_TYPE_DOUBLE))\n \t{\n-\t  avalue[i] = ((char *) &fpr[i]);\n+#ifdef __MIPSEB__\n+\t  if (arg_types[i]->type == FFI_TYPE_FLOAT)\n+\t    avaluep[i] = ((char *) &fpr[i]) + sizeof (float);\n+\t  else\n+#endif\n+\t    avaluep[i] = (char *) &fpr[i];\n \t}\n       else\n \t{\n \t  if (arg_types[i]->alignment == 8 && (argn & 0x1))\n \t    argn++;\n-\t  avalue[i] = ((char *) &ar[argn]);\n+\t  switch (arg_types[i]->type)\n+\t    {\n+\t      case FFI_TYPE_SINT8:\n+\t\tavaluep[i] = &avalue[i];\n+\t\t*(SINT8 *) &avalue[i] = (SINT8) ar[argn];\n+\t\tbreak;\n+\n+\t      case FFI_TYPE_UINT8:\n+\t\tavaluep[i] = &avalue[i];\n+\t\t*(UINT8 *) &avalue[i] = (UINT8) ar[argn];\n+\t\tbreak;\n+\t\t  \n+\t      case FFI_TYPE_SINT16:\n+\t\tavaluep[i] = &avalue[i];\n+\t\t*(SINT16 *) &avalue[i] = (SINT16) ar[argn];\n+\t\tbreak;\n+\t\t  \n+\t      case FFI_TYPE_UINT16:\n+\t\tavaluep[i] = &avalue[i];\n+\t\t*(UINT16 *) &avalue[i] = (UINT16) ar[argn];\n+\t\tbreak;\n+\n+\t      default:\n+\t\tavaluep[i] = (char *) &ar[argn];\n+\t\tbreak;\n+\t    }\n \t  seen_int = 1;\n \t}\n       argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n       i++;\n     }\n \n   /* Invoke the closure. */\n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+  (closure->fun) (cif, rvalue, avaluep, closure->user_data);\n \n   if (cif->abi == FFI_O32_SOFT_FLOAT)\n     {"}, {"sha": "e610745698f6c77768649a81aa6048cc314ddfff", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=8a39029d19e1f7ec50a7203d53137940f447314e", "patch": "@@ -26,17 +26,13 @@\n #ifndef LIBFFI_TARGET_H\n #define LIBFFI_TARGET_H\n \n-#ifndef LIBFFI_ASM\n-#include <sgidefs.h>\n-#endif\n-\n #if !defined(_MIPS_SIM)\n -- something is very wrong --\n #else\n #  if (_MIPS_SIM==_ABIN32 && defined(_ABIN32)) || (_MIPS_SIM==_ABI64 && defined(_ABI64))\n #    define FFI_MIPS_N32\n #  else\n-#    if _MIPS_SIM==_ABIO32 && defined(_ABIO32)\n+#    if (_MIPS_SIM==_ABIO32 && defined(_ABIO32))\n #      define FFI_MIPS_O32\n #    else\n -- this is an unsupported platform --"}, {"sha": "63f3d14635787d1b570516867fd43ab4e4c6be16", "filename": "libffi/src/mips/o32.S", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2Fsrc%2Fmips%2Fo32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a39029d19e1f7ec50a7203d53137940f447314e/libffi%2Fsrc%2Fmips%2Fo32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fo32.S?ref=8a39029d19e1f7ec50a7203d53137940f447314e", "patch": "@@ -35,7 +35,10 @@\n #define bytes\t a2\n #define flags\t a3\n \t\t\n-#define SIZEOF_FRAME\t( 4 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG )\n+#define SIZEOF_FRAME\t(4 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG)\n+#define A3_OFF\t\t(SIZEOF_FRAME + 3 * FFI_SIZEOF_ARG)\n+#define FP_OFF\t\t(SIZEOF_FRAME - 2 * FFI_SIZEOF_ARG)\n+#define RA_OFF\t\t(SIZEOF_FRAME - 1 * FFI_SIZEOF_ARG)\n \n \t.abicalls\n \t.text\n@@ -45,48 +48,42 @@\n ffi_call_O32:\t\n $LFB0:\n \t# Prologue\n-\tSUBU\t$sp, SIZEOF_FRAME\t\t\t# Frame size\n+\tSUBU\t$sp, SIZEOF_FRAME\t# Frame size\n $LCFI0:\n-\tREG_S\t$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp)\t# Save frame pointer\n+\tREG_S\t$fp, FP_OFF($sp)\t# Save frame pointer\n $LCFI1:\n-\tREG_S\tra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)\t# Save return address\n+\tREG_S\tra, RA_OFF($sp)\t\t# Save return address\n $LCFI2:\n \tmove\t$fp, $sp\n \n $LCFI3:\n-\tmove\tt9, callback\t# callback function pointer\n-\tREG_S\tflags, SIZEOF_FRAME + 3*FFI_SIZEOF_ARG($fp) # flags\n+\tmove\tt9, callback\t\t# callback function pointer\n+\tREG_S\tflags, A3_OFF($fp)\t# flags\n \n \t# Allocate at least 4 words in the argstack\n-\tmove\tv0, bytes\n-\tbge\tbytes, 4 * FFI_SIZEOF_ARG, bigger\t\n \tLI\tv0, 4 * FFI_SIZEOF_ARG\n-\tb\tsixteen\n+\tblt\tbytes, v0, sixteen\n \n-bigger:\t\n-\tADDU\tt0, v0, 2 * FFI_SIZEOF_ARG -1\t# make sure it is aligned \n-\tand\tv0, t0, -2 * FFI_SIZEOF_ARG\t\t# to an 8 byte boundry\n+\tADDU\tv0, bytes, 7\t# make sure it is aligned \n+\tand\tv0, -8\t\t# to an 8 byte boundry\n \n sixteen:\n-\tSUBU\t$sp, $sp, v0\t# move the stack pointer to reflect the\n+\tSUBU\t$sp, v0\t\t# move the stack pointer to reflect the\n \t\t\t\t# arg space\n \n \tADDU\ta0, $sp, 4 * FFI_SIZEOF_ARG\n-\tADDU\ta3, $fp, SIZEOF_FRAME + 3*FFI_SIZEOF_ARG\n \n \tjalr\tt9\n \t\n-\tREG_L\tt0, SIZEOF_FRAME + 3*FFI_SIZEOF_ARG($fp)  # load the flags word\n-\tadd\tt2, t0, 0\t\t\t   # and copy it into t2\n-\n+\tREG_L\tt0, A3_OFF($fp)\t\t# load the flags word\n+\tSRL\tt2, t0, 4\t\t# shift our arg info\n \tand     t0, ((1<<4)-1)          # mask out the return type\n-\tSRL\tt2, 4\t\t\t# shift our arg info\n \t\t\n-\tADDU\t$sp, $sp, 4 * FFI_SIZEOF_ARG\t# adjust $sp to new args\n+\tADDU\t$sp, 4 * FFI_SIZEOF_ARG\t\t# adjust $sp to new args\n \n \tbnez\tt0, pass_d\t\t\t# make it quick for int\n-\tREG_L\ta0, 0*FFI_SIZEOF_ARG($sp)\t\t# just go ahead and load the\n-\tREG_L\ta1, 1*FFI_SIZEOF_ARG($sp)\t\t# four regs.\n+\tREG_L\ta0, 0*FFI_SIZEOF_ARG($sp)\t# just go ahead and load the\n+\tREG_L\ta1, 1*FFI_SIZEOF_ARG($sp)\t# four regs.\n \tREG_L\ta2, 2*FFI_SIZEOF_ARG($sp)\n \tREG_L\ta3, 3*FFI_SIZEOF_ARG($sp)\n \tb\tcall_it\n@@ -176,9 +173,9 @@ noretval:\n \t# Epilogue\n epilogue:\t\n \tmove\t$sp, $fp\t\n-\tREG_L\t$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp) # Restore frame pointer\n-\tREG_L\tra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)  # Restore return address\n-\tADDU\t$sp, SIZEOF_FRAME\t\t      # Fix stack pointer\n+\tREG_L\t$fp, FP_OFF($sp)\t# Restore frame pointer\n+\tREG_L\tra, RA_OFF($sp)\t\t# Restore return address\n+\tADDU\t$sp, SIZEOF_FRAME\t# Fix stack pointer\n \tj\tra\n \n $LFE0:\n@@ -209,7 +206,21 @@ $LFE0:\n \t 0 - Called function a0 save our sp, fp point here\n \t */\n \t\n-#define SIZEOF_FRAME2\t( 14 * FFI_SIZEOF_ARG )\n+#define SIZEOF_FRAME2\t(14 * FFI_SIZEOF_ARG)\n+#define A3_OFF2\t\t(SIZEOF_FRAME2 + 3 * FFI_SIZEOF_ARG)\n+#define A2_OFF2\t\t(SIZEOF_FRAME2 + 2 * FFI_SIZEOF_ARG)\n+#define A1_OFF2\t\t(SIZEOF_FRAME2 + 1 * FFI_SIZEOF_ARG)\n+#define A0_OFF2\t\t(SIZEOF_FRAME2 + 0 * FFI_SIZEOF_ARG)\n+#define RA_OFF2\t\t(SIZEOF_FRAME2 - 1 * FFI_SIZEOF_ARG)\n+#define FP_OFF2\t\t(SIZEOF_FRAME2 - 2 * FFI_SIZEOF_ARG)\n+#define S0_OFF2\t\t(SIZEOF_FRAME2 - 3 * FFI_SIZEOF_ARG)\n+#define GP_OFF2\t\t(SIZEOF_FRAME2 - 4 * FFI_SIZEOF_ARG)\n+#define V1_OFF2\t\t(SIZEOF_FRAME2 - 5 * FFI_SIZEOF_ARG)\n+#define V0_OFF2\t\t(SIZEOF_FRAME2 - 6 * FFI_SIZEOF_ARG)\n+#define FA_1_1_OFF2\t(SIZEOF_FRAME2 - 7 * FFI_SIZEOF_ARG)\n+#define FA_1_0_OFF2\t(SIZEOF_FRAME2 - 8 * FFI_SIZEOF_ARG)\n+#define FA_0_1_OFF2\t(SIZEOF_FRAME2 - 9 * FFI_SIZEOF_ARG)\n+#define FA_0_0_OFF2\t(SIZEOF_FRAME2 - 10 * FFI_SIZEOF_ARG)\n \n \t.text\n \t.align\t2\n@@ -218,45 +229,45 @@ $LFE0:\n ffi_closure_O32:\n $LFB1:\n \t# Prologue\n-\t.frame\t$fp, SIZEOF_FRAME2, $31\n+\t.frame\t$fp, SIZEOF_FRAME2, ra\n \t.set\tnoreorder\n-\t.cpload\t$25\n+\t.cpload\tt9\n \t.set\treorder\n \tSUBU\t$sp, SIZEOF_FRAME2\n-\t.cprestore SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG\n+\t.cprestore GP_OFF2\n $LCFI4:\n-\tREG_S\t$16, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\t # Save s0\n-\tREG_S\t$fp, SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\t # Save frame pointer\n-\tREG_S\tra, SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\t # Save return address\n+\tREG_S\t$16, S0_OFF2($sp)\t # Save s0\n+\tREG_S\t$fp, FP_OFF2($sp)\t # Save frame pointer\n+\tREG_S\tra, RA_OFF2($sp)\t # Save return address\n $LCFI6:\n \tmove\t$fp, $sp\n \n $LCFI7:\n \t# Store all possible argument registers. If there are more than\n-\t# four arguments, then they should be stored above where we put $7.\n-\tREG_S\t$4, SIZEOF_FRAME2 + 0*FFI_SIZEOF_ARG($fp)\n-\tREG_S\t$5, SIZEOF_FRAME2 + 1*FFI_SIZEOF_ARG($fp)\n-\tREG_S\t$6, SIZEOF_FRAME2 + 2*FFI_SIZEOF_ARG($fp)\n-\tREG_S\t$7, SIZEOF_FRAME2 + 3*FFI_SIZEOF_ARG($fp)\n+\t# four arguments, then they are stored above where we put a3.\n+\tREG_S\ta0, A0_OFF2($fp)\n+\tREG_S\ta1, A1_OFF2($fp)\n+\tREG_S\ta2, A2_OFF2($fp)\n+\tREG_S\ta3, A3_OFF2($fp)\n \n-\t# Load ABI enum to $16\n+\t# Load ABI enum to s0\n \tREG_L\t$16, 20($8)\t# cif pointer follows tramp.\n \tREG_L\t$16, 0($16)\t# abi is first member.\n \n \tli\t$13, 1\t\t# FFI_O32\n \tbne\t$16, $13, 1f\t# Skip fp save if FFI_O32_SOFT_FLOAT\n \t\n \t# Store all possible float/double registers.\n-\ts.d\t$f12, SIZEOF_FRAME2 - 10*FFI_SIZEOF_ARG($fp)\n-\ts.d\t$f14, SIZEOF_FRAME2 -  8*FFI_SIZEOF_ARG($fp)\n+\ts.d\t$f12, FA_0_0_OFF2($fp)\n+\ts.d\t$f14, FA_1_0_OFF2($fp)\n 1:\t\n \t# Call ffi_closure_mips_inner_O32 to do the work.\n-\tla\t$25, ffi_closure_mips_inner_O32\n-\tmove\t$4, $8\t # Pointer to the ffi_closure\n-\taddu\t$5, $fp, SIZEOF_FRAME2 -  6*FFI_SIZEOF_ARG\n-\taddu\t$6, $fp, SIZEOF_FRAME2 +  0*FFI_SIZEOF_ARG\n-\taddu\t$7, $fp, SIZEOF_FRAME2 - 10*FFI_SIZEOF_ARG\n-\tjalr\t$31, $25\n+\tla\tt9, ffi_closure_mips_inner_O32\n+\tmove\ta0, $8\t # Pointer to the ffi_closure\n+\taddu\ta1, $fp, V0_OFF2\n+\taddu\ta2, $fp, A0_OFF2\n+\taddu\ta3, $fp, FA_0_0_OFF2\n+\tjalr\tt9\n \n \t# Load the return value into the appropriate register.\n \tmove\t$8, $2\n@@ -267,28 +278,22 @@ $LCFI7:\n \tbne\t$16, $13, 1f\t# Skip fp restore if FFI_O32_SOFT_FLOAT\n \n \tli\t$9, FFI_TYPE_FLOAT\n-\tl.s\t$f0, SIZEOF_FRAME2 - 6*FFI_SIZEOF_ARG($fp)\n+\tl.s\t$f0, V0_OFF2($fp)\n \tbeq\t$8, $9, closure_done\n \n \tli\t$9, FFI_TYPE_DOUBLE\n-\tl.d\t$f0, SIZEOF_FRAME2 - 6*FFI_SIZEOF_ARG($fp)\n+\tl.d\t$f0, V0_OFF2($fp)\n \tbeq\t$8, $9, closure_done\n 1:\t\n-\tli\t$9, FFI_TYPE_SINT64\n-\tREG_L\t$3, SIZEOF_FRAME2 - 5*FFI_SIZEOF_ARG($fp)\n-\tbeq\t$8, $9, integer\n-\tli\t$9, FFI_TYPE_UINT64\n-\tbeq\t$8, $9, integer\n-\n-integer:\n-\tREG_L\t$2, SIZEOF_FRAME2 - 6*FFI_SIZEOF_ARG($fp)\n+\tREG_L\t$3, V1_OFF2($fp)\n+\tREG_L\t$2, V0_OFF2($fp)\n \n closure_done:\n \t# Epilogue\n \tmove\t$sp, $fp\n-\tREG_L\t$16, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\t # Restore s0\n-\tREG_L\t$fp, SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\t # Restore frame pointer\n-\tREG_L\tra,  SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\t # Restore return address\n+\tREG_L\t$16, S0_OFF2($sp)\t # Restore s0\n+\tREG_L\t$fp, FP_OFF2($sp)\t # Restore frame pointer\n+\tREG_L\tra,  RA_OFF2($sp)\t # Restore return address\n \tADDU\t$sp, SIZEOF_FRAME2\n \tj\tra\n $LFE1:"}]}