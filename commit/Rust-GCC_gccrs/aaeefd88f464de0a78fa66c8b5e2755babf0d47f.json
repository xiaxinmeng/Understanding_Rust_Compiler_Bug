{"sha": "aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFlZWZkODhmNDY0ZGUwYTc4ZmE2NmM4YjVlMjc1NWJhYmYwZDQ3Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:47:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:47:03Z"}, "message": "Split mask checking out of vectorizable_mask_load_store\n\nThis patch splits the mask argument checking out of\nvectorizable_mask_load_store, so that a later patch can use it in both\nvectorizable_load and vectorizable_store.  It also adds dump messages\nfor false returns.  This is mostly useful for the TYPE_VECTOR_SUBPARTS\ncheck, which can fail if pattern recognition didn't convert the mask\nproperly.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-stmts.c (vect_check_load_store_mask): New function,\n\tsplit out from...\n\t(vectorizable_mask_load_store): ...here.\n\nFrom-SVN: r256212", "tree": {"sha": "8617ce6e9f567dd6cf5ae93bbda7f1e578c38f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8617ce6e9f567dd6cf5ae93bbda7f1e578c38f24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaeefd88f464de0a78fa66c8b5e2755babf0d47f/comments", "author": null, "committer": null, "parents": [{"sha": "9ce4345afba69ff793ff4df992fc57ec29a92d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce4345afba69ff793ff4df992fc57ec29a92d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce4345afba69ff793ff4df992fc57ec29a92d93"}], "stats": {"total": 95, "additions": 77, "deletions": 18}, "files": [{"sha": "86320f716e49c0b39a672e262494a82650d2aa26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeefd88f464de0a78fa66c8b5e2755babf0d47f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeefd88f464de0a78fa66c8b5e2755babf0d47f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-stmts.c (vect_check_load_store_mask): New function,\n+\tsplit out from...\n+\t(vectorizable_mask_load_store): ...here.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vectorizer.h (vec_load_store_type): Moved from tree-vec-stmts.c"}, {"sha": "c493eb54b4b211487de2e8576ccaca08f7dbbe26", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeefd88f464de0a78fa66c8b5e2755babf0d47f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeefd88f464de0a78fa66c8b5e2755babf0d47f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "patch": "@@ -2024,6 +2024,74 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp,\n   return true;\n }\n \n+/* Return true if boolean argument MASK is suitable for vectorizing\n+   conditional load or store STMT.  When returning true, store the\n+   type of the vectorized mask in *MASK_VECTYPE_OUT.  */\n+\n+static bool\n+vect_check_load_store_mask (gimple *stmt, tree mask, tree *mask_vectype_out)\n+{\n+  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (mask)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"mask argument is not a boolean.\\n\");\n+      return false;\n+    }\n+\n+  if (TREE_CODE (mask) != SSA_NAME)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"mask argument is not an SSA name.\\n\");\n+      return false;\n+    }\n+\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  gimple *def_stmt;\n+  enum vect_def_type dt;\n+  tree mask_vectype;\n+  if (!vect_is_simple_use (mask, stmt_info->vinfo, &def_stmt, &dt,\n+\t\t\t   &mask_vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"mask use not simple.\\n\");\n+      return false;\n+    }\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  if (!mask_vectype)\n+    mask_vectype = get_mask_type_for_scalar_type (TREE_TYPE (vectype));\n+\n+  if (!mask_vectype || !VECTOR_BOOLEAN_TYPE_P (mask_vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"could not find an appropriate vector mask type.\\n\");\n+      return false;\n+    }\n+\n+  if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_vectype),\n+\t\tTYPE_VECTOR_SUBPARTS (vectype)))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"vector mask type \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, mask_vectype);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION,\n+\t\t       \" does not match vector data type \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, vectype);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \".\\n\");\n+\t}\n+      return false;\n+    }\n+\n+  *mask_vectype_out = mask_vectype;\n+  return true;\n+}\n+\n /* Function vectorizable_mask_load_store.\n \n    Check if STMT performs a conditional load or store that can be vectorized.\n@@ -2066,11 +2134,6 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   ncopies = vect_get_num_copies (loop_vinfo, vectype);\n   gcc_assert (ncopies >= 1);\n \n-  mask = gimple_call_arg (stmt, 2);\n-\n-  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (mask)))\n-    return false;\n-\n   /* FORNOW. This restriction should be relaxed.  */\n   if (nested_in_vect_loop && ncopies > 1)\n     {\n@@ -2090,21 +2153,11 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  elem_type = TREE_TYPE (vectype);\n-\n-  if (TREE_CODE (mask) != SSA_NAME)\n-    return false;\n-\n-  if (!vect_is_simple_use (mask, loop_vinfo, &def_stmt, &dt, &mask_vectype))\n+  mask = gimple_call_arg (stmt, 2);\n+  if (!vect_check_load_store_mask (stmt, mask, &mask_vectype))\n     return false;\n \n-  if (!mask_vectype)\n-    mask_vectype = get_mask_type_for_scalar_type (TREE_TYPE (vectype));\n-\n-  if (!mask_vectype || !VECTOR_BOOLEAN_TYPE_P (mask_vectype)\n-      || maybe_ne (TYPE_VECTOR_SUBPARTS (mask_vectype),\n-\t\t   TYPE_VECTOR_SUBPARTS (vectype)))\n-    return false;\n+  elem_type = TREE_TYPE (vectype);\n \n   if (gimple_call_internal_fn (stmt) == IFN_MASK_STORE)\n     {"}]}