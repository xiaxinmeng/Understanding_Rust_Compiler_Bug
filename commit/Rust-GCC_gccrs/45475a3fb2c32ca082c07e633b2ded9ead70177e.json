{"sha": "45475a3fb2c32ca082c07e633b2ded9ead70177e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU0NzVhM2ZiMmMzMmNhMDgyYzA3ZTYzM2IyZGVkOWVhZDcwMTc3ZQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-28T17:03:03Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-28T17:03:03Z"}, "message": "dojump.c (do_compare_rtx_and_jump): Try swapping the condition for floating point modes.\n\n2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n\n        * dojump.c (do_compare_rtx_and_jump): Try swapping the\n        condition for floating point modes.\n        * expmed.c (emit_store_flag_1): Move here a bigger part\n        of emit_store_flag.\n        (emit_store_flag): Try swapping the condition for floating point\n        modes.\n        * optabs.c (emit_cmp_and_jump_insns): Cope with constant op0 better.\n\nFrom-SVN: r149033", "tree": {"sha": "6cb46c8b1432e5b2682ebbe1c480966ef11ded79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cb46c8b1432e5b2682ebbe1c480966ef11ded79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45475a3fb2c32ca082c07e633b2ded9ead70177e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45475a3fb2c32ca082c07e633b2ded9ead70177e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45475a3fb2c32ca082c07e633b2ded9ead70177e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45475a3fb2c32ca082c07e633b2ded9ead70177e/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "495499daead6ed7050db2af715fabd4f472595cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495499daead6ed7050db2af715fabd4f472595cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/495499daead6ed7050db2af715fabd4f472595cd"}], "stats": {"total": 150, "additions": 88, "deletions": 62}, "files": [{"sha": "70763970f2a6400307e7175e8fd219c62cb99a51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45475a3fb2c32ca082c07e633b2ded9ead70177e", "patch": "@@ -1,3 +1,13 @@\n+2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * dojump.c (do_compare_rtx_and_jump): Try swapping the\n+        condition for floating point modes.\n+        * expmed.c (emit_store_flag_1): Move here a bigger part\n+        of emit_store_flag.\n+        (emit_store_flag): Try swapping the condition for floating point\n+        modes.\n+        * optabs.c (emit_cmp_and_jump_insns): Cope with constant op0 better.\n+\n 2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n \n         * expr.c (expand_expr_real_1): Just use do_store_flag."}, {"sha": "3685ff513d00880d220e31732830e5e87a479708", "filename": "gcc/dojump.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=45475a3fb2c32ca082c07e633b2ded9ead70177e", "patch": "@@ -920,16 +920,27 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n     {\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && ! can_compare_p (code, mode, ccp_jump)\n+\t  && can_compare_p (swap_condition (code), mode, ccp_jump))\n+\t{\n+\t  rtx tmp;\n+\t  code = swap_condition (code);\n+\t  tmp = op0;\n+\t  op0 = op1;\n+\t  op1 = tmp;\n+\t}\n+\n+      else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t       && ! can_compare_p (code, mode, ccp_jump)\n \n-\t  /* Never split ORDERED and UNORDERED.  These must be implemented.  */\n-\t  && (code != ORDERED && code != UNORDERED)\n+\t       /* Never split ORDERED and UNORDERED.  These must be implemented.  */\n+\t       && (code != ORDERED && code != UNORDERED)\n \n-          /* Split a floating-point comparison if we can jump on other\n-\t     conditions...  */\n-\t  && (have_insn_for (COMPARE, mode)\n+               /* Split a floating-point comparison if we can jump on other\n+\t          conditions...  */\n+\t       && (have_insn_for (COMPARE, mode)\n \n-\t      /* ... or if there is no libcall for it.  */\n-\t      || code_to_optab[code] == NULL))\n+\t           /* ... or if there is no libcall for it.  */\n+\t           || code_to_optab[code] == NULL))\n         {\n \t  enum rtx_code first_code;\n \t  bool and_them = split_comparison (code, mode, &first_code, &code);"}, {"sha": "841f94b4c9271c6400fc9d842fe60f83c8db15c1", "filename": "gcc/expmed.c", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=45475a3fb2c32ca082c07e633b2ded9ead70177e", "patch": "@@ -5115,11 +5115,40 @@ expand_and (enum machine_mode mode, rtx op0, rtx op1, rtx target)\n \n /* Helper function for emit_store_flag.  */\n static rtx\n-emit_store_flag_1 (rtx target, rtx subtarget, enum machine_mode mode,\n-\t\t   int normalizep)\n+emit_store_flag_1 (rtx target, enum insn_code icode, enum rtx_code code,\n+\t\t   enum machine_mode mode, enum machine_mode compare_mode,\n+\t\t   int unsignedp, rtx x, rtx y, int normalizep)\n {\n-  rtx op0;\n+  rtx op0, last, comparison, subtarget, pattern;\n   enum machine_mode target_mode;\n+  enum machine_mode result_mode = insn_data[(int) icode].operand[0].mode;\n+\n+  last = get_last_insn ();\n+  x = prepare_operand (icode, x, 2, mode, compare_mode, unsignedp);\n+  y = prepare_operand (icode, y, 3, mode, compare_mode, unsignedp);\n+  comparison = gen_rtx_fmt_ee (code, result_mode, x, y);\n+  if (!x || !y\n+      || !insn_data[icode].operand[2].predicate\n+\t  (x, insn_data[icode].operand[2].mode)\n+      || !insn_data[icode].operand[3].predicate\n+\t  (y, insn_data[icode].operand[3].mode)\n+      || !insn_data[icode].operand[1].predicate (comparison, VOIDmode))\n+    {\n+      delete_insns_since (last);\n+      return NULL_RTX;\n+    }\n+\n+  if (!target\n+      || optimize\n+      || !(insn_data[(int) icode].operand[0].predicate (target, result_mode)))\n+    subtarget = gen_reg_rtx (result_mode);\n+  else\n+    subtarget = target;\n+\n+  pattern = GEN_FCN (icode) (subtarget, comparison, x, y);\n+  if (!pattern)\n+    return NULL_RTX;\n+  emit_insn (pattern);\n \n   if (!target)\n     target = gen_reg_rtx (GET_MODE (subtarget));\n@@ -5133,15 +5162,15 @@ emit_store_flag_1 (rtx target, rtx subtarget, enum machine_mode mode,\n      If STORE_FLAG_VALUE does not have the sign bit set when\n      interpreted in MODE, we can do this conversion as unsigned, which\n      is usually more efficient.  */\n-  if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n+  if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (result_mode))\n     {\n       convert_move (target, subtarget,\n-\t\t    (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t\t    (GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT)\n \t\t    && 0 == (STORE_FLAG_VALUE\n \t\t\t     & ((HOST_WIDE_INT) 1\n-\t\t\t\t<< (GET_MODE_BITSIZE (mode) -1))));\n+\t\t\t\t<< (GET_MODE_BITSIZE (result_mode) -1))));\n       op0 = target;\n-      mode = target_mode;\n+      result_mode = target_mode;\n     }\n   else\n     op0 = subtarget;\n@@ -5158,28 +5187,28 @@ emit_store_flag_1 (rtx target, rtx subtarget, enum machine_mode mode,\n   /* STORE_FLAG_VALUE might be the most negative number, so write\n      the comparison this way to avoid a compiler-time warning.  */\n   else if (- normalizep == STORE_FLAG_VALUE)\n-    op0 = expand_unop (mode, neg_optab, op0, subtarget, 0);\n+    op0 = expand_unop (result_mode, neg_optab, op0, subtarget, 0);\n \n   /* We don't want to use STORE_FLAG_VALUE < 0 below since this makes\n      it hard to use a value of just the sign bit due to ANSI integer\n      constant typing rules.  */\n-  else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+  else if (GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n \t   && (STORE_FLAG_VALUE\n-\t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))))\n-    op0 = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\tsize_int (GET_MODE_BITSIZE (mode) - 1), subtarget,\n+\t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (result_mode) - 1))))\n+    op0 = expand_shift (RSHIFT_EXPR, result_mode, op0,\n+\t\t\tsize_int (GET_MODE_BITSIZE (result_mode) - 1), subtarget,\n \t\t\tnormalizep == 1);\n   else\n     {\n       gcc_assert (STORE_FLAG_VALUE & 1);\n \n-      op0 = expand_and (mode, op0, const1_rtx, subtarget);\n+      op0 = expand_and (result_mode, op0, const1_rtx, subtarget);\n       if (normalizep == -1)\n-\top0 = expand_unop (mode, neg_optab, op0, op0, 0);\n+\top0 = expand_unop (result_mode, neg_optab, op0, op0, 0);\n     }\n \n   /* If we were converting to a smaller mode, do the conversion now.  */\n-  if (target_mode != mode)\n+  if (target_mode != result_mode)\n     {\n       convert_move (target, op0, 0);\n       return target;\n@@ -5213,12 +5242,13 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   enum machine_mode target_mode = target ? GET_MODE (target) : VOIDmode;\n   enum mode_class mclass;\n   enum rtx_code rcode;\n+  enum rtx_code scode;\n   rtx tem, trueval;\n   rtx last;\n-  rtx pattern, comparison;\n \n   if (unsignedp)\n     code = unsigned_condition (code);\n+  scode = swap_condition (code);\n \n   /* If one operand is constant, make it the second one.  Only do this\n      if the other operand is not constant as well.  */\n@@ -5359,44 +5389,19 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n      icode = optab_handler (cstore_optab, optab_mode)->insn_code;\n      if (icode != CODE_FOR_nothing)\n \t{\n-\t  rtx x, y;\n-\t  enum machine_mode result_mode\n-\t    = insn_data[(int) icode].operand[0].mode;\n-\n \t  do_pending_stack_adjust ();\n-\t  last = get_last_insn ();\n+\t  tem = emit_store_flag_1 (target, icode, code, mode, compare_mode,\n+\t\t\t\t   unsignedp, op0, op1, normalizep);\n+\t  if (tem)\n+\t    return tem;\n \n-          x = prepare_operand (icode, op0, 2, mode, compare_mode, unsignedp);\n-          y = prepare_operand (icode, op1, 3, mode, compare_mode, unsignedp);\n-\t  comparison = gen_rtx_fmt_ee (code, result_mode, x, y);\n-\t  if (!x || !y\n-\t      || !insn_data[icode].operand[2].predicate\n-\t\t  (x, insn_data[icode].operand[2].mode)\n-\t      || !insn_data[icode].operand[3].predicate\n-\t\t  (y, insn_data[icode].operand[3].mode)\n-\t      || !insn_data[icode].operand[1].predicate (comparison, VOIDmode))\n+\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t    {\n-\t      delete_insns_since (last);\n-\t      continue;\n-\t    }\n-\n-\t  if (!target\n-\t      || optimize\n-\t      || !(insn_data[(int) icode].operand[0].predicate (target, result_mode)))\n-\t    subtarget = gen_reg_rtx (result_mode);\n-\t  else\n-\t    subtarget = target;\n-\n-\t  pattern = GEN_FCN (icode) (subtarget, comparison, x, y);\n-\n-\t  if (pattern)\n-\t    {\n-\t      emit_insn (pattern);\n-\t      return emit_store_flag_1 (target, subtarget, result_mode,\n-\t\t\t\t\tnormalizep);\n+\t      tem = emit_store_flag_1 (target, icode, scode, mode, compare_mode,\n+\t\t\t\t       unsignedp, op1, op0, normalizep);\n+\t      if (tem)\n+\t        return tem;\n \t    }\n-\n-\t  delete_insns_since (last);\n \t  break;\n \t}\n     }"}, {"sha": "16eb4dd3dbbad37a170c23b7fd644a61a28f7edd", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45475a3fb2c32ca082c07e633b2ded9ead70177e/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=45475a3fb2c32ca082c07e633b2ded9ead70177e", "patch": "@@ -4280,18 +4280,18 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n   rtx test;\n \n   /* Swap operands and condition to ensure canonical RTL.  */\n-  if (swap_commutative_operands_p (x, y))\n+  if (swap_commutative_operands_p (x, y)\n+      && can_compare_p (swap_condition (comparison), mode, ccp_jump))\n     {\n       op0 = y, op1 = x;\n       comparison = swap_condition (comparison);\n     }\n \n-#ifdef HAVE_cc0\n-  /* If OP0 is still a constant, then both X and Y must be constants.\n-     Force X into a register to create canonical RTL.  */\n+  /* If OP0 is still a constant, then both X and Y must be constants\n+     or the opposite comparison is not supported.  Force X into a register\n+     to create canonical RTL.  */\n   if (CONSTANT_P (op0))\n     op0 = force_reg (mode, op0);\n-#endif\n \n   if (unsignedp)\n     comparison = unsigned_condition (comparison);"}]}