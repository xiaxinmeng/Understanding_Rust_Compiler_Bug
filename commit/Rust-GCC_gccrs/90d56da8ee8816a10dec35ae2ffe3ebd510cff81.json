{"sha": "90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBkNTZkYThlZTg4MTZhMTBkZWMzNWFlMmZmZTNlYmQ1MTBjZmY4MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-15T18:34:18Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-15T18:34:18Z"}, "message": "(duplicate_decls, pushdecl, grokdeclarator):\n\n(store_parm_decls, combine_parm_decls, finish_function):\nUse TYPE_MAIN_VARIANT when comparing against specific non-void types.\n\nFrom-SVN: r1590", "tree": {"sha": "a628a32c71624a51edf9a3d9cce8228fffbbc9d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a628a32c71624a51edf9a3d9cce8228fffbbc9d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d56da8ee8816a10dec35ae2ffe3ebd510cff81/comments", "author": null, "committer": null, "parents": [{"sha": "60654f77caa149c67892783132ff4f024fa4847c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60654f77caa149c67892783132ff4f024fa4847c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60654f77caa149c67892783132ff4f024fa4847c"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "bbcec2ea5c42811273ad09fdd887e74b51acb56b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d56da8ee8816a10dec35ae2ffe3ebd510cff81/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d56da8ee8816a10dec35ae2ffe3ebd510cff81/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "patch": "@@ -1311,7 +1311,7 @@ duplicate_decls (newdecl, olddecl)\n \t\t  break;\n \t\t}\n \n-\t      if (type == float_type_node\n+\t      if (TYPE_MAIN_VARIANT (type) == float_type_node\n \t\t  || (TREE_CODE (type) == INTEGER_TYPE\n \t\t      && (TYPE_PRECISION (type)\n \t\t\t  < TYPE_PRECISION (integer_type_node))))\n@@ -1361,8 +1361,8 @@ duplicate_decls (newdecl, olddecl)\n \t\t  /* If -traditional, allow `unsigned int' instead of `int'\n \t\t     in the prototype.  */\n \t\t  && (! (flag_traditional\n-\t\t\t && TREE_VALUE (parm) == integer_type_node\n-\t\t\t && TREE_VALUE (type) == unsigned_type_node)))\n+\t\t\t && TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == integer_type_node\n+\t\t\t && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == unsigned_type_node)))\n \t\t{\n \t\t  errmsg = \"prototype for `%s' follows and argument %d\";\n \t\t  break;\n@@ -1786,7 +1786,8 @@ pushdecl (x)\n \t  if (IDENTIFIER_IMPLICIT_DECL (name) != 0\n \t      /* If this real decl matches the implicit, don't complain.  */\n \t      && ! (TREE_CODE (x) == FUNCTION_DECL\n-\t\t    && TREE_TYPE (TREE_TYPE (x)) == integer_type_node))\n+\t\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (x)))\n+\t\t\t== integer_type_node)))\n \t    pedwarn (\"`%s' was previously implicitly declared to return `int'\",\n \t\t     IDENTIFIER_POINTER (name));\n \n@@ -3523,7 +3524,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n   /* Long double is a special combination.  */\n \n-  if ((specbits & 1 << (int) RID_LONG) && type == double_type_node)\n+  if ((specbits & 1 << (int) RID_LONG)\n+      && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n       specbits &= ~ (1 << (int) RID_LONG);\n       type = long_double_type_node;\n@@ -3844,7 +3846,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n #ifndef TRADITIONAL_RETURN_FLOAT\n \t  /* Traditionally, declaring return type float means double.  */\n \n-\t  if (flag_traditional && type == float_type_node)\n+\t  if (flag_traditional && TYPE_MAIN_VARIANT (type) == float_type_node)\n \t    type = double_type_node;\n #endif /* TRADITIONAL_RETURN_FLOAT */\n \n@@ -4007,6 +4009,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n     if (decl_context == PARM)\n       {\n \ttree type_as_written = type;\n+\ttree main_type;\n \n \t/* A parameter declared as an array of T is really a pointer to T.\n \t   One declared as a function is really a pointer to a function.  */\n@@ -4040,15 +4043,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t   When there is a prototype, this is overridden later.  */\n \n \tDECL_ARG_TYPE (decl) = type;\n-\tif (type == float_type_node)\n+\tmain_type = TYPE_MAIN_VARIANT (type);\n+\tif (main_type == float_type_node)\n \t  DECL_ARG_TYPE (decl) = double_type_node;\n \t/* Don't use TYPE_PREISION to decide whether to promote,\n \t   because we should convert short if it's the same size as int,\n \t   but we should not convert long if it's the same size as int.  */\n-\telse if (type == char_type_node || type == signed_char_type_node\n-\t\t || type == unsigned_char_type_node\n-\t\t || type == short_integer_type_node\n-\t\t || type == short_unsigned_type_node)\n+\telse if (main_type == char_type_node\n+\t\t || main_type == signed_char_type_node\n+\t\t || main_type == unsigned_char_type_node\n+\t\t || main_type == short_integer_type_node\n+\t\t || main_type == short_unsigned_type_node)\n \t  {\n \t    if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)\n \t\t&& TREE_UNSIGNED (type))\n@@ -5398,7 +5403,7 @@ store_parm_decls ()\n \n \t  /* Traditionally, a parm declared float is actually a double.  */\n \t  if (found && flag_traditional\n-\t      && TREE_TYPE (found) == float_type_node)\n+\t      && TYPE_MAIN_VARIANT (TREE_TYPE (found)) == float_type_node)\n \t    TREE_TYPE (found) = double_type_node;\n \n \t  /* If no declaration found, default to int.  */\n@@ -5522,8 +5527,8 @@ store_parm_decls ()\n \t\t  /* If -traditional, allow `int' argument to match\n \t\t     `unsigned' prototype.  */\n \t\t  else if (! (flag_traditional\n-\t\t\t      && TREE_TYPE (parm) == integer_type_node\n-\t\t\t      && TREE_VALUE (type) == unsigned_type_node))\n+\t\t\t      && TYPE_MAIN_VARIANT (TREE_TYPE (parm)) == integer_type_node\n+\t\t\t      && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == unsigned_type_node))\n \t\t    error (\"argument `%s' doesn't match prototype\",\n \t\t\t   IDENTIFIER_POINTER (DECL_NAME (parm)));\n \t\t}\n@@ -5678,7 +5683,7 @@ combine_parm_decls (specparms, parmlist, void_at_end)\n \n       /* Traditionally, a parm declared float is actually a double.  */\n       if (found && flag_traditional\n-\t  && TREE_TYPE (found) == float_type_node)\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (found)) == float_type_node)\n \tTREE_TYPE (found) = double_type_node;\n \n       /* If no declaration found, default to int.  */\n@@ -5793,7 +5798,8 @@ finish_function (nested)\n #ifdef DEFAULT_MAIN_RETURN\n   if (! strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), \"main\"))\n     {\n-      if (TREE_TYPE (TREE_TYPE (fndecl)) != integer_type_node)\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (fndecl)))\n+\t  != integer_type_node)\n \twarning_with_decl (fndecl, \"return type of `%s' is not `int'\");\n       else\n \t{"}]}