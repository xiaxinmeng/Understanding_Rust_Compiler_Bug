{"sha": "157236dbd621644b3cec50b6cf38811959f3e78c", "node_id": "C_kwDOANBUbNoAKDE1NzIzNmRiZDYyMTY0NGIzY2VjNTBiNmNmMzg4MTE5NTlmM2U3OGM", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2022-08-25T10:11:40Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-08T18:29:12Z"}, "message": "libstdc++: Clear padding bits in atomic compare_exchange\n\nThis change implements P0528 which requires that padding bits not\nparticipate in atomic compare exchange operations. All arguments to the\ngeneric template are 'sanitized' by the __builtin_clear_padding intrinsic\nbefore they are used in comparisons. This requires that any stores\nalso sanitize the incoming value.\n\nCo-authored-by: Jakub Jelinek <jakub@redhat.com>\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\n\nSigned-off-by: Thomas Rodgers <trodgers@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/atomic_base.h (__atomic_impl::__maybe_has_padding):\n\tNew function.\n\t(__atomic_impl::clear_padding): Likewise.\n\t(__atomic_impl::__compare_exchange): Likewise.\n\t(__atomic_impl::compare_exchange_weak): Delegate to\n\t__compare_exchange.\n\t(__atomic_impl::compare_exchange_strong): Likewise.\n\t* include/std/atomic (atomic<T>::atomic(T)): Clear padding when\n\tpossible in a constexpr function.\n\t(atomic::store): Clear padding.\n\t(atomic::exchange): Likewise.\n\t(atomic::compare_exchange_weak): Use __compare_exchange.\n\t(atomic::compare_exchange_strong): Likewise.\n\t* testsuite/29_atomics/atomic/compare_exchange_padding.cc: New\n\ttest.\n\t* testsuite/29_atomics/atomic_ref/compare_exchange_padding.cc:\n\tNew test.", "tree": {"sha": "af9e5ef2a4382cb1af7d6083b3945936e60d18f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af9e5ef2a4382cb1af7d6083b3945936e60d18f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/157236dbd621644b3cec50b6cf38811959f3e78c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157236dbd621644b3cec50b6cf38811959f3e78c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157236dbd621644b3cec50b6cf38811959f3e78c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157236dbd621644b3cec50b6cf38811959f3e78c/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3883dc77b1426984c0edea6081f57ed2305c9f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3883dc77b1426984c0edea6081f57ed2305c9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3883dc77b1426984c0edea6081f57ed2305c9f2"}], "stats": {"total": 240, "additions": 188, "deletions": 52}, "files": [{"sha": "29315547aab5e5ba02023fa6013030fe03f35190", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 76, "deletions": 21, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=157236dbd621644b3cec50b6cf38811959f3e78c", "patch": "@@ -33,6 +33,7 @@\n #pragma GCC system_header\n \n #include <bits/c++config.h>\n+#include <new> // For placement new\n #include <stdint.h>\n #include <bits/atomic_lockfree_defines.h>\n #include <bits/move.h>\n@@ -952,19 +953,76 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }\n     };\n \n-  /// @endcond\n-\n-#if __cplusplus > 201703L\n-  /// @cond undocumented\n-\n-  // Implementation details of atomic_ref and atomic<floating-point>.\n   namespace __atomic_impl\n   {\n+    // Implementation details of atomic padding handling\n+\n+    template<typename _Tp>\n+      constexpr bool\n+      __maybe_has_padding()\n+      {\n+#if ! __has_builtin(__builtin_clear_padding)\n+\treturn false;\n+#elif __has_builtin(__has_unique_object_representations)\n+\treturn !__has_unique_object_representations(_Tp)\n+\t  && !is_same<_Tp, float>::value && !is_same<_Tp, double>::value;\n+#else\n+\treturn true;\n+#endif\n+      }\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE _Tp*\n+      __clear_padding(_Tp& __val) noexcept\n+      {\n+\tauto* __ptr = std::__addressof(__val);\n+#if __has_builtin(__builtin_clear_padding)\n+\tif _GLIBCXX17_CONSTEXPR (__atomic_impl::__maybe_has_padding<_Tp>())\n+\t  __builtin_clear_padding(__ptr);\n+#endif\n+\treturn __ptr;\n+      }\n+\n     // Remove volatile and create a non-deduced context for value arguments.\n     template<typename _Tp>\n-      using _Val = remove_volatile_t<_Tp>;\n+      using _Val = typename remove_volatile<_Tp>::type;\n+\n+    template<typename _Tp>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      __compare_exchange(_Tp& __val, _Val<_Tp>& __e, _Val<_Tp>& __i,\n+\t\t\t bool __weak, memory_order __s, memory_order __f) noexcept\n+      {\n+\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));\n+\n+\tusing _Vp = _Val<_Tp>;\n+\n+\tif _GLIBCXX17_CONSTEXPR (__atomic_impl::__maybe_has_padding<_Vp>())\n+\t  {\n+\t    // We must not modify __e on success, so cannot clear its padding.\n+\t    // Copy into a buffer and clear that, then copy back on failure.\n+\t    alignas(_Vp) unsigned char __buf[sizeof(_Vp)];\n+\t    _Vp* __exp = ::new((void*)__buf) _Vp(__e);\n+\t    __atomic_impl::__clear_padding(*__exp);\n+\t    if (__atomic_compare_exchange(std::__addressof(__val), __exp,\n+\t\t\t\t\t  __atomic_impl::__clear_padding(__i),\n+\t\t\t\t\t  __weak, int(__s), int(__f)))\n+\t      return true;\n+\t    __builtin_memcpy(std::__addressof(__e), __exp, sizeof(_Vp));\n+\t    return false;\n+\t  }\n+\telse\n+\t  return __atomic_compare_exchange(std::__addressof(__val),\n+\t\t\t\t\t   std::__addressof(__e),\n+\t\t\t\t\t   std::__addressof(__i),\n+\t\t\t\t\t   __weak, int(__s), int(__f));\n+      }\n+  } // namespace __atomic_impl\n \n-    // As above, but for difference_type arguments.\n+#if __cplusplus > 201703L\n+  // Implementation details of atomic_ref and atomic<floating-point>.\n+  namespace __atomic_impl\n+  {\n+    // Like _Val<T> above, but for difference_type arguments.\n     template<typename _Tp>\n       using _Diff = __conditional_t<is_pointer_v<_Tp>, ptrdiff_t, _Val<_Tp>>;\n \n@@ -979,7 +1037,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     template<typename _Tp>\n       _GLIBCXX_ALWAYS_INLINE void\n       store(_Tp* __ptr, _Val<_Tp> __t, memory_order __m) noexcept\n-      { __atomic_store(__ptr, std::__addressof(__t), int(__m)); }\n+      {\n+\t__atomic_store(__ptr, __atomic_impl::__clear_padding(__t), int(__m));\n+      }\n \n     template<typename _Tp>\n       _GLIBCXX_ALWAYS_INLINE _Val<_Tp>\n@@ -997,7 +1057,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n         alignas(_Tp) unsigned char __buf[sizeof(_Tp)];\n \tauto* __dest = reinterpret_cast<_Val<_Tp>*>(__buf);\n-\t__atomic_exchange(__ptr, std::__addressof(__desired), __dest, int(__m));\n+\t__atomic_exchange(__ptr, __atomic_impl::__clear_padding(__desired),\n+\t\t\t  __dest, int(__m));\n \treturn *__dest;\n       }\n \n@@ -1007,11 +1068,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t    _Val<_Tp> __desired, memory_order __success,\n \t\t\t    memory_order __failure) noexcept\n       {\n-\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));\n-\n-\treturn __atomic_compare_exchange(__ptr, std::__addressof(__expected),\n-\t\t\t\t\t std::__addressof(__desired), true,\n-\t\t\t\t\t int(__success), int(__failure));\n+\treturn __atomic_impl::__compare_exchange(*__ptr, __expected, __desired,\n+\t\t\t\t\t\t true, __success, __failure);\n       }\n \n     template<typename _Tp>\n@@ -1020,11 +1078,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t      _Val<_Tp> __desired, memory_order __success,\n \t\t\t      memory_order __failure) noexcept\n       {\n-\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));\n-\n-\treturn __atomic_compare_exchange(__ptr, std::__addressof(__expected),\n-\t\t\t\t\t std::__addressof(__desired), false,\n-\t\t\t\t\t int(__success), int(__failure));\n+\treturn __atomic_impl::__compare_exchange(*__ptr, __expected, __desired,\n+\t\t\t\t\t\t false, __success, __failure);\n       }\n \n #if __cpp_lib_atomic_wait\n@@ -1955,9 +2010,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Tp** _M_ptr;\n     };\n+#endif // C++2a\n \n   /// @endcond\n-#endif // C++2a\n \n   /// @} group atomics\n "}, {"sha": "b913960336d20866055b744c55603697ef85f65c", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=157236dbd621644b3cec50b6cf38811959f3e78c", "patch": "@@ -230,7 +230,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       atomic& operator=(const atomic&) = delete;\n       atomic& operator=(const atomic&) volatile = delete;\n \n-      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }\n+      constexpr atomic(_Tp __i) noexcept : _M_i(__i)\n+      {\n+#if __cplusplus >= 201402L && __has_builtin(__builtin_clear_padding)\n+\tif _GLIBCXX17_CONSTEXPR (__atomic_impl::__maybe_has_padding<_Tp>())\n+\t  __builtin_clear_padding(std::__addressof(_M_i));\n+#endif\n+      }\n \n       operator _Tp() const noexcept\n       { return load(); }\n@@ -270,13 +276,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       store(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept\n       {\n-\t__atomic_store(std::__addressof(_M_i), std::__addressof(__i), int(__m));\n+\t__atomic_store(std::__addressof(_M_i),\n+\t\t       __atomic_impl::__clear_padding(__i),\n+\t\t       int(__m));\n       }\n \n       void\n       store(_Tp __i, memory_order __m = memory_order_seq_cst) volatile noexcept\n       {\n-\t__atomic_store(std::__addressof(_M_i), std::__addressof(__i), int(__m));\n+\t__atomic_store(std::__addressof(_M_i),\n+\t\t       __atomic_impl::__clear_padding(__i),\n+\t\t       int(__m));\n       }\n \n       _Tp\n@@ -302,7 +312,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n         alignas(_Tp) unsigned char __buf[sizeof(_Tp)];\n \t_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);\n-\t__atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),\n+\t__atomic_exchange(std::__addressof(_M_i),\n+\t\t\t  __atomic_impl::__clear_padding(__i),\n \t\t\t  __ptr, int(__m));\n \treturn *__ptr;\n       }\n@@ -313,7 +324,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n         alignas(_Tp) unsigned char __buf[sizeof(_Tp)];\n \t_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);\n-\t__atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),\n+\t__atomic_exchange(std::__addressof(_M_i),\n+\t\t\t  __atomic_impl::__clear_padding(__i),\n \t\t\t  __ptr, int(__m));\n \treturn *__ptr;\n       }\n@@ -322,24 +334,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,\n \t\t\t    memory_order __f) noexcept\n       {\n-\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));\n-\n-\treturn __atomic_compare_exchange(std::__addressof(_M_i),\n-\t\t\t\t\t std::__addressof(__e),\n-\t\t\t\t\t std::__addressof(__i),\n-\t\t\t\t\t true, int(__s), int(__f));\n+\treturn __atomic_impl::__compare_exchange(_M_i, __e, __i, true,\n+\t\t\t\t\t\t __s, __f);\n       }\n \n       bool\n       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,\n \t\t\t    memory_order __f) volatile noexcept\n       {\n-\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));\n-\n-\treturn __atomic_compare_exchange(std::__addressof(_M_i),\n-\t\t\t\t\t std::__addressof(__e),\n-\t\t\t\t\t std::__addressof(__i),\n-\t\t\t\t\t true, int(__s), int(__f));\n+\treturn __atomic_impl::__compare_exchange(_M_i, __e, __i, true,\n+\t\t\t\t\t\t __s, __f);\n       }\n \n       bool\n@@ -358,24 +362,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,\n \t\t\t      memory_order __f) noexcept\n       {\n-\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));\n-\n-\treturn __atomic_compare_exchange(std::__addressof(_M_i),\n-\t\t\t\t\t std::__addressof(__e),\n-\t\t\t\t\t std::__addressof(__i),\n-\t\t\t\t\t false, int(__s), int(__f));\n+\treturn __atomic_impl::__compare_exchange(_M_i, __e, __i, false,\n+\t\t\t\t\t\t __s, __f);\n       }\n \n       bool\n       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,\n \t\t\t      memory_order __f) volatile noexcept\n       {\n-\t__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));\n-\n-\treturn __atomic_compare_exchange(std::__addressof(_M_i),\n-\t\t\t\t\t std::__addressof(__e),\n-\t\t\t\t\t std::__addressof(__i),\n-\t\t\t\t\t false, int(__s), int(__f));\n+\treturn __atomic_impl::__compare_exchange(_M_i, __e, __i, false,\n+\t\t\t\t\t\t __s, __f);\n       }\n \n       bool\n@@ -390,7 +386,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return compare_exchange_strong(__e, __i, __m,\n                                        __cmpexch_failure_order(__m)); }\n \n-#if __cpp_lib_atomic_wait \n+#if __cpp_lib_atomic_wait\n     void\n     wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept\n     {\n@@ -407,7 +403,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     notify_all() noexcept\n     { std::__atomic_notify_address(&_M_i, true); }\n-#endif // __cpp_lib_atomic_wait \n+#endif // __cpp_lib_atomic_wait\n \n     };\n #undef _GLIBCXX20_INIT"}, {"sha": "c4ab876db2acbcc887502cf10d94477503f97599", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/compare_exchange_padding.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcompare_exchange_padding.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcompare_exchange_padding.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcompare_exchange_padding.cc?ref=157236dbd621644b3cec50b6cf38811959f3e78c", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-add-options libatomic }\n+\n+#include <atomic>\n+\n+#include <testsuite_hooks.h>\n+\n+struct S { char c; short s; };\n+\n+void __attribute__((noinline,noipa))\n+fill_struct(S& s)\n+{ __builtin_memset(&s, 0xff, sizeof(S)); }\n+\n+bool\n+compare_struct(const S& a, const S& b)\n+{ return __builtin_memcmp(&a, &b, sizeof(S)) == 0; }\n+\n+int\n+main ()\n+{\n+  S s;\n+  fill_struct(s);\n+  s.c = 'a';\n+  s.s = 42;\n+\n+  std::atomic<S> as{ s };\n+  auto ts = as.load();\n+  VERIFY( !compare_struct(s, ts) ); // padding cleared on construction\n+  as.exchange(s);\n+  auto es = as.load();\n+  VERIFY( compare_struct(ts, es) ); // padding cleared on exchange\n+\n+  S n;\n+  fill_struct(n);\n+  n.c = 'b';\n+  n.s = 71;\n+  // padding cleared on compexchg\n+  VERIFY( as.compare_exchange_weak(s, n) );\n+  VERIFY( as.compare_exchange_strong(n, s) );\n+  return 0;\n+}"}, {"sha": "1b1a12dddda581a9353ed104ca28d0c56dc618bf", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/compare_exchange_padding.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fcompare_exchange_padding.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157236dbd621644b3cec50b6cf38811959f3e78c/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fcompare_exchange_padding.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fcompare_exchange_padding.cc?ref=157236dbd621644b3cec50b6cf38811959f3e78c", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-add-options libatomic }\n+\n+#include <atomic>\n+\n+#include <testsuite_hooks.h>\n+\n+struct S { char c; short s; };\n+\n+void __attribute__((noinline,noipa))\n+fill_struct(S& s)\n+{ __builtin_memset(&s, 0xff, sizeof(S)); }\n+\n+bool\n+compare_struct(const S& a, const S& b)\n+{ return __builtin_memcmp(&a, &b, sizeof(S)) == 0; }\n+\n+int\n+main ()\n+{\n+  S s;\n+  fill_struct(s);\n+  s.c = 'a';\n+  s.s = 42;\n+\n+  S ss{ s };\n+  std::atomic_ref<S> as{ s };\n+  auto ts = as.load();\n+  VERIFY( !compare_struct(ss, ts) ); // padding cleared on construction\n+  as.exchange(ss);\n+  auto es = as.load();\n+  VERIFY( compare_struct(ts, es) ); // padding cleared on exchange\n+\n+  S n;\n+  fill_struct(n);\n+  n.c = 'b';\n+  n.s = 71;\n+  // padding cleared on compexchg\n+  VERIFY( as.compare_exchange_weak(s, n) );\n+  VERIFY( as.compare_exchange_strong(n, s) );\n+  return 0;\n+}"}]}