{"sha": "00e641f13e16cc2e1402b17f43df934014a95cfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlNjQxZjEzZTE2Y2MyZTE0MDJiMTdmNDNkZjkzNDAxNGE5NWNmYg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2014-11-21T14:04:25Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2014-11-21T14:04:25Z"}, "message": "Forward-port from 2014-10-30 4_9-branch r216934 PR target/63633\n\ngcc/\n\tForward-port from 2014-10-30 4_9-branch r216934\n\tPR target/63633\n\t* config/avr/avr-protos.h (regmask): New inline function.\n\t(avr_fix_inputs, avr_emit3_fix_outputs): New protos.\n\t* config/avr/avr.c (avr_fix_operands, avr_move_fixed_operands)\n\t(avr_fix_inputs, avr_emit3_fix_outputs): New functions.\n\t* config/avr/avr-fixed.md (mulqq3_nomul, muluqq3_nomul)\n\t(mul<ALL2QA>3, mul<ALL4A>3, <usdiv><ALL1Q>3, <usdiv><ALL2QA>3)\n\t(<usdiv><ALL4A>3, round<ALL124QA>3): Fix input operands.\n\t* config/avr/avr-dimode.md (add<ALL8>3, sub<ALL8>3)\n\t(<ss_addsub><ALL8S>3, <us_addsub><ALL8U>3, cbranch<ALL8>4)\n\t(<di_shifts><ALL8>3, <any_extend>mulsidi3): Fix input operands.\n\t* config/avr/avr.md (mulqi3_call, mulhi3_call, mulsi3, mulpsi3)\n\t(mulu<QIHI>si3, muls<QIHI>si3, mulohisi3, <any_extend>mulhisi3)\n\t(usmulhisi3, <any_extend>mulhi3_highpart, mulsqipsi3)\n\t(fmul, fmuls, fmulsu): Fix operands.  Turn insn into expander as\n\tneeded.\n\ngcc/testsuite/\n\tForward-port from 2014-10-30 4_9-branch r216934\n\tPR target/63633\n\t* gcc.target/avr/torture/pr63633-ice-mult.c: New test.\n\nFrom-SVN: r217922", "tree": {"sha": "d409635e26b1bc8b6198fb7ae5658c346d46ee81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d409635e26b1bc8b6198fb7ae5658c346d46ee81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00e641f13e16cc2e1402b17f43df934014a95cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e641f13e16cc2e1402b17f43df934014a95cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00e641f13e16cc2e1402b17f43df934014a95cfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e641f13e16cc2e1402b17f43df934014a95cfb/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7697b16f45c592826e6a6a1a3ac2ca7f6db530bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7697b16f45c592826e6a6a1a3ac2ca7f6db530bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7697b16f45c592826e6a6a1a3ac2ca7f6db530bc"}], "stats": {"total": 323, "additions": 307, "deletions": 16}, "files": [{"sha": "56cd304582ab2b31e1bbabb65fba2d48440087de", "filename": "gcc/config/avr/avr-dimode.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr-dimode.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr-dimode.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-dimode.md?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -68,6 +68,7 @@\n   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n     emit_move_insn (acc_a, operands[1]);\n \n     if (DImode == <MODE>mode\n@@ -145,6 +146,7 @@\n   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n     emit_move_insn (acc_a, operands[1]);\n \n     if (const_operand (operands[2], GET_MODE (operands[2])))\n@@ -201,6 +203,7 @@\n   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n     emit_move_insn (acc_a, operands[1]);\n \n     if (const_operand (operands[2], GET_MODE (operands[2])))\n@@ -249,6 +252,7 @@\n   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n     emit_move_insn (acc_a, operands[1]);\n \n     if (const_operand (operands[2], GET_MODE (operands[2])))\n@@ -338,6 +342,7 @@\n   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n     emit_move_insn (acc_a, operands[1]);\n \n     if (s8_operand (operands[2], VOIDmode))\n@@ -424,6 +429,7 @@\n   {\n     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n \n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));\n     emit_move_insn (acc_a, operands[1]);\n     emit_move_insn (gen_rtx_REG (QImode, 16), operands[2]);\n     emit_insn (gen_<code_stdname><mode>3_insn ());\n@@ -457,6 +463,7 @@\n               (clobber (any_extend:SI (match_dup 1)))])]\n   \"avr_have_dimode\"\n   {\n+    avr_fix_inputs (operands, 1 << 2, regmask (SImode, 22));\n     emit_move_insn (gen_rtx_REG (SImode, 22), operands[1]);\n     emit_move_insn (gen_rtx_REG (SImode, 18), operands[2]);\n     emit_insn (gen_<extend_u>mulsidi3_insn());"}, {"sha": "6763f596e5fb02628c5e9ec5d2977fb68fbf70da", "filename": "gcc/config/avr/avr-fixed.md", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr-fixed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr-fixed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-fixed.md?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -231,7 +231,11 @@\n               (clobber (reg:HI 24))])\n    (set (match_operand:QQ 0 \"register_operand\" \"\")\n         (reg:QQ 23))]\n-  \"!AVR_HAVE_MUL\")\n+  \"!AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (QQmode, 24));\n+  })\n+\n \n (define_expand \"muluqq3_nomul\"\n   [(set (reg:UQQ 22)\n@@ -246,7 +250,10 @@\n               (clobber (reg:HI 22))])\n    (set (match_operand:UQQ 0 \"register_operand\" \"\")\n         (reg:UQQ 25))]\n-  \"!AVR_HAVE_MUL\")\n+  \"!AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (UQQmode, 22));\n+  })\n \n (define_insn \"*mulqq3.call\"\n   [(set (reg:QQ 23)\n@@ -274,7 +281,10 @@\n               (clobber (reg:HI 22))])\n    (set (match_operand:ALL2QA 0 \"register_operand\" \"\")\n         (reg:ALL2QA 24))]\n-  \"AVR_HAVE_MUL\")\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 18));\n+  })\n \n ;; \"*mulhq3.call\"  \"*muluhq3.call\"\n ;; \"*mulha3.call\"  \"*muluha3.call\"\n@@ -302,7 +312,10 @@\n                     (reg:ALL4A 20)))\n    (set (match_operand:ALL4A 0 \"register_operand\" \"\")\n         (reg:ALL4A 24))]\n-  \"AVR_HAVE_MUL\")\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 16));\n+  })\n \n ;; \"*mulsa3.call\" \"*mulusa3.call\"\n (define_insn \"*mul<mode>3.call\"\n@@ -330,7 +343,12 @@\n                                 (reg:ALL1Q 22)))\n               (clobber (reg:QI 25))])\n    (set (match_operand:ALL1Q 0 \"register_operand\" \"\")\n-        (reg:ALL1Q 24))])\n+        (reg:ALL1Q 24))]\n+  \"\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 25));\n+  })\n+\n \n ;; \"*divqq3.call\" \"*udivuqq3.call\"\n (define_insn \"*<code><mode>3.call\"\n@@ -356,7 +374,11 @@\n               (clobber (reg:HI 26))\n               (clobber (reg:QI 21))])\n    (set (match_operand:ALL2QA 0 \"register_operand\" \"\")\n-        (reg:ALL2QA 24))])\n+        (reg:ALL2QA 24))]\n+  \"\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 26));\n+  })\n \n ;; \"*divhq3.call\" \"*udivuhq3.call\"\n ;; \"*divha3.call\" \"*udivuha3.call\"\n@@ -385,7 +407,11 @@\n               (clobber (reg:HI 26))\n               (clobber (reg:HI 30))])\n    (set (match_operand:ALL4A 0 \"register_operand\" \"\")\n-        (reg:ALL4A 22))])\n+        (reg:ALL4A 22))]\n+  \"\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 24));\n+  })\n \n ;; \"*divsa3.call\" \"*udivusa3.call\"\n (define_insn \"*<code><mode>3.call\"\n@@ -435,6 +461,7 @@\n \n     operands[3] = gen_rtx_REG (<MODE>mode, regno_out[(size_t) GET_MODE_SIZE (<MODE>mode)]);\n     operands[4] = gen_rtx_REG (<MODE>mode,  regno_in[(size_t) GET_MODE_SIZE (<MODE>mode)]);\n+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, REGNO (operands[4])));\n     operands[5] = simplify_gen_subreg (QImode, force_reg (HImode, operands[2]), HImode, 0);\n     // $2 is no more needed, but is referenced for expand.\n     operands[2] = const0_rtx;"}, {"sha": "bdb754201b43501f9e2283a73f6e392ef3a31ea3", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -129,6 +129,15 @@ extern bool avr_load_libgcc_p (rtx);\n extern bool avr_xload_libgcc_p (machine_mode);\n extern rtx avr_eval_addr_attrib (rtx x);\n \n+static inline unsigned\n+regmask (machine_mode mode, unsigned regno)\n+{\n+  return ((1u << GET_MODE_SIZE (mode)) - 1) << regno;\n+}\n+\n+extern void avr_fix_inputs (rtx*, unsigned, unsigned);\n+extern bool avr_emit3_fix_outputs (rtx (*)(rtx,rtx,rtx), rtx*, unsigned, unsigned);\n+\n extern rtx lpm_reg_rtx;\n extern rtx lpm_addr_reg_rtx;\n extern rtx tmp_reg_rtx;"}, {"sha": "bc83adb7c3f3147e0897655be1e53eb3cca36c94", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -12201,6 +12201,115 @@ avr_convert_to_type (tree type, tree expr)\n }\n \n \n+/* PR63633: The middle-end might come up with hard regs as input operands.\n+\n+   RMASK is a bit mask representing a subset of hard registers R0...R31:\n+   Rn is an element of that set iff bit n of RMASK is set.\n+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then\n+   OP[n] has to be fixed; otherwise OP[n] is left alone.\n+\n+   For each element of OPMASK which is a hard register overlapping RMASK,\n+   replace OP[n] with a newly created pseudo register\n+\n+   HREG == 0:  Also emit a move insn that copies the contents of that\n+               hard register into the new pseudo.\n+\n+   HREG != 0:  Also set HREG[n] to the hard register.  */\n+\n+static void\n+avr_fix_operands (rtx *op, rtx *hreg, unsigned opmask, unsigned rmask)\n+{\n+  for (; opmask; opmask >>= 1, op++)\n+    {\n+      rtx reg = *op;\n+\n+      if (hreg)\n+        *hreg = NULL_RTX;\n+\n+      if ((opmask & 1)\n+          && REG_P (reg)\n+          && REGNO (reg) < FIRST_PSEUDO_REGISTER\n+          // This hard-reg overlaps other prohibited hard regs?\n+          && (rmask & regmask (GET_MODE (reg), REGNO (reg))))\n+        {\n+          *op = gen_reg_rtx (GET_MODE (reg));\n+          if (hreg == NULL)\n+            emit_move_insn (*op, reg);\n+          else\n+            *hreg = reg;\n+        }\n+\n+      if (hreg)\n+        hreg++;\n+    }\n+}\n+\n+\n+void\n+avr_fix_inputs (rtx *op, unsigned opmask, unsigned rmask)\n+{\n+  avr_fix_operands (op, NULL, opmask, rmask);\n+}\n+\n+\n+/* Helper for the function below:  If bit n of MASK is set and\n+   HREG[n] != NULL, then emit a move insn to copy OP[n] to HREG[n].\n+   Otherwise do nothing for that n.  Return TRUE.  */\n+\n+static bool\n+avr_move_fixed_operands (rtx *op, rtx *hreg, unsigned mask)\n+{\n+  for (; mask; mask >>= 1, op++, hreg++)\n+    if ((mask & 1)\n+        && *hreg)\n+      emit_move_insn (*hreg, *op);\n+\n+  return true;\n+}\n+\n+\n+/* PR63633: The middle-end might come up with hard regs as output operands.\n+\n+   GEN is a sequence generating function like gen_mulsi3 with 3 operands OP[].\n+   RMASK is a bit mask representing a subset of hard registers R0...R31:\n+   Rn is an element of that set iff bit n of RMASK is set.\n+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then\n+   OP[n] has to be fixed; otherwise OP[n] is left alone.\n+\n+   Emit the insn sequence as generated by GEN() with all elements of OPMASK\n+   which are hard registers overlapping RMASK replaced by newly created\n+   pseudo registers.  After the sequence has been emitted, emit insns that\n+   move the contents of respective pseudos to their hard regs.  */\n+\n+bool\n+avr_emit3_fix_outputs (rtx (*gen)(rtx,rtx,rtx), rtx *op,\n+                       unsigned opmask, unsigned rmask)\n+{\n+  const int n = 3;\n+  rtx hreg[n];\n+\n+  /* It is letigimate for GEN to call this function, and in order not to\n+     get self-recursive we use the following static kludge.  This is the\n+     only way not to duplicate all expanders and to avoid ugly and\n+     hard-to-maintain C-code instead of the much more appreciated RTL\n+     representation as supplied by define_expand.  */\n+  static bool lock = false;\n+\n+  gcc_assert (opmask < (1u << n));\n+\n+  if (lock)\n+    return false;\n+\n+  avr_fix_operands (op, hreg, opmask, rmask);\n+\n+  lock = true;\n+  emit_insn (gen (op[0], op[1], op[2]));\n+  lock = false;\n+\n+  return avr_move_fixed_operands (op, hreg, opmask);\n+}\n+\n+\n /* Worker function for movmemhi expander.\n    XOP[0]  Destination as MEM:BLK\n    XOP[1]  Source      \"     \""}, {"sha": "9f722cb108ebd5a87501c511ebd85415e75d713a", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 104, "deletions": 9, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -1548,7 +1548,11 @@\n    (set (reg:QI 22) (match_operand:QI 2 \"register_operand\" \"\"))\n    (parallel [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))\n               (clobber (reg:QI 22))])\n-   (set (match_operand:QI 0 \"register_operand\" \"\") (reg:QI 24))])\n+   (set (match_operand:QI 0 \"register_operand\" \"\") (reg:QI 24))]\n+  \"\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));\n+  })\n \n (define_insn \"*mulqi3_call\"\n   [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))\n@@ -2276,7 +2280,13 @@\n    (parallel [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))\n               (clobber (reg:HI 22))\n               (clobber (reg:QI 21))])\n-   (set (match_operand:HI 0 \"register_operand\" \"\") (reg:HI 24))])\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+        (reg:HI 24))]\n+  \"\"\n+  {\n+    avr_fix_inputs (operands, (1 << 2), regmask (HImode, 24));\n+  })\n+\n \n (define_insn \"*mulhi3_call\"\n   [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))\n@@ -2314,6 +2324,10 @@\n         emit_insn (gen_mulohisi3 (operands[0], operands[2], operands[1]));\n         DONE;\n       }\n+\n+    if (avr_emit3_fix_outputs (gen_mulsi3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n   })\n \n (define_insn_and_split \"*mulsi3\"\n@@ -2353,7 +2367,23 @@\n \n ;; \"muluqisi3\"\n ;; \"muluhisi3\"\n-(define_insn_and_split \"mulu<mode>si3\"\n+(define_expand \"mulu<mode>si3\"\n+  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\")\n+                   (mult:SI (zero_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\" \"\"))\n+                            (match_operand:SI 2 \"pseudo_register_or_const_int_operand\" \"\")))\n+              (clobber (reg:HI 26))\n+              (clobber (reg:DI 18))])]\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);\n+    if (avr_emit3_fix_outputs (gen_mulu<mode>si3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n+  })\n+\n+;; \"*muluqisi3\"\n+;; \"*muluhisi3\"\n+(define_insn_and_split \"*mulu<mode>si3\"\n   [(set (match_operand:SI 0 \"pseudo_register_operand\"                           \"=r\")\n         (mult:SI (zero_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\" \"r\"))\n                  (match_operand:SI 2 \"pseudo_register_or_const_int_operand\"      \"rn\")))\n@@ -2389,7 +2419,23 @@\n \n ;; \"mulsqisi3\"\n ;; \"mulshisi3\"\n-(define_insn_and_split \"muls<mode>si3\"\n+(define_expand \"muls<mode>si3\"\n+  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\")\n+                   (mult:SI (sign_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\" \"\"))\n+                            (match_operand:SI 2 \"pseudo_register_or_const_int_operand\" \"\")))\n+              (clobber (reg:HI 26))\n+              (clobber (reg:DI 18))])]\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);\n+    if (avr_emit3_fix_outputs (gen_muls<mode>si3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n+  })\n+\n+;; \"*mulsqisi3\"\n+;; \"*mulshisi3\"\n+(define_insn_and_split \"*muls<mode>si3\"\n   [(set (match_operand:SI 0 \"pseudo_register_operand\"                           \"=r\")\n         (mult:SI (sign_extend:SI (match_operand:QIHI 1 \"pseudo_register_operand\" \"r\"))\n                  (match_operand:SI 2 \"pseudo_register_or_const_int_operand\"      \"rn\")))\n@@ -2432,7 +2478,22 @@\n \n ;; One-extend operand 1\n \n-(define_insn_and_split \"mulohisi3\"\n+(define_expand \"mulohisi3\"\n+  [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\")\n+                   (mult:SI (not:SI (zero_extend:SI\n+                                     (not:HI (match_operand:HI 1 \"pseudo_register_operand\" \"\"))))\n+                            (match_operand:SI 2 \"pseudo_register_or_const_int_operand\" \"\")))\n+              (clobber (reg:HI 26))\n+              (clobber (reg:DI 18))])]\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);\n+    if (avr_emit3_fix_outputs (gen_mulohisi3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n+  })\n+\n+(define_insn_and_split \"*mulohisi3\"\n   [(set (match_operand:SI 0 \"pseudo_register_operand\"                          \"=r\")\n         (mult:SI (not:SI (zero_extend:SI\n                           (not:HI (match_operand:HI 1 \"pseudo_register_operand\" \"r\"))))\n@@ -2460,15 +2521,25 @@\n                             (any_extend:SI (match_operand:HI 2 \"register_operand\" \"\"))))\n               (clobber (reg:HI 26))\n               (clobber (reg:DI 18))])]\n-  \"AVR_HAVE_MUL\")\n+  \"AVR_HAVE_MUL\"\n+  {\n+    if (avr_emit3_fix_outputs (gen_<extend_u>mulhisi3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n+  })\n \n (define_expand \"usmulhisi3\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n                    (mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n                             (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"\"))))\n               (clobber (reg:HI 26))\n               (clobber (reg:DI 18))])]\n-  \"AVR_HAVE_MUL\")\n+  \"AVR_HAVE_MUL\"\n+  {\n+    if (avr_emit3_fix_outputs (gen_usmulhisi3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n+  })\n \n ;; \"*uumulqihisi3\" \"*uumulhiqisi3\" \"*uumulhihisi3\" \"*uumulqiqisi3\"\n ;; \"*usmulqihisi3\" \"*usmulhiqisi3\" \"*usmulhihisi3\" \"*usmulqiqisi3\"\n@@ -2540,7 +2611,10 @@\n               (clobber (reg:HI 22))])\n    (set (match_operand:HI 0 \"register_operand\" \"\")\n         (reg:HI 24))]\n-  \"AVR_HAVE_MUL\")\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, 1 << 2, regmask (HImode, 18));\n+  })\n \n \n (define_insn \"*mulsi3_call\"\n@@ -2763,6 +2837,10 @@\n         emit_insn (gen_mulsqipsi3 (operands[0], reg, operands[1]));\n         DONE;\n       }\n+\n+    if (avr_emit3_fix_outputs (gen_mulpsi3, operands, 1u << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n   })\n \n (define_insn \"*umulqihipsi3\"\n@@ -2795,7 +2873,21 @@\n   [(set_attr \"length\" \"7\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn_and_split \"mulsqipsi3\"\n+(define_expand \"mulsqipsi3\"\n+  [(parallel [(set (match_operand:PSI 0 \"pseudo_register_operand\" \"\")\n+                   (mult:PSI (sign_extend:PSI (match_operand:QI 1 \"pseudo_register_operand\" \"\"))\n+                             (match_operand:PSI 2 \"pseudo_register_or_const_int_operand\"\"\")))\n+              (clobber (reg:HI 26))\n+              (clobber (reg:DI 18))])]\n+  \"AVR_HAVE_MUL\"\n+  {\n+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);\n+    if (avr_emit3_fix_outputs (gen_mulsqipsi3, operands, 1 << 0,\n+                               regmask (DImode, 18) | regmask (HImode, 26)))\n+      DONE;\n+  })\n+\n+(define_insn_and_split \"*mulsqipsi3\"\n   [(set (match_operand:PSI 0 \"pseudo_register_operand\"                          \"=r\")\n         (mult:PSI (sign_extend:PSI (match_operand:QI 1 \"pseudo_register_operand\" \"r\"))\n                   (match_operand:PSI 2 \"pseudo_register_or_const_int_operand\"    \"rn\")))\n@@ -6134,6 +6226,7 @@\n         emit_insn (gen_fmul_insn (operand0, operand1, operand2));\n         DONE;\n       }\n+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));\n   })\n \n (define_insn \"fmul_insn\"\n@@ -6177,6 +6270,7 @@\n         emit_insn (gen_fmuls_insn (operand0, operand1, operand2));\n         DONE;\n       }\n+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));\n   })\n \n (define_insn \"fmuls_insn\"\n@@ -6220,6 +6314,7 @@\n         emit_insn (gen_fmulsu_insn (operand0, operand1, operand2));\n         DONE;\n       }\n+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));\n   })\n \n (define_insn \"fmulsu_insn\""}, {"sha": "0885198b9537ac7480a95143b60a0d6e621dcc21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -1,3 +1,10 @@\n+2014-11-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tForward-port from 2014-10-30 4_9-branch r216934\n+\n+\tPR target/63633\n+\t* gcc.target/avr/torture/pr63633-ice-mult.c: New test.\n+\n 2014-11-21  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR debug/63239"}, {"sha": "a523424c325324fb882edfdb873771d33a58ee7c", "filename": "gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fpr63633-ice-mult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e641f13e16cc2e1402b17f43df934014a95cfb/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fpr63633-ice-mult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fpr63633-ice-mult.c?ref=00e641f13e16cc2e1402b17f43df934014a95cfb", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+\n+void ice_mult32 (int x)\n+{\n+  register long reg __asm (\"22\");\n+  __asm volatile (\" \" :: \"r\" (reg = 0x12345 * x));\n+}\n+\n+void ice_mult24 (int x)\n+{\n+  register __int24 reg __asm (\"20\");\n+  __asm volatile (\" \" :: \"r\" (reg = 0x12345 * x));\n+}\n+\n+void ice_sh24 (__int24 x)\n+{\n+  register __int24 reg __asm (\"20\");\n+  __asm volatile (\" \" :: \"r\" (reg = x << 3));\n+}\n+\n+void ice_sh24b (__int24 x)\n+{\n+  register __int24 reg __asm (\"20\");\n+  __asm volatile (\" \" :: \"r\" (reg = x << 22));\n+}\n+\n+void ice_s16s16 (int x)\n+{\n+  register long reg __asm (\"20\");\n+  __asm volatile (\" \" :: \"r\" (reg = (long) x*x));\n+}\n+\n+void ice_u16s16 (int x)\n+{\n+  register long reg __asm (\"20\");\n+  __asm volatile (\" \" :: \"r\" (reg = (long) x*0x1234u));\n+}"}]}