{"sha": "04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRlNWViNWYxMGRkMjYxYmVkY2FmNTYxOGE0MTQ3ZmZlMzc4NGEzNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-05-07T19:31:24Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-05-07T19:31:24Z"}, "message": "re PR c++/61083 ([C++11] Ambiguous member pointer results in failure, even if used in SFINAE.)\n\n/cp\n2014-05-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/61083\n\t* pt.c (convert_nontype_argument): Protect all the error calls\n\twith complain & tf_error.\n\n/testsuite\n2014-05-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/61083\n\t* g++.dg/cpp0x/sfinae50.C: New.\n\nFrom-SVN: r210184", "tree": {"sha": "e6db5cde3bdf3d4148f41837ea87038d59a1fa6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6db5cde3bdf3d4148f41837ea87038d59a1fa6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/comments", "author": null, "committer": null, "parents": [{"sha": "1a51f10c8157788eb15dcad754dd32acdae1114e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a51f10c8157788eb15dcad754dd32acdae1114e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a51f10c8157788eb15dcad754dd32acdae1114e"}], "stats": {"total": 149, "additions": 108, "deletions": 41}, "files": [{"sha": "8a7f18c1169eba73f3c6f2270577b96c54e44e3e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "patch": "@@ -1,3 +1,9 @@\n+2014-05-07  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/61083\n+\t* pt.c (convert_nontype_argument): Protect all the error calls\n+\twith complain & tf_error.\n+\n 2014-05-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/61080"}, {"sha": "d30349cd85755639ab71489dc5a7efa0bb1d8de2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "patch": "@@ -5812,17 +5812,18 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t{\n \t  if (VAR_P (expr))\n \t    {\n-\t      error (\"%qD is not a valid template argument \"\n-\t\t     \"because %qD is a variable, not the address of \"\n-\t\t     \"a variable\",\n-\t\t     expr, expr);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qD is not a valid template argument \"\n+\t\t       \"because %qD is a variable, not the address of \"\n+\t\t       \"a variable\", expr, expr);\n \t      return NULL_TREE;\n \t    }\n \t  if (POINTER_TYPE_P (expr_type))\n \t    {\n-\t      error (\"%qE is not a valid template argument for %qT \"\n-\t\t     \"because it is not the address of a variable\",\n-\t\t     expr, type);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument for %qT \"\n+\t\t       \"because it is not the address of a variable\",\n+\t\t       expr, type);\n \t      return NULL_TREE;\n \t    }\n \t  /* Other values, like integer constants, might be valid\n@@ -5837,23 +5838,24 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t\t  ? TREE_OPERAND (expr, 0) : expr);\n \t  if (!VAR_P (decl))\n \t    {\n-\t      error (\"%qE is not a valid template argument of type %qT \"\n-\t\t     \"because %qE is not a variable\",\n-\t\t     expr, type, decl);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument of type %qT \"\n+\t\t       \"because %qE is not a variable\", expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n \t  else if (cxx_dialect < cxx11 && !DECL_EXTERNAL_LINKAGE_P (decl))\n \t    {\n-\t      error (\"%qE is not a valid template argument of type %qT \"\n-\t\t     \"because %qD does not have external linkage\",\n-\t\t     expr, type, decl);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument of type %qT \"\n+\t\t       \"because %qD does not have external linkage\",\n+\t\t       expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n \t  else if (cxx_dialect >= cxx11 && decl_linkage (decl) == lk_none)\n \t    {\n-\t      error (\"%qE is not a valid template argument of type %qT \"\n-\t\t     \"because %qD has no linkage\",\n-\t\t     expr, type, decl);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument of type %qT \"\n+\t\t       \"because %qD has no linkage\", expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n \t}\n@@ -5881,15 +5883,17 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n       if (!at_least_as_qualified_p (TREE_TYPE (type), expr_type))\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because of conflicts in cv-qualification\", expr, type);\n+\t  if (complain & tf_error)\n+\t    error (\"%qE is not a valid template argument for type %qT \"\n+\t\t   \"because of conflicts in cv-qualification\", expr, type);\n \t  return NULL_TREE;\n \t}\n \n       if (!real_lvalue_p (expr))\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because it is not an lvalue\", expr, type);\n+\t  if (complain & tf_error)\n+\t    error (\"%qE is not a valid template argument for type %qT \"\n+\t\t   \"because it is not an lvalue\", expr, type);\n \t  return NULL_TREE;\n \t}\n \n@@ -5905,26 +5909,29 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t  expr = TREE_OPERAND (expr, 0);\n \t  if (DECL_P (expr))\n \t    {\n-\t      error (\"%q#D is not a valid template argument for type %qT \"\n-\t\t     \"because a reference variable does not have a constant \"\n-\t\t     \"address\", expr, type);\n+\t      if (complain & tf_error)\n+\t\terror (\"%q#D is not a valid template argument for type %qT \"\n+\t\t       \"because a reference variable does not have a constant \"\n+\t\t       \"address\", expr, type);\n \t      return NULL_TREE;\n \t    }\n \t}\n \n       if (!DECL_P (expr))\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because it is not an object with external linkage\",\n-\t\t expr, type);\n+\t  if (complain & tf_error)\n+\t    error (\"%qE is not a valid template argument for type %qT \"\n+\t\t   \"because it is not an object with external linkage\",\n+\t\t   expr, type);\n \t  return NULL_TREE;\n \t}\n \n       if (!DECL_EXTERNAL_LINKAGE_P (expr))\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because object %qD has not external linkage\",\n-\t\t expr, type, expr);\n+\t  if (complain & tf_error)\n+\t    error (\"%qE is not a valid template argument for type %qT \"\n+\t\t   \"because object %qD has not external linkage\",\n+\t\t   expr, type, expr);\n \t  return NULL_TREE;\n \t}\n \n@@ -5966,9 +5973,13 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n     {\n       if (TREE_CODE (expr) == ADDR_EXPR)\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because it is a pointer\", expr, type);\n-\t  inform (input_location, \"try using %qE instead\", TREE_OPERAND (expr, 0));\n+\t  if (complain & tf_error)\n+\t    {\n+\t      error (\"%qE is not a valid template argument for type %qT \"\n+\t\t     \"because it is a pointer\", expr, type);\n+\t      inform (input_location, \"try using %qE instead\",\n+\t\t      TREE_OPERAND (expr, 0));\n+\t    }\n \t  return NULL_TREE;\n \t}\n \n@@ -6006,13 +6017,16 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t provide a superior diagnostic.  */\n       if (!same_type_p (TREE_TYPE (expr), type))\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because it is of type %qT\", expr, type,\n-\t\t TREE_TYPE (expr));\n-\t  /* If we are just one standard conversion off, explain.  */\n-\t  if (can_convert_standard (type, TREE_TYPE (expr), complain))\n-\t    inform (input_location,\n-\t\t    \"standard conversions are not allowed in this context\");\n+\t  if (complain & tf_error)\n+\t    {\n+\t      error (\"%qE is not a valid template argument for type %qT \"\n+\t\t     \"because it is of type %qT\", expr, type,\n+\t\t     TREE_TYPE (expr));\n+\t      /* If we are just one standard conversion off, explain.  */\n+\t      if (can_convert_standard (type, TREE_TYPE (expr), complain))\n+\t\tinform (input_location,\n+\t\t\t\"standard conversions are not allowed in this context\");\n+\t    }\n \t  return NULL_TREE;\n \t}\n     }\n@@ -6035,8 +6049,9 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n     {\n       if (expr != nullptr_node)\n \t{\n-\t  error (\"%qE is not a valid template argument for type %qT \"\n-\t\t \"because it is of type %qT\", expr, type, TREE_TYPE (expr));\n+\t  if (complain & tf_error)\n+\t    error (\"%qE is not a valid template argument for type %qT \"\n+\t\t   \"because it is of type %qT\", expr, type, TREE_TYPE (expr));\n \t  return NULL_TREE;\n \t}\n       return expr;"}, {"sha": "5b4ef30a8d1e2916ac6d8c95d58cf363195639a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "patch": "@@ -1,3 +1,8 @@\n+2014-05-07  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/61083\n+\t* g++.dg/cpp0x/sfinae50.C: New.\n+\n 2014-05-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/61080"}, {"sha": "e8d90ca76816dabf6245e6ac1d88f36491ef77e7", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae50.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e5eb5f10dd261bedcaf5618a4147ffe3784a34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae50.C?ref=04e5eb5f10dd261bedcaf5618a4147ffe3784a34", "patch": "@@ -0,0 +1,41 @@\n+// PR c++/61083\n+// { dg-do compile { target c++11 } }\n+\n+template<typename T> T declval();\n+\n+template<typename T, typename U>\n+struct is_same {\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T> {\n+  static const bool value = true;\n+};\n+\n+struct true_type {};\n+struct false_type {};\n+\n+template <typename T>\n+struct is_foo {\n+private:\n+  template<typename U, U> struct helper {};\n+\n+  template <typename Z> static auto\n+  test(Z z) -> decltype(helper<void (Z::*)() const, &Z::foo>(), true_type());\n+\n+  template <typename> static auto test(...) -> false_type;\n+\n+public:\n+  enum { value = is_same<decltype(test<T>(declval<T>())), true_type>::value };\n+};\n+\n+struct A { \n+  int foo();\n+  void foo() const; \n+};\n+\n+struct A1 : public A {};\n+\n+static_assert (is_foo<A>::value == 1, \"\");\n+static_assert (is_foo<A1>::value == 0, \"\");"}]}