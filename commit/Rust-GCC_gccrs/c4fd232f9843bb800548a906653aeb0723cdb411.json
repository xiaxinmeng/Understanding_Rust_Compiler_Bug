{"sha": "c4fd232f9843bb800548a906653aeb0723cdb411", "node_id": "C_kwDOANBUbNoAKGM0ZmQyMzJmOTg0M2JiODAwNTQ4YTkwNjY1M2FlYjA3MjNjZGI0MTE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-10T13:20:10Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-03-10T13:20:10Z"}, "message": "analyzer: fix deref-before-check false +ves seen in haproxy [PR108475,PR109060]\n\nIntegration testing showed various false positives from\n-Wanalyzer-deref-before-check where the expression that's dereferenced\nis different from the one that's checked, but the diagnostic is emitted\nbecause they both evaluate to the same symbolic value.\n\nThis patch rejects such warnings, unless we have tree expressions for\nboth and that both tree expressions are \"spelled the same way\" i.e.\nwould be printed to the same user-facing string.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108475\n\tPR analyzer/109060\n\t* sm-malloc.cc (deref_before_check::deref_before_check):\n\tInitialize new field m_deref_expr.  Assert that arg is non-NULL.\n\t(deref_before_check::emit): Reject cases where the spelling of the\n\tthing that was dereferenced differs from that of what is checked,\n\tor if the dereference expression was not found.  Remove code to\n\thandle NULL m_arg.\n\t(deref_before_check::describe_state_change): Remove code to handle\n\tNULL m_arg.\n\t(deref_before_check::describe_final_event): Likewise.\n\t(deref_before_check::sufficiently_similar_p): New.\n\t(deref_before_check::m_deref_expr): New field.\n\t(malloc_state_machine::maybe_complain_about_deref_before_check):\n\tDon't warn if the diag_ptr is NULL.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108475\n\tPR analyzer/109060\n\t* gcc.dg/analyzer/deref-before-check-pr108475-1.c: New test.\n\t* gcc.dg/analyzer/deref-before-check-pr108475-haproxy-tcpcheck.c:\n\tNew test.\n\t* gcc.dg/analyzer/deref-before-check-pr109060-haproxy-cfgparse.c:\n\tNew test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "db0e039b56a6a1ad65bae0d864e068ead3e8f186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db0e039b56a6a1ad65bae0d864e068ead3e8f186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4fd232f9843bb800548a906653aeb0723cdb411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fd232f9843bb800548a906653aeb0723cdb411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4fd232f9843bb800548a906653aeb0723cdb411", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fd232f9843bb800548a906653aeb0723cdb411/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44f80a370b76fd1564e280f08d6640d0f641d487", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f80a370b76fd1564e280f08d6640d0f641d487", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f80a370b76fd1564e280f08d6640d0f641d487"}], "stats": {"total": 393, "additions": 356, "deletions": 37}, "files": [{"sha": "16883d301d5b5b82df211f0de9b9688f4ba2e5ff", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=c4fd232f9843bb800548a906653aeb0723cdb411", "patch": "@@ -1498,8 +1498,11 @@ class deref_before_check : public malloc_diagnostic\n   deref_before_check (const malloc_state_machine &sm, tree arg)\n   : malloc_diagnostic (sm, arg),\n     m_deref_enode (NULL),\n+    m_deref_expr (NULL),\n     m_check_enode (NULL)\n-  {}\n+  {\n+    gcc_assert (arg);\n+  }\n \n   const char *get_kind () const final override { return \"deref_before_check\"; }\n \n@@ -1560,6 +1563,15 @@ class deref_before_check : public malloc_diagnostic\n     if (linemap_location_from_macro_definition_p (line_table, check_loc))\n       return false;\n \n+    /* Reject if m_deref_expr is sufficiently different from m_arg\n+       for cases where the dereference is spelled differently from\n+       the check, which is probably two different ways to get the\n+       same svalue, and thus not worth reporting.  */\n+    if (!m_deref_expr)\n+      return false;\n+    if (!sufficiently_similar_p (m_deref_expr, m_arg))\n+      return false;\n+\n     /* Reject the warning if the deref's BB doesn't dominate that\n        of the check, so that we don't warn e.g. for shared cleanup\n        code that checks a pointer for NULL, when that code is sometimes\n@@ -1572,15 +1584,10 @@ class deref_before_check : public malloc_diagnostic\n \t\t\t m_deref_enode->get_supernode ()->m_bb))\n       return false;\n \n-    if (m_arg)\n-      return warning_at (rich_loc, get_controlling_option (),\n-\t\t\t \"check of %qE for NULL after already\"\n-\t\t\t \" dereferencing it\",\n-\t\t\t m_arg);\n-    else\n-      return warning_at (rich_loc, get_controlling_option (),\n-\t\t\t \"check of pointer for NULL after already\"\n-\t\t\t \" dereferencing it\");\n+    return warning_at (rich_loc, get_controlling_option (),\n+\t\t       \"check of %qE for NULL after already\"\n+\t\t       \" dereferencing it\",\n+\t\t       m_arg);\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n@@ -1591,11 +1598,9 @@ class deref_before_check : public malloc_diagnostic\n       {\n \tm_first_deref_event = change.m_event_id;\n \tm_deref_enode = change.m_event.get_exploded_node ();\n-\tif (m_arg)\n-\t  return change.formatted_print (\"pointer %qE is dereferenced here\",\n-\t\t\t\t\t m_arg);\n-\telse\n-\t  return label_text::borrow (\"pointer is dereferenced here\");\n+\tm_deref_expr = change.m_expr;\n+\treturn change.formatted_print (\"pointer %qE is dereferenced here\",\n+\t\t\t\t       m_arg);\n       }\n     return malloc_diagnostic::describe_state_change (change);\n   }\n@@ -1604,31 +1609,32 @@ class deref_before_check : public malloc_diagnostic\n   {\n     m_check_enode = ev.m_event.get_exploded_node ();\n     if (m_first_deref_event.known_p ())\n-      {\n-\tif (m_arg)\n-\t  return ev.formatted_print (\"pointer %qE is checked for NULL here but\"\n-\t\t\t\t     \" it was already dereferenced at %@\",\n-\t\t\t\t     m_arg, &m_first_deref_event);\n-\telse\n-\t  return ev.formatted_print (\"pointer is checked for NULL here but\"\n-\t\t\t\t     \" it was already dereferenced at %@\",\n-\t\t\t\t     &m_first_deref_event);\n-      }\n+      return ev.formatted_print (\"pointer %qE is checked for NULL here but\"\n+\t\t\t\t \" it was already dereferenced at %@\",\n+\t\t\t\t m_arg, &m_first_deref_event);\n     else\n-      {\n-\tif (m_arg)\n-\t  return ev.formatted_print (\"pointer %qE is checked for NULL here but\"\n-\t\t\t\t     \" it was already dereferenced\",\n-\t\t\t\t     m_arg);\n-\telse\n-\t  return ev.formatted_print (\"pointer is checked for NULL here but\"\n-\t\t\t\t     \" it was already dereferenced\");\n-      }\n+      return ev.formatted_print (\"pointer %qE is checked for NULL here but\"\n+\t\t\t\t \" it was already dereferenced\",\n+\t\t\t\t m_arg);\n   }\n \n private:\n+  static bool sufficiently_similar_p (tree expr_a, tree expr_b)\n+  {\n+    pretty_printer *pp_a = global_dc->printer->clone ();\n+    pretty_printer *pp_b = global_dc->printer->clone ();\n+    pp_printf (pp_a, \"%qE\", expr_a);\n+    pp_printf (pp_b, \"%qE\", expr_b);\n+    bool result = (strcmp (pp_formatted_text (pp_a), pp_formatted_text (pp_b))\n+\t\t   == 0);\n+    delete pp_a;\n+    delete pp_b;\n+    return result;\n+  }\n+\n   diagnostic_event_id_t m_first_deref_event;\n   const exploded_node *m_deref_enode;\n+  tree m_deref_expr;\n   const exploded_node *m_check_enode;\n };\n \n@@ -2141,9 +2147,10 @@ maybe_complain_about_deref_before_check (sm_context *sm_ctxt,\n     return;\n \n   tree diag_ptr = sm_ctxt->get_diagnostic_tree (ptr);\n-  sm_ctxt->warn\n-    (node, stmt, ptr,\n-     make_unique<deref_before_check> (*this, diag_ptr));\n+  if (diag_ptr)\n+    sm_ctxt->warn\n+      (node, stmt, ptr,\n+       make_unique<deref_before_check> (*this, diag_ptr));\n   sm_ctxt->set_next_state (stmt, ptr, m_stop);\n }\n "}, {"sha": "fa3beaaa15ffe2b466f163e22e3f1428b835b127", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-pr108475-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108475-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108475-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108475-1.c?ref=c4fd232f9843bb800548a906653aeb0723cdb411", "patch": "@@ -0,0 +1,51 @@\n+/* Reduced from haproxy-2.7.1: src/tcpcheck.c.  */\n+\n+#define NULL ((void *)0)\n+\n+int\n+test_1 (char **args, int cur_arg)\n+{\n+  char *p = NULL;\n+\n+  if (*args[cur_arg]) {\n+    p = args[cur_arg];\n+  }\n+\n+  if (p) { /* { dg-bogus \"check of 'p' for NULL after already dereferencing it\" } */\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+int\n+test_2 (char **args, int cur_arg)\n+{\n+  char *p = NULL;\n+  char *q = NULL;\n+\n+  if (*args[cur_arg]) {\n+    if (*args[cur_arg + 1]) {\n+      p = args[cur_arg];\n+    } else {\n+      q = args[cur_arg];\n+    }      \n+  }\n+\n+  if (p) { /* { dg-bogus \"check of 'p' for NULL after already dereferencing it\" } */\n+    return 1;\n+  }\n+  if (q) { /* { dg-bogus \"check of 'q' for NULL after already dereferencing it\" } */\n+    return 2;\n+  }\n+  return 0;\n+}\n+\n+int test_3 (void **pp, int flag)\n+{\n+  void *p = NULL;\n+  if (*pp && flag)\n+    p = pp;\n+  if (p) /* { dg-bogus \"check of 'p' for NULL after already dereferencing it\" } */\n+    return 1;\n+  return 0;    \n+}"}, {"sha": "1180e17e5552a12584d419c2eee79ca2c0843f8e", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-pr108475-haproxy-tcpcheck.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108475-haproxy-tcpcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108475-haproxy-tcpcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108475-haproxy-tcpcheck.c?ref=c4fd232f9843bb800548a906653aeb0723cdb411", "patch": "@@ -0,0 +1,169 @@\n+/* Reduced from haproxy-2.7.1: src/tcpcheck.c.  */\n+\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *)0)\n+\n+extern void *calloc(size_t __nmemb, size_t __size)\n+    __attribute__((__nothrow__, __leaf__)) __attribute__((__malloc__))\n+    __attribute__((__alloc_size__(1, 2)));\n+extern char *strdup(const char *__s) __attribute__((__nothrow__, __leaf__))\n+__attribute__((__malloc__)) __attribute__((__nonnull__(1)));\n+extern char *strstr(const char *__haystack, const char *__needle)\n+    __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))\n+    __attribute__((__nonnull__(1, 2)));\n+extern size_t strlen(const char *__s) __attribute__((__nothrow__, __leaf__))\n+__attribute__((__pure__)) __attribute__((__nonnull__(1)));\n+struct list {\n+  struct list *n;\n+  struct list *p;\n+};\n+struct buffer {\n+  size_t size;\n+  char *area;\n+  size_t data;\n+  size_t head;\n+};\n+struct proxy;\n+struct ist {\n+  char *ptr;\n+  size_t len;\n+};\n+static inline int isttest(const struct ist ist) { return ist.ptr != NULL; }\n+\n+enum http_meth_t {\n+  HTTP_METH_OPTIONS,\n+  /* [...snip...] */\n+} __attribute__((packed));\n+\n+struct http_meth {\n+  enum http_meth_t meth;\n+  struct buffer str;\n+};\n+enum tcpcheck_send_type {\n+  /* [...snip...] */\n+  TCPCHK_SEND_HTTP,\n+};\n+enum tcpcheck_rule_type {\n+  TCPCHK_ACT_SEND = 0,\n+  /* [...snip...] */\n+};\n+struct tcpcheck_http_hdr {\n+  struct ist name;\n+  struct list value;\n+  struct list list;\n+};\n+struct tcpcheck_send {\n+  enum tcpcheck_send_type type;\n+  union {\n+    /* [...snip...] */\n+    struct {\n+      unsigned int flags;\n+      struct http_meth meth;\n+      union {\n+        struct ist uri;\n+        /* [...snip...] */\n+      };\n+      struct ist vsn;\n+      struct list hdrs;\n+      /* [...snip...] */\n+    } http;\n+  };\n+};\n+struct tcpcheck_rule {\n+  /* [...snip...] */\n+  enum tcpcheck_rule_type action;\n+  /* [...snip...] */\n+  union {\n+    /* [...snip...] */\n+    struct tcpcheck_send send;\n+    /* [...snip...] */\n+  };\n+};\n+enum http_meth_t find_http_meth(const char *str, const int len);\n+void free_tcpcheck(struct tcpcheck_rule *rule, int in_pool);\n+void free_tcpcheck_http_hdr(struct tcpcheck_http_hdr *hdr);\n+\n+#define ist(str) ({                                                    \\\n+\tchar *__x = (void *)(str);                                     \\\n+\t(struct ist){                                                  \\\n+\t\t.ptr = __x,                                            \\\n+\t\t.len = __builtin_constant_p(str) ?                     \\\n+\t\t\t((void *)str == (void *)0) ? 0 :               \\\n+\t\t\t__builtin_strlen(__x) :                        \\\n+\t\t\t({                                             \\\n+\t\t\t\tsize_t __l = 0;                        \\\n+\t\t\t\tif (__x) for (__l--; __x[++__l]; ) ;   \\\n+\t\t\t\t__l;                                   \\\n+\t\t\t})                                             \\\n+\t};                                                             \\\n+})\n+\n+struct tcpcheck_rule *proxy_parse_httpchk_req(char **args, int cur_arg,\n+                                              struct proxy *px, char **errmsg) {\n+  struct tcpcheck_rule *chk = NULL;\n+  struct tcpcheck_http_hdr *hdr = NULL;\n+  char *meth = NULL, *uri = NULL, *vsn = NULL;\n+  char *hdrs, *body;\n+\n+  hdrs = (*args[cur_arg + 2] ? strstr(args[cur_arg + 2], \"\\r\\n\") : NULL);\n+  body = (*args[cur_arg + 2] ? strstr(args[cur_arg + 2], \"\\r\\n\\r\\n\") : NULL);\n+  if (hdrs || body) {\n+    /* [...snip...] */\n+    goto error;\n+  }\n+\n+  chk = calloc(1, sizeof(*chk));\n+  if (!chk) {\n+    /* [...snip...] */\n+    goto error;\n+  }\n+  chk->action = TCPCHK_ACT_SEND;\n+  chk->send.type = TCPCHK_SEND_HTTP;\n+  chk->send.http.flags |= 0x0004;\n+  chk->send.http.meth.meth = HTTP_METH_OPTIONS;\n+  ((&chk->send.http.hdrs)->n = (&chk->send.http.hdrs)->p =\n+       (&chk->send.http.hdrs));\n+\n+  if (*args[cur_arg]) {\n+    if (!*args[cur_arg + 1])\n+      uri = args[cur_arg];\n+    else\n+      meth = args[cur_arg];\n+  }\n+  if (*args[cur_arg + 1])\n+    uri = args[cur_arg + 1];\n+  if (*args[cur_arg + 2])\n+    vsn = args[cur_arg + 2];\n+\n+  if (meth) { /* { dg-bogus \"check of 'meth' for NULL after already dereferencing it\" } */\n+    chk->send.http.meth.meth = find_http_meth(meth, strlen(meth));\n+    chk->send.http.meth.str.area = strdup(meth);\n+    chk->send.http.meth.str.data = strlen(meth);\n+    if (!chk->send.http.meth.str.area) {\n+      /* [...snip...] */\n+      goto error;\n+    }\n+  }\n+  if (uri) {\n+    chk->send.http.uri = ist(strdup(uri));\n+    if (!isttest(chk->send.http.uri)) {\n+      /* [...snip...] */\n+      goto error;\n+    }\n+  }\n+  if (vsn) { /* { dg-bogus \"check of 'vsn' for NULL after already dereferencing it\" } */\n+    chk->send.http.vsn = ist(strdup(vsn));\n+    if (!isttest(chk->send.http.vsn)) {\n+      /* [...snip...] */\n+      goto error;\n+    }\n+  }\n+  return chk;\n+\n+error:\n+  free_tcpcheck_http_hdr(hdr);\n+  free_tcpcheck(chk, 0);\n+  return NULL;\n+}"}, {"sha": "4f50882eb8ac85268d558631ffe7f5e4c1137841", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-pr109060-haproxy-cfgparse.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr109060-haproxy-cfgparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fd232f9843bb800548a906653aeb0723cdb411/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr109060-haproxy-cfgparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr109060-haproxy-cfgparse.c?ref=c4fd232f9843bb800548a906653aeb0723cdb411", "patch": "@@ -0,0 +1,92 @@\n+/* Reduced from haproxy-2.7.1's cfgparse.c.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern int\n+strcmp(const char* __s1, const char* __s2)\n+  __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))\n+  __attribute__((__nonnull__(1, 2)));\n+\n+extern int\n+strncmp(const char* __s1, const char* __s2, size_t __n)\n+  __attribute__((__nothrow__, __leaf__)) __attribute__((__pure__))\n+  __attribute__((__nonnull__(1, 2)));\n+\n+enum\n+{\n+ /* [...snip...] */\n+  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),\n+ /* [...snip...] */\n+};\n+\n+extern const unsigned short int**\n+__ctype_b_loc(void) __attribute__((__nothrow__, __leaf__))\n+  __attribute__((__const__));\n+\n+unsigned int str2uic(const char* s);\n+\n+char*\n+memprintf(char** out, const char* format, ...)\n+  __attribute__((format(printf, 2, 3)));\n+\n+int\n+parse_process_number(const char* arg,\n+                     unsigned long* proc,\n+                     int max,\n+                     int* autoinc,\n+                     char** err)\n+{\n+  if (autoinc) {\n+    *autoinc = 0;\n+    if (strncmp(arg, \"auto:\", 5) == 0) {\n+      arg += 5;\n+      *autoinc = 1;\n+    }\n+  }\n+\n+  if (strcmp(arg, \"all\") == 0) /* { dg-bogus \"pointer 'dash' is dereferenced here\" } */\n+    *proc |= ~0UL;\n+  else if (strcmp(arg, \"odd\") == 0)\n+    *proc |= ~0UL / 3UL;\n+  else if (strcmp(arg, \"even\") == 0)\n+    *proc |= (~0UL / 3UL) << 1;\n+  else {\n+    const char *p, *dash = ((void*)0);\n+    unsigned int low, high;\n+\n+    for (p = arg; *p; p++) {\n+      if (*p == '-' && !dash) /* { dg-bogus \"check of 'dash' for NULL after already dereferencing it\" } */\n+        dash = p;\n+      else if (!((*__ctype_b_loc())[(int)(((unsigned char)*p))] &\n+                 (unsigned short int)_ISdigit)) {\n+        memprintf(err, \"'%s' is not a valid number/range.\", arg);\n+        return -1;\n+      }\n+    }\n+\n+    low = high = str2uic(arg);\n+    if (dash) /* { dg-bogus \"check of 'dash' for NULL after already dereferencing it\" } */\n+      high = ((!*(dash + 1)) ? max : str2uic(dash + 1));\n+\n+    if (high < low) {\n+      unsigned int swap = low;\n+      low = high;\n+      high = swap;\n+    }\n+\n+    if (low < 1 || low > max || high > max) {\n+      memprintf(err,\n+                \"'%s' is not a valid number/range.\"\n+                \" It supports numbers from 1 to %d.\\n\",\n+                arg,\n+                max);\n+      return 1;\n+    }\n+\n+    for (; low <= high; low++)\n+      *proc |= 1UL << (low - 1);\n+  }\n+  *proc &= ~0UL >> (((unsigned int)sizeof(long) * 8) - max);\n+\n+  return 0;\n+}"}]}