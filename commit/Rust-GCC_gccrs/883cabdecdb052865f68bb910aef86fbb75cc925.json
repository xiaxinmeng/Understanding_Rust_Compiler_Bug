{"sha": "883cabdecdb052865f68bb910aef86fbb75cc925", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgzY2FiZGVjZGIwNTI4NjVmNjhiYjkxMGFlZjg2ZmJiNzVjYzkyNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-17T18:51:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-17T18:51:55Z"}, "message": "Extend tree-call-cdce to calls whose result is used\n\nFor -fmath-errno, builtins.c currently expands calls to sqrt to:\n\n        y = sqrt_optab (x);\n        if (y != y)\n          [ sqrt (x); or errno = EDOM; ]\n\nThe drawbacks of this are:\n\n- the call to sqrt is protected by the result of the optab rather\n      than the input.  It would be better to check __builtin_isless (x, 0),\n      like tree-call-cdce.c does.\n\n- the branch isn't exposed at the gimple level and so gets little\n      high-level optimisation.\n\n- we do this for log too, but for log a zero input produces\n      -inf rather than a NaN, and sets errno to ERANGE rather than EDOM.\n\nThis patch moves the code to tree-call-cdce.c instead, with the optab\noperation being represented as an internal function.  This means that\nwe can use the existing argument-based range checks rather than the\nresult-based checks and that we get more gimple optimisation of\nthe branch.\n\nPreviously the pass was only enabled by default at -O2 or above,\nbut the old builtins.c code was enabled at -O.  The patch therefore\nenables the pass at -O as well.\n\nThe previous patch to cfgexpand.c handled cases where functions\ndon't (or are assumed not to) set errno, so this patch makes\nthe builtins.c code dead.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu, arm-linux-gnueabi\nand visium-elf (for the EDOM stuff).\n\ngcc/\n\t* builtins.c (expand_errno_check, expand_builtin_mathfn)\n\t(expand_builtin_mathfn_2): Delete.\n\t(expand_builtin): Remove handling of functions with\n\tinternal function equivalents.\n\t* internal-fn.def (SET_EDOM): New internal function.\n\t* internal-fn.h (set_edom_supported_p): Declare.\n\t* internal-fn.c (expand_SET_EDOM): New function.\n\t(set_edom_supported_p): Likewise.\n\t* tree-call-cdce.c: Include builtins.h and internal-fn.h.\n\tRewrite comment at head of file.\n\t(is_call_dce_candidate): Rename to...\n\t(can_test_argument_range): ...this.  Don't check gimple_call_lhs\n\tor gimple_call_builtin_p here.\n\t(edom_only_function): New function.\n\t(shrink_wrap_one_built_in_call_with_conds): New function, split out\n\tfrom...\n\t(shrink_wrap_one_built_in_call): ...here.\n\t(can_use_internal_fn, use_internal_fn): New functions.\n\t(shrink_wrap_conditional_dead_built_in_calls): Call use_internal_fn\n\tfor calls that have an lhs.\n\t(pass_call_cdce::gate): Remove optimize_function_for_speed_p check.\n\t(pass_call_cdce::execute): Skip blocks that are optimized for size.\n\tCheck gimple_call_builtin_p here.  Use can_use_internal_fn for\n\tcalls with an lhs.\n\t* opts.c (default_options_table): Enable -ftree-builtin-call-cdce\n\tat -O and above.\n\nFrom-SVN: r230488", "tree": {"sha": "6dcadb07c42281f307350b2580b0ef025f6a79a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dcadb07c42281f307350b2580b0ef025f6a79a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/883cabdecdb052865f68bb910aef86fbb75cc925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/883cabdecdb052865f68bb910aef86fbb75cc925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/883cabdecdb052865f68bb910aef86fbb75cc925", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/883cabdecdb052865f68bb910aef86fbb75cc925/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4cfe7a6c3569019e33dc86a54ec03aef87ad5d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cfe7a6c3569019e33dc86a54ec03aef87ad5d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cfe7a6c3569019e33dc86a54ec03aef87ad5d83"}], "stats": {"total": 675, "additions": 282, "deletions": 393}, "files": [{"sha": "9fe80ff93aa0581136fcaea0f3fa88f7a7196359", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -1,3 +1,32 @@\n+2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* builtins.c (expand_errno_check, expand_builtin_mathfn)\n+\t(expand_builtin_mathfn_2): Delete.\n+\t(expand_builtin): Remove handling of functions with\n+\tinternal function equivalents.\n+\t* internal-fn.def (SET_EDOM): New internal function.\n+\t* internal-fn.h (set_edom_supported_p): Declare.\n+\t* internal-fn.c (expand_SET_EDOM): New function.\n+\t(set_edom_supported_p): Likewise.\n+\t* tree-call-cdce.c: Include builtins.h and internal-fn.h.\n+\tRewrite comment at head of file.\n+\t(is_call_dce_candidate): Rename to...\n+\t(can_test_argument_range): ...this.  Don't check gimple_call_lhs\n+\tor gimple_call_builtin_p here.\n+\t(edom_only_function): New function.\n+\t(shrink_wrap_one_built_in_call_with_conds): New function, split out\n+\tfrom...\n+\t(shrink_wrap_one_built_in_call): ...here.\n+\t(can_use_internal_fn, use_internal_fn): New functions.\n+\t(shrink_wrap_conditional_dead_built_in_calls): Call use_internal_fn\n+\tfor calls that have an lhs.\n+\t(pass_call_cdce::gate): Remove optimize_function_for_speed_p check.\n+\t(pass_call_cdce::execute): Skip blocks that are optimized for size.\n+\tCheck gimple_call_builtin_p here.  Use can_use_internal_fn for\n+\tcalls with an lhs.\n+\t* opts.c (default_options_table): Enable -ftree-builtin-call-cdce\n+\tat -O and above.\n+\n 2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* builtins.h (called_as_built_in): Declare."}, {"sha": "df5c49309973337619098a533e6724584f7d9678", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -101,9 +101,6 @@ static rtx expand_builtin_apply (rtx, rtx, rtx);\n static void expand_builtin_return (rtx);\n static enum type_class type_to_class (tree);\n static rtx expand_builtin_classify_type (tree);\n-static void expand_errno_check (tree, rtx);\n-static rtx expand_builtin_mathfn (tree, rtx, rtx);\n-static rtx expand_builtin_mathfn_2 (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_3 (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_ternary (tree, rtx, rtx);\n static rtx expand_builtin_interclass_mathfn (tree, rtx);\n@@ -1972,286 +1969,6 @@ replacement_internal_fn (gcall *call)\n   return IFN_LAST;\n }\n \n-/* If errno must be maintained, expand the RTL to check if the result,\n-   TARGET, of a built-in function call, EXP, is NaN, and if so set\n-   errno to EDOM.  */\n-\n-static void\n-expand_errno_check (tree exp, rtx target)\n-{\n-  rtx_code_label *lab = gen_label_rtx ();\n-\n-  /* Test the result; if it is NaN, set errno=EDOM because\n-     the argument was not in the domain.  */\n-  do_compare_rtx_and_jump (target, target, EQ, 0, GET_MODE (target),\n-\t\t\t   NULL_RTX, NULL, lab,\n-\t\t\t   /* The jump is very likely.  */\n-\t\t\t   REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1));\n-\n-#ifdef TARGET_EDOM\n-  /* If this built-in doesn't throw an exception, set errno directly.  */\n-  if (TREE_NOTHROW (TREE_OPERAND (CALL_EXPR_FN (exp), 0)))\n-    {\n-#ifdef GEN_ERRNO_RTX\n-      rtx errno_rtx = GEN_ERRNO_RTX;\n-#else\n-      rtx errno_rtx\n-\t  = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n-#endif\n-      emit_move_insn (errno_rtx,\n-\t\t      gen_int_mode (TARGET_EDOM, GET_MODE (errno_rtx)));\n-      emit_label (lab);\n-      return;\n-    }\n-#endif\n-\n-  /* Make sure the library call isn't expanded as a tail call.  */\n-  CALL_EXPR_TAILCALL (exp) = 0;\n-\n-  /* We can't set errno=EDOM directly; let the library call do it.\n-     Pop the arguments right away in case the call gets deleted.  */\n-  NO_DEFER_POP;\n-  expand_call (exp, target, 0);\n-  OK_DEFER_POP;\n-  emit_label (lab);\n-}\n-\n-/* Expand a call to one of the builtin math functions (sqrt, exp, or log).\n-   Return NULL_RTX if a normal call should be emitted rather than expanding\n-   the function in-line.  EXP is the expression that is a call to the builtin\n-   function; if convenient, the result should be placed in TARGET.\n-   SUBTARGET may be used as the target for computing one of EXP's operands.  */\n-\n-static rtx\n-expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n-{\n-  optab builtin_optab;\n-  rtx op0;\n-  rtx_insn *insns;\n-  tree fndecl = get_callee_fndecl (exp);\n-  machine_mode mode;\n-  bool errno_set = false;\n-  bool try_widening = false;\n-  tree arg;\n-\n-  if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  arg = CALL_EXPR_ARG (exp, 0);\n-\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-    CASE_FLT_FN (BUILT_IN_SQRT):\n-      errno_set = ! tree_expr_nonnegative_p (arg);\n-      try_widening = true;\n-      builtin_optab = sqrt_optab;\n-      break;\n-    CASE_FLT_FN (BUILT_IN_EXP):\n-      errno_set = true; builtin_optab = exp_optab; break;\n-    CASE_FLT_FN (BUILT_IN_EXP10):\n-    CASE_FLT_FN (BUILT_IN_POW10):\n-      errno_set = true; builtin_optab = exp10_optab; break;\n-    CASE_FLT_FN (BUILT_IN_EXP2):\n-      errno_set = true; builtin_optab = exp2_optab; break;\n-    CASE_FLT_FN (BUILT_IN_EXPM1):\n-      errno_set = true; builtin_optab = expm1_optab; break;\n-    CASE_FLT_FN (BUILT_IN_LOGB):\n-      errno_set = true; builtin_optab = logb_optab; break;\n-    CASE_FLT_FN (BUILT_IN_LOG):\n-      errno_set = true; builtin_optab = log_optab; break;\n-    CASE_FLT_FN (BUILT_IN_LOG10):\n-      errno_set = true; builtin_optab = log10_optab; break;\n-    CASE_FLT_FN (BUILT_IN_LOG2):\n-      errno_set = true; builtin_optab = log2_optab; break;\n-    CASE_FLT_FN (BUILT_IN_LOG1P):\n-      errno_set = true; builtin_optab = log1p_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ASIN):\n-      builtin_optab = asin_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ACOS):\n-      builtin_optab = acos_optab; break;\n-    CASE_FLT_FN (BUILT_IN_TAN):\n-      builtin_optab = tan_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ATAN):\n-      builtin_optab = atan_optab; break;\n-    CASE_FLT_FN (BUILT_IN_FLOOR):\n-      builtin_optab = floor_optab; break;\n-    CASE_FLT_FN (BUILT_IN_CEIL):\n-      builtin_optab = ceil_optab; break;\n-    CASE_FLT_FN (BUILT_IN_TRUNC):\n-      builtin_optab = btrunc_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ROUND):\n-      builtin_optab = round_optab; break;\n-    CASE_FLT_FN (BUILT_IN_NEARBYINT):\n-      builtin_optab = nearbyint_optab;\n-      if (flag_trapping_math)\n-\tbreak;\n-      /* Else fallthrough and expand as rint.  */\n-    CASE_FLT_FN (BUILT_IN_RINT):\n-      builtin_optab = rint_optab; break;\n-    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n-      builtin_optab = significand_optab; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Make a suitable register to place result in.  */\n-  mode = TYPE_MODE (TREE_TYPE (exp));\n-\n-  if (! flag_errno_math || ! HONOR_NANS (mode))\n-    errno_set = false;\n-\n-  /* Before working hard, check whether the instruction is available, but try\n-     to widen the mode for specific operations.  */\n-  if ((optab_handler (builtin_optab, mode) != CODE_FOR_nothing\n-       || (try_widening && !excess_precision_type (TREE_TYPE (exp))))\n-      && (!errno_set || !optimize_insn_for_size_p ()))\n-    {\n-      rtx result = gen_reg_rtx (mode);\n-\n-      /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n-\t need to expand the argument again.  This way, we will not perform\n-\t side-effects more the once.  */\n-      CALL_EXPR_ARG (exp, 0) = arg = builtin_save_expr (arg);\n-\n-      op0 = expand_expr (arg, subtarget, VOIDmode, EXPAND_NORMAL);\n-\n-      start_sequence ();\n-\n-      /* Compute into RESULT.\n-\t Set RESULT to wherever the result comes back.  */\n-      result = expand_unop (mode, builtin_optab, op0, result, 0);\n-\n-      if (result != 0)\n-\t{\n-\t  if (errno_set)\n-\t    expand_errno_check (exp, result);\n-\n-\t  /* Output the entire sequence.  */\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insn (insns);\n-\t  return result;\n-\t}\n-\n-      /* If we were unable to expand via the builtin, stop the sequence\n-\t (without outputting the insns) and call to the library function\n-\t with the stabilized argument list.  */\n-      end_sequence ();\n-    }\n-\n-  return expand_call (exp, target, target == const0_rtx);\n-}\n-\n-/* Expand a call to the builtin binary math functions (pow and atan2).\n-   Return NULL_RTX if a normal call should be emitted rather than expanding the\n-   function in-line.  EXP is the expression that is a call to the builtin\n-   function; if convenient, the result should be placed in TARGET.\n-   SUBTARGET may be used as the target for computing one of EXP's\n-   operands.  */\n-\n-static rtx\n-expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n-{\n-  optab builtin_optab;\n-  rtx op0, op1, result;\n-  rtx_insn *insns;\n-  int op1_type = REAL_TYPE;\n-  tree fndecl = get_callee_fndecl (exp);\n-  tree arg0, arg1;\n-  machine_mode mode;\n-  bool errno_set = true;\n-\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-    CASE_FLT_FN (BUILT_IN_SCALBN):\n-    CASE_FLT_FN (BUILT_IN_SCALBLN):\n-    CASE_FLT_FN (BUILT_IN_LDEXP):\n-      op1_type = INTEGER_TYPE;\n-    default:\n-      break;\n-    }\n-\n-  if (!validate_arglist (exp, REAL_TYPE, op1_type, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  arg0 = CALL_EXPR_ARG (exp, 0);\n-  arg1 = CALL_EXPR_ARG (exp, 1);\n-\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-    CASE_FLT_FN (BUILT_IN_POW):\n-      builtin_optab = pow_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ATAN2):\n-      builtin_optab = atan2_optab; break;\n-    CASE_FLT_FN (BUILT_IN_SCALB):\n-      if (REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (exp)))->b != 2)\n-\treturn 0;\n-      builtin_optab = scalb_optab; break;\n-    CASE_FLT_FN (BUILT_IN_SCALBN):\n-    CASE_FLT_FN (BUILT_IN_SCALBLN):\n-      if (REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (exp)))->b != 2)\n-\treturn 0;\n-    /* Fall through... */\n-    CASE_FLT_FN (BUILT_IN_LDEXP):\n-      builtin_optab = ldexp_optab; break;\n-    CASE_FLT_FN (BUILT_IN_FMOD):\n-      builtin_optab = fmod_optab; break;\n-    CASE_FLT_FN (BUILT_IN_REMAINDER):\n-    CASE_FLT_FN (BUILT_IN_DREM):\n-      builtin_optab = remainder_optab; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Make a suitable register to place result in.  */\n-  mode = TYPE_MODE (TREE_TYPE (exp));\n-\n-  /* Before working hard, check whether the instruction is available.  */\n-  if (optab_handler (builtin_optab, mode) == CODE_FOR_nothing)\n-    return NULL_RTX;\n-\n-  result = gen_reg_rtx (mode);\n-\n-  if (! flag_errno_math || ! HONOR_NANS (mode))\n-    errno_set = false;\n-\n-  if (errno_set && optimize_insn_for_size_p ())\n-    return 0;\n-\n-  /* Always stabilize the argument list.  */\n-  CALL_EXPR_ARG (exp, 0) = arg0 = builtin_save_expr (arg0);\n-  CALL_EXPR_ARG (exp, 1) = arg1 = builtin_save_expr (arg1);\n-\n-  op0 = expand_expr (arg0, subtarget, VOIDmode, EXPAND_NORMAL);\n-  op1 = expand_normal (arg1);\n-\n-  start_sequence ();\n-\n-  /* Compute into RESULT.\n-     Set RESULT to wherever the result comes back.  */\n-  result = expand_binop (mode, builtin_optab, op0, op1,\n-\t\t\t result, 0, OPTAB_DIRECT);\n-\n-  /* If we were unable to expand via the builtin, stop the sequence\n-     (without outputting the insns) and call to the library function\n-     with the stabilized argument list.  */\n-  if (result == 0)\n-    {\n-      end_sequence ();\n-      return expand_call (exp, target, target == const0_rtx);\n-    }\n-\n-  if (errno_set)\n-    expand_errno_check (exp, result);\n-\n-  /* Output the entire sequence.  */\n-  insns = get_insns ();\n-  end_sequence ();\n-  emit_insn (insns);\n-\n-  return result;\n-}\n-\n /* Expand a call to the builtin trinary math functions (fma).\n    Return NULL_RTX if a normal call should be emitted rather than expanding the\n    function in-line.  EXP is the expression that is a call to the builtin\n@@ -5984,37 +5701,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     CASE_FLT_FN (BUILT_IN_CABS):\n       break;\n \n-    CASE_FLT_FN (BUILT_IN_EXP):\n-    CASE_FLT_FN (BUILT_IN_EXP10):\n-    CASE_FLT_FN (BUILT_IN_POW10):\n-    CASE_FLT_FN (BUILT_IN_EXP2):\n-    CASE_FLT_FN (BUILT_IN_EXPM1):\n-    CASE_FLT_FN (BUILT_IN_LOGB):\n-    CASE_FLT_FN (BUILT_IN_LOG):\n-    CASE_FLT_FN (BUILT_IN_LOG10):\n-    CASE_FLT_FN (BUILT_IN_LOG2):\n-    CASE_FLT_FN (BUILT_IN_LOG1P):\n-    CASE_FLT_FN (BUILT_IN_TAN):\n-    CASE_FLT_FN (BUILT_IN_ASIN):\n-    CASE_FLT_FN (BUILT_IN_ACOS):\n-    CASE_FLT_FN (BUILT_IN_ATAN):\n-    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n-      /* Treat these like sqrt only if unsafe math optimizations are allowed,\n-\t because of possible accuracy problems.  */\n-      if (! flag_unsafe_math_optimizations)\n-\tbreak;\n-    CASE_FLT_FN (BUILT_IN_SQRT):\n-    CASE_FLT_FN (BUILT_IN_FLOOR):\n-    CASE_FLT_FN (BUILT_IN_CEIL):\n-    CASE_FLT_FN (BUILT_IN_TRUNC):\n-    CASE_FLT_FN (BUILT_IN_ROUND):\n-    CASE_FLT_FN (BUILT_IN_NEARBYINT):\n-    CASE_FLT_FN (BUILT_IN_RINT):\n-      target = expand_builtin_mathfn (exp, target, subtarget);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     CASE_FLT_FN (BUILT_IN_FMA):\n       target = expand_builtin_mathfn_ternary (exp, target, subtarget);\n       if (target)\n@@ -6061,23 +5747,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n-    CASE_FLT_FN (BUILT_IN_ATAN2):\n-    CASE_FLT_FN (BUILT_IN_LDEXP):\n-    CASE_FLT_FN (BUILT_IN_SCALB):\n-    CASE_FLT_FN (BUILT_IN_SCALBN):\n-    CASE_FLT_FN (BUILT_IN_SCALBLN):\n-      if (! flag_unsafe_math_optimizations)\n-\tbreak;\n-\n-    CASE_FLT_FN (BUILT_IN_FMOD):\n-    CASE_FLT_FN (BUILT_IN_REMAINDER):\n-    CASE_FLT_FN (BUILT_IN_DREM):\n-    CASE_FLT_FN (BUILT_IN_POW):\n-      target = expand_builtin_mathfn_2 (exp, target, subtarget);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     CASE_FLT_FN (BUILT_IN_CEXPI):\n       target = expand_builtin_cexpi (exp, target);\n       gcc_assert (target);"}, {"sha": "06c5d9ef43f12c3192ddabc3ba7d3e6af9232168", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -2073,6 +2073,24 @@ expand_GOACC_REDUCTION (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* Set errno to EDOM.  */\n+\n+static void\n+expand_SET_EDOM (internal_fn, gcall *)\n+{\n+#ifdef TARGET_EDOM\n+#ifdef GEN_ERRNO_RTX\n+  rtx errno_rtx = GEN_ERRNO_RTX;\n+#else\n+  rtx errno_rtx = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n+#endif\n+  emit_move_insn (errno_rtx,\n+\t\t  gen_int_mode (TARGET_EDOM, GET_MODE (errno_rtx)));\n+#else\n+  gcc_unreachable ();\n+#endif\n+}\n+\n /* Expand a call to FN using the operands in STMT.  FN has a single\n    output operand and NARGS input operands.  */\n \n@@ -2217,6 +2235,18 @@ direct_internal_fn_supported_p (internal_fn fn, tree type)\n   return direct_internal_fn_supported_p (fn, tree_pair (type, type));\n }\n \n+/* Return true if IFN_SET_EDOM is supported.  */\n+\n+bool\n+set_edom_supported_p (void)\n+{\n+#ifdef TARGET_EDOM\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n #define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) \\\n   static void\t\t\t\t\t\t\\\n   expand_##CODE (internal_fn fn, gcall *stmt)\t\t\\"}, {"sha": "825dba11f24ee13c53ba58727451c875ca99a1e3", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -181,6 +181,10 @@ DEF_INTERNAL_FN (GOACC_LOOP, ECF_PURE | ECF_NOTHROW, NULL)\n /* OpenACC reduction abstraction.  See internal-fn.h  for usage.  */\n DEF_INTERNAL_FN (GOACC_REDUCTION, ECF_NOTHROW | ECF_LEAF, NULL)\n \n+/* Set errno to EDOM, if GCC knows how to do that directly for the\n+   current target.  */\n+DEF_INTERNAL_FN (SET_EDOM, ECF_LEAF | ECF_NOTHROW, NULL)\n+\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_OPTAB_FN"}, {"sha": "6cb123f248dceefb54f62bb010baa277ac6ada4f", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -160,6 +160,7 @@ extern tree_pair direct_internal_fn_types (internal_fn, tree, tree *);\n extern tree_pair direct_internal_fn_types (internal_fn, gcall *);\n extern bool direct_internal_fn_supported_p (internal_fn, tree_pair);\n extern bool direct_internal_fn_supported_p (internal_fn, tree);\n+extern bool set_edom_supported_p (void);\n \n extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);"}, {"sha": "4345cc886edcf1f8b85703591c4e314c9b9b828c", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -478,6 +478,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_fmove_loop_invariants, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_ftree_pta, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_fssa_phiopt, NULL, 1 },\n+    { OPT_LEVELS_1_PLUS, OPT_ftree_builtin_call_dce, NULL, 1 },\n \n     /* -O2 optimizations.  */\n     { OPT_LEVELS_2_PLUS, OPT_finline_small_functions, NULL, 1 },\n@@ -503,7 +504,6 @@ static const struct default_options default_options_table[] =\n       REORDER_BLOCKS_ALGORITHM_STC },\n     { OPT_LEVELS_2_PLUS, OPT_freorder_functions, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_vrp, NULL, 1 },\n-    { OPT_LEVELS_2_PLUS, OPT_ftree_builtin_call_dce, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_pre, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_switch_conversion, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_cp, NULL, 1 },"}, {"sha": "75ef180933b49edb6965b5b3122874451ff2f368", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 217, "deletions": 61, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/883cabdecdb052865f68bb910aef86fbb75cc925/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=883cabdecdb052865f68bb910aef86fbb75cc925", "patch": "@@ -33,46 +33,77 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n #include \"tree-into-ssa.h\"\n+#include \"builtins.h\"\n+#include \"internal-fn.h\"\n \f\n \n-/* Conditional dead call elimination\n+/* This pass serves two closely-related purposes:\n \n-   Some builtin functions can set errno on error conditions, but they\n-   are otherwise pure.  If the result of a call to such a function is\n-   not used, the compiler can still not eliminate the call without\n-   powerful interprocedural analysis to prove that the errno is not\n-   checked.  However, if the conditions under which the error occurs\n-   are known, the compiler can conditionally dead code eliminate the\n-   calls by shrink-wrapping the semi-dead calls into the error condition:\n+   1. It conditionally executes calls that set errno if (a) the result of\n+      the call is unused and (b) a simple range check on the arguments can\n+      detect most cases where errno does not need to be set.\n \n-        built_in_call (args)\n-          ==>\n-        if (error_cond (args))\n-             built_in_call (args)\n+      This is the \"conditional dead-code elimination\" that gave the pass\n+      its original name, since the call is dead for most argument values.\n+      The calls for which it helps are usually part of the C++ abstraction\n+      penalty exposed after inlining.\n+\n+   2. It looks for calls to built-in functions that set errno and whose\n+      result is used.  It checks whether there is an associated internal\n+      function that doesn't set errno and whether the target supports\n+      that internal function.  If so, the pass uses the internal function\n+      to compute the result of the built-in function but still arranges\n+      for errno to be set when necessary.  There are two ways of setting\n+      errno:\n+\n+      a. by protecting the original call with the same argument checks as (1)\n+\n+      b. by protecting the original call with a check that the result\n+\t of the internal function is not equal to itself (i.e. is NaN).\n+\n+      (b) requires that NaNs are the only erroneous results.  It is not\n+      appropriate for functions like log, which returns ERANGE for zero\n+      arguments.  (b) is also likely to perform worse than (a) because it\n+      requires the result to be calculated first.  The pass therefore uses\n+      (a) when it can and uses (b) as a fallback.\n+\n+      For (b) the pass can replace the original call with a call to\n+      IFN_SET_EDOM, if the target supports direct assignments to errno.\n+\n+   In both cases, arguments that require errno to be set should occur\n+   rarely in practice.  Checks of the errno result should also be rare,\n+   but the compiler would need powerful interprocedural analysis to\n+   prove that errno is not checked.  It's much easier to add argument\n+   checks or result checks instead.\n+\n+     An example of (1) is:\n \n-    An actual simple example is :\n \t log (x);   // Mostly dead call\n      ==>\n \t if (__builtin_islessequal (x, 0))\n \t     log (x);\n \n      With this change, call to log (x) is effectively eliminated, as\n-     in majority of the cases, log won't be called with x out of\n+     in the majority of the cases, log won't be called with x out of\n      range.  The branch is totally predictable, so the branch cost\n      is low.\n \n+     An example of (2) is:\n+\n+\ty = sqrt (x);\n+     ==>\n+\ty = IFN_SQRT (x);\n+\tif (__builtin_isless (x, 0))\n+\t    sqrt (x);\n+\n+     In the vast majority of cases we should then never need to call sqrt.\n+\n    Note that library functions are not supposed to clear errno to zero without\n    error.  See IEEE Std 1003.1, section 2.3 Error Numbers, and section 7.5:3 of\n    ISO/IEC 9899 (C99).\n \n    The condition wrapping the builtin call is conservatively set to avoid too\n-   aggressive (wrong) shrink wrapping.  The optimization is called conditional\n-   dead call elimination because the call is eliminated under the condition\n-   that the input arguments would not lead to domain or range error (for\n-   instance when x <= 0 for a log (x) call), however the chances that the error\n-   condition is hit is very low (those builtin calls which are conditionally\n-   dead are usually part of the C++ abstraction penalty exposed after\n-   inlining).  */\n+   aggressive (wrong) shrink wrapping.  */\n \n \n /* A structure for representing input domain of\n@@ -251,28 +282,15 @@ check_builtin_call (gcall *bcall)\n   return check_target_format (arg);\n }\n \n-/* A helper function to determine if a builtin function call is a\n-   candidate for conditional DCE.  Returns true if the builtin call\n-   is a candidate.  */\n+/* Return true if built-in function call CALL calls a math function\n+   and if we know how to test the range of its arguments to detect _most_\n+   situations in which errno is not set.  The test must err on the side\n+   of treating non-erroneous values as potentially erroneous.  */\n \n static bool\n-is_call_dce_candidate (gcall *call)\n+can_test_argument_range (gcall *call)\n {\n-  tree fn;\n-  enum built_in_function fnc;\n-\n-  /* Only potentially dead calls are considered.  */\n-  if (gimple_call_lhs (call))\n-    return false;\n-\n-  fn = gimple_call_fndecl (call);\n-  if (!fn\n-      || !DECL_BUILT_IN (fn)\n-      || (DECL_BUILT_IN_CLASS (fn) != BUILT_IN_NORMAL))\n-    return false;\n-\n-  fnc = DECL_FUNCTION_CODE (fn);\n-  switch (fnc)\n+  switch (DECL_FUNCTION_CODE (gimple_call_fndecl (call)))\n     {\n     /* Trig functions.  */\n     CASE_FLT_FN (BUILT_IN_ACOS):\n@@ -306,6 +324,31 @@ is_call_dce_candidate (gcall *call)\n   return false;\n }\n \n+/* Return true if CALL can produce a domain error (EDOM) but can never\n+   produce a pole, range overflow or range underflow error (all ERANGE).\n+   This means that we can tell whether a function would have set errno\n+   by testing whether the result is a NaN.  */\n+\n+static bool\n+edom_only_function (gcall *call)\n+{\n+  switch (DECL_FUNCTION_CODE (gimple_call_fndecl (call)))\n+    {\n+    CASE_FLT_FN (BUILT_IN_ACOS):\n+    CASE_FLT_FN (BUILT_IN_ASIN):\n+    CASE_FLT_FN (BUILT_IN_ATAN):\n+    CASE_FLT_FN (BUILT_IN_COS):\n+    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n+    CASE_FLT_FN (BUILT_IN_SIN):\n+    CASE_FLT_FN (BUILT_IN_SQRT):\n+    CASE_FLT_FN (BUILT_IN_FMOD):\n+    CASE_FLT_FN (BUILT_IN_REMAINDER):\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n \f\n /* A helper function to generate gimple statements for one bound\n    comparison, so that the built-in function is called whenever\n@@ -703,33 +746,24 @@ gen_shrink_wrap_conditions (gcall *bi_call, vec<gimple *> conds,\n /* Probability of the branch (to the call) is taken.  */\n #define ERR_PROB 0.01\n \n-/* The function to shrink wrap a partially dead builtin call\n-   whose return value is not used anywhere, but has to be kept\n-   live due to potential error condition.  Returns true if the\n-   transformation actually happens.  */\n+/* Shrink-wrap BI_CALL so that it is only called when one of the NCONDS\n+   conditions in CONDS is false.\n+\n+   Return true on success, in which case the cfg will have been updated.  */\n \n static bool\n-shrink_wrap_one_built_in_call (gcall *bi_call)\n+shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n+\t\t\t\t\t  unsigned int nconds)\n {\n   gimple_stmt_iterator bi_call_bsi;\n   basic_block bi_call_bb, join_tgt_bb, guard_bb;\n   edge join_tgt_in_edge_from_call, join_tgt_in_edge_fall_thru;\n   edge bi_call_in_edge0, guard_bb_in_edge;\n-  unsigned tn_cond_stmts, nconds;\n+  unsigned tn_cond_stmts;\n   unsigned ci;\n   gimple *cond_expr = NULL;\n   gimple *cond_expr_start;\n \n-  auto_vec<gimple *, 12> conds;\n-  gen_shrink_wrap_conditions (bi_call, conds, &nconds);\n-\n-  /* This can happen if the condition generator decides\n-     it is not beneficial to do the transformation.  Just\n-     return false and do not do any transformation for\n-     the call.  */\n-  if (nconds == 0)\n-    return false;\n-\n   /* The cfg we want to create looks like this:\n \n \t   [guard n-1]         <- guard_bb (old block)\n@@ -868,6 +902,117 @@ shrink_wrap_one_built_in_call (gcall *bi_call)\n   return true;\n }\n \n+/* Shrink-wrap BI_CALL so that it is only called when it might set errno\n+   (but is always called if it would set errno).\n+\n+   Return true on success, in which case the cfg will have been updated.  */\n+\n+static bool\n+shrink_wrap_one_built_in_call (gcall *bi_call)\n+{\n+  unsigned nconds = 0;\n+  auto_vec<gimple *, 12> conds;\n+  gen_shrink_wrap_conditions (bi_call, conds, &nconds);\n+  /* This can happen if the condition generator decides\n+     it is not beneficial to do the transformation.  Just\n+     return false and do not do any transformation for\n+     the call.  */\n+  if (nconds == 0)\n+    return false;\n+  return shrink_wrap_one_built_in_call_with_conds (bi_call, conds, nconds);\n+}\n+\n+/* Return true if built-in function call CALL could be implemented using\n+   a combination of an internal function to compute the result and a\n+   separate call to set errno.  */\n+\n+static bool\n+can_use_internal_fn (gcall *call)\n+{\n+  /* Only replace calls that set errno.  */\n+  if (!gimple_vdef (call))\n+    return false;\n+\n+  /* Punt if we can't conditionalize the call.  */\n+  basic_block bb = gimple_bb (call);\n+  if (stmt_ends_bb_p (call) && !find_fallthru_edge (bb->succs))\n+    return false;\n+\n+  /* See whether there is an internal function for this built-in.  */\n+  if (replacement_internal_fn (call) == IFN_LAST)\n+    return false;\n+\n+  /* See whether we can catch all cases where errno would be set,\n+     while still avoiding the call in most cases.  */\n+  if (!can_test_argument_range (call)\n+      && !edom_only_function (call))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Implement built-in function call CALL using an internal function.\n+   Return true on success, in which case the cfg will have changed.  */\n+\n+static bool\n+use_internal_fn (gcall *call)\n+{\n+  unsigned nconds = 0;\n+  auto_vec<gimple *, 12> conds;\n+  gen_shrink_wrap_conditions (call, conds, &nconds);\n+  if (nconds == 0 && !edom_only_function (call))\n+    return false;\n+\n+  internal_fn ifn = replacement_internal_fn (call);\n+  gcc_assert (ifn != IFN_LAST);\n+\n+  /* Construct the new call, with the same arguments as the original one.  */\n+  auto_vec <tree, 16> args;\n+  unsigned int nargs = gimple_call_num_args (call);\n+  for (unsigned int i = 0; i < nargs; ++i)\n+    args.safe_push (gimple_call_arg (call, i));\n+  gcall *new_call = gimple_build_call_internal_vec (ifn, args);\n+  gimple_set_location (new_call, gimple_location (call));\n+\n+  /* Transfer the LHS to the new call.  */\n+  tree lhs = gimple_call_lhs (call);\n+  gimple_call_set_lhs (new_call, lhs);\n+  gimple_call_set_lhs (call, NULL_TREE);\n+  SSA_NAME_DEF_STMT (lhs) = new_call;\n+\n+  /* Insert the new call.  */\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  gsi_insert_before (&gsi, new_call, GSI_SAME_STMT);\n+\n+  if (nconds == 0)\n+    {\n+      /* Skip the call if LHS == LHS.  If we reach here, EDOM is the only\n+\t valid errno value and it is used iff the result is NaN.  */\n+      conds.quick_push (gimple_build_cond (EQ_EXPR, lhs, lhs,\n+\t\t\t\t\t   NULL_TREE, NULL_TREE));\n+      nconds++;\n+\n+      /* Try replacing the original call with a direct assignment to\n+\t errno, via an internal function.  */\n+      if (set_edom_supported_p () && !stmt_ends_bb_p (call))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+\t  gcall *new_call = gimple_build_call_internal (IFN_SET_EDOM, 0);\n+\t  gimple_set_vuse (new_call, gimple_vuse (call));\n+\t  gimple_set_vdef (new_call, gimple_vdef (call));\n+\t  SSA_NAME_DEF_STMT (gimple_vdef (new_call)) = new_call;\n+\t  gimple_set_location (new_call, gimple_location (call));\n+\t  gsi_replace (&gsi, new_call, false);\n+\t  call = new_call;\n+\t}\n+    }\n+\n+  if (!shrink_wrap_one_built_in_call_with_conds (call, conds, nconds))\n+    /* It's too late to back out now.  */\n+    gcc_unreachable ();\n+  return true;\n+}\n+\n /* The top level function for conditional dead code shrink\n    wrapping transformation.  */\n \n@@ -884,7 +1029,10 @@ shrink_wrap_conditional_dead_built_in_calls (vec<gcall *> calls)\n   for (; i < n ; i++)\n     {\n       gcall *bi_call = calls[i];\n-      changed |= shrink_wrap_one_built_in_call (bi_call);\n+      if (gimple_call_lhs (bi_call))\n+\tchanged |= use_internal_fn (bi_call);\n+      else\n+\tchanged |= shrink_wrap_one_built_in_call (bi_call);\n     }\n \n   return changed;\n@@ -913,13 +1061,12 @@ class pass_call_cdce : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n+  virtual bool gate (function *)\n     {\n       /* The limit constants used in the implementation\n \t assume IEEE floating point format.  Other formats\n \t can be supported in the future if needed.  */\n-      return flag_tree_builtin_call_dce != 0\n-       \t&& optimize_function_for_speed_p (fun);\n+      return flag_tree_builtin_call_dce != 0;\n     }\n \n   virtual unsigned int execute (function *);\n@@ -935,11 +1082,20 @@ pass_call_cdce::execute (function *fun)\n   auto_vec<gcall *> cond_dead_built_in_calls;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n+      /* Skip blocks that are being optimized for size, since our\n+\t transformation always increases code size.  */\n+      if (optimize_bb_for_size_p (bb))\n+\tcontinue;\n+\n       /* Collect dead call candidates.  */\n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n         {\n \t  gcall *stmt = dyn_cast <gcall *> (gsi_stmt (i));\n-          if (stmt && is_call_dce_candidate (stmt))\n+          if (stmt\n+\t      && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+\t      && (gimple_call_lhs (stmt)\n+\t\t  ? can_use_internal_fn (stmt)\n+\t\t  : can_test_argument_range (stmt)))\n             {\n               if (dump_file && (dump_flags & TDF_DETAILS))\n                 {"}]}