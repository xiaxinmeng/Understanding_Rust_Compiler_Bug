{"sha": "ec25720ba36c2017367b2939cbf1a002694313ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyNTcyMGJhMzZjMjAxNzM2N2IyOTM5Y2JmMWEwMDI2OTQzMTNhYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-09-09T06:00:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-09-09T06:00:40Z"}, "message": "re PR fortran/12840 ([4.0 only] Unable to find scalarization loop specifier)\n\n\tPR fortran/12840\n\t* trans.h (gfor_fndecl_internal_realloc): Declare.\n\t(gfor_fndecl_internal_realloc64): Declare.\n\t* trans-decl.c (gfor_fndecl_internal_realloc): New variable.\n\t(gfor_fndecl_internal_realloc64): New variable.\n\t(gfc_build_builtin_function_decls): Initialize them.\n\t* trans-array.h (gfc_trans_allocate_temp_array): Add a fourth argument.\n\t* trans-array.c (gfc_trans_allocate_array_storage): Add an argument\n\tto say whether the array can grow later.  Don't allocate the array\n\ton the stack if so.  Don't call malloc for zero-sized arrays.\n\t(gfc_trans_allocate_temp_array): Add a similar argument here.\n\tPass it along to gfc_trans_allocate_array_storage.\n\t(gfc_get_iteration_count, gfc_grow_array): New functions.\n\t(gfc_iterator_has_dynamic_bounds): New function.\n\t(gfc_get_array_constructor_element_size): New function.\n\t(gfc_get_array_constructor_size): New function.\n\t(gfc_trans_array_ctor_element): Replace pointer argument with\n\ta descriptor tree.\n\t(gfc_trans_array_constructor_subarray): Likewise.  Take an extra\n\targument to say whether the variable-sized part of the constructor\n\tmust be allocated using realloc.  Grow the array when this\n\targument is true.\n\t(gfc_trans_array_constructor_value): Likewise.\n\t(gfc_get_array_cons_size): Delete.\n\t(gfc_trans_array_constructor): If the loop bound has not been set,\n\tsplit the allocation into a static part and a dynamic part.  Set\n\tloop->to to the bounds for static part before allocating the\n\ttemporary.  Adjust call to gfc_trans_array_constructor_value.\n\t(gfc_conv_loop_setup): Allow any constructor to determine the\n\tloop bounds.  Check whether the constructor has a dynamic size\n\tand prefer to use something else if so.  Expect the loop bound\n\tto be set later.  Adjust call to gfc_trans_allocate_temp_array.\n\t* trans-expr.c (gfc_conv_function_call): Adjust another call here.\n\nFrom-SVN: r104073", "tree": {"sha": "d788ce4f5e058a0f2c9ae51b2f4c42658aaa6a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d788ce4f5e058a0f2c9ae51b2f4c42658aaa6a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec25720ba36c2017367b2939cbf1a002694313ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec25720ba36c2017367b2939cbf1a002694313ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec25720ba36c2017367b2939cbf1a002694313ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec25720ba36c2017367b2939cbf1a002694313ab/comments", "author": null, "committer": null, "parents": [{"sha": "84bb243df1247aff566d54e2d097154e760059c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84bb243df1247aff566d54e2d097154e760059c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84bb243df1247aff566d54e2d097154e760059c3"}], "stats": {"total": 825, "additions": 689, "deletions": 136}, "files": [{"sha": "157578fcd957d3bab0413f30728f7c80bebadcae", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -1,3 +1,39 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/12840\n+\t* trans.h (gfor_fndecl_internal_realloc): Declare.\n+\t(gfor_fndecl_internal_realloc64): Declare.\n+\t* trans-decl.c (gfor_fndecl_internal_realloc): New variable.\n+\t(gfor_fndecl_internal_realloc64): New variable.\n+\t(gfc_build_builtin_function_decls): Initialize them.\n+\t* trans-array.h (gfc_trans_allocate_temp_array): Add a fourth argument.\n+\t* trans-array.c (gfc_trans_allocate_array_storage): Add an argument\n+\tto say whether the array can grow later.  Don't allocate the array\n+\ton the stack if so.  Don't call malloc for zero-sized arrays.\n+\t(gfc_trans_allocate_temp_array): Add a similar argument here.\n+\tPass it along to gfc_trans_allocate_array_storage.\n+\t(gfc_get_iteration_count, gfc_grow_array): New functions.\n+\t(gfc_iterator_has_dynamic_bounds): New function.\n+\t(gfc_get_array_constructor_element_size): New function.\n+\t(gfc_get_array_constructor_size): New function.\n+\t(gfc_trans_array_ctor_element): Replace pointer argument with\n+\ta descriptor tree.\n+\t(gfc_trans_array_constructor_subarray): Likewise.  Take an extra\n+\targument to say whether the variable-sized part of the constructor\n+\tmust be allocated using realloc.  Grow the array when this\n+\targument is true.\n+\t(gfc_trans_array_constructor_value): Likewise.\n+\t(gfc_get_array_cons_size): Delete.\n+\t(gfc_trans_array_constructor): If the loop bound has not been set,\n+\tsplit the allocation into a static part and a dynamic part.  Set\n+\tloop->to to the bounds for static part before allocating the\n+\ttemporary.  Adjust call to gfc_trans_array_constructor_value.\n+\t(gfc_conv_loop_setup): Allow any constructor to determine the\n+\tloop bounds.  Check whether the constructor has a dynamic size\n+\tand prefer to use something else if so.  Expect the loop bound\n+\tto be set later.  Adjust call to gfc_trans_allocate_temp_array.\n+\t* trans-expr.c (gfc_conv_function_call): Adjust another call here.\n+\n 2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/18878"}, {"sha": "f6bd24c2271cfb0044c0a046d68596d800efaea9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 286, "deletions": 133, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -94,6 +94,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"dependency.h\"\n \n static gfc_ss *gfc_walk_subexpr (gfc_ss *, gfc_expr *);\n+static bool gfc_get_array_constructor_size (mpz_t *, gfc_constructor *);\n \n /* The contents of this structure aren't actually used, just the address.  */\n static gfc_ss gfc_ss_terminator_var;\n@@ -435,11 +436,14 @@ gfc_trans_static_array_pointer (gfc_symbol * sym)\n /* Generate code to allocate an array temporary, or create a variable to\n    hold the data.  If size is NULL zero the descriptor so that so that the\n    callee will allocate the array.  Also generates code to free the array\n-   afterwards.  */\n+   afterwards.\n+\n+   DYNAMIC is true if the caller may want to extend the array later\n+   using realloc.  This prevents us from putting the array on the stack.  */\n \n static void\n gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n-\t\t\t\t  tree size, tree nelem)\n+\t\t\t\t  tree size, tree nelem, bool dynamic)\n {\n   tree tmp;\n   tree args;\n@@ -448,7 +452,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \n   desc = info->descriptor;\n   info->offset = gfc_index_zero_node;\n-  if (size == NULL_TREE)\n+  if (size == NULL_TREE || integer_zerop (size))\n     {\n       /* A callee allocated array.  */\n       gfc_conv_descriptor_data_set (&loop->pre, desc, null_pointer_node);\n@@ -457,7 +461,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n   else\n     {\n       /* Allocate the temporary.  */\n-      onstack = gfc_can_put_var_on_stack (size);\n+      onstack = !dynamic && gfc_can_put_var_on_stack (size);\n \n       if (onstack)\n \t{\n@@ -512,11 +516,13 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n    functions returning arrays.  Adjusts the loop variables to be zero-based,\n    and calculates the loop bounds for callee allocated arrays.\n    Also fills in the descriptor, data and offset fields of info if known.\n-   Returns the size of the array, or NULL for a callee allocated array.  */\n+   Returns the size of the array, or NULL for a callee allocated array.\n+\n+   DYNAMIC is as for gfc_trans_allocate_array_storage.  */\n \n tree\n gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n-\t\t\t       tree eltype)\n+\t\t\t       tree eltype, bool dynamic)\n {\n   tree type;\n   tree desc;\n@@ -611,7 +617,7 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n     size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n \n-  gfc_trans_allocate_array_storage (loop, info, size, nelem);\n+  gfc_trans_allocate_array_storage (loop, info, size, nelem, dynamic);\n \n   if (info->dimen > loop->temp_dim)\n     loop->temp_dim = info->dimen;\n@@ -620,6 +626,149 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n }\n \n \n+/* Return the number of iterations in a loop that starts at START,\n+   ends at END, and has step STEP.  */\n+\n+static tree\n+gfc_get_iteration_count (tree start, tree end, tree step)\n+{\n+  tree tmp;\n+  tree type;\n+\n+  type = TREE_TYPE (step);\n+  tmp = fold_build2 (MINUS_EXPR, type, end, start);\n+  tmp = fold_build2 (FLOOR_DIV_EXPR, type, tmp, step);\n+  tmp = fold_build2 (PLUS_EXPR, type, tmp, build_int_cst (type, 1));\n+  tmp = fold_build2 (MAX_EXPR, type, tmp, build_int_cst (type, 0));\n+  return fold_convert (gfc_array_index_type, tmp);\n+}\n+\n+\n+/* Extend the data in array DESC by EXTRA elements.  */\n+\n+static void\n+gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n+{\n+  tree args;\n+  tree tmp;\n+  tree size;\n+  tree ubound;\n+\n+  if (integer_zerop (extra))\n+    return;\n+\n+  ubound = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[0]);\n+\n+  /* Add EXTRA to the upper bound.  */\n+  tmp = build2 (PLUS_EXPR, gfc_array_index_type, ubound, extra);\n+  gfc_add_modify_expr (pblock, ubound, tmp);\n+\n+  /* Get the value of the current data pointer.  */\n+  tmp = gfc_conv_descriptor_data_get (desc);\n+  args = gfc_chainon_list (NULL_TREE, tmp);\n+\n+  /* Calculate the new array size.  */\n+  size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n+  tmp = build2 (PLUS_EXPR, gfc_array_index_type, ubound, gfc_index_one_node);\n+  tmp = build2 (MULT_EXPR, gfc_array_index_type, tmp, size);\n+  args = gfc_chainon_list (args, tmp);\n+\n+  /* Pick the appropriate realloc function.  */\n+  if (gfc_index_integer_kind == 4)\n+    tmp = gfor_fndecl_internal_realloc;\n+  else if (gfc_index_integer_kind == 8)\n+    tmp = gfor_fndecl_internal_realloc64;\n+  else\n+    gcc_unreachable ();\n+\n+  /* Set the new data pointer.  */\n+  tmp = gfc_build_function_call (tmp, args);\n+  gfc_conv_descriptor_data_set (pblock, desc, tmp);\n+}\n+\n+\n+/* Return true if the bounds of iterator I can only be determined\n+   at run time.  */\n+\n+static inline bool\n+gfc_iterator_has_dynamic_bounds (gfc_iterator * i)\n+{\n+  return (i->start->expr_type != EXPR_CONSTANT\n+\t  || i->end->expr_type != EXPR_CONSTANT\n+\t  || i->step->expr_type != EXPR_CONSTANT);\n+}\n+\n+\n+/* Split the size of constructor element EXPR into the sum of two terms,\n+   one of which can be determined at compile time and one of which must\n+   be calculated at run time.  Set *SIZE to the former and return true\n+   if the latter might be nonzero.  */\n+\n+static bool\n+gfc_get_array_constructor_element_size (mpz_t * size, gfc_expr * expr)\n+{\n+  if (expr->expr_type == EXPR_ARRAY)\n+    return gfc_get_array_constructor_size (size, expr->value.constructor);\n+  else if (expr->rank > 0)\n+    {\n+      /* Calculate everything at run time.  */\n+      mpz_set_ui (*size, 0);\n+      return true;\n+    }\n+  else\n+    {\n+      /* A single element.  */\n+      mpz_set_ui (*size, 1);\n+      return false;\n+    }\n+}\n+\n+\n+/* Like gfc_get_array_constructor_element_size, but applied to the whole\n+   of array constructor C.  */\n+\n+static bool\n+gfc_get_array_constructor_size (mpz_t * size, gfc_constructor * c)\n+{\n+  gfc_iterator *i;\n+  mpz_t val;\n+  mpz_t len;\n+  bool dynamic;\n+\n+  mpz_set_ui (*size, 0);\n+  mpz_init (len);\n+  mpz_init (val);\n+\n+  dynamic = false;\n+  for (; c; c = c->next)\n+    {\n+      i = c->iterator;\n+      if (i && gfc_iterator_has_dynamic_bounds (i))\n+\tdynamic = true;\n+      else\n+\t{\n+\t  dynamic |= gfc_get_array_constructor_element_size (&len, c->expr);\n+\t  if (i)\n+\t    {\n+\t      /* Multiply the static part of the element size by the\n+\t\t number of iterations.  */\n+\t      mpz_sub (val, i->end->value.integer, i->start->value.integer);\n+\t      mpz_fdiv_q (val, val, i->step->value.integer);\n+\t      mpz_add_ui (val, val, 1);\n+\t      if (mpz_sgn (val) > 0)\n+\t\tmpz_mul (len, len, val);\n+\t      else\n+\t\tmpz_set_ui (len, 0);\n+\t    }\n+\t  mpz_add (*size, *size, len);\n+\t}\n+    }\n+  mpz_clear (len);\n+  mpz_clear (val);\n+  return dynamic;\n+}\n+\n+\n /* Make sure offset is a variable.  */\n \n static void\n@@ -638,7 +787,7 @@ gfc_put_offset_into_var (stmtblock_t * pblock, tree * poffset,\n /* Assign an element of an array constructor.  */\n \n static void\n-gfc_trans_array_ctor_element (stmtblock_t * pblock, tree pointer,\n+gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t\t\t      tree offset, gfc_se * se, gfc_expr * expr)\n {\n   tree tmp;\n@@ -647,7 +796,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree pointer,\n   gfc_conv_expr (se, expr);\n \n   /* Store the value.  */\n-  tmp = gfc_build_indirect_ref (pointer);\n+  tmp = gfc_build_indirect_ref (gfc_conv_descriptor_data_get (desc));\n   tmp = gfc_build_array_ref (tmp, offset);\n   if (expr->ts.type == BT_CHARACTER)\n     {\n@@ -684,19 +833,23 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree pointer,\n }\n \n \n-/* Add the contents of an array to the constructor.  */\n+/* Add the contents of an array to the constructor.  DYNAMIC is as for\n+   gfc_trans_array_constructor_value.  */\n \n static void\n gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n \t\t\t\t      tree type ATTRIBUTE_UNUSED,\n-\t\t\t\t      tree pointer, gfc_expr * expr,\n-\t\t\t\t      tree * poffset, tree * offsetvar)\n+\t\t\t\t      tree desc, gfc_expr * expr,\n+\t\t\t\t      tree * poffset, tree * offsetvar,\n+\t\t\t\t      bool dynamic)\n {\n   gfc_se se;\n   gfc_ss *ss;\n   gfc_loopinfo loop;\n   stmtblock_t body;\n   tree tmp;\n+  tree size;\n+  int n;\n \n   /* We need this to be a variable so we can increment it.  */\n   gfc_put_offset_into_var (pblock, poffset, offsetvar);\n@@ -715,6 +868,22 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   gfc_conv_ss_startstride (&loop);\n   gfc_conv_loop_setup (&loop);\n \n+  /* Make sure the constructed array has room for the new data.  */\n+  if (dynamic)\n+    {\n+      /* Set SIZE to the total number of elements in the subarray.  */\n+      size = gfc_index_one_node;\n+      for (n = 0; n < loop.dimen; n++)\n+\t{\n+\t  tmp = gfc_get_iteration_count (loop.from[n], loop.to[n],\n+\t\t\t\t\t gfc_index_one_node);\n+\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+\t}\n+\n+      /* Grow the constructed array by SIZE elements.  */\n+      gfc_grow_array (&loop.pre, desc, size);\n+    }\n+\n   /* Make the loop body.  */\n   gfc_mark_ss_chain_used (ss, 1);\n   gfc_start_scalarized_body (&loop, &body);\n@@ -724,7 +893,7 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   if (expr->ts.type == BT_CHARACTER)\n     gfc_todo_error (\"character arrays in constructors\");\n \n-  gfc_trans_array_ctor_element (&body, pointer, *poffset, &se, expr);\n+  gfc_trans_array_ctor_element (&body, desc, *poffset, &se, expr);\n   gcc_assert (se.ss == gfc_ss_terminator);\n \n   /* Increment the offset.  */\n@@ -741,17 +910,23 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n }\n \n \n-/* Assign the values to the elements of an array constructor.  */\n+/* Assign the values to the elements of an array constructor.  DYNAMIC\n+   is true if descriptor DESC only contains enough data for the static\n+   size calculated by gfc_get_array_constructor_size.  When true, memory\n+   for the dynamic parts must be allocated using realloc.  */\n \n static void\n gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n-\t\t\t\t   tree pointer, gfc_constructor * c,\n-\t\t\t\t   tree * poffset, tree * offsetvar)\n+\t\t\t\t   tree desc, gfc_constructor * c,\n+\t\t\t\t   tree * poffset, tree * offsetvar,\n+\t\t\t\t   bool dynamic)\n {\n   tree tmp;\n   stmtblock_t body;\n   gfc_se se;\n+  mpz_t size;\n \n+  mpz_init (size);\n   for (; c; c = c->next)\n     {\n       /* If this is an iterator or an array, the offset must be a variable.  */\n@@ -763,14 +938,14 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n       if (c->expr->expr_type == EXPR_ARRAY)\n \t{\n \t  /* Array constructors can be nested.  */\n-\t  gfc_trans_array_constructor_value (&body, type, pointer,\n+\t  gfc_trans_array_constructor_value (&body, type, desc,\n \t\t\t\t\t     c->expr->value.constructor,\n-\t\t\t\t\t     poffset, offsetvar);\n+\t\t\t\t\t     poffset, offsetvar, dynamic);\n \t}\n       else if (c->expr->rank > 0)\n \t{\n-\t  gfc_trans_array_constructor_subarray (&body, type, pointer,\n-\t\t\t\t\t\tc->expr, poffset, offsetvar);\n+\t  gfc_trans_array_constructor_subarray (&body, type, desc, c->expr,\n+\t\t\t\t\t\tpoffset, offsetvar, dynamic);\n \t}\n       else\n \t{\n@@ -790,8 +965,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t    {\n \t      /* Scalar values.  */\n \t      gfc_init_se (&se, NULL);\n-\t      gfc_trans_array_ctor_element (&body, pointer, *poffset, &se,\n-\t\t\t\t\t    c->expr);\n+\t      gfc_trans_array_ctor_element (&body, desc, *poffset,\n+\t\t\t\t\t    &se, c->expr);\n \n \t      *poffset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t\t      *poffset, gfc_index_one_node);\n@@ -813,13 +988,12 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t  gfc_init_se (&se, NULL);\n \t\t  gfc_conv_constant (&se, p->expr);\n \t\t  if (p->expr->ts.type == BT_CHARACTER\n-\t\t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE\n-\t\t\t  (TREE_TYPE (pointer)))))\n+\t\t      && POINTER_TYPE_P (type))\n \t\t    {\n \t\t      /* For constant character array constructors we build\n \t\t\t an array of pointers.  */\n \t\t      se.expr = gfc_build_addr_expr (pchar_type_node,\n-\t\t\t\t\t\t      se.expr);\n+\t\t\t\t\t\t     se.expr);\n \t\t    }\n \t\t    \n \t\t  list = tree_cons (NULL_TREE, se.expr, list);\n@@ -846,7 +1020,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      init = tmp;\n \n \t      /* Use BUILTIN_MEMCPY to assign the values.  */\n-\t      tmp = gfc_build_indirect_ref (pointer);\n+\t      tmp = gfc_conv_descriptor_data_get (desc);\n+\t      tmp = gfc_build_indirect_ref (tmp);\n \t      tmp = gfc_build_array_ref (tmp, *poffset);\n \t      tmp = gfc_build_addr_expr (NULL, tmp);\n \t      init = gfc_build_addr_expr (NULL, init);\n@@ -887,6 +1062,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  tree loopvar;\n \t  tree exit_label;\n \t  tree loopbody;\n+\t  tree tmp2;\n \n \t  loopbody = gfc_finish_block (&body);\n \n@@ -911,6 +1087,23 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_add_block_to_block (pblock, &se.pre);\n \t  step = gfc_evaluate_now (se.expr, pblock);\n \n+\t  /* If this array expands dynamically, and the number of iterations\n+\t     is not constant, we won't have allocated space for the static\n+\t     part of C->EXPR's size.  Do that now.  */\n+\t  if (dynamic && gfc_iterator_has_dynamic_bounds (c->iterator))\n+\t    {\n+\t      /* Get the number of iterations.  */\n+\t      tmp = gfc_get_iteration_count (loopvar, end, step);\n+\n+\t      /* Get the static part of C->EXPR's size.  */\n+\t      gfc_get_array_constructor_element_size (&size, c->expr);\n+\t      tmp2 = gfc_conv_mpz_to_tree (size, gfc_index_integer_kind);\n+\n+\t      /* Grow the array by TMP * TMP2 elements.  */\n+\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, tmp2);\n+\t      gfc_grow_array (pblock, desc, tmp);\n+\t    }\n+\n \t  /* Generate the loop body.  */\n \t  exit_label = gfc_build_label_decl (NULL_TREE);\n \t  gfc_start_block (&body);\n@@ -947,73 +1140,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_add_expr_to_block (pblock, tmp);\n \t}\n     }\n-}\n-\n-\n-/* Get the size of an expression.  Returns -1 if the size isn't constant.\n-   Implied do loops with non-constant bounds are tricky because we must only\n-   evaluate the bounds once.  */\n-\n-static void\n-gfc_get_array_cons_size (mpz_t * size, gfc_constructor * c)\n-{\n-  gfc_iterator *i;\n-  mpz_t val;\n-  mpz_t len;\n-\n-  mpz_set_ui (*size, 0);\n-  mpz_init (len);\n-  mpz_init (val);\n-\n-  for (; c; c = c->next)\n-    {\n-      if (c->expr->expr_type == EXPR_ARRAY)\n-\t{\n-          /* A nested array constructor.  */\n-\t  gfc_get_array_cons_size (&len, c->expr->value.constructor);\n-\t  if (mpz_sgn (len) < 0)\n-\t    {\n-\t      mpz_set (*size, len);\n-\t      mpz_clear (len);\n-\t      mpz_clear (val);\n-\t      return;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (c->expr->rank > 0)\n-\t    {\n-\t      mpz_set_si (*size, -1);\n-\t      mpz_clear (len);\n-\t      mpz_clear (val);\n-\t      return;\n-\t    }\n-\t  mpz_set_ui (len, 1);\n-\t}\n-\n-      if (c->iterator)\n-\t{\n-\t  i = c->iterator;\n-\n-\t  if (i->start->expr_type != EXPR_CONSTANT\n-\t      || i->end->expr_type != EXPR_CONSTANT\n-\t      || i->step->expr_type != EXPR_CONSTANT)\n-\t    {\n-\t      mpz_set_si (*size, -1);\n-\t      mpz_clear (len);\n-\t      mpz_clear (val);\n-\t      return;\n-\t    }\n-\n-\t  mpz_add (val, i->end->value.integer, i->start->value.integer);\n-\t  mpz_tdiv_q (val, val, i->step->value.integer);\n-\t  mpz_add_ui (val, val, 1);\n-\t  mpz_mul (len, len, val);\n-\t}\n-      mpz_add (*size, *size, len);\n-    }\n-  mpz_clear (len);\n-  mpz_clear (val);\n+  mpz_clear (size);\n }\n \n \n@@ -1104,19 +1231,20 @@ get_array_ctor_strlen (gfc_constructor * c, tree * len)\n static void\n gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n {\n+  gfc_constructor *c;\n   tree offset;\n   tree offsetvar;\n   tree desc;\n-  tree size;\n   tree type;\n   bool const_string;\n+  bool dynamic;\n \n   ss->data.info.dimen = loop->dimen;\n \n+  c = ss->expr->value.constructor;\n   if (ss->expr->ts.type == BT_CHARACTER)\n     {\n-      const_string = get_array_ctor_strlen (ss->expr->value.constructor,\n-\t\t\t\t\t    &ss->string_length);\n+      const_string = get_array_ctor_strlen (c, &ss->string_length);\n       if (!ss->string_length)\n \tgfc_todo_error (\"complex character array constructors\");\n \n@@ -1130,16 +1258,39 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n       type = gfc_typenode_for_spec (&ss->expr->ts);\n     }\n \n-  size = gfc_trans_allocate_temp_array (loop, &ss->data.info, type);\n+  /* See if the constructor determines the loop bounds.  */\n+  dynamic = false;\n+  if (loop->to[0] == NULL_TREE)\n+    {\n+      mpz_t size;\n+\n+      /* We should have a 1-dimensional, zero-based loop.  */\n+      gcc_assert (loop->dimen == 1);\n+      gcc_assert (integer_zerop (loop->from[0]));\n+\n+      /* Split the constructor size into a static part and a dynamic part.\n+\t Allocate the static size up-front and record whether the dynamic\n+\t size might be nonzero.  */\n+      mpz_init (size);\n+      dynamic = gfc_get_array_constructor_size (&size, c);\n+      mpz_sub_ui (size, size, 1);\n+      loop->to[0] = gfc_conv_mpz_to_tree (size, gfc_index_integer_kind);\n+      mpz_clear (size);\n+    }\n+\n+  gfc_trans_allocate_temp_array (loop, &ss->data.info, type, dynamic);\n \n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n   offsetvar = gfc_create_var_np (gfc_array_index_type, \"offset\");\n   TREE_USED (offsetvar) = 0;\n-  gfc_trans_array_constructor_value (&loop->pre, type,\n-\t\t\t\t     ss->data.info.data,\n-\t\t\t\t     ss->expr->value.constructor, &offset,\n-\t\t\t\t     &offsetvar);\n+  gfc_trans_array_constructor_value (&loop->pre, type, desc, c,\n+\t\t\t\t     &offset, &offsetvar, dynamic);\n+\n+  /* If the array grows dynamically, the upper bound of the loop variable\n+     is determined by the array's final upper bound.  */\n+  if (dynamic)\n+    loop->to[0] = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[0]);\n \n   if (TREE_USED (offsetvar))\n     pushdecl (offsetvar);\n@@ -2411,13 +2562,16 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n   tree tmp;\n   tree len;\n   gfc_ss *loopspec[GFC_MAX_DIMENSIONS];\n+  bool dynamic[GFC_MAX_DIMENSIONS];\n+  gfc_constructor *c;\n   mpz_t *cshape;\n   mpz_t i;\n \n   mpz_init (i);\n   for (n = 0; n < loop->dimen; n++)\n     {\n       loopspec[n] = NULL;\n+      dynamic[n] = false;\n       /* We use one SS term, and use that to determine the bounds of the\n          loop for this dimension.  We try to pick the simplest term.  */\n       for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n@@ -2435,17 +2589,15 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t\t Higher rank constructors will either have known shape,\n \t\t or still be wrapped in a call to reshape.  */\n \t      gcc_assert (loop->dimen == 1);\n-\t      /* Try to figure out the size of the constructor.  */\n-\t      /* TODO: avoid this by making the frontend set the shape.  */\n-\t      gfc_get_array_cons_size (&i, ss->expr->value.constructor);\n-\t      /* A negative value means we failed.  */\n-\t      if (mpz_sgn (i) > 0)\n-\t\t{\n-\t\t  mpz_sub_ui (i, i, 1);\n-\t\t  loop->to[n] =\n-\t\t    gfc_conv_mpz_to_tree (i, gfc_index_integer_kind);\n-\t\t  loopspec[n] = ss;\n-\t\t}\n+\n+\t      /* Always prefer to use the constructor bounds if the size\n+\t\t can be determined at compile time.  Prefer not to otherwise,\n+\t\t since the general case involves realloc, and it's better to\n+\t\t avoid that overhead if possible.  */\n+\t      c = ss->expr->value.constructor;\n+\t      dynamic[n] = gfc_get_array_constructor_size (&i, c);\n+\t      if (!dynamic[n] || !loopspec[n])\n+\t\tloopspec[n] = ss;\n \t      continue;\n \t    }\n \n@@ -2466,31 +2618,30 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t    specinfo = NULL;\n \t  info = &ss->data.info;\n \n+\t  if (!specinfo)\n+\t    loopspec[n] = ss;\n \t  /* Criteria for choosing a loop specifier (most important first):\n+\t     doesn't need realloc\n \t     stride of one\n \t     known stride\n \t     known lower bound\n \t     known upper bound\n \t   */\n-\t  if (!specinfo)\n+\t  else if (loopspec[n]->type == GFC_SS_CONSTRUCTOR && dynamic[n])\n \t    loopspec[n] = ss;\n-\t  /* TODO: Is != constructor correct?  */\n-\t  else if (loopspec[n]->type != GFC_SS_CONSTRUCTOR)\n-\t    {\n-\t      if (integer_onep (info->stride[n])\n-\t\t  && !integer_onep (specinfo->stride[n]))\n-\t\tloopspec[n] = ss;\n-\t      else if (INTEGER_CST_P (info->stride[n])\n-\t\t       && !INTEGER_CST_P (specinfo->stride[n]))\n-\t\tloopspec[n] = ss;\n-\t      else if (INTEGER_CST_P (info->start[n])\n-\t\t       && !INTEGER_CST_P (specinfo->start[n]))\n-\t\tloopspec[n] = ss;\n-\t      /* We don't work out the upper bound.\n-\t         else if (INTEGER_CST_P (info->finish[n])\n-\t         && ! INTEGER_CST_P (specinfo->finish[n]))\n-\t         loopspec[n] = ss; */\n-\t    }\n+\t  else if (integer_onep (info->stride[n])\n+\t\t   && !integer_onep (specinfo->stride[n]))\n+\t    loopspec[n] = ss;\n+\t  else if (INTEGER_CST_P (info->stride[n])\n+\t\t   && !INTEGER_CST_P (specinfo->stride[n]))\n+\t    loopspec[n] = ss;\n+\t  else if (INTEGER_CST_P (info->start[n])\n+\t\t   && !INTEGER_CST_P (specinfo->start[n]))\n+\t    loopspec[n] = ss;\n+\t  /* We don't work out the upper bound.\n+\t     else if (INTEGER_CST_P (info->finish[n])\n+\t     && ! INTEGER_CST_P (specinfo->finish[n]))\n+\t     loopspec[n] = ss; */\n \t}\n \n       if (!loopspec[n])\n@@ -2520,8 +2671,9 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t  switch (loopspec[n]->type)\n \t    {\n \t    case GFC_SS_CONSTRUCTOR:\n-\t      gcc_assert (info->dimen == 1);\n-      \t      gcc_assert (loop->to[n]);\n+\t      /* The upper bound is calculated when we expand the\n+\t\t constructor.  */\n+\t      gcc_assert (loop->to[n] == NULL_TREE);\n \t      break;\n \n \t    case GFC_SS_SECTION:\n@@ -2575,7 +2727,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n       memset (&loop->temp_ss->data.info, 0, sizeof (gfc_ss_info));\n       loop->temp_ss->type = GFC_SS_SECTION;\n       loop->temp_ss->data.info.dimen = n;\n-      gfc_trans_allocate_temp_array (loop, &loop->temp_ss->data.info, tmp);\n+      gfc_trans_allocate_temp_array (loop, &loop->temp_ss->data.info,\n+\t\t\t\t     tmp, false);\n     }\n \n   for (n = 0; n < loop->temp_dim; n++)"}, {"sha": "eda4245d5d9e4f2e27f5806aeece055ddd19a8b8", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -27,7 +27,7 @@ tree gfc_array_deallocate (tree, tree);\n void gfc_array_allocate (gfc_se *, gfc_ref *, tree);\n \n /* Generate code to allocate a temporary array.  */\n-tree gfc_trans_allocate_temp_array (gfc_loopinfo *, gfc_ss_info *, tree);\n+tree gfc_trans_allocate_temp_array (gfc_loopinfo *, gfc_ss_info *, tree, bool);\n \n /* Generate function entry code for allocation of compiler allocated array\n    variables.  */"}, {"sha": "73e02f0cc4a4c354d32889e0f75015411ce6ef3a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -73,6 +73,8 @@ tree gfc_static_ctors;\n \n tree gfor_fndecl_internal_malloc;\n tree gfor_fndecl_internal_malloc64;\n+tree gfor_fndecl_internal_realloc;\n+tree gfor_fndecl_internal_realloc64;\n tree gfor_fndecl_internal_free;\n tree gfor_fndecl_allocate;\n tree gfor_fndecl_allocate64;\n@@ -1891,6 +1893,18 @@ gfc_build_builtin_function_decls (void)\n \t\t\t\t     pvoid_type_node, 1, gfc_int8_type_node);\n   DECL_IS_MALLOC (gfor_fndecl_internal_malloc64) = 1;\n \n+  gfor_fndecl_internal_realloc =\n+    gfc_build_library_function_decl (get_identifier\n+\t\t\t\t     (PREFIX(\"internal_realloc\")),\n+\t\t\t\t     pvoid_type_node, 2, pvoid_type_node,\n+\t\t\t\t     gfc_int4_type_node);\n+\n+  gfor_fndecl_internal_realloc64 =\n+    gfc_build_library_function_decl (get_identifier\n+\t\t\t\t     (PREFIX(\"internal_realloc64\")),\n+\t\t\t\t     pvoid_type_node, 2, pvoid_type_node,\n+\t\t\t\t     gfc_int8_type_node);\n+\n   gfor_fndecl_internal_free =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"internal_free\")),\n \t\t\t\t     void_type_node, 1, pvoid_type_node);"}, {"sha": "aa60e7ff57b7b2d0fe942789fec141149f46131a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -1694,7 +1694,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  info->dimen = se->loop->dimen;\n \n \t  /* Allocate a temporary to store the result.  */\n-\t  gfc_trans_allocate_temp_array (se->loop, info, tmp);\n+\t  gfc_trans_allocate_temp_array (se->loop, info, tmp, false);\n \n \t  /* Zero the first stride to indicate a temporary.  */\n \t  tmp = gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);"}, {"sha": "5c27fa77c10f908d94180d9d460fc43541197107", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -443,6 +443,8 @@ tree builtin_function (const char *, tree, int, enum built_in_class,\n /* Runtime library function decls.  */\n extern GTY(()) tree gfor_fndecl_internal_malloc;\n extern GTY(()) tree gfor_fndecl_internal_malloc64;\n+extern GTY(()) tree gfor_fndecl_internal_realloc;\n+extern GTY(()) tree gfor_fndecl_internal_realloc64;\n extern GTY(()) tree gfor_fndecl_internal_free;\n extern GTY(()) tree gfor_fndecl_allocate;\n extern GTY(()) tree gfor_fndecl_allocate64;"}, {"sha": "7178e75e85f44cfb31e9f524f099885450f09cad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -1,3 +1,14 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/12840\n+\t* gfortran.dg/array_constructor_6.f90\n+\t* gfortran.dg/array_constructor_7.f90\n+\t* gfortran.dg/array_constructor_8.f90\n+\t* gfortran.dg/array_constructor_9.f90\n+\t* gfortran.dg/array_constructor_10.f90\n+\t* gfortran.dg/array_constructor_11.f90\n+\t* gfortran.dg/array_constructor_12.f90: New tests.\n+\n 2005-09-08  Josh Conner  <jconner@apple.com>\n \n \tPR c++/23180"}, {"sha": "c439e0c7f7e93066a054901dec22c5c281bbbae5", "filename": "gcc/testsuite/gfortran.dg/array_constructor_10.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_10.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,27 @@\n+! Like array_constructor_6.f90, but check constructors that apply\n+! an elemental function to an array.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call build (200)\n+contains\n+  subroutine build (order)\n+    integer :: order, i\n+\n+    call test (order, (/ (abs ((/ i, -i, -i * 2 /)), i = 1, order) /))\n+    call test (order, abs ((/ ((/ -i, -i, i * 2 /), i = 1, order) /)))\n+    call test (order, (/ abs ((/ ((/ i, i, -i * 2 /), i = 1, order) /)) /))\n+  end subroutine build\n+\n+  subroutine test (order, values)\n+    integer, dimension (3:) :: values\n+    integer :: order, i\n+\n+    if (size (values, dim = 1) .ne. order * 3) call abort\n+    do i = 1, order\n+      if (values (i * 3) .ne. i) call abort\n+      if (values (i * 3 + 1) .ne. i) call abort\n+      if (values (i * 3 + 2) .ne. i * 2) call abort\n+    end do\n+  end subroutine test\n+end program main"}, {"sha": "395d2927b9efe7faf4838fc9fc8a8d917cbb21e3", "filename": "gcc/testsuite/gfortran.dg/array_constructor_11.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_11.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,47 @@\n+! Like array_constructor_6.f90, but check iterators with non-default stride,\n+! including combinations which lead to zero-length vectors.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call build (77)\n+contains\n+  subroutine build (order)\n+    integer :: order, i, j\n+\n+    call test (1, 11, 3, (/ (i, i = 1, 11, 3) /))\n+    call test (3, 20, 2, (/ (i, i = 3, 20, 2) /))\n+    call test (4, 0, 11, (/ (i, i = 4, 0, 11) /))\n+\n+    call test (110, 10, -3,  (/ (i, i = 110, 10, -3) /))\n+    call test (200, 20, -12, (/ (i, i = 200, 20, -12) /))\n+    call test (29, 30, -6,   (/ (i, i = 29, 30, -6) /))\n+\n+    call test (1, order, 3,  (/ (i, i = 1, order, 3) /))\n+    call test (order, 1, -3, (/ (i, i = order, 1, -3) /))\n+\n+    ! Triggers compile-time iterator calculations in trans-array.c\n+    call test (1, 1000, 2,   (/ (i, i = 1, 1000, 2),   (i, i = order, 0, 1) /))\n+    call test (1, 0, 3,      (/ (i, i = 1, 0, 3),      (i, i = order, 0, 1) /))\n+    call test (1, 2000, -5,  (/ (i, i = 1, 2000, -5),  (i, i = order, 0, 1) /))\n+    call test (3000, 99, 4,  (/ (i, i = 3000, 99, 4),  (i, i = order, 0, 1) /))\n+    call test (400, 77, -39, (/ (i, i = 400, 77, -39), (i, i = order, 0, 1) /))\n+\n+    do j = -10, 10\n+      call test (order + j, order, 5,  (/ (i, i = order + j, order, 5) /))\n+      call test (order + j, order, -5, (/ (i, i = order + j, order, -5) /))\n+    end do\n+\n+  end subroutine build\n+\n+  subroutine test (from, to, step, values)\n+    integer, dimension (:) :: values\n+    integer :: from, to, step, last, i\n+\n+    last = 0\n+    do i = from, to, step\n+      last = last + 1\n+      if (values (last) .ne. i) call abort\n+    end do\n+    if (size (values, dim = 1) .ne. last) call abort\n+  end subroutine test\n+end program main"}, {"sha": "1c22ab911bcd39bbaf8e69bcf887618e0ebb6b65", "filename": "gcc/testsuite/gfortran.dg/array_constructor_12.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_12.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,51 @@\n+! Like array_constructor_6.f90, but check integer(8) iterators.\n+! { dg-do run }\n+program main\n+  integer (kind = 8) :: i, l8, u8, step8\n+  integer (kind = 4) :: l4, step4\n+  integer (kind = 8), parameter :: big = 10000000000_8\n+\n+  l4 = huge (1)\n+  u8 = l4 + 10_8\n+  step4 = 2\n+  call test ((/ (i, i = l4, u8, step4) /), l4 + 0_8, u8, step4 + 0_8)\n+\n+  l8 = big\n+  u8 = big * 20\n+  step8 = big\n+  call test ((/ (i, i = l8, u8, step8) /), l8, u8, step8)\n+\n+  u8 = big + 100\n+  l8 = big\n+  step4 = -20\n+  call test ((/ (i, i = u8, l8, step4) /), u8, l8, step4 + 0_8)\n+\n+  u8 = big * 40\n+  l8 = big * 20\n+  step8 = -big * 2\n+  call test ((/ (i, i = u8, l8, step8) /), u8, l8, step8)\n+\n+  u8 = big\n+  l4 = big / 100\n+  step4 = -big / 500\n+  call test ((/ (i, i = u8, l4, step4) /), u8, l4 + 0_8, step4 + 0_8)\n+\n+  u8 = big * 40 + 200\n+  l4 = 200\n+  step8 = -big\n+  call test ((/ (i, i = u8, l4, step8) /), u8, l4 + 0_8, step8)\n+contains\n+  subroutine test (a, l, u, step)\n+    integer (kind = 8), dimension (:), intent (in) :: a\n+    integer (kind = 8), intent (in) :: l, u, step\n+    integer (kind = 8) :: i\n+    integer :: j\n+\n+    j = 1\n+    do i = l, u, step\n+      if (a (j) .ne. i) call abort\n+      j = j + 1\n+    end do\n+    if (size (a, 1) .ne. j - 1) call abort\n+  end subroutine test\n+end program main"}, {"sha": "177fb20ee7a909c27a238451eae5db22fc4ae066", "filename": "gcc/testsuite/gfortran.dg/array_constructor_6.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_6.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,25 @@\n+! PR 12840.  Make sure that array constructors can be used to determine\n+! the bounds of a scalarization loop.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call build (11)\n+contains\n+  subroutine build (order)\n+    integer :: order, i\n+\n+    call test (order, (/ (i * 2, i = 1, order) /))\n+    call test (17, (/ (i * 2, i = 1, 17) /))\n+    call test (5, (/ 2, 4, 6, 8, 10 /))\n+  end subroutine build\n+\n+  subroutine test (order, values)\n+    integer, dimension (:) :: values\n+    integer :: order, i\n+\n+    if (size (values, dim = 1) .ne. order) call abort\n+    do i = 1, order\n+      if (values (i) .ne. i * 2) call abort\n+    end do\n+  end subroutine test\n+end program main"}, {"sha": "65ec26c8750b7922569fbb31ce3b8194981249ef", "filename": "gcc/testsuite/gfortran.dg/array_constructor_7.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_7.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,26 @@\n+! Like array_constructor_6.f90, but test for nested iterators.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call build (17)\n+contains\n+  subroutine build (order)\n+    integer :: order, i, j\n+\n+    call test (order, (/ (((j + 100) * i, j = 1, i), i = 1, order) /))\n+    call test (9, (/ (((j + 100) * i, j = 1, i), i = 1, 9) /))\n+    call test (3, (/ 101, 202, 204, 303, 306, 309 /))\n+  end subroutine build\n+\n+  subroutine test (order, values)\n+    integer, dimension (:) :: values\n+    integer :: order, i, j\n+\n+    if (size (values, dim = 1) .ne. order * (order + 1) / 2) call abort\n+    do i = 1, order\n+      do j = 1, i\n+        if (values (i * (i - 1) / 2 + j) .ne. (j + 100) * i) call abort\n+      end do\n+    end do\n+  end subroutine test\n+end program main"}, {"sha": "0ecebbca9f87b408eecfe4b00cd6319a72cedd12", "filename": "gcc/testsuite/gfortran.dg/array_constructor_8.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_8.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,46 @@\n+! Like array_constructor_6.f90, but check constructors that mix iterators\n+! and individual scalar elements.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call build (42)\n+contains\n+  subroutine build (order)\n+    integer :: order, i\n+\n+    call test (order, 8, 5, (/ ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), i = 1, order), &\n+                               100, 200, 300, 400, 500 /))\n+\n+    call test (order, 2, 3, (/ ((/ 1, 2 /), i = 1, order), &\n+                               100, 200, 300 /))\n+\n+    call test (order, 3, 5, (/ ((/ 1, 2, 3 /), i = 1, order), &\n+                               100, 200, 300, 400, 500 /))\n+\n+    call test (order, 6, 1, (/ ((/ 1, 2, 3, 4, 5, 6 /), i = 1, order), &\n+                               100 /))\n+\n+    call test (order, 5, 0, (/ ((/ 1, 2, 3, 4, 5 /), i = 1, order) /))\n+\n+    call test (order, 0, 4, (/ 100, 200, 300, 400 /))\n+\n+    call test (11, 5, 2, (/ ((/ 1, 2, 3, 4, 5 /), i = 1, 11), &\n+                            100, 200 /))\n+\n+    call test (6, 2, order, (/ ((/ 1, 2 /), i = 1, 6), &\n+                               (i * 100, i = 1, order) /))\n+  end subroutine build\n+\n+  subroutine test (order, repeat, trail, values)\n+    integer, dimension (:) :: values\n+    integer :: order, repeat, trail, i\n+\n+    if (size (values, dim = 1) .ne. order * repeat + trail) call abort\n+    do i = 1, order * repeat\n+      if (values (i) .ne. mod (i - 1, repeat) + 1) call abort\n+    end do\n+    do i = 1, trail\n+      if (values (i + order * repeat) .ne. i * 100) call abort\n+    end do\n+  end subroutine test\n+end program main"}, {"sha": "71e939bf0db2181e0ae2cb23b396fe487884eaf5", "filename": "gcc/testsuite/gfortran.dg/array_constructor_9.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_9.f90?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -0,0 +1,43 @@\n+! Like array_constructor_6.f90, but check constructors in which the length\n+! of each subarray can only be determined at run time.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call build (9)\n+contains\n+  function gen (order)\n+    real, dimension (:, :), pointer :: gen\n+    integer :: order, i, j\n+\n+    allocate (gen (order, order + 1))\n+    forall (i = 1 : order, j = 1 : order + 1) gen (i, j) = i * i + j\n+  end function gen\n+\n+  ! Deliberately leaky!\n+  subroutine build (order)\n+    integer :: order, i\n+\n+    call test (order, 0, (/ (gen (i), i = 1, order) /))\n+    call test (3, 2, (/ ((/ 1.5, 1.5, gen (i) /), i = 1, 3) /))\n+  end subroutine build\n+\n+  subroutine test (order, prefix, values)\n+    real, dimension (:) :: values\n+    integer :: order, prefix, last, i, j, k\n+\n+    last = 0\n+    do i = 1, order\n+      do j = 1, prefix\n+        last = last + 1\n+        if (values (last) .ne. 1.5) call abort\n+      end do\n+      do j = 1, i + 1\n+        do k = 1, i\n+          last = last + 1\n+          if (values (last) .ne. j + k * k) call abort\n+        end do\n+      end do\n+    end do\n+    if (size (values, dim = 1) .ne. last) call abort\n+  end subroutine test\n+end program main"}, {"sha": "5edab98b3226fa48e2eb3cfdb07db05bbde59f83", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -1,3 +1,11 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/12840\n+\t* runtime/memory.c (internal_malloc_size): Return a null pointer\n+\tif the size is zero.\n+\t(internal_free): Do nothing if the pointer is null.\n+\t(internal_realloc_size, internal_realloc, internal_realloc64): New.\n+\n 2005-09-07  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/23262"}, {"sha": "1e1190e472bb203cc20991a309f2c264f82a8812", "filename": "libgfortran/runtime/memory.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25720ba36c2017367b2939cbf1a002694313ab/libgfortran%2Fruntime%2Fmemory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25720ba36c2017367b2939cbf1a002694313ab/libgfortran%2Fruntime%2Fmemory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmemory.c?ref=ec25720ba36c2017367b2939cbf1a002694313ab", "patch": "@@ -141,6 +141,9 @@ internal_malloc_size (size_t size)\n {\n   malloc_t *newmem;\n \n+  if (size == 0)\n+    return 0;\n+\n   newmem = malloc_with_header (size);\n \n   if (!newmem)\n@@ -195,7 +198,7 @@ internal_free (void *mem)\n   malloc_t *m;\n \n   if (!mem)\n-    runtime_error (\"Internal: Possible double free of temporary.\");\n+    return;\n \n   m = DATA_HEADER (mem);\n \n@@ -213,6 +216,67 @@ internal_free (void *mem)\n }\n iexport(internal_free);\n \n+/* Reallocate internal memory MEM so it has SIZE bytes of data.\n+   Allocate a new block if MEM is zero, and free the block if\n+   SIZE is 0.  */\n+\n+static void *\n+internal_realloc_size (void *mem, size_t size)\n+{\n+  malloc_t *m;\n+\n+  if (size == 0)\n+    {\n+      if (mem)\n+\tinternal_free (mem);\n+      return 0;\n+    }\n+\n+  if (mem == 0)\n+    return internal_malloc (size);\n+\n+  m = DATA_HEADER (mem);\n+  if (m->magic != GFC_MALLOC_MAGIC)\n+    runtime_error (\"Internal: No magic memblock marker.  \"\n+\t\t   \"Possible memory corruption\");\n+\n+  m = realloc (m, size + HEADER_SIZE);\n+  if (!m)\n+    os_error (\"Out of memory.\");\n+\n+  m->prev->next = m;\n+  m->next->prev = m;\n+  return DATA_POINTER (m);\n+}\n+\n+extern void *internal_realloc (void *, GFC_INTEGER_4);\n+export_proto(internal_realloc);\n+\n+void *\n+internal_realloc (void *mem, GFC_INTEGER_4 size)\n+{\n+#ifdef GFC_CHECK_MEMORY\n+  /* Under normal circumstances, this is _never_ going to happen!  */\n+  if (size < 0)\n+    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n+#endif\n+  return internal_realloc_size (mem, (size_t) size);\n+}\n+\n+extern void *internal_realloc64 (void *, GFC_INTEGER_8);\n+export_proto(internal_realloc64);\n+\n+void *\n+internal_realloc64 (void *mem, GFC_INTEGER_8 size)\n+{\n+#ifdef GFC_CHECK_MEMORY\n+  /* Under normal circumstances, this is _never_ going to happen!  */\n+  if (size < 0)\n+    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n+#endif\n+  return internal_realloc_size (mem, (size_t) size);\n+}\n+\n \n /* User-allocate, one call for each member of the alloc-list of an\n    ALLOCATE statement. */"}]}