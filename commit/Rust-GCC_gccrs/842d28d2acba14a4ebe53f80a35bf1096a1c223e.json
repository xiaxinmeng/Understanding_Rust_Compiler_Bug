{"sha": "842d28d2acba14a4ebe53f80a35bf1096a1c223e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyZDI4ZDJhY2JhMTRhNGViZTUzZjgwYTM1YmYxMDk2YTFjMjIzZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-03-24T08:40:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-12T08:29:24Z"}, "message": "[Ada] Fix handling of subprograms declared in a protected body\n\n2020-06-12  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Declaration): Do nothing for\n\ta subprogram declared in a protected body.\n\t* exp_ch9.ads, exp_ch9.adb\n\t(Build_Private_Protected_Declaration): Moved to sem_ch6.adb.\n\t(Expand_N_Protected_Body): Do nothing for a subprogram declared\n\tin a protected body.\n\t* sem_ch6.adb (Build_Internal_Protected_Declaration): Moved from\n\texp_ch9.adb and renamed and fixed to ensure in particular that\n\tsuch subprograms have convention Intrinsic and have no protected\n\tversion.\n\t(Analyze_Subprogram_Body_Helper): Call\n\tBuild_Internal_Protected_Declaration.\n\t(Move_Pragmas): Moved up and merged with the more general\n\tversion from Build_Private_Protected_Declaration. We only want\n\tto copy selected pragmas, most pragmas are not suitable for a\n\tcopy on the spec.", "tree": {"sha": "647a2c558f240596d4f385e57faec866e43468f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/647a2c558f240596d4f385e57faec866e43468f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/842d28d2acba14a4ebe53f80a35bf1096a1c223e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842d28d2acba14a4ebe53f80a35bf1096a1c223e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/842d28d2acba14a4ebe53f80a35bf1096a1c223e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842d28d2acba14a4ebe53f80a35bf1096a1c223e/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ca9a460f02fc538d314682f456bf3519f311f97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca9a460f02fc538d314682f456bf3519f311f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca9a460f02fc538d314682f456bf3519f311f97"}], "stats": {"total": 528, "additions": 238, "deletions": 290}, "files": [{"sha": "f4369336e2c0964e280414b63c75a47f6a270d7a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=842d28d2acba14a4ebe53f80a35bf1096a1c223e", "patch": "@@ -6346,19 +6346,6 @@ package body Exp_Ch6 is\n             Analyze (Prot_Decl);\n             Freeze_Before (N, Prot_Id);\n             Set_Protected_Body_Subprogram (Subp, Prot_Id);\n-\n-            --  Create protected operation as well. Even though the operation\n-            --  is only accessible within the body, it is possible to make it\n-            --  available outside of the protected object by using 'Access to\n-            --  provide a callback, so build protected version in all cases.\n-\n-            Prot_Decl :=\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Build_Protected_Sub_Specification (N, Scop, Protected_Mode));\n-            Insert_Before (Prot_Bod, Prot_Decl);\n-            Analyze (Prot_Decl);\n-\n             Pop_Scope;\n          end if;\n "}, {"sha": "83717115ee8712cae7ac7319280652a93fbb6c4a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 39, "deletions": 216, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=842d28d2acba14a4ebe53f80a35bf1096a1c223e", "patch": "@@ -23,7 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n@@ -56,7 +55,6 @@ with Sem_Ch11; use Sem_Ch11;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n-with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -3491,177 +3489,6 @@ package body Exp_Ch9 is\n       Set_Master_Id (Ptr_Typ, Master_Id);\n    end Build_Master_Renaming;\n \n-   -----------------------------------------\n-   -- Build_Private_Protected_Declaration --\n-   -----------------------------------------\n-\n-   function Build_Private_Protected_Declaration\n-     (N : Node_Id) return Entity_Id\n-   is\n-      procedure Analyze_Pragmas (From : Node_Id);\n-      --  Analyze all pragmas which follow arbitrary node From\n-\n-      procedure Move_Pragmas (From : Node_Id; To : Node_Id);\n-      --  Find all suitable source pragmas at the top of subprogram body From's\n-      --  declarations and insert them after arbitrary node To.\n-      --\n-      --  Very similar to Move_Pragmas in sem_ch6 ???\n-\n-      ---------------------\n-      -- Analyze_Pragmas --\n-      ---------------------\n-\n-      procedure Analyze_Pragmas (From : Node_Id) is\n-         Decl : Node_Id;\n-\n-      begin\n-         Decl := Next (From);\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Pragma then\n-               Analyze_Pragma (Decl);\n-\n-            --  No candidate pragmas are available for analysis\n-\n-            else\n-               exit;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-      end Analyze_Pragmas;\n-\n-      ------------------\n-      -- Move_Pragmas --\n-      ------------------\n-\n-      procedure Move_Pragmas (From : Node_Id; To : Node_Id) is\n-         Decl       : Node_Id;\n-         Insert_Nod : Node_Id;\n-         Next_Decl  : Node_Id;\n-\n-      begin\n-         pragma Assert (Nkind (From) = N_Subprogram_Body);\n-\n-         --  The pragmas are moved in an order-preserving fashion\n-\n-         Insert_Nod := To;\n-\n-         --  Inspect the declarations of the subprogram body and relocate all\n-         --  candidate pragmas.\n-\n-         Decl := First (Declarations (From));\n-         while Present (Decl) loop\n-\n-            --  Preserve the following declaration for iteration purposes, due\n-            --  to possible relocation of a pragma.\n-\n-            Next_Decl := Next (Decl);\n-\n-            --  We add an exception here for Unreferenced pragmas since the\n-            --  internally generated spec gets analyzed within\n-            --  Build_Private_Protected_Declaration and will lead to spurious\n-            --  warnings due to the way references are checked.\n-\n-            if Nkind (Decl) = N_Pragma\n-              and then Pragma_Name_Unmapped (Decl) /= Name_Unreferenced\n-            then\n-               Remove (Decl);\n-               Insert_After (Insert_Nod, Decl);\n-               Insert_Nod := Decl;\n-\n-            --  Skip internally generated code\n-\n-            elsif not Comes_From_Source (Decl) then\n-               null;\n-\n-            --  No candidate pragmas are available for relocation\n-\n-            else\n-               exit;\n-            end if;\n-\n-            Decl := Next_Decl;\n-         end loop;\n-      end Move_Pragmas;\n-\n-      --  Local variables\n-\n-      Body_Id  : constant Entity_Id  := Defining_Entity (N);\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      Decl     : Node_Id;\n-      Formal   : Entity_Id;\n-      Formals  : List_Id;\n-      Spec     : Node_Id;\n-      Spec_Id  : Entity_Id;\n-\n-   --  Start of processing for Build_Private_Protected_Declaration\n-\n-   begin\n-      Formal := First_Formal (Body_Id);\n-\n-      --  The protected operation always has at least one formal, namely the\n-      --  object itself, but it is only placed in the parameter list if\n-      --  expansion is enabled.\n-\n-      if Present (Formal) or else Expander_Active then\n-         Formals := Copy_Parameter_List (Body_Id);\n-      else\n-         Formals := No_List;\n-      end if;\n-\n-      Spec_Id :=\n-        Make_Defining_Identifier (Sloc (Body_Id),\n-          Chars => Chars (Body_Id));\n-\n-      --  Indicate that the entity comes from source, to ensure that cross-\n-      --  reference information is properly generated. The body itself is\n-      --  rewritten during expansion, and the body entity will not appear in\n-      --  calls to the operation.\n-\n-      Set_Comes_From_Source (Spec_Id, True);\n-\n-      if Nkind (Specification (N)) = N_Procedure_Specification then\n-         Spec :=\n-           Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Spec_Id,\n-              Parameter_Specifications => Formals);\n-      else\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => Spec_Id,\n-             Parameter_Specifications => Formals,\n-             Result_Definition        =>\n-               New_Occurrence_Of (Etype (Body_Id), Loc));\n-      end if;\n-\n-      Decl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n-      Set_Corresponding_Body (Decl, Body_Id);\n-      Set_Corresponding_Spec (N,    Spec_Id);\n-\n-      Insert_Before (N, Decl);\n-\n-      --  Associate all aspects and pragmas of the body with the spec. This\n-      --  ensures that these annotations apply to the initial declaration of\n-      --  the subprogram body.\n-\n-      Move_Aspects (From => N, To => Decl);\n-      Move_Pragmas (From => N, To => Decl);\n-\n-      Analyze (Decl);\n-\n-      --  The analysis of the spec may generate pragmas which require manual\n-      --  analysis. Since the generation of the spec and the relocation of the\n-      --  annotations is driven by the expansion of the stand-alone body, the\n-      --  pragmas will not be analyzed in a timely manner. Do this now.\n-\n-      Analyze_Pragmas (Decl);\n-\n-      Set_Convention     (Spec_Id, Convention_Protected);\n-      Set_Has_Completion (Spec_Id);\n-\n-      return Spec_Id;\n-   end Build_Private_Protected_Declaration;\n-\n    ---------------------------\n    -- Build_Protected_Entry --\n    ---------------------------\n@@ -8630,6 +8457,7 @@ package body Exp_Ch9 is\n       Disp_Op_Body : Node_Id;\n       New_Op_Body  : Node_Id;\n       Op_Body      : Node_Id;\n+      Op_Decl      : Node_Id;\n       Op_Id        : Entity_Id;\n \n       function Build_Dispatching_Subprogram_Body\n@@ -8766,51 +8594,46 @@ package body Exp_Ch9 is\n                   Current_Node := New_Op_Body;\n                   Analyze (New_Op_Body);\n \n-                  --  Build the corresponding protected operation. It may\n-                  --  appear that this is needed only if this is a visible\n-                  --  operation of the type, or if it is an interrupt handler,\n-                  --  and this was the strategy used previously in GNAT.\n-\n-                  --  However, the operation may be exported through a 'Access\n-                  --  to an external caller. This is the common idiom in code\n-                  --  that uses the Ada 2005 Timing_Events package. As a result\n-                  --  we need to produce the protected body for both visible\n-                  --  and private operations, as well as operations that only\n-                  --  have a body in the source, and for which we create a\n-                  --  declaration in the protected body itself.\n+                  --  Build the corresponding protected operation. This is\n+                  --  needed only if this is a public or private operation of\n+                  --  the type.\n \n                   if Present (Corresponding_Spec (Op_Body)) then\n-                     if Lock_Free_Active then\n-                        New_Op_Body :=\n-                          Build_Lock_Free_Protected_Subprogram_Body\n-                            (Op_Body, Pid, Specification (New_Op_Body));\n-                     else\n-                        New_Op_Body :=\n-                          Build_Protected_Subprogram_Body\n-                            (Op_Body, Pid, Specification (New_Op_Body));\n-                     end if;\n-\n-                     Insert_After (Current_Node, New_Op_Body);\n-                     Analyze (New_Op_Body);\n-\n-                     Current_Node := New_Op_Body;\n-\n-                     --  Generate an overriding primitive operation body for\n-                     --  this subprogram if the protected type implements an\n-                     --  interface.\n-\n-                     if Ada_Version >= Ada_2005\n-                       and then\n-                         Present (Interfaces (Corresponding_Record_Type (Pid)))\n-                     then\n-                        Disp_Op_Body :=\n-                          Build_Dispatching_Subprogram_Body\n-                            (Op_Body, Pid, New_Op_Body);\n-\n-                        Insert_After (Current_Node, Disp_Op_Body);\n-                        Analyze (Disp_Op_Body);\n-\n-                        Current_Node := Disp_Op_Body;\n+                     Op_Decl :=\n+                       Unit_Declaration_Node (Corresponding_Spec (Op_Body));\n+\n+                     if Nkind (Parent (Op_Decl)) = N_Protected_Definition then\n+                        if Lock_Free_Active then\n+                           New_Op_Body :=\n+                             Build_Lock_Free_Protected_Subprogram_Body\n+                               (Op_Body, Pid, Specification (New_Op_Body));\n+                        else\n+                           New_Op_Body :=\n+                             Build_Protected_Subprogram_Body (\n+                               Op_Body, Pid, Specification (New_Op_Body));\n+                        end if;\n+\n+                        Insert_After (Current_Node, New_Op_Body);\n+                        Analyze (New_Op_Body);\n+                        Current_Node := New_Op_Body;\n+\n+                        --  Generate an overriding primitive operation body for\n+                        --  this subprogram if the protected type implements\n+                        --  an interface.\n+\n+                        if Ada_Version >= Ada_2005\n+                          and then Present (Interfaces (\n+                                     Corresponding_Record_Type (Pid)))\n+                        then\n+                           Disp_Op_Body :=\n+                             Build_Dispatching_Subprogram_Body (\n+                               Op_Body, Pid, New_Op_Body);\n+\n+                           Insert_After (Current_Node, Disp_Op_Body);\n+                           Analyze (Disp_Op_Body);\n+\n+                           Current_Node := Disp_Op_Body;\n+                        end if;\n                      end if;\n                   end if;\n                end if;"}, {"sha": "5ba5b9fdd07039c27f85a3ad53a34d7274e30eac", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=842d28d2acba14a4ebe53f80a35bf1096a1c223e", "patch": "@@ -72,17 +72,6 @@ package Exp_Ch9 is\n    --  where _master denotes the task master of the enclosing context. Ins_Nod\n    --  is used to provide a specific insertion node for the renaming.\n \n-   function Build_Private_Protected_Declaration (N : Node_Id) return Entity_Id;\n-   --  A subprogram body without a previous spec that appears in a protected\n-   --  body must be expanded separately to create a subprogram declaration\n-   --  for it, in order to resolve internal calls to it from other protected\n-   --  operations. It would seem that no locking version of the operation is\n-   --  needed, but in fact, in Ada 2005 the subprogram may be used in a call-\n-   --  back, and therefore a protected version of the operation must be\n-   --  generated as well.\n-   --\n-   --  Possibly factor this with Exp_Dist.Copy_Specification ???\n-\n    function Build_Protected_Sub_Specification\n      (N        : Node_Id;\n       Prot_Typ : Entity_Id;"}, {"sha": "51724ff0ea3c12a9c627d3ff2df4a9f2311aec29", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 199, "deletions": 50, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842d28d2acba14a4ebe53f80a35bf1096a1c223e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=842d28d2acba14a4ebe53f80a35bf1096a1c223e", "patch": "@@ -2504,6 +2504,15 @@ package body Sem_Ch6 is\n       --  because it is specified directly on the body, or because it is\n       --  inherited from the enclosing subprogram or package.\n \n+      function Build_Internal_Protected_Declaration\n+        (N : Node_Id) return Entity_Id;\n+      --  A subprogram body without a previous spec that appears in a protected\n+      --  body must be expanded separately to create a subprogram declaration\n+      --  for it, in order to resolve internal calls to it from other protected\n+      --  operations.\n+      --\n+      --  Possibly factor this with Exp_Dist.Copy_Specification ???\n+\n       procedure Build_Subprogram_Declaration;\n       --  Create a matching subprogram declaration for subprogram body N\n \n@@ -2552,6 +2561,12 @@ package body Sem_Ch6 is\n       --  the not-yet-frozen types referenced by the simple return statement\n       --  of the function as formally frozen.\n \n+      procedure Move_Pragmas (From : Node_Id; To : Node_Id);\n+      --  Find all suitable source pragmas at the top of subprogram body\n+      --  From's declarations and move them after arbitrary node To.\n+      --  One exception is pragma SPARK_Mode which is copied rather than moved,\n+      --  as it applies to the body too.\n+\n       procedure Restore_Limited_Views (Restore_List : Elist_Id);\n       --  Undo the transformation done by Exchange_Limited_Views.\n \n@@ -2664,68 +2679,129 @@ package body Sem_Ch6 is\n          return SPARK_Mode = On;\n       end Body_Has_SPARK_Mode_On;\n \n-      ----------------------------------\n-      -- Build_Subprogram_Declaration --\n-      ----------------------------------\n+      ------------------------------------------\n+      -- Build_Internal_Protected_Declaration --\n+      ------------------------------------------\n \n-      procedure Build_Subprogram_Declaration is\n-         procedure Move_Pragmas (From : Node_Id; To : Node_Id);\n-         --  Relocate certain categorization pragmas from the declarative list\n-         --  of subprogram body From and insert them after node To. The pragmas\n-         --  in question are:\n-         --    Ghost\n-         --    Volatile_Function\n-         --  Also copy pragma SPARK_Mode if present in the declarative list\n-         --  of subprogram body From and insert it after node To. This pragma\n-         --  should not be moved, as it applies to the body too.\n+      function Build_Internal_Protected_Declaration\n+        (N : Node_Id) return Entity_Id\n+      is\n+         procedure Analyze_Pragmas (From : Node_Id);\n+         --  Analyze all pragmas which follow arbitrary node From\n \n-         ------------------\n-         -- Move_Pragmas --\n-         ------------------\n+         ---------------------\n+         -- Analyze_Pragmas --\n+         ---------------------\n \n-         procedure Move_Pragmas (From : Node_Id; To : Node_Id) is\n-            Decl      : Node_Id;\n-            Next_Decl : Node_Id;\n+         procedure Analyze_Pragmas (From : Node_Id) is\n+            Decl : Node_Id;\n \n          begin\n-            pragma Assert (Nkind (From) = N_Subprogram_Body);\n-\n-            --  The destination node must be part of a list, as the pragmas are\n-            --  inserted after it.\n-\n-            pragma Assert (Is_List_Member (To));\n-\n-            --  Inspect the declarations of the subprogram body looking for\n-            --  specific pragmas.\n-\n-            Decl := First (Declarations (N));\n+            Decl := Next (From);\n             while Present (Decl) loop\n-               Next_Decl := Next (Decl);\n-\n                if Nkind (Decl) = N_Pragma then\n-                  if Pragma_Name_Unmapped (Decl) = Name_SPARK_Mode then\n-                     Insert_After (To, New_Copy_Tree (Decl));\n+                  Analyze_Pragma (Decl);\n \n-                  elsif Nam_In (Pragma_Name_Unmapped (Decl),\n-                                Name_Ghost,\n-                                Name_Volatile_Function)\n-                  then\n-                     Remove (Decl);\n-                     Insert_After (To, Decl);\n-                  end if;\n+               --  No candidate pragmas are available for analysis\n+\n+               else\n+                  exit;\n                end if;\n \n-               Decl := Next_Decl;\n+               Next (Decl);\n             end loop;\n-         end Move_Pragmas;\n+         end Analyze_Pragmas;\n \n          --  Local variables\n \n+         Body_Id  : constant Entity_Id  := Defining_Entity (N);\n+         Loc      : constant Source_Ptr := Sloc (N);\n+         Decl     : Node_Id;\n+         Formal   : Entity_Id;\n+         Formals  : List_Id;\n+         Spec     : Node_Id;\n+         Spec_Id  : Entity_Id;\n+\n+      --  Start of processing for Build_Internal_Protected_Declaration\n+\n+      begin\n+         Formal := First_Formal (Body_Id);\n+\n+         --  The protected operation always has at least one formal, namely the\n+         --  object itself, but it is only placed in the parameter list if\n+         --  expansion is enabled.\n+\n+         if Present (Formal) or else Expander_Active then\n+            Formals := Copy_Parameter_List (Body_Id);\n+         else\n+            Formals := No_List;\n+         end if;\n+\n+         Spec_Id :=\n+           Make_Defining_Identifier (Sloc (Body_Id),\n+             Chars => Chars (Body_Id));\n+\n+         --  Indicate that the entity comes from source, to ensure that cross-\n+         --  reference information is properly generated. The body itself is\n+         --  rewritten during expansion, and the body entity will not appear in\n+         --  calls to the operation.\n+\n+         Set_Comes_From_Source (Spec_Id, True);\n+\n+         if Nkind (Specification (N)) = N_Procedure_Specification then\n+            Spec :=\n+              Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name       => Spec_Id,\n+                 Parameter_Specifications => Formals);\n+         else\n+            Spec :=\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name       => Spec_Id,\n+                Parameter_Specifications => Formals,\n+                Result_Definition        =>\n+                  New_Occurrence_Of (Etype (Body_Id), Loc));\n+         end if;\n+\n+         Decl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n+         Set_Corresponding_Body (Decl, Body_Id);\n+         Set_Corresponding_Spec (N,    Spec_Id);\n+\n+         Insert_Before (N, Decl);\n+\n+         --  Associate all aspects and pragmas of the body with the spec. This\n+         --  ensures that these annotations apply to the initial declaration of\n+         --  the subprogram body.\n+\n+         Move_Aspects (From => N, To => Decl);\n+         Move_Pragmas (From => N, To => Decl);\n+\n+         Analyze (Decl);\n+\n+         --  The analysis of the spec may generate pragmas which require manual\n+         --  analysis. Since the generation of the spec and the relocation of\n+         --  the annotations is driven by the expansion of the stand-alone\n+         --  body, the pragmas will not be analyzed in a timely manner. Do this\n+         --  now.\n+\n+         Analyze_Pragmas (Decl);\n+\n+         --  This subprogram has convention Intrinsic as per RM 6.3.1(10/2)\n+         --  ensuring in particular that 'Access is illegal.\n+\n+         Set_Convention     (Spec_Id, Convention_Intrinsic);\n+         Set_Has_Completion (Spec_Id);\n+\n+         return Spec_Id;\n+      end Build_Internal_Protected_Declaration;\n+\n+      ----------------------------------\n+      -- Build_Subprogram_Declaration --\n+      ----------------------------------\n+\n+      procedure Build_Subprogram_Declaration is\n          Decl      : Node_Id;\n          Subp_Decl : Node_Id;\n \n-      --  Start of processing for Build_Subprogram_Declaration\n-\n       begin\n          --  Create a matching subprogram spec using the profile of the body.\n          --  The structure of the tree is identical, but has new entities for\n@@ -3376,6 +3452,77 @@ package body Sem_Ch6 is\n          return Result;\n       end Mask_Unfrozen_Types;\n \n+      ------------------\n+      -- Move_Pragmas --\n+      ------------------\n+\n+      procedure Move_Pragmas (From : Node_Id; To : Node_Id) is\n+         Decl       : Node_Id;\n+         Insert_Nod : Node_Id;\n+         Next_Decl  : Node_Id;\n+\n+      begin\n+         pragma Assert (Nkind (From) = N_Subprogram_Body);\n+\n+         --  The pragmas are moved in an order-preserving fashion\n+\n+         Insert_Nod := To;\n+\n+         --  Inspect the declarations of the subprogram body and relocate all\n+         --  candidate pragmas.\n+\n+         Decl := First (Declarations (From));\n+         while Present (Decl) loop\n+\n+            --  Preserve the following declaration for iteration purposes, due\n+            --  to possible relocation of a pragma.\n+\n+            Next_Decl := Next (Decl);\n+\n+            if Nkind (Decl) = N_Pragma then\n+               --  Copy pragma SPARK_Mode if present in the declarative list\n+               --  of subprogram body From and insert it after node To. This\n+               --  pragma should not be moved, as it applies to the body too.\n+\n+               if Pragma_Name_Unmapped (Decl) = Name_SPARK_Mode then\n+                  Insert_After (Insert_Nod, New_Copy_Tree (Decl));\n+\n+               --  Move relevant pragmas to the spec\n+\n+               elsif Nam_In (Pragma_Name_Unmapped (Decl),\n+                             Name_Depends,\n+                             Name_Ghost,\n+                             Name_Global,\n+                             Name_Pre,\n+                             Name_Precondition,\n+                             Name_Post,\n+                             Name_Refined_Depends,\n+                             Name_Refined_Global,\n+                             Name_Refined_Post,\n+                             Name_Inline,\n+                             Name_Pure_Function,\n+                             Name_Volatile_Function)\n+               then\n+                  Remove (Decl);\n+                  Insert_After (Insert_Nod, Decl);\n+                  Insert_Nod := Decl;\n+               end if;\n+\n+            --  Skip internally generated code\n+\n+            elsif not Comes_From_Source (Decl) then\n+               null;\n+\n+            --  No candidate pragmas are available for relocation\n+\n+            else\n+               exit;\n+            end if;\n+\n+            Decl := Next_Decl;\n+         end loop;\n+      end Move_Pragmas;\n+\n       ---------------------------\n       -- Restore_Limited_Views --\n       ---------------------------\n@@ -3668,6 +3815,8 @@ package body Sem_Ch6 is\n                --  are legal and can be processed ahead of the body.\n                --  We make two copies of the given spec, one for the new\n                --  declaration, and one for the body.\n+               --  ??? This should be conditioned on front-end inlining rather\n+               --  than GNATprove_Mode.\n \n                if No (Spec_Id) and then GNATprove_Mode\n \n@@ -3708,7 +3857,7 @@ package body Sem_Ch6 is\n                   Build_Subprogram_Declaration;\n \n                --  If this is a function that returns a constrained array, and\n-               --  we are generating SPARK_For_C, create subprogram declaration\n+               --  we are generating C code, create subprogram declaration\n                --  to simplify subsequent C generation.\n \n                elsif No (Spec_Id)\n@@ -3795,15 +3944,15 @@ package body Sem_Ch6 is\n \n       --  Deal with special case of a fully private operation in the body of\n       --  the protected type. We must create a declaration for the subprogram,\n-      --  in order to attach the protected subprogram that will be used in\n-      --  internal calls. We exclude compiler generated bodies from the\n-      --  expander since the issue does not arise for those cases.\n+      --  in order to attach the subprogram that will be used in internal\n+      --  calls. We exclude compiler generated bodies from the expander since\n+      --  the issue does not arise for those cases.\n \n       if No (Spec_Id)\n         and then Comes_From_Source (N)\n         and then Is_Protected_Type (Current_Scope)\n       then\n-         Spec_Id := Build_Private_Protected_Declaration (N);\n+         Spec_Id := Build_Internal_Protected_Declaration (N);\n       end if;\n \n       --  If we are generating C and this is a function returning a constrained"}]}