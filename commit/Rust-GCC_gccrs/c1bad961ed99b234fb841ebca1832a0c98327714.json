{"sha": "c1bad961ed99b234fb841ebca1832a0c98327714", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiYWQ5NjFlZDk5YjIzNGZiODQxZWJjYTE4MzJhMGM5ODMyNzcxNA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-03-15T12:18:47Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-03-15T12:18:47Z"}, "message": "Makefile.in: Update.\n\n\t* Makefile.in: Update.\n\t* c-common.h (cb_register_builtins): Rename c_cpp_builtins.\n\t* c-lex.c (init_c_lex): Register builtins hook is dead.\n\t* c-opts.c (COMMAND_LINE_OPTIONS, missing_arg): Handle -A, -D and -U.\n\t(c_common_decode_option): Don't call cpp_handle_option.\n\tHandle -A, -D and -U.\n\t(handle_deferred_opts): Simplify.\n\t(finish_options): Define builtins and command line macros.\n\t* c-ppoutput.c (init_pp_output): Register builtins hook is dead.\n\t* cppinit.c: Don't include intl.h.\n\t(init_builtins): Rename cpp_init_builtins.  No hook to call.\n\t(init_library): Don't need to sort options.\n\t(cpp_create_reader): Don't set pending.\n\t(cpp_destroy): Don't free pending.\n\t(struct pending_option, cl_directive_handler, struct cpp_pending,\n\tAPPEND, free_chain, new_pending_directive, parse_option, opt_comp,\n\tcpp_finish_options, COMMAND_LINE_OPTIONS, DEF_OPT, struct cl_option,\n\tcl_options, cpp_handle_option): Remove.\n\t* cpplib.h (struct cpp_pending, register_builtins, cpp_handle_option,\n\tcpp_finish_options): Remove.\n\t(cpp_init_builtins): New.\n\t* fix-header.c (read_scan_file): Update to handle -D.  Fix\n\thandling of -I.  Replace call to cpp_finish_options.\ncp:\n\t* Make-lang.in: Update.\n\nFrom-SVN: r64398", "tree": {"sha": "9ab94f87b27944c394c8bce04fc6f0433140ed8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ab94f87b27944c394c8bce04fc6f0433140ed8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1bad961ed99b234fb841ebca1832a0c98327714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bad961ed99b234fb841ebca1832a0c98327714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bad961ed99b234fb841ebca1832a0c98327714", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bad961ed99b234fb841ebca1832a0c98327714/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e049fcd1f2935275f6e567dc902c5929c923ce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e049fcd1f2935275f6e567dc902c5929c923ce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e049fcd1f2935275f6e567dc902c5929c923ce6"}], "stats": {"total": 492, "additions": 121, "deletions": 371}, "files": [{"sha": "51da75e52d0d861a601724188528c011f61c9b21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -1,3 +1,29 @@\n+2003-03-15  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in: Update.\n+\t* c-common.h (cb_register_builtins): Rename c_cpp_builtins.\n+\t* c-lex.c (init_c_lex): Register builtins hook is dead.\n+\t* c-opts.c (COMMAND_LINE_OPTIONS, missing_arg): Handle -A, -D and -U.\n+\t(c_common_decode_option): Don't call cpp_handle_option.\n+\tHandle -A, -D and -U.\n+\t(handle_deferred_opts): Simplify.\n+\t(finish_options): Define builtins and command line macros.\n+\t* c-ppoutput.c (init_pp_output): Register builtins hook is dead.\n+\t* cppinit.c: Don't include intl.h.\n+\t(init_builtins): Rename cpp_init_builtins.  No hook to call.\n+\t(init_library): Don't need to sort options.\n+\t(cpp_create_reader): Don't set pending.\n+\t(cpp_destroy): Don't free pending.\n+\t(struct pending_option, cl_directive_handler, struct cpp_pending,\n+\tAPPEND, free_chain, new_pending_directive, parse_option, opt_comp,\n+\tcpp_finish_options, COMMAND_LINE_OPTIONS, DEF_OPT, struct cl_option,\n+\tcl_options, cpp_handle_option): Remove.\n+\t* cpplib.h (struct cpp_pending, register_builtins, cpp_handle_option,\n+\tcpp_finish_options): Remove.\n+\t(cpp_init_builtins): New.\n+\t* fix-header.c (read_scan_file): Update to handle -D.  Fix\n+\thandling of -I.  Replace call to cpp_finish_options.\n+\n 2003-03-15  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \tPR optimization/9387"}, {"sha": "6d088b0d083ba2f45f5ce8fc75868e9d59f6e88a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -789,7 +789,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n-  c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o \\\n+  c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n   c-objc-common.o c-dump.o c-pch.o libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n@@ -2315,7 +2315,7 @@ PREPROCESSOR_DEFINES = \\\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n \t\tcpphash.o cpperror.o cppinit.o \\\n-\t\thashtable.o line-map.o mkdeps.o prefix.o mbchar.o cpppch.o\n+\t\thashtable.o line-map.o mkdeps.o mbchar.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n \t\t$(OBSTACK_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n@@ -2335,7 +2335,7 @@ cpplib.o:   cpplib.c   $(LIBCPP_DEPS)\n cpphash.o:  cpphash.c  $(LIBCPP_DEPS)\n cpptrad.o:  cpptrad.c  $(LIBCPP_DEPS)\n cppfiles.o: cppfiles.c $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n-cppinit.o:  cppinit.c  $(LIBCPP_DEPS) mkdeps.h prefix.h\n+cppinit.o:  cppinit.c  $(LIBCPP_DEPS) mkdeps.h\n cpppch.o:   cpppch.c   $(LIBCPP_DEPS) mkdeps.h\n \n cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -2553,9 +2553,9 @@ xsys-protos.h: $(GCC_PASSES) $(srcdir)/sys-protos.h deduced.h gen-protos$(build_\n # This is nominally a 'build' program, but it's run only when host==build,\n # so we can (indeed, must) use $(LIBDEPS) and $(LIBS).\n fix-header$(build_exeext): fix-header.o scan-decls.o scan.o xsys-protos.h \\\n-           c-incpath.o cppdefault.o $(LIBDEPS) libcpp.a\n+           c-incpath.o cppdefault.o prefix.o $(LIBDEPS) libcpp.a\n \t$(BUILD_CC) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ fix-header.o \\\n-\t   c-incpath.o cppdefault.o scan-decls.o scan.o libcpp.a $(LIBS)\n+\tc-incpath.o cppdefault.o scan-decls.o prefix.o scan.o libcpp.a $(LIBS)\n \n fix-header.o: fix-header.c $(OBSTACK_H) scan.h \\\n \txsys-protos.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(CPPLIB_H)"}, {"sha": "b4a14a39b1c011403a34e64cab1537ff07e24341", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -1263,7 +1263,7 @@ extern int c_common_unsafe_for_reeval\t\tPARAMS ((tree));\n \n extern void init_c_lex\t\t\t\tPARAMS ((void));\n \n-extern void cb_register_builtins\t\tPARAMS ((cpp_reader *));\n+extern void c_cpp_builtins\t\t\tPARAMS ((cpp_reader *));\n \n /* Positive if an implicit `extern \"C\"' scope has just been entered;\n    negative if such a scope has just been exited.  */"}, {"sha": "060a7b17a30da9bef011071968d2a13ec926db4d", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -281,7 +281,7 @@ define__GNUC__ ()\n \n /* Hook that registers front end and target-specific built-ins.  */\n void\n-cb_register_builtins (pfile)\n+c_cpp_builtins (pfile)\n      cpp_reader *pfile;\n {\n   /* -undef turns off target-specific built-ins.  */"}, {"sha": "95419c5b37ec263a502e6f8ef82c985901f04581", "filename": "gcc/c-lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -112,7 +112,6 @@ init_c_lex ()\n   \n   cb = cpp_get_callbacks (parse_in);\n \n-  cb->register_builtins = cb_register_builtins;\n   cb->line_change = cb_line_change;\n   cb->ident = cb_ident;\n   cb->def_pragma = cb_def_pragma;"}, {"sha": "adab26d719590521745748afe3890d3fd0219bf5", "filename": "gcc/c-opts.c", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -149,8 +149,10 @@ static void finish_options PARAMS ((void));\n #define COMMAND_LINE_OPTIONS\t\t\t\t\t\t     \\\n   OPT(\"-help\",                  CL_ALL,   OPT__help)\t\t\t     \\\n   OPT(\"-output-pch=\",\t\tCL_ALL | CL_ARG, OPT__output_pch)\t     \\\n+  OPT(\"A\",                      CL_ALL | CL_ARG, OPT_A)\t\t\t     \\\n   OPT(\"C\",                      CL_ALL,   OPT_C)\t\t\t     \\\n   OPT(\"CC\",                     CL_ALL,   OPT_CC)\t\t\t     \\\n+  OPT(\"D\",                      CL_ALL | CL_ARG, OPT_D)\t\t\t     \\\n   OPT(\"E\",\t\t\tCL_ALL,   OPT_E)\t\t\t     \\\n   OPT(\"H\",                      CL_ALL,   OPT_H)\t\t\t     \\\n   OPT(\"I\",                      CL_ALL | CL_ARG, OPT_I)\t\t\t     \\\n@@ -164,6 +166,7 @@ static void finish_options PARAMS ((void));\n   OPT(\"MQ\",                     CL_ALL | CL_ARG, OPT_MQ)\t\t     \\\n   OPT(\"MT\",                     CL_ALL | CL_ARG, OPT_MT)\t\t     \\\n   OPT(\"P\",                      CL_ALL,   OPT_P)\t\t\t     \\\n+  OPT(\"U\",                      CL_ALL | CL_ARG, OPT_U)\t\t\t     \\\n   OPT(\"Wabi\",                   CL_CXX,   OPT_Wabi)                          \\\n   OPT(\"Wall\",\t\t\tCL_ALL,   OPT_Wall)\t\t\t     \\\n   OPT(\"Wbad-function-cast\",\tCL_C,     OPT_Wbad_function_cast)\t     \\\n@@ -413,6 +416,15 @@ missing_arg (opt_index)\n       error (\"no class name specified with \\\"-%s\\\"\", opt_text);\n       break;\n \n+    case OPT_A:\n+      error (\"assertion missing after \\\"-%s\\\"\", opt_text);\n+      break;\n+\n+    case OPT_D:\n+    case OPT_U:\n+      error (\"macro name missing after \\\"-%s\\\"\", opt_text);\n+      break;\n+\n     case OPT_I:\n     case OPT_idirafter:\n     case OPT_isysroot:\n@@ -595,7 +607,7 @@ c_common_decode_option (argc, argv)\n   const char *opt, *arg = 0;\n   char *dup = 0;\n   bool on = true;\n-  int result, lang_flag;\n+  int result = 0, lang_flag;\n   const struct cl_option *option;\n   enum opt_code code;\n \n@@ -632,8 +644,6 @@ c_common_decode_option (argc, argv)\n       on = false;\n     }\n \n-  result = cpp_handle_option (parse_in, argc, argv);\n-\n   /* Skip over '-'.  */\n   lang_flag = lang_flags[(c_language << 1) + flag_objc];\n   opt_index = find_opt (opt + 1, lang_flag);\n@@ -694,6 +704,10 @@ c_common_decode_option (argc, argv)\n       pch_file = arg;\n       break;\n \n+    case OPT_A:\n+      defer_opt (code, arg);\n+      break;\n+\n     case OPT_C:\n       cpp_opts->discard_comments = 0;\n       break;\n@@ -703,6 +717,10 @@ c_common_decode_option (argc, argv)\n       cpp_opts->discard_comments_in_macro_exp = 0;\n       break;\n \n+    case OPT_D:\n+      defer_opt (code, arg);\n+      break;\n+\n     case OPT_E:\n       flag_preprocess_only = 1;\n       break;\n@@ -765,6 +783,10 @@ c_common_decode_option (argc, argv)\n       flag_no_line_commands = 1;\n       break;\n \n+    case OPT_U:\n+      defer_opt (code, arg);\n+      break;\n+\n     case OPT_Wabi:\n       warn_abi = on;\n       break;\n@@ -1689,20 +1711,8 @@ handle_deferred_opts ()\n     {\n       struct deferred_opt *opt = &deferred_opts[i];\n \n-      switch (opt->code)\n-\t{\n-\tcase OPT_MT:\n-\tcase OPT_MQ:\n-\t  cpp_add_dependency_target (parse_in, opt->arg, opt->code == OPT_MQ);\n-\t  break;\n-\n-\tcase OPT_include:\n-\tcase OPT_imacros:\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      if (opt->code == OPT_MT || opt->code == OPT_MQ)\n+\tcpp_add_dependency_target (parse_in, opt->arg, opt->code == OPT_MQ);\n     }\n }\n \n@@ -1765,13 +1775,32 @@ add_prefixed_path (suffix, chain)\n static void\n finish_options ()\n {\n-  cpp_finish_options (parse_in);\n-\n   if (!cpp_opts->preprocessed)\n     {\n-      unsigned int i;\n+      size_t i;\n+\n+      cpp_rename_file (parse_in, _(\"<built-in>\"));\n+      cpp_init_builtins (parse_in);\n+      c_cpp_builtins (parse_in);\n+      cpp_rename_file (parse_in, _(\"<command line>\"));\n+      for (i = 0; i < deferred_count; i++)\n+\t{\n+\t  struct deferred_opt *opt = &deferred_opts[i];\n+\n+\t  if (opt->code == OPT_D)\n+\t    cpp_define (parse_in, opt->arg);\n+\t  else if (opt->code == OPT_U)\n+\t    cpp_undef (parse_in, opt->arg);\n+\t  else if (opt->code == OPT_A)\n+\t    {\n+\t      if (opt->arg[0] == '-')\n+\t\tcpp_unassert (parse_in, opt->arg + 1);\n+\t      else\n+\t\tcpp_assert (parse_in, opt->arg);\n+\t    }\n+\t}\n \n-      /* Handle -imacros after -D, -U and -A.  */\n+      /* Handle -imacros after -D and -U.  */\n       for (i = 0; i < deferred_count; i++)\n \t{\n \t  struct deferred_opt *opt = &deferred_opts[i];"}, {"sha": "69eec220a90b17204969a6c13f16bb1cbf2457a8", "filename": "gcc/c-ppoutput.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -95,8 +95,6 @@ init_pp_output (out_stream)\n {\n   cpp_callbacks *cb = cpp_get_callbacks (parse_in);\n \n-  cb->register_builtins = cb_register_builtins;\n-\n   if (!flag_no_output)\n     {\n       cb->line_change = cb_line_change;"}, {"sha": "1fec2a5d69068884fb5681b9a33c75b2320b209d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -1,3 +1,7 @@\n+2003-03-15  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Make-lang.in: Update.\n+\n 2003-03-15  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/6440"}, {"sha": "3f9695ad0023fa2d0f99f81cacc2cdf740f0da15", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -80,7 +80,7 @@ g++-cross$(exeext): g++$(exeext)\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n \tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \\\n-\tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o\n+\tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\"}, {"sha": "abfcc50eadc54c0d5ec48e4676c28d8950c059fa", "filename": "gcc/cppinit.c", "status": "modified", "additions": 5, "deletions": 309, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -25,53 +25,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"tm.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n-#include \"intl.h\"\n #include \"mkdeps.h\"\n \n-/* Internal structures and prototypes.  */\n-\n-/* A `struct pending_option' remembers one -D, -A, -U, -include, or\n-   -imacros switch.  */\n-typedef void (* cl_directive_handler) PARAMS ((cpp_reader *, const char *));\n-struct pending_option\n-{\n-  struct pending_option *next;\n-  const char *arg;\n-  cl_directive_handler handler;\n-};\n-\n-/* The `pending' structure accumulates all the options that are not\n-   actually processed until we hit cpp_read_main_file.  It consists of\n-   several lists, one for each type of option.  We keep both head and\n-   tail pointers for quick insertion.  */\n-struct cpp_pending\n-{\n-  struct pending_option *directive_head, *directive_tail;\n-};\n-\n-#ifdef __STDC__\n-#define APPEND(pend, list, elt) \\\n-  do {  if (!(pend)->list##_head) (pend)->list##_head = (elt); \\\n-\telse (pend)->list##_tail->next = (elt); \\\n-\t(pend)->list##_tail = (elt); \\\n-  } while (0)\n-#else\n-#define APPEND(pend, list, elt) \\\n-  do {  if (!(pend)->list/**/_head) (pend)->list/**/_head = (elt); \\\n-\telse (pend)->list/**/_tail->next = (elt); \\\n-\t(pend)->list/**/_tail = (elt); \\\n-  } while (0)\n-#endif\n-\n static void init_library\t\tPARAMS ((void));\n-static void init_builtins\t\tPARAMS ((cpp_reader *));\n static void mark_named_operators\tPARAMS ((cpp_reader *));\n-static void free_chain\t\t\tPARAMS ((struct pending_option *));\n static void read_original_filename\tPARAMS ((cpp_reader *));\n-static void new_pending_directive\tPARAMS ((struct cpp_pending *,\n-\t\t\t\t\t\t const char *,\n-\t\t\t\t\t\t cl_directive_handler));\n-static int parse_option\t\t\tPARAMS ((const char *));\n static void post_options\t\tPARAMS ((cpp_reader *));\n \n /* If we have designated initializers (GCC >2.7) these tables can be\n@@ -153,21 +111,7 @@ cpp_set_lang (pfile, lang)\n   CPP_OPTION (pfile, digraphs)\t\t = l->digraphs;\n }\n \n-#ifdef HOST_EBCDIC\n-static int opt_comp PARAMS ((const void *, const void *));\n-\n-/* Run-time sorting of options array.  */\n-static int\n-opt_comp (p1, p2)\n-     const void *p1, *p2;\n-{\n-  return strcmp (((struct cl_option *) p1)->opt_text,\n-\t\t ((struct cl_option *) p2)->opt_text);\n-}\n-#endif\n-\n-/* init initializes library global state.  It might not need to\n-   do anything depending on the platform and compiler.  */\n+/* Initialize library global state.  */\n static void\n init_library ()\n {\n@@ -177,12 +121,6 @@ init_library ()\n     {\n       initialized = 1;\n \n-#ifdef HOST_EBCDIC\n-      /* For non-ASCII hosts, the cl_options array needs to be sorted at\n-\t runtime.  */\n-      qsort (cl_options, N_OPTS, sizeof (struct cl_option), opt_comp);\n-#endif\n-\n       /* Set up the trigraph map.  This doesn't need to do anything if\n \t we were compiled with a compiler that supports C99 designated\n \t initializers.  */\n@@ -216,9 +154,6 @@ cpp_create_reader (lang)\n   CPP_OPTION (pfile, warn_deprecated) = 1;\n   CPP_OPTION (pfile, warn_long_long) = !CPP_OPTION (pfile, c99);\n \n-  CPP_OPTION (pfile, pending) =\n-    (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n-\n   /* Default CPP arithmetic to something sensible for the host for the\n      benefit of dumb users like fix-header.  */\n   CPP_OPTION (pfile, precision) = CHAR_BIT * sizeof (long);\n@@ -276,7 +211,6 @@ cpp_destroy (pfile)\n   cpp_context *context, *contextn;\n   tokenrun *run, *runn;\n \n-  free (CPP_OPTION (pfile, pending));\n   free (pfile->op_stack);\n \n   while (CPP_BUFFER (pfile) != NULL)\n@@ -391,10 +325,10 @@ mark_named_operators (pfile)\n     }\n }\n \n-/* Subroutine of cpp_read_main_file; reads the builtins table above and\n-   enters them, and language-specific macros, into the hash table.  */\n-static void\n-init_builtins (pfile)\n+/* Read the builtins table above and enter them, and language-specific\n+   macros, into the hash table.  */\n+void\n+cpp_init_builtins (pfile)\n      cpp_reader *pfile;\n {\n   const struct builtin *b;\n@@ -422,24 +356,6 @@ init_builtins (pfile)\n \n   if (CPP_OPTION (pfile, objc))\n     _cpp_define_builtin (pfile, \"__OBJC__ 1\");\n-\n-  if (pfile->cb.register_builtins)\n-    (*pfile->cb.register_builtins) (pfile);\n-}\n-\n-/* Frees a pending_option chain.  */\n-static void\n-free_chain (head)\n-     struct pending_option *head;\n-{\n-  struct pending_option *next;\n-\n-  while (head)\n-    {\n-      next = head->next;\n-      free (head);\n-      head = next;\n-    }\n }\n \n /* Sanity-checks are dependent on command-line options, so it is\n@@ -587,29 +503,6 @@ read_original_filename (pfile)\n   _cpp_backup_tokens (pfile, 1);\n }\n \n-/* Handle pending command line options: -D, -U, -A, -imacros and\n-   -include.  This should be called after debugging has been properly\n-   set up in the front ends.  */\n-void\n-cpp_finish_options (pfile)\n-     cpp_reader *pfile;\n-{\n-  /* Install builtins and process command line macros etc. in the order\n-     they appeared, but only if not already preprocessed.  */\n-  if (! CPP_OPTION (pfile, preprocessed))\n-    {\n-      struct pending_option *p;\n-\n-      _cpp_do_file_change (pfile, LC_RENAME, _(\"<built-in>\"), 1, 0);\n-      init_builtins (pfile);\n-      _cpp_do_file_change (pfile, LC_RENAME, _(\"<command line>\"), 1, 0);\n-      for (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n-\t(*p->handler) (pfile, p->arg);\n-    }\n-\n-  free_chain (CPP_OPTION (pfile, pending)->directive_head);\n-}\n-\n /* This is called at the end of preprocessing.  It pops the last\n    buffer and writes dependency output, and returns the number of\n    errors.\n@@ -650,203 +543,6 @@ cpp_finish (pfile, deps_stream)\n   return pfile->errors;\n }\n \n-/* Add a directive to be handled later in the initialization phase.  */\n-static void\n-new_pending_directive (pend, text, handler)\n-     struct cpp_pending *pend;\n-     const char *text;\n-     cl_directive_handler handler;\n-{\n-  struct pending_option *o = (struct pending_option *)\n-    xmalloc (sizeof (struct pending_option));\n-\n-  o->arg = text;\n-  o->next = NULL;\n-  o->handler = handler;\n-  APPEND (pend, directive, o);\n-}\n-\n-/* Irix6 \"cc -n32\" and OSF4 cc have problems with char foo[] = (\"string\");\n-   I.e. a const string initializer with parens around it.  That is\n-   what N_(\"string\") resolves to, so we make no_* be macros instead.  */\n-#define no_ass N_(\"assertion missing after %s\")\n-#define no_mac N_(\"macro name missing after %s\")\n-\n-/* This is the list of all command line options, with the leading\n-   \"-\" removed.  It must be sorted in ASCII collating order.  */\n-#define COMMAND_LINE_OPTIONS                                                  \\\n-  DEF_OPT(\"A\",                        no_ass, OPT_A)                          \\\n-  DEF_OPT(\"D\",                        no_mac, OPT_D)                          \\\n-  DEF_OPT(\"U\",                        no_mac, OPT_U)                          \\\n-\n-\n-#define DEF_OPT(text, msg, code) code,\n-enum opt_code\n-{\n-  COMMAND_LINE_OPTIONS\n-  N_OPTS\n-};\n-#undef DEF_OPT\n-\n-struct cl_option\n-{\n-  const char *opt_text;\n-  const char *msg;\n-  size_t opt_len;\n-  enum opt_code opt_code;\n-};\n-\n-#define DEF_OPT(text, msg, code) { text, msg, sizeof(text) - 1, code },\n-#ifdef HOST_EBCDIC\n-static struct cl_option cl_options[] =\n-#else\n-static const struct cl_option cl_options[] =\n-#endif\n-{\n-  COMMAND_LINE_OPTIONS\n-};\n-#undef DEF_OPT\n-#undef COMMAND_LINE_OPTIONS\n-\n-/* Perform a binary search to find which, if any, option the given\n-   command-line matches.  Returns its index in the option array,\n-   negative on failure.  Complications arise since some options can be\n-   suffixed with an argument, and multiple complete matches can occur,\n-   e.g. -pedantic and -pedantic-errors.  */\n-static int\n-parse_option (input)\n-     const char *input;\n-{\n-  unsigned int md, mn, mx;\n-  size_t opt_len;\n-  int comp;\n-\n-  mn = 0;\n-  mx = N_OPTS;\n-\n-  while (mx > mn)\n-    {\n-      md = (mn + mx) / 2;\n-\n-      opt_len = cl_options[md].opt_len;\n-      comp = strncmp (input, cl_options[md].opt_text, opt_len);\n-\n-      if (comp > 0)\n-\tmn = md + 1;\n-      else if (comp < 0)\n-\tmx = md;\n-      else\n-\t{\n-\t  if (input[opt_len] == '\\0')\n-\t    return md;\n-\t  /* We were passed more text.  If the option takes an argument,\n-\t     we may match a later option or we may have been passed the\n-\t     argument.  The longest possible option match succeeds.\n-\t     If the option takes no arguments we have not matched and\n-\t     continue the search (e.g. input=\"stdc++\" match was \"stdc\").  */\n-\t  mn = md + 1;\n-\t  if (cl_options[md].msg)\n-\t    {\n-\t      /* Scan forwards.  If we get an exact match, return it.\n-\t\t Otherwise, return the longest option-accepting match.\n-\t\t This loops no more than twice with current options.  */\n-\t      mx = md;\n-\t      for (; mn < (unsigned int) N_OPTS; mn++)\n-\t\t{\n-\t\t  opt_len = cl_options[mn].opt_len;\n-\t\t  if (strncmp (input, cl_options[mn].opt_text, opt_len))\n-\t\t    break;\n-\t\t  if (input[opt_len] == '\\0')\n-\t\t    return mn;\n-\t\t  if (cl_options[mn].msg)\n-\t\t    mx = mn;\n-\t\t}\n-\t      return mx;\n-\t    }\n-\t}\n-    }\n-\n-  return -1;\n-}\n-\n-/* Handle one command-line option in (argc, argv).\n-   Can be called multiple times, to handle multiple sets of options.\n-   Returns number of strings consumed.  */\n-int\n-cpp_handle_option (pfile, argc, argv)\n-     cpp_reader *pfile;\n-     int argc;\n-     char **argv;\n-{\n-  int i = 0;\n-  struct cpp_pending *pend = CPP_OPTION (pfile, pending);\n-\n-    {\n-      enum opt_code opt_code;\n-      int opt_index;\n-      const char *arg = 0;\n-\n-      /* Skip over '-'.  */\n-      opt_index = parse_option (&argv[i][1]);\n-      if (opt_index < 0)\n-\treturn i;\n-\n-      opt_code = cl_options[opt_index].opt_code;\n-      if (cl_options[opt_index].msg)\n-\t{\n-\t  arg = &argv[i][cl_options[opt_index].opt_len + 1];\n-\t  if (arg[0] == '\\0')\n-\t    {\n-\t      arg = argv[++i];\n-\t      if (!arg)\n-\t\t{\n-\t\t  cpp_error (pfile, DL_ERROR,\n-\t\t\t     cl_options[opt_index].msg, argv[i - 1]);\n-\t\t  return argc;\n-\t\t}\n-\t    }\n-\t}\n-\n-      switch (opt_code)\n-\t{\n-\tcase N_OPTS: /* Shut GCC up.  */\n-\t  break;\n-\n-\tcase OPT_D:\n-\t  new_pending_directive (pend, arg, cpp_define);\n-\t  break;\n-\n-\tcase OPT_A:\n-\t  if (arg[0] == '-')\n-\t    {\n-\t      /* -A with an argument beginning with '-' acts as\n-\t\t #unassert on whatever immediately follows the '-'.\n-\t\t If \"-\" is the whole argument, we eliminate all\n-\t\t predefined macros and assertions, including those\n-\t\t that were specified earlier on the command line.\n-\t\t That way we can get rid of any that were passed\n-\t\t automatically in from GCC.  */\n-\n-\t      if (arg[1] == '\\0')\n-\t\t{\n-\t\t  free_chain (pend->directive_head);\n-\t\t  pend->directive_head = NULL;\n-\t\t  pend->directive_tail = NULL;\n-\t\t}\n-\t      else\n-\t\tnew_pending_directive (pend, arg + 1, cpp_unassert);\n-\t    }\n-\t  else\n-\t    new_pending_directive (pend, arg, cpp_assert);\n-\t  break;\n-\tcase OPT_U:\n-\t  new_pending_directive (pend, arg, cpp_undef);\n-\t  break;\n-\t}\n-    }\n-  return i + 1;\n-}\n-\n static void\n post_options (pfile)\n      cpp_reader *pfile;"}, {"sha": "7664b1f137950762506644568d467702f66903c4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -213,9 +213,6 @@ struct cpp_options\n   /* Characters between tab stops.  */\n   unsigned int tabstop;\n \n-  /* Pending options - -D, -U, -A, -I, -ixxx.  */\n-  struct cpp_pending *pending;\n-\n   /* Map between header names and file names, used only on DOS where\n      file names are limited in length.  */\n   struct file_name_map_list *map_list;\n@@ -380,9 +377,6 @@ struct cpp_callbacks\n   void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n   void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));\n   void (*def_pragma) PARAMS ((cpp_reader *, unsigned int));\n-  /* Called when the client has a chance to properly register\n-     built-ins with cpp_define() and cpp_assert().  */\n-  void (*register_builtins) PARAMS ((cpp_reader *));\n   int (*valid_pch) PARAMS ((cpp_reader *, const char *, int));\n   void (*read_pch) PARAMS ((cpp_reader *, const char *, int, const char *));\n };\n@@ -517,11 +511,6 @@ extern const struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\n extern cpp_callbacks *cpp_get_callbacks PARAMS ((cpp_reader *));\n extern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n \n-/* Now call cpp_handle_option to handle 1 switch.  The return value is\n-   the number of arguments used.  Options processing is not completed\n-   until you call cpp_finish_options.  */\n-extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n-\n /* This function reads the file, but does not start preprocessing.  It\n    returns the name of the original file; this is the same as the\n    input file, except for preprocessed input.  This will generate at\n@@ -535,12 +524,8 @@ extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern const char *cpp_read_main_file PARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t       struct ht *));\n \n-/* Deferred handling of command line options that can generate debug\n-   callbacks, such as -D and -imacros.  Call this after\n-   cpp_read_main_file.  The front ends need this separation so they\n-   can initialize debug output with the original file name, returned\n-   from cpp_read_main_file, before they get debug callbacks.  */\n-extern void cpp_finish_options PARAMS ((cpp_reader *));\n+/* Set up built-ins like __FILE__.  */\n+extern void cpp_init_builtins PARAMS ((cpp_reader *));\n \n /* Call this to finish preprocessing.  If you requested dependency\n    generation, pass an open stream to write the information to,\n@@ -578,7 +563,7 @@ extern cppchar_t\n cpp_interpret_charconst PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t unsigned int *, int *));\n \n-/* Used to register builtins during the register_builtins callback.\n+/* Used to register macros and assertions, perhaps from the command line.\n    The text is the same as the command line argument.  */\n extern void cpp_define PARAMS ((cpp_reader *, const char *));\n extern void cpp_assert PARAMS ((cpp_reader *, const char *));"}, {"sha": "930728ee73b1cd637aea11d72408d46dab92bdc6", "filename": "gcc/fix-header.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bad961ed99b234fb841ebca1832a0c98327714/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=c1bad961ed99b234fb841ebca1832a0c98327714", "patch": "@@ -1,6 +1,6 @@\n /* fix-header.c - Make C header file suitable for C++.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -67,7 +67,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    * INFILE.H is a full pathname for the input file (e.g. /usr/include/stdio.h)\n    * OUTFILE.H is the full pathname for where to write the output file,\n    if anything needs to be done.  (e.g. ./include/stdio.h)\n-   * OPTIONS are such as you would pass to cpp.\n+   * OPTIONS can be -D or -I switches as you would pass to cpp.\n \n    Written by Per Bothner <bothner@cygnus.com>, July 1993.  */\n \n@@ -634,17 +634,28 @@ read_scan_file (in_fname, argc, argv)\n \n   for (i = 0; i < argc; i += strings_processed)\n     {\n-      if (argv[i][0] == 'I')\n+      strings_processed = 0;\n+      if (argv[i][0] == '-')\n \t{\n-\t  if (argv[i][1] != '\\0')\n-\t    strings_processed = 1, add_path (argv[i] + 1, BRACKET, false);\n-\t  else if (i + 1 == argc)\n-\t    strings_processed = 0;\n-\t  else\n-\t    strings_processed = 2, add_path (argv[i + 1], BRACKET, false);\n+\t  if (argv[i][1] == 'I')\n+\t    {\n+\t      if (argv[i][2] != '\\0')\n+\t\tstrings_processed = 1, add_path (argv[i] + 2, BRACKET, false);\n+\t      else if (i + 1 == argc)\n+\t\tstrings_processed = 0;\n+\t      else\n+\t\tstrings_processed = 2, add_path (argv[i + 2], BRACKET, false);\n+\t    }\n+\t  else if (argv[i][1] == 'D')\n+\t    {\n+\t      if (argv[i][2] != '\\0')\n+\t\tstrings_processed = 1, cpp_define (scan_in, argv[i] + 2);\n+\t      else if (i + 1 == argc)\n+\t\tstrings_processed = 0;\n+\t      else\t\n+\t\tstrings_processed = 2, cpp_define (scan_in, argv[i + 1]);\n+\t    }\n \t}\n-      else\n-\tstrings_processed = cpp_handle_option (scan_in, argc - i, argv + i);\n \n       if (strings_processed == 0)\n \tbreak;\n@@ -661,7 +672,9 @@ read_scan_file (in_fname, argc, argv)\n   if (! cpp_read_main_file (scan_in, in_fname, NULL))\n     exit (FATAL_EXIT_CODE);\n \n-  cpp_finish_options (scan_in);\n+  cpp_rename_file (scan_in, \"<built-in>\");\n+  cpp_init_builtins (scan_in);\n+  cpp_rename_file (scan_in, in_fname);\n \n   /* We are scanning a system header, so mark it as such.  */\n   cpp_make_system_header (scan_in, 1, 0);"}]}