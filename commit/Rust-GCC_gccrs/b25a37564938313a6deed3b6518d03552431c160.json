{"sha": "b25a37564938313a6deed3b6518d03552431c160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1YTM3NTY0OTM4MzEzYTZkZWVkM2I2NTE4ZDAzNTUyNDMxYzE2MA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2019-01-17T04:49:55Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-01-17T04:49:55Z"}, "message": "[PR88146] avoid diagnostics diffs if cdtor_returns_this\n\nDiagnostics for testsuite/g++.dg/cpp0x/inh-ctor32.C varied across\nplatforms.  Specifically, on ARM, the diagnostics within the subtest\nderived_ctor::inherited_derived_ctor::constexpr_noninherited_ctor did\nnot match those displayed on other platforms, and the test failed.\n\nThe difference seemed to have to do with locations assigned to ctors,\nbut it was more subtle: on ARM, the instantiation of bor's template\nctor was nested within the instantiation of bar's template ctor\ninherited from bor.  The reason turned out to be related with the\ninternal return type of ctors: arm_cxx_cdtor_returns_this is enabled\nfor because of AAPCS, while cxx.cdtor_returns_this is disabled on most\nother platforms.  While convert_to_void returns early with a VOID\nexpr, the non-VOID return type of the base ctor CALL_EXPR causes\nconvert_to_void to inspect the called decl for nodiscard attributes:\nmaybe_warn_nodiscard -> cp_get_fndecl_from_callee ->\nmaybe_constant_init -> cxx_eval_outermost_constant_expr ->\ninstantiate_constexpr_fns -> nested instantiation.\n\nThe internal return type assigned to a cdtor should not affect\ninstantiation (constexpr or template) decisions, IMHO.  We know it\naffects diagnostics, but I have a hunch this might bring deeper issues\nwith it, so I've arranged for the CALL_EXPR handler in convert_to_void\nto disregard cdtors, regardless of the ABI.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/88146\n\t* cvt.c (convert_to_void): Handle all cdtor calls as if\n\treturning void.\n\nFrom-SVN: r268004", "tree": {"sha": "9b87c42a315e4470058f30f1c2a4753a656f98a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b87c42a315e4470058f30f1c2a4753a656f98a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25a37564938313a6deed3b6518d03552431c160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25a37564938313a6deed3b6518d03552431c160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25a37564938313a6deed3b6518d03552431c160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25a37564938313a6deed3b6518d03552431c160/comments", "author": null, "committer": null, "parents": [{"sha": "b0dd8f37fa8a1c4d792513809605d8d715700f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0dd8f37fa8a1c4d792513809605d8d715700f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0dd8f37fa8a1c4d792513809605d8d715700f12"}], "stats": {"total": 16, "additions": 16, "deletions": 0}, "files": [{"sha": "732aa53d04855f95a30c6d1ea4f158d8d1645088", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25a37564938313a6deed3b6518d03552431c160/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25a37564938313a6deed3b6518d03552431c160/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b25a37564938313a6deed3b6518d03552431c160", "patch": "@@ -1,3 +1,9 @@\n+2019-01-17  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/88146\n+\t* cvt.c (convert_to_void): Handle all cdtor calls as if\n+\treturning void.\n+\n 2019-01-16  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (grokdeclarator): Use locations[ds_storage_class] in"}, {"sha": "82a44f353c763d459faddf3b7d414a335d911c2b", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25a37564938313a6deed3b6518d03552431c160/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25a37564938313a6deed3b6518d03552431c160/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b25a37564938313a6deed3b6518d03552431c160", "patch": "@@ -1175,6 +1175,16 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n       break;\n \n     case CALL_EXPR:   /* We have a special meaning for volatile void fn().  */\n+      /* cdtors may return this or void, depending on\n+\t targetm.cxx.cdtor_returns_this, but this shouldn't affect our\n+\t decisions here: neither nodiscard warnings (nodiscard cdtors\n+\t are nonsensical), nor should any constexpr or template\n+\t instantiations be affected by an ABI property that is, or at\n+\t least ought to be transparent to the language.  */\n+      if (tree fn = cp_get_callee_fndecl_nofold (expr))\n+\tif (DECL_CONSTRUCTOR_P (fn) || DECL_DESTRUCTOR_P (fn))\n+\t  return expr;\n+\n       maybe_warn_nodiscard (expr, implicit);\n       break;\n "}]}