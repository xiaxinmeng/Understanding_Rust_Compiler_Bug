{"sha": "88b811bd29063036fd4536ee1312b1269cade6ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhiODExYmQyOTA2MzAzNmZkNDUzNmVlMTMxMmIxMjY5Y2FkZTZlZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-08-29T21:38:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-08-29T21:38:21Z"}, "message": "PR c++/81236 - ICE with template-id in generic lambda\n\n\t* semantics.c (finish_id_expression): Remove special dependent case.\n\tAvoid some later pieces when dependent.\n\t(finish_qualified_id_expr): Do normal BASELINK handling in a\n\ttemplate.  Always build a SCOPE_REF for a destructor BIT_NOT_EXPR.\n\t(parsing_default_capturing_generic_lambda_in_template): Remove.\n\t* parser.c (cp_parser_postfix_dot_deref_expression): Always give an\n\terror for types that will never be complete.\n\t* mangle.c (write_expression): Add sanity check.\n\t* tree.c (build_qualified_name): Add sanity check.\n\t(cp_walk_subtrees): Walk into the class context of a BASELINK.\n\t* lambda.c (add_capture): Improve diagnostic for generic lambda\n\tcapture failure.\n\t* call.c (build_new_method_call_1): Print the right constructor\n\tname.\n\nFrom-SVN: r251438", "tree": {"sha": "e1ea3e04489af6dd429b46ac2e60b64c29ffcb12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1ea3e04489af6dd429b46ac2e60b64c29ffcb12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88b811bd29063036fd4536ee1312b1269cade6ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b811bd29063036fd4536ee1312b1269cade6ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b811bd29063036fd4536ee1312b1269cade6ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b811bd29063036fd4536ee1312b1269cade6ed/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "888a9854256974585874eb982fceda24cd7842d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888a9854256974585874eb982fceda24cd7842d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/888a9854256974585874eb982fceda24cd7842d3"}], "stats": {"total": 186, "additions": 81, "deletions": 105}, "files": [{"sha": "8532f57e91a3030a29488dfd8d9056d5c09fedc1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -1,5 +1,21 @@\n 2017-08-29  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/81236 - ICE with template-id in generic lambda\n+\t* semantics.c (finish_id_expression): Remove special dependent case.\n+\tAvoid some later pieces when dependent.\n+\t(finish_qualified_id_expr): Do normal BASELINK handling in a\n+\ttemplate.  Always build a SCOPE_REF for a destructor BIT_NOT_EXPR.\n+\t(parsing_default_capturing_generic_lambda_in_template): Remove.\n+\t* parser.c (cp_parser_postfix_dot_deref_expression): Always give an\n+\terror for types that will never be complete.\n+\t* mangle.c (write_expression): Add sanity check.\n+\t* tree.c (build_qualified_name): Add sanity check.\n+\t(cp_walk_subtrees): Walk into the class context of a BASELINK.\n+\t* lambda.c (add_capture): Improve diagnostic for generic lambda\n+\tcapture failure.\n+\t* call.c (build_new_method_call_1): Print the right constructor\n+\tname.\n+\n \tReimplement handling of lambdas in templates.\n \t* cp-tree.h (LAMBDA_FUNCTION_P): Check DECL_DECLARES_FUNCTION_P.\n \t* decl.c (start_preparsed_function): Call start_lambda_scope."}, {"sha": "c446057cfba7b1b193dd137b1c29e7ba7e3d6300", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -9007,6 +9007,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n       if (! (complain & tf_error))\n \treturn error_mark_node;\n \n+      basetype = DECL_CONTEXT (fn);\n       name = constructor_name (basetype);\n       if (permerror (input_location,\n \t\t     \"cannot call constructor %<%T::%D%> directly\","}, {"sha": "9ba3df10363c90ec89b61514aa0357d2771e3d64", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -590,7 +590,11 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n   /* Add it to the appropriate closure class if we've started it.  */\n   if (current_class_type\n       && current_class_type == LAMBDA_EXPR_CLOSURE (lambda))\n-    finish_member_declaration (member);\n+    {\n+      if (COMPLETE_TYPE_P (current_class_type))\n+\tinternal_error (\"trying to capture %qD after closure is complete\", id);\n+      finish_member_declaration (member);\n+    }\n \n   tree listmem = member;\n   if (variadic)"}, {"sha": "ce7c0c51f0ae931988db8d93d6e709a868f0b091", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -3015,6 +3015,7 @@ write_expression (tree expr)\n \t{\n \t  scope = TREE_OPERAND (expr, 0);\n \t  member = TREE_OPERAND (expr, 1);\n+\t  gcc_assert (!BASELINK_P (member));\n \t}\n       else\n \t{"}, {"sha": "47d91bfa9a79a78183c601b61cc213b2336c0c53", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -7446,11 +7446,14 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t      /* In a template, be permissive by treating an object expression\n \t\t of incomplete type as dependent (after a pedwarn).  */\n \t      diagnostic_t kind = (processing_template_decl\n+\t\t\t\t   && MAYBE_CLASS_TYPE_P (scope)\n \t\t\t\t   ? DK_PEDWARN\n \t\t\t\t   : DK_ERROR);\n \t      cxx_incomplete_type_diagnostic\n \t\t(location_of (postfix_expression),\n \t\t postfix_expression, scope, kind);\n+\t      if (!MAYBE_CLASS_TYPE_P (scope))\n+\t\treturn error_mark_node;\n \t      if (processing_template_decl)\n \t\t{\n \t\t  dependent_p = true;\n@@ -20671,33 +20674,6 @@ parsing_nsdmi (void)\n   return false;\n }\n \n-/* Return true iff our current scope is a default capturing generic lambda\n-   defined within a template.  FIXME: This is part of a workaround (see\n-   semantics.c) to handle building lambda closure types correctly in templates\n-   which we ultimately want to defer to instantiation time. */\n-\n-bool\n-parsing_default_capturing_generic_lambda_in_template (void)\n-{\n-  if (!processing_template_decl || !current_class_type)\n-    return false;\n-\n-  tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n-  if (!lam || LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam) == CPLD_NONE)\n-    return false;\n-\n-  tree callop = lambda_function (lam);\n-  if (!callop)\n-    return false;\n-\n-  return (DECL_TEMPLATE_INFO (callop)\n-\t  && (DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (callop)) == callop)\n-\t  && ((current_nonlambda_class_type ()\n-\t       && CLASSTYPE_TEMPLATE_INFO (current_nonlambda_class_type ()))\n-\t      || ((current_nonlambda_function ()\n-\t\t   && DECL_TEMPLATE_INFO (current_nonlambda_function ())))));\n-}\n-\n /* Parse a late-specified return type, if any.  This is not a separate\n    non-terminal, but part of a function declarator, which looks like\n "}, {"sha": "b2e58d2dbf056eb8d79f96f4512f6e03b6c0e138", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 75, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -2035,7 +2035,7 @@ finish_qualified_id_expr (tree qualifying_class,\n \t\t\t\t\t    qualifying_class);\n       pop_deferring_access_checks ();\n     }\n-  else if (BASELINK_P (expr) && !processing_template_decl)\n+  else if (BASELINK_P (expr))\n     {\n       /* See if any of the functions are non-static members.  */\n       /* If so, the expression may be relative to 'this'.  */\n@@ -2055,8 +2055,6 @@ finish_qualified_id_expr (tree qualifying_class,\n \texpr = build_offset_ref (qualifying_class, expr, /*address_p=*/false,\n \t\t\t\t complain);\n     }\n-  else if (BASELINK_P (expr))\n-    ;\n   else\n     {\n       /* In a template, return a SCOPE_REF for most qualified-ids\n@@ -2065,7 +2063,8 @@ finish_qualified_id_expr (tree qualifying_class,\n \t know we have access and building up the SCOPE_REF confuses\n \t non-type template argument handling.  */\n       if (processing_template_decl\n-\t  && !currently_open_class (qualifying_class))\n+\t  && (!currently_open_class (qualifying_class)\n+\t      || TREE_CODE (expr) == BIT_NOT_EXPR))\n \texpr = build_qualified_name (TREE_TYPE (expr),\n \t\t\t\t     qualifying_class, expr,\n \t\t\t\t     template_p);\n@@ -3595,78 +3594,12 @@ finish_id_expression (tree id_expression,\n \t\t    ? CP_ID_KIND_UNQUALIFIED_DEPENDENT\n \t\t    : CP_ID_KIND_UNQUALIFIED)));\n \n-      /* If the name was dependent on a template parameter and we're not in a\n-\t default capturing generic lambda within a template, we will resolve the\n-\t name at instantiation time.  FIXME: For lambdas, we should defer\n-\t building the closure type until instantiation time then we won't need\n-\t the extra test here.  */\n       if (dependent_p\n-\t  && !parsing_default_capturing_generic_lambda_in_template ())\n-\t{\n-\t  if (DECL_P (decl)\n-\t      && any_dependent_type_attributes_p (DECL_ATTRIBUTES (decl)))\n-\t    /* Dependent type attributes on the decl mean that the TREE_TYPE is\n-\t       wrong, so just return the identifier.  */\n-\t    return id_expression;\n-\n-\t  /* If we found a variable, then name lookup during the\n-\t     instantiation will always resolve to the same VAR_DECL\n-\t     (or an instantiation thereof).  */\n-\t  if (VAR_P (decl)\n-\t      || TREE_CODE (decl) == CONST_DECL\n-\t      || TREE_CODE (decl) == PARM_DECL)\n-\t    {\n-\t      mark_used (decl);\n-\t      return convert_from_reference (decl);\n-\t    }\n-\n-\t  /* Create a SCOPE_REF for qualified names, if the scope is\n-\t     dependent.  */\n-\t  if (scope)\n-\t    {\n-\t      if (TYPE_P (scope))\n-\t\t{\n-\t\t  if (address_p && done)\n-\t\t    decl = finish_qualified_id_expr (scope, decl,\n-\t\t\t\t\t\t     done, address_p,\n-\t\t\t\t\t\t     template_p,\n-\t\t\t\t\t\t     template_arg_p,\n-\t\t\t\t\t\t     tf_warning_or_error);\n-\t\t  else\n-\t\t    {\n-\t\t      tree type = NULL_TREE;\n-\t\t      if (DECL_P (decl) && !dependent_scope_p (scope))\n-\t\t\ttype = TREE_TYPE (decl);\n-\t\t      decl = build_qualified_name (type,\n-\t\t\t\t\t\t   scope,\n-\t\t\t\t\t\t   id_expression,\n-\t\t\t\t\t\t   template_p);\n-\t\t    }\n-\t\t}\n-\t      if (TREE_TYPE (decl))\n-\t\tdecl = convert_from_reference (decl);\n-\t      return decl;\n-\t    }\n-\t  /* A TEMPLATE_ID already contains all the information we\n-\t     need.  */\n-\t  if (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR)\n-\t    return id_expression;\n-\t  /* The same is true for FIELD_DECL, but we also need to\n-\t     make sure that the syntax is correct.  */\n-\t  else if (TREE_CODE (decl) == FIELD_DECL)\n-\t    {\n-\t      /* Since SCOPE is NULL here, this is an unqualified name.\n-\t\t Access checking has been performed during name lookup\n-\t\t already.  Turn off checking to avoid duplicate errors.  */\n-\t      push_deferring_access_checks (dk_no_check);\n-\t      decl = finish_non_static_data_member\n-\t\t       (decl, NULL_TREE,\n-\t\t\t/*qualifying_scope=*/NULL_TREE);\n-\t      pop_deferring_access_checks ();\n-\t      return decl;\n-\t    }\n-\t  return id_expression;\n-\t}\n+\t  && DECL_P (decl)\n+\t  && any_dependent_type_attributes_p (DECL_ATTRIBUTES (decl)))\n+\t/* Dependent type attributes on the decl mean that the TREE_TYPE is\n+\t   wrong, so just return the identifier.  */\n+\treturn id_expression;\n \n       if (TREE_CODE (decl) == NAMESPACE_DECL)\n \t{\n@@ -3700,6 +3633,7 @@ finish_id_expression (tree id_expression,\n \t expression.  Template parameters have already\n \t been handled above.  */\n       if (! error_operand_p (decl)\n+\t  && !dependent_p\n \t  && integral_constant_expression_p\n \t  && ! decl_constant_var_p (decl)\n \t  && TREE_CODE (decl) != CONST_DECL\n@@ -3726,6 +3660,7 @@ finish_id_expression (tree id_expression,\n \t  decl = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);\n \t}\n       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n+\t       && !dependent_p\n \t       && variable_template_p (TREE_OPERAND (decl, 0)))\n \t{\n \t  decl = finish_template_variable (decl);\n@@ -3734,6 +3669,12 @@ finish_id_expression (tree id_expression,\n \t}\n       else if (scope)\n \t{\n+\t  if (TREE_CODE (decl) == SCOPE_REF)\n+\t    {\n+\t      gcc_assert (same_type_p (scope, TREE_OPERAND (decl, 0)));\n+\t      decl = TREE_OPERAND (decl, 1);\n+\t    }\n+\n \t  decl = (adjust_result_of_qualified_name_lookup\n \t\t  (decl, scope, current_nonlambda_class_type()));\n "}, {"sha": "aab92d5e9d5fb451b0e437cd9d3f43d0ad1f1c46", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -2028,6 +2028,7 @@ build_qualified_name (tree type, tree scope, tree name, bool template_p)\n       || scope == error_mark_node\n       || name == error_mark_node)\n     return error_mark_node;\n+  gcc_assert (TREE_CODE (name) != SCOPE_REF);\n   t = build2 (SCOPE_REF, type, scope, name);\n   QUALIFIED_NAME_IS_TEMPLATE (t) = template_p;\n   PTRMEM_OK_P (t) = true;\n@@ -4663,6 +4664,8 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n       break;\n \n     case BASELINK:\n+      if (BASELINK_QUALIFIED_P (*tp))\n+\tWALK_SUBTREE (BINFO_TYPE (BASELINK_ACCESS_BINFO (*tp)));\n       WALK_SUBTREE (BASELINK_FUNCTIONS (*tp));\n       *walk_subtrees_p = 0;\n       break;"}, {"sha": "52d25af9c5a1cbb04cf1a364ceca9fdb30126d6a", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-this1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-this1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-this1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-this1.C?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/81236\n+// { dg-do compile { target c++14 } }\n+\n+struct A { constexpr operator int() { return 24; } };\n+\n+struct MyType {\n+  void crash() {\n+    auto l = [&](auto i){\n+      make_crash<i>(); // Line (1)\n+    };\n+\n+    l(A{});\n+  }\n+    \n+  template<int i>\n+  void make_crash() {}\n+};"}, {"sha": "d321a0773ee176d6b518880beac2c15957243226", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-this1a.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-this1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-this1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-this1a.C?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/81236\n+// { dg-do compile { target c++14 } }\n+\n+struct A { constexpr operator int() { return 24; } };\n+\n+struct MyType {\n+  void crash() {\n+    auto l = [&](auto i){\n+      MyType::make_crash<i>(); // Line (1)\n+    };\n+\n+    l(A{});\n+  }\n+    \n+  template<int i>\n+  void make_crash() {}\n+};"}, {"sha": "21a68aaac45f83f4076a3231a50afac0397c99b3", "filename": "gcc/testsuite/g++.dg/template/pseudodtor3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpseudodtor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b811bd29063036fd4536ee1312b1269cade6ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpseudodtor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpseudodtor3.C?ref=88b811bd29063036fd4536ee1312b1269cade6ed", "patch": "@@ -11,7 +11,7 @@ struct A\n template <typename T> struct B\n {\n   T &foo ();\n-  B () { foo.~T (); }\t// { dg-error \"15:invalid use of member\" }\n+  B () { foo.~T (); }\t// { dg-error \"10:invalid use of member\" }\n };\n \n B<int> b;\n@@ -37,7 +37,7 @@ template <typename T> struct E\n {\n   T &foo ();\n   typedef long int U;\n-  E () { foo.~U (); }\t// { dg-error \"10:is not of type\" }\n+  E () { foo.~U (); }\t// { dg-error \"10:invalid use of member\" }\n };\n \n E<int> e;"}]}