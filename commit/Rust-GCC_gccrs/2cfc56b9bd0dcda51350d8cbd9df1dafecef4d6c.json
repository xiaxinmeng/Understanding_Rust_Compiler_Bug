{"sha": "2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNmYzU2YjliZDBkY2RhNTEzNTBkOGNiZDlkZjFkYWZlY2VmNGQ2Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-01-16T14:06:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-01-16T14:06:58Z"}, "message": "re PR tree-optimization/55964 (Segmentation fault with -O -ftree-loop-distribution -funswitch-loops)\n\n2013-01-16  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/55964\n\t* tree-flow.h (rename_variables_in_loop): Remove.\n\t(rename_variables_in_bb): Likewise.\n\t* tree-loop-distribution.c (update_phis_for_loop_copy): Remove.\n\t(copy_loop_before): Adjust and delete update-ssa status.\n\t* tree-vect-loop-manip.c (rename_variables_in_bb): Make static.\n\t(rename_variables_in_bb): Likewise.  Properly walk over\n\tpredecessors.\n\t(rename_variables_in_loop): Remove.\n\t(slpeel_update_phis_for_duplicate_loop): Likewise.\n\t(slpeel_tree_duplicate_loop_to_edge_cfg): Handle nested loops,\n\tuse available cfg machinery instead of duplicating it.\n\tUpdate PHI nodes and perform poor-mans SSA update here.\n\t(slpeel_tree_peel_loop_to_edge): Adjust.\n\n\t* gcc.dg/torture/pr55964.c: New testcase.\n\nFrom-SVN: r195239", "tree": {"sha": "57ef3c159a5442c7ebc9b1b98e651e37f06bfd0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57ef3c159a5442c7ebc9b1b98e651e37f06bfd0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c25a0c60a5893ae7f4ba309b5b3bb2f336873683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25a0c60a5893ae7f4ba309b5b3bb2f336873683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25a0c60a5893ae7f4ba309b5b3bb2f336873683"}], "stats": {"total": 345, "additions": 100, "deletions": 245}, "files": [{"sha": "144175b6b46c019203bec5223c13b5f7f303ef4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "patch": "@@ -1,3 +1,20 @@\n+2013-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/55964\n+\t* tree-flow.h (rename_variables_in_loop): Remove.\n+\t(rename_variables_in_bb): Likewise.\n+\t* tree-loop-distribution.c (update_phis_for_loop_copy): Remove.\n+\t(copy_loop_before): Adjust and delete update-ssa status.\n+\t* tree-vect-loop-manip.c (rename_variables_in_bb): Make static.\n+\t(rename_variables_in_bb): Likewise.  Properly walk over\n+\tpredecessors.\n+\t(rename_variables_in_loop): Remove.\n+\t(slpeel_update_phis_for_duplicate_loop): Likewise.\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): Handle nested loops,\n+\tuse available cfg machinery instead of duplicating it.\n+\tUpdate PHI nodes and perform poor-mans SSA update here.\n+\t(slpeel_tree_peel_loop_to_edge): Adjust.\n+\n 2013-01-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/54767"}, {"sha": "fe566baee0ebf7c560fa248c736168a79855c9df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "patch": "@@ -1,3 +1,8 @@\n+2013-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/55964\n+\t* gcc.dg/torture/pr55964.c: New testcase.\n+\n 2013-01-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/54767"}, {"sha": "361151ccf0c77d561cbbb34ea771e72021c6cee2", "filename": "gcc/testsuite/gcc.dg/torture/pr55964.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55964.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55964.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55964.c?ref=2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-ftree-loop-distribution -funswitch-loops -w\" } */\n+\n+int a, b;\n+\n+void f(void)\n+{\n+lbl1:\n+    for(b = 0; b < 1; b++)\n+    {\n+        int u = 1;\n+\n+        if((b %= 0) * (b ? 0 : a) - 1 && (u /= 0))\n+        {\n+            int *q = &u, **k = q;\n+            goto lbl1;\n+lbl2:\n+lbl3:\n+            a = **k;\n+            goto lbl2;\n+        }\n+    }\n+    goto lbl3;\n+}"}, {"sha": "a87eeaef263214f5e8f04e69e1459d852af413e2", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "patch": "@@ -654,8 +654,6 @@ bool gimple_duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t edge, vec<edge> *,\n \t\t\t\t\t int);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n-void rename_variables_in_loop (struct loop *);\n-void rename_variables_in_bb (basic_block bb);\n tree expand_simple_operations (tree);\n void substitute_in_loop_info (struct loop *, tree, tree);\n edge single_dom_exit (struct loop *);"}, {"sha": "747b6ac6131d3b2315773a9d3f02595ca9759d4d", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "patch": "@@ -151,58 +151,6 @@ stmt_has_scalar_dependences_outside_loop (loop_p loop, gimple stmt)\n   return false;\n }\n \n-/* Update the PHI nodes of NEW_LOOP.  NEW_LOOP is a duplicate of\n-   ORIG_LOOP.  */\n-\n-static void\n-update_phis_for_loop_copy (struct loop *orig_loop, struct loop *new_loop)\n-{\n-  tree new_ssa_name;\n-  gimple_stmt_iterator si_new, si_orig;\n-  edge orig_loop_latch = loop_latch_edge (orig_loop);\n-  edge orig_entry_e = loop_preheader_edge (orig_loop);\n-  edge new_loop_entry_e = loop_preheader_edge (new_loop);\n-\n-  /* Scan the phis in the headers of the old and new loops\n-     (they are organized in exactly the same order).  */\n-  for (si_new = gsi_start_phis (new_loop->header),\n-       si_orig = gsi_start_phis (orig_loop->header);\n-       !gsi_end_p (si_new) && !gsi_end_p (si_orig);\n-       gsi_next (&si_new), gsi_next (&si_orig))\n-    {\n-      tree def;\n-      source_location locus;\n-      gimple phi_new = gsi_stmt (si_new);\n-      gimple phi_orig = gsi_stmt (si_orig);\n-\n-      /* Add the first phi argument for the phi in NEW_LOOP (the one\n-\t associated with the entry of NEW_LOOP)  */\n-      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_entry_e);\n-      locus = gimple_phi_arg_location_from_edge (phi_orig, orig_entry_e);\n-      add_phi_arg (phi_new, def, new_loop_entry_e, locus);\n-\n-      /* Add the second phi argument for the phi in NEW_LOOP (the one\n-\t associated with the latch of NEW_LOOP)  */\n-      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_loop_latch);\n-      locus = gimple_phi_arg_location_from_edge (phi_orig, orig_loop_latch);\n-\n-      if (TREE_CODE (def) == SSA_NAME)\n-\t{\n-\t  new_ssa_name = get_current_def (def);\n-\n-\t  if (!new_ssa_name)\n-\t    /* This only happens if there are no definitions inside the\n-\t       loop.  Use the the invariant in the new loop as is.  */\n-\t    new_ssa_name = def;\n-\t}\n-      else\n-\t/* Could be an integer.  */\n-\tnew_ssa_name = def;\n-\n-      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop), locus);\n-    }\n-}\n-\n /* Return a copy of LOOP placed before LOOP.  */\n \n static struct loop *\n@@ -215,9 +163,7 @@ copy_loop_before (struct loop *loop)\n   res = slpeel_tree_duplicate_loop_to_edge_cfg (loop, preheader);\n   gcc_assert (res != NULL);\n   free_original_copy_tables ();\n-\n-  update_phis_for_loop_copy (loop, res);\n-  rename_variables_in_loop (res);\n+  delete_update_ssa ();\n \n   return res;\n }"}, {"sha": "8e589de6d1f1ff429c56f25926deb2d3c113b3b7", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 53, "deletions": 188, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=2cfc56b9bd0dcda51350d8cbd9df1dafecef4d6c", "patch": "@@ -67,7 +67,7 @@ rename_use_op (use_operand_p op_p)\n \n /* Renames the variables in basic block BB.  */\n \n-void\n+static void\n rename_variables_in_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -85,32 +85,16 @@ rename_variables_in_bb (basic_block bb)\n \trename_use_op (use_p);\n     }\n \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      if (!flow_bb_inside_loop_p (loop, e->dest))\n+      if (!flow_bb_inside_loop_p (loop, e->src))\n \tcontinue;\n-      for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n         rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (gsi_stmt (gsi), e));\n     }\n }\n \n \n-/* Renames variables in new generated LOOP.  */\n-\n-void\n-rename_variables_in_loop (struct loop *loop)\n-{\n-  unsigned i;\n-  basic_block *bbs;\n-\n-  bbs = get_loop_body (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    rename_variables_in_bb (bbs[i]);\n-\n-  free (bbs);\n-}\n-\n typedef struct\n {\n   tree from, to;\n@@ -234,101 +218,6 @@ adjust_phi_and_debug_stmts (gimple update_phi, edge e, tree new_def)\n }\n \n \n-/* Update the PHI nodes of NEW_LOOP.\n-\n-   NEW_LOOP is a duplicate of ORIG_LOOP.\n-   AFTER indicates whether NEW_LOOP executes before or after ORIG_LOOP:\n-   AFTER is true if NEW_LOOP executes after ORIG_LOOP, and false if it\n-   executes before it.  */\n-\n-static void\n-slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n-\t\t\t\t       struct loop *new_loop, bool after)\n-{\n-  tree new_ssa_name;\n-  gimple phi_new, phi_orig;\n-  tree def;\n-  edge orig_loop_latch = loop_latch_edge (orig_loop);\n-  edge orig_entry_e = loop_preheader_edge (orig_loop);\n-  edge new_loop_exit_e = single_exit (new_loop);\n-  edge new_loop_entry_e = loop_preheader_edge (new_loop);\n-  edge entry_arg_e = (after ? orig_loop_latch : orig_entry_e);\n-  gimple_stmt_iterator gsi_new, gsi_orig;\n-\n-  /*\n-     step 1. For each loop-header-phi:\n-             Add the first phi argument for the phi in NEW_LOOP\n-            (the one associated with the entry of NEW_LOOP)\n-\n-     step 2. For each loop-header-phi:\n-             Add the second phi argument for the phi in NEW_LOOP\n-            (the one associated with the latch of NEW_LOOP)\n-\n-     step 3. Update the phis in the successor block of NEW_LOOP.\n-\n-        case 1: NEW_LOOP was placed before ORIG_LOOP:\n-                The successor block of NEW_LOOP is the header of ORIG_LOOP.\n-                Updating the phis in the successor block can therefore be done\n-                along with the scanning of the loop header phis, because the\n-                header blocks of ORIG_LOOP and NEW_LOOP have exactly the same\n-                phi nodes, organized in the same order.\n-\n-        case 2: NEW_LOOP was placed after ORIG_LOOP:\n-                The successor block of NEW_LOOP is the original exit block of\n-                ORIG_LOOP - the phis to be updated are the loop-closed-ssa phis.\n-                We postpone updating these phis to a later stage (when\n-                loop guards are added).\n-   */\n-\n-\n-  /* Scan the phis in the headers of the old and new loops\n-     (they are organized in exactly the same order).  */\n-\n-  for (gsi_new = gsi_start_phis (new_loop->header),\n-       gsi_orig = gsi_start_phis (orig_loop->header);\n-       !gsi_end_p (gsi_new) && !gsi_end_p (gsi_orig);\n-       gsi_next (&gsi_new), gsi_next (&gsi_orig))\n-    {\n-      source_location locus;\n-      phi_new = gsi_stmt (gsi_new);\n-      phi_orig = gsi_stmt (gsi_orig);\n-\n-      /* step 1.  */\n-      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, entry_arg_e);\n-      locus = gimple_phi_arg_location_from_edge (phi_orig, entry_arg_e);\n-      add_phi_arg (phi_new, def, new_loop_entry_e, locus);\n-\n-      /* step 2.  */\n-      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_loop_latch);\n-      locus = gimple_phi_arg_location_from_edge (phi_orig, orig_loop_latch);\n-      if (TREE_CODE (def) != SSA_NAME)\n-        continue;\n-\n-      new_ssa_name = get_current_def (def);\n-      if (!new_ssa_name)\n-\t{\n-\t  /* This only happens if there are no definitions\n-\t     inside the loop. use the phi_result in this case.  */\n-\t  new_ssa_name = PHI_RESULT (phi_new);\n-\t}\n-\n-      /* An ordinary ssa name defined in the loop.  */\n-      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop), locus);\n-\n-      /* Drop any debug references outside the loop, if they would\n-\t become ill-formed SSA.  */\n-      adjust_debug_stmts (def, NULL, single_exit (orig_loop)->dest);\n-\n-      /* step 3 (case 1).  */\n-      if (!after)\n-        {\n-          gcc_assert (new_loop_exit_e == orig_entry_e);\n-\t  adjust_phi_and_debug_stmts (phi_orig, new_loop_exit_e, new_ssa_name);\n-        }\n-    }\n-}\n-\n-\n /* Update PHI nodes for a guard of the LOOP.\n \n    Input:\n@@ -809,16 +698,15 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n   bool at_exit;\n   bool was_imm_dom;\n   basic_block exit_dest;\n-  gimple phi;\n-  tree phi_arg;\n   edge exit, new_exit;\n-  gimple_stmt_iterator gsi;\n \n-  at_exit = (e == single_exit (loop));\n+  exit = single_exit (loop);\n+  at_exit = (e == exit);\n   if (!at_exit && e != loop_preheader_edge (loop))\n     return NULL;\n \n-  bbs = get_loop_body (loop);\n+  bbs = XNEWVEC (basic_block, loop->num_nodes + 1);\n+  get_loop_body_with_size (loop, bbs, loop->num_nodes);\n \n   /* Check whether duplication is possible.  */\n   if (!can_copy_bbs_p (bbs, loop->num_nodes))\n@@ -829,91 +717,71 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n \n   /* Generate new loop structure.  */\n   new_loop = duplicate_loop (loop, loop_outer (loop));\n-  if (!new_loop)\n-    {\n-      free (bbs);\n-      return NULL;\n-    }\n+  duplicate_subloops (loop, new_loop);\n \n-  exit_dest = single_exit (loop)->dest;\n+  exit_dest = exit->dest;\n   was_imm_dom = (get_immediate_dominator (CDI_DOMINATORS,\n \t\t\t\t\t  exit_dest) == loop->header ?\n \t\t true : false);\n \n-  new_bbs = XNEWVEC (basic_block, loop->num_nodes);\n+  /* Also copy the pre-header, this avoids jumping through hoops to\n+     duplicate the loop entry PHI arguments.  Create an empty\n+     pre-header unconditionally for this.  */\n+  basic_block preheader = split_edge (loop_preheader_edge (loop));\n+  edge entry_e = single_pred_edge (preheader);\n+  bbs[loop->num_nodes] = preheader;\n+  new_bbs = XNEWVEC (basic_block, loop->num_nodes + 1);\n \n-  exit = single_exit (loop);\n-  copy_bbs (bbs, loop->num_nodes, new_bbs,\n+  copy_bbs (bbs, loop->num_nodes + 1, new_bbs,\n \t    &exit, 1, &new_exit, NULL,\n \t    e->src);\n+  basic_block new_preheader = new_bbs[loop->num_nodes];\n \n-  /* Duplicating phi args at exit bbs as coming\n-     also from exit of duplicated loop.  */\n-  for (gsi = gsi_start_phis (exit_dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      phi = gsi_stmt (gsi);\n-      phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, single_exit (loop));\n-      if (phi_arg)\n-\t{\n-\t  edge new_loop_exit_edge;\n-\t  source_location locus;\n-\n-\t  locus = gimple_phi_arg_location_from_edge (phi, single_exit (loop));\n-\t  if (EDGE_SUCC (new_loop->header, 0)->dest == new_loop->latch)\n-\t    new_loop_exit_edge = EDGE_SUCC (new_loop->header, 1);\n-\t  else\n-\t    new_loop_exit_edge = EDGE_SUCC (new_loop->header, 0);\n-\n-\t  add_phi_arg (phi, phi_arg, new_loop_exit_edge, locus);\n-\t}\n-    }\n+  add_phi_args_after_copy (new_bbs, loop->num_nodes + 1, NULL);\n \n   if (at_exit) /* Add the loop copy at exit.  */\n     {\n-      redirect_edge_and_branch_force (e, new_loop->header);\n-      PENDING_STMT (e) = NULL;\n-      set_immediate_dominator (CDI_DOMINATORS, new_loop->header, e->src);\n+      redirect_edge_and_branch_force (e, new_preheader);\n+      flush_pending_stmts (e);\n+      set_immediate_dominator (CDI_DOMINATORS, new_preheader, e->src);\n       if (was_imm_dom)\n \tset_immediate_dominator (CDI_DOMINATORS, exit_dest, new_loop->header);\n+\n+      /* And remove the non-necessary forwarder again.  Keep the other\n+         one so we have a proper pre-header for the loop at the exit edge.  */\n+      redirect_edge_pred (single_succ_edge (preheader), single_pred (preheader));\n+      delete_basic_block (preheader);\n+      set_immediate_dominator (CDI_DOMINATORS, loop->header,\n+\t\t\t       loop_preheader_edge (loop)->src);\n     }\n   else /* Add the copy at entry.  */\n     {\n-      edge new_exit_e;\n-      edge entry_e = loop_preheader_edge (loop);\n-      basic_block preheader = entry_e->src;\n-\n-      if (!flow_bb_inside_loop_p (new_loop,\n-\t\t\t\t  EDGE_SUCC (new_loop->header, 0)->dest))\n-        new_exit_e = EDGE_SUCC (new_loop->header, 0);\n-      else\n-\tnew_exit_e = EDGE_SUCC (new_loop->header, 1);\n-\n-      redirect_edge_and_branch_force (new_exit_e, loop->header);\n-      PENDING_STMT (new_exit_e) = NULL;\n-      set_immediate_dominator (CDI_DOMINATORS, loop->header,\n-\t\t\t       new_exit_e->src);\n-\n-      /* We have to add phi args to the loop->header here as coming\n-\t from new_exit_e edge.  */\n-      for (gsi = gsi_start_phis (loop->header);\n-           !gsi_end_p (gsi);\n-           gsi_next (&gsi))\n-\t{\n-\t  phi = gsi_stmt (gsi);\n-\t  phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, entry_e);\n-\t  if (phi_arg)\n-\t    add_phi_arg (phi, phi_arg, new_exit_e,\n-\t\t\t gimple_phi_arg_location_from_edge (phi, entry_e));\n-\t}\n-\n-      redirect_edge_and_branch_force (entry_e, new_loop->header);\n-      PENDING_STMT (entry_e) = NULL;\n-      set_immediate_dominator (CDI_DOMINATORS, new_loop->header, preheader);\n+      redirect_edge_and_branch_force (entry_e, new_preheader);\n+      flush_pending_stmts (entry_e);\n+      set_immediate_dominator (CDI_DOMINATORS, new_preheader, entry_e->src);\n+\n+      redirect_edge_and_branch_force (new_exit, preheader);\n+      flush_pending_stmts (new_exit);\n+      set_immediate_dominator (CDI_DOMINATORS, preheader, new_exit->src);\n+\n+      /* And remove the non-necessary forwarder again.  Keep the other\n+         one so we have a proper pre-header for the loop at the exit edge.  */\n+      redirect_edge_pred (single_succ_edge (new_preheader), single_pred (new_preheader));\n+      delete_basic_block (new_preheader);\n+      set_immediate_dominator (CDI_DOMINATORS, new_loop->header,\n+\t\t\t       loop_preheader_edge (new_loop)->src);\n     }\n \n+  for (unsigned i = 0; i < loop->num_nodes+1; i++)\n+    rename_variables_in_bb (new_bbs[i]);\n+\n   free (new_bbs);\n   free (bbs);\n \n+#ifdef ENABLE_CHECKING\n+  verify_dominators (CDI_DOMINATORS);\n+#endif\n+\n   return new_loop;\n }\n \n@@ -1265,10 +1133,6 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n       second_loop = loop;\n     }\n \n-  slpeel_update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n-  rename_variables_in_loop (new_loop);\n-\n-\n   /* 2.  Add the guard code in one of the following ways:\n \n      2.a Add the guard that controls whether the first loop is executed.\n@@ -1355,7 +1219,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   */\n \n   bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n-  bb_before_second_loop = split_edge (single_exit (first_loop));\n+  /* Loop copying insterted a forwarder block for us here.  */\n+  bb_before_second_loop = single_exit (first_loop)->dest;\n \n   probability_of_second_loop = (inverse_probability (first_guard_probability)\n \t\t\t        + combine_probabilities (second_guard_probability,"}]}