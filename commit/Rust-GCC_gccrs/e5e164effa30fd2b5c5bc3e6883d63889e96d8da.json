{"sha": "e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlMTY0ZWZmYTMwZmQyYjVjNWJjM2U2ODgzZDYzODg5ZTk2ZDhkYQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2016-03-06T14:38:21Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-07-30T17:34:19Z"}, "message": "Add QI vector mode support to by-pieces for memset\n\n1. Replace scalar_int_mode with fixed_size_mode in the by-pieces\ninfrastructure to allow non-integer mode.\n2. Rename widest_int_mode_for_size to widest_fixed_size_mode_for_size\nto return QI vector mode for memset.\n3. Add op_by_pieces_d::smallest_fixed_size_mode_for_size to return the\nsmallest integer or QI vector mode.\n4. Remove clear_by_pieces_1 and use builtin_memset_read_str in\nclear_by_pieces to support vector mode broadcast.\n5. Add lowpart_subreg_regno, a wrapper around simplify_subreg_regno that\nuses subreg_lowpart_offset (mode, prev_mode) as the offset.\n6. Add TARGET_GEN_MEMSET_SCRATCH_RTX to allow the backend to use a hard\nscratch register to avoid stack realignment when expanding memset.\n\ngcc/\n\n\tPR middle-end/90773\n\t* builtins.c (builtin_memcpy_read_str): Change the mode argument\n\tfrom scalar_int_mode to fixed_size_mode.\n\t(builtin_strncpy_read_str): Likewise.\n\t(gen_memset_value_from_prev): New function.\n\t(builtin_memset_read_str): Change the mode argument from\n\tscalar_int_mode to fixed_size_mode.  Use gen_memset_value_from_prev\n\tand support CONST_VECTOR.\n\t(builtin_memset_gen_str): Likewise.\n\t(try_store_by_multiple_pieces): Use by_pieces_constfn to declare\n\tconstfun.\n\t* builtins.h (builtin_strncpy_read_str): Replace scalar_int_mode\n\twith fixed_size_mode.\n\t(builtin_memset_read_str): Likewise.\n\t* expr.c (widest_int_mode_for_size): Renamed to ...\n\t(widest_fixed_size_mode_for_size): Add a bool argument to\n\tindicate if QI vector mode can be used.\n\t(by_pieces_ninsns): Call widest_fixed_size_mode_for_size\n\tinstead of widest_int_mode_for_size.\n\t(pieces_addr::adjust): Change the mode argument from\n\tscalar_int_mode to fixed_size_mode.\n\t(op_by_pieces_d): Make m_len read-only.  Add a bool member,\n\tm_qi_vector_mode, to indicate that QI vector mode can be used.\n\t(op_by_pieces_d::op_by_pieces_d): Add a bool argument to\n\tinitialize m_qi_vector_mode.  Call widest_fixed_size_mode_for_size\n\tinstead of widest_int_mode_for_size.\n\t(op_by_pieces_d::get_usable_mode): Change the mode argument from\n\tscalar_int_mode to fixed_size_mode.  Call\n\twidest_fixed_size_mode_for_size instead of\n\twidest_int_mode_for_size.\n\t(op_by_pieces_d::smallest_fixed_size_mode_for_size): New member\n\tfunction to return the smallest integer or QI vector mode.\n\t(op_by_pieces_d::run): Call widest_fixed_size_mode_for_size\n\tinstead of widest_int_mode_for_size.  Call\n\tsmallest_fixed_size_mode_for_size instead of\n\tsmallest_int_mode_for_size.\n\t(store_by_pieces_d::store_by_pieces_d): Add a bool argument to\n\tindicate that QI vector mode can be used and pass it to\n\top_by_pieces_d::op_by_pieces_d.\n\t(can_store_by_pieces): Call widest_fixed_size_mode_for_size\n\tinstead of widest_int_mode_for_size.  Pass memsetp to\n\twidest_fixed_size_mode_for_size to support QI vector mode.\n\tAllow all CONST_VECTORs for memset if vec_duplicate is supported.\n\t(store_by_pieces): Pass memsetp to\n\tstore_by_pieces_d::store_by_pieces_d.\n\t(clear_by_pieces_1): Removed.\n\t(clear_by_pieces): Replace clear_by_pieces_1 with\n\tbuiltin_memset_read_str and pass true to store_by_pieces_d to\n\tsupport vector mode broadcast.\n\t(string_cst_read_str): Change the mode argument from\n\tscalar_int_mode to fixed_size_mode.\n\t* expr.h (by_pieces_constfn): Change scalar_int_mode to\n\tfixed_size_mode.\n\t(by_pieces_prev): Likewise.\n\t* rtl.h (lowpart_subreg_regno): New.\n\t* rtlanal.c (lowpart_subreg_regno): New.  A wrapper around\n\tsimplify_subreg_regno.\n\t* target.def (gen_memset_scratch_rtx): New hook.\n\t* doc/tm.texi.in: Add TARGET_GEN_MEMSET_SCRATCH_RTX.\n\t* doc/tm.texi: Regenerated.\n\ngcc/testsuite/\n\n\t* gcc.target/i386/pr100865-3.c: Expect vmovdqu8 instead of\n\tvmovdqu.\n\t* gcc.target/i386/pr100865-4b.c: Likewise.", "tree": {"sha": "2bc5b9da149ccd05f459cebc9086397430a4cccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bc5b9da149ccd05f459cebc9086397430a4cccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d68d275a00573be49f5e83eba52ce3f26d11db9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68d275a00573be49f5e83eba52ce3f26d11db9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d68d275a00573be49f5e83eba52ce3f26d11db9e"}], "stats": {"total": 386, "additions": 297, "deletions": 89}, "files": [{"sha": "2387b5d2a5d568cc798f5f0588c90ee37b58c0a6", "filename": "gcc/builtins.c", "status": "modified", "additions": 140, "deletions": 31, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -3119,13 +3119,16 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n \n static rtx\n builtin_memcpy_read_str (void *data, void *, HOST_WIDE_INT offset,\n-\t\t\t scalar_int_mode mode)\n+\t\t\t fixed_size_mode mode)\n {\n   /* The REPresentation pointed to by DATA need not be a nul-terminated\n      string but the caller guarantees it's large enough for MODE.  */\n   const char *rep = (const char *) data;\n \n-  return c_readstr (rep + offset, mode, /*nul_terminated=*/false);\n+  /* The by-pieces infrastructure does not try to pick a vector mode\n+     for memcpy expansion.  */\n+  return c_readstr (rep + offset, as_a <scalar_int_mode> (mode),\n+\t\t    /*nul_terminated=*/false);\n }\n \n /* LEN specify length of the block of memcpy/memset operation.\n@@ -3742,14 +3745,16 @@ expand_builtin_stpncpy (tree exp, rtx)\n \n rtx\n builtin_strncpy_read_str (void *data, void *, HOST_WIDE_INT offset,\n-\t\t\t  scalar_int_mode mode)\n+\t\t\t  fixed_size_mode mode)\n {\n   const char *str = (const char *) data;\n \n   if ((unsigned HOST_WIDE_INT) offset > strlen (str))\n     return const0_rtx;\n \n-  return c_readstr (str + offset, mode);\n+  /* The by-pieces infrastructure does not try to pick a vector mode\n+     for strncpy expansion.  */\n+  return c_readstr (str + offset, as_a <scalar_int_mode> (mode));\n }\n \n /* Helper to check the sizes of sequences and the destination of calls\n@@ -3950,30 +3955,122 @@ expand_builtin_strncpy (tree exp, rtx target)\n   return NULL_RTX;\n }\n \n-/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n-   bytes from constant string DATA + OFFSET and return it as target\n-   constant.  If PREV isn't nullptr, it has the RTL info from the\n+/* Return the RTL of a register in MODE generated from PREV in the\n    previous iteration.  */\n \n-rtx\n-builtin_memset_read_str (void *data, void *prevp,\n-\t\t\t HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n-\t\t\t scalar_int_mode mode)\n+static rtx\n+gen_memset_value_from_prev (by_pieces_prev *prev, fixed_size_mode mode)\n {\n-  by_pieces_prev *prev = (by_pieces_prev *) prevp;\n+  rtx target = nullptr;\n   if (prev != nullptr && prev->data != nullptr)\n     {\n       /* Use the previous data in the same mode.  */\n       if (prev->mode == mode)\n \treturn prev->data;\n+\n+      fixed_size_mode prev_mode = prev->mode;\n+\n+      /* Don't use the previous data to write QImode if it is in a\n+\t vector mode.  */\n+      if (VECTOR_MODE_P (prev_mode) && mode == QImode)\n+\treturn target;\n+\n+      rtx prev_rtx = prev->data;\n+\n+      if (REG_P (prev_rtx)\n+\t  && HARD_REGISTER_P (prev_rtx)\n+\t  && lowpart_subreg_regno (REGNO (prev_rtx), prev_mode, mode) < 0)\n+\t{\n+\t  /* This case occurs when PREV_MODE is a vector and when\n+\t     MODE is too small to store using vector operations.\n+\t     After register allocation, the code will need to move the\n+\t     lowpart of the vector register into a non-vector register.\n+\n+\t     Also, the target has chosen to use a hard register\n+\t     instead of going with the default choice of using a\n+\t     pseudo register.  We should respect that choice and try to\n+\t     avoid creating a pseudo register with the same mode as the\n+\t     current hard register.\n+\n+\t     In principle, we could just use a lowpart MODE subreg of\n+\t     the vector register.  However, the vector register mode might\n+\t     be too wide for non-vector registers, and we already know\n+\t     that the non-vector mode is too small for vector registers.\n+\t     It's therefore likely that we'd need to spill to memory in\n+\t     the vector mode and reload the non-vector value from there.\n+\n+\t     Try to avoid that by reducing the vector register to the\n+\t     smallest size that it can hold.  This should increase the\n+\t     chances that non-vector registers can hold both the inner\n+\t     and outer modes of the subreg that we generate later.  */\n+\t  machine_mode m;\n+\t  fixed_size_mode candidate;\n+\t  FOR_EACH_MODE_IN_CLASS (m, GET_MODE_CLASS (mode))\n+\t    if (is_a<fixed_size_mode> (m, &candidate))\n+\t      {\n+\t\tif (GET_MODE_SIZE (candidate)\n+\t\t    >= GET_MODE_SIZE (prev_mode))\n+\t\t  break;\n+\t\tif (GET_MODE_SIZE (candidate) >= GET_MODE_SIZE (mode)\n+\t\t    && lowpart_subreg_regno (REGNO (prev_rtx),\n+\t\t\t\t\t     prev_mode, candidate) >= 0)\n+\t\t  {\n+\t\t    target = lowpart_subreg (candidate, prev_rtx,\n+\t\t\t\t\t     prev_mode);\n+\t\t    prev_rtx = target;\n+\t\t    prev_mode = candidate;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  if (target == nullptr)\n+\t    prev_rtx = copy_to_reg (prev_rtx);\n+\t}\n+\n+      target = lowpart_subreg (mode, prev_rtx, prev_mode);\n     }\n+  return target;\n+}\n \n+/* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n+   bytes from constant string DATA + OFFSET and return it as target\n+   constant.  If PREV isn't nullptr, it has the RTL info from the\n+   previous iteration.  */\n+\n+rtx\n+builtin_memset_read_str (void *data, void *prev,\n+\t\t\t HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n+\t\t\t fixed_size_mode mode)\n+{\n   const char *c = (const char *) data;\n-  char *p = XALLOCAVEC (char, GET_MODE_SIZE (mode));\n+  unsigned int size = GET_MODE_SIZE (mode);\n+\n+  rtx target = gen_memset_value_from_prev ((by_pieces_prev *) prev,\n+\t\t\t\t\t   mode);\n+  if (target != nullptr)\n+    return target;\n+  rtx src = gen_int_mode (*c, QImode);\n \n-  memset (p, *c, GET_MODE_SIZE (mode));\n+  if (VECTOR_MODE_P (mode))\n+    {\n+      gcc_assert (GET_MODE_INNER (mode) == QImode);\n+\n+      rtx const_vec = gen_const_vec_duplicate (mode, src);\n+      if (prev == NULL)\n+\t/* Return CONST_VECTOR when called by a query function.  */\n+\treturn const_vec;\n+\n+      /* Use the move expander with CONST_VECTOR.  */\n+      target = targetm.gen_memset_scratch_rtx (mode);\n+      emit_move_insn (target, const_vec);\n+      return target;\n+    }\n+\n+  char *p = XALLOCAVEC (char, size);\n+\n+  memset (p, *c, size);\n \n-  return c_readstr (p, mode);\n+  /* Vector modes should be handled above.  */\n+  return c_readstr (p, as_a <scalar_int_mode> (mode));\n }\n \n /* Callback routine for store_by_pieces.  Return the RTL of a register\n@@ -3983,33 +4080,45 @@ builtin_memset_read_str (void *data, void *prevp,\n    nullptr, it has the RTL info from the previous iteration.  */\n \n static rtx\n-builtin_memset_gen_str (void *data, void *prevp,\n+builtin_memset_gen_str (void *data, void *prev,\n \t\t\tHOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n-\t\t\tscalar_int_mode mode)\n+\t\t\tfixed_size_mode mode)\n {\n   rtx target, coeff;\n   size_t size;\n   char *p;\n \n-  by_pieces_prev *prev = (by_pieces_prev *) prevp;\n-  if (prev != nullptr && prev->data != nullptr)\n-    {\n-      /* Use the previous data in the same mode.  */\n-      if (prev->mode == mode)\n-\treturn prev->data;\n-\n-      target = simplify_gen_subreg (mode, prev->data, prev->mode, 0);\n-      if (target != nullptr)\n-\treturn target;\n-    }\n-\n   size = GET_MODE_SIZE (mode);\n   if (size == 1)\n     return (rtx) data;\n \n+  target = gen_memset_value_from_prev ((by_pieces_prev *) prev, mode);\n+  if (target != nullptr)\n+    return target;\n+\n+  if (VECTOR_MODE_P (mode))\n+    {\n+      gcc_assert (GET_MODE_INNER (mode) == QImode);\n+\n+      /* vec_duplicate_optab is a precondition to pick a vector mode for\n+\t the memset expander.  */\n+      insn_code icode = optab_handler (vec_duplicate_optab, mode);\n+\n+      target = targetm.gen_memset_scratch_rtx (mode);\n+      class expand_operand ops[2];\n+      create_output_operand (&ops[0], target, mode);\n+      create_input_operand (&ops[1], (rtx) data, QImode);\n+      expand_insn (icode, 2, ops);\n+      if (!rtx_equal_p (target, ops[0].value))\n+\temit_move_insn (target, ops[0].value);\n+\n+      return target;\n+    }\n+\n   p = XALLOCAVEC (char, size);\n   memset (p, 1, size);\n-  coeff = c_readstr (p, mode);\n+  /* Vector modes should be handled above.  */\n+  coeff = c_readstr (p, as_a <scalar_int_mode> (mode));\n \n   target = convert_to_mode (mode, (rtx) data, 1);\n   target = expand_mult (mode, target, coeff, NULL_RTX, 1);\n@@ -4113,7 +4222,7 @@ try_store_by_multiple_pieces (rtx to, rtx len, unsigned int ctz_len,\n \t\t\t    &valc, align, true))\n     return false;\n \n-  rtx (*constfun) (void *, void *, HOST_WIDE_INT, scalar_int_mode);\n+  by_pieces_constfn constfun;\n   void *constfundata;\n   if (val)\n     {"}, {"sha": "024ddbfa704dac4563a03e6e94bd4d5d786e219c", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -111,9 +111,9 @@ extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree mathfn_built_in (tree, combined_fn);\n extern tree mathfn_built_in_type (combined_fn);\n extern rtx builtin_strncpy_read_str (void *, void *, HOST_WIDE_INT,\n-\t\t\t\t     scalar_int_mode);\n+\t\t\t\t     fixed_size_mode);\n extern rtx builtin_memset_read_str (void *, void *, HOST_WIDE_INT,\n-\t\t\t\t    scalar_int_mode);\n+\t\t\t\t    fixed_size_mode);\n extern rtx expand_builtin_saveregs (void);\n extern tree std_build_builtin_va_list (void);\n extern tree std_fn_abi_va_list (tree);"}, {"sha": "cb015283237c5892eddfe5ed17fad09596e8ed44", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -12158,6 +12158,13 @@ This function prepares to emit a conditional comparison within a sequence\n  @var{bit_code} is @code{AND} or @code{IOR}, which is the op on the compares.\n @end deftypefn\n \n+@deftypefn {Target Hook} rtx TARGET_GEN_MEMSET_SCRATCH_RTX (machine_mode @var{mode})\n+This hook should return an rtx for a scratch register in @var{mode} to\n+be used when expanding memset calls.  The backend can use a hard scratch\n+register to avoid stack realignment when expanding memset.  The default\n+is @code{gen_reg_rtx}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned @var{nunroll}, class loop *@var{loop})\n This target hook returns a new value for the number of times @var{loop}\n should be unrolled. The parameter @var{nunroll} is the number of times"}, {"sha": "4a522ae7e2e53a084311c53600589dff4269b441", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -7986,6 +7986,8 @@ lists.\n \n @hook TARGET_GEN_CCMP_NEXT\n \n+@hook TARGET_GEN_MEMSET_SCRATCH_RTX\n+\n @hook TARGET_LOOP_UNROLL_ADJUST\n \n @defmac POWI_MAX_MULTS"}, {"sha": "b65cfcfdcd10e349f2aa3eef6f36c63274a26965", "filename": "gcc/expr.c", "status": "modified", "additions": 120, "deletions": 52, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -769,15 +769,36 @@ alignment_for_piecewise_move (unsigned int max_pieces, unsigned int align)\n   return align;\n }\n \n-/* Return the widest integer mode that is narrower than SIZE bytes.  */\n+/* Return the widest QI vector, if QI_MODE is true, or integer mode\n+   that is narrower than SIZE bytes.  */\n \n-static scalar_int_mode\n-widest_int_mode_for_size (unsigned int size)\n+static fixed_size_mode\n+widest_fixed_size_mode_for_size (unsigned int size, bool qi_vector)\n {\n-  scalar_int_mode result = NARROWEST_INT_MODE;\n+  fixed_size_mode result = NARROWEST_INT_MODE;\n \n   gcc_checking_assert (size > 1);\n \n+  /* Use QI vector only if size is wider than a WORD.  */\n+  if (qi_vector && size > UNITS_PER_WORD)\n+    {\n+      machine_mode mode;\n+      fixed_size_mode candidate;\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n+\tif (is_a<fixed_size_mode> (mode, &candidate)\n+\t    && GET_MODE_INNER (candidate) == QImode)\n+\t  {\n+\t    if (GET_MODE_SIZE (candidate) >= size)\n+\t      break;\n+\t    if (optab_handler (vec_duplicate_optab, candidate)\n+\t\t!= CODE_FOR_nothing)\n+\t      result = candidate;\n+\t  }\n+\n+      if (result != NARROWEST_INT_MODE)\n+\treturn result;\n+    }\n+\n   opt_scalar_int_mode tmode;\n   FOR_EACH_MODE_IN_CLASS (tmode, MODE_INT)\n     if (GET_MODE_SIZE (tmode.require ()) < size)\n@@ -815,13 +836,14 @@ by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n \t\t  unsigned int max_size, by_pieces_operation op)\n {\n   unsigned HOST_WIDE_INT n_insns = 0;\n-  scalar_int_mode mode;\n+  fixed_size_mode mode;\n \n   if (targetm.overlap_op_by_pieces_p () && op != COMPARE_BY_PIECES)\n     {\n       /* NB: Round up L and ALIGN to the widest integer mode for\n \t MAX_SIZE.  */\n-      mode = widest_int_mode_for_size (max_size);\n+      mode = widest_fixed_size_mode_for_size (max_size,\n+\t\t\t\t\t      op == SET_BY_PIECES);\n       if (optab_handler (mov_optab, mode) != CODE_FOR_nothing)\n \t{\n \t  unsigned HOST_WIDE_INT up = ROUND_UP (l, GET_MODE_SIZE (mode));\n@@ -835,7 +857,8 @@ by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n \n   while (max_size > 1 && l > 0)\n     {\n-      mode = widest_int_mode_for_size (max_size);\n+      mode = widest_fixed_size_mode_for_size (max_size,\n+\t\t\t\t\t      op == SET_BY_PIECES);\n       enum insn_code icode;\n \n       unsigned int modesize = GET_MODE_SIZE (mode);\n@@ -903,8 +926,7 @@ class pieces_addr\n   void *m_cfndata;\n public:\n   pieces_addr (rtx, bool, by_pieces_constfn, void *);\n-  rtx adjust (scalar_int_mode, HOST_WIDE_INT,\n-\t      by_pieces_prev * = nullptr);\n+  rtx adjust (fixed_size_mode, HOST_WIDE_INT, by_pieces_prev * = nullptr);\n   void increment_address (HOST_WIDE_INT);\n   void maybe_predec (HOST_WIDE_INT);\n   void maybe_postinc (HOST_WIDE_INT);\n@@ -1006,7 +1028,7 @@ pieces_addr::decide_autoinc (machine_mode ARG_UNUSED (mode), bool reverse,\n    but we still modify the MEM's properties.  */\n \n rtx\n-pieces_addr::adjust (scalar_int_mode mode, HOST_WIDE_INT offset,\n+pieces_addr::adjust (fixed_size_mode mode, HOST_WIDE_INT offset,\n \t\t     by_pieces_prev *prev)\n {\n   if (m_constfn)\n@@ -1060,11 +1082,14 @@ pieces_addr::maybe_postinc (HOST_WIDE_INT size)\n class op_by_pieces_d\n {\n  private:\n-  scalar_int_mode get_usable_mode (scalar_int_mode mode, unsigned int);\n+  fixed_size_mode get_usable_mode (fixed_size_mode, unsigned int);\n+  fixed_size_mode smallest_fixed_size_mode_for_size (unsigned int);\n \n  protected:\n   pieces_addr m_to, m_from;\n-  unsigned HOST_WIDE_INT m_len;\n+  /* Make m_len read-only so that smallest_fixed_size_mode_for_size can\n+     use it to check the valid mode size.  */\n+  const unsigned HOST_WIDE_INT m_len;\n   HOST_WIDE_INT m_offset;\n   unsigned int m_align;\n   unsigned int m_max_size;\n@@ -1073,6 +1098,8 @@ class op_by_pieces_d\n   bool m_push;\n   /* True if targetm.overlap_op_by_pieces_p () returns true.  */\n   bool m_overlap_op_by_pieces;\n+  /* True if QI vector mode can be used.  */\n+  bool m_qi_vector_mode;\n \n   /* Virtual functions, overriden by derived classes for the specific\n      operation.  */\n@@ -1084,7 +1111,8 @@ class op_by_pieces_d\n \n  public:\n   op_by_pieces_d (rtx, bool, rtx, bool, by_pieces_constfn, void *,\n-\t\t  unsigned HOST_WIDE_INT, unsigned int, bool);\n+\t\t  unsigned HOST_WIDE_INT, unsigned int, bool,\n+\t\t  bool = false);\n   void run ();\n };\n \n@@ -1099,11 +1127,12 @@ op_by_pieces_d::op_by_pieces_d (rtx to, bool to_load,\n \t\t\t\tby_pieces_constfn from_cfn,\n \t\t\t\tvoid *from_cfn_data,\n \t\t\t\tunsigned HOST_WIDE_INT len,\n-\t\t\t\tunsigned int align, bool push)\n+\t\t\t\tunsigned int align, bool push,\n+\t\t\t\tbool qi_vector_mode)\n   : m_to (to, to_load, NULL, NULL),\n     m_from (from, from_load, from_cfn, from_cfn_data),\n     m_len (len), m_max_size (MOVE_MAX_PIECES + 1),\n-    m_push (push)\n+    m_push (push), m_qi_vector_mode (qi_vector_mode)\n {\n   int toi = m_to.get_addr_inc ();\n   int fromi = m_from.get_addr_inc ();\n@@ -1124,7 +1153,9 @@ op_by_pieces_d::op_by_pieces_d (rtx to, bool to_load,\n   if (by_pieces_ninsns (len, align, m_max_size, MOVE_BY_PIECES) > 2)\n     {\n       /* Find the mode of the largest comparison.  */\n-      scalar_int_mode mode = widest_int_mode_for_size (m_max_size);\n+      fixed_size_mode mode\n+\t= widest_fixed_size_mode_for_size (m_max_size,\n+\t\t\t\t\t   m_qi_vector_mode);\n \n       m_from.decide_autoinc (mode, m_reverse, len);\n       m_to.decide_autoinc (mode, m_reverse, len);\n@@ -1139,22 +1170,51 @@ op_by_pieces_d::op_by_pieces_d (rtx to, bool to_load,\n /* This function returns the largest usable integer mode for LEN bytes\n    whose size is no bigger than size of MODE.  */\n \n-scalar_int_mode\n-op_by_pieces_d::get_usable_mode (scalar_int_mode mode, unsigned int len)\n+fixed_size_mode\n+op_by_pieces_d::get_usable_mode (fixed_size_mode mode, unsigned int len)\n {\n   unsigned int size;\n   do\n     {\n       size = GET_MODE_SIZE (mode);\n       if (len >= size && prepare_mode (mode, m_align))\n \tbreak;\n-      /* NB: widest_int_mode_for_size checks SIZE > 1.  */\n-      mode = widest_int_mode_for_size (size);\n+      /* widest_fixed_size_mode_for_size checks SIZE > 1.  */\n+      mode = widest_fixed_size_mode_for_size (size, m_qi_vector_mode);\n     }\n   while (1);\n   return mode;\n }\n \n+/* Return the smallest integer or QI vector mode that is not narrower\n+   than SIZE bytes.  */\n+\n+fixed_size_mode\n+op_by_pieces_d::smallest_fixed_size_mode_for_size (unsigned int size)\n+{\n+  /* Use QI vector only for > size of WORD.  */\n+  if (m_qi_vector_mode && size > UNITS_PER_WORD)\n+    {\n+      machine_mode mode;\n+      fixed_size_mode candidate;\n+      FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n+\tif (is_a<fixed_size_mode> (mode, &candidate)\n+\t    && GET_MODE_INNER (candidate) == QImode)\n+\t  {\n+\t    /* Don't return a mode wider than M_LEN.  */\n+\t    if (GET_MODE_SIZE (candidate) > m_len)\n+\t      break;\n+\n+\t    if (GET_MODE_SIZE (candidate) >= size\n+\t\t&& (optab_handler (vec_duplicate_optab, candidate)\n+\t\t    != CODE_FOR_nothing))\n+\t      return candidate;\n+\t  }\n+    }\n+\n+  return smallest_int_mode_for_size (size * BITS_PER_UNIT);\n+}\n+\n /* This function contains the main loop used for expanding a block\n    operation.  First move what we can in the largest integer mode,\n    then go to successively smaller modes.  For every access, call\n@@ -1166,9 +1226,12 @@ op_by_pieces_d::run ()\n   if (m_len == 0)\n     return;\n \n-  /* NB: widest_int_mode_for_size checks M_MAX_SIZE > 1.  */\n-  scalar_int_mode mode = widest_int_mode_for_size (m_max_size);\n-  mode = get_usable_mode (mode, m_len);\n+  unsigned HOST_WIDE_INT length = m_len;\n+\n+  /* widest_fixed_size_mode_for_size checks M_MAX_SIZE > 1.  */\n+  fixed_size_mode mode\n+    = widest_fixed_size_mode_for_size (m_max_size, m_qi_vector_mode);\n+  mode = get_usable_mode (mode, length);\n \n   by_pieces_prev to_prev = { nullptr, mode };\n   by_pieces_prev from_prev = { nullptr, mode };\n@@ -1178,7 +1241,7 @@ op_by_pieces_d::run ()\n       unsigned int size = GET_MODE_SIZE (mode);\n       rtx to1 = NULL_RTX, from1;\n \n-      while (m_len >= size)\n+      while (length >= size)\n \t{\n \t  if (m_reverse)\n \t    m_offset -= size;\n@@ -1201,22 +1264,22 @@ op_by_pieces_d::run ()\n \t  if (!m_reverse)\n \t    m_offset += size;\n \n-\t  m_len -= size;\n+\t  length -= size;\n \t}\n \n       finish_mode (mode);\n \n-      if (m_len == 0)\n+      if (length == 0)\n \treturn;\n \n       if (!m_push && m_overlap_op_by_pieces)\n \t{\n \t  /* NB: Generate overlapping operations if it is not a stack\n \t     push since stack push must not overlap.  Get the smallest\n-\t     integer mode for M_LEN bytes.  */\n-\t  mode = smallest_int_mode_for_size (m_len * BITS_PER_UNIT);\n+\t     fixed size mode for M_LEN bytes.  */\n+\t  mode = smallest_fixed_size_mode_for_size (length);\n \t  mode = get_usable_mode (mode, GET_MODE_SIZE (mode));\n-\t  int gap = GET_MODE_SIZE (mode) - m_len;\n+\t  int gap = GET_MODE_SIZE (mode) - length;\n \t  if (gap > 0)\n \t    {\n \t      /* If size of MODE > M_LEN, generate the last operation\n@@ -1226,20 +1289,21 @@ op_by_pieces_d::run ()\n \t\tm_offset += gap;\n \t      else\n \t\tm_offset -= gap;\n-\t      m_len += gap;\n+\t      length += gap;\n \t    }\n \t}\n       else\n \t{\n-\t  /* NB: widest_int_mode_for_size checks SIZE > 1.  */\n-\t  mode = widest_int_mode_for_size (size);\n-\t  mode = get_usable_mode (mode, m_len);\n+\t  /* widest_fixed_size_mode_for_size checks SIZE > 1.  */\n+\t  mode = widest_fixed_size_mode_for_size (size,\n+\t\t\t\t\t\t  m_qi_vector_mode);\n+\t  mode = get_usable_mode (mode, length);\n \t}\n     }\n   while (1);\n \n   /* The code above should have handled everything.  */\n-  gcc_assert (!m_len);\n+  gcc_assert (!length);\n }\n \n /* Derived class from op_by_pieces_d, providing support for block move\n@@ -1355,9 +1419,10 @@ class store_by_pieces_d : public op_by_pieces_d\n \n  public:\n   store_by_pieces_d (rtx to, by_pieces_constfn cfn, void *cfn_data,\n-\t\t     unsigned HOST_WIDE_INT len, unsigned int align)\n+\t\t     unsigned HOST_WIDE_INT len, unsigned int align,\n+\t\t     bool qi_vector_mode)\n     : op_by_pieces_d (to, false, NULL_RTX, true, cfn, cfn_data, len,\n-\t\t      align, false)\n+\t\t      align, false, qi_vector_mode)\n   {\n   }\n   rtx finish_retmode (memop_ret);\n@@ -1446,7 +1511,8 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n       max_size = STORE_MAX_PIECES + 1;\n       while (max_size > 1 && l > 0)\n \t{\n-\t  scalar_int_mode mode = widest_int_mode_for_size (max_size);\n+\t  fixed_size_mode mode\n+\t    = widest_fixed_size_mode_for_size (max_size, memsetp);\n \n \t  icode = optab_handler (mov_optab, mode);\n \t  if (icode != CODE_FOR_nothing\n@@ -1460,7 +1526,11 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \t\t    offset -= size;\n \n \t\t  cst = (*constfun) (constfundata, nullptr, offset, mode);\n-\t\t  if (!targetm.legitimate_constant_p (mode, cst))\n+\t\t  /* All CONST_VECTORs can be loaded for memset since\n+\t\t     vec_duplicate_optab is a precondition to pick a\n+\t\t     vector mode for the memset expander.  */\n+\t\t  if (!((memsetp && VECTOR_MODE_P (mode))\n+\t\t\t|| targetm.legitimate_constant_p (mode, cst)))\n \t\t    return 0;\n \n \t\t  if (!reverse)\n@@ -1504,7 +1574,8 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t\t memsetp ? SET_BY_PIECES : STORE_BY_PIECES,\n \t\t optimize_insn_for_speed_p ()));\n \n-  store_by_pieces_d data (to, constfun, constfundata, len, align);\n+  store_by_pieces_d data (to, constfun, constfundata, len, align,\n+\t\t\t  memsetp);\n   data.run ();\n \n   if (retmode != RETURN_BEGIN)\n@@ -1513,15 +1584,6 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n     return to;\n }\n \n-/* Callback routine for clear_by_pieces.\n-   Return const0_rtx unconditionally.  */\n-\n-static rtx\n-clear_by_pieces_1 (void *, void *, HOST_WIDE_INT, scalar_int_mode)\n-{\n-  return const0_rtx;\n-}\n-\n /* Generate several move instructions to clear LEN bytes of block TO.  (A MEM\n    rtx with BLKmode).  ALIGN is maximum alignment we can assume.  */\n \n@@ -1531,7 +1593,10 @@ clear_by_pieces (rtx to, unsigned HOST_WIDE_INT len, unsigned int align)\n   if (len == 0)\n     return;\n \n-  store_by_pieces_d data (to, clear_by_pieces_1, NULL, len, align);\n+  /* Use builtin_memset_read_str to support vector mode broadcast.  */\n+  char c = 0;\n+  store_by_pieces_d data (to, builtin_memset_read_str, &c, len, align,\n+\t\t\t  true);\n   data.run ();\n }\n \n@@ -5754,7 +5819,7 @@ emit_storent_insn (rtx to, rtx from)\n \n static rtx\n string_cst_read_str (void *data, void *, HOST_WIDE_INT offset,\n-\t\t     scalar_int_mode mode)\n+\t\t     fixed_size_mode mode)\n {\n   tree str = (tree) data;\n \n@@ -5769,10 +5834,13 @@ string_cst_read_str (void *data, void *, HOST_WIDE_INT offset,\n       size_t l = TREE_STRING_LENGTH (str) - offset;\n       memcpy (p, TREE_STRING_POINTER (str) + offset, l);\n       memset (p + l, '\\0', GET_MODE_SIZE (mode) - l);\n-      return c_readstr (p, mode, false);\n+      return c_readstr (p, as_a <scalar_int_mode> (mode), false);\n     }\n \n-  return c_readstr (TREE_STRING_POINTER (str) + offset, mode, false);\n+  /* The by-pieces infrastructure does not try to pick a vector mode\n+     for storing STRING_CST.  */\n+  return c_readstr (TREE_STRING_POINTER (str) + offset,\n+\t\t    as_a <scalar_int_mode> (mode), false);\n }\n \n /* Generate code for computing expression EXP,"}, {"sha": "94a85b40dcaa585199ab365dde25620527322eda", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -108,13 +108,13 @@ enum block_op_methods\n };\n \n typedef rtx (*by_pieces_constfn) (void *, void *, HOST_WIDE_INT,\n-\t\t\t\t  scalar_int_mode);\n+\t\t\t\t  fixed_size_mode);\n \n /* The second pointer passed to by_pieces_constfn.  */\n struct by_pieces_prev\n {\n   rtx data;\n-  scalar_int_mode mode;\n+  fixed_size_mode mode;\n };\n \n extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);"}, {"sha": "5fdcdfcd728b2c6c88fb0c8add0c0418163d7461", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -2460,6 +2460,8 @@ extern bool subreg_offset_representable_p (unsigned int, machine_mode,\n extern unsigned int subreg_regno (const_rtx);\n extern int simplify_subreg_regno (unsigned int, machine_mode,\n \t\t\t\t  poly_uint64, machine_mode);\n+extern int lowpart_subreg_regno (unsigned int, machine_mode,\n+\t\t\t\t machine_mode);\n extern unsigned int subreg_nregs (const_rtx);\n extern unsigned int subreg_nregs_with_regno (unsigned int, const_rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (const_rtx, machine_mode);"}, {"sha": "3b8d88afd4dcc931c6c72b2acdaec4d594290bc0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -4325,6 +4325,17 @@ simplify_subreg_regno (unsigned int xregno, machine_mode xmode,\n   return (int) yregno;\n }\n \n+/* A wrapper around simplify_subreg_regno that uses subreg_lowpart_offset\n+   (xmode, ymode) as the offset.  */\n+\n+int\n+lowpart_subreg_regno (unsigned int regno, machine_mode xmode,\n+\t\t      machine_mode ymode)\n+{\n+  poly_uint64 offset = subreg_lowpart_offset (xmode, ymode);\n+  return simplify_subreg_regno (regno, xmode, offset, ymode);\n+}\n+\n /* Return the final regno that a subreg expression refers to.  */\n unsigned int\n subreg_regno (const_rtx x)"}, {"sha": "68a46aaa832ffb92b64c71cf9dfedad025ea6ace", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -2726,6 +2726,15 @@ DEFHOOK\n  rtx, (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code),\n  NULL)\n \n+DEFHOOK\n+(gen_memset_scratch_rtx,\n+ \"This hook should return an rtx for a scratch register in @var{mode} to\\n\\\n+be used when expanding memset calls.  The backend can use a hard scratch\\n\\\n+register to avoid stack realignment when expanding memset.  The default\\n\\\n+is @code{gen_reg_rtx}.\",\n+ rtx, (machine_mode mode),\n+ gen_reg_rtx)\n+\n /* Return a new value for loop unroll size.  */\n DEFHOOK\n (loop_unroll_adjust,"}, {"sha": "007e79f91b0804639cfe2e807eaed754144b2b03", "filename": "gcc/testsuite/gcc.target/i386/pr100865-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100865-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100865-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100865-3.c?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -10,6 +10,6 @@ foo (void)\n }\n \n /* { dg-final { scan-assembler-times \"vpbroadcastb\\[\\\\t \\]+%(?:r|e)\\[^\\n\\]*, %xmm\\[0-9\\]+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vmovdqu\\[\\\\t \\]%xmm\\[0-9\\]+, \\\\(%\\[\\^,\\]+\\\\)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmovdqu8\\[\\\\t \\]%xmm\\[0-9\\]+, \\\\(%\\[\\^,\\]+\\\\)\" 1 } } */\n /* { dg-final { scan-assembler-not \"vpbroadcastb\\[\\\\t \\]+%xmm\\[0-9\\]+, %xmm\\[0-9\\]+\" } } */\n /* { dg-final { scan-assembler-not \"vmovdqa\" } } */"}, {"sha": "1e50dc842bc483cbe0eef3137e2c7ff068f0eeee", "filename": "gcc/testsuite/gcc.target/i386/pr100865-4b.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100865-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e164effa30fd2b5c5bc3e6883d63889e96d8da/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100865-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100865-4b.c?ref=e5e164effa30fd2b5c5bc3e6883d63889e96d8da", "patch": "@@ -4,6 +4,6 @@\n #include \"pr100865-4a.c\"\n \n /* { dg-final { scan-assembler-times \"vpbroadcastb\\[\\\\t \\]+%(?:r|e)\\[^\\n\\]*, %xmm\\[0-9\\]+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vmovdqu\\[\\\\t \\]%xmm\\[0-9\\]+, \" 4 } } */\n+/* { dg-final { scan-assembler-times \"vmovdqu8\\[\\\\t \\]%xmm\\[0-9\\]+, \" 4 } } */\n /* { dg-final { scan-assembler-not \"vpbroadcastb\\[\\\\t \\]+%xmm\\[0-9\\]+, %xmm\\[0-9\\]+\" } } */\n /* { dg-final { scan-assembler-not \"vmovdqa\" } } */"}]}