{"sha": "3b4ebfc31bb3c1a81119f71e0d7cf08952471019", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0ZWJmYzMxYmIzYzFhODExMTlmNzFlMGQ3Y2YwODk1MjQ3MTAxOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-04-29T13:21:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T13:21:10Z"}, "message": "sem_util.adb (May_Be_Lvalue): Fix cases involving indexed/selected components\n\n2009-04-29  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.adb (May_Be_Lvalue): Fix cases involving indexed/selected\n\tcomponents\n\nFrom-SVN: r146963", "tree": {"sha": "f9a9df5616d3760e7879b0d08770f81e0de8b283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9a9df5616d3760e7879b0d08770f81e0de8b283"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b4ebfc31bb3c1a81119f71e0d7cf08952471019", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4ebfc31bb3c1a81119f71e0d7cf08952471019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b4ebfc31bb3c1a81119f71e0d7cf08952471019", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4ebfc31bb3c1a81119f71e0d7cf08952471019/comments", "author": null, "committer": null, "parents": [{"sha": "0c463e161734f80cedd2b771bee49e7ee6be0f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c463e161734f80cedd2b771bee49e7ee6be0f05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c463e161734f80cedd2b771bee49e7ee6be0f05"}], "stats": {"total": 58, "additions": 49, "deletions": 9}, "files": [{"sha": "d51fddbcc4e6b0a0208fbc7802e17672b2591f83", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4ebfc31bb3c1a81119f71e0d7cf08952471019/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4ebfc31bb3c1a81119f71e0d7cf08952471019/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3b4ebfc31bb3c1a81119f71e0d7cf08952471019", "patch": "@@ -1,3 +1,8 @@\n+2009-04-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.adb (May_Be_Lvalue): Fix cases involving indexed/selected\n+\tcomponents\n+\n 2009-04-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch9.ads, exp_ch9.adb (Build_Wrapper_Spec): Use source line of"}, {"sha": "e76e9d2c987aa7bb4da6c0f79ee6b16a521e1880", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4ebfc31bb3c1a81119f71e0d7cf08952471019/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4ebfc31bb3c1a81119f71e0d7cf08952471019/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3b4ebfc31bb3c1a81119f71e0d7cf08952471019", "patch": "@@ -7259,23 +7259,58 @@ package body Sem_Util is\n             return N = Prefix (P)\n               and then Name_Implies_Lvalue_Prefix (Attribute_Name (P));\n \n-         when N_Expanded_Name        |\n-              N_Indexed_Component    |\n-              N_Selected_Component   |\n-              N_Slice                =>\n-            if Is_Access_Type (Etype (N)) then\n-               return False;  --  P is an implicit dereference\n+         --  For an expanded name, the name is an lvalue if the expanded name\n+         --  is an lvalue, but the prefix is never an lvalue, since it is just\n+         --  the scope where the name is found.\n+\n+         when N_Expanded_Name        =>\n+            if N = Prefix (P) then\n+               return May_Be_Lvalue (P);\n             else\n-               return N = Prefix (P);\n+               return False;\n             end if;\n \n+         --  For a selected component A.B, A is certainly an Lvalue if A.B is\n+         --  an Lvalue. B is a little interesting, if we have A.B:=3, there is\n+         --  some discussion as to whether B is an Lvalue or not, we choose to\n+         --  say it is. Note however that A is not an Lvalue if it is of an\n+         --  access type since this is an implicit dereference.\n+\n+         when N_Selected_Component   =>\n+            if N = Prefix (P)\n+              and then Present (Etype (N))\n+              and then Is_Access_Type (Etype (N))\n+            then\n+               return False;\n+            else\n+               return May_Be_Lvalue (P);\n+            end if;\n+\n+         --  For an indexed component or slice, the index or slice bounds is\n+         --  never an Lvalue. The prefix is an lvalue if the indexed component\n+         --  or slice is an Lvalue, except if it is an access type, where we\n+         --  have an implicit dereference.\n+\n+         when N_Indexed_Component    =>\n+            if N /= Prefix (P)\n+              or else (Present (Etype (N)) and then Is_Access_Type (Etype (N)))\n+            then\n+               return False;\n+            else\n+               return May_Be_Lvalue (P);\n+            end if;\n+\n+         --  Prefix of a reference is an Lvalue if the reference is an Lvalue\n+\n          when N_Reference            =>\n-            return N = Prefix (P);\n+            return May_Be_Lvalue (P);\n+\n+         --  Prefix of explicit dereference is never an Lvalue\n \n          when N_Explicit_Dereference =>\n             return False;\n \n-         --  Function call arguments are never lvalues\n+         --  Function call arguments are never Lvalues\n \n          when N_Function_Call =>\n             return False;"}]}