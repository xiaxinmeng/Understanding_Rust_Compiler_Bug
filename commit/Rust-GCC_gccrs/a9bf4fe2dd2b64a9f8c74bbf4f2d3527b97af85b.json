{"sha": "a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTliZjRmZTJkZDJiNjRhOWY4Yzc0YmJmNGYyZDM1MjdiOTdhZjg1Yg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-06-22T01:30:16Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-06-22T01:30:16Z"}, "message": "re PR debug/53671 (Many guality test failures)\n\nPR debug/53671\nPR debug/49888\n* alias.c (memrefs_conflict_p): Improve handling of AND for\nalignment.\n\nFrom-SVN: r188868", "tree": {"sha": "e05c081d7dd22a96f2bb18fb320a80b010d911d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e05c081d7dd22a96f2bb18fb320a80b010d911d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b/comments", "author": null, "committer": null, "parents": [{"sha": "1ca63357cb07ce7c61ad275d8f870187d8dd8950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca63357cb07ce7c61ad275d8f870187d8dd8950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ca63357cb07ce7c61ad275d8f870187d8dd8950"}], "stats": {"total": 42, "additions": 28, "deletions": 14}, "files": [{"sha": "70785f82146bea7f313cbbdcb994f01303041a75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b", "patch": "@@ -1,3 +1,10 @@\n+2012-06-21  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/53671\n+\tPR debug/49888\n+\t* alias.c (memrefs_conflict_p): Improve handling of AND for\n+\talignment.\n+\n 2012-06-21  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* ddg.c (build_intra_loop_deps): Discard deps of nondebug on debug."}, {"sha": "b6aca343f06a157f276355536bba76e05451e2fc", "filename": "gcc/alias.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=a9bf4fe2dd2b64a9f8c74bbf4f2d3527b97af85b", "patch": "@@ -2097,25 +2097,32 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \tbreak;\n       }\n \n-  /* Treat an access through an AND (e.g. a subword access on an Alpha)\n-     as an access with indeterminate size.  Assume that references\n-     besides AND are aligned, so if the size of the other reference is\n-     at least as large as the alignment, assume no other overlap.  */\n+  /* Deal with alignment ANDs by adjusting offset and size so as to\n+     cover the maximum range, without taking any previously known\n+     alignment into account.  */\n   if (GET_CODE (x) == AND && CONST_INT_P (XEXP (x, 1)))\n     {\n-      if (GET_CODE (y) == AND || ysize < -INTVAL (XEXP (x, 1)))\n-\txsize = -1;\n-      return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)), ysize, y, c);\n+      HOST_WIDE_INT sc = INTVAL (XEXP (x, 1));\n+      unsigned HOST_WIDE_INT uc = sc;\n+      if (xsize > 0 && sc < 0 && -uc == (uc & -uc))\n+\t{\n+\t  xsize -= sc + 1;\n+\t  c -= sc;\n+\t  return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n+\t\t\t\t     ysize, y, c);\n+\t}\n     }\n   if (GET_CODE (y) == AND && CONST_INT_P (XEXP (y, 1)))\n     {\n-      /* ??? If we are indexing far enough into the array/structure, we\n-\t may yet be able to determine that we can not overlap.  But we\n-\t also need to that we are far enough from the end not to overlap\n-\t a following reference, so we do nothing with that for now.  */\n-      if (GET_CODE (x) == AND || xsize < -INTVAL (XEXP (y, 1)))\n-\tysize = -1;\n-      return memrefs_conflict_p (xsize, x, ysize, canon_rtx (XEXP (y, 0)), c);\n+      HOST_WIDE_INT sc = INTVAL (XEXP (y, 1));\n+      unsigned HOST_WIDE_INT uc = sc;\n+      if (ysize > 0 && sc < 0 && -uc == (uc & -uc))\n+\t{\n+\t  ysize -= sc + 1;\n+\t  c += sc;\n+\t  return memrefs_conflict_p (xsize, x,\n+\t\t\t\t     ysize, canon_rtx (XEXP (y, 0)), c);\n+\t}\n     }\n \n   if (CONSTANT_P (x))"}]}