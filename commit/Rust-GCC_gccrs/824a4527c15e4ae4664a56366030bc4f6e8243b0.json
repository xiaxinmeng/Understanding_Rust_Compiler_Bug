{"sha": "824a4527c15e4ae4664a56366030bc4f6e8243b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI0YTQ1MjdjMTVlNGFlNDY2NGE1NjM2NjAzMGJjNGY2ZTgyNDNiMA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2006-08-04T14:15:37Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2006-08-04T14:15:37Z"}, "message": "re PR rtl-optimization/26244 (FAIL: gcc.c-torture/execute/builtin-bitops-1.c execution,  -O3 -fomit-frame-pointer -funroll-loops)\n\n\tPR rtl-optimization/26244\n\t* cse.c (fold_rtx): Correctly associate shifts when const_arg1 and/or\n\tinner_const are negative or greater than or equal to the bitsize of\n\tMODE.  If SHIFT_COUNT_TRUNCATED is false, the values aren't associated.\n\tOtherwise, the values are masked using GET_MODE_BITSIZE (mode) - 1.\n\tSimplify complicated if statement.  For ASHIFT and LSHIFTRT, return\n\tCONST0_RTX (mode) when the new shift count is greater than or equal to\n\tto the bitsize of the object being shifted and XEXP (y, 0) has no side\n\teffects.\n\n\nCo-Authored-By: Roger Sayle <roger@eyesopen.com>\n\nFrom-SVN: r115924", "tree": {"sha": "5409dbf0f47dca9a57cdfb0b9da22af3175d67e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5409dbf0f47dca9a57cdfb0b9da22af3175d67e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/824a4527c15e4ae4664a56366030bc4f6e8243b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824a4527c15e4ae4664a56366030bc4f6e8243b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/824a4527c15e4ae4664a56366030bc4f6e8243b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824a4527c15e4ae4664a56366030bc4f6e8243b0/comments", "author": null, "committer": null, "parents": [{"sha": "8443c250af760dbb4489b3ff9e75bc334feba4df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8443c250af760dbb4489b3ff9e75bc334feba4df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8443c250af760dbb4489b3ff9e75bc334feba4df"}], "stats": {"total": 62, "additions": 51, "deletions": 11}, "files": [{"sha": "af93012c36eb66cff4f522d1984f4c185d758888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824a4527c15e4ae4664a56366030bc4f6e8243b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824a4527c15e4ae4664a56366030bc4f6e8243b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=824a4527c15e4ae4664a56366030bc4f6e8243b0", "patch": "@@ -1,3 +1,16 @@\n+2006-08-04  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\t    Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/26244\n+\t* cse.c (fold_rtx): Correctly associate shifts when const_arg1 and/or\n+\tinner_const are negative or greater than or equal to the bitsize of\n+\tMODE.  If SHIFT_COUNT_TRUNCATED is false, the values aren't associated.\n+\tOtherwise, the values are masked using GET_MODE_BITSIZE (mode) - 1.\n+\tSimplify complicated if statement.  For ASHIFT and LSHIFTRT, return\n+\tCONST0_RTX (mode) when the new shift count is greater than or equal to\n+\tto the bitsize of the object being shifted and XEXP (y, 0) has no side\n+\teffects.\n+\n 2006-08-04  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree-cfg.c: Fix a comment typo."}, {"sha": "fc15511dbc8a4ab0325e12161f6ec52095715e9f", "filename": "gcc/cse.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824a4527c15e4ae4664a56366030bc4f6e8243b0/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824a4527c15e4ae4664a56366030bc4f6e8243b0/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=824a4527c15e4ae4664a56366030bc4f6e8243b0", "patch": "@@ -4267,16 +4267,29 @@ fold_rtx (rtx x, rtx insn)\n \t      enum rtx_code associate_code;\n \t      rtx new_const;\n \n-\t      if (y == 0\n-\t\t  || 0 == (inner_const\n-\t\t\t   = equiv_constant (fold_rtx (XEXP (y, 1), 0)))\n-\t\t  || GET_CODE (inner_const) != CONST_INT\n-\t\t  /* If we have compiled a statement like\n-\t\t     \"if (x == (x & mask1))\", and now are looking at\n-\t\t     \"x & mask2\", we will have a case where the first operand\n-\t\t     of Y is the same as our first operand.  Unless we detect\n-\t\t     this case, an infinite loop will result.  */\n-\t\t  || XEXP (y, 0) == folded_arg0)\n+\t      if (is_shift\n+\t\t  && (INTVAL (const_arg1) >= GET_MODE_BITSIZE (mode)\n+\t\t      || INTVAL (const_arg1) < 0))\n+\t\t{\n+\t\t  if (SHIFT_COUNT_TRUNCATED)\n+\t\t    const_arg1 = GEN_INT (INTVAL (const_arg1)\n+\t\t\t\t\t  & (GET_MODE_BITSIZE (mode) - 1));\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\n+\t      if (y == 0)\n+\t\tbreak;\n+\t      inner_const = equiv_constant (fold_rtx (XEXP (y, 1), 0));\n+\t      if (!inner_const || GET_CODE (inner_const) != CONST_INT)\n+\t\tbreak;\n+\n+\t      /* If we have compiled a statement like\n+\t\t \"if (x == (x & mask1))\", and now are looking at\n+\t\t \"x & mask2\", we will have a case where the first operand\n+\t\t of Y is the same as our first operand.  Unless we detect\n+\t\t this case, an infinite loop will result.  */\n+\t      if (XEXP (y, 0) == folded_arg0)\n \t\tbreak;\n \n \t      /* Don't associate these operations if they are a PLUS with the\n@@ -4295,6 +4308,17 @@ fold_rtx (rtx x, rtx insn)\n \t\t\t  && exact_log2 (- INTVAL (const_arg1)) >= 0)))\n \t\tbreak;\n \n+\t      if (is_shift\n+\t\t  && (INTVAL (inner_const) >= GET_MODE_BITSIZE (mode)\n+\t\t      || INTVAL (inner_const) < 0))\n+\t\t{\n+\t\t  if (SHIFT_COUNT_TRUNCATED)\n+\t\t    inner_const = GEN_INT (INTVAL (inner_const)\n+\t\t\t\t\t   & (GET_MODE_BITSIZE (mode) - 1));\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\n \t      /* Compute the code used to compose the constants.  For example,\n \t\t A-C1-C2 is A-(C1 + C2), so if CODE == MINUS, we want PLUS.  */\n \n@@ -4312,13 +4336,16 @@ fold_rtx (rtx x, rtx insn)\n \t\t shift on a machine that does a sign-extend as a pair\n \t\t of shifts.  */\n \n-\t      if (is_shift && GET_CODE (new_const) == CONST_INT\n+\t      if (is_shift\n+\t\t  && GET_CODE (new_const) == CONST_INT\n \t\t  && INTVAL (new_const) >= GET_MODE_BITSIZE (mode))\n \t\t{\n \t\t  /* As an exception, we can turn an ASHIFTRT of this\n \t\t     form into a shift of the number of bits - 1.  */\n \t\t  if (code == ASHIFTRT)\n \t\t    new_const = GEN_INT (GET_MODE_BITSIZE (mode) - 1);\n+\t\t  else if (!side_effects_p (XEXP (y, 0)))\n+\t\t    return CONST0_RTX (mode);\n \t\t  else\n \t\t    break;\n \t\t}"}]}