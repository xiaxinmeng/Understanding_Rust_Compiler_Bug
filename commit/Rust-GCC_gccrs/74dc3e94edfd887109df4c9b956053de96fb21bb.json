{"sha": "74dc3e94edfd887109df4c9b956053de96fb21bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRkYzNlOTRlZGZkODg3MTA5ZGY0YzliOTU2MDUzZGU5NmZiMjFiYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-06-05T00:23:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-06-05T00:23:23Z"}, "message": "i386.c (struct ix86_address): Add seg.\n\n        * config/i386/i386.c (struct ix86_address): Add seg.\n        (no_seg_address_operand): New.\n        (ix86_decompose_address): Restructure PLUS loop.  Accept one\n        UNSPEC_TP if TARGET_TLS_DIRECT_SEG_REFS.  Adjust ESP swap test\n        to test for a regnum, not stack_pointer_rtx.\n        (ix86_address_cost): Reduce cost if non-default segment.\n        (legitimate_address_p): Remove UNSPEC_TP check.\n        (get_thread_pointer): Add to_reg argument.  Don't represent\n        the thread pointer as a memory load.\n        (legitimize_tls_address): Split out of ...\n        (legitimize_address): ... here.\n        (print_operand_address): Handle parts.seg.\n        (ix86_expand_move): Use legitimize_tls_address.\n        (ix86_rtx_costs): Handle UNSPEC_TP.\n        * config/i386/i386.h (MASK_TLS_DIRECT_SEG_REFS): New.\n        (TARGET_TLS_DIRECT_SEG_REFS): New.\n        (TARGET_SWITCHES): Add tls-direct-seg-refs.\n        (TARGET_TLS_DIRECT_SEG_REFS_DEFAULT): Default.\n        (PREDICATE_CODES): Add no_seg_address_operand.\n        * config/i386/i386.md (lea_1): Use it.\n        (lea_1_rex64, lea_1_zext, lea_2_rex64): Likewise.\n        (load_tp_si, add_tp_si, load_tp_di, add_tp_di): New.\n        * config/i386/linux.h (TARGET_TLS_DIRECT_SEG_REFS_DEFAULT): New.\n        * config/i386/linux64.h (TARGET_TLS_DIRECT_SEG_REFS_DEFAULT): New.\n        * doc/invoke.texi: Add -mtls-direct-seg-refs.\n\nFrom-SVN: r67475", "tree": {"sha": "68a0fa8732f08f9b84bdcad7829831a39e3d9f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68a0fa8732f08f9b84bdcad7829831a39e3d9f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74dc3e94edfd887109df4c9b956053de96fb21bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74dc3e94edfd887109df4c9b956053de96fb21bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74dc3e94edfd887109df4c9b956053de96fb21bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74dc3e94edfd887109df4c9b956053de96fb21bb/comments", "author": null, "committer": null, "parents": [{"sha": "d7068b3d2acc18be3975a44362bc34ba3d9dc2e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7068b3d2acc18be3975a44362bc34ba3d9dc2e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7068b3d2acc18be3975a44362bc34ba3d9dc2e1"}], "stats": {"total": 619, "additions": 395, "deletions": 224}, "files": [{"sha": "a057fc2b7118c545d10bec589e818b0c37e864e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -1,3 +1,31 @@\n+2003-06-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (struct ix86_address): Add seg.\n+\t(no_seg_address_operand): New.\n+\t(ix86_decompose_address): Restructure PLUS loop.  Accept one\n+\tUNSPEC_TP if TARGET_TLS_DIRECT_SEG_REFS.  Adjust ESP swap test\n+\tto test for a regnum, not stack_pointer_rtx.\n+\t(ix86_address_cost): Reduce cost if non-default segment.\n+\t(legitimate_address_p): Remove UNSPEC_TP check.\n+\t(get_thread_pointer): Add to_reg argument.  Don't represent\n+\tthe thread pointer as a memory load.\n+\t(legitimize_tls_address): Split out of ...\n+\t(legitimize_address): ... here.\n+\t(print_operand_address): Handle parts.seg.\n+\t(ix86_expand_move): Use legitimize_tls_address.\n+\t(ix86_rtx_costs): Handle UNSPEC_TP.\n+\t* config/i386/i386.h (MASK_TLS_DIRECT_SEG_REFS): New.\n+\t(TARGET_TLS_DIRECT_SEG_REFS): New.\n+\t(TARGET_SWITCHES): Add tls-direct-seg-refs.\n+\t(TARGET_TLS_DIRECT_SEG_REFS_DEFAULT): Default.\n+\t(PREDICATE_CODES): Add no_seg_address_operand.\n+\t* config/i386/i386.md (lea_1): Use it.\n+\t(lea_1_rex64, lea_1_zext, lea_2_rex64): Likewise.\n+\t(load_tp_si, add_tp_si, load_tp_di, add_tp_di): New.\n+\t* config/i386/linux.h (TARGET_TLS_DIRECT_SEG_REFS_DEFAULT): New.\n+\t* config/i386/linux64.h (TARGET_TLS_DIRECT_SEG_REFS_DEFAULT): New.\n+\t* doc/invoke.texi: Add -mtls-direct-seg-refs.\n+\n 2003-06-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (QMTESTRUNFLAGS): Set for DejaGNU emulation."}, {"sha": "f36c99ca20018134bc40cec45f3e31ab69a16e58", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 276, "deletions": 218, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -793,7 +793,8 @@ static rtx maybe_get_pool_constant PARAMS ((rtx));\n static rtx ix86_expand_int_compare PARAMS ((enum rtx_code, rtx, rtx));\n static enum rtx_code ix86_prepare_fp_compare_args PARAMS ((enum rtx_code,\n \t\t\t\t\t\t\t   rtx *, rtx *));\n-static rtx get_thread_pointer PARAMS ((void));\n+static rtx get_thread_pointer PARAMS ((int));\n+static rtx legitimize_tls_address PARAMS ((rtx, enum tls_model, int));\n static void get_pc_thunk_name PARAMS ((char [32], unsigned int));\n static rtx gen_push PARAMS ((rtx));\n static int memory_address_length PARAMS ((rtx addr));\n@@ -835,6 +836,7 @@ struct ix86_address\n {\n   rtx base, index, disp;\n   HOST_WIDE_INT scale;\n+  enum ix86_address_seg { SEG_DEFAULT, SEG_FS, SEG_GS } seg;\n };\n \n static int ix86_decompose_address PARAMS ((rtx, struct ix86_address *));\n@@ -3863,6 +3865,25 @@ vector_move_operand (op, mode)\n   return (op == CONST0_RTX (GET_MODE (op)));\n }\n \n+/* Return true if op if a valid address, and does not contain\n+   a segment override.  */\n+\n+int\n+no_seg_address_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  struct ix86_address parts;\n+\n+  if (! address_operand (op, mode))\n+    return 0;\n+\n+  if (! ix86_decompose_address (op, &parts))\n+    abort ();\n+\n+  return parts.seg == SEG_DEFAULT;\n+}\n+\n /* Return 1 if OP is a comparison that can be used in the CMPSS/CMPPS\n    insns.  */\n int\n@@ -5403,8 +5424,7 @@ ix86_output_function_epilogue (file, size)\n /* Extract the parts of an RTL expression that is a valid memory address\n    for an instruction.  Return 0 if the structure of the address is\n    grossly off.  Return -1 if the address contains ASHIFT, so it is not\n-   strictly valid, but still used for computing length of lea instruction.\n-   */\n+   strictly valid, but still used for computing length of lea instruction.  */\n \n static int\n ix86_decompose_address (addr, out)\n@@ -5417,47 +5437,72 @@ ix86_decompose_address (addr, out)\n   HOST_WIDE_INT scale = 1;\n   rtx scale_rtx = NULL_RTX;\n   int retval = 1;\n+  enum ix86_address_seg seg = SEG_DEFAULT;\n \n   if (REG_P (addr) || GET_CODE (addr) == SUBREG)\n     base = addr;\n   else if (GET_CODE (addr) == PLUS)\n     {\n-      rtx op0 = XEXP (addr, 0);\n-      rtx op1 = XEXP (addr, 1);\n-      enum rtx_code code0 = GET_CODE (op0);\n-      enum rtx_code code1 = GET_CODE (op1);\n+      rtx addends[4], op;\n+      int n = 0, i;\n \n-      if (code0 == REG || code0 == SUBREG)\n-\t{\n-\t  if (code1 == REG || code1 == SUBREG)\n-\t    index = op0, base = op1;\t/* index + base */\n-\t  else\n-\t    base = op0, disp = op1;\t/* base + displacement */\n-\t}\n-      else if (code0 == MULT)\n-\t{\n-\t  index = XEXP (op0, 0);\n-\t  scale_rtx = XEXP (op0, 1);\n-\t  if (code1 == REG || code1 == SUBREG)\n-\t    base = op1;\t\t\t/* index*scale + base */\n-\t  else\n-\t    disp = op1;\t\t\t/* index*scale + disp */\n-\t}\n-      else if (code0 == PLUS && GET_CODE (XEXP (op0, 0)) == MULT)\n+      op = addr;\n+      do\n \t{\n-\t  index = XEXP (XEXP (op0, 0), 0);\t/* index*scale + base + disp */\n-\t  scale_rtx = XEXP (XEXP (op0, 0), 1);\n-\t  base = XEXP (op0, 1);\n-\t  disp = op1;\n+\t  if (n >= 4)\n+\t    return 0;\n+\t  addends[n++] = XEXP (op, 1);\n+\t  op = XEXP (op, 0);\n \t}\n-      else if (code0 == PLUS)\n+      while (GET_CODE (op) == PLUS);\n+      if (n >= 4)\n+\treturn 0;\n+      addends[n] = op;\n+\n+      for (i = n; i >= 0; --i)\n \t{\n-\t  index = XEXP (op0, 0);\t/* index + base + disp */\n-\t  base = XEXP (op0, 1);\n-\t  disp = op1;\n+\t  op = addends[i];\n+\t  switch (GET_CODE (op))\n+\t    {\n+\t    case MULT:\n+\t      if (index)\n+\t\treturn 0;\n+\t      index = XEXP (op, 0);\n+\t      scale_rtx = XEXP (op, 1);\n+\t      break;\n+\n+\t    case UNSPEC:\n+\t      if (XINT (op, 1) == UNSPEC_TP\n+\t          && TARGET_TLS_DIRECT_SEG_REFS\n+\t          && seg == SEG_DEFAULT)\n+\t\tseg = TARGET_64BIT ? SEG_FS : SEG_GS;\n+\t      else\n+\t\treturn 0;\n+\t      break;\n+\n+\t    case REG:\n+\t    case SUBREG:\n+\t      if (!base)\n+\t\tbase = op;\n+\t      else if (!index)\n+\t\tindex = op;\n+\t      else\n+\t\treturn 0;\n+\t      break;\n+\n+\t    case CONST:\n+\t    case CONST_INT:\n+\t    case SYMBOL_REF:\n+\t    case LABEL_REF:\n+\t      if (disp)\n+\t\treturn 0;\n+\t      disp = op;\n+\t      break;\n+\n+\t    default:\n+\t      return 0;\n+\t    }\n \t}\n-      else\n-\treturn 0;\n     }\n   else if (GET_CODE (addr) == MULT)\n     {\n@@ -5490,10 +5535,11 @@ ix86_decompose_address (addr, out)\n       scale = INTVAL (scale_rtx);\n     }\n \n-  /* Allow arg pointer and stack pointer as index if there is not scaling */\n+  /* Allow arg pointer and stack pointer as index if there is not scaling.  */\n   if (base && index && scale == 1\n-      && (index == arg_pointer_rtx || index == frame_pointer_rtx\n-          || index == stack_pointer_rtx))\n+      && (index == arg_pointer_rtx\n+\t  || index == frame_pointer_rtx\n+\t  || (REG_P (index) && REGNO (index) == STACK_POINTER_REGNUM)))\n     {\n       rtx tmp = base;\n       base = index;\n@@ -5526,6 +5572,7 @@ ix86_decompose_address (addr, out)\n   out->index = index;\n   out->disp = disp;\n   out->scale = scale;\n+  out->seg = seg;\n \n   return retval;\n }\n@@ -5553,6 +5600,8 @@ ix86_address_cost (x)\n   /* More complex memory references are better.  */\n   if (parts.disp && parts.disp != const0_rtx)\n     cost--;\n+  if (parts.seg != SEG_DEFAULT)\n+    cost--;\n \n   /* Attempt to minimize number of registers in the address.  */\n   if ((parts.base\n@@ -5871,13 +5920,6 @@ legitimate_address_p (mode, addr, strict)\n       debug_rtx (addr);\n     }\n \n-  if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_TP)\n-    {\n-      if (TARGET_DEBUG_ADDR)\n-\tfprintf (stderr, \"Success.\\n\");\n-      return TRUE;\n-    }\n-\n   if (ix86_decompose_address (addr, &parts) <= 0)\n     {\n       reason = \"decomposition failed\";\n@@ -6267,20 +6309,151 @@ legitimize_pic_address (orig, reg)\n   return new;\n }\n \f\n-/* Load the thread pointer into a register.  */\n+/* Load the thread pointer.  If TO_REG is true, force it into a register.  */\n \n static rtx\n-get_thread_pointer ()\n+get_thread_pointer (to_reg)\n+     int to_reg;\n {\n-  rtx tp;\n+  rtx tp, reg, insn;\n \n   tp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TP);\n-  tp = gen_rtx_MEM (Pmode, tp);\n-  RTX_UNCHANGING_P (tp) = 1;\n-  set_mem_alias_set (tp, ix86_GOT_alias_set ());\n-  tp = force_reg (Pmode, tp);\n+  if (!to_reg)\n+    return tp;\n \n-  return tp;\n+  reg = gen_reg_rtx (Pmode);\n+  insn = gen_rtx_SET (VOIDmode, reg, tp);\n+  insn = emit_insn (insn);\n+\n+  return reg;\n+}\n+\n+/* A subroutine of legitimize_address and ix86_expand_move.  FOR_MOV is\n+   false if we expect this to be used for a memory address and true if\n+   we expect to load the address into a register.  */\n+\n+static rtx\n+legitimize_tls_address (x, model, for_mov)\n+     rtx x;\n+     enum tls_model model;\n+     int for_mov;\n+{\n+  rtx dest, base, off, pic;\n+  int type;\n+\n+  switch (model)\n+    {\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      dest = gen_reg_rtx (Pmode);\n+      if (TARGET_64BIT)\n+\t{\n+\t  rtx rax = gen_rtx_REG (Pmode, 0), insns;\n+\n+\t  start_sequence ();\n+\t  emit_call_insn (gen_tls_global_dynamic_64 (rax, x));\n+\t  insns = get_insns ();\n+\t  end_sequence ();\n+\n+\t  emit_libcall_block (insns, dest, rax, x);\n+\t}\n+      else\n+\temit_insn (gen_tls_global_dynamic_32 (dest, x));\n+      break;\n+\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      base = gen_reg_rtx (Pmode);\n+      if (TARGET_64BIT)\n+\t{\n+\t  rtx rax = gen_rtx_REG (Pmode, 0), insns, note;\n+\n+\t  start_sequence ();\n+\t  emit_call_insn (gen_tls_local_dynamic_base_64 (rax));\n+\t  insns = get_insns ();\n+\t  end_sequence ();\n+\n+\t  note = gen_rtx_EXPR_LIST (VOIDmode, const0_rtx, NULL);\n+\t  note = gen_rtx_EXPR_LIST (VOIDmode, ix86_tls_get_addr (), note);\n+\t  emit_libcall_block (insns, base, rax, note);\n+\t}\n+      else\n+\temit_insn (gen_tls_local_dynamic_base_32 (base));\n+\n+      off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPOFF);\n+      off = gen_rtx_CONST (Pmode, off);\n+\n+      return gen_rtx_PLUS (Pmode, base, off);\n+\n+    case TLS_MODEL_INITIAL_EXEC:\n+      if (TARGET_64BIT)\n+\t{\n+\t  pic = NULL;\n+\t  type = UNSPEC_GOTNTPOFF;\n+\t}\n+      else if (flag_pic)\n+\t{\n+\t  if (reload_in_progress)\n+\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\t  pic = pic_offset_table_rtx;\n+\t  type = TARGET_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n+\t}\n+      else if (!TARGET_GNU_TLS)\n+\t{\n+\t  pic = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_set_got (pic));\n+\t  type = UNSPEC_GOTTPOFF;\n+\t}\n+      else\n+\t{\n+\t  pic = NULL;\n+\t  type = UNSPEC_INDNTPOFF;\n+\t}\n+\n+      off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), type);\n+      off = gen_rtx_CONST (Pmode, off);\n+      if (pic)\n+\toff = gen_rtx_PLUS (Pmode, pic, off);\n+      off = gen_rtx_MEM (Pmode, off);\n+      RTX_UNCHANGING_P (off) = 1;\n+      set_mem_alias_set (off, ix86_GOT_alias_set ());\n+\n+      if (TARGET_64BIT || TARGET_GNU_TLS)\n+\t{\n+          base = get_thread_pointer (for_mov || !TARGET_TLS_DIRECT_SEG_REFS);\n+\t  off = force_reg (Pmode, off);\n+\t  return gen_rtx_PLUS (Pmode, base, off);\n+\t}\n+      else\n+\t{\n+\t  base = get_thread_pointer (true);\n+\t  dest = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_subsi3 (dest, base, off));\n+\t}\n+      break;\n+\n+    case TLS_MODEL_LOCAL_EXEC:\n+      off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x),\n+\t\t\t    (TARGET_64BIT || TARGET_GNU_TLS)\n+\t\t\t    ? UNSPEC_NTPOFF : UNSPEC_TPOFF);\n+      off = gen_rtx_CONST (Pmode, off);\n+\n+      if (TARGET_64BIT || TARGET_GNU_TLS)\n+\t{\n+\t  base = get_thread_pointer (for_mov || !TARGET_TLS_DIRECT_SEG_REFS);\n+\t  return gen_rtx_PLUS (Pmode, base, off);\n+\t}\n+      else\n+\t{\n+\t  base = get_thread_pointer (true);\n+\t  dest = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_subsi3 (dest, base, off));\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return dest;\n }\n \n /* Try machine-dependent ways of modifying an illegitimate address\n@@ -6322,120 +6495,7 @@ legitimize_address (x, oldx, mode)\n \n   log = tls_symbolic_operand (x, mode);\n   if (log)\n-    {\n-      rtx dest, base, off, pic;\n-      int type;\n-\n-      switch (log)\n-        {\n-        case TLS_MODEL_GLOBAL_DYNAMIC:\n-\t  dest = gen_reg_rtx (Pmode);\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      rtx rax = gen_rtx_REG (Pmode, 0), insns;\n-\n-\t      start_sequence ();\n-\t      emit_call_insn (gen_tls_global_dynamic_64 (rax, x));\n-\t      insns = get_insns ();\n-\t      end_sequence ();\n-\n-\t      emit_libcall_block (insns, dest, rax, x);\n-\t    }\n-\t  else\n-\t    emit_insn (gen_tls_global_dynamic_32 (dest, x));\n-\t  break;\n-\n-        case TLS_MODEL_LOCAL_DYNAMIC:\n-\t  base = gen_reg_rtx (Pmode);\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      rtx rax = gen_rtx_REG (Pmode, 0), insns, note;\n-\n-\t      start_sequence ();\n-\t      emit_call_insn (gen_tls_local_dynamic_base_64 (rax));\n-\t      insns = get_insns ();\n-\t      end_sequence ();\n-\n-\t      note = gen_rtx_EXPR_LIST (VOIDmode, const0_rtx, NULL);\n-\t      note = gen_rtx_EXPR_LIST (VOIDmode, ix86_tls_get_addr (), note);\n-\t      emit_libcall_block (insns, base, rax, note);\n-\t    }\n-\t  else\n-\t    emit_insn (gen_tls_local_dynamic_base_32 (base));\n-\n-\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPOFF);\n-\t  off = gen_rtx_CONST (Pmode, off);\n-\n-\t  return gen_rtx_PLUS (Pmode, base, off);\n-\n-        case TLS_MODEL_INITIAL_EXEC:\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      pic = NULL;\n-\t      type = UNSPEC_GOTNTPOFF;\n-\t    }\n-\t  else if (flag_pic)\n-\t    {\n-\t      if (reload_in_progress)\n-\t\tregs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n-\t      pic = pic_offset_table_rtx;\n-\t      type = TARGET_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n-\t    }\n-\t  else if (!TARGET_GNU_TLS)\n-\t    {\n-\t      pic = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_set_got (pic));\n-\t      type = UNSPEC_GOTTPOFF;\n-\t    }\n-\t  else\n-\t    {\n-\t      pic = NULL;\n-\t      type = UNSPEC_INDNTPOFF;\n-\t    }\n-\n-\t  base = get_thread_pointer ();\n-\n-\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), type);\n-\t  off = gen_rtx_CONST (Pmode, off);\n-\t  if (pic)\n-\t    off = gen_rtx_PLUS (Pmode, pic, off);\n-\t  off = gen_rtx_MEM (Pmode, off);\n-\t  RTX_UNCHANGING_P (off) = 1;\n-\t  set_mem_alias_set (off, ix86_GOT_alias_set ());\n-\t  dest = gen_reg_rtx (Pmode);\n-\n-\t  if (TARGET_64BIT || TARGET_GNU_TLS)\n-\t    {\n-\t      emit_move_insn (dest, off);\n-\t      return gen_rtx_PLUS (Pmode, base, dest);\n-\t    }\n-\t  else\n-\t    emit_insn (gen_subsi3 (dest, base, off));\n-\t  break;\n-\n-        case TLS_MODEL_LOCAL_EXEC:\n-\t  base = get_thread_pointer ();\n-\n-\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x),\n-\t\t\t\t(TARGET_64BIT || TARGET_GNU_TLS)\n-\t\t\t\t? UNSPEC_NTPOFF : UNSPEC_TPOFF);\n-\t  off = gen_rtx_CONST (Pmode, off);\n-\n-\t  if (TARGET_64BIT || TARGET_GNU_TLS)\n-\t    return gen_rtx_PLUS (Pmode, base, off);\n-\t  else\n-\t    {\n-\t      dest = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_subsi3 (dest, base, off));\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-        }\n-\n-      return dest;\n-    }\n+    return legitimize_tls_address (x, log, false);\n \n   if (flag_pic && SYMBOLIC_CONST (x))\n     return legitimize_pic_address (x, 0);\n@@ -7418,8 +7478,8 @@ print_operand (file, x, code)\n       fprintf (file, \"0x%lx\", l);\n     }\n \n- /* These float cases don't actually occur as immediate operands.  */\n- else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+  /* These float cases don't actually occur as immediate operands.  */\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n     {\n       char dstr[30];\n \n@@ -7474,19 +7534,6 @@ print_operand_address (file, addr)\n   rtx base, index, disp;\n   int scale;\n \n-  if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_TP)\n-    {\n-      if (ASSEMBLER_DIALECT == ASM_INTEL)\n-\tfputs (\"DWORD PTR \", file);\n-      if (ASSEMBLER_DIALECT == ASM_ATT || USER_LABEL_PREFIX[0] == 0)\n-\tputc ('%', file);\n-      if (TARGET_64BIT)\n-\tfputs (\"fs:0\", file);\n-      else\n-\tfputs (\"gs:0\", file);\n-      return;\n-    }\n-\n   if (! ix86_decompose_address (addr, &parts))\n     abort ();\n \n@@ -7495,35 +7542,49 @@ print_operand_address (file, addr)\n   disp = parts.disp;\n   scale = parts.scale;\n \n+  switch (parts.seg)\n+    {\n+    case SEG_DEFAULT:\n+      break;\n+    case SEG_FS:\n+    case SEG_GS:\n+      if (USER_LABEL_PREFIX[0] == 0)\n+\tputc ('%', file);\n+      fputs ((parts.seg == SEG_FS ? \"fs:\" : \"gs:\"), file);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n   if (!base && !index)\n     {\n       /* Displacement only requires special attention.  */\n \n       if (GET_CODE (disp) == CONST_INT)\n \t{\n-\t  if (ASSEMBLER_DIALECT == ASM_INTEL)\n+\t  if (ASSEMBLER_DIALECT == ASM_INTEL && parts.seg == SEG_DEFAULT)\n \t    {\n \t      if (USER_LABEL_PREFIX[0] == 0)\n \t\tputc ('%', file);\n \t      fputs (\"ds:\", file);\n \t    }\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (addr));\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (disp));\n \t}\n       else if (flag_pic)\n-\toutput_pic_addr_const (file, addr, 0);\n+\toutput_pic_addr_const (file, disp, 0);\n       else\n-\toutput_addr_const (file, addr);\n+\toutput_addr_const (file, disp);\n \n       /* Use one byte shorter RIP relative addressing for 64bit mode.  */\n       if (TARGET_64BIT\n-\t  && ((GET_CODE (addr) == SYMBOL_REF\n-\t       && ! tls_symbolic_operand (addr, GET_MODE (addr)))\n-\t      || GET_CODE (addr) == LABEL_REF\n-\t      || (GET_CODE (addr) == CONST\n-\t\t  && GET_CODE (XEXP (addr, 0)) == PLUS\n-\t\t  && (GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\n-\t\t      || GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF)\n-\t\t  && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)))\n+\t  && ((GET_CODE (disp) == SYMBOL_REF\n+\t       && ! tls_symbolic_operand (disp, GET_MODE (disp)))\n+\t      || GET_CODE (disp) == LABEL_REF\n+\t      || (GET_CODE (disp) == CONST\n+\t\t  && GET_CODE (XEXP (disp, 0)) == PLUS\n+\t\t  && (GET_CODE (XEXP (XEXP (disp, 0), 0)) == SYMBOL_REF\n+\t\t      || GET_CODE (XEXP (XEXP (disp, 0), 0)) == LABEL_REF)\n+\t\t  && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT)))\n \tfputs (\"(%rip)\", file);\n     }\n   else\n@@ -8220,22 +8281,22 @@ ix86_expand_move (mode, operands)\n      rtx operands[];\n {\n   int strict = (reload_in_progress || reload_completed);\n-  rtx insn, op0, op1, tmp;\n+  rtx op0, op1;\n+  enum tls_model model;\n \n   op0 = operands[0];\n   op1 = operands[1];\n \n-  if (tls_symbolic_operand (op1, Pmode))\n+  model = tls_symbolic_operand (op1, Pmode);\n+  if (model)\n     {\n-      op1 = legitimize_address (op1, op1, VOIDmode);\n-      if (GET_CODE (op0) == MEM)\n-\t{\n-\t  tmp = gen_reg_rtx (mode);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, tmp, op1));\n-\t  op1 = tmp;\n-\t}\n+      op1 = legitimize_tls_address (op1, model, true);\n+      op1 = force_operand (op1, op0);\n+      if (op1 == op0)\n+\treturn;\n     }\n-  else if (flag_pic && mode == Pmode && symbolic_operand (op1, Pmode))\n+\n+  if (flag_pic && mode == Pmode && symbolic_operand (op1, Pmode))\n     {\n #if TARGET_MACHO\n       if (MACHOPIC_PURE)\n@@ -8248,18 +8309,11 @@ ix86_expand_move (mode, operands)\n \t  op1 = machopic_legitimize_pic_address (op1, mode,\n \t\t\t\t\t\t temp == op1 ? 0 : temp);\n \t}\n-      else\n-\t{\n-\t  if (MACHOPIC_INDIRECT)\n-\t    op1 = machopic_indirect_data_reference (op1, 0);\n-\t}\n-      if (op0 != op1)\n-\t{\n-\t  insn = gen_rtx_SET (VOIDmode, op0, op1);\n-\t  emit_insn (insn);\n-\t}\n-      return;\n-#endif /* TARGET_MACHO */\n+      else if (MACHOPIC_INDIRECT)\n+\top1 = machopic_indirect_data_reference (op1, 0);\n+      if (op0 == op1)\n+\treturn;\n+#else\n       if (GET_CODE (op0) == MEM)\n \top1 = force_reg (Pmode, op1);\n       else\n@@ -8272,6 +8326,7 @@ ix86_expand_move (mode, operands)\n \t    return;\n \t  op1 = temp;\n \t}\n+#endif /* TARGET_MACHO */\n     }\n   else\n     {\n@@ -8316,9 +8371,7 @@ ix86_expand_move (mode, operands)\n \t}\n     }\n \n-  insn = gen_rtx_SET (VOIDmode, op0, op1);\n-\n-  emit_insn (insn);\n+  emit_insn (gen_rtx_SET (VOIDmode, op0, op1));\n }\n \n void\n@@ -15094,6 +15147,11 @@ ix86_rtx_costs (x, code, outer_code, total)\n \t*total = COSTS_N_INSNS (ix86_cost->fsqrt);\n       return false;\n \n+    case UNSPEC:\n+      if (XINT (x, 1) == UNSPEC_TP)\n+\t*total = 0;\n+      return false;\n+\n     default:\n       return false;\n     }"}, {"sha": "f543c286b93a88ecf178bf598e4da13dda9fd8cb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -122,6 +122,7 @@ extern int target_flags;\n #define MASK_128BIT_LONG_DOUBLE 0x00040000\t/* long double size is 128bit */\n #define MASK_64BIT\t\t0x00080000\t/* Produce 64bit code */\n #define MASK_MS_BITFIELD_LAYOUT 0x00100000\t/* Use native (MS) bitfield layout */\n+#define MASK_TLS_DIRECT_SEG_REFS 0x00200000\t/* Avoid adding %gs:0  */\n \n /* Unused:\t\t\t0x03e0000\t*/\n \n@@ -201,6 +202,9 @@ extern int target_flags;\n #endif\n #endif\n \n+/* Avoid adding %gs:0 in TLS references; use %gs:address directly.  */\n+#define TARGET_TLS_DIRECT_SEG_REFS (target_flags & MASK_TLS_DIRECT_SEG_REFS)\n+\n #define TARGET_386 (ix86_tune == PROCESSOR_I386)\n #define TARGET_486 (ix86_tune == PROCESSOR_I486)\n #define TARGET_PENTIUM (ix86_tune == PROCESSOR_PENTIUM)\n@@ -405,12 +409,21 @@ extern int x86_prefetch_sse;\n     N_(\"Use red-zone in the x86-64 code\") },\t\t\t\t      \\\n   { \"no-red-zone\",\t\tMASK_NO_RED_ZONE,\t\t\t      \\\n     N_(\"Do not use red-zone in the x86-64 code\") },\t\t\t      \\\n+  { \"tls-direct-seg-refs\",\tMASK_TLS_DIRECT_SEG_REFS,\t\t      \\\n+    N_(\"Use direct references against %gs when accessing tls data\") },\t      \\\n+  { \"no-tls-direct-seg-refs\",\t-MASK_TLS_DIRECT_SEG_REFS,\t\t      \\\n+    N_(\"Do not use direct references against %gs when accessing tls data\") }, \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t      \\\n-  { \"\", TARGET_DEFAULT | TARGET_64BIT_DEFAULT | TARGET_SUBTARGET_DEFAULT, 0 }}\n+  { \"\",\t\t\t\t\t\t\t\t\t      \\\n+    TARGET_DEFAULT | TARGET_64BIT_DEFAULT | TARGET_SUBTARGET_DEFAULT\t      \\\n+    | TARGET_TLS_DIRECT_SEG_REFS_DEFAULT, 0 }}\n \n #ifndef TARGET_64BIT_DEFAULT\n #define TARGET_64BIT_DEFAULT 0\n #endif\n+#ifndef TARGET_TLS_DIRECT_SEG_REFS_DEFAULT\n+#define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT 0\n+#endif\n \n /* Once GDB has been enhanced to deal with functions without frame\n    pointers, we can change this to allow for elimination of\n@@ -3034,6 +3047,8 @@ do {\t\t\t\t\t\t\\\n   {\"register_and_not_fp_reg_operand\", {REG}},\t\t\t\t\\\n   {\"zero_extended_scalar_load_operand\", {MEM}},\t\t\t\t\\\n   {\"vector_move_operand\", {CONST_VECTOR, SUBREG, REG, MEM}},\t\t\\\n+  {\"no_seg_address_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF, \\\n+\t\t\t      LABEL_REF, SUBREG, REG, MEM, PLUS, MULT}},\n \n /* A list of predicates that do special things with modes, and so\n    should not elicit warnings for VOIDmode match_operand.  */"}, {"sha": "a027a7623badc6497fa642ba4e511459aa874f94", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -5312,31 +5312,32 @@\n \n (define_insn \"*lea_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+\t(match_operand:SI 1 \"no_seg_address_operand\" \"p\"))]\n   \"!TARGET_64BIT\"\n   \"lea{l}\\t{%a1, %0|%0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*lea_1_rex64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(subreg:SI (match_operand:DI 1 \"address_operand\" \"p\") 0))]\n+\t(subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0))]\n   \"TARGET_64BIT\"\n   \"lea{l}\\t{%a1, %0|%0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*lea_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (subreg:SI (match_operand:DI 1 \"address_operand\" \"p\") 0)))]\n+\t(zero_extend:DI\n+\t (subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0)))]\n   \"TARGET_64BIT\"\n   \"lea{l}\\t{%a1, %k0|%k0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*lea_2_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"address_operand\" \"p\"))]\n+\t(match_operand:DI 1 \"no_seg_address_operand\" \"p\"))]\n   \"TARGET_64BIT\"\n   \"lea{q}\\t{%a1, %0|%0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n@@ -14636,6 +14637,56 @@\n \t      (clobber (match_dup 5))\n \t      (clobber (reg:CC 17))])]\n   \"\")\n+\n+;; Load and add the thread base pointer from %gs:0.\n+\n+(define_insn \"*load_tp_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_TP))]\n+  \"!TARGET_64BIT\"\n+  \"mov{l}\\t{%%gs:0, %0|%0, DWORD PTR %%gs:0}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"length\" \"7\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"imm_disp\" \"false\")])\n+\n+(define_insn \"*add_tp_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (unspec:SI [(const_int 0)] UNSPEC_TP)\n+\t\t (match_operand:SI 1 \"register_operand\" \"0\")))\n+   (clobber (reg:CC 17))]\n+  \"!TARGET_64BIT\"\n+  \"add{l}\\t{%%gs:0, %0|%0, DWORD PTR %%gs:0}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"length\" \"7\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"imm_disp\" \"false\")])\n+\n+(define_insn \"*load_tp_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(const_int 0)] UNSPEC_TP))]\n+  \"TARGET_64BIT\"\n+  \"mov{l}\\t{%%fs:0, %0|%0, QWORD PTR %%fs:0}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"length\" \"7\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"imm_disp\" \"false\")])\n+\n+(define_insn \"*add_tp_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (unspec:DI [(const_int 0)] UNSPEC_TP)\n+\t\t (match_operand:DI 1 \"register_operand\" \"0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n+  \"add{q}\\t{%%fs:0, %0|%0, QWORD PTR %%fs:0}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"modrm\" \"0\")\n+   (set_attr \"length\" \"7\")\n+   (set_attr \"memory\" \"load\")\n+   (set_attr \"imm_disp\" \"false\")])\n \f\n ;; These patterns match the binary 387 instructions for addM3, subM3,\n ;; mulM3 and divM3.  There are three patterns for each of DFmode and"}, {"sha": "8f0a22c049486fbe1ee70dd4ba774d60f5f10c67", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -40,6 +40,10 @@ Boston, MA 02111-1307, USA.  */\n #undef DEFAULT_PCC_STRUCT_RETURN\n #define DEFAULT_PCC_STRUCT_RETURN 1\n \n+/* We arrange for the whole %gs segment to map the tls area.  */\n+#undef TARGET_TLS_DIRECT_SEG_REFS_DEFAULT\n+#define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT MASK_TLS_DIRECT_SEG_REFS\n+\n #undef ASM_COMMENT_START\n #define ASM_COMMENT_START \"#\"\n "}, {"sha": "ec398de8d6650488951339f00e4385096ab81f67", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -47,6 +47,10 @@ Boston, MA 02111-1307, USA.  */\n #undef DEFAULT_PCC_STRUCT_RETURN\n #define DEFAULT_PCC_STRUCT_RETURN 1\n \n+/* We arrange for the whole %fs segment to map the tls area.  */\n+#undef TARGET_TLS_DIRECT_SEG_REFS_DEFAULT\n+#define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT MASK_TLS_DIRECT_SEG_REFS\n+\n /* Provide a LINK_SPEC.  Here we provide support for the special GCC\n    options -static and -shared, which allow us to link things in one\n    of these three modes by applying the appropriate combinations of"}, {"sha": "b87d3102a93866920f18083572b92e7af47a3894", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dc3e94edfd887109df4c9b956053de96fb21bb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=74dc3e94edfd887109df4c9b956053de96fb21bb", "patch": "@@ -490,7 +490,7 @@ in the following sections.\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n -m96bit-long-double  -mregparm=@var{num}  -momit-leaf-frame-pointer @gol\n--mno-red-zone @gol\n+-mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} @gol\n -m32  -m64}\n \n@@ -8401,6 +8401,17 @@ avoids the instructions to save, set up and restore frame pointers and\n makes an extra register available in leaf functions.  The option\n @option{-fomit-frame-pointer} removes the frame pointer for all functions\n which might make debugging harder.\n+\n+@item -mtls-direct-seg-refs\n+@itemx -mno-tls-direct-seg-refs\n+@opindex mtls-direct-seg-refs\n+Controls whether TLS variables may be accessed with offsets from the\n+TLS segment register (@code{%gs} for 32-bit, @code{%fs} for 64-bit),\n+or whether the thread base pointer must be added.  Whether or not this\n+is legal depends on the operating system, and whether it maps the\n+segment to cover the entire TLS area.\n+\n+For systems that use GNU libc, the default is on.\n @end table\n \n These @samp{-m} switches are supported in addition to the above"}]}