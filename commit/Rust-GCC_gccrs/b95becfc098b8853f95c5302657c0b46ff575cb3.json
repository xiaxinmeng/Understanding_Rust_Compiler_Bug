{"sha": "b95becfc098b8853f95c5302657c0b46ff575cb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk1YmVjZmMwOThiODg1M2Y5NWM1MzAyNjU3YzBiNDZmZjU3NWNiMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-02-05T21:38:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-02-05T21:38:53Z"}, "message": "tree-vectorizer.h (vectorizable_function): Add argument type argument, change return type.\n\n2007-02-05  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vectorizable_function): Add argument type\n\targument, change return type.\n\t* tree-vect-patterns.c (vect_recog_pow_pattern): Adjust caller.\n\t* tree-vect-transform.c (vectorizable_function): Handle extra\n\targument, return vectorized function decl.\n\t(build_vectorized_function_call): Remove.\n\t(vectorizable_call): Handle calls with result and argument types\n\tdiffering.  Handle loop vectorization factor correctly.\n\t* targhooks.c (default_builtin_vectorized_function): Adjust for\n\textra argument.\n\t* targhooks.h (default_builtin_vectorized_function): Likewise.\n\t* target.h (builtin_vectorized_function): Add argument type\n        argument.\n\t* config/i386/i386.c (ix86_builtin_vectorized_function): Handle\n\textra argument, allow vectorizing of lrintf.\n\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION): Adjust\n\tdocumentation of target hook.\n\n\t* gcc.target/i386/vectorize3.c: New testcase.\n\nFrom-SVN: r121617", "tree": {"sha": "acd2d1f47d5813e7f9565319ed7b57c1c8a10607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acd2d1f47d5813e7f9565319ed7b57c1c8a10607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b95becfc098b8853f95c5302657c0b46ff575cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b95becfc098b8853f95c5302657c0b46ff575cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b95becfc098b8853f95c5302657c0b46ff575cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b95becfc098b8853f95c5302657c0b46ff575cb3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6df67efcd64255f685a4556c20690f56315dad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6df67efcd64255f685a4556c20690f56315dad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6df67efcd64255f685a4556c20690f56315dad0"}], "stats": {"total": 271, "additions": 189, "deletions": 82}, "files": [{"sha": "00483ff65c3d808f94f287dacf7d05d08f34a112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -1,3 +1,23 @@\n+2007-02-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vectorizable_function): Add argument type\n+\targument, change return type.\n+\t* tree-vect-patterns.c (vect_recog_pow_pattern): Adjust caller.\n+\t* tree-vect-transform.c (vectorizable_function): Handle extra\n+\targument, return vectorized function decl.\n+\t(build_vectorized_function_call): Remove.\n+\t(vectorizable_call): Handle calls with result and argument types\n+\tdiffering.  Handle loop vectorization factor correctly.\n+\t* targhooks.c (default_builtin_vectorized_function): Adjust for\n+\textra argument.\n+\t* targhooks.h (default_builtin_vectorized_function): Likewise.\n+\t* target.h (builtin_vectorized_function): Add argument type\n+        argument.\n+\t* config/i386/i386.c (ix86_builtin_vectorized_function): Handle\n+\textra argument, allow vectorizing of lrintf.\n+\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION): Adjust\n+\tdocumentation of target hook.\n+\n 2007-02-05  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/30665"}, {"sha": "ea1284960adc3e59732084694f9fbc228cf6e23e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -1355,7 +1355,7 @@ static bool ix86_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n static void ix86_init_builtins (void);\n static rtx ix86_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-static tree ix86_builtin_vectorized_function (enum built_in_function, tree);\n+static tree ix86_builtin_vectorized_function (enum built_in_function, tree, tree);\n static const char *ix86_mangle_fundamental_type (tree);\n static tree ix86_stack_protect_fail (void);\n static rtx ix86_internal_arg_pointer (void);\n@@ -17661,29 +17661,41 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n    if it is not available.  */\n \n static tree\n-ix86_builtin_vectorized_function (enum built_in_function fn, tree type)\n+ix86_builtin_vectorized_function (enum built_in_function fn, tree type_out,\n+\t\t\t\t  tree type_in)\n {\n-  enum machine_mode el_mode;\n-  int n;\n+  enum machine_mode in_mode, out_mode;\n+  int in_n, out_n;\n \n-  if (TREE_CODE (type) != VECTOR_TYPE)\n+  if (TREE_CODE (type_out) != VECTOR_TYPE\n+      || TREE_CODE (type_in) != VECTOR_TYPE)\n     return NULL_TREE;\n \n-  el_mode = TYPE_MODE (TREE_TYPE (type));\n-  n = TYPE_VECTOR_SUBPARTS (type);\n+  out_mode = TYPE_MODE (TREE_TYPE (type_out));\n+  out_n = TYPE_VECTOR_SUBPARTS (type_out);\n+  in_mode = TYPE_MODE (TREE_TYPE (type_in));\n+  in_n = TYPE_VECTOR_SUBPARTS (type_in);\n \n   switch (fn)\n     {\n     case BUILT_IN_SQRT:\n-      if (el_mode == DFmode && n == 2)\n+      if (out_mode == DFmode && out_n == 2\n+\t  && in_mode == DFmode && in_n == 2)\n \treturn ix86_builtins[IX86_BUILTIN_SQRTPD];\n       return NULL_TREE;\n \n     case BUILT_IN_SQRTF:\n-      if (el_mode == SFmode && n == 4)\n+      if (out_mode == SFmode && out_n == 4\n+\t  && in_mode == SFmode && in_n == 4)\n \treturn ix86_builtins[IX86_BUILTIN_SQRTPS];\n       return NULL_TREE;\n \n+    case BUILT_IN_LRINTF:\n+      if (out_mode == SImode && out_n == 4\n+\t  && in_mode == SFmode && in_n == 4)\n+\treturn ix86_builtins[IX86_BUILTIN_CVTPS2DQ];\n+      return NULL_TREE;\n+\n     default:\n       ;\n     }"}, {"sha": "ebb3f2c871b5215c72208db61d8c8a261a4faa21", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -5384,11 +5384,12 @@ preserved (e.g. used only by a reduction computation). Otherwise, the\n @code{widen_mult_hi/lo} idioms will be used.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (enum built_in_function @var{code}, tree @var{vec_type})\n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (enum built_in_function @var{code}, tree @var{vec_type_out}, tree @var{vec_type_in})\n This hook should return the decl of a function that implements the vectorized\n variant of the builtin function with builtin function code @var{code} or\n @code{NULL_TREE} if such a function is not available.  The return type of\n-the vectorized function shall be of vector type @var{vec_type}.\n+the vectorized function shall be of vector type @var{vec_type_out} and the\n+argument types should be @var{vec_type_in}.\n @end deftypefn\n \n @node Anchored Addresses"}, {"sha": "2d8d69bed645176d69945fe5b984429cc176673f", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -395,7 +395,7 @@ struct gcc_target\n \n     /* Returns a code for builtin that realizes vectorized version of\n        function, or NULL_TREE if not available.  */\n-    tree (* builtin_vectorized_function) (unsigned, tree);\n+    tree (* builtin_vectorized_function) (unsigned, tree, tree);\n \n     /* Target builtin that implements vector widening multiplication.\n        builtin_mul_widen_eve computes the element-by-element products "}, {"sha": "ed4d890d2cf05255ef2595482c662c3addf1431f", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -323,7 +323,8 @@ default_invalid_within_doloop (rtx insn)\n \n tree\n default_builtin_vectorized_function (enum built_in_function fn ATTRIBUTE_UNUSED,\n-\t\t\t\t     tree type ATTRIBUTE_UNUSED)\n+\t\t\t\t     tree type_out ATTRIBUTE_UNUSED,\n+\t\t\t\t     tree type_in ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n }"}, {"sha": "0b4ded93c45da93244d2825338d97021d4da046e", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -57,7 +57,7 @@ extern const char * default_invalid_within_doloop (rtx);\n \n extern bool default_narrow_bitfield (void);\n \n-extern tree default_builtin_vectorized_function (enum built_in_function, tree);\n+extern tree default_builtin_vectorized_function (enum built_in_function, tree, tree);\n \n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */"}, {"sha": "2b88029caf44c166ea99b5ec8ff0431f712c86fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -1,3 +1,7 @@\n+2007-02-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.target/i386/vectorize3.c: New testcase.\n+\n 2007-02-05  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/30665"}, {"sha": "2947acbafda49630998f04eb320225b1fbee5021", "filename": "gcc/testsuite/gcc.target/i386/vectorize3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize3.c?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -ffast-math -ftree-vectorize -msse2 -mfpmath=sse\" } */\n+\n+float a[256];\n+int b[256];\n+unsigned short c[256];\n+\n+extern long lrintf (float);\n+\n+void foo(void)\n+{\n+  int i;\n+\n+  for (i=0; i<256; ++i)\n+    b[i] = lrintf (a[i]);\n+}\n+\n+void bar(void)\n+{\n+  int i;\n+\n+  for (i=0; i<256; ++i)\n+    {\n+      b[i] = lrintf (a[i]);\n+      c[i] += c[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"cvtps2dq\" } } */"}, {"sha": "c9e34e3e4198779490e86945a502cf0e7b3614fa", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -488,7 +488,7 @@ vect_recog_pow_pattern (tree last_stmt, tree *type_in, tree *type_out)\n       if (*type_in)\n \t{\n \t  newfn = build_function_call_expr (newfn, newarglist);\n-\t  if (vectorizable_function (newfn, *type_in))\n+\t  if (vectorizable_function (newfn, *type_in, *type_in) != NULL_TREE)\n \t    return newfn;\n \t}\n     }"}, {"sha": "fc95e6090aa8bc363587090f1d4f994305076295", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 105, "deletions": 66, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -1579,47 +1579,28 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n }\n \n /* Checks if CALL can be vectorized in type VECTYPE.  Returns\n-   true if the target has a vectorized version of the function,\n-   or false if the function cannot be vectorized.  */\n+   a function declaration if the target has a vectorized version\n+   of the function, or NULL_TREE if the function cannot be vectorized.  */\n \n-bool\n-vectorizable_function (tree call, tree vectype)\n+tree\n+vectorizable_function (tree call, tree vectype_out, tree vectype_in)\n {\n   tree fndecl = get_callee_fndecl (call);\n+  enum built_in_function code;\n \n   /* We only handle functions that do not read or clobber memory -- i.e.\n      const or novops ones.  */\n   if (!(call_expr_flags (call) & (ECF_CONST | ECF_NOVOPS)))\n-    return false;\n+    return NULL_TREE;\n \n   if (!fndecl\n       || TREE_CODE (fndecl) != FUNCTION_DECL\n       || !DECL_BUILT_IN (fndecl))\n-    return false;\n+    return NULL_TREE;\n \n-  if (targetm.vectorize.builtin_vectorized_function (DECL_FUNCTION_CODE (fndecl), vectype))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Returns an expression that performs a call to vectorized version\n-   of FNDECL in type VECTYPE, with the arguments given by ARGS.\n-   If extra statements need to be generated, they are inserted\n-   before BSI.  */\n-\n-static tree\n-build_vectorized_function_call (tree fndecl,\n-\t\t\t\ttree vectype, tree args)\n-{\n-  tree vfndecl;\n-  enum built_in_function code = DECL_FUNCTION_CODE (fndecl);\n-\n-  /* The target specific builtin should be available.  */\n-  vfndecl = targetm.vectorize.builtin_vectorized_function (code, vectype);\n-  gcc_assert (vfndecl != NULL_TREE);\n-\n-  return build_function_call_expr (vfndecl, args);\n+  code = DECL_FUNCTION_CODE (fndecl);\n+  return targetm.vectorize.builtin_vectorized_function (code, vectype_out,\n+\t\t\t\t\t\t        vectype_in);\n }\n \n /* Function vectorizable_call.\n@@ -1635,13 +1616,13 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vec_dest;\n   tree scalar_dest;\n   tree operation;\n-  tree op, args, type;\n-  tree vec_oprnd, vargs, *pvargs_end;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree args, type;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt), prev_stmt_info;\n+  tree vectype_out, vectype_in;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  tree fndecl, rhs, new_temp, def, def_stmt;\n-  enum vect_def_type dt;\n+  tree fndecl, rhs, new_temp, def, def_stmt, rhs_type, lhs_type;\n+  enum vect_def_type dt[2];\n+  int ncopies, j, nargs;\n \n   /* Is STMT a vectorizable call?   */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n@@ -1653,31 +1634,68 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (operation) != CALL_EXPR)\n     return false;\n-   \n+\n+  /* Process function arguments.  */\n+  rhs_type = NULL_TREE;\n+  for (args = TREE_OPERAND (operation, 1), nargs = 0;\n+       args; args = TREE_CHAIN (args), ++nargs)\n+    {\n+      tree op = TREE_VALUE (args);\n+\n+      /* Bail out if the function has more than two arguments, we\n+\t do not have interesting builtin functions to vectorize with\n+\t more than two arguments.  */\n+      if (nargs >= 2)\n+\treturn false;\n+\n+      /* We can only handle calls with arguments of the same type.  */\n+      if (rhs_type\n+\t  && rhs_type != TREE_TYPE (op))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"argument types differ.\");\n+\t  return false;\n+\t}\n+      rhs_type = TREE_TYPE (op);\n+\n+      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt[nargs]))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"use not simple.\");\n+\t  return false;\n+\t}\n+    }\n+\n+  /* No arguments is also not good.  */\n+  if (nargs == 0)\n+    return false;\n+\n+  vectype_in = get_vectype_for_scalar_type (rhs_type);\n+\n+  lhs_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n+  vectype_out = get_vectype_for_scalar_type (lhs_type);\n+\n+  /* Only handle the case of vectors with the same number of elements.\n+     FIXME: We need a way to handle for example the SSE2 cvtpd2dq\n+\t    instruction which converts V2DFmode to V4SImode but only\n+\t    using the lower half of the V4SImode result.  */\n+  if (TYPE_VECTOR_SUBPARTS (vectype_in) != TYPE_VECTOR_SUBPARTS (vectype_out))\n+    return false;\n+\n   /* For now, we only vectorize functions if a target specific builtin\n      is available.  TODO -- in some cases, it might be profitable to\n      insert the calls for pieces of the vector, in order to be able\n      to vectorize other operations in the loop.  */\n-  if (!vectorizable_function (operation, vectype))\n+  fndecl = vectorizable_function (operation, vectype_out, vectype_in);\n+  if (fndecl == NULL_TREE)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"function is not vectorizable.\");\n \n       return false;\n     }\n-  gcc_assert (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS));\n \n-  for (args = TREE_OPERAND (operation, 1); args; args = TREE_CHAIN (args))\n-    {\n-      op = TREE_VALUE (args);\n-\n-      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"use not simple.\");\n-\t  return false;\n-\t}\n-    }\n+  gcc_assert (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS));\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -1690,29 +1708,50 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform operation.\");\n \n+  ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t     / TYPE_VECTOR_SUBPARTS (vectype_out));\n+  gcc_assert (ncopies >= 1);\n+\n   /* Handle def.  */\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n-  /* Handle uses.  */\n-  vargs = NULL_TREE;\n-  pvargs_end = &vargs;\n-  for (args = TREE_OPERAND (operation, 1); args; args = TREE_CHAIN (args))\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; ++j)\n     {\n-      op = TREE_VALUE (args);\n-      vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n-\t  \n-      *pvargs_end = tree_cons (NULL_TREE, vec_oprnd, NULL_TREE);\n-      pvargs_end = &TREE_CHAIN (*pvargs_end);\n-    }\n+      tree new_stmt, vargs;\n+      tree vec_oprnd[2];\n+      int n;\n+\n+      /* Build argument list for the vectorized call.  */\n+      vargs = NULL_TREE;\n+      for (args = TREE_OPERAND (operation, 1), n = 0;\n+\t   args; args = TREE_CHAIN (args), ++n)\n+\t{\n+\t  tree op = TREE_VALUE (args);\n \n-  fndecl = get_callee_fndecl (operation);\n-  rhs = build_vectorized_function_call (fndecl, vectype, vargs);\n-  *vec_stmt = build2 (GIMPLE_MODIFY_STMT, vectype, vec_dest, rhs);\n-  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n+\t  if (j == 0)\n+\t    vec_oprnd[n] = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t  else\n+\t    vec_oprnd[n] = vect_get_vec_def_for_stmt_copy (dt[n], vec_oprnd[n]);\n \n-  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+\t  vargs = tree_cons (NULL_TREE, vec_oprnd[n], vargs);\n+\t}\n+      vargs = nreverse (vargs);\n+\n+      rhs = build_function_call_expr (fndecl, vargs);\n+      new_stmt = build2 (GIMPLE_MODIFY_STMT, NULL_TREE, vec_dest, rhs);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n \n   /* The call in STMT might prevent it from being removed in dce.  We however\n      cannot remove it here, due to the way the ssa name it defines is mapped"}, {"sha": "b523d880bfd3ea6bc5cffe71c84c0df6ccdc43dd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95becfc098b8853f95c5302657c0b46ff575cb3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b95becfc098b8853f95c5302657c0b46ff575cb3", "patch": "@@ -412,7 +412,7 @@ extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_promotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_demotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n-extern bool vectorizable_function (tree, tree);\n+extern tree vectorizable_function (tree, tree, tree);\n extern bool vectorizable_call (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);"}]}