{"sha": "9c709f646545f39c49ea0d2efb85b41693e587f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM3MDlmNjQ2NTQ1ZjM5YzQ5ZWEwZDJlZmI4NWI0MTY5M2U1ODdmNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-05T11:13:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-05T11:13:14Z"}, "message": "tree-ssa-pre.c (create_component_ref_by_pieces_1): Move call handling ...\n\n2015-10-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Move\n\tcall handling ...\n\t(create_expression_by_pieces): ... here and build GIMPLE\n\tcalls directly.  Use gimple_build API and avoid force_gimple_operand.\n\t(insert_into_preds_of_block): Simplify.\n\t(do_regular_insertion): Add comment.\n\nFrom-SVN: r228471", "tree": {"sha": "695bf52d47256a987ce95fdfa3717959c8ff8783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/695bf52d47256a987ce95fdfa3717959c8ff8783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c709f646545f39c49ea0d2efb85b41693e587f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c709f646545f39c49ea0d2efb85b41693e587f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c709f646545f39c49ea0d2efb85b41693e587f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c709f646545f39c49ea0d2efb85b41693e587f4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "562eadf8e0f3a993ce3c2369a98baf0bf942091c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/562eadf8e0f3a993ce3c2369a98baf0bf942091c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/562eadf8e0f3a993ce3c2369a98baf0bf942091c"}], "stats": {"total": 280, "additions": 111, "deletions": 169}, "files": [{"sha": "4b9ed52e95afdf00d5db75715bcee77a4cab3dda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c709f646545f39c49ea0d2efb85b41693e587f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c709f646545f39c49ea0d2efb85b41693e587f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c709f646545f39c49ea0d2efb85b41693e587f4", "patch": "@@ -1,3 +1,12 @@\n+2015-10-05  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Move\n+\tcall handling ...\n+\t(create_expression_by_pieces): ... here and build GIMPLE\n+\tcalls directly.  Use gimple_build API and avoid force_gimple_operand.\n+\t(insert_into_preds_of_block): Simplify.\n+\t(do_regular_insertion): Add comment.\n+\n 2015-10-04  Jason Merrill  <jason@redhat.com>\n \n \t* builtins.def (BUILT_IN_ABORT): Add transaction_pure attribute."}, {"sha": "fb9ed02ec87184413d9cac334c08f7b64f510b15", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 102, "deletions": 169, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c709f646545f39c49ea0d2efb85b41693e587f4/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c709f646545f39c49ea0d2efb85b41693e587f4/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=9c709f646545f39c49ea0d2efb85b41693e587f4", "patch": "@@ -2474,42 +2474,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n   switch (currop->opcode)\n     {\n     case CALL_EXPR:\n-      {\n-\ttree folded, sc = NULL_TREE;\n-\tunsigned int nargs = 0;\n-\ttree fn, *args;\n-\tif (TREE_CODE (currop->op0) == FUNCTION_DECL)\n-\t  fn = currop->op0;\n-\telse\n-\t  fn = find_or_generate_expression (block, currop->op0, stmts);\n-\tif (!fn)\n-\t  return NULL_TREE;\n-\tif (currop->op1)\n-\t  {\n-\t    sc = find_or_generate_expression (block, currop->op1, stmts);\n-\t    if (!sc)\n-\t      return NULL_TREE;\n-\t  }\n-\targs = XNEWVEC (tree, ref->operands.length () - 1);\n-\twhile (*operand < ref->operands.length ())\n-\t  {\n-\t    args[nargs] = create_component_ref_by_pieces_1 (block, ref,\n-\t\t\t\t\t\t\t    operand, stmts);\n-\t    if (!args[nargs])\n-\t      return NULL_TREE;\n-\t    nargs++;\n-\t  }\n-\tfolded = build_call_array (currop->type,\n-\t\t\t\t   (TREE_CODE (fn) == FUNCTION_DECL\n-\t\t\t\t    ? build_fold_addr_expr (fn) : fn),\n-\t\t\t\t   nargs, args);\n-\tif (currop->with_bounds)\n-\t  CALL_WITH_BOUNDS_P (folded) = true;\n-\tfree (args);\n-\tif (sc)\n-\t  CALL_EXPR_STATIC_CHAIN (folded) = sc;\n-\treturn folded;\n-      }\n+      gcc_unreachable ();\n \n     case MEM_REF:\n       {\n@@ -2798,21 +2763,75 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \n   switch (expr->kind)\n     {\n-      /* We may hit the NAME/CONSTANT case if we have to convert types\n-\t that value numbering saw through.  */\n+    /* We may hit the NAME/CONSTANT case if we have to convert types\n+       that value numbering saw through.  */\n     case NAME:\n       folded = PRE_EXPR_NAME (expr);\n+      if (useless_type_conversion_p (exprtype, TREE_TYPE (folded)))\n+\treturn folded;\n       break;\n     case CONSTANT:\n-      folded = PRE_EXPR_CONSTANT (expr);\n-      break;\n-    case REFERENCE:\n-      {\n-\tvn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n-\tfolded = create_component_ref_by_pieces (block, ref, stmts);\n-\tif (!folded)\n-\t  return NULL_TREE;\n+      { \n+\tfolded = PRE_EXPR_CONSTANT (expr);\n+\ttree tem = fold_convert (exprtype, folded);\n+\tif (is_gimple_min_invariant (tem))\n+\t  return tem;\n+\tbreak;\n       }\n+    case REFERENCE:\n+      if (PRE_EXPR_REFERENCE (expr)->operands[0].opcode == CALL_EXPR)\n+\t{\n+\t  vn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n+\t  unsigned int operand = 1;\n+\t  vn_reference_op_t currop = &ref->operands[0];\n+\t  tree sc = NULL_TREE;\n+\t  tree fn;\n+\t  if (TREE_CODE (currop->op0) == FUNCTION_DECL)\n+\t    fn = currop->op0;\n+\t  else\n+\t    fn = find_or_generate_expression (block, currop->op0, stmts);\n+\t  if (!fn)\n+\t    return NULL_TREE;\n+\t  if (currop->op1)\n+\t    {\n+\t      sc = find_or_generate_expression (block, currop->op1, stmts);\n+\t      if (!sc)\n+\t\treturn NULL_TREE;\n+\t    }\n+\t  auto_vec<tree> args (ref->operands.length () - 1);\n+\t  while (operand < ref->operands.length ())\n+\t    {\n+\t      tree arg = create_component_ref_by_pieces_1 (block, ref,\n+\t\t\t\t\t\t\t   &operand, stmts);\n+\t      if (!arg)\n+\t\treturn NULL_TREE;\n+\t      args.quick_push (arg);\n+\t    }\n+\t  gcall *call\n+\t    = gimple_build_call_vec ((TREE_CODE (fn) == FUNCTION_DECL\n+\t\t\t\t      ? build_fold_addr_expr (fn) : fn), args);\n+\t  gimple_call_set_with_bounds (call, currop->with_bounds);\n+\t  if (sc)\n+\t    gimple_call_set_chain (call, sc);\n+\t  tree forcedname = make_ssa_name (currop->type);\n+\t  gimple_call_set_lhs (call, forcedname);\n+\t  gimple_set_vuse (call, BB_LIVE_VOP_ON_EXIT (block));\n+\t  gimple_seq_add_stmt_without_update (&forced_stmts, call);\n+\t  folded = forcedname;\n+\t}\n+      else\n+\t{\n+\t  folded = create_component_ref_by_pieces (block,\n+\t\t\t\t\t\t   PRE_EXPR_REFERENCE (expr),\n+\t\t\t\t\t\t   stmts);\n+\t  if (!folded)\n+\t    return NULL_TREE;\n+\t  name = make_temp_ssa_name (exprtype, NULL, \"pretmp\");\n+\t  newstmt = gimple_build_assign (name, folded);\n+\t  gimple_seq_add_stmt_without_update (&forced_stmts, newstmt);\n+\t  gimple_set_vuse (newstmt, BB_LIVE_VOP_ON_EXIT (block));\n+\t  folded = name;\n+\t}\n       break;\n     case NARY:\n       {\n@@ -2845,22 +2864,26 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t    for (i = 0; i < nary->length; ++i)\n \t      CONSTRUCTOR_APPEND_ELT (elts, NULL_TREE, genop[i]);\n \t    folded = build_constructor (nary->type, elts);\n+\t    name = make_temp_ssa_name (exprtype, NULL, \"pretmp\");\n+\t    newstmt = gimple_build_assign (name, folded);\n+\t    gimple_seq_add_stmt_without_update (&forced_stmts, newstmt);\n+\t    folded = name;\n \t  }\n \telse\n \t  {\n \t    switch (nary->length)\n \t      {\n \t      case 1:\n-\t\tfolded = fold_build1 (nary->opcode, nary->type,\n-\t\t\t\t      genop[0]);\n+\t\tfolded = gimple_build (&forced_stmts, nary->opcode, nary->type,\n+\t\t\t\t       genop[0]);\n \t\tbreak;\n \t      case 2:\n-\t\tfolded = fold_build2 (nary->opcode, nary->type,\n-\t\t\t\t      genop[0], genop[1]);\n+\t\tfolded = gimple_build (&forced_stmts, nary->opcode, nary->type,\n+\t\t\t\t       genop[0], genop[1]);\n \t\tbreak;\n \t      case 3:\n-\t\tfolded = fold_build3 (nary->opcode, nary->type,\n-\t\t\t\t      genop[0], genop[1], genop[2]);\n+\t\tfolded = gimple_build (&forced_stmts, nary->opcode, nary->type,\n+\t\t\t\t       genop[0], genop[1], genop[2]);\n \t\tbreak;\n \t      default:\n \t\tgcc_unreachable ();\n@@ -2872,17 +2895,15 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n       gcc_unreachable ();\n     }\n \n-  if (!useless_type_conversion_p (exprtype, TREE_TYPE (folded)))\n-    folded = fold_convert (exprtype, folded);\n+  folded = gimple_convert (&forced_stmts, exprtype, folded);\n+\n+  /* If everything simplified to an exisiting SSA name or constant just\n+     return that.  */\n+  if (gimple_seq_empty_p (forced_stmts)\n+      || is_gimple_min_invariant (folded))\n+    return folded;\n \n-  /* Force the generated expression to be a sequence of GIMPLE\n-     statements.\n-     We have to call unshare_expr because force_gimple_operand may\n-     modify the tree we pass to it.  */\n-  gimple_seq tem = NULL;\n-  folded = force_gimple_operand (unshare_expr (folded), &tem,\n-\t\t\t\t false, NULL);\n-  gimple_seq_add_seq_without_update (&forced_stmts, tem);\n+  gcc_assert (TREE_CODE (folded) == SSA_NAME);\n \n   /* If we have any intermediate expressions to the value sets, add them\n      to the value sets and chain them in the instruction stream.  */\n@@ -2895,9 +2916,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t  tree forcedname = gimple_get_lhs (stmt);\n \t  pre_expr nameexpr;\n \n-\t  if (TREE_CODE (forcedname) == SSA_NAME)\n+\t  if (forcedname != folded)\n \t    {\n-\t      bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (forcedname));\n \t      VN_INFO_GET (forcedname)->valnum = forcedname;\n \t      VN_INFO (forcedname)->value_id = get_next_value_id ();\n \t      nameexpr = get_or_alloc_expr_for_name (forcedname);\n@@ -2906,20 +2926,13 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t      bitmap_value_replace_in_set (AVAIL_OUT (block), nameexpr);\n \t    }\n \n-\t  gimple_set_vuse (stmt, BB_LIVE_VOP_ON_EXIT (block));\n-\t  gimple_set_modified (stmt, true);\n+\t  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (forcedname));\n+\t  gimple_set_plf (stmt, NECESSARY, false);\n \t}\n       gimple_seq_add_seq (stmts, forced_stmts);\n     }\n \n-  name = make_temp_ssa_name (exprtype, NULL, \"pretmp\");\n-  newstmt = gimple_build_assign (name, folded);\n-  gimple_set_vuse (newstmt, BB_LIVE_VOP_ON_EXIT (block));\n-  gimple_set_modified (newstmt, true);\n-  gimple_set_plf (newstmt, NECESSARY, false);\n-\n-  gimple_seq_add_stmt (stmts, newstmt);\n-  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (name));\n+  name = folded;\n \n   /* Fold the last statement.  */\n   gsi = gsi_last (*stmts);\n@@ -2947,7 +2960,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Inserted \");\n-      print_gimple_stmt (dump_file, newstmt, 0, 0);\n+      print_gimple_stmt (dump_file, gsi_stmt (gsi_last (*stmts)), 0, 0);\n       fprintf (dump_file, \" in predecessor %d (%04d)\\n\",\n \t       block->index, value_id);\n     }\n@@ -3004,106 +3017,25 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n       tree builtexpr;\n       bprime = pred->src;\n       eprime = avail[pred->dest_idx];\n-\n-      if (eprime->kind != NAME && eprime->kind != CONSTANT)\n+      builtexpr = create_expression_by_pieces (bprime, eprime,\n+\t\t\t\t\t       &stmts, type);\n+      gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n+      if (!gimple_seq_empty_p (stmts))\n \t{\n-\t  builtexpr = create_expression_by_pieces (bprime, eprime,\n-\t\t\t\t\t\t   &stmts, type);\n-\t  gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n \t  gsi_insert_seq_on_edge (pred, stmts);\n-\t  if (!builtexpr)\n-\t    {\n-\t      /* We cannot insert a PHI node if we failed to insert\n-\t\t on one edge.  */\n-\t      nophi = true;\n-\t      continue;\n-\t    }\n-\t  avail[pred->dest_idx] = get_or_alloc_expr_for_name (builtexpr);\n \t  insertions = true;\n \t}\n-      else if (eprime->kind == CONSTANT)\n-\t{\n-\t  /* Constants may not have the right type, fold_convert\n-\t     should give us back a constant with the right type.  */\n-\t  tree constant = PRE_EXPR_CONSTANT (eprime);\n-\t  if (!useless_type_conversion_p (type, TREE_TYPE (constant)))\n-\t    {\n-\t      tree builtexpr = fold_convert (type, constant);\n-\t      if (!is_gimple_min_invariant (builtexpr))\n-\t\t{\n-\t\t  tree forcedexpr = force_gimple_operand (builtexpr,\n-\t\t\t\t\t\t\t  &stmts, true,\n-\t\t\t\t\t\t\t  NULL);\n-\t\t  if (!is_gimple_min_invariant (forcedexpr))\n-\t\t    {\n-\t\t      if (forcedexpr != builtexpr)\n-\t\t\t{\n-\t\t\t  VN_INFO_GET (forcedexpr)->valnum = PRE_EXPR_CONSTANT (eprime);\n-\t\t\t  VN_INFO (forcedexpr)->value_id = get_expr_value_id (eprime);\n-\t\t\t}\n-\t\t      if (stmts)\n-\t\t\t{\n-\t\t\t  gimple_stmt_iterator gsi;\n-\t\t\t  gsi = gsi_start (stmts);\n-\t\t\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t\t    {\n-\t\t\t      gimple *stmt = gsi_stmt (gsi);\n-\t\t\t      tree lhs = gimple_get_lhs (stmt);\n-\t\t\t      if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t\t\tbitmap_set_bit (inserted_exprs,\n-\t\t\t\t\t\tSSA_NAME_VERSION (lhs));\n-\t\t\t      gimple_set_plf (stmt, NECESSARY, false);\n-\t\t\t    }\n-\t\t\t  gsi_insert_seq_on_edge (pred, stmts);\n-\t\t\t}\n-\t\t      avail[pred->dest_idx]\n-\t\t\t= get_or_alloc_expr_for_name (forcedexpr);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tavail[pred->dest_idx]\n-\t\t    = get_or_alloc_expr_for_constant (builtexpr);\n-\t    }\n-\t}\n-      else if (eprime->kind == NAME)\n+      if (!builtexpr)\n \t{\n-\t  /* We may have to do a conversion because our value\n-\t     numbering can look through types in certain cases, but\n-\t     our IL requires all operands of a phi node have the same\n-\t     type.  */\n-\t  tree name = PRE_EXPR_NAME (eprime);\n-\t  if (!useless_type_conversion_p (type, TREE_TYPE (name)))\n-\t    {\n-\t      tree builtexpr;\n-\t      tree forcedexpr;\n-\t      builtexpr = fold_convert (type, name);\n-\t      forcedexpr = force_gimple_operand (builtexpr,\n-\t\t\t\t\t\t &stmts, true,\n-\t\t\t\t\t\t NULL);\n-\n-\t      if (forcedexpr != name)\n-\t\t{\n-\t\t  VN_INFO_GET (forcedexpr)->valnum = VN_INFO (name)->valnum;\n-\t\t  VN_INFO (forcedexpr)->value_id = VN_INFO (name)->value_id;\n-\t\t}\n-\n-\t      if (stmts)\n-\t\t{\n-\t\t  gimple_stmt_iterator gsi;\n-\t\t  gsi = gsi_start (stmts);\n-\t\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t    {\n-\t\t      gimple *stmt = gsi_stmt (gsi);\n-\t\t      tree lhs = gimple_get_lhs (stmt);\n-\t\t      if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t\tbitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (lhs));\n-\t\t      gimple_set_plf (stmt, NECESSARY, false);\n-\t\t    }\n-\t\t  gsi_insert_seq_on_edge (pred, stmts);\n-\t\t}\n-\t      avail[pred->dest_idx] = get_or_alloc_expr_for_name (forcedexpr);\n-\t    }\n+\t  /* We cannot insert a PHI node if we failed to insert\n+\t     on one edge.  */\n+\t  nophi = true;\n+\t  continue;\n \t}\n+      if (is_gimple_min_invariant (builtexpr))\n+\tavail[pred->dest_idx] = get_or_alloc_expr_for_constant (builtexpr);\n+      else\n+\tavail[pred->dest_idx] = get_or_alloc_expr_for_name (builtexpr);\n     }\n   /* If we didn't want a phi node, and we made insertions, we still have\n      inserted new stuff, and thus return true.  If we didn't want a phi node,\n@@ -3267,6 +3199,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t         and so not come across fake pred edges.  */\n \t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n+\t      /* We are looking at ANTIC_OUT of bprime.  */\n \t      eprime = phi_translate (expr, ANTIC_IN (block), NULL,\n \t\t\t\t      bprime, block);\n "}]}