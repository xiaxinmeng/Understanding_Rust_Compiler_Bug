{"sha": "b59d39763b34536f6357a98a622908de83e152e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU5ZDM5NzYzYjM0NTM2ZjYzNTdhOThhNjIyOTA4ZGU4M2UxNTJlNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-09-09T13:54:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-09-09T13:54:08Z"}, "message": "tree-cfg.c (verify_types_in_gimple_op): Remove.\n\n2008-09-09  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-cfg.c (verify_types_in_gimple_op): Remove.\n\t(verify_types_in_gimple_call): Rename to ...\n\t(verify_gimple_call): ... this.  Enhance.\n\t(verify_types_in_gimple_cond): Remove.\n\t(verify_gimple_comparison): New function ...\n\t(verify_types_in_gimple_assign): ... split out from here.\n\t(verify_types_in_gimple_return): Rename to ...\n\t(verify_gimple_return): ... this.  Enhance.\n\t(verify_types_in_gimple_switch): Rename to ...\n\t(verify_gimple_switch): ... this.  Enhance.\n\t(verify_gimple_goto): New function.\n\t(verify_types_in_gimple_phi): Rename to ...\n\t(verify_gimple_phi): ... this.  Enhance.\n\t(verify_types_in_gimple_stmt): Adjust calls to helper functions.\n\tFold in single-statement cases from verify_types_in_gimple_seq_2.\n\t(verify_types_in_gimple_seq_2): Remove cases handled in\n\tverify_types_in_gimple_stmt.\n\nFrom-SVN: r140150", "tree": {"sha": "5094fbcc2ba7b8fe69b3b9b182c21cdb8ea4d116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5094fbcc2ba7b8fe69b3b9b182c21cdb8ea4d116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b59d39763b34536f6357a98a622908de83e152e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59d39763b34536f6357a98a622908de83e152e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b59d39763b34536f6357a98a622908de83e152e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59d39763b34536f6357a98a622908de83e152e6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3fb1916bb064eaff41a8470a5a4b155415517df1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb1916bb064eaff41a8470a5a4b155415517df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fb1916bb064eaff41a8470a5a4b155415517df1"}], "stats": {"total": 331, "additions": 198, "deletions": 133}, "files": [{"sha": "edde7b70cc1fce52c8d91aa19393c90939b6dafa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59d39763b34536f6357a98a622908de83e152e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59d39763b34536f6357a98a622908de83e152e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b59d39763b34536f6357a98a622908de83e152e6", "patch": "@@ -1,3 +1,23 @@\n+2008-09-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-cfg.c (verify_types_in_gimple_op): Remove.\n+\t(verify_types_in_gimple_call): Rename to ...\n+\t(verify_gimple_call): ... this.  Enhance.\n+\t(verify_types_in_gimple_cond): Remove.\n+\t(verify_gimple_comparison): New function ...\n+\t(verify_types_in_gimple_assign): ... split out from here.\n+\t(verify_types_in_gimple_return): Rename to ...\n+\t(verify_gimple_return): ... this.  Enhance.\n+\t(verify_types_in_gimple_switch): Rename to ...\n+\t(verify_gimple_switch): ... this.  Enhance.\n+\t(verify_gimple_goto): New function.\n+\t(verify_types_in_gimple_phi): Rename to ...\n+\t(verify_gimple_phi): ... this.  Enhance.\n+\t(verify_types_in_gimple_stmt): Adjust calls to helper functions.\n+\tFold in single-statement cases from verify_types_in_gimple_seq_2.\n+\t(verify_types_in_gimple_seq_2): Remove cases handled in\n+\tverify_types_in_gimple_stmt.\n+\n 2008-09-09  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (n_regs_to_save): New static variable."}, {"sha": "4b253bf789941ffbb02e7aaf4afc1cc517bf544d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 178, "deletions": 133, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59d39763b34536f6357a98a622908de83e152e6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59d39763b34536f6357a98a622908de83e152e6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b59d39763b34536f6357a98a622908de83e152e6", "patch": "@@ -3168,67 +3168,94 @@ valid_fixed_convert_types_p (tree type1, tree type2)\n \t      || FIXED_POINT_TYPE_P (type2)));\n }\n \n-/* Verify that OP is a valid GIMPLE operand.  Return true if there is\n-   an error, false otherwise.  */\n-\n-static bool\n-verify_types_in_gimple_op (tree op)\n-{\n-  if (!is_gimple_val (op) && !is_gimple_lvalue (op))\n-    {\n-      error (\"Invalid GIMPLE operand\");\n-      debug_generic_expr (op);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-\n /* Verify the contents of a GIMPLE_CALL STMT.  Returns true when there\n    is a problem, otherwise false.  */\n \n static bool\n-verify_types_in_gimple_call (gimple stmt)\n+verify_gimple_call (gimple stmt)\n {\n-  bool failed = false;\n-  unsigned int i;\n-  tree fn;\n+  tree fn = gimple_call_fn (stmt);\n+  tree fntype;\n \n-  if (gimple_call_lhs (stmt))\n-    failed |= verify_types_in_gimple_op (gimple_call_lhs (stmt));\n+  if (!POINTER_TYPE_P (TREE_TYPE  (fn))\n+      || (TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != FUNCTION_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != METHOD_TYPE))\n+    {\n+      error (\"non-function in gimple call\");\n+      return true;\n+    }\n \n-  fn = gimple_call_fn (stmt);\n-  if (TREE_CODE (fn) != OBJ_TYPE_REF\n-      && verify_types_in_gimple_op (fn))\n-    failed = true;\n+  if (gimple_call_lhs (stmt)\n+      && !is_gimple_lvalue (gimple_call_lhs (stmt)))\n+    {\n+      error (\"invalid LHS in gimple call\");\n+      return true;\n+    }\n \n-  if (gimple_call_chain (stmt))\n-    failed |= verify_types_in_gimple_op (gimple_call_chain (stmt));\n+  fntype = TREE_TYPE (TREE_TYPE (fn));\n+  if (gimple_call_lhs (stmt)\n+      && !useless_type_conversion_p (TREE_TYPE (gimple_call_lhs (stmt)),\n+\t\t\t\t     TREE_TYPE (fntype))\n+      /* ???  At least C++ misses conversions at assignments from\n+\t void * call results.\n+\t ???  Java is completely off.  Especially with functions\n+\t returning java.lang.Object.\n+\t For now simply allow arbitrary pointer type conversions.  */\n+      && !(POINTER_TYPE_P (TREE_TYPE (gimple_call_lhs (stmt)))\n+\t   && POINTER_TYPE_P (TREE_TYPE (fntype))))\n+    {\n+      error (\"invalid conversion in gimple call\");\n+      debug_generic_stmt (TREE_TYPE (gimple_call_lhs (stmt)));\n+      debug_generic_stmt (TREE_TYPE (fntype));\n+      return true;\n+    }\n \n-  for (i = 0; i < gimple_call_num_args (stmt); i++)\n-    failed |= verify_types_in_gimple_op (gimple_call_arg (stmt,i));\n+  /* ???  The C frontend passes unpromoted arguments in case it\n+     didn't see a function declaration before the call.  So for now\n+     leave the call arguments unverified.  Once we gimplify\n+     unit-at-a-time we have a chance to fix this.  */\n \n-  return failed;\n+  return false;\n }\n \n-\n-/* Verify the contents of a GIMPLE_COND STMT.  Returns true when there\n-   is a problem, otherwise false.  */\n+/* Verifies the gimple comparison with the result type TYPE and\n+   the operands OP0 and OP1.  */\n \n static bool\n-verify_types_in_gimple_cond (gimple stmt)\n+verify_gimple_comparison (tree type, tree op0, tree op1)\n {\n-  bool failed = false;\n-  \n-  failed |= verify_types_in_gimple_op (gimple_cond_lhs (stmt));\n-  failed |= verify_types_in_gimple_op (gimple_cond_rhs (stmt));\n-  failed |= verify_types_in_gimple_op (gimple_cond_true_label (stmt));\n-  failed |= verify_types_in_gimple_op (gimple_cond_false_label (stmt));\n+  tree op0_type = TREE_TYPE (op0);\n+  tree op1_type = TREE_TYPE (op1);\n \n-  return failed;\n-}\n+  if (!is_gimple_val (op0) || !is_gimple_val (op1))\n+    {\n+      error (\"invalid operands in gimple comparison\");\n+      return true;\n+    }\n \n+  /* For comparisons we do not have the operations type as the\n+     effective type the comparison is carried out in.  Instead\n+     we require that either the first operand is trivially\n+     convertible into the second, or the other way around.\n+     The resulting type of a comparison may be any integral type.\n+     Because we special-case pointers to void we allow\n+     comparisons of pointers with the same mode as well.  */\n+  if ((!useless_type_conversion_p (op0_type, op1_type)\n+       && !useless_type_conversion_p (op1_type, op0_type)\n+       && (!POINTER_TYPE_P (op0_type)\n+\t   || !POINTER_TYPE_P (op1_type)\n+\t   || TYPE_MODE (op0_type) != TYPE_MODE (op1_type)))\n+      || !INTEGRAL_TYPE_P (type))\n+    {\n+      error (\"type mismatch in comparison expression\");\n+      debug_generic_expr (type);\n+      debug_generic_expr (op0_type);\n+      debug_generic_expr (op1_type);\n+      return true;\n+    }\n+\n+  return false;\n+}\n \n /* Verify the contents of a GIMPLE_ASSIGN STMT.  Returns true when there\n    is a problem, otherwise false.\n@@ -3588,35 +3615,7 @@ verify_types_in_gimple_assign (gimple stmt)\n       return verify_types_in_gimple_reference (rhs1);\n \n     case tcc_comparison:\n-      {\n-\tif (!is_gimple_val (rhs1) || !is_gimple_val (rhs2))\n-\t  {\n-\t    error (\"invalid operands in comparison expression\");\n-\t    return true;\n-\t  }\n-\n-\t/* For comparisons we do not have the operations type as the\n-\t   effective type the comparison is carried out in.  Instead\n-\t   we require that either the first operand is trivially\n-\t   convertible into the second, or the other way around.\n-\t   The resulting type of a comparison may be any integral type.\n-\t   Because we special-case pointers to void we allow\n-\t   comparisons of pointers with the same mode as well.  */\n-\tif ((!useless_type_conversion_p (rhs1_type, rhs2_type)\n-\t     && !useless_type_conversion_p (rhs2_type, rhs1_type)\n-\t     && (!POINTER_TYPE_P (rhs1_type)\n-\t\t || !POINTER_TYPE_P (rhs2_type)\n-\t\t || TYPE_MODE (rhs1_type) != TYPE_MODE (rhs2_type)))\n-\t    || !INTEGRAL_TYPE_P (lhs_type))\n-\t  {\n-\t    error (\"type mismatch in comparison expression\");\n-\t    debug_generic_expr (lhs_type);\n-\t    debug_generic_expr (rhs1_type);\n-\t    debug_generic_expr (rhs2_type);\n-\t    return true;\n-\t  }\n-        break;\n-      }\n+      return verify_gimple_comparison (lhs_type, rhs1, rhs2);\n \n     default:;\n     }\n@@ -3629,27 +3628,72 @@ verify_types_in_gimple_assign (gimple stmt)\n    is a problem, otherwise false.  */\n \n static bool\n-verify_types_in_gimple_return (gimple stmt)\n+verify_gimple_return (gimple stmt)\n {\n   tree op = gimple_return_retval (stmt);\n+  tree restype = TREE_TYPE (TREE_TYPE (cfun->decl));\n \n+  /* We cannot test for present return values as we do not fix up missing\n+     return values from the original source.  */\n   if (op == NULL)\n     return false;\n-  \n-  return verify_types_in_gimple_op (op);\n+ \n+  if (!is_gimple_val (op)\n+      && TREE_CODE (op) != RESULT_DECL)\n+    {\n+      error (\"invalid operand in return statement\");\n+      debug_generic_stmt (op);\n+      return true;\n+    }\n+\n+  if (!useless_type_conversion_p (restype, TREE_TYPE (op))\n+      /* ???  With C++ we can have the situation that the result\n+\t decl is a reference type while the return type is an aggregate.  */\n+      && !(TREE_CODE (op) == RESULT_DECL\n+\t   && TREE_CODE (TREE_TYPE (op)) == REFERENCE_TYPE\n+\t   && useless_type_conversion_p (restype, TREE_TYPE (TREE_TYPE (op)))))\n+    {\n+      error (\"invalid conversion in return statement\");\n+      debug_generic_stmt (restype);\n+      debug_generic_stmt (TREE_TYPE (op));\n+      return true;\n+    }\n+\n+  return false;\n }\n \n \n+/* Verify the contents of a GIMPLE_GOTO STMT.  Returns true when there\n+   is a problem, otherwise false.  */\n+\n+static bool\n+verify_gimple_goto (gimple stmt)\n+{\n+  tree dest = gimple_goto_dest (stmt);\n+\n+  /* ???  We have two canonical forms of direct goto destinations, a\n+     bare LABEL_DECL and an ADDR_EXPR of a LABEL_DECL.  */\n+  if (TREE_CODE (dest) != LABEL_DECL\n+      && (!is_gimple_val (dest)\n+\t  || !POINTER_TYPE_P (TREE_TYPE (dest))))\n+    {\n+      error (\"goto destination is neither a label nor a pointer\");\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Verify the contents of a GIMPLE_SWITCH STMT.  Returns true when there\n    is a problem, otherwise false.  */\n \n static bool\n-verify_types_in_gimple_switch (gimple stmt)\n+verify_gimple_switch (gimple stmt)\n {\n   if (!is_gimple_val (gimple_switch_index (stmt)))\n     {\n       error (\"invalid operand to switch statement\");\n-      debug_generic_expr (gimple_switch_index (stmt));\n+      debug_generic_stmt (gimple_switch_index (stmt));\n       return true;\n     }\n \n@@ -3661,16 +3705,34 @@ verify_types_in_gimple_switch (gimple stmt)\n    and false otherwise.  */\n \n static bool\n-verify_types_in_gimple_phi (gimple stmt)\n+verify_gimple_phi (gimple stmt)\n {\n-  size_t i;\n+  tree type = TREE_TYPE (gimple_phi_result (stmt));\n+  unsigned i;\n \n-  if (verify_types_in_gimple_op (gimple_phi_result (stmt)))\n-    return true;\n+  if (!is_gimple_variable (gimple_phi_result (stmt)))\n+    {\n+      error (\"Invalid PHI result\");\n+      return true;\n+    }\n \n   for (i = 0; i < gimple_phi_num_args (stmt); i++)\n-    if (verify_types_in_gimple_op (gimple_phi_arg_def (stmt, i)))\n-      return true;\n+    {\n+      tree arg = gimple_phi_arg_def (stmt, i);\n+      if (!is_gimple_val (arg))\n+\t{\n+\t  error (\"Invalid PHI argument\");\n+\t  debug_generic_stmt (arg);\n+\t  return true;\n+\t}\n+      if (!useless_type_conversion_p (type, TREE_TYPE (arg)))\n+\t{\n+\t  error (\"Incompatible types in PHI argument\");\n+\t  debug_generic_stmt (type);\n+\t  debug_generic_stmt (TREE_TYPE (arg));\n+\t  return true;\n+\t}\n+    }\n \n   return false;\n }\n@@ -3702,32 +3764,37 @@ verify_types_in_gimple_stmt (gimple stmt)\n       return TREE_CODE (gimple_label_label (stmt)) != LABEL_DECL;\n \n     case GIMPLE_CALL:\n-      return verify_types_in_gimple_call (stmt);\n+      return verify_gimple_call (stmt);\n \n     case GIMPLE_COND:\n-      return verify_types_in_gimple_cond (stmt);\n+      return verify_gimple_comparison (boolean_type_node,\n+\t\t\t\t       gimple_cond_lhs (stmt),\n+\t\t\t\t       gimple_cond_rhs (stmt));\n \n     case GIMPLE_GOTO:\n-      return verify_types_in_gimple_op (gimple_goto_dest (stmt));\n-\n-    case GIMPLE_NOP:\n-    case GIMPLE_PREDICT:\n-      return false;\n+      return verify_gimple_goto (stmt);\n \n     case GIMPLE_SWITCH:\n-      return verify_types_in_gimple_switch (stmt);\n+      return verify_gimple_switch (stmt);\n \n     case GIMPLE_RETURN:\n-      return verify_types_in_gimple_return (stmt);\n+      return verify_gimple_return (stmt);\n \n     case GIMPLE_ASM:\n       return false;\n \n     case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-      return verify_types_in_gimple_op (gimple_cdt_location (stmt));\n+      return (!is_gimple_reg (gimple_cdt_location (stmt))\n+\t      || !POINTER_TYPE_P (TREE_TYPE (gimple_cdt_location (stmt))));\n \n     case GIMPLE_PHI:\n-      return verify_types_in_gimple_phi (stmt);\n+      return verify_gimple_phi (stmt);\n+\n+    /* Tuples that do not have tree operands.  */\n+    case GIMPLE_NOP:\n+    case GIMPLE_RESX:\n+    case GIMPLE_PREDICT:\n+      return false;\n \n     default:\n       gcc_unreachable ();\n@@ -3748,44 +3815,22 @@ verify_types_in_gimple_seq_2 (gimple_seq stmts)\n \n       switch (gimple_code (stmt))\n         {\n-          case GIMPLE_BIND:\n-            err |= verify_types_in_gimple_seq_2 (gimple_bind_body (stmt));\n-            break;\n-\n-          case GIMPLE_TRY:\n-            err |= verify_types_in_gimple_seq_2 (gimple_try_eval (stmt));\n-            err |= verify_types_in_gimple_seq_2 (gimple_try_cleanup (stmt));\n-            break;\n-\n-          case GIMPLE_EH_FILTER:\n-            err |= verify_types_in_gimple_seq_2\n-\t      \t     (gimple_eh_filter_failure (stmt));\n-            break;\n-\n-          case GIMPLE_CATCH:\n-             err |= verify_types_in_gimple_seq_2 (gimple_catch_handler (stmt));\n-             break;\n-\n-\t  case GIMPLE_OMP_CRITICAL:\n-          case GIMPLE_OMP_CONTINUE:\n-          case GIMPLE_OMP_MASTER:\n-          case GIMPLE_OMP_ORDERED:\n-          case GIMPLE_OMP_SECTION:\n-          case GIMPLE_OMP_FOR:\n-          case GIMPLE_OMP_PARALLEL:\n-\t  case GIMPLE_OMP_TASK:\n-          case GIMPLE_OMP_SECTIONS:\n-          case GIMPLE_OMP_SINGLE:\n-\t  case GIMPLE_OMP_ATOMIC_STORE:\n-\t  case GIMPLE_OMP_ATOMIC_LOAD:\n-            break;\n-\n-\t  /* Tuples that do not have trees.  */\n-          case GIMPLE_NOP:\n-          case GIMPLE_RESX:\n-          case GIMPLE_OMP_RETURN:\n-\t  case GIMPLE_PREDICT:\n-            break;\n+\tcase GIMPLE_BIND:\n+\t  err |= verify_types_in_gimple_seq_2 (gimple_bind_body (stmt));\n+\t  break;\n+\n+\tcase GIMPLE_TRY:\n+\t  err |= verify_types_in_gimple_seq_2 (gimple_try_eval (stmt));\n+\t  err |= verify_types_in_gimple_seq_2 (gimple_try_cleanup (stmt));\n+\t  break;\n+\n+\tcase GIMPLE_EH_FILTER:\n+\t  err |= verify_types_in_gimple_seq_2 (gimple_eh_filter_failure (stmt));\n+\t  break;\n+\n+\tcase GIMPLE_CATCH:\n+\t  err |= verify_types_in_gimple_seq_2 (gimple_catch_handler (stmt));\n+\t  break;\n \n \tdefault:\n \t  {"}]}