{"sha": "fdb8a883a4f3415aec0434737c9446f80d0133f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiOGE4ODNhNGYzNDE1YWVjMDQzNDczN2M5NDQ2ZjgwZDAxMzNmMA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1998-10-12T10:06:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-12T10:06:49Z"}, "message": "flow.c: Update comment.\n\n        * flow.c: Update comment.\n        (notice_stack_pointer_modification): New static function.\n        (record_volatile_insns): Use it.\n        (mark_regs_live_at_end): Mark the stack pointer as alive\n        at the end of the function if current_function_sp_is_unchanging\n        is set.\n        (life_analysis_1): Set current_function_sp_is_unchanging.\n        * function.c: Define it.\n        (init_function_start): Initialize it.\n        * output.h: Declare it.\n        * reorg.c (fill_simple_delay_slots, dbr_schedule): Mark\n        the stack pointer as alive at the end of the function if\n        current_function_sp_is_unchanging is set.\n        * i386.c (ix86_epilogue): Optimize the restoring\n        of the stack pointer.\n\nFrom-SVN: r23009", "tree": {"sha": "3dfd3a630883b77a0b6ce45c2d90fe9452e85a15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dfd3a630883b77a0b6ce45c2d90fe9452e85a15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdb8a883a4f3415aec0434737c9446f80d0133f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb8a883a4f3415aec0434737c9446f80d0133f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb8a883a4f3415aec0434737c9446f80d0133f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb8a883a4f3415aec0434737c9446f80d0133f0/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3babe36c375f475103415e2ab33b32681b25e8b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3babe36c375f475103415e2ab33b32681b25e8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3babe36c375f475103415e2ab33b32681b25e8b7"}], "stats": {"total": 94, "additions": 81, "deletions": 13}, "files": [{"sha": "2cb1e09631de317ecfb2bd82d25d9cf64db632dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdb8a883a4f3415aec0434737c9446f80d0133f0", "patch": "@@ -1,3 +1,21 @@\n+Sun Oct 11 16:49:15 EDT 1998  John Wehle  (john@feith.com)\n+\n+\t* flow.c: Update comment.\n+\t(notice_stack_pointer_modification): New static function.\n+\t(record_volatile_insns): Use it.\n+\t(mark_regs_live_at_end): Mark the stack pointer as alive\n+\tat the end of the function if current_function_sp_is_unchanging\n+\tis set.\n+\t(life_analysis_1): Set current_function_sp_is_unchanging.\n+\t* function.c: Define it.\n+\t(init_function_start): Initialize it.\n+\t* output.h: Declare it.\n+\t* reorg.c (fill_simple_delay_slots, dbr_schedule): Mark\n+\tthe stack pointer as alive at the end of the function if\n+\tcurrent_function_sp_is_unchanging is set.\n+\t* i386.c (ix86_epilogue): Optimize the restoring\n+\tof the stack pointer.\n+\n Mon Oct 12 02:03:25 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* i386/t-cygwin32 (TARGET_LIBGCC2_CFLAGS): Define."}, {"sha": "70cfcdc500b778c1e80be7b3557b58aee74a8d4f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fdb8a883a4f3415aec0434737c9446f80d0133f0", "patch": "@@ -2294,6 +2294,7 @@ ix86_epilogue (do_rtl)\n   rtx xops[3];\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n+  int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n   long tsize = get_frame_size ();\n \n   /* Compute the number of registers to pop */\n@@ -2307,12 +2308,7 @@ ix86_epilogue (do_rtl)\n \t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n       nregs++;\n \n-  /* sp is often  unreliable so we must go off the frame pointer.\n-\n-     In reality, we may not care if sp is unreliable, because we can restore\n-     the register relative to the frame pointer.  In theory, since each move\n-     is the same speed as a pop, and we don't need the leal, this is faster.\n-     For now restore multiple registers the old way. */\n+  /* sp is often unreliable so we may have to go off the frame pointer. */\n \n   offset = - tsize - (nregs * UNITS_PER_WORD);\n \n@@ -2329,9 +2325,14 @@ ix86_epilogue (do_rtl)\n   if (flag_pic || profile_flag || profile_block_flag)\n     emit_insn (gen_blockage ());\n \n-  if (nregs > 1 || ! frame_pointer_needed)\n+  /* If we're only restoring one register and sp is not valid then\n+     using a move instruction to restore the register since it's\n+     less work than reloading sp and popping the register.  Otherwise,\n+     restore sp (if necessary) and pop the registers. */\n+\n+  if (nregs > 1 || sp_valid)\n     {\n-      if (frame_pointer_needed)\n+      if ( !sp_valid )\n \t{\n \t  xops[0] = adj_offsettable_operand (AT_BP (QImode), offset);\n \t  if (do_rtl)"}, {"sha": "0161d94be64c47161296fb77fa7d2b9747a8210d", "filename": "gcc/flow.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=fdb8a883a4f3415aec0434737c9446f80d0133f0", "patch": "@@ -106,7 +106,10 @@ Boston, MA 02111-1307, USA.  */\n \n    life_analysis fills in certain vectors containing information about\n    register usage: reg_n_refs, reg_n_deaths, reg_n_sets, reg_live_length,\n-   reg_n_calls_crosses and reg_basic_block.  */\n+   reg_n_calls_crosses and reg_basic_block.\n+\n+   life_analysis sets current_function_sp_is_unchanging if the function\n+   doesn't modify the stack pointer.  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -289,6 +292,7 @@ static void init_regset_vector\t\tPROTO ((regset *, int,\n static void count_reg_sets_1\t\tPROTO ((rtx));\n static void count_reg_sets\t\tPROTO ((rtx));\n static void count_reg_references\tPROTO ((rtx));\n+static void notice_stack_pointer_modification PROTO ((rtx, rtx));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register numbers\n@@ -1221,9 +1225,28 @@ noop_move_p (insn)\n   return 0;\n }\n \n+static void\n+notice_stack_pointer_modification (x, pat)\n+     rtx x;\n+     rtx pat ATTRIBUTE_UNUSED;\n+{\n+  if (x == stack_pointer_rtx\n+      /* The stack pointer is only modified indirectly as the result\n+\t of a push until later in flow.  See the comments in rtl.texi\n+\t regarding Embedded Side-Effects on Addresses.  */\n+      || (GET_CODE (x) == MEM\n+\t  && (GET_CODE (XEXP (x, 0)) == PRE_DEC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == POST_DEC\n+\t      || GET_CODE (XEXP (x, 0)) == POST_INC)\n+\t  && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx))\n+    current_function_sp_is_unchanging = 0;\n+}\n+\n /* Record which insns refer to any volatile memory\n    or for any reason can't be deleted just because they are dead stores.\n-   Also, delete any insns that copy a register to itself.  */\n+   Also, delete any insns that copy a register to itself.\n+   And see if the stack pointer is modified.  */\n static void\n record_volatile_insns (f)\n      rtx f;\n@@ -1264,6 +1287,11 @@ record_volatile_insns (f)\n \t      NOTE_SOURCE_FILE (insn) = 0;\n \t    }\n \t}\n+\n+      /* Check if insn modifies the stack pointer.  */\n+      if ( current_function_sp_is_unchanging\n+\t   && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\tnote_stores (PATTERN (insn), notice_stack_pointer_modification);\n     }\n }\n \n@@ -1279,7 +1307,8 @@ mark_regs_live_at_end (set)\n   if (! EXIT_IGNORE_STACK\n       || (! FRAME_POINTER_REQUIRED\n \t  && ! current_function_calls_alloca\n-\t  && flag_omit_frame_pointer))\n+\t  && flag_omit_frame_pointer)\n+      || current_function_sp_is_unchanging)\n #endif\n     /* If exiting needs the right stack value,\n        consider the stack pointer live at the end of the function.  */\n@@ -1376,6 +1405,11 @@ life_analysis_1 (f, nregs)\n     = (regset *) alloca (n_basic_blocks * sizeof (regset));\n   init_regset_vector (basic_block_significant, n_basic_blocks, &flow_obstack);\n \n+  /* Assume that the stack pointer is unchanging if alloca hasn't been used.\n+     This will be cleared by record_volatile_insns if it encounters an insn\n+     which modifies the stack pointer.  */\n+  current_function_sp_is_unchanging = !current_function_calls_alloca;\n+\n   record_volatile_insns (f);\n \n   if (n_basic_blocks > 0)"}, {"sha": "48018cff6f5c57361f84c76c1ebf7cedbff27caf", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fdb8a883a4f3415aec0434737c9446f80d0133f0", "patch": "@@ -138,6 +138,12 @@ int current_function_has_computed_jump;\n \n int current_function_contains_functions;\n \n+/* Nonzero if function being compiled doesn't modify the stack pointer\n+   (ignoring the prologue and epilogue).  This is only valid after\n+   life_analysis has run. */\n+\n+int current_function_sp_is_unchanging;\n+\n /* Nonzero if the current function is a thunk (a lightweight function that\n    just adjusts one of its arguments and forwards to another function), so\n    we should try to cut corners where we can.  */\n@@ -5426,6 +5432,7 @@ init_function_start (subr, filename, line)\n   current_function_has_nonlocal_label = 0;\n   current_function_has_nonlocal_goto = 0;\n   current_function_contains_functions = 0;\n+  current_function_sp_is_unchanging = 0;\n   current_function_is_thunk = 0;\n \n   current_function_returns_pcc_struct = 0;"}, {"sha": "83ec167f298ea59a24ea921f8750c26e8fc5585d", "filename": "gcc/output.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=fdb8a883a4f3415aec0434737c9446f80d0133f0", "patch": "@@ -380,6 +380,12 @@ extern int current_function_has_nonlocal_label;\n \n extern int current_function_contains_functions;\n \n+/* Nonzero if function being compiled doesn't modify the stack pointer\n+   (ignoring the prologue and epilogue).  This is only valid after\n+   life_analysis has run. */\n+\n+extern int current_function_sp_is_unchanging;\n+\n /* Nonzero if the current function returns a pointer type */\n \n extern int current_function_returns_pointer;"}, {"sha": "d4c7778570cc492ae1979af5cb748870fcb51f4d", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb8a883a4f3415aec0434737c9446f80d0133f0/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=fdb8a883a4f3415aec0434737c9446f80d0133f0", "patch": "@@ -3452,7 +3452,8 @@ fill_simple_delay_slots (non_jumps_p)\n       SET_HARD_REG_BIT (needed.regs, HARD_FRAME_POINTER_REGNUM);\n #endif\n #ifdef EXIT_IGNORE_STACK\n-      if (! EXIT_IGNORE_STACK)\n+      if (! EXIT_IGNORE_STACK\n+\t  || current_function_sp_is_unchanging)\n #endif\n \tSET_HARD_REG_BIT (needed.regs, STACK_POINTER_REGNUM);\n     }\n@@ -4602,7 +4603,8 @@ dbr_schedule (first, file)\n       SET_HARD_REG_BIT (end_of_function_needs.regs, HARD_FRAME_POINTER_REGNUM);\n #endif\n #ifdef EXIT_IGNORE_STACK\n-      if (! EXIT_IGNORE_STACK)\n+      if (! EXIT_IGNORE_STACK\n+\t  || current_function_sp_is_unchanging)\n #endif\n \tSET_HARD_REG_BIT (end_of_function_needs.regs, STACK_POINTER_REGNUM);\n     }"}]}