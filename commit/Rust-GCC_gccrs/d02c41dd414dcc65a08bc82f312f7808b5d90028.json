{"sha": "d02c41dd414dcc65a08bc82f312f7808b5d90028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAyYzQxZGQ0MTRkY2M2NWEwOGJjODJmMzEyZjc4MDhiNWQ5MDAyOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-12-01T20:38:08Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-12-01T20:39:46Z"}, "message": "PR middle-end/97373 - missing warning on sprintf into allocated destination\n\ngcc/ChangeLog:\n\n\tPR middle-end/97373\n\t* builtins.c (compute_objsize): Rename...\n\t(compute_objsize_r): to this.  Change order and types of arguments.\n\tUse new argument.  Adjust calls to self.\n\t(access_ref::get_ref): New member function.\n\t(pointer_query::pointer_query): New member function.\n\t(pointer_query::get_ref): Same.\n\t(pointer_query::put_ref): Same.\n\t(handle_min_max_size): Change order and types of arguments.\n\t(maybe_emit_free_warning): Add a test.\n\t* builtins.h (class pointer_query): New class.\n\t(compute_objsize): Declare an overload.\n\t* gimple-ssa-sprintf.c (get_destination_size): Add argument.\n\t(handle_printf_call): Change argument type.\n\t* tree-ssa-strlen.c (adjust_last_stmt): Add an argument and use it.\n\t(maybe_warn_overflow): Same.\n\t(handle_builtin_strcpy): Same.\n\t(maybe_diag_stxncpy_trunc): Same.\n\t(handle_builtin_memcpy): Change argument type.  Adjust calls.\n\t(handle_builtin_strcat): Same.\n\t(handle_builtin_memset): Same.\n\t(handle_store): Same.\n\t(strlen_check_and_optimize_call): Same.\n\t(check_and_optimize_stmt): Same.\n\t(strlen_dom_walker): Add new data members.\n\t(strlen_dom_walker::before_dom_children): Use new member.\n\t(printf_strlen_execute): Dump cache performance counters.  Remove\n\tobjsize pass cleanup.\n\t* tree-ssa-strlen.h (maybe_diag_stxncpy_trunc): Add argument.\n\t(handle_printf_call): Change argument type.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/97373\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-25.c: New test.", "tree": {"sha": "1e37ab650d96cc4b1bf719bc64cda60c5b6b8342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e37ab650d96cc4b1bf719bc64cda60c5b6b8342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d02c41dd414dcc65a08bc82f312f7808b5d90028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d02c41dd414dcc65a08bc82f312f7808b5d90028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d02c41dd414dcc65a08bc82f312f7808b5d90028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d02c41dd414dcc65a08bc82f312f7808b5d90028/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65"}], "stats": {"total": 534, "additions": 444, "deletions": 90}, "files": [{"sha": "0f2c8c477dfedcf840468d0891fb8f95889638e1", "filename": "gcc/builtins.c", "status": "modified", "additions": 214, "deletions": 23, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d02c41dd414dcc65a08bc82f312f7808b5d90028", "patch": "@@ -185,8 +185,8 @@ static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n-static bool compute_objsize (tree, int, access_ref *, ssa_name_limit_t &,\n-\t\t\t     range_query *);\n+static bool compute_objsize_r (tree, int, access_ref *, ssa_name_limit_t &,\n+\t\t\t       pointer_query *);\n \n unsigned HOST_WIDE_INT target_newline;\n unsigned HOST_WIDE_INT target_percent;\n@@ -250,7 +250,7 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n \t\t     access_ref *pref /* = NULL */,\n \t\t     int ostype /* = 1 */,\n \t\t     ssa_name_limit_t *psnlim /* = NULL */,\n-\t\t     range_query *rvals /* = NULL */) const\n+\t\t     pointer_query *qry /* = NULL */) const\n {\n   gphi *phi_stmt = this->phi ();\n   if (!phi_stmt)\n@@ -271,6 +271,10 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n   /* The conservative result of the PHI reflecting the offset and size\n      of the largest PHI argument, regardless of whether or not they all\n      refer to the same object.  */\n+  pointer_query empty_qry;\n+  if (!qry)\n+    qry = &empty_qry;\n+\n   access_ref phi_ref;\n   if (pref)\n     {\n@@ -292,13 +296,15 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n     {\n       access_ref phi_arg_ref;\n       tree arg = gimple_phi_arg_def (phi_stmt, i);\n-      if (!compute_objsize (arg, ostype, &phi_arg_ref, *psnlim, rvals)\n+      if (!compute_objsize_r (arg, ostype, &phi_arg_ref, *psnlim, qry)\n \t  || phi_arg_ref.sizrng[0] < 0)\n \t/* A PHI with all null pointer arguments.  */\n \treturn NULL_TREE;\n \n       /* Add PREF's offset to that of the argument.  */\n       phi_arg_ref.add_offset (orng[0], orng[1]);\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\tqry->put_ref (arg, phi_arg_ref);\n \n       if (all_refs)\n \tall_refs->safe_push (phi_arg_ref);\n@@ -558,7 +564,6 @@ ssa_name_limit_t::next ()\n     return false;\n \n   --ssa_def_max;\n-\n   return true;\n }\n \n@@ -593,6 +598,142 @@ ssa_name_limit_t::~ssa_name_limit_t ()\n     BITMAP_FREE (visited);\n }\n \n+/* Default ctor.  Initialize object with pointers to the range_query\n+   and cache_type instances to use or null.  */\n+\n+pointer_query::pointer_query (range_query *qry /* = NULL */,\n+\t\t\t      cache_type *cache /* = NULL */)\n+: rvals (qry), var_cache (cache), hits (), misses (),\n+  failures (), depth (), max_depth ()\n+{\n+  /* No op.  */\n+}\n+\n+/* Return a pointer to the cached access_ref instance for the SSA_NAME\n+   PTR if it's there or null otherwise.  */\n+\n+const access_ref *\n+pointer_query::get_ref (tree ptr, int ostype /* = 1 */) const\n+{\n+  if (!var_cache)\n+    {\n+      ++misses;\n+      return NULL;\n+    }\n+\n+  unsigned version = SSA_NAME_VERSION (ptr);\n+  unsigned idx = version << 1 | (ostype & 1);\n+  if (var_cache->indices.length () <= idx)\n+    {\n+      ++misses;\n+      return NULL;\n+    }\n+\n+  unsigned cache_idx = var_cache->indices[idx];\n+  if (var_cache->access_refs.length () <= cache_idx)\n+    {\n+      ++misses;\n+      return NULL;\n+    }\n+\n+  access_ref &cache_ref = var_cache->access_refs[cache_idx];\n+  if (cache_ref.ref)\n+    {\n+      ++hits;\n+      return &cache_ref;\n+    }\n+\n+  ++misses;\n+  return NULL;\n+}\n+\n+/* Retrieve the access_ref instance for a variable from the cache if it's\n+   there or compute it and insert it into the cache if it's nonnonull.  */\n+\n+bool\n+pointer_query::get_ref (tree ptr, access_ref *pref, int ostype /* = 1 */)\n+{\n+  const unsigned version\n+    = TREE_CODE (ptr) == SSA_NAME ? SSA_NAME_VERSION (ptr) : 0;\n+\n+  if (var_cache && version)\n+    {\n+      unsigned idx = version << 1 | (ostype & 1);\n+      if (idx < var_cache->indices.length ())\n+\t{\n+\t  unsigned cache_idx = var_cache->indices[idx] - 1;\n+\t  if (cache_idx < var_cache->access_refs.length ()\n+\t      && var_cache->access_refs[cache_idx].ref)\n+\t    {\n+\t      ++hits;\n+\t      *pref = var_cache->access_refs[cache_idx];\n+\t      return true;\n+\t    }\n+\t}\n+\n+      ++misses;\n+    }\n+\n+  if (!compute_objsize (ptr, ostype, pref, this))\n+    {\n+      ++failures;\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Add a copy of the access_ref REF for the SSA_NAME to the cache if it's\n+   nonnull.  */\n+\n+void\n+pointer_query::put_ref (tree ptr, const access_ref &ref, int ostype /* = 1 */)\n+{\n+  /* Only add populated/valid entries.  */\n+  if (!var_cache || !ref.ref || ref.sizrng[0] < 0)\n+    return;\n+\n+  /* Add REF to the two-level cache.  */\n+  unsigned version = SSA_NAME_VERSION (ptr);\n+  unsigned idx = version << 1 | (ostype & 1);\n+\n+  /* Grow INDICES if necessary.  An index is valid if it's nonzero.\n+     Its value minus one is the index into ACCESS_REFS.  Not all\n+     entries are valid.  */\n+  if (var_cache->indices.length () <= idx)\n+    var_cache->indices.safe_grow_cleared (idx + 1);\n+\n+  if (!var_cache->indices[idx])\n+    var_cache->indices[idx] = var_cache->access_refs.length () + 1;\n+\n+  /* Grow ACCESS_REF cache if necessary.  An entry is valid if its\n+     REF member is nonnull.  All entries except for the last two\n+     are valid.  Once nonnull, the REF value must stay unchanged.  */\n+  unsigned cache_idx = var_cache->indices[idx];\n+  if (var_cache->access_refs.length () <= cache_idx)\n+    var_cache->access_refs.safe_grow_cleared (cache_idx + 1);\n+\n+  access_ref cache_ref = var_cache->access_refs[cache_idx - 1];\n+  if (cache_ref.ref)\n+  {\n+    gcc_checking_assert (cache_ref.ref == ref.ref);\n+    return;\n+  }\n+\n+  cache_ref = ref;\n+}\n+\n+/* Flush the cache if it's nonnull.  */\n+\n+void\n+pointer_query::flush_cache ()\n+{\n+  if (!var_cache)\n+    return;\n+  var_cache->indices.release ();\n+  var_cache->access_refs.release ();\n+}\n+\n /* Return true if NAME starts with __builtin_ or __sync_.  */\n \n static bool\n@@ -5076,7 +5217,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2],\n \n static bool\n handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n-\t\t     ssa_name_limit_t &snlim, range_query *rvals)\n+\t\t     ssa_name_limit_t &snlim, pointer_query *qry)\n {\n   tree_code code = gimple_assign_rhs_code (stmt);\n \n@@ -5088,7 +5229,7 @@ handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n      determined from the other instead, adjusted up or down as appropriate\n      for the expression.  */\n   access_ref aref[2] = { *pref, *pref };\n-  if (!compute_objsize (ptr, ostype, &aref[0], snlim, rvals))\n+  if (!compute_objsize_r (ptr, ostype, &aref[0], snlim, qry))\n     {\n       aref[0].base0 = false;\n       aref[0].offrng[0] = aref[0].offrng[1] = 0;\n@@ -5097,7 +5238,7 @@ handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n     }\n \n   ptr = gimple_assign_rhs2 (stmt);\n-  if (!compute_objsize (ptr, ostype, &aref[1], snlim, rvals))\n+  if (!compute_objsize_r (ptr, ostype, &aref[1], snlim, qry))\n     {\n       aref[1].base0 = false;\n       aref[1].offrng[0] = aref[1].offrng[1] = 0;\n@@ -5165,8 +5306,8 @@ handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n    to influence code generation or optimization.  */\n \n static bool\n-compute_objsize (tree ptr, int ostype, access_ref *pref,\n-\t\t ssa_name_limit_t &snlim, range_query *rvals)\n+compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n+\t\t   ssa_name_limit_t &snlim, pointer_query *qry)\n {\n   STRIP_NOPS (ptr);\n \n@@ -5198,11 +5339,12 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n     }\n \n   const tree_code code = TREE_CODE (ptr);\n+  range_query *const rvals = qry ? qry->rvals : NULL;\n \n   if (code == BIT_FIELD_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n+      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n \treturn false;\n \n       offset_int off = wi::to_offset (pref->eval (TREE_OPERAND (ptr, 2)));\n@@ -5224,7 +5366,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t  /* In OSTYPE zero (for raw memory functions like memcpy), use\n \t     the maximum size instead if the identity of the enclosing\n \t     object cannot be determined.  */\n-\t  if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n+\t  if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n \t    return false;\n \n \t  /* Otherwise, use the size of the enclosing object and add\n@@ -5299,7 +5441,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t    return false;\n \t}\n \n-      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n+      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n \treturn false;\n \n       offset_int orng[2];\n@@ -5365,7 +5507,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   if (code == TARGET_MEM_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n+      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n \treturn false;\n \n       /* TODO: Handle remaining operands.  Until then, add maximum offset.  */\n@@ -5399,7 +5541,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   if (code == POINTER_PLUS_EXPR)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n+      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n \treturn false;\n \n       offset_int orng[2];\n@@ -5414,7 +5556,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   if (code == VIEW_CONVERT_EXPR)\n     {\n       ptr = TREE_OPERAND (ptr, 0);\n-      return compute_objsize (ptr, ostype, pref, snlim, rvals);\n+      return compute_objsize_r (ptr, ostype, pref, snlim, qry);\n     }\n \n   if (code == SSA_NAME)\n@@ -5424,6 +5566,19 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n       /* Only process an SSA_NAME if the recursion limit has not yet\n \t been reached.  */\n+      if (qry)\n+\t{\n+\t  if (++qry->depth)\n+\t    qry->max_depth = qry->depth;\n+\t  if (const access_ref *cache_ref = qry->get_ref (ptr))\n+\t    {\n+\t      /* If the pointer is in the cache set *PREF to what it refers\n+\t\t to and return success.  */\n+\t      *pref = *cache_ref;\n+\t      return true;\n+\t    }\n+\t}\n+\n       gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n       if (is_gimple_call (stmt))\n \t{\n@@ -5452,7 +5607,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t      offset_int offrng[2];\n \t      if (tree ret = gimple_call_return_array (stmt, offrng, rvals))\n \t\t{\n-\t\t  if (!compute_objsize (ret, ostype, pref, snlim, rvals))\n+\t\t  if (!compute_objsize_r (ret, ostype, pref, snlim, qry))\n \t\t    return false;\n \n \t\t  /* Cap OFFRNG[1] to at most the remaining size of\n@@ -5474,6 +5629,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t\t  pref->ref = ptr;\n \t\t}\n \t    }\n+\t  qry->put_ref (ptr, *pref);\n \t  return true;\n \t}\n \n@@ -5490,23 +5646,26 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n \t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n \t      pref->ref = ref;\n+\t      qry->put_ref (ptr, *pref);\n \t      return true;\n \t    }\n \n \t  pref->set_max_size_range ();\n \t  pref->base0 = false;\n \t  pref->ref = ptr;\n+\t  qry->put_ref (ptr, *pref);\n \t  return true;\n \t}\n \n       if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n \t  pref->ref = ptr;\n \t  access_ref phi_ref = *pref;\n-\t  if (!pref->get_ref (NULL, &phi_ref, ostype, &snlim, rvals))\n+\t  if (!pref->get_ref (NULL, &phi_ref, ostype, &snlim, qry))\n \t    return false;\n \t  *pref = phi_ref;\n \t  pref->ref = ptr;\n+\t  qry->put_ref (ptr, *pref);\n \t  return true;\n \t}\n \n@@ -5525,15 +5684,20 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n       tree_code code = gimple_assign_rhs_code (stmt);\n \n       if (code == MAX_EXPR || code == MIN_EXPR)\n-\treturn handle_min_max_size (stmt, ostype, pref, snlim, rvals);\n+\t{\n+\t  if (!handle_min_max_size (stmt, ostype, pref, snlim, qry))\n+\t    return false;\n+\t  qry->put_ref (ptr, *pref);\n+\t  return true;\n+\t}\n \n       tree rhs = gimple_assign_rhs1 (stmt);\n \n       if (code == POINTER_PLUS_EXPR\n \t  && TREE_CODE (TREE_TYPE (rhs)) == POINTER_TYPE)\n \t{\n \t  /* Compute the size of the object first. */\n-\t  if (!compute_objsize (rhs, ostype, pref, snlim, rvals))\n+\t  if (!compute_objsize_r (rhs, ostype, pref, snlim, qry))\n \t    return false;\n \n \t  offset_int orng[2];\n@@ -5542,12 +5706,13 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t    pref->add_offset (orng[0], orng[1]);\n \t  else\n \t    pref->add_max_offset ();\n+\t  qry->put_ref (ptr, *pref);\n \t  return true;\n \t}\n \n       if (code == ADDR_EXPR\n \t  || code == SSA_NAME)\n-\treturn compute_objsize (rhs, ostype, pref, snlim, rvals);\n+\treturn compute_objsize_r (rhs, ostype, pref, snlim, qry);\n \n       /* (This could also be an assignment from a nonlocal pointer.)  Save\n \t PTR to mention in diagnostics but otherwise treat it as a pointer\n@@ -5563,6 +5728,8 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   pref->ref = ptr;\n   pref->base0 = false;\n   pref->set_max_size_range ();\n+  if (TREE_CODE (ptr) == SSA_NAME)\n+    qry->put_ref (ptr, *pref);\n   return true;\n }\n \n@@ -5573,8 +5740,32 @@ tree\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t\t range_query *rvals /* = NULL */)\n {\n+  pointer_query qry;\n+  qry.rvals = rvals;\n+  ssa_name_limit_t snlim;\n+  if (!compute_objsize_r (ptr, ostype, pref, snlim, &qry))\n+    return NULL_TREE;\n+\n+  offset_int maxsize = pref->size_remaining ();\n+  if (pref->base0 && pref->offrng[0] < 0 && pref->offrng[1] >= 0)\n+    pref->offrng[0] = 0;\n+  return wide_int_to_tree (sizetype, maxsize);\n+}\n+\n+/* Transitional wrapper.  The function should be removed once callers\n+   transition to the pointer_query API.  */\n+\n+tree\n+compute_objsize (tree ptr, int ostype, access_ref *pref, pointer_query *ptr_qry)\n+{\n+  pointer_query qry;\n+  if (ptr_qry)\n+    ptr_qry->depth = 0;\n+  else\n+    ptr_qry = &qry;\n+\n   ssa_name_limit_t snlim;\n-  if (!compute_objsize (ptr, ostype, pref, snlim, rvals))\n+  if (!compute_objsize_r (ptr, ostype, pref, snlim, ptr_qry))\n     return NULL_TREE;\n \n   offset_int maxsize = pref->size_remaining ();\n@@ -5583,7 +5774,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   return wide_int_to_tree (sizetype, maxsize);\n }\n \n-/* Transitional wrapper around the above.  The function should be removed\n+/* Legacy wrapper around the above.  The function should be removed\n    once callers transition to one of the two above.  */\n \n tree"}, {"sha": "0ca1cbc9f4da2be90b430e3e99166ad946559051", "filename": "gcc/builtins.h", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=d02c41dd414dcc65a08bc82f312f7808b5d90028", "patch": "@@ -187,7 +187,7 @@ class ssa_name_limit_t\n   ~ssa_name_limit_t ();\n };\n \n-class range_query;\n+class pointer_query;\n \n /* Describes a reference to an object used in an access.  */\n struct access_ref\n@@ -203,7 +203,7 @@ struct access_ref\n \n   /* Return the object to which REF refers.  */\n   tree get_ref (vec<access_ref> *, access_ref * = NULL, int = 1,\n-\t\tssa_name_limit_t * = NULL, range_query * = NULL) const;\n+\t\tssa_name_limit_t * = NULL, pointer_query * = NULL) const;\n \n   /* Return true if OFFRNG is the constant zero.  */\n   bool offset_zero () const\n@@ -271,6 +271,52 @@ struct access_ref\n   bool parmarray;\n };\n \n+class range_query;\n+\n+/* Queries and caches compute_objsize results.  */\n+class pointer_query\n+{\n+  DISABLE_COPY_AND_ASSIGN (pointer_query);\n+\n+public:\n+  /* Type of the two-level cache object defined by clients of the class\n+     to have pointer SSA_NAMEs cached for speedy access.  */\n+  struct cache_type\n+  {\n+    /* 1-based indices into cache.  */\n+    vec<unsigned> indices;\n+    /* The cache itself.  */\n+    vec<access_ref> access_refs;\n+  };\n+\n+  /* Construct an object with the given Ranger instance and cache.  */\n+  explicit pointer_query (range_query * = NULL, cache_type * = NULL);\n+\n+  /* Retrieve the access_ref for a variable from cache if it's there.  */\n+  const access_ref* get_ref (tree, int = 1) const;\n+\n+  /* Retrieve the access_ref for a variable from cache or compute it.  */\n+  bool get_ref (tree, access_ref*, int = 1);\n+\n+  /* Add an access_ref for the SSA_NAME to the cache.  */\n+  void put_ref (tree, const access_ref&, int = 1);\n+\n+  /* Flush the cache.  */\n+  void flush_cache ();\n+\n+  /* A Ranger instance.  May be null to use global ranges.  */\n+  range_query *rvals;\n+  /* Cache of SSA_NAMEs.  May be null to disable caching.  */\n+  cache_type *var_cache;\n+\n+  /* Cache performance counters.  */\n+  mutable unsigned hits;\n+  mutable unsigned misses;\n+  mutable unsigned failures;\n+  mutable unsigned depth;\n+  mutable unsigned max_depth;\n+};\n+\n /* Describes a pair of references used in an access by built-in\n    functions like memcpy.  */\n struct access_data\n@@ -295,7 +341,10 @@ struct access_data\n extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n \t\t\t\t    range_query * = NULL);\n extern tree gimple_parm_array_size (tree, wide_int[2], bool * = NULL);\n+\n extern tree compute_objsize (tree, int, access_ref *, range_query * = NULL);\n+/* Legacy/transitional API.  Should not be used in new code.  */\n+extern tree compute_objsize (tree, int, access_ref *, pointer_query *);\n extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n \t\t\t     range_query * = NULL);\n extern bool check_access (tree, tree, tree, tree, tree,"}, {"sha": "ca0572f53d3d1db2b882a94f253a2d52e905ae77", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=d02c41dd414dcc65a08bc82f312f7808b5d90028", "patch": "@@ -4032,26 +4032,22 @@ compute_format_length (call_info &info, format_result *res, range_query *query)\n    available, or the maximum possible size otherwise.  */\n \n static unsigned HOST_WIDE_INT\n-get_destination_size (tree dest)\n+get_destination_size (tree dest, pointer_query &ptr_qry)\n {\n   /* When there is no destination return the maximum.  */\n   if (!dest)\n     return HOST_WIDE_INT_MAX;\n \n-  /* Initialize object size info before trying to compute it.  */\n-  init_object_sizes ();\n+  /* Use compute_objsize to determine the size of the destination object.  */\n+  access_ref aref;\n+  if (!ptr_qry.get_ref (dest, &aref))\n+    return HOST_WIDE_INT_MAX;\n \n-  /* Use __builtin_object_size to determine the size of the destination\n-     object.  When optimizing, determine the smallest object (such as\n-     a member array as opposed to the whole enclosing object), otherwise\n-     use type-zero object size to determine the size of the enclosing\n-     object (the function fails without optimization in this type).  */\n-  int ost = optimize > 0;\n-  unsigned HOST_WIDE_INT size;\n-  if (compute_builtin_object_size (dest, ost, &size))\n-    return size;\n+  offset_int remsize = aref.size_remaining ();\n+  if (!wi::fits_uhwi_p (remsize))\n+    return HOST_WIDE_INT_MAX;\n \n-  return HOST_WIDE_INT_MAX;\n+  return remsize.to_uhwi ();\n }\n \n /* Return true if the call described by INFO with result RES safe to\n@@ -4296,7 +4292,7 @@ get_user_idx_format (tree fndecl, unsigned *idx_args)\n    gsi_next should not be performed in the caller.  */\n \n bool\n-handle_printf_call (gimple_stmt_iterator *gsi, range_query *query)\n+handle_printf_call (gimple_stmt_iterator *gsi, pointer_query &ptr_qry)\n {\n   init_target_to_host_charmap ();\n \n@@ -4519,7 +4515,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, range_query *query)\n       /* For non-bounded functions like sprintf, determine the size\n \t of the destination from the object or pointer passed to it\n \t as the first argument.  */\n-      dstsize = get_destination_size (dstptr);\n+      dstsize = get_destination_size (dstptr, ptr_qry);\n     }\n   else if (tree size = gimple_call_arg (info.callstmt, idx_dstsize))\n     {\n@@ -4566,7 +4562,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, range_query *query)\n \t     and use the greater of the two at level 1 and the smaller\n \t     of them at level 2.  */\n \t  value_range vr;\n-\t  query->range_of_expr (vr, size, info.callstmt);\n+\t  ptr_qry.rvals->range_of_expr (vr, size, info.callstmt);\n \n \t  if (!vr.undefined_p ())\n \t    {\n@@ -4683,7 +4679,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, range_query *query)\n      never set to true again).  */\n   res.posunder4k = posunder4k && dstptr;\n \n-  bool success = compute_format_length (info, &res, query);\n+  bool success = compute_format_length (info, &res, ptr_qry.rvals);\n   if (res.warned)\n     gimple_set_no_warning (info.callstmt, true);\n "}, {"sha": "df46023d8c58aebd06e1851aa4e8b6cff970dfa5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-25.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-25.c?ref=d02c41dd414dcc65a08bc82f312f7808b5d90028", "patch": "@@ -0,0 +1,76 @@\n+/* PR middle-end/97373 - missing warning on sprintf into allocated destination\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#include \"../range.h\"\n+\n+extern void* alloca (size_t);\n+extern void* malloc (size_t);\n+\n+extern int sprintf (char*, const char*, ...);\n+#define sprintf(d, ...) (sprintf (d, __VA_ARGS__), sink (d))\n+\n+void sink (void*, ...);\n+\n+void test_alloca_range (void)\n+{\n+  int n1_2 = UR (1, 2);\n+  int n5_9 = UR (5, 9);\n+\n+  char *d = (char*)alloca (n5_9);\n+\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n1_2;\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n1_2;\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n1_2;\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n1_2;\n+  sprintf (d, \"%i\", 12345);         // { dg-warning \"writing a terminating nul past the end of the destination\" }\n+\n+  d += n1_2;\n+  sprintf (d, \"%i\", 12345);         // { dg-warning \"'%i' directive writing 5 bytes into a region of size 4\" }\n+}\n+\n+\n+void test_malloc_range (void)\n+{\n+  int n2_3 = UR (2, 3);\n+  int n5_9 = UR (5, 9);\n+\n+  char *d = (char*)malloc (n5_9);\n+\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n2_3;\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n2_3;\n+  sprintf (d, \"%i\", 12345);         // { dg-warning \"writing a terminating nul past the end of the destination\" }\n+\n+  d += n2_3;\n+  sprintf (d, \"%i\", 12345);         // { dg-warning \"'%i' directive writing 5 bytes into a region of size 3\" }\n+}\n+\n+\n+void test_vla_range (void)\n+{\n+  int n3_4 = UR (3, 4);\n+  int n5_9 = UR (5, 9);\n+\n+  char vla[n5_9];\n+  char *d = vla;\n+\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n3_4;\n+  sprintf (d, \"%i\", 12345);\n+\n+  d += n3_4;\n+  sprintf (d, \"%i\", 12345);         // { dg-warning \"'%i' directive writing 5 bytes into a region of size 3\" }\n+}"}, {"sha": "741b47bca4a6571743bc7be4c8b28a3c9d54cb78", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 85, "deletions": 46, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=d02c41dd414dcc65a08bc82f312f7808b5d90028", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-strlen.h\"\n #include \"tree-hash-traits.h\"\n-#include \"tree-object-size.h\"\n #include \"builtins.h\"\n #include \"target.h\"\n #include \"diagnostic-core.h\"\n@@ -1667,7 +1666,8 @@ valid_builtin_call (gimple *stmt)\n    strinfo.  */\n \n static void\n-adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n+adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat,\n+\t\t  pointer_query &ptr_qry)\n {\n   tree vuse, callee, len;\n   struct laststmt_struct last = laststmt;\n@@ -1754,7 +1754,9 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n       /* Don't fold away an out of bounds access, as this defeats proper\n \t warnings.  */\n       tree dst = gimple_call_arg (last.stmt, 0);\n-      tree size = compute_objsize (dst, 0);\n+\n+      access_ref aref;\n+      tree size = compute_objsize (dst, 1, &aref, &ptr_qry);\n       if (size && tree_int_cst_lt (size, len))\n \treturn;\n     }\n@@ -1912,8 +1914,7 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n    to allow accesses across subobject boundaries.  */\n \n static void\n-maybe_warn_overflow (gimple *stmt, tree len,\n-\t\t     range_query *rvals = NULL,\n+maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n \t\t     strinfo *si = NULL, bool plus_one = false,\n \t\t     bool rawmem = false)\n {\n@@ -1939,14 +1940,17 @@ maybe_warn_overflow (gimple *stmt, tree len,\n   if (TREE_NO_WARNING (dest))\n     return;\n \n+  const int ostype = rawmem ? 0 : 1;\n+\n   /* Use maximum precision to avoid overflow in the addition below.\n      Make sure all operands have the same precision to keep wide_int\n      from ICE'ing.  */\n \n   access_ref aref;\n   /* The size of the destination region (which is smaller than\n      the destination object for stores at a non-zero offset).  */\n-  tree destsize = compute_objsize (dest, rawmem ? 0 : 1, &aref, rvals);\n+  tree destsize = compute_objsize (dest, ostype, &aref, &ptr_qry);\n+\n   if (!destsize)\n     {\n       aref.sizrng[0] = 0;\n@@ -1962,7 +1966,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n     return;\n \n   wide_int rng[2];\n-  if (!get_range (len, stmt, rng, rvals))\n+  if (!get_range (len, stmt, rng, ptr_qry.rvals))\n     return;\n \n   widest_int lenrng[2] =\n@@ -2091,10 +2095,10 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \n static inline void\n maybe_warn_overflow (gimple *stmt, unsigned HOST_WIDE_INT len,\n-\t\t     range_query *rvals = NULL, strinfo *si = NULL,\n+\t\t     pointer_query &ptr_qry, strinfo *si = NULL,\n \t\t     bool plus_one = false, bool rawmem = false)\n {\n-  maybe_warn_overflow (stmt, build_int_cst (size_type_node, len), rvals,\n+  maybe_warn_overflow (stmt, build_int_cst (size_type_node, len), ptr_qry,\n \t\t       si, plus_one, rawmem);\n }\n \n@@ -2394,7 +2398,7 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n \n static void\n handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       range_query *rvals)\n+\t\t       pointer_query &ptr_qry)\n {\n   int idx, didx;\n   tree src, dst, srclen, len, lhs, type, fn, oldlen;\n@@ -2420,18 +2424,18 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n     return;\n \n   if (olddsi != NULL)\n-    adjust_last_stmt (olddsi, stmt, false);\n+    adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n \n   srclen = NULL_TREE;\n   if (si != NULL)\n     srclen = get_string_length (si);\n   else if (idx < 0)\n     srclen = build_int_cst (size_type_node, ~idx);\n \n-  maybe_warn_overflow (stmt, srclen, rvals, olddsi, true);\n+  maybe_warn_overflow (stmt, srclen, ptr_qry, olddsi, true);\n \n   if (olddsi != NULL)\n-    adjust_last_stmt (olddsi, stmt, false);\n+    adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n \n   loc = gimple_location (stmt);\n   if (srclen == NULL_TREE)\n@@ -2776,7 +2780,8 @@ is_strlen_related_p (tree src, tree len)\n */\n \n bool\n-maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n+maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n+\t\t\t  pointer_query *ptr_qry /* = NULL */)\n {\n   gimple *stmt = gsi_stmt (gsi);\n   if (gimple_no_warning_p (stmt))\n@@ -3032,7 +3037,8 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n \t}\n     }\n \n-  if (tree dstsize = compute_objsize (dst, 1))\n+  access_ref aref;\n+  if (tree dstsize = compute_objsize (dst, 1, &aref, ptr_qry))\n     {\n       /* The source length is unknown.  Try to determine the destination\n \t size and see if it matches the specified bound.  If not, bail.\n@@ -3047,7 +3053,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n       /* Avoid warning for strncpy(a, b, N) calls where the following\n \t equalities hold:\n \t   N == sizeof a && N == sizeof b */\n-      if (tree srcsize = compute_objsize (src, 1))\n+      if (tree srcsize = compute_objsize (src, 1, &aref, ptr_qry))\n \tif (wi::to_wide (srcsize) == cntrange[1])\n \t  return false;\n \n@@ -3190,7 +3196,7 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n \n static void\n handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       range_query *rvals)\n+\t\t       pointer_query &ptr_qry)\n {\n   tree lhs, oldlen, newlen;\n   gimple *stmt = gsi_stmt (*gsi);\n@@ -3210,8 +3216,8 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   if (olddsi != NULL\n       && !integer_zerop (len))\n     {\n-      maybe_warn_overflow (stmt, len, rvals, olddsi, false, false);\n-      adjust_last_stmt (olddsi, stmt, false);\n+      maybe_warn_overflow (stmt, len, ptr_qry, olddsi, false, false);\n+      adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n     }\n \n   int idx = get_stridx (src);\n@@ -3288,7 +3294,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n     }\n \n   if (olddsi != NULL && TREE_CODE (len) == SSA_NAME)\n-    adjust_last_stmt (olddsi, stmt, false);\n+    adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n \n   if (didx == 0)\n     {\n@@ -3370,7 +3376,8 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n    is known.  */\n \n static void\n-handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n+\t\t       pointer_query &ptr_qry)\n {\n   int idx, didx;\n   tree srclen, args, type, fn, objsz, endptr;\n@@ -3598,7 +3605,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \t computed by transforming this strcpy into stpcpy.  */\n       if (srclen == NULL_TREE && dsi->dont_invalidate)\n \tdsi->stmt = stmt;\n-      adjust_last_stmt (dsi, stmt, true);\n+      adjust_last_stmt (dsi, stmt, true, ptr_qry);\n       if (srclen != NULL_TREE)\n \t{\n \t  laststmt.stmt = stmt;\n@@ -3655,13 +3662,13 @@ handle_alloc_call (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n static bool\n handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t\t       range_query *rvals)\n+\t\t       pointer_query &ptr_qry)\n {\n   gimple *memset_stmt = gsi_stmt (*gsi);\n   tree ptr = gimple_call_arg (memset_stmt, 0);\n   /* Set to the non-constant offset added to PTR.  */\n   wide_int offrng[2];\n-  int idx1 = get_stridx (ptr, offrng, rvals);\n+  int idx1 = get_stridx (ptr, offrng, ptr_qry.rvals);\n   if (idx1 <= 0)\n     return false;\n   strinfo *si1 = get_strinfo (idx1);\n@@ -3677,7 +3684,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n   tree memset_size = gimple_call_arg (memset_stmt, 2);\n \n   /* Check for overflow.  */\n-  maybe_warn_overflow (memset_stmt, memset_size, rvals, NULL, false, false);\n+  maybe_warn_overflow (memset_stmt, memset_size, ptr_qry, NULL, false, false);\n \n   /* Bail when there is no statement associated with the destination\n      (the statement may be null even when SI1->ALLOC is not).  */\n@@ -4691,14 +4698,16 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n \n static bool\n handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t      range_query *rvals)\n+\t      pointer_query &ptr_qry)\n {\n   int idx = -1;\n   strinfo *si = NULL;\n   gimple *stmt = gsi_stmt (*gsi);\n   tree ssaname = NULL_TREE, lhs = gimple_assign_lhs (stmt);\n   tree rhs = gimple_assign_rhs1 (stmt);\n \n+  range_query *const rvals = ptr_qry.rvals;\n+\n   /* The offset of the first byte in LHS modified by the store.  */\n   unsigned HOST_WIDE_INT offset = 0;\n \n@@ -4725,7 +4734,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t      unsigned lenrange[] = { UINT_MAX, 0, 0 };\n \t      if (count_nonzero_bytes (rhs, lenrange, &dummy, &dummy, &dummy,\n \t\t\t\t       rvals))\n-\t\tmaybe_warn_overflow (stmt, lenrange[2], rvals);\n+\t\tmaybe_warn_overflow (stmt, lenrange[2], ptr_qry);\n \n \t      return true;\n \t    }\n@@ -4765,7 +4774,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n       storing_nonzero_p = lenrange[1] > 0;\n       *zero_write = storing_all_zeros_p;\n \n-      maybe_warn_overflow (stmt, lenrange[2], rvals);\n+      maybe_warn_overflow (stmt, lenrange[2], ptr_qry);\n     }\n   else\n     {\n@@ -4883,7 +4892,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t    /* We're overwriting the nul terminator with a nonzero or\n \t       unknown character.  If the previous stmt was a memcpy,\n \t       its length may be decreased.  */\n-\t    adjust_last_stmt (si, stmt, false);\n+\t    adjust_last_stmt (si, stmt, false, ptr_qry);\n \t  si = unshare_strinfo (si);\n \t  if (storing_nonzero_p)\n \t    {\n@@ -5101,7 +5110,7 @@ is_char_type (tree type)\n \n static bool\n strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t\t\t\trange_query *rvals)\n+\t\t\t\tpointer_query &ptr_qry)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n@@ -5118,7 +5127,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n   if (!flag_optimize_strlen\n       || !strlen_optimize\n       || !valid_builtin_call (stmt))\n-    return !handle_printf_call (gsi, rvals);\n+    return !handle_printf_call (gsi, ptr_qry);\n \n   tree callee = gimple_call_fndecl (stmt);\n   switch (DECL_FUNCTION_CODE (callee))\n@@ -5134,7 +5143,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY:\n     case BUILT_IN_STPCPY_CHK:\n-      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi, rvals);\n+      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi, ptr_qry);\n       break;\n \n     case BUILT_IN_STRNCAT:\n@@ -5153,11 +5162,11 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMPCPY:\n     case BUILT_IN_MEMPCPY_CHK:\n-      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi, rvals);\n+      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi, ptr_qry);\n       break;\n     case BUILT_IN_STRCAT:\n     case BUILT_IN_STRCAT_CHK:\n-      handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi);\n+      handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi, ptr_qry);\n       break;\n     case BUILT_IN_ALLOCA:\n     case BUILT_IN_ALLOCA_WITH_ALIGN:\n@@ -5166,7 +5175,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n       handle_alloc_call (DECL_FUNCTION_CODE (callee), gsi);\n       break;\n     case BUILT_IN_MEMSET:\n-      if (handle_builtin_memset (gsi, zero_write, rvals))\n+      if (handle_builtin_memset (gsi, zero_write, ptr_qry))\n \treturn false;\n       break;\n     case BUILT_IN_MEMCMP:\n@@ -5175,11 +5184,11 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n       break;\n     case BUILT_IN_STRCMP:\n     case BUILT_IN_STRNCMP:\n-      if (handle_builtin_string_cmp (gsi, rvals))\n+      if (handle_builtin_string_cmp (gsi, ptr_qry.rvals))\n \treturn false;\n       break;\n     default:\n-      if (handle_printf_call (gsi, rvals))\n+      if (handle_printf_call (gsi, ptr_qry))\n \treturn false;\n       break;\n     }\n@@ -5337,7 +5346,7 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \n static bool\n check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n-\t\t\t range_query *rvals)\n+\t\t\t pointer_query &ptr_qry)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n@@ -5347,7 +5356,7 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \n   if (is_gimple_call (stmt))\n     {\n-      if (!strlen_check_and_optimize_call (gsi, &zero_write, rvals))\n+      if (!strlen_check_and_optimize_call (gsi, &zero_write, ptr_qry))\n \treturn false;\n     }\n   else if (!flag_optimize_strlen || !strlen_optimize)\n@@ -5372,7 +5381,7 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t}\n       else if (TREE_CODE (lhs) == SSA_NAME && INTEGRAL_TYPE_P (lhs_type))\n \t/* Handle assignment to a character.  */\n-\thandle_integral_assign (gsi, cleanup_eh, rvals);\n+\thandle_integral_assign (gsi, cleanup_eh, ptr_qry.rvals);\n       else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n \t{\n \t  tree type = TREE_TYPE (lhs);\n@@ -5403,7 +5412,7 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t  }\n \n \t  /* Handle a single or multibyte assignment.  */\n-\t  if (is_char_store && !handle_store (gsi, &zero_write, rvals))\n+\t  if (is_char_store && !handle_store (gsi, &zero_write, ptr_qry))\n \t    return false;\n \t}\n     }\n@@ -5477,8 +5486,10 @@ class strlen_dom_walker : public dom_walker\n   strlen_dom_walker (cdi_direction direction)\n     : dom_walker (direction),\n     evrp (false),\n+    ptr_qry (&evrp, &var_cache),\n+    var_cache (),\n     m_cleanup_cfg (false)\n-  {}\n+  { }\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n@@ -5487,6 +5498,11 @@ class strlen_dom_walker : public dom_walker\n      to track strlen results across integer variable assignments.  */\n   evrp_range_analyzer evrp;\n \n+  /* A pointer_query object and its cache to store information about\n+     pointers and their targets in.  */\n+  pointer_query ptr_qry;\n+  pointer_query::cache_type var_cache;\n+\n   /* Flag that will trigger TODO_cleanup_cfg to be returned in strlen\n      execute function.  */\n   bool m_cleanup_cfg;\n@@ -5580,7 +5596,10 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n \t can be used by printf argument processing.  */\n       evrp.record_ranges_from_stmt (stmt, false);\n \n-      if (check_and_optimize_stmt (&gsi, &cleanup_eh, &evrp))\n+      /* Reset search depth preformance counter.  */\n+      ptr_qry.depth = 0;\n+\n+      if (check_and_optimize_stmt (&gsi, &cleanup_eh, ptr_qry))\n \tgsi_next (&gsi);\n     }\n \n@@ -5648,6 +5667,29 @@ printf_strlen_execute (function *fun, bool warn_only)\n   strlen_dom_walker walker (CDI_DOMINATORS);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      unsigned nused = 0;\n+      unsigned nidxs = walker.ptr_qry.var_cache->indices.length ();\n+      for (unsigned i = 0; i != nidxs; ++i)\n+\tif (walker.ptr_qry.var_cache->indices[i])\n+\t  ++nused;\n+\n+      fprintf (dump_file, \"pointer_query counters\\n\"\n+\t       \"  index cache size:  %u\\n\"\n+\t       \"  utilization:       %u%%\\n\"\n+\t       \"  access cache size: %u\\n\"\n+\t       \"  hits:              %u\\n\"\n+\t       \"  misses:            %u\\n\"\n+\t       \"  failures:          %u\\n\"\n+\t       \"  max_depth:         %u\\n\",\n+\t       nidxs,\n+\t       (nused * 100) / nidxs,\n+\t       walker.ptr_qry.var_cache->access_refs.length (),\n+\t       walker.ptr_qry.hits, walker.ptr_qry.misses,\n+\t       walker.ptr_qry.failures, walker.ptr_qry.max_depth);\n+    }\n+\n   ssa_ver_to_stridx.release ();\n   strinfo_pool.release ();\n   if (decl_to_stridxlist_htab)\n@@ -5673,9 +5715,6 @@ printf_strlen_execute (function *fun, bool warn_only)\n       loop_optimizer_finalize ();\n     }\n \n-  /* Clean up object size info.  */\n-  fini_object_sizes ();\n-\n   return walker.m_cleanup_cfg ? TODO_cleanup_cfg : 0;\n }\n "}, {"sha": "e3435c187bf91c43a79469b075e61430e4f1f5d4", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d02c41dd414dcc65a08bc82f312f7808b5d90028/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=d02c41dd414dcc65a08bc82f312f7808b5d90028", "patch": "@@ -21,8 +21,11 @@\n #ifndef GCC_TREE_SSA_STRLEN_H\n #define GCC_TREE_SSA_STRLEN_H\n \n+class pointer_query;\n+\n extern bool is_strlen_related_p (tree, tree);\n-extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree);\n+extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree,\n+\t\t\t\t      pointer_query * = NULL);\n extern tree set_strlen_range (tree, wide_int, wide_int, tree = NULL_TREE);\n \n extern tree get_range (tree, gimple *, wide_int[2],\n@@ -33,6 +36,6 @@ extern void get_range_strlen_dynamic (tree, gimple *, c_strlen_data *,\n \t\t\t\t      class range_query *);\n \n /* APIs internal to strlen pass.  Defined in gimple-ssa-sprintf.c.  */\n-extern bool handle_printf_call (gimple_stmt_iterator *,  class range_query *);\n+extern bool handle_printf_call (gimple_stmt_iterator *, pointer_query &);\n \n #endif   // GCC_TREE_SSA_STRLEN_H"}]}