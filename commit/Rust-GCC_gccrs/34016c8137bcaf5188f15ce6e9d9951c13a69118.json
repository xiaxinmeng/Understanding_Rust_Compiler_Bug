{"sha": "34016c8137bcaf5188f15ce6e9d9951c13a69118", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwMTZjODEzN2JjYWY1MTg4ZjE1Y2U2ZTlkOTk1MWMxM2E2OTExOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-10-09T00:10:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-10-09T00:10:57Z"}, "message": "pt.c (resolve_overloaded_unification): New fn.\n\n\t* pt.c (resolve_overloaded_unification): New fn.\n\t(try_one_overload): Likewise.\n\t(unify): Don't fail on unknown type.\n\t(type_unification_real): Likewise.  Use resolve_overloaded_unification\n\tto handle an overloaded argument.\n\t(template_args_equal): Split out...\n\t(comp_template_args): From here.\n\t(determine_specialization): Also allow a template with more\n\tparms than were explicitly specified.\n\t* cp-tree.h: Add template_args_equal.\n\t* call.c (resolve_args): Remove TEMPLATE_ID_EXPR code.\n\nFrom-SVN: r22951", "tree": {"sha": "f6d0957dbeb49e219b9dadd34047d2207d444193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d0957dbeb49e219b9dadd34047d2207d444193"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34016c8137bcaf5188f15ce6e9d9951c13a69118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34016c8137bcaf5188f15ce6e9d9951c13a69118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34016c8137bcaf5188f15ce6e9d9951c13a69118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34016c8137bcaf5188f15ce6e9d9951c13a69118/comments", "author": null, "committer": null, "parents": [{"sha": "85ee60379d3900cc3fe1a92f8c1b92b380ab8296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ee60379d3900cc3fe1a92f8c1b92b380ab8296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ee60379d3900cc3fe1a92f8c1b92b380ab8296"}], "stats": {"total": 296, "additions": 217, "deletions": 79}, "files": [{"sha": "7ef415c822e7ef6b7d7380576639ea9438ccf6cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=34016c8137bcaf5188f15ce6e9d9951c13a69118", "patch": "@@ -1,3 +1,17 @@\n+1998-10-08  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (resolve_overloaded_unification): New fn.\n+\t(try_one_overload): Likewise.\n+\t(unify): Don't fail on unknown type.\n+\t(type_unification_real): Likewise.  Use resolve_overloaded_unification\n+\tto handle an overloaded argument.\n+\t(template_args_equal): Split out...\n+\t(comp_template_args): From here.\n+\t(determine_specialization): Also allow a template with more\n+\tparms than were explicitly specified.\n+\t* cp-tree.h: Add template_args_equal.\n+\t* call.c (resolve_args): Remove TEMPLATE_ID_EXPR code.\n+\n Thu Oct  8 15:58:30 1998  Anthony Green  <green@cygnus.com>\n \n \t* semantics.c (finish_asm_stmt): Revert my 1998-09-28"}, {"sha": "f431885ab37348a2d936691a59a5a547a537a890", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=34016c8137bcaf5188f15ce6e9d9951c13a69118", "patch": "@@ -2255,26 +2255,6 @@ resolve_args (args)\n \t}\n       else if (TREE_CODE (TREE_VALUE (t)) == OFFSET_REF)\n \tTREE_VALUE (t) = resolve_offset_ref (TREE_VALUE (t));\n-      else if (TREE_CODE (TREE_VALUE (t)) == TEMPLATE_ID_EXPR)\n-\t{\n-\t  tree targs;\n-\t  tree r;\n-\n-\t  r = determine_specialization (TREE_VALUE (t), NULL_TREE,\n-\t\t\t\t\t&targs, \n-\t\t\t\t\t/*need_member_template=*/0,\n-\t\t\t\t\t/*complain=*/0);\n-\n-\t  /* If we figured out what was being specialized, use it.\n-\t     Otherwise, the function being called may resolve the\n-\t     choice of specialization, so we don't issue any error\n-\t     messages here.  */\n-\t  if (r)\n-\t    {\n-\t      r = instantiate_template (r, targs);\n-\t      TREE_VALUE (t) = r;\n-\t    }\n-\t}\n     }\n   return args;\n }"}, {"sha": "15845572e463a90782d1a2dd4edcd8335d08be99", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=34016c8137bcaf5188f15ce6e9d9951c13a69118", "patch": "@@ -2861,6 +2861,7 @@ extern void pop_tinst_level\t\t\tPROTO((void));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n+extern int template_parms_equal                 PROTO((tree, tree));\n extern int comp_template_parms                  PROTO((tree, tree));\n extern int decl_template_parm_p\t\t\tPROTO((tree));\n extern int template_class_depth                 PROTO((tree));"}, {"sha": "478c0b937e2b0f67582a09a64f1b50c54f18d7e4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 202, "deletions": 59, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34016c8137bcaf5188f15ce6e9d9951c13a69118/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=34016c8137bcaf5188f15ce6e9d9951c13a69118", "patch": "@@ -76,6 +76,12 @@ static tree saved_trees;\n #define UNIFY_ALLOW_LESS_CV_QUAL 2\n #define UNIFY_ALLOW_DERIVED 4\n \n+static int unify PROTO((tree, tree, tree, tree, int, int*));\n+static int resolve_overloaded_unification PROTO((tree, tree, tree, tree,\n+\t\t\t\t\t\t unification_kind_t, int,\n+\t\t\t\t\t\t int*));\n+static int try_one_overload PROTO((tree, tree, tree, tree,\n+\t\t\t\t   unification_kind_t, int, int*));\n static int unify PROTO((tree, tree, tree, tree, int, int*));\n static void add_pending_template PROTO((tree));\n static int push_tinst_level PROTO((tree));\n@@ -905,7 +911,6 @@ determine_specialization (template_id, decl, targs_out,\n   tree fns, targs_in;\n   tree templates = NULL_TREE;\n   tree fn;\n-  int i;\n \n   *targs_out = NULL_TREE;\n \n@@ -949,18 +954,14 @@ determine_specialization (template_id, decl, targs_out,\n \n       if (decl == NULL_TREE)\n \t{\n-\t  tree targs = make_scratch_vec (DECL_NTPARMS (tmpl));\n-\n-\t  /* We allow incomplete unification here, because we are going to\n-\t     check all the functions. */\n-\t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n-\t\t\t\ttargs,\n-\t\t\t\tNULL_TREE,\n-\t\t\t\tNULL_TREE,  \n-\t\t\t\ttargs_in,\n-\t\t\t\tDEDUCE_EXACT, 1);\n-      \n-\t  if (i == 0) \n+\t  /* Unify against ourselves to make sure that the args we have\n+\t     make sense and there aren't any undeducible parms.  It's OK if\n+\t     not all the parms are specified; they might be deduced\n+\t     later. */\n+\t  tree targs = get_bindings_overload (tmpl, DECL_RESULT (tmpl),\n+\t\t\t\t\t      targs_in);\n+\n+\t  if (targs) \n \t    /* Unification was successful.  */\n \t    templates = scratch_tree_cons (targs, tmpl, templates);\n \t}\n@@ -1005,7 +1006,8 @@ determine_specialization (template_id, decl, targs_out,\n \t}\n       return NULL_TREE;\n     }\n-  else if (TREE_CHAIN (templates) != NULL_TREE) \n+  else if (TREE_CHAIN (templates) != NULL_TREE\n+\t   || uses_template_parms (TREE_PURPOSE (templates)))\n     {\n     ambiguous:\n       if (complain)\n@@ -3045,7 +3047,26 @@ coerce_template_parms (parms, args, in_decl,\n   return new_inner_args;\n }\n \n-/* Renturns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n+/* Returns 1 if template args OT and NT are equivalent.  */\n+\n+int\n+template_args_equal (ot, nt)\n+     tree ot, nt;\n+{\n+  if (nt == ot)\n+    return 1;\n+  if (TREE_CODE (nt) != TREE_CODE (ot))\n+    return 0;\n+  if (TREE_CODE (nt) == TREE_VEC)\n+    /* For member templates */\n+    return comp_template_args (ot, nt);\n+  else if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n+    return comptypes (ot, nt, 1);\n+  else\n+    return (cp_tree_equal (ot, nt) > 0);\n+}\n+\n+/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n    of template arguments.  Returns 0 otherwise.  */\n \n int\n@@ -3062,26 +3083,8 @@ comp_template_args (oldargs, newargs)\n       tree nt = TREE_VEC_ELT (newargs, i);\n       tree ot = TREE_VEC_ELT (oldargs, i);\n \n-      if (nt == ot)\n-\tcontinue;\n-      else if (!nt || !ot)\n+      if (! template_args_equal (ot, nt))\n \treturn 0;\n-      else if (TREE_CODE (nt) != TREE_CODE (ot))\n-\treturn 0;\n-      else if (TREE_CODE (nt) == TREE_VEC)\n-        {\n-          /* For member templates */\n-\t  if (comp_template_args (ot, nt))\n-\t    continue;\n-        }\n-      else if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n-\t{\n-\t  if (comptypes (ot, nt, 1))\n-\t    continue;\n-\t}\n-      else if (cp_tree_equal (ot, nt) > 0)\n-\tcontinue;\n-      return 0;\n     }\n   return 1;\n }\n@@ -6730,7 +6733,9 @@ type_unification_real (tparms, targs, parms, args, subr,\n       if (arg == error_mark_node)\n \treturn 1;\n       if (arg == unknown_type_node)\n-\treturn 1;\n+\t/* We can't deduce anything from this, but we might get all the\n+\t   template args from other function args.  */\n+\tcontinue;\n \n       /* Conversions will be performed on a function argument that\n \t corresponds with a function parameter that contains only\n@@ -6771,28 +6776,19 @@ type_unification_real (tparms, targs, parms, args, subr,\n       if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n \t{\n \t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n-\t  if (TREE_CODE (arg) == OVERLOAD\n-\t      && TREE_CODE (OVL_FUNCTION (arg)) == TEMPLATE_DECL)\n+\t  if (type_unknown_p (arg))\n \t    {\n-\t      tree targs;\n-\t      tree arg_type;\n-\t      int r;\n-\n-\t      /* Have to back unify here */\n-\t      arg = OVL_FUNCTION (arg);\n-\t      targs = make_scratch_vec (DECL_NTPARMS (arg));\n-\t      arg_type = TREE_TYPE (arg);\n-\t      maybe_adjust_types_for_deduction (strict, &parm, &arg_type);\n-\t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);\n-\t      arg_type = scratch_tree_cons (NULL_TREE, arg_type, NULL_TREE);\n-\t      r = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n-\t\t\t\t    targs, arg_type, parm, NULL_TREE,\n-\t\t\t\t    DEDUCE_EXACT, allow_incomplete);\n-\t      if (r)\n-\t\t/* If the back-unification failed, just bail out.  */\n-\t\treturn r;\n-\t      else \n-\t\tcontinue;\n+\t      /* [temp.deduct.type] A template-argument can be deduced from\n+\t\t a pointer to function or pointer to member function\n+\t\t argument if the set of overloaded functions does not\n+\t\t contain function templates and at most one of a set of\n+\t\t overloaded functions provides a unique match.  */\n+\n+\t      if (resolve_overloaded_unification\n+\t\t  (tparms, targs, parm, arg, strict, sub_strict, explicit_mask)\n+\t\t  != 0)\n+\t\treturn 1;\n+\t      continue;\n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n@@ -6829,6 +6825,152 @@ type_unification_real (tparms, targs, parms, args, subr,\n   return 0;\n }\n \n+/* Subroutine of type_unification_real.  Args are like the variables at the\n+   call site.  ARG is an overloaded function (or template-id); we try\n+   deducing template args from each of the overloads, and if only one\n+   succeeds, we go with that.  Modifies TARGS and returns 0 on success.  */\n+\n+static int\n+resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n+\t\t\t\tsub_strict, explicit_mask)\n+     tree tparms, targs, parm, arg;\n+     unification_kind_t strict;\n+     int sub_strict;\n+     int* explicit_mask;\n+{\n+  tree tempargs = copy_node (targs);\n+  int good = 0;\n+\n+  if (TREE_CODE (arg) == ADDR_EXPR)\n+    arg = TREE_OPERAND (arg, 0);\n+  if (TREE_CODE (arg) == TEMPLATE_ID_EXPR)\n+    {\n+      /* If we got some explicit template args, we need to plug them into\n+\t the affected templates before we try to unify, in case the\n+\t explicit args will completely resolve the templates in question.  */\n+\n+      tree expl_subargs = TREE_OPERAND (arg, 1);\n+      arg = TREE_OPERAND (arg, 0);\n+\n+      for (; arg; arg = OVL_NEXT (arg))\n+\t{\n+\t  tree fn = OVL_CURRENT (arg);\n+\t  tree subargs, elem;\n+\n+\t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n+\t    continue;\n+\n+\t  subargs = get_bindings_overload (fn, DECL_RESULT (fn), expl_subargs);\n+\t  if (subargs)\n+\t    {\n+\t      elem = tsubst (TREE_TYPE (fn), subargs, NULL_TREE);\n+\t      good += try_one_overload (tparms, tempargs, parm, elem,\n+\t\t\t\t\tstrict, sub_strict, explicit_mask);\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (arg) == OVERLOAD)\n+    {\n+      for (; arg; arg = OVL_NEXT (arg))\n+\tgood += try_one_overload (tparms, tempargs, parm,\n+\t\t\t\t  TREE_TYPE (OVL_CURRENT (arg)),\n+\t\t\t\t  strict, sub_strict, explicit_mask);\n+    }\n+  else\n+    my_friendly_abort (981006);\n+\n+  /* [temp.deduct.type] A template-argument can be deduced from a pointer\n+     to function or pointer to member function argument if the set of\n+     overloaded functions does not contain function templates and at most\n+     one of a set of overloaded functions provides a unique match.\n+\n+     So if we found multiple possibilities, we return success but don't\n+     deduce anything.  */\n+\n+  if (good == 1)\n+    {\n+      int i = TREE_VEC_LENGTH (targs);\n+      for (; i--; )\n+\tif (TREE_VEC_ELT (tempargs, i))\n+\t  TREE_VEC_ELT (targs, i) = TREE_VEC_ELT (tempargs, i);\n+    }\n+  if (good)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Subroutine of resolve_overloaded_unification; does deduction for a single\n+   overload.  Fills TARGS with any deduced arguments, or error_mark_node if\n+   different overloads deduce different arguments for a given parm.\n+   Returns 1 on success.  */\n+\n+static int\n+try_one_overload (tparms, targs, parm, arg, strict,\n+\t\t  sub_strict, explicit_mask)\n+     tree tparms, targs, parm, arg;\n+     unification_kind_t strict;\n+     int sub_strict;\n+     int* explicit_mask;\n+{\n+  int nargs;\n+  tree tempargs;\n+  int i;\n+\n+  /* [temp.deduct.type] A template-argument can be deduced from a pointer\n+     to function or pointer to member function argument if the set of\n+     overloaded functions does not contain function templates and at most\n+     one of a set of overloaded functions provides a unique match.\n+\n+     So if this is a template, just return success.  */\n+\n+  if (uses_template_parms (arg))\n+    return 1;\n+\n+  maybe_adjust_types_for_deduction (strict, &parm, &arg);\n+\n+  /* We don't copy orig_targs for this because if we have already deduced\n+     some template args from previous args, unify would complain when we\n+     try to deduce a template parameter for the same argument, even though\n+     there isn't really a conflict.  */\n+  nargs = TREE_VEC_LENGTH (targs);\n+  tempargs = make_scratch_vec (nargs);\n+\n+  if (unify (tparms, tempargs, parm, arg, sub_strict, explicit_mask) != 0)\n+    return 0;\n+\n+  /* First make sure we didn't deduce anything that conflicts with\n+     previously deduced/specified args.  */\n+  for (i = nargs; i--; )\n+    {\n+      tree elt = TREE_VEC_ELT (tempargs, i);\n+      tree oldelt = TREE_VEC_ELT (targs, i);\n+\n+      if (elt == NULL_TREE)\n+\tcontinue;\n+      else if (uses_template_parms (elt))\n+\t{\n+\t  /* Since we're unifying against ourselves, we will fill in template\n+\t     args used in the function parm list with our own template parms.\n+\t     Discard them.  */\n+\t  TREE_VEC_ELT (tempargs, i) = NULL_TREE;\n+\t  continue;\n+\t}\n+      else if (oldelt && ! template_args_equal (oldelt, elt))\n+\treturn 0;\n+    }\n+\n+  for (i = nargs; i--; )\n+    {\n+      tree elt = TREE_VEC_ELT (tempargs, i);\n+\n+      if (elt)\n+\tTREE_VEC_ELT (targs, i) = elt;\n+    }\n+\n+  return 1;\n+}\n+\n /* Returns the level of DECL, which declares a template parameter.  */\n \n int\n@@ -6903,7 +7045,10 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n   if (arg == error_mark_node)\n     return 1;\n   if (arg == unknown_type_node)\n-    return 1;\n+    /* We can't deduce anything from this, but we might get all the\n+       template args from other function args.  */\n+    return 0;\n+\n   /* If PARM uses template parameters, then we can't bail out here,\n      even in ARG == PARM, since we won't record unifications for the\n      template parameters.  We might need them if we're trying to\n@@ -8496,5 +8641,3 @@ set_mangled_name_for_template_decl (decl)\n   /* Restore the previously active namespace.  */\n   current_namespace = saved_namespace;\n }\n-\n-"}]}