{"sha": "2182274f510c180ea92a4f826a0f6cf5f1f55b66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE4MjI3NGY1MTBjMTgwZWE5MmE0ZjgyNmEwZjZjZjVmMWY1NWI2Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-14T13:08:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-14T15:14:01Z"}, "message": "tree-optimization/98674 - improve dependence analysis\n\nThis improves dependence analysis on refs that access the same\narray but with different typed but same sized accesses.  That's\nobviously safe for the case of types that cannot have any\naccess function based off them.  For the testcase this is\nsigned short vs. unsigned short.\n\n2021-01-14  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98674\n\t* tree-data-ref.c (base_supports_access_fn_components_p): New.\n\t(initialize_data_dependence_relation): For two bases without\n\tpossible access fns resort to type size equality when determining\n\tshape compatibility.\n\n\t* gcc.dg/vect/pr98674.c: New testcase.", "tree": {"sha": "9f4b751f8f09cefcbaea037fc522ef5f1fedd89d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f4b751f8f09cefcbaea037fc522ef5f1fedd89d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2182274f510c180ea92a4f826a0f6cf5f1f55b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2182274f510c180ea92a4f826a0f6cf5f1f55b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2182274f510c180ea92a4f826a0f6cf5f1f55b66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2182274f510c180ea92a4f826a0f6cf5f1f55b66/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a512079ef40e442c1269ea1cc55f18790ba68449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a512079ef40e442c1269ea1cc55f18790ba68449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a512079ef40e442c1269ea1cc55f18790ba68449"}], "stats": {"total": 42, "additions": 40, "deletions": 2}, "files": [{"sha": "0f1b6cb060bec8c31f6c1f15023acb425a06d8c5", "filename": "gcc/testsuite/gcc.dg/vect/pr98674.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2182274f510c180ea92a4f826a0f6cf5f1f55b66/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr98674.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2182274f510c180ea92a4f826a0f6cf5f1f55b66/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr98674.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr98674.c?ref=2182274f510c180ea92a4f826a0f6cf5f1f55b66", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-msse2\" { target sse2 } } */\n+\n+void swap(short *p, int cnt)\n+{\n+  while (cnt-- > 0)\n+    {\n+      *p = ((*p << 8) & 0xFF00) | ((*p >> 8) & 0x00FF);\n+      ++p;\n+    }\n+}\n+\n+/* Dependence analysis should not fail.  */\n+/* { dg-final { scan-tree-dump \"dependence distance == 0\" \"vect\" } } */\n+/* On x86 with SSE2 we can vectorize this with psllw/psrlw.  */\n+/* { dg-final { scan-tree-dump \"loop vectorized\" \"vect\" { target sse2 } } } */"}, {"sha": "65fe6d5da91e996fe8ebbb7d76bfa41f8be6ae47", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2182274f510c180ea92a4f826a0f6cf5f1f55b66/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2182274f510c180ea92a4f826a0f6cf5f1f55b66/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=2182274f510c180ea92a4f826a0f6cf5f1f55b66", "patch": "@@ -1291,6 +1291,23 @@ access_fn_component_p (tree op)\n     }\n }\n \n+/* Returns whether BASE can have a access_fn_component_p with BASE\n+   as base.  */\n+\n+static bool\n+base_supports_access_fn_components_p (tree base)\n+{\n+  switch (TREE_CODE (TREE_TYPE (base)))\n+    {\n+    case COMPLEX_TYPE:\n+    case ARRAY_TYPE:\n+    case RECORD_TYPE:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Determines the base object and the list of indices of memory reference\n    DR, analyzed in LOOP and instantiated before NEST.  */\n \n@@ -3272,8 +3289,13 @@ initialize_data_dependence_relation (struct data_reference *a,\n \t\t      && full_seq.start_b + full_seq.length == num_dimensions_b\n \t\t      && DR_UNCONSTRAINED_BASE (a) == DR_UNCONSTRAINED_BASE (b)\n \t\t      && operand_equal_p (base_a, base_b, OEP_ADDRESS_OF)\n-\t\t      && types_compatible_p (TREE_TYPE (base_a),\n-\t\t\t\t\t     TREE_TYPE (base_b))\n+\t\t      && (types_compatible_p (TREE_TYPE (base_a),\n+\t\t\t\t\t      TREE_TYPE (base_b))\n+\t\t\t  || (!base_supports_access_fn_components_p (base_a)\n+\t\t\t      && !base_supports_access_fn_components_p (base_b)\n+\t\t\t      && operand_equal_p\n+\t\t\t\t   (TYPE_SIZE (TREE_TYPE (base_a)),\n+\t\t\t\t    TYPE_SIZE (TREE_TYPE (base_b)), 0)))\n \t\t      && (!loop_nest.exists ()\n \t\t\t  || (object_address_invariant_in_loop_p\n \t\t\t      (loop_nest[0], base_a))));"}]}