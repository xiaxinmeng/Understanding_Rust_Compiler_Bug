{"sha": "494bdadf28d0fb3505ff8dce5afa587e0ff46544", "node_id": "C_kwDOANBUbNoAKDQ5NGJkYWRmMjhkMGZiMzUwNWZmOGRjZTVhZmE1ODdlMGZmNDY1NDQ", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-11T17:14:45Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-11T17:14:45Z"}, "message": "Enable pure-const discovery in modref.\n\nWe newly can handle some extra cases, for example:\n\nstruct a {int a,b,c;};\n__attribute__ ((noinline))\nint init (struct a *a)\n{\n  a->a=1;\n  a->b=2;\n  a->c=3;\n}\nint const_fn ()\n{\n  struct a a;\n  init (&a);\n  return a.a + a.b + a.c;\n}\n\nHere pure/const stops on the fact that const_fn calls non-const init, while\nmodref knows that the memory it initializes is local to const_fn.\n\nI ended up reordering passes so early modref is done after early pure-const\nmostly to avoid need to change testsuite which greps for const functions\nbeing detects in pure-const.  Stil some testuiste compensation is needed.\n\ngcc/ChangeLog:\n\n2021-11-11  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (analyze_function): Do pure/const discovery, return\n\ttrue on success.\n\t(pass_modref::execute): If pure/const is discovered fixup cfg.\n\t(ignore_edge): Do not ignore pure/const edges.\n\t(modref_propagate_in_scc): Do pure/const discovery, return true if\n\tcdtor was promoted pure/const.\n\t(pass_ipa_modref::execute): If needed remove unreachable functions.\n\t* ipa-pure-const.c (warn_function_noreturn): Fix whitespace.\n\t(warn_function_cold): Likewise.\n\t(skip_function_for_local_pure_const): Move earlier.\n\t(ipa_make_function_const): Break out from ...\n\t(ipa_make_function_pure): Break out from ...\n\t(propagate_pure_const): ... here.\n\t(pass_local_pure_const::execute): Use it.\n\t* ipa-utils.h (ipa_make_function_const): Declare.\n\t(ipa_make_function_pure): Declare.\n\t* passes.def: Move early modref after pure-const.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-11  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* c-c++-common/tm/inline-asm.c: Disable pure-const.\n\t* g++.dg/ipa/modref-1.C: Update template.\n\t* gcc.dg/tree-ssa/modref-11.c: Disable pure-const.\n\t* gcc.dg/tree-ssa/modref-14.c: New test.\n\t* gcc.dg/tree-ssa/modref-8.c: Do not optimize sibling calls.\n\t* gfortran.dg/do_subscript_3.f90: Add -O0.", "tree": {"sha": "9924cba8140a7768bc2b1a4e4997f1d1eec9fa07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9924cba8140a7768bc2b1a4e4997f1d1eec9fa07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/494bdadf28d0fb3505ff8dce5afa587e0ff46544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494bdadf28d0fb3505ff8dce5afa587e0ff46544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494bdadf28d0fb3505ff8dce5afa587e0ff46544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494bdadf28d0fb3505ff8dce5afa587e0ff46544/comments", "author": null, "committer": null, "parents": [{"sha": "abdff441a07f55d16e3d0e5ced3123c83d210a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdff441a07f55d16e3d0e5ced3123c83d210a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abdff441a07f55d16e3d0e5ced3123c83d210a0a"}], "stats": {"total": 349, "additions": 204, "deletions": 145}, "files": [{"sha": "72006251f29fb6b1818332c0e26723f6fffe9bcc", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 69, "deletions": 16, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -2603,11 +2603,13 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n }\n \n /* Analyze function F.  IPA indicates whether we're running in local mode\n-   (false) or the IPA mode (true).  */\n+   (false) or the IPA mode (true).\n+   Return true if fixup cfg is needed after the pass.  */\n \n-static void\n+static bool\n analyze_function (function *f, bool ipa)\n {\n+  bool fixup_cfg = false;\n   if (dump_file)\n     fprintf (dump_file, \"modref analyzing '%s' (ipa=%i)%s%s\\n\",\n \t     function_name (f), ipa,\n@@ -2617,7 +2619,7 @@ analyze_function (function *f, bool ipa)\n   /* Don't analyze this function if it's compiled with -fno-strict-aliasing.  */\n   if (!flag_ipa_modref\n       || lookup_attribute (\"noipa\", DECL_ATTRIBUTES (current_function_decl)))\n-    return;\n+    return false;\n \n   /* Compute no-LTO summaries when local optimization is going to happen.  */\n   bool nolto = (!ipa || ((!flag_lto || flag_fat_lto_objects) && !in_lto_p)\n@@ -2774,12 +2776,32 @@ analyze_function (function *f, bool ipa)\n \t      if (!summary->useful_p (ecf_flags, false))\n \t\t{\n \t\t  remove_summary (lto, nolto, ipa);\n-\t\t  return;\n+\t\t  return false;\n \t\t}\n \t    }\n \t  first = false;\n \t}\n     }\n+  if (summary && !summary->global_memory_written_p () && !summary->side_effects\n+      && !finite_function_p ())\n+    summary->side_effects = true;\n+  if (summary_lto && !summary_lto->side_effects && !finite_function_p ())\n+    summary_lto->side_effects = true;\n+\n+  if (!ipa && flag_ipa_pure_const)\n+    {\n+      if (!summary->stores->every_base && !summary->stores->bases)\n+\t{\n+\t  if (!summary->loads->every_base && !summary->loads->bases)\n+\t    fixup_cfg = ipa_make_function_const\n+\t\t   (cgraph_node::get (current_function_decl),\n+\t\t    summary->side_effects, true);\n+\t  else\n+\t    fixup_cfg = ipa_make_function_pure\n+\t\t   (cgraph_node::get (current_function_decl),\n+\t\t    summary->side_effects, true);\n+\t}\n+    }\n   if (summary && !summary->useful_p (ecf_flags))\n     {\n       if (!ipa)\n@@ -2793,11 +2815,6 @@ analyze_function (function *f, bool ipa)\n       summaries_lto->remove (fnode);\n       summary_lto = NULL;\n     }\n-  if (summary && !summary->global_memory_written_p () && !summary->side_effects\n-      && !finite_function_p ())\n-    summary->side_effects = true;\n-  if (summary_lto && !summary_lto->side_effects && !finite_function_p ())\n-    summary_lto->side_effects = true;\n \n   if (ipa && !summary && !summary_lto)\n     remove_modref_edge_summaries (fnode);\n@@ -2907,6 +2924,7 @@ analyze_function (function *f, bool ipa)\n \t    }\n \t}\n     }\n+  return fixup_cfg;\n }\n \n /* Callback for generate_summary.  */\n@@ -3714,7 +3732,8 @@ class pass_ipa_modref : public ipa_opt_pass_d\n \n unsigned int pass_modref::execute (function *f)\n {\n-  analyze_function (f, false);\n+  if (analyze_function (f, false))\n+    return execute_fixup_cfg ();\n   return 0;\n }\n \n@@ -3749,9 +3768,7 @@ ignore_edge (struct cgraph_edge *e)\n \n   return (avail <= AVAIL_INTERPOSABLE\n \t  || ((!optimization_summaries || !optimization_summaries->get (callee))\n-\t      && (!summaries_lto || !summaries_lto->get (callee)))\n-\t  || flags_from_decl_or_type (e->callee->decl)\n-\t     & (ECF_CONST | ECF_NOVOPS));\n+\t      && (!summaries_lto || !summaries_lto->get (callee))));\n }\n \n /* Compute parm_map for CALLEE_EDGE.  */\n@@ -4130,7 +4147,7 @@ remove_useless_summaries (cgraph_node *node,\n /* Perform iterative dataflow on SCC component starting in COMPONENT_NODE\n    and propagate loads/stores.  */\n \n-static void\n+static bool\n modref_propagate_in_scc (cgraph_node *component_node)\n {\n   bool changed = true;\n@@ -4352,6 +4369,38 @@ modref_propagate_in_scc (cgraph_node *component_node)\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Propagation finished in %i iterations\\n\", iteration);\n+  bool pureconst = false;\n+  for (struct cgraph_node *cur = component_node; cur;\n+       cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n+    if (!cur->inlined_to && opt_for_fn (cur->decl, flag_ipa_pure_const))\n+      {\n+\tmodref_summary *summary = optimization_summaries\n+\t\t\t\t  ? optimization_summaries->get (cur)\n+\t\t\t\t  : NULL;\n+\tmodref_summary_lto *summary_lto = summaries_lto\n+\t\t\t\t\t  ? summaries_lto->get (cur)\n+\t\t\t\t\t  : NULL;\n+\tif (summary && !summary->stores->every_base && !summary->stores->bases)\n+\t  {\n+\t    if (!summary->loads->every_base && !summary->loads->bases)\n+\t      pureconst |= ipa_make_function_const\n+\t\t     (cur, summary->side_effects, false);\n+\t    else\n+\t      pureconst |= ipa_make_function_pure\n+\t\t     (cur, summary->side_effects, false);\n+\t  }\n+\tif (summary_lto && !summary_lto->stores->every_base\n+\t    && !summary_lto->stores->bases)\n+\t  {\n+\t    if (!summary_lto->loads->every_base && !summary_lto->loads->bases)\n+\t      pureconst |= ipa_make_function_const\n+\t\t     (cur, summary_lto->side_effects, false);\n+\t    else\n+\t      pureconst |= ipa_make_function_pure\n+\t\t     (cur, summary_lto->side_effects, false);\n+\t  }\n+     }\n+  return pureconst;\n }\n \n /* Dump results of propagation in SCC rooted in COMPONENT_NODE.  */\n@@ -4831,6 +4880,7 @@ pass_ipa_modref::execute (function *)\n {\n   if (!summaries && !summaries_lto)\n     return 0;\n+  bool pureconst = false;\n \n   if (optimization_summaries)\n     ggc_delete (optimization_summaries);\n@@ -4853,7 +4903,7 @@ pass_ipa_modref::execute (function *)\n       if (dump_file)\n \tfprintf (dump_file, \"\\n\\nStart of SCC component\\n\");\n \n-      modref_propagate_in_scc (component_node);\n+      pureconst |= modref_propagate_in_scc (component_node);\n       modref_propagate_flags_in_scc (component_node);\n       if (dump_file)\n \tmodref_propagate_dump_scc (component_node);\n@@ -4869,7 +4919,10 @@ pass_ipa_modref::execute (function *)\n   fnspec_summaries = NULL;\n   delete escape_summaries;\n   escape_summaries = NULL;\n-  return 0;\n+\n+  /* If we posibly made constructors const/pure we may need to remove\n+     them.  */\n+  return pureconst ? TODO_remove_functions : 0;\n }\n \n /* Summaries must stay alive until end of compilation.  */"}, {"sha": "550bdeded1609299c1dbc42ba48aeb1600ee37bf", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 110, "deletions": 123, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -275,7 +275,7 @@ warn_function_noreturn (tree decl)\n   static hash_set<tree> *warned_about;\n   if (!lang_hooks.missing_noreturn_ok_p (decl)\n       && targetm.warn_func_return (decl))\n-    warned_about \n+    warned_about\n       = suggest_attribute (OPT_Wsuggest_attribute_noreturn, original_decl,\n \t\t\t   true, warned_about, \"noreturn\");\n }\n@@ -286,7 +286,7 @@ warn_function_cold (tree decl)\n   tree original_decl = decl;\n \n   static hash_set<tree> *warned_about;\n-  warned_about \n+  warned_about\n     = suggest_attribute (OPT_Wsuggest_attribute_cold, original_decl,\n \t\t\t true, warned_about, \"cold\");\n }\n@@ -1428,6 +1428,105 @@ ignore_edge_for_pure_const (struct cgraph_edge *e)\n \t\t\t  flag_ipa_pure_const));\n }\n \n+/* Return true if function should be skipped for local pure const analysis.  */\n+\n+static bool\n+skip_function_for_local_pure_const (struct cgraph_node *node)\n+{\n+  /* Because we do not schedule pass_fixup_cfg over whole program after early\n+     optimizations we must not promote functions that are called by already\n+     processed functions.  */\n+\n+  if (function_called_by_processed_nodes_p ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function called in recursive cycle; ignoring\\n\");\n+      return true;\n+    }\n+  /* Save some work and do not analyze functions which are interposable and\n+     do not have any non-interposable aliases.  */\n+  if (node->get_availability () <= AVAIL_INTERPOSABLE\n+      && !flag_lto\n+      && !node->has_aliases_p ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Function is interposable; not analyzing.\\n\");\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Make function const and output warning.  If LOCAL is true,\n+   return true if anything changed.  Otherwise return true if\n+   we may have introduced removale ctors.  */\n+\n+bool\n+ipa_make_function_const (struct cgraph_node *node, bool looping, bool local)\n+{\n+  bool cdtor = false;\n+\n+  if (TREE_READONLY (node->decl)\n+      && (looping || !DECL_LOOPING_CONST_OR_PURE_P (node->decl)))\n+    return false;\n+  warn_function_const (node->decl, !looping);\n+  if (local && skip_function_for_local_pure_const (node))\n+    return false;\n+  if (dump_file)\n+    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n+\t     looping ? \"looping \" : \"\",\n+\t     node->dump_name ());\n+  if (!local)\n+    cdtor = node->call_for_symbol_and_aliases (cdtor_p, NULL, true);\n+  if (node->set_const_flag (true, looping))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Declaration updated to be %sconst: %s\\n\",\n+\t\t looping ? \"looping \" : \"\",\n+\t\t node->dump_name ());\n+      if (local)\n+\treturn true;\n+      return cdtor;\n+    }\n+  return false;\n+}\n+\n+/* Make function const and output warning.  If LOCAL is true,\n+   return true if anything changed.  Otherwise return true if\n+   we may have introduced removale ctors.  */\n+\n+bool\n+ipa_make_function_pure (struct cgraph_node *node, bool looping, bool local)\n+{\n+  bool cdtor = false;\n+\n+  if (DECL_PURE_P (node->decl)\n+      && (looping || DECL_LOOPING_CONST_OR_PURE_P (node->decl)))\n+    return false;\n+  warn_function_pure (node->decl, !looping);\n+  if (local && skip_function_for_local_pure_const (node))\n+    return false;\n+  if (dump_file)\n+    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n+\t     looping ? \"looping \" : \"\",\n+\t     node->dump_name ());\n+  if (!local)\n+    cdtor = node->call_for_symbol_and_aliases (cdtor_p, NULL, true);\n+  if (node->set_pure_flag (true, looping))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Declaration updated to be %spure: %s\\n\",\n+\t\t looping ? \"looping \" : \"\",\n+\t\t node->dump_name ());\n+      if (local)\n+\treturn true;\n+      return cdtor;\n+    }\n+  return false;\n+}\n+\n /* Produce transitive closure over the callgraph and compute pure/const\n    attributes.  */\n \n@@ -1442,7 +1541,6 @@ propagate_pure_const (void)\n   int i;\n   struct ipa_dfs_info * w_info;\n   bool remove_p = false;\n-  bool has_cdtor;\n \n   order_pos = ipa_reduced_postorder (order, true,\n \t\t\t\t     ignore_edge_for_pure_const);\n@@ -1513,6 +1611,9 @@ propagate_pure_const (void)\n \t      enum pure_const_state_e edge_state = IPA_CONST;\n \t      bool edge_looping = false;\n \n+\t      if (e->recursive_p ())\n+\t\tlooping = true;\n+\n \t      if (e->recursive_p ())\n \t\tlooping = true;\n \n@@ -1699,55 +1800,11 @@ propagate_pure_const (void)\n \t    switch (this_state)\n \t      {\n \t      case IPA_CONST:\n-\t\tif (!TREE_READONLY (w->decl))\n-\t\t  {\n-\t\t    warn_function_const (w->decl, !this_looping);\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n-\t\t\t       this_looping ? \"looping \" : \"\",\n-\t\t\t       w->dump_name ());\n-\t\t  }\n-\t\t/* Turning constructor or destructor to non-looping const/pure\n-\t\t   enables us to possibly remove the function completely.  */\n-\t\tif (this_looping)\n-\t\t  has_cdtor = false;\n-\t\telse\n-\t\t  has_cdtor = w->call_for_symbol_and_aliases (cdtor_p,\n-\t\t\t\t\t\t\t      NULL, true);\n-\t\tif (w->set_const_flag (true, this_looping))\n-\t\t  {\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"Declaration updated to be %sconst: %s\\n\",\n-\t\t\t       this_looping ? \"looping \" : \"\",\n-\t\t\t       w->dump_name ());\n-\t\t    remove_p |= has_cdtor;\n-\t\t  }\n+\t\tremove_p |= ipa_make_function_const (node, looping, false);\n \t\tbreak;\n \n \t      case IPA_PURE:\n-\t\tif (!DECL_PURE_P (w->decl))\n-\t\t  {\n-\t\t    warn_function_pure (w->decl, !this_looping);\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n-\t\t\t       this_looping ? \"looping \" : \"\",\n-\t\t\t       w->dump_name ());\n-\t\t  }\n-\t\tif (this_looping)\n-\t\t  has_cdtor = false;\n-\t\telse\n-\t\t  has_cdtor = w->call_for_symbol_and_aliases (cdtor_p,\n-\t\t\t\t\t\t\t      NULL, true);\n-\t\tif (w->set_pure_flag (true, this_looping))\n-\t\t  {\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"Declaration updated to be %spure: %s\\n\",\n-\t\t\t       this_looping ? \"looping \" : \"\",\n-\t\t\t       w->dump_name ());\n-\t\t    remove_p |= has_cdtor;\n-\t\t  }\n+\t\tremove_p |= ipa_make_function_pure (node, looping, false);\n \t\tbreak;\n \n \t      default:\n@@ -2046,34 +2103,6 @@ make_pass_ipa_pure_const (gcc::context *ctxt)\n   return new pass_ipa_pure_const (ctxt);\n }\n \n-/* Return true if function should be skipped for local pure const analysis.  */\n-\n-static bool\n-skip_function_for_local_pure_const (struct cgraph_node *node)\n-{\n-  /* Because we do not schedule pass_fixup_cfg over whole program after early\n-     optimizations we must not promote functions that are called by already\n-     processed functions.  */\n-\n-  if (function_called_by_processed_nodes_p ())\n-    {\n-      if (dump_file)\n-        fprintf (dump_file, \"Function called in recursive cycle; ignoring\\n\");\n-      return true;\n-    }\n-  /* Save some work and do not analyze functions which are interposable and\n-     do not have any non-interposable aliases.  */\n-  if (node->get_availability () <= AVAIL_INTERPOSABLE\n-      && !node->has_aliases_p ())\n-    {\n-      if (dump_file)\n-        fprintf (dump_file,\n-\t\t \"Function is interposable; not analyzing.\\n\");\n-      return true;\n-    }\n-  return false;\n-}\n-\n /* Simple local pass for pure const discovery reusing the analysis from\n    ipa_pure_const.   This pass is effective when executed together with\n    other optimization passes in early optimization pass queue.  */\n@@ -2144,55 +2173,13 @@ pass_local_pure_const::execute (function *fun)\n   switch (l->pure_const_state)\n     {\n     case IPA_CONST:\n-      if (!TREE_READONLY (current_function_decl))\n-\t{\n-\t  warn_function_const (current_function_decl, !l->looping);\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n-\t\t     l->looping ? \"looping \" : \"\",\n-\t\t     current_function_name ());\n-\t}\n-      else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n-\t       && !l->looping)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n-\t\t     current_function_name ());\n-\t}\n-      if (!skip && node->set_const_flag (true, l->looping))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Declaration updated to be %sconst: %s\\n\",\n-\t\t     l->looping ? \"looping \" : \"\",\n-\t\t     current_function_name ());\n-\t  changed = true;\n-\t}\n+      changed |= ipa_make_function_const\n+\t\t   (cgraph_node::get (current_function_decl), l->looping, true);\n       break;\n \n     case IPA_PURE:\n-      if (!DECL_PURE_P (current_function_decl))\n-\t{\n-\t  warn_function_pure (current_function_decl, !l->looping);\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n-\t\t     l->looping ? \"looping \" : \"\",\n-\t\t     current_function_name ());\n-\t}\n-      else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n-\t       && !l->looping)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n-\t\t     current_function_name ());\n-\t}\n-      if (!skip && node->set_pure_flag (true, l->looping))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Declaration updated to be %spure: %s\\n\",\n-\t\t     l->looping ? \"looping \" : \"\",\n-\t\t     current_function_name ());\n-\t  changed = true;\n-\t}\n+      changed |= ipa_make_function_pure\n+\t\t   (cgraph_node::get (current_function_decl), l->looping, true);\n       break;\n \n     default:"}, {"sha": "e2440a1f8939078a0cec06aeaedb38b1ef39bf84", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -50,6 +50,8 @@ bool recursive_call_p (tree, tree);\n /* In ipa-pure-const.c  */\n bool finite_function_p ();\n bool builtin_safe_for_const_function_p (bool *, tree);\n+bool ipa_make_function_const (cgraph_node *, bool, bool);\n+bool ipa_make_function_pure (cgraph_node *, bool, bool);\n \n /* In ipa-profile.c  */\n bool ipa_propagate_frequency (struct cgraph_node *node);"}, {"sha": "b583d17c86f13f511343b0fe54d91d1260cd4c48", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -92,13 +92,13 @@ along with GCC; see the file COPYING3.  If not see\n           NEXT_PASS (pass_dse);\n \t  NEXT_PASS (pass_cd_dce, false /* update_address_taken_p */);\n \t  NEXT_PASS (pass_phiopt, true /* early_p */);\n-\t  NEXT_PASS (pass_modref);\n \t  NEXT_PASS (pass_tail_recursion);\n \t  NEXT_PASS (pass_if_to_switch);\n \t  NEXT_PASS (pass_convert_switch);\n \t  NEXT_PASS (pass_cleanup_eh);\n \t  NEXT_PASS (pass_profile);\n \t  NEXT_PASS (pass_local_pure_const);\n+\t  NEXT_PASS (pass_modref);\n \t  /* Split functions creates parts that are not run through\n \t     early optimizations again.  It is thus good idea to do this\n \t      late.  */"}, {"sha": "176266893e9d5986cae52944867d7ef572dc1c5d", "filename": "gcc/testsuite/c-c++-common/tm/inline-asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm.c?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fgnu-tm -O1\" } */\n+/* { dg-options \"-fgnu-tm -O1 -fno-ipa-modref -fno-ipa-pure-const\" } */\n \n static inline void\n inline_death ()"}, {"sha": "b49238162fece901c342e030e5706d35ab63d641", "filename": "gcc/testsuite/g++.dg/ipa/modref-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -30,6 +30,6 @@ int main()\n \t\tlinker_error ();\n \treturn 0;\n }\n-/* { dg-final { scan-tree-dump \"Function found to be const: {anonymous}::B::genB\" \"local-pure-const1\"  } } */\n-/* { dg-final { scan-tree-dump \"Retslot flags: no_indirect_clobber no_direct_escape no_indirect_escape not_returned_directly not_returned_indirectly no_direct_read no_indirect_read\" \"modref1\" } } */\n+/* { dg-final { scan-tree-dump \"Function found to be const: static {anonymous}::B {anonymous}::B::genB\" \"local-pure-const1\"  } } */\n+/* { dg-final { scan-tree-dump \"Retslot flags: not_returned_directly\" \"modref1\" } } */\n   "}, {"sha": "10ebe1ff47406fd40348db97c456391852e9cd31", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-11.c?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-modref1\"  } */\n+/* { dg-options \"-O2 -fdump-tree-modref1 -fno-ipa-pure-const\"  } */\n struct linkedlist {\n   struct linkedlist *next;\n };"}, {"sha": "986248f37a22a8e095e9c791d663414e9a28f0c3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-14.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-14.c?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wsuggest-attribute=const\" } */\n+struct a {int a,b,c;};\n+__attribute__ ((noinline))\n+int init (struct a *a)\n+{\n+  a->a=1;\n+  a->b=2;\n+  a->c=3;\n+}\n+int const_fn () /* { dg-warning \"function might be candidate for attribute 'const\" } */\n+{\n+  struct a a;\n+  init (&a);\n+  return a.a + a.b + a.c;\n+}"}, {"sha": "4a18e34cd160aab0ddffc94c590a9cb0e07e9d39", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-8.c?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 --param modref-max-adjustments=8 -fdump-tree-modref1\"  } */\n+/* { dg-options \"-O2 --param modref-max-adjustments=8 -fdump-tree-modref1 -fno-optimize-sibling-calls\"  } */\n /* { dg-do compile } */\n void\n set (char *p)"}, {"sha": "8f7183eb9b62a9a69cb1484bf60651aea74c2f14", "filename": "gcc/testsuite/gfortran.dg/do_subscript_3.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bdadf28d0fb3505ff8dce5afa587e0ff46544/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_subscript_3.f90?ref=494bdadf28d0fb3505ff8dce5afa587e0ff46544", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-options \"-O0\" }\n ! PR fortran/91424\n ! Check that only one warning is issued inside blocks, and that\n ! warnings are also issued for contained subroutines."}]}