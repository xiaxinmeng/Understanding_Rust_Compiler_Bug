{"sha": "87d05b4491ae7e9343f11c4c52c0486456a3e120", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdkMDViNDQ5MWFlN2U5MzQzZjExYzRjNTJjMDQ4NjQ1NmEzZTEyMA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2010-02-01T15:09:20Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2010-02-01T15:09:20Z"}, "message": "arm.c (FL_FOR_ARCH_7A): is also a superset of ARMv6K.\n\n\t* arm.c (FL_FOR_ARCH_7A): is also a superset of ARMv6K.\n\t(arm_override_options): Allow automatic selection of the thread\n\tpointer register if thumb2.\n\t(legitimize_pic_address): Improve code sequences for Thumb2.\n\t(arm_call_tls_get_addr): Likewise.\n\t(legitimize_tls_address): Likewise.\n\t* arm.md (pic_load_addr_arm): Delete.  Replace with ...\n\t(pic_load_addr_32bit): ... this.  New named pattern.\n\t* thumb2.md (pic_load_addr_thumb2): Delete.\n\t(pic_load_dot_plus_four): Delete.\n\t(tls_load_dot_plus_four): New named pattern.\n\nFrom-SVN: r156428", "tree": {"sha": "9bd30a1587af1975cdf59224794c9322b20ef1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bd30a1587af1975cdf59224794c9322b20ef1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87d05b4491ae7e9343f11c4c52c0486456a3e120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d05b4491ae7e9343f11c4c52c0486456a3e120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d05b4491ae7e9343f11c4c52c0486456a3e120", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d05b4491ae7e9343f11c4c52c0486456a3e120/comments", "author": null, "committer": null, "parents": [{"sha": "cb717ac46c67a96e1640fada72e7e3bb651e3f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb717ac46c67a96e1640fada72e7e3bb651e3f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb717ac46c67a96e1640fada72e7e3bb651e3f5b"}], "stats": {"total": 120, "additions": 43, "deletions": 77}, "files": [{"sha": "c52c23b72424255234ab5e7f7aa69616b88c42b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87d05b4491ae7e9343f11c4c52c0486456a3e120", "patch": "@@ -1,3 +1,17 @@\n+2010-02-01  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (FL_FOR_ARCH_7A): is also a superset of ARMv6K.\n+\t(arm_override_options): Allow automatic selection of the thread\n+\tpointer register if thumb2.\n+\t(legitimize_pic_address): Improve code sequences for Thumb2.\n+\t(arm_call_tls_get_addr): Likewise.\n+\t(legitimize_tls_address): Likewise.\n+\t* arm.md (pic_load_addr_arm): Delete.  Replace with ...\n+\t(pic_load_addr_32bit): ... this.  New named pattern.\n+\t* thumb2.md (pic_load_addr_thumb2): Delete.\n+\t(pic_load_dot_plus_four): Delete.\n+\t(tls_load_dot_plus_four): New named pattern.\n+\n 2010-02-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR libgomp/29986"}, {"sha": "543498ea82acb03576a4bf15078bc06fe046a411", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 45, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=87d05b4491ae7e9343f11c4c52c0486456a3e120", "patch": "@@ -601,7 +601,7 @@ static int thumb_call_reg_needed;\n #define FL_FOR_ARCH6T2\t(FL_FOR_ARCH6 | FL_THUMB2)\n #define FL_FOR_ARCH6M\t(FL_FOR_ARCH6 & ~FL_NOTM)\n #define FL_FOR_ARCH7\t(FL_FOR_ARCH6T2 &~ FL_NOTM)\n-#define FL_FOR_ARCH7A\t(FL_FOR_ARCH7 | FL_NOTM)\n+#define FL_FOR_ARCH7A\t(FL_FOR_ARCH7 | FL_NOTM | FL_ARCH6K)\n #define FL_FOR_ARCH7R\t(FL_FOR_ARCH7A | FL_DIV)\n #define FL_FOR_ARCH7M\t(FL_FOR_ARCH7 | FL_DIV)\n #define FL_FOR_ARCH7EM  (FL_FOR_ARCH7M | FL_ARCH7EM)\n@@ -1758,7 +1758,7 @@ arm_override_options (void)\n   /* Use the cp15 method if it is available.  */\n   if (target_thread_pointer == TP_AUTO)\n     {\n-      if (arm_arch6k && !TARGET_THUMB)\n+      if (arm_arch6k && !TARGET_THUMB1)\n \ttarget_thread_pointer = TP_CP15;\n       else\n \ttarget_thread_pointer = TP_SOFT;\n@@ -4926,10 +4926,8 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       else\n \taddress = reg;\n \n-      if (TARGET_ARM)\n-\temit_insn (gen_pic_load_addr_arm (address, orig));\n-      else if (TARGET_THUMB2)\n-\temit_insn (gen_pic_load_addr_thumb2 (address, orig));\n+      if (TARGET_32BIT)\n+\temit_insn (gen_pic_load_addr_32bit (address, orig));\n       else /* TARGET_THUMB1 */\n \temit_insn (gen_pic_load_addr_thumb1 (address, orig));\n \n@@ -5106,7 +5104,7 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n     {\n       pic_rtx = gen_rtx_SYMBOL_REF (Pmode, VXWORKS_GOTT_BASE);\n       pic_rtx = gen_rtx_CONST (Pmode, pic_rtx);\n-      emit_insn (gen_pic_load_addr_arm (pic_reg, pic_rtx));\n+      emit_insn (gen_pic_load_addr_32bit (pic_reg, pic_rtx));\n \n       emit_insn (gen_rtx_SET (Pmode, pic_reg, gen_rtx_MEM (Pmode, pic_reg)));\n \n@@ -5129,29 +5127,13 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n \t\t\t\tUNSPEC_GOTSYM_OFF);\n       pic_rtx = gen_rtx_CONST (Pmode, pic_rtx);\n \n-      if (TARGET_ARM)\n-\t{\n-\t  emit_insn (gen_pic_load_addr_arm (pic_reg, pic_rtx));\n-\t  emit_insn (gen_pic_add_dot_plus_eight (pic_reg, pic_reg, labelno));\n-\t}\n-      else if (TARGET_THUMB2)\n+      if (TARGET_32BIT)\n \t{\n-\t  /* Thumb-2 only allows very limited access to the PC.  Calculate the\n-\t     address in a temporary register.  */\n-\t  if (arm_pic_register != INVALID_REGNUM)\n-\t    {\n-\t      pic_tmp = gen_rtx_REG (SImode,\n-\t\t\t\t     thumb_find_work_register (saved_regs));\n-\t    }\n+\t  emit_insn (gen_pic_load_addr_32bit (pic_reg, pic_rtx));\n+\t  if (TARGET_ARM)\n+\t    emit_insn (gen_pic_add_dot_plus_eight (pic_reg, pic_reg, labelno));\n \t  else\n-\t    {\n-\t      gcc_assert (can_create_pseudo_p ());\n-\t      pic_tmp = gen_reg_rtx (Pmode);\n-\t    }\n-\n-\t  emit_insn (gen_pic_load_addr_thumb2 (pic_reg, pic_rtx));\n-\t  emit_insn (gen_pic_load_dot_plus_four (pic_tmp, labelno));\n-\t  emit_insn (gen_addsi3 (pic_reg, pic_reg, pic_tmp));\n+\t    emit_insn (gen_pic_add_dot_plus_four (pic_reg, pic_reg, labelno));\n \t}\n       else /* TARGET_THUMB1 */\n \t{\n@@ -5808,14 +5790,7 @@ arm_call_tls_get_addr (rtx x, rtx reg, rtx *valuep, int reloc)\n   if (TARGET_ARM)\n     emit_insn (gen_pic_add_dot_plus_eight (reg, reg, labelno));\n   else if (TARGET_THUMB2)\n-    {\n-      rtx tmp;\n-      /* Thumb-2 only allows very limited access to the PC.  Calculate\n-\t the address in a temporary register.  */\n-      tmp = gen_reg_rtx (SImode);\n-      emit_insn (gen_pic_load_dot_plus_four (tmp, labelno));\n-      emit_insn (gen_addsi3(reg, reg, tmp));\n-    }\n+    emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));\n   else /* TARGET_THUMB1 */\n     emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));\n \n@@ -5871,15 +5846,7 @@ legitimize_tls_address (rtx x, rtx reg)\n       if (TARGET_ARM)\n \temit_insn (gen_tls_load_dot_plus_eight (reg, reg, labelno));\n       else if (TARGET_THUMB2)\n-\t{\n-\t  rtx tmp;\n-\t  /* Thumb-2 only allows very limited access to the PC.  Calculate\n-\t     the address in a temporary register.  */\n-\t  tmp = gen_reg_rtx (SImode);\n-\t  emit_insn (gen_pic_load_dot_plus_four (tmp, labelno));\n-\t  emit_insn (gen_addsi3(reg, reg, tmp));\n-\t  emit_move_insn (reg, gen_const_mem (SImode, reg));\n-\t}\n+\temit_insn (gen_tls_load_dot_plus_four (reg, reg, labelno));\n       else\n \t{\n \t  emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));"}, {"sha": "3d0d7f2ec2d9fe0f78a781c5b5d520defd15b515", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=87d05b4491ae7e9343f11c4c52c0486456a3e120", "patch": "@@ -5242,14 +5242,17 @@\n ;; the insn alone, and to force the minipool generation pass to then move\n ;; the GOT symbol to memory.\n \n-(define_insn \"pic_load_addr_arm\"\n+(define_insn \"pic_load_addr_32bit\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] UNSPEC_PIC_SYM))]\n-  \"TARGET_ARM && flag_pic\"\n+  \"TARGET_32BIT && flag_pic\"\n   \"ldr%?\\\\t%0, %1\"\n   [(set_attr \"type\" \"load1\")\n-   (set (attr \"pool_range\")     (const_int 4096))\n-   (set (attr \"neg_pool_range\") (const_int 4084))]\n+   (set_attr \"pool_range\" \"4096\")\n+   (set (attr \"neg_pool_range\")\n+\t(if_then_else (eq_attr \"is_thumb\" \"no\")\n+\t\t      (const_int 4084)\n+\t\t      (const_int 0)))]\n )\n \n (define_insn \"pic_load_addr_thumb1\"\n@@ -5267,7 +5270,7 @@\n \t\t    (const_int 4)\n \t\t    (match_operand 2 \"\" \"\")]\n \t\t   UNSPEC_PIC_BASE))]\n-  \"TARGET_THUMB1\"\n+  \"TARGET_THUMB\"\n   \"*\n   (*targetm.asm_out.internal_label) (asm_out_file, \\\"LPIC\\\",\n \t\t\t\t     INTVAL (operands[2]));"}, {"sha": "e36735146c3ba506330e47bdc15218c995650ba5", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d05b4491ae7e9343f11c4c52c0486456a3e120/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=87d05b4491ae7e9343f11c4c52c0486456a3e120", "patch": "@@ -243,37 +243,19 @@\n    (set_attr \"neg_pool_range\" \"*,*,*,*,0,*\")]\n )\n \n-;; ??? We can probably do better with thumb2\n-(define_insn \"pic_load_addr_thumb2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] UNSPEC_PIC_SYM))]\n-  \"TARGET_THUMB2 && flag_pic\"\n-  \"ldr%?\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load1\")\n-   (set_attr \"pool_range\" \"4096\")\n-   (set_attr \"neg_pool_range\" \"0\")]\n-)\n-\n-;; Set reg to the address of this instruction plus four.  The low two\n-;; bits of the PC are always read as zero, so ensure the instructions is\n-;; word aligned.\n-(define_insn \"pic_load_dot_plus_four\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(const_int 4)\n-\t\t    (match_operand 1 \"\" \"\")]\n-\t\t   UNSPEC_PIC_BASE))]\n+(define_insn \"tls_load_dot_plus_four\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,r\")\n+\t(mem:SI (unspec:SI [(match_operand:SI 1 \"register_operand\" \"+l,r\")\n+\t\t\t    (const_int 4)\n+\t\t\t    (match_operand 2 \"\" \"\")]\n+\t\t\t   UNSPEC_PIC_BASE)))]\n   \"TARGET_THUMB2\"\n   \"*\n-  assemble_align(BITS_PER_WORD);\n   (*targetm.asm_out.internal_label) (asm_out_file, \\\"LPIC\\\",\n-\t\t\t     INTVAL (operands[1]));\n-  /* We use adr because some buggy gas assemble add r8, pc, #0\n-     to add.w r8, pc, #0, not addw r8, pc, #0.  */\n-  asm_fprintf (asm_out_file, \\\"\\\\tadr\\\\t%r, %LLPIC%d + 4\\\\n\\\",\n-\t       REGNO(operands[0]), (int)INTVAL (operands[1]));\n-  return \\\"\\\";\n+\t\t\t     INTVAL (operands[2]));\n+  return \\\"add\\\\t%1, %|pc\\;ldr%?\\\\t%0, [%1]\\\";\n   \"\n-  [(set_attr \"length\" \"6\")]\n+  [(set_attr \"length\" \"4,6\")]\n )\n \n ;; Thumb-2 always has load/store halfword instructions, so we can avoid a lot"}]}