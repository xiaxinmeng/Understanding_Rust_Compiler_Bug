{"sha": "6245ad72d23867f979d0960bdde9a8427c6ba262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0NWFkNzJkMjM4NjdmOTc5ZDA5NjBiZGRlOWE4NDI3YzZiYTI2Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-06-30T17:45:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-06-30T17:45:21Z"}, "message": "re PR fortran/71704 (ICE with -fopenmp and some omp constructs)\n\n\tPR fortran/71704\n\t* parse.c (matchs, matcho): Move right before decode_omp_directive.\n\tIf spec_only, only gfc_match the keyword and if successful, goto\n\tdo_spec_only.\n\t(matchds, matchdo): Define.\n\t(decode_omp_directive): Add spec_only local var and set it.\n\tUse matchds or matchdo macros instead of matchs or matcho\n\tfor declare target, declare simd, declare reduction and threadprivate\n\tdirectives.  Return ST_GET_FCN_CHARACTERISTICS if a non-declarative\n\tdirective could be matched.\n\t(next_statement): For ST_GET_FCN_CHARACTERISTICS restore\n\tgfc_current_locus from old_locus even if there is no label.\n\n\t* gfortran.dg/gomp/pr71704.f90: New test.\n\nFrom-SVN: r237888", "tree": {"sha": "c2bfa8ece838421c7970feab49f1b7fb9a3e7488", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2bfa8ece838421c7970feab49f1b7fb9a3e7488"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6245ad72d23867f979d0960bdde9a8427c6ba262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6245ad72d23867f979d0960bdde9a8427c6ba262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6245ad72d23867f979d0960bdde9a8427c6ba262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6245ad72d23867f979d0960bdde9a8427c6ba262/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "351beab7f57e82ee88abaedc407ff793542c08ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351beab7f57e82ee88abaedc407ff793542c08ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/351beab7f57e82ee88abaedc407ff793542c08ab"}], "stats": {"total": 183, "additions": 150, "deletions": 33}, "files": [{"sha": "e399d35912611ccc50739d231aaccce2c29bd498", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6245ad72d23867f979d0960bdde9a8427c6ba262", "patch": "@@ -1,5 +1,18 @@\n 2016-06-30  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR fortran/71704\n+\t* parse.c (matchs, matcho): Move right before decode_omp_directive.\n+\tIf spec_only, only gfc_match the keyword and if successful, goto\n+\tdo_spec_only.\n+\t(matchds, matchdo): Define.\n+\t(decode_omp_directive): Add spec_only local var and set it.\n+\tUse matchds or matchdo macros instead of matchs or matcho\n+\tfor declare target, declare simd, declare reduction and threadprivate\n+\tdirectives.  Return ST_GET_FCN_CHARACTERISTICS if a non-declarative\n+\tdirective could be matched.\n+\t(next_statement): For ST_GET_FCN_CHARACTERISTICS restore\n+\tgfc_current_locus from old_locus even if there is no label.\n+\n \tPR fortran/71705\n \t* trans-openmp.c (gfc_trans_omp_clauses): Set TREE_ADDRESSABLE on\n \tdecls in to/from clauses."}, {"sha": "d795225b7117e99960518b8bc307739d01bf21a1", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6245ad72d23867f979d0960bdde9a8427c6ba262", "patch": "@@ -589,28 +589,6 @@ decode_statement (void)\n   return ST_NONE;\n }\n \n-/* Like match, but set a flag simd_matched if keyword matched.  */\n-#define matchs(keyword, subr, st)\t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-      if (match_word_omp_simd (keyword, subr, &old_locus,\t\\\n-\t\t\t       &simd_matched) == MATCH_YES)\t\\\n-\treturn st;\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tundo_new_statement ();\t\t\t\t  \t\\\n-    } while (0);\n-\n-/* Like match, but don't match anything if not -fopenmp.  */\n-#define matcho(keyword, subr, st)\t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-      if (!flag_openmp)\t\t\t\t\t\t\\\n-\t;\t\t\t\t\t\t\t\\\n-      else if (match_word (keyword, subr, &old_locus)\t\t\\\n-\t       == MATCH_YES)\t\t\t\t\t\\\n-\treturn st;\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tundo_new_statement ();\t\t\t\t  \t\\\n-    } while (0);\n-\n static gfc_statement\n decode_oacc_directive (void)\n {\n@@ -702,12 +680,63 @@ decode_oacc_directive (void)\n   return ST_NONE;\n }\n \n+/* Like match, but set a flag simd_matched if keyword matched\n+   and if spec_only, goto do_spec_only without actually matching.  */\n+#define matchs(keyword, subr, st)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+      if (spec_only && gfc_match (keyword) == MATCH_YES)\t\\\n+\tgoto do_spec_only;\t\t\t\t\t\\\n+      if (match_word_omp_simd (keyword, subr, &old_locus,\t\\\n+\t\t\t       &simd_matched) == MATCH_YES)\t\\\n+\treturn st;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n+    } while (0);\n+\n+/* Like match, but don't match anything if not -fopenmp\n+   and if spec_only, goto do_spec_only without actually matching.  */\n+#define matcho(keyword, subr, st)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+      if (!flag_openmp)\t\t\t\t\t\t\\\n+\t;\t\t\t\t\t\t\t\\\n+      else if (spec_only && gfc_match (keyword) == MATCH_YES)\t\\\n+\tgoto do_spec_only;\t\t\t\t\t\\\n+      else if (match_word (keyword, subr, &old_locus)\t\t\\\n+\t       == MATCH_YES)\t\t\t\t\t\\\n+\treturn st;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n+    } while (0);\n+\n+/* Like match, but set a flag simd_matched if keyword matched.  */\n+#define matchds(keyword, subr, st)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+      if (match_word_omp_simd (keyword, subr, &old_locus,\t\\\n+\t\t\t       &simd_matched) == MATCH_YES)\t\\\n+\treturn st;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n+    } while (0);\n+\n+/* Like match, but don't match anything if not -fopenmp.  */\n+#define matchdo(keyword, subr, st)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+      if (!flag_openmp)\t\t\t\t\t\t\\\n+\t;\t\t\t\t\t\t\t\\\n+      else if (match_word (keyword, subr, &old_locus)\t\t\\\n+\t       == MATCH_YES)\t\t\t\t\t\\\n+\treturn st;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n+    } while (0);\n+\n static gfc_statement\n decode_omp_directive (void)\n {\n   locus old_locus;\n   char c;\n   bool simd_matched = false;\n+  bool spec_only = false;\n \n   gfc_enforce_clean_symbol_state ();\n \n@@ -722,6 +751,10 @@ decode_omp_directive (void)\n       return ST_NONE;\n     }\n \n+  if (gfc_current_state () == COMP_FUNCTION\n+      && gfc_current_block ()->result->ts.kind == -1)\n+    spec_only = true;\n+\n   gfc_unset_implicit_pure (NULL);\n \n   old_locus = gfc_current_locus;\n@@ -750,12 +783,12 @@ decode_omp_directive (void)\n       matcho (\"critical\", gfc_match_omp_critical, ST_OMP_CRITICAL);\n       break;\n     case 'd':\n-      matchs (\"declare reduction\", gfc_match_omp_declare_reduction,\n-\t      ST_OMP_DECLARE_REDUCTION);\n-      matchs (\"declare simd\", gfc_match_omp_declare_simd,\n-\t      ST_OMP_DECLARE_SIMD);\n-      matcho (\"declare target\", gfc_match_omp_declare_target,\n-\t      ST_OMP_DECLARE_TARGET);\n+      matchds (\"declare reduction\", gfc_match_omp_declare_reduction,\n+\t       ST_OMP_DECLARE_REDUCTION);\n+      matchds (\"declare simd\", gfc_match_omp_declare_simd,\n+\t       ST_OMP_DECLARE_SIMD);\n+      matchdo (\"declare target\", gfc_match_omp_declare_target,\n+\t       ST_OMP_DECLARE_TARGET);\n       matchs (\"distribute parallel do simd\",\n \t      gfc_match_omp_distribute_parallel_do_simd,\n \t      ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD);\n@@ -875,8 +908,8 @@ decode_omp_directive (void)\n       matcho (\"teams distribute\", gfc_match_omp_teams_distribute,\n \t      ST_OMP_TEAMS_DISTRIBUTE);\n       matcho (\"teams\", gfc_match_omp_teams, ST_OMP_TEAMS);\n-      matcho (\"threadprivate\", gfc_match_omp_threadprivate,\n-\t      ST_OMP_THREADPRIVATE);\n+      matchdo (\"threadprivate\", gfc_match_omp_threadprivate,\n+\t       ST_OMP_THREADPRIVATE);\n       break;\n     case 'w':\n       matcho (\"workshare\", gfc_match_omp_workshare, ST_OMP_WORKSHARE);\n@@ -899,6 +932,13 @@ decode_omp_directive (void)\n   gfc_error_recovery ();\n \n   return ST_NONE;\n+\n+ do_spec_only:\n+  reject_statement ();\n+  gfc_clear_error ();\n+  gfc_buffer_error (false);\n+  gfc_current_locus = old_locus;\n+  return ST_GET_FCN_CHARACTERISTICS;\n }\n \n static gfc_statement\n@@ -1319,10 +1359,13 @@ next_statement (void)\n \n   gfc_buffer_error (false);\n \n-  if (st == ST_GET_FCN_CHARACTERISTICS && gfc_statement_label != NULL)\n+  if (st == ST_GET_FCN_CHARACTERISTICS)\n     {\n-      gfc_free_st_label (gfc_statement_label);\n-      gfc_statement_label = NULL;\n+      if (gfc_statement_label != NULL)\n+\t{\n+\t  gfc_free_st_label (gfc_statement_label);\n+\t  gfc_statement_label = NULL;\n+\t}\n       gfc_current_locus = old_locus;\n     }\n "}, {"sha": "1f181dcc41491e78be76221572c6863c6e1d4c5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6245ad72d23867f979d0960bdde9a8427c6ba262", "patch": "@@ -1,5 +1,8 @@\n 2016-06-30  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR fortran/71704\n+\t* gfortran.dg/gomp/pr71704.f90: New test.\n+\n \tPR fortran/71705\n \t* gfortran.dg/gomp/pr71705.f90: New test.\n "}, {"sha": "5c1c003ca57339c14ca41d65c443c794827d8a04", "filename": "gcc/testsuite/gfortran.dg/gomp/pr71704.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr71704.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6245ad72d23867f979d0960bdde9a8427c6ba262/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr71704.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fpr71704.f90?ref=6245ad72d23867f979d0960bdde9a8427c6ba262", "patch": "@@ -0,0 +1,58 @@\n+! PR fortran/71704\n+! { dg-do compile }\n+\n+real function f0 ()\n+!$omp declare simd (f0)\n+  f0 = 1\n+end\n+\n+real function f1 ()\n+!$omp declare target (f1)\n+  f1 = 1\n+end\n+\n+real function f2 ()\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) &\n+!$omp & initializer (omp_priv = 0)\n+  f2 = 1\n+end\n+\n+real function f3 ()\n+  real, save :: t\n+!$omp threadprivate (t)\n+  f3 = 1\n+end\n+\n+real function f4 ()\n+!$omp taskwait\n+  f4 = 1\n+end\n+\n+real function f5 ()\n+!$omp barrier\n+  f5 = 1\n+end\n+\n+real function f6 ()\n+!$omp parallel\n+!$omp end parallel\n+  f6 = 1\n+end\n+\n+real function f7 ()\n+!$omp single\n+!$omp end single\n+  f7 = 1\n+end\n+\n+real function f8 ()\n+!$omp critical\n+!$omp end critical\n+  f8 = 1\n+end\n+\n+real function f9 ()\n+!$omp critical\n+!$omp end critical\n+  f9 = 1\n+end"}]}