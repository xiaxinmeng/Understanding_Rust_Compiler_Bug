{"sha": "849cab7b758a2da9c739de3af5d42bb252a1db5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5Y2FiN2I3NThhMmRhOWM3MzlkZTNhZjVkNDJiYjI1MmExZGI1Zg==", "commit": {"author": {"name": "Stephen M. Webb", "email": "stephen.webb@bregmasoft.ca", "date": "2010-06-25T19:27:16Z"}, "committer": {"name": "Stephen M. Webb", "email": "smw@gcc.gnu.org", "date": "2010-06-25T19:27:16Z"}, "message": "Initial regex implementation.\n\n2010-06-25  Stephen M. Webb  <stephen.webb@bregmasoft.ca>\n\n  Initial regex implementation.\n\n  * include/std/regex: Modified to use bits/regex_* headers.\n  * include/bits/regex_compiler.h: New file.\n  * include/bits/regex_constants.h: New file.\n  * include/bits/regex_cursor.h: New file.\n  * include/bits/regex_error.h: New file.\n  * include/bits/regex_grep_matcher.h: New file.\n  * include/bits/regex_grep_matcher.tcc: New file.\n  * include/bits/regex.h: New file.\n  * include/bits/regex_nfa.h: New file.\n  * include/bits/regex_nfa.tcc: New file.\n  * include/Makefile.am: Added above new files.\n  * include/Makefile.in: Regenerated.\n  * testsuite/28_regex/02_definitions: New file.\n  * testsuite/28_regex/03_requirements: New file.\n  * testsuite/28_regex/03_requirements/typedefs.cc: New file.\n  * testsuite/28_regex/04_header: New file.\n  * testsuite/28_regex/04_header/regex: New file.\n  * testsuite/28_regex/04_header/regex/std_c++0x_neg.cc: New file.\n  * testsuite/28_regex/05_constants: New file.\n  * testsuite/28_regex/05_constants/error_type.cc: New file.\n  * testsuite/28_regex/05_constants/match_flag_type.cc: New file.\n  * testsuite/28_regex/05_constants/syntax_option_type.cc: New file.\n  * testsuite/28_regex/06_exception_type: New file.\n  * testsuite/28_regex/06_exception_type/regex_error.cc: New file.\n  * testsuite/28_regex/07_traits: New file.\n  * testsuite/28_regex/07_traits/char: New file.\n  * testsuite/28_regex/07_traits/char/ctor.cc: New file.\n  * testsuite/28_regex/07_traits/char/isctype.cc: New file.\n  * testsuite/28_regex/07_traits/char/length.cc: New file.\n  * testsuite/28_regex/07_traits/char/lookup_classname.cc: New file.\n  * testsuite/28_regex/07_traits/char/lookup_collatename.cc: New file.\n  * testsuite/28_regex/07_traits/char/transform.cc: New file.\n  * testsuite/28_regex/07_traits/char/transform_primary.cc: New file.\n  * testsuite/28_regex/07_traits/char/translate.cc: New file.\n  * testsuite/28_regex/07_traits/char/translate_nocase.cc: New file.\n  * testsuite/28_regex/07_traits/char/value.cc: New file.\n  * testsuite/28_regex/07_traits/wchar_t: New file.\n  * testsuite/28_regex/07_traits/wchar_t/ctor.cc: New file.\n  * testsuite/28_regex/07_traits/wchar_t/length.cc: New file.\n  * testsuite/28_regex/07_traits/wchar_t/transform.cc: New file.\n  * testsuite/28_regex/07_traits/wchar_t/translate.cc: New file.\n  * testsuite/28_regex/07_traits/wchar_t/translate_nocase.cc: New file.\n  * testsuite/28_regex/07_traits/wchar_t/value.cc: New file.\n  * testsuite/28_regex/08_basic_regex: New file.\n  * testsuite/28_regex/08_basic_regex/assign: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/cstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/cstring_op.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/moveable.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/pstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/range.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/string.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/char/string_op.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t/cstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t/cstring_op.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t/pstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t/range.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t/string.cc: New file.\n  * testsuite/28_regex/08_basic_regex/assign/wchar_t/string_op.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/basic: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/basic/cstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/basic/pstring_char.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/basic/pstring_wchar_t.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/basic/string_range_01_02_03.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_awk.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/cstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_ecma.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_egrep.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_grep.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/default.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/char/range.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/copy_char.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/extended: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/extended/cstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/extended/string_range_01_02_03.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/move_char.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/string_char.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/string_wchar_t.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/wchar_t: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/wchar_t/cstring.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/wchar_t/default.cc: New file.\n  * testsuite/28_regex/08_basic_regex/ctors/wchar_t/range.cc: New file.\n  * testsuite/28_regex/08_basic_regex/regex.cc: New file.\n  * testsuite/28_regex/09_sub_match: New file.\n  * testsuite/28_regex/09_sub_match/cast_char.cc: New file.\n  * testsuite/28_regex/09_sub_match/cast_wchar_t.cc: New file.\n  * testsuite/28_regex/09_sub_match/length.cc: New file.\n  * testsuite/28_regex/09_sub_match/typedefs.cc: New file.\n  * testsuite/28_regex/10_match_results: New file.\n  * testsuite/28_regex/10_match_results/ctors: New file.\n  * testsuite/28_regex/10_match_results/ctors/char: New file.\n  * testsuite/28_regex/10_match_results/ctors/char/default.cc: New file.\n  * testsuite/28_regex/10_match_results/ctors/wchar_t: New file.\n  * testsuite/28_regex/10_match_results/ctors/wchar_t/default.cc: New file.\n  * testsuite/28_regex/10_match_results/typedefs.cc: New file.\n  * testsuite/28_regex/11_algorithms: New file.\n  * testsuite/28_regex/11_algorithms/02_match: New file.\n  * testsuite/28_regex/11_algorithms/02_match/basic: New file.\n  * testsuite/28_regex/11_algorithms/02_match/basic/string_01.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/basic/string_range_00_03.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/basic/string_range_01_03.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/basic/string_range_02_03.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended/cstring_plus.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended/cstring_questionmark.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended/string_any.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended/string_range_00_03.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended/string_range_01_03.cc: New file.\n  * testsuite/28_regex/11_algorithms/02_match/extended/string_range_02_03.cc: New file.\n  * testsuite/28_regex/12_iterators: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator/ctors: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator/ctors/char: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator/ctors/char/default.cc: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator/ctors/wchar_t: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator/ctors/wchar_t/default.cc: New file.\n  * testsuite/28_regex/12_iterators/regex_iterator/typedefs.cc: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/char: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/char/default.cc: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/wchar_t: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/wchar_t/default.cc: New file.\n  * testsuite/28_regex/12_iterators/regex_token_iterator/typedefs.cc: New file.\n  * testsuite/28_regex/13_ecmascript: New file.\n\nFrom-SVN: r161410", "tree": {"sha": "826b5ae77ad6d71029705ac2465096e2249ccf90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/826b5ae77ad6d71029705ac2465096e2249ccf90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/849cab7b758a2da9c739de3af5d42bb252a1db5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849cab7b758a2da9c739de3af5d42bb252a1db5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/849cab7b758a2da9c739de3af5d42bb252a1db5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849cab7b758a2da9c739de3af5d42bb252a1db5f/comments", "author": {"login": "bregma", "id": 552308, "node_id": "MDQ6VXNlcjU1MjMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/552308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bregma", "html_url": "https://github.com/bregma", "followers_url": "https://api.github.com/users/bregma/followers", "following_url": "https://api.github.com/users/bregma/following{/other_user}", "gists_url": "https://api.github.com/users/bregma/gists{/gist_id}", "starred_url": "https://api.github.com/users/bregma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bregma/subscriptions", "organizations_url": "https://api.github.com/users/bregma/orgs", "repos_url": "https://api.github.com/users/bregma/repos", "events_url": "https://api.github.com/users/bregma/events{/privacy}", "received_events_url": "https://api.github.com/users/bregma/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58fc89f6b9dfb78d857c08ecc5135dfcca1c3702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fc89f6b9dfb78d857c08ecc5135dfcca1c3702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58fc89f6b9dfb78d857c08ecc5135dfcca1c3702"}], "stats": {"total": 8903, "additions": 8884, "deletions": 19}, "files": [{"sha": "bf8fd743b639b13a48c22952755935b45180972f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -1,3 +1,149 @@\n+2010-06-25  Stephen M. Webb  <stephen.webb@bregmasoft.ca>\n+\n+  Initial regex implementation.\n+\n+  * include/std/regex: Modified to use bits/regex_* headers.\n+  * include/bits/regex_compiler.h: New file.\n+  * include/bits/regex_constants.h: New file.\n+  * include/bits/regex_cursor.h: New file.\n+  * include/bits/regex_error.h: New file.\n+  * include/bits/regex_grep_matcher.h: New file.\n+  * include/bits/regex_grep_matcher.tcc: New file.\n+  * include/bits/regex.h: New file.\n+  * include/bits/regex_nfa.h: New file.\n+  * include/bits/regex_nfa.tcc: New file.\n+  * include/Makefile.am: Added above new files.\n+  * include/Makefile.in: Regenerated.\n+  * testsuite/28_regex/02_definitions: New file.\n+  * testsuite/28_regex/03_requirements: New file.\n+  * testsuite/28_regex/03_requirements/typedefs.cc: New file.\n+  * testsuite/28_regex/04_header: New file.\n+  * testsuite/28_regex/04_header/regex: New file.\n+  * testsuite/28_regex/04_header/regex/std_c++0x_neg.cc: New file.\n+  * testsuite/28_regex/05_constants: New file.\n+  * testsuite/28_regex/05_constants/error_type.cc: New file.\n+  * testsuite/28_regex/05_constants/match_flag_type.cc: New file.\n+  * testsuite/28_regex/05_constants/syntax_option_type.cc: New file.\n+  * testsuite/28_regex/06_exception_type: New file.\n+  * testsuite/28_regex/06_exception_type/regex_error.cc: New file.\n+  * testsuite/28_regex/07_traits: New file.\n+  * testsuite/28_regex/07_traits/char: New file.\n+  * testsuite/28_regex/07_traits/char/ctor.cc: New file.\n+  * testsuite/28_regex/07_traits/char/isctype.cc: New file.\n+  * testsuite/28_regex/07_traits/char/length.cc: New file.\n+  * testsuite/28_regex/07_traits/char/lookup_classname.cc: New file.\n+  * testsuite/28_regex/07_traits/char/lookup_collatename.cc: New file.\n+  * testsuite/28_regex/07_traits/char/transform.cc: New file.\n+  * testsuite/28_regex/07_traits/char/transform_primary.cc: New file.\n+  * testsuite/28_regex/07_traits/char/translate.cc: New file.\n+  * testsuite/28_regex/07_traits/char/translate_nocase.cc: New file.\n+  * testsuite/28_regex/07_traits/char/value.cc: New file.\n+  * testsuite/28_regex/07_traits/wchar_t: New file.\n+  * testsuite/28_regex/07_traits/wchar_t/ctor.cc: New file.\n+  * testsuite/28_regex/07_traits/wchar_t/length.cc: New file.\n+  * testsuite/28_regex/07_traits/wchar_t/transform.cc: New file.\n+  * testsuite/28_regex/07_traits/wchar_t/translate.cc: New file.\n+  * testsuite/28_regex/07_traits/wchar_t/translate_nocase.cc: New file.\n+  * testsuite/28_regex/07_traits/wchar_t/value.cc: New file.\n+  * testsuite/28_regex/08_basic_regex: New file.\n+  * testsuite/28_regex/08_basic_regex/assign: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/cstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/cstring_op.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/moveable.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/pstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/range.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/string.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/char/string_op.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t/cstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t/cstring_op.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t/pstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t/range.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t/string.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/assign/wchar_t/string_op.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/basic: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/basic/cstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/basic/pstring_char.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/basic/pstring_wchar_t.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/basic/string_range_01_02_03.cc:\n+  New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_awk.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/cstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_ecma.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_egrep.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/cstring_grep.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/default.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/char/range.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/copy_char.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/extended: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/extended/cstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/extended/string_range_01_02_03.cc:\n+  New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/move_char.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/string_char.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/string_wchar_t.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/wchar_t: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/wchar_t/cstring.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/wchar_t/default.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/ctors/wchar_t/range.cc: New file.\n+  * testsuite/28_regex/08_basic_regex/regex.cc: New file.\n+  * testsuite/28_regex/09_sub_match: New file.\n+  * testsuite/28_regex/09_sub_match/cast_char.cc: New file.\n+  * testsuite/28_regex/09_sub_match/cast_wchar_t.cc: New file.\n+  * testsuite/28_regex/09_sub_match/length.cc: New file.\n+  * testsuite/28_regex/09_sub_match/typedefs.cc: New file.\n+  * testsuite/28_regex/10_match_results: New file.\n+  * testsuite/28_regex/10_match_results/ctors: New file.\n+  * testsuite/28_regex/10_match_results/ctors/char: New file.\n+  * testsuite/28_regex/10_match_results/ctors/char/default.cc: New file.\n+  * testsuite/28_regex/10_match_results/ctors/wchar_t: New file.\n+  * testsuite/28_regex/10_match_results/ctors/wchar_t/default.cc: New file.\n+  * testsuite/28_regex/10_match_results/typedefs.cc: New file.\n+  * testsuite/28_regex/11_algorithms: New file.\n+  * testsuite/28_regex/11_algorithms/02_match: New file.\n+  * testsuite/28_regex/11_algorithms/02_match/basic: New file.\n+  * testsuite/28_regex/11_algorithms/02_match/basic/string_01.cc: New file.\n+  * testsuite/28_regex/11_algorithms/02_match/basic/string_range_00_03.cc:\n+  New file.\n+  * testsuite/28_regex/11_algorithms/02_match/basic/string_range_01_03.cc:\n+  New file.\n+  * testsuite/28_regex/11_algorithms/02_match/basic/string_range_02_03.cc:\n+  New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended: New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended/cstring_plus.cc: New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended/cstring_questionmark.cc:\n+  New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended/string_any.cc: New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended/string_range_00_03.cc:\n+  New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended/string_range_01_03.cc:\n+  New file.\n+  * testsuite/28_regex/11_algorithms/02_match/extended/string_range_02_03.cc:\n+  New file.\n+  * testsuite/28_regex/12_iterators: New file.\n+  * testsuite/28_regex/12_iterators/regex_iterator: New file.\n+  * testsuite/28_regex/12_iterators/regex_iterator/ctors: New file.\n+  * testsuite/28_regex/12_iterators/regex_iterator/ctors/char: New file.\n+  * testsuite/28_regex/12_iterators/regex_iterator/ctors/char/default.cc: New\n+  file.\n+  * testsuite/28_regex/12_iterators/regex_iterator/ctors/wchar_t: New file.\n+  * testsuite/28_regex/12_iterators/regex_iterator/ctors/wchar_t/default.cc: New\n+  file.\n+  * testsuite/28_regex/12_iterators/regex_iterator/typedefs.cc: New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator: New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors: New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/char: New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/char/default.cc:\n+  New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/wchar_t: New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator/ctors/wchar_t/default.cc:\n+  New file.\n+  * testsuite/28_regex/12_iterators/regex_token_iterator/typedefs.cc: New file.\n+  * testsuite/28_regex/13_ecmascript: New file.\n+\n 2010-06-25  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/profile/impl/profiler_list_to_slist.h: Remove spurious"}, {"sha": "6c0230ad292576f0c71fa0241cd827d37217e244", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -121,6 +121,15 @@ bits_headers = \\\n \t${bits_srcdir}/postypes.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n+\t${bits_srcdir}/regex.h \\\n+\t${bits_srcdir}/regex_compiler.h \\\n+\t${bits_srcdir}/regex_constants.h \\\n+\t${bits_srcdir}/regex_cursor.h \\\n+\t${bits_srcdir}/regex_error.h \\\n+\t${bits_srcdir}/regex_grep_matcher.h \\\n+\t${bits_srcdir}/regex_grep_matcher.tcc \\\n+\t${bits_srcdir}/regex_nfa.h \\\n+\t${bits_srcdir}/regex_nfa.tcc \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\"}, {"sha": "631561c585e4f571b1a50e33d6efd1a624a112e7", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -361,6 +361,15 @@ bits_headers = \\\n \t${bits_srcdir}/postypes.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n+\t${bits_srcdir}/regex.h \\\n+\t${bits_srcdir}/regex_compiler.h \\\n+\t${bits_srcdir}/regex_constants.h \\\n+\t${bits_srcdir}/regex_cursor.h \\\n+\t${bits_srcdir}/regex_error.h \\\n+\t${bits_srcdir}/regex_grep_matcher.h \\\n+\t${bits_srcdir}/regex_grep_matcher.tcc \\\n+\t${bits_srcdir}/regex_nfa.h \\\n+\t${bits_srcdir}/regex_nfa.tcc \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\"}, {"sha": "75c99a747abd76ca203e7206c08e0b8172baef01", "filename": "libstdc++-v3/include/bits/regex.h", "status": "added", "additions": 2427, "deletions": 0, "changes": 2427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,2427 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+\n+/**\n+ * @defgroup regex Regular Expressions\n+ * A facility for performing regular expression pattern matching.\n+ */\n+ //@{\n+\n+  // [7.7] Class regex_traits\n+  /**\n+   * @brief Describes aspects of a regular expression.\n+   *\n+   * A regular expression traits class that satisfies the requirements of \n+   * section [28.7].\n+   *\n+   * The class %regex is parameterized around a set of related types and\n+   * functions used to complete the definition of its semantics.  This class\n+   * satisfies the requirements of such a traits class.\n+   */\n+  template<typename _Ch_type>\n+    struct regex_traits\n+    {\n+    public:\n+      typedef _Ch_type                     char_type;\n+      typedef std::basic_string<char_type> string_type;\n+      typedef std::locale                  locale_type;\n+      typedef std::ctype_base::mask        char_class_type;\n+\n+    public:\n+      /**\n+       * @brief Constructs a default traits object.\n+       */\n+      regex_traits()\n+      { }\n+      \n+      /**\n+       * @brief Gives the length of a C-style string starting at @p __p.\n+       *\n+       * @param __p a pointer to the start of a character sequence.\n+       *\n+       * @returns the number of characters between @p *__p and the first\n+       * default-initialized value of type @p char_type.  In other words, uses\n+       * the C-string algorithm for determining the length of a sequence of\n+       * characters.\n+       */\n+      static std::size_t\n+      length(const char_type* __p)\n+      { return string_type::traits_type::length(__p); }\n+\n+      /**\n+       * @brief Performs the identity translation.\n+       *\n+       * @param c A character to the locale-specific character set.\n+       *\n+       * @returns c.\n+       */\n+      char_type\n+      translate(char_type __c) const\n+      { return __c; }\n+      \n+      /**\n+       * @brief Translates a character into a case-insensitive equivalent.\n+       *\n+       * @param c A character to the locale-specific character set.\n+       *\n+       * @returns the locale-specific lower-case equivalent of c.\n+       * @throws std::bad_cast if the imbued locale does not support the ctype\n+       *         facet.\n+       */\n+      char_type\n+      translate_nocase(char_type __c) const\n+      {\n+\tusing std::ctype;\n+\tusing std::use_facet;\n+\treturn use_facet<ctype<char_type> >(_M_locale).tolower(__c);\n+      }\n+      \n+      /**\n+       * @brief Gets a sort key for a character sequence.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * Returns a sort key for the character sequence designated by the\n+       * iterator range [F1, F2) such that if the character sequence [G1, G2)\n+       * sorts before the character sequence [H1, H2) then\n+       * v.transform(G1, G2) < v.transform(H1, H2).\n+       *\n+       * What this really does is provide a more efficient way to compare a\n+       * string to multiple other strings in locales with fancy collation\n+       * rules and equivalence classes.\n+       *\n+       * @returns a locale-specific sort key equivalent to the input range.\n+       *\n+       * @throws std::bad_cast if the current locale does not have a collate\n+       *         facet.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        transform(_Fwd_iter __first, _Fwd_iter __last) const\n+        {\n+\t  using std::collate;\n+\t  using std::use_facet;\n+\t  const collate<_Ch_type>& __c(use_facet<\n+\t\t\t\t       collate<_Ch_type> >(_M_locale));\n+\t  string_type __s(__first, __last);\n+\t  return __c.transform(__s.data(), __s.data() + __s.size());\n+\t}\n+\n+      /**\n+       * @brief Gets a sort key for a character sequence, independant of case.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==\n+       * typeid(collate_byname<_Ch_type>) and the form of the sort key\n+       * returned by collate_byname<_Ch_type>::transform(first, last) is known\n+       * and can be converted into a primary sort key then returns that key,\n+       * otherwise returns an empty string.\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        transform_primary(_Fwd_iter __first, _Fwd_iter __last) const\n+        { return string_type(); }\n+\n+      /**\n+       * @brief Gets a collation element by name.\n+       *\n+       * @param first beginning of the collation element name.\n+       * @param last  one-past-the-end of the collation element name.\n+       * \n+       * @returns a sequence of one or more characters that represents the\n+       * collating element consisting of the character sequence designated by\n+       * the iterator range [first, last). Returns an empty string if the\n+       * character sequence is not a valid collating element.\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const\n+        { return string_type(); }\n+\n+      /**\n+       * @brief Maps one or more characters to a named character\n+       *        classification.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       * @param icase ignores the case of the classification name.\n+       *\n+       * @returns an unspecified value that represents the character\n+       * classification named by the character sequence designated by the\n+       * iterator range [first, last). If @p icase is true, the returned mask\n+       * identifies the classification regardless of the case of the characters\n+       * to be matched (for example, [[:lower:]] is the same as [[:alpha:]]),\n+       * otherwise a case-dependant classification is returned.  The value\n+       * returned shall be independent of the case of the characters in the\n+       * character sequence. If the name is not recognized then returns a value\n+       * that compares equal to 0.\n+       *\n+       * At least the following names (or their wide-character equivalent) are\n+       * supported.\n+       * - d\n+       * - w\n+       * - s\n+       * - alnum\n+       * - alpha\n+       * - blank\n+       * - cntrl\n+       * - digit\n+       * - graph\n+       * - lower\n+       * - print\n+       * - punct\n+       * - space\n+       * - upper\n+       * - xdigit\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        char_class_type\n+        lookup_classname(_Fwd_iter __first, _Fwd_iter __last,\n+\t                 bool __icase = false) const\n+\t{ return 0; }\n+\n+      /**\n+       * @brief Determines if @p c is a member of an identified class.\n+       *\n+       * @param c a character.\n+       * @param f a class type (as returned from lookup_classname).\n+       *\n+       * @returns true if the character @p c is a member of the classification\n+       * represented by @p f, false otherwise.\n+       *\n+       * @throws std::bad_cast if the current locale does not have a ctype\n+       *         facet.\n+       */\n+      bool\n+      isctype(_Ch_type __c, char_class_type __f) const;\n+\n+      /**\n+       * @brief Converts a digit to an int.\n+       *\n+       * @param ch    a character representing a digit.\n+       * @param radix the radix if the numeric conversion (limited to 8, 10,\n+       *              or 16).\n+       * \n+       * @returns the value represented by the digit ch in base radix if the\n+       * character ch is a valid digit in base radix; otherwise returns -1.\n+       */\n+      int\n+      value(_Ch_type __ch, int __radix) const;\n+      \n+      /**\n+       * @brief Imbues the regex_traits object with a copy of a new locale.\n+       *\n+       * @param loc A locale.\n+       *\n+       * @returns a copy of the previous locale in use by the regex_traits\n+       *          object.\n+       *\n+       * @note Calling imbue with a different locale than the one currently in\n+       *       use invalidates all cached data held by *this.\n+       */\n+      locale_type\n+      imbue(locale_type __loc)\n+      {\n+\tstd::swap(_M_locale, __loc);\n+\treturn __loc;\n+      }\n+      \n+      /**\n+       * @brief Gets a copy of the current locale in use by the regex_traits\n+       * object.\n+       */\n+      locale_type\n+      getloc() const\n+      { return _M_locale; }\n+      \n+    protected:\n+      locale_type _M_locale;\n+    };\n+\n+  template<typename _Ch_type>\n+    bool\n+    regex_traits<_Ch_type>::\n+    isctype(_Ch_type __c, char_class_type __f) const\n+    {\n+      using std::ctype;\n+      using std::use_facet;\n+      const ctype<_Ch_type>& __ctype(use_facet<\n+\t\t\t\t     ctype<_Ch_type> >(_M_locale));\n+      \n+      if (__ctype.is(__c, __f))\n+\treturn true;\n+      \n+      // special case of underscore in [[:w:]]\n+      if (__c == __ctype.widen('_'))\n+\t{\n+\t  const char __wb[] = \"w\";\n+\t  char_class_type __wt = this->lookup_classname(__wb,\n+\t\t\t\t\t\t\t__wb + sizeof(__wb));\n+\t  if (__f | __wt)\n+\t    return true;\n+\t}\n+    \n+      // special case of [[:space:]] in [[:blank:]]\n+      if (__ctype.is(std::ctype_base::space, __c))\n+\t{\n+\t  const char __bb[] = \"blank\";\n+\t  char_class_type __bt = this->lookup_classname(__bb,\n+\t\t\t\t\t\t\t__bb + sizeof(__bb));\n+\t  if (__f | __bt)\n+\t    return true;\n+\t}\n+      \n+      return false;\n+    }\n+\n+  template<typename _Ch_type>\n+    int\n+    regex_traits<_Ch_type>::\n+    value(_Ch_type __ch, int __radix) const\n+    {\n+      std::basic_istringstream<_Ch_type> __is(string_type(1, __ch));\n+      int __v;\n+      if (__radix == 8)\n+\t__is >> std::oct;\n+      else if (__radix == 16)\n+\t__is >> std::hex;\n+      __is >> __v;\n+      return __is.fail() ? -1 : __v;\n+    }\n+\n+  // [7.8] Class basic_regex\n+  /**\n+   * Objects of specializations of this class represent regular expressions\n+   * constructed from sequences of character type @p _Ch_type.\n+   *\n+   * Storage for the regular expression is allocated and deallocated as\n+   * necessary by the member functions of this class.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type> >\n+    class basic_regex\n+    {\n+    public:\n+      // types:\n+      typedef _Ch_type                            value_type;\n+      typedef regex_constants::syntax_option_type flag_type;\n+      typedef typename _Rx_traits::locale_type    locale_type;\n+      typedef typename _Rx_traits::string_type    string_type;\n+\n+      /**\n+       * @name Constants\n+       * std [28.8.1](1)\n+       * @todo These should be constexpr.\n+       */\n+      //@{\n+      static const regex_constants::syntax_option_type icase\n+        = regex_constants::icase;\n+      static const regex_constants::syntax_option_type nosubs\n+        = regex_constants::nosubs;\n+      static const regex_constants::syntax_option_type optimize\n+        = regex_constants::optimize;\n+      static const regex_constants::syntax_option_type collate\n+        = regex_constants::collate;\n+      static const regex_constants::syntax_option_type ECMAScript\n+        = regex_constants::ECMAScript;\n+      static const regex_constants::syntax_option_type basic\n+        = regex_constants::basic;\n+      static const regex_constants::syntax_option_type extended\n+        = regex_constants::extended;\n+      static const regex_constants::syntax_option_type awk\n+        = regex_constants::awk;\n+      static const regex_constants::syntax_option_type grep\n+        = regex_constants::grep;\n+      static const regex_constants::syntax_option_type egrep\n+        = regex_constants::egrep;\n+      //@}\n+\n+      // [7.8.2] construct/copy/destroy\n+      /**\n+       * Constructs a basic regular expression that does not match any\n+       * character sequence.\n+       */\n+      basic_regex()\n+      : _M_flags(regex_constants::ECMAScript),\n+        _M_automaton(__regex::__compile<const _Ch_type*, _Rx_traits>(0, 0,\n+                     _M_traits, _M_flags))\n+      { }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the sequence\n+       * [p, p + char_traits<_Ch_type>::length(p)) interpreted according to the\n+       * flags in @p f.\n+       *\n+       * @param p A pointer to the start of a C-style null-terminated string\n+       *          containing a regular expression.\n+       * @param f Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      explicit\n+      basic_regex(const _Ch_type* __p,\n+\t\t  flag_type __f = regex_constants::ECMAScript)\n+      : _M_flags(__f),\n+        _M_automaton(__regex::__compile(__p, __p + _Rx_traits::length(__p),\n+        \t\t\t\t_M_traits, _M_flags))\n+      { }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the sequence\n+       * [p, p + len) interpreted according to the flags in @p f.\n+       *\n+       * @param p   A pointer to the start of a string containing a regular\n+       *            expression.\n+       * @param len The length of the string containing the regular expression.\n+       * @param f   Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)\n+      : _M_flags(__f),\n+        _M_automaton(__regex::__compile(__p, __p + __len, _M_traits, _M_flags))\n+      { }\n+\n+      /**\n+       * @brief Copy-constructs a basic regular expression.\n+       *\n+       * @param rhs A @p regex object.\n+       */\n+      basic_regex(const basic_regex& __rhs)\n+      : _M_flags(__rhs._M_flags), _M_traits(__rhs._M_traits),\n+        _M_automaton(__rhs._M_automaton)\n+      { }\n+\n+      /**\n+       * @brief Move-constructs a basic regular expression.\n+       *\n+       * @param rhs A @p regex object.\n+       */\n+      basic_regex(const basic_regex&& __rhs)\n+      : _M_flags(__rhs._M_flags), _M_traits(__rhs._M_traits),\n+        _M_automaton(std::move(__rhs._M_automaton))\n+      { }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the string\n+       * @p s interpreted according to the flags in @p f.\n+       *\n+       * @param s A string containing a regular expression.\n+       * @param f Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p s is not a valid regular expression.\n+       */\n+      template<typename _Ch_traits, typename _Ch_alloc>\n+        explicit\n+        basic_regex(const std::basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\t    flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f),\n+\t  _M_automaton(__regex::__compile(__s.begin(), __s.end(),\n+\t  \t\t\t\t  _M_traits, _M_flags))\n+        { }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the range\n+       * [first, last) interpreted according to the flags in @p f.\n+       *\n+       * @param first The start of a range containing a valid regular\n+       *              expression.\n+       * @param last  The end of a range containing a valid regular\n+       *              expression.\n+       * @param f     The format flags of the regular expression.\n+       *\n+       * @throws regex_error if @p [first, last) is not a valid regular\n+       *         expression.\n+       */\n+      template<typename _InputIterator>\n+        basic_regex(_InputIterator __first, _InputIterator __last, \n+\t\t    flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f),\n+\t  _M_automaton(__regex::__compile(__first, __last, _M_traits, _M_flags))\n+        { }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from an initializer list.\n+       *\n+       * @param l  The initializer list.\n+       * @param f  The format flags of the regular expression.\n+       *\n+       * @throws regex_error if @p l is not a valid regular expression.\n+       */\n+      basic_regex(initializer_list<_Ch_type> __l,\n+\t\t  flag_type __f = regex_constants::ECMAScript)\n+      : _M_flags(__f),\n+        _M_automaton(__regex::__compile(__l.begin(), __l.end(),\n+        \t\t\t\t_M_traits, _M_flags))\n+      { }\n+\n+      /**\n+       * @brief Destroys a basic regular expression.\n+       */\n+      ~basic_regex()\n+      { }\n+      \n+      /**\n+       * @brief Assigns one regular expression to another.\n+       */\n+      basic_regex&\n+      operator=(const basic_regex& __rhs)\n+      { return this->assign(__rhs); }\n+\n+      /**\n+       * @brief Move-assigns one regular expression to another.\n+       */\n+      basic_regex&\n+      operator=(basic_regex&& __rhs)\n+      { return this->assign(std::move(__rhs)); }\n+\n+      /**\n+       * @brief Replaces a regular expression with a new one constructed from\n+       * a C-style null-terminated string.\n+       *\n+       * @param A pointer to the start of a null-terminated C-style string\n+       *        containing a regular expression.\n+       */\n+      basic_regex&\n+      operator=(const _Ch_type* __p)\n+      { return this->assign(__p, flags()); }\n+      \n+      /**\n+       * @brief Replaces a regular expression with a new one constructed from\n+       * a string.\n+       *\n+       * @param A pointer to a string containing a regular expression.\n+       */\n+      template<typename _Ch_typeraits, typename _Allocator>\n+        basic_regex&\n+        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s)\n+        { return this->assign(__s, flags()); }\n+\n+      // [7.8.3] assign\n+      /**\n+       * @brief the real assignment operator.\n+       *\n+       * @param rhs Another regular expression object.\n+       */\n+      basic_regex&\n+      assign(const basic_regex& __rhs)\n+      {\n+\tbasic_regex __tmp(__rhs);\n+\tthis->swap(__tmp);\n+\treturn *this;\n+      }\n+      \n+      /**\n+       * @brief The move-assignment operator.\n+       *\n+       * @param rhs Another regular expression object.\n+       */\n+      basic_regex&\n+      assign(basic_regex&& __rhs)\n+      {\n+\tbasic_regex __tmp(std::move(__rhs));\n+\tthis->swap(__tmp);\n+\treturn *this;\n+      }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a\n+       * C-style null-terminated string containing a regular expression\n+       * pattern.\n+       *\n+       * @param p     A pointer to a C-style null-terminated string containing\n+       *              a regular expression pattern.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      basic_regex&\n+      assign(const _Ch_type* __p,\n+\t     flag_type __flags = regex_constants::ECMAScript)\n+      { return this->assign(string_type(__p), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a\n+       * C-style string containing a regular expression pattern.\n+       *\n+       * @param p     A pointer to a C-style string containing a\n+       *              regular expression pattern.\n+       * @param len   The length of the regular expression pattern string.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      basic_regex&\n+      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)\n+      { return this->assign(string_type(__p, __len), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a \n+       * string containing a regular expression pattern.\n+       *\n+       * @param s     A string containing a regular expression pattern.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      template<typename _Ch_typeraits, typename _Allocator>\n+        basic_regex&\n+        assign(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s,\n+\t       flag_type __f = regex_constants::ECMAScript)\n+        { \n+\t  basic_regex __tmp(__s, __f);\n+\t  this->swap(__tmp);\n+\t  return *this;\n+\t}\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object.\n+       *\n+       * @param first The start of a range containing a valid regular\n+       *              expression.\n+       * @param last  The end of a range containing a valid regular\n+       *              expression.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * the object remains unchanged.\n+       */\n+      template<typename _InputIterator>\n+        basic_regex&\n+        assign(_InputIterator __first, _InputIterator __last,\n+\t       flag_type __flags = regex_constants::ECMAScript)\n+        { return this->assign(string_type(__first, __last), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object.\n+       *\n+       * @param l     An initializer list representing a regular expression.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if @p l does not contain a valid regular\n+       * expression pattern interpreted according to @p flags.  If regex_error\n+       * is thrown, the object remains unchanged.\n+       */\n+      basic_regex&\n+      assign(initializer_list<_Ch_type> __l,\n+\t     flag_type __f = regex_constants::ECMAScript)\n+      { return this->assign(__l.begin(), __l.end(), __f); }\n+\n+      // [7.8.4] const operations\n+      /**\n+       * @brief Gets the number of marked subexpressions within the regular\n+       * expression.\n+       */\n+      unsigned int\n+      mark_count() const\n+      { return _M_automaton->_M_sub_count() - 1; }\n+      \n+      /**\n+       * @brief Gets the flags used to construct the regular expression\n+       * or in the last call to assign().\n+       */\n+      flag_type\n+      flags() const\n+      { return _M_flags; }\n+      \n+      // [7.8.5] locale\n+      /**\n+       * @brief Imbues the regular expression object with the given locale.\n+       *\n+       * @param loc A locale.\n+       */\n+      locale_type\n+      imbue(locale_type __loc)\n+      { return _M_traits.imbue(__loc); }\n+      \n+      /**\n+       * @brief Gets the locale currently imbued in the regular expression\n+       *        object.\n+       */\n+      locale_type\n+      getloc() const\n+      { return _M_traits.getloc(); }\n+      \n+      // [7.8.6] swap\n+      /**\n+       * @brief Swaps the contents of two regular expression objects.\n+       *\n+       * @param rhs Another regular expression object.\n+       */\n+      void\n+      swap(basic_regex& __rhs)\n+      {\n+\tstd::swap(_M_flags,     __rhs._M_flags);\n+\tstd::swap(_M_traits,    __rhs._M_traits);\n+\tstd::swap(_M_automaton, __rhs._M_automaton);\n+      }\n+\n+#ifdef _GLIBCXX_DEBUG\n+      void\n+      _M_dot(std::ostream& __ostr)\n+      { _M_automaton->_M_dot(__ostr); }\n+#endif\n+      \n+      const __regex::_AutomatonPtr&\n+      _M_get_automaton() const\n+      { return _M_automaton; }\n+\n+    protected:\n+      flag_type              _M_flags;\n+      _Rx_traits             _M_traits;\n+      __regex::_AutomatonPtr _M_automaton;\n+    };\n+  \n+  /** @brief Standard regular expressions. */\n+  typedef basic_regex<char>    regex;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  /** @brief Standard wide-character regular expressions. */\n+  typedef basic_regex<wchar_t> wregex;\n+#endif\n+\n+\n+  // [7.8.6] basic_regex swap\n+  /**\n+   * @brief Swaps the contents of two regular expression objects.\n+   * @param lhs First regular expression.\n+   * @param rhs Second regular expression.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits>\n+    inline void\n+    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,\n+\t basic_regex<_Ch_type, _Rx_traits>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+\n+  // [7.9] Class template sub_match\n+  /**\n+   * A sequence of characters matched by a particular marked sub-expression.\n+   *\n+   * An object of this class is essentially a pair of iterators marking a\n+   * matched subexpression within a regular expression pattern match. Such\n+   * objects can be converted to and compared with std::basic_string objects\n+   * of a similar base character type as the pattern matched by the regular\n+   * expression.\n+   *\n+   * The iterators that make up the pair are the usual half-open interval\n+   * referencing the actual original pattern matched.\n+   */\n+  template<typename _BiIter>\n+    class sub_match : public std::pair<_BiIter, _BiIter>\n+    {\n+    public:\n+      typedef typename iterator_traits<_BiIter>::value_type      value_type;\n+      typedef typename iterator_traits<_BiIter>::difference_type\n+                                                            difference_type;\n+      typedef _BiIter                                              iterator;\n+      typedef std::basic_string<value_type>                     string_type;\n+\n+    public:\n+      bool matched;\n+      \n+      /**\n+       * Gets the length of the matching sequence.\n+       */\n+      difference_type\n+      length() const\n+      { return this->matched ? std::distance(this->first, this->second) : 0; }\n+\n+      /**\n+       * @brief Gets the matching sequence as a string.\n+       *\n+       * @returns the matching sequence as a string.\n+       *\n+       * This is the implicit conversion operator.  It is identical to the\n+       * str() member function except that it will want to pop up in\n+       * unexpected places and cause a great deal of confusion and cursing\n+       * from the unwary.\n+       */\n+      operator string_type() const\n+      {\n+\treturn this->matched\n+\t  ? string_type(this->first, this->second)\n+\t  : string_type();\n+      }\n+      \n+      /**\n+       * @brief Gets the matching sequence as a string.\n+       *\n+       * @returns the matching sequence as a string.\n+       */\n+      string_type\n+      str() const\n+      {\n+\treturn this->matched\n+\t  ? string_type(this->first, this->second)\n+\t  : string_type();\n+      }\n+      \n+      /**\n+       * @brief Compares this and another matched sequence.\n+       *\n+       * @param s Another matched sequence to compare to this one.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const sub_match& __s) const\n+      { return this->str().compare(__s.str()); }\n+\n+      /**\n+       * @brief Compares this sub_match to a string.\n+       *\n+       * @param s A string to compare to this sub_match.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const string_type& __s) const\n+      { return this->str().compare(__s); }\n+      \n+      /**\n+       * @brief Compares this sub_match to a C-style string.\n+       *\n+       * @param s A C-style string to compare to this sub_match.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const value_type* __s) const\n+      { return this->str().compare(__s); }\n+    };\n+  \n+  \n+  /** @brief Standard regex submatch over a C-style null-terminated string. */\n+  typedef sub_match<const char*>             csub_match;\n+  /** @brief Standard regex submatch over a standard string. */\n+  typedef sub_match<string::const_iterator>  ssub_match;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  /** @brief Regex submatch over a C-style null-terminated wide string. */\n+  typedef sub_match<const wchar_t*>          wcsub_match;\n+  /** @brief Regex submatch over a standard wide string. */\n+  typedef sub_match<wstring::const_iterator> wssub_match;\n+#endif\n+\n+  // [7.9.2] sub_match non-member operators\n+  \n+  /**\n+   * @brief Tests the equivalence of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator==(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  /**\n+   * @brief Tests the inequivalence of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator!=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) != 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator<(const sub_match<_BiIter>& __lhs,\n+\t      const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator<=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator>=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator>(const sub_match<_BiIter>& __lhs,\n+\t      const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  /**\n+   * @brief Tests the equivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator==(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator!=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator<(const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+     { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator>(const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type, \n+\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator>=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator<=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Tests the equivalence of a C string and a regular expression\n+   *        submatch.\n+   * @param lhs A C string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of an iterator value and a regular\n+   *        expression submatch.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A pointer to a string?\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A pointer to a string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Tests the equivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Inserts a matched string into an output stream.\n+   *\n+   * @param os The output stream.\n+   * @param m  A submatch string.\n+   *\n+   * @returns the output stream with the submatch string inserted.\n+   */\n+  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>\n+    inline\n+    basic_ostream<_Ch_type, _Ch_traits>&\n+    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,\n+\t       const sub_match<_Bi_iter>& __m)\n+    { return __os << __m.str(); }\n+\n+  // [7.10] Class template match_results\n+\n+  /*\n+   * Special sub_match object representing an unmatched sub-expression.\n+   */\n+  template<typename _Bi_iter>\n+    inline const sub_match<_Bi_iter>&\n+    __unmatched_sub()\n+    {\n+      static const sub_match<_Bi_iter> __unmatched = sub_match<_Bi_iter>();\n+      return __unmatched;\n+    }\n+\n+  /**\n+   * @brief The results of a match or search operation.\n+   *\n+   * A collection of character sequences representing the result of a regular\n+   * expression match.  Storage for the collection is allocated and freed as\n+   * necessary by the member functions of class template match_results.\n+   *\n+   * This class satisfies the Sequence requirements, with the exception that\n+   * only the operations defined for a const-qualified Sequence are supported.\n+   *\n+   * The sub_match object stored at index 0 represents sub-expression 0, i.e.\n+   * the whole match. In this case the %sub_match member matched is always true.\n+   * The sub_match object stored at index n denotes what matched the marked\n+   * sub-expression n within the matched expression. If the sub-expression n\n+   * participated in a regular expression match then the %sub_match member\n+   * matched evaluates to true, and members first and second denote the range\n+   * of characters [first, second) which formed that match. Otherwise matched\n+   * is false, and members first and second point to the end of the sequence\n+   * that was searched.\n+   *\n+   * @nosubgrouping\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Allocator = allocator<sub_match<_Bi_iter> > >\n+    class match_results\n+    : private std::vector<std::sub_match<_Bi_iter>, _Allocator>\n+    {\n+    private:\n+      /*\n+       * The vector base is empty if this does not represent a successful match.\n+       * Otherwise it contains n+3 elements where n is the number of marked\n+       * sub-expressions:\n+       * [0] entire match\n+       * [1] 1st marked subexpression\n+       * ...\n+       * [n] nth marked subexpression\n+       * [n+1] prefix\n+       * [n+2] suffix\n+       */\n+      typedef std::vector<std::sub_match<_Bi_iter>, _Allocator>\n+                                                              _Base_type;\n+\n+    public:\n+      /**\n+       * @name 10.? Public Types\n+       */\n+      //@{\n+      typedef sub_match<_Bi_iter>                             value_type;\n+      typedef const value_type&                               const_reference;\n+      typedef const_reference                                 reference;\n+      typedef typename _Base_type::const_iterator             const_iterator;\n+      typedef const_iterator                                  iterator;\n+      typedef typename std::iterator_traits<_Bi_iter>::difference_type\n+                                                              difference_type;\n+      /* TODO: needs allocator_traits */\n+      typedef typename _Allocator::size_type                  size_type;\n+      typedef _Allocator                                      allocator_type;\n+      typedef typename std::iterator_traits<_Bi_iter>::value_type\n+                                                              char_type;\n+      typedef std::basic_string<char_type>                    string_type;\n+      //@}\n+  \n+    public:\n+      /**\n+       * @name 10.1 Construction, Copying, and Destruction\n+       */\n+      //@{\n+\n+      /**\n+       * @brief Constructs a default %match_results container.\n+       * @post size() returns 0 and str() returns an empty string.\n+       */\n+      explicit\n+      match_results(const _Allocator& __a = _Allocator())\n+      : _Base_type(__a)\n+      { }\n+\n+      /**\n+       * @brief Copy constructs a %match_results.\n+       */\n+      match_results(const match_results& __rhs)\n+      : _Base_type(__rhs)\n+      { }\n+\n+      /**\n+       * @brief Assigns rhs to *this.\n+       */\n+      match_results&\n+      operator=(const match_results __rhs)\n+      {\n+\tmatch_results(__rhs).swap(*this);\n+\treturn *this;\n+      }\n+\n+      /**\n+       * @brief Destroys a %match_results object.\n+       */\n+      ~match_results()\n+      { }\n+      \n+      //@}\n+\n+      /**\n+       * @name 10.2 Size\n+       */\n+      //@{\n+\n+      /**\n+       * @brief Gets the number of matches and submatches.\n+       *\n+       * The number of matches for a given regular expression will be either 0\n+       * if there was no match or mark_count() + 1 if a match was successful.\n+       * Some matches may be empty.\n+       *\n+       * @returns the number of matches found.\n+       */\n+      size_type\n+      size() const\n+      {\n+      \tsize_type __size = _Base_type::size();\n+      \treturn (__size && _Base_type::operator[](0).matched) ? __size - 2 : 0;\n+      }\n+      \n+      size_type\n+      max_size() const\n+      { return _Base_type::max_size(); }\n+\n+      /**\n+       * @brief Indicates if the %match_results contains no results.\n+       * @retval true The %match_results object is empty.\n+       * @retval false The %match_results object is not empty.\n+       */\n+      bool\n+      empty() const\n+      { return _Base_type::empty(); }\n+      \n+      //@}\n+\n+      /**\n+       * @name 10.3 Element Access\n+       */\n+      //@{\n+\n+      /**\n+       * @brief Gets the length of the indicated submatch.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function returns the length of the indicated submatch, or the\n+       * length of the entire match if @p sub is zero (the default).\n+       */\n+      difference_type\n+      length(size_type __sub = 0) const\n+      { return this[__sub].length(); }\n+\n+      /**\n+       * @brief Gets the offset of the beginning of the indicated submatch.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function returns the offset from the beginning of the target\n+       * sequence to the beginning of the submatch, unless the value of @p sub\n+       * is zero (the default), in which case this function returns the offset\n+       * from the beginning of the target sequence to the beginning of the\n+       * match.\n+       *\n+       * Returns -1 if @p sub is out of range.\n+       */\n+      difference_type\n+      position(size_type __sub = 0) const\n+      {\n+\treturn __sub < size() ? std::distance(this->prefix().first,\n+\t\t\t\t\t      (*this)[__sub].first) : -1;\n+      }\n+\n+      /**\n+       * @brief Gets the match or submatch converted to a string type.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function gets the submatch (or match, if @p sub is zero) extracted\n+       * from the target range and converted to the associated string type.\n+       */\n+      string_type\n+      str(size_type __sub = 0) const\n+      { return (*this)[__sub].str(); }\n+      \n+      /**\n+       * @brief Gets a %sub_match reference for the match or submatch.\n+       * @param sub indicates the submatch.\n+       *\n+       * This function gets a reference to the indicated submatch, or the entire\n+       * match if @p sub is zero.\n+       *\n+       * If @p sub >= size() then this function returns a %sub_match with a\n+       * special value indicating no submatch.\n+       */\n+      const_reference\n+      operator[](size_type __sub) const\n+      { \n+      \treturn __sub < size()\n+\t       ?  _Base_type::operator[](__sub)\n+\t       : __unmatched_sub<_Bi_iter>();\n+      }\n+\n+      /**\n+       * @brief Gets a %sub_match representing the match prefix.\n+       *\n+       * This function gets a reference to a %sub_match object representing the\n+       * part of the target range between the start of the target range and the\n+       * start of the match.\n+       */\n+      const_reference\n+      prefix() const\n+      {\n+      \treturn !empty()\n+      \t       ? _Base_type::operator[](_Base_type::size() - 2)\n+\t       : __unmatched_sub<_Bi_iter>();\n+      }\n+\n+      /**\n+       * @brief Gets a %sub_match representing the match suffix.\n+       *\n+       * This function gets a reference to a %sub_match object representing the\n+       * part of the target range between the end of the match and the end of\n+       * the target range.\n+       */\n+      const_reference\n+      suffix() const\n+      {\n+      \treturn !empty()\n+      \t       ? _Base_type::operator[](_Base_type::size() - 1)\n+\t       : __unmatched_sub<_Bi_iter>();\n+      }\n+\n+      /**\n+       * @brief Gets an iterator to the start of the %sub_match collection.\n+       */\n+      const_iterator\n+      begin() const\n+      { return _Base_type::begin(); }\n+      \n+      /**\n+       * @brief Gets an iterator to the start of the %sub_match collection.\n+       */\n+      const_iterator\n+      cbegin() const\n+      { return _Base_type::cbegin(); }\n+\n+      /**\n+       * @brief Gets an iterator to one-past-the-end of the collection.\n+       */\n+      const_iterator\n+      end() const\n+      {\n+      \treturn !empty()\n+      \t       ? _Base_type::end() - 2\n+\t       : _Base_type::end();\n+      }\n+      \n+      /**\n+       * @brief Gets an iterator to one-past-the-end of the collection.\n+       */\n+      const_iterator\n+      cend() const\n+      {\n+      \treturn !empty()\n+      \t       ? _Base_type::cend() - 2\n+\t       : _Base_type::cend();\n+      }\n+\n+      //@}\n+\n+      /**\n+       * @name 10.4 Formatting\n+       *\n+       * These functions perform formatted substitution of the matched character\n+       * sequences into their target.  The format specifiers and escape sequences\n+       * accepted by these functions are determined by their @p flags parameter \n+       * as documented above.\n+       */\n+       //@{\n+\n+      /**\n+       * @todo Implement this function.\n+       */\n+      template<typename _Out_iter>\n+        _Out_iter\n+        format(_Out_iter __out, const string_type& __fmt,\n+\t       regex_constants::match_flag_type __flags\n+\t       = regex_constants::format_default) const\n+        { return __out; }\n+\n+      /**\n+       * @todo Implement this function.\n+       */\n+      string_type\n+      format(const string_type& __fmt,\n+\t     regex_constants::match_flag_type __flags\n+\t     = regex_constants::format_default) const;\n+\n+      //@} \n+\n+      /**\n+       * @name 10.5 Allocator\n+       */\n+      //@{ \n+\n+      /**\n+       * @brief Gets a copy of the allocator.\n+       */\n+      allocator_type\n+      get_allocator() const\n+      { return _Base_type::get_allocator(); }\n+      \n+      //@} \n+\n+      /**\n+       * @name 10.6 Swap\n+       */\n+       //@{ \n+\n+      /**\n+       * @brief Swaps the contents of two match_results.\n+       */\n+      void\n+      swap(match_results& __that)\n+      { _Base_type::swap(__that); }\n+      //@} \n+      \n+    private:\n+      friend class __regex::_SpecializedResults<_Bi_iter, _Allocator>;\n+    };\n+  \n+  typedef match_results<const char*>             cmatch;\n+  typedef match_results<string::const_iterator>  smatch;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef match_results<const wchar_t*>          wcmatch;\n+  typedef match_results<wstring::const_iterator> wsmatch;\n+#endif\n+\n+  // match_results comparisons\n+  /**\n+   * @brief Compares two match_results for equality.\n+   * @returns true if the two objects refer to the same match,\n+   * false otherwise.\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator>\n+    inline bool\n+    operator==(const match_results<_Bi_iter, _Allocator>& __m1,\n+\t       const match_results<_Bi_iter, _Allocator>& __m2);\n+\n+  /**\n+   * @brief Compares two match_results for inequality.\n+   * @returns true if the two objects do not refer to the same match,\n+   * false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Allocator>\n+    inline bool\n+    operator!=(const match_results<_Bi_iter, _Allocator>& __m1,\n+\t       const match_results<_Bi_iter, _Allocator>& __m2)\n+    { return !(__m1 == __m2); }\n+\n+  // [7.10.6] match_results swap\n+  /**\n+   * @brief Swaps two match results.\n+   * @param lhs A match result.\n+   * @param rhs A match result.\n+   *\n+   * The contents of the two match_results objects are swapped.\n+   */\n+  template<typename _Bi_iter, typename _Allocator>\n+    inline void\n+    swap(match_results<_Bi_iter, _Allocator>& __lhs,\n+\t match_results<_Bi_iter, _Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+  // [7.11.2] Function template regex_match\n+  /**\n+   * @name Matching, Searching, and Replacing\n+   */\n+  //@{\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and all of the character sequence [first, last).\n+   *\n+   * @param s     Start of the character sequence to match.\n+   * @param e     One-past-the-end of the character sequence to match.\n+   * @param m     The match results.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter                                 __s,\n+                _Bi_iter                                 __e,\n+                match_results<_Bi_iter, _Allocator>&     __m,\n+                const basic_regex<_Ch_type, _Rx_traits>& __re,\n+                regex_constants::match_flag_type         __flags\n+                               = regex_constants::match_default)\n+    {\n+      __regex::_AutomatonPtr __a = __re._M_get_automaton();\n+      __regex::_Automaton::_SizeT __sz = __a->_M_sub_count();\n+      __regex::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n+      __regex::_SpecializedResults<_Bi_iter, _Allocator> __r(__sz, __cs, __m);\n+      __regex::_Grep_matcher __matcher(__cs, __r, __a, __flags);\n+      return __m[0].matched;\n+    }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and all of the character sequence [first, last).\n+   *\n+   * @param first Beginning of the character sequence to match.\n+   * @param last  One-past-the-end of the character sequence to match.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter __first, _Bi_iter __last,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { \n+      match_results<_Bi_iter> __what;\n+      return regex_match(__first, __last, __what, __re, __flags);\n+    }\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and a C-style null-terminated string.\n+   *\n+   * @param s  The C-style null-terminated string to match.\n+   * @param m  The match results.\n+   * @param re The regular expression.\n+   * @param f  Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, typename _Allocator, typename _Rx_traits>\n+    inline bool\n+    regex_match(const _Ch_type* __s,\n+\t\tmatch_results<const _Ch_type*, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __f\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and a string.\n+   *\n+   * @param s     The string to match.\n+   * @param m     The match results.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _Ch_alloc,\n+\t   typename _Allocator, typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\tmatch_results<typename basic_string<_Ch_type, \n+\t\t_Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and a C-style null-terminated string.\n+   *\n+   * @param s  The C-style null-terminated string to match.\n+   * @param re The regular expression.\n+   * @param f  Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, class _Rx_traits>\n+    inline bool\n+    regex_match(const _Ch_type* __s,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __f\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and a string.\n+   *\n+   * @param s     [IN] The string to match.\n+   * @param re    [IN] The regular expression.\n+   * @param flags [IN] Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _Str_allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s.begin(), __s.end(), __re, __flags); }\n+\n+  // [7.11.3] Function template regex_search\n+  /**\n+   * Searches for a regular expression within a range.\n+   * @param first [IN]  The start of the string to search.\n+   * @param last  [IN]  One-past-the-end of the string to search.\n+   * @param m     [OUT] The match results.\n+   * @param re    [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   *\n+   * @throws an exception of type regex_error.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t match_results<_Bi_iter, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    { return false; }\n+\n+  /**\n+   * Searches for a regular expression within a range.\n+   * @param first [IN]  The start of the string to search.\n+   * @param last  [IN]  One-past-the-end of the string to search.\n+   * @param re    [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    {\n+      match_results<_Bi_iter> __what;\n+      return regex_search(__first, __last, __what, __re, __flags);\n+    }\n+\n+  /**\n+   * @brief Searches for a regular expression within a C-string.\n+   * @param s [IN]  A C-string to search for the regex.\n+   * @param m [OUT] The set of regex matches.\n+   * @param e [IN]  The regex to search for in @p s.\n+   * @param f [IN]  The search flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, class _Allocator, class _Rx_traits>\n+    inline bool\n+    regex_search(const _Ch_type* __s,\n+\t\t match_results<const _Ch_type*, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a C-string.\n+   * @param s [IN]  The C-string to search.\n+   * @param e [IN]  The regular expression to search for.\n+   * @param f [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(const _Ch_type* __s,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a string.\n+   * @param s     [IN]  The string to search.\n+   * @param e     [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @doctodo\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _String_allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(const basic_string<_Ch_type, _Ch_traits,\n+\t\t _String_allocator>& __s,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s.begin(), __s.end(), __e, __flags); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a string.\n+   * @param s [IN]  A C++ string to search for the regex.\n+   * @param m [OUT] The set of regex matches.\n+   * @param e [IN]  The regex to search for in @p s.\n+   * @param f [IN]  The search flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Ch_traits, typename _Ch_alloc,\n+\t   typename _Allocator, typename _Ch_type,\n+\t   typename _Rx_traits>\n+    inline bool\n+    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\t match_results<typename basic_string<_Ch_type,\n+\t\t _Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }\n+\n+  // std [28.11.4] Function template regex_replace\n+  /**\n+   * @doctodo\n+   * @param out\n+   * @param first\n+   * @param last\n+   * @param e\n+   * @param fmt\n+   * @param flags\n+   *\n+   * @returns out\n+   * @throws an exception of type regex_error.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Out_iter, typename _Bi_iter,\n+\t   typename _Rx_traits, typename _Ch_type>\n+    inline _Out_iter\n+    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    { return __out; }\n+\n+  /**\n+   * @doctodo\n+   * @param s\n+   * @param e\n+   * @param fmt\n+   * @param flags\n+   *\n+   * @returns a copy of string @p s with replacements.\n+   *\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Rx_traits, typename _Ch_type>\n+    inline basic_string<_Ch_type>\n+    regex_replace(const basic_string<_Ch_type>& __s,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      std::string __result;\n+      regex_replace(std::back_inserter(__result),\n+\t\t    __s.begin(), __s.end(), __e, __fmt, __flags);\n+      return __result;\n+    }\n+\n+  //@}\n+\n+  // std [28.12] Class template regex_iterator\n+  /**\n+   * An iterator adaptor that will provide repeated calls of regex_search over \n+   * a range until no more matches remain.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+    class regex_iterator\n+    {\n+    public:\n+      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;\n+      typedef match_results<_Bi_iter>            value_type;\n+      typedef std::ptrdiff_t                     difference_type;\n+      typedef const value_type*                  pointer;\n+      typedef const value_type&                  reference;\n+      typedef std::forward_iterator_tag          iterator_category;\n+\n+    public:\n+      /**\n+       * @brief Provides a singular iterator, useful for indicating\n+       * one-past-the-end of a range.\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator();\n+      \n+      /**\n+       * Constructs a %regex_iterator...\n+       * @param a  [IN] The start of a text range to search.\n+       * @param b  [IN] One-past-the-end of the text range to search.\n+       * @param re [IN] The regular expression to match.\n+       * @param m  [IN] Policy flags for match rules.\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n+\t\t     regex_constants::match_flag_type __m\n+\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * Copy constructs a %regex_iterator.\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator&\n+      operator=(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      bool\n+      operator==(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      bool\n+      operator!=(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      const value_type&\n+      operator*();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      const value_type*\n+      operator->();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator&\n+      operator++();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_iterator\n+      operator++(int);\n+      \n+    private:\n+      // these members are shown for exposition only:\n+      _Bi_iter                         begin;\n+      _Bi_iter                         end;\n+      const regex_type*                pregex;\n+      regex_constants::match_flag_type flags;\n+      match_results<_Bi_iter>          match;\n+    };\n+  \n+  typedef regex_iterator<const char*>             cregex_iterator;\n+  typedef regex_iterator<string::const_iterator>  sregex_iterator;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef regex_iterator<const wchar_t*>          wcregex_iterator;\n+  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;\n+#endif\n+\n+  // [7.12.2] Class template regex_token_iterator\n+  /**\n+   * Iterates over submatches in a range (or @a splits a text string).\n+   *\n+   * The purpose of this iterator is to enumerate all, or all specified,\n+   * matches of a regular expression within a text range.  The dereferenced\n+   * value of an iterator of this class is a std::sub_match object.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+    class regex_token_iterator\n+    {\n+    public:\n+      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;\n+      typedef sub_match<_Bi_iter>               value_type;\n+      typedef std::ptrdiff_t                    difference_type;\n+      typedef const value_type*                 pointer;\n+      typedef const value_type&                 reference;\n+      typedef std::forward_iterator_tag         iterator_category;\n+      \n+    public:\n+      /**\n+       * @brief Default constructs a %regex_token_iterator.\n+       * @todo Implement this function.\n+       * \n+       * A default-constructed %regex_token_iterator is a singular iterator\n+       * that will compare equal to the one-past-the-end value for any\n+       * iterator of the same type.\n+       */\n+      regex_token_iterator();\n+      \n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-end of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatch   [IN] Which submatch to return.  There are some\n+       *                        special values for this parameter:\n+       *                        - -1 each enumerated subexpression does NOT\n+       *                          match the regular expression (aka field\n+       *                          splitting)\n+       *                        - 0 the entire string matching the\n+       *                          subexpression is returned for each match\n+       *                          within the text.\n+       *                        - >0 enumerates only the indicated\n+       *                          subexpression from a match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       *\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n+\t\t\t   int __submatch = 0,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t   = regex_constants::match_default);\n+\n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-end of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatches [IN] A list of subexpressions to return for each\n+       *                        regular expression match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       *\n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t   const regex_type& __re,\n+\t\t\t   const std::vector<int>& __submatches,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-end of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatches [IN] A list of subexpressions to return for each\n+       *                        regular expression match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       \n+       * @todo Implement this function.\n+       * @doctodo\n+       */\n+      template<std::size_t _Nm>\n+        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t     const regex_type& __re,\n+\t\t\t     const int (&__submatches)[_Nm],\n+\t\t\t     regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * @brief Copy constructs a %regex_token_iterator.\n+       * @param rhs [IN] A %regex_token_iterator to copy.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Assigns a %regex_token_iterator to another.\n+       * @param rhs [IN] A %regex_token_iterator to copy.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator&\n+      operator=(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Compares a %regex_token_iterator to another for equality.\n+       * @todo Implement this function.\n+       */\n+      bool\n+      operator==(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Compares a %regex_token_iterator to another for inequality.\n+       * @todo Implement this function.\n+       */\n+      bool\n+      operator!=(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Dereferences a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      const value_type&\n+      operator*();\n+      \n+      /**\n+       * @brief Selects a %regex_token_iterator member.\n+       * @todo Implement this function.\n+       */\n+      const value_type*\n+      operator->();\n+      \n+      /**\n+       * @brief Increments a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator&\n+      operator++();\n+      \n+      /**\n+       * @brief Postincrements a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator\n+      operator++(int);\n+      \n+    private: // data members for exposition only:\n+      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> position_iterator;\n+\n+      position_iterator __position;\n+      const value_type* __result;\n+      value_type        __suffix;\n+      std::size_t       __n;\n+      std::vector<int>  __subs;\n+    };\n+\n+  /** @brief Token iterator for C-style NULL-terminated strings. */\n+  typedef regex_token_iterator<const char*>             cregex_token_iterator;\n+  /** @brief Token iterator for standard strings. */\n+  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  /** @brief Token iterator for C-style NULL-terminated wide strings. */\n+  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;\n+  /** @brief Token iterator for standard wide-character strings. */\n+  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;\n+#endif\n+  \n+  //@} // group regex\n+  \n+}\n+"}, {"sha": "1d12a2cc41175573cb7367406bf7e01f322915ae", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "added", "additions": 1111, "deletions": 0, "changes": 1111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,1111 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex_parser.h\n+ * This is an internal header file, included by other library headers.\n+ * You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+namespace __regex\n+{\n+  struct _Scanner_base\n+  {\n+    typedef unsigned int _StateT; // FIXME: replace these constanst with constexpr\n+\n+    static const _StateT _S_state_at_start    = 1 << 0;\n+    static const _StateT _S_state_in_brace    = 1 << 2;\n+    static const _StateT _S_state_in_bracket  = 1 << 3;\n+  };\n+\n+  //\n+  // @brief Scans an input range for regex tokens.\n+  //\n+  // The %_Scanner class interprets the regular expression pattern in the input\n+  // range passed to its constructor as a sequence of parse tokens passed to\n+  // the regular expression compiler.  The sequence of tokens provided depends\n+  // on the flag settings passed to the constructor:  different regular\n+  // expression gramars will interpret the same input pattern in syntactically\n+  // different ways.\n+  //\n+  template<typename _InputIterator>\n+    class _Scanner: public _Scanner_base\n+    {\n+    public:\n+      typedef _InputIterator                                        _IteratorT;\n+      typedef typename std::iterator_traits<_IteratorT>::value_type _CharT;\n+      typedef std::basic_string<_CharT>                             _StringT;\n+      typedef regex_constants::syntax_option_type                   _FlagT;\n+      typedef const std::ctype<_CharT>                              _CtypeT;\n+\n+      // Token types returned from the scanner.\n+      enum _TokenT\n+      {\n+\t_S_token_anychar,\n+\t_S_token_backref,\n+\t_S_token_bracket_begin,\n+\t_S_token_bracket_end,\n+\t_S_token_inverse_class,\n+\t_S_token_char_class_name,\n+\t_S_token_closure0,\n+\t_S_token_closure1,\n+\t_S_token_collelem_multi,\n+\t_S_token_collelem_single,\n+\t_S_token_collsymbol,\n+\t_S_token_comma,\n+\t_S_token_dash,\n+\t_S_token_dup_count,\n+\t_S_token_eof,\n+\t_S_token_equiv_class_name,\n+\t_S_token_interval_begin,\n+\t_S_token_interval_end,\n+\t_S_token_line_begin,\n+\t_S_token_line_end,\n+\t_S_token_opt,\n+\t_S_token_or,\n+\t_S_token_ord_char,\n+\t_S_token_quoted_char,\n+\t_S_token_subexpr_begin,\n+\t_S_token_subexpr_end,\n+\t_S_token_word_begin,\n+\t_S_token_word_end,\n+\t_S_token_unknown\n+      };\n+\n+    public:\n+      _Scanner(_IteratorT __begin, _IteratorT __end, _FlagT __flags,\n+\t       std::locale __loc)\n+      : _M_current(__begin) , _M_end(__end) , _M_flags(__flags),\n+        _M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(_S_state_at_start)\n+      { _M_advance(); }\n+\n+      void\n+      _M_advance();\n+\n+      _TokenT\n+      _M_token() const\n+      { return _M_curToken; }\n+\n+      const _StringT&\n+      _M_value() const\n+      { return _M_curValue; }\n+\n+#ifdef _GLIBCXX_DEBUG\n+      std::ostream&\n+      _M_print(std::ostream&);\n+#endif\n+\n+    private:\n+      void\n+      _M_eat_escape();\n+\n+      void\n+      _M_scan_in_brace();\n+\n+      void\n+      _M_scan_in_bracket();\n+\n+      void\n+      _M_eat_charclass();\n+\n+      void\n+      _M_eat_equivclass();\n+\n+      void\n+      _M_eat_collsymbol();\n+\n+    private:\n+      _IteratorT  _M_current;\n+      _IteratorT  _M_end;\n+      _FlagT      _M_flags;\n+      _CtypeT&    _M_ctype;\n+      _TokenT     _M_curToken;\n+      _StringT    _M_curValue;\n+      _StateT     _M_state;\n+    };\n+\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_advance()\n+    {\n+      if (_M_current == _M_end)\n+      {\n+\t_M_curToken = _S_token_eof;\n+\treturn;\n+      }\n+\n+      _CharT __c = *_M_current;\n+      if (_M_state & _S_state_in_bracket)\n+      {\n+\t_M_scan_in_bracket();\n+\treturn;\n+      }\n+      if (_M_state & _S_state_in_brace)\n+      {\n+\t_M_scan_in_brace();\n+\treturn;\n+      }\n+      else if (_M_state & _S_state_at_start && __c == _M_ctype.widen('^'))\n+      {\n+\t_M_curToken = _S_token_line_begin;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('$'))\n+      {\n+\t_M_curToken = _S_token_line_end;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('.'))\n+      {\n+\t_M_curToken = _S_token_anychar;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('*'))\n+      {\n+\t_M_curToken = _S_token_closure0;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('+'))\n+      {\n+\t_M_curToken = _S_token_closure1;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('|'))\n+      {\n+\t_M_curToken = _S_token_or;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('['))\n+      {\n+\t_M_curToken = _S_token_bracket_begin;\n+\t_M_state |= (_S_state_in_bracket | _S_state_at_start);\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (__c == _M_ctype.widen('\\\\'))\n+      {\n+\t_M_eat_escape();\n+\treturn;\n+      }\n+      else if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+      {\n+\tif (__c == _M_ctype.widen('('))\n+\t{\n+\t  _M_curToken = _S_token_subexpr_begin;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+\telse if (__c == _M_ctype.widen(')'))\n+\t{\n+\t  _M_curToken = _S_token_subexpr_end;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+\telse if (__c == _M_ctype.widen('{'))\n+\t{\n+\t  _M_curToken = _S_token_interval_begin;\n+\t  _M_state |= _S_state_in_brace;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      }\n+\n+      _M_curToken = _S_token_ord_char;\n+      _M_curValue.assign(1, __c);\n+      ++_M_current;\n+    }\n+\n+\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_scan_in_brace()\n+    {\n+      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n+      {\n+\t_M_curToken = _S_token_dup_count;\n+\t_M_curValue.assign(1, *_M_current);\n+\t++_M_current;\n+\twhile (_M_current != _M_end && _M_ctype.is(_CtypeT::digit, *_M_current))\n+\t{\n+\t  _M_curValue += *_M_current;\n+\t  ++_M_current;\n+\t}\n+\treturn;\n+      }\n+      else if (*_M_current == _M_ctype.widen(','))\n+      {\n+\t_M_curToken = _S_token_comma;\n+\t++_M_current;\n+\treturn;\n+      }\n+      if (_M_flags & (regex_constants::basic | regex_constants::grep))\n+      {\n+\tif (*_M_current == _M_ctype.widen('\\\\'))\n+\t{ _M_eat_escape(); }\n+      }\n+      else \n+      {\n+\tif (*_M_current == _M_ctype.widen('}'))\n+\t{\n+\t  _M_curToken = _S_token_interval_end;\n+\t  _M_state &= ~_S_state_in_brace;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      }\n+    }\n+\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_scan_in_bracket()\n+    {\n+      if (_M_state & _S_state_at_start && *_M_current == _M_ctype.widen('^'))\n+      {\n+\t_M_curToken = _S_token_inverse_class;\n+\t_M_state &= ~_S_state_at_start;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (*_M_current == _M_ctype.widen('['))\n+      {\n+\t++_M_current;\n+\tif (_M_current == _M_end)\n+\t{\n+\t  _M_curToken = _S_token_eof;\n+\t  return;\n+\t}\n+\n+\tif (*_M_current == _M_ctype.widen('.'))\n+\t{\n+\t  _M_curToken = _S_token_collsymbol;\n+\t  _M_eat_collsymbol();\n+\t  return;\n+\t}\n+\telse if (*_M_current == _M_ctype.widen(':'))\n+\t{\n+\t  _M_curToken = _S_token_char_class_name;\n+\t  _M_eat_charclass();\n+\t  return;\n+\t}\n+\telse if (*_M_current == _M_ctype.widen('='))\n+\t{\n+\t  _M_curToken = _S_token_equiv_class_name;\n+\t  _M_eat_equivclass();\n+\t  return;\n+\t}\n+      }\n+      else if (*_M_current == _M_ctype.widen('-'))\n+      {\n+\t_M_curToken = _S_token_dash;\n+\t++_M_current;\n+\treturn;\n+      }\n+      else if (*_M_current == _M_ctype.widen(']'))\n+      {\n+\tif (!(_M_flags & regex_constants::ECMAScript)\n+\t || !(_M_state & _S_state_at_start))\n+\t{\n+\t  // special case: only if  _not_ chr first after '[' or '[^' and if not\n+\t  // ECMAscript\n+\t  _M_curToken = _S_token_bracket_end;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      }\n+      _M_curToken = _S_token_collelem_single;\n+      _M_curValue.assign(1, *_M_current);\n+      ++_M_current;\n+    }\n+\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_eat_escape()\n+    {\n+      ++_M_current;\n+      if (_M_current == _M_end)\n+      {\n+\t_M_curToken = _S_token_eof;\n+\treturn;\n+      }\n+      _CharT __c = *_M_current;\n+      ++_M_current;\n+\n+      if (__c == _M_ctype.widen('('))\n+      {\n+\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t{\n+\t  _M_curToken = _S_token_ord_char;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n+\telse\n+\t{\n+\t  _M_curToken = _S_token_subexpr_begin;\n+\t}\n+      }\n+      else if (__c == _M_ctype.widen(')'))\n+      {\n+\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t{\n+\t  _M_curToken = _S_token_ord_char;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n+\telse\n+\t{\n+\t  _M_curToken = _S_token_subexpr_end;\n+\t}\n+      }\n+      else if (__c == _M_ctype.widen('{'))\n+      {\n+\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t{\n+\t  _M_curToken = _S_token_ord_char;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n+\telse\n+\t{\n+\t  _M_curToken = _S_token_interval_begin;\n+\t  _M_state |= _S_state_in_brace;\n+\t}\n+      }\n+      else if (__c == _M_ctype.widen('}'))\n+      {\n+\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t{\n+\t  _M_curToken = _S_token_ord_char;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n+\telse\n+\t{\n+\t  if (!(_M_state && _S_state_in_brace))\n+\t    __throw_regex_error(regex_constants::error_badbrace);\n+\t  _M_state &= ~_S_state_in_brace;\n+\t  _M_curToken = _S_token_interval_end;\n+\t}\n+      }\n+      else if (__c == _M_ctype.widen('x'))\n+      {\n+\t++_M_current;\n+\tif (_M_current == _M_end)\n+\t{\n+\t  _M_curToken = _S_token_eof;\n+\t  return;\n+\t}\n+\tif (_M_ctype.is(_CtypeT::digit, *_M_current))\n+\t{\n+\t  _M_curValue.assign(1, *_M_current);\n+\t  ++_M_current;\n+\t  if (_M_current == _M_end)\n+\t  {\n+\t    _M_curToken = _S_token_eof;\n+\t    return;\n+\t  }\n+\t  if (_M_ctype.is(_CtypeT::digit, *_M_current))\n+\t  {\n+\t    _M_curValue += *_M_current;\n+\t    ++_M_current;\n+\t    return;\n+\t  }\n+\t}\n+      }\n+      else if (__c == _M_ctype.widen('^')\n+\t    || __c == _M_ctype.widen('.')\n+\t    || __c == _M_ctype.widen('*')\n+\t    || __c == _M_ctype.widen('$')\n+\t    || __c == _M_ctype.widen('\\\\'))\n+      {\n+\t_M_curToken = _S_token_ord_char;\n+\t_M_curValue.assign(1, __c);\n+      }\n+      else if (_M_ctype.is(_CtypeT::digit, __c))\n+      {\n+\t_M_curToken = _S_token_backref;\n+\t_M_curValue.assign(1, __c);\n+      }\n+      else\n+      {\n+\t__throw_regex_error(regex_constants::error_escape);\n+      }\n+    }\n+\n+\n+  // Eats a character class or throwns an exception.\n+  // current point to ':' delimiter on entry, char after ']' on return\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_eat_charclass()\n+    {\n+      ++_M_current; // skip ':'\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_ctype);\n+      for (_M_curValue.clear();\n+\t   _M_current != _M_end && *_M_current != _M_ctype.widen(':');\n+\t   ++_M_current)\n+\t_M_curValue += *_M_current;\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_ctype);\n+      ++_M_current; // skip ':'\n+      if (*_M_current != _M_ctype.widen(']'))\n+\t__throw_regex_error(regex_constants::error_ctype);\n+      ++_M_current; // skip ']'\n+    }\n+\n+\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_eat_equivclass()\n+    {\n+      ++_M_current; // skip '='\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      for (_M_curValue.clear();\n+\t   _M_current != _M_end && *_M_current != _M_ctype.widen('=');\n+\t   ++_M_current)\n+\t_M_curValue += *_M_current;\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip '='\n+      if (*_M_current != _M_ctype.widen(']'))\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip ']'\n+    }\n+\n+\n+  template<typename _InputIterator>\n+    void\n+    _Scanner<_InputIterator>::\n+    _M_eat_collsymbol()\n+    {\n+      ++_M_current; // skip '.'\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      for (_M_curValue.clear();\n+\t   _M_current != _M_end && *_M_current != _M_ctype.widen('.');\n+\t   ++_M_current)\n+\t_M_curValue += *_M_current;\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip '.'\n+      if (*_M_current != _M_ctype.widen(']'))\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip ']'\n+    }\n+\n+#ifdef _GLIBCXX_DEBUG\n+  template<typename _InputIterator>\n+    std::ostream&\n+    _Scanner<_InputIterator>::\n+    _M_print(std::ostream& ostr)\n+    {\n+      switch (_M_curToken)\n+      {\n+\tcase _S_token_anychar:\n+\t\tostr << \"any-character\\n\";\n+\t\tbreak;\n+\tcase _S_token_backref:\n+\t\tostr << \"backref\\n\";\n+\t\tbreak;\n+\tcase _S_token_bracket_begin:\n+\t\tostr << \"bracket-begin\\n\";\n+\t\tbreak;\n+\tcase _S_token_bracket_end:\n+\t\tostr << \"bracket-end\\n\";\n+\t\tbreak;\n+\tcase _S_token_char_class_name:\n+\t\tostr << \"char-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t\tbreak;\n+\tcase _S_token_closure0:\n+\t\tostr << \"closure0\\n\";\n+\t\tbreak;\n+\tcase _S_token_closure1:\n+\t\tostr << \"closure1\\n\";\n+\t\tbreak;\n+\tcase _S_token_collelem_multi:\n+\t\tostr << \"coll-elem-multi \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t\tbreak;\n+\tcase _S_token_collelem_single:\n+\t\tostr << \"coll-elem-single \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t\tbreak;\n+\tcase _S_token_collsymbol:\n+\t\tostr << \"collsymbol \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t\tbreak;\n+\tcase _S_token_comma:\n+\t\tostr << \"comma\\n\";\n+\t\tbreak;\n+\tcase _S_token_dash:\n+\t\tostr << \"dash\\n\";\n+\t\tbreak;\n+\tcase _S_token_dup_count:\n+\t\tostr << \"dup count: \" << _M_curValue << \"\\n\";\n+\t\tbreak;\n+\tcase _S_token_eof:\n+\t\tostr << \"EOF\\n\";\n+\t\tbreak;\n+\tcase _S_token_equiv_class_name:\n+\t\tostr << \"equiv-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t\tbreak;\n+\tcase _S_token_interval_begin:\n+\t\tostr << \"interval begin\\n\";\n+\t\tbreak;\n+\tcase _S_token_interval_end:\n+\t\tostr << \"interval end\\n\";\n+\t\tbreak;\n+\tcase _S_token_line_begin:\n+\t\tostr << \"line begin\\n\";\n+\t\tbreak;\n+\tcase _S_token_line_end:\n+\t\tostr << \"line end\\n\";\n+\t\tbreak;\n+\tcase _S_token_opt:\n+\t\tostr << \"opt\\n\";\n+\t\tbreak;\n+\tcase _S_token_or:\n+\t\tostr << \"or\\n\";\n+\t\tbreak;\n+\tcase _S_token_ord_char:\n+\t\tostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n+\t\tbreak;\n+\tcase _S_token_quoted_char:\n+\t\tostr << \"quoted char\\n\";\n+\t\tbreak;\n+\tcase _S_token_subexpr_begin:\n+\t\tostr << \"subexpr begin\\n\";\n+\t\tbreak;\n+\tcase _S_token_subexpr_end:\n+\t\tostr << \"subexpr end\\n\";\n+\t\tbreak;\n+\tcase _S_token_word_begin:\n+\t\tostr << \"word begin\\n\";\n+\t\tbreak;\n+\tcase _S_token_word_end:\n+\t\tostr << \"word end\\n\";\n+\t\tbreak;\n+\tcase _S_token_unknown:\n+\t\tostr << \"-- unknown token --\\n\";\n+\t\tbreak;\n+      }\n+      return ostr;\n+    }\n+#endif\n+\n+  // Builds an NFA from an input iterator interval.\n+  template<typename _InIter, typename _TraitsT>\n+    class _Compiler\n+    {\n+    public:\n+      typedef _InIter                                            _IterT;\n+      typedef typename std::iterator_traits<_InIter>::value_type _CharT;\n+      typedef std::basic_string<_CharT>                          _StringT;\n+      typedef regex_constants::syntax_option_type                _FlagT;\n+\n+    public:\n+      _Compiler(const _InIter& __b, const _InIter& __e,\n+\t\t_TraitsT& __traits, _FlagT __flags);\n+\n+      const _Nfa&\n+      _M_nfa() const\n+      { return _M_state_store; }\n+\n+    private:\n+      typedef _Scanner<_InIter>                              _ScannerT;\n+      typedef typename _ScannerT::_TokenT                    _TokenT;\n+      typedef std::stack<_StateSeq, std::vector<_StateSeq> > _StackT;\n+      typedef _RangeMatcher<_InIter, _TraitsT>               _RMatcherT;\n+\n+      // accepts a specific token or returns false.\n+      bool\n+      _M_match_token(_TokenT token);\n+\n+      void\n+      _M_disjunction();\n+\n+      bool\n+      _M_alternative();\n+\n+      bool\n+      _M_term();\n+\n+      bool\n+      _M_assertion();\n+\n+      bool\n+      _M_quantifier();\n+\n+      bool\n+      _M_atom();\n+\n+      bool\n+      _M_bracket_expression();\n+\n+      bool\n+      _M_bracket_list(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_follow_list(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_follow_list2(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_expression_term(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_range_expression(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_start_range(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_collating_symbol(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_equivalence_class(_RMatcherT& __matcher);\n+\n+      bool\n+      _M_character_class(_RMatcherT& __matcher);\n+\n+      int\n+      _M_cur_int_value(int __radix);\n+\n+    private:\n+      _TraitsT&      _M_traits;\n+      _ScannerT      _M_scanner;\n+      _StringT       _M_cur_value;\n+      _Nfa           _M_state_store;\n+      _StackT        _M_stack;\n+    };\n+\n+  template<typename _InIter, typename _TraitsT>\n+    _Compiler<_InIter, _TraitsT>::\n+    _Compiler(const _InIter& __b, const _InIter& __e, _TraitsT& __traits,\n+\t      _Compiler<_InIter, _TraitsT>::_FlagT __flags)\n+    : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n+      _M_state_store(__flags)\n+    {\n+      using std::bind;\n+      using std::placeholders::_1;\n+      using std::placeholders::_2;\n+      typedef _StartTagger<_InIter, _TraitsT> _Start;\n+      typedef _EndTagger<_InIter, _TraitsT> _End;\n+\n+      _StateSeq __r(_M_state_store,\n+      \t\t    _M_state_store._M_insert_subexpr_begin(\n+                        bind(_Start(0), _1, _2)));\n+      _M_disjunction();\n+      if (!_M_stack.empty())\n+      {\n+\t__r._M_append(_M_stack.top());\n+\t_M_stack.pop();\n+      }\n+      __r._M_append(_M_state_store._M_insert_subexpr_end(0,\n+                        bind(_End(0), _1, _2)));\n+      __r._M_append(_M_state_store._M_insert_accept());\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_match_token(_Compiler<_InIter, _TraitsT>::_TokenT token)\n+    { \n+      if (token == _M_scanner._M_token())\n+      {\n+\t_M_cur_value = _M_scanner._M_value();\n+\t_M_scanner._M_advance();\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    void\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_disjunction()\n+    {\n+      this->_M_alternative();\n+      if (_M_match_token(_ScannerT::_S_token_or))\n+      {\n+\t_StateSeq __alt1 = _M_stack.top(); _M_stack.pop();\n+\tthis->_M_disjunction();\n+\t_StateSeq __alt2 = _M_stack.top(); _M_stack.pop();\n+\t_M_stack.push(_StateSeq(__alt1, __alt2));\n+      }\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_alternative()\n+    {\n+      if (this->_M_term())\n+      {\n+\t_StateSeq __re = _M_stack.top(); _M_stack.pop();\n+\tthis->_M_alternative();\n+\tif (!_M_stack.empty())\n+\t{\n+\t  __re._M_append(_M_stack.top());\n+\t  _M_stack.pop();\n+\t}\n+\t_M_stack.push(__re);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_term()\n+    {\n+      if (this->_M_assertion())\n+\treturn true;\n+      if (this->_M_atom())\n+      {\n+\tthis->_M_quantifier();\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_assertion()\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_line_begin))\n+      {\n+\t// __m.push(_Matcher::_S_opcode_line_begin);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_line_end))\n+      {\n+\t// __m.push(_Matcher::_S_opcode_line_end);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_word_begin))\n+      {\n+\t// __m.push(_Matcher::_S_opcode_word_begin);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_word_end))\n+      {\n+\t// __m.push(_Matcher::_S_opcode_word_end);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_quantifier()\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_closure0))\n+      {\n+\tif (_M_stack.empty())\n+\t  __throw_regex_error(regex_constants::error_badrepeat);\n+\t_StateSeq __r(_M_stack.top(), -1);\n+\t__r._M_append(__r._M_front());\n+\t_M_stack.pop();\n+\t_M_stack.push(__r);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_closure1))\n+      {\n+\tif (_M_stack.empty())\n+\t  __throw_regex_error(regex_constants::error_badrepeat);\n+\t_StateSeq __r(_M_state_store,\n+\t\t       _M_state_store._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t    _M_stack.top()._M_front()));\n+\t_M_stack.top()._M_append(__r);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_opt))\n+      {\n+\tif (_M_stack.empty())\n+\t  __throw_regex_error(regex_constants::error_badrepeat);\n+\t_StateSeq __r(_M_stack.top(), -1);\n+\t_M_stack.pop();\n+\t_M_stack.push(__r);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_interval_begin))\n+      {\n+\tif (_M_stack.empty())\n+\t  __throw_regex_error(regex_constants::error_badrepeat);\n+\tif (!_M_match_token(_ScannerT::_S_token_dup_count))\n+\t  __throw_regex_error(regex_constants::error_badbrace);\n+\t_StateSeq __r(_M_stack.top());\n+\tint __min_rep = _M_cur_int_value(10);\n+\tfor (int __i = 1; __i < __min_rep; ++__i)\n+\t  _M_stack.top()._M_append(__r._M_clone()); \n+\tif (_M_match_token(_ScannerT::_S_token_comma))\n+\t  if (_M_match_token(_ScannerT::_S_token_dup_count))\n+\t  {\n+\t    int __n = _M_cur_int_value(10) - __min_rep;\n+\t    if (__n < 0)\n+\t      __throw_regex_error(regex_constants::error_badbrace);\n+\t    for (int __i = 0; __i < __n; ++__i)\n+\t    {\n+\t      _StateSeq __r(_M_state_store,\n+\t\t\t    _M_state_store._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t  _M_stack.top()._M_front()));\n+\t      _M_stack.top()._M_append(__r);\n+\t    }\n+\t  }\n+\t  else\n+\t  {\n+\t    _StateSeq __r(_M_stack.top(), -1);\n+\t    __r._M_push_back(__r._M_front());\n+\t    _M_stack.pop();\n+\t    _M_stack.push(__r);\n+\t  }\n+\tif (!_M_match_token(_ScannerT::_S_token_interval_end))\n+\t  __throw_regex_error(regex_constants::error_brace);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_atom()\n+    {\n+      using std::bind;\n+      using std::placeholders::_1;\n+      using std::placeholders::_2;\n+      typedef _CharMatcher<_InIter, _TraitsT> _CMatcher;\n+      typedef _StartTagger<_InIter, _TraitsT> _Start;\n+      typedef _EndTagger<_InIter, _TraitsT> _End;\n+\n+      if (_M_match_token(_ScannerT::_S_token_anychar))\n+      {\n+\t_M_stack.push(_StateSeq(_M_state_store,\n+\t     _M_state_store._M_insert_matcher(bind(_AnyMatcher, _1))));\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_ord_char))\n+      {\n+\t_M_stack.push(_StateSeq(_M_state_store,\n+\t                        _M_state_store._M_insert_matcher(\n+\t                        bind(_CMatcher(_M_cur_value[0], _M_traits), _1))));\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_quoted_char))\n+      {\n+\t// note that in the ECMA grammar, this case covers backrefs.\n+\t_M_stack.push(_StateSeq(_M_state_store,\n+\t                        _M_state_store._M_insert_matcher(\n+\t                        bind(_CMatcher(_M_cur_value[0], _M_traits), _1))));\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_backref))\n+      {\n+\t// __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n+      {\n+\tint __mark = _M_state_store._M_sub_count();\n+\t_StateSeq __r(_M_state_store,\n+\t\t      _M_state_store._M_insert_subexpr_begin(bind(_Start(__mark), _1, _2)));\n+\tthis->_M_disjunction();\n+\tif (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n+\t  __throw_regex_error(regex_constants::error_paren);\n+\tif (!_M_stack.empty())\n+\t{\n+\t  __r._M_append(_M_stack.top());\n+\t  _M_stack.pop();\n+\t}\n+\t__r._M_append(_M_state_store._M_insert_subexpr_end(__mark,\n+\t                  bind(_End(__mark), _1, _2)));\n+\t_M_stack.push(__r);\n+\treturn true;\n+      }\n+      return _M_bracket_expression();\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_bracket_expression()\n+    {\n+      using std::bind;\n+      using std::placeholders::_1;\n+      if (_M_match_token(_ScannerT::_S_token_bracket_begin))\n+      {\n+\t_RMatcherT __matcher(_M_match_token(_ScannerT::_S_token_line_begin),\n+\t                     _M_traits);\n+\tif (!_M_bracket_list(__matcher)\n+\t || !_M_match_token(_ScannerT::_S_token_bracket_end))\n+\t  __throw_regex_error(regex_constants::error_brack);\n+\t_M_stack.push(_StateSeq(_M_state_store,\n+\t                        _M_state_store._M_insert_matcher(\n+\t                            bind(__matcher, _1))));\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  // If the dash is the last character in the bracket expression, it is not\n+  // special.\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_bracket_list(_RMatcherT& __matcher)\n+    {\n+      if (_M_follow_list(__matcher))\n+      {\n+\tif (_M_match_token(_ScannerT::_S_token_dash))\n+\t  __matcher._M_add_char(_M_cur_value[0]);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_follow_list(_RMatcherT& __matcher)\n+    { return _M_expression_term(__matcher) && _M_follow_list2(__matcher); }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_follow_list2(_RMatcherT& __matcher)\n+    {\n+      if (_M_expression_term(__matcher))\n+\treturn _M_follow_list2(__matcher);\n+      return true;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_expression_term(_RMatcherT& __matcher)\n+    {\n+      return _M_collating_symbol(__matcher)\n+\t  || _M_character_class(__matcher)\n+\t  || _M_equivalence_class(__matcher)\n+\t  || (_M_start_range(__matcher) && _M_range_expression(__matcher));\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_range_expression(_RMatcherT& __matcher)\n+    {\n+      if (!_M_collating_symbol(__matcher))\n+\tif (!_M_match_token(_ScannerT::_S_token_dash))\n+\t  __throw_regex_error(regex_constants::error_range);\n+      __matcher._M_make_range();\n+      return true;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_start_range(_RMatcherT& __matcher)\n+    { return _M_match_token(_ScannerT::_S_token_dash); }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_collating_symbol(_RMatcherT& __matcher)\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_collelem_single))\n+      {\n+\t__matcher._M_add_char(_M_cur_value[0]);\n+\treturn true;\n+      }\n+      if (_M_match_token(_ScannerT::_S_token_collsymbol))\n+      {\n+\t__matcher._M_add_collating_element(_M_cur_value);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_equivalence_class(_RMatcherT& __matcher)\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n+      {\n+\t__matcher._M_add_equivalence_class(_M_cur_value);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    bool\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_character_class(_RMatcherT& __matcher)\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_char_class_name))\n+      {\n+\t__matcher._M_add_character_class(_M_cur_value);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    int\n+    _Compiler<_InIter, _TraitsT>::\n+    _M_cur_int_value(int __radix)\n+    {\n+      int __v = 0;\n+      for (typename _StringT::size_type __i = 0;\n+\t   __i < _M_cur_value.length(); ++__i)\n+\t__v =__v * __radix + _M_traits.value(_M_cur_value[__i], __radix);\n+      return __v;\n+    }\n+\n+  template<typename _InIter, typename _TraitsT>\n+    _AutomatonPtr\n+    __compile(const _InIter& __b, const _InIter& __e, _TraitsT& __t,\n+\t      regex_constants::syntax_option_type __f)\n+    { return _AutomatonPtr(new _Nfa(_Compiler<_InIter, _TraitsT>(__b, __e, __t,\n+                                        __f)._M_nfa())); }\n+\n+} // namespace __regex\n+} // namespace std\n+\n+/* vim: set ts=8 sw=2 sts=2: */"}, {"sha": "787b88b8cd463801950af91d266bd07cd1e1daa7", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,299 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex_constants\n+ * @brief Constant definitions for the std regex library.\n+ *\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+\n+/**\n+ * @namespace std::regex_constants\n+ * @brief ISO C++-0x entities sub namespace for regex.\n+ */\n+namespace regex_constants\n+{\n+  /**\n+   * @name 5.1 Regular Expression Syntax Options\n+   */\n+  //@{\n+  enum __syntax_option\n+    {\n+      _S_icase,\n+      _S_nosubs,\n+      _S_optimize,\n+      _S_collate,\n+      _S_ECMAScript,\n+      _S_basic,\n+      _S_extended,\n+      _S_awk,\n+      _S_grep,\n+      _S_egrep,\n+      _S_syntax_last\n+    };\n+\n+  /**\n+   * @brief This is a bitmask type indicating how to interpret the regex.\n+   *\n+   * The @c syntax_option_type is implementation defined but it is valid to\n+   * perform bitwise operations on these values and expect the right thing to\n+   * happen.\n+   *\n+   * A valid value of type syntax_option_type shall have exactly one of the\n+   * elements @c ECMAScript, @c basic, @c extended, @c awk, @c grep, @c egrep\n+   * %set.\n+   */\n+  typedef unsigned int syntax_option_type;\n+\n+  /** \n+   * Specifies that the matching of regular expressions against a character\n+   * sequence shall be performed without regard to case.\n+   */\n+  static const syntax_option_type icase      = 1 << _S_icase;\n+\n+  /**\n+   * Specifies that when a regular expression is matched against a character\n+   * container sequence, no sub-expression matches are to be stored in the\n+   * supplied match_results structure.\n+   */\n+  static const syntax_option_type nosubs     = 1 << _S_nosubs;\n+\n+  /**\n+   * Specifies that the regular expression engine should pay more attention to\n+   * the speed with which regular expressions are matched, and less to the\n+   * speed with which regular expression objects are constructed. Otherwise\n+   * it has no detectable effect on the program output.\n+   */\n+  static const syntax_option_type optimize   = 1 << _S_optimize;\n+\n+  /**\n+   * Specifies that character ranges of the form [a-b] should be locale\n+   * sensitive.\n+   */\n+  static const syntax_option_type collate    = 1 << _S_collate;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n+   * Language Specification, Standard Ecma-262, third edition, 1999], as\n+   * modified in section [28.13].  This grammar is similar to that defined\n+   * in the PERL scripting language but extended with elements found in the\n+   * POSIX regular expression grammar.\n+   */\n+  static const syntax_option_type ECMAScript = 1 << _S_ECMAScript;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n+   * Portable Operating System Interface (POSIX), Base Definitions and\n+   * Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n+   * Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+   */\n+  static const syntax_option_type basic      = 1 << _S_basic;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n+   * Portable Operating System Interface (POSIX), Base Definitions and Headers,\n+   * Section 9, Regular Expressions.\n+   */\n+  static const syntax_option_type extended   = 1 << _S_extended;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n+   * identical to syntax_option_type extended, except that C-style escape\n+   * sequences are supported.  These sequences are:\n+   * \\\\\\\\, \\\\a, \\\\b, \\\\f, \\\\n, \\\\r, \\\\t , \\\\v, \\\\&apos;, &apos;,\n+   * and \\\\ddd (where ddd is one, two, or three octal digits).  \n+   */\n+  static const syntax_option_type awk        = 1 << _S_awk;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n+   * identical to syntax_option_type basic, except that newlines are treated\n+   * as whitespace.\n+   */\n+  static const syntax_option_type grep       = 1 << _S_grep;\n+\n+  /**\n+   * Specifies that the grammar recognized by the regular expression engine is\n+   * that used by POSIX utility grep when given the -E option in\n+   * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type \n+   * extended, except that newlines are treated as whitespace.\n+   */\n+  static const syntax_option_type egrep      = 1 << _S_egrep;\n+\n+  //@}\n+\n+  /**\n+   * @name 5.2 Matching Rules\n+   *\n+   * Matching a regular expression against a sequence of characters [first,\n+   * last) proceeds according to the rules of the grammar specified for the\n+   * regular expression object, modified according to the effects listed\n+   * below for any bitmask elements set.\n+   *\n+   */\n+  //@{\n+\n+  enum __match_flag\n+    {\n+      _S_not_bol,\n+      _S_not_eol,\n+      _S_not_bow,\n+      _S_not_eow,\n+      _S_any,\n+      _S_not_null,\n+      _S_continuous,\n+      _S_prev_avail,\n+      _S_sed,\n+      _S_no_copy,\n+      _S_first_only,\n+      _S_match_flag_last\n+    };\n+\n+  /**\n+   * @brief This is a bitmask type indicating regex matching rules.\n+   *\n+   * The @c match_flag_type is implementation defined but it is valid to\n+   * perform bitwise operations on these values and expect the right thing to\n+   * happen.\n+   */\n+  typedef std::bitset<_S_match_flag_last> match_flag_type;\n+\n+  /**\n+   * The default matching rules.\n+   */\n+  static const match_flag_type match_default     = 0;\n+\n+  /**\n+   * The first character in the sequence [first, last) is treated as though it\n+   * is not at the beginning of a line, so the character (^) in the regular\n+   * expression shall not match [first, first).\n+   */\n+  static const match_flag_type match_not_bol     = 1 << _S_not_bol;\n+\n+  /**\n+   * The last character in the sequence [first, last) is treated as though it\n+   * is not at the end of a line, so the character ($) in the regular\n+   * expression shall not match [last, last).\n+   */\n+  static const match_flag_type match_not_eol     = 1 << _S_not_eol;\n+   \n+  /**\n+   * The expression \\\\b is not matched against the sub-sequence\n+   * [first,first).\n+   */\n+  static const match_flag_type match_not_bow     = 1 << _S_not_bow;\n+   \n+  /**\n+   * The expression \\\\b should not be matched against the sub-sequence\n+   * [last,last).\n+   */\n+  static const match_flag_type match_not_eow     = 1 << _S_not_eow;\n+   \n+  /**\n+   * If more than one match is possible then any match is an acceptable\n+   * result.\n+   */\n+  static const match_flag_type match_any         = 1 << _S_any;\n+   \n+  /**\n+   * The expression does not match an empty sequence.\n+   */\n+  static const match_flag_type match_not_null    = 1 << _S_not_null;\n+   \n+  /**\n+   * The expression only matches a sub-sequence that begins at first .\n+   */\n+  static const match_flag_type match_continuous  = 1 << _S_continuous;\n+   \n+  /**\n+   * --first is a valid iterator position.  When this flag is set then the\n+   * flags match_not_bol and match_not_bow are ignored by the regular\n+   * expression algorithms 7.11 and iterators 7.12.\n+   */\n+  static const match_flag_type match_prev_avail  = 1 << _S_prev_avail;\n+\n+  /**\n+   * When a regular expression match is to be replaced by a new string, the\n+   * new string is constructed using the rules used by the ECMAScript replace\n+   * function in ECMA- 262 [Ecma International, ECMAScript Language\n+   * Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n+   * String.prototype.replace. In addition, during search and replace\n+   * operations all non-overlapping occurrences of the regular expression\n+   * are located and replaced, and sections of the input that did not match\n+   * the expression are copied unchanged to the output string.\n+   * \n+   * Format strings (from ECMA-262 [15.5.4.11]):\n+   * @li $$  The dollar-sign itself ($)\n+   * @li $&  The matched substring.\n+   * @li $`  The portion of @a string that precedes the matched substring.\n+   *         This would be match_results::prefix().\n+   * @li $'  The portion of @a string that follows the matched substring.\n+   *         This would be match_results::suffix().\n+   * @li $n  The nth capture, where n is in [1,9] and $n is not followed by a\n+   *         decimal digit.  If n <= match_results::size() and the nth capture\n+   *         is undefined, use the empty string instead.  If n >\n+   *         match_results::size(), the result is implementation-defined.\n+   * @li $nn The nnth capture, where nn is a two-digit decimal number on\n+   *         [01, 99].  If nn <= match_results::size() and the nth capture is\n+   *         undefined, use the empty string instead. If\n+   *         nn > match_results::size(), the result is implementation-defined.\n+   */\n+  static const match_flag_type format_default    = 0;\n+\n+  /**\n+   * When a regular expression match is to be replaced by a new string, the\n+   * new string is constructed using the rules used by the POSIX sed utility\n+   * in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n+   * Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+   */\n+  static const match_flag_type format_sed        = 1 << _S_sed;\n+\n+  /**\n+   * During a search and replace operation, sections of the character\n+   * container sequence being searched that do not match the regular\n+   * expression shall not be copied to the output string.\n+   */\n+  static const match_flag_type format_no_copy    = 1 << _S_no_copy;\n+\n+  /**\n+   * When specified during a search and replace operation, only the first\n+   * occurrence of the regular expression shall be replaced.\n+   */\n+  static const match_flag_type format_first_only = 1 << _S_first_only;\n+\n+  //@}\n+\n+} // namespace regex_constants\n+} // namespace std\n+"}, {"sha": "0a293fae95300e2fc83c039edb6d31c45b8bbc93", "filename": "libstdc++-v3/include/bits/regex_cursor.h", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,92 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex_cursor.h\n+ * This is an internal header file, included by other library headers.\n+ * You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+namespace __regex\n+{\n+  // ABC for pattern matching\n+  struct _PatternCursor\n+  {\n+    virtual ~_PatternCursor() { };\n+    virtual void _M_next() = 0;\n+    virtual bool _M_at_end() const = 0;\n+  };\n+\n+  // Provides a cursor into the specific target string.\n+  template<typename _FwdIterT>\n+    class _SpecializedCursor\n+    : public _PatternCursor\n+    {\n+    public:\n+      _SpecializedCursor(const _FwdIterT& __b, const _FwdIterT __e)\n+      : _M_b(__b), _M_c(__b), _M_e(__e)\n+      { }\n+\n+      typename std::iterator_traits<_FwdIterT>::value_type\n+      _M_current() const\n+      { return *_M_c; }\n+\n+      void\n+      _M_next()\n+      { ++_M_c; }\n+\n+      _FwdIterT\n+      _M_pos() const\n+      { return _M_c; }\n+\n+      const _FwdIterT&\n+      _M_begin() const\n+\t\t\t{ return _M_b; }\n+\n+      const _FwdIterT&\n+      _M_end() const\n+\t\t\t{ return _M_e; }\n+\n+      bool\n+      _M_at_end() const\n+      { return _M_c == _M_e; }\n+\n+    private:\n+      _FwdIterT _M_b;\n+      _FwdIterT _M_c;\n+      _FwdIterT _M_e;\n+    };\n+\n+  // Helper funxtion to create a cursor specialized for an iterator class.\n+  template<typename _FwdIterT>\n+  \t_SpecializedCursor<_FwdIterT>\n+  \t__cursor(const _FwdIterT& __b, const _FwdIterT __e)\n+\t\t{ return _SpecializedCursor<_FwdIterT>(__b, __e); }\n+\n+} // namespace __regex\n+} // namespace std\n+\n+/* vim: set ts=8 sw=2 sts=2: */"}, {"sha": "56bfae4cc660dcbaf0ee4acdac365d023bf5d7af", "filename": "libstdc++-v3/include/bits/regex_error.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,160 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex_error\n+ * @brief Error and exception objects for the std regex library.\n+ *\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+\n+namespace regex_constants\n+{\n+  /**\n+   * @name 5.3 Error Types\n+   */\n+  //@{\n+ \n+  enum error_type\n+    {\n+      _S_error_collate,\n+      _S_error_ctype,\n+      _S_error_escape,\n+      _S_error_backref,\n+      _S_error_brack,\n+      _S_error_paren,\n+      _S_error_brace,\n+      _S_error_badbrace,\n+      _S_error_range,\n+      _S_error_space,\n+      _S_error_badrepeat,\n+      _S_error_complexity,\n+      _S_error_stack,\n+      _S_error_last\n+    };\n+\n+  /** The expression contained an invalid collating element name. */\n+  static const error_type error_collate(_S_error_collate);\n+\n+  /** The expression contained an invalid character class name. */\n+  static const error_type error_ctype(_S_error_ctype);\n+\n+  /**\n+   * The expression contained an invalid escaped character, or a trailing\n+   * escape.\n+   */\n+  static const error_type error_escape(_S_error_escape);\n+\n+  /** The expression contained an invalid back reference. */\n+  static const error_type error_backref(_S_error_backref);\n+\n+  /** The expression contained mismatched [ and ]. */\n+  static const error_type error_brack(_S_error_brack);\n+\n+  /** The expression contained mismatched ( and ). */\n+  static const error_type error_paren(_S_error_paren);\n+\n+  /** The expression contained mismatched { and } */\n+  static const error_type error_brace(_S_error_brace);\n+\n+  /** The expression contained an invalid range in a {} expression. */\n+  static const error_type error_badbrace(_S_error_badbrace);\n+\n+  /**\n+   * The expression contained an invalid character range,\n+   * such as [b-a] in most encodings.\n+   */\n+  static const error_type error_range(_S_error_range);\n+\n+  /**\n+   * There was insufficient memory to convert the expression into a\n+   * finite state machine.\n+   */\n+  static const error_type error_space(_S_error_space);\n+\n+  /**\n+   * One of <em>*?+{<em> was not preceded by a valid regular expression.\n+   */\n+  static const error_type error_badrepeat(_S_error_badrepeat);\n+\n+  /**\n+   * The complexity of an attempted match against a regular expression\n+   * exceeded a pre-set level.\n+   */\n+  static const error_type error_complexity(_S_error_complexity);\n+\n+  /**\n+   * There was insufficient memory to determine whether the\n+   * regular expression could match the specified character sequence.\n+   */\n+  static const error_type error_stack(_S_error_stack);\n+\n+  //@}\n+}\n+\n+  // [7.8] Class regex_error\n+  /**\n+   * @brief A regular expression exception class.\n+   * @ingroup exceptions\n+   *\n+   * The regular expression library throws objects of this class on error.\n+   */\n+  class regex_error\n+  : public std::runtime_error\n+  {\n+  public:\n+    /**\n+     * @brief Constructs a regex_error object.\n+     *\n+     * @param ecode the regex error code.\n+     */\n+    explicit\n+    regex_error(regex_constants::error_type __ecode)\n+    : std::runtime_error(\"regex_error\"), _M_code(__ecode)\n+    { }\n+\n+    /**\n+     * @brief Gets the regex error code.\n+     *\n+     * @returns the regex error code.\n+     */\n+    regex_constants::error_type\n+    code() const\n+    { return _M_code; }\n+\n+  protected:\n+    regex_constants::error_type _M_code;\n+  };\n+\n+\n+  inline void\n+  __throw_regex_error(regex_constants::error_type __ecode)\n+  { throw regex_error(__ecode); }\n+\n+} // namespace std\n+"}, {"sha": "f243c92406ba208be8fc2158421c482b017c984f", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,131 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex_executor.h\n+ * This is an internal header file, included by other library headers.\n+ * You should not attempt to use it directly.\n+ */\n+\n+\n+namespace std\n+{\n+  template<typename _BiIter>\n+    class sub_match;\n+\n+  template<typename _Bi_iter, typename _Allocator>\n+    class match_results;\n+  \n+namespace __regex\n+{\n+  // A _Results facade specialized for wrapping a templated sub_match.\n+  template<typename _FwdIterT, typename _Alloc>\n+    class _SpecializedResults\n+    : public _Results\n+    {\n+    public:\n+      _SpecializedResults(const _Automaton::_SizeT __size,\n+\t\t\t  const _SpecializedCursor<_FwdIterT>& __cursor,\n+\t\t\t  match_results<_FwdIterT, _Alloc>& __m);\n+\n+      void\n+      _M_set_pos(int __i, int __j, const _PatternCursor& __pc);\n+\n+      void\n+      _M_set_matched(int __i, bool __is_matched)\n+      { _M_results.at(__i).matched = __is_matched; }\n+\n+    private:\n+      match_results<_FwdIterT, _Alloc>& _M_results;\n+    };\n+\n+  template<typename _FwdIterT, typename _Alloc>\n+    _SpecializedResults<_FwdIterT, _Alloc>::\n+    _SpecializedResults(const _Automaton::_SizeT __size,\n+    \t\t\tconst _SpecializedCursor<_FwdIterT>& __cursor,\n+                        match_results<_FwdIterT, _Alloc>& __m)\n+    : _M_results(__m)\n+    {\n+      typedef typename match_results<_FwdIterT, _Alloc>::size_type size_type;\n+      _M_results.clear();\n+      std::sub_match<_FwdIterT> __sm;\n+      __sm.matched = false;\n+      size_type __result_count = __size + 2;\n+      for (size_type __i = 0; __i < __result_count; ++__i)\n+\t_M_results.push_back(__sm);\n+      _M_results.at(__size+0).first = __cursor._M_begin();\n+      _M_results.at(__size+0).second = __cursor._M_begin();\n+      _M_results.at(__size+1).first = __cursor._M_end();\n+      _M_results.at(__size+1).second = __cursor._M_end();\n+    }\n+\n+  template<typename _FwdIterT, typename _Alloc>\n+    void\n+    _SpecializedResults<_FwdIterT, _Alloc>::\n+    _M_set_pos(int __i, int __j, const _PatternCursor& __pc)\n+    { \n+      typedef const _SpecializedCursor<_FwdIterT>& _CursorT;\n+      _CursorT __c = static_cast<_CursorT>(__pc);\n+      if (__j == 0)\n+\t_M_results.at(__i).first = __c._M_pos();\n+      else\n+\t_M_results.at(__i).second = __c._M_pos()+1;\n+    }\n+\n+  // A stack of states used in evaluating the NFA.\n+  typedef std::stack<_StateIdT, std::vector<_StateIdT> > _StateStack;\n+\n+  // Executes a regular expression NFA/DFA over a range using a variant of\n+  // the parallel execution algorithm featured in the grep utility, modified\n+  // to use Laurikari tags.\n+  class _Grep_matcher\n+  {\n+  public:\n+    _Grep_matcher(_PatternCursor&                   __p,\n+\t\t  _Results&                         __r,\n+\t\t  const _AutomatonPtr&              __automaton,\n+\t\t  regex_constants::match_flag_type  __flags);\n+\n+  private:\n+    _StateSet\n+    _M_e_closure(_StateIdT __i);\n+\n+    _StateSet\n+    _M_e_closure(const _StateSet& __s);\n+\n+    _StateSet\n+    _M_e_closure(_StateStack& __stack, const _StateSet& __s);\n+\n+  private:\n+    const std::shared_ptr<_Nfa>        _M_nfa;\n+    _PatternCursor&                    _M_pattern;\n+    _Results&                          _M_results;\n+  };\n+\n+} // namespace __regex\n+} // namespace std\n+\n+#include <bits/regex_grep_matcher.tcc>\n+\n+/* vim: set ts=8 sw=2 sts=2: */"}, {"sha": "e43975765b8fd84b9bc6f362f53a46d600462d7d", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,179 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file regex_grep_matcher.cc\n+ */\n+#include <regex>\n+\n+namespace std\n+{\n+\n+namespace\n+{\n+\n+  // A stack of states used in evaluating the NFA.\n+  typedef std::stack<\n+                     std::__regex::_StateIdT,\n+                     std::vector<std::__regex::_StateIdT>\n+                    > _StateStack;\n+\n+  // Obtains the next state set given the current state set __s and the current\n+  // input character.\n+  inline std::__regex::_StateSet\n+  __move(const std::__regex::_PatternCursor& __p,\n+         const std::__regex::_Nfa& __nfa,\n+         const std::__regex::_StateSet& __s)\n+  {\n+    std::__regex::_StateSet __m;\n+    for (std::__regex::_StateSet::const_iterator __i = __s.begin();\n+\t\t     __i != __s.end(); ++__i)\n+    {\n+      if (*__i == std::__regex::_S_invalid_state_id)\n+\tcontinue;\n+\n+      const std::__regex::_State& __state = __nfa[*__i];\n+      if (__state._M_opcode == std::__regex::_S_opcode_match\n+       && __state._M_matches(__p))\n+\t  __m.insert(__state._M_next);\n+    }\n+    return __m;\n+  }\n+\n+  // returns true if (__s intersect __t) is not empty\n+  inline bool\n+  __includes_some(const std::__regex::_StateSet& __s,\n+                  const std::__regex::_StateSet& __t)\n+  {\n+    if (__s.size() > 0 && __t.size() > 0)\n+    {\n+      std::__regex::_StateSet::const_iterator __first = __s.begin();\n+      std::__regex::_StateSet::const_iterator __second = __t.begin();\n+      while (__first != __s.end() && __second != __t.end())\n+      {\n+\tif (*__first < *__second)\n+\t  ++__first;\n+\telse if (*__second < *__first)\n+\t  ++__second;\n+\telse\n+\t  return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  // If an identified state __u is not already in the current state set __e,\n+  // insert it and push it on the current state stack __s.\n+  inline void\n+  __add_visited_state(const std::__regex::_StateIdT __u,\n+                      _StateStack&                  __s,\n+                      std::__regex::_StateSet&      __e)\n+  {\n+    if (__e.count(__u) == 0)\n+    {\n+      __e.insert(__u);\n+      __s.push(__u);\n+    }\n+  }\n+\n+} // anonymous namespace\n+\n+namespace __regex\n+{\n+  inline _Grep_matcher::\n+  _Grep_matcher(_PatternCursor&                  __p,\n+\t\t_Results&                        __r,\n+\t\tconst _AutomatonPtr&             __nfa,\n+\t\tregex_constants::match_flag_type __flags)\n+  : _M_nfa(static_pointer_cast<_Nfa>(__nfa)), _M_pattern(__p), _M_results(__r)\n+  {\n+    __regex::_StateSet __t = this->_M_e_closure(_M_nfa->_M_start());\n+    for (; !_M_pattern._M_at_end(); _M_pattern._M_next())\n+      __t = this->_M_e_closure(__move(_M_pattern, *_M_nfa, __t));\n+\n+    _M_results._M_set_matched(0,\n+                              __includes_some(_M_nfa->_M_final_states(), __t));\n+  }\n+\n+  // Creates the e-closure set for the initial state __i.\n+  inline _StateSet _Grep_matcher::\n+  _M_e_closure(_StateIdT __i)\n+  {\n+    _StateSet __s;\n+    __s.insert(__i);\n+    _StateStack __stack;\n+    __stack.push(__i);\n+    return this->_M_e_closure(__stack, __s);\n+  }\n+\n+  // Creates the e-closure set for an arbitrary state set __s.\n+  inline _StateSet _Grep_matcher::\n+  _M_e_closure(const _StateSet& __s)\n+  {\n+    _StateStack __stack;\n+    for (_StateSet::const_iterator __i = __s.begin(); __i != __s.end(); ++__i)\n+      __stack.push(*__i);\n+    return this->_M_e_closure(__stack, __s);\n+  }\n+\n+  inline _StateSet _Grep_matcher::\n+  _M_e_closure(_StateStack& __stack, const _StateSet& __s)\n+  {\n+    _StateSet __e = __s;\n+    while (!__stack.empty())\n+    {\n+      _StateIdT __t = __stack.top(); __stack.pop();\n+      if (__t == _S_invalid_state_id)\n+\tcontinue;\n+      // for each __u with edge from __t to __u labeled e do ...\n+      const _State& __state = _M_nfa->operator[](__t);\n+      switch (__state._M_opcode)\n+      {\n+\tcase _S_opcode_alternative:\n+\t  __add_visited_state(__state._M_next, __stack, __e);\n+\t  __add_visited_state(__state._M_alt, __stack, __e);\n+\t  break;\n+\tcase _S_opcode_subexpr_begin:\n+\t  __add_visited_state(__state._M_next, __stack, __e);\n+\t  __state._M_tagger(_M_pattern, _M_results);\n+\t  break;\n+\tcase _S_opcode_subexpr_end:\n+\t  __add_visited_state(__state._M_next, __stack, __e);\n+\t  __state._M_tagger(_M_pattern, _M_results);\n+\t  _M_results._M_set_matched(__state._M_subexpr, true);\n+\t  break;\n+\tcase _S_opcode_accept:\n+\t  __add_visited_state(__state._M_next, __stack, __e);\n+\t  break;\n+\tdefault:\n+\t  break;\n+      }\n+    }\n+    return __e;\n+  }\n+\n+} // namespace __regex\n+} // namespace std\n+\n+/* vim: set ts=8 sw=2 sts=2: */"}, {"sha": "2a938915b97342cc844f4434bcddc9a34ac2f4d1", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,403 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file bits/regex_nfa.h\n+ * This is an internal header file, included by other library headers.\n+ * You should not attempt to use it directly.\n+ */\n+\n+namespace std\n+{\n+namespace __regex\n+{\n+\n+  // Base class for, um, automata.  Could be an NFA or a DFA.  Your choice.\n+  class _Automaton\n+  {\n+  public:\n+    typedef unsigned int _SizeT;\n+\n+  public:\n+    virtual\n+    ~_Automaton()\n+    { }\n+\n+    virtual _SizeT\n+    _M_sub_count() const = 0;\n+\n+#ifdef _GLIBCXX_DEBUG\n+    virtual std::ostream&\n+    _M_dot(std::ostream& __ostr) const = 0;\n+#endif\n+  };\n+\n+  // Generic shred pointer to an automaton.  \n+  typedef std::shared_ptr<_Automaton> _AutomatonPtr;\n+\n+  // Operation codes that define the type of transitions within the base NFA\n+  // that represents the regular expression.\n+  enum _Opcode\n+  {\n+      _S_opcode_unknown       =   0,\n+      _S_opcode_alternative   =   1,\n+      _S_opcode_subexpr_begin =   4,\n+      _S_opcode_subexpr_end   =   5,\n+      _S_opcode_match         = 100,\n+      _S_opcode_accept        = 255\n+  };\n+\n+  // Provides a generic facade for a templated match_results.\n+  struct _Results\n+  {\n+    virtual void _M_set_pos(int __i, int __j, const _PatternCursor& __p) = 0;\n+    virtual void _M_set_matched(int __i, bool __is_matched) = 0;\n+  };\n+\n+  // Tags current state (for subexpr begin/end).\n+  typedef std::function<void (const _PatternCursor&, _Results&)> _Tagger;\n+\n+  template<typename _FwdIterT, typename _TraitsT>\n+    struct _StartTagger\n+    : public _Tagger\n+    {\n+      explicit\n+      _StartTagger(int __i)\n+      : _M_index(__i)\n+      { }\n+\n+      void\n+      operator()(const _PatternCursor& __pc, _Results& __r)\n+      { __r._M_set_pos(_M_index, 0, __pc); }\n+\n+      int       _M_index;\n+    };\n+\n+  template<typename _FwdIterT, typename _TraitsT>\n+    struct _EndTagger\n+    : public _Tagger\n+    {\n+      explicit\n+      _EndTagger(int __i)\n+      : _M_index(__i)\n+      { }\n+\n+      void\n+      operator()(const _PatternCursor& __pc, _Results& __r)\n+      { __r._M_set_pos(_M_index, 1, __pc); }\n+\n+      int       _M_index;\n+      _FwdIterT _M_pos;\n+    };\n+  // Indicates if current state matches cursor current.\n+  typedef std::function<bool (const _PatternCursor&)> _Matcher;\n+\n+  // Matches any character\n+  inline bool\n+  _AnyMatcher(const _PatternCursor&)\n+  { return true; }\n+\n+  // Matches a single character\n+  template<typename _InIterT, typename _TraitsT>\n+    struct _CharMatcher\n+    : public _Matcher\n+    {\n+      typedef typename _TraitsT::char_type char_type;\n+\n+      explicit\n+      _CharMatcher(char_type __c, const _TraitsT& __t = _TraitsT())\n+      : _M_traits(__t), _M_c(_M_traits.translate(__c))\n+      { }\n+\n+      bool\n+      operator()(const _PatternCursor& __pc) const\n+      {\n+\ttypedef const _SpecializedCursor<_InIterT>& _CursorT;\n+\t_CursorT __c = static_cast<_CursorT>(__pc);\n+\treturn _M_traits.translate(__c._M_current()) == _M_c;\n+      }\n+\n+      const _TraitsT& _M_traits;\n+      char_type       _M_c;\n+    };\n+\n+  // Matches a character range (bracket expression)\n+  template<typename _InIterT, typename _TraitsT>\n+    struct _RangeMatcher\n+    : public _Matcher\n+    {\n+      typedef typename _TraitsT::char_type _CharT;\n+      typedef std::basic_string<_CharT>    _StringT;\n+\n+      explicit\n+      _RangeMatcher(bool __is_non_matching, const _TraitsT& __t = _TraitsT())\n+      : _M_traits(__t), _M_is_non_matching(__is_non_matching)\n+      { }\n+\n+      bool\n+      operator()(const _PatternCursor& __pc) const\n+      {\n+\ttypedef const _SpecializedCursor<_InIterT>& _CursorT;\n+\t_CursorT __c = static_cast<_CursorT>(__pc);\n+\treturn true;\n+      }\n+\n+      void\n+      _M_add_char(_CharT __c)\n+      { }\n+\n+      void\n+      _M_add_collating_element(const _StringT& __s)\n+      { }\n+\n+      void\n+      _M_add_equivalence_class(const _StringT& __s)\n+      { }\n+\n+      void\n+      _M_add_character_class(const _StringT& __s)\n+      { }\n+\n+      void\n+      _M_make_range()\n+      { }\n+\n+      const _TraitsT& _M_traits;\n+      bool            _M_is_non_matching;\n+    };\n+\n+  // Identifies a state in the NFA.\n+  typedef int _StateIdT;\n+\n+  // The special case in which a state identifier is not an index.\n+  static const _StateIdT _S_invalid_state_id  = -1;\n+\n+\n+  // An individual state in an NFA\n+  //\n+  // In this case a \"state\" is an entry in the NFA definition coupled with its\n+  // outgoing transition(s).  All states have a single outgoing transition,\n+  // except for accepting states (which have no outgoing transitions) and alt\n+  // states, which have two outgoing transitions.\n+  //\n+  struct _State\n+  {\n+    typedef int  _OpcodeT;\n+\n+    _OpcodeT     _M_opcode;    // type of outgoing transition\n+    _StateIdT    _M_next;      // outgoing tranition\n+    _StateIdT    _M_alt;       // for _S_opcode_alternative\n+    unsigned int _M_subexpr;   // for _S_opcode_subexpr_*\n+    _Tagger      _M_tagger;    // for _S_opcode_subexpr_*\n+    _Matcher     _M_matches;   // for _S_opcode_match\n+\n+    explicit _State(_OpcodeT __opcode)\n+    : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n+    { }\n+\n+    _State(const _Matcher& __m)\n+    : _M_opcode(_S_opcode_match), _M_next(_S_invalid_state_id), _M_matches(__m)\n+    { }\n+\n+    _State(_OpcodeT __opcode, unsigned int __s, const _Tagger& __t)\n+    : _M_opcode(__opcode), _M_next(_S_invalid_state_id), _M_subexpr(__s),\n+      _M_tagger(__t)\n+    { }\n+\n+    _State(_StateIdT __next, _StateIdT __alt)\n+    : _M_opcode(_S_opcode_alternative), _M_next(__next), _M_alt(__alt)\n+    { }\n+\n+#ifdef _GLIBCXX_DEBUG\n+    std::ostream&\n+    _M_print(std::ostream& ostr) const;\n+\n+    // Prints graphviz dot commands for state.\n+    std::ostream&\n+    _M_dot(std::ostream& __ostr, _StateIdT __id) const;\n+#endif\n+  };\n+\n+  \n+  // The Grep Matcher works on sets of states.  Here are sets of states.\n+  typedef std::set<_StateIdT> _StateSet;\n+\n+ // A collection of all states making up an NFA\n+  //\n+  // An NFA is a 4-tuple M = (K, S, s, F), where\n+  //    K is a finite set of states,\n+  //    S is the alphabet of the NFA,\n+  //    s is the initial state,\n+  //    F is a set of final (accepting) states.\n+  //\n+  // This NFA class is templated on S, a type that will hold values of the\n+  // underlying alphabet (without regard to semantics of that alphabet).  The\n+  // other elements of the tuple are generated during construction of the NFA\n+  // and are available through accessor member functions.\n+  //\n+  class _Nfa\n+  : public _Automaton, public std::vector<_State>\n+  {\n+  public:\n+    typedef _State                              _StateT;\n+    typedef unsigned int                        _SizeT;\n+    typedef regex_constants::syntax_option_type _FlagT;\n+\n+  public:\n+    _Nfa(_FlagT __f)\n+    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0)\n+    { }\n+\n+    ~_Nfa()\n+    { }\n+\n+    _FlagT\n+    _M_options() const\n+    { return _M_flags; }\n+\n+    _StateIdT\n+    _M_start() const\n+    { return _M_start_state; }\n+\n+    const _StateSet&\n+    _M_final_states() const\n+    { return _M_accepting_states; }\n+\n+    _SizeT\n+    _M_sub_count() const\n+    { return _M_subexpr_count; }\n+\n+    _StateIdT\n+    _M_insert_accept()\n+    {\n+      this->push_back(_StateT(_S_opcode_accept));\n+      _M_accepting_states.insert(this->size()-1);\n+      return this->size()-1;\n+    }\n+\n+    _StateIdT\n+    _M_insert_alt(_StateIdT __next, _StateIdT __alt)\n+    {\n+      this->push_back(_StateT(__next, __alt));\n+      return this->size()-1;\n+    }\n+\n+    _StateIdT\n+    _M_insert_matcher(_Matcher __m)\n+    {\n+      this->push_back(_StateT(__m));\n+      return this->size()-1;\n+    }\n+\n+    _StateIdT\n+    _M_insert_subexpr_begin(const _Tagger& __t)\n+    {\n+      this->push_back(_StateT(_S_opcode_subexpr_begin, _M_subexpr_count++, __t));\n+      return this->size()-1;\n+    }\n+\n+    _StateIdT \n+    _M_insert_subexpr_end(unsigned int __i, const _Tagger& __t)\n+    {\n+      this->push_back(_StateT(_S_opcode_subexpr_end, __i, __t));\n+      return this->size()-1;\n+    }\n+\n+#ifdef _GLIBCXX_DEBUG\n+    std::ostream&\n+    _M_dot(std::ostream& __ostr) const;\n+#endif\n+\n+  private:\n+    _FlagT     _M_flags;\n+    _StateIdT  _M_start_state;\n+    _StateSet  _M_accepting_states;\n+    _SizeT     _M_subexpr_count;\n+  };\n+\n+  // Describes a sequence of one or more %_State, its current start and end(s).\n+  //\n+  // This structure contains fragments of an NFA during construction.\n+  class _StateSeq\n+  {\n+  public:\n+    // Constructs a single-node sequence\n+    _StateSeq(_Nfa& __ss, _StateIdT __s, _StateIdT __e = _S_invalid_state_id)\n+    : _M_nfa(__ss), _M_start(__s), _M_end1(__s), _M_end2(__e)\n+    { }\n+    // Constructs a split sequence from two other sequencces\n+    _StateSeq(const _StateSeq& __e1, const _StateSeq& __e2)\n+    : _M_nfa(__e1._M_nfa),\n+      _M_start(_M_nfa._M_insert_alt(__e1._M_start, __e2._M_start)),\n+      _M_end1(__e1._M_end1), _M_end2(__e2._M_end1)\n+    { }\n+\n+    // Constructs a split sequence from a single sequence\n+    _StateSeq(const _StateSeq& __e, _StateIdT __id)\n+    : _M_nfa(__e._M_nfa),\n+      _M_start(_M_nfa._M_insert_alt(__id, __e._M_start)),\n+      _M_end1(__id), _M_end2(__e._M_end1)\n+    { }\n+\n+    // Constructs a copy of a %_StateSeq\n+    _StateSeq(const _StateSeq& __rhs)\n+    : _M_nfa(__rhs._M_nfa), _M_start(__rhs._M_start),\n+      _M_end1(__rhs._M_end1), _M_end2(__rhs._M_end2)\n+    { }\n+\n+\n+    _StateSeq& operator=(const _StateSeq& __rhs);\n+\n+    _StateIdT\n+    _M_front() const\n+    { return _M_start; }\n+\n+    // Extends a sequence by one.\n+    void\n+    _M_push_back(_StateIdT __id);\n+\n+    // Extends and maybe joins a sequence.\n+    void\n+    _M_append(_StateIdT __id);\n+\n+    void\n+    _M_append(_StateSeq& __rhs);\n+\n+    // Clones an entire sequence.\n+    _StateIdT\n+    _M_clone();\n+\n+  private:\n+    _Nfa&     _M_nfa;\n+    _StateIdT _M_start;\n+    _StateIdT _M_end1;\n+    _StateIdT _M_end2;\n+\n+  };\n+\n+} // namespace __regex\n+} // namespace std\n+\n+#include <bits/regex_nfa.tcc>\n+"}, {"sha": "38ab7e0b2ae2cf7159d8a5d8922fa1e67acb95f9", "filename": "libstdc++-v3/include/bits/regex_nfa.tcc", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,170 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ * @file regex_nfa.cc\n+ */\n+#include <regex>\n+\n+namespace std\n+{\n+namespace __regex\n+{\n+#ifdef _GLIBCXX_DEBUG\n+inline std::ostream& _State::\n+_M_print(std::ostream& ostr) const\n+{\n+  switch (_M_opcode)\n+  {\n+    case _S_opcode_alternative:\n+      ostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n+      break;\n+    case _S_opcode_subexpr_begin:\n+      ostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n+      break;\n+    case _S_opcode_subexpr_end:\n+      ostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n+      break;\n+    case _S_opcode_match:\n+      ostr << \"match next=\" << _M_next;\n+      break;\n+    case _S_opcode_accept:\n+      ostr << \"accept next=\" << _M_next;\n+      break;\n+    default:\n+      ostr << \"unknown next=\" << _M_next;\n+      break;\n+  }\n+  return ostr;\n+}\n+\n+// Prints graphviz dot commands for state.\n+inline std::ostream& _State::\n+_M_dot(std::ostream& __ostr, _StateIdT __id) const\n+{\n+  switch (_M_opcode)\n+  {\n+    case _S_opcode_alternative:\n+      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\" \n+             << __id << \" -> \" << _M_next\n+             << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+             << __id << \" -> \" << _M_alt \n+             << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n+      break;\n+    case _S_opcode_subexpr_begin:\n+      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n+             << _M_subexpr << \"\\\"];\\n\" \n+             << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+      break;\n+    case _S_opcode_subexpr_end:\n+      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n+             << _M_subexpr << \"\\\"];\\n\" \n+             << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+      break;\n+    case _S_opcode_match:\n+      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\" \n+             << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+      break;\n+    case _S_opcode_accept:\n+      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n+      break;\n+    default:\n+      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nUNK\\\"];\\n\" \n+             << __id << \" -> \" << _M_next << \" [label=\\\"?\\\"];\\n\";\n+      break;\n+  }\n+  return __ostr;\n+}\n+\n+inline std::ostream& _Nfa::\n+_M_dot(std::ostream& __ostr) const\n+{\n+  __ostr << \"digraph _Nfa {\\n\"\n+   << \"  rankdir=LR;\\n\";\n+  for (unsigned int __i = 0; __i < this->size(); ++__i)\n+  { this->at(__i)._M_dot(__ostr, __i); }\n+  __ostr << \"}\\n\";\n+  return __ostr;\n+}\n+#endif\n+\n+inline _StateSeq& _StateSeq::\n+operator=(const _StateSeq& __rhs)\n+{\n+  _M_start = __rhs._M_start;\n+  _M_end1  = __rhs._M_end1;\n+  _M_end2  = __rhs._M_end2;\n+  return *this;\n+}\n+\n+inline void _StateSeq::\n+_M_push_back(_StateIdT __id)\n+{\n+  if (_M_end1 != _S_invalid_state_id)\n+    _M_nfa[_M_end1]._M_next = __id;\n+  _M_end1 = __id;\n+}\n+\n+inline void _StateSeq::\n+_M_append(_StateIdT __id)\n+{\n+  if (_M_end2 != _S_invalid_state_id)\n+  {\n+    if (_M_end2 == _M_end1)\n+      _M_nfa[_M_end2]._M_alt = __id;\n+    else\n+      _M_nfa[_M_end2]._M_next = __id;\n+    _M_end2 = _S_invalid_state_id;\n+  }\n+  if (_M_end1 != _S_invalid_state_id)\n+    _M_nfa[_M_end1]._M_next = __id;\n+  _M_end1 = __id;\n+}\n+\n+inline void _StateSeq::\n+_M_append(_StateSeq& __rhs)\n+{\n+  if (_M_end2 != _S_invalid_state_id)\n+  {\n+    if (_M_end2 == _M_end1)\n+      _M_nfa[_M_end2]._M_alt = __rhs._M_start;\n+    else\n+      _M_nfa[_M_end2]._M_next = __rhs._M_start;\n+    _M_end2 = _S_invalid_state_id;\n+  }\n+  if (__rhs._M_end2 != _S_invalid_state_id)\n+    _M_end2 = __rhs._M_end2;\n+  if (_M_end1 != _S_invalid_state_id)\n+    _M_nfa[_M_end1]._M_next = __rhs._M_start;\n+  _M_end1 = __rhs._M_end1;\n+}\n+\n+// @todo implement this function.\n+inline _StateIdT _StateSeq::\n+_M_clone()\n+{ return 0; }\n+\n+} // namespace __regex\n+} // namespace std\n+"}, {"sha": "95ad4239459e24d99cd253436da78f502372512c", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -35,33 +35,30 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n #include <algorithm>\n #include <bitset>\n+#include <functional>\n+#ifdef _GLIBCXX_DEBUG\n+# include <iosfwd>\n+#endif\n #include <iterator>\n #include <locale>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stack>\n #include <stdexcept>\n #include <string>\n-#include <vector>\n #include <utility>\n-#include <sstream>\n+#include <vector>\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  include <tr1_impl/regex>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_CXX0X\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n-#  include <tr1_impl/regex>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_CXX0X\n-#endif\n+#include <bits/regex_constants.h>\n+#include <bits/regex_error.h>\n+#include <bits/regex_cursor.h>\n+#include <bits/regex_nfa.h>\n+#include <bits/regex_compiler.h>\n+#include <bits/regex_grep_matcher.h>\n+#include <bits/regex.h>\n \n #endif // __GXX_EXPERIMENTAL_CXX0X__\n "}, {"sha": "072d5d07f403a9c80788a179c715c202ec5c0cff", "filename": "libstdc++-v3/testsuite/28_regex/03_requirements/typedefs.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F03_requirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F03_requirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F03_requirements%2Ftypedefs.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  typedef std::regex_traits<char> traits;\n+\n+  typedef traits::char_type       char_type;\n+  typedef traits::string_type     string_type;\n+  typedef traits::locale_type     locale_type;\n+  typedef traits::char_class_type char_class_type;\n+}"}, {"sha": "e8ddb77bbb389e5fdab0718dbb04bba3eda95ad9", "filename": "libstdc++-v3/testsuite/28_regex/04_header/regex/std_c++0x_neg.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F04_header%2Fregex%2Fstd_c%2B%2B0x_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F04_header%2Fregex%2Fstd_c%2B%2B0x_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F04_header%2Fregex%2Fstd_c%2B%2B0x_neg.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++98\" }\n+\n+// Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <regex>  // { dg-excess-errors \"In file included from\" }\n+\n+"}, {"sha": "1841a462688780b3b4052ca40265d932cafed8e9", "filename": "libstdc++-v3/testsuite/28_regex/05_constants/error_type.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Ferror_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Ferror_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Ferror_type.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,54 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do compile }\n+//\n+// 2009-06-17  Stephen M. Webb  <stephen.webb@xandros.com>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.5.3 \n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex_constants::error_type err __attribute__((unused));\n+\n+\terr = std::regex_constants::error_collate;\n+\terr = std::regex_constants::error_ctype;\n+\terr = std::regex_constants::error_escape;\n+\terr = std::regex_constants::error_backref;\n+\terr = std::regex_constants::error_brack;\n+\terr = std::regex_constants::error_paren;\n+\terr = std::regex_constants::error_brace;\n+\terr = std::regex_constants::error_badbrace;\n+\terr = std::regex_constants::error_range;\n+\terr = std::regex_constants::error_space;\n+\terr = std::regex_constants::error_badrepeat;\n+\terr = std::regex_constants::error_complexity;\n+\terr = std::regex_constants::error_stack;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "10635ff5f7f9c45fc42d3a83dc5631b6d90f9054", "filename": "libstdc++-v3/testsuite/28_regex/05_constants/match_flag_type.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fmatch_flag_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fmatch_flag_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fmatch_flag_type.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do compile }\n+//\n+// 2009-06-17  Stephen M. Webb  <stephen.webb@xandros.com>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.5.1 \n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex_constants::match_flag_type flag = std::regex_constants::match_default;\n+\n+\tflag |= std::regex_constants::match_not_bol;\n+\tflag |= std::regex_constants::match_not_eol;\n+\tflag |= std::regex_constants::match_not_bow;\n+\tflag |= std::regex_constants::match_not_eow;\n+\tflag |= std::regex_constants::match_any;\n+\tflag |= std::regex_constants::match_not_null;\n+\tflag |= std::regex_constants::match_continuous;\n+\tflag |= std::regex_constants::match_prev_avail;\n+\tflag |= std::regex_constants::format_default;\n+\tflag |= std::regex_constants::format_sed;\n+\tflag |= std::regex_constants::format_no_copy;\n+\tflag |= std::regex_constants::format_first_only;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2aebf46d19e8b2ee9f19dc6b06352c684268cf8d", "filename": "libstdc++-v3/testsuite/28_regex/05_constants/syntax_option_type.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fsyntax_option_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fsyntax_option_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F05_constants%2Fsyntax_option_type.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do compile }\n+//\n+// 2009-06-17  Stephen M. Webb  <stephen.webb@xandros.com>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.5.1 \n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex_constants::syntax_option_type option = 0;\n+\n+\toption |= std::regex_constants::icase;\n+\toption |= std::regex_constants::nosubs;\n+\toption |= std::regex_constants::optimize;\n+\toption |= std::regex_constants::collate;\n+\toption |= std::regex_constants::ECMAScript;\n+\toption |= std::regex_constants::basic;\n+\toption |= std::regex_constants::extended;\n+\toption |= std::regex_constants::awk;\n+\toption |= std::regex_constants::grep;\n+\toption |= std::regex_constants::egrep;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "04fd71242775b303a99b1868048166c1e2b028a2", "filename": "libstdc++-v3/testsuite/28_regex/06_exception_type/regex_error.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F06_exception_type%2Fregex_error.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F06_exception_type%2Fregex_error.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F06_exception_type%2Fregex_error.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do compile }\n+//\n+// 2009-06-17  Stephen M. Webb  <stephen.webb@xandros.com>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.6 [re.badexp]\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex_error error(std::regex_constants::error_collate);\n+\tVERIFY(error.code() == std::regex_constants::error_collate);\n+\n+\ttry\n+\t{\n+\t\tthrow error;\n+\t}\n+\tcatch (std::runtime_error& ex)\n+\t{\n+\t}\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6f5a2f3ab8d96fb0ef9015fde10730069711743c", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/ctor.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fctor.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do link }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.7] class template regex_traits\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the regex_traits class.  There is only the\n+// default constructor.\n+void test01()\n+{\n+\tbool test __attribute__((unused)) = true;\n+  typedef std::regex_traits<char> test_type;\n+\n+  // required default constructor\n+  test_type t;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type       char_type;\n+  typedef test_type::string_type     string_type;\n+  typedef test_type::locale_type     locale_type;\n+  typedef test_type::char_class_type char_class_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "cb8664ca8bfefa62541ceaae0d6baa5e835f4412", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/isctype.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fisctype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fisctype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fisctype.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do run { xfail *-*-* } }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-23  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2(4) Table 127 - Regular expression traits class requirements\n+// 28.7(11) Class template regex_traits [re.traits]\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+  typedef std::regex_traits<CharT> traits;\n+\n+\tchar name[] = \"lower\";\n+\ttraits t;\n+\n+\tVERIFY( t.isctype('e',  t.lookup_classname(name, name+sizeof(name)-1)) );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "55406dd0dedf27d671ac2365c1c8e134b3a8fc1c", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/length.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flength.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flength.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flength.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+// 28.7 (3) static std::size_t length(const char_type* p);\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  typedef char CharT;\n+  typedef std::regex_traits<CharT> traits;\n+  bool test __attribute__((unused)) = true;\n+  const CharT* p = \"\";\n+\n+\tstd::size_t i = traits::length(p);\n+\n+\tVERIFY( i == 0 );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "49ffb511adda7f3495e9f6b0f4b4a0d0a6ddea4f", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/lookup_classname.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flookup_classname.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flookup_classname.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flookup_classname.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do run { xfail *-*-* } }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-23  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2(4) Table 127 - Regular expression traits class requirements\n+// 28.7(9) Class template regex_traits [re.traits]\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+  typedef std::regex_traits<CharT> traits;\n+\n+\tchar n1[] = \"lower\";\n+\tchar n2[] = \"alpha\";\n+\ttraits t;\n+\n+  traits::char_class_type c1 = t.lookup_classname(n1, n1+sizeof(n1)-1);\n+  VERIFY( c1 != 0 );\n+\n+  traits::char_class_type c2 = t.lookup_classname(n1, n1+sizeof(n1)-1, true);\n+  traits::char_class_type c3 = t.lookup_classname(n2, n2+sizeof(n2)-1, true);\n+\tVERIFY( c2 == c3 );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "58eb5878de51f5d2f5c5ce852b279607d21be3c9", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/lookup_collatename.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flookup_collatename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flookup_collatename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Flookup_collatename.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do run { xfail *-*-* } }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-23  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 (8) Class template regex_traits [re.traits]\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+  typedef std::regex_traits<CharT> traits;\n+\n+\tchar name[] = \"ll\";\n+\ttraits t;\n+\n+\ttraits::string_type sname = t.lookup_collatename(name, name+sizeof(name)-1);\n+\n+  VERIFY( !sname.empty() );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "1481dcfbb8c1f6e965d89eefb1a50c36b37506cb", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/transform.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftransform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftransform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftransform.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+\n+#include <regex>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+  typedef std::regex_traits<CharT> traits;\n+\n+\ttraits t;\n+\ttraits::string_type G = \"abc\";\n+\ttraits::string_type H = \"def\";\n+\n+  VERIFY( G < H );\n+  VERIFY( t.transform(G.begin(), G.end()) < t.transform(H.begin(), H.end()) );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "7de8904b49a7d255d4e471a6ca3ad0ccb646e0d5", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/transform_primary.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftransform_primary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftransform_primary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftransform_primary.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+\n+#include <regex>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+  typedef std::regex_traits<CharT> traits;\n+\n+\ttraits t;\n+\ttraits::string_type G = \"abc\";\n+\ttraits::string_type H = \"def\";\n+\ttraits::string_type J = \"ABC\";\n+\n+  VERIFY( G < H );\n+  VERIFY( t.transform_primary(G.begin(), G.end()) < t.transform_primary(H.begin(), H.end()) ); \n+\n+  VERIFY( G == H );\n+  VERIFY( t.transform_primary(G.begin(), G.end()) == t.transform_primary(J.begin(), J.end()) );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "2dbbba396370e9031ee64955fb643621f42bb6a2", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/translate.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftranslate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftranslate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftranslate.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg_do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+// 28.7 (3) static std::size_t length(const char_type* p);\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+\n+  std::regex_traits<CharT> t;\n+  CharT c = 'a';\n+  CharT d = 'a';\n+\n+  VERIFY( t.translate(c) == t.translate(d) );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "4c963ddd3a5fad648d37e0f9133af89acf6c7042", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/translate_nocase.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftranslate_nocase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftranslate_nocase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Ftranslate_nocase.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.7] class template regex_traits (5) translate_nocase\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Verifies the workings of the regex_traits translate_nocase function.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef char CharT;\n+\n+  std::regex_traits<CharT> t;\n+  CharT c = 'a';\n+  CharT C = 'A';\n+\n+  VERIFY( t.translate_nocase(c) == t.translate_nocase(C) );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "f0535acb2ccc9e4e7c3eec9a68447025216e4f8b", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/char/value.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fchar%2Fvalue.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2008-08-11  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.7] class template regex_traits value() function\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests the value() function of the regex_traits<char> class.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::regex_traits<char> t;\n+  VERIFY( t.value('7', 8)  == 7 );\n+  VERIFY( t.value('7', 10) == 7 );\n+  VERIFY( t.value('7', 16) == 7 );\n+  VERIFY( t.value('9', 8)  == -1 );\n+  VERIFY( t.value('9', 10) == 9 );\n+  VERIFY( t.value('9', 16) == 9 );\n+  VERIFY( t.value('d', 8)  == -1 );\n+  VERIFY( t.value('d', 10) == -1 );\n+  VERIFY( t.value('d', 16) == 13 );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "39caf432d32aec3d18a23aa7573d37122a70b337", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/wchar_t/ctor.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Fctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Fctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Fctor.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do link }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.7] class template regex_traits\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the regex_traits class.  There is only the\n+// default constructor.\n+void test01()\n+{\n+  typedef std::regex_traits<wchar_t> test_type;\n+\n+  // required default constructor\n+  test_type t;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type       char_type;\n+  typedef test_type::string_type     string_type;\n+  typedef test_type::locale_type     locale_type;\n+  typedef test_type::char_class_type char_class_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "c3cd7b60d0cceb8c91f81f450ca038a515b0f4b9", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/wchar_t/length.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Flength.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Flength.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Flength.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+// 28.7 (3) static std::size_t length(const char_type* p);\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  typedef wchar_t CharT;\n+  typedef std::regex_traits<CharT> traits;\n+  bool test __attribute__((unused)) = true;\n+  const CharT* p = L\"\";\n+\n+\tstd::size_t i = traits::length(p);\n+\n+\tVERIFY( i == 0 );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "c1f7af44d71c84575609cdd7102e5ecc850fa672", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/wchar_t/transform.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftransform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftransform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftransform.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+\n+#include <regex>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef wchar_t CharT;\n+  typedef std::regex_traits<CharT> traits;\n+\n+\ttraits t;\n+\ttraits::string_type G = L\"abc\";\n+\ttraits::string_type H = L\"def\";\n+\n+  VERIFY( G < H );\n+  VERIFY( t.transform(G.begin(), G.end()) < t.transform(H.begin(), H.end()) );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "962c381520c6fd6dbf11ec432e7a141b2eb3ede2", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/wchar_t/translate.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftranslate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftranslate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftranslate.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-02-17  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.3 Requirements [re.req]\n+// 28.2 (4) Table 127 - Regular expression traits class requirements\n+// 28.7 Class template regex_traits [re.traits]\n+// 28.7 (3) static std::size_t length(const char_type* p);\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef wchar_t CharT;\n+\n+  std::regex_traits<CharT> t;\n+  CharT c = L'a';\n+  CharT d = L'a';\n+\n+  VERIFY( t.translate(c) == t.translate(d) );\n+}\n+\n+int main()\n+{\n+\ttest01();\n+\treturn 0;\n+}"}, {"sha": "5602cf00117bc7997a3fc144982962fd308fae8f", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/wchar_t/translate_nocase.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftranslate_nocase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftranslate_nocase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Ftranslate_nocase.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.7] class template regex_traits (5) translate_nocase\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Verifies the workings of the regex_traits translate_nocase function.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef wchar_t CharT;\n+\n+  std::regex_traits<CharT> t;\n+  CharT c = L'a';\n+  CharT C = L'A';\n+\n+  VERIFY( t.translate_nocase(c) == t.translate_nocase(C) );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "f0535acb2ccc9e4e7c3eec9a68447025216e4f8b", "filename": "libstdc++-v3/testsuite/28_regex/07_traits/wchar_t/value.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F07_traits%2Fwchar_t%2Fvalue.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2008-08-11  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.7] class template regex_traits value() function\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests the value() function of the regex_traits<char> class.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::regex_traits<char> t;\n+  VERIFY( t.value('7', 8)  == 7 );\n+  VERIFY( t.value('7', 10) == 7 );\n+  VERIFY( t.value('7', 16) == 7 );\n+  VERIFY( t.value('9', 8)  == -1 );\n+  VERIFY( t.value('9', 10) == 9 );\n+  VERIFY( t.value('9', 16) == 9 );\n+  VERIFY( t.value('d', 8)  == -1 );\n+  VERIFY( t.value('d', 10) == -1 );\n+  VERIFY( t.value('d', 16) == 13 );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "1552818e9871618fe9bf0155000920beea935aae", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/cstring.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fcstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2009-06-05  Stephen M. Webb  <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++0X [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a C-style null-terminated-string.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::basic_regex<char> re;\n+\n+  const char* cs = \"aab\";\n+  re.assign(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "12353023b383a756e3ad4103bfa1ad5f2953732f", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/cstring_op.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fcstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fcstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fcstring_op.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assign operator from a C-style null-terminated-string.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  const char* cs = \"aab\";\n+  test_type re;\n+  re = cs;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "64f5bcac570679d38194507d1be94d48118d53b7", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/moveable.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fmoveable.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-07-07  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3](9-11) class template basic_regex assign\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <utility>\n+\n+// Tests assign operator of the basic_regex class for moveable rvalues.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex src_re(\"aaba\");\n+  const unsigned mark_count = src_re.mark_count();\n+\tconst std::regex::flag_type flags = src_re.flags();\n+\n+\tstd::regex target_re;\n+  \n+  target_re.assign(std::move(src_re));\n+  \n+\tVERIFY( target_re.flags() == flags );\n+\tVERIFY( target_re.mark_count() == mark_count );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "398b66c60639643e3002dd356339e7926ec9dca3", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/pstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fpstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fpstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fpstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a Pascal-style counted-string.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  const char cs[] = \"aab\";\n+  test_type re;\n+  re.assign(cs, sizeof(cs)-1, std::regex_constants::basic);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "cd741d5fff295e77d215a98573b1c97cb081f997", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/range.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Frange.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range assign of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  char s[] = \"a+b|c\";\n+  test_type re;\n+  re.assign(s, s + 5);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "afa071eb312b74728fe0f1b93a59706d4c0ea37e", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/string.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C++ string assignment of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  std::string s(\"a*b\");\n+  test_type re;\n+  re.assign(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "724872decd50bf34efe0a385e18ab335b30d82df", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/char/string_op.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fchar%2Fstring_op.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assignment operator from a C++ string;\n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  std::string s(\"a*b\");\n+  test_type re;\n+  re = s;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "20ccab01244a4e34453d32246ddd1eedd06c91ce", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/wchar_t/cstring.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fcstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a C-style null-terminated-string.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re;\n+  re.assign(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "8d8e9656d9e1dc71dfd28fefe16ec91aa74d1a48", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/wchar_t/cstring_op.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fcstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fcstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fcstring_op.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assign operator from a C-style null-terminated-string.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re;\n+  re = cs;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "9034a542c015d1f9bfcfd4d52c8b684df1f797c4", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/wchar_t/pstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fpstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fpstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fpstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a Pascal-style counted-string.  \n+void test01()\n+{\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t cs[] = L\"aab\";\n+  test_type re;\n+  re.assign(cs, sizeof(cs)-1, std::regex_constants::basic);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "2e31a708417073b7bce9015ad1186a03e661822d", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/wchar_t/range.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Frange.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range assign of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<wchar_t> test_type;\n+  bool test __attribute__((unused)) = true;\n+\n+  wchar_t s[] = L\"a+b|c\";\n+  test_type re;\n+  re.assign(s, s + 5);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "156374ac1a7cce09bf17eb87a58ebe56457518f8", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/wchar_t/string.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C++ string assignment of the basic_regex class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  std::wstring s(L\"a*b\");\n+  test_type re;\n+  re.assign(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "43704af2bd108b824d900c65b8e8c29a3f2f939c", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/assign/wchar_t/string_op.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fassign%2Fwchar_t%2Fstring_op.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assignment operator from a C++ string;\n+void test01()\n+{\n+\tbool test __attribute__((unused)) = true;\n+\ttypedef std::basic_regex<wchar_t> test_type;\n+\n+  std::wstring s(L\"a*b\");\n+  test_type re;\n+  re = s;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "b91453c0e775f32b9b70cab556bf06e8cd703dac", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/basic/cstring.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fcstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <regex>\n+\n+void\n+test01() \n+{ \n+  std::regex re(\"(a|b)*abb\", std::regex::basic);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2f011fe52c425c72c7a16ca9db297305c5a34ebe", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/basic/pstring_char.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fpstring_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fpstring_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fpstring_char.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests Pascal-style counted-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  const char* cs = \"aab\";\n+\tstd::regex re(cs, 3, std::regex::basic);\n+\n+  VERIFY( re.flags() & std::regex_constants::basic );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "89deef6f19feb95d6fe90822ba8b4bbb4f753353", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/basic/pstring_wchar_t.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fpstring_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fpstring_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fpstring_wchar_t.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests Pascal-style counted-string constructor of the basic_regex class.  \n+void test01()\n+{\n+\tbool test __attribute__((unused)) = true;\n+\n+  const wchar_t* cs = L\"aab\";\n+\tstd::wregex re(cs, 3, std::wregex::basic);\n+\n+  VERIFY( re.flags() & std::regex_constants::basic );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "471c89c902442c7fc919e2877bb0423bd31c1fd6", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/basic/string_range_01_02_03.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fstring_range_01_02_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fstring_range_01_02_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fbasic%2Fstring_range_01_02_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.8.2 basic_regex ctor\n+// Tests for invalid range expression\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\ttry\n+\t{\n+\t\tstd::regex  re(\"a\\\\{1,2,3\\\\}\", std::regex::basic);\n+\t}\n+\tcatch (std::regex_error& ex)\n+\t{\n+\t\tVERIFY( ex.code() == std::regex_constants::error_badbrace );\n+\t}\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "ac87e4d69a0df37dda4c9b609872b893eb1dfeb1", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/cstring.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C-style null-terminated-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  const char* cs = \"aab\";\n+  test_type re(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "8b93fe7a7214f48c4faadc30ad0a3a5c780fbb48", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/cstring_awk.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_awk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_awk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_awk.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <regex>\n+\n+void\n+test01() \n+{ \n+  std::regex re(\"(a|b)*abb\", std::regex::awk);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6c72736c5cdd9959a068ad7d9e60ed2873c50275", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/cstring_ecma.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_ecma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_ecma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_ecma.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <regex>\n+\n+void\n+test01() \n+{ \n+  std::regex re(\"(a|b)*abb\");\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f38a9b8704e416352d52ed337eaa67ee26529573", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/cstring_egrep.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_egrep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_egrep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_egrep.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <regex>\n+\n+void\n+test01() \n+{ \n+  std::regex re(\"(a|b)*abb\", std::regex::egrep);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "458f6d21cc5d1d1e806640a925b0c4a78b7157eb", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/cstring_grep.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_grep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_grep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fcstring_grep.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <regex>\n+\n+void\n+test01() \n+{ \n+  using std::regex;\n+\n+  regex re(\"(a|b)*abb\", regex::grep);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b7c6f410cde8738a726a572a9561a6ff4bfc7796", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/default.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  // default constructor\n+  test_type re;\n+  \n+  // Check for required typedefs\n+  typedef test_type::value_type  value_type;\n+  typedef test_type::flag_type   flag_type;\n+  typedef test_type::locale_type locale_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "027a927849e0a5017199a442f74653b9602d7bc6", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/char/range.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fchar%2Frange.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  char s[] = \"a+b|c\";\n+  test_type re(s, s + 5);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "4ed5f92c8b044aab965de2959661d7345ddd3834", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/copy_char.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fcopy_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fcopy_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fcopy_char.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2010-07-07  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2](11) class template basic_regex constructors\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests copy constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  test_type src_re(\"aaba\");\n+\n+  test_type target_re(src_re);\n+  \n+\tVERIFY( target_re.flags() == src_re.flags() );\n+\tVERIFY( target_re.mark_count() == src_re.mark_count() );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "691b8c7f5f181d8fe07bee4d79a2d363c7b7c3f5", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/extended/cstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fextended%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fextended%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fextended%2Fcstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01() \n+{ \n+  bool test __attribute__((unused)) = true;\n+\n+  std::regex re(\"(wee|week)(knights|night)\", std::regex::extended);\n+  \n+  VERIFY( re.flags() == std::regex::extended );\n+  VERIFY( re.mark_count() == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "036321face5f3b7bd42a03673bd99c74ae7f842a", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/extended/string_range_01_02_03.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fextended%2Fstring_range_01_02_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fextended%2Fstring_range_01_02_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fextended%2Fstring_range_01_02_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.8.2 basic_regex ctor\n+// Tests for invalid range expression\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\ttry\n+\t{\n+\t\tstd::regex  re(\"a{1,2,3}\", std::regex::extended);\n+\t}\n+\tcatch (std::regex_error& ex)\n+\t{\n+\t\tVERIFY( ex.code() == std::regex_constants::error_badbrace );\n+\t}\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "ba056969c5c0b6b5c82603df5cfe5d45c2e4228f", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/move_char.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fmove_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fmove_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fmove_char.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-07-07  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2](12-14) class template basic_regex constructors\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <utility>\n+\n+// Tests move constructor of the basic_regex class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<char> test_type;\n+\n+  test_type src_re(\"aaba\");\n+  const unsigned mark_count = src_re.mark_count();\n+\tconst test_type::flag_type flags = src_re.flags();\n+\n+  test_type target_re = std::move(src_re);\n+  \n+\tVERIFY( target_re.flags() == flags );\n+\tVERIFY( target_re.mark_count() == mark_count );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "f65d783a73539b3d1051e1ea5fc2846d61e6fbd9", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/string_char.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fstring_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fstring_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fstring_char.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <string>\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// Tests C++ string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::basic_regex<char> test_type;\n+\n+  std::string s(\"a*b\");\n+  test_type re(s);\n+}\n+\n+void test02()\n+{\n+  typedef std::basic_regex<char> test_type;\n+  typedef __gnu_test::tracker_allocator<char> alloc_type;\n+\n+  std::basic_string<char, std::char_traits<char>, alloc_type> s(\"a*b\");\n+  test_type re(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  test02();\n+  return 0;\n+};"}, {"sha": "b715195c383a002a429da238044fa59e9b63669b", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/string_wchar_t.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fstring_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fstring_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fstring_wchar_t.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,56 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <string>\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// Tests C++ string constructor of the basic_regex class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  std::wstring s(L\"a*b\");\n+  test_type re(s);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+  typedef __gnu_test::tracker_allocator<wchar_t> alloc_type;\n+\n+  std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc_type> s(L\"a*b\");\n+  test_type re(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  test02();\n+  return 0;\n+};"}, {"sha": "4dabf3996771122813ba31ccd68ebce1face816f", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/wchar_t/cstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Fcstring.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C-style null-terminated-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "a0f41740229397ff03543f299676ae9c7c252620", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/wchar_t/default.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the basic_regex class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  // default constructor\n+  test_type re;\n+  \n+  // Check for required typedefs\n+  typedef test_type::value_type  value_type;\n+  typedef test_type::flag_type   flag_type;\n+  typedef test_type::locale_type locale_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "efc0597cc1dbcf39033c1ca388c6c1bf19adbcfb", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/ctors/wchar_t/range.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fctors%2Fwchar_t%2Frange.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// [28.8.2] class template basic_regex constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range constructor of the basic_regex class.  \n+void test01()\n+{\n+\tbool test __attribute__((unused)) = true;\n+  typedef std::basic_regex<wchar_t> test_type;\n+\n+  wchar_t s[] = L\"a+b|c\";\n+  test_type re(s, s + 5);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "8a803ede81f325ef471bbbbd4c8c32c9ee18661e", "filename": "libstdc++-v3/testsuite/28_regex/08_basic_regex/regex.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fregex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fregex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F08_basic_regex%2Fregex.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 7.4 typedef std::regex\n+\n+#include <regex>\n+\n+void\n+test01() \n+{ \n+  std::regex re;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6beb9c5cdb2992bbb83059be3e982446b73da8e2", "filename": "libstdc++-v3/testsuite/28_regex/09_sub_match/cast_char.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Fcast_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Fcast_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Fcast_char.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-09  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.9.1 [re.submatch.members] sub_match members\n+\n+#include <regex>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef char                          value_type;\n+  typedef std::basic_string<value_type> string_type;\n+  typedef std::sub_match<value_type*>   sub_match_type;\n+  value_type test_data[] = \"cabbage\";\n+\n+\tsub_match_type sm;\n+\tsm.first = test_data + 0;\n+\tsm.second  = test_data + sizeof(test_data)/sizeof(value_type);\n+\tsm.matched = true;\n+\n+\tstring_type sm_string = sm;\n+\n+\tVERIFY( sm_string == string_type(test_data) );\n+}"}, {"sha": "6e29ac88c095dc5b7c96d7508a4e9edc18bc9bc9", "filename": "libstdc++-v3/testsuite/28_regex/09_sub_match/cast_wchar_t.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Fcast_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Fcast_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Fcast_wchar_t.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-09  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.9.1 [re.submatch.members] sub_match members\n+\n+#include <regex>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef wchar_t                       value_type;\n+  typedef std::basic_string<value_type> string_type;\n+  typedef std::sub_match<value_type*>   sub_match_type;\n+  value_type test_data[] = L\"cabbage\";\n+\n+\tsub_match_type sm;\n+\tsm.first = test_data + 0;\n+\tsm.second  = test_data + sizeof(test_data)/sizeof(value_type);\n+\tsm.matched = true;\n+\n+\tstring_type sm_string = sm;\n+\n+\tVERIFY( sm_string == string_type(test_data) );\n+}"}, {"sha": "fc12b920ad98081687dd853fdd5950dbe58df4cd", "filename": "libstdc++-v3/testsuite/28_regex/09_sub_match/length.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Flength.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Flength.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Flength.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-09  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.9.1 [re.submatch.members] sub_match members\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::sub_match<const char*> sm_t;\n+  const char*           test_data = \"cabbage\";\n+  sm_t::difference_type test_len = 3;\n+\n+\tsm_t sm1;\n+\tsm1.first   = test_data + 0;\n+\tsm1.second  = test_data + test_len;\n+\tsm1.matched = true;\n+\n+\tsm_t sm2;\n+\tsm2.matched = false;\n+\n+\tVERIFY( sm1.length() == test_len );\n+\tVERIFY( sm2.length() == 0 );\n+}"}, {"sha": "c150da02dac91a99c55edf9e11df0f0a609718ac", "filename": "libstdc++-v3/testsuite/28_regex/09_sub_match/typedefs.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F09_sub_match%2Ftypedefs.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-07  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.9 Class template sub_match\n+\n+#include <regex>\n+\n+\n+void\n+test01()\n+{\n+  typedef std::sub_match<char*> sm;\n+\n+  typedef sm::value_type       value_type;\n+  typedef sm::difference_type  difference_type;\n+  typedef sm::iterator         iterator;\n+  typedef sm::string_type      string_type;\n+}"}, {"sha": "4c897d7a4a0d8f0e0868cb20fec193aceacf4925", "filename": "libstdc++-v3/testsuite/28_regex/10_match_results/ctors/char/default.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Fctors%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Fctors%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Fctors%2Fchar%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2009-06-10  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++0X [28.10.1] class template match_results constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the match_result class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::cmatch cm;\n+  VERIFY( cm.size() == 0 );\n+  VERIFY( cm.str() == std::cmatch::string_type() );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::smatch sm;\n+  VERIFY( sm.size() == 0 );\n+  VERIFY( sm.str() == std::smatch::string_type() );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  test02();\n+  return 0;\n+};"}, {"sha": "f8b3d45e867f0948353d3b0df1ef5b8e7a00cf4c", "filename": "libstdc++-v3/testsuite/28_regex/10_match_results/ctors/wchar_t/default.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Fctors%2Fwchar_t%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Fctors%2Fwchar_t%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Fctors%2Fwchar_t%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// 2009-06-05  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// C++0X [28.10.1] class template match_results constructor\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the match_result class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::wcmatch cm;\n+  VERIFY( cm.size() == 0 );\n+  VERIFY( cm.str() == std::wcmatch::string_type() );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::wsmatch sm;\n+  VERIFY( sm.size() == 0 );\n+  VERIFY( sm.str() == std::wsmatch::string_type() );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  test02();\n+  return 0;\n+};"}, {"sha": "02bdcdadb7192b58b1c938026fbf2b64beccd09f", "filename": "libstdc++-v3/testsuite/28_regex/10_match_results/typedefs.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F10_match_results%2Ftypedefs.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.10 Class template sub_match\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::match_results<char*> mr;\n+\n+  typedef mr::value_type       value_type;\n+  typedef mr::const_reference  const_reference;\n+  typedef mr::reference        reference;\n+  typedef mr::const_iterator   const_iterator;\n+  typedef mr::iterator         iterator;\n+  typedef mr::difference_type  difference_type;\n+  typedef mr::size_type        size_type;\n+  typedef mr::allocator_type   allocator_type;\n+  typedef mr::char_type        char_type;\n+  typedef mr::string_type      string_type;\n+}"}, {"sha": "4a7161a79673628d78e7dff24b780439936778c9", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/basic/string_01.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_01.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-11  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests BRE against a std::string target.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"\\\\(a\\\\).*\", std::regex::basic);\n+\tstd::string target(\"aaba\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+\tVERIFY( m[1].first == target.begin() );\n+\tVERIFY( m[1].second == target.begin()+1 );\n+\tVERIFY( m[1].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "6c0fdd76f2ce3e832f1ab82727d441f62ad7b775", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/basic/string_range_00_03.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_00_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_00_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_00_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests BRE against a std::string target, exercising range {0,3}\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"a\\\\{0,3\\\\}\", std::regex::basic);\n+\tstd::string target(\"aa\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "3439b544b63b9ce2d2350325fc7cb4fe3c40f4e7", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/basic/string_range_01_03.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_01_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_01_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_01_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests BRE against a std::string target, exercising range {1,3}\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"a\\\\{1,3\\\\}\", std::regex::basic);\n+\tstd::string target(\"aa\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "dfd00a0f3d7d58e1472166f86e9c074407b4492d", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/basic/string_range_02_03.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_02_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_02_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fbasic%2Fstring_range_02_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests BRE against a std::string target, exercising range {2,3}\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"a\\\\{2,3\\\\}\", std::regex::basic);\n+\tstd::string target(\"aa\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "ad0f57e221daac69be274f8ed231aa66ce9e892d", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/extended/cstring_plus.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fcstring_plus.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fcstring_plus.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fcstring_plus.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-06-21  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ERE against a C-string target, plus-sign match.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"(a+)\", std::regex::extended);\n+\tconst char target[] = \"aa\";\n+\tstd::cmatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( re.mark_count() == 1 );\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target );\n+\tVERIFY( m.prefix().second == target );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target+sizeof(target) );\n+\tVERIFY( m.suffix().second == target+sizeof(target) );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target );\n+\tVERIFY( m[0].second == target+sizeof(target) );\n+\tVERIFY( m[0].matched == true );\n+\tVERIFY( m[1].first == target );\n+\tVERIFY( m[1].second == target+sizeof(target) );\n+\tVERIFY( m[1].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "21abea456a9ef7c507ee7663b7e35dc1e1bed946", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/extended/cstring_questionmark.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fcstring_questionmark.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fcstring_questionmark.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fcstring_questionmark.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-06-21  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ERE against a C-string target, question-mark match.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"(aa?)\", std::regex::extended);\n+\tchar target[] = \"a\";\n+\tstd::cmatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( re.mark_count() == 1 );\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target );\n+\tVERIFY( m.prefix().second == target );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target+sizeof(target) );\n+\tVERIFY( m.suffix().second == target+sizeof(target) );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target );\n+\tVERIFY( m[0].second == target+sizeof(target) );\n+\tVERIFY( m[0].matched == true );\n+\tVERIFY( m[1].first == target );\n+\tVERIFY( m[1].second == target+sizeof(target) );\n+\tVERIFY( m[1].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "8d3716b1edff424516a0995c61c4c655e0e22c0e", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/extended/string_any.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_any.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_any.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_any.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-11  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ERE against a std::string target.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\".*\", std::regex::extended);\n+\tstd::string target(\"aaba\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "a0a2e1fa9d88bacd8656bf5653e2721209eb5417", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/extended/string_range_00_03.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_00_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_00_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_00_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ERE against a std::string target, exercising range {0,3}\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"a{0,3}\", std::regex::extended);\n+\tstd::string target(\"aa\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "b50e07645ab33c42f663ae4da924d8fef88af337", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/extended/string_range_01_03.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_01_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_01_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_01_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ERE against a std::string target, exercising range {1,3}\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"a{1,3}\", std::regex::extended);\n+\tstd::string target(\"aa\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "ca322a8d4cdb1ba42501f72044f945b018ba0d66", "filename": "libstdc++-v3/testsuite/28_regex/11_algorithms/02_match/extended/string_range_02_03.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_02_03.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_02_03.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F11_algorithms%2F02_match%2Fextended%2Fstring_range_02_03.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+//\n+// 2010-06-16  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ERE against a std::string target, exercising range {2,3}\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+\tstd::regex  re(\"a{2,3}\", std::regex::extended);\n+\tstd::string target(\"aa\");\n+\tstd::smatch m;\n+\n+\tVERIFY( std::regex_match(target, m, re) );\n+\n+\tVERIFY( m.size()  == re.mark_count()+1 );\n+\tVERIFY( m.empty() == false );\n+\tVERIFY( m.prefix().first == target.begin() );\n+\tVERIFY( m.prefix().second == target.begin() );\n+\tVERIFY( m.prefix().matched == false );\n+\tVERIFY( m.suffix().first == target.end() );\n+\tVERIFY( m.suffix().second == target.end() );\n+\tVERIFY( m.suffix().matched == false );\n+\tVERIFY( m[0].first == target.begin() );\n+\tVERIFY( m[0].second == target.end() );\n+\tVERIFY( m[0].matched == true );\n+}\n+\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "2de4a0d09b885717bde8e5fc0dbf4d82ef88f62e", "filename": "libstdc++-v3/testsuite/28_regex/12_iterators/regex_iterator/ctors/char/default.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Fctors%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Fctors%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Fctors%2Fchar%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.1 Class template regex_iterator\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::regex_iterator<char*> it;\n+\tstd::cregex_iterator cit;\n+\tstd::sregex_iterator sit;\n+}"}, {"sha": "33fb5baa8084f336597fdef029c71643c7c66895", "filename": "libstdc++-v3/testsuite/28_regex/12_iterators/regex_iterator/ctors/wchar_t/default.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Fctors%2Fwchar_t%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Fctors%2Fwchar_t%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Fctors%2Fwchar_t%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.1 Class template regex_iterator\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::regex_iterator<wchar_t*> it;\n+\tstd::wcregex_iterator cit;\n+\tstd::wsregex_iterator sit;\n+}"}, {"sha": "8ad889950786c12da0e8519c48e85ad03a651b31", "filename": "libstdc++-v3/testsuite/28_regex/12_iterators/regex_iterator/typedefs.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_iterator%2Ftypedefs.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.1 Class template regex_iterator\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::regex_iterator<char*> it;\n+\n+  typedef it::regex_type         regex_type;\n+  typedef it::value_type         value_type;\n+  typedef it::difference_type    difference_type;\n+  typedef it::pointer            pointer;\n+  typedef it::reference          reference;\n+  typedef it::iterator_category  iterator_category;\n+}"}, {"sha": "5105c7d8732e20b70bb25a207677c3e1de988f04", "filename": "libstdc++-v3/testsuite/28_regex/12_iterators/regex_token_iterator/ctors/char/default.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Fctors%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Fctors%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Fctors%2Fchar%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.2 Class template regex_token_iterator\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::regex_token_iterator<char*> it;\n+\tstd::cregex_token_iterator cit;\n+\tstd::sregex_token_iterator sit;\n+}"}, {"sha": "fe918c80d71f8ad36806c8d831225bd1fc6f9ed1", "filename": "libstdc++-v3/testsuite/28_regex/12_iterators/regex_token_iterator/ctors/wchar_t/default.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Fctors%2Fwchar_t%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Fctors%2Fwchar_t%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Fctors%2Fwchar_t%2Fdefault.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.2 Class template regex_token_iterator\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::regex_token_iterator<wchar_t*> it;\n+\tstd::wcregex_token_iterator cit;\n+\tstd::wsregex_token_iterator sit;\n+}"}, {"sha": "d765ab2f4031592f6fd994c9fbd26e63b33c3bff", "filename": "libstdc++-v3/testsuite/28_regex/12_iterators/regex_token_iterator/typedefs.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849cab7b758a2da9c739de3af5d42bb252a1db5f/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2F12_iterators%2Fregex_token_iterator%2Ftypedefs.cc?ref=849cab7b758a2da9c739de3af5d42bb252a1db5f", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+//\n+// 2010-06-10  Stephen M. Webb <stephen.webb@bregmasoft.ca>\n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.2 Class template regex_token_iterator\n+\n+#include <regex>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::regex_token_iterator<char*> it;\n+\n+  typedef it::regex_type         regex_type;\n+  typedef it::value_type         value_type;\n+  typedef it::difference_type    difference_type;\n+  typedef it::pointer            pointer;\n+  typedef it::reference          reference;\n+  typedef it::iterator_category  iterator_category;\n+}"}]}