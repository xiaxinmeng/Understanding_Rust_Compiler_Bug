{"sha": "56d8ffc170912cb1dee5900799acaf5d4857fde9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZkOGZmYzE3MDkxMmNiMWRlZTU5MDA3OTlhY2FmNWQ0ODU3ZmRlOQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2016-11-23T17:23:12Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2016-11-23T17:23:12Z"}, "message": "[Patch 6/17] Migrate excess precision logic to use TARGET_EXCESS_PRECISION\n\ngcc/\n\n\t* toplev.c (init_excess_precision): Delete most logic.\n\t* tree.c (excess_precision_type): Rewrite to use\n\tTARGET_EXCESS_PRECISION.\n\t* doc/invoke.texi (-fexcess-precision): Document behaviour in a\n\tmore generic fashion.\n\t* ginclude/float.h: Wrap definition of FLT_EVAL_METHOD in\n\t__STDC_WANT_IEC_60559_TYPES_EXT__.\n\ngcc/c-family/\n\n\t* c-common.c (excess_precision_mode_join): New.\n\t(c_ts18661_flt_eval_method): New.\n\t(c_c11_flt_eval_method): Likewise.\n\t(c_flt_eval_method): Likewise.\n\t* c-common.h (excess_precision_mode_join): New.\n\t(c_flt_eval_method): Likewise.\n\t* c-cppbuiltin.c (c_cpp_flt_eval_method_iec_559): New.\n\t(cpp_iec_559_value): Call it.\n\t(c_cpp_builtins): Modify logic for __LIBGCC_*_EXCESS_PRECISION__,\n\tcall c_flt_eval_method to set __FLT_EVAL_METHOD__ and\n\t__FLT_EVAL_METHOD_TS_18661_3__.\n\ngcc/testsuite/\n\n\t* gcc.dg/fpermitted-flt-eval-methods_3.c: New.\n\t* gcc.dg/fpermitted-flt-eval-methods_4.c: Likewise.\n\nFrom-SVN: r242776", "tree": {"sha": "b2e05c11d31890a7a8ef669c3474d40a7843da1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2e05c11d31890a7a8ef669c3474d40a7843da1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56d8ffc170912cb1dee5900799acaf5d4857fde9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d8ffc170912cb1dee5900799acaf5d4857fde9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d8ffc170912cb1dee5900799acaf5d4857fde9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d8ffc170912cb1dee5900799acaf5d4857fde9/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04f0fcf7bdfa1b4d153ca37df8843c44ed8c4d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f0fcf7bdfa1b4d153ca37df8843c44ed8c4d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04f0fcf7bdfa1b4d153ca37df8843c44ed8c4d93"}], "stats": {"total": 526, "additions": 408, "deletions": 118}, "files": [{"sha": "66045fb9fefef9b414d17135cadcfd1a3e758cd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -1,3 +1,13 @@\n+2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* toplev.c (init_excess_precision): Delete most logic.\n+\t* tree.c (excess_precision_type): Rewrite to use\n+\tTARGET_EXCESS_PRECISION.\n+\t* doc/invoke.texi (-fexcess-precision): Document behaviour in a\n+\tmore generic fashion.\n+\t* ginclude/float.h: Wrap definition of FLT_EVAL_METHOD in\n+\t__STDC_WANT_IEC_60559_TYPES_EXT__.\n+\n 2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* common.opt (fpermitted-flt-eval-methods): New."}, {"sha": "b2f712f5256d50c9355a0d838407df1b2018dda3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -1,3 +1,17 @@\n+2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* c-common.c (excess_precision_mode_join): New.\n+\t(c_ts18661_flt_eval_method): New.\n+\t(c_c11_flt_eval_method): Likewise.\n+\t(c_flt_eval_method): Likewise.\n+\t* c-common.h (excess_precision_mode_join): New.\n+\t(c_flt_eval_method): Likewise.\n+\t* c-cppbuiltin.c (c_cpp_flt_eval_method_iec_559): New.\n+\t(cpp_iec_559_value): Call it.\n+\t(c_cpp_builtins): Modify logic for __LIBGCC_*_EXCESS_PRECISION__,\n+\tcall c_flt_eval_method to set __FLT_EVAL_METHOD__ and\n+\t__FLT_EVAL_METHOD_TS_18661_3__.\n+\n 2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* c-opts.c (c_common_post_options): Add logic to handle the default"}, {"sha": "62174a9eaa5c708df386bc6f94f9a6f1f99a6661", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -7950,4 +7950,86 @@ cb_get_suggestion (cpp_reader *, const char *goal,\n   return bm.get_best_meaningful_candidate ();\n }\n \n+/* Return the latice point which is the wider of the two FLT_EVAL_METHOD\n+   modes X, Y.  This isn't just  >, as the FLT_EVAL_METHOD values added\n+   by C TS 18661-3 for interchange  types that are computed in their\n+   native precision are larger than the C11 values for evaluating in the\n+   precision of float/double/long double.  If either mode is\n+   FLT_EVAL_METHOD_UNPREDICTABLE, return that.  */\n+\n+enum flt_eval_method\n+excess_precision_mode_join (enum flt_eval_method x,\n+\t\t\t    enum flt_eval_method y)\n+{\n+  if (x == FLT_EVAL_METHOD_UNPREDICTABLE\n+      || y == FLT_EVAL_METHOD_UNPREDICTABLE)\n+    return FLT_EVAL_METHOD_UNPREDICTABLE;\n+\n+  /* GCC only supports one interchange type right now, _Float16.  If\n+     we're evaluating _Float16 in 16-bit precision, then flt_eval_method\n+     will be FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16.  */\n+  if (x == FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16)\n+    return y;\n+  if (y == FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16)\n+    return x;\n+\n+  /* Other values for flt_eval_method are directly comparable, and we want\n+     the maximum.  */\n+  return MAX (x, y);\n+}\n+\n+/* Return the value that should be set for FLT_EVAL_METHOD in the\n+   context of ISO/IEC TS 18861-3.\n+\n+   This relates to the effective excess precision seen by the user,\n+   which is the join point of the precision the target requests for\n+   -fexcess-precision={standard,fast} and the implicit excess precision\n+   the target uses.  */\n+\n+static enum flt_eval_method\n+c_ts18661_flt_eval_method (void)\n+{\n+  enum flt_eval_method implicit\n+    = targetm.c.excess_precision (EXCESS_PRECISION_TYPE_IMPLICIT);\n+\n+  enum excess_precision_type flag_type\n+    = (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD\n+       ? EXCESS_PRECISION_TYPE_STANDARD\n+       : EXCESS_PRECISION_TYPE_FAST);\n+\n+  enum flt_eval_method requested\n+    = targetm.c.excess_precision (flag_type);\n+\n+  return excess_precision_mode_join (implicit, requested);\n+}\n+\n+/* As c_cpp_ts18661_flt_eval_method, but clamps the expected values to\n+   those that were permitted by C11.  That is to say, eliminates\n+   FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16.  */\n+\n+static enum flt_eval_method\n+c_c11_flt_eval_method (void)\n+{\n+  return excess_precision_mode_join (c_ts18661_flt_eval_method (),\n+\t\t\t\t     FLT_EVAL_METHOD_PROMOTE_TO_FLOAT);\n+}\n+\n+/* Return the value that should be set for FLT_EVAL_METHOD.\n+   MAYBE_C11_ONLY_P is TRUE if we should check\n+   FLAG_PERMITTED_EVAL_METHODS as to whether we should limit the possible\n+   values we can return to those from C99/C11, and FALSE otherwise.\n+   See the comments on c_ts18661_flt_eval_method for what value we choose\n+   to set here.  */\n+\n+int\n+c_flt_eval_method (bool maybe_c11_only_p)\n+{\n+  if (maybe_c11_only_p\n+      && flag_permitted_flt_eval_methods\n+\t  == PERMITTED_FLT_EVAL_METHODS_C11)\n+    return c_c11_flt_eval_method ();\n+  else\n+    return c_ts18661_flt_eval_method ();\n+}\n+\n #include \"gt-c-family-c-common.h\""}, {"sha": "a23193ee9db9dfbac6946e0c359f3bc0b28ab6cf", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -1546,6 +1546,11 @@ extern int tm_attr_to_mask (tree);\n extern tree tm_mask_to_attr (int);\n extern tree find_tm_attribute (tree);\n \n+extern enum flt_eval_method\n+excess_precision_mode_join (enum flt_eval_method, enum flt_eval_method);\n+\n+extern int c_flt_eval_method (bool ts18661_p);\n+\n #if CHECKING_P\n namespace selftest {\n   extern void c_format_c_tests (void);"}, {"sha": "e2419e81233101f68433109f4dff13a588a4e67a", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 79, "deletions": 27, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -728,6 +728,31 @@ cpp_atomic_builtins (cpp_reader *pfile)\n \t\t\t(have_swap[psize]? 2 : 1));\n }\n \n+/* Return TRUE if the implicit excess precision in which the back-end will\n+   compute floating-point calculations is not more than the explicit\n+   excess precision that the front-end will apply under\n+   -fexcess-precision=[standard|fast].\n+\n+   More intuitively, return TRUE if the excess precision proposed by the\n+   front-end is the excess precision that will actually be used.  */\n+\n+static bool\n+c_cpp_flt_eval_method_iec_559 (void)\n+{\n+  enum excess_precision_type front_end_ept\n+    = (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD\n+       ? EXCESS_PRECISION_TYPE_STANDARD\n+       : EXCESS_PRECISION_TYPE_FAST);\n+\n+  enum flt_eval_method back_end\n+    = targetm.c.excess_precision (EXCESS_PRECISION_TYPE_IMPLICIT);\n+\n+  enum flt_eval_method front_end\n+    = targetm.c.excess_precision (front_end_ept);\n+\n+  return excess_precision_mode_join (front_end, back_end) == front_end;\n+}\n+\n /* Return the value for __GCC_IEC_559.  */\n static int\n cpp_iec_559_value (void)\n@@ -770,16 +795,17 @@ cpp_iec_559_value (void)\n       || !dfmt->has_signed_zero)\n     ret = 0;\n \n-  /* In strict C standards conformance mode, consider unpredictable\n-     excess precision to mean lack of IEEE 754 support.  The same\n-     applies to unpredictable contraction.  For C++, and outside\n-     strict conformance mode, do not consider these options to mean\n-     lack of IEEE 754 support.  */\n+  /* In strict C standards conformance mode, consider a back-end providing\n+     more implicit excess precision than the explicit excess precision\n+     the front-end options would require to mean a lack of IEEE 754\n+     support.  For C++, and outside strict conformance mode, do not consider\n+     this to mean a lack of IEEE 754 support.  */\n+\n   if (flag_iso\n       && !c_dialect_cxx ()\n-      && TARGET_FLT_EVAL_METHOD != 0\n-      && flag_excess_precision_cmdline != EXCESS_PRECISION_STANDARD)\n+      && !c_cpp_flt_eval_method_iec_559 ())\n     ret = 0;\n+\n   if (flag_iso\n       && !c_dialect_cxx ()\n       && flag_fp_contract_mode == FP_CONTRACT_FAST)\n@@ -1045,9 +1071,22 @@ c_cpp_builtins (cpp_reader *pfile)\n   builtin_define_with_int_value (\"__GCC_IEC_559_COMPLEX\",\n \t\t\t\t cpp_iec_559_complex_value ());\n \n-  /* float.h needs to know this.  */\n+  /* float.h needs these to correctly set FLT_EVAL_METHOD\n+\n+     We define two values:\n+\n+     __FLT_EVAL_METHOD__\n+       Which, depending on the value given for\n+       -fpermitted-flt-eval-methods, may be limited to only those values\n+       for FLT_EVAL_METHOD defined in C99/C11.\n+\n+     __FLT_EVAL_METHOD_TS_18661_3__\n+       Which always permits the values for FLT_EVAL_METHOD defined in\n+       ISO/IEC TS 18661-3.  */\n   builtin_define_with_int_value (\"__FLT_EVAL_METHOD__\",\n-\t\t\t\t TARGET_FLT_EVAL_METHOD);\n+\t\t\t\t c_flt_eval_method (true));\n+  builtin_define_with_int_value (\"__FLT_EVAL_METHOD_TS_18661_3__\",\n+\t\t\t\t c_flt_eval_method (false));\n \n   /* And decfloat.h needs this.  */\n   builtin_define_with_int_value (\"__DEC_EVAL_METHOD__\",\n@@ -1188,25 +1227,38 @@ c_cpp_builtins (cpp_reader *pfile)\n \t      gcc_assert (found_suffix);\n \t    }\n \t  builtin_define_with_value (macro_name, suffix, 0);\n+\n+\t  /* The way __LIBGCC_*_EXCESS_PRECISION__ is used is about\n+\t     eliminating excess precision from results assigned to\n+\t     variables - meaning it should be about the implicit excess\n+\t     precision only.  */\n \t  bool excess_precision = false;\n-\t  if (TARGET_FLT_EVAL_METHOD != 0\n-\t      && mode != TYPE_MODE (long_double_type_node)\n-\t      && (mode == TYPE_MODE (float_type_node)\n-\t\t  || mode == TYPE_MODE (double_type_node)))\n-\t    switch (TARGET_FLT_EVAL_METHOD)\n-\t      {\n-\t      case -1:\n-\t      case 2:\n-\t\texcess_precision = true;\n-\t\tbreak;\n-\n-\t      case 1:\n-\t\texcess_precision = mode == TYPE_MODE (float_type_node);\n-\t\tbreak;\n-\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n+\t  machine_mode float16_type_mode = (float16_type_node\n+\t\t\t\t\t    ? TYPE_MODE (float16_type_node)\n+\t\t\t\t\t    : VOIDmode);\n+\t  switch (targetm.c.excess_precision\n+\t\t    (EXCESS_PRECISION_TYPE_IMPLICIT))\n+\t    {\n+\t    case FLT_EVAL_METHOD_UNPREDICTABLE:\n+\t    case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n+\t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == TYPE_MODE (float_type_node)\n+\t\t\t\t  || mode == TYPE_MODE (double_type_node));\n+\t      break;\n+\n+\t    case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n+\t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == TYPE_MODE (float_type_node));\n+\t      break;\n+\t    case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n+\t      excess_precision = mode == float16_type_mode;\n+\t      break;\n+\t    case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16:\n+\t      excess_precision = false;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t  macro_name = (char *) alloca (strlen (name)\n \t\t\t\t\t+ sizeof (\"__LIBGCC__EXCESS_\"\n \t\t\t\t\t\t  \"PRECISION__\"));"}, {"sha": "22f539d440725c005e7b7b5260043cf7d994ecb4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -8987,15 +8987,14 @@ them to store all pertinent intermediate computations into variables.\n @item -fexcess-precision=@var{style}\n @opindex fexcess-precision\n This option allows further control over excess precision on machines\n-where floating-point registers have more precision than the IEEE\n-@code{float} and @code{double} types and the processor does not\n-support operations rounding to those types.  By default,\n-@option{-fexcess-precision=fast} is in effect; this means that\n-operations are carried out in the precision of the registers and that\n-it is unpredictable when rounding to the types specified in the source\n-code takes place.  When compiling C, if\n-@option{-fexcess-precision=standard} is specified then excess\n-precision follows the rules specified in ISO C99; in particular,\n+where floating-point operations occur in a format with more precision or\n+range than the IEEE standard and interchange floating-point types.  By\n+default, @option{-fexcess-precision=fast} is in effect; this means that\n+operations may be carried out in a wider precision than the types specified\n+in the source if that would result in faster code, and it is unpredictable\n+when rounding to the types specified in the source code takes place.\n+When compiling C, if @option{-fexcess-precision=standard} is specified then\n+excess precision follows the rules specified in ISO C99; in particular,\n both casts and assignments cause values to be rounded to their\n semantic types (whereas @option{-ffloat-store} only affects\n assignments).  This option is enabled by default for C if a strict"}, {"sha": "3df2889164ffaebe575d02b3c6eec87b24a2885d", "filename": "gcc/ginclude/float.h", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fginclude%2Ffloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Fginclude%2Ffloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Ffloat.h?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -129,21 +129,73 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) \\\n      || (defined (__cplusplus) && __cplusplus >= 201103L)\n-/* The floating-point expression evaluation method.\n-        -1  indeterminate\n-         0  evaluate all operations and constants just to the range and\n-            precision of the type\n-         1  evaluate operations and constants of type float and double\n-            to the range and precision of the double type, evaluate\n-            long double operations and constants to the range and\n-            precision of the long double type\n-         2  evaluate all operations and constants to the range and\n-            precision of the long double type\n+/* The floating-point expression evaluation method.  The precise\n+   definitions of these values are generalised to include support for\n+   the interchange and extended types defined in ISO/IEC TS 18661-3.\n+   Prior to this (for C99/C11) the definitions were:\n+\n+\t-1  indeterminate\n+\t 0  evaluate all operations and constants just to the range and\n+\t    precision of the type\n+\t 1  evaluate operations and constants of type float and double\n+\t    to the range and precision of the double type, evaluate\n+\t    long double operations and constants to the range and\n+\t    precision of the long double type\n+\t 2  evaluate all operations and constants to the range and\n+\t    precision of the long double type\n+\n+   The TS 18661-3 definitions are:\n+\n+\t-1  indeterminate\n+\t 0  evaluate all operations and constants, whose semantic type has\n+\t    at most the range and precision of float, to the range and\n+\t    precision of float; evaluate all other operations and constants\n+\t    to the range and precision of the semantic type.\n+\t 1  evaluate all operations and constants, whose semantic type has\n+\t    at most the range and precision of double, to the range and\n+\t    precision of double; evaluate all other operations and constants\n+\t    to the range and precision of the semantic type.\n+\t 2  evaluate all operations and constants, whose semantic type has\n+\t    at most the range and precision of long double, to the range and\n+\t    precision of long double; evaluate all other operations and\n+\t    constants to the range and precision of the semantic type.\n+\t N  where _FloatN  is a supported interchange floating type\n+\t    evaluate all operations and constants, whose semantic type has\n+\t    at most the range and precision of the _FloatN type, to the\n+\t    range and precision of the _FloatN type; evaluate all other\n+\t    operations and constants to the range and precision of the\n+\t    semantic type.\n+\t N + 1, where _FloatNx is a supported extended floating type\n+\t    evaluate operations and constants, whose semantic type has at\n+\t    most the range and precision of the _FloatNx type, to the range\n+\t    and precision of the _FloatNx type; evaluate all other\n+\t    operations and constants to the range and precision of the\n+\t    semantic type.\n+\n+   The compiler predefines two macros:\n+\n+      __FLT_EVAL_METHOD__\n+      Which, depending on the value given for\n+      -fpermitted-flt-eval-methods, may be limited to only those values\n+      for FLT_EVAL_METHOD defined in C99/C11.\n+\n+     __FLT_EVAL_METHOD_TS_18661_3__\n+      Which always permits the values for FLT_EVAL_METHOD defined in\n+      ISO/IEC TS 18661-3.\n+\n+     Here we want to use __FLT_EVAL_METHOD__, unless\n+     __STDC_WANT_IEC_60559_TYPES_EXT__ is defined, in which case the user\n+     is specifically asking for the ISO/IEC TS 18661-3 types, so we use\n+     __FLT_EVAL_METHOD_TS_18661_3__.\n \n    ??? This ought to change with the setting of the fp control word;\n    the value provided by the compiler assumes the widest setting.  */\n #undef FLT_EVAL_METHOD\n+#ifdef __STDC_WANT_IEC_60559_TYPES_EXT__\n+#define FLT_EVAL_METHOD __FLT_EVAL_METHOD_TS_18661_3__\n+#else\n #define FLT_EVAL_METHOD\t__FLT_EVAL_METHOD__\n+#endif\n \n /* Number of decimal digits, n, such that any floating-point number in the\n    widest supported floating type with pmax radix b digits can be rounded"}, {"sha": "99c89b60d391724e5b084c42cc8c43d7ea9a55c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -1,3 +1,8 @@\n+2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.dg/fpermitted-flt-eval-methods_3.c: New.\n+\t* gcc.dg/fpermitted-flt-eval-methods_4.c: Likewise.\n+\n 2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc.dg/fpermitted-flt-eval-methods_1.c: New."}, {"sha": "c7bd7567ca4753c3e6b57d396dd2f7152c538076", "filename": "gcc/testsuite/gcc.dg/fpermitted-flt-eval-methods_3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftestsuite%2Fgcc.dg%2Ffpermitted-flt-eval-methods_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftestsuite%2Fgcc.dg%2Ffpermitted-flt-eval-methods_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffpermitted-flt-eval-methods_3.c?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11\" } */\n+\n+/* Test that when compiling with -std=c11, we only see the C99/C11 values\n+   for FLT_EVAL_METHOD.  */\n+\n+#include <float.h>\n+\n+int main (int argc, char** argv)\n+{\n+  switch (FLT_EVAL_METHOD)\n+    {\n+      case 0:\n+      case 1:\n+      case 2:\n+      case -1:\n+\treturn 0;\n+      default:\n+\treturn 1;\n+    }\n+}"}, {"sha": "a7bbb65b3dfbcab22707f264c60ca0a495192e2d", "filename": "gcc/testsuite/gcc.dg/fpermitted-flt-eval-methods_4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftestsuite%2Fgcc.dg%2Ffpermitted-flt-eval-methods_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftestsuite%2Fgcc.dg%2Ffpermitted-flt-eval-methods_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffpermitted-flt-eval-methods_4.c?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11\" } */\n+\n+/* Test that when compiling with -std=c11 and defining\n+   __STDC_WANT_IEC_60559_TYPES_EXT__, we only see the ISO/IEC TS\n+   18661-3 values for FLT_EVAL_METHOD.  */\n+\n+#define __STDC_WANT_IEC_60559_TYPES_EXT__\n+\n+#include <float.h>\n+\n+int main (int argc, char** argv)\n+{\n+  switch (__FLT_EVAL_METHOD__)\n+    {\n+      case 0:\n+      case 1:\n+      case 2:\n+      case 16:\n+      case -1:\n+\treturn 0;\n+      default:\n+\treturn 1;\n+    }\n+}"}, {"sha": "5af02ea34e826e3032b26c457b1c2942d9c83439", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -1680,41 +1680,17 @@ backend_init (void)\n   init_regs ();\n }\n \n-/* Initialize excess precision settings.  */\n+/* Initialize excess precision settings.\n+\n+   We have no need to modify anything here, just keep track of what the\n+   user requested.  We'll figure out any appropriate relaxations\n+   later.  */\n+\n static void\n init_excess_precision (void)\n {\n-  /* Adjust excess precision handling based on the target options.  If\n-     the front end cannot handle it, flag_excess_precision_cmdline\n-     will already have been set accordingly in the post_options\n-     hook.  */\n   gcc_assert (flag_excess_precision_cmdline != EXCESS_PRECISION_DEFAULT);\n   flag_excess_precision = flag_excess_precision_cmdline;\n-  if (flag_unsafe_math_optimizations)\n-    flag_excess_precision = EXCESS_PRECISION_FAST;\n-  if (flag_excess_precision == EXCESS_PRECISION_STANDARD)\n-    {\n-      int flt_eval_method = TARGET_FLT_EVAL_METHOD;\n-      switch (flt_eval_method)\n-\t{\n-\tcase -1:\n-\tcase 0:\n-\t  /* Either the target acts unpredictably (-1) or has all the\n-\t     operations required not to have excess precision (0).  */\n-\t  flag_excess_precision = EXCESS_PRECISION_FAST;\n-\t  break;\n-\tcase 1:\n-\tcase 2:\n-\t  /* In these cases, predictable excess precision makes\n-\t     sense.  */\n-\t  break;\n-\tdefault:\n-\t  /* Any other implementation-defined FLT_EVAL_METHOD values\n-\t     require the compiler to handle the associated excess\n-\t     precision rules in excess_precision_type.  */\n-\t  gcc_unreachable ();\n-\t}\n-    }\n }\n \n /* Initialize things that are both lang-dependent and target-dependent."}, {"sha": "4f3d678e08fb5ad989027c51ee7a28298f4e93a1", "filename": "gcc/tree.c", "status": "modified", "additions": 91, "deletions": 42, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d8ffc170912cb1dee5900799acaf5d4857fde9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=56d8ffc170912cb1dee5900799acaf5d4857fde9", "patch": "@@ -8855,50 +8855,99 @@ build_complex_type (tree component_type, bool named)\n tree\n excess_precision_type (tree type)\n {\n-  if (flag_excess_precision != EXCESS_PRECISION_FAST)\n+  /* The target can give two different responses to the question of\n+     which excess precision mode it would like depending on whether we\n+     are in -fexcess-precision=standard or -fexcess-precision=fast.  */\n+\n+  enum excess_precision_type requested_type\n+    = (flag_excess_precision == EXCESS_PRECISION_FAST\n+       ? EXCESS_PRECISION_TYPE_FAST\n+       : EXCESS_PRECISION_TYPE_STANDARD);\n+\n+  enum flt_eval_method target_flt_eval_method\n+    = targetm.c.excess_precision (requested_type);\n+\n+  /* The target should not ask for unpredictable float evaluation (though\n+     it might advertise that implicitly the evaluation is unpredictable,\n+     but we don't care about that here, it will have been reported\n+     elsewhere).  If it does ask for unpredictable evaluation, we have\n+     nothing to do here.  */\n+  gcc_assert (target_flt_eval_method != FLT_EVAL_METHOD_UNPREDICTABLE);\n+\n+  /* Nothing to do.  The target has asked for all types we know about\n+     to be computed with their native precision and range.  */\n+  if (target_flt_eval_method == FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16)\n+    return NULL_TREE;\n+\n+  /* The target will promote this type in a target-dependent way, so excess\n+     precision ought to leave it alone.  */\n+  if (targetm.promoted_type (type) != NULL_TREE)\n+    return NULL_TREE;\n+\n+  machine_mode float16_type_mode = (float16_type_node\n+\t\t\t\t    ? TYPE_MODE (float16_type_node)\n+\t\t\t\t    : VOIDmode);\n+  machine_mode float_type_mode = TYPE_MODE (float_type_node);\n+  machine_mode double_type_mode = TYPE_MODE (double_type_node);\n+\n+  switch (TREE_CODE (type))\n     {\n-      int flt_eval_method = TARGET_FLT_EVAL_METHOD;\n-      switch (TREE_CODE (type))\n-\t{\n-\tcase REAL_TYPE:\n-\t  switch (flt_eval_method)\n-\t    {\n-\t    case 1:\n-\t      if (TYPE_MODE (type) == TYPE_MODE (float_type_node))\n-\t\treturn double_type_node;\n-\t      break;\n-\t    case 2:\n-\t      if (TYPE_MODE (type) == TYPE_MODE (float_type_node)\n-\t\t  || TYPE_MODE (type) == TYPE_MODE (double_type_node))\n-\t\treturn long_double_type_node;\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tcase COMPLEX_TYPE:\n-\t  if (TREE_CODE (TREE_TYPE (type)) != REAL_TYPE)\n-\t    return NULL_TREE;\n-\t  switch (flt_eval_method)\n-\t    {\n-\t    case 1:\n-\t      if (TYPE_MODE (TREE_TYPE (type)) == TYPE_MODE (float_type_node))\n-\t\treturn complex_double_type_node;\n-\t      break;\n-\t    case 2:\n-\t      if (TYPE_MODE (TREE_TYPE (type)) == TYPE_MODE (float_type_node)\n-\t\t  || (TYPE_MODE (TREE_TYPE (type))\n-\t\t      == TYPE_MODE (double_type_node)))\n-\t\treturn complex_long_double_type_node;\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n+    case REAL_TYPE:\n+      {\n+\tmachine_mode type_mode = TYPE_MODE (type);\n+\tswitch (target_flt_eval_method)\n+\t  {\n+\t  case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n+\t    if (type_mode == float16_type_mode)\n+\t      return float_type_node;\n+\t    break;\n+\t  case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n+\t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == float_type_mode)\n+\t      return double_type_node;\n+\t    break;\n+\t  case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n+\t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == float_type_mode\n+\t\t|| type_mode == double_type_mode)\n+\t      return long_double_type_node;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+      }\n+    case COMPLEX_TYPE:\n+      {\n+\tif (TREE_CODE (TREE_TYPE (type)) != REAL_TYPE)\n+\t  return NULL_TREE;\n+\tmachine_mode type_mode = TYPE_MODE (TREE_TYPE (type));\n+\tswitch (target_flt_eval_method)\n+\t  {\n+\t  case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n+\t    if (type_mode == float16_type_mode)\n+\t      return complex_float_type_node;\n+\t    break;\n+\t  case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n+\t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == float_type_mode)\n+\t      return complex_double_type_node;\n+\t    break;\n+\t  case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n+\t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == float_type_mode\n+\t\t|| type_mode == double_type_mode)\n+\t      return complex_long_double_type_node;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      break;\n     }\n+\n   return NULL_TREE;\n }\n \f"}]}