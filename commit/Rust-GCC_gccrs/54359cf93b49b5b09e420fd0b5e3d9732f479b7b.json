{"sha": "54359cf93b49b5b09e420fd0b5e3d9732f479b7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzNTljZjkzYjQ5YjViMDllNDIwZmQwYjVlM2Q5NzMyZjQ3OWI3Yg==", "commit": {"author": {"name": "Ovidiu Predescu", "email": "ovidiu@gcc.gnu.org", "date": "2000-08-07T05:51:14Z"}, "committer": {"name": "Ovidiu Predescu", "email": "ovidiu@gcc.gnu.org", "date": "2000-08-07T05:51:14Z"}, "message": "Integrated Chris Ball's <cball@fmco.com> changes to improve the Posix\nthread support for Objective-C.\n\nFrom-SVN: r35535", "tree": {"sha": "ff9ec72c7b6fb923b82bfded67ce23d5277b8918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff9ec72c7b6fb923b82bfded67ce23d5277b8918"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54359cf93b49b5b09e420fd0b5e3d9732f479b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54359cf93b49b5b09e420fd0b5e3d9732f479b7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54359cf93b49b5b09e420fd0b5e3d9732f479b7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54359cf93b49b5b09e420fd0b5e3d9732f479b7b/comments", "author": null, "committer": null, "parents": [{"sha": "5a4f31cf6222faee4bd9138ba6c15a258dc9a8e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4f31cf6222faee4bd9138ba6c15a258dc9a8e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a4f31cf6222faee4bd9138ba6c15a258dc9a8e2"}], "stats": {"total": 119, "additions": 97, "deletions": 22}, "files": [{"sha": "71a9660f7eaeafaa3afab33bc68be1db4d1983f2", "filename": "libobjc/thr-posix.c", "status": "modified", "additions": 97, "deletions": 22, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54359cf93b49b5b09e420fd0b5e3d9732f479b7b/libobjc%2Fthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54359cf93b49b5b09e420fd0b5e3d9732f479b7b/libobjc%2Fthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-posix.c?ref=54359cf93b49b5b09e420fd0b5e3d9732f479b7b", "patch": "@@ -2,6 +2,7 @@\n    Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n    Modified for Linux/Pthreads by Kai-Uwe Sattler (kus@iti.cs.uni-magdeburg.de)\n+   Modified for posix compliance by Chris Ball (cball@fmco.com)\n \n This file is part of GNU CC.\n \n@@ -31,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Key structure for maintaining thread specific storage */\n static pthread_key_t _objc_thread_storage;\n+static pthread_attr_t _objc_thread_attribs;\n \n /* Backend initialization functions */\n \n@@ -39,14 +41,34 @@ int\n __objc_init_thread_system(void)\n {\n   /* Initialize the thread storage key */\n-  return pthread_key_create(&_objc_thread_storage, NULL);\n+  if (pthread_key_create(&_objc_thread_storage, NULL) == 0)\n+    {\n+      /*\n+       * The normal default detach state for threads is PTHREAD_CREATE_JOINABLE\n+       * which causes threads to not die when you think they should.\n+\t   */\n+      if (pthread_attr_init(&_objc_thread_attribs) == 0)\n+        {\n+          if (pthread_attr_setdetachstate(&_objc_thread_attribs, \n+                                          PTHREAD_CREATE_DETACHED) == 0)\n+            return 0;\n+        }\n+    }\n+\n+  return -1;\n }\n \n /* Close the threads subsystem. */\n int\n __objc_close_thread_system(void)\n {\n-  return 0;\n+  if (pthread_key_delete(_objc_thread_storage) == 0)\n+    {\n+      if (pthread_attr_destroy(&_objc_thread_attribs) == 0)\n+        return 0;\n+    }\n+\n+  return -1;\n }\n \n /* Backend thread functions */\n@@ -57,29 +79,64 @@ __objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n   objc_thread_t thread_id;\n   pthread_t new_thread_handle;\n-\n-  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n-      thread_id = *(objc_thread_t *)&new_thread_handle;\n+  \n+  if (!(pthread_create(&new_thread_handle, &_objc_thread_attribs, \n+                       (void *)func, arg)))\n+    thread_id = *(objc_thread_t *)&new_thread_handle;\n   else\n     thread_id = NULL;\n   \n   return thread_id;\n }\n \n-/* Set the current thread's priority. */\n+/* Set the current thread's priority.\n+ *\n+ * Be aware that the default schedpolicy often disallows thread priorities.\n+ */\n int\n __objc_thread_set_priority(int priority)\n {\n-  /* Not implemented yet */\n+  pthread_t thread_id = pthread_self();\n+  int policy;\n+  struct sched_param params;\n+  int priority_min, priority_max;\n+\n+  if (pthread_getschedparam(thread_id, &policy, &params) == 0)\n+    {\n+      if ((priority_max = sched_get_priority_max(policy)) != 0)\n+        return -1;\n+\n+      if ((priority_min = sched_get_priority_min(policy)) != 0)\n+        return -1;\n+\n+      if (priority > priority_max)\n+        priority = priority_max;\n+      else if (priority < priority_min)\n+        priority = priority_min;\n+      params.sched_priority = priority;\n+\n+      /*\n+       * The solaris 7 and several other man pages incorrectly state that\n+       * this should be a pointer to policy but pthread.h is universally\n+       * at odds with this.\n+       */\n+      if (pthread_setschedparam(thread_id, policy, &params) == 0)\n+        return 0;\n+    }\n   return -1;\n }\n \n /* Return the current thread's priority. */\n int\n __objc_thread_get_priority(void)\n {\n-  /* Not implemented yet */\n-  return -1;\n+  int policy;\n+  struct sched_param params;\n+\n+  if (pthread_getschedparam(pthread_self(), &policy, &params) == 0)\n+    return params.sched_priority;\n+  else\n+    return -1;\n }\n \n /* Yield our process time to another thread. */\n@@ -113,7 +170,10 @@ __objc_thread_id(void)\n int\n __objc_thread_set_data(void *value)\n {\n-  return pthread_setspecific(_objc_thread_storage, value);\n+  if (pthread_setspecific(_objc_thread_storage, value) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n /* Returns the thread's local storage pointer. */\n@@ -152,10 +212,9 @@ __objc_mutex_deallocate(objc_mutex_t mutex)\n    * pthread_mutex_destroy to work.\n    */\n \n-  while ( count )\n+  while (count)\n     {\n-      if (( count = pthread_mutex_unlock((pthread_mutex_t *)mutex->backend))\n-          < 0 )\n+      if ((count = pthread_mutex_unlock((pthread_mutex_t*)mutex->backend)) < 0)\n         return -1;\n     }\n \n@@ -171,21 +230,30 @@ __objc_mutex_deallocate(objc_mutex_t mutex)\n int\n __objc_mutex_lock(objc_mutex_t mutex)\n {\n-  return pthread_mutex_lock((pthread_mutex_t *)mutex->backend);\n+  if (pthread_mutex_lock((pthread_mutex_t *)mutex->backend) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n /* Try to grab a lock on a mutex. */\n int\n __objc_mutex_trylock(objc_mutex_t mutex)\n {\n-  return pthread_mutex_trylock((pthread_mutex_t *)mutex->backend);\n+  if (pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n /* Unlock the mutex */\n int\n __objc_mutex_unlock(objc_mutex_t mutex)\n {\n-  return pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n+  if (pthread_mutex_unlock((pthread_mutex_t *)mutex->backend) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n /* Backend condition mutex functions */\n@@ -222,22 +290,29 @@ __objc_condition_deallocate(objc_condition_t condition)\n int\n __objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n-  return pthread_cond_wait((pthread_cond_t *)condition->backend,\n-\t\t\t   (pthread_mutex_t *)mutex->backend);\n+  if (pthread_cond_wait((pthread_cond_t *)condition->backend,\n+                        (pthread_mutex_t *)mutex->backend) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n /* Wake up all threads waiting on this condition. */\n int\n __objc_condition_broadcast(objc_condition_t condition)\n {\n-  return pthread_cond_broadcast((pthread_cond_t *)condition->backend);\n+  if (pthread_cond_broadcast((pthread_cond_t *)condition->backend) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n /* Wake up one thread waiting on this condition. */\n int\n __objc_condition_signal(objc_condition_t condition)\n {\n-  return pthread_cond_signal((pthread_cond_t *)condition->backend);\n+  if (pthread_cond_signal((pthread_cond_t *)condition->backend) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n-\n-/* End of File */"}]}