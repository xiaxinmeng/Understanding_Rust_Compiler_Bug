{"sha": "8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4YTRlOWQzZDY1MDY4N2RmYTI0ZDU4ZTc5ZmRjNzBkMGY3NzE3Mw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2008-11-11T12:15:59Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-11T12:15:59Z"}, "message": "extptr_allocator.h: Minor tweaks.\n\n2008-11-11  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/ext/extptr_allocator.h: Minor tweaks.\n\t* include/ext/pointer.h: Likewise.\n\t* include/ext/cast.h: Likewise.\n\nFrom-SVN: r141764", "tree": {"sha": "0ed3d94cd555c0a5fdd5f06a27bf1e0698192558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ed3d94cd555c0a5fdd5f06a27bf1e0698192558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/comments", "author": null, "committer": null, "parents": [{"sha": "ddb47467a200b8e90ecaa9df3ac79c0c45104526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb47467a200b8e90ecaa9df3ac79c0c45104526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb47467a200b8e90ecaa9df3ac79c0c45104526"}], "stats": {"total": 275, "additions": 114, "deletions": 161}, "files": [{"sha": "48d3cad6cde58fedf95c2a0a290bc2d07bb63b67", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "patch": "@@ -1,3 +1,9 @@\n+2008-11-11  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/ext/extptr_allocator.h: Minor tweaks.\n+\t* include/ext/pointer.h: Likewise.\n+\t* include/ext/cast.h: Likewise.\n+\n 2008-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/38067"}, {"sha": "e8325daf34d8de66186919882025faf9f4e43c8e", "filename": "libstdc++-v3/include/ext/cast.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2Finclude%2Fext%2Fcast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2Finclude%2Fext%2Fcast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fcast.h?ref=8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "patch": "@@ -27,8 +27,8 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#ifndef _EXT_CAST_\n-#define _EXT_CAST_ 1\n+#ifndef _CAST_H\n+#define _CAST_H 1\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx);\n \n@@ -48,14 +48,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx);\n    */\n   template<typename _ToType>\n     struct _Caster\n-    {\n-      typedef typename _ToType::element_type*  type;\n-    };\n+    { typedef typename _ToType::element_type*  type; };\n+\n   template<typename _ToType>\n     struct _Caster<_ToType*>\n-    {\n-      typedef _ToType*  type;\n-    };\n+    { typedef _ToType*  type; };\n \n   /**\n    * Casting operations for cases where _FromType is not a standard pointer.\n@@ -118,4 +115,4 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx);\n \n _GLIBCXX_END_NAMESPACE\n \n-#endif\n+#endif // _CAST_H"}, {"sha": "c0510fc883ea900005b7dd1046c98bbeaeb7a800", "filename": "libstdc++-v3/include/ext/extptr_allocator.h", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h?ref=8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "patch": "@@ -43,51 +43,26 @@\n #include <limits>\n #include <ext/pointer.h>\n \n-using __gnu_cxx::_Pointer_adapter;\n-using __gnu_cxx::_Relative_pointer_impl;\n-\n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n-  // forward declaration\n-  template<typename _Tp>\n-    class _ExtPtr_allocator;\n-\n-  // _ExtPtr_allocator<void> specialization.\n-  template<>\n-    class _ExtPtr_allocator<void>\n-    {\n-    public:\n-      typedef size_t      size_type;\n-      typedef ptrdiff_t   difference_type;\n-      typedef void        value_type;\n-\n-      // Note the non-standard pointer types\n-      typedef _Pointer_adapter<_Relative_pointer_impl<void> >       pointer;\n-      typedef _Pointer_adapter<_Relative_pointer_impl<const void> >\n-                                                              const_pointer;\n-\n-      template<typename _Up>\n-        struct rebind\n-        { typedef _ExtPtr_allocator<_Up> other; };\n-    };\n-\n   /**\n    * @brief An example allocator which uses a non-standard pointer type.\n    *\n    * This allocator specifies that containers use a 'relative pointer' as it's\n-   * pointer type.  (See bits/pointer.h)  Memory allocation in this example\n+   * pointer type.  (See ext/pointer.h)  Memory allocation in this example\n    * is still performed using std::allocator.\n    */\n   template<typename _Tp>\n     class _ExtPtr_allocator\n     {\n     public:\n-      typedef size_t     size_type;\n-      typedef ptrdiff_t  difference_type;\n+      typedef std::size_t     size_type;\n+      typedef std::ptrdiff_t  difference_type;\n \n       // Note the non-standard pointer types.\n       typedef _Pointer_adapter<_Relative_pointer_impl<_Tp> >       pointer;\n-      typedef _Pointer_adapter<_Relative_pointer_impl<const _Tp> > const_pointer;\n+      typedef _Pointer_adapter<_Relative_pointer_impl<const _Tp> > \n+                                                             const_pointer;\n \n       typedef _Tp&       reference;\n       typedef const _Tp& const_reference;\n@@ -103,7 +78,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       _ExtPtr_allocator(const _ExtPtr_allocator &__rarg) throw()\n       : _M_real_alloc(__rarg._M_real_alloc) { }\n \n-      template<class _Up>\n+      template<typename _Up>\n         _ExtPtr_allocator(const _ExtPtr_allocator<_Up>& __rarg) throw()\n         : _M_real_alloc(__rarg._M_getUnderlyingImp()) { }\n \n@@ -158,25 +133,46 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n       template<typename _Up>\n         inline friend void\n-        swap(_ExtPtr_allocator<_Up>& __larg, _ExtPtr_allocator<_Up>& __rarg);\n+        swap(_ExtPtr_allocator<_Up>&, _ExtPtr_allocator<_Up>&);\n \n       // A method specific to this implementation.\n       const std::allocator<_Tp>&\n       _M_getUnderlyingImp() const\n       { return _M_real_alloc; }\n \n     private:\n-      // simlated state data.\n       std::allocator<_Tp>  _M_real_alloc;\n     };\n \n+  // _ExtPtr_allocator<void> specialization.\n+  template<>\n+    class _ExtPtr_allocator<void>\n+    {\n+    public:\n+      typedef std::size_t      size_type;\n+      typedef std::ptrdiff_t   difference_type;\n+      typedef void             value_type;\n+\n+      // Note the non-standard pointer types\n+      typedef _Pointer_adapter<_Relative_pointer_impl<void> >       pointer;\n+      typedef _Pointer_adapter<_Relative_pointer_impl<const void> >\n+                                                              const_pointer;\n+\n+      template<typename _Up>\n+        struct rebind\n+        { typedef _ExtPtr_allocator<_Up> other; };\n+\n+    private:\n+      std::allocator<void>  _M_real_alloc;\n+    };\n+\n   template<typename _Tp>\n     inline void\n     swap(_ExtPtr_allocator<_Tp>& __larg, _ExtPtr_allocator<_Tp>& __rarg)\n     {\n-      std::allocator<_Tp> temp( __rarg._M_real_alloc );\n+      std::allocator<_Tp> __tmp( __rarg._M_real_alloc );\n       __rarg._M_real_alloc = __larg._M_real_alloc;\n-      __larg._M_real_alloc = temp;\n+      __larg._M_real_alloc = __tmp;\n     }\n \n _GLIBCXX_END_NAMESPACE"}, {"sha": "5c764cfd4b061e3e755b4483f6ba1c39956521ef", "filename": "libstdc++-v3/include/ext/pointer.h", "status": "modified", "additions": 71, "deletions": 117, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h?ref=8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "patch": "@@ -1,7 +1,6 @@\n // Custom pointer adapter and sample storage policies\n \n-// Copyright (C) 2008\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -33,23 +32,16 @@\n  * @author Bob Walters\n  *\n  * Provides reusable _Pointer_adapter for assisting in the development of\n- * custom pointer types that can be used with libstdc++ STL containers via\n+ * custom pointer types that can be used with the standard containers via\n  * the allocator::pointer and allocator::const_pointer typedefs.\n  */\n \n-#ifndef _EXT_POINTER_ADAPTER\n-#define _EXT_POINTER_ADAPTER 1\n+#ifndef _POINTER_H\n+#define _POINTER_H 1\n \n-#include <ostream>\n+#include <iosfwd>\n+#include <bits/stl_iterator_base_types.h>\n #include <ext/cast.h>\n-#include <bits/concept_check.h>\n-\n-\n-// forward declaration of the iterator tag\n-namespace std {\n-  struct random_access_iterator_tag;\n-};\n-\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n@@ -64,15 +56,15 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    *    4) An operator<() to support pointer comparison.\n    *    5) An operator==() to support pointer comparison.\n    */\n-  template<typename _Type> \n+  template<typename _Tp> \n     class _Std_pointer_impl \n     {\n     public:\n       // the type this pointer points to.\n-      typedef _Type element_type;\n+      typedef _Tp element_type;\n   \n       // A method to fetch the pointer value as a standard T* value;\n-      inline _Type* \n+      inline _Tp* \n       get() const \n       { return _M_value; }\n   \n@@ -94,7 +86,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       element_type* _M_value;\n     };\n \n-\n   /**\n    * @brief A storage policy for use with _Pointer_adapter<> which stores\n    *        the pointer's address as an offset value which is relative to\n@@ -108,27 +99,27 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    * As there is no reason why any normal pointer would point 1 byte into\n    * its own pointer address.\n    */\n-  template<typename _Type> \n+  template<typename _Tp> \n     class _Relative_pointer_impl \n     {\n     public:\n-      typedef _Type element_type;\n+      typedef _Tp element_type;\n   \n-      _Type* \n+      _Tp*\n       get() const \n       {\n         if (_M_diff == 1)\n-          return NULL;\n+          return 0;\n         else\n-          return reinterpret_cast<_Type*>(\n+          return reinterpret_cast<_Tp*>(\n                  const_cast<char*>(reinterpret_cast<const char*>(this))\n                  + _M_diff);\n       }\n   \n       void \n-      set(_Type* __arg)\n+      set(_Tp* __arg)\n       {\n-        if (__arg == NULL)\n+        if (!__arg)\n           _M_diff = 1;\n         else\n           _M_diff = reinterpret_cast<char*>(__arg) \n@@ -145,33 +136,33 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       { return (this->get() == __rarg.get()); }\n \n     private:\n-      ptrdiff_t _M_diff;\n+      std::ptrdiff_t _M_diff;\n     };\n   \n   /**\n    * Relative_pointer_impl needs a specialization for const T because of\n    * the casting done during pointer arithmetic.\n    */\n-  template<typename _Type> \n-    class _Relative_pointer_impl<const _Type> \n+  template<typename _Tp> \n+    class _Relative_pointer_impl<const _Tp> \n     {\n     public:\n-      typedef const _Type element_type;\n+      typedef const _Tp element_type;\n   \n-      const _Type* \n+      const _Tp*\n       get() const\n       {\n         if (_M_diff == 1)\n-          return NULL;\n+          return 0;\n         else\n-          return reinterpret_cast<const _Type*>(\n+          return reinterpret_cast<const _Tp*>(\n                   (reinterpret_cast<const char*>(this)) + _M_diff);\n       }\n   \n       void \n-      set(const _Type* __arg) \n+      set(const _Tp* __arg)\n       {\n-        if (__arg == NULL)\n+        if (!__arg)\n           _M_diff = 1;\n         else\n           _M_diff = reinterpret_cast<const char*>(__arg) \n@@ -188,10 +179,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       { return (this->get() == __rarg.get()); }\n   \n     private:\n-      ptrdiff_t _M_diff;\n+      std::ptrdiff_t _M_diff;\n     };\n \n-\n   /**\n    * The specialization on this type helps resolve the problem of\n    * reference to void, and eliminates the need to specialize _Pointer_adapter\n@@ -201,70 +191,48 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   \n   template<typename _Tp>\n     struct _Reference_type \n-    {\n-      typedef _Tp& reference;\n-    };\n+    { typedef _Tp& reference; };\n \n   template<> \n     struct _Reference_type<void> \n-    {\n-      typedef _Invalid_type& reference;\n-    };\n+    { typedef _Invalid_type& reference; };\n \n   template<> \n     struct _Reference_type<const void> \n-    {\n-      typedef const _Invalid_type& reference;\n-    };\n+    { typedef const _Invalid_type& reference; };\n \n   template<> \n     struct _Reference_type<volatile void> \n-    {\n-      typedef volatile _Invalid_type&  reference;\n-    };\n+    { typedef volatile _Invalid_type&  reference; };\n \n   template<> \n     struct _Reference_type<volatile const void> \n-    {\n-      typedef const volatile _Invalid_type&  reference;\n-    };\n-\n+    { typedef const volatile _Invalid_type&  reference; };\n \n   /**\n    * This structure accomodates the way in which std::iterator_traits<>\n    * is normally specialized for const T*, so that value_type is still T.\n    */\n   template<typename _Tp> \n     struct _Unqualified_type \n-    {\n-      typedef _Tp type;\n-    };\n+    { typedef _Tp type; };\n     \n   template<typename _Tp> \n     struct _Unqualified_type<const _Tp> \n-    {\n-      typedef _Tp type;\n-    };\n+    { typedef _Tp type; };\n     \n   template<typename _Tp> \n     struct _Unqualified_type<volatile _Tp> \n-    {\n-      typedef volatile _Tp type;\n-    };\n+    { typedef volatile _Tp type; };\n     \n   template<typename _Tp> \n     struct _Unqualified_type<volatile const _Tp> \n-    {\n-      typedef volatile _Tp type;\n-    };\n-    \n-  \n+    { typedef volatile _Tp type; };\n   \n   /**\n-   * The following provides an 'alternative pointer' that works with \n-   * libstdc++-v3 containers when specified as the pointer typedef of the \n-   * allocator.\n-   * \n+   * The following provides an 'alternative pointer' that works with the\n+   * containers when specified as the pointer typedef of the allocator.\n+   *\n    * The pointer type used with the containers doesn't have to be this class,\n    * but it must support the implicit conversions, pointer arithmetic,\n    * comparison operators, etc. that are supported by this class, and avoid\n@@ -290,50 +258,42 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    * _Tp* const       == const _Pointer_adapter<_Std_pointer_impl<_Tp> >;\n    * const _Tp* const == const _Pointer_adapter<_Std_pointer_impl<const _Tp> >;\n    */\n- \n-  template<typename _Storage_policy >\n+  template<typename _Storage_policy>\n     class _Pointer_adapter : public _Storage_policy \n     {\n     public:\n       typedef typename _Storage_policy::element_type element_type;\n-  \n+\n       // These are needed for iterator_traits\n       typedef std::random_access_iterator_tag                iterator_category;\n       typedef typename _Unqualified_type<element_type>::type value_type;\n-      typedef ptrdiff_t                                      difference_type;\n+      typedef std::ptrdiff_t                                 difference_type;\n       typedef _Pointer_adapter                               pointer;\n       typedef typename _Reference_type<element_type>::reference  reference;\n-  \n+\n       // Reminder: 'const' methods mean that the method is valid when the \n       // pointer is immutable, and has nothing to do with whether the \n       // 'pointee' is const.\n \n       // Default Constructor (Convert from element_type*)\n-      _Pointer_adapter(element_type* __arg = NULL)\n+      _Pointer_adapter(element_type* __arg = 0)\n       { _Storage_policy::set(__arg); }\n-  \n+\n       // Copy constructor from _Pointer_adapter of same type.\n       _Pointer_adapter(const _Pointer_adapter& __arg) \n       { _Storage_policy::set(__arg.get()); }\n-  \n+\n       // Convert from _Up* if conversion to element_type* is valid.\n       template<typename _Up>\n-        _Pointer_adapter(_Up*__arg)\n-        {\n-          __glibcxx_function_requires(_ConvertibleConcept<element_type*, _Up*>);\n-          _Storage_policy::set(__arg); \n-        }\n-  \n+        _Pointer_adapter(_Up* __arg)\n+        { _Storage_policy::set(__arg); }\n+\n       // Conversion from another _Pointer_adapter if _Up if static cast is\n       // valid.\n       template<typename _Up>\n         _Pointer_adapter(const _Pointer_adapter<_Up>& __arg)\n-        { \n-          __glibcxx_function_requires(_ConvertibleConcept<element_type*, \n-            typename _Pointer_adapter<_Up>::element_type*>);\n-          _Storage_policy::set(__arg.get()); \n-        }\n-  \n+        { _Storage_policy::set(__arg.get()); }\n+\n       // Destructor\n       ~_Pointer_adapter() { }\n   \n@@ -344,7 +304,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n         _Storage_policy::set(__arg.get()); \n         return *this; \n       }\n- \n+\n       template<typename _Up>\n         _Pointer_adapter&\n         operator=(const _Pointer_adapter<_Up>& __arg)\n@@ -365,17 +325,17 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       inline reference \n       operator*() const \n       { return *(_Storage_policy::get()); }\n-  \n+\n       // Operator->, returns element_type*\n       inline element_type* \n       operator->() const \n       { return _Storage_policy::get(); }\n-  \n+\n       // Operator[], returns a element_type& to the item at that loc.\n-      inline reference \n-      operator[](int __index) const\n+      inline reference\n+      operator[](std::ptrdiff_t __index) const\n       { return _Storage_policy::get()[__index]; }\n-  \n+\n       // To allow implicit conversion to \"bool\", for \"if (ptr)...\"\n     private:\n       typedef element_type*(_Pointer_adapter::*__unspecified_bool_type)() const;\n@@ -388,9 +348,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       }\n \n       // ! operator (for: if (!ptr)...)\n-      inline bool \n+      inline bool\n       operator!() const \n-      { return (_Storage_policy::get()==NULL); }\n+      { return (_Storage_policy::get() == 0); }\n   \n       // Pointer differences\n       inline friend std::ptrdiff_t \n@@ -401,12 +361,12 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       operator-(element_type* __lhs, const _Pointer_adapter& __rhs) \n       { return (__lhs - __rhs.get()); }\n   \n-      template<class _Up>\n+      template<typename _Up>\n         inline friend std::ptrdiff_t \n         operator-(const _Pointer_adapter& __lhs, _Up* __rhs) \n         { return (__lhs.get() - __rhs); }\n     \n-      template<class _Up>\n+      template<typename _Up>\n         inline friend std::ptrdiff_t \n         operator-(_Up* __lhs, const _Pointer_adapter& __rhs)\n         { return (__lhs - __rhs.get()); }\n@@ -483,7 +443,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       }\n   \n       inline _Pointer_adapter\n-      operator--(int __unused) \n+      operator--(int) \n       {\n         _Pointer_adapter tmp(*this);\n         _Storage_policy::set(_Storage_policy::get() - 1);\n@@ -520,7 +480,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>,);\n   _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>=,);\n \n-\n   // These are here for expressions like \"ptr == 0\", \"ptr != 0\"\n   template<typename _Tp>\n     inline bool\n@@ -551,42 +510,37 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     operator==(const _Pointer_adapter<_Tp>& __lhs, \n                const _Pointer_adapter<_Tp>& __rhs)\n     { return __lhs._Tp::operator==(__rhs); }\n-  \n+\n   template<typename _Tp>\n     inline bool\n     operator<=(const _Pointer_adapter<_Tp>& __lhs, \n                const _Pointer_adapter<_Tp>& __rhs)\n     { return __lhs._Tp::operator<(__rhs) || __lhs._Tp::operator==(__rhs); }\n-  \n+\n   template<typename _Tp>\n     inline bool\n     operator!=(const _Pointer_adapter<_Tp>& __lhs, \n                const _Pointer_adapter<_Tp>& __rhs)\n     { return !(__lhs._Tp::operator==(__rhs)); }\n-  \n+\n   template<typename _Tp>\n     inline bool\n     operator>(const _Pointer_adapter<_Tp>& __lhs, \n               const _Pointer_adapter<_Tp>& __rhs)\n     { return !(__lhs._Tp::operator<(__rhs) || __lhs._Tp::operator==(__rhs)); }\n-  \n+\n   template<typename _Tp>\n     inline bool\n     operator>=(const _Pointer_adapter<_Tp>& __lhs, \n                const _Pointer_adapter<_Tp>& __rhs)\n     { return !(__lhs._Tp::operator<(__rhs)); }\n-  \n-  \n-  template<class _CharT, class _Traits, class _StoreT>\n-    std::basic_ostream<_CharT, _Traits>&\n-    operator<<(std::basic_ostream<_CharT, _Traits> &os, \n+\n+  template<typename _CharT, typename _Traits, typename _StoreT>\n+    inline std::basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits>& __os, \n                const _Pointer_adapter<_StoreT>& __p)\n-    {\n-      os << __p.get();\n-      return os;\n-    }\n+    { return (__os << __p.get()); }\n \n- \n _GLIBCXX_END_NAMESPACE\n \n-#endif /* _GCC_EXT_POINTER_ADAPTER */\n+#endif // _POINTER_H"}]}