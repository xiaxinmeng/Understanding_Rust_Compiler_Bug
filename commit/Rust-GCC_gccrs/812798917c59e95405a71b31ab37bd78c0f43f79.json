{"sha": "812798917c59e95405a71b31ab37bd78c0f43f79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyNzk4OTE3YzU5ZTk1NDA1YTcxYjMxYWIzN2JkNzhjMGY0M2Y3OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-07-07T05:41:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-07-20T21:54:18Z"}, "message": "c++: Allow subobject references in C++20.\n\nThe last new thing allowed by P1907R1: subobject addresses as template\narguments.  The ABI group has discussed mangling for this; there has been\nsome talk of a compressed subobject mangling, but it hasn't been finalized,\nso for now I'm using normal expression mangling.  In order for two array\nsubobject references to compare as equal template arguments, the offsets\nneed to have the same type, so I convert them to always be the same type,\ncurrently ptrdiff_t.  Base class conversions are represented as a cast to\nreference type, only if necessary to resolve an ambiguity.\n\nThis patch also updates the value of __cpp_nontype_template_args, since\nthe paper is fully implemented.\n\ngcc/cp/ChangeLog:\n\n\t* mangle.c (write_base_ref): New.\n\t(write_expression): Use it for base field COMPONENT_REFs.\n\t* pt.c (invalid_tparm_referent_p): Canonicalize the type\n\tof array offsets.  Allow subobjects.\n\ngcc/c-family/ChangeLog:\n\n\t* c-cppbuiltin.c (c_cpp_builtins): Update\n\t__cpp_nontype_template_args for C++20.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/nontype2.C: No error in C++20.\n\t* g++.dg/template/nontype25.C: No error in C++20.\n\t* g++.dg/template/nontype8.C: No error in C++20.\n\t* g++.dg/cpp2a/nontype-subob1.C: New test.\n\t* g++.dg/cpp2a/nontype-subob2.C: New test.\n\t* g++.dg/cpp1z/nontype3.C: Now C++17-only.\n\t* g++.dg/cpp2a/feat-cxx2a.C: Adjust expected value.", "tree": {"sha": "7819648c4081fc5e37fba3b3ae505472d5023bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7819648c4081fc5e37fba3b3ae505472d5023bd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/812798917c59e95405a71b31ab37bd78c0f43f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812798917c59e95405a71b31ab37bd78c0f43f79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812798917c59e95405a71b31ab37bd78c0f43f79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812798917c59e95405a71b31ab37bd78c0f43f79/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0ffe9d5dc83092e6de996483c4c08b439a316c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ffe9d5dc83092e6de996483c4c08b439a316c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0ffe9d5dc83092e6de996483c4c08b439a316c0"}], "stats": {"total": 140, "additions": 126, "deletions": 14}, "files": [{"sha": "74ecca8de8e08610c43249047e0be1a3bab6eb2e", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -967,7 +967,8 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_enumerator_attributes=201411L\");\n \t  cpp_define (pfile, \"__cpp_nested_namespace_definitions=201411L\");\n \t  cpp_define (pfile, \"__cpp_fold_expressions=201603L\");\n-\t  cpp_define (pfile, \"__cpp_nontype_template_args=201411L\");\n+\t  if (cxx_dialect <= cxx17)\n+\t    cpp_define (pfile, \"__cpp_nontype_template_args=201411L\");\n \t  cpp_define (pfile, \"__cpp_range_based_for=201603L\");\n \t  if (cxx_dialect <= cxx17)\n \t    cpp_define (pfile, \"__cpp_constexpr=201603L\");\n@@ -998,6 +999,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_consteval=201811L\");\n \t  cpp_define (pfile, \"__cpp_constinit=201907L\");\n \t  cpp_define (pfile, \"__cpp_deduction_guides=201907L\");\n+\t  cpp_define (pfile, \"__cpp_nontype_template_args=201911L\");\n \t  cpp_define (pfile, \"__cpp_nontype_template_parameter_class=201806L\");\n \t  cpp_define (pfile, \"__cpp_impl_destroying_delete=201806L\");\n \t  cpp_define (pfile, \"__cpp_constexpr_dynamic_alloc=201907L\");"}, {"sha": "43ff2e84db5850e831b89f796e6f90a1b2e400a0", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -2850,6 +2850,60 @@ write_member_name (tree member)\n     write_expression (member);\n }\n \n+/* EXPR is a base COMPONENT_REF; write the minimized base conversion path for\n+   converting to BASE, or just the conversion of EXPR if BASE is null.\n+\n+   \"Given a fully explicit base path P := C_n -> ... -> C_0, the minimized base\n+   path Min(P) is defined as follows: let C_i be the last element for which the\n+   conversion to C_0 is unambiguous; if that element is C_n, the minimized path\n+   is C_n -> C_0; otherwise, the minimized path is Min(C_n -> ... -> C_i) ->\n+   C_0.\"\n+\n+   We mangle the conversion to C_i if it's different from C_n.  */\n+\n+static bool\n+write_base_ref (tree expr, tree base = NULL_TREE)\n+{\n+  if (TREE_CODE (expr) != COMPONENT_REF)\n+    return false;\n+\n+  tree field = TREE_OPERAND (expr, 1);\n+\n+  if (TREE_CODE (field) != FIELD_DECL || !DECL_FIELD_IS_BASE (field))\n+    return false;\n+\n+  tree object = TREE_OPERAND (expr, 0);\n+\n+  tree binfo = NULL_TREE;\n+  if (base)\n+    {\n+      tree cur = TREE_TYPE (object);\n+      binfo = lookup_base (cur, base, ba_unique, NULL, tf_none);\n+    }\n+  else\n+    /* We're at the end of the base conversion chain, so it can't be\n+       ambiguous.  */\n+    base = TREE_TYPE (field);\n+\n+  if (binfo == error_mark_node)\n+    {\n+      /* cur->base is ambiguous, so make the conversion to\n+\t last explicit, expressed as a cast (last&)object.  */\n+      tree last = TREE_TYPE (expr);\n+      write_string (OVL_OP_INFO (false, CAST_EXPR)->mangled_name);\n+      write_type (build_reference_type (last));\n+      write_expression (object);\n+    }\n+  else if (write_base_ref (object, base))\n+    /* cur->base is unambiguous, but we had another base conversion\n+       underneath and wrote it out.  */;\n+  else\n+    /* No more base conversions, just write out the object.  */\n+    write_expression (object);\n+\n+  return true;\n+}\n+\n /* <expression> ::= <unary operator-name> <expression>\n \t\t::= <binary operator-name> <expression> <expression>\n \t\t::= <expr-primary>\n@@ -3268,6 +3322,8 @@ write_expression (tree expr)\n \t      ob = TREE_OPERAND (ob, 0);\n \t      write_expression (ob);\n \t    }\n+\t  else if (write_base_ref (expr))\n+\t    return;\n \t  else if (!is_dummy_object (ob))\n \t    {\n \t      write_string (\"dt\");"}, {"sha": "cfe5dcd59cf11f9aa1c8af7a4af79341f5ee84cc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -6907,7 +6907,9 @@ template_parm_object_p (const_tree t)\n }\n \n /* Subroutine of convert_nontype_argument, to check whether EXPR, as an\n-   argument for TYPE, points to an unsuitable object.  */\n+   argument for TYPE, points to an unsuitable object.\n+\n+   Also adjust the type of the index in C++20 array subobject references.  */\n \n static bool\n invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n@@ -6935,6 +6937,19 @@ invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n       {\n \ttree decl = TREE_OPERAND (expr, 0);\n \n+\tif (cxx_dialect >= cxx20)\n+\t  while (TREE_CODE (decl) == COMPONENT_REF\n+\t\t || TREE_CODE (decl) == ARRAY_REF)\n+\t    {\n+\t      tree &op = TREE_OPERAND (decl, 1);\n+\t      if (TREE_CODE (decl) == ARRAY_REF\n+\t\t  && TREE_CODE (op) == INTEGER_CST)\n+\t\t/* Canonicalize array offsets to ptrdiff_t; how they were\n+\t\t   written doesn't matter for subobject identity.  */\n+\t\top = fold_convert (ptrdiff_type_node, op);\n+\t      decl = TREE_OPERAND (decl, 0);\n+\t    }\n+\n \tif (!VAR_P (decl))\n \t  {\n \t    if (complain & tf_error)\n@@ -6976,9 +6991,10 @@ invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n \t\t     decl);\n \t    return true;\n \t  }\n-\telse if (!same_type_ignoring_top_level_qualifiers_p\n-\t\t (strip_array_types (TREE_TYPE (type)),\n-\t\t  strip_array_types (TREE_TYPE (decl))))\n+\telse if (cxx_dialect < cxx20\n+\t\t && !(same_type_ignoring_top_level_qualifiers_p\n+\t\t      (strip_array_types (TREE_TYPE (type)),\n+\t\t       strip_array_types (TREE_TYPE (decl)))))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"the address of the %qT subobject of %qD is not a \""}, {"sha": "cf73166dc3a5bba5775551348ccc5ce45e996b55", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype2.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -8,7 +8,7 @@ template<int* p> class X { };\n template<const char *s> class Y {};\n template<const std::type_info &> class Z {};\n \n-X<&s.m> x7;\t\t\t// { dg-error \"3:.& s.S::m. is not a valid template argument\" }\n+X<&s.m> x7; // { dg-error \"3:.& s.S::m. is not a valid template argument\" \"\" { target c++17_down } }\n Y<\"foo\"> y1;\t\t\t// { dg-error \"string literal\" }\n Z<typeid(p)> z1;\t\t// { dg-error \"\" }\n "}, {"sha": "1e02f1e1f5b4899d9022f370c9393ab1617783c3", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype3.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do compile { target c++17 } }\n+// { dg-do compile { target c++17_only } }\n \n #ifndef __cpp_nontype_template_args\n #error __cpp_nontype_template_args not defined"}, {"sha": "7f1fe34ad7fa8aa9b2335e269343ccea6dfc69e3", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -334,8 +334,8 @@\n \n #ifndef __cpp_nontype_template_args\n #  error \"__cpp_nontype_template_args\"\n-#elif __cpp_nontype_template_args != 201411\n-#  error \"__cpp_nontype_template_args != 201411\"\n+#elif __cpp_nontype_template_args != 201911\n+#  error \"__cpp_nontype_template_args != 201911\"\n #endif\n \n #ifndef __cpp_hex_float"}, {"sha": "4c1633e22a04d73e6d91343c6a7f4bd9fcf2f0af", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-subob1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-subob1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-subob1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-subob1.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++20 } }\n+\n+template <auto N> struct A {};\n+template <class,class> struct assert_same;\n+template <class T> struct assert_same<T,T> {};\n+\n+#define TEQ(X,Y) static_assert(__is_same(A<(X)>,A<(Y)>))\n+#define TNEQ(X,Y) static_assert(!__is_same(A<(X)>,A<(Y)>))\n+\n+struct C { int i; };\n+\n+struct B: C\n+{\n+  int j[3];\n+} b;\n+\n+// { dg-final { scan-assembler _Z1f1AIXaddtL_Z1bE1iEE } }\n+void f(A<&b.i>) {}\n+TEQ(&b.i,&((C*)&b)->i);\n+\n+// { dg-final { scan-assembler _Z1g1AIXadixdtL_Z1bE1jLl1EEE } }\n+void g(A<&b.j[0]+1>) {}\n+TEQ(&b.j[1],&b.j[1]);\n+TEQ(&b.j[1],&b.j[0]+1);\n+TNEQ(&b.j[1],&b.j[0]);"}, {"sha": "a5768f643604b576e91d10e3bc75d0edd35001db", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-subob2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-subob2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-subob2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-subob2.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++20 } }\n+// { dg-additional-options -Wno-inaccessible-base }\n+\n+struct Base { int i; };\n+template <int N> struct Derived : Derived<N-1>, Base {};\n+template <> struct Derived<0> : Base {};\n+\n+template <int* P> struct A { };\n+\n+Derived<4> d;\n+void f(A<&((Derived<0>&)d).i>) {}\n+\n+// { dg-final { scan-assembler _Z1f1AIXaddtcvR7DerivedILi0EEL_Z1dE1iEE } }"}, {"sha": "aba85092794bbec39b8fc5e9236229721d4da633", "filename": "gcc/testsuite/g++.dg/template/nontype25.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype25.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -7,16 +7,16 @@ template<const A* a> class C {};\n template<const B* b> class D {};\n template<B* b> class E {};\n \n-template<const B* b> void f(D<b> &, C<static_cast<const A*>(b)> &) {} // { dg-error \"\" }\n+template<const B* b> void f(D<b> &, C<static_cast<const A*>(b)> &) {} // { dg-error \"\" \"\" { target { ! c++20 } } }\n template<const B* b> void g(D<b> &, E<const_cast<B*>(b)> &) {} // { dg-error \"\" \"\" { target { ! c++11 } } }\n \n B b;\n \n int main()\n {\n-  C<static_cast<const A*>(&b)> c; // { dg-error \"\" }\n+  C<static_cast<const A*>(&b)> c; // { dg-error \"\" \"\" { target c++17_down } }\n   D<&b> d;\n   E<const_cast<B*>(&b)> e; // { dg-error \"\" \"\" { target { ! c++11 } } }\n-  f(d, c);\t\t   // { dg-error \"\" \"\" { target c++11 } }\n+  f(d, c);\t\t   // { dg-error \"\" \"\" { target { c++11 && { ! c++20 } } } }\n   g(d, e);\n }"}, {"sha": "a0458b91ed4831a0f6567be09693c7c4ecf3aa6f", "filename": "gcc/testsuite/g++.dg/template/nontype8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812798917c59e95405a71b31ab37bd78c0f43f79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype8.C?ref=812798917c59e95405a71b31ab37bd78c0f43f79", "patch": "@@ -6,9 +6,9 @@ template<int* p> class X { };\n int a[10];\n struct S { int m; static int s; } s;\n \n-X<&a[2]> x3;                    // { dg-error \"3:.& a\\\\\\[2\\\\\\]. is not a valid template argument\" \"\" { target c++17 } }\n+X<&a[2]> x3;                    // { dg-error \"3:.& a\\\\\\[2\\\\\\]. is not a valid template argument\" \"\" { target c++17_only } }\n // { dg-error \"\" \"\" { target c++14_down } .-1 }\n-X<&s.m> x4;                     // { dg-error \"3:.& s.S::m. is not a valid template argument\" \"\" { target c++17 } }\n+X<&s.m> x4;                     // { dg-error \"3:.& s.S::m. is not a valid template argument\" \"\" { target c++17_only } }\n // { dg-error \"\" \"\" { target c++14_down } .-1 }\n X<&s.s> x5;                     // { dg-error \"\" \"\" { target { ! c++17 } } } &S::s must be used\n X<&S::s> x6;                    // OK: address of static member"}]}