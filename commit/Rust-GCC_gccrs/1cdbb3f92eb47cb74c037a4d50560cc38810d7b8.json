{"sha": "1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNkYmIzZjkyZWI0N2NiNzRjMDM3YTRkNTA1NjBjYzM4ODEwZDdiOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-10T08:32:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-10T08:32:36Z"}, "message": "lto-cgraph.c (compute_ltrans_boundary): Do not care about aliases.\n\n\n\t* lto-cgraph.c (compute_ltrans_boundary): Do not care about aliases.\n\t* lto-partition.c (partition_symbol_p): Forward declare.\n\t(add_references_to_partition): Reimplement using partition_symbol_p.\n\t(add_aliases_to_partition): Break out from add_references_to_partition;\n\treimplement using partition_symbol_p.\n\t(add_cgraph_node_to_partition_1): Handle callees using partition_symbol_p;\n\tadd sanity checks.\n\t(add_varpool_node_to_partition): Use add_aliases_to_partition.\n\t(partition_varpool_node_p): Do not special case aliases.\n\nFrom-SVN: r191129", "tree": {"sha": "865c0b54e18cfb2b9d2e793041cef72810e71181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/865c0b54e18cfb2b9d2e793041cef72810e71181"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/comments", "author": null, "committer": null, "parents": [{"sha": "6ca408fc44483cdbee4d8b1b2da288239581b197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca408fc44483cdbee4d8b1b2da288239581b197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca408fc44483cdbee4d8b1b2da288239581b197"}], "stats": {"total": 98, "additions": 55, "deletions": 43}, "files": [{"sha": "0a43ed829a24c20f63d96f2c60d5b663d32e8655", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "patch": "@@ -1,3 +1,9 @@\n+2012-09-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-cgraph.c (compute_ltrans_boundary): Do not care about aliases.\n+\t* symtab.c (symtab_make_decl_local): Remove user defined visibility\n+\twhen making symbol local.\n+\n 2012-09-09  Mark Kettenis  <kettenis@gnu.org>\n \n \t* config/openbsd-stdint.h (INTMAX_TYPE, UINTMAX_TYPE): Define."}, {"sha": "6223d1a6a5761d9aa8aa11f7506ad29b7440a154", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "patch": "@@ -730,8 +730,6 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n \t      add_references (encoder, &vnode->symbol.ref_list);\n \t    }\n-\t  else if (vnode->alias || vnode->alias_of)\n-\t    add_references (encoder, &vnode->symbol.ref_list);\n        }\n     }\n "}, {"sha": "b7a9de5c8cde1ff936aee8a9d8e560f976f9c820", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "patch": "@@ -1,3 +1,14 @@\n+2012-09-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (partition_symbol_p): Forward declare.\n+\t(add_references_to_partition): Reimplement using partition_symbol_p.\n+\t(add_aliases_to_partition): Break out from add_references_to_partition;\n+\treimplement using partition_symbol_p.\n+\t(add_cgraph_node_to_partition_1): Handle callees using partition_symbol_p;\n+\tadd sanity checks.\n+\t(add_varpool_node_to_partition): Use add_aliases_to_partition.\n+\t(partition_varpool_node_p): Do not special case aliases.\n+\n 2012-08-12  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_wpa_write_files): Do not delete partition encoder;"}, {"sha": "4775ee60340c4fb1d0f147b1afa6460207b563c9", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "patch": "@@ -35,6 +35,7 @@ VEC(ltrans_partition, heap) *ltrans_partitions;\n \n static void add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node);\n static void add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode);\n+static bool partition_symbol_p (symtab_node node);\n \n /* Create new partition with name NAME.  */\n static ltrans_partition\n@@ -62,55 +63,47 @@ free_ltrans_partitions (void)\n   VEC_free (ltrans_partition, heap, ltrans_partitions);\n }\n \n-/* See all references that go to comdat objects and bring them into partition too.\n-   Also see all aliases of the newly added entry and bring them, too.  */\n+/* Add all referenced symbols referenced by REFS that are not external and not\n+   partitioned into PART.  */\n static void\n add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n {\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n     {\n-      if (symtab_function_p (ref->referred)\n-\t  && (DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref),\n-\t\t\t   NULL)->symbol.decl)\n-\t      || (ref->use == IPA_REF_ALIAS\n-\t\t  && lookup_attribute\n-\t\t       (\"weakref\", DECL_ATTRIBUTES (ref->referred->symbol.decl))))\n-\t  && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n+      if (DECL_EXTERNAL (ref->referred->symbol.decl)\n+\t  || partition_symbol_p (ref->referred)\n+\t  || lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n+\tcontinue;\n+      if (symtab_function_p (ref->referred))\n \tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n       else\n-        if (symtab_variable_p (ref->referred)\n-\t    && (DECL_COMDAT (ref->referred->symbol.decl)\n-\t\t|| DECL_EXTERNAL (ref->referred->symbol.decl)\n-\t        || (ref->use == IPA_REF_ALIAS\n-\t\t    && lookup_attribute\n-\t\t         (\"weakref\",\n-\t\t\t  DECL_ATTRIBUTES (ref->referred->symbol.decl))))\n-\t    && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n-\t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n+\tadd_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n     }\n+}\n+\n+/* Look for all (nonweakref) aliases in REFS and add them into PART. */\n+static void\n+add_aliases_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n   for (i = 0; ipa_ref_list_referring_iterate (refs, i, ref); i++)\n-    {\n-      if (symtab_function_p (ref->referring)\n-\t  && ref->use == IPA_REF_ALIAS\n-\t  && !lto_symtab_encoder_in_partition_p (part->encoder,\n-\t\t\t\t\t\t ref->referring)\n-\t  && !lookup_attribute (\"weakref\",\n-\t\t\t\tDECL_ATTRIBUTES\n-\t\t\t\t  (ref->referring->symbol.decl)))\n-\tadd_cgraph_node_to_partition (part, ipa_ref_referring_node (ref));\n-      else\n-        if (symtab_variable_p (ref->referring)\n-\t    && ref->use == IPA_REF_ALIAS\n-\t    && !lto_symtab_encoder_in_partition_p (part->encoder,\n-\t\t\t\t\t\t   ref->referring)\n-\t    && !lookup_attribute (\"weakref\",\n-\t\t\t\t  DECL_ATTRIBUTES\n-\t\t\t\t    (ref->referring->symbol.decl)))\n+    if (ref->use == IPA_REF_ALIAS\n+\t&& !lto_symtab_encoder_in_partition_p (part->encoder,\n+\t\t\t\t\t       ref->referring)\n+\t&& !lookup_attribute (\"weakref\",\n+\t\t\t      DECL_ATTRIBUTES\n+\t\t\t\t(ref->referring->symbol.decl)))\n+      {\n+\tif (symtab_function_p (ref->referring))\n+\t  add_cgraph_node_to_partition (part, ipa_ref_referring_node (ref));\n+\telse\n \t  add_varpool_node_to_partition (part,\n \t\t\t\t\t ipa_ref_referring_varpool_node (ref));\n-    }\n+      }\n }\n \n /* Worker for add_cgraph_node_to_partition.  */\n@@ -120,6 +113,9 @@ add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n {\n   ltrans_partition part = (ltrans_partition) data;\n \n+  if (lto_symtab_encoder_in_partition_p (part->encoder, (symtab_node) node))\n+    return false;\n+\n   /* non-COMDAT aliases of COMDAT functions needs to be output just once.  */\n   if (!DECL_COMDAT (node->symbol.decl)\n       && !node->global.inlined_to\n@@ -157,12 +153,10 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n \n   part->insns += inline_summary (node)->self_size;\n \n-\n-  lto_set_symtab_encoder_in_partition (part->encoder, (symtab_node) node);\n-\n   for (e = node->callees; e; e = e->next_callee)\n     if ((!e->inline_failed\n-\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->symbol.decl)))\n+         || (!DECL_EXTERNAL (e->callee->symbol.decl)\n+\t     && !partition_symbol_p ((symtab_node) e->callee))))\n       add_cgraph_node_to_partition (part, e->callee);\n \n   /* The only way to assemble non-weakref alias is to add the aliased object into\n@@ -211,6 +205,7 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n     add_varpool_node_to_partition (part, v);\n \n   add_references_to_partition (part, &vnode->symbol.ref_list);\n+  add_aliases_to_partition (part, &vnode->symbol.ref_list);\n \n   if (vnode->symbol.same_comdat_group\n       && !lto_symtab_encoder_in_partition_p (part->encoder,\n@@ -266,7 +261,7 @@ partition_cgraph_node_p (struct cgraph_node *node)\n static bool\n partition_varpool_node_p (struct varpool_node *vnode)\n {\n-  if (vnode->alias || !vnode->analyzed)\n+  if (!vnode->analyzed)\n     return false;\n   /* Constant pool and comdat are always only in partitions they are needed.  */\n   if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)"}, {"sha": "1dceb799dadb8940585db9103d975baf1a243e2a", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdbb3f92eb47cb74c037a4d50560cc38810d7b8/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=1cdbb3f92eb47cb74c037a4d50560cc38810d7b8", "patch": "@@ -734,6 +734,8 @@ symtab_make_decl_local (tree decl)\n   DECL_WEAK (decl) = 0;\n   DECL_EXTERNAL (decl) = 0;\n   TREE_PUBLIC (decl) = 0;\n+  DECL_VISIBILITY_SPECIFIED (decl) = 0;\n+  DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n   if (!DECL_RTL_SET_P (decl))\n     return;\n "}]}