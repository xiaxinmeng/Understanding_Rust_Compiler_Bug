{"sha": "8cd5951d68b98425beec4a632abcdc3c559074a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkNTk1MWQ2OGI5ODQyNWJlZWM0YTYzMmFiY2RjM2M1NTkwNzRhNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-05-27T10:10:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-15T13:42:40Z"}, "message": "[Ada] Extend static functions\n\ngcc/ada/\n\n\t* inline.adb, inline.ads\n\t(Inline_Static_Expression_Function_Call): Renamed\n\tInline_Static_Function_Call.\n\t* sem_ch13.adb (Analyze_Aspect_Static): Allow static intrinsic\n\timported functions under -gnatX.\n\t* sem_util.ads, sem_util.adb (Is_Static_Expression_Function):\n\tRenamed Is_Static_Function.\n\t(Is_Static_Expression_Function_Call): Renamed\n\tIs_Static_Function_Call.\n\t* sem_ch6.adb, sem_elab.adb, sem_res.adb: Update calls to\n\tIs_Static_Function*.\n\t* sem_eval.adb (Fold_Dummy, Eval_Intrinsic_Call, Fold_Shift):\n\tNew.\n\t(Eval_Call): Add support for intrinsic calls, code refactoring.\n\t(Eval_Entity_Name): Code refactoring.\n\t(Eval_Logical_Op): Update comment.\n\t(Eval_Shift): Call Fold_Shift. Update comments.\n\t* par-prag.adb (Par [Pragma_Extensions_Allowed]): Set\n\tAda_Version to Ada_Version_Type'Last to handle\n\tExtensions_Allowed (On) consistently.\n\t* opt.ads (Extensions_Allowed): Update documentation.\n\t* sem_attr.adb: Update comment.\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Update\n\tdocumentation of Extensions_Allowed.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "af7d3ce514dc5102c4a9eb08613c871fb1337be0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af7d3ce514dc5102c4a9eb08613c871fb1337be0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd5951d68b98425beec4a632abcdc3c559074a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd5951d68b98425beec4a632abcdc3c559074a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd5951d68b98425beec4a632abcdc3c559074a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd5951d68b98425beec4a632abcdc3c559074a4/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa02302bc17def4530df18fd5d77d0236cacb395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa02302bc17def4530df18fd5d77d0236cacb395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa02302bc17def4530df18fd5d77d0236cacb395"}], "stats": {"total": 492, "additions": 362, "deletions": 130}, "files": [{"sha": "737bc60230aaf7f8d9cb259321a962035083430d", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -2193,16 +2193,32 @@ extension mode (the use of Off as a parameter cancels the effect\n of the *-gnatX* command switch).\n \n In extension mode, the latest version of the Ada language is\n-implemented (currently Ada 2012), and in addition a small number\n+implemented (currently Ada 202x), and in addition a small number\n of GNAT specific extensions are recognized as follows:\n \n+* Constrained attribute for generic objects\n \n-\n-*Constrained attribute for generic objects*\n   The ``Constrained`` attribute is permitted for objects of\n   generic types. The result indicates if the corresponding actual\n   is constrained.\n \n+* ``Static`` aspect on intrinsic functions\n+\n+  The Ada 202x ``Static`` aspect can be specified on Intrinsic imported\n+  functions and the compiler will evaluate some of these intrinsic statically,\n+  in particular the ``Shift_Left`` and ``Shift_Right`` intrinsics.\n+\n+* ``'Reduce`` attribute\n+\n+  This attribute part of the Ada 202x language definition is provided for\n+  now under -gnatX to confirm and potentially refine its usage and syntax.\n+\n+* ``[]`` aggregates\n+\n+  This new aggregate syntax for arrays and containers is provided under -gnatX\n+  to experiment and confirm this new language syntax.\n+\n+\n .. _Pragma-Extensions_Visible:\n \n Pragma Extensions_Visible"}, {"sha": "882f9e22b6dd16fd949d013077f5a9196d9f2d8d", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -3610,18 +3610,38 @@ extension mode (the use of Off as a parameter cancels the effect\n of the @emph{-gnatX} command switch).\n \n In extension mode, the latest version of the Ada language is\n-implemented (currently Ada 2012), and in addition a small number\n+implemented (currently Ada 202x), and in addition a small number\n of GNAT specific extensions are recognized as follows:\n \n \n-@table @asis\n+@itemize *\n \n-@item @emph{Constrained attribute for generic objects}\n+@item \n+Constrained attribute for generic objects\n \n The @code{Constrained} attribute is permitted for objects of\n generic types. The result indicates if the corresponding actual\n is constrained.\n-@end table\n+\n+@item \n+@code{Static} aspect on intrinsic functions\n+\n+The Ada 202x @code{Static} aspect can be specified on Intrinsic imported\n+functions and the compiler will evaluate some of these intrinsic statically,\n+in particular the @code{Shift_Left} and @code{Shift_Right} intrinsics.\n+\n+@item \n+@code{'Reduce} attribute\n+\n+This attribute part of the Ada 202x language definition is provided for\n+now under -gnatX to confirm and potentially refine its usage and syntax.\n+\n+@item \n+@code{[]} aggregates\n+\n+This new aggregate syntax for arrays and containers is provided under -gnatX\n+to experiment and confirm this new language syntax.\n+@end itemize\n \n @node Pragma Extensions_Visible,Pragma External,Pragma Extensions_Allowed,Implementation Defined Pragmas\n @anchor{gnat_rm/implementation_defined_pragmas id12}@anchor{66}@anchor{gnat_rm/implementation_defined_pragmas pragma-extensions-visible}@anchor{67}"}, {"sha": "b08634e78e09f9eae0aad02648946ed93389b219", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -4632,13 +4632,11 @@ package body Inline is\n       Backend_Not_Inlined_Subps := No_Elist;\n    end Initialize;\n \n-   --------------------------------------------\n-   -- Inline_Static_Expression_Function_Call --\n-   --------------------------------------------\n+   ---------------------------------\n+   -- Inline_Static_Function_Call --\n+   ---------------------------------\n \n-   procedure Inline_Static_Expression_Function_Call\n-     (N : Node_Id; Subp : Entity_Id)\n-   is\n+   procedure Inline_Static_Function_Call (N : Node_Id; Subp : Entity_Id) is\n \n       function Replace_Formal (N : Node_Id) return Traverse_Result;\n       --  Replace each occurrence of a formal with the corresponding actual,\n@@ -4697,10 +4695,10 @@ package body Inline is\n \n       procedure Reset_Slocs is new Traverse_Proc (Reset_Sloc);\n \n-   --  Start of processing for Inline_Static_Expression_Function_Call\n+   --  Start of processing for Inline_Static_Function_Call\n \n    begin\n-      pragma Assert (Is_Static_Expression_Function_Call (N));\n+      pragma Assert (Is_Static_Function_Call (N));\n \n       declare\n          Decls     : constant List_Id := New_List;\n@@ -4759,7 +4757,7 @@ package body Inline is\n \n          Reset_Actual_Mapping_For_Inlined_Call (Subp);\n       end;\n-   end Inline_Static_Expression_Function_Call;\n+   end Inline_Static_Function_Call;\n \n    ------------------------\n    -- Instantiate_Bodies --"}, {"sha": "51eab9c7318efdd1c81c4b7be9ae4636102bb0df", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -227,11 +227,11 @@ package Inline is\n    --  Check a list of statements, Stats, that make inlining of Subp not\n    --  worthwhile, including any tasking statement, nested at any level.\n \n-   procedure Inline_Static_Expression_Function_Call\n+   procedure Inline_Static_Function_Call\n      (N : Node_Id; Subp : Entity_Id);\n-   --  Evaluate static call to a static expression function Subp, substituting\n-   --  actuals in place of references to their corresponding formals and\n-   --  rewriting the call N as a fully folded and static result expression.\n+   --  Evaluate static call to a static function Subp, substituting actuals in\n+   --  place of references to their corresponding formals and rewriting the\n+   --  call N as a fully folded and static result expression.\n \n    procedure List_Inlining_Info;\n    --  Generate listing of calls inlined by the frontend plus listing of"}, {"sha": "78b2b50e033ebe1288ab315e75665f95d28c63b8", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -620,7 +620,7 @@ package Opt is\n    Extensions_Allowed : Boolean := False;\n    --  GNAT\n    --  Set to True by switch -gnatX if GNAT specific language extensions\n-   --  are allowed. Currently there are no such defined extensions.\n+   --  are allowed. See GNAT RM for details.\n \n    type External_Casing_Type is (\n      As_Is,       -- External names cased as they appear in the Ada source"}, {"sha": "1f25ec8fbf03eb5e56302b7a140ced29be45f00b", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -435,7 +435,7 @@ begin\n \n          if Chars (Expression (Arg1)) = Name_On then\n             Extensions_Allowed := True;\n-            Ada_Version := Ada_2012;\n+            Ada_Version := Ada_Version_Type'Last;\n          else\n             Extensions_Allowed := False;\n             Ada_Version := Ada_Version_Explicit;"}, {"sha": "80e8f099e37911f68682cb9696a35541f2536f3d", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -3540,7 +3540,7 @@ package body Sem_Attr is\n                return;\n \n             --  Also allow an object of a generic type if extensions allowed\n-            --  and allow this for any type at all. (this may be obsolete ???)\n+            --  and allow this for any type at all.\n \n             elsif (Is_Generic_Type (P_Type)\n                     or else Is_Generic_Actual_Type (P_Type))"}, {"sha": "5c3cc48f08d06decb9888dfce741793730c5eb84", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -2405,28 +2405,80 @@ package body Sem_Ch13 is\n             ---------------------------\n \n             procedure Analyze_Aspect_Static is\n+               function Has_Convention_Intrinsic (L : List_Id) return Boolean;\n+               --  Return True if L contains a pragma argument association\n+               --  node representing a convention Intrinsic.\n+\n+               ------------------------------\n+               -- Has_Convention_Intrinsic --\n+               ------------------------------\n+\n+               function Has_Convention_Intrinsic\n+                 (L : List_Id) return Boolean\n+               is\n+                  Arg : Node_Id := First (L);\n+               begin\n+                  while Present (Arg) loop\n+                     if Nkind (Arg) = N_Pragma_Argument_Association\n+                       and then Chars (Arg) = Name_Convention\n+                       and then Chars (Expression (Arg)) = Name_Intrinsic\n+                     then\n+                        return True;\n+                     end if;\n+\n+                     Next (Arg);\n+                  end loop;\n+\n+                  return False;\n+               end Has_Convention_Intrinsic;\n+\n+               Is_Imported_Intrinsic : Boolean;\n+\n             begin\n                if Ada_Version < Ada_2020 then\n                   Error_Msg_N\n                     (\"aspect % is an Ada 202x feature\", Aspect);\n                   Error_Msg_N (\"\\compile with -gnat2020\", Aspect);\n \n                   return;\n+               end if;\n+\n+               Is_Imported_Intrinsic := Is_Imported (E)\n+                 and then\n+                   Has_Convention_Intrinsic\n+                     (Pragma_Argument_Associations (Import_Pragma (E)));\n \n                --  The aspect applies only to expression functions that\n                --  statisfy the requirements for a static expression function\n-               --  (such as having an expression that is predicate-static).\n+               --  (such as having an expression that is predicate-static) as\n+               --  well as Intrinsic imported functions as a -gnatX extension.\n \n-               elsif not Is_Expression_Function (E) then\n-                  Error_Msg_N\n-                    (\"aspect % requires expression function\", Aspect);\n+               if not Is_Expression_Function (E)\n+                 and then\n+                   not (Extensions_Allowed and then Is_Imported_Intrinsic)\n+               then\n+                  if Extensions_Allowed then\n+                     Error_Msg_N\n+                       (\"aspect % requires intrinsic or expression function\",\n+                        Aspect);\n+\n+                  elsif Is_Imported_Intrinsic then\n+                     Error_Msg_N\n+                       (\"aspect % on intrinsic function is an extension: \" &\n+                        \"use -gnatX\",\n+                        Aspect);\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"aspect % requires expression function\", Aspect);\n+                  end if;\n \n                   return;\n \n                --  Ada 202x (AI12-0075): Check that the function satisfies\n-               --  several requirements of static expression functions as\n-               --  specified in RM 6.8(5.1-5.8). Note that some of the\n-               --  requirements given there are checked elsewhere.\n+               --  several requirements of static functions as specified in\n+               --  RM 6.8(5.1-5.8). Note that some of the requirements given\n+               --  there are checked elsewhere.\n \n                else\n                   --  The expression of the expression function must be a"}, {"sha": "6651671e747ee4380ff29578dba8ef4f1bc7696c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -580,7 +580,7 @@ package body Sem_Ch6 is\n                --  requirements of the Ada 202x RM in 4.9(3.2/5-3.4/5) and\n                --  we flag an error.\n \n-               if Is_Static_Expression_Function (Def_Id) then\n+               if Is_Static_Function (Def_Id) then\n                   if not Is_Static_Expression (Expr) then\n                      declare\n                         Exp_Copy : constant Node_Id := New_Copy_Tree (Expr);"}, {"sha": "3cbc27fc5073b51513d06492d4d03ec57f44d358", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -3687,7 +3687,7 @@ package body Sem_Elab is\n \n       --  Static expression functions require no ABE processing\n \n-      elsif Is_Static_Expression_Function (Subp_Id) then\n+      elsif Is_Static_Function (Subp_Id) then\n          return;\n \n       --  Source calls to source targets are always considered because they"}, {"sha": "6707aaa5ded55c7c70c8866f88ad48f8c7dd2d1c", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 208, "deletions": 62, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -45,6 +45,7 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Elab; use Sem_Elab;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Type; use Sem_Type;\n@@ -171,6 +172,9 @@ package body Sem_Eval is\n    --  discrete, real, or string type and must be a compile-time-known value\n    --  (it is an error to make the call if these conditions are not met).\n \n+   procedure Eval_Intrinsic_Call (N : Node_Id; E : Entity_Id);\n+   --  Evaluate a call N to an intrinsic subprogram E.\n+\n    function Find_Universal_Operator_Type (N : Node_Id) return Entity_Id;\n    --  Check whether an arithmetic operation with universal operands which is a\n    --  rewritten function call with an explicit scope indication is ambiguous:\n@@ -179,6 +183,22 @@ package body Sem_Eval is\n    --  (e.g. in the expression of a type conversion). If ambiguous, emit an\n    --  error and return Empty, else return the result type of the operator.\n \n+   procedure Fold_Dummy (N : Node_Id; Typ : Entity_Id);\n+   --  Rewrite N as a constant dummy value in the relevant type if possible.\n+\n+   procedure Fold_Shift\n+     (N          : Node_Id;\n+      Left       : Node_Id;\n+      Right      : Node_Id;\n+      Op         : Node_Kind;\n+      Static     : Boolean := False;\n+      Check_Elab : Boolean := False);\n+   --  Rewrite N as the result of evaluating Left <shift op> Right if possible.\n+   --  Op represents the shift operation.\n+   --  Static indicates whether the resulting node should be marked static.\n+   --  Check_Elab indicates whether checks for elaboration calls should be\n+   --  inserted when relevant.\n+\n    function From_Bits (B : Bits; T : Entity_Id) return Uint;\n    --  Converts a bit string of length B'Length to a Uint value to be used for\n    --  a target of type T, which is a modular type. This procedure includes the\n@@ -2217,9 +2237,8 @@ package body Sem_Eval is\n    --  Only the latter case is handled here, predefined operators are\n    --  constant-folded elsewhere.\n \n-   --  If the function is itself inherited (see 7423-001) the literal of\n-   --  the parent type must be explicitly converted to the return type\n-   --  of the function.\n+   --  If the function is itself inherited the literal of the parent type must\n+   --  be explicitly converted to the return type of the function.\n \n    procedure Eval_Call (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -2246,37 +2265,22 @@ package body Sem_Eval is\n             Resolve (N, Typ);\n          end if;\n \n+      elsif Nkind (N) = N_Function_Call\n+        and then Is_Entity_Name (Name (N))\n+        and then Is_Intrinsic_Subprogram (Entity (Name (N)))\n+      then\n+         Eval_Intrinsic_Call (N, Entity (Name (N)));\n+\n       --  Ada 202x (AI12-0075): If checking for potentially static expressions\n-      --  is enabled and we have a call to a static expression function,\n-      --  substitute a static value for the call, to allow folding the\n-      --  expression. This supports checking the requirement of RM 6.8(5.3/5)\n-      --  in Analyze_Expression_Function.\n+      --  is enabled and we have a call to a static function, substitute a\n+      --  static value for the call, to allow folding the expression. This\n+      --  supports checking the requirement of RM 6.8(5.3/5) in\n+      --  Analyze_Expression_Function.\n \n       elsif Checking_Potentially_Static_Expression\n-        and then Is_Static_Expression_Function_Call (N)\n+        and then Is_Static_Function_Call (N)\n       then\n-         if Is_Integer_Type (Typ) then\n-            Fold_Uint (N, Uint_1, Static => True);\n-            return;\n-\n-         elsif Is_Real_Type (Typ) then\n-            Fold_Ureal (N, Ureal_1, Static => True);\n-            return;\n-\n-         elsif Is_Enumeration_Type (Typ) then\n-            Fold_Uint\n-              (N,\n-               Expr_Value (Type_Low_Bound (Base_Type (Typ))),\n-               Static => True);\n-            return;\n-\n-         elsif Is_String_Type (Typ) then\n-            Fold_Str\n-              (N,\n-               Strval (Make_String_Literal (Sloc (N), \"\")),\n-               Static => True);\n-            return;\n-         end if;\n+         Fold_Dummy (N, Typ);\n       end if;\n    end Eval_Call;\n \n@@ -2566,30 +2570,9 @@ package body Sem_Eval is\n \n       elsif Ekind (Def_Id) = E_In_Parameter\n         and then Checking_Potentially_Static_Expression\n-        and then Is_Static_Expression_Function (Scope (Def_Id))\n+        and then Is_Static_Function (Scope (Def_Id))\n       then\n-         if Is_Integer_Type (Etype (Def_Id)) then\n-            Fold_Uint (N, Uint_1, Static => True);\n-            return;\n-\n-         elsif Is_Real_Type (Etype (Def_Id)) then\n-            Fold_Ureal (N, Ureal_1, Static => True);\n-            return;\n-\n-         elsif Is_Enumeration_Type (Etype (Def_Id)) then\n-            Fold_Uint\n-              (N,\n-               Expr_Value (Type_Low_Bound (Base_Type (Etype (Def_Id)))),\n-               Static => True);\n-            return;\n-\n-         elsif Is_String_Type (Etype (Def_Id)) then\n-            Fold_Str\n-              (N,\n-               Strval (Make_String_Literal (Sloc (N), \"\")),\n-               Static => True);\n-            return;\n-         end if;\n+         Fold_Dummy (N, Etype (Def_Id));\n       end if;\n \n       --  Fall through if the name is not static\n@@ -2893,6 +2876,80 @@ package body Sem_Eval is\n       end if;\n    end Eval_Integer_Literal;\n \n+   -------------------------\n+   -- Eval_Intrinsic_Call --\n+   -------------------------\n+\n+   procedure Eval_Intrinsic_Call (N : Node_Id; E : Entity_Id) is\n+\n+      procedure Eval_Shift (N : Node_Id; E : Entity_Id; Op : Node_Kind);\n+      --  Evaluate an intrinsic shift call N on the given subprogram E.\n+      --  Op is the kind for the shift node.\n+\n+      ----------------\n+      -- Eval_Shift --\n+      ----------------\n+\n+      procedure Eval_Shift (N : Node_Id; E : Entity_Id; Op : Node_Kind) is\n+         Left   : constant Node_Id := First_Actual (N);\n+         Right  : constant Node_Id := Next_Actual (Left);\n+         Static : constant Boolean := Is_Static_Function (E);\n+\n+      begin\n+         if Static then\n+            if Checking_Potentially_Static_Expression then\n+               Fold_Dummy (N, Etype (N));\n+               return;\n+            end if;\n+         end if;\n+\n+         Fold_Shift\n+           (N, Left, Right, Op, Static => Static, Check_Elab => not Static);\n+      end Eval_Shift;\n+\n+      Nam : Name_Id;\n+\n+   begin\n+      --  Nothing to do if the intrinsic is handled by the back end.\n+\n+      if Present (Interface_Name (E)) then\n+         return;\n+      end if;\n+\n+      --  Intrinsic calls as part of a static function is a language extension.\n+\n+      if Checking_Potentially_Static_Expression\n+        and then not Extensions_Allowed\n+      then\n+         return;\n+      end if;\n+\n+      --  If we have a renaming, expand the call to the original operation,\n+      --  which must itself be intrinsic, since renaming requires matching\n+      --  conventions and this has already been checked.\n+\n+      if Present (Alias (E)) then\n+         Eval_Intrinsic_Call (N, Alias (E));\n+         return;\n+      end if;\n+\n+      --  If the intrinsic subprogram is generic, gets its original name\n+\n+      if Present (Parent (E))\n+        and then Present (Generic_Parent (Parent (E)))\n+      then\n+         Nam := Chars (Generic_Parent (Parent (E)));\n+      else\n+         Nam := Chars (E);\n+      end if;\n+\n+      case Nam is\n+         when Name_Shift_Left  => Eval_Shift (N, E, N_Op_Shift_Left);\n+         when Name_Shift_Right => Eval_Shift (N, E, N_Op_Shift_Right);\n+         when others           => null;\n+      end case;\n+   end Eval_Intrinsic_Call;\n+\n    ---------------------\n    -- Eval_Logical_Op --\n    ---------------------\n@@ -2932,7 +2989,9 @@ package body Sem_Eval is\n                To_Bits (Right_Int, Right_Bits);\n \n                --  Note: should really be able to use array ops instead of\n-               --  these loops, but they weren't working at the time ???\n+               --  these loops, but they break the build with a cryptic error\n+               --  during the bind of gnat1 likely due to a wrong computation\n+               --  of a date or checksum.\n \n                if Nkind (N) = N_Op_And then\n                   for J in Left_Bits'Range loop\n@@ -3761,16 +3820,13 @@ package body Sem_Eval is\n    -- Eval_Shift --\n    ----------------\n \n-   --  Shift operations are intrinsic operations that can never be static, so\n-   --  the only processing required is to perform the required check for a non\n-   --  static context for the two operands.\n-\n-   --  Actually we could do some compile time evaluation here some time ???\n-\n    procedure Eval_Shift (N : Node_Id) is\n    begin\n-      Check_Non_Static_Context (Left_Opnd (N));\n-      Check_Non_Static_Context (Right_Opnd (N));\n+      --  This procedure is only called for compiler generated code (e.g.\n+      --  packed arrays), so there is nothing to do except attempting to fold\n+      --  the expression.\n+\n+      Fold_Shift (N, Left_Opnd (N), Right_Opnd (N), Nkind (N));\n    end Eval_Shift;\n \n    ------------------------\n@@ -4688,6 +4744,96 @@ package body Sem_Eval is\n       end if;\n    end Flag_Non_Static_Expr;\n \n+   ----------------\n+   -- Fold_Dummy --\n+   ----------------\n+\n+   procedure Fold_Dummy (N : Node_Id; Typ : Entity_Id) is\n+   begin\n+      if Is_Integer_Type (Typ) then\n+         Fold_Uint (N, Uint_1, Static => True);\n+\n+      elsif Is_Real_Type (Typ) then\n+         Fold_Ureal (N, Ureal_1, Static => True);\n+\n+      elsif Is_Enumeration_Type (Typ) then\n+         Fold_Uint\n+           (N,\n+            Expr_Value (Type_Low_Bound (Base_Type (Typ))),\n+            Static => True);\n+\n+      elsif Is_String_Type (Typ) then\n+         Fold_Str\n+           (N,\n+            Strval (Make_String_Literal (Sloc (N), \"\")),\n+            Static => True);\n+      end if;\n+   end Fold_Dummy;\n+\n+   ----------------\n+   -- Fold_Shift --\n+   ----------------\n+\n+   procedure Fold_Shift\n+     (N          : Node_Id;\n+      Left       : Node_Id;\n+      Right      : Node_Id;\n+      Op         : Node_Kind;\n+      Static     : Boolean := False;\n+      Check_Elab : Boolean := False)\n+   is\n+      Typ : constant Entity_Id := Etype (Left);\n+\n+      procedure Check_Elab_Call;\n+      --  Add checks related to calls in elaboration code\n+\n+      ---------------------\n+      -- Check_Elab_Call --\n+      ---------------------\n+\n+      procedure Check_Elab_Call is\n+      begin\n+         if Check_Elab then\n+            if Legacy_Elaboration_Checks then\n+               Check_Elab_Call (N);\n+            end if;\n+\n+            Build_Call_Marker (N);\n+         end if;\n+      end Check_Elab_Call;\n+\n+   begin\n+      --  Evaluate logical shift operators on binary modular types\n+\n+      if Is_Modular_Integer_Type (Typ)\n+        and then not Non_Binary_Modulus (Typ)\n+        and then Compile_Time_Known_Value (Left)\n+        and then Compile_Time_Known_Value (Right)\n+      then\n+         if Op = N_Op_Shift_Left then\n+            Check_Elab_Call;\n+\n+            --  Fold Shift_Left (X, Y) by computing (X * 2**Y) rem modulus\n+\n+            Fold_Uint\n+              (N,\n+               (Expr_Value (Left) * (Uint_2 ** Expr_Value (Right)))\n+                 rem Modulus (Typ),\n+               Static => Static);\n+\n+         elsif Op = N_Op_Shift_Right then\n+            Check_Elab_Call;\n+\n+            --  Fold Shift_Right (X, Y) by computing X / 2**Y\n+\n+            Fold_Uint\n+              (N,\n+               Expr_Value (Left) / (Uint_2 ** Expr_Value (Right)),\n+               Static => Static);\n+         end if;\n+      end if;\n+   end Fold_Shift;\n+\n    --------------\n    -- Fold_Str --\n    --------------"}, {"sha": "dc11a0886c1b8fc8e5e41b00da7a0dd0d18057a5", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -3035,7 +3035,7 @@ package body Sem_Res is\n          Resolution_Failed;\n          return;\n \n-      --  Only one intepretation\n+      --  Only one interpretation\n \n       else\n          --  In Ada 2005, if we have something like \"X : T := 2 + 2;\", where\n@@ -6573,7 +6573,7 @@ package body Sem_Res is\n \n          if Same_Or_Aliased_Subprograms (Nam, Scop)\n            and then not Restriction_Active (No_Recursion)\n-           and then not Is_Static_Expression_Function (Scop)\n+           and then not Is_Static_Function (Scop)\n            and then Check_Infinite_Recursion (N)\n          then\n             --  Here we detected and flagged an infinite recursion, so we do\n@@ -6591,11 +6591,10 @@ package body Sem_Res is\n             Scope_Loop : while Scop /= Standard_Standard loop\n                if Same_Or_Aliased_Subprograms (Nam, Scop) then\n \n-                  --  Ada 202x (AI12-0075): Static expression function are\n-                  --  never allowed to make a recursive call, as specified\n-                  --  by 6.8(5.4/5).\n+                  --  Ada 202x (AI12-0075): Static functions are never allowed\n+                  --  to make a recursive call, as specified by 6.8(5.4/5).\n \n-                  if Is_Static_Expression_Function (Scop) then\n+                  if Is_Static_Function (Scop) then\n                      Error_Msg_N\n                        (\"recursive call not allowed in static expression \"\n                           & \"function\", N);\n@@ -6758,7 +6757,7 @@ package body Sem_Res is\n         or else Is_Build_In_Place_Function (Nam)\n         or else Is_Intrinsic_Subprogram (Nam)\n         or else Is_Inlinable_Expression_Function (Nam)\n-        or else Is_Static_Expression_Function_Call (N)\n+        or else Is_Static_Function_Call (N)\n       then\n          null;\n \n@@ -7032,10 +7031,10 @@ package body Sem_Res is\n       --  when doing the inlining).\n \n       if not Checking_Potentially_Static_Expression\n-        and then Is_Static_Expression_Function_Call (N)\n+        and then Is_Static_Function_Call (N)\n         and then not Error_Posted (Ultimate_Alias (Nam))\n       then\n-         Inline_Static_Expression_Function_Call (N, Ultimate_Alias (Nam));\n+         Inline_Static_Function_Call (N, Ultimate_Alias (Nam));\n \n       --  In GNATprove mode, expansion is disabled, but we want to inline some\n       --  subprograms to facilitate formal verification. Indirect calls through"}, {"sha": "782337346bb45f90df9696abe2678ddca55de44e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -18729,30 +18729,31 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n-   ------------------------------------\n-   --  Is_Static_Expression_Function --\n-   ------------------------------------\n+   ------------------------\n+   -- Is_Static_Function --\n+   ------------------------\n \n-   function Is_Static_Expression_Function (Subp : Entity_Id) return Boolean is\n+   function Is_Static_Function (Subp : Entity_Id) return Boolean is\n    begin\n-      return Is_Expression_Function (Subp)\n-        and then Has_Aspect (Subp, Aspect_Static)\n+      return Has_Aspect (Subp, Aspect_Static)\n         and then\n           (No (Find_Value_Of_Aspect (Subp, Aspect_Static))\n             or else Is_True (Static_Boolean\n                                (Find_Value_Of_Aspect (Subp, Aspect_Static))));\n-   end Is_Static_Expression_Function;\n-\n-   -----------------------------------------\n-   --  Is_Static_Expression_Function_Call --\n-   -----------------------------------------\n+   end Is_Static_Function;\n \n-   function Is_Static_Expression_Function_Call (Call : Node_Id) return Boolean\n-   is\n+   ------------------------------\n+   --  Is_Static_Function_Call --\n+   ------------------------------\n \n+   function Is_Static_Function_Call (Call : Node_Id) return Boolean is\n       function Has_All_Static_Actuals (Call : Node_Id) return Boolean;\n       --  Return whether all actual parameters of Call are static expressions\n \n+      ----------------------------\n+      -- Has_All_Static_Actuals --\n+      ----------------------------\n+\n       function Has_All_Static_Actuals (Call : Node_Id) return Boolean is\n          Actual        : Node_Id := First_Actual (Call);\n          String_Result : constant Boolean :=\n@@ -18765,12 +18766,12 @@ package body Sem_Util is\n                --  ??? In the string-returning case we want to avoid a call\n                --  being made to Establish_Transient_Scope in Resolve_Call,\n                --  but at the point where that's tested for (which now includes\n-               --  a call to test Is_Static_Expression_Function_Call), the\n-               --  actuals of the call haven't been resolved, so expressions\n-               --  of the actuals may not have been marked Is_Static_Expression\n-               --  yet, so we force them to be resolved here, so we can tell if\n-               --  they're static. Calling Resolve here is admittedly a kludge,\n-               --  and we limit this call to string-returning cases. ???\n+               --  a call to test Is_Static_Function_Call), the actuals of the\n+               --  call haven't been resolved, so expressions of the actuals\n+               --  may not have been marked Is_Static_Expression yet, so we\n+               --  force them to be resolved here, so we can tell if they're\n+               --  static. Calling Resolve here is admittedly a kludge, and we\n+               --  limit this call to string-returning cases.\n \n                if String_Result then\n                   Resolve (Actual);\n@@ -18792,9 +18793,9 @@ package body Sem_Util is\n    begin\n       return Nkind (Call) = N_Function_Call\n         and then Is_Entity_Name (Name (Call))\n-        and then Is_Static_Expression_Function (Entity (Name (Call)))\n+        and then Is_Static_Function (Entity (Name (Call)))\n         and then Has_All_Static_Actuals (Call);\n-   end Is_Static_Expression_Function_Call;\n+   end Is_Static_Function_Call;\n \n    ----------------------------------------\n    --  Is_Subcomponent_Of_Atomic_Object  --"}, {"sha": "cc28eedc565ad737d85bbd0c6198a54a67e33117", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd5951d68b98425beec4a632abcdc3c559074a4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8cd5951d68b98425beec4a632abcdc3c559074a4", "patch": "@@ -2081,13 +2081,13 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n-   function Is_Static_Expression_Function (Subp : Entity_Id) return Boolean;\n-   --  Determine whether subprogram Subp denotes a static expression function,\n-   --  which is an expression function with the aspect Static with value True.\n+   function Is_Static_Function (Subp : Entity_Id) return Boolean;\n+   --  Determine whether subprogram Subp denotes a static function,\n+   --  which is a function with the aspect Static with value True.\n \n-   function Is_Static_Expression_Function_Call (Call : Node_Id) return Boolean;\n-   --  Determine whether Call is a static call to a static expression function,\n-   --  meaning that the name of the call denotes a static expression function\n+   function Is_Static_Function_Call (Call : Node_Id) return Boolean;\n+   --  Determine whether Call is a static call to a static function,\n+   --  meaning that the name of the call denotes a static function\n    --  and all of the call's actual parameters are given by static expressions.\n \n    function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean;"}]}