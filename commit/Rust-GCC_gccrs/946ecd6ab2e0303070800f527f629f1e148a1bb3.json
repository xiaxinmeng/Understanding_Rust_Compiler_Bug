{"sha": "946ecd6ab2e0303070800f527f629f1e148a1bb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ2ZWNkNmFiMmUwMzAzMDcwODAwZjUyN2Y2MjlmMWUxNDhhMWJiMw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-04-21T14:49:19Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-04-21T14:49:19Z"}, "message": "PR libstdc++/80316 make promise::set_value throw no_state error\n\n\tPR libstdc++/80316\n\t* include/std/future (_State_baseV2::_Setter::operator()): Remove\n\t_S_check calls that are done after the pointer to the shared state is\n\talready dereferenced.\n\t(_State_baseV2::_Setter<_Res, void>): Define specialization for void\n\tas partial specialization so it can be defined within the definition\n\tof _State_baseV2.\n\t(_State_baseV2::__setter): Call _S_check.\n\t(_State_baseV2::__setter(promise<void>*)): Add overload for use by\n\tpromise<void>::set_value and promise<void>::set_value_at_thread_exit.\n\t(promise<T>, promise<T&>, promise<void>): Make _State a friend.\n\t(_State_baseV2::_Setter<void, void>): Remove explicit specialization.\n\t(promise<void>::set_value, promise<void>::set_value_at_thread_exit):\n\tUse new __setter overload.\n\t* testsuite/30_threads/promise/members/at_thread_exit2.cc: New test.\n\t* testsuite/30_threads/promise/members/set_exception.cc: Test\n\tpromise<T&> and promise<void> specializations.\n\t* testsuite/30_threads/promise/members/set_exception2.cc: Likewise.\n\tTest for no_state error condition.\n\t* testsuite/30_threads/promise/members/set_value2.cc: Likewise.\n\nFrom-SVN: r247064", "tree": {"sha": "f779fe7290890be0edb3ec56ca625f3311448394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f779fe7290890be0edb3ec56ca625f3311448394"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/946ecd6ab2e0303070800f527f629f1e148a1bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946ecd6ab2e0303070800f527f629f1e148a1bb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/946ecd6ab2e0303070800f527f629f1e148a1bb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946ecd6ab2e0303070800f527f629f1e148a1bb3/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2c0a1942c16c58b39024aaecba443b84b3ad8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c0a1942c16c58b39024aaecba443b84b3ad8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c0a1942c16c58b39024aaecba443b84b3ad8f6"}], "stats": {"total": 769, "additions": 740, "deletions": 29}, "files": [{"sha": "bd43faa6c6d2ad502d258e2a85e8683723d71e6c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=946ecd6ab2e0303070800f527f629f1e148a1bb3", "patch": "@@ -1,5 +1,26 @@\n 2017-04-21  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/80316\n+\t* include/std/future (_State_baseV2::_Setter::operator()): Remove\n+\t_S_check calls that are done after the pointer to the shared state is\n+\talready dereferenced.\n+\t(_State_baseV2::_Setter<_Res, void>): Define specialization for void\n+\tas partial specialization so it can be defined within the definition\n+\tof _State_baseV2.\n+\t(_State_baseV2::__setter): Call _S_check.\n+\t(_State_baseV2::__setter(promise<void>*)): Add overload for use by\n+\tpromise<void>::set_value and promise<void>::set_value_at_thread_exit.\n+\t(promise<T>, promise<T&>, promise<void>): Make _State a friend.\n+\t(_State_baseV2::_Setter<void, void>): Remove explicit specialization.\n+\t(promise<void>::set_value, promise<void>::set_value_at_thread_exit):\n+\tUse new __setter overload.\n+\t* testsuite/30_threads/promise/members/at_thread_exit2.cc: New test.\n+\t* testsuite/30_threads/promise/members/set_exception.cc: Test\n+\tpromise<T&> and promise<void> specializations.\n+\t* testsuite/30_threads/promise/members/set_exception2.cc: Likewise.\n+\tTest for no_state error condition.\n+\t* testsuite/30_threads/promise/members/set_value2.cc: Likewise.\n+\n \t* include/backward/auto_ptr.h: Ignore deprecated warnings from use\n \tof auto_ptr.\n \t* include/bits/shared_ptr.h: Likewise."}, {"sha": "73d5a60a9183c32edfa5d9adf2e9ac372075596a", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=946ecd6ab2e0303070800f527f629f1e148a1bb3", "patch": "@@ -471,7 +471,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // Used by std::promise to copy construct the result.\n           typename promise<_Res>::_Ptr_type operator()() const\n           {\n-            _State_baseV2::_S_check(_M_promise->_M_future);\n             _M_promise->_M_storage->_M_set(*_M_arg);\n             return std::move(_M_promise->_M_storage);\n           }\n@@ -486,14 +485,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // Used by std::promise to move construct the result.\n           typename promise<_Res>::_Ptr_type operator()() const\n           {\n-            _State_baseV2::_S_check(_M_promise->_M_future);\n             _M_promise->_M_storage->_M_set(std::move(*_M_arg));\n             return std::move(_M_promise->_M_storage);\n           }\n           promise<_Res>*    _M_promise;\n           _Res*             _M_arg;\n         };\n \n+      // set void\n+      template<typename _Res>\n+\tstruct _Setter<_Res, void>\n+\t{\n+\t  static_assert(is_void<_Res>::value, \"Only used for promise<void>\");\n+\n+\t  typename promise<_Res>::_Ptr_type operator()() const\n+\t  { return std::move(_M_promise->_M_storage); }\n+\n+\t  promise<_Res>*    _M_promise;\n+\t};\n+\n       struct __exception_ptr_tag { };\n \n       // set exceptions\n@@ -503,7 +513,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // Used by std::promise to store an exception as the result.\n           typename promise<_Res>::_Ptr_type operator()() const\n           {\n-            _State_baseV2::_S_check(_M_promise->_M_future);\n             _M_promise->_M_storage->_M_error = *_M_ex;\n             return std::move(_M_promise->_M_storage);\n           }\n@@ -516,16 +525,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         static _Setter<_Res, _Arg&&>\n         __setter(promise<_Res>* __prom, _Arg&& __arg)\n         {\n+\t  _S_check(__prom->_M_future);\n           return _Setter<_Res, _Arg&&>{ __prom, std::__addressof(__arg) };\n         }\n \n       template<typename _Res>\n         static _Setter<_Res, __exception_ptr_tag>\n         __setter(exception_ptr& __ex, promise<_Res>* __prom)\n         {\n+\t  _S_check(__prom->_M_future);\n           return _Setter<_Res, __exception_ptr_tag>{ __prom, &__ex };\n         }\n \n+      template<typename _Res>\n+\tstatic _Setter<_Res, void>\n+\t__setter(promise<_Res>* __prom)\n+\t{\n+\t  _S_check(__prom->_M_future);\n+\t  return _Setter<_Res, void>{ __prom };\n+\t}\n+\n       template<typename _Tp>\n         static void\n         _S_check(const shared_ptr<_Tp>& __p)\n@@ -1027,6 +1046,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef __future_base::_Result<_Res>\t_Res_type;\n       typedef __future_base::_Ptr<_Res_type>\t_Ptr_type;\n       template<typename, typename> friend class _State::_Setter;\n+      friend _State;\n \n       shared_ptr<_State>                        _M_future;\n       _Ptr_type                                 _M_storage;\n@@ -1137,6 +1157,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef __future_base::_Result<_Res&>\t_Res_type;\n       typedef __future_base::_Ptr<_Res_type> \t_Ptr_type;\n       template<typename, typename> friend class _State::_Setter;\n+      friend _State;\n \n       shared_ptr<_State>                        _M_future;\n       _Ptr_type                                 _M_storage;\n@@ -1226,6 +1247,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef __future_base::_Result<void>\t_Res_type;\n       typedef __future_base::_Ptr<_Res_type> \t_Ptr_type;\n       template<typename, typename> friend class _State::_Setter;\n+      friend _State;\n \n       shared_ptr<_State>                        _M_future;\n       _Ptr_type                                 _M_storage;\n@@ -1286,14 +1308,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return future<void>(_M_future); }\n \n       // Setting the result\n-      void set_value();\n+      void\n+      set_value()\n+      { _M_future->_M_set_result(_State::__setter(this)); }\n \n       void\n       set_exception(exception_ptr __p)\n       { _M_future->_M_set_result(_State::__setter(__p, this)); }\n \n       void\n-      set_value_at_thread_exit();\n+      set_value_at_thread_exit()\n+      { _M_future->_M_set_delayed_result(_State::__setter(this), _M_future); }\n \n       void\n       set_exception_at_thread_exit(exception_ptr __p)\n@@ -1303,30 +1328,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-  // set void\n-  template<>\n-    struct __future_base::_State_base::_Setter<void, void>\n-    {\n-      promise<void>::_Ptr_type operator()() const\n-      {\n-        _State_base::_S_check(_M_promise->_M_future);\n-        return std::move(_M_promise->_M_storage);\n-      }\n-\n-      promise<void>*    _M_promise;\n-    };\n-\n-  inline void\n-  promise<void>::set_value()\n-  { _M_future->_M_set_result(_State::_Setter<void, void>{ this }); }\n-\n-  inline void\n-  promise<void>::set_value_at_thread_exit()\n-  {\n-    _M_future->_M_set_delayed_result(_State::_Setter<void, void>{this},\n-\t\t\t\t     _M_future);\n-  }\n-\n   template<typename _Ptr_type, typename _Fn, typename _Res>\n     struct __future_base::_Task_setter\n     {"}, {"sha": "9429a9958d28332d3227b06972fe44a7152d3e12", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fat_thread_exit2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fat_thread_exit2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fat_thread_exit2.cc?ref=946ecd6ab2e0303070800f527f629f1e148a1bb3", "patch": "@@ -0,0 +1,167 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-rtems* *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* powerpc-ibm-aix* } }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Test set_value_at_thread_exit error conditions\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::promise<int> p1;\n+  p1.set_value(1);\n+  try\n+  {\n+    p1.set_value_at_thread_exit(2);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n+  }\n+  try\n+  {\n+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n+  }\n+\n+  std::promise<int> p2(std::move(p1));\n+  try\n+  {\n+    p1.set_value_at_thread_exit(2);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::no_state );\n+  }\n+  try\n+  {\n+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::no_state );\n+  }\n+}\n+\n+void test02()\n+{\n+  std::promise<int&> p1;\n+  int i = 1;\n+  p1.set_value(i);\n+  try\n+  {\n+    p1.set_value_at_thread_exit(i);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n+  }\n+  try\n+  {\n+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n+  }\n+\n+  std::promise<int&> p2(std::move(p1));\n+  try\n+  {\n+    int i = 0;\n+    p1.set_value_at_thread_exit(i);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::no_state );\n+  }\n+  try\n+  {\n+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::no_state );\n+  }\n+}\n+\n+void test03()\n+{\n+  std::promise<void> p1;\n+  int i = 0;\n+  p1.set_value();\n+  try {\n+    p1.set_value_at_thread_exit();\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n+  }\n+  try\n+  {\n+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n+  }\n+\n+  std::promise<void> p2(std::move(p1));\n+  try {\n+    p1.set_value_at_thread_exit();\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::no_state );\n+  }\n+  try\n+  {\n+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY( e.code() == std::future_errc::no_state );\n+  }\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "4646e381a2fb3e7151027fe70f5e2231332562b1", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_exception.cc", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception.cc?ref=946ecd6ab2e0303070800f527f629f1e148a1bb3", "patch": "@@ -21,6 +21,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+// Test that promise::set_exception stores an exception.\n \n #include <future>\n #include <testsuite_hooks.h>\n@@ -48,8 +49,56 @@ void test01()\n   VERIFY( !f1.valid() );\n }\n \n+void test02()\n+{\n+  bool test = false;\n+\n+  std::promise<int&> p1;\n+  std::future<int&> f1 = p1.get_future();\n+\n+  VERIFY( f1.valid() );\n+\n+  p1.set_exception(std::make_exception_ptr(0));\n+\n+  try\n+  {\n+    f1.get();\n+  }\n+  catch (int)\n+  {\n+    test = true;\n+  }\n+  VERIFY( test );\n+  VERIFY( !f1.valid() );\n+}\n+\n+void test03()\n+{\n+  bool test = false;\n+\n+  std::promise<void> p1;\n+  std::future<void> f1 = p1.get_future();\n+\n+  VERIFY( f1.valid() );\n+\n+  p1.set_exception(std::make_exception_ptr(0));\n+\n+  try\n+  {\n+    f1.get();\n+  }\n+  catch (int)\n+  {\n+    test = true;\n+  }\n+  VERIFY( test );\n+  VERIFY( !f1.valid() );\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n+  test03();\n   return 0;\n }"}, {"sha": "dc2c4a88a9c66170016f6c441036ac75e870da56", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_exception2.cc", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception2.cc?ref=946ecd6ab2e0303070800f527f629f1e148a1bb3", "patch": "@@ -21,10 +21,13 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+// Test that promise::set_exception throws when required.\n \n #include <future>\n #include <testsuite_hooks.h>\n \n+// Check for promise_already_satisfied error conditions.\n+\n void test01()\n {\n   bool test = false;\n@@ -83,9 +86,187 @@ void test02()\n   VERIFY( test );\n }\n \n+void test03()\n+{\n+  bool test = false;\n+\n+  std::promise<int&> p1;\n+  std::future<int&> f1 = p1.get_future();\n+\n+  p1.set_exception(std::make_exception_ptr(0));\n+\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(1));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  try\n+  {\n+    f1.get();\n+    test = false;\n+  }\n+  catch(int i)\n+  {\n+    VERIFY( i == 0 );\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+void test04()\n+{\n+  bool test = false;\n+\n+  std::promise<int&> p1;\n+  std::future<int&> f1 = p1.get_future();\n+\n+  int i = 2;\n+  p1.set_value(i);\n+\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(0));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+void test05()\n+{\n+  bool test = false;\n+\n+  std::promise<void> p1;\n+  std::future<void> f1 = p1.get_future();\n+\n+  p1.set_exception(std::make_exception_ptr(0));\n+\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(1));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  try\n+  {\n+    f1.get();\n+    test = false;\n+  }\n+  catch(int i)\n+  {\n+    VERIFY( i == 0 );\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+void test06()\n+{\n+  bool test = false;\n+\n+  std::promise<void> p1;\n+  std::future<void> f1 = p1.get_future();\n+\n+  p1.set_value();\n+\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(0));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+// Check for no_state error condition (PR libstdc++/80316)\n+\n+void test07()\n+{\n+  using namespace std;\n+\n+  promise<int> p1;\n+  promise<int> p2(std::move(p1));\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(1));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n+  }\n+}\n+\n+void test08()\n+{\n+  using namespace std;\n+\n+  promise<int&> p1;\n+  promise<int&> p2(std::move(p1));\n+  try\n+  {\n+    int i = 0;\n+    p1.set_exception(std::make_exception_ptr(1));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n+  }\n+}\n+\n+void test09()\n+{\n+  using namespace std;\n+\n+  promise<void> p1;\n+  promise<void> p2(std::move(p1));\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(1));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n+  }\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n   return 0;\n }"}, {"sha": "33c8ed9ede4599adf320ef5b3fd2ac710d4cba2b", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_value2.cc", "status": "modified", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946ecd6ab2e0303070800f527f629f1e148a1bb3/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value2.cc?ref=946ecd6ab2e0303070800f527f629f1e148a1bb3", "patch": "@@ -21,10 +21,13 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+// Test that promise::set_value throws when required.\n \n #include <future>\n #include <testsuite_hooks.h>\n \n+// Check for promise_already_satisfied error conditions.\n+\n void test01()\n {\n   bool test = false;\n@@ -79,9 +82,298 @@ void test02()\n   VERIFY( test );\n }\n \n+void test03()\n+{\n+  bool test = false;\n+\n+  std::promise<int> p1;\n+  std::future<int> f1 = p1.get_future();\n+\n+  p1.set_exception(std::make_exception_ptr(4));\n+\n+  try\n+  {\n+    p1.set_value(3);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  test = false;\n+  try\n+  {\n+    f1.get();\n+    VERIFY( false );\n+  }\n+  catch (int e)\n+  {\n+    VERIFY(e == 4 );\n+    test = true;\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+void test04()\n+{\n+  bool test = false;\n+\n+  std::promise<int&> p1;\n+  std::future<int&> f1 = p1.get_future();\n+\n+  int i = 1;\n+  p1.set_value(i);\n+\n+  try\n+  {\n+    p1.set_value(i);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  VERIFY( f1.get() == 1 );\n+  VERIFY( test );\n+}\n+\n+void test05()\n+{\n+  bool test = false;\n+\n+  std::promise<int&> p1;\n+  std::future<int&> f1 = p1.get_future();\n+\n+  int i = 3;\n+  p1.set_value(i);\n+\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(4));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  VERIFY( f1.get() == 3 );\n+  VERIFY( test );\n+}\n+\n+void test06()\n+{\n+  bool test = false;\n+\n+  std::promise<int&> p1;\n+  std::future<int&> f1 = p1.get_future();\n+\n+  p1.set_exception(std::make_exception_ptr(4));\n+\n+  try\n+  {\n+    int i = 3;\n+    p1.set_value(i);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  test = false;\n+  try\n+  {\n+    f1.get();\n+    VERIFY( false );\n+  }\n+  catch (int e)\n+  {\n+    VERIFY(e == 4 );\n+    test = true;\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+void test07()\n+{\n+  bool test = false;\n+\n+  std::promise<void> p1;\n+  std::future<void> f1 = p1.get_future();\n+\n+  p1.set_value();\n+\n+  try\n+  {\n+    p1.set_value();\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  f1.get();\n+  VERIFY( test );\n+}\n+\n+void test08()\n+{\n+  bool test = false;\n+\n+  std::promise<void> p1;\n+  std::future<void> f1 = p1.get_future();\n+\n+  p1.set_value();\n+\n+  try\n+  {\n+    p1.set_exception(std::make_exception_ptr(4));\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  f1.get();\n+  VERIFY( test );\n+}\n+\n+void test09()\n+{\n+  bool test = false;\n+\n+  std::promise<void> p1;\n+  std::future<void> f1 = p1.get_future();\n+\n+  p1.set_exception(std::make_exception_ptr(4));\n+\n+  try\n+  {\n+    p1.set_value();\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() ==\n+        std::make_error_code(std::future_errc::promise_already_satisfied));\n+    test = true;\n+  }\n+\n+  std::chrono::milliseconds delay(1);\n+  VERIFY( f1.wait_for(delay) == std::future_status::ready );\n+  test = false;\n+  try\n+  {\n+    f1.get();\n+    VERIFY( false );\n+  }\n+  catch (int e)\n+  {\n+    VERIFY(e == 4 );\n+    test = true;\n+  }\n+\n+  VERIFY( test );\n+}\n+\n+// Check for no_state error condition (PR libstdc++/80316)\n+\n+void test10()\n+{\n+  using namespace std;\n+\n+  promise<int> p1;\n+  promise<int> p2(std::move(p1));\n+  try\n+  {\n+    p1.set_value(1);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n+  }\n+}\n+\n+void test11()\n+{\n+  using namespace std;\n+\n+  promise<int&> p1;\n+  promise<int&> p2(std::move(p1));\n+  try\n+  {\n+    int i = 0;\n+    p1.set_value(i);\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n+  }\n+}\n+\n+void test12()\n+{\n+  using namespace std;\n+\n+  promise<void> p1;\n+  promise<void> p2(std::move(p1));\n+  try\n+  {\n+    p1.set_value();\n+    VERIFY( false );\n+  }\n+  catch (std::future_error& e)\n+  {\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n+  }\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n+  test10();\n+  test11();\n+  test12();\n   return 0;\n }"}]}