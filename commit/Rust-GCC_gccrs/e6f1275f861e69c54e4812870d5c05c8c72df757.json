{"sha": "e6f1275f861e69c54e4812870d5c05c8c72df757", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmMTI3NWY4NjFlNjljNTRlNDgxMjg3MGQ1YzA1YzhjNzJkZjc1Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-20T10:44:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-20T10:44:06Z"}, "message": "pt.c (complete_template_args): Rewrite.\n\n\t* pt.c (complete_template_args): Rewrite.\n\t(tsubst, FUNCTION_DECL): Use it.\n\t* semantics.c (finish_asm_stmt): Fix combine strings. Call\n\tc_expand_asm_operands () if output_operands, input_operands or\n\tclobbers is not NULL_TREE.\n\t* pt.c (complete_template_args): New function.\n\t(get_bindings): Deal with specializations of function templates\n\twith return type containing parameters from outer class\n\ttemplates.\n\t(tsubst, TEMPLATE_TEMPLATE_PARM): When reducing parameter level,\n\tsubstitute arguments and compose a new type.\n\nFrom-SVN: r18724", "tree": {"sha": "ecbafe902e4da99957d7fb9189bf75722c9b4995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecbafe902e4da99957d7fb9189bf75722c9b4995"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6f1275f861e69c54e4812870d5c05c8c72df757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f1275f861e69c54e4812870d5c05c8c72df757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f1275f861e69c54e4812870d5c05c8c72df757", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f1275f861e69c54e4812870d5c05c8c72df757/comments", "author": null, "committer": null, "parents": [{"sha": "7aa74e4c2f4ca8b4a819099127b6263b4e0257c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aa74e4c2f4ca8b4a819099127b6263b4e0257c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aa74e4c2f4ca8b4a819099127b6263b4e0257c7"}], "stats": {"total": 159, "additions": 140, "deletions": 19}, "files": [{"sha": "6c7d567addde5068a91594c04e3114ccf38d626e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f1275f861e69c54e4812870d5c05c8c72df757/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f1275f861e69c54e4812870d5c05c8c72df757/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6f1275f861e69c54e4812870d5c05c8c72df757", "patch": "@@ -1,3 +1,23 @@\n+Fri Mar 20 10:42:07 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (complete_template_args): Rewrite.\n+\t(tsubst, FUNCTION_DECL): Use it.\n+\n+Fri Mar 20 08:12:43 1998  H.J. Lu  (hjl@gnu.org)\n+\n+\t* semantics.c (finish_asm_stmt): Fix combine strings. Call\n+\tc_expand_asm_operands () if output_operands, input_operands or\n+\tclobbers is not NULL_TREE.\n+\n+Fri Mar 20 00:10:19 1998  Kriang Lerdsuwanakij  <lerdsuwa@scf.usc.edu>\n+\n+\t* pt.c (complete_template_args): New function.\n+\t(get_bindings): Deal with specializations of function templates\n+\twith return type containing parameters from outer class \n+\ttemplates.\n+\t(tsubst, TEMPLATE_TEMPLATE_PARM): When reducing parameter level,\n+\tsubstitute arguments and compose a new type.\n+\n Thu Mar 19 19:01:48 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* pt.c (tsubst): Clear DECL_PENDING_INLINE_INFO for new"}, {"sha": "d372e11e3a1ffa48965296fd09da9279fbe0fc47", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 117, "deletions": 17, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f1275f861e69c54e4812870d5c05c8c72df757/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f1275f861e69c54e4812870d5c05c8c72df757/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e6f1275f861e69c54e4812870d5c05c8c72df757", "patch": "@@ -81,6 +81,7 @@ static tree get_class_bindings PROTO((tree, tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n+static tree complete_template_args PROTO((tree, tree, int));\n static int  type_unification_real PROTO((tree, tree *, tree, tree,\n \t\t\t\t\t int, int, int));\n static void note_template_header PROTO((int));\n@@ -340,6 +341,103 @@ is_member_template (t)\n   return 0;\n }\n \n+/* Return a new template argument vector which contains all of ARGS\n+   for all outer templates TYPE is contained in, but has as its \n+   innermost set of arguments the EXTRA_ARGS.  If UNBOUND_ONLY, we\n+   are only interested in unbound template arguments, not arguments from\n+   enclosing templates that have been instantiated already.  */\n+\n+static tree\n+complete_template_args (tmpl, extra_args, unbound_only)\n+     tree tmpl, extra_args;\n+     int unbound_only;\n+{\n+  /* depth is the number of levels of enclosing args we're adding.  */\n+  int depth, i;\n+  tree args, new_args, spec_args = NULL_TREE;\n+  \n+  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+  my_friendly_assert (TREE_CODE (extra_args) == TREE_VEC, 0);\n+\n+  if (DECL_TEMPLATE_INFO (tmpl) && !unbound_only)\n+    {\n+      /* A specialization of a member template of a template class shows up\n+\t as a TEMPLATE_DECL with DECL_TEMPLATE_SPECIALIZATION set.\n+\t DECL_TI_ARGS is the specialization args, and DECL_TI_TEMPLATE\n+\t is the template being specialized.  */\n+      if (DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+\t{\n+\t  spec_args = DECL_TI_ARGS (tmpl);\n+\t  tmpl = DECL_TI_TEMPLATE (tmpl);\n+\t}\n+\n+      if (DECL_TEMPLATE_INFO (tmpl))\n+\t{\n+\t  /* A partial instantiation of a member template shows up as a\n+\t     TEMPLATE_DECL with DECL_TEMPLATE_INFO.  DECL_TI_ARGS is\n+\t     all the bound template arguments.  */\n+\t  args = DECL_TI_ARGS (tmpl);\n+\t  if (TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)\n+\t    depth = 1;\n+\t  else\n+\t    depth = TREE_VEC_LENGTH (args);\n+\t}\n+      else\n+\t/* If we are a specialization, we might have no previously bound\n+\t   template args.  */\n+\tdepth = 0;\n+\n+      new_args = make_tree_vec (depth + 1 + (!!spec_args));\n+\n+      if (depth == 1)\n+\tTREE_VEC_ELT (new_args, 0) = args;\n+      else\n+\tfor (i = 0; i < depth; ++i)\n+\t  TREE_VEC_ELT (new_args, i) = TREE_VEC_ELT (args, i);\n+    }\n+  else\n+    {\n+      tree type;\n+      int skip;\n+\n+      /* For unbound args, we have to do more work.  We are getting bindings\n+\t for the innermost args from extra_args, so we start from our\n+\t context and work out until we've seen all the args.  We need to\n+\t do it this way to handle partial specialization.  */\n+\n+      depth = list_length (DECL_TEMPLATE_PARMS (tmpl)) - 1;\n+      if (depth == 0)\n+\treturn extra_args;\n+\n+      new_args = make_tree_vec (depth + 1);\n+\n+      if (! is_member_template (tmpl))\n+\t/* If this isn't a member template, extra_args is for the innermost\n+\t   template class, so skip over it.  */\n+\tskip = 1;\n+\n+      type = DECL_REAL_CONTEXT (tmpl);\n+      for (i = depth; i; type = TYPE_CONTEXT (type))\n+\tif (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type)))\n+\t  {\n+\t    if (skip)\n+\t      skip = 0;\n+\t    else\n+\t      {\n+\t\t--i;\n+\t\tTREE_VEC_ELT (new_args, i) = CLASSTYPE_TI_ARGS (type);\n+\t      }\n+\t  }\n+    }\n+\n+  TREE_VEC_ELT (new_args, depth) = extra_args;\n+\n+  if (spec_args)\n+    TREE_VEC_ELT (new_args, depth + 1) = spec_args;\n+\n+  return new_args;\n+}\n+\n /* Return a new template argument vector which contains all of ARGS,\n    but has as its innermost set of arguments the EXTRA_ARGS.  */\n \n@@ -3591,7 +3689,20 @@ tsubst (t, args, in_decl)\n \t  {\n \t  case TEMPLATE_TYPE_PARM:\n \t  case TEMPLATE_TEMPLATE_PARM:\n-\t    r = copy_node (t);\n+\n+\t    if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n+\t\t&& CLASSTYPE_TEMPLATE_INFO (t))\n+\t      {\n+\t\ttree argvec = tsubst (CLASSTYPE_TI_ARGS (t),\n+\t\t\t\t      args, in_decl);\n+\t\tr = lookup_template_class (TYPE_NAME (t), argvec, in_decl, \n+\t\t\t\t\t   DECL_CONTEXT (TYPE_NAME (t)));\n+\t\tr = cp_build_type_variant (r, TYPE_READONLY (t),\n+\t\t\t\t\t   TYPE_VOLATILE (t));\n+\t      }\n+\t    else\n+\t      r = copy_node (t);\n+\n \t    TEMPLATE_TYPE_PARM_INDEX (r)\n \t      = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n \t\t\t\t\t    r, levels);\n@@ -3804,21 +3915,8 @@ tsubst (t, args, in_decl)\n \t    /* Start by getting the innermost args.  */\n \t    argvec = tsubst (DECL_TI_ARGS (t), args, in_decl);\n \n-\t    /* If tmpl is an instantiation of a member template, tack on\n-\t       the args for the enclosing class.  NOTE: this will change\n-\t       for member class templates.  The generalized procedure\n-\t       is to grab the outer args, then tack on the current args,\n-\t       then any specialized args.  */\n-\t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n-\t      {\n-\t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl))\n-\t\t  argvec = add_to_template_args (DECL_TI_ARGS (tmpl), argvec);\n-\t\telse\n-\t\t  /* In this case, we are instantiating a\n-\t\t     specialization.  The innermost template args are\n-\t\t     already given by the specialization.  */\n-\t\t  argvec = add_to_template_args (argvec, DECL_TI_ARGS (tmpl));\n-\t      }\n+\t    if (DECL_TEMPLATE_INFO (tmpl))\n+\t      argvec = complete_template_args (tmpl, argvec, 0);\n \n \t    /* Do we already have this instantiation?  */\n \t    spec = retrieve_specialization (tmpl, argvec);\n@@ -5701,7 +5799,9 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n   if (check_rettype)\n     {\n       /* Check to see that the resulting return type is also OK.  */\n-      tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)), targs, NULL_TREE);\n+      tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)),\n+\t\t       complete_template_args (fn, targs, 1),\n+\t\t       NULL_TREE);\n \n       if (!comptypes (t, TREE_TYPE (TREE_TYPE (decl)), 1))\n \treturn NULL_TREE;"}, {"sha": "79f503863141b4802e346b5ad03996381ed4ea64", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f1275f861e69c54e4812870d5c05c8c72df757/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f1275f861e69c54e4812870d5c05c8c72df757/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e6f1275f861e69c54e4812870d5c05c8c72df757", "patch": "@@ -709,7 +709,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n      tree clobbers;\n {\n   if (TREE_CHAIN (string))\n-    combine_strings (string);\n+    string = combine_strings (string);\n \n   if (processing_template_decl)\n     {\n@@ -721,7 +721,8 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n   else\n     {\n       emit_line_note (input_filename, lineno);\n-      if (output_operands != NULL_TREE)\n+      if (output_operands != NULL_TREE || input_operands != NULL_TREE\n+\t  || clobbers != NULL_TREE)\n \t{\n \t  if (cv_qualifier != NULL_TREE\n \t      && cv_qualifier != ridpointers[(int) RID_VOLATILE])"}]}