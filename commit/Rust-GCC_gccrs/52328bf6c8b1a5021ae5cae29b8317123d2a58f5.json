{"sha": "52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIzMjhiZjZjOGIxYTUwMjFhZTVjYWUyOWI4MzE3MTIzZDJhNThmNQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-10-27T17:45:21Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-10-27T17:45:21Z"}, "message": "re PR tree-optimization/17133 (wrong code with -ftree-lim)\n\n2004-10-27  Daniel Berlin <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/17133\n\n\t* tree-cfg.c (rewrite_to_new_ssa_names_bb): Also rewrite must\n\tdef kill operand.\n\n\t* tree-flow-inline.h: V_MUST_DEF_OP became V_MUST_DEF_RESULT.\n\t(get_v_must_def_result_ptr): Modify for new structure of\n\tv_must_defs array.\n\t(get_v_must_def_kill_ptr): New.\n\t(op_iter_next_use): Add support for the kill that occurs in V_MUST_DEFs.\n\t(op_iter_next_tree): Ditto. Also V_MAY_DEF_OP became V_MAY_DEF_RESULT.\n\t(op_iter_next_def): V_MAY_DEF_OP became V_MAY_DEF_RESULT.\n\t(op_iter_init): Initialize new mustu members.\n\t(op_iter_next_mustdef): New function.\n\t(op_iter_init_mustdef): Ditto.\n\n\t* tree-flow.h (rewrite_def_def_chains): New function.\n\n\t* tree-into-ssa.c (mark_def_sites): Handle mustdefkill operands.\n\t(ssa_mark_def_sites): Ditto.\n\t(rewrite_stmt): Ditto.\n\t(ssa_rewrite_stmt): Ditto.\n\t(rewrite_blocks): Factor out from rewrite_into_ssa.\n\t(mark_def_block_sites): Ditto.\n\t(rewrite_def_def_chains): New function, just rewrites def-def\n\tchains without phi node insertion.\n\n\t* tree-pass.h (TODO_fix_def_def_chains): New todo flag.\n\n\t* tree-optimize.c (execute_todo): Handle TODO_fix_def_def_chains.\n\n\t* tree-pretty-print.c (dump_vops): Print out MUST_DEF's so that\n\tthey include the rhs now.\n\n\t* tree-ssa-ccp.c (visit_assignment): V_MUST_DEF_OP became\n\tV_MUST_DEF_RESULT.\n\n\t* tree-ssa-dce.c (mark_operand_necessary): Add phionly argument.\n\tUpdate callers.\n\t(mark_really_necessary_kill_operand_phis): New function.\n\t(perform_tree_ssa_dce): Call it.\n\t(pass_dce): Add TODO_fix_def_def_chains.\n\t(pass_cd_dce): Ditto.\n\n\t* tree-ssa-loop-im.c (determine_max_movement): Look at kills as\n\twell.\n\t(rewrite_mem_refs): Ditto.\n\n\t* tree-ssa-loop-manip.c (find_uses_to_rename_stmt): Look at kills\n\tas well.\n\n\t* tree-ssa-operands.c (allocate_v_may_def_optype):\n\tv_may_def_operand_type_t became v_def_use_operand_type_t.\n\t(allocate_v_must_def_optype) Ditto.\n\t(finalize_ssa_v_must_defs): Update for new operand type, as well\n\tas setting the use portion as well.\n\t(copy_virtual_operands): Copy the kill operand as well.\n\t(create_ssa_artficial_load_stmt): V_MUST_DEF_OP became\n\tV_MUST_DEF_RESULT.\n\n\t* tree-ssa-operands.h (v_may_def_operand_type): Renamed to\n\tv_def_use_operand_type.\n\t(v_must_def_optype_d): Use v_def_use_operand_type.\n\t(V_MUST_DEF_OP_*): Renamed to V_MUST_DEF_RESULT_*\n\t(V_MUST_DEF_KILL_*): New macros.\n\t(struct ssa_operand_iterator_d): Add num_v_mustu and v_mustu_i\n\tmembers.\n\tRename existing must_i and num_v_must members to mustd_i and\n\tnum_v_mustd.\n\t(SSA_OP_VMUSTDEFKILL): New flag.\n\t(SSA_OP_VIRTUAL_KILLS): New flag.\n\t(SSA_OP_ALL_OPERANDS): Add in SSA_OP_ALL_KILLS.\n\t(SSA_OP_ALL_KILLS): New flag.\n\t(FOR_EACH_SSA_MUSTDEF_OPERAND): New macro.\n\n\t* tree-ssa.c (verify_ssa): Verify virtual kills as well.\n\n\t* tree-vectorizer.c (vect_create_data_ref_ptr): V_MUST_DEF_OP\n\tbecame V_MUST_DEF_RESULT.\n\t(rename_variables_in_bb): Rename kill pointer as well.\n\n\t* tree-dfa.c (compute_immediate_uses_for_stmt): Add kills into the\n\timmediate uses.\n\nFrom-SVN: r89695", "tree": {"sha": "36b6b5291cd04acd1807e64b366402dc565251b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36b6b5291cd04acd1807e64b366402dc565251b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47a3c2dcc616e8eace211fac58278055b0ebb3ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a3c2dcc616e8eace211fac58278055b0ebb3ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a3c2dcc616e8eace211fac58278055b0ebb3ba"}], "stats": {"total": 627, "additions": 465, "deletions": 162}, "files": [{"sha": "75423d85bbac95b451885ca54540d3c56dd2c308", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -1,3 +1,89 @@\n+2004-10-27  Daniel Berlin <dberlin@dberlin.org>\n+\t\n+\tFix PR tree-optimization/17133\n+\t\n+\t* tree-cfg.c (rewrite_to_new_ssa_names_bb): Also rewrite must\n+\tdef kill operand.\n+\n+\t* tree-flow-inline.h: V_MUST_DEF_OP became V_MUST_DEF_RESULT.\n+\t(get_v_must_def_result_ptr): Modify for new structure of\n+\tv_must_defs array.\n+\t(get_v_must_def_kill_ptr): New.\n+\t(op_iter_next_use): Add support for the kill that occurs in V_MUST_DEFs.\n+\t(op_iter_next_tree): Ditto. Also V_MAY_DEF_OP became V_MAY_DEF_RESULT.\n+\t(op_iter_next_def): V_MAY_DEF_OP became V_MAY_DEF_RESULT.\n+\t(op_iter_init): Initialize new mustu members.\n+\t(op_iter_next_mustdef): New function.\n+\t(op_iter_init_mustdef): Ditto.\n+\n+\t* tree-flow.h (rewrite_def_def_chains): New function.\n+\n+\t* tree-into-ssa.c (mark_def_sites): Handle mustdefkill operands.\n+\t(ssa_mark_def_sites): Ditto.\n+\t(rewrite_stmt): Ditto.\n+\t(ssa_rewrite_stmt): Ditto.\n+\t(rewrite_blocks): Factor out from rewrite_into_ssa.\n+\t(mark_def_block_sites): Ditto.\n+\t(rewrite_def_def_chains): New function, just rewrites def-def\n+\tchains without phi node insertion.\n+\n+\t* tree-pass.h (TODO_fix_def_def_chains): New todo flag.\n+\n+\t* tree-optimize.c (execute_todo): Handle TODO_fix_def_def_chains.\t\n+\n+\t* tree-pretty-print.c (dump_vops): Print out MUST_DEF's so that\n+\tthey include the rhs now.\n+\n+\t* tree-ssa-ccp.c (visit_assignment): V_MUST_DEF_OP became\n+\tV_MUST_DEF_RESULT. \n+\n+\t* tree-ssa-dce.c (mark_operand_necessary): Add phionly argument.\n+\tUpdate callers.\n+\t(mark_really_necessary_kill_operand_phis): New function.\n+\t(perform_tree_ssa_dce): Call it.\n+\t(pass_dce): Add TODO_fix_def_def_chains.\n+\t(pass_cd_dce): Ditto.\n+\n+\t* tree-ssa-loop-im.c (determine_max_movement): Look at kills as\n+\twell.\n+\t(rewrite_mem_refs): Ditto.\n+\n+\t* tree-ssa-loop-manip.c (find_uses_to_rename_stmt): Look at kills\n+\tas well.\n+\n+\t* tree-ssa-operands.c (allocate_v_may_def_optype):\n+\tv_may_def_operand_type_t became v_def_use_operand_type_t.\n+\t(allocate_v_must_def_optype) Ditto.\n+\t(finalize_ssa_v_must_defs): Update for new operand type, as well\n+\tas setting the use portion as well.\n+\t(copy_virtual_operands): Copy the kill operand as well.\n+\t(create_ssa_artficial_load_stmt): V_MUST_DEF_OP became\n+\tV_MUST_DEF_RESULT. \n+\n+\t* tree-ssa-operands.h (v_may_def_operand_type): Renamed to\n+\tv_def_use_operand_type. \n+\t(v_must_def_optype_d): Use v_def_use_operand_type.\n+\t(V_MUST_DEF_OP_*): Renamed to V_MUST_DEF_RESULT_*\n+\t(V_MUST_DEF_KILL_*): New macros.\n+\t(struct ssa_operand_iterator_d): Add num_v_mustu and v_mustu_i\n+\tmembers.\n+\tRename existing must_i and num_v_must members to mustd_i and\n+\tnum_v_mustd. \n+\t(SSA_OP_VMUSTDEFKILL): New flag.\n+\t(SSA_OP_VIRTUAL_KILLS): New flag.\n+\t(SSA_OP_ALL_OPERANDS): Add in SSA_OP_ALL_KILLS.\n+\t(SSA_OP_ALL_KILLS): New flag.\n+\t(FOR_EACH_SSA_MUSTDEF_OPERAND): New macro.\n+\n+\t* tree-ssa.c (verify_ssa): Verify virtual kills as well.\n+\n+\t* tree-vectorizer.c (vect_create_data_ref_ptr): V_MUST_DEF_OP\n+\tbecame V_MUST_DEF_RESULT.\n+\t(rename_variables_in_bb): Rename kill pointer as well.\n+\n+\t* tree-dfa.c (compute_immediate_uses_for_stmt): Add kills into the\n+\timmediate uses.\n+\n 2004-10-27  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* dbxout.c (dbxout_source_line): Move declaration of begin_label to"}, {"sha": "a9631249c5e7aad4087d86df7ea3274cded62309", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -4542,8 +4542,12 @@ rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n \n       v_must_defs = V_MUST_DEF_OPS (ann);\n       for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\trewrite_to_new_ssa_names_def\n-\t\t(V_MUST_DEF_OP_PTR (v_must_defs, i), stmt, map);\n+\t{\n+\t  rewrite_to_new_ssa_names_def\n+\t    (V_MUST_DEF_RESULT_PTR (v_must_defs, i), stmt, map);\n+\t  rewrite_to_new_ssa_names_use\n+\t    (V_MUST_DEF_KILL_PTR (v_must_defs, i),  map);\n+\t}\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "de4e225bb9e962adc1a46c4522bc159d684bfdce", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -312,7 +312,14 @@ compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n \t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (use)))\n \t    add_immediate_use (imm_rdef_stmt, stmt);\n \t}\n-    }\n+      \n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_KILLS)\n+\t{\n+\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (use);\n+\t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (use)))\n+\t    add_immediate_use (imm_rdef_stmt, stmt);\n+\t}\n+    }  \n }\n \n "}, {"sha": "e3c955e8c2671d59b4fef0ce6f964845b4013a1d", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -267,14 +267,25 @@ get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n   return op;\n }\n \n-/* Return a def_operand_p that is the V_MUST_DEF_OP for the\n+/* Return a def_operand_p that is the V_MUST_DEF_RESULT for the\n    V_MUST_DEF at INDEX in the V_MUST_DEFS array.  */\n static inline def_operand_p\n-get_v_must_def_op_ptr (v_must_def_optype v_must_defs, unsigned int index)\n+get_v_must_def_result_ptr (v_must_def_optype v_must_defs, unsigned int index)\n {\n   def_operand_p op;\n   gcc_assert (index < v_must_defs->num_v_must_defs);\n-  op.def = &(v_must_defs->v_must_defs[index]);\n+  op.def = &(v_must_defs->v_must_defs[index].def);\n+  return op;\n+}\n+\n+/* Return a use_operand_p that is the V_MUST_DEF_KILL for the \n+   V_MUST_DEF at INDEX in the V_MUST_DEFS array.  */\n+static inline use_operand_p\n+get_v_must_def_kill_ptr (v_must_def_optype v_must_defs, unsigned int index)\n+{\n+  use_operand_p op;\n+  gcc_assert (index < v_must_defs->num_v_must_defs);\n+  op.use = &(v_must_defs->v_must_defs[index].use);\n   return op;\n }\n \n@@ -670,7 +681,12 @@ op_iter_next_use (ssa_op_iter *ptr)\n   if (ptr->v_mayu_i < ptr->num_v_mayu)\n     {\n       return V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops,\n-\t\t\t\t       (ptr->v_mayu_i)++);\n+\t\t\t       (ptr->v_mayu_i)++);\n+    }\n+  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+    {\n+      return V_MUST_DEF_KILL_PTR (ptr->ops->v_must_def_ops,\n+\t\t\t\t  (ptr->v_mustu_i)++);\n     }\n   ptr->done = true;\n   return NULL_USE_OPERAND_P;\n@@ -684,10 +700,10 @@ op_iter_next_def (ssa_op_iter *ptr)\n     {\n       return DEF_OP_PTR (ptr->ops->def_ops, (ptr->def_i)++);\n     }\n-  if (ptr->v_must_i < ptr->num_v_must)\n+  if (ptr->v_mustd_i < ptr->num_v_mustd)\n     {\n-      return V_MUST_DEF_OP_PTR (ptr->ops->v_must_def_ops, \n-\t\t\t\t\t(ptr->v_must_i)++);\n+      return V_MUST_DEF_RESULT_PTR (ptr->ops->v_must_def_ops, \n+\t\t\t\t\t(ptr->v_mustd_i)++);\n     }\n   if (ptr->v_mayd_i < ptr->num_v_mayd)\n     {\n@@ -714,14 +730,18 @@ op_iter_next_tree (ssa_op_iter *ptr)\n     {\n       return V_MAY_DEF_OP (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n     }\n+  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+    {\n+      return V_MUST_DEF_KILL (ptr->ops->v_must_def_ops, (ptr->v_mustu_i)++);\n+    }\n   if (ptr->def_i < ptr->num_def)\n     {\n       return DEF_OP (ptr->ops->def_ops, (ptr->def_i)++);\n     }\n-  if (ptr->v_must_i < ptr->num_v_must)\n+  if (ptr->v_mustd_i < ptr->num_v_mustd)\n     {\n-      return V_MUST_DEF_OP (ptr->ops->v_must_def_ops, \n-\t\t\t\t\t(ptr->v_must_i)++);\n+      return V_MUST_DEF_RESULT (ptr->ops->v_must_def_ops, \n+\t\t\t\t\t(ptr->v_mustd_i)++);\n     }\n   if (ptr->v_mayd_i < ptr->num_v_mayd)\n     {\n@@ -749,14 +769,17 @@ op_iter_init (ssa_op_iter *ptr, tree stmt, int flags)\n \t\t     ?  NUM_V_MAY_DEFS (ops->v_may_def_ops) : 0;\n   ptr->num_v_mayd = (flags & SSA_OP_VMAYDEF) \n \t\t     ?  NUM_V_MAY_DEFS (ops->v_may_def_ops) : 0;\n-  ptr->num_v_must = (flags & SSA_OP_VMUSTDEF) \n+  ptr->num_v_mustu = (flags & SSA_OP_VMUSTDEFKILL)\n+                     ? NUM_V_MUST_DEFS (ops->v_must_def_ops) : 0;\n+  ptr->num_v_mustd = (flags & SSA_OP_VMUSTDEF) \n \t\t     ? NUM_V_MUST_DEFS (ops->v_must_def_ops) : 0;\n   ptr->def_i = 0;\n   ptr->use_i = 0;\n   ptr->vuse_i = 0;\n   ptr->v_mayu_i = 0;\n   ptr->v_mayd_i = 0;\n-  ptr->v_must_i = 0;\n+  ptr->v_mustu_i = 0;\n+  ptr->v_mustd_i = 0;\n }\n \n /* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n@@ -786,6 +809,25 @@ op_iter_init_tree (ssa_op_iter *ptr, tree stmt, int flags)\n   return op_iter_next_tree (ptr);\n }\n \n+/* Get the next iterator mustdef value for PTR, returning the mustdef values in\n+   KILL and DEF.  */\n+static inline void\n+op_iter_next_mustdef (use_operand_p *kill, def_operand_p *def, ssa_op_iter *ptr)\n+{\n+  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+    {\n+      *def = V_MUST_DEF_RESULT_PTR (ptr->ops->v_must_def_ops, ptr->v_mustu_i);\n+      *kill = V_MUST_DEF_KILL_PTR (ptr->ops->v_must_def_ops, (ptr->v_mustu_i)++);\n+      return;\n+    }\n+  else\n+    {\n+      *def = NULL_DEF_OPERAND_P;\n+      *kill = NULL_USE_OPERAND_P;\n+    }\n+  ptr->done = true;\n+  return;\n+}\n /* Get the next iterator maydef value for PTR, returning the maydef values in\n    USE and DEF.  */\n static inline void\n@@ -815,4 +857,14 @@ op_iter_init_maydef (ssa_op_iter *ptr, tree stmt, use_operand_p *use,\n   op_iter_init (ptr, stmt, SSA_OP_VMAYUSE);\n   op_iter_next_maydef (use, def, ptr);\n }\n+\n+/* Initialize iterator PTR to the operands in STMT.  Return the first operands\n+   in KILL and DEF.  */\n+static inline void\n+op_iter_init_mustdef (ssa_op_iter *ptr, tree stmt, use_operand_p *kill, \n+\t\t     def_operand_p *def)\n+{\n+  op_iter_init (ptr, stmt, SSA_OP_VMUSTDEFKILL);\n+  op_iter_next_mustdef (kill, def, ptr);\n+}\n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "37cf55644e22fd05ef035c94d3d71c2b3891770e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -583,6 +583,7 @@ extern void kill_redundant_phi_nodes (void);\n /* In tree-into-ssa.c  */\n extern void rewrite_into_ssa (bool);\n extern void rewrite_ssa_into_ssa (void);\n+extern void rewrite_def_def_chains (void);\n \n void compute_global_livein (bitmap, bitmap);\n tree duplicate_ssa_name (tree, tree);"}, {"sha": "079065ea62a2f6e6725e7176eee4e8852d3eae92", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 119, "deletions": 85, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -379,13 +379,13 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n \n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n     {\n       if (prepare_use_operand_for_rename (use_p, &uid)\n \t  && !TEST_BIT (kills, uid))\n \tset_livein_block (USE_FROM_PTR (use_p), bb);\n     }\n-\t  \n+  \n   /* Note that virtual definitions are irrelevant for computing KILLS\n      because a V_MAY_DEF does not constitute a killing definition of the\n      variable.  However, the operand of a virtual definitions is a use\n@@ -438,7 +438,7 @@ ssa_mark_def_sites (struct dom_walk_data *walk_data,\n \n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     {\n       uid = SSA_NAME_VERSION (use);\n \n@@ -1077,7 +1077,7 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   gcc_assert (!ann->modified);\n \n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     rewrite_operand (use_p);\n \n   /* Step 2.  Register the statement's DEF and VDEF operands.  */\n@@ -1121,7 +1121,7 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n   gcc_assert (!ann->modified);\n \n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     {\n       if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n \tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n@@ -1382,7 +1382,105 @@ invalidate_name_tags (bitmap vars_to_rename)\n       }\n }\n \n+/* Rewrite the actual blocks, statements, and phi arguments, to be in SSA\n+   form.  ADD_PHI_ARGS is true if we should be adding arguments to phi nodes,\n+   because they may have been just inserted.  */\n+\n+static void\n+rewrite_blocks (bool add_phi_args)\n+{\n+  struct dom_walk_data walk_data;\n+\n+  /* Rewrite all the basic blocks in the program.  */\n+  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n+\n+  /* Setup callbacks for the generic dominator tree walker.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n+  walk_data.before_dom_children_after_stmts = NULL;\n+  if (add_phi_args)\n+    walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments; \n+  walk_data.after_dom_children_before_stmts =  NULL;\n+  walk_data.after_dom_children_walk_stmts =  NULL;\n+  walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n+  walk_data.global_data = NULL;\n+  walk_data.block_local_data_size = 0;\n+\n+  VARRAY_TREE_INIT (block_defs_stack, 10, \"Block DEFS Stack\");\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree rewriting each statement in\n+     each basic block.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  htab_delete (def_blocks);\n+\n+  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n+}\n+\n+/* Mark the definition site blocks for each variable, so that we know where\n+   the variable is actually live.  */\n+\n+static void \n+mark_def_site_blocks (void)\n+{\n+  size_t i;\n+  struct dom_walk_data walk_data;\n+  struct mark_def_sites_global_data mark_def_sites_global_data;\n+\n+  /* Allocate memory for the DEF_BLOCKS hash table.  */\n+  def_blocks = htab_create (VARRAY_ACTIVE_SIZE (referenced_vars),\n+\t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n+\n+  for (i = 0; i < num_referenced_vars; i++)\n+    set_current_def (referenced_var (i), NULL_TREE);\n+\n+  /* Ensure that the dominance information is OK.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n \n+  /* Setup callbacks for the generic dominator tree walker to find and\n+     mark definition sites.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts = mark_def_sites_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = mark_def_sites;\n+  walk_data.before_dom_children_after_stmts = NULL; \n+  walk_data.after_dom_children_before_stmts =  NULL;\n+  walk_data.after_dom_children_walk_stmts =  NULL;\n+  walk_data.after_dom_children_after_stmts =  NULL;\n+\n+  /* Notice that this bitmap is indexed using variable UIDs, so it must be\n+     large enough to accommodate all the variables referenced in the\n+     function, not just the ones we are renaming.  */\n+  mark_def_sites_global_data.kills = sbitmap_alloc (num_referenced_vars);\n+  walk_data.global_data = &mark_def_sites_global_data;\n+\n+  /* We do not have any local data.  */\n+  walk_data.block_local_data_size = 0;\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  /* We no longer need this bitmap, clear and free it.  */\n+  sbitmap_free (mark_def_sites_global_data.kills);\n+\n+}\n /* Main entry point into the SSA builder.  The renaming process\n    proceeds in five main phases:\n \n@@ -1395,13 +1493,11 @@ invalidate_name_tags (bitmap vars_to_rename)\n       order.\n \n    3- Find and mark all the blocks that define variables\n-      (mark_def_sites).\n+      (mark_def_site_blocks).\n \n    4- Insert PHI nodes at dominance frontiers (insert_phi_nodes).\n \n-   5- Rename all the blocks (rewrite_initialize_block,\n-      rewrite_add_phi_arguments) and statements in the program\n-      (rewrite_stmt).\n+   5- Rename all the blocks (rewrite_blocks) and statements in the program.\n \n    Steps 3 and 5 are done using the dominator tree walker\n    (walk_dominator_tree).\n@@ -1414,10 +1510,7 @@ rewrite_into_ssa (bool all)\n {\n   bitmap *dfs;\n   basic_block bb;\n-  struct dom_walk_data walk_data;\n-  struct mark_def_sites_global_data mark_def_sites_global_data;\n   bitmap old_vars_to_rename = vars_to_rename;\n-  unsigned i;\n   \n   timevar_push (TV_TREE_SSA_OTHER);\n \n@@ -1441,9 +1534,7 @@ rewrite_into_ssa (bool all)\n       remove_all_phi_nodes_for (vars_to_rename);\n     }\n \n-  /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  def_blocks = htab_create (VARRAY_ACTIVE_SIZE (referenced_vars),\n-\t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n+  mark_def_site_blocks ();\n \n   /* Initialize dominance frontier and immediate dominator bitmaps. \n      Also count the number of predecessors for each block.  Doing so\n@@ -1452,80 +1543,13 @@ rewrite_into_ssa (bool all)\n   FOR_EACH_BB (bb)\n     dfs[bb->index] = BITMAP_XMALLOC ();\n \n-  for (i = 0; i < num_referenced_vars; i++)\n-    set_current_def (referenced_var (i), NULL_TREE);\n-\n-  /* Ensure that the dominance information is OK.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   /* Compute dominance frontiers.  */\n   compute_dominance_frontiers (dfs);\n \n-  /* Setup callbacks for the generic dominator tree walker to find and\n-     mark definition sites.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = mark_def_sites_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = mark_def_sites;\n-  walk_data.before_dom_children_after_stmts = NULL; \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  NULL;\n-\n-  /* Notice that this bitmap is indexed using variable UIDs, so it must be\n-     large enough to accommodate all the variables referenced in the\n-     function, not just the ones we are renaming.  */\n-  mark_def_sites_global_data.kills = sbitmap_alloc (num_referenced_vars);\n-  walk_data.global_data = &mark_def_sites_global_data;\n-\n-  /* We do not have any local data.  */\n-  walk_data.block_local_data_size = 0;\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n-\n-  /* We no longer need this bitmap, clear and free it.  */\n-  sbitmap_free (mark_def_sites_global_data.kills);\n-\n   /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n   insert_phi_nodes (dfs, NULL);\n \n-  /* Rewrite all the basic blocks in the program.  */\n-  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n-\n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n-  walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments; \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-\n-  VARRAY_TREE_INIT (block_defs_stack, 10, \"Block DEFS Stack\");\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree rewriting each statement in\n-     each basic block.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n-\n-  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n+  rewrite_blocks (true);\n \n   /* Debugging dumps.  */\n   if (dump_file && (dump_flags & TDF_STATS))\n@@ -1539,12 +1563,22 @@ rewrite_into_ssa (bool all)\n     BITMAP_XFREE (dfs[bb->index]);\n   free (dfs);\n \n-  htab_delete (def_blocks);\n-\n   vars_to_rename = old_vars_to_rename;\n   timevar_pop (TV_TREE_SSA_OTHER);\n }\n \n+/* Rewrite the def-def chains so that they have the correct reaching\n+   definitions.  */\n+\n+void\n+rewrite_def_def_chains (void)\n+{\n+  /* Ensure that the dominance information is OK.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  mark_def_site_blocks ();\n+  rewrite_blocks (false);\n+\n+}\n /* The marked ssa names may have more than one definition;\n    add phi nodes and rewrite them to fix this.  */\n "}, {"sha": "88d18a71f4652aab5ecfd78bd253de6afab44dfc", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -420,6 +420,11 @@ execute_todo (int properties, unsigned int flags)\n       rewrite_into_ssa (false);\n       bitmap_clear (vars_to_rename);\n     }\n+  if (flags & TODO_fix_def_def_chains)\n+    {\n+      rewrite_def_def_chains ();\n+      bitmap_clear (vars_to_rename);\n+    }\n \n   if ((flags & TODO_dump_func) && dump_file)\n     {"}, {"sha": "71407665679d2cd4aa782f3c4ad5d7878f15478f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -106,6 +106,7 @@ struct dump_file_info\n #define TODO_verify_ssa\t\t(1 << 3)\n #define TODO_verify_flow\t(1 << 4)\n #define TODO_verify_stmts\t(1 << 5)\n+#define TODO_fix_def_def_chains (1 << 6)        /* rewrite def-def chains  */\n \n #define TODO_verify_all \\\n   (TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts)"}, {"sha": "3f2d4b68d9b36d4993422eaa8f19d5a9350d6baa", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -2131,9 +2131,10 @@ newline_and_indent (pretty_printer *buffer, int spc)\n static void\n dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n {\n-  tree use, def;\n+  tree use;\n   use_operand_p use_p;\n   def_operand_p def_p;\n+  use_operand_p kill_p;\n   ssa_op_iter iter;\n \n   FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n@@ -2148,10 +2149,14 @@ dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n       newline_and_indent (buffer, spc);\n     }\n \n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMUSTDEF)\n+  FOR_EACH_SSA_MUSTDEF_OPERAND (def_p, kill_p, stmt, iter)\n     {\n-      pp_string (buffer, \"#   V_MUST_DEF <\");\n-      dump_generic_node (buffer, def, spc + 2, flags, false);\n+      pp_string (buffer, \"#   \");\n+      dump_generic_node (buffer, DEF_FROM_PTR (def_p),\n+                         spc + 2, flags, false);\n+      pp_string (buffer, \" = V_MUST_DEF <\");\n+      dump_generic_node (buffer, USE_FROM_PTR (kill_p),\n+                         spc + 2, flags, false);\n       pp_string (buffer, \">;\");\n       newline_and_indent (buffer, spc);\n     }"}, {"sha": "b97424f02e26968b9bf55138433e0ea33a9b2485", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -1041,7 +1041,7 @@ visit_assignment (tree stmt, tree *output_p)\n     {\n       /* If we make it here, then stmt only has one definition:\n          a V_MUST_DEF.  */\n-      lhs = V_MUST_DEF_OP (v_must_defs, 0);\n+      lhs = V_MUST_DEF_RESULT (v_must_defs, 0);\n     }\n \n   if (TREE_CODE (rhs) == SSA_NAME)"}, {"sha": "2c688616fc889740f0bdb845a8768efe37eff9fe", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 108, "deletions": 27, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -112,7 +112,7 @@ static void find_control_dependence (struct edge_list *, int);\n static inline basic_block find_pdom (basic_block);\n \n static inline void mark_stmt_necessary (tree, bool);\n-static inline void mark_operand_necessary (tree);\n+static inline void mark_operand_necessary (tree, bool);\n \n static void mark_stmt_if_obviously_necessary (tree, bool);\n static void find_obviously_necessary_stmts (struct edge_list *);\n@@ -234,10 +234,11 @@ mark_stmt_necessary (tree stmt, bool add_to_worklist)\n     VARRAY_PUSH_TREE (worklist, stmt);\n }\n \n-/* Mark the statement defining operand OP as necessary.  */\n+/* Mark the statement defining operand OP as necessary.  PHIONLY is true\n+   if we should only mark it necessary if it is a phi node.  */\n \n static inline void\n-mark_operand_necessary (tree op)\n+mark_operand_necessary (tree op, bool phionly)\n {\n   tree stmt;\n   int ver;\n@@ -253,7 +254,8 @@ mark_operand_necessary (tree op)\n   gcc_assert (stmt);\n \n   if (NECESSARY (stmt)\n-      || IS_EMPTY_STMT (stmt))\n+      || IS_EMPTY_STMT (stmt)\n+      || (phionly && TREE_CODE (stmt) != PHI_NODE))\n     return;\n \n   NECESSARY (stmt) = 1;\n@@ -592,7 +594,7 @@ propagate_necessity (struct edge_list *el)\n             {\n \t      tree arg = PHI_ARG_DEF (i, k);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n-\t\tmark_operand_necessary (arg);\n+\t\tmark_operand_necessary (arg, false);\n \t    }\n \n \t  if (aggressive)\n@@ -624,11 +626,79 @@ propagate_necessity (struct edge_list *el)\n \t     links).  */\n \n \t  FOR_EACH_SSA_TREE_OPERAND (use, i, iter, SSA_OP_ALL_USES)\n-\t    mark_operand_necessary (use);\n+\t    mark_operand_necessary (use, false);\n \t}\n     }\n }\n+\n+\n+/* Propagate necessity around virtual phi nodes used in kill operands.\n+   The reason this isn't done during propagate_necessity is because we don't\n+   want to keep phis around that are just there for must-defs, unless we\n+   absolutely have to.  After we've rewritten the reaching definitions to be\n+   correct in the previous part of the fixup routine, we can simply propagate\n+   around the information about which of these virtual phi nodes are really\n+   used, and set the NECESSARY flag accordingly.\n+   Note that we do the minimum here to ensure that we keep alive the phis that\n+   are actually used in the corrected SSA form.  In particular, some of these\n+   phis may now have all of the same operand, and will be deleted by some\n+   other pass.  */\n+\n+static void\n+mark_really_necessary_kill_operand_phis (void)\n+{\n+  basic_block bb;\n+  int i;\n+\n+  /* Seed the worklist with the new virtual phi arguments and virtual\n+     uses */\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      tree phi;\n+      \n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  if (!is_gimple_reg (PHI_RESULT (phi)) && NECESSARY (phi))\n+\t    {\n+\t      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+\t\tmark_operand_necessary (PHI_ARG_DEF (phi, i), true);\n+\t    }\n+\t}\n+      \n+      for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t\n+\t  if (NECESSARY (stmt))\n+\t    {\n+\t      use_operand_p use_p;\n+\t      ssa_op_iter iter;\n+\t      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n+\t\t\t\t\tSSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n+\t\t{\n+\t\t  tree use = USE_FROM_PTR (use_p);\n+\t\t  mark_operand_necessary (use, true);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  \n+  /* Mark all virtual phis still in use as necessary, and all of their\n+     arguments that are phis as necessary.  */\n+  while (VARRAY_ACTIVE_SIZE (worklist) > 0)\n+    {\n+      tree use = VARRAY_TOP_TREE (worklist);\n+      VARRAY_POP (worklist);\n+      \n+      for (i = 0; i < PHI_NUM_ARGS (use); i++)\n+\tmark_operand_necessary (PHI_ARG_DEF (use, i), true);\n+    }\n+}\n+\n+\n \f\n+\n /* Eliminate unnecessary statements. Any instruction not marked as necessary\n    contributes nothing to the program, and can be deleted.  */\n \n@@ -640,7 +710,7 @@ eliminate_unnecessary_stmts (void)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEliminating unnecessary statements:\\n\");\n-\n+  \n   clear_special_calls ();\n   FOR_EACH_BB (bb)\n     {\n@@ -650,23 +720,23 @@ eliminate_unnecessary_stmts (void)\n       /* Remove dead statements.  */\n       for (i = bsi_start (bb); ! bsi_end_p (i) ; )\n \t{\n-\t  tree t = bsi_stmt (i);\n-\n-\t  stats.total++;\n-\n-\t  /* If `i' is not necessary then remove it.  */\n-\t  if (! NECESSARY (t))\n-\t    remove_dead_stmt (&i, bb);\n-\t  else\n-\t    {\n-\t      tree call = get_call_expr_in (t);\n-\t      if (call)\n-\t\tnotice_special_calls (call);\n-\t      bsi_next (&i);\n-\t    }\n+         tree t = bsi_stmt (i);\n+\n+         stats.total++;\n+\n+         /* If `i' is not necessary then remove it.  */\n+         if (! NECESSARY (t))\n+           remove_dead_stmt (&i, bb);\n+         else\n+           {\n+             tree call = get_call_expr_in (t);\n+             if (call)\n+               notice_special_calls (call);\n+             bsi_next (&i);\n+           }\n \t}\n     }\n-}\n+ }\n \f\n /* Remove dead PHI nodes from block BB.  */\n \n@@ -711,6 +781,9 @@ static void\n remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n {\n   tree t = bsi_stmt (*i);\n+  def_operand_p def_p;\n+\n+  ssa_op_iter iter;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -765,9 +838,16 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n       while (EDGE_COUNT (bb->succs) != 1)\n         remove_edge (EDGE_SUCC (bb, 1));\n     }\n-\n-  bsi_remove (i);\n-  release_defs (t);\n+  \n+  FOR_EACH_SSA_DEF_OPERAND (def_p, t, iter, \n+\t\t\t    SSA_OP_VIRTUAL_DEFS | SSA_OP_VIRTUAL_KILLS)\n+    {\n+      tree def = DEF_FROM_PTR (def_p);\n+      bitmap_set_bit (vars_to_rename,\n+\t\t      var_ann (SSA_NAME_VAR (def))->uid);\n+    }\n+  bsi_remove (i);  \n+  release_defs (t); \n }\n \f\n /* Print out removed statement statistics.  */\n@@ -875,6 +955,7 @@ perform_tree_ssa_dce (bool aggressive)\n \n   propagate_necessity (el);\n \n+  mark_really_necessary_kill_operand_phis ();\n   eliminate_unnecessary_stmts ();\n \n   if (aggressive)\n@@ -926,7 +1007,7 @@ struct tree_opt_pass pass_dce =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_ggc_collect | TODO_verify_ssa,\t/* todo_flags_finish */\n+  TODO_fix_def_def_chains |TODO_ggc_collect | TODO_verify_ssa,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -943,7 +1024,7 @@ struct tree_opt_pass pass_cd_dce =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_ggc_collect | TODO_verify_ssa | TODO_verify_flow,\n+  TODO_fix_def_def_chains | TODO_ggc_collect | TODO_verify_ssa | TODO_verify_flow,\n \t\t\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}, {"sha": "bcdd9d7c3bb6e87ce290b7c26e3103366d8adef3", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -436,7 +436,7 @@ determine_max_movement (tree stmt, bool must_preserve_exec)\n     if (!add_dependency (val, lim_data, loop, true))\n       return false;\n \n-  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_USES)\n+  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n     if (!add_dependency (val, lim_data, loop, false))\n       return false;\n \n@@ -1034,8 +1034,7 @@ rewrite_mem_refs (tree tmp_var, struct mem_ref *mem_refs)\n \n   for (; mem_refs; mem_refs = mem_refs->next)\n     {\n-      FOR_EACH_SSA_TREE_OPERAND (var, mem_refs->stmt, iter,\n-\t\t\t\t (SSA_OP_VIRTUAL_DEFS | SSA_OP_VUSE))\n+      FOR_EACH_SSA_TREE_OPERAND (var, mem_refs->stmt, iter, SSA_OP_ALL_VIRTUALS)\n \t{\n \t  var = SSA_NAME_VAR (var);\n \t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);"}, {"sha": "1f949a43041b5f11c9c33e043f5dca8d55f8d875", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -254,7 +254,7 @@ find_uses_to_rename_stmt (tree stmt, bitmap *use_blocks)\n \n   get_stmt_operands (stmt);\n \n-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n     find_uses_to_rename_use (bb, var, use_blocks);\n }\n "}, {"sha": "55cebf20c8d37ecf6c4c79f3ba3cb13cff429479", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -174,7 +174,7 @@ allocate_v_may_def_optype (unsigned num)\n   v_may_def_optype v_may_def_ops;\n   unsigned size;\n   size = sizeof (struct v_may_def_optype_d) \n-\t   + sizeof (v_may_def_operand_type_t) * (num - 1);\n+\t   + sizeof (v_def_use_operand_type_t) * (num - 1);\n   v_may_def_ops =  ggc_alloc (size);\n   v_may_def_ops->num_v_may_defs = num;\n   return v_may_def_ops;\n@@ -202,7 +202,7 @@ allocate_v_must_def_optype (unsigned num)\n {\n   v_must_def_optype v_must_def_ops;\n   unsigned size;\n-  size = sizeof (struct v_must_def_optype_d) + sizeof (tree) * (num - 1);\n+  size = sizeof (struct v_must_def_optype_d) + sizeof (v_def_use_operand_type_t) * (num - 1);\n   v_must_def_ops =  ggc_alloc (size);\n   v_must_def_ops->num_v_must_defs = num;\n   return v_must_def_ops;\n@@ -650,7 +650,7 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n       build_diff = false;\n       for (x = 0; x < num; x++)\n         {\n-\t  tree var = old_ops->v_must_defs[x];\n+\t  tree var = old_ops->v_must_defs[x].def;\n \t  if (TREE_CODE (var) == SSA_NAME)\n \t    var = SSA_NAME_VAR (var);\n \t  if (var != VARRAY_TREE (build_v_must_defs, x))\n@@ -677,17 +677,21 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n \t  /* Look for VAR in the original vector.  */\n \t  for (i = 0; i < old_num; i++)\n \t    {\n-\t      result = old_ops->v_must_defs[i];\n+\t      result = old_ops->v_must_defs[i].def;\n \t      if (TREE_CODE (result) == SSA_NAME)\n \t\tresult = SSA_NAME_VAR (result);\n \t      if (result == var)\n \t        {\n-\t\t  v_must_def_ops->v_must_defs[x] = old_ops->v_must_defs[i];\n+\t\t  v_must_def_ops->v_must_defs[x].def = old_ops->v_must_defs[i].def;\n+\t\t  v_must_def_ops->v_must_defs[x].use = old_ops->v_must_defs[i].use;\n \t\t  break;\n \t\t}\n \t    }\n \t  if (i == old_num)\n-\t    v_must_def_ops->v_must_defs[x] = var;\n+\t    {\n+\t      v_must_def_ops->v_must_defs[x].def = var;\n+\t      v_must_def_ops->v_must_defs[x].use = var;\n+\t    }\n \t}\n     }\n   VARRAY_POP_ALL (build_v_must_defs);\n@@ -1672,7 +1676,10 @@ copy_virtual_operands (tree dst, tree src)\n     {\n       *v_must_defs_new = allocate_v_must_def_optype (NUM_V_MUST_DEFS (v_must_defs));\n       for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\tSET_V_MUST_DEF_OP (*v_must_defs_new, i, V_MUST_DEF_OP (v_must_defs, i));\n+\t{\n+\t  SET_V_MUST_DEF_RESULT (*v_must_defs_new, i, V_MUST_DEF_RESULT (v_must_defs, i));\n+\t  SET_V_MUST_DEF_KILL (*v_must_defs_new, i, V_MUST_DEF_KILL (v_must_defs, i));\n+\t}\n     }\n }\n \n@@ -1701,7 +1708,7 @@ create_ssa_artficial_load_stmt (stmt_operands_p old_ops, tree new_stmt)\n   free_vuses (&(ann->operands.vuse_ops));\n   free_v_may_defs (&(ann->operands.v_may_def_ops));\n   free_v_must_defs (&(ann->operands.v_must_def_ops));\n-\n+  \n   /* For each VDEF on the original statement, we want to create a\n      VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n      statement.  */\n@@ -1713,7 +1720,7 @@ create_ssa_artficial_load_stmt (stmt_operands_p old_ops, tree new_stmt)\n     \n   for (j = 0; j < NUM_V_MUST_DEFS (old_ops->v_must_def_ops); j++)\n     {\n-      op = V_MUST_DEF_OP (old_ops->v_must_def_ops, j);\n+      op = V_MUST_DEF_RESULT (old_ops->v_must_def_ops, j);\n       append_vuse (op);\n     }\n "}, {"sha": "521845ff21570e5585349d0a3f8d88ca5e84466c", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -58,17 +58,17 @@ typedef struct use_optype_d GTY(())\n typedef use_optype_t *use_optype;\n \n /* Operand type which stores a def and a use tree.  */\n-typedef struct v_may_def_operand_type GTY(())\n+typedef struct v_def_use_operand_type GTY(())\n {\n   tree def;\n   tree use;\n-} v_may_def_operand_type_t;\n+} v_def_use_operand_type_t;\n \n /* This represents the MAY_DEFS for a stmt.  */\n typedef struct v_may_def_optype_d GTY(())\n {\n   unsigned num_v_may_defs; \n-  struct v_may_def_operand_type GTY((length (\"%h.num_v_may_defs\")))\n+  struct v_def_use_operand_type GTY((length (\"%h.num_v_may_defs\")))\n \t\t\t\t\t\t\t      v_may_defs[1];\n } v_may_def_optype_t;\n \n@@ -87,7 +87,7 @@ typedef vuse_optype_t *vuse_optype;\n typedef struct v_must_def_optype_d GTY(())\n {\n   unsigned num_v_must_defs; \n-  tree GTY((length(\"%h.num_v_must_defs\"))) v_must_defs[1];\n+  v_def_use_operand_type_t GTY((length(\"%h.num_v_must_defs\"))) v_must_defs[1];\n } v_must_def_optype_t;\n \n typedef v_must_def_optype_t *v_must_def_optype;\n@@ -157,12 +157,14 @@ typedef stmt_operands_t *stmt_operands_p;\n #define V_MUST_DEF_OPS(ANN)\t\tget_v_must_def_ops (ANN)\n #define STMT_V_MUST_DEF_OPS(STMT)\tget_v_must_def_ops (stmt_ann (STMT))\n #define NUM_V_MUST_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_must_defs : 0)\n-#define V_MUST_DEF_OP_PTR(OPS, I)\tget_v_must_def_op_ptr ((OPS), (I))\n-#define V_MUST_DEF_OP(OPS, I)\t\t\t\t\t\t\\\n-\t\t\t\t(DEF_FROM_PTR (V_MUST_DEF_OP_PTR ((OPS), (I))))\n-#define SET_V_MUST_DEF_OP(OPS, I, V)\t\t\t\t\t\\\n-\t\t\t\t(SET_DEF (V_MUST_DEF_OP_PTR ((OPS), (I)), (V)))\n-\n+#define V_MUST_DEF_RESULT_PTR(OPS, I)\tget_v_must_def_result_ptr ((OPS), (I))\n+#define V_MUST_DEF_RESULT(OPS, I) \\\n+\t\t\t\t(DEF_FROM_PTR (V_MUST_DEF_RESULT_PTR ((OPS), (I))))\n+#define SET_V_MUST_DEF_RESULT(OPS, I, V) \\\n+\t\t\t\t(SET_DEF (V_MUST_DEF_RESULT_PTR ((OPS), (I)), (V)))\n+#define V_MUST_DEF_KILL_PTR(OPS, I)  get_v_must_def_kill_ptr ((OPS), (I))\n+#define V_MUST_DEF_KILL(OPS, I) (USE_FROM_PTR (V_MUST_DEF_KILL_PTR ((OPS), (I))))\n+#define SET_V_MUST_DEF_KILL(OPS, I, V) (SET_USE (V_MUST_DEF_KILL_PTR ((OPS), (I)), (V)))\n \n #define PHI_RESULT_PTR(PHI)\tget_phi_result_ptr (PHI)\n #define PHI_RESULT(PHI)\t\tDEF_FROM_PTR (PHI_RESULT_PTR (PHI))\n@@ -199,13 +201,15 @@ typedef struct ssa_operand_iterator_d\n   int num_vuse;\n   int num_v_mayu;\n   int num_v_mayd;\n-  int num_v_must;\n+  int num_v_mustu;\n+  int num_v_mustd;\n   int use_i;\n   int def_i;\n   int vuse_i;\n   int v_mayu_i;\n   int v_mayd_i;\n-  int v_must_i;\n+  int v_mustu_i;\n+  int v_mustd_i;\n   stmt_operands_p ops;\n   bool done;\n } ssa_op_iter;\n@@ -218,13 +222,17 @@ typedef struct ssa_operand_iterator_d\n #define SSA_OP_VMAYUSE\t\t0x08\t/* USE portion of V_MAY_DEFS.  */\n #define SSA_OP_VMAYDEF\t\t0x10\t/* DEF portion of V_MAY_DEFS.  */\n #define SSA_OP_VMUSTDEF\t\t0x20\t/* V_MUST_DEF definitions.  */\n+#define SSA_OP_VMUSTDEFKILL     0x40    /* V_MUST_DEF kills.  */\n \n /* These are commonly grouped operand flags.  */\n #define SSA_OP_VIRTUAL_USES\t(SSA_OP_VUSE | SSA_OP_VMAYUSE)\n #define SSA_OP_VIRTUAL_DEFS\t(SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF)\n+#define SSA_OP_VIRTUAL_KILLS    (SSA_OP_VMUSTDEFKILL)\n+#define SSA_OP_ALL_VIRTUALS     (SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS | SSA_OP_VIRTUAL_DEFS)\n #define SSA_OP_ALL_USES\t\t(SSA_OP_VIRTUAL_USES | SSA_OP_USE)\n #define SSA_OP_ALL_DEFS\t\t(SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)\n-#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)\n+#define SSA_OP_ALL_KILLS        (SSA_OP_VIRTUAL_KILLS)\n+#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS | SSA_OP_ALL_KILLS)\n \n /* This macro executes a loop over the operands of STMT specified in FLAG, \n    returning each operand as a 'tree' in the variable TREEVAR.  ITER is an\n@@ -258,4 +266,12 @@ typedef struct ssa_operand_iterator_d\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n        op_iter_next_maydef (&(USEVAR), &(DEFVAR), &(ITER)))\n \n+/* This macro executes a loop over the V_MUST_DEF operands of STMT.  The def\n+   and kill for each V_MUST_DEF is returned in DEFVAR and KILLVAR. \n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_MUSTDEF_OPERAND(DEFVAR, KILLVAR, STMT, ITER)\t\\\n+  for (op_iter_init_mustdef (&(ITER), STMT, &(KILLVAR), &(DEFVAR));\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       op_iter_next_mustdef (&(KILLVAR), &(DEFVAR), &(ITER)))\n+\n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "d9379ba22e759fb83a1b64b0eafa79f985bcc8a5", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -672,7 +672,7 @@ verify_ssa (void)\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_USES)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n \t    {\n \t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n \t\t\t      op, stmt, false, true,\n@@ -1082,7 +1082,8 @@ replace_immediate_uses (tree var, tree repl)\n \t}\n       else\n \t{\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_VIRTUAL_USES)\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, \n+\t\t\t\t    SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n \t    if (USE_FROM_PTR (use_p) == var)\n \t      propagate_value (use_p, repl);\n \t}\n@@ -1464,3 +1465,4 @@ struct tree_opt_pass pass_late_warn_uninitialized =\n   0,                                    /* todo_flags_finish */\n   0\t\t\t\t        /* letter */\n };\n+\t  "}, {"sha": "df16c2ca36c527e97b2efe668f929e971c8ba79c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52328bf6c8b1a5021ae5cae29b8317123d2a58f5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=52328bf6c8b1a5021ae5cae29b8317123d2a58f5", "patch": "@@ -381,7 +381,10 @@ rename_variables_in_bb (basic_block bb)\n \n       v_must_defs = V_MUST_DEF_OPS (ann);\n       for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\trename_def_op (V_MUST_DEF_OP_PTR (v_must_defs, i), stmt);\n+\t{\n+\t  rename_use_op (V_MUST_DEF_KILL_PTR (v_must_defs, i));\n+\t  rename_def_op (V_MUST_DEF_RESULT_PTR (v_must_defs, i), stmt);\n+\t}\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1853,7 +1856,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n     }\n   for (i = 0; i < nv_must_defs; i++)\n     {\n-      tree def = V_MUST_DEF_OP (v_must_defs, i);\n+      tree def = V_MUST_DEF_RESULT (v_must_defs, i);\n       if (TREE_CODE (def) == SSA_NAME)\n         bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n     }"}]}