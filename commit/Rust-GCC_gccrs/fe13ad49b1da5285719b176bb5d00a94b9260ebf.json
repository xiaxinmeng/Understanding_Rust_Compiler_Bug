{"sha": "fe13ad49b1da5285719b176bb5d00a94b9260ebf", "node_id": "C_kwDOANBUbNoAKGZlMTNhZDQ5YjFkYTUyODU3MTliMTc2YmI1ZDAwYTk0YjkyNjBlYmY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-17T10:23:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-17T10:23:04Z"}, "message": "Merge #1030\n\n1030: Rewrite our unconstrained type-param error checking r=philberty a=philberty\n\nThis is a series of patches that were all required to fix this issue. We\r\nnow take advantage of our substitutions abstractions and traits\r\nso that our TypeBoundPredicate's which form the basis of our HRTB code\r\nI think this class is almost akin to rustc existential-trait-references. This now\r\nreuses the same code path to give us the same error checking for generics\r\nas we get with ADT's, functions etc.\r\n\r\nWith this refactoring in place we can then reuse the abstractions to map the\r\nID's from the used arguments in the type-bound-predicate, the impl block type\r\nsubstation mappings and the self type itself.\r\n\r\nThere are quite a few cases to handle and our testsuite picked up all the regressions\r\nso no behaviour of our existing test-cases have changed now. See each commit for\r\nmore detailed information.\r\n\r\nFixes #1019 \r\nAddresses #849\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7753f3b23d66655b6766159e0df3206ed594e164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7753f3b23d66655b6766159e0df3206ed594e164"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe13ad49b1da5285719b176bb5d00a94b9260ebf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiMwwICRBK7hj4Ov3rIwAA2c8IAA3BiIUUf9ttUHx6Sapr0APP\nM21h3IUhoThqJ+F4byekWFdTz7EaiNfqbHlaNNMjmLT4ic5cmmLUAu3Q9b0t/aK9\nCQBcVUEYsAMFQ0TdFtiUK092qElY+nl81R82sTdhHITPTDtAZA1zX1IwDDKm0tIJ\nfL8B8c8elGT9cbPy+/xcnYq56bt2casBjEW1uJyDtmq/5VOoOmodmdeqwKXlPKN6\nmN6G0oAONRFWlzN9QszhZ0a1ETsFwo4gYsaQqNlzgTtnm66ulRvzqXhtI2SGnHmR\n/G++jRrGpCjEjyWJh6NqO6z1TH03HKQPeZo1iNhWUVbClWamwvR8m3lAJkp7AB0=\n=bUcq\n-----END PGP SIGNATURE-----\n", "payload": "tree 7753f3b23d66655b6766159e0df3206ed594e164\nparent bb234b080a5be332bbe67d9920a65959124088e7\nparent 8086790254d0adaad48405ee838b8ca699e9d9a8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647512584 +0000\ncommitter GitHub <noreply@github.com> 1647512584 +0000\n\nMerge #1030\n\n1030: Rewrite our unconstrained type-param error checking r=philberty a=philberty\n\nThis is a series of patches that were all required to fix this issue. We\r\nnow take advantage of our substitutions abstractions and traits\r\nso that our TypeBoundPredicate's which form the basis of our HRTB code\r\nI think this class is almost akin to rustc existential-trait-references. This now\r\nreuses the same code path to give us the same error checking for generics\r\nas we get with ADT's, functions etc.\r\n\r\nWith this refactoring in place we can then reuse the abstractions to map the\r\nID's from the used arguments in the type-bound-predicate, the impl block type\r\nsubstation mappings and the self type itself.\r\n\r\nThere are quite a few cases to handle and our testsuite picked up all the regressions\r\nso no behaviour of our existing test-cases have changed now. See each commit for\r\nmore detailed information.\r\n\r\nFixes #1019 \r\nAddresses #849\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe13ad49b1da5285719b176bb5d00a94b9260ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe13ad49b1da5285719b176bb5d00a94b9260ebf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe13ad49b1da5285719b176bb5d00a94b9260ebf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb234b080a5be332bbe67d9920a65959124088e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb234b080a5be332bbe67d9920a65959124088e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb234b080a5be332bbe67d9920a65959124088e7"}, {"sha": "8086790254d0adaad48405ee838b8ca699e9d9a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8086790254d0adaad48405ee838b8ca699e9d9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8086790254d0adaad48405ee838b8ca699e9d9a8"}], "stats": {"total": 723, "additions": 483, "deletions": 240}, "files": [{"sha": "cd40efb9d339e6dda5ff73993078af52d37962b3", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -99,6 +99,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-pattern.o \\\n     rust/rust-hir-type-check-expr.o \\\n     rust/rust-hir-dot-operator.o \\\n+    rust/rust-hir-type-check-base.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\"}, {"sha": "99f4f0b02c548ada305d90a4c2e21dc95c2d9e87", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -133,8 +133,7 @@ struct GenericArgs\n \n   GenericArgs (std::vector<Lifetime> lifetime_args,\n \t       std::vector<std::unique_ptr<Type> > type_args,\n-\t       std::vector<GenericArgsBinding> binding_args,\n-\t       Location locus = Location ())\n+\t       std::vector<GenericArgsBinding> binding_args, Location locus)\n     : lifetime_args (std::move (lifetime_args)),\n       type_args (std::move (type_args)),\n       binding_args (std::move (binding_args)), locus (locus)\n@@ -471,7 +470,7 @@ class TypePathSegmentGeneric : public TypePathSegment\n \t\t       has_separating_scope_resolution, locus),\n       generic_args (GenericArgs (std::move (lifetime_args),\n \t\t\t\t std::move (type_args),\n-\t\t\t\t std::move (binding_args)))\n+\t\t\t\t std::move (binding_args), locus))\n   {}\n \n   std::string as_string () const override;"}, {"sha": "585fb6c8dbfe2f3c89d25a22cc50c6770f43e473", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -181,27 +181,48 @@ class TraitReference\n public:\n   TraitReference (const HIR::Trait *hir_trait_ref,\n \t\t  std::vector<TraitItemReference> item_refs,\n-\t\t  std::vector<const TraitReference *> super_traits)\n+\t\t  std::vector<const TraitReference *> super_traits,\n+\t\t  std::vector<TyTy::SubstitutionParamMapping> substs)\n     : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n       super_traits (super_traits)\n-  {}\n+  {\n+    trait_substs.clear ();\n+    trait_substs.reserve (substs.size ());\n+    for (const auto &p : substs)\n+      trait_substs.push_back (p.clone ());\n+  }\n \n   TraitReference (TraitReference const &other)\n-    : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs)\n-  {}\n+    : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs),\n+      super_traits (other.super_traits)\n+  {\n+    trait_substs.clear ();\n+    trait_substs.reserve (other.trait_substs.size ());\n+    for (const auto &p : other.trait_substs)\n+      trait_substs.push_back (p.clone ());\n+  }\n \n   TraitReference &operator= (TraitReference const &other)\n   {\n     hir_trait_ref = other.hir_trait_ref;\n     item_refs = other.item_refs;\n+    super_traits = other.super_traits;\n+\n+    trait_substs.clear ();\n+    trait_substs.reserve (other.trait_substs.size ());\n+    for (const auto &p : other.trait_substs)\n+      trait_substs.push_back (p.clone ());\n \n     return *this;\n   }\n \n   TraitReference (TraitReference &&other) = default;\n   TraitReference &operator= (TraitReference &&other) = default;\n \n-  static TraitReference error () { return TraitReference (nullptr, {}, {}); }\n+  static TraitReference error ()\n+  {\n+    return TraitReference (nullptr, {}, {}, {});\n+  }\n \n   bool is_error () const { return hir_trait_ref == nullptr; }\n \n@@ -384,10 +405,18 @@ class TraitReference\n     return is_safe;\n   }\n \n+  bool trait_has_generics () const { return !trait_substs.empty (); }\n+\n+  std::vector<TyTy::SubstitutionParamMapping> get_trait_substs () const\n+  {\n+    return trait_substs;\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;\n   std::vector<const TraitReference *> super_traits;\n+  std::vector<TyTy::SubstitutionParamMapping> trait_substs;\n };\n \n class AssociatedImplTrait"}, {"sha": "806a46f13cee2eec4e0bbe51180542c9e7db1efa", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -150,8 +150,13 @@ class TraitResolver : public TypeCheckBase\n \n     // They also inherit themselves as a bound this enables a trait item to\n     // reference other Self::trait_items\n+    std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n+    for (auto &sub : substitutions)\n+      self_subst_copy.push_back (sub.clone ());\n+\n     specified_bounds.push_back (\n       TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n+\t\t\t\tstd::move (self_subst_copy),\n \t\t\t\ttrait_reference->get_locus ()));\n \n     std::vector<const TraitReference *> super_traits;\n@@ -168,8 +173,8 @@ class TraitResolver : public TypeCheckBase\n \t\t// FIXME this might be recursive we need a check for that\n \n \t\tTraitReference *trait = resolve_trait_path (b->get_path ());\n-\t\tTyTy::TypeBoundPredicate predicate (\n-\t\t  trait->get_mappings ().get_defid (), bound->get_locus ());\n+\t\tTyTy::TypeBoundPredicate predicate (*trait,\n+\t\t\t\t\t\t    bound->get_locus ());\n \n \t\tspecified_bounds.push_back (std::move (predicate));\n \t\tsuper_traits.push_back (predicate.get ());\n@@ -193,7 +198,8 @@ class TraitResolver : public TypeCheckBase\n       }\n \n     TraitReference trait_object (trait_reference, item_refs,\n-\t\t\t\t std::move (super_traits));\n+\t\t\t\t std::move (super_traits),\n+\t\t\t\t std::move (substitutions));\n     context->insert_trait_reference (\n       trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n "}, {"sha": "32c588165826a9d040b1f5487d0b00dffd2ed113", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+bool\n+TypeCheckBase::check_for_unconstrained (\n+  const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,\n+  const TyTy::SubstitutionArgumentMappings &constraint_a,\n+  const TyTy::SubstitutionArgumentMappings &constraint_b,\n+  const TyTy::BaseType *reference)\n+{\n+  std::set<HirId> symbols_to_constrain;\n+  std::map<HirId, Location> symbol_to_location;\n+  for (const auto &p : params_to_constrain)\n+    {\n+      HirId ref = p.get_param_ty ()->get_ref ();\n+      symbols_to_constrain.insert (ref);\n+      symbol_to_location.insert ({ref, p.get_param_locus ()});\n+    }\n+\n+  // set up the set of constrained symbols\n+  std::set<HirId> constrained_symbols;\n+  for (const auto &c : constraint_a.get_mappings ())\n+    {\n+      const TyTy::BaseType *arg = c.get_tyty ();\n+      if (arg != nullptr)\n+\t{\n+\t  const TyTy::BaseType *p = arg->get_root ();\n+\t  constrained_symbols.insert (p->get_ty_ref ());\n+\t}\n+    }\n+  for (const auto &c : constraint_b.get_mappings ())\n+    {\n+      const TyTy::BaseType *arg = c.get_tyty ();\n+      if (arg != nullptr)\n+\t{\n+\t  const TyTy::BaseType *p = arg->get_root ();\n+\t  constrained_symbols.insert (p->get_ty_ref ());\n+\t}\n+    }\n+\n+  const auto root = reference->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      const TyTy::ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+      constrained_symbols.insert (p->get_ty_ref ());\n+    }\n+\n+  // check for unconstrained\n+  bool unconstrained = false;\n+  for (auto &sym : symbols_to_constrain)\n+    {\n+      bool used = constrained_symbols.find (sym) != constrained_symbols.end ();\n+      if (!used)\n+\t{\n+\t  Location locus = symbol_to_location.at (sym);\n+\t  rust_error_at (locus, \"unconstrained type parameter\");\n+\t  unconstrained = true;\n+\t}\n+    }\n+  return unconstrained;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "5a3f553367f356c5b01852b9875b54f675b81c3e", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -47,6 +47,14 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n \n   TraitReference *resolve_trait_path (HIR::TypePath &);\n \n+  TyTy::TypeBoundPredicate get_predicate_from_bound (HIR::TypePath &path);\n+\n+  bool check_for_unconstrained (\n+    const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,\n+    const TyTy::SubstitutionArgumentMappings &constraint_a,\n+    const TyTy::SubstitutionArgumentMappings &constraint_b,\n+    const TyTy::BaseType *reference);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "4c6c4a633d291f60734fa145f6b66a657b863282", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -70,34 +70,15 @@ class TypeCheckItem : public TypeCheckBase\n \t  }\n       }\n \n-    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+    auto specified_bound = TyTy::TypeBoundPredicate::error ();\n     TraitReference *trait_reference = &TraitReference::error_node ();\n     if (impl_block.has_trait_ref ())\n       {\n \tstd::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n \ttrait_reference = TraitResolver::Resolve (*ref.get ());\n \trust_assert (!trait_reference->is_error ());\n \n-\t// setup the bound\n-\tTyTy::TypeBoundPredicate predicate (\n-\t  trait_reference->get_mappings ().get_defid (), ref->get_locus ());\n-\tauto &final_seg = ref->get_final_segment ();\n-\tif (final_seg->is_generic_segment ())\n-\t  {\n-\t    auto final_generic_seg\n-\t      = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-\t    if (final_generic_seg->has_generic_args ())\n-\t      {\n-\t\tHIR::GenericArgs &generic_args\n-\t\t  = final_generic_seg->get_generic_args ();\n-\n-\t\t// this is applying generic arguments to a trait\n-\t\t// reference\n-\t\tpredicate.apply_generic_arguments (&generic_args);\n-\t      }\n-\t  }\n-\n-\tspecified_bounds.push_back (std::move (predicate));\n+\tspecified_bound = get_predicate_from_bound (*ref.get ());\n       }\n \n     TyTy::BaseType *self = nullptr;\n@@ -108,11 +89,25 @@ class TypeCheckItem : public TypeCheckBase\n \t\t       \"failed to resolve Self for ImplBlock\");\n \treturn;\n       }\n-    // inherit the bounds\n-    self->inherit_bounds (specified_bounds);\n \n+    // inherit the bounds\n+    if (!specified_bound.is_error ())\n+      self->inherit_bounds ({specified_bound});\n+\n+    // check for any unconstrained type-params\n+    const TyTy::SubstitutionArgumentMappings trait_constraints\n+      = specified_bound.get_substitution_arguments ();\n+    const TyTy::SubstitutionArgumentMappings impl_constraints\n+      = GetUsedSubstArgs::From (self);\n+\n+    bool impl_block_has_unconstrained_typarams\n+      = check_for_unconstrained (substitutions, trait_constraints,\n+\t\t\t\t impl_constraints, self);\n+    if (impl_block_has_unconstrained_typarams)\n+      return;\n+\n+    // validate the impl items\n     bool is_trait_impl_block = !trait_reference->is_error ();\n-\n     std::vector<const TraitItemReference *> trait_item_refs;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {"}, {"sha": "5e124663fe744bebc3caa17d45609c0b3a43112d", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -468,9 +468,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n       }\n \n-    auto self\n-      = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n-    if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)\n+    auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n+    if (self->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n     for (auto &impl_item : impl_block.get_impl_items ())"}, {"sha": "914bebbecf82c1d0f8192bda703be6f59845b808", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -84,11 +84,6 @@ TypeCheckType::visit (HIR::TypePath &path)\n \t}\n \n       translated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n-      if (translated->get_kind () != TyTy::TypeKind::ERROR\n-\t  && mappings != nullptr)\n-\t{\n-\t  check_for_unconstrained (args.get_type_args ());\n-\t}\n     }\n   else if (!args.is_empty ())\n     {\n@@ -548,27 +543,11 @@ TypeCheckType::visit (HIR::TraitObjectType &type)\n       HIR::TypeParamBound &b = *bound.get ();\n       HIR::TraitBound &trait_bound = static_cast<HIR::TraitBound &> (b);\n \n-      auto &type_path = trait_bound.get_path ();\n-      TraitReference *trait = resolve_trait_path (type_path);\n-      TyTy::TypeBoundPredicate predicate (trait->get_mappings ().get_defid (),\n-\t\t\t\t\t  trait_bound.get_locus ());\n-      auto &final_seg = type_path.get_final_segment ();\n-      if (final_seg->is_generic_segment ())\n-\t{\n-\t  auto final_generic_seg\n-\t    = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-\t  if (final_generic_seg->has_generic_args ())\n-\t    {\n-\t      HIR::GenericArgs &generic_args\n-\t\t= final_generic_seg->get_generic_args ();\n-\n-\t      // this is applying generic arguments to a trait\n-\t      // reference\n-\t      predicate.apply_generic_arguments (&generic_args);\n-\t    }\n-\t}\n+      TyTy::TypeBoundPredicate predicate\n+\t= get_predicate_from_bound (trait_bound.get_path ());\n \n-      if (predicate.is_object_safe (true, type.get_locus ()))\n+      if (!predicate.is_error ()\n+\t  && predicate.is_object_safe (true, type.get_locus ()))\n \tspecified_bounds.push_back (std::move (predicate));\n     }\n "}, {"sha": "127502f14941ce042876f2a3ebb0d081b268322d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 12, "deletions": 87, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -57,12 +57,9 @@ class TypeCheckType : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TyTy::BaseType *\n-  Resolve (HIR::Type *type,\n-\t   std::vector<TyTy::SubstitutionParamMapping> *subst_mappings\n-\t   = nullptr)\n+  static TyTy::BaseType *Resolve (HIR::Type *type)\n   {\n-    TypeCheckType resolver (type->get_mappings ().get_hirid (), subst_mappings);\n+    TypeCheckType resolver (type->get_mappings ().get_hirid ());\n     type->accept_vis (resolver);\n     rust_assert (resolver.translated != nullptr);\n     resolver.context->insert_type (type->get_mappings (), resolver.translated);\n@@ -159,43 +156,10 @@ class TypeCheckType : public TypeCheckBase\n   void visit (HIR::TraitObjectType &type) override;\n \n private:\n-  TypeCheckType (HirId id,\n-\t\t std::vector<TyTy::SubstitutionParamMapping> *subst_mappings)\n-    : TypeCheckBase (), subst_mappings (subst_mappings),\n-      translated (new TyTy::ErrorType (id))\n+  TypeCheckType (HirId id)\n+    : TypeCheckBase (), translated (new TyTy::ErrorType (id))\n   {}\n \n-  void\n-  check_for_unconstrained (std::vector<std::unique_ptr<HIR::Type>> &type_args)\n-  {\n-    std::map<std::string, Location> param_location_map;\n-    std::set<std::string> param_tys;\n-\n-    if (subst_mappings != nullptr)\n-      {\n-\tfor (auto &mapping : *subst_mappings)\n-\t  {\n-\t    std::string sym = mapping.get_param_ty ()->get_symbol ();\n-\t    param_tys.insert (sym);\n-\t    param_location_map[sym] = mapping.get_generic_param ().get_locus ();\n-\t  }\n-      }\n-\n-    std::set<std::string> args;\n-    for (auto &arg : type_args)\n-      args.insert (arg->as_string ());\n-\n-    for (auto &exp : param_tys)\n-      {\n-\tbool used = args.find (exp) != args.end ();\n-\tif (!used)\n-\t  {\n-\t    Location locus = param_location_map.at (exp);\n-\t    rust_error_at (locus, \"unconstrained type parameter\");\n-\t  }\n-      }\n-  }\n-\n   TyTy::BaseType *resolve_root_path (HIR::TypePath &path, size_t *offset,\n \t\t\t\t     NodeId *root_resolved_node_id);\n \n@@ -205,7 +169,6 @@ class TypeCheckType : public TypeCheckBase\n     TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n     Location expr_locus);\n \n-  std::vector<TyTy::SubstitutionParamMapping> *subst_mappings;\n   TyTy::BaseType *translated;\n };\n \n@@ -245,29 +208,10 @@ class TypeResolveGenericParam : public TypeCheckBase\n \t\t  HIR::TraitBound *b\n \t\t    = static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t\t  auto &type_path = b->get_path ();\n-\t\t  TraitReference *trait = resolve_trait_path (type_path);\n-\t\t  TyTy::TypeBoundPredicate predicate (\n-\t\t    trait->get_mappings ().get_defid (), b->get_locus ());\n-\n-\t\t  auto &final_seg = type_path.get_final_segment ();\n-\t\t  if (final_seg->is_generic_segment ())\n-\t\t    {\n-\t\t      auto final_generic_seg\n-\t\t\t= static_cast<HIR::TypePathSegmentGeneric *> (\n-\t\t\t  final_seg.get ());\n-\t\t      if (final_generic_seg->has_generic_args ())\n-\t\t\t{\n-\t\t\t  HIR::GenericArgs &generic_args\n-\t\t\t    = final_generic_seg->get_generic_args ();\n-\n-\t\t\t  // this is applying generic arguments to a trait\n-\t\t\t  // reference\n-\t\t\t  predicate.apply_generic_arguments (&generic_args);\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  specified_bounds.push_back (std::move (predicate));\n+\t\t  TyTy::TypeBoundPredicate predicate\n+\t\t    = get_predicate_from_bound (b->get_path ());\n+\t\t  if (!predicate.is_error ())\n+\t\t    specified_bounds.push_back (std::move (predicate));\n \t\t}\n \t\tbreak;\n \n@@ -316,29 +260,10 @@ class ResolveWhereClauseItem : public TypeCheckBase\n \t      HIR::TraitBound *b\n \t\t= static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t      auto &type_path = b->get_path ();\n-\t      TraitReference *trait = resolve_trait_path (type_path);\n-\t      TyTy::TypeBoundPredicate predicate (\n-\t\ttrait->get_mappings ().get_defid (), b->get_locus ());\n-\n-\t      auto &final_seg = type_path.get_final_segment ();\n-\t      if (final_seg->is_generic_segment ())\n-\t\t{\n-\t\t  auto final_generic_seg\n-\t\t    = static_cast<HIR::TypePathSegmentGeneric *> (\n-\t\t      final_seg.get ());\n-\t\t  if (final_generic_seg->has_generic_args ())\n-\t\t    {\n-\t\t      HIR::GenericArgs &generic_args\n-\t\t\t= final_generic_seg->get_generic_args ();\n-\n-\t\t      // this is applying generic arguments to a trait\n-\t\t      // reference\n-\t\t      predicate.apply_generic_arguments (&generic_args);\n-\t\t    }\n-\t\t}\n-\n-\t      specified_bounds.push_back (std::move (predicate));\n+\t      TyTy::TypeBoundPredicate predicate\n+\t\t= get_predicate_from_bound (b->get_path ());\n+\t      if (!predicate.is_error ())\n+\t\tspecified_bounds.push_back (std::move (predicate));\n \t    }\n \t    break;\n "}, {"sha": "a7ec42c7a1c278fcb4bb91b6fa5d3c0d1e630f24", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 179, "deletions": 6, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -63,17 +63,101 @@ TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n   return TraitResolver::Resolve (path);\n }\n \n+TyTy::TypeBoundPredicate\n+TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n+{\n+  TraitReference *trait = resolve_trait_path (type_path);\n+  if (trait->is_error ())\n+    return TyTy::TypeBoundPredicate::error ();\n+\n+  TyTy::TypeBoundPredicate predicate (*trait, type_path.get_locus ());\n+  HIR::GenericArgs args\n+    = HIR::GenericArgs::create_empty (type_path.get_locus ());\n+\n+  auto &final_seg = type_path.get_final_segment ();\n+  if (final_seg->is_generic_segment ())\n+    {\n+      auto final_generic_seg\n+\t= static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+      if (final_generic_seg->has_generic_args ())\n+\t{\n+\t  args = final_generic_seg->get_generic_args ();\n+\t}\n+    }\n+\n+  if (predicate.requires_generic_args ())\n+    {\n+      // this is applying generic arguments to a trait reference\n+      predicate.apply_generic_arguments (&args);\n+    }\n+\n+  return predicate;\n+}\n+\n } // namespace Resolver\n \n namespace TyTy {\n \n+TypeBoundPredicate::TypeBoundPredicate (\n+  const Resolver::TraitReference &trait_reference, Location locus)\n+  : SubstitutionRef (trait_reference.get_trait_substs (),\n+\t\t     SubstitutionArgumentMappings::error ()),\n+    reference (trait_reference.get_mappings ().get_defid ()), locus (locus),\n+    args (HIR::GenericArgs::create_empty ()), error_flag (false)\n+{}\n+\n+TypeBoundPredicate::TypeBoundPredicate (\n+  DefId reference, std::vector<SubstitutionParamMapping> substitutions,\n+  Location locus)\n+  : SubstitutionRef (std::move (substitutions),\n+\t\t     SubstitutionArgumentMappings::error ()),\n+    reference (reference), locus (locus),\n+    args (HIR::GenericArgs::create_empty ()), error_flag (false)\n+{}\n+\n+TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n+  : SubstitutionRef ({}, other.used_arguments), reference (other.reference),\n+    locus (other.locus), args (other.args), error_flag (other.error_flag)\n+{\n+  substitutions.clear ();\n+  if (!other.is_error ())\n+    {\n+      for (const auto &p : other.get_substs ())\n+\tsubstitutions.push_back (p.clone ());\n+    }\n+}\n+\n+TypeBoundPredicate &\n+TypeBoundPredicate::operator= (const TypeBoundPredicate &other)\n+{\n+  reference = other.reference;\n+  locus = other.locus;\n+  args = other.args;\n+  error_flag = other.error_flag;\n+  used_arguments = other.used_arguments;\n+\n+  substitutions.clear ();\n+  if (!other.is_error ())\n+    {\n+      for (const auto &p : other.get_substs ())\n+\tsubstitutions.push_back (p.clone ());\n+    }\n+\n+  return *this;\n+}\n+\n+TypeBoundPredicate\n+TypeBoundPredicate::error ()\n+{\n+  auto p = TypeBoundPredicate (UNKNOWN_DEFID, {}, Location ());\n+  p.error_flag = true;\n+  return p;\n+}\n+\n std::string\n TypeBoundPredicate::as_string () const\n {\n-  return get ()->as_string ()\n-\t + (has_generic_args ()\n-\t      ? std::string (\"<\") + args->as_string () + std::string (\">\")\n-\t      : \"\");\n+  return get ()->as_string () + subst_as_string ();\n }\n \n const Resolver::TraitReference *\n@@ -114,8 +198,19 @@ TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n void\n TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n {\n-  args = generic_args;\n-  // TODO verify these arguments are valid and not too many were added\n+  // we need to get the substitutions argument mappings but also remember that\n+  // we have an implicit Self argument which we must be careful to respect\n+  rust_assert (used_arguments.is_empty ());\n+  rust_assert (!substitutions.empty ());\n+\n+  // we setup a dummy implict self argument\n+  SubstitutionArg placeholder_self (&substitutions.front (), nullptr);\n+  used_arguments.get_mappings ().push_back (std::move (placeholder_self));\n+\n+  // now actually perform a substitution\n+  used_arguments = get_mappings_from_generic_args (*generic_args);\n+  error_flag |= used_arguments.is_error ();\n+  args = *generic_args;\n }\n \n bool\n@@ -179,6 +274,34 @@ TypeBoundPredicateItem::get_tyty_for_receiver (\n \n   return resolved;\n }\n+bool\n+TypeBoundPredicate::is_error () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  Resolver::TraitReference *ref = nullptr;\n+  bool ok = context->lookup_trait_reference (reference, &ref);\n+\n+  return !ok || error_flag;\n+}\n+\n+BaseType *\n+TypeBoundPredicate::handle_substitions (SubstitutionArgumentMappings mappings)\n+{\n+  gcc_unreachable ();\n+  return nullptr;\n+}\n+\n+bool\n+TypeBoundPredicate::requires_generic_args () const\n+{\n+  if (is_error ())\n+    return false;\n+\n+  return substitutions.size () > 1 && args.is_empty ();\n+}\n+\n+// trait item reference\n \n const Resolver::TraitItemReference *\n TypeBoundPredicateItem::get_raw_item () const\n@@ -192,5 +315,55 @@ TypeBoundPredicateItem::needs_implementation () const\n   return !get_raw_item ()->is_optional ();\n }\n \n+// TypeBoundsMappings\n+\n+TypeBoundsMappings::TypeBoundsMappings (\n+  std::vector<TypeBoundPredicate> specified_bounds)\n+  : specified_bounds (specified_bounds)\n+{}\n+\n+std::vector<TypeBoundPredicate> &\n+TypeBoundsMappings::get_specified_bounds ()\n+{\n+  return specified_bounds;\n+}\n+\n+const std::vector<TypeBoundPredicate> &\n+TypeBoundsMappings::get_specified_bounds () const\n+{\n+  return specified_bounds;\n+}\n+\n+size_t\n+TypeBoundsMappings::num_specified_bounds () const\n+{\n+  return specified_bounds.size ();\n+}\n+\n+std::string\n+TypeBoundsMappings::raw_bounds_as_string () const\n+{\n+  std::string buf;\n+  for (size_t i = 0; i < specified_bounds.size (); i++)\n+    {\n+      const TypeBoundPredicate &b = specified_bounds.at (i);\n+      bool has_next = (i + 1) < specified_bounds.size ();\n+      buf += b.get_name () + (has_next ? \" + \" : \"\");\n+    }\n+  return buf;\n+}\n+\n+std::string\n+TypeBoundsMappings::bounds_as_string () const\n+{\n+  return \"bounds:[\" + raw_bounds_as_string () + \"]\";\n+}\n+\n+void\n+TypeBoundsMappings::add_bound (TypeBoundPredicate predicate)\n+{\n+  specified_bounds.push_back (predicate);\n+}\n+\n } // namespace TyTy\n } // namespace Rust"}, {"sha": "c12095f26ebf37e62969581bbf153cfeb3050772", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -201,11 +201,16 @@ BaseType::inherit_bounds (\n const BaseType *\n BaseType::get_root () const\n {\n-  const BaseType *root = this;\n-  while (root->get_kind () == TyTy::REF)\n+  const TyTy::BaseType *root = this;\n+  if (get_kind () == TyTy::REF)\n     {\n       const ReferenceType *r = static_cast<const ReferenceType *> (root);\n-      root = r->get_base ();\n+      root = r->get_base ()->get_root ();\n+    }\n+  else if (get_kind () == TyTy::POINTER)\n+    {\n+      const PointerType *r = static_cast<const PointerType *> (root);\n+      root = r->get_base ()->get_root ();\n     }\n   return root;\n }\n@@ -543,11 +548,11 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       rust_error_at (\n \tr,\n \t\"generic item takes at least %lu type arguments but %lu were supplied\",\n-\tsubstitutions.size (), args.get_type_args ().size ());\n+\t(min_required_substitutions () - offs), args.get_type_args ().size ());\n       return SubstitutionArgumentMappings::error ();\n     }\n \n-  std::vector<SubstitutionArg> mappings;\n+  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n   for (auto &arg : args.get_type_args ())\n     {\n       BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n@@ -2351,7 +2356,7 @@ ParamType::handle_substitions (SubstitutionArgumentMappings mappings)\n \n   SubstitutionArg arg = SubstitutionArg::error ();\n   bool ok = mappings.get_argument_for_symbol (this, &arg);\n-  if (ok)\n+  if (ok && !arg.is_error ())\n     p->set_ty_ref (arg.get_tyty ()->get_ref ());\n \n   return p;"}, {"sha": "58b5042c34ab345be26578e73a3c5f9850f79aae", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -108,92 +108,24 @@ class TypeBoundPredicateItem\n   const Resolver::TraitItemReference *trait_item_ref;\n };\n \n-class TypeBoundPredicate\n-{\n-public:\n-  TypeBoundPredicate (DefId reference, Location locus)\n-    : reference (reference), locus (locus), args (nullptr)\n-  {}\n-\n-  std::string as_string () const;\n-\n-  const Resolver::TraitReference *get () const;\n-\n-  Location get_locus () const { return locus; }\n-\n-  std::string get_name () const;\n-\n-  // check that this predicate is object-safe see:\n-  // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n-  bool is_object_safe (bool emit_error, Location locus) const;\n-\n-  void apply_generic_arguments (HIR::GenericArgs *generic_args);\n-\n-  bool contains_item (const std::string &search) const;\n-\n-  TypeBoundPredicateItem\n-  lookup_associated_item (const std::string &search) const;\n-\n-  HIR::GenericArgs *get_generic_args () { return args; }\n-\n-  const HIR::GenericArgs *get_generic_args () const { return args; }\n-\n-  bool has_generic_args () const\n-  {\n-    if (args == nullptr)\n-      return false;\n-\n-    return args->has_generic_args ();\n-  }\n-\n-private:\n-  DefId reference;\n-  Location locus;\n-  HIR::GenericArgs *args;\n-};\n-\n class TypeBoundsMappings\n {\n protected:\n-  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds)\n-    : specified_bounds (specified_bounds)\n-  {}\n+  TypeBoundsMappings (std::vector<TypeBoundPredicate> specified_bounds);\n \n public:\n-  std::vector<TypeBoundPredicate> &get_specified_bounds ()\n-  {\n-    return specified_bounds;\n-  }\n+  std::vector<TypeBoundPredicate> &get_specified_bounds ();\n \n-  const std::vector<TypeBoundPredicate> &get_specified_bounds () const\n-  {\n-    return specified_bounds;\n-  }\n+  const std::vector<TypeBoundPredicate> &get_specified_bounds () const;\n \n-  size_t num_specified_bounds () const { return specified_bounds.size (); }\n+  size_t num_specified_bounds () const;\n \n-  std::string raw_bounds_as_string () const\n-  {\n-    std::string buf;\n-    for (size_t i = 0; i < specified_bounds.size (); i++)\n-      {\n-\tconst TypeBoundPredicate &b = specified_bounds.at (i);\n-\tbool has_next = (i + 1) < specified_bounds.size ();\n-\tbuf += b.get_name () + (has_next ? \" + \" : \"\");\n-      }\n-    return buf;\n-  }\n+  std::string raw_bounds_as_string () const;\n \n-  std::string bounds_as_string () const\n-  {\n-    return \"bounds:[\" + raw_bounds_as_string () + \"]\";\n-  }\n+  std::string bounds_as_string () const;\n \n protected:\n-  void add_bound (TypeBoundPredicate predicate)\n-  {\n-    specified_bounds.push_back (predicate);\n-  }\n+  void add_bound (TypeBoundPredicate predicate);\n \n   std::vector<TypeBoundPredicate> specified_bounds;\n };\n@@ -619,7 +551,13 @@ class SubstitutionParamMapping\n     : generic (other.generic), param (other.param)\n   {}\n \n-  std::string as_string () const { return param->get_name (); }\n+  std::string as_string () const\n+  {\n+    if (param == nullptr)\n+      return \"nullptr\";\n+\n+    return param->get_name ();\n+  }\n \n   bool fill_param_ty (BaseType &type, Location locus);\n \n@@ -683,7 +621,9 @@ class SubstitutionArg\n \n   BaseType *get_tyty () { return argument; }\n \n-  const SubstitutionParamMapping *get_param_mapping () { return param; }\n+  const BaseType *get_tyty () const { return argument; }\n+\n+  const SubstitutionParamMapping *get_param_mapping () const { return param; }\n \n   static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n \n@@ -702,7 +642,8 @@ class SubstitutionArg\n \n   std::string as_string () const\n   {\n-    return param->as_string () + \":\" + argument->as_string ();\n+    return param->as_string ()\n+\t   + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n   }\n \n private:\n@@ -780,8 +721,12 @@ class SubstitutionArgumentMappings\n \n   size_t size () const { return mappings.size (); }\n \n+  bool is_empty () const { return size () == 0; }\n+\n   std::vector<SubstitutionArg> &get_mappings () { return mappings; }\n \n+  const std::vector<SubstitutionArg> &get_mappings () const { return mappings; }\n+\n   std::string as_string () const\n   {\n     std::string buffer;\n@@ -1007,6 +952,62 @@ class SubstitutionRef\n   SubstitutionArgumentMappings used_arguments;\n };\n \n+class TypeBoundPredicate : public SubstitutionRef\n+{\n+public:\n+  TypeBoundPredicate (const Resolver::TraitReference &trait_reference,\n+\t\t      Location locus);\n+\n+  TypeBoundPredicate (DefId reference,\n+\t\t      std::vector<SubstitutionParamMapping> substitutions,\n+\t\t      Location locus);\n+\n+  TypeBoundPredicate (const TypeBoundPredicate &other);\n+\n+  TypeBoundPredicate &operator= (const TypeBoundPredicate &other);\n+\n+  static TypeBoundPredicate error ();\n+\n+  std::string as_string () const;\n+\n+  const Resolver::TraitReference *get () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::string get_name () const;\n+\n+  // check that this predicate is object-safe see:\n+  // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n+  bool is_object_safe (bool emit_error, Location locus) const;\n+\n+  void apply_generic_arguments (HIR::GenericArgs *generic_args);\n+\n+  bool contains_item (const std::string &search) const;\n+\n+  TypeBoundPredicateItem\n+  lookup_associated_item (const std::string &search) const;\n+\n+  HIR::GenericArgs *get_generic_args () { return &args; }\n+\n+  const HIR::GenericArgs *get_generic_args () const { return &args; }\n+\n+  bool has_generic_args () const { return args.has_generic_args (); }\n+\n+  // WARNING THIS WILL ALWAYS RETURN NULLPTR\n+  BaseType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n+  bool is_error () const;\n+\n+  bool requires_generic_args () const;\n+\n+private:\n+  DefId reference;\n+  Location locus;\n+  HIR::GenericArgs args;\n+  bool error_flag;\n+};\n+\n // https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.VariantDef.html\n class VariantDef\n {"}, {"sha": "aea86a821c773e25fe0ca657247322f8626dbba7", "filename": "gcc/testsuite/rust/compile/issue-1019.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1019.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1019.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1019.rs?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -0,0 +1,19 @@\n+trait A<T> {\n+    type Output;\n+\n+    fn test(self, a: &T) -> &Self::Output;\n+}\n+\n+struct Foo<T> {\n+    // { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+    start: T,\n+    end: T,\n+}\n+\n+impl<X> A<X> for Foo<usize> {\n+    type Output = X;\n+\n+    fn test(self, a: &X) -> &Self::Output {\n+        a\n+    }\n+}"}, {"sha": "25e0eb7aaa3cd307f6d11e271729f595afc83ec6", "filename": "gcc/testsuite/rust/compile/traits12.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe13ad49b1da5285719b176bb5d00a94b9260ebf/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs?ref=fe13ad49b1da5285719b176bb5d00a94b9260ebf", "patch": "@@ -0,0 +1,20 @@\n+trait A<T> {\n+    type Output;\n+\n+    fn test(self, a: &T) -> &Self::Output;\n+}\n+\n+struct Foo<T> {\n+    start: T,\n+    end: T,\n+}\n+\n+impl<T> A for Foo<usize> {\n+    // { dg-error \"generic item takes at least 1 type arguments but 0 were supplied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"unconstrained type parameter\" \"\" { target *-*-* } .-2 }\n+    type Output = T;\n+\n+    fn test(self, a: &T) -> &Self::Output {\n+        a\n+    }\n+}"}]}