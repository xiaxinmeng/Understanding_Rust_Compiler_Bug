{"sha": "635559ab2e63321fc138894332e8dc4704aea20f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1NTU5YWIyZTYzMzIxZmMxMzg4OTQzMzJlOGRjNDcwNGFlYTIwZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-10-23T13:34:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-10-23T13:34:33Z"}, "message": "i386.c (ix86_expand_int_movcc): Cleanup; use expand_simple_*op.\n\n\t* i386.c (ix86_expand_int_movcc): Cleanup; use expand_simple_*op.\n\n\t* toplev.c (rest_of_compilation): Use CLEANUP_UPDATE_LIFE\n\tto avoid update_life_info call.\n\t* basic-block.h (CLEANUP_UPATE_LIFE): Define.\n\t* cfgcleanup.c (bb_flags): New enum.\n\t(BB_FLAGS, BB_SET_FLAG, BB_CLEAR_FLAG, FORWARDER_BLOCK_P): New macros.\n\t(notice_new_block, update_forwarder_flag): New functions.\n\t(try_simplify_condjump): Use FORWARDER_BLOCK_P.\n\t(try_forward_edges): Likewise; update flags.\n\t(merge_blocks): Likewise.\n\t(outgoing_edges_match): Likewise.\n\t(try_crossjump_to_edge): Likewise.\n\t(try_optimize_cfg): Likewise; initialize and clear the flags;\n\trecompute life info if needed.\n\t(cleanup_cfg): No need to clear aux pointers.\n\nFrom-SVN: r46434", "tree": {"sha": "59fd5309924b42f685561489c0b8479317babeb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59fd5309924b42f685561489c0b8479317babeb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/635559ab2e63321fc138894332e8dc4704aea20f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635559ab2e63321fc138894332e8dc4704aea20f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635559ab2e63321fc138894332e8dc4704aea20f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635559ab2e63321fc138894332e8dc4704aea20f/comments", "author": null, "committer": null, "parents": [{"sha": "fbb83b433067ff743fe0e6c84fc45c4c270f276d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb83b433067ff743fe0e6c84fc45c4c270f276d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb83b433067ff743fe0e6c84fc45c4c270f276d"}], "stats": {"total": 280, "additions": 178, "deletions": 102}, "files": [{"sha": "39b5d61e909373b14db095abfe50d1632a1ac5d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=635559ab2e63321fc138894332e8dc4704aea20f", "patch": "@@ -1,3 +1,22 @@\n+Tue Oct 23 15:30:23 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_expand_int_movcc): Cleanup; use expand_simple_*op.\n+\n+\t* toplev.c (rest_of_compilation): Use CLEANUP_UPDATE_LIFE\n+\tto avoid update_life_info call.\n+\t* basic-block.h (CLEANUP_UPATE_LIFE): Define.\n+\t* cfgcleanup.c (bb_flags): New enum.\n+\t(BB_FLAGS, BB_SET_FLAG, BB_CLEAR_FLAG, FORWARDER_BLOCK_P): New macros.\n+\t(notice_new_block, update_forwarder_flag): New functions.\n+\t(try_simplify_condjump): Use FORWARDER_BLOCK_P.\n+\t(try_forward_edges): Likewise; update flags.\n+\t(merge_blocks): Likewise.\n+\t(outgoing_edges_match): Likewise.\n+\t(try_crossjump_to_edge): Likewise.\n+\t(try_optimize_cfg): Likewise; initialize and clear the flags;\n+\trecompute life info if needed.\n+\t(cleanup_cfg): No need to clear aux pointers.\n+\n 2001-10-23  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/i386/i386.c (override_options): Default to minimum"}, {"sha": "cca96a3b747d17ccd7a755f11ae6df5747e0f15c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=635559ab2e63321fc138894332e8dc4704aea20f", "patch": "@@ -574,6 +574,7 @@ enum update_life_extent\n \t\t\t\t\t   inside call_placeholders..  */\n #define CLEANUP_PRE_LOOP\t16\t/* Take care to preserve syntactic loop\n \t\t\t\t\t   notes.  */\n+#define CLEANUP_UPDATE_LIFE\t32\t/* Keep life information up to date.  */\n /* Flags for loop discovery.  */\n \n #define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */"}, {"sha": "c53e69579efdd11c6caaf8ce6cc5b8472b9a0693", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 102, "deletions": 25, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=635559ab2e63321fc138894332e8dc4704aea20f", "patch": "@@ -45,6 +45,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"obstack.h\"\n \n+/* cleanup_cfg maitains following flags for each basic block.  */\n+enum bb_flags {\n+    /* Set if life info needs to be recomputed for given BB.  */\n+    BB_UPDATE_LIFE = 1,\n+    /* Set if BB is the forwarder block to avoid too many\n+       forwarder_block_p calls.  */\n+    BB_FORWARDER_BLOCK = 2\n+  };\n+\n+#define BB_FLAGS(bb) (enum bb_flags)(bb)->aux\n+#define BB_SET_FLAG(bb,flag) \\\n+  (bb)->aux = (void *)((enum bb_flags)(bb)->aux | (flag))\n+#define BB_CLEAR_FLAG(bb,flag) \\\n+  (bb)->aux = (void *)((enum bb_flags)(bb)->aux & ~(flag))\n+\n+#define FORWARDER_BLOCK_P(bb) (BB_FLAGS(bb) & BB_FORWARDER_BLOCK)\n+\n static bool try_crossjump_to_edge\tPARAMS ((int, edge, edge));\n static bool try_crossjump_bb\t\tPARAMS ((int, basic_block));\n static bool outgoing_edges_match\tPARAMS ((basic_block, basic_block));\n@@ -62,6 +79,33 @@ static bool merge_blocks\t\tPARAMS ((edge,basic_block,basic_block,\n static bool try_optimize_cfg\t\tPARAMS ((int));\n static bool try_simplify_condjump\tPARAMS ((basic_block));\n static bool try_forward_edges\t\tPARAMS ((int, basic_block));\n+static void notice_new_block\t\tPARAMS ((basic_block));\n+static void update_forwarder_flag\tPARAMS ((basic_block));\n+\f\n+/* Set flags for newly created block.  */\n+\n+static void\n+notice_new_block (bb)\n+     basic_block bb;\n+{\n+  if (!bb)\n+    return;\n+  BB_SET_FLAG (bb, BB_UPDATE_LIFE);\n+  if (forwarder_block_p (bb))\n+    BB_SET_FLAG (bb, BB_FORWARDER_BLOCK);\n+}\n+\n+/* Recompute forwarder flag after block has been modified.  */\n+\n+static void\n+update_forwarder_flag (bb)\n+     basic_block bb;\n+{\n+  if (forwarder_block_p (bb))\n+    BB_SET_FLAG (bb, BB_FORWARDER_BLOCK);\n+  else\n+    BB_CLEAR_FLAG (bb, BB_FORWARDER_BLOCK);\n+}\n \f\n /* Simplify a conditional jump around an unconditional jump.\n    Return true if something changed.  */\n@@ -95,7 +139,7 @@ try_simplify_condjump (cbranch_block)\n   jump_block = cbranch_fallthru_edge->dest;\n   if (jump_block->pred->pred_next\n       || jump_block->index == n_basic_blocks - 1\n-      || !forwarder_block_p (jump_block))\n+      || !FORWARDER_BLOCK_P (jump_block))\n     return false;\n   jump_dest_block = jump_block->succ->dest;\n \n@@ -163,7 +207,7 @@ try_forward_edges (mode, b)\n       /* Look for the real destination of the jump.\n          Avoid inifinite loop in the infinite empty loop by counting\n          up to n_basic_blocks.  */\n-      while (forwarder_block_p (target)\n+      while (FORWARDER_BLOCK_P (target)\n \t     && target->succ->dest != EXIT_BLOCK_PTR\n \t     && counter < n_basic_blocks)\n \t{\n@@ -220,6 +264,10 @@ try_forward_edges (mode, b)\n \t\t\t\t     + REG_BR_PROB_BASE / 2)\n \t\t\t\t    / REG_BR_PROB_BASE);\n \n+\t      if (!FORWARDER_BLOCK_P (b) && forwarder_block_p (b))\n+\t\tBB_SET_FLAG (b, BB_FORWARDER_BLOCK);\n+\t      BB_SET_FLAG (b, BB_UPDATE_LIFE);\n+\n \t      do\n \t\t{\n \t\t  first->count -= edge_count;\n@@ -384,6 +432,7 @@ merge_blocks (e, b, c, mode)\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       merge_blocks_nomove (b, c);\n+      update_forwarder_flag (b);\n \n       if (rtl_dump_file)\n \t{\n@@ -405,7 +454,7 @@ merge_blocks (e, b, c, mode)\n          eliminated by edge redirection instead.  One exception might have\n \t been if B is a forwarder block and C has no fallthru edge, but\n \t that should be cleaned up by bb-reorder instead.  */\n-      if (forwarder_block_p (b) || forwarder_block_p (c))\n+      if (FORWARDER_BLOCK_P (b) || FORWARDER_BLOCK_P (c))\n \treturn false;\n \n       /* We must make sure to not munge nesting of lexical blocks,\n@@ -441,7 +490,8 @@ merge_blocks (e, b, c, mode)\n \t{\n \t  if (b_fallthru_edge->src == ENTRY_BLOCK_PTR)\n \t    return false;\n-\t  force_nonfallthru (b_fallthru_edge);\n+\t  BB_SET_FLAG (b_fallthru_edge, BB_UPDATE_LIFE);\n+\t  notice_new_block (force_nonfallthru (b_fallthru_edge));\n \t}\n       merge_blocks_move_predecessor_nojumps (b, c);\n       return true;\n@@ -681,18 +731,18 @@ outgoing_edges_match (bb1, bb2)\n \n       /* Get around possible forwarders on fallthru edges.  Other cases\n          should be optimized out already.  */\n-      if (forwarder_block_p (f1->dest))\n+      if (FORWARDER_BLOCK_P (f1->dest))\n \tf1 = f1->dest->succ;\n-      if (forwarder_block_p (f2->dest))\n+      if (FORWARDER_BLOCK_P (f2->dest))\n \tf2 = f2->dest->succ;\n \n       /* To simplify use of this function, return false if there are\n \t unneeded forwarder blocks.  These will get eliminated later\n \t during cleanup_cfg.  */\n-      if (forwarder_block_p (f1->dest)\n-\t  || forwarder_block_p (f2->dest)\n-\t  || forwarder_block_p (b1->dest)\n-\t  || forwarder_block_p (b2->dest))\n+      if (FORWARDER_BLOCK_P (f1->dest)\n+\t  || FORWARDER_BLOCK_P (f2->dest)\n+\t  || FORWARDER_BLOCK_P (b1->dest)\n+\t  || FORWARDER_BLOCK_P (b2->dest))\n \treturn false;\n \n       if (f1->dest == f2->dest && b1->dest == b2->dest)\n@@ -795,14 +845,14 @@ try_crossjump_to_edge (mode, e1, e2)\n      conditional jump that is required due to the current CFG shape.  */\n   if (src1->pred\n       && !src1->pred->pred_next\n-      && forwarder_block_p (src1))\n+      && FORWARDER_BLOCK_P (src1))\n     {\n       e1 = src1->pred;\n       src1 = e1->src;\n     }\n   if (src2->pred\n       && !src2->pred->pred_next\n-      && forwarder_block_p (src2))\n+      && FORWARDER_BLOCK_P (src2))\n     {\n       e2 = src2->pred;\n       src2 = e2->src;\n@@ -815,11 +865,11 @@ try_crossjump_to_edge (mode, e1, e2)\n     return false;\n \n   /* Seeing more than 1 forwarder blocks would confuse us later...  */\n-  if (forwarder_block_p (e1->dest)\n-      && forwarder_block_p (e1->dest->succ->dest))\n+  if (FORWARDER_BLOCK_P (e1->dest)\n+      && FORWARDER_BLOCK_P (e1->dest->succ->dest))\n     return false;\n-  if (forwarder_block_p (e2->dest)\n-      && forwarder_block_p (e2->dest->succ->dest))\n+  if (FORWARDER_BLOCK_P (e2->dest)\n+      && FORWARDER_BLOCK_P (e2->dest->succ->dest))\n     return false;\n \n   /* Likewise with dead code (possibly newly created by the other optimizations\n@@ -867,12 +917,12 @@ try_crossjump_to_edge (mode, e1, e2)\n       edge s2;\n       basic_block d = s->dest;\n \n-      if (forwarder_block_p (d))\n+      if (FORWARDER_BLOCK_P (d))\n \td = d->succ->dest;\n       for (s2 = src1->succ; ; s2 = s2->succ_next)\n \t{\n \t  basic_block d2 = s2->dest;\n-\t  if (forwarder_block_p (d2))\n+\t  if (FORWARDER_BLOCK_P (d2))\n \t    d2 = d2->succ->dest;\n \t  if (d == d2)\n \t    break;\n@@ -882,13 +932,13 @@ try_crossjump_to_edge (mode, e1, e2)\n       /* Take care to update possible forwarder blocks.  We verified\n          that there is no more than one in the chain, so we can't run\n          into infinite loop.  */\n-      if (forwarder_block_p (s->dest))\n+      if (FORWARDER_BLOCK_P (s->dest))\n \t{\n \t  s->dest->succ->count += s2->count;\n \t  s->dest->count += s2->count;\n \t  s->dest->frequency += EDGE_FREQUENCY (s);\n \t}\n-      if (forwarder_block_p (s2->dest))\n+      if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n \t  s2->dest->succ->count -= s2->count;\n \t  s2->dest->count -= s2->count;\n@@ -935,6 +985,9 @@ try_crossjump_to_edge (mode, e1, e2)\n     remove_edge (src1->succ);\n   make_single_succ_edge (src1, redirect_to, 0);\n \n+  BB_SET_FLAG (src1, BB_UPDATE_LIFE);\n+  update_forwarder_flag (src1);\n+\n   return true;\n }\n \n@@ -1048,10 +1101,14 @@ try_optimize_cfg (mode)\n   bool changed_overall = false;\n   bool changed;\n   int iterations = 0;\n+  sbitmap blocks;\n \n   if (mode & CLEANUP_CROSSJUMP)\n     add_noreturn_fake_exit_edges ();\n \n+  for (i = 0; i < n_basic_blocks; i++)\n+    update_forwarder_flag (BASIC_BLOCK (i));\n+\n   /* Attempt to merge blocks as made possible by edge removal.  If a block\n      has only one successor, and the successor has only one predecessor,\n      they may be combined.  */\n@@ -1108,7 +1165,7 @@ try_optimize_cfg (mode)\n \t  if (b->pred->pred_next == NULL\n \t      && (b->pred->flags & EDGE_FALLTHRU)\n \t      && GET_CODE (b->head) != CODE_LABEL\n-\t      && forwarder_block_p (b)\n+\t      && FORWARDER_BLOCK_P (b)\n \t      /* Note that forwarder_block_p true ensures that there\n \t\t is a successor for this block.  */\n \t      && (b->succ->flags & EDGE_FALLTHRU)\n@@ -1151,7 +1208,11 @@ try_optimize_cfg (mode)\n \t      && b->succ->dest != EXIT_BLOCK_PTR\n \t      && onlyjump_p (b->end)\n \t      && redirect_edge_and_branch (b->succ, b->succ->dest))\n-\t    changed_here = true;\n+\t    {\n+\t      BB_SET_FLAG (b, BB_UPDATE_LIFE);\n+\t      update_forwarder_flag (b);\n+\t      changed_here = true;\n+\t    }\n \n \t  /* Simplify branch to branch.  */\n \t  if (try_forward_edges (mode, b))\n@@ -1186,6 +1247,25 @@ try_optimize_cfg (mode)\n   if (mode & CLEANUP_CROSSJUMP)\n     remove_fake_edges ();\n \n+  if ((mode & CLEANUP_UPDATE_LIFE) & changed_overall)\n+    {\n+      bool found = 0;\n+      blocks = sbitmap_alloc (n_basic_blocks);\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tif (BB_FLAGS (BASIC_BLOCK (i)) & BB_UPDATE_LIFE)\n+\t  {\n+\t    found = 1;\n+\t    SET_BIT (blocks, i);\n+\t  }\n+      if (found)\n+\tupdate_life_info (blocks, UPDATE_LIFE_GLOBAL,\n+\t\t\t  PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n+\t\t\t  | PROP_KILL_DEAD_CODE);\n+      sbitmap_free (blocks);\n+    }\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BASIC_BLOCK (i)->aux = NULL;\n+\n   return changed_overall;\n }\n \f\n@@ -1235,8 +1315,5 @@ cleanup_cfg (mode)\n   free_EXPR_LIST_list (&tail_recursion_label_list);\n   timevar_pop (TV_CLEANUP_CFG);\n \n-  /* Clear bb->aux on all basic blocks.  */\n-  for (i = 0; i < n_basic_blocks; ++i)\n-    BASIC_BLOCK (i)->aux = NULL;\n   return changed;\n }"}, {"sha": "5291d9c0d94b5661a44cfccee89a186e1df763ca", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 55, "deletions": 63, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=635559ab2e63321fc138894332e8dc4704aea20f", "patch": "@@ -7908,14 +7908,15 @@ ix86_expand_int_movcc (operands)\n   enum rtx_code code = GET_CODE (operands[1]), compare_code;\n   rtx compare_seq, compare_op;\n   rtx second_test, bypass_test;\n+  enum machine_mode mode = GET_MODE (operands[0]);\n \n   /* When the compare code is not LTU or GEU, we can not use sbbl case.\n      In case comparsion is done with immediate, we can convert it to LTU or\n      GEU by altering the integer.  */\n \n   if ((code == LEU || code == GTU)\n       && GET_CODE (ix86_compare_op1) == CONST_INT\n-      && GET_MODE (operands[0]) != HImode\n+      && mode != HImode\n       && (unsigned int)INTVAL (ix86_compare_op1) != 0xffffffff\n       && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n@@ -7937,8 +7938,8 @@ ix86_expand_int_movcc (operands)\n   /* Don't attempt mode expansion here -- if we had to expand 5 or 6\n      HImode insns, we'd be swallowed in word prefix ops.  */\n \n-  if (GET_MODE (operands[0]) != HImode\n-      && (GET_MODE (operands[0]) != DImode || TARGET_64BIT)\n+  if (mode != HImode\n+      && (mode != DImode || TARGET_64BIT)\n       && GET_CODE (operands[2]) == CONST_INT\n       && GET_CODE (operands[3]) == CONST_INT)\n     {\n@@ -7967,10 +7968,10 @@ ix86_expand_int_movcc (operands)\n \n \t  if (reg_overlap_mentioned_p (out, ix86_compare_op0)\n \t      || reg_overlap_mentioned_p (out, ix86_compare_op1))\n-\t    tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+\t    tmp = gen_reg_rtx (mode);\n \n \t  emit_insn (compare_seq);\n-\t  if (GET_MODE (tmp) == DImode)\n+\t  if (mode == DImode)\n \t    emit_insn (gen_x86_movdicc_0_m1_rex64 (tmp));\n \t  else\n \t    emit_insn (gen_x86_movsicc_0_m1 (tmp));\n@@ -7985,12 +7986,9 @@ ix86_expand_int_movcc (operands)\n \t       * Size 5 - 8.\n \t       */\n \t      if (ct)\n-\t\t{\n-\t\t  if (GET_MODE (tmp) == DImode)\n-\t            emit_insn (gen_adddi3 (tmp, tmp, GEN_INT (ct)));\n-\t\t  else\n-\t            emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (ct)));\n-\t\t}\n+\t       \ttmp = expand_simple_binop (mode, PLUS,\n+\t\t\t\t\t   tmp, GEN_INT (ct),\n+\t\t\t\t\t   tmp, 1, OPTAB_DIRECT);\n \t    }\n \t  else if (cf == -1)\n \t    {\n@@ -8001,10 +7999,9 @@ ix86_expand_int_movcc (operands)\n \t       *\n \t       * Size 8.\n \t       */\n-\t      if (GET_MODE (tmp) == DImode)\n-\t\temit_insn (gen_iordi3 (tmp, tmp, GEN_INT (ct)));\n-\t      else\n-\t\temit_insn (gen_iorsi3 (tmp, tmp, GEN_INT (ct)));\n+\t      tmp = expand_simple_binop (mode, IOR,\n+\t\t\t\t\t tmp, GEN_INT (ct),\n+\t\t\t\t\t tmp, 1, OPTAB_DIRECT);\n \t    }\n \t  else if (diff == -1 && ct)\n \t    {\n@@ -8016,18 +8013,11 @@ ix86_expand_int_movcc (operands)\n \t       *\n \t       * Size 8 - 11.\n \t       */\n-\t      if (GET_MODE (tmp) == DImode)\n-\t        {\n-\t\t  emit_insn (gen_one_cmpldi2 (tmp, tmp));\n-\t\t  if (cf)\n-\t\t    emit_insn (gen_adddi3 (tmp, tmp, GEN_INT (cf)));\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  emit_insn (gen_one_cmplsi2 (tmp, tmp));\n-\t\t  if (cf)\n-\t\t    emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (cf)));\n-\t\t}\n+\t      tmp = expand_simple_unop (mode, NOT, tmp, tmp, 1);\n+\t      if (cf)\n+\t       \ttmp = expand_simple_binop (mode, PLUS,\n+\t\t\t\t\t   tmp, GEN_INT (cf),\n+\t\t\t\t\t   tmp, 1, OPTAB_DIRECT);\n \t    }\n \t  else\n \t    {\n@@ -8039,20 +8029,15 @@ ix86_expand_int_movcc (operands)\n \t       *\n \t       * Size 8 - 11.\n \t       */\n-\t      if (GET_MODE (tmp) == DImode)\n-\t        {\n-\t\t  emit_insn (gen_anddi3 (tmp, tmp, GEN_INT (trunc_int_for_mode\n-\t\t\t\t\t\t\t    (cf - ct, DImode))));\n-\t\t  if (ct)\n-\t\t    emit_insn (gen_adddi3 (tmp, tmp, GEN_INT (ct)));\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  emit_insn (gen_andsi3 (tmp, tmp, GEN_INT (trunc_int_for_mode\n-\t\t\t\t\t\t\t    (cf - ct, SImode))));\n-\t\t  if (ct)\n-\t\t    emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (ct)));\n-\t\t}\n+\t      tmp = expand_simple_binop (mode, AND,\n+\t\t\t\t\t tmp,\n+\t\t\t\t\t GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t\t  (cf - ct, mode)),\n+\t\t\t\t\t tmp, 1, OPTAB_DIRECT);\n+\t      if (ct)\n+\t       \ttmp = expand_simple_binop (mode, PLUS,\n+\t\t\t\t\t   tmp, GEN_INT (ct),\n+\t\t\t\t\t   tmp, 1, OPTAB_DIRECT);\n \t    }\n \n \t  if (tmp != out)\n@@ -8082,8 +8067,9 @@ ix86_expand_int_movcc (operands)\n \t      code = reverse_condition (code);\n \t    }\n \t}\n-      if (diff == 1 || diff == 2 || diff == 4 || diff == 8\n-\t  || diff == 3 || diff == 5 || diff == 9)\n+      if ((diff == 1 || diff == 2 || diff == 4 || diff == 8\n+\t   || diff == 3 || diff == 5 || diff == 9)\n+\t  && (mode != DImode || x86_64_sign_extended_value (GEN_INT (cf))))\n \t{\n \t  /*\n \t   * xorl dest,dest\n@@ -8111,17 +8097,17 @@ ix86_expand_int_movcc (operands)\n \t    {\n \t      rtx out1;\n \t      out1 = out;\n-\t      tmp = gen_rtx_MULT (GET_MODE (out), out1, GEN_INT (diff & ~1));\n+\t      tmp = gen_rtx_MULT (mode, out1, GEN_INT (diff & ~1));\n \t      nops++;\n \t      if (diff & 1)\n \t\t{\n-\t\t  tmp = gen_rtx_PLUS (GET_MODE (out), tmp, out1);\n+\t\t  tmp = gen_rtx_PLUS (mode, tmp, out1);\n \t\t  nops++;\n \t\t}\n \t    }\n \t  if (cf != 0)\n \t    {\n-\t      tmp = gen_rtx_PLUS (GET_MODE (out), tmp, GEN_INT (cf));\n+\t      tmp = gen_rtx_PLUS (mode, tmp, GEN_INT (cf));\n \t      nops++;\n \t    }\n \t  if (tmp != out\n@@ -8191,11 +8177,17 @@ ix86_expand_int_movcc (operands)\n \t  out = emit_store_flag (out, code, ix86_compare_op0,\n \t\t\t\t ix86_compare_op1, VOIDmode, 0, 1);\n \n-\t  emit_insn (gen_addsi3 (out, out, constm1_rtx));\n-\t  emit_insn (gen_andsi3 (out, out, GEN_INT (trunc_int_for_mode\n-\t\t\t\t\t\t    (cf - ct, SImode))));\n-\t  if (ct != 0)\n-\t    emit_insn (gen_addsi3 (out, out, GEN_INT (ct)));\n+\t  out = expand_simple_binop (mode, PLUS,\n+\t\t\t\t     out, constm1_rtx,\n+\t\t\t\t     out, 1, OPTAB_DIRECT);\n+\t  out = expand_simple_binop (mode, AND,\n+\t\t\t\t     out,\n+\t\t\t\t     GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t      (cf - ct, mode)),\n+\t\t\t\t     out, 1, OPTAB_DIRECT);\n+\t  out = expand_simple_binop (mode, PLUS,\n+\t\t\t\t     out, GEN_INT (ct),\n+\t\t\t\t     out, 1, OPTAB_DIRECT);\n \t  if (out != operands[0])\n \t    emit_move_insn (operands[0], out);\n \n@@ -8240,15 +8232,15 @@ ix86_expand_int_movcc (operands)\n         return 0; /* FAIL */\n \n       orig_out = operands[0];\n-      tmp = gen_reg_rtx (GET_MODE (orig_out));\n+      tmp = gen_reg_rtx (mode);\n       operands[0] = tmp;\n \n       /* Recurse to get the constant loaded.  */\n       if (ix86_expand_int_movcc (operands) == 0)\n         return 0; /* FAIL */\n \n       /* Mask in the interesting variable.  */\n-      out = expand_binop (GET_MODE (orig_out), op, var, tmp, orig_out, 0,\n+      out = expand_binop (mode, op, var, tmp, orig_out, 0,\n \t\t\t  OPTAB_WIDEN);\n       if (out != orig_out)\n \temit_move_insn (orig_out, out);\n@@ -8267,41 +8259,41 @@ ix86_expand_int_movcc (operands)\n    * Size 15.\n    */\n \n-  if (! nonimmediate_operand (operands[2], GET_MODE (operands[0])))\n-    operands[2] = force_reg (GET_MODE (operands[0]), operands[2]);\n-  if (! nonimmediate_operand (operands[3], GET_MODE (operands[0])))\n-    operands[3] = force_reg (GET_MODE (operands[0]), operands[3]);\n+  if (! nonimmediate_operand (operands[2], mode))\n+    operands[2] = force_reg (mode, operands[2]);\n+  if (! nonimmediate_operand (operands[3], mode))\n+    operands[3] = force_reg (mode, operands[3]);\n \n   if (bypass_test && reg_overlap_mentioned_p (operands[0], operands[3]))\n     {\n-      rtx tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      rtx tmp = gen_reg_rtx (mode);\n       emit_move_insn (tmp, operands[3]);\n       operands[3] = tmp;\n     }\n   if (second_test && reg_overlap_mentioned_p (operands[0], operands[2]))\n     {\n-      rtx tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      rtx tmp = gen_reg_rtx (mode);\n       emit_move_insn (tmp, operands[2]);\n       operands[2] = tmp;\n     }\n   if (! register_operand (operands[2], VOIDmode)\n       && ! register_operand (operands[3], VOIDmode))\n-    operands[2] = force_reg (GET_MODE (operands[0]), operands[2]);\n+    operands[2] = force_reg (mode, operands[2]);\n \n   emit_insn (compare_seq);\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t  gen_rtx_IF_THEN_ELSE (mode,\n \t\t\t\t\t\tcompare_op, operands[2],\n \t\t\t\t\t\toperands[3])));\n   if (bypass_test)\n     emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t    gen_rtx_IF_THEN_ELSE (mode,\n \t\t\t\t  bypass_test,\n \t\t\t\t  operands[3],\n \t\t\t\t  operands[0])));\n   if (second_test)\n     emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t    gen_rtx_IF_THEN_ELSE (mode,\n \t\t\t\t  second_test,\n \t\t\t\t  operands[2],\n \t\t\t\t  operands[0])));"}, {"sha": "1320013cb476407a23207034bc0490b4c7757de6", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635559ab2e63321fc138894332e8dc4704aea20f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=635559ab2e63321fc138894332e8dc4704aea20f", "patch": "@@ -3309,20 +3309,7 @@ rest_of_compilation (decl)\n \t  rebuild_jump_labels (insns);\n \t  timevar_pop (TV_JUMP);\n \n-\t  timevar_push (TV_FLOW);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-\t  /* Blimey.  We've got to have the CFG up to date for the call to\n-\t     if_convert below.  However, the random deletion of blocks\n-\t     without updating life info can wind up with Wierd Stuff in\n-\t     global_live_at_end.  We then run sched1, which updates things\n-\t     properly, discovers the wierdness and aborts.  */\n-\t  allocate_bb_life_data ();\n-\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t    PROP_DEATH_NOTES | PROP_KILL_DEAD_CODE\n-\t\t\t    | PROP_SCAN_DEAD_CODE);\n-\n-\t  timevar_pop (TV_FLOW);\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n \t}\n \n       close_dump_file (DFI_combine, print_rtl_with_bb, insns);"}]}