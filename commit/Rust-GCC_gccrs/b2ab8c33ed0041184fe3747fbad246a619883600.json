{"sha": "b2ab8c33ed0041184fe3747fbad246a619883600", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJhYjhjMzNlZDAwNDExODRmZTM3NDdmYmFkMjQ2YTYxOTg4MzYwMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T13:52:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T13:52:11Z"}, "message": "[multiple changes]\n\n2011-11-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_alfa.adb: Add with and use clauses for Exp_Ch8 and\n\tSem_Util.\n\t(Expand_Alfa): Alphabetize cases on first choice. Add\n\tprocessing for object renaming declarations, identifiers and\n\texpanded names.\n\t(Expand_Alfa_N_In): Remove useless return.\n\t(Expand_Alfa_N_Object_Renaming_Declaration): New routine.\n\t(Expand_Potential_Renaming): New routine.\n\t* exp_ch8.adb (Evaluate_Name): Moved to the top level.\n\t(Expand_N_Object_Declaration): Alphabetize local variables. Move\n\tEvaluate_Name out to the top level.\n\t* exp_ch8.ads (Evaluate_Name): Moved from body to package spec.\n\t* exp_util.adb (Remove_Side_Effects): Add processing for\n\tfunctions with side effects in Alfa mode.\n\n2011-11-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* gnat_rm.texi: Add entries for\n\trestrictions No_Relative_Delay, No_Requeue_Statements and\n\tNo_Stream_Optimizations.\n\n2011-11-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb: Set type of entity in prefixed call, for\n\tcompleteness in a generic context.\n\nFrom-SVN: r180951", "tree": {"sha": "7f53d4867b8bca91dd3be1c563430e99336b44b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f53d4867b8bca91dd3be1c563430e99336b44b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2ab8c33ed0041184fe3747fbad246a619883600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ab8c33ed0041184fe3747fbad246a619883600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ab8c33ed0041184fe3747fbad246a619883600", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ab8c33ed0041184fe3747fbad246a619883600/comments", "author": null, "committer": null, "parents": [{"sha": "4c3182538905f7e806afcf2358825cce22183991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c3182538905f7e806afcf2358825cce22183991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c3182538905f7e806afcf2358825cce22183991"}], "stats": {"total": 390, "additions": 254, "deletions": 136}, "files": [{"sha": "392c0b19f8c7f943c16e2d672deb6477c4edc65d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -1,3 +1,31 @@\n+2011-11-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_alfa.adb: Add with and use clauses for Exp_Ch8 and\n+\tSem_Util.\n+\t(Expand_Alfa): Alphabetize cases on first choice. Add\n+\tprocessing for object renaming declarations, identifiers and\n+\texpanded names.\n+\t(Expand_Alfa_N_In): Remove useless return.\n+\t(Expand_Alfa_N_Object_Renaming_Declaration): New routine.\n+\t(Expand_Potential_Renaming): New routine.\n+\t* exp_ch8.adb (Evaluate_Name): Moved to the top level.\n+\t(Expand_N_Object_Declaration): Alphabetize local variables. Move\n+\tEvaluate_Name out to the top level.\n+\t* exp_ch8.ads (Evaluate_Name): Moved from body to package spec.\n+\t* exp_util.adb (Remove_Side_Effects): Add processing for\n+\tfunctions with side effects in Alfa mode.\n+\n+2011-11-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat_rm.texi: Add entries for\n+\trestrictions No_Relative_Delay, No_Requeue_Statements and\n+\tNo_Stream_Optimizations.\n+\n+2011-11-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb: Set type of entity in prefixed call, for\n+\tcompleteness in a generic context.\n+\n 2011-11-04  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb: Minor refactoring (renaming of a parameter)."}, {"sha": "7dcecfd9df72c425fb3cdfb86e5c8c23aff8ecc0", "filename": "gcc/ada/exp_alfa.adb", "status": "modified", "additions": 53, "deletions": 11, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.adb?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -28,11 +28,13 @@ with Einfo;    use Einfo;\n with Exp_Attr; use Exp_Attr;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Ch8;  use Exp_Ch8;\n with Exp_Dbug; use Exp_Dbug;\n with Nlists;   use Nlists;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n@@ -56,42 +58,55 @@ package body Exp_Alfa is\n    procedure Expand_Alfa_N_In (N : Node_Id);\n    --  Expand set membership into individual ones\n \n+   procedure Expand_Alfa_N_Object_Renaming_Declaration (N : Node_Id);\n+   --  Perform name evaluation for a renamed object\n+\n    procedure Expand_Alfa_N_Simple_Return_Statement (N : Node_Id);\n    --  Insert conversion on function return if necessary\n \n    procedure Expand_Alfa_Simple_Function_Return (N : Node_Id);\n    --  Expand simple return from function\n \n+   procedure Expand_Potential_Renaming (N : Node_Id);\n+   --  N denotes a N_Identifier or N_Expanded_Name. If N references a renaming,\n+   --  replace N with the renamed object.\n+\n    -----------------\n    -- Expand_Alfa --\n    -----------------\n \n    procedure Expand_Alfa (N : Node_Id) is\n    begin\n       case Nkind (N) is\n+         when N_Attribute_Reference =>\n+            Expand_Alfa_N_Attribute_Reference (N);\n \n-         when N_Package_Body        |\n+         when N_Block_Statement     |\n+              N_Package_Body        |\n               N_Package_Declaration |\n-              N_Subprogram_Body     |\n-              N_Block_Statement     =>\n+              N_Subprogram_Body     =>\n             Qualify_Entity_Names (N);\n \n-         when N_Simple_Return_Statement =>\n-            Expand_Alfa_N_Simple_Return_Statement (N);\n-\n          when N_Function_Call            |\n               N_Procedure_Call_Statement =>\n             Expand_Alfa_Call (N);\n \n-         when N_Attribute_Reference =>\n-            Expand_Alfa_N_Attribute_Reference (N);\n+         when N_Expanded_Name |\n+              N_Identifier    =>\n+            Expand_Potential_Renaming (N);\n \n          when N_In =>\n             Expand_Alfa_N_In (N);\n \n          when N_Not_In =>\n             Expand_N_Not_In (N);\n \n+         when N_Object_Renaming_Declaration =>\n+            Expand_Alfa_N_Object_Renaming_Declaration (N);\n+\n+         when N_Simple_Return_Statement =>\n+            Expand_Alfa_N_Simple_Return_Statement (N);\n+\n          when others =>\n             null;\n       end case;\n@@ -157,7 +172,6 @@ package body Exp_Alfa is\n \n          Set_Entity (Name (Call_Node), Parent_Subp);\n       end if;\n-\n    end Expand_Alfa_Call;\n \n    ---------------------------------------\n@@ -186,10 +200,20 @@ package body Exp_Alfa is\n    begin\n       if Present (Alternatives (N)) then\n          Expand_Set_Membership (N);\n-         return;\n       end if;\n    end Expand_Alfa_N_In;\n \n+   -----------------------------------------------\n+   -- Expand_Alfa_N_Object_Renaming_Declaration --\n+   -----------------------------------------------\n+\n+   procedure Expand_Alfa_N_Object_Renaming_Declaration (N : Node_Id) is\n+   begin\n+      --  Unconditionally remove all side effects from the name\n+\n+      Evaluate_Name (Name (N));\n+   end Expand_Alfa_N_Object_Renaming_Declaration;\n+\n    -------------------------------------------\n    -- Expand_Alfa_N_Simple_Return_Statement --\n    -------------------------------------------\n@@ -218,7 +242,6 @@ package body Exp_Alfa is\n               E_Entry             |\n               E_Entry_Family      |\n               E_Return_Statement =>\n-            --  Expand_Non_Function_Return (N);\n             null;\n \n          when others =>\n@@ -265,4 +288,23 @@ package body Exp_Alfa is\n       end if;\n    end Expand_Alfa_Simple_Function_Return;\n \n+   -------------------------------\n+   -- Expand_Potential_Renaming --\n+   -------------------------------\n+\n+   procedure Expand_Potential_Renaming (N : Node_Id) is\n+      E : constant Entity_Id := Entity (N);\n+      T : constant Entity_Id := Etype (N);\n+\n+   begin\n+      --  Substitute a reference to a renaming with the actual renamed object\n+\n+      if Present (Renamed_Object (E)) then\n+         Rewrite (N, New_Copy_Tree (Renamed_Object (E)));\n+\n+         Reset_Analyzed_Flags (N);\n+         Analyze_And_Resolve (N, T);\n+      end if;\n+   end Expand_Potential_Renaming;\n+\n end Exp_Alfa;"}, {"sha": "c1fc7e8bc675da93290a0129c30aa9e1c9f0b75a", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 103, "deletions": 106, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,6 +44,100 @@ with Tbuild;   use Tbuild;\n \n package body Exp_Ch8 is\n \n+   -------------------\n+   -- Evaluate_Name --\n+   -------------------\n+\n+   procedure Evaluate_Name (Nam : Node_Id) is\n+      K : constant Node_Kind := Nkind (Nam);\n+\n+   begin\n+      --  For an explicit dereference, we simply force the evaluation of the\n+      --  name expression. The dereference provides a value that is the address\n+      --  for the renamed object, and it is precisely this value that we want\n+      --  to preserve.\n+\n+      if K = N_Explicit_Dereference then\n+         Force_Evaluation (Prefix (Nam));\n+\n+      --  For a selected component, we simply evaluate the prefix\n+\n+      elsif K = N_Selected_Component then\n+         Evaluate_Name (Prefix (Nam));\n+\n+      --  For an indexed component, or an attribute reference, we evaluate the\n+      --  prefix, which is itself a name, recursively, and then force the\n+      --  evaluation of all the subscripts (or attribute expressions).\n+\n+      elsif Nkind_In (K, N_Indexed_Component, N_Attribute_Reference) then\n+         Evaluate_Name (Prefix (Nam));\n+\n+         declare\n+            E : Node_Id;\n+\n+         begin\n+            E := First (Expressions (Nam));\n+            while Present (E) loop\n+               Force_Evaluation (E);\n+\n+               if Original_Node (E) /= E then\n+                  Set_Do_Range_Check (E, Do_Range_Check (Original_Node (E)));\n+               end if;\n+\n+               Next (E);\n+            end loop;\n+         end;\n+\n+      --  For a slice, we evaluate the prefix, as for the indexed component\n+      --  case and then, if there is a range present, either directly or as the\n+      --  constraint of a discrete subtype indication, we evaluate the two\n+      --  bounds of this range.\n+\n+      elsif K = N_Slice then\n+         Evaluate_Name (Prefix (Nam));\n+\n+         declare\n+            DR     : constant Node_Id := Discrete_Range (Nam);\n+            Constr : Node_Id;\n+            Rexpr  : Node_Id;\n+\n+         begin\n+            if Nkind (DR) = N_Range then\n+               Force_Evaluation (Low_Bound (DR));\n+               Force_Evaluation (High_Bound (DR));\n+\n+            elsif Nkind (DR) = N_Subtype_Indication then\n+               Constr := Constraint (DR);\n+\n+               if Nkind (Constr) = N_Range_Constraint then\n+                  Rexpr := Range_Expression (Constr);\n+\n+                  Force_Evaluation (Low_Bound (Rexpr));\n+                  Force_Evaluation (High_Bound (Rexpr));\n+               end if;\n+            end if;\n+         end;\n+\n+      --  For a type conversion, the expression of the conversion must be the\n+      --  name of an object, and we simply need to evaluate this name.\n+\n+      elsif K = N_Type_Conversion then\n+         Evaluate_Name (Expression (Nam));\n+\n+      --  For a function call, we evaluate the call\n+\n+      elsif K = N_Function_Call then\n+         Force_Evaluation (Nam);\n+\n+      --  The remaining cases are direct name, operator symbol and character\n+      --  literal. In all these cases, we do nothing, since we want to\n+      --  reevaluate each time the renamed object is used.\n+\n+      else\n+         return;\n+      end if;\n+   end Evaluate_Name;\n+\n    ---------------------------------------------\n    -- Expand_N_Exception_Renaming_Declaration --\n    ---------------------------------------------\n@@ -91,114 +185,17 @@ package body Exp_Ch8 is\n \n    procedure Expand_N_Object_Renaming_Declaration (N : Node_Id) is\n       Nam  : constant Node_Id := Name (N);\n-      T    : Entity_Id;\n       Decl : Node_Id;\n-\n-      procedure Evaluate_Name (Fname : Node_Id);\n-      --  A recursive procedure used to freeze a name in the sense described\n-      --  above, i.e. any variable references or function calls are removed.\n-      --  Of course the outer level variable reference must not be removed.\n-      --  For example in A(J,F(K)), A is left as is, but J and F(K) are\n-      --  evaluated and removed.\n+      T    : Entity_Id;\n \n       function Evaluation_Required (Nam : Node_Id) return Boolean;\n-      --  Determines whether it is necessary to do static name evaluation\n-      --  for renaming of Nam. It is considered necessary if evaluating the\n-      --  name involves indexing a packed array, or extracting a component\n-      --  of a record to which a component clause applies. Note that we are\n-      --  only interested in these operations if they occur as part of the\n-      --  name itself, subscripts are just values that are computed as part\n-      --  of the evaluation, so their form is unimportant.\n-\n-      -------------------\n-      -- Evaluate_Name --\n-      -------------------\n-\n-      procedure Evaluate_Name (Fname : Node_Id) is\n-         K : constant Node_Kind := Nkind (Fname);\n-         E : Node_Id;\n-\n-      begin\n-         --  For an explicit dereference, we simply force the evaluation\n-         --  of the name expression. The dereference provides a value that\n-         --  is the address for the renamed object, and it is precisely\n-         --  this value that we want to preserve.\n-\n-         if K = N_Explicit_Dereference then\n-            Force_Evaluation (Prefix (Fname));\n-\n-         --  For a selected component, we simply evaluate the prefix\n-\n-         elsif K = N_Selected_Component then\n-            Evaluate_Name (Prefix (Fname));\n-\n-         --  For an indexed component, or an attribute reference, we evaluate\n-         --  the prefix, which is itself a name, recursively, and then force\n-         --  the evaluation of all the subscripts (or attribute expressions).\n-\n-         elsif Nkind_In (K, N_Indexed_Component, N_Attribute_Reference) then\n-            Evaluate_Name (Prefix (Fname));\n-\n-            E := First (Expressions (Fname));\n-            while Present (E) loop\n-               Force_Evaluation (E);\n-\n-               if Original_Node (E) /= E then\n-                  Set_Do_Range_Check (E, Do_Range_Check (Original_Node (E)));\n-               end if;\n-\n-               Next (E);\n-            end loop;\n-\n-         --  For a slice, we evaluate the prefix, as for the indexed component\n-         --  case and then, if there is a range present, either directly or\n-         --  as the constraint of a discrete subtype indication, we evaluate\n-         --  the two bounds of this range.\n-\n-         elsif K = N_Slice then\n-            Evaluate_Name (Prefix (Fname));\n-\n-            declare\n-               DR     : constant Node_Id := Discrete_Range (Fname);\n-               Constr : Node_Id;\n-               Rexpr  : Node_Id;\n-\n-            begin\n-               if Nkind (DR) = N_Range then\n-                  Force_Evaluation (Low_Bound (DR));\n-                  Force_Evaluation (High_Bound (DR));\n-\n-               elsif Nkind (DR) = N_Subtype_Indication then\n-                  Constr := Constraint (DR);\n-\n-                  if Nkind (Constr) = N_Range_Constraint then\n-                     Rexpr := Range_Expression (Constr);\n-\n-                     Force_Evaluation (Low_Bound (Rexpr));\n-                     Force_Evaluation (High_Bound (Rexpr));\n-                  end if;\n-               end if;\n-            end;\n-\n-         --  For a type conversion, the expression of the conversion must be\n-         --  the name of an object, and we simply need to evaluate this name.\n-\n-         elsif K = N_Type_Conversion then\n-            Evaluate_Name (Expression (Fname));\n-\n-         --  For a function call, we evaluate the call\n-\n-         elsif K = N_Function_Call then\n-            Force_Evaluation (Fname);\n-\n-         --  The remaining cases are direct name, operator symbol and\n-         --  character literal. In all these cases, we do nothing, since\n-         --  we want to reevaluate each time the renamed object is used.\n-\n-         else\n-            return;\n-         end if;\n-      end Evaluate_Name;\n+      --  Determines whether it is necessary to do static name evaluation for\n+      --  renaming of Nam. It is considered necessary if evaluating the name\n+      --  involves indexing a packed array, or extracting a component of a\n+      --  record to which a component clause applies. Note that we are only\n+      --  interested in these operations if they occur as part of the name\n+      --  itself, subscripts are just values that are computed as part of the\n+      --  evaluation, so their form is unimportant.\n \n       -------------------------\n       -- Evaluation_Required --"}, {"sha": "b5056ab2e7fccbe0c76205a9ec2ac0266a789969", "filename": "gcc/ada/exp_ch8.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.ads?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,4 +32,9 @@ package Exp_Ch8 is\n    procedure Expand_N_Object_Renaming_Declaration     (N : Node_Id);\n    procedure Expand_N_Package_Renaming_Declaration    (N : Node_Id);\n    procedure Expand_N_Subprogram_Renaming_Declaration (N : Node_Id);\n+\n+   procedure Evaluate_Name (Nam : Node_Id);\n+   --  Remove the all side effects from a name except for the outermost\n+   --  construct.\n+\n end Exp_Ch8;"}, {"sha": "8281ded0c30a17c8702d46c4ddb58f6240156891", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -6531,32 +6531,57 @@ package body Exp_Util is\n             end;\n          end if;\n \n-         Ref_Type := Make_Temporary (Loc, 'A');\n+         Def_Id := Make_Temporary (Loc, 'R', Exp);\n+         Set_Etype (Def_Id, Exp_Type);\n \n-         Ptr_Typ_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Ref_Type,\n-             Type_Definition =>\n-               Make_Access_To_Object_Definition (Loc,\n-                 All_Present => True,\n-                 Subtype_Indication =>\n-                   New_Reference_To (Exp_Type, Loc)));\n+         --  The regular expansion of functions with side effects involves the\n+         --  generation of an access type to capture the return value found on\n+         --  the secondary stack. Since Alfa (and why) cannot process access\n+         --  types, use a different approach which ignores the secondary stack\n+         --  and \"copies\" the returned object.\n \n-         E := Exp;\n-         Insert_Action (Exp, Ptr_Typ_Decl);\n+         if Alfa_Mode then\n+            Res := New_Reference_To (Def_Id, Loc);\n+            Ref_Type := Exp_Type;\n \n-         Def_Id := Make_Temporary (Loc, 'R', Exp);\n-         Set_Etype (Def_Id, Exp_Type);\n+         --  Regular expansion utilizing an access type and 'reference\n \n-         Res :=\n-           Make_Explicit_Dereference (Loc,\n-             Prefix => New_Reference_To (Def_Id, Loc));\n+         else\n+            Res :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Reference_To (Def_Id, Loc));\n+\n+            --  Generate:\n+            --    type Ann is access all <Exp_Type>;\n \n+            Ref_Type := Make_Temporary (Loc, 'A');\n+\n+            Ptr_Typ_Decl :=\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Ref_Type,\n+                Type_Definition     =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present        => True,\n+                    Subtype_Indication =>\n+                      New_Reference_To (Exp_Type, Loc)));\n+\n+            Insert_Action (Exp, Ptr_Typ_Decl);\n+         end if;\n+\n+         E := Exp;\n          if Nkind (E) = N_Explicit_Dereference then\n             New_Exp := Relocate_Node (Prefix (E));\n          else\n             E := Relocate_Node (E);\n-            New_Exp := Make_Reference (Loc, E);\n+\n+            --  Do not generate a 'reference in Alfa since the access type is\n+            --  not generated.\n+\n+            if Alfa_Mode then\n+               New_Exp := E;\n+            else\n+               New_Exp := Make_Reference (Loc, E);\n+            end if;\n          end if;\n \n          if Is_Delayed_Aggregate (E) then"}, {"sha": "dd9f55168a97ea6a265ab299ad4d7185aafdc0c1", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -9124,6 +9124,17 @@ only declared at the library level.\n This restriction ensures at compile time that there are no allocator\n expressions that attempt to allocate protected objects.\n \n+@item No_Relative_Delay\n+@findex No_Relative_Delay\n+This restriction ensures at compile time that there are no delay relative\n+statements and prevents expressions such as @code{delay 1.23;} from appearing\n+in source code.\n+\n+@item No_Requeue_Statements\n+@findex No_Requeue_Statements\n+This restriction ensures at compile time that no requeue statements are\n+permitted and prevents keyword @code{requeue} from being used in source code.\n+\n @item No_Secondary_Stack\n @findex No_Secondary_Stack\n This restriction ensures at compile time that the generated code does not\n@@ -9145,6 +9156,14 @@ use the standard default storage pool.  Any access type declared must\n have an explicit Storage_Pool attribute defined specifying a\n user-defined storage pool.\n \n+@item No_Stream_Optimizations\n+@findex No_Stream_Optimizations\n+This restriction affects the performance of stream operations on types\n+@code{String}, @code{Wide_String} and @code{Wide_Wide_String}. By default, the\n+compiler uses block reads and writes when manipulating @code{String} objects\n+due to their supperior performance. When this restriction is in effect, the\n+compiler performs all IO operations on a per-character basis.\n+\n @item No_Streams\n @findex No_Streams\n This restriction ensures at compile/bind time that there are no"}, {"sha": "1a88e77ede8e8dc7269d4936f5432759674776c4", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2ab8c33ed0041184fe3747fbad246a619883600/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b2ab8c33ed0041184fe3747fbad246a619883600", "patch": "@@ -6863,7 +6863,8 @@ package body Sem_Ch4 is\n          First_Actual := First (Parameter_Associations (Call_Node));\n \n          --  For cross-reference purposes, treat the new node as being in\n-         --  the source if the original one is.\n+         --  the source if the original one is. Set entity and type, even\n+         --  though they may be overwritten during resolution if overloaded.\n \n          Set_Comes_From_Source (Subprog, Comes_From_Source (N));\n          Set_Comes_From_Source (Call_Node, Comes_From_Source (N));\n@@ -6872,6 +6873,7 @@ package body Sem_Ch4 is\n            and then not Inside_A_Generic\n          then\n             Set_Entity (Selector_Name (N), Entity (Subprog));\n+            Set_Etype  (Selector_Name (N), Etype (Entity (Subprog)));\n          end if;\n \n          --  If need be, rewrite first actual as an explicit dereference"}]}