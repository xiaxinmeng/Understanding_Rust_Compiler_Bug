{"sha": "35fb60c476e5c273e1b7b91440e2f227b02028d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVmYjYwYzQ3NmU1YzI3M2UxYjdiOTE0NDBlMmYyMjdiMDIwMjhkMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-06-04T01:58:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-06-04T01:58:24Z"}, "message": "reload.c (reload_inner_reg_of_subreg): Return 1 for PLUS.\n\n\t* reload.c (reload_inner_reg_of_subreg): Return 1 for PLUS.\n\t(push_reload): Handle non-REG in reload_inner_reg_of_subreg case.\n\nFrom-SVN: r42843", "tree": {"sha": "a99733560f926f6f9337641dc2360486231c76fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a99733560f926f6f9337641dc2360486231c76fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35fb60c476e5c273e1b7b91440e2f227b02028d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fb60c476e5c273e1b7b91440e2f227b02028d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fb60c476e5c273e1b7b91440e2f227b02028d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fb60c476e5c273e1b7b91440e2f227b02028d1/comments", "author": null, "committer": null, "parents": [{"sha": "b91455de3df82c050aaf16938f507bbeff8dfebe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91455de3df82c050aaf16938f507bbeff8dfebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91455de3df82c050aaf16938f507bbeff8dfebe"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "e6d8ff537acd4c33f24995a2ce7adb9e212ce37a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fb60c476e5c273e1b7b91440e2f227b02028d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fb60c476e5c273e1b7b91440e2f227b02028d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35fb60c476e5c273e1b7b91440e2f227b02028d1", "patch": "@@ -1,3 +1,8 @@\n+Sun Jun  3 21:59:51 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload.c (reload_inner_reg_of_subreg): Return 1 for PLUS.\n+\t(push_reload): Handle non-REG in reload_inner_reg_of_subreg case.\n+\n 2001-06-03  kaz Kojima  <kkojima@rr.iij4u.or.jp>\n \n \t* gcc/config/sh/sh.c (print_operand_address, print_operand): Call"}, {"sha": "a05c52a833ac10df68baca7a34780ed3761acf93", "filename": "gcc/reload.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fb60c476e5c273e1b7b91440e2f227b02028d1/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fb60c476e5c273e1b7b91440e2f227b02028d1/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=35fb60c476e5c273e1b7b91440e2f227b02028d1", "patch": "@@ -690,6 +690,7 @@ find_valid_class (m1, n)\n    combine.  P_IN points to the corresponding value of IN, which can be\n    modified by this function.\n    DONT_SHARE is nonzero if we can't share any input-only reload for IN.  */\n+\n static int\n find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n      rtx *p_in, out;\n@@ -780,8 +781,8 @@ reload_inner_reg_of_subreg (x, mode)\n \n   inner = SUBREG_REG (x);\n \n-  /* If INNER is a constant, then INNER must be reloaded.  */\n-  if (CONSTANT_P (inner))\n+  /* If INNER is a constant or PLUS, then INNER must be reloaded.  */\n+  if (CONSTANT_P (inner) || GET_CODE (inner) == PLUS)\n     return 1;\n \n   /* If INNER is not a hard register, then INNER will not need to\n@@ -1030,18 +1031,23 @@ push_reload (in, out, inloc, outloc, class,\n \n   if (in != 0 && reload_inner_reg_of_subreg (in, inmode))\n     {\n+      enum reg_class in_class = class;\n+\n+      if (GET_CODE (SUBREG_REG (in)) == REG)\n+\tin_class\n+\t  = find_valid_class (inmode,\n+\t\t\t      subreg_regno_offset (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t\t   GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t\t   SUBREG_BYTE (in),\n+\t\t\t\t\t\t   GET_MODE (in)));\n+\n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for input reloads of type RELOAD_OTHER in the same\n \t order as the reloads.  Thus if the outer reload is also of type\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output before the outer reload.  */\n-      push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), (rtx*)0,\n-\t\t   find_valid_class (inmode,\n-\t\t\t\t     subreg_regno_offset (REGNO (SUBREG_REG (in)),\n-\t\t\t\t\t\t\t  GET_MODE (SUBREG_REG (in)),\n-\t\t\t\t\t\t\t  SUBREG_BYTE (in),\n-\t\t\t\t\t\t\t  GET_MODE (in))),\n-\t\t   VOIDmode, VOIDmode, 0, 0, opnum, type);\n+      push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_RTX,\n+\t\t   in_class, VOIDmode, VOIDmode, 0, 0, opnum, type);\n       dont_remove_subreg = 1;\n     }\n "}]}