{"sha": "3615b8c2004057ce9cc64a449d0f9a88214e8997", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxNWI4YzIwMDQwNTdjZTljYzY0YTQ0OWQwZjlhODgyMTRlODk5Nw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2007-12-18T19:40:35Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-12-18T19:40:35Z"}, "message": "re PR tree-optimization/34123 (verify_ssa failed with -ftree-loop-linear)\n\n2007-12-18  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/34123\n\t* lambda-code.c (can_duplicate_iv): New.\n\t(cannot_convert_modify_to_perfect_nest): New.\n\t(cannot_convert_bb_to_perfect_nest): New.\n\t(can_convert_to_perfect_nest): Split up.\n\n\t* gcc.dg/tree-ssa/pr34123.c: New test.\n\nFrom-SVN: r131040", "tree": {"sha": "ae13d73b1dc25d00be82d6fd2f66f0a92a230242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae13d73b1dc25d00be82d6fd2f66f0a92a230242"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3615b8c2004057ce9cc64a449d0f9a88214e8997", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3615b8c2004057ce9cc64a449d0f9a88214e8997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3615b8c2004057ce9cc64a449d0f9a88214e8997", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3615b8c2004057ce9cc64a449d0f9a88214e8997/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d0f690c5daed0f448979e4de55d3150d8a4f2ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d0f690c5daed0f448979e4de55d3150d8a4f2ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d0f690c5daed0f448979e4de55d3150d8a4f2ad"}], "stats": {"total": 259, "additions": 158, "deletions": 101}, "files": [{"sha": "94ff58edb3bbedec3f0b5d5c3b17ee71dffdb49f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3615b8c2004057ce9cc64a449d0f9a88214e8997", "patch": "@@ -1,3 +1,11 @@\n+2007-12-18  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/34123\n+\t* lambda-code.c (can_duplicate_iv): New.\n+\t(cannot_convert_modify_to_perfect_nest): New.\n+\t(cannot_convert_bb_to_perfect_nest): New.\n+\t(can_convert_to_perfect_nest): Split up.\n+\n 2007-12-18  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/mips.md (clear_hazard): Use PRINT_OPERAND punctuation"}, {"sha": "e38b9703f3732b64c6a4ce3e63cbb5a844b87441", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 127, "deletions": 101, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=3615b8c2004057ce9cc64a449d0f9a88214e8997", "patch": "@@ -2177,7 +2177,128 @@ can_put_after_inner_loop (struct loop *loop, tree stmt)\n   return true;\n }\n \n+/* Return true when the induction variable IV is simple enough to be\n+   re-synthesized.  */\n \n+static bool\n+can_duplicate_iv (tree iv, struct loop *loop)\n+{\n+  tree scev = instantiate_parameters\n+    (loop, analyze_scalar_evolution (loop, iv));\n+\n+  if (!automatically_generated_chrec_p (scev))\n+    {\n+      tree step = evolution_part_in_loop_num (scev, loop->num);\n+\n+      if (step && step != chrec_dont_know && TREE_CODE (step) == INTEGER_CST)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* If this is a scalar operation that can be put back into the inner\n+   loop, or after the inner loop, through copying, then do so. This\n+   works on the theory that any amount of scalar code we have to\n+   reduplicate into or after the loops is less expensive that the win\n+   we get from rearranging the memory walk the loop is doing so that\n+   it has better cache behavior.  */\n+\n+static bool\n+cannot_convert_modify_to_perfect_nest (tree stmt, struct loop *loop)\n+{\n+  \n+  use_operand_p use_a, use_b;\n+  imm_use_iterator imm_iter;\n+  ssa_op_iter op_iter, op_iter1;\n+  tree op0 = GIMPLE_STMT_OPERAND (stmt, 0);\n+\n+  /* The statement should not define a variable used in the inner\n+     loop.  */\n+  if (TREE_CODE (op0) == SSA_NAME\n+      && !can_duplicate_iv (op0, loop))\n+    FOR_EACH_IMM_USE_FAST (use_a, imm_iter, op0)\n+      if (bb_for_stmt (USE_STMT (use_a))->loop_father\n+\t  == loop->inner)\n+\treturn true;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_a, stmt, op_iter, SSA_OP_USE)\n+    {\n+      tree node, op = USE_FROM_PTR (use_a);\n+\n+      /* The variables should not be used in both loops.  */\n+      if (!can_duplicate_iv (op, loop))\n+\tFOR_EACH_IMM_USE_FAST (use_b, imm_iter, op)\n+\t  if (bb_for_stmt (USE_STMT (use_b))->loop_father\n+\t      == loop->inner)\n+\t    return true;\n+\n+      /* The statement should not use the value of a scalar that was\n+\t modified in the loop.  */\n+      node = SSA_NAME_DEF_STMT (op);\n+      if (TREE_CODE (node) == PHI_NODE)\n+\tFOR_EACH_PHI_ARG (use_b, node, op_iter1, SSA_OP_USE)\n+\t{\n+\t  tree arg = USE_FROM_PTR (use_b);\n+\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      tree arg_stmt = SSA_NAME_DEF_STMT (arg);\n+\n+\t      if (bb_for_stmt (arg_stmt)\n+\t\t  && (bb_for_stmt (arg_stmt)->loop_father\n+\t\t      == loop->inner))\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true when BB contains statements that can harm the transform\n+   to a perfect loop nest.  */\n+\n+static bool\n+cannot_convert_bb_to_perfect_nest (basic_block bb, struct loop *loop)\n+{\n+  block_stmt_iterator bsi;\n+  tree exit_condition = get_loop_exit_condition (loop);\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    { \n+      tree stmt = bsi_stmt (bsi);\n+\n+      if (stmt == exit_condition\n+\t  || not_interesting_stmt (stmt)\n+\t  || stmt_is_bumper_for_loop (loop, stmt))\n+\tcontinue;\n+\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t{\n+\t  if (cannot_convert_modify_to_perfect_nest (stmt, loop))\n+\t    return true;\n+\n+\t  if (can_duplicate_iv (GIMPLE_STMT_OPERAND (stmt, 0), loop))\n+\t    continue;\n+\n+\t  if (can_put_in_inner_loop (loop->inner, stmt)\n+\t      || can_put_after_inner_loop (loop, stmt))\n+\t    continue;\n+\t}\n+\n+      /* If the bb of a statement we care about isn't dominated by the\n+\t header of the inner loop, then we can't handle this case\n+\t right now.  This test ensures that the statement comes\n+\t completely *after* the inner loop.  */\n+      if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t   bb_for_stmt (stmt), \n+\t\t\t   loop->inner->header))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n \n /* Return TRUE if LOOP is an imperfect nest that we can convert to a\n    perfect one.  At the moment, we only handle imperfect nests of\n@@ -2187,117 +2308,22 @@ static bool\n can_convert_to_perfect_nest (struct loop *loop)\n {\n   basic_block *bbs;\n-  tree exit_condition, phi;\n+  tree phi;\n   size_t i;\n-  block_stmt_iterator bsi;\n-  basic_block exitdest;\n \n   /* Can't handle triply nested+ loops yet.  */\n   if (!loop->inner || loop->inner->inner)\n     return false;\n   \n   bbs = get_loop_body (loop);\n-  exit_condition = get_loop_exit_condition (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      if (bbs[i]->loop_father == loop)\n-\t{\n-\t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t    { \n-\t      tree stmt = bsi_stmt (bsi);\n-\n-\t      if (stmt == exit_condition\n-\t\t  || not_interesting_stmt (stmt)\n-\t\t  || stmt_is_bumper_for_loop (loop, stmt))\n-\t\tcontinue;\n-\n-\t      /* If this is a scalar operation that can be put back\n-\t         into the inner loop, or after the inner loop, through\n-\t\t copying, then do so. This works on the theory that\n-\t\t any amount of scalar code we have to reduplicate\n-\t\t into or after the loops is less expensive that the\n-\t\t win we get from rearranging the memory walk\n-\t\t the loop is doing so that it has better\n-\t\t cache behavior.  */\n-\t      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-\t\t{\n-\t\t  use_operand_p use_a, use_b;\n-\t\t  imm_use_iterator imm_iter;\n-\t\t  ssa_op_iter op_iter, op_iter1;\n-\t\t  tree op0 = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t\t  tree scev = instantiate_parameters\n-\t\t    (loop, analyze_scalar_evolution (loop, op0));\n-\n-\t\t  /* If the IV is simple, it can be duplicated.  */\n-\t\t  if (!automatically_generated_chrec_p (scev))\n-\t\t    {\n-\t\t      tree step = evolution_part_in_loop_num (scev, loop->num);\n-\t\t      if (step && step != chrec_dont_know \n-\t\t\t  && TREE_CODE (step) == INTEGER_CST)\n-\t\t\tcontinue;\n-\t\t    }\n-\n-\t\t  /* The statement should not define a variable used\n-\t\t     in the inner loop.  */\n-\t\t  if (TREE_CODE (op0) == SSA_NAME)\n-\t\t    FOR_EACH_IMM_USE_FAST (use_a, imm_iter, op0)\n-\t\t      if (bb_for_stmt (USE_STMT (use_a))->loop_father\n-\t\t\t  == loop->inner)\n-\t\t\tgoto fail;\n-\n-\t\t  FOR_EACH_SSA_USE_OPERAND (use_a, stmt, op_iter, SSA_OP_USE)\n-\t\t    {\n-\t\t      tree node, op = USE_FROM_PTR (use_a);\n-\n-\t\t      /* The variables should not be used in both loops.  */\n-\t\t      FOR_EACH_IMM_USE_FAST (use_b, imm_iter, op)\n-\t\t      if (bb_for_stmt (USE_STMT (use_b))->loop_father\n-\t\t\t  == loop->inner)\n-\t\t\tgoto fail;\n-\n-\t\t      /* The statement should not use the value of a\n-\t\t\t scalar that was modified in the loop.  */\n-\t\t      node = SSA_NAME_DEF_STMT (op);\n-\t\t      if (TREE_CODE (node) == PHI_NODE)\n-\t\t\tFOR_EACH_PHI_ARG (use_b, node, op_iter1, SSA_OP_USE)\n-\t\t\t  {\n-\t\t\t    tree arg = USE_FROM_PTR (use_b);\n-\n-\t\t\t    if (TREE_CODE (arg) == SSA_NAME)\n-\t\t\t      {\n-\t\t\t\ttree arg_stmt = SSA_NAME_DEF_STMT (arg);\n-\n-\t\t\t\tif (bb_for_stmt (arg_stmt)\n-\t\t\t\t    && (bb_for_stmt (arg_stmt)->loop_father\n-\t\t\t\t\t== loop->inner))\n-\t\t\t\t  goto fail;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t    }\n-\n-\t\t  if (can_put_in_inner_loop (loop->inner, stmt)\n-\t\t      || can_put_after_inner_loop (loop, stmt))\n-\t\t    continue;\n-\t\t}\n-\n-\t      /* Otherwise, if the bb of a statement we care about isn't\n-\t\t dominated by the header of the inner loop, then we can't\n-\t\t handle this case right now.  This test ensures that the\n-\t\t statement comes completely *after* the inner loop.  */\n-\t      if (!dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t   bb_for_stmt (stmt), \n-\t\t\t\t   loop->inner->header))\n-\t\tgoto fail;\n-\t    }\n-\t}\n-    }\n+    if (bbs[i]->loop_father == loop\n+\t&& cannot_convert_bb_to_perfect_nest (bbs[i], loop))\n+      goto fail;\n \n   /* We also need to make sure the loop exit only has simple copy phis in it,\n-     otherwise we don't know how to transform it into a perfect nest right\n-     now.  */\n-  exitdest = single_exit (loop)->dest;\n-  \n-  for (phi = phi_nodes (exitdest); phi; phi = PHI_CHAIN (phi))\n+     otherwise we don't know how to transform it into a perfect nest.  */\n+  for (phi = phi_nodes (single_exit (loop)->dest); phi; phi = PHI_CHAIN (phi))\n     if (PHI_NUM_ARGS (phi) != 1)\n       goto fail;\n   "}, {"sha": "d414b13ddc184de1c561769e1791752615df80c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3615b8c2004057ce9cc64a449d0f9a88214e8997", "patch": "@@ -1,3 +1,8 @@\n+2007-12-18  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/34123\n+\t* gcc.dg/tree-ssa/pr34123.c: New test.\n+\n 2007-12-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \tPR rtl-optimization/34456"}, {"sha": "81dbf3aacdcbe1210b501d6d2d50c1aa7f2af57d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr34123.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr34123.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3615b8c2004057ce9cc64a449d0f9a88214e8997/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr34123.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr34123.c?ref=3615b8c2004057ce9cc64a449d0f9a88214e8997", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-linear\" } */\n+\n+/* Testcase by Martin Michlmayr <tbm@cyrius.com> */\n+\n+static unsigned char sbox[256] = {\n+};\n+void MD2Transform (unsigned char state[16])\n+{\n+  unsigned char t = 0;\n+  int i, j;\n+  for (i = 0; i < 16; i++)\n+    {\n+      for (j = 0; j < 2; j++)\n+        t = (state[j] ^= sbox[t]);\n+      t += i;\n+    }\n+}"}]}