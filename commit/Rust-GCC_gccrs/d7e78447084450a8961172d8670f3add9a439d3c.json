{"sha": "d7e78447084450a8961172d8670f3add9a439d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlNzg0NDcwODQ0NTBhODk2MTE3MmQ4NjcwZjNhZGQ5YTQzOWQzYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-08-18T14:51:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-08-18T14:51:04Z"}, "message": "re PR middle-end/62090 (ice in compute_may_aliases)\n\n2014-08-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/62090\n\t* builtins.c (fold_builtin_snprintf): Move to gimple-fold.c.\n\t(fold_builtin_3): Do not fold snprintf.\n\t(fold_builtin_4): Likewise.\n\t* gimple-fold.c (gimple_fold_builtin_snprintf): New function\n\tmoved from builtins.c.\n\t(gimple_fold_builtin_with_strlen): Fold snprintf and sprintf.\n\t(gimple_fold_builtin): Do not fold sprintf here.\n\n\t* gcc.dg/pr62090-2.c: New testcase.\n\nFrom-SVN: r214105", "tree": {"sha": "bee237c22bc9fb7e476ab299631bf10e912e77cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bee237c22bc9fb7e476ab299631bf10e912e77cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7e78447084450a8961172d8670f3add9a439d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e78447084450a8961172d8670f3add9a439d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e78447084450a8961172d8670f3add9a439d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e78447084450a8961172d8670f3add9a439d3c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "040292e700e79d48385da73a976e3ea7d7e4b913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040292e700e79d48385da73a976e3ea7d7e4b913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040292e700e79d48385da73a976e3ea7d7e4b913"}], "stats": {"total": 354, "additions": 209, "deletions": 145}, "files": [{"sha": "75591f450d76d458eb082c1ef147d6ce79ca771a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7e78447084450a8961172d8670f3add9a439d3c", "patch": "@@ -1,3 +1,14 @@\n+2014-08-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/62090\n+\t* builtins.c (fold_builtin_snprintf): Move to gimple-fold.c.\n+\t(fold_builtin_3): Do not fold snprintf.\n+\t(fold_builtin_4): Likewise.\n+\t* gimple-fold.c (gimple_fold_builtin_snprintf): New function\n+\tmoved from builtins.c.\n+\t(gimple_fold_builtin_with_strlen): Fold snprintf and sprintf.\n+\t(gimple_fold_builtin): Do not fold sprintf here.\n+\n 2014-08-18  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-fold.c (maybe_fold_reference): Move re-gimplification"}, {"sha": "29ddde8742a3fc677a0e3583842c5ca9793d3066", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d7e78447084450a8961172d8670f3add9a439d3c", "patch": "@@ -190,7 +190,6 @@ static tree fold_builtin_strrchr (location_t, tree, tree, tree);\n static tree fold_builtin_strncat (location_t, tree, tree, tree);\n static tree fold_builtin_strspn (location_t, tree, tree);\n static tree fold_builtin_strcspn (location_t, tree, tree);\n-static tree fold_builtin_snprintf (location_t, tree, tree, tree, tree, int);\n \n static rtx expand_builtin_object_size (tree);\n static rtx expand_builtin_memory_chk (tree, rtx, enum machine_mode,\n@@ -10309,9 +10308,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n     case BUILT_IN_MEMCMP:\n       return fold_builtin_memcmp (loc, arg0, arg1, arg2);;\n \n-    case BUILT_IN_SNPRINTF:\n-      return fold_builtin_snprintf (loc, arg0, arg1, arg2, NULL_TREE, ignore);\n-\n     case BUILT_IN_STRCAT_CHK:\n       return fold_builtin_strcat_chk (loc, fndecl, arg0, arg1, arg2);\n \n@@ -10364,9 +10360,6 @@ fold_builtin_4 (location_t loc, tree fndecl,\n     case BUILT_IN_STRNCAT_CHK:\n       return fold_builtin_strncat_chk (loc, fndecl, arg0, arg1, arg2, arg3);\n \n-    case BUILT_IN_SNPRINTF:\n-      return fold_builtin_snprintf (loc, arg0, arg1, arg2, arg3, ignore);\n-\n     case BUILT_IN_FPRINTF_CHK:\n     case BUILT_IN_VFPRINTF_CHK:\n       if (!validate_arg (arg1, INTEGER_TYPE)\n@@ -11230,126 +11223,6 @@ fold_builtin_next_arg (tree exp, bool va_start_p)\n }\n \n \n-/* Simplify a call to the snprintf builtin with arguments DEST, DESTSIZE,\n-   FMT, and ORIG.  ORIG may be null if this is a 3-argument call.  We don't\n-   attempt to simplify calls with more than 4 arguments.\n-\n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.  If IGNORED is true, it means that\n-   the caller does not use the returned value of the function.  */\n-\n-static tree\n-fold_builtin_snprintf (location_t loc, tree dest, tree destsize, tree fmt,\n-\t\t       tree orig, int ignored)\n-{\n-  tree call, retval;\n-  const char *fmt_str = NULL;\n-  unsigned HOST_WIDE_INT destlen;\n-\n-  /* Verify the required arguments in the original call.  We deal with two\n-     types of snprintf() calls: 'snprintf (str, cst, fmt)' and\n-     'snprintf (dest, cst, \"%s\", orig)'.  */\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (destsize, INTEGER_TYPE)\n-      || !validate_arg (fmt, POINTER_TYPE))\n-    return NULL_TREE;\n-  if (orig && !validate_arg (orig, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  if (!tree_fits_uhwi_p (destsize))\n-    return NULL_TREE;\n-\n-  /* Check whether the format is a literal string constant.  */\n-  fmt_str = c_getstr (fmt);\n-  if (fmt_str == NULL)\n-    return NULL_TREE;\n-\n-  call = NULL_TREE;\n-  retval = NULL_TREE;\n-\n-  if (!init_target_chars ())\n-    return NULL_TREE;\n-\n-  destlen = tree_to_uhwi (destsize);\n-\n-  /* If the format doesn't contain % args or %%, use strcpy.  */\n-  if (strchr (fmt_str, target_percent) == NULL)\n-    {\n-      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n-      size_t len = strlen (fmt_str);\n-\n-      /* Don't optimize snprintf (buf, 4, \"abc\", ptr++).  */\n-      if (orig)\n-\treturn NULL_TREE;\n-\n-      /* We could expand this as\n-\t memcpy (str, fmt, cst - 1); str[cst - 1] = '\\0';\n-\t or to\n-\t memcpy (str, fmt_with_nul_at_cstm1, cst);\n-\t but in the former case that might increase code size\n-\t and in the latter case grow .rodata section too much.\n-\t So punt for now.  */\n-      if (len >= destlen)\n-\treturn NULL_TREE;\n-\n-      if (!fn)\n-\treturn NULL_TREE;\n-\n-      /* Convert snprintf (str, cst, fmt) into strcpy (str, fmt) when\n-\t 'format' is known to contain no % formats and\n-\t strlen (fmt) < cst.  */\n-      call = build_call_expr_loc (loc, fn, 2, dest, fmt);\n-\n-      if (!ignored)\n-\tretval = build_int_cst (integer_type_node, strlen (fmt_str));\n-    }\n-\n-  /* If the format is \"%s\", use strcpy if the result isn't used.  */\n-  else if (fmt_str && strcmp (fmt_str, target_percent_s) == 0)\n-    {\n-      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n-      unsigned HOST_WIDE_INT origlen;\n-\n-      /* Don't crash on snprintf (str1, cst, \"%s\").  */\n-      if (!orig)\n-\treturn NULL_TREE;\n-\n-      retval = c_strlen (orig, 1);\n-      if (!retval || !tree_fits_uhwi_p (retval))\n-\treturn NULL_TREE;\n-\n-      origlen = tree_to_uhwi (retval);\n-      /* We could expand this as\n-\t memcpy (str1, str2, cst - 1); str1[cst - 1] = '\\0';\n-\t or to\n-\t memcpy (str1, str2_with_nul_at_cstm1, cst);\n-\t but in the former case that might increase code size\n-\t and in the latter case grow .rodata section too much.\n-\t So punt for now.  */\n-      if (origlen >= destlen)\n-\treturn NULL_TREE;\n-\n-      /* Convert snprintf (str1, cst, \"%s\", str2) into\n-\t strcpy (str1, str2) if strlen (str2) < cst.  */\n-      if (!fn)\n-\treturn NULL_TREE;\n-\n-      call = build_call_expr_loc (loc, fn, 2, dest, orig);\n-\n-      if (ignored)\n-\tretval = NULL_TREE;\n-    }\n-\n-  if (call && retval)\n-    {\n-      tree fn = builtin_decl_explicit (BUILT_IN_SNPRINTF);\n-      retval = fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fn)), retval);\n-      return build2 (COMPOUND_EXPR, TREE_TYPE (retval), call, retval);\n-    }\n-  else\n-    return call;\n-}\n-\n /* Expand a call EXP to __builtin_object_size.  */\n \n static rtx"}, {"sha": "f432baf07c24dec52e649b8a376ccefd4d30c5a4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 169, "deletions": 18, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d7e78447084450a8961172d8670f3add9a439d3c", "patch": "@@ -2091,7 +2091,7 @@ gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n    the caller does not use the returned value of the function.  */\n \n static bool\n-gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n+gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi, tree orig_len)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   tree dest = gimple_call_arg (stmt, 0);\n@@ -2169,11 +2169,11 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n       if (!orig)\n \treturn false;\n \n-      tree len = NULL_TREE;\n-      if (gimple_call_lhs (stmt))\n+      if (gimple_call_lhs (stmt)\n+\t  && !orig_len)\n \t{\n-\t  len = c_strlen (orig, 1);\n-\t  if (!len)\n+\t  orig_len = c_strlen (orig, 1);\n+\t  if (!orig_len)\n \t    return false;\n \t}\n \n@@ -2183,9 +2183,10 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n       gimple_seq_add_stmt_without_update (&stmts, repl);\n       if (gimple_call_lhs (stmt))\n \t{\n-\t  if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (len)))\n-\t    len = fold_convert (integer_type_node, len);\n-\t  repl = gimple_build_assign (gimple_call_lhs (stmt), len);\n+\t  if (!useless_type_conversion_p (integer_type_node,\n+\t\t\t\t\t  TREE_TYPE (orig_len)))\n+\t    orig_len = fold_convert (integer_type_node, orig_len);\n+\t  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);\n \t  gimple_seq_add_stmt_without_update (&stmts, repl);\n \t  gsi_replace_with_seq_vops (gsi, stmts);\n \t  /* gsi now points at the assignment to the lhs, get a\n@@ -2206,7 +2207,147 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/* Simplify a call to the snprintf builtin with arguments DEST, DESTSIZE,\n+   FMT, and ORIG.  ORIG may be null if this is a 3-argument call.  We don't\n+   attempt to simplify calls with more than 4 arguments.\n \n+   Return NULL_TREE if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.  If IGNORED is true, it means that\n+   the caller does not use the returned value of the function.  */\n+\n+static bool\n+gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi, tree orig_len)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree dest = gimple_call_arg (stmt, 0);\n+  tree destsize = gimple_call_arg (stmt, 1);\n+  tree fmt = gimple_call_arg (stmt, 2);\n+  tree orig = NULL_TREE;\n+  const char *fmt_str = NULL;\n+\n+  if (gimple_call_num_args (stmt) > 4)\n+    return false;\n+\n+  if (gimple_call_num_args (stmt) == 4)\n+    orig = gimple_call_arg (stmt, 3);\n+\n+  if (!tree_fits_uhwi_p (destsize))\n+    return false;\n+  unsigned HOST_WIDE_INT destlen = tree_to_uhwi (destsize);\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return false;\n+\n+  if (!init_target_chars ())\n+    return false;\n+\n+  /* If the format doesn't contain % args or %%, use strcpy.  */\n+  if (strchr (fmt_str, target_percent) == NULL)\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n+      if (!fn)\n+\treturn false;\n+\n+      /* Don't optimize snprintf (buf, 4, \"abc\", ptr++).  */\n+      if (orig)\n+\treturn false;\n+\n+      /* We could expand this as\n+\t memcpy (str, fmt, cst - 1); str[cst - 1] = '\\0';\n+\t or to\n+\t memcpy (str, fmt_with_nul_at_cstm1, cst);\n+\t but in the former case that might increase code size\n+\t and in the latter case grow .rodata section too much.\n+\t So punt for now.  */\n+      size_t len = strlen (fmt_str);\n+      if (len >= destlen)\n+\treturn false;\n+\n+      gimple_seq stmts = NULL;\n+      gimple repl = gimple_build_call (fn, 2, dest, fmt);\n+      gimple_seq_add_stmt_without_update (&stmts, repl);\n+      if (gimple_call_lhs (stmt))\n+\t{\n+\t  repl = gimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t      build_int_cst (integer_type_node, len));\n+\t  gimple_seq_add_stmt_without_update (&stmts, repl);\n+\t  gsi_replace_with_seq_vops (gsi, stmts);\n+\t  /* gsi now points at the assignment to the lhs, get a\n+\t     stmt iterator to the memcpy call.\n+\t     ???  We can't use gsi_for_stmt as that doesn't work when the\n+\t     CFG isn't built yet.  */\n+\t  gimple_stmt_iterator gsi2 = *gsi;\n+\t  gsi_prev (&gsi2);\n+\t  fold_stmt (&gsi2);\n+\t}\n+      else\n+\t{\n+\t  gsi_replace_with_seq_vops (gsi, stmts);\n+\t  fold_stmt (gsi);\n+\t}\n+      return true;\n+    }\n+\n+  /* If the format is \"%s\", use strcpy if the result isn't used.  */\n+  else if (fmt_str && strcmp (fmt_str, target_percent_s) == 0)\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRCPY);\n+      if (!fn)\n+\treturn false;\n+\n+      /* Don't crash on snprintf (str1, cst, \"%s\").  */\n+      if (!orig)\n+\treturn false;\n+\n+      if (!orig_len)\n+\t{\n+\t  orig_len = c_strlen (orig, 1);\n+\t  if (!orig_len)\n+\t    return false;\n+\t}\n+\n+      /* We could expand this as\n+\t memcpy (str1, str2, cst - 1); str1[cst - 1] = '\\0';\n+\t or to\n+\t memcpy (str1, str2_with_nul_at_cstm1, cst);\n+\t but in the former case that might increase code size\n+\t and in the latter case grow .rodata section too much.\n+\t So punt for now.  */\n+      if (compare_tree_int (orig_len, destlen) >= 0)\n+\treturn false;\n+\n+      /* Convert snprintf (str1, cst, \"%s\", str2) into\n+\t strcpy (str1, str2) if strlen (str2) < cst.  */\n+      gimple_seq stmts = NULL;\n+      gimple repl = gimple_build_call (fn, 2, dest, orig);\n+      gimple_seq_add_stmt_without_update (&stmts, repl);\n+      if (gimple_call_lhs (stmt))\n+\t{\n+\t  if (!useless_type_conversion_p (integer_type_node,\n+\t\t\t\t\t  TREE_TYPE (orig_len)))\n+\t    orig_len = fold_convert (integer_type_node, orig_len);\n+\t  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);\n+\t  gimple_seq_add_stmt_without_update (&stmts, repl);\n+\t  gsi_replace_with_seq_vops (gsi, stmts);\n+\t  /* gsi now points at the assignment to the lhs, get a\n+\t     stmt iterator to the memcpy call.\n+\t     ???  We can't use gsi_for_stmt as that doesn't work when the\n+\t     CFG isn't built yet.  */\n+\t  gimple_stmt_iterator gsi2 = *gsi;\n+\t  gsi_prev (&gsi2);\n+\t  fold_stmt (&gsi2);\n+\t}\n+      else\n+\t{\n+\t  gsi_replace_with_seq_vops (gsi, stmts);\n+\t  fold_stmt (gsi);\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n \n \n /* Fold a call to __builtin_strlen with known length LEN.  */\n@@ -2232,7 +2373,7 @@ static bool\n gimple_fold_builtin_with_strlen (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n-  tree val[3];\n+  tree val[4];\n   tree a;\n   int arg_idx, type;\n   bitmap visited;\n@@ -2276,23 +2417,32 @@ gimple_fold_builtin_with_strlen (gimple_stmt_iterator *gsi)\n       arg_idx = 1;\n       type = 2;\n       break;\n+    case BUILT_IN_SPRINTF:\n+      arg_idx = 2;\n+      type = 0;\n+      break;\n+    case BUILT_IN_SNPRINTF:\n+      arg_idx = 3;\n+      type = 0;\n+      break;\n     default:\n       return false;\n     }\n \n   int nargs = gimple_call_num_args (stmt);\n-  if (arg_idx >= nargs)\n-    return false;\n \n   /* Try to use the dataflow information gathered by the CCP process.  */\n   visited = BITMAP_ALLOC (NULL);\n   bitmap_clear (visited);\n \n   memset (val, 0, sizeof (val));\n-  a = gimple_call_arg (stmt, arg_idx);\n-  if (!get_maxval_strlen (a, &val[arg_idx], visited, type)\n-      || !is_gimple_val (val[arg_idx]))\n-    val[arg_idx] = NULL_TREE;\n+  if (arg_idx < nargs)\n+    {\n+      a = gimple_call_arg (stmt, arg_idx);\n+      if (!get_maxval_strlen (a, &val[arg_idx], visited, type)\n+\t  || !is_gimple_val (val[arg_idx]))\n+\tval[arg_idx] = NULL_TREE;\n+    }\n \n   BITMAP_FREE (visited);\n \n@@ -2364,7 +2514,10 @@ gimple_fold_builtin_with_strlen (gimple_stmt_iterator *gsi)\n     case BUILT_IN_VSNPRINTF_CHK:\n       return gimple_fold_builtin_snprintf_chk (gsi, val[1],\n \t\t\t\t\t       DECL_FUNCTION_CODE (callee));\n-\n+    case BUILT_IN_SNPRINTF:\n+      return gimple_fold_builtin_snprintf (gsi, val[3]);\n+    case BUILT_IN_SPRINTF:\n+      return gimple_fold_builtin_sprintf (gsi, val[2]);\n     default:\n       gcc_unreachable ();\n     }\n@@ -2414,8 +2567,6 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_SPRINTF_CHK:\n     case BUILT_IN_VSPRINTF_CHK:\n       return gimple_fold_builtin_sprintf_chk (gsi, DECL_FUNCTION_CODE (callee));\n-    case BUILT_IN_SPRINTF:\n-      return gimple_fold_builtin_sprintf (gsi);\n     default:;\n     }\n "}, {"sha": "89d164cc02133584c95ec6cd9fefc839f5e79fdd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7e78447084450a8961172d8670f3add9a439d3c", "patch": "@@ -1,3 +1,8 @@\n+2014-08-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/62090\n+\t* gcc.dg/pr62090-2.c: New testcase.\n+\n 2014-08-18  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* g++.dg/ipa/pr61800.C: New."}, {"sha": "5bddc53fbe410fcfd848c878e296f15f1212425d", "filename": "gcc/testsuite/gcc.dg/pr62090-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62090-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e78447084450a8961172d8670f3add9a439d3c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62090-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr62090-2.c?ref=d7e78447084450a8961172d8670f3add9a439d3c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef long unsigned int size_t;\n+extern __inline __attribute__ ((__always_inline__))\n+__attribute__ ((__gnu_inline__)) int\n+snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)\n+{\n+  return __builtin___snprintf_chk (__s, __n, 2 - 1,\n+\t\t\t\t   __builtin_object_size (__s, 2 > 1),\n+\t\t\t\t   __fmt, __builtin_va_arg_pack ());\n+}\n+typedef struct apacket apacket;\n+struct apacket {\n+    unsigned char data[4096];\n+};\n+static size_t fill_connect_data(char *buf, size_t bufsize)\n+{\n+  return snprintf(buf, bufsize, \"host::\") + 1;\n+}\n+unsigned send_connect(apacket *cp)\n+{\n+  return fill_connect_data((char *)cp->data, sizeof(cp->data));\n+}"}]}