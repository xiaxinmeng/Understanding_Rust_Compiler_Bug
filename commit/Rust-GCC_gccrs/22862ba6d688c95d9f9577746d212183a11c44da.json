{"sha": "22862ba6d688c95d9f9577746d212183a11c44da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI4NjJiYTZkNjg4Yzk1ZDlmOTU3Nzc0NmQyMTIxODNhMTFjNDRkYQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2019-07-22T13:57:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-22T13:57:46Z"}, "message": "[Ada] Usage of signed type in array bounds in CCG\n\n2019-07-22  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Size_In_Storage_Elements): Improve the expansion\n\tto handle array indexes that are modular type.\n\t(Expand_N_Allocator): For 32-bit targets improve the generation\n\tof the runtime check associated with large arrays supporting\n\tarrays initialized with a qualified expression.\n\t* libgnat/s-imenne.adb (Image_Enumeration_8,\n\tImage_Enumeration_16, Image_Enumeration_32): Define the index of\n\tIndex_Table with range Natural'First .. Names'Length since in\n\tthe worst case all the literals of the enumeration type would be\n\tsingle letter literals and the Table built by the frontend would\n\thave as many components as the length of the names string. As a\n\tresult of this enhancement, the internal tables declared using\n\tIndex_Table have a length closer to the real needs, thus\n\tavoiding the declaration of large arrays on 32-bit CCG targets.\n\nFrom-SVN: r273685", "tree": {"sha": "6ddb30a27da5adddf79b4b6b394811f6d114ee12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ddb30a27da5adddf79b4b6b394811f6d114ee12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22862ba6d688c95d9f9577746d212183a11c44da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22862ba6d688c95d9f9577746d212183a11c44da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22862ba6d688c95d9f9577746d212183a11c44da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22862ba6d688c95d9f9577746d212183a11c44da/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5dcbefb1c407fcb949597c4257726bfbc8760cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dcbefb1c407fcb949597c4257726bfbc8760cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dcbefb1c407fcb949597c4257726bfbc8760cfb"}], "stats": {"total": 193, "additions": 173, "deletions": 20}, "files": [{"sha": "ac990bee17cca6d93e0b0449a256d8f70bbb94c6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22862ba6d688c95d9f9577746d212183a11c44da/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22862ba6d688c95d9f9577746d212183a11c44da/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=22862ba6d688c95d9f9577746d212183a11c44da", "patch": "@@ -1,3 +1,20 @@\n+2019-07-22  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Size_In_Storage_Elements): Improve the expansion\n+\tto handle array indexes that are modular type.\n+\t(Expand_N_Allocator): For 32-bit targets improve the generation\n+\tof the runtime check associated with large arrays supporting\n+\tarrays initialized with a qualified expression.\n+\t* libgnat/s-imenne.adb (Image_Enumeration_8,\n+\tImage_Enumeration_16, Image_Enumeration_32): Define the index of\n+\tIndex_Table with range Natural'First .. Names'Length since in\n+\tthe worst case all the literals of the enumeration type would be\n+\tsingle letter literals and the Table built by the frontend would\n+\thave as many components as the length of the names string. As a\n+\tresult of this enhancement, the internal tables declared using\n+\tIndex_Table have a length closer to the real needs, thus\n+\tavoiding the declaration of large arrays on 32-bit CCG targets.\n+\n 2019-07-22  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch3.adb (Constrain_Access): Issue a message about ignored"}, {"sha": "117d6d67528a9127aa0b67855be306e2983fce3b", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 150, "deletions": 17, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22862ba6d688c95d9f9577746d212183a11c44da/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22862ba6d688c95d9f9577746d212183a11c44da/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=22862ba6d688c95d9f9577746d212183a11c44da", "patch": "@@ -4249,9 +4249,12 @@ package body Exp_Ch4 is\n \n       function Size_In_Storage_Elements (E : Entity_Id) return Node_Id;\n       --  Given a constrained array type E, returns a node representing the\n-      --  code to compute the size in storage elements for the given type.\n-      --  This is done without using the attribute (which malfunctions for\n-      --  large sizes ???)\n+      --  code to compute a close approximation of the size in storage elements\n+      --  for the given type; for indexes that are modular types we compute\n+      --  'Last - First (instead of 'Length) because for large arrays computing\n+      --  'Last -'First + 1 causes overflow. This is done without using the\n+      --  attribute 'Size_In_Storage_Elements (which malfunctions for large\n+      --  sizes ???)\n \n       -------------------------\n       -- Rewrite_Coextension --\n@@ -4310,17 +4313,77 @@ package body Exp_Ch4 is\n          --  just a fraction of a storage element???\n \n          declare\n+            Idx : Node_Id := First_Index (E);\n             Len : Node_Id;\n             Res : Node_Id;\n             pragma Warnings (Off, Res);\n \n          begin\n             for J in 1 .. Number_Dimensions (E) loop\n-               Len :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => New_Occurrence_Of (E, Loc),\n-                   Attribute_Name => Name_Length,\n-                   Expressions    => New_List (Make_Integer_Literal (Loc, J)));\n+\n+               if not Is_Modular_Integer_Type (Etype (Idx)) then\n+                  Len :=\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (E, Loc),\n+                      Attribute_Name => Name_Length,\n+                      Expressions    => New_List\n+                                          (Make_Integer_Literal (Loc, J)));\n+\n+               --  For indexes that are modular types we cannot generate code\n+               --  to compute 'Length since for large arrays 'Last -'First + 1\n+               --  causes overflow; therefore we compute 'Last - 'First (which\n+               --  is not the exact number of components but it is valid for\n+               --  the purpose of this runtime check on 32-bit targets)\n+\n+               else\n+                  declare\n+                     Len_Minus_1_Expr : Node_Id;\n+                     Test_Gt          : Node_Id;\n+\n+                  begin\n+                     Test_Gt :=\n+                       Make_Op_Gt (Loc,\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix         => New_Occurrence_Of (E, Loc),\n+                           Attribute_Name => Name_Last,\n+                           Expressions    =>\n+                             New_List (Make_Integer_Literal (Loc, J))),\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix         => New_Occurrence_Of (E, Loc),\n+                           Attribute_Name => Name_First,\n+                           Expressions    =>\n+                             New_List (Make_Integer_Literal (Loc, J))));\n+\n+                     Len_Minus_1_Expr :=\n+                       Convert_To (Standard_Unsigned,\n+                         Make_Op_Subtract (Loc,\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => New_Occurrence_Of (E, Loc),\n+                             Attribute_Name => Name_Last,\n+                             Expressions =>\n+                               New_List\n+                                 (Make_Integer_Literal (Loc, J))),\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => New_Occurrence_Of (E, Loc),\n+                             Attribute_Name => Name_First,\n+                             Expressions =>\n+                               New_List\n+                                 (Make_Integer_Literal (Loc, J)))));\n+\n+                     --  Handle superflat arrays, i.e. arrays with such bounds\n+                     --  as 4 .. 2, to insure that the result is correct.\n+\n+                     --  Generate:\n+                     --    (if X'Last > X'First then X'Last - X'First else 0)\n+\n+                     Len :=\n+                       Make_If_Expression (Loc,\n+                         Expressions => New_List (\n+                           Test_Gt,\n+                           Len_Minus_1_Expr,\n+                           Make_Integer_Literal (Loc, Uint_0)));\n+                  end;\n+               end if;\n \n                if J = 1 then\n                   Res := Len;\n@@ -4331,6 +4394,8 @@ package body Exp_Ch4 is\n                       Left_Opnd  => Res,\n                       Right_Opnd => Len);\n                end if;\n+\n+               Next_Index (Idx);\n             end loop;\n \n             return\n@@ -4573,15 +4638,83 @@ package body Exp_Ch4 is\n          --  apply the check for constrained arrays, and manually compute the\n          --  value of the attribute ???\n \n-         if Is_Array_Type (Etyp) and then Is_Constrained (Etyp) then\n-            Insert_Action (N,\n-              Make_Raise_Storage_Error (Loc,\n-                Condition =>\n-                  Make_Op_Gt (Loc,\n-                    Left_Opnd  => Size_In_Storage_Elements (Etyp),\n-                    Right_Opnd =>\n-                      Make_Integer_Literal (Loc, Uint_7 * (Uint_2 ** 29))),\n-                Reason    => SE_Object_Too_Large));\n+         --  The check on No_Initialization is used here to prevent generating\n+         --  this runtime check twice when the allocator is locally replaced by\n+         --  the expander by another one.\n+\n+         if Is_Array_Type (Etyp) and then not No_Initialization (N) then\n+            declare\n+               Cond    : Node_Id;\n+               Ins_Nod : Node_Id   := N;\n+               Siz_Typ : Entity_Id := Etyp;\n+               Expr    : Node_Id;\n+\n+            begin\n+               --  For unconstrained array types initialized with a qualified\n+               --  expression we use its type to perform this check\n+\n+               if not Is_Constrained (Etyp)\n+                 and then not No_Initialization (N)\n+                 and then Nkind (Expression (N)) = N_Qualified_Expression\n+               then\n+                  Expr    := Expression (Expression (N));\n+                  Siz_Typ := Etype (Expression (Expression (N)));\n+\n+                  --  If the qualified expression has been moved to an internal\n+                  --  temporary (to remove side effects) then we must insert\n+                  --  the runtime check before its declaration to ensure that\n+                  --  the check is performed before the execution of the code\n+                  --  computing the qualified expression.\n+\n+                  if Nkind (Expr) = N_Identifier\n+                    and then Is_Internal_Name (Chars (Expr))\n+                    and then\n+                      Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n+                  then\n+                     Ins_Nod := Parent (Entity (Expr));\n+                  else\n+                     Ins_Nod := Expr;\n+                  end if;\n+               end if;\n+\n+               if Is_Constrained (Siz_Typ)\n+                 and then Ekind (Siz_Typ) /= E_String_Literal_Subtype\n+               then\n+                  --  For CCG targets the largest array may have up to 2**31-1\n+                  --  components (i.e. 2 Gigabytes if each array component is\n+                  --  1-byte). This insures that fat pointer fields do not\n+                  --  overflow, since they are 32-bit integer types, and also\n+                  --  insures that 'Length can be computed at run time.\n+\n+                  if Modify_Tree_For_C then\n+                     Cond :=\n+                       Make_Op_Gt (Loc,\n+                         Left_Opnd  => Size_In_Storage_Elements (Siz_Typ),\n+                         Right_Opnd => Make_Integer_Literal (Loc,\n+                                         Uint_2 ** 31 - Uint_1));\n+\n+                  --  For native targets the largest object is 3.5 gigabytes\n+\n+                  else\n+                     Cond :=\n+                       Make_Op_Gt (Loc,\n+                         Left_Opnd  => Size_In_Storage_Elements (Siz_Typ),\n+                         Right_Opnd => Make_Integer_Literal (Loc,\n+                                         Uint_7 * (Uint_2 ** 29)));\n+                  end if;\n+\n+                  Insert_Action (Ins_Nod,\n+                    Make_Raise_Storage_Error (Loc,\n+                      Condition => Cond,\n+                      Reason    => SE_Object_Too_Large));\n+\n+                  if Entity (Cond) = Standard_True then\n+                     Error_Msg_N\n+                       (\"object too large: Storage_Error will be raised at \"\n+                        & \"run time??\", N);\n+                  end if;\n+               end if;\n+            end;\n          end if;\n       end if;\n "}, {"sha": "30df1a4d9b6549bb95c59cc96dcdfbbfbb2c0504", "filename": "gcc/ada/libgnat/s-imenne.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22862ba6d688c95d9f9577746d212183a11c44da/gcc%2Fada%2Flibgnat%2Fs-imenne.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22862ba6d688c95d9f9577746d212183a11c44da/gcc%2Fada%2Flibgnat%2Fs-imenne.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imenne.adb?ref=22862ba6d688c95d9f9577746d212183a11c44da", "patch": "@@ -49,7 +49,8 @@ package body System.Img_Enum_New is\n       pragma Assert (S'First = 1);\n \n       type Natural_8 is range 0 .. 2 ** 7 - 1;\n-      type Index_Table is array (Natural) of Natural_8;\n+      subtype Index is Natural range Natural'First .. Names'Length;\n+      type Index_Table is array (Index) of Natural_8;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n@@ -79,7 +80,8 @@ package body System.Img_Enum_New is\n       pragma Assert (S'First = 1);\n \n       type Natural_16 is range 0 .. 2 ** 15 - 1;\n-      type Index_Table is array (Natural) of Natural_16;\n+      subtype Index is Natural range Natural'First .. Names'Length;\n+      type Index_Table is array (Index) of Natural_16;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n@@ -109,7 +111,8 @@ package body System.Img_Enum_New is\n       pragma Assert (S'First = 1);\n \n       type Natural_32 is range 0 .. 2 ** 31 - 1;\n-      type Index_Table is array (Natural) of Natural_32;\n+      subtype Index is Natural range Natural'First .. Names'Length;\n+      type Index_Table is array (Index) of Natural_32;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is"}]}