{"sha": "a3368b8ea1bda5edd41900096b10514bcf7c6de7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMzNjhiOGVhMWJkYTVlZGQ0MTkwMDA5NmIxMDUxNGJjZjdjNmRlNw==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-10-08T14:16:13Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-10-08T14:16:13Z"}, "message": "Fix ICE on block move when using LRA.\n\n    * config/pdp11/pdp11-protos.h (output_block_move): Remove.\n    (expand_block_move): New function.\n    * config/pdp11/pdp11.c (output_block_move): Remove.\n    (expand_block_move): New function.\n    * config/pdp11/pdp11.h (MOVE_RATIO): New definition.\n    * config/pdp11/pdp11.md (movmemhi): Use expand_block_move.\n    (*movmemhi1): Remove.\n\nFrom-SVN: r264930", "tree": {"sha": "2f3fd59532ffddb2f375acecfc1567f2c35989ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f3fd59532ffddb2f375acecfc1567f2c35989ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3368b8ea1bda5edd41900096b10514bcf7c6de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3368b8ea1bda5edd41900096b10514bcf7c6de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3368b8ea1bda5edd41900096b10514bcf7c6de7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3368b8ea1bda5edd41900096b10514bcf7c6de7/comments", "author": null, "committer": null, "parents": [{"sha": "a3927ffb90429d9ac6bd73190063f8b922cfec45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3927ffb90429d9ac6bd73190063f8b922cfec45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3927ffb90429d9ac6bd73190063f8b922cfec45"}], "stats": {"total": 241, "additions": 51, "deletions": 190}, "files": [{"sha": "0e10c559e3bfefd31d6dd0f3abaf8b60a11fcedc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3368b8ea1bda5edd41900096b10514bcf7c6de7", "patch": "@@ -1,3 +1,13 @@\n+2018-10-08  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/pdp11/pdp11-protos.h (output_block_move): Remove.\n+\t(expand_block_move): New function.\n+\t* config/pdp11/pdp11.c (output_block_move): Remove.\n+\t(expand_block_move): New function.\n+\t* config/pdp11/pdp11.h (MOVE_RATIO): New definition.\n+\t* config/pdp11/pdp11.md (movmemhi): Use expand_block_move.\n+\t(*movmemhi1): Remove.\n+\n 2018-10-08  Robin Dapp  <rdapp@linux.ibm.com>\n \n \t* config/s390/2827.md: Increase latencies for some FP instructions."}, {"sha": "0ed61ea6106fe4037eac7a3a33f095723dfac850", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=a3368b8ea1bda5edd41900096b10514bcf7c6de7", "patch": "@@ -26,7 +26,7 @@ extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n extern void output_addr_const_pdp11 (FILE *, rtx);\n extern const char *output_move_multiple (rtx *);\n-extern const char *output_block_move (rtx *);\n+extern void expand_block_move (rtx *);\n extern const char *output_jump (rtx *, int, int);\n extern void print_operand_address (FILE *, rtx);\n typedef enum { no_action, dec_before, inc_after } pdp11_action;"}, {"sha": "06129f1d2d9db5257845cfc9beac55bcbec86ec5", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 28, "deletions": 152, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=a3368b8ea1bda5edd41900096b10514bcf7c6de7", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"builtins.h\"\n #include \"dbxout.h\"\n+#include \"explow.h\"\n #include \"expmed.h\"\n \n /* This file should be included last.  */\n@@ -1513,173 +1514,48 @@ no_side_effect_operand(rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n \n \n /*\n- * output a block move:\n+ * expand a block move:\n  *\n  * operands[0]\t... to\n  * operands[1]  ... from\n  * operands[2]  ... length\n  * operands[3]  ... alignment\n- * operands[4]  ... scratch register\n  */\n \n- \n-const char *\n-output_block_move(rtx *operands)\n+void\n+expand_block_move(rtx *operands)\n {\n-    static int count = 0;\n-    char buf[200];\n-    int unroll;\n-    int lastbyte = 0;\n-    \n-    /* Move of zero bytes is a NOP.  */\n-    if (operands[2] == const0_rtx)\n-      return \"\";\n-    \n-    /* Look for moves by small constant byte counts, those we'll\n-       expand to straight line code.  */\n-    if (CONSTANT_P (operands[2]))\n-    {\n-\tif (INTVAL (operands[2]) < 16\n-\t    && (!optimize_size || INTVAL (operands[2]) < 5)\n-\t    && INTVAL (operands[3]) == 1)\n-\t{\n-\t    register int i;\n-\t    \n-\t    for (i = 1; i <= INTVAL (operands[2]); i++)\n-\t\toutput_asm_insn(\"movb\\t(%1)+,(%0)+\", operands);\n-\n-\t    return \"\";\n-\t}\n-\telse if (INTVAL(operands[2]) < 32\n-\t\t && (!optimize_size || INTVAL (operands[2]) < 9)\n-\t\t && INTVAL (operands[3]) >= 2)\n-\t{\n-\t    register int i;\n-\t    \n-\t    for (i = 1; i <= INTVAL (operands[2]) / 2; i++)\n-\t\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\t    if (INTVAL (operands[2]) & 1)\n-\t      output_asm_insn (\"movb\\t(%1),(%0)\", operands);\n-\t    \n-\t    return \"\";\n-\t}\n-    }\n-\n-    /* Ideally we'd look for moves that are multiples of 4 or 8\n-       bytes and handle those by unrolling the move loop.  That\n-       makes for a lot of code if done at run time, but it's ok\n-       for constant counts.  Also, for variable counts we have\n-       to worry about odd byte count with even aligned pointers.\n-       On 11/40 and up we handle that case; on older machines\n-       we don't and just use byte-wise moves all the time.  */\n-\n-    if (CONSTANT_P (operands[2]) )\n-    {\n-      if (INTVAL (operands[3]) < 2)\n-\tunroll = 0;\n-      else\n-\t{\n-\t  lastbyte = INTVAL (operands[2]) & 1;\n-\n-\t  if (optimize_size || INTVAL (operands[2]) & 2)\n-\t    unroll = 1;\n-\t  else if (INTVAL (operands[2]) & 4)\n-\t    unroll = 2;\n-\t  else\n-\t    unroll = 3;\n-\t}\n-      \n-      /* Loop count is byte count scaled by unroll.  */\n-      operands[2] = GEN_INT (INTVAL (operands[2]) >> unroll);\n-      output_asm_insn (\"mov\\t%2,%4\", operands);\n-    }\n-    else\n-    {\n-\t/* Variable byte count; use the input register\n-\t   as the scratch.  */\n-\toperands[4] = operands[2];\n-\n-\t/* Decide whether to move by words, and check\n-\t   the byte count for zero.  */\n-\tif (TARGET_40_PLUS && INTVAL (operands[3]) > 1)\n-\t  {\n-\t    unroll = 1;\n-\t    output_asm_insn (\"asr\\t%4\", operands);\n-\t  }\n-\telse\n-\t  {\n-\t    unroll = 0;\n-\t    output_asm_insn (\"tst\\t%4\", operands);\n-\t  }\n-\tsprintf (buf, \"beq movestrhi%d\", count + 1);\n-\toutput_asm_insn (buf, NULL);\n-    }\n+    rtx lb, test;\n+    rtx fromop, toop, counter;\n+    int count;\n \n-    /* Output the loop label.  */\n-    sprintf (buf, \"\\nmovestrhi%d:\", count);\n-    output_asm_insn (buf, NULL);\n+    /* Transform BLKmode MEM reference into a (reg)+ operand.  */\n+    toop = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+    toop = gen_rtx_POST_INC (Pmode, toop);\n+    fromop = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+    fromop = gen_rtx_POST_INC (Pmode, fromop);\n \n-    /* Output the appropriate move instructions.  */\n-    switch (unroll)\n-    {\n-      case 0:\n-\toutput_asm_insn (\"movb\\t(%1)+,(%0)+\", operands);\n-\tbreak;\n-\t\n-      case 1:\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\tbreak;\n-\t\n-      case 2:\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\tbreak;\n-\t\n-      default:\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n-\tbreak;\n-    }\n-\n-    /* Output the decrement and test.  */\n-    if (TARGET_40_PLUS)\n+    count = INTVAL (operands[2]);\n+    if (INTVAL (operands [3]) >= 2 && (count & 1) == 0)\n       {\n-\tsprintf (buf, \"sob\\t%%4, movestrhi%d\", count);\n-\toutput_asm_insn (buf, operands);\n+\tcount >>= 1;\n+\ttoop = gen_rtx_MEM (HImode, toop);\n+\tfromop = gen_rtx_MEM (HImode, fromop);\n       }\n     else\n       {\n-\toutput_asm_insn (\"dec\\t%4\", operands);\n-\tsprintf (buf, \"bgt movestrhi%d\", count);\n-\toutput_asm_insn (buf, NULL);\n-      }\n-    count ++;\n-\n-    /* If constant odd byte count, move the last byte.  */\n-    if (lastbyte)\n-      output_asm_insn (\"movb\\t(%1),(%0)\", operands);\n-    else if (!CONSTANT_P (operands[2]))\n-      {\n-\t/* Output the destination label for the zero byte count check.  */\n-\tsprintf (buf, \"\\nmovestrhi%d:\", count);\n-\toutput_asm_insn (buf, NULL);\n-\tcount++;\n-    \n-\t/* If we did word moves, check for trailing last byte. */\n-\tif (unroll)\n-\t  {\n-\t    sprintf (buf, \"bcc movestrhi%d\", count);\n-\t    output_asm_insn (buf, NULL);\n-\t    output_asm_insn (\"movb\\t(%1),(%0)\", operands);\n-\t    sprintf (buf, \"\\nmovestrhi%d:\", count);\n-\t    output_asm_insn (buf, NULL);\n-\t    count++;\n-\t  }\n+\ttoop = gen_rtx_MEM (QImode, toop);\n+\tfromop = gen_rtx_MEM (QImode, fromop);\n       }\n-\t     \n-    return \"\";\n+    counter = copy_to_mode_reg (HImode, gen_rtx_CONST_INT (HImode, count));\n+\n+    /* Label at top of loop */\n+    lb = gen_label_rtx ();\n+    emit_label (lb);\n+    emit_move_insn (toop, fromop);\n+    emit_insn (gen_subhi3 (counter, counter, const1_rtx));\n+    test = gen_rtx_NE (HImode, counter, const0_rtx);\n+    emit_jump_insn (gen_cbranchhi4 (test, counter, const0_rtx, lb));\n }\n \n /* This function checks whether a real value can be encoded as"}, {"sha": "d65d8f5b8a241bff66816bbd309c01130ac1137c", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=a3368b8ea1bda5edd41900096b10514bcf7c6de7", "patch": "@@ -439,9 +439,12 @@ extern int may_call_alloca;\n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  \n */\n-\n #define MOVE_MAX 2\n \n+/* Max number of insns to use for inline move rather than library\n+   call.  */\n+#define MOVE_RATIO(speed) 6\n+\n /* Nonzero if access to memory by byte is no faster than by word.  */\n #define SLOW_BYTE_ACCESS 1\n "}, {"sha": "a41e159012ebfae1be0dc51d3688190a9391c26d", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3368b8ea1bda5edd41900096b10514bcf7c6de7/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=a3368b8ea1bda5edd41900096b10514bcf7c6de7", "patch": "@@ -570,48 +570,20 @@\n   clrf\\t%0\"\n   [(set_attr \"length\" \"2,2,4,4,2\")])\n \n-;; maybe fiddle a bit with move_ratio, then \n-;; let constraints only accept a register ...\n-\n+;; Expand a block move.  We turn this into a move loop.\n (define_expand \"movmemhi\"\n-  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"=g,g\")\n-\t\t   (match_operand:BLK 1 \"general_operand\" \"g,g\"))\n-\t      (use (match_operand:HI 2 \"general_operand\" \"n,mr\"))\n-\t      (use (match_operand:HI 3 \"immediate_operand\" \"i,i\"))\n-\t      (clobber (match_scratch:HI 6 \"=&r,X\"))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 2))])]\n+  [(match_operand:BLK 0 \"general_operand\" \"=g\")\n+   (match_operand:BLK 1 \"general_operand\" \"g\")\n+   (match_operand:HI 2 \"immediate_operand\" \"i\")\n+   (match_operand:HI 3 \"immediate_operand\" \"i\")]\n   \"\"\n   \"\n {\n-  operands[0]\n-    = replace_equiv_address (operands[0],\n-\t\t\t     copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n-  operands[1]\n-    = replace_equiv_address (operands[1],\n-\t\t\t     copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n-\n-  operands[4] = XEXP (operands[0], 0);\n-  operands[5] = XEXP (operands[1], 0);\n+  if (INTVAL (operands[2]) != 0)\n+    expand_block_move (operands);\n+  DONE;\n }\")\n \n-\n-(define_insn \"*movmemhi1\"\n-  [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"r,r\"))\n-\t(mem:BLK (match_operand:HI 1 \"register_operand\" \"r,r\")))\n-   (use (match_operand:HI 2 \"general_operand\" \"n,r\"))\n-   (use (match_operand:HI 3 \"immediate_operand\" \"i,i\"))\n-   (clobber (match_scratch:HI 4 \"=&r,X\"))\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))\n-   (clobber (match_dup 2))]\n-  \"\"\n-  \"* return output_block_move (operands);\"\n-;;; just a guess\n-  [(set_attr \"length\" \"80\")])\n-   \n-\n \f\n ;;- truncation instructions\n "}]}