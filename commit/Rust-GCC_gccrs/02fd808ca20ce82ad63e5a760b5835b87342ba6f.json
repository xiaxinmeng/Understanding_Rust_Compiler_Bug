{"sha": "02fd808ca20ce82ad63e5a760b5835b87342ba6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJmZDgwOGNhMjBjZTgyYWQ2M2U1YTc2MGI1ODM1Yjg3MzQyYmE2Zg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-01T13:35:01Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-01T13:35:01Z"}, "message": "[Ada] Clean up of GNAT.Lists\n\n------------\n-- Source --\n------------\n\n--  operations.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith GNAT;        use GNAT;\nwith GNAT.Lists;  use GNAT.Lists;\n\nprocedure Operations is\n   procedure Destroy (Val : in out Integer) is null;\n\n   package Integer_Lists is new Doubly_Linked_Lists\n     (Element_Type    => Integer,\n      \"=\"             => \"=\",\n      Destroy_Element => Destroy);\n   use Integer_Lists;\n\n   procedure Check_Empty\n     (Caller    : String;\n      L         : Doubly_Linked_List;\n      Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Ensure that none of the elements in the range Low_Elem .. High_Elem are\n   --  present in list L, and that the list's length is 0.\n\n   procedure Check_Locked_Mutations\n     (Caller : String;\n      L      : in out Doubly_Linked_List);\n   --  Ensure that all mutation operations of list L are locked\n\n   procedure Check_Present\n     (Caller    : String;\n      L         : Doubly_Linked_List;\n      Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Ensure that all elements in the range Low_Elem .. High_Elem are present\n   --  in list L.\n\n   procedure Check_Unlocked_Mutations\n     (Caller : String;\n      L      : in out Doubly_Linked_List);\n   --  Ensure that all mutation operations of list L are unlocked\n\n   procedure Populate_With_Append\n     (L         : Doubly_Linked_List;\n      Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Add elements in the range Low_Elem .. High_Elem in that order in list L\n\n   procedure Test_Append;\n   --  Verify that Append properly inserts at the tail of a list\n\n   procedure Test_Contains\n     (Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Verify that Contains properly identifies that elements in the range\n   --  Low_Elem .. High_Elem are within a list.\n\n   procedure Test_Create;\n   --  Verify that all list operations fail on a non-created list\n\n   procedure Test_Delete\n     (Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Verify that Delete properly removes elements in the range Low_Elem ..\n   --  High_Elem from a list.\n\n   procedure Test_Delete_First\n     (Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Verify that Delete properly removes elements in the range Low_Elem ..\n   --  High_Elem from the head of a list.\n\n   procedure Test_Delete_Last\n     (Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Verify that Delete properly removes elements in the range Low_Elem ..\n   --  High_Elem from the tail of a list.\n\n   procedure Test_First;\n   --  Verify that First properly returns the head of a list\n\n   procedure Test_Insert_After;\n   --  Verify that Insert_After properly adds an element after some other\n   --  element.\n\n   procedure Test_Insert_Before;\n   --  Vefity that Insert_Before properly adds an element before some other\n   --  element.\n\n   procedure Test_Is_Empty;\n   --  Verify that Is_Empty properly returns this status of a list\n\n   procedure Test_Iterate;\n   --  Verify that iterators properly manipulate mutation operations\n\n   procedure Test_Iterate_Empty;\n   --  Verify that iterators properly manipulate mutation operations of an\n   --  empty list.\n\n   procedure Test_Iterate_Forced\n     (Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Verify that an iterator that is forcefully advanced by Next properly\n   --  unlocks the mutation operations of a list.\n\n   procedure Test_Last;\n   --  Verify that Last properly returns the tail of a list\n\n   procedure Test_Prepend;\n   --  Verify that Prepend properly inserts at the head of a list\n\n   procedure Test_Present;\n   --  Verify that Present properly detects a list\n\n   procedure Test_Replace;\n   --  Verify that Replace properly substitutes old elements with new ones\n\n   procedure Test_Size;\n   --  Verify that Size returns the correct size of a list\n\n   -----------------\n   -- Check_Empty --\n   -----------------\n\n   procedure Check_Empty\n     (Caller    : String;\n      L         : Doubly_Linked_List;\n      Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      Len : constant Natural := Size (L);\n\n   begin\n      for Elem in Low_Elem .. High_Elem loop\n         if Contains (L, Elem) then\n            Put_Line (\"ERROR: \" & Caller & \": extra element\" & Elem'Img);\n         end if;\n      end loop;\n\n      if Len /= 0 then\n         Put_Line (\"ERROR: \" & Caller & \": wrong length\");\n         Put_Line (\"expected: 0\");\n         Put_Line (\"got     :\" & Len'Img);\n      end if;\n   end Check_Empty;\n\n   ----------------------------\n   -- Check_Locked_Mutations --\n   ----------------------------\n\n   procedure Check_Locked_Mutations\n     (Caller : String;\n      L      : in out Doubly_Linked_List)\n   is\n   begin\n      begin\n         Append (L, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Append: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Append: unexpected exception\");\n      end;\n\n      begin\n         Delete (L, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Delete: no exception raised\");\n      exception\n         when List_Empty =>\n            null;\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n      end;\n\n      begin\n         Delete_First (L);\n         Put_Line (\"ERROR: \" & Caller & \": Delete_First: no exception raised\");\n      exception\n         when List_Empty =>\n            null;\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Delete_First: unexpected exception\");\n      end;\n\n      begin\n         Delete_Last (L);\n         Put_Line (\"ERROR: \" & Caller & \": Delete_List: no exception raised\");\n      exception\n         when List_Empty =>\n            null;\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Delete_Last: unexpected exception\");\n      end;\n\n      begin\n         Destroy (L);\n         Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n      end;\n\n      begin\n         Insert_After (L, 1, 2);\n         Put_Line (\"ERROR: \" & Caller & \": Insert_After: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Insert_After: unexpected exception\");\n      end;\n\n      begin\n         Insert_Before (L, 1, 2);\n         Put_Line\n           (\"ERROR: \" & Caller & \": Insert_Before: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Insert_Before: unexpected exception\");\n      end;\n\n      begin\n         Prepend (L, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Prepend: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Prepend: unexpected exception\");\n      end;\n\n      begin\n         Replace (L, 1, 2);\n         Put_Line (\"ERROR: \" & Caller & \": Replace: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Replace: unexpected exception\");\n      end;\n   end Check_Locked_Mutations;\n\n   -------------------\n   -- Check_Present --\n   -------------------\n\n   procedure Check_Present\n     (Caller    : String;\n      L         : Doubly_Linked_List;\n      Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      Elem : Integer;\n      Iter : Iterator;\n\n   begin\n      Iter := Iterate (L);\n      for Exp_Elem in Low_Elem .. High_Elem loop\n         Next (Iter, Elem);\n\n         if Elem /= Exp_Elem then\n            Put_Line (\"ERROR: \" & Caller & \": Check_Present: wrong element\");\n            Put_Line (\"expected:\" & Exp_Elem'Img);\n            Put_Line (\"got     :\" & Elem'Img);\n         end if;\n      end loop;\n\n      --  At this point all elements should have been accounted for. Check for\n      --  extra elements.\n\n      while Has_Next (Iter) loop\n         Next (Iter, Elem);\n         Put_Line\n           (\"ERROR: \" & Caller & \": Check_Present: extra element\" & Elem'Img);\n      end loop;\n\n   exception\n      when Iterator_Exhausted =>\n         Put_Line\n           (\"ERROR: \"\n            & Caller\n            & \"Check_Present: incorrect number of elements\");\n   end Check_Present;\n\n   ------------------------------\n   -- Check_Unlocked_Mutations --\n   ------------------------------\n\n   procedure Check_Unlocked_Mutations\n     (Caller : String;\n      L      : in out Doubly_Linked_List)\n   is\n   begin\n      begin\n         Append (L, 1);\n         Append (L, 2);\n         Append (L, 3);\n      exception\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Append: unexpected exception\");\n      end;\n\n      begin\n         Delete (L, 1);\n      exception\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n      end;\n\n      begin\n         Delete_First (L);\n      exception\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Delete_First: unexpected exception\");\n      end;\n\n      begin\n         Delete_Last (L);\n      exception\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Delete_Last: unexpected exception\");\n      end;\n\n      begin\n         Insert_After (L, 2, 3);\n      exception\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Insert_After: unexpected exception\");\n      end;\n\n      begin\n         Insert_Before (L, 2, 1);\n      exception\n         when others =>\n            Put_Line\n              (\"ERROR: \" & Caller & \": Insert_Before: unexpected exception\");\n      end;\n\n      begin\n         Prepend (L, 0);\n      exception\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Prepend: unexpected exception\");\n      end;\n\n      begin\n         Replace (L, 3, 4);\n      exception\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Replace: unexpected exception\");\n      end;\n   end Check_Unlocked_Mutations;\n\n   --------------------------\n   -- Populate_With_Append --\n   --------------------------\n\n   procedure Populate_With_Append\n     (L         : Doubly_Linked_List;\n      Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n   begin\n      for Elem in Low_Elem .. High_Elem loop\n         Append (L, Elem);\n      end loop;\n   end Populate_With_Append;\n\n   -----------------\n   -- Test_Append --\n   -----------------\n\n   procedure Test_Append is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Append (L, 1);\n      Append (L, 2);\n      Append (L, 3);\n      Append (L, 4);\n      Append (L, 5);\n\n      Check_Present\n        (Caller    => \"Test_Append\",\n         L         => L,\n         Low_Elem  => 1,\n         High_Elem => 5);\n\n      Destroy (L);\n   end Test_Append;\n\n   -------------------\n   -- Test_Contains --\n   -------------------\n\n   procedure Test_Contains\n     (Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      Low_Bogus  : constant Integer := Low_Elem  - 1;\n      High_Bogus : constant Integer := High_Elem + 1;\n\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, Low_Elem, High_Elem);\n\n      --  Ensure that the elements are contained in the list\n\n      for Elem in Low_Elem .. High_Elem loop\n         if not Contains (L, Elem) then\n            Put_Line\n              (\"ERROR: Test_Contains: element\" & Elem'Img & \" not in list\");\n         end if;\n      end loop;\n\n      --  Ensure that arbitrary elements which were not inserted in the list\n      --  are not contained in the list.\n\n      if Contains (L, Low_Bogus) then\n         Put_Line\n           (\"ERROR: Test_Contains: element\" & Low_Bogus'Img & \" in list\");\n      end if;\n\n      if Contains (L, High_Bogus) then\n         Put_Line\n           (\"ERROR: Test_Contains: element\" & High_Bogus'Img & \" in list\");\n      end if;\n\n      Destroy (L);\n   end Test_Contains;\n\n   -----------------\n   -- Test_Create --\n   -----------------\n\n   procedure Test_Create is\n      Count : Natural;\n      Flag  : Boolean;\n      Iter  : Iterator;\n      L     : Doubly_Linked_List;\n      Val   : Integer;\n\n   begin\n      --  Ensure that every routine defined in the API fails on a list which\n      --  has not been created yet.\n\n      begin\n         Append (L, 1);\n         Put_Line (\"ERROR: Test_Create: Append: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Append: unexpected exception\");\n      end;\n\n      begin\n         Flag := Contains (L, 1);\n         Put_Line (\"ERROR: Test_Create: Contains: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Contains: unexpected exception\");\n      end;\n\n      begin\n         Delete (L, 1);\n         Put_Line (\"ERROR: Test_Create: Delete: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Delete: unexpected exception\");\n      end;\n\n      begin\n         Delete_First (L);\n         Put_Line (\"ERROR: Test_Create: Delete_First: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: Test_Create: Delete_First: unexpected exception\");\n      end;\n\n      begin\n         Delete_Last (L);\n         Put_Line (\"ERROR: Test_Create: Delete_Last: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Delete_Last: unexpected exception\");\n      end;\n\n      begin\n         Val := First (L);\n         Put_Line (\"ERROR: Test_Create: First: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: First: unexpected exception\");\n      end;\n\n      begin\n         Insert_After (L, 1, 2);\n         Put_Line (\"ERROR: Test_Create: Insert_After: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: Test_Create: Insert_After: unexpected exception\");\n      end;\n\n      begin\n         Insert_Before (L, 1, 2);\n         Put_Line (\"ERROR: Test_Create: Insert_Before: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line\n              (\"ERROR: Test_Create: Insert_Before: unexpected exception\");\n      end;\n\n      begin\n         Flag := Is_Empty (L);\n         Put_Line (\"ERROR: Test_Create: Is_Empty: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Is_Empty: unexpected exception\");\n      end;\n\n      begin\n         Iter := Iterate (L);\n         Put_Line (\"ERROR: Test_Create: Iterate: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Iterate: unexpected exception\");\n      end;\n\n      begin\n         Val := Last (L);\n         Put_Line (\"ERROR: Test_Create: Last: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Last: unexpected exception\");\n      end;\n\n      begin\n         Prepend (L, 1);\n         Put_Line (\"ERROR: Test_Create: Prepend: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Prepend: unexpected exception\");\n      end;\n\n      begin\n         Replace (L, 1, 2);\n         Put_Line (\"ERROR: Test_Create: Replace: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Replace: unexpected exception\");\n      end;\n\n      begin\n         Count := Size (L);\n         Put_Line (\"ERROR: Test_Create: Size: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Size: unexpected exception\");\n      end;\n   end Test_Create;\n\n   -----------------\n   -- Test_Delete --\n   -----------------\n\n   procedure Test_Delete\n     (Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, Low_Elem, High_Elem);\n\n      --  Delete the first element, which is technically the head\n\n      Delete (L, Low_Elem);\n\n      --  Ensure that all remaining elements except for the head are present in\n      --  the list.\n\n      Check_Present\n        (Caller    => \"Test_Delete\",\n         L         => L,\n         Low_Elem  => Low_Elem + 1,\n         High_Elem => High_Elem);\n\n      --  Delete the last element, which is technically the tail\n\n      Delete (L, High_Elem);\n\n      --  Ensure that all remaining elements except for the head and tail are\n      --  present in the list.\n\n      Check_Present\n        (Caller    => \"Test_Delete\",\n         L         => L,\n         Low_Elem  => Low_Elem  + 1,\n         High_Elem => High_Elem - 1);\n\n      --  Delete all even elements\n\n      for Elem in Low_Elem + 1 .. High_Elem - 1 loop\n         if Elem mod 2 = 0 then\n            Delete (L, Elem);\n         end if;\n      end loop;\n\n      --  Ensure that all remaining elements except the head, tail, and even\n      --  elements are present in the list.\n\n      for Elem in Low_Elem + 1 .. High_Elem - 1 loop\n         if Elem mod 2 /= 0 and then not Contains (L, Elem) then\n            Put_Line (\"ERROR: Test_Delete: missing element\" & Elem'Img);\n         end if;\n      end loop;\n\n      --  Delete all odd elements\n\n      for Elem in Low_Elem + 1 .. High_Elem - 1 loop\n         if Elem mod 2 /= 0 then\n            Delete (L, Elem);\n         end if;\n      end loop;\n\n      --  At this point the list should be completely empty\n\n      Check_Empty\n        (Caller    => \"Test_Delete\",\n         L         => L,\n         Low_Elem  => Low_Elem,\n         High_Elem => High_Elem);\n\n      --  Try to delete an element. This operation should raise List_Empty.\n\n      begin\n         Delete (L, Low_Elem);\n         Put_Line (\"ERROR: Test_Delete: List_Empty not raised\");\n      exception\n         when List_Empty =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Delete: unexpected exception\");\n      end;\n\n      Destroy (L);\n   end Test_Delete;\n\n   -----------------------\n   -- Test_Delete_First --\n   -----------------------\n\n   procedure Test_Delete_First\n     (Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, Low_Elem, High_Elem);\n\n      --  Delete the head of the list, and verify that the remaining elements\n      --  are still present in the list.\n\n      for Elem in Low_Elem .. High_Elem loop\n         Delete_First (L);\n\n         Check_Present\n           (Caller    => \"Test_Delete_First\",\n            L         => L,\n            Low_Elem  => Elem + 1,\n            High_Elem => High_Elem);\n      end loop;\n\n      --  At this point the list should be completely empty\n\n      Check_Empty\n        (Caller    => \"Test_Delete_First\",\n         L         => L,\n         Low_Elem  => Low_Elem,\n         High_Elem => High_Elem);\n\n      --  Try to delete an element. This operation should raise List_Empty.\n\n      begin\n         Delete_First (L);\n         Put_Line (\"ERROR: Test_Delete_First: List_Empty not raised\");\n      exception\n         when List_Empty =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Delete_First: unexpected exception\");\n      end;\n\n      Destroy (L);\n   end Test_Delete_First;\n\n   ----------------------\n   -- Test_Delete_Last --\n   ----------------------\n\n   procedure Test_Delete_Last\n     (Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, Low_Elem, High_Elem);\n\n      --  Delete the tail of the list, and verify that the remaining elements\n      --  are still present in the list.\n\n      for Elem in reverse Low_Elem .. High_Elem loop\n         Delete_Last (L);\n\n         Check_Present\n           (Caller    => \"Test_Delete_Last\",\n            L         => L,\n            Low_Elem  => Low_Elem,\n            High_Elem => Elem - 1);\n      end loop;\n\n      --  At this point the list should be completely empty\n\n      Check_Empty\n        (Caller    => \"Test_Delete_Last\",\n         L         => L,\n         Low_Elem  => Low_Elem,\n         High_Elem => High_Elem);\n\n      --  Try to delete an element. This operation should raise List_Empty.\n\n      begin\n         Delete_Last (L);\n         Put_Line (\"ERROR: Test_Delete_Last: List_Empty not raised\");\n      exception\n         when List_Empty =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Delete_First: unexpected exception\");\n      end;\n\n      Destroy (L);\n   end Test_Delete_Last;\n\n   ----------------\n   -- Test_First --\n   ----------------\n\n   procedure Test_First is\n      Elem : Integer;\n      L    : Doubly_Linked_List := Create;\n\n   begin\n      --  Try to obtain the head. This operation should raise List_Empty.\n\n      begin\n         Elem := First (L);\n         Put_Line (\"ERROR: Test_First: List_Empty not raised\");\n      exception\n         when List_Empty =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_First: unexpected exception\");\n      end;\n\n      Populate_With_Append (L, 1, 2);\n\n      --  Obtain the head\n\n      Elem := First (L);\n\n      if Elem /= 1 then\n         Put_Line (\"ERROR: Test_First: wrong element\");\n         Put_Line (\"expected: 1\");\n         Put_Line (\"got     :\" & Elem'Img);\n      end if;\n\n      Destroy (L);\n   end Test_First;\n\n   -----------------------\n   -- Test_Insert_After --\n   -----------------------\n\n   procedure Test_Insert_After is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      --  Try to insert after a non-inserted element, in an empty list\n\n      Insert_After (L, 1, 2);\n\n      --  At this point the list should be completely empty\n\n      Check_Empty\n        (Caller    => \"Test_Insert_After\",\n         L         => L,\n         Low_Elem  => 0,\n         High_Elem => -1);\n\n      Append (L, 1);           --  1\n\n      Insert_After (L, 1, 3);  --  1, 3\n      Insert_After (L, 1, 2);  --  1, 2, 3\n      Insert_After (L, 3, 4);  --  1, 2, 3, 4\n\n      --  Try to insert after a non-inserted element, in a full list\n\n      Insert_After (L, 10, 11);\n\n      Check_Present\n        (Caller    => \"Test_Insert_After\",\n         L         => L,\n         Low_Elem  => 1,\n         High_Elem => 4);\n\n      Destroy (L);\n   end Test_Insert_After;\n\n   ------------------------\n   -- Test_Insert_Before --\n   ------------------------\n\n   procedure Test_Insert_Before is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      --  Try to insert before a non-inserted element, in an empty list\n\n      Insert_Before (L, 1, 2);\n\n      --  At this point the list should be completely empty\n\n      Check_Empty\n        (Caller    => \"Test_Insert_Before\",\n         L         => L,\n         Low_Elem  => 0,\n         High_Elem => -1);\n\n      Append (L, 4);            --  4\n\n      Insert_Before (L, 4, 2);  --  2, 4\n      Insert_Before (L, 2, 1);  --  1, 2, 4\n      Insert_Before (L, 4, 3);  --  1, 2, 3, 4\n\n      --  Try to insert before a non-inserted element, in a full list\n\n      Insert_Before (L, 10, 11);\n\n      Check_Present\n        (Caller    => \"Test_Insert_Before\",\n         L         => L,\n         Low_Elem  => 1,\n         High_Elem => 4);\n\n      Destroy (L);\n   end Test_Insert_Before;\n\n   -------------------\n   -- Test_Is_Empty --\n   -------------------\n\n   procedure Test_Is_Empty is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      if not Is_Empty (L) then\n         Put_Line (\"ERROR: Test_Is_Empty: list is not empty\");\n      end if;\n\n      Append (L, 1);\n\n      if Is_Empty (L) then\n         Put_Line (\"ERROR: Test_Is_Empty: list is empty\");\n      end if;\n\n      Delete_First (L);\n\n      if not Is_Empty (L) then\n         Put_Line (\"ERROR: Test_Is_Empty: list is not empty\");\n      end if;\n\n      Destroy (L);\n   end Test_Is_Empty;\n\n   ------------------\n   -- Test_Iterate --\n   ------------------\n\n   procedure Test_Iterate is\n      Elem   : Integer;\n      Iter_1 : Iterator;\n      Iter_2 : Iterator;\n      L      : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, 1, 5);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the list.\n\n      Iter_1 := Iterate (L);\n\n      --  Ensure that every mutation routine defined in the API fails on a list\n      --  with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         L      => L);\n\n      --  Obtain another iterator\n\n      Iter_2 := Iterate (L);\n\n      --  Ensure that every mutation is still locked\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         L      => L);\n\n      --  Exhaust the first itertor\n\n      while Has_Next (Iter_1) loop\n         Next (Iter_1, Elem);\n      end loop;\n\n      --  Ensure that every mutation is still locked\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         L      => L);\n\n      --  Exhaust the second itertor\n\n      while Has_Next (Iter_2) loop\n         Next (Iter_2, Elem);\n      end loop;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Check_Unlocked_Mutations\n        (Caller => \"Test_Iterate\",\n         L      => L);\n\n      Destroy (L);\n   end Test_Iterate;\n\n   ------------------------\n   -- Test_Iterate_Empty --\n   ------------------------\n\n   procedure Test_Iterate_Empty is\n      Elem : Integer;\n      Iter : Iterator;\n      L    : Doubly_Linked_List := Create;\n\n   begin\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the list.\n\n      Iter := Iterate (L);\n\n      --  Ensure that every mutation routine defined in the API fails on a list\n      --  with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate_Empty\",\n         L      => L);\n\n      --  Attempt to iterate over the elements\n\n      while Has_Next (Iter) loop\n         Next (Iter, Elem);\n\n         Put_Line\n           (\"ERROR: Test_Iterate_Empty: element\" & Elem'Img & \" exists\");\n      end loop;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Check_Unlocked_Mutations\n        (Caller => \"Test_Iterate_Empty\",\n         L      => L);\n\n      Destroy (L);\n   end Test_Iterate_Empty;\n\n   -------------------------\n   -- Test_Iterate_Forced --\n   -------------------------\n\n   procedure Test_Iterate_Forced\n     (Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      Elem : Integer;\n      Iter : Iterator;\n      L    : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, Low_Elem, High_Elem);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the list.\n\n      Iter := Iterate (L);\n\n      --  Ensure that every mutation routine defined in the API fails on a list\n      --  with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate_Forced\",\n         L      => L);\n\n      --  Forcibly advance the iterator until it raises an exception\n\n      begin\n         for Guard in Low_Elem .. High_Elem + 1 loop\n            Next (Iter, Elem);\n         end loop;\n\n         Put_Line\n           (\"ERROR: Test_Iterate_Forced: Iterator_Exhausted not raised\");\n      exception\n         when Iterator_Exhausted =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Iterate_Forced: unexpected exception\");\n      end;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Check_Unlocked_Mutations\n        (Caller => \"Test_Iterate_Forced\",\n         L      => L);\n\n      Destroy (L);\n   end Test_Iterate_Forced;\n\n   ---------------\n   -- Test_Last --\n   ---------------\n\n   procedure Test_Last is\n      Elem : Integer;\n      L    : Doubly_Linked_List := Create;\n\n   begin\n      --  Try to obtain the tail. This operation should raise List_Empty.\n\n      begin\n         Elem := First (L);\n         Put_Line (\"ERROR: Test_Last: List_Empty not raised\");\n      exception\n         when List_Empty =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Last: unexpected exception\");\n      end;\n\n      Populate_With_Append (L, 1, 2);\n\n      --  Obtain the tail\n\n      Elem := Last (L);\n\n      if Elem /= 2 then\n         Put_Line (\"ERROR: Test_Last: wrong element\");\n         Put_Line (\"expected: 2\");\n         Put_Line (\"got     :\" & Elem'Img);\n      end if;\n\n      Destroy (L);\n   end Test_Last;\n\n   ------------------\n   -- Test_Prepend --\n   ------------------\n\n   procedure Test_Prepend is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Prepend (L, 5);\n      Prepend (L, 4);\n      Prepend (L, 3);\n      Prepend (L, 2);\n      Prepend (L, 1);\n\n      Check_Present\n        (Caller    => \"Test_Prepend\",\n         L         => L,\n         Low_Elem  => 1,\n         High_Elem => 5);\n\n      Destroy (L);\n   end Test_Prepend;\n\n   ------------------\n   -- Test_Present --\n   ------------------\n\n   procedure Test_Present is\n      L : Doubly_Linked_List;\n\n   begin\n      if Present (L) then\n         Put_Line (\"ERROR: Test_Present: list does not exist\");\n      end if;\n\n      L := Create;\n\n      if not Present (L) then\n         Put_Line (\"ERROR: Test_Present: list exists\");\n      end if;\n\n      Destroy (L);\n   end Test_Present;\n\n   ------------------\n   -- Test_Replace --\n   ------------------\n\n   procedure Test_Replace is\n      L : Doubly_Linked_List := Create;\n\n   begin\n      Populate_With_Append (L, 1, 5);\n\n      Replace (L, 3, 8);\n      Replace (L, 1, 6);\n      Replace (L, 4, 9);\n      Replace (L, 5, 10);\n      Replace (L, 2, 7);\n\n      Replace (L, 11, 12);\n\n      Check_Present\n        (Caller    => \"Test_Replace\",\n         L         => L,\n         Low_Elem  => 6,\n         High_Elem => 10);\n\n      Destroy (L);\n   end Test_Replace;\n\n   ---------------\n   -- Test_Size --\n   ---------------\n\n   procedure Test_Size is\n      L : Doubly_Linked_List := Create;\n      S : Natural;\n\n   begin\n      S := Size (L);\n\n      if S /= 0 then\n         Put_Line (\"ERROR: Test_Size: wrong size\");\n         Put_Line (\"expected: 0\");\n         Put_Line (\"got     :\" & S'Img);\n      end if;\n\n      Populate_With_Append (L, 1, 2);\n      S := Size (L);\n\n      if S /= 2 then\n         Put_Line (\"ERROR: Test_Size: wrong size\");\n         Put_Line (\"expected: 2\");\n         Put_Line (\"got     :\" & S'Img);\n      end if;\n\n      Populate_With_Append (L, 3, 6);\n      S := Size (L);\n\n      if S /= 6 then\n         Put_Line (\"ERROR: Test_Size: wrong size\");\n         Put_Line (\"expected: 6\");\n         Put_Line (\"got     :\" & S'Img);\n      end if;\n\n      Destroy (L);\n   end Test_Size;\n\n--  Start of processing for Operations\n\nbegin\n   Test_Append;\n\n   Test_Contains\n     (Low_Elem  => 1,\n      High_Elem => 5);\n\n   Test_Create;\n\n   Test_Delete\n     (Low_Elem  => 1,\n      High_Elem => 10);\n\n   Test_Delete_First\n     (Low_Elem  => 1,\n      High_Elem => 5);\n\n   Test_Delete_Last\n     (Low_Elem  => 1,\n      High_Elem => 5);\n\n   Test_First;\n   Test_Insert_After;\n   Test_Insert_Before;\n   Test_Is_Empty;\n   Test_Iterate;\n   Test_Iterate_Empty;\n\n   Test_Iterate_Forced\n     (Low_Elem  => 1,\n      High_Elem => 5);\n\n   Test_Last;\n   Test_Prepend;\n   Test_Present;\n   Test_Replace;\n   Test_Size;\nend Operations;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q operations.adb -largs -lgmem\n$ ./operations\n$ gnatmem operations > leaks.txt\n$ grep -c \"non freed allocations\" leaks.txt\n0\n\n2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/g-lists.adb: Use type Doubly_Linked_List rather than\n\tInstance in various routines.\n\t* libgnat/g-lists.ads: Change type Instance to\n\tDoubly_Linked_List. Update various routines that mention the\n\ttype.\n\ngcc/testsuite/\n\n\t* gnat.dg/linkedlist.adb: Update.\n\nFrom-SVN: r272861", "tree": {"sha": "779c5e5ac22336999966f2afb9ea370da11b9fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/779c5e5ac22336999966f2afb9ea370da11b9fe7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02fd808ca20ce82ad63e5a760b5835b87342ba6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fd808ca20ce82ad63e5a760b5835b87342ba6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02fd808ca20ce82ad63e5a760b5835b87342ba6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fd808ca20ce82ad63e5a760b5835b87342ba6f/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f070fc469c71b0d3e435cf23964b6de7cd9943e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f070fc469c71b0d3e435cf23964b6de7cd9943e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f070fc469c71b0d3e435cf23964b6de7cd9943e"}], "stats": {"total": 251, "additions": 156, "deletions": 95}, "files": [{"sha": "570a04a5c8a2a6ec561f403e6d1b915be526c82a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=02fd808ca20ce82ad63e5a760b5835b87342ba6f", "patch": "@@ -1,3 +1,11 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* libgnat/g-lists.adb: Use type Doubly_Linked_List rather than\n+\tInstance in various routines.\n+\t* libgnat/g-lists.ads: Change type Instance to\n+\tDoubly_Linked_List. Update various routines that mention the\n+\ttype.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* libgnat/g-dynhta.adb: Use type Dynamic_Hash_Table rather than"}, {"sha": "f7447a50d473181abcf189d34e2c5098fd54b927", "filename": "gcc/ada/libgnat/g-lists.adb", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.adb?ref=02fd808ca20ce82ad63e5a760b5835b87342ba6f", "patch": "@@ -33,26 +33,28 @@ with Ada.Unchecked_Deallocation;\n \n package body GNAT.Lists is\n \n-   package body Doubly_Linked_List is\n-      procedure Delete_Node (L : Instance; Nod : Node_Ptr);\n+   package body Doubly_Linked_Lists is\n+      procedure Delete_Node\n+        (L   : Doubly_Linked_List;\n+         Nod : Node_Ptr);\n       pragma Inline (Delete_Node);\n       --  Detach and delete node Nod from list L\n \n       procedure Ensure_Circular (Head : Node_Ptr);\n       pragma Inline (Ensure_Circular);\n       --  Ensure that dummy head Head is circular with respect to itself\n \n-      procedure Ensure_Created (L : Instance);\n+      procedure Ensure_Created (L : Doubly_Linked_List);\n       pragma Inline (Ensure_Created);\n       --  Verify that list L is created. Raise Not_Created if this is not the\n       --  case.\n \n-      procedure Ensure_Full (L : Instance);\n+      procedure Ensure_Full (L : Doubly_Linked_List);\n       pragma Inline (Ensure_Full);\n       --  Verify that list L contains at least one element. Raise List_Empty if\n       --  this is not the case.\n \n-      procedure Ensure_Unlocked (L : Instance);\n+      procedure Ensure_Unlocked (L : Doubly_Linked_List);\n       pragma Inline (Ensure_Unlocked);\n       --  Verify that list L is unlocked. Raise Iterated if this is not the\n       --  case.\n@@ -65,12 +67,14 @@ package body GNAT.Lists is\n       --  exists a node with element Elem. If such a node exists, return it,\n       --  otherwise return null;\n \n-      procedure Free is new Ada.Unchecked_Deallocation (Linked_List, Instance);\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation\n+              (Doubly_Linked_List_Attributes, Doubly_Linked_List);\n \n       procedure Free is new Ada.Unchecked_Deallocation (Node, Node_Ptr);\n \n       procedure Insert_Between\n-        (L     : Instance;\n+        (L     : Doubly_Linked_List;\n          Elem  : Element_Type;\n          Left  : Node_Ptr;\n          Right : Node_Ptr);\n@@ -81,28 +85,33 @@ package body GNAT.Lists is\n       pragma Inline (Is_Valid);\n       --  Determine whether iterator Iter refers to a valid element\n \n-      function Is_Valid (Nod : Node_Ptr; Head : Node_Ptr) return Boolean;\n+      function Is_Valid\n+        (Nod  : Node_Ptr;\n+         Head : Node_Ptr) return Boolean;\n       pragma Inline (Is_Valid);\n       --  Determine whether node Nod is non-null and does not refer to dummy\n       --  head Head, thus making it valid.\n \n-      procedure Lock (L : Instance);\n+      procedure Lock (L : Doubly_Linked_List);\n       pragma Inline (Lock);\n       --  Lock all mutation functionality of list L\n \n       function Present (Nod : Node_Ptr) return Boolean;\n       pragma Inline (Present);\n       --  Determine whether node Nod exists\n \n-      procedure Unlock (L : Instance);\n+      procedure Unlock (L : Doubly_Linked_List);\n       pragma Inline (Unlock);\n       --  Unlock all mutation functionality of list L\n \n       ------------\n       -- Append --\n       ------------\n \n-      procedure Append (L : Instance; Elem : Element_Type) is\n+      procedure Append\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type)\n+      is\n          Head : Node_Ptr;\n \n       begin\n@@ -129,16 +138,19 @@ package body GNAT.Lists is\n       -- Create --\n       ------------\n \n-      function Create return Instance is\n+      function Create return Doubly_Linked_List is\n       begin\n-         return new Linked_List;\n+         return new Doubly_Linked_List_Attributes;\n       end Create;\n \n       --------------\n       -- Contains --\n       --------------\n \n-      function Contains (L : Instance; Elem : Element_Type) return Boolean is\n+      function Contains\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type) return Boolean\n+      is\n          Head : Node_Ptr;\n          Nod  : Node_Ptr;\n \n@@ -155,7 +167,10 @@ package body GNAT.Lists is\n       -- Delete --\n       ------------\n \n-      procedure Delete (L : Instance; Elem : Element_Type) is\n+      procedure Delete\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type)\n+      is\n          Head : Node_Ptr;\n          Nod  : Node_Ptr;\n \n@@ -176,7 +191,7 @@ package body GNAT.Lists is\n       -- Delete_First --\n       ------------------\n \n-      procedure Delete_First (L : Instance) is\n+      procedure Delete_First (L : Doubly_Linked_List) is\n          Head : Node_Ptr;\n          Nod  : Node_Ptr;\n \n@@ -197,7 +212,7 @@ package body GNAT.Lists is\n       -- Delete_Last --\n       -----------------\n \n-      procedure Delete_Last (L : Instance) is\n+      procedure Delete_Last (L : Doubly_Linked_List) is\n          Head : Node_Ptr;\n          Nod  : Node_Ptr;\n \n@@ -218,7 +233,10 @@ package body GNAT.Lists is\n       -- Delete_Node --\n       -----------------\n \n-      procedure Delete_Node (L : Instance; Nod : Node_Ptr) is\n+      procedure Delete_Node\n+        (L   : Doubly_Linked_List;\n+         Nod : Node_Ptr)\n+      is\n          Ref : Node_Ptr := Nod;\n \n          pragma Assert (Present (Ref));\n@@ -250,7 +268,7 @@ package body GNAT.Lists is\n       -- Destroy --\n       -------------\n \n-      procedure Destroy (L : in out Instance) is\n+      procedure Destroy (L : in out Doubly_Linked_List) is\n          Head : Node_Ptr;\n \n       begin\n@@ -284,7 +302,7 @@ package body GNAT.Lists is\n       -- Ensure_Created --\n       --------------------\n \n-      procedure Ensure_Created (L : Instance) is\n+      procedure Ensure_Created (L : Doubly_Linked_List) is\n       begin\n          if not Present (L) then\n             raise Not_Created;\n@@ -295,7 +313,7 @@ package body GNAT.Lists is\n       -- Ensure_Full --\n       -----------------\n \n-      procedure Ensure_Full (L : Instance) is\n+      procedure Ensure_Full (L : Doubly_Linked_List) is\n       begin\n          pragma Assert (Present (L));\n \n@@ -308,7 +326,7 @@ package body GNAT.Lists is\n       -- Ensure_Unlocked --\n       ---------------------\n \n-      procedure Ensure_Unlocked (L : Instance) is\n+      procedure Ensure_Unlocked (L : Doubly_Linked_List) is\n       begin\n          pragma Assert (Present (L));\n \n@@ -350,7 +368,7 @@ package body GNAT.Lists is\n       -- First --\n       -----------\n \n-      function First (L : Instance) return Element_Type is\n+      function First (L : Doubly_Linked_List) return Element_Type is\n       begin\n          Ensure_Created (L);\n          Ensure_Full    (L);\n@@ -382,7 +400,7 @@ package body GNAT.Lists is\n       ------------------\n \n       procedure Insert_After\n-        (L     : Instance;\n+        (L     : Doubly_Linked_List;\n          After : Element_Type;\n          Elem  : Element_Type)\n       is\n@@ -410,7 +428,7 @@ package body GNAT.Lists is\n       -------------------\n \n       procedure Insert_Before\n-        (L      : Instance;\n+        (L      : Doubly_Linked_List;\n          Before : Element_Type;\n          Elem   : Element_Type)\n       is\n@@ -438,7 +456,7 @@ package body GNAT.Lists is\n       --------------------\n \n       procedure Insert_Between\n-        (L     : Instance;\n+        (L     : Doubly_Linked_List;\n          Elem  : Element_Type;\n          Left  : Node_Ptr;\n          Right : Node_Ptr)\n@@ -463,7 +481,7 @@ package body GNAT.Lists is\n       -- Is_Empty --\n       --------------\n \n-      function Is_Empty (L : Instance) return Boolean is\n+      function Is_Empty (L : Doubly_Linked_List) return Boolean is\n       begin\n          Ensure_Created (L);\n \n@@ -486,7 +504,10 @@ package body GNAT.Lists is\n       -- Is_Valid --\n       --------------\n \n-      function Is_Valid (Nod : Node_Ptr; Head : Node_Ptr) return Boolean is\n+      function Is_Valid\n+        (Nod  : Node_Ptr;\n+         Head : Node_Ptr) return Boolean\n+      is\n       begin\n          --  A node is valid if it is non-null, and does not refer to the dummy\n          --  head of some list.\n@@ -498,7 +519,7 @@ package body GNAT.Lists is\n       -- Iterate --\n       -------------\n \n-      function Iterate (L : Instance) return Iterator is\n+      function Iterate (L : Doubly_Linked_List) return Iterator is\n       begin\n          Ensure_Created (L);\n \n@@ -514,7 +535,7 @@ package body GNAT.Lists is\n       -- Last --\n       ----------\n \n-      function Last (L : Instance) return Element_Type is\n+      function Last (L : Doubly_Linked_List) return Element_Type is\n       begin\n          Ensure_Created (L);\n          Ensure_Full   (L);\n@@ -526,7 +547,7 @@ package body GNAT.Lists is\n       -- Lock --\n       ----------\n \n-      procedure Lock (L : Instance) is\n+      procedure Lock (L : Doubly_Linked_List) is\n       begin\n          pragma Assert (Present (L));\n \n@@ -540,7 +561,10 @@ package body GNAT.Lists is\n       -- Next --\n       ----------\n \n-      procedure Next (Iter : in out Iterator; Elem : out Element_Type) is\n+      procedure Next\n+        (Iter : in out Iterator;\n+         Elem : out Element_Type)\n+      is\n          Is_OK : constant Boolean  := Is_Valid (Iter);\n          Saved : constant Node_Ptr := Iter.Curr_Nod;\n \n@@ -565,7 +589,10 @@ package body GNAT.Lists is\n       -- Prepend --\n       -------------\n \n-      procedure Prepend (L : Instance; Elem : Element_Type) is\n+      procedure Prepend\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type)\n+      is\n          Head : Node_Ptr;\n \n       begin\n@@ -592,7 +619,7 @@ package body GNAT.Lists is\n       -- Present --\n       -------------\n \n-      function Present (L : Instance) return Boolean is\n+      function Present (L : Doubly_Linked_List) return Boolean is\n       begin\n          return L /= Nil;\n       end Present;\n@@ -611,7 +638,7 @@ package body GNAT.Lists is\n       -------------\n \n       procedure Replace\n-        (L        : Instance;\n+        (L        : Doubly_Linked_List;\n          Old_Elem : Element_Type;\n          New_Elem : Element_Type)\n       is\n@@ -634,7 +661,7 @@ package body GNAT.Lists is\n       -- Size --\n       ----------\n \n-      function Size (L : Instance) return Natural is\n+      function Size (L : Doubly_Linked_List) return Natural is\n       begin\n          Ensure_Created (L);\n \n@@ -645,7 +672,7 @@ package body GNAT.Lists is\n       -- Unlock --\n       ------------\n \n-      procedure Unlock (L : Instance) is\n+      procedure Unlock (L : Doubly_Linked_List) is\n       begin\n          pragma Assert (Present (L));\n \n@@ -654,6 +681,6 @@ package body GNAT.Lists is\n \n          L.Iterators := L.Iterators - 1;\n       end Unlock;\n-   end Doubly_Linked_List;\n+   end Doubly_Linked_Lists;\n \n end GNAT.Lists;"}, {"sha": "b64ef08ddb36ac80e129fd181a88cf9fdac4d490", "filename": "gcc/ada/libgnat/g-lists.ads", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.ads?ref=02fd808ca20ce82ad63e5a760b5835b87342ba6f", "patch": "@@ -45,7 +45,7 @@ package GNAT.Lists is\n    --\n    --  The following use pattern must be employed with this list:\n    --\n-   --    List : Instance := Create;\n+   --    List : Doubly_Linked_List := Create;\n    --\n    --    <various operations>\n    --\n@@ -63,97 +63,105 @@ package GNAT.Lists is\n       with procedure Destroy_Element (Elem : in out Element_Type);\n       --  Element destructor\n \n-   package Doubly_Linked_List is\n+   package Doubly_Linked_Lists is\n \n       ---------------------\n       -- List operations --\n       ---------------------\n \n-      type Instance is private;\n-      Nil : constant Instance;\n+      type Doubly_Linked_List is private;\n+      Nil : constant Doubly_Linked_List;\n \n       --  The following exception is raised when the list is empty, and an\n       --  attempt is made to delete an element from it.\n \n       List_Empty : exception;\n \n-      procedure Append (L : Instance; Elem : Element_Type);\n+      procedure Append\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type);\n       --  Insert element Elem at the end of list L. This action will raise\n       --  Iterated if the list has outstanding iterators.\n \n-      function Contains (L : Instance; Elem : Element_Type) return Boolean;\n+      function Contains\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type) return Boolean;\n       --  Determine whether list L contains element Elem\n \n-      function Create return Instance;\n+      function Create return Doubly_Linked_List;\n       --  Create a new list\n \n-      procedure Delete (L : Instance; Elem : Element_Type);\n+      procedure Delete\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type);\n       --  Delete element Elem from list L. The routine has no effect if Elem is\n       --  not present. This action will raise\n       --\n       --    * List_Empty if the list is empty.\n       --    * Iterated if the list has outstanding iterators.\n \n-      procedure Delete_First (L : Instance);\n+      procedure Delete_First (L : Doubly_Linked_List);\n       --  Delete an element from the start of list L. This action will raise\n       --\n       --    * List_Empty if the list is empty.\n       --    * Iterated if the list has outstanding iterators.\n \n-      procedure Delete_Last (L : Instance);\n+      procedure Delete_Last (L : Doubly_Linked_List);\n       --  Delete an element from the end of list L. This action will raise\n       --\n       --    * List_Empty if the list is empty.\n       --    * Iterated if the list has outstanding iterators.\n \n-      procedure Destroy (L : in out Instance);\n+      procedure Destroy (L : in out Doubly_Linked_List);\n       --  Destroy the contents of list L. This routine must be called at the\n       --  end of a list's lifetime. This action will raise Iterated if the\n       --  list has outstanding iterators.\n \n-      function First (L : Instance) return Element_Type;\n+      function First (L : Doubly_Linked_List) return Element_Type;\n       --  Obtain an element from the start of list L. This action will raise\n       --  List_Empty if the list is empty.\n \n       procedure Insert_After\n-        (L     : Instance;\n+        (L     : Doubly_Linked_List;\n          After : Element_Type;\n          Elem  : Element_Type);\n       --  Insert new element Elem after element After in list L. The routine\n       --  has no effect if After is not present. This action will raise\n       --  Iterated if the list has outstanding iterators.\n \n       procedure Insert_Before\n-        (L      : Instance;\n+        (L      : Doubly_Linked_List;\n          Before : Element_Type;\n          Elem   : Element_Type);\n       --  Insert new element Elem before element Before in list L. The routine\n       --  has no effect if After is not present. This action will raise\n       --  Iterated if the list has outstanding iterators.\n \n-      function Is_Empty (L : Instance) return Boolean;\n+      function Is_Empty (L : Doubly_Linked_List) return Boolean;\n       --  Determine whether list L is empty\n \n-      function Last (L : Instance) return Element_Type;\n+      function Last (L : Doubly_Linked_List) return Element_Type;\n       --  Obtain an element from the end of list L. This action will raise\n       --  List_Empty if the list is empty.\n \n-      procedure Prepend (L : Instance; Elem : Element_Type);\n+      procedure Prepend\n+        (L    : Doubly_Linked_List;\n+         Elem : Element_Type);\n       --  Insert element Elem at the start of list L. This action will raise\n       --  Iterated if the list has outstanding iterators.\n \n-      function Present (L : Instance) return Boolean;\n+      function Present (L : Doubly_Linked_List) return Boolean;\n       --  Determine whether list L exists\n \n       procedure Replace\n-        (L        : Instance;\n+        (L        : Doubly_Linked_List;\n          Old_Elem : Element_Type;\n          New_Elem : Element_Type);\n       --  Replace old element Old_Elem with new element New_Elem in list L. The\n       --  routine has no effect if Old_Elem is not present. This action will\n       --  raise Iterated if the list has outstanding iterators.\n \n-      function Size (L : Instance) return Natural;\n+      function Size (L : Doubly_Linked_List) return Natural;\n       --  Obtain the number of elements in list L\n \n       -------------------------\n@@ -179,11 +187,13 @@ package GNAT.Lists is\n       --  iterator has been exhausted, restore all mutation functionality of\n       --  the associated list.\n \n-      function Iterate (L : Instance) return Iterator;\n+      function Iterate (L : Doubly_Linked_List) return Iterator;\n       --  Obtain an iterator over the elements of list L. This action locks all\n       --  mutation functionality of the associated list.\n \n-      procedure Next (Iter : in out Iterator; Elem : out Element_Type);\n+      procedure Next\n+        (Iter : in out Iterator;\n+         Elem : out Element_Type);\n       --  Return the current element referenced by iterator Iter and advance\n       --  to the next available element. If the iterator has been exhausted\n       --  and further attempts are made to advance it, this routine restores\n@@ -204,7 +214,7 @@ package GNAT.Lists is\n \n       --  The following type represents a list\n \n-      type Linked_List is record\n+      type Doubly_Linked_List_Attributes is record\n          Elements : Natural := 0;\n          --  The number of elements in the list\n \n@@ -215,8 +225,8 @@ package GNAT.Lists is\n          --  The dummy head of the list\n       end record;\n \n-      type Instance is access all Linked_List;\n-      Nil : constant Instance := null;\n+      type Doubly_Linked_List is access all Doubly_Linked_List_Attributes;\n+      Nil : constant Doubly_Linked_List := null;\n \n       --  The following type represents an element iterator\n \n@@ -226,9 +236,9 @@ package GNAT.Lists is\n          --  iterator requires that this field always points to a valid node. A\n          --  value of null indicates that the iterator is exhausted.\n \n-         List : Instance := null;\n+         List : Doubly_Linked_List := null;\n          --  Reference to the associated list\n       end record;\n-   end Doubly_Linked_List;\n+   end Doubly_Linked_Lists;\n \n end GNAT.Lists;"}, {"sha": "782dd4bb720ec81a62308487f1c4047f3f3ba185", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02fd808ca20ce82ad63e5a760b5835b87342ba6f", "patch": "@@ -1,3 +1,7 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/linkedlist.adb: Update.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/dynhash.adb, gnat.dg/dynhash1.adb: Update."}, {"sha": "34df2ed7e43dbcdefc4892a5f96965afbc3bff24", "filename": "gcc/testsuite/gnat.dg/linkedlist.adb", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fd808ca20ce82ad63e5a760b5835b87342ba6f/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb?ref=02fd808ca20ce82ad63e5a760b5835b87342ba6f", "patch": "@@ -5,35 +5,42 @@ with GNAT;        use GNAT;\n with GNAT.Lists;  use GNAT.Lists;\n \n procedure Linkedlist is\n-   package Integer_Lists is new Doubly_Linked_List\n-     (Element_Type => Integer,\n-      \"=\"          => \"=\");\n+   procedure Destroy (Val : in out Integer) is null;\n+\n+   package Integer_Lists is new Doubly_Linked_Lists\n+     (Element_Type    => Integer,\n+      \"=\"             => \"=\",\n+      Destroy_Element => Destroy);\n    use Integer_Lists;\n \n    procedure Check_Empty\n      (Caller    : String;\n-      L         : Instance;\n+      L         : Doubly_Linked_List;\n       Low_Elem  : Integer;\n       High_Elem : Integer);\n    --  Ensure that none of the elements in the range Low_Elem .. High_Elem are\n    --  present in list L, and that the list's length is 0.\n \n-   procedure Check_Locked_Mutations (Caller : String; L : in out Instance);\n+   procedure Check_Locked_Mutations\n+     (Caller : String;\n+      L      : in out Doubly_Linked_List);\n    --  Ensure that all mutation operations of list L are locked\n \n    procedure Check_Present\n      (Caller    : String;\n-      L         : Instance;\n+      L         : Doubly_Linked_List;\n       Low_Elem  : Integer;\n       High_Elem : Integer);\n    --  Ensure that all elements in the range Low_Elem .. High_Elem are present\n    --  in list L.\n \n-   procedure Check_Unlocked_Mutations (Caller : String; L : in out Instance);\n+   procedure Check_Unlocked_Mutations\n+     (Caller : String;\n+      L      : in out Doubly_Linked_List);\n    --  Ensure that all mutation operations of list L are unlocked\n \n    procedure Populate_With_Append\n-     (L         : Instance;\n+     (L         : Doubly_Linked_List;\n       Low_Elem  : Integer;\n       High_Elem : Integer);\n    --  Add elements in the range Low_Elem .. High_Elem in that order in list L\n@@ -113,7 +120,7 @@ procedure Linkedlist is\n \n    procedure Check_Empty\n      (Caller    : String;\n-      L         : Instance;\n+      L         : Doubly_Linked_List;\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n@@ -137,7 +144,9 @@ procedure Linkedlist is\n    -- Check_Locked_Mutations --\n    ----------------------------\n \n-   procedure Check_Locked_Mutations (Caller : String; L : in out Instance) is\n+   procedure Check_Locked_Mutations\n+     (Caller : String;\n+      L      : in out Doubly_Linked_List) is\n    begin\n       begin\n          Append (L, 1);\n@@ -247,7 +256,7 @@ procedure Linkedlist is\n \n    procedure Check_Present\n      (Caller    : String;\n-      L         : Instance;\n+      L         : Doubly_Linked_List;\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n@@ -287,7 +296,10 @@ procedure Linkedlist is\n    -- Check_Unlocked_Mutations --\n    ------------------------------\n \n-   procedure Check_Unlocked_Mutations (Caller : String; L : in out Instance) is\n+   procedure Check_Unlocked_Mutations\n+     (Caller : String;\n+      L      : in out Doubly_Linked_List)\n+   is\n    begin\n       Append        (L, 1);\n       Append        (L, 2);\n@@ -306,7 +318,7 @@ procedure Linkedlist is\n    --------------------------\n \n    procedure Populate_With_Append\n-     (L         : Instance;\n+     (L         : Doubly_Linked_List;\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n@@ -321,7 +333,7 @@ procedure Linkedlist is\n    -----------------\n \n    procedure Test_Append is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       Append (L, 1);\n@@ -350,7 +362,7 @@ procedure Linkedlist is\n       Low_Bogus  : constant Integer := Low_Elem  - 1;\n       High_Bogus : constant Integer := High_Elem + 1;\n \n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, Low_Elem, High_Elem);\n@@ -388,7 +400,7 @@ procedure Linkedlist is\n       Count : Natural;\n       Flag  : Boolean;\n       Iter  : Iterator;\n-      L     : Instance;\n+      L     : Doubly_Linked_List;\n       Val   : Integer;\n \n    begin\n@@ -548,7 +560,7 @@ procedure Linkedlist is\n       High_Elem : Integer)\n    is\n       Iter : Iterator;\n-      L    : Instance := Create;\n+      L    : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, Low_Elem, High_Elem);\n@@ -635,7 +647,7 @@ procedure Linkedlist is\n      (Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, Low_Elem, High_Elem);\n@@ -684,7 +696,7 @@ procedure Linkedlist is\n      (Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, Low_Elem, High_Elem);\n@@ -731,7 +743,7 @@ procedure Linkedlist is\n \n    procedure Test_First is\n       Elem : Integer;\n-      L    : Instance := Create;\n+      L    : Doubly_Linked_List := Create;\n \n    begin\n       --  Try to obtain the head. This operation should raise List_Empty.\n@@ -766,7 +778,7 @@ procedure Linkedlist is\n    -----------------------\n \n    procedure Test_Insert_After is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       --  Try to insert after a non-inserted element, in an empty list\n@@ -805,7 +817,7 @@ procedure Linkedlist is\n    ------------------------\n \n    procedure Test_Insert_Before is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       --  Try to insert before a non-inserted element, in an empty list\n@@ -844,7 +856,7 @@ procedure Linkedlist is\n    -------------------\n \n    procedure Test_Is_Empty is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       if not Is_Empty (L) then\n@@ -874,7 +886,7 @@ procedure Linkedlist is\n       Elem   : Integer;\n       Iter_1 : Iterator;\n       Iter_2 : Iterator;\n-      L      : Instance := Create;\n+      L      : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, 1, 5);\n@@ -935,7 +947,7 @@ procedure Linkedlist is\n    procedure Test_Iterate_Empty is\n       Elem : Integer;\n       Iter : Iterator;\n-      L    : Instance := Create;\n+      L    : Doubly_Linked_List := Create;\n \n    begin\n       --  Obtain an iterator. This action must lock all mutation operations of\n@@ -978,7 +990,7 @@ procedure Linkedlist is\n    is\n       Elem : Integer;\n       Iter : Iterator;\n-      L    : Instance := Create;\n+      L    : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, Low_Elem, High_Elem);\n@@ -1026,7 +1038,7 @@ procedure Linkedlist is\n \n    procedure Test_Last is\n       Elem : Integer;\n-      L    : Instance := Create;\n+      L    : Doubly_Linked_List := Create;\n \n    begin\n       --  Try to obtain the tail. This operation should raise List_Empty.\n@@ -1061,7 +1073,7 @@ procedure Linkedlist is\n    ------------------\n \n    procedure Test_Prepend is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       Prepend (L, 5);\n@@ -1084,7 +1096,7 @@ procedure Linkedlist is\n    ------------------\n \n    procedure Test_Replace is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n \n    begin\n       Populate_With_Append (L, 1, 5);\n@@ -1111,7 +1123,7 @@ procedure Linkedlist is\n    ---------------\n \n    procedure Test_Size is\n-      L : Instance := Create;\n+      L : Doubly_Linked_List := Create;\n       S : Natural;\n \n    begin"}]}