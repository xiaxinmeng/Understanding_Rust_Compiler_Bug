{"sha": "87d3f828de27930f88ce5b76c9ae222c89064cca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdkM2Y4MjhkZTI3OTMwZjg4Y2U1Yjc2YzlhZTIyMmM4OTA2NGNjYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2020-01-07T17:58:18Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2020-01-07T17:58:18Z"}, "message": "init.c (build_new): Add location_t parameter and use it throughout.\n\n/gcc/cp\n2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* init.c (build_new): Add location_t parameter and use it throughout.\n\t(build_raw_new_expr): Likewise.\n\t* parser.c (cp_parser_new_expression): Pass the combined_loc.\n\t* pt.c (tsubst_copy_and_build): Adjust call.\n\t* cp-tree.h: Update declarations.\n\n/libcc1\n2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* libcp1plugin.cc (plugin_build_new_expr): Update build_new call.\n\n/gcc/testsuite\n2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* g++.old-deja/g++.bugs/900208_03.C: Check locations too.\n\t* g++.old-deja/g++.bugs/900519_06.C: Likewise.\n\nFrom-SVN: r279963", "tree": {"sha": "0ef2f63dd66b1f11dbf259112bc90605ba83aae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ef2f63dd66b1f11dbf259112bc90605ba83aae6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87d3f828de27930f88ce5b76c9ae222c89064cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d3f828de27930f88ce5b76c9ae222c89064cca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d3f828de27930f88ce5b76c9ae222c89064cca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d3f828de27930f88ce5b76c9ae222c89064cca/comments", "author": null, "committer": null, "parents": [{"sha": "5561b41dd67630273479d7661638c5c36a5abb5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5561b41dd67630273479d7661638c5c36a5abb5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5561b41dd67630273479d7661638c5c36a5abb5b"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "1655cafb9ab000bfac8e46bb5a90599a9452157c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -1,3 +1,11 @@\n+2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* init.c (build_new): Add location_t parameter and use it throughout.\n+\t(build_raw_new_expr): Likewise.\n+\t* parser.c (cp_parser_new_expression): Pass the combined_loc.\n+\t* pt.c (tsubst_copy_and_build): Adjust call.\n+\t* cp-tree.h: Update declarations.\n+\n 2020-01-07  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/47877 - -fvisibility-inlines-hidden and member templates."}, {"sha": "98572bdbad161cb0361628e4c2ef3c53e510b74f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -6720,9 +6720,10 @@ extern tree throw_bad_array_new_length\t\t(void);\n extern bool type_has_new_extended_alignment\t(tree);\n extern unsigned malloc_alignment\t\t(void);\n extern tree build_new_constexpr_heap_type\t(tree, tree, tree);\n-extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n-\t\t\t\t\t\t vec<tree, va_gc> **, int,\n-                                                 tsubst_flags_t);\n+extern tree build_new\t\t\t\t(location_t,\n+\t\t\t\t\t\t vec<tree, va_gc> **, tree,\n+\t\t\t\t\t\t tree, vec<tree, va_gc> **,\n+\t\t\t\t\t\t int, tsubst_flags_t);\n extern tree get_temp_regvar\t\t\t(tree, tree);\n extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int,\n                                                  tsubst_flags_t);"}, {"sha": "ba80474e6ac6f5d500cf050bf0c17bbcdc6fabc2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -2396,8 +2396,8 @@ decl_constant_value (tree decl)\n    creates and returns a NEW_EXPR.  */\n \n static tree\n-build_raw_new_expr (vec<tree, va_gc> *placement, tree type, tree nelts,\n-\t\t    vec<tree, va_gc> *init, int use_global_new)\n+build_raw_new_expr (location_t loc, vec<tree, va_gc> *placement, tree type,\n+\t\t    tree nelts, vec<tree, va_gc> *init, int use_global_new)\n {\n   tree init_list;\n   tree new_expr;\n@@ -2413,9 +2413,9 @@ build_raw_new_expr (vec<tree, va_gc> *placement, tree type, tree nelts,\n   else\n     init_list = build_tree_list_vec (init);\n \n-  new_expr = build4 (NEW_EXPR, build_pointer_type (type),\n-\t\t     build_tree_list_vec (placement), type, nelts,\n-\t\t     init_list);\n+  new_expr = build4_loc (loc, NEW_EXPR, build_pointer_type (type),\n+\t\t\t build_tree_list_vec (placement), type, nelts,\n+\t\t\t init_list);\n   NEW_EXPR_USE_GLOBAL (new_expr) = use_global_new;\n   TREE_SIDE_EFFECTS (new_expr) = 1;\n \n@@ -3775,8 +3775,9 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n    rather than just \"new\".  This may change PLACEMENT and INIT.  */\n \n tree\n-build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n-\t   vec<tree, va_gc> **init, int use_global_new, tsubst_flags_t complain)\n+build_new (location_t loc, vec<tree, va_gc> **placement, tree type,\n+\t   tree nelts, vec<tree, va_gc> **init, int use_global_new,\n+\t   tsubst_flags_t complain)\n {\n   tree rval;\n   vec<tree, va_gc> *orig_placement = NULL;\n@@ -3826,7 +3827,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t  || (nelts && type_dependent_expression_p (nelts))\n \t  || (nelts && *init)\n \t  || any_type_dependent_arguments_p (*init))\n-\treturn build_raw_new_expr (*placement, type, nelts, *init,\n+\treturn build_raw_new_expr (loc, *placement, type, nelts, *init,\n \t\t\t\t   use_global_new);\n \n       orig_placement = make_tree_vector_copy (*placement);\n@@ -3852,10 +3853,11 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   if (nelts)\n     {\n+      location_t nelts_loc = cp_expr_loc_or_loc (nelts, loc);\n       if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, nelts, false))\n         {\n           if (complain & tf_error)\n-\t    permerror (cp_expr_loc_or_input_loc (nelts),\n+\t    permerror (nelts_loc,\n \t\t       \"size in array new must have integral type\");\n           else\n             return error_mark_node;\n@@ -3871,8 +3873,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t less than zero. ... If the expression is a constant expression,\n \t the program is ill-fomed.  */\n       if (TREE_CODE (cst_nelts) == INTEGER_CST\n-\t  && !valid_array_size_p (cp_expr_loc_or_input_loc (nelts),\n-\t\t\t\t  cst_nelts, NULL_TREE,\n+\t  && !valid_array_size_p (nelts_loc, cst_nelts, NULL_TREE,\n \t\t\t\t  complain & tf_error))\n \treturn error_mark_node;\n \n@@ -3886,7 +3887,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n   if (TYPE_REF_P (type))\n     {\n       if (complain & tf_error)\n-        error (\"new cannot be applied to a reference type\");\n+        error_at (loc, \"new cannot be applied to a reference type\");\n       else\n         return error_mark_node;\n       type = TREE_TYPE (type);\n@@ -3895,7 +3896,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n       if (complain & tf_error)\n-        error (\"new cannot be applied to a function type\");\n+        error_at (loc, \"new cannot be applied to a function type\");\n       return error_mark_node;\n     }\n \n@@ -3911,15 +3912,15 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   if (processing_template_decl)\n     {\n-      tree ret = build_raw_new_expr (orig_placement, type, orig_nelts,\n+      tree ret = build_raw_new_expr (loc, orig_placement, type, orig_nelts,\n \t\t\t\t     orig_init, use_global_new);\n       release_tree_vector (orig_placement);\n       release_tree_vector (orig_init);\n       return ret;\n     }\n \n   /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n-  rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n+  rval = build1_loc (loc, NOP_EXPR, TREE_TYPE (rval), rval);\n   TREE_NO_WARNING (rval) = 1;\n \n   return rval;"}, {"sha": "595c185f2f8473bc003a8849341227db001d74ed", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -8750,11 +8750,9 @@ cp_parser_new_expression (cp_parser* parser)\n          at the end of the final token we consumed.  */\n       location_t combined_loc = make_location (start_loc, start_loc,\n \t\t\t\t\t       parser->lexer);\n-\n       /* Create a representation of the new-expression.  */\n-      ret = build_new (&placement, type, nelts, &initializer, global_scope_p,\n-\t\t       tf_warning_or_error);\n-      protected_set_expr_location (ret, combined_loc);\n+      ret = build_new (combined_loc, &placement, type, nelts, &initializer,\n+\t\t       global_scope_p, tf_warning_or_error);\n     }\n \n   if (placement != NULL)"}, {"sha": "29c3aecd8315d8b54501e083e7fc420086059e84", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -18821,12 +18821,12 @@ tsubst_copy_and_build (tree t,\n \t\t\t integral_constant_expression_p)\n \n   tree retval, op1;\n-  location_t loc;\n+  location_t save_loc;\n \n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n-  loc = input_location;\n+  save_loc = input_location;\n   if (location_t eloc = cp_expr_location (t))\n     input_location = eloc;\n \n@@ -19286,6 +19286,7 @@ tsubst_copy_and_build (tree t,\n \tvec<tree, va_gc> *placement_vec;\n \tvec<tree, va_gc> *init_vec;\n \ttree ret;\n+\tlocation_t loc = EXPR_LOCATION (t);\n \n \tif (placement == NULL_TREE)\n \t  placement_vec = NULL;\n@@ -19321,8 +19322,8 @@ tsubst_copy_and_build (tree t,\n \n \ttree op1 = tsubst (TREE_OPERAND (t, 1), args, complain, in_decl);\n \ttree op2 = RECUR (TREE_OPERAND (t, 2));\n-\tret = build_new (&placement_vec, op1, op2, &init_vec,\n-\t\t\t NEW_EXPR_USE_GLOBAL (t),\n+\tret = build_new (loc, &placement_vec, op1, op2,\n+\t\t\t &init_vec, NEW_EXPR_USE_GLOBAL (t),\n \t\t\t complain);\n \n \tif (placement_vec != NULL)\n@@ -20232,7 +20233,7 @@ tsubst_copy_and_build (tree t,\n #undef RECUR\n #undef RETURN\n  out:\n-  input_location = loc;\n+  input_location = save_loc;\n   return retval;\n }\n "}, {"sha": "ec35056910bd5575034ca030be925d1c14341bc1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -1,3 +1,8 @@\n+2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* g++.old-deja/g++.bugs/900208_03.C: Check locations too.\n+\t* g++.old-deja/g++.bugs/900519_06.C: Likewise.\n+\n 2020-01-07  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* gcc.dg/vect/vect-epilogues.c: XFAIL for arm big endian.\n@@ -29,7 +34,7 @@\n 2020-01-07  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/92860\n-\t* gcc.dg/pr92860.c: New test. \n+\t* gcc.dg/pr92860.c: New test.\n \n 2020-01-07  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "2b63e087eae03d19be95480bad1ba63f7c1eac0e", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900208_03.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900208_03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900208_03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900208_03.C?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -13,7 +13,7 @@ typedef void (func_type) ();\n \n void global_function_0 ()\n {\n-  new func_type;\t// { dg-error \"\" } missed by both cfront 2.0 and g++ 1.36.1\n+  new func_type;\t// { dg-error \"3:new cannot be applied to a function type\" } missed by both cfront 2.0 and g++ 1.36.1\n }\n \n int main () { return 0; }"}, {"sha": "a37033aad9897f4bc5b044cff51ca2da8395131a", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900519_06.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900519_06.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900519_06.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900519_06.C?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -12,12 +12,12 @@ typedef int& int_ref;\n \n void test (int n)\n {\n-  new int&;\t\t// { dg-error \"\" } missed\n-  new int_ref;\t\t// { dg-error \"\" } missed\n+  new int&;\t\t// { dg-error \"3:new cannot be applied to a reference type\" } missed\n+  new int_ref;\t\t// { dg-error \"3:new cannot be applied to a reference type\" } missed\n   new int&[n];\t\t// { dg-error \"\" } missed\n-  new int_ref[n];\t// { dg-error \"\" } missed\n+  new int_ref[n];\t// { dg-error \"3:new cannot be applied to a reference type\" } missed\n   new int&[3];\t\t// { dg-error \"\" } missed\n-  new int_ref[3];\t// { dg-error \"\" } missed\n+  new int_ref[3];\t// { dg-error \"3:new cannot be applied to a reference type\" } missed\n }\n \n int main () { return 0; }"}, {"sha": "ff994596200f5e33804804e4efe11ee22bd8b18c", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -1,3 +1,7 @@\n+2020-01-07  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* libcp1plugin.cc (plugin_build_new_expr): Update build_new call.\n+\n 2020-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "b466b34bee35cd5f4231dbc4734e149fd2ab5c61", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87d3f828de27930f88ce5b76c9ae222c89064cca/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87d3f828de27930f88ce5b76c9ae222c89064cca/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=87d3f828de27930f88ce5b76c9ae222c89064cca", "patch": "@@ -3258,8 +3258,8 @@ plugin_build_new_expr (cc1_plugin::connection *self,\n   if (!template_dependent_p)\n     processing_template_decl--;\n \n-  tree result = build_new (&placement, type, nelts, &initializer,\n-\t\t\t   global_scope_p, tf_error);\n+  tree result = build_new (input_location, &placement, type, nelts,\n+\t\t\t   &initializer, global_scope_p, tf_error);\n \n   if (template_dependent_p)\n     processing_template_decl--;"}]}