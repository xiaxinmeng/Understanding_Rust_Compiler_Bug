{"sha": "7fc5cca3880987199e2a65dfd0b56162711f451d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjNWNjYTM4ODA5ODcxOTllMmE2NWRmZDBiNTYxNjI3MTFmNDUxZA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2015-07-20T16:30:56Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2015-07-20T16:30:56Z"}, "message": "re PR target/66217 (PowerPC rotate/shift/mask instructions not optimal)\n\n\tPR target/66217\n\t* config/rs6000/constraints.md (\"S\", \"T\", \"t\"): Delete.  Update\n\t\"available letters\" comment.\n\t* config/rs6000/predicates.md (mask_operand, mask_operand_wrap,\n\tmask64_operand, mask64_2_operand, any_mask_operand, and64_2_operand,\n\tand_2rld_operand):  Delete.\n\t(and_operand): Adjust.\n\t(rotate_mask_operator): New.\n\t* config/rs6000/rs6000-protos.h (build_mask64_2_operands,\n\tincludes_lshift_p, includes_rshift_p, includes_rldic_lshift_p,\n\tincludes_rldicr_lshift_p, insvdi_rshift_rlwimi_p, extract_MB,\n\textract_ME): Delete.\n\t(rs6000_is_valid_mask, rs6000_is_valid_and_mask,\n\trs6000_is_valid_shift_mask, rs6000_is_valid_insert_mask,\n\trs6000_insn_for_and_mask, rs6000_insn_for_shift_mask,\n\trs6000_insn_for_insert_mask, rs6000_is_valid_2insn_and,\n\trs6000_emit_2insn_and): New.\n\t* config/rs6000/rs6000.c (num_insns_constant): Adjust.\n\t(build_mask64_2_operands, includes_lshift_p, includes_rshift_p,\n\tincludes_rldic_lshift_p, includes_rldicr_lshift_p,\n\tinsvdi_rshift_rlwimi_p, extract_MB, extract_ME): Delete.\n\t(rs6000_is_valid_mask, rs6000_is_valid_and_mask,\n\trs6000_insn_for_and_mask, rs6000_is_valid_shift_mask,\n\ts6000_insn_for_shift_mask, rs6000_is_valid_insert_mask,\n\trs6000_insn_for_insert_mask, rs6000_is_valid_2insn_and,\n\trs6000_emit_2insn_and): New.\n\t(print_operand) <'b', 'B', 'm', 'M', 's', 'S', 'W'>: Delete.\n\t(rs6000_rtx_costs) <CONST_INT>: Delete mask_operand and mask64_operand\n\thandling.\n\t<NOT>: Don't fall through to next case.\n\t<AND>: Handle the various rotate-and-mask cases directly.\n\t<IOR>: Always cost as one insn.\n\t* config/rs6000/rs6000.md (splitter for bswap:SI): Adjust.\n\t(and<mode>3): Adjust expander for the new patterns.\n\t(and<mode>3_imm, and<mode>3_imm_dot, and<mode>3_imm_dot2,\n\tand<mode>3_imm_mask_dot, and<mode>3_imm_mask_dot2): Adjust condition.\n\t(*and<mode>3_imm_dot_shifted): New.\n\t(*and<mode>3_mask): Delete, rewrite as ...\n\t(and<mode>3_mask): ... New.\n\t(*and<mode>3_mask_dot, *and<mode>3_mask_dot): Rewrite.\n\t(andsi3_internal0_nomc): Delete.\n\t(*andsi3_internal6): Delete.\n\t(*and<mode>3_2insn): New.\n\t(insv, insvsi_internal, *insvsi_internal1, *insvsi_internal2,\n\t*insvsi_internal3, *insvsi_internal4, *insvsi_internal5,\n\t*insvsi_internal6, insvdi_internal, *insvdi_internal2,\n\t*insvdi_internal3): Delete.\n\t(*rotl<mode>3_mask, *rotl<mode>3_mask_dot, *rotl<mode>3_mask_dot2,\n\t*rotl<mode>3_insert, *rotl<mode>3_insert_2, *rotl<mode>3_insert_3,\n\t*rotl<mode>3_insert_4, two splitters for multi-precision shifts,\n\t*ior<mode>_mask): New.\n\t(extzv, extzvdi_internal, *extzvdi_internal1, *extzvdi_internal2,\n\t*rotlsi3_mask, *rotlsi3_mask_dot, *rotlsi3_mask_dot2,\n\t*ashlsi3_imm_mask, *ashlsi3_imm_mask_dot, *ashlsi3_imm_mask_dot2,\n\t*lshrsi3_imm_mask, *lshrsi3_imm_mask_dot, *lshrsi3_imm_mask_dot2):\n\tDelete.\n\t(ashr<mode>3): Delete expander.\n\t(*ashr<mode>3): Rename to ...\n\t(ashr<mode>3): ... This.\n\t(ashrdi3_no_power, *ashrdisi3_noppc64be): Delete.\n\t(*rotldi3_internal4, *rotldi3_internal5 and split,\n\t*rotldi3_internal6 and split, *ashldi3_internal4, ashldi3_internal5\n\tand split, *ashldi3_internal6 and split, *ashldi3_internal7,\n\tashldi3_internal8 and split, *ashldi3_internal9 and split): Delete.\n\t(*anddi3_2rld, *anddi3_2rld_dot, *anddi3_2rld_dot2): Delete.\n\t(splitter for loading a mask): Adjust.\n\t* doc/md.texi (Machine Constraints): Remove q, S, T, t constraints.\n\nFrom-SVN: r226005", "tree": {"sha": "5ed20308e2f734932c72a712e77573be496a07c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ed20308e2f734932c72a712e77573be496a07c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fc5cca3880987199e2a65dfd0b56162711f451d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc5cca3880987199e2a65dfd0b56162711f451d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc5cca3880987199e2a65dfd0b56162711f451d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc5cca3880987199e2a65dfd0b56162711f451d/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3e9a059a74680325960aa3e6ebc629773c9e1f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e9a059a74680325960aa3e6ebc629773c9e1f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3e9a059a74680325960aa3e6ebc629773c9e1f8"}], "stats": {"total": 2430, "additions": 941, "deletions": 1489}, "files": [{"sha": "6a4b22bf6f3d0c6764bd5345126f4449c6e43373", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -1,3 +1,73 @@\n+2015-07-20  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR target/66217\n+\t* config/rs6000/constraints.md (\"S\", \"T\", \"t\"): Delete.  Update\n+\t\"available letters\" comment.\n+\t* config/rs6000/predicates.md (mask_operand, mask_operand_wrap,\n+\tmask64_operand, mask64_2_operand, any_mask_operand, and64_2_operand,\n+\tand_2rld_operand):  Delete.\n+\t(and_operand): Adjust.\n+\t(rotate_mask_operator): New.\n+\t* config/rs6000/rs6000-protos.h (build_mask64_2_operands,\n+\tincludes_lshift_p, includes_rshift_p, includes_rldic_lshift_p,\n+\tincludes_rldicr_lshift_p, insvdi_rshift_rlwimi_p, extract_MB,\n+\textract_ME): Delete.\n+\t(rs6000_is_valid_mask, rs6000_is_valid_and_mask,\n+\trs6000_is_valid_shift_mask, rs6000_is_valid_insert_mask,\n+\trs6000_insn_for_and_mask, rs6000_insn_for_shift_mask,\n+\trs6000_insn_for_insert_mask, rs6000_is_valid_2insn_and,\n+\trs6000_emit_2insn_and): New.\n+\t* config/rs6000/rs6000.c (num_insns_constant): Adjust.\n+\t(build_mask64_2_operands, includes_lshift_p, includes_rshift_p,\n+\tincludes_rldic_lshift_p, includes_rldicr_lshift_p,\n+\tinsvdi_rshift_rlwimi_p, extract_MB, extract_ME): Delete.\n+\t(rs6000_is_valid_mask, rs6000_is_valid_and_mask,\n+\trs6000_insn_for_and_mask, rs6000_is_valid_shift_mask,\n+\ts6000_insn_for_shift_mask, rs6000_is_valid_insert_mask,\n+\trs6000_insn_for_insert_mask, rs6000_is_valid_2insn_and,\n+\trs6000_emit_2insn_and): New.\n+\t(print_operand) <'b', 'B', 'm', 'M', 's', 'S', 'W'>: Delete.\n+\t(rs6000_rtx_costs) <CONST_INT>: Delete mask_operand and mask64_operand\n+\thandling.\n+\t<NOT>: Don't fall through to next case.\n+\t<AND>: Handle the various rotate-and-mask cases directly.\n+\t<IOR>: Always cost as one insn.\n+\t* config/rs6000/rs6000.md (splitter for bswap:SI): Adjust.\n+\t(and<mode>3): Adjust expander for the new patterns.\n+\t(and<mode>3_imm, and<mode>3_imm_dot, and<mode>3_imm_dot2,\n+\tand<mode>3_imm_mask_dot, and<mode>3_imm_mask_dot2): Adjust condition.\n+\t(*and<mode>3_imm_dot_shifted): New.\n+\t(*and<mode>3_mask): Delete, rewrite as ...\n+\t(and<mode>3_mask): ... New.\n+\t(*and<mode>3_mask_dot, *and<mode>3_mask_dot): Rewrite.\n+\t(andsi3_internal0_nomc): Delete.\n+\t(*andsi3_internal6): Delete.\n+\t(*and<mode>3_2insn): New.\n+\t(insv, insvsi_internal, *insvsi_internal1, *insvsi_internal2,\n+\t*insvsi_internal3, *insvsi_internal4, *insvsi_internal5,\n+\t*insvsi_internal6, insvdi_internal, *insvdi_internal2,\n+\t*insvdi_internal3): Delete.\n+\t(*rotl<mode>3_mask, *rotl<mode>3_mask_dot, *rotl<mode>3_mask_dot2,\n+\t*rotl<mode>3_insert, *rotl<mode>3_insert_2, *rotl<mode>3_insert_3,\n+\t*rotl<mode>3_insert_4, two splitters for multi-precision shifts,\n+\t*ior<mode>_mask): New.\n+\t(extzv, extzvdi_internal, *extzvdi_internal1, *extzvdi_internal2,\n+\t*rotlsi3_mask, *rotlsi3_mask_dot, *rotlsi3_mask_dot2,\n+\t*ashlsi3_imm_mask, *ashlsi3_imm_mask_dot, *ashlsi3_imm_mask_dot2,\n+\t*lshrsi3_imm_mask, *lshrsi3_imm_mask_dot, *lshrsi3_imm_mask_dot2):\n+\tDelete.\n+\t(ashr<mode>3): Delete expander.\n+\t(*ashr<mode>3): Rename to ...\n+\t(ashr<mode>3): ... This.\n+\t(ashrdi3_no_power, *ashrdisi3_noppc64be): Delete.\n+\t(*rotldi3_internal4, *rotldi3_internal5 and split,\n+\t*rotldi3_internal6 and split, *ashldi3_internal4, ashldi3_internal5\n+\tand split, *ashldi3_internal6 and split, *ashldi3_internal7,\n+\tashldi3_internal8 and split, *ashldi3_internal9 and split): Delete.\n+\t(*anddi3_2rld, *anddi3_2rld_dot, *anddi3_2rld_dot2): Delete.\n+\t(splitter for loading a mask): Adjust.\n+\t* doc/md.texi (Machine Constraints): Remove q, S, T, t constraints.\n+\n 2015-07-20  Marek Polacek  <polacek@redhat.com>\n \n \t* genemit.c (print_code, gen_exp, gen_insn, gen_expand, gen_split,"}, {"sha": "893a826dcba0ac5eff91809e7204a8698f1daafc", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -17,7 +17,7 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-;; Available constraint letters: \"e\", \"k\", \"q\", \"u\", \"A\", \"B\", \"C\", \"D\"\n+;; Available constraint letters: e k q t u A B C D S T\n \n ;; Register constraints\n \n@@ -230,29 +230,11 @@ usually better to use @samp{m} or @samp{es} in @code{asm} statements)\"\n \n ;; General constraints\n \n-(define_constraint \"S\"\n-  \"Constant that can be placed into a 64-bit mask operand\"\n-  (and (match_test \"TARGET_POWERPC64\")\n-       (match_operand 0 \"mask64_operand\")))\n-\n-(define_constraint \"T\"\n-  \"Constant that can be placed into a 32-bit mask operand\"\n-  (match_operand 0 \"mask_operand\"))\n-\n (define_constraint \"U\"\n   \"V.4 small data reference\"\n   (and (match_test \"DEFAULT_ABI == ABI_V4\")\n        (match_test \"small_data_operand (op, mode)\")))\n \n-(define_constraint \"t\"\n-  \"AND masks that can be performed by two rldic{l,r} insns\n-   (but excluding those that could match other constraints of anddi3)\"\n-  (and (and (and (match_operand 0 \"mask64_2_operand\")\n-\t\t (match_test \"(fixed_regs[CR0_REGNO]\n-\t\t\t      || !logical_operand (op, DImode))\"))\n-\t    (not (match_operand 0 \"mask_operand\")))\n-       (not (match_operand 0 \"mask64_operand\"))))\n-\n (define_constraint \"W\"\n   \"vector constant that does not require memory\"\n   (match_operand 0 \"easy_vector_constant\"))"}, {"sha": "2adeee7be31f6fb65787c1f2f59e4bb40313f0a4", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 165, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -751,178 +751,14 @@\n        (and (not (match_operand 0 \"logical_operand\"))\n \t    (match_operand 0 \"reg_or_logical_cint_operand\"))))\n \n-;; Return 1 if op is a constant that can be encoded in a 32-bit mask,\n-;; suitable for use with rlwinm (no more than two 1->0 or 0->1\n-;; transitions).  Reject all ones and all zeros, since these should have\n-;; been optimized away and confuse the making of MB and ME.\n-(define_predicate \"mask_operand\"\n-  (match_code \"const_int\")\n-{\n-  unsigned HOST_WIDE_INT c, lsb;\n-\n-  c = INTVAL (op);\n-\n-  if (TARGET_POWERPC64)\n-    {\n-      /* Fail if the mask is not 32-bit.  */\n-      if (mode == DImode && (c & ~(unsigned HOST_WIDE_INT) 0xffffffff) != 0)\n-\treturn 0;\n-\n-      /* Fail if the mask wraps around because the upper 32-bits of the\n-\t mask will all be 1s, contrary to GCC's internal view.  */\n-      if ((c & 0x80000001) == 0x80000001)\n-\treturn 0;\n-    }\n-\n-  /* We don't change the number of transitions by inverting,\n-     so make sure we start with the LS bit zero.  */\n-  if (c & 1)\n-    c = ~c;\n-\n-  /* Reject all zeros or all ones.  */\n-  if (c == 0)\n-    return 0;\n-\n-  /* Find the first transition.  */\n-  lsb = c & -c;\n-\n-  /* Invert to look for a second transition.  */\n-  c = ~c;\n-\n-  /* Erase first transition.  */\n-  c &= -lsb;\n-\n-  /* Find the second transition (if any).  */\n-  lsb = c & -c;\n-\n-  /* Match if all the bits above are 1's (or c is zero).  */\n-  return c == -lsb;\n-})\n-\n-;; Return 1 for the PowerPC64 rlwinm corner case.\n-(define_predicate \"mask_operand_wrap\"\n-  (match_code \"const_int\")\n-{\n-  unsigned HOST_WIDE_INT c, lsb;\n-\n-  c = INTVAL (op);\n-\n-  if ((c & 0x80000001) != 0x80000001)\n-    return 0;\n-\n-  c = ~c;\n-  if (c == 0)\n-    return 0;\n-\n-  lsb = c & -c;\n-  c = ~c;\n-  c &= -lsb;\n-  lsb = c & -c;\n-  return c == -lsb;\n-})\n-\n-;; Return 1 if the operand is a constant that is a PowerPC64 mask\n-;; suitable for use with rldicl or rldicr (no more than one 1->0 or 0->1\n-;; transition).  Reject all zeros, since zero should have been\n-;; optimized away and confuses the making of MB and ME.\n-(define_predicate \"mask64_operand\"\n-  (match_code \"const_int\")\n-{\n-  unsigned HOST_WIDE_INT c, lsb;\n-\n-  c = INTVAL (op);\n-\n-  /* Reject all zeros.  */\n-  if (c == 0)\n-    return 0;\n-\n-  /* We don't change the number of transitions by inverting,\n-     so make sure we start with the LS bit zero.  */\n-  if (c & 1)\n-    c = ~c;\n-\n-  /* Find the first transition.  */\n-  lsb = c & -c;\n-\n-  /* Match if all the bits above are 1's (or c is zero).  */\n-  return c == -lsb;\n-})\n-\n-;; Like mask64_operand, but allow up to three transitions.  This\n-;; predicate is used by insn patterns that generate two rldicl or\n-;; rldicr machine insns.\n-(define_predicate \"mask64_2_operand\"\n-  (match_code \"const_int\")\n-{\n-  unsigned HOST_WIDE_INT c, lsb;\n-\n-  c = INTVAL (op);\n-\n-  /* Disallow all zeros.  */\n-  if (c == 0)\n-    return 0;\n-\n-  /* We don't change the number of transitions by inverting,\n-     so make sure we start with the LS bit zero.  */\n-  if (c & 1)\n-    c = ~c;\n-\n-  /* Find the first transition.  */\n-  lsb = c & -c;\n-\n-  /* Invert to look for a second transition.  */\n-  c = ~c;\n-\n-  /* Erase first transition.  */\n-  c &= -lsb;\n-\n-  /* Find the second transition.  */\n-  lsb = c & -c;\n-\n-  /* Invert to look for a third transition.  */\n-  c = ~c;\n-\n-  /* Erase second transition.  */\n-  c &= -lsb;\n-\n-  /* Find the third transition (if any).  */\n-  lsb = c & -c;\n-\n-  /* Match if all the bits above are 1's (or c is zero).  */\n-  return c == -lsb;\n-})\n-\n-;; Match a mask_operand or a mask64_operand.\n-(define_predicate \"any_mask_operand\"\n-  (ior (match_operand 0 \"mask_operand\")\n-       (and (match_test \"TARGET_POWERPC64 && mode == DImode\")\n-\t    (match_operand 0 \"mask64_operand\"))))\n-\n-;; Like and_operand, but also match constants that can be implemented\n-;; with two rldicl or rldicr insns.\n-(define_predicate \"and64_2_operand\"\n-  (ior (match_operand 0 \"mask64_2_operand\")\n-       (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n-\t (match_operand 0 \"gpc_reg_operand\")\n-\t (match_operand 0 \"logical_operand\"))))\n-\n ;; Return 1 if the operand is either a non-special register or a\n ;; constant that can be used as the operand of a logical AND.\n (define_predicate \"and_operand\"\n-  (ior (match_operand 0 \"mask_operand\")\n-       (and (match_test \"TARGET_POWERPC64 && mode == DImode\")\n-\t    (match_operand 0 \"mask64_operand\"))\n+  (ior (match_test \"rs6000_is_valid_and_mask (op, mode)\")\n        (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n \t (match_operand 0 \"gpc_reg_operand\")\n \t (match_operand 0 \"logical_operand\"))))\n \n-;; Return 1 if the operand is a constant that can be used as the operand\n-;; of a logical AND, implemented with two rld* insns, and it cannot be done\n-;; using just one insn.\n-(define_predicate \"and_2rld_operand\"\n-  (and (match_operand 0 \"and64_2_operand\")\n-       (not (match_operand 0 \"and_operand\"))))\n-\n ;; Return 1 if the operand is either a logical operand or a short cint operand.\n (define_predicate \"scc_eq_operand\"\n   (ior (match_operand 0 \"logical_operand\")\n@@ -1128,6 +964,10 @@\n   return nonimmediate_operand (op, mode);\n })\n \n+;; Return true if operand is an operator used in rotate-and-mask instructions.\n+(define_predicate \"rotate_mask_operator\"\n+  (match_code \"rotate,ashift,lshiftrt\"))\n+\n ;; Return true if operand is boolean operator.\n (define_predicate \"boolean_operator\"\n   (match_code \"and,ior,xor\"))"}, {"sha": "30a7128ca56a66d99d172abbfb7f928481db8540", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -66,15 +66,18 @@ extern void altivec_expand_stvex_be (rtx, rtx, machine_mode, unsigned);\n extern void rs6000_expand_extract_even (rtx, rtx, rtx);\n extern void rs6000_expand_interleave (rtx, rtx, rtx, bool);\n extern void rs6000_scale_v2df (rtx, rtx, int);\n-extern void build_mask64_2_operands (rtx, rtx *);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n extern const char * rs6000_output_load_multiple (rtx[]);\n-extern int includes_lshift_p (rtx, rtx);\n-extern int includes_rshift_p (rtx, rtx);\n-extern int includes_rldic_lshift_p (rtx, rtx);\n-extern int includes_rldicr_lshift_p (rtx, rtx);\n-extern int insvdi_rshift_rlwimi_p (rtx, rtx, rtx);\n+extern bool rs6000_is_valid_mask (rtx, int *, int *, machine_mode);\n+extern bool rs6000_is_valid_and_mask (rtx, machine_mode);\n+extern bool rs6000_is_valid_shift_mask (rtx, rtx, machine_mode);\n+extern bool rs6000_is_valid_insert_mask (rtx, rtx, machine_mode);\n+extern const char *rs6000_insn_for_and_mask (machine_mode, rtx *, bool);\n+extern const char *rs6000_insn_for_shift_mask (machine_mode, rtx *, bool);\n+extern const char *rs6000_insn_for_insert_mask (machine_mode, rtx *, bool);\n+extern bool rs6000_is_valid_2insn_and (rtx, machine_mode);\n+extern void rs6000_emit_2insn_and (machine_mode, rtx *, bool, bool);\n extern int registers_ok_for_quad_peep (rtx, rtx);\n extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n@@ -102,8 +105,6 @@ extern void paired_expand_vector_move (rtx operands[]);\n \n \n extern int ccr_bit (rtx, int);\n-extern int extract_MB (rtx);\n-extern int extract_ME (rtx);\n extern void rs6000_output_function_entry (FILE *, const char *);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);"}, {"sha": "3f0fe4ffeda16fc0b756aff01b7b0c9ac44f5ced", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 503, "deletions": 293, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -5270,7 +5270,7 @@ num_insns_constant (rtx op, machine_mode mode)\n     {\n     case CONST_INT:\n       if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n-\t  && mask64_operand (op, mode))\n+\t  && rs6000_is_valid_and_mask (op, mode))\n \treturn 2;\n       else\n \treturn num_insns_constant_wide (INTVAL (op));\n@@ -5318,7 +5318,7 @@ num_insns_constant (rtx op, machine_mode mode)\n \t\t|| (high == -1 && low < 0))\n \t      return num_insns_constant_wide (low);\n \n-\t    else if (mask64_operand (op, mode))\n+\t    else if (rs6000_is_valid_and_mask (op, mode))\n \t      return 2;\n \n \t    else if (low == 0)\n@@ -6033,69 +6033,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n }\n \n-/* Generates shifts and masks for a pair of rldicl or rldicr insns to\n-   implement ANDing by the mask IN.  */\n-void\n-build_mask64_2_operands (rtx in, rtx *out)\n-{\n-  unsigned HOST_WIDE_INT c, lsb, m1, m2;\n-  int shift;\n-\n-  gcc_assert (GET_CODE (in) == CONST_INT);\n-\n-  c = INTVAL (in);\n-  if (c & 1)\n-    {\n-      /* Assume c initially something like 0x00fff000000fffff.  The idea\n-\t is to rotate the word so that the middle ^^^^^^ group of zeros\n-\t is at the MS end and can be cleared with an rldicl mask.  We then\n-\t rotate back and clear off the MS    ^^ group of zeros with a\n-\t second rldicl.  */\n-      c = ~c;\t\t\t/*   c == 0xff000ffffff00000 */\n-      lsb = c & -c;\t\t/* lsb == 0x0000000000100000 */\n-      m1 = -lsb;\t\t/*  m1 == 0xfffffffffff00000 */\n-      c = ~c;\t\t\t/*   c == 0x00fff000000fffff */\n-      c &= -lsb;\t\t/*   c == 0x00fff00000000000 */\n-      lsb = c & -c;\t\t/* lsb == 0x0000100000000000 */\n-      c = ~c;\t\t\t/*   c == 0xff000fffffffffff */\n-      c &= -lsb;\t\t/*   c == 0xff00000000000000 */\n-      shift = 0;\n-      while ((lsb >>= 1) != 0)\n-\tshift++;\t\t/* shift == 44 on exit from loop */\n-      m1 <<= 64 - shift;\t/*  m1 == 0xffffff0000000000 */\n-      m1 = ~m1;\t\t\t/*  m1 == 0x000000ffffffffff */\n-      m2 = ~c;\t\t\t/*  m2 == 0x00ffffffffffffff */\n-    }\n-  else\n-    {\n-      /* Assume c initially something like 0xff000f0000000000.  The idea\n-\t is to rotate the word so that the     ^^^  middle group of zeros\n-\t is at the LS end and can be cleared with an rldicr mask.  We then\n-\t rotate back and clear off the LS group of ^^^^^^^^^^ zeros with\n-\t a second rldicr.  */\n-      lsb = c & -c;\t\t/* lsb == 0x0000010000000000 */\n-      m2 = -lsb;\t\t/*  m2 == 0xffffff0000000000 */\n-      c = ~c;\t\t\t/*   c == 0x00fff0ffffffffff */\n-      c &= -lsb;\t\t/*   c == 0x00fff00000000000 */\n-      lsb = c & -c;\t\t/* lsb == 0x0000100000000000 */\n-      c = ~c;\t\t\t/*   c == 0xff000fffffffffff */\n-      c &= -lsb;\t\t/*   c == 0xff00000000000000 */\n-      shift = 0;\n-      while ((lsb >>= 1) != 0)\n-\tshift++;\t\t/* shift == 44 on exit from loop */\n-      m1 = ~c;\t\t\t/*  m1 == 0x00ffffffffffffff */\n-      m1 >>= shift;\t\t/*  m1 == 0x0000000000000fff */\n-      m1 = ~m1;\t\t\t/*  m1 == 0xfffffffffffff000 */\n-    }\n-\n-  /* Note that when we only have two 0->1 and 1->0 transitions, one of the\n-     masks will be all 1's.  We are guaranteed more than one transition.  */\n-  out[0] = GEN_INT (64 - shift);\n-  out[1] = GEN_INT (m1);\n-  out[2] = GEN_INT (shift);\n-  out[3] = GEN_INT (m2);\n-}\n-\n /* Return TRUE if OP is an invalid SUBREG operation on the e500.  */\n \n bool\n@@ -16423,121 +16360,495 @@ validate_condition_mode (enum rtx_code code, machine_mode mode)\n }\n \n \f\n-/* Return 1 if ANDOP is a mask that has no bits on that are not in the\n-   mask required to convert the result of a rotate insn into a shift\n-   left insn of SHIFTOP bits.  Both are known to be SImode CONST_INT.  */\n+/* Return whether MASK (a CONST_INT) is a valid mask for any rlwinm,\n+   rldicl, rldicr, or rldic instruction in mode MODE.  If so, if E is\n+   not zero, store there the bit offset (counted from the right) where\n+   the single stretch of 1 bits begins; and similarly for B, the bit\n+   offset where it ends.  */\n \n-int\n-includes_lshift_p (rtx shiftop, rtx andop)\n+bool\n+rs6000_is_valid_mask (rtx mask, int *b, int *e, machine_mode mode)\n {\n-  unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+  unsigned HOST_WIDE_INT val = INTVAL (mask);\n+  unsigned HOST_WIDE_INT bit;\n+  int nb, ne;\n+  int n = GET_MODE_PRECISION (mode);\n+\n+  if (mode != DImode && mode != SImode)\n+    return false;\n+\n+  if (INTVAL (mask) >= 0)\n+    {\n+      bit = val & -val;\n+      ne = exact_log2 (bit);\n+      nb = exact_log2 (val + bit);\n+    }\n+  else if (val + 1 == 0)\n+    {\n+      nb = n;\n+      ne = 0;\n+    }\n+  else if (val & 1)\n+    {\n+      val = ~val;\n+      bit = val & -val;\n+      nb = exact_log2 (bit);\n+      ne = exact_log2 (val + bit);\n+    }\n+  else\n+    {\n+      bit = val & -val;\n+      ne = exact_log2 (bit);\n+      if (val + bit == 0)\n+\tnb = n;\n+      else\n+\tnb = 0;\n+    }\n \n-  shift_mask <<= INTVAL (shiftop);\n+  nb--;\n \n-  return (INTVAL (andop) & 0xffffffff & ~shift_mask) == 0;\n+  if (nb < 0 || ne < 0 || nb >= n || ne >= n)\n+    return false;\n+\n+  if (b)\n+    *b = nb;\n+  if (e)\n+    *e = ne;\n+\n+  return true;\n }\n \n-/* Similar, but for right shift.  */\n+/* Return whether MASK (a CONST_INT) is a valid mask for any rlwinm, rldicl,\n+   or rldicr instruction, to implement an AND with it in mode MODE.  */\n \n-int\n-includes_rshift_p (rtx shiftop, rtx andop)\n+bool\n+rs6000_is_valid_and_mask (rtx mask, machine_mode mode)\n {\n-  unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+  int nb, ne;\n+\n+  if (!rs6000_is_valid_mask (mask, &nb, &ne, mode))\n+    return false;\n+\n+  /* For DImode, we need a rldicl, rldicr, or a rlwinm with mask that\n+     does not wrap.  */\n+  if (mode == DImode)\n+    return (ne == 0 || nb == 63 || (nb < 32 && ne <= nb));\n \n-  shift_mask >>= INTVAL (shiftop);\n+  /* For SImode, rlwinm can do everything.  */\n+  if (mode == SImode)\n+    return (nb < 32 && ne < 32);\n \n-  return (INTVAL (andop) & 0xffffffff & ~shift_mask) == 0;\n+  return false;\n }\n \n-/* Return 1 if ANDOP is a mask suitable for use with an rldic insn\n-   to perform a left shift.  It must have exactly SHIFTOP least\n-   significant 0's, then one or more 1's, then zero or more 0's.  */\n+/* Return the instruction template for an AND with mask in mode MODE, with\n+   operands OPERANDS.  If DOT is true, make it a record-form instruction.  */\n \n-int\n-includes_rldic_lshift_p (rtx shiftop, rtx andop)\n+const char *\n+rs6000_insn_for_and_mask (machine_mode mode, rtx *operands, bool dot)\n {\n-  if (GET_CODE (andop) == CONST_INT)\n+  int nb, ne;\n+\n+  if (!rs6000_is_valid_mask (operands[2], &nb, &ne, mode))\n+    gcc_unreachable ();\n+\n+  if (mode == DImode && ne == 0)\n     {\n-      unsigned HOST_WIDE_INT c, lsb, shift_mask;\n+      operands[3] = GEN_INT (63 - nb);\n+      if (dot)\n+\treturn \"rldicl. %0,%1,0,%3\";\n+      return \"rldicl %0,%1,0,%3\";\n+    }\n \n-      c = INTVAL (andop);\n-      if (c == 0 || c == HOST_WIDE_INT_M1U)\n-\treturn 0;\n+  if (mode == DImode && nb == 63)\n+    {\n+      operands[3] = GEN_INT (63 - ne);\n+      if (dot)\n+\treturn \"rldicr. %0,%1,0,%3\";\n+      return \"rldicr %0,%1,0,%3\";\n+    }\n \n-      shift_mask = HOST_WIDE_INT_M1U;\n-      shift_mask <<= INTVAL (shiftop);\n+  if (nb < 32 && ne < 32)\n+    {\n+      operands[3] = GEN_INT (31 - nb);\n+      operands[4] = GEN_INT (31 - ne);\n+      if (dot)\n+\treturn \"rlwinm. %0,%1,0,%3,%4\";\n+      return \"rlwinm %0,%1,0,%3,%4\";\n+    }\n \n-      /* Find the least significant one bit.  */\n-      lsb = c & -c;\n+  gcc_unreachable ();\n+}\n \n-      /* It must coincide with the LSB of the shift mask.  */\n-      if (-lsb != shift_mask)\n-\treturn 0;\n+/* Return whether MASK (a CONST_INT) is a valid mask for any rlw[i]nm,\n+   rld[i]cl, rld[i]cr, or rld[i]c instruction, to implement an AND with\n+   shift SHIFT (a ROTATE, ASHIFT, or LSHIFTRT) in mode MODE.  */\n+\n+bool\n+rs6000_is_valid_shift_mask (rtx mask, rtx shift, machine_mode mode)\n+{\n+  int nb, ne;\n \n-      /* Invert to look for the next transition (if any).  */\n-      c = ~c;\n+  if (!rs6000_is_valid_mask (mask, &nb, &ne, mode))\n+    return false;\n \n-      /* Remove the low group of ones (originally low group of zeros).  */\n-      c &= -lsb;\n+  int n = GET_MODE_PRECISION (mode);\n+  int sh = -1;\n \n-      /* Again find the lsb, and check we have all 1's above.  */\n-      lsb = c & -c;\n-      return c == -lsb;\n+  if (CONST_INT_P (XEXP (shift, 1)))\n+    {\n+      sh = INTVAL (XEXP (shift, 1));\n+      if (sh < 0 || sh >= n)\n+\treturn false;\n     }\n-  else\n-    return 0;\n+\n+  rtx_code code = GET_CODE (shift);\n+\n+  /* Convert any shift by 0 to a rotate, to simplify below code.  */\n+  if (sh == 0)\n+    code = ROTATE;\n+\n+  /* Convert rotate to simple shift if we can, to make analysis simpler.  */\n+  if (code == ROTATE && sh >= 0 && nb >= ne && ne >= sh)\n+    code = ASHIFT;\n+  if (code == ROTATE && sh >= 0 && nb >= ne && nb < sh)\n+    {\n+      code = LSHIFTRT;\n+      sh = n - sh;\n+    }\n+\n+  /* DImode rotates need rld*.  */\n+  if (mode == DImode && code == ROTATE)\n+    return (nb == 63 || ne == 0 || ne == sh);\n+\n+  /* SImode rotates need rlw*.  */\n+  if (mode == SImode && code == ROTATE)\n+    return (nb < 32 && ne < 32 && sh < 32);\n+\n+  /* Wrap-around masks are only okay for rotates.  */\n+  if (ne > nb)\n+    return false;\n+\n+  /* Variable shifts are only okay for rotates.  */\n+  if (sh < 0)\n+    return false;\n+\n+  /* Don't allow ASHIFT if the mask is wrong for that.  */\n+  if (code == ASHIFT && ne < sh)\n+    return false;\n+\n+  /* If we can do it with an rlw*, we can do it.  Don't allow LSHIFTRT\n+     if the mask is wrong for that.  */\n+  if (nb < 32 && ne < 32 && sh < 32\n+      && !(code == LSHIFTRT && nb >= 32 - sh))\n+    return true;\n+\n+  /* If we can do it with an rld*, we can do it.  Don't allow LSHIFTRT\n+     if the mask is wrong for that.  */\n+  if (code == LSHIFTRT)\n+    sh = 64 - sh;\n+  if (nb == 63 || ne == 0 || ne == sh)\n+    return !(code == LSHIFTRT && nb >= sh);\n+\n+  return false;\n }\n \n-/* Return 1 if ANDOP is a mask suitable for use with an rldicr insn\n-   to perform a left shift.  It must have SHIFTOP or more least\n-   significant 0's, with the remainder of the word 1's.  */\n+/* Return the instruction template for a shift with mask in mode MODE, with\n+   operands OPERANDS.  If DOT is true, make it a record-form instruction.  */\n \n-int\n-includes_rldicr_lshift_p (rtx shiftop, rtx andop)\n+const char *\n+rs6000_insn_for_shift_mask (machine_mode mode, rtx *operands, bool dot)\n {\n-  if (GET_CODE (andop) == CONST_INT)\n+  int nb, ne;\n+\n+  if (!rs6000_is_valid_mask (operands[3], &nb, &ne, mode))\n+    gcc_unreachable ();\n+\n+  if (mode == DImode && ne == 0)\n     {\n-      unsigned HOST_WIDE_INT c, lsb, shift_mask;\n+      if (GET_CODE (operands[4]) == LSHIFTRT && INTVAL (operands[2]))\n+\toperands[2] = GEN_INT (64 - INTVAL (operands[2]));\n+      operands[3] = GEN_INT (63 - nb);\n+      if (dot)\n+\treturn \"rld%I2cl. %0,%1,%2,%3\";\n+      return \"rld%I2cl %0,%1,%2,%3\";\n+    }\n \n-      shift_mask = HOST_WIDE_INT_M1U;\n-      shift_mask <<= INTVAL (shiftop);\n-      c = INTVAL (andop);\n+  if (mode == DImode && nb == 63)\n+    {\n+      operands[3] = GEN_INT (63 - ne);\n+      if (dot)\n+\treturn \"rld%I2cr. %0,%1,%2,%3\";\n+      return \"rld%I2cr %0,%1,%2,%3\";\n+    }\n \n-      /* Find the least significant one bit.  */\n-      lsb = c & -c;\n+  if (mode == DImode\n+      && GET_CODE (operands[4]) != LSHIFTRT\n+      && CONST_INT_P (operands[2])\n+      && ne == INTVAL (operands[2]))\n+    {\n+      operands[3] = GEN_INT (63 - nb);\n+      if (dot)\n+\treturn \"rld%I2c. %0,%1,%2,%3\";\n+      return \"rld%I2c %0,%1,%2,%3\";\n+    }\n \n-      /* It must be covered by the shift mask.\n-\t This test also rejects c == 0.  */\n-      if ((lsb & shift_mask) == 0)\n-\treturn 0;\n+  if (nb < 32 && ne < 32)\n+    {\n+      if (GET_CODE (operands[4]) == LSHIFTRT && INTVAL (operands[2]))\n+\toperands[2] = GEN_INT (32 - INTVAL (operands[2]));\n+      operands[3] = GEN_INT (31 - nb);\n+      operands[4] = GEN_INT (31 - ne);\n+      if (dot)\n+\treturn \"rlw%I2nm. %0,%1,%2,%3,%4\";\n+      return \"rlw%I2nm %0,%1,%2,%3,%4\";\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return whether MASK (a CONST_INT) is a valid mask for any rlwimi or\n+   rldimi instruction, to implement an insert with shift SHIFT (a ROTATE,\n+   ASHIFT, or LSHIFTRT) in mode MODE.  */\n \n-      /* Check we have all 1's above the transition, and reject all 1's.  */\n-      return c == -lsb && lsb != 1;\n+bool\n+rs6000_is_valid_insert_mask (rtx mask, rtx shift, machine_mode mode)\n+{\n+  int nb, ne;\n+\n+  if (!rs6000_is_valid_mask (mask, &nb, &ne, mode))\n+    return false;\n+\n+  int n = GET_MODE_PRECISION (mode);\n+\n+  int sh = INTVAL (XEXP (shift, 1));\n+  if (sh < 0 || sh >= n)\n+    return false;\n+\n+  rtx_code code = GET_CODE (shift);\n+\n+  /* Convert any shift by 0 to a rotate, to simplify below code.  */\n+  if (sh == 0)\n+    code = ROTATE;\n+\n+  /* Convert rotate to simple shift if we can, to make analysis simpler.  */\n+  if (code == ROTATE && sh >= 0 && nb >= ne && ne >= sh)\n+    code = ASHIFT;\n+  if (code == ROTATE && sh >= 0 && nb >= ne && nb < sh)\n+    {\n+      code = LSHIFTRT;\n+      sh = n - sh;\n     }\n-  else\n-    return 0;\n+\n+  /* DImode rotates need rldimi.  */\n+  if (mode == DImode && code == ROTATE)\n+    return (ne == sh);\n+\n+  /* SImode rotates need rlwimi.  */\n+  if (mode == SImode && code == ROTATE)\n+    return (nb < 32 && ne < 32 && sh < 32);\n+\n+  /* Wrap-around masks are only okay for rotates.  */\n+  if (ne > nb)\n+    return false;\n+\n+  /* Don't allow ASHIFT if the mask is wrong for that.  */\n+  if (code == ASHIFT && ne < sh)\n+    return false;\n+\n+  /* If we can do it with an rlwimi, we can do it.  Don't allow LSHIFTRT\n+     if the mask is wrong for that.  */\n+  if (nb < 32 && ne < 32 && sh < 32\n+      && !(code == LSHIFTRT && nb >= 32 - sh))\n+    return true;\n+\n+  /* If we can do it with an rldimi, we can do it.  Don't allow LSHIFTRT\n+     if the mask is wrong for that.  */\n+  if (code == LSHIFTRT)\n+    sh = 64 - sh;\n+  if (ne == sh)\n+    return !(code == LSHIFTRT && nb >= sh);\n+\n+  return false;\n }\n \n-/* Return 1 if operands will generate a valid arguments to rlwimi\n-instruction for insert with right shift in 64-bit mode.  The mask may\n-not start on the first bit or stop on the last bit because wrap-around\n-effects of instruction do not correspond to semantics of RTL insn.  */\n+/* Return the instruction template for an insert with mask in mode MODE, with\n+   operands OPERANDS.  If DOT is true, make it a record-form instruction.  */\n \n-int\n-insvdi_rshift_rlwimi_p (rtx sizeop, rtx startop, rtx shiftop)\n-{\n-  if (INTVAL (startop) > 32\n-      && INTVAL (startop) < 64\n-      && INTVAL (sizeop) > 1\n-      && INTVAL (sizeop) + INTVAL (startop) < 64\n-      && INTVAL (shiftop) > 0\n-      && INTVAL (sizeop) + INTVAL (shiftop) < 32\n-      && (64 - (INTVAL (shiftop) & 63)) >= INTVAL (sizeop))\n-    return 1;\n+const char *\n+rs6000_insn_for_insert_mask (machine_mode mode, rtx *operands, bool dot)\n+{\n+  int nb, ne;\n \n-  return 0;\n+  if (!rs6000_is_valid_mask (operands[3], &nb, &ne, mode))\n+    gcc_unreachable ();\n+\n+  /* Prefer rldimi because rlwimi is cracked.  */\n+  if (TARGET_POWERPC64\n+      && (!dot || mode == DImode)\n+      && GET_CODE (operands[4]) != LSHIFTRT\n+      && ne == INTVAL (operands[2]))\n+    {\n+      operands[3] = GEN_INT (63 - nb);\n+      if (dot)\n+\treturn \"rldimi. %0,%1,%2,%3\";\n+      return \"rldimi %0,%1,%2,%3\";\n+    }\n+\n+  if (nb < 32 && ne < 32)\n+    {\n+      if (GET_CODE (operands[4]) == LSHIFTRT && INTVAL (operands[2]))\n+\toperands[2] = GEN_INT (32 - INTVAL (operands[2]));\n+      operands[3] = GEN_INT (31 - nb);\n+      operands[4] = GEN_INT (31 - ne);\n+      if (dot)\n+\treturn \"rlwimi. %0,%1,%2,%3,%4\";\n+      return \"rlwimi %0,%1,%2,%3,%4\";\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return whether an AND with C (a CONST_INT) in mode MODE can be done\n+   using two machine instructions.  */\n+\n+bool\n+rs6000_is_valid_2insn_and (rtx c, machine_mode mode)\n+{\n+  /* There are two kinds of AND we can handle with two insns:\n+     1) those we can do with two rl* insn;\n+     2) ori[s];xori[s].\n+\n+     We do not handle that last case yet.  */\n+\n+  /* If there is just one stretch of ones, we can do it.  */\n+  if (rs6000_is_valid_mask (c, NULL, NULL, mode))\n+    return true;\n+\n+  /* Otherwise, fill in the lowest \"hole\"; if we can do the result with\n+     one insn, we can do the whole thing with two.  */\n+  unsigned HOST_WIDE_INT val = INTVAL (c);\n+  unsigned HOST_WIDE_INT bit1 = val & -val;\n+  unsigned HOST_WIDE_INT bit2 = (val + bit1) & ~val;\n+  unsigned HOST_WIDE_INT val1 = (val + bit1) & val;\n+  unsigned HOST_WIDE_INT bit3 = val1 & -val1;\n+  return rs6000_is_valid_and_mask (GEN_INT (val + bit3 - bit2), mode);\n }\n \n+/* Emit the two insns to do an AND in mode MODE, with operands OPERANDS.\n+   If EXPAND is true, split rotate-and-mask instructions we generate to\n+   their constituent parts as well (this is used during expand); if DOT\n+   is true, make the last insn a record-form instruction.  */\n+\n+void\n+rs6000_emit_2insn_and (machine_mode mode, rtx *operands, bool expand, bool dot)\n+{\n+  gcc_assert (!(expand && dot));\n+\n+  /* We do not actually handle record form yet.  */\n+  if (dot)\n+    gcc_unreachable ();\n+\n+  unsigned HOST_WIDE_INT val = INTVAL (operands[2]);\n+\n+  /* If it is one stretch of ones, it is DImode; shift left, mask, then\n+     shift right.  This generates better code than doing the masks without\n+     shifts, or shifting first right and then left.  */\n+  int nb, ne;\n+  if (rs6000_is_valid_mask (operands[2], &nb, &ne, mode) && nb >= ne)\n+    {\n+      gcc_assert (mode == DImode);\n+\n+      int shift = 63 - nb;\n+      if (expand)\n+\t{\n+\t  rtx tmp1 = gen_reg_rtx (DImode);\n+\t  rtx tmp2 = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_ashldi3 (tmp1, operands[1], GEN_INT (shift)));\n+\t  emit_insn (gen_anddi3 (tmp2, tmp1, GEN_INT (val << shift)));\n+\t  emit_insn (gen_lshrdi3 (operands[0], tmp2, GEN_INT (shift)));\n+\t}\n+      else\n+\t{\n+\t  rtx tmp = gen_rtx_ASHIFT (mode, operands[1], GEN_INT (shift));\n+\t  tmp = gen_rtx_AND (mode, tmp, GEN_INT (val << shift));\n+\t  emit_move_insn (operands[0], tmp);\n+\t  emit_insn (gen_lshrdi3 (operands[0], operands[0], GEN_INT (shift)));\n+\t}\n+      return;\n+    }\n+\n+  /* Otherwise, make a mask2 that cuts out the lowest \"hole\", and a mask1\n+     that does the rest.  */\n+  unsigned HOST_WIDE_INT bit1 = val & -val;\n+  unsigned HOST_WIDE_INT bit2 = (val + bit1) & ~val;\n+  unsigned HOST_WIDE_INT val1 = (val + bit1) & val;\n+  unsigned HOST_WIDE_INT bit3 = val1 & -val1;\n+\n+  unsigned HOST_WIDE_INT mask1 = -bit3 + bit2 - 1;\n+  unsigned HOST_WIDE_INT mask2 = val + bit3 - bit2;\n+\n+  gcc_assert (rs6000_is_valid_and_mask (GEN_INT (mask2), mode));\n+\n+  /* Two \"no-rotate\"-and-mask instructions, for SImode.  */\n+  if (rs6000_is_valid_and_mask (GEN_INT (mask1), mode))\n+    {\n+      gcc_assert (mode == SImode);\n+\n+      rtx reg = expand ? gen_reg_rtx (mode) : operands[0];\n+      rtx tmp = gen_rtx_AND (mode, operands[1], GEN_INT (mask1));\n+      emit_move_insn (reg, tmp);\n+      tmp = gen_rtx_AND (mode, reg, GEN_INT (mask2));\n+      emit_move_insn (operands[0], tmp);\n+      return;\n+    }\n+\n+  gcc_assert (mode == DImode);\n+\n+  /* Two \"no-rotate\"-and-mask instructions, for DImode: both are rlwinm\n+     insns; we have to do the first in SImode, because it wraps.  */\n+  if (mask2 <= 0xffffffff\n+      && rs6000_is_valid_and_mask (GEN_INT (mask1), SImode))\n+    {\n+      rtx reg = expand ? gen_reg_rtx (mode) : operands[0];\n+      rtx tmp = gen_rtx_AND (SImode, gen_lowpart (SImode, operands[1]),\n+\t\t\t     GEN_INT (mask1));\n+      rtx reg_low = gen_lowpart (SImode, reg);\n+      emit_move_insn (reg_low, tmp);\n+      tmp = gen_rtx_AND (mode, reg, GEN_INT (mask2));\n+      emit_move_insn (operands[0], tmp);\n+      return;\n+    }\n+\n+  /* Two rld* insns: rotate, clear the hole in the middle (which now is\n+     at the top end), rotate back and clear the other hole.  */\n+  int right = exact_log2 (bit3);\n+  int left = 64 - right;\n+\n+  /* Rotate the mask too.  */\n+  mask1 = (mask1 >> right) | ((bit2 - 1) << left);\n+\n+  if (expand)\n+    {\n+      rtx tmp1 = gen_reg_rtx (DImode);\n+      rtx tmp2 = gen_reg_rtx (DImode);\n+      rtx tmp3 = gen_reg_rtx (DImode);\n+      emit_insn (gen_rotldi3 (tmp1, operands[1], GEN_INT (left)));\n+      emit_insn (gen_anddi3 (tmp2, tmp1, GEN_INT (mask1)));\n+      emit_insn (gen_rotldi3 (tmp3, tmp2, GEN_INT (right)));\n+      emit_insn (gen_anddi3 (operands[0], tmp3, GEN_INT (mask2)));\n+    }\n+  else\n+    {\n+      rtx tmp = gen_rtx_ROTATE (mode, operands[1], GEN_INT (left));\n+      tmp = gen_rtx_AND (mode, tmp, GEN_INT (mask1));\n+      emit_move_insn (operands[0], tmp);\n+      tmp = gen_rtx_ROTATE (mode, operands[0], GEN_INT (right));\n+      tmp = gen_rtx_AND (mode, tmp, GEN_INT (mask2));\n+      emit_move_insn (operands[0], tmp);\n+    }\n+}\n+\f\n /* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates\n    for lfq and stfq insns iff the registers are hard registers.   */\n \n@@ -18422,71 +18733,6 @@ rs6000_init_machine_status (void)\n \f\n #define INT_P(X) (GET_CODE (X) == CONST_INT && GET_MODE (X) == VOIDmode)\n \n-int\n-extract_MB (rtx op)\n-{\n-  int i;\n-  unsigned long val = INTVAL (op);\n-\n-  /* If the high bit is zero, the value is the first 1 bit we find\n-     from the left.  */\n-  if ((val & 0x80000000) == 0)\n-    {\n-      gcc_assert (val & 0xffffffff);\n-\n-      i = 1;\n-      while (((val <<= 1) & 0x80000000) == 0)\n-\t++i;\n-      return i;\n-    }\n-\n-  /* If the high bit is set and the low bit is not, or the mask is all\n-     1's, the value is zero.  */\n-  if ((val & 1) == 0 || (val & 0xffffffff) == 0xffffffff)\n-    return 0;\n-\n-  /* Otherwise we have a wrap-around mask.  Look for the first 0 bit\n-     from the right.  */\n-  i = 31;\n-  while (((val >>= 1) & 1) != 0)\n-    --i;\n-\n-  return i;\n-}\n-\n-int\n-extract_ME (rtx op)\n-{\n-  int i;\n-  unsigned long val = INTVAL (op);\n-\n-  /* If the low bit is zero, the value is the first 1 bit we find from\n-     the right.  */\n-  if ((val & 1) == 0)\n-    {\n-      gcc_assert (val & 0xffffffff);\n-\n-      i = 30;\n-      while (((val >>= 1) & 1) == 0)\n-\t--i;\n-\n-      return i;\n-    }\n-\n-  /* If the low bit is set and the high bit is not, or the mask is all\n-     1's, the value is 31.  */\n-  if ((val & 0x80000000) == 0 || (val & 0xffffffff) == 0xffffffff)\n-    return 31;\n-\n-  /* Otherwise we have a wrap-around mask.  Look for the first 0 bit\n-     from the left.  */\n-  i = 0;\n-  while (((val <<= 1) & 0x80000000) != 0)\n-    ++i;\n-\n-  return i;\n-}\n-\n /* Write out a function code label.  */\n \n void\n@@ -18536,21 +18782,6 @@ print_operand (FILE *file, rtx x, int code)\n     {\n       /* %a is output_address.  */\n \n-    case 'b':\n-      /* If constant, low-order 16 bits of constant, unsigned.\n-\t Otherwise, write normally.  */\n-      if (INT_P (x))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xffff);\n-      else\n-\tprint_operand (file, x, 0);\n-      return;\n-\n-    case 'B':\n-      /* If the low-order bit is zero, write 'r'; otherwise, write 'l'\n-\t for 64-bit mask direction.  */\n-      putc (((INTVAL (x) & 1) == 0 ? 'r' : 'l'), file);\n-      return;\n-\n       /* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise\n \t output_operand.  */\n \n@@ -18713,24 +18944,6 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       return;\n \n-    case 'm':\n-      /* MB value for a mask operand.  */\n-      if (! mask_operand (x, SImode))\n-\toutput_operand_lossage (\"invalid %%m value\");\n-\n-      fprintf (file, \"%d\", extract_MB (x));\n-      return;\n-\n-    case 'M':\n-      /* ME value for a mask operand.  */\n-      if (! mask_operand (x, SImode))\n-\toutput_operand_lossage (\"invalid %%M value\");\n-\n-      fprintf (file, \"%d\", extract_ME (x));\n-      return;\n-\n-      /* %n outputs the negative of its operand.  */\n-\n     case 'N':\n       /* Write the number of elements in the vector times 4.  */\n       if (GET_CODE (x) != PARALLEL)\n@@ -18819,44 +19032,6 @@ print_operand (FILE *file, rtx x, int code)\n \tfprintf (file, \"%d\", 128 >> (REGNO (x) - CR0_REGNO));\n       return;\n \n-    case 's':\n-      /* Low 5 bits of 32 - value */\n-      if (! INT_P (x))\n-\toutput_operand_lossage (\"invalid %%s value\");\n-      else\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, (32 - INTVAL (x)) & 31);\n-      return;\n-\n-    case 'S':\n-      /* PowerPC64 mask position.  All 0's is excluded.\n-\t CONST_INT 32-bit mask is considered sign-extended so any\n-\t transition must occur within the CONST_INT, not on the boundary.  */\n-      if (! mask64_operand (x, DImode))\n-\toutput_operand_lossage (\"invalid %%S value\");\n-\n-      uval = INTVAL (x);\n-\n-      if (uval & 1)\t/* Clear Left */\n-\t{\n-#if HOST_BITS_PER_WIDE_INT > 64\n-\t  uval &= ((unsigned HOST_WIDE_INT) 1 << 64) - 1;\n-#endif\n-\t  i = 64;\n-\t}\n-      else\t\t/* Clear Right */\n-\t{\n-\t  uval = ~uval;\n-#if HOST_BITS_PER_WIDE_INT > 64\n-\t  uval &= ((unsigned HOST_WIDE_INT) 1 << 64) - 1;\n-#endif\n-\t  i = 63;\n-\t}\n-      while (uval != 0)\n-\t--i, uval >>= 1;\n-      gcc_assert (i >= 0);\n-      fprintf (file, \"%d\", i);\n-      return;\n-\n     case 't':\n       /* Like 'J' but get to the OVERFLOW/UNORDERED bit.  */\n       gcc_assert (REG_P (x) && GET_MODE (x) == CCmode);\n@@ -18962,13 +19137,6 @@ print_operand (FILE *file, rtx x, int code)\n \tprint_operand (file, x, 0);\n       return;\n \n-    case 'W':\n-      /* MB value for a PowerPC64 rldic operand.  */\n-      i = clz_hwi (INTVAL (x));\n-\n-      fprintf (file, \"%d\", i);\n-      return;\n-\n     case 'x':\n       /* X is a FPR or Altivec register used in a VSX context.  */\n       if (GET_CODE (x) != REG || !VSX_REGNO_P (REGNO (x)))\n@@ -30671,10 +30839,7 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t      && (satisfies_constraint_K (x)\n \t\t  || (mode == SImode\n \t\t      ? satisfies_constraint_L (x)\n-\t\t      : satisfies_constraint_J (x))\n-\t\t  || mask_operand (x, mode)\n-\t\t  || (mode == DImode\n-\t\t      && mask64_operand (x, DImode))))\n+\t\t      : satisfies_constraint_J (x))))\n \t  || ((outer_code == IOR || outer_code == XOR)\n \t      && (satisfies_constraint_K (x)\n \t\t  || (mode == SImode\n@@ -30823,15 +30988,60 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \n     case NOT:\n       if (outer_code == AND || outer_code == IOR || outer_code == XOR)\n+\t*total = 0;\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return false;\n+\n+    case AND:\n+      if (CONST_INT_P (XEXP (x, 1)))\n \t{\n-\t  *total = 0;\n-\t  return false;\n+\t  rtx left = XEXP (x, 0);\n+\t  rtx_code left_code = GET_CODE (left);\n+\n+\t  /* rotate-and-mask: 1 insn.  */\n+\t  if ((left_code == ROTATE\n+\t       || left_code == ASHIFT\n+\t       || left_code == LSHIFTRT)\n+\t      && rs6000_is_valid_shift_mask (XEXP (x, 1), left, mode))\n+\t    {\n+\t      *total = rtx_cost (XEXP (left, 0), mode, left_code, 0, speed);\n+\t      if (!CONST_INT_P (XEXP (left, 1)))\n+\t\t*total += rtx_cost (XEXP (left, 1), SImode, left_code, 1, speed);\n+\t      *total += COSTS_N_INSNS (1);\n+\t      return true;\n+\t    }\n+\n+\t  /* rotate-and-mask (no rotate), andi., andis.: 1 insn.  */\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n+\t  if (rs6000_is_valid_and_mask (XEXP (x, 1), mode)\n+\t      || (val & 0xffff) == val\n+\t      || (val & 0xffff0000) == val\n+\t      || ((val & 0xffff) == 0 && mode == SImode))\n+\t    {\n+\t      *total = rtx_cost (left, mode, AND, 0, speed);\n+\t      *total += COSTS_N_INSNS (1);\n+\t      return true;\n+\t    }\n+\n+\t  /* 2 insns.  */\n+\t  if (rs6000_is_valid_2insn_and (XEXP (x, 1), mode))\n+\t    {\n+\t      *total = rtx_cost (left, mode, AND, 0, speed);\n+\t      *total += COSTS_N_INSNS (2);\n+\t      return true;\n+\t    }\n \t}\n-      /* FALLTHRU */\n \n-    case AND:\n-    case CLZ:\n+      *total = COSTS_N_INSNS (1);\n+      return false;\n+\n     case IOR:\n+      /* FIXME */\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case CLZ:\n     case XOR:\n     case ZERO_EXTRACT:\n       *total = COSTS_N_INSNS (1);"}, {"sha": "5727068060c4d3f0476db58d60269865e5c1d9b0", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 353, "deletions": 992, "changes": 1345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -2245,17 +2245,23 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(bswap:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n   \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(rotate:SI (match_dup 1) (const_int 8)))\n-   (set (zero_extract:SI (match_dup 0)\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 0))\n-\t(match_dup 1))\n-   (set (zero_extract:SI (match_dup 0)\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 16))\n+  [(set (match_dup 0)\t\t\t\t\t; DABC\n \t(rotate:SI (match_dup 1)\n-\t\t   (const_int 16)))]\n+\t\t   (const_int 24)))\n+   (set (match_dup 0)\t\t\t\t\t; DCBC\n+\t(ior:SI (and:SI (ashift:SI (match_dup 1)\n+\t\t\t\t   (const_int 8))\n+\t\t\t(const_int 16711680))\n+\t\t(and:SI (match_dup 0)\n+\t\t\t(const_int -16711681))))\n+   (set (match_dup 0)\t\t\t\t\t; DCBA\n+\t(ior:SI (and:SI (lshiftrt:SI (match_dup 1)\n+\t\t\t\t     (const_int 24))\n+\t\t\t(const_int 255))\n+\t\t(and:SI (match_dup 0)\n+\t\t\t(const_int -256))))\n+\n+  ]\n   \"\")\n \n (define_expand \"bswapdi2\"\n@@ -2892,21 +2898,26 @@\n       DONE;\n     }\n \n+  if (rs6000_is_valid_and_mask (operands[2], <MODE>mode))\n+    {\n+      emit_insn (gen_and<mode>3_mask (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+\n   if (logical_const_operand (operands[2], <MODE>mode)\n-      && !any_mask_operand (operands[2], <MODE>mode))\n+      && rs6000_gen_cell_microcode)\n     {\n-      if (rs6000_gen_cell_microcode)\n-\t{\n-\t  emit_insn (gen_and<mode>3_imm (operands[0], operands[1], operands[2]));\n-\t  DONE;\n-\t}\n-      else\n-\toperands[2] = force_reg (<MODE>mode, operands[2]);\n+      emit_insn (gen_and<mode>3_imm (operands[0], operands[1], operands[2]));\n+      DONE;\n     }\n \n-  if ((<MODE>mode == DImode && !and64_2_operand (operands[2], <MODE>mode))\n-      || (<MODE>mode != DImode && !and_operand (operands[2], <MODE>mode)))\n-    operands[2] = force_reg (<MODE>mode, operands[2]);\n+  if (rs6000_is_valid_2insn_and (operands[2], <MODE>mode))\n+    {\n+      rs6000_emit_2insn_and (<MODE>mode, operands, true, false);\n+      DONE;\n+    }\n+\n+  operands[2] = force_reg (<MODE>mode, operands[2]);\n })\n \n \n@@ -2916,7 +2927,7 @@\n \t\t (match_operand:GPR 2 \"logical_const_operand\" \"n\")))\n    (clobber (match_scratch:CC 3 \"=x\"))]\n   \"rs6000_gen_cell_microcode\n-   && !any_mask_operand (operands[2], <MODE>mode)\"\n+   && !rs6000_is_valid_and_mask (operands[2], <MODE>mode)\"\n   \"andi%e2. %0,%1,%u2\"\n   [(set_attr \"type\" \"logical\")\n    (set_attr \"dot\" \"yes\")])\n@@ -2930,7 +2941,7 @@\n    (clobber (match_scratch:CC 4 \"=X,x\"))]\n   \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n    && rs6000_gen_cell_microcode\n-   && !any_mask_operand (operands[2], <MODE>mode)\"\n+   && !rs6000_is_valid_and_mask (operands[2], <MODE>mode)\"\n   \"@\n    andi%e2. %0,%1,%u2\n    #\"\n@@ -2958,7 +2969,7 @@\n    (clobber (match_scratch:CC 4 \"=X,x\"))]\n   \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n    && rs6000_gen_cell_microcode\n-   && !any_mask_operand (operands[2], <MODE>mode)\"\n+   && !rs6000_is_valid_and_mask (operands[2], <MODE>mode)\"\n   \"@\n    andi%e2. %0,%1,%u2\n    #\"\n@@ -2982,8 +2993,7 @@\n \t\t    (const_int 0)))\n    (clobber (match_scratch:GPR 0 \"=r,r\"))]\n   \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n-   && rs6000_gen_cell_microcode\n-   && any_mask_operand (operands[2], <MODE>mode)\"\n+   && rs6000_gen_cell_microcode\"\n   \"@\n    andi%e2. %0,%1,%u2\n    #\"\n@@ -3008,8 +3018,7 @@\n \t(and:GPR (match_dup 1)\n \t\t (match_dup 2)))]\n   \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n-   && rs6000_gen_cell_microcode\n-   && any_mask_operand (operands[2], <MODE>mode)\"\n+   && rs6000_gen_cell_microcode\"\n   \"@\n    andi%e2. %0,%1,%u2\n    #\"\n@@ -3025,31 +3034,68 @@\n    (set_attr \"dot\" \"yes\")\n    (set_attr \"length\" \"4,8\")])\n \n-\n-(define_insn \"*and<mode>3_mask\"\n-  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t (match_operand:GPR 2 \"any_mask_operand\" \"S,T\")))]\n+(define_insn_and_split \"*and<mode>3_imm_dot_shifted\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC\n+\t  (and:GPR\n+\t    (lshiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t  (match_operand:SI 4 \"const_int_operand\" \"n,n\"))\n+\t    (match_operand:GPR 2 \"const_int_operand\" \"n,n\"))\n+\t  (const_int 0)))\n+   (clobber (match_scratch:GPR 0 \"=r,r\"))]\n+  \"logical_const_operand (GEN_INT (UINTVAL (operands[2])\n+\t\t\t\t   << INTVAL (operands[4])),\n+\t\t\t  DImode)\n+   && (<MODE>mode == Pmode\n+       || (UINTVAL (operands[2]) << INTVAL (operands[4])) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\"\n+{\n+  operands[2] = GEN_INT (UINTVAL (operands[2]) << INTVAL (operands[4]));\n+  if (which_alternative == 0)\n+    return \"andi%e2. %0,%1,%u2\";\n+  else\n+    return \"#\";\n+}\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (lshiftrt:GPR (match_dup 1)\n+\t\t\t       (match_dup 4))\n+\t\t (match_dup 2)))\n+   (set (match_dup 3)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n   \"\"\n-  \"@\n-   rldic%B2 %0,%1,0,%S2\n-   rlwinm %0,%1,0,%m2,%M2\"\n+  [(set_attr \"type\" \"logical\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+\n+(define_insn \"and<mode>3_mask\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r\")\n+\t\t (match_operand:GPR 2 \"const_int_operand\" \"n\")))]\n+  \"rs6000_is_valid_and_mask (operands[2], <MODE>mode)\"\n+{\n+  return rs6000_insn_for_and_mask (<MODE>mode, operands, false);\n+}\n   [(set_attr \"type\" \"shift\")])\n \n (define_insn_and_split \"*and<mode>3_mask_dot\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t\t     (match_operand:GPR 2 \"any_mask_operand\" \"S,T,S,T\"))\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t     (match_operand:GPR 2 \"const_int_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:GPR 0 \"=r,r,r,r\"))]\n+   (clobber (match_scratch:GPR 0 \"=r,r\"))]\n   \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n    && rs6000_gen_cell_microcode\n-   && !logical_const_operand (operands[2], <MODE>mode)\"\n-  \"@\n-   rldic%B2. %0,%1,0,%S2\n-   rlwinm. %0,%1,0,%m2,%M2\n-   #\n-   #\"\n+   && !logical_const_operand (operands[2], <MODE>mode)\n+   && rs6000_is_valid_and_mask (operands[2], <MODE>mode)\"\n+{\n+  if (which_alternative == 0)\n+    return rs6000_insn_for_and_mask (<MODE>mode, operands, true);\n+  else\n+    return \"#\";\n+}\n   \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(and:GPR (match_dup 1)\n@@ -3060,24 +3106,26 @@\n   \"\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,4,8,8\")])\n+   (set_attr \"length\" \"4,8\")])\n \n (define_insn_and_split \"*and<mode>3_mask_dot2\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t\t     (match_operand:GPR 2 \"any_mask_operand\" \"S,T,S,T\"))\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t     (match_operand:GPR 2 \"const_int_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:GPR (match_dup 1)\n \t\t (match_dup 2)))]\n   \"(<MODE>mode == Pmode || UINTVAL (operands[2]) <= 0x7fffffff)\n    && rs6000_gen_cell_microcode\n-   && !logical_const_operand (operands[2], <MODE>mode)\"\n-  \"@\n-   rldic%B2. %0,%1,0,%S2\n-   rlwinm. %0,%1,0,%m2,%M2\n-   #\n-   #\"\n+   && !logical_const_operand (operands[2], <MODE>mode)\n+   && rs6000_is_valid_and_mask (operands[2], <MODE>mode)\"\n+{\n+  if (which_alternative == 0)\n+    return rs6000_insn_for_and_mask (<MODE>mode, operands, true);\n+  else\n+    return \"#\";\n+}\n   \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n \t(and:GPR (match_dup 1)\n@@ -3088,43 +3136,25 @@\n   \"\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,4,8,8\")])\n-\n-\n-\n-(define_insn \"andsi3_internal0_nomc\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-        (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r\")\n-                (match_operand:SI 2 \"and_operand\" \"?r,T\")))]\n-  \"!rs6000_gen_cell_microcode\"\n-  \"@\n-   and %0,%1,%2\n-   rlwinm %0,%1,0,%m2,%M2\"\n-  [(set_attr \"type\" \"logical,shift\")])\n-\n+   (set_attr \"length\" \"4,8\")])\n \n-;; Handle the PowerPC64 rlwinm corner case\n \n-(define_insn_and_split \"*andsi3_internal6\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:SI 2 \"mask_operand_wrap\" \"i\")))]\n-  \"TARGET_POWERPC64\"\n+; TODO: dots of this\n+(define_insn_and_split \"*and<mode>3_2insn\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r\")\n+\t\t (match_operand:GPR 2 \"const_int_operand\" \"n\")))]\n+  \"rs6000_is_valid_2insn_and (operands[2], <MODE>mode)\n+   && !(rs6000_is_valid_and_mask (operands[2], <MODE>mode)\n+\t|| (logical_const_operand (operands[2], <MODE>mode)\n+\t    && rs6000_gen_cell_microcode))\"\n   \"#\"\n-  \"TARGET_POWERPC64\"\n-  [(set (match_dup 0)\n-\t(and:SI (rotate:SI (match_dup 1) (match_dup 3))\n-\t\t(match_dup 4)))\n-   (set (match_dup 0)\n-\t(rotate:SI (match_dup 0) (match_dup 5)))]\n-  \"\n+  \"&& 1\"\n+  [(pc)]\n {\n-  int mb = extract_MB (operands[2]);\n-  int me = extract_ME (operands[2]);\n-  operands[3] = GEN_INT (me + 1);\n-  operands[5] = GEN_INT (32 - (me + 1));\n-  operands[4] = GEN_INT (~((HOST_WIDE_INT) -1 << (33 + me - mb)));\n-}\"\n+  rs6000_emit_2insn_and (<MODE>mode, operands, false, false);\n+  DONE;\n+}\n   [(set_attr \"length\" \"8\")])\n \n \n@@ -3366,318 +3396,239 @@\n   \"eqv %0,%1,%2\"\n   [(set_attr \"type\" \"logical\")])\n \f\n-;; Rotate and shift insns, in all their variants.  These support shifts,\n-;; field inserts and extracts, and various combinations thereof.\n-(define_expand \"insv\"\n-  [(set (zero_extract (match_operand 0 \"gpc_reg_operand\" \"\")\n-\t\t       (match_operand:SI 1 \"const_int_operand\" \"\")\n-\t\t       (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t(match_operand 3 \"gpc_reg_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Do not handle 16/8 bit structures that fit in HI/QI modes directly, since\n-     the (SUBREG:SI (REG:HI xxx)) that is otherwise generated can confuse the\n-     compiler if the address of the structure is taken later.  Likewise, do\n-     not handle invalid E500 subregs.  */\n-  if (GET_CODE (operands[0]) == SUBREG\n-      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0]))) < UNITS_PER_WORD\n-\t  || ((TARGET_E500_DOUBLE || TARGET_SPE)\n-\t      && invalid_e500_subreg (operands[0], GET_MODE (operands[0])))))\n-    FAIL;\n-\n-  if (TARGET_POWERPC64 && GET_MODE (operands[0]) == DImode)\n-    emit_insn (gen_insvdi_internal (operands[0], operands[1], operands[2],\n-\t\t\t\t    operands[3]));\n-  else\n-    emit_insn (gen_insvsi_internal (operands[0], operands[1], operands[2],\n-\t\t\t\t    operands[3]));\n-  DONE;\n-}\")\n+;; Rotate-and-mask and insert.\n \n-(define_insn \"insvsi_internal\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(match_operand:SI 3 \"gpc_reg_operand\" \"r\"))]\n-  \"\"\n-  \"*\n-{\n-  int start = INTVAL (operands[2]) & 31;\n-  int size = INTVAL (operands[1]) & 31;\n-\n-  operands[4] = GEN_INT (32 - start - size);\n-  operands[1] = GEN_INT (start + size - 1);\n-  return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\"\n-  [(set_attr \"type\" \"insert\")])\n-\n-(define_insn \"*insvsi_internal1\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(rotate:SI (match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-\t\t   (match_operand:SI 4 \"const_int_operand\" \"i\")))]\n-  \"(32 - (INTVAL (operands[4]) & 31)) >= INTVAL (operands[1])\"\n-  \"*\n+(define_insn \"*rotl<mode>3_mask\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:GPR (match_operator:GPR 4 \"rotate_mask_operator\"\n+\t\t  [(match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")])\n+\t\t (match_operand:GPR 3 \"const_int_operand\" \"n\")))]\n+  \"rs6000_is_valid_shift_mask (operands[3], operands[4], <MODE>mode)\"\n {\n-  int shift = INTVAL (operands[4]) & 31;\n-  int start = INTVAL (operands[2]) & 31;\n-  int size = INTVAL (operands[1]) & 31;\n-\n-  operands[4] = GEN_INT (shift - start - size);\n-  operands[1] = GEN_INT (start + size - 1);\n-  return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\"\n-  [(set_attr \"type\" \"insert\")])\n+  return rs6000_insn_for_shift_mask (<MODE>mode, operands, false);\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"yes\")])\n \n-(define_insn \"*insvsi_internal2\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(ashiftrt:SI (match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 4 \"const_int_operand\" \"i\")))]\n-  \"(32 - (INTVAL (operands[4]) & 31)) >= INTVAL (operands[1])\"\n-  \"*\n+(define_insn_and_split \"*rotl<mode>3_mask_dot\"\n+  [(set (match_operand:CC 5 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC\n+\t  (and:GPR (match_operator:GPR 4 \"rotate_mask_operator\"\n+\t\t    [(match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\")])\n+\t\t   (match_operand:GPR 3 \"const_int_operand\" \"n,n\"))\n+\t  (const_int 0)))\n+   (clobber (match_scratch:GPR 0 \"=r,r\"))]\n+  \"(<MODE>mode == Pmode || UINTVAL (operands[3]) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\n+   && rs6000_is_valid_shift_mask (operands[3], operands[4], <MODE>mode)\"\n {\n-  int shift = INTVAL (operands[4]) & 31;\n-  int start = INTVAL (operands[2]) & 31;\n-  int size = INTVAL (operands[1]) & 31;\n-\n-  operands[4] = GEN_INT (32 - shift - start - size);\n-  operands[1] = GEN_INT (start + size - 1);\n-  return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\"\n-  [(set_attr \"type\" \"insert\")])\n+  if (which_alternative == 0)\n+    return rs6000_insn_for_shift_mask (<MODE>mode, operands, true);\n+  else\n+    return \"#\";\n+}\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[5], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (match_dup 4)\n+\t\t (match_dup 3)))\n+   (set (match_dup 5)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"yes\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*insvsi_internal3\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(lshiftrt:SI (match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 4 \"const_int_operand\" \"i\")))]\n-  \"(32 - (INTVAL (operands[4]) & 31)) >= INTVAL (operands[1])\"\n-  \"*\n+(define_insn_and_split \"*rotl<mode>3_mask_dot2\"\n+  [(set (match_operand:CC 5 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC\n+\t  (and:GPR (match_operator:GPR 4 \"rotate_mask_operator\"\n+\t\t    [(match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\")])\n+\t\t   (match_operand:GPR 3 \"const_int_operand\" \"n,n\"))\n+\t  (const_int 0)))\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:GPR (match_dup 4)\n+\t\t (match_dup 3)))]\n+  \"(<MODE>mode == Pmode || UINTVAL (operands[3]) <= 0x7fffffff)\n+   && rs6000_gen_cell_microcode\n+   && rs6000_is_valid_shift_mask (operands[3], operands[4], <MODE>mode)\"\n {\n-  int shift = INTVAL (operands[4]) & 31;\n-  int start = INTVAL (operands[2]) & 31;\n-  int size = INTVAL (operands[1]) & 31;\n-\n-  operands[4] = GEN_INT (32 - shift - start - size);\n-  operands[1] = GEN_INT (start + size - 1);\n-  return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\"\n-  [(set_attr \"type\" \"insert\")])\n+  if (which_alternative == 0)\n+    return rs6000_insn_for_shift_mask (<MODE>mode, operands, true);\n+  else\n+    return \"#\";\n+}\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[5], CCmode)\"\n+  [(set (match_dup 0)\n+\t(and:GPR (match_dup 4)\n+\t\t (match_dup 3)))\n+   (set (match_dup 5)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"yes\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*insvsi_internal4\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(zero_extract:SI (match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-\t\t\t (match_operand:SI 4 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 5 \"const_int_operand\" \"i\")))]\n-  \"INTVAL (operands[4]) >= INTVAL (operands[1])\"\n-  \"*\n-{\n-  int extract_start = INTVAL (operands[5]) & 31;\n-  int extract_size = INTVAL (operands[4]) & 31;\n-  int insert_start = INTVAL (operands[2]) & 31;\n-  int insert_size = INTVAL (operands[1]) & 31;\n \n-/* Align extract field with insert field */\n-  operands[5] = GEN_INT (extract_start + extract_size - insert_start - insert_size);\n-  operands[1] = GEN_INT (insert_start + insert_size - 1);\n-  return \\\"rlwimi %0,%3,%h5,%h2,%h1\\\";\n-}\"\n+; Two forms for insert (the two arms of the IOR are not canonicalized,\n+; both are an AND so are the same precedence).\n+(define_insn \"*rotl<mode>3_insert\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:GPR (and:GPR (match_operator:GPR 4 \"rotate_mask_operator\"\n+\t\t\t   [(match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"n\")])\n+\t\t\t  (match_operand:GPR 3 \"const_int_operand\" \"n\"))\n+\t\t (and:GPR (match_operand:GPR 5 \"gpc_reg_operand\" \"0\")\n+\t\t\t  (match_operand:GPR 6 \"const_int_operand\" \"n\"))))]\n+  \"rs6000_is_valid_insert_mask (operands[3], operands[4], <MODE>mode)\n+   && UINTVAL (operands[3]) + UINTVAL (operands[6]) + 1 == 0\"\n+{\n+  return rs6000_insn_for_insert_mask (<MODE>mode, operands, false);\n+}\n   [(set_attr \"type\" \"insert\")])\n+; FIXME: this needs an attr \"size\", so that the scheduler can see the\n+; difference between rlwimi and rldimi.  We also might want dot forms,\n+; but not for rlwimi on POWER4 and similar processors.\n \n-;; combine patterns for rlwimi\n-(define_insn \"*insvsi_internal5\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (ior:SI (and:SI (match_operand:SI 4 \"gpc_reg_operand\" \"0\")\n-                        (match_operand:SI 1 \"mask_operand\" \"i\"))\n-                (and:SI (lshiftrt:SI (match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-                                     (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-                        (match_operand:SI 5 \"mask_operand\" \"i\"))))]\n-  \"INTVAL(operands[1]) == ~INTVAL(operands[5])\"\n-  \"*\n-{\n- int me = extract_ME(operands[5]);\n- int mb = extract_MB(operands[5]);\n- operands[4] = GEN_INT(32 - INTVAL(operands[2]));\n- operands[2] = GEN_INT(mb);\n- operands[1] = GEN_INT(me);\n- return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\"\n+(define_insn \"*rotl<mode>3_insert_2\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 5 \"gpc_reg_operand\" \"0\")\n+\t\t\t  (match_operand:GPR 6 \"const_int_operand\" \"n\"))\n+\t\t (and:GPR (match_operator:GPR 4 \"rotate_mask_operator\"\n+\t\t\t   [(match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"n\")])\n+\t\t\t  (match_operand:GPR 3 \"const_int_operand\" \"n\"))))]\n+  \"rs6000_is_valid_insert_mask (operands[3], operands[4], <MODE>mode)\n+   && UINTVAL (operands[3]) + UINTVAL (operands[6]) + 1 == 0\"\n+{\n+  return rs6000_insn_for_insert_mask (<MODE>mode, operands, false);\n+}\n   [(set_attr \"type\" \"insert\")])\n \n-(define_insn \"*insvsi_internal6\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (ior:SI (and:SI (lshiftrt:SI (match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-                                     (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-                        (match_operand:SI 5 \"mask_operand\" \"i\"))\n-                (and:SI (match_operand:SI 4 \"gpc_reg_operand\" \"0\")\n-                        (match_operand:SI 1 \"mask_operand\" \"i\"))))]\n-  \"INTVAL(operands[1]) == ~INTVAL(operands[5])\"\n-  \"*\n-{\n- int me = extract_ME(operands[5]);\n- int mb = extract_MB(operands[5]);\n- operands[4] = GEN_INT(32 - INTVAL(operands[2]));\n- operands[2] = GEN_INT(mb);\n- operands[1] = GEN_INT(me);\n- return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\"\n+; There are also some forms without one of the ANDs.\n+(define_insn \"*rotl<mode>3_insert_3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 3 \"gpc_reg_operand\" \"0\")\n+\t\t\t  (match_operand:GPR 4 \"const_int_operand\" \"n\"))\n+\t\t (ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n+  \"INTVAL (operands[2]) == exact_log2 (UINTVAL (operands[4]) + 1)\"\n+{\n+  if (<MODE>mode == SImode)\n+    return \"rlwimi %0,%1,%h2,0,31-%h2\";\n+  else\n+    return \"rldimi %0,%1,%H2,0\";\n+}\n   [(set_attr \"type\" \"insert\")])\n \n-(define_insn \"insvdi_internal\"\n-  [(set (zero_extract:DI (match_operand:DI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(match_operand:DI 3 \"gpc_reg_operand\" \"r\"))]\n-  \"TARGET_POWERPC64\"\n-  \"*\n-{\n-  int start = INTVAL (operands[2]) & 63;\n-  int size = INTVAL (operands[1]) & 63;\n-\n-  operands[1] = GEN_INT (64 - start - size);\n-  return \\\"rldimi %0,%3,%H1,%H2\\\";\n-}\"\n-  [(set_attr \"type\" \"insert\")\n-   (set_attr \"size\" \"64\")])\n-\n-(define_insn \"*insvdi_internal2\"\n-  [(set (zero_extract:DI (match_operand:DI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(ashiftrt:DI (match_operand:DI 3 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 4 \"const_int_operand\" \"i\")))]\n-  \"TARGET_POWERPC64\n-   && insvdi_rshift_rlwimi_p (operands[1], operands[2], operands[4])\"\n-  \"*\n-{\n-  int shift = INTVAL (operands[4]) & 63;\n-  int start = (INTVAL (operands[2]) & 63) - 32;\n-  int size = INTVAL (operands[1]) & 63;\n-\n-  operands[4] = GEN_INT (64 - shift - start - size);\n-  operands[2] = GEN_INT (start);\n-  operands[1] = GEN_INT (start + size - 1);\n-  return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\")\n-\n-(define_insn \"*insvdi_internal3\"\n-  [(set (zero_extract:DI (match_operand:DI 0 \"gpc_reg_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(lshiftrt:DI (match_operand:DI 3 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:SI 4 \"const_int_operand\" \"i\")))]\n-  \"TARGET_POWERPC64\n-   && insvdi_rshift_rlwimi_p (operands[1], operands[2], operands[4])\"\n-  \"*\n-{\n-  int shift = INTVAL (operands[4]) & 63;\n-  int start = (INTVAL (operands[2]) & 63) - 32;\n-  int size = INTVAL (operands[1]) & 63;\n-\n-  operands[4] = GEN_INT (64 - shift - start - size);\n-  operands[2] = GEN_INT (start);\n-  operands[1] = GEN_INT (start + size - 1);\n-  return \\\"rlwimi %0,%3,%h4,%h2,%h1\\\";\n-}\")\n-\n-(define_expand \"extzv\"\n-  [(set (match_operand 0 \"gpc_reg_operand\" \"\")\n-\t(zero_extract (match_operand 1 \"gpc_reg_operand\" \"\")\n-\t\t       (match_operand:SI 2 \"const_int_operand\" \"\")\n-\t\t       (match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* Do not handle 16/8 bit structures that fit in HI/QI modes directly, since\n-     the (SUBREG:SI (REG:HI xxx)) that is otherwise generated can confuse the\n-     compiler if the address of the structure is taken later.  */\n-  if (GET_CODE (operands[0]) == SUBREG\n-      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0]))) < UNITS_PER_WORD))\n-    FAIL;\n-\n-  if (TARGET_POWERPC64 && GET_MODE (operands[1]) == DImode)\n-    emit_insn (gen_extzvdi_internal (operands[0], operands[1], operands[2],\n-\t\t\t\t     operands[3]));\n+(define_insn \"*rotl<mode>3_insert_4\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 3 \"gpc_reg_operand\" \"0\")\n+\t\t\t  (match_operand:GPR 4 \"const_int_operand\" \"n\"))\n+\t\t (lshiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t       (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n+  \"<MODE>mode == SImode &&\n+   GET_MODE_PRECISION (<MODE>mode)\n+   == INTVAL (operands[2]) + exact_log2 (-UINTVAL (operands[4]))\"\n+{\n+  operands[2] = GEN_INT (GET_MODE_PRECISION (<MODE>mode)\n+\t\t\t - INTVAL (operands[2]));\n+  if (<MODE>mode == SImode)\n+    return \"rlwimi %0,%1,%h2,32-%h2,31\";\n   else\n-    FAIL;\n-\n-  DONE;\n-}\")\n+    return \"rldimi %0,%1,%H2,64-%H2\";\n+}\n+  [(set_attr \"type\" \"insert\")])\n \n-(define_insn \"extzvdi_internal\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extract:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n-  \"TARGET_POWERPC64\"\n-  \"*\n-{\n-  int start = INTVAL (operands[3]) & 63;\n-  int size = INTVAL (operands[2]) & 63;\n \n-  if (start + size >= 64)\n-    operands[3] = const0_rtx;\n-  else\n-    operands[3] = GEN_INT (start + size);\n-  operands[2] = GEN_INT (64 - size);\n-  return \\\"rldicl %0,%1,%3,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"shift\")])\n+; This handles the important case of multiple-precision shifts.  There is\n+; no canonicalization rule for ASHIFT vs. LSHIFTRT, so two patterns.\n+(define_split\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\")\n+\t(ior:GPR (ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\")\n+\t\t\t     (match_operand:SI 3 \"const_int_operand\"))\n+\t\t (lshiftrt:GPR (match_operand:GPR 2 \"gpc_reg_operand\")\n+\t\t\t       (match_operand:SI 4 \"const_int_operand\"))))]\n+  \"can_create_pseudo_p ()\n+   && INTVAL (operands[3]) + INTVAL (operands[4])\n+      >= GET_MODE_PRECISION (<MODE>mode)\"\n+  [(set (match_dup 5)\n+\t(lshiftrt:GPR (match_dup 2)\n+\t\t      (match_dup 4)))\n+   (set (match_dup 0)\n+\t(ior:GPR (and:GPR (match_dup 5)\n+\t\t\t  (match_dup 6))\n+\t\t (ashift:GPR (match_dup 1)\n+\t\t\t     (match_dup 3))))]\n+{\n+  unsigned HOST_WIDE_INT mask = 1;\n+  mask = (mask << INTVAL (operands[3])) - 1;\n+  operands[5] = gen_reg_rtx (<MODE>mode);\n+  operands[6] = GEN_INT (mask);\n+})\n \n-(define_insn \"*extzvdi_internal1\"\n-  [(set (match_operand:CC 0 \"gpc_reg_operand\" \"=x\")\n-\t(compare:CC (zero_extract:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"=r\"))]\n-  \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n-  \"*\n-{\n-  int start = INTVAL (operands[3]) & 63;\n-  int size = INTVAL (operands[2]) & 63;\n+(define_split\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\")\n+\t(ior:GPR (lshiftrt:GPR (match_operand:GPR 2 \"gpc_reg_operand\")\n+\t\t\t       (match_operand:SI 4 \"const_int_operand\"))\n+\t\t (ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\")\n+\t\t\t     (match_operand:SI 3 \"const_int_operand\"))))]\n+  \"can_create_pseudo_p ()\n+   && INTVAL (operands[3]) + INTVAL (operands[4])\n+      >= GET_MODE_PRECISION (<MODE>mode)\"\n+  [(set (match_dup 5)\n+\t(lshiftrt:GPR (match_dup 2)\n+\t\t      (match_dup 4)))\n+   (set (match_dup 0)\n+\t(ior:GPR (and:GPR (match_dup 5)\n+\t\t\t  (match_dup 6))\n+\t\t (ashift:GPR (match_dup 1)\n+\t\t\t     (match_dup 3))))]\n+{\n+  unsigned HOST_WIDE_INT mask = 1;\n+  mask = (mask << INTVAL (operands[3])) - 1;\n+  operands[5] = gen_reg_rtx (<MODE>mode);\n+  operands[6] = GEN_INT (mask);\n+})\n \n-  if (start + size >= 64)\n-    operands[3] = const0_rtx;\n-  else\n-    operands[3] = GEN_INT (start + size);\n-  operands[2] = GEN_INT (64 - size);\n-  return \\\"rldicl. %4,%1,%3,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")])\n \n-(define_insn \"*extzvdi_internal2\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x\")\n-\t(compare:CC (zero_extract:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extract:DI (match_dup 1) (match_dup 2) (match_dup 3)))]\n-  \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n-  \"*\n-{\n-  int start = INTVAL (operands[3]) & 63;\n-  int size = INTVAL (operands[2]) & 63;\n+; Another important case is setting some bits to 1; we can do that with\n+; an insert instruction, in many cases.\n+(define_insn_and_split \"*ior<mode>_mask\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand:GPR 2 \"const_int_operand\" \"n\")))]\n+  \"can_create_pseudo_p ()\n+   && !logical_const_operand (operands[2], <MODE>mode)\n+   && rs6000_is_valid_mask (operands[2], NULL, NULL, <MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 3)\n+\t(const_int -1))\n+   (set (match_dup 0)\n+\t(ior:GPR (and:GPR (rotate:GPR (match_dup 3)\n+\t\t\t\t      (match_dup 4))\n+\t\t\t  (match_dup 2))\n+\t\t (and:GPR (match_dup 1)\n+\t\t\t  (match_dup 5))))]\n+{\n+  int nb, ne;\n+  rs6000_is_valid_mask (operands[2], &nb, &ne, <MODE>mode);\n+  operands[3] = gen_reg_rtx (<MODE>mode);\n+  operands[4] = GEN_INT (ne);\n+  operands[5] = GEN_INT (~UINTVAL (operands[2]));\n+}\n+  [(set_attr \"type\" \"two\")\n+   (set_attr \"length\" \"8\")])\n \n-  if (start + size >= 64)\n-    operands[3] = const0_rtx;\n-  else\n-    operands[3] = GEN_INT (start + size);\n-  operands[2] = GEN_INT (64 - size);\n-  return \\\"rldicl. %0,%1,%3,%2\\\";\n-}\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")])\n \n+;; Now the simple shifts.\n \n (define_insn \"rotl<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n@@ -3747,74 +3698,6 @@\n    (set_attr \"length\" \"4,8\")])\n \n \n-(define_insn \"*rotlsi3_mask\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\"))\n-\t\t(match_operand:SI 3 \"mask_operand\" \"n\")))]\n-  \"\"\n-  \"rlw%I2nm %0,%1,%h2,%m3,%M3\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")])\n-\n-(define_insn_and_split \"*rotlsi3_mask_dot\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n-\t\t (match_operand:SI 3 \"mask_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r,r\"))]\n-  \"rs6000_gen_cell_microcode\n-   && (TARGET_32BIT || UINTVAL (operands[3]) <= 0x7fffffff)\"\n-  \"@\n-   rlw%I2nm. %0,%1,%h2,%m3,%M3\n-   #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n-  [(set (match_dup 0)\n-\t(and:SI (rotate:SI (match_dup 1)\n-\t\t\t   (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_insn_and_split \"*rotlsi3_mask_dot2\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (rotate:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n-\t\t (match_operand:SI 3 \"mask_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (rotate:SI (match_dup 1)\n-\t\t\t   (match_dup 2))\n-\t\t(match_dup 3)))]\n-  \"rs6000_gen_cell_microcode\n-   && (TARGET_32BIT || UINTVAL (operands[3]) <= 0x7fffffff)\"\n-  \"@\n-   rlw%I2nm. %0,%1,%h2,%m3,%M3\n-   #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n-  [(set (match_dup 0)\n-\t(and:SI (rotate:SI (match_dup 1)\n-\t\t\t   (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-\n (define_insn \"ashl<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n@@ -3861,91 +3744,24 @@\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (ashift:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ashift:GPR (match_dup 1)\n-\t\t    (match_dup 2)))]\n-  \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n-  \"@\n-   sl<wd>%I2. %0,%1,%<hH>2\n-   #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n-  [(set (match_dup 0)\n-\t(ashift:GPR (match_dup 1)\n-\t\t    (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-\n-(define_insn \"*ashlsi3_imm_mask\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (ashift:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:SI 3 \"mask_operand\" \"n\")))]\n-  \"includes_lshift_p (operands[2], operands[3])\"\n-  \"rlwinm %0,%1,%h2,%m3,%M3\"\n-  [(set_attr \"type\" \"shift\")])\n-\n-(define_insn_and_split \"*ashlsi3_imm_mask_dot\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (ashift:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:SI 3 \"mask_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r,r\"))]\n-  \"rs6000_gen_cell_microcode\n-   && (TARGET_32BIT || UINTVAL (operands[3]) <= 0x7fffffff)\n-   && includes_lshift_p (operands[2], operands[3])\"\n-  \"@\n-   rlwinm. %0,%1,%h2,%m3,%M3\n-   #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n-  [(set (match_dup 0)\n-\t(and:SI (ashift:SI (match_dup 1)\n-\t\t\t   (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_insn_and_split \"*ashlsi3_imm_mask_dot2\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (ashift:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:SI 3 \"mask_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (ashift:SI (match_dup 1)\n-\t\t\t   (match_dup 2))\n-\t\t(match_dup 3)))]\n-  \"rs6000_gen_cell_microcode\n-   && (TARGET_32BIT || UINTVAL (operands[3]) <= 0x7fffffff)\n-   && includes_lshift_p (operands[2], operands[3])\"\n+\t\t    (const_int 0)))\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(ashift:GPR (match_dup 1)\n+\t\t    (match_dup 2)))]\n+  \"<MODE>mode == Pmode && rs6000_gen_cell_microcode\"\n   \"@\n-   rlwinm. %0,%1,%h2,%m3,%M3\n+   sl<wd>%I2. %0,%1,%<hH>2\n    #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n+  \"&& reload_completed && cc_reg_not_cr0_operand (operands[3], CCmode)\"\n   [(set (match_dup 0)\n-\t(and:SI (ashift:SI (match_dup 1)\n-\t\t\t   (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n+\t(ashift:GPR (match_dup 1)\n+\t\t    (match_dup 2)))\n+   (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\"\n   [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"yes\")\n    (set_attr \"dot\" \"yes\")\n    (set_attr \"length\" \"4,8\")])\n \n@@ -4018,97 +3834,7 @@\n    (set_attr \"length\" \"4,8\")])\n \n \n-(define_insn \"*lshrsi3_imm_mask\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:SI (lshiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:SI 3 \"mask_operand\" \"n\")))]\n-  \"includes_rshift_p (operands[2], operands[3])\"\n-  \"rlwinm %0,%1,%s2,%m3,%M3\"\n-  [(set_attr \"type\" \"shift\")])\n-\n-(define_insn_and_split \"*lshrsi3_imm_mask_dot\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (lshiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t      (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:SI 3 \"mask_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r,r\"))]\n-  \"rs6000_gen_cell_microcode\n-   && (TARGET_32BIT || UINTVAL (operands[3]) <= 0x7fffffff)\n-   && includes_rshift_p (operands[2], operands[3])\"\n-  \"@\n-   rlwinm. %0,%1,%s2,%m3,%M3\n-   #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n-  [(set (match_dup 0)\n-\t(and:SI (lshiftrt:SI (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_insn_and_split \"*lshrsi3_imm_mask_dot2\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (lshiftrt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t      (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:SI 3 \"mask_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:SI (lshiftrt:SI (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t(match_dup 3)))]\n-  \"rs6000_gen_cell_microcode\n-   && (TARGET_32BIT || UINTVAL (operands[3]) <= 0x7fffffff)\n-   && includes_rshift_p (operands[2], operands[3])\"\n-  \"@\n-   rlwinm. %0,%1,%s2,%m3,%M3\n-   #\"\n-  \"&& reload_completed && cc_reg_not_cr0_operand (operands[4], CCmode)\"\n-  [(set (match_dup 0)\n-\t(and:SI (lshiftrt:SI (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-\n-(define_expand \"ashr<mode>3\"\n-  [(parallel [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n-\t\t   (ashiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))\n-\t      (clobber (reg:GPR CA_REGNO))])]\n-  \"\"\n-{\n-  /* The generic code does not generate optimal code for the low word\n-     (it should be a rlwimi and a rot).  Until we have target code to\n-     solve this generically, keep this expander.  */\n-\n-  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n-    {\n-      if (CONST_INT_P (operands[2]))\n-\t{\n-\t  emit_insn (gen_ashrdi3_no_power (operands[0], operands[1], operands[2]));\n-\t  DONE;\n-\t}\n-      else\n-\tFAIL;\n-    }\n-})\n-\n-(define_insn \"*ashr<mode>3\"\n+(define_insn \"ashr<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(ashiftrt:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n \t\t      (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")))\n@@ -5736,373 +5462,6 @@\n   emit_insn (gen_subfdi3_carry_in (hi0, hi2, hi1));\n   DONE;\n })\n-\n-\n-;; Shift by a variable amount is too complex to be worth open-coding.  We\n-;; just handle shifts by constants.\n-(define_insn \"ashrdi3_no_power\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"M,i\")))\n-   (clobber (reg:SI CA_REGNO))]\n-  \"!TARGET_POWERPC64\"\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case 0:\n-      if (WORDS_BIG_ENDIAN)\n-        return \\\"srawi %0,%1,31\\;srawi %L0,%1,%h2\\\";\n-      else\n-        return \\\"srawi %L0,%L1,31\\;srawi %0,%L1,%h2\\\";\n-    case 1:\n-      if (WORDS_BIG_ENDIAN)\n-\treturn \\\"srwi %L0,%L1,%h2\\;insrwi %L0,%1,%h2,0\\;srawi %0,%1,%h2\\\";\n-      else\n-\treturn \\\"srwi %0,%1,%h2\\;insrwi %0,%L1,%h2,0\\;srawi %L0,%L1,%h2\\\";\n-    }\n-}\n-  [(set_attr \"type\" \"two,three\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_insn \"*ashrdisi3_noppc64be\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-                                (const_int 32)) 4))]\n-  \"TARGET_32BIT && !TARGET_POWERPC64 && WORDS_BIG_ENDIAN\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \\\"\\\";\n-  else\n-    return \\\"mr %0,%1\\\";\n-}\"\n-   [(set_attr \"length\" \"4\")])\n-\n-\f\n-;; PowerPC64 DImode operations.\n-\n-(define_insn \"*rotldi3_internal4\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:DI (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t   (match_operand:DI 2 \"reg_or_cint_operand\" \"rn\"))\n-\t\t(match_operand:DI 3 \"mask64_operand\" \"n\")))]\n-  \"TARGET_POWERPC64\"\n-  \"rld%I2c%B3 %0,%1,%H2,%S3\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")])\n-\n-(define_insn \"*rotldi3_internal5\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI\n-\t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"=r,r\"))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   rld%I2c%B3. %4,%1,%H2,%S3\n-   #\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (and:DI\n-\t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 4)\n-\t(and:DI (rotate:DI (match_dup 1)\n-\t\t\t\t(match_dup 2))\n-\t\t     (match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*rotldi3_internal6\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI\n-\t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"rn,rn\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   rld%I2c%B3. %0,%1,%H2,%S3\n-   #\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"maybe_var_shift\" \"yes\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (and:DI\n-\t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-\n-(define_insn \"*ashldi3_internal4\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:DI 3 \"const_int_operand\" \"n\")))]\n-  \"TARGET_POWERPC64 && includes_rldic_lshift_p (operands[2], operands[3])\"\n-  \"rldic %0,%1,%H2,%W3\"\n-  [(set_attr \"type\" \"shift\")])\n-\n-(define_insn \"ashldi3_internal5\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"const_int_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"=r,r\"))]\n-  \"TARGET_64BIT && includes_rldic_lshift_p (operands[2], operands[3])\"\n-  \"@\n-   rldic. %4,%1,%H2,%W3\n-   #\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"const_int_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\n-   && includes_rldic_lshift_p (operands[2], operands[3])\"\n-  [(set (match_dup 4)\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*ashldi3_internal6\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t    (match_operand:DI 3 \"const_int_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_64BIT && includes_rldic_lshift_p (operands[2], operands[3])\"\n-  \"@\n-   rldic. %0,%1,%H2,%W3\n-   #\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"const_int_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_POWERPC64 && reload_completed\n-   && includes_rldic_lshift_p (operands[2], operands[3])\"\n-  [(set (match_dup 0)\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*ashldi3_internal7\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:DI 3 \"mask64_operand\" \"n\")))]\n-  \"TARGET_POWERPC64 && includes_rldicr_lshift_p (operands[2], operands[3])\"\n-  \"rldicr %0,%1,%H2,%S3\"\n-  [(set_attr \"type\" \"shift\")])\n-\n-(define_insn \"ashldi3_internal8\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"=r,r\"))]\n-  \"TARGET_64BIT && includes_rldicr_lshift_p (operands[2], operands[3])\"\n-  \"@\n-   rldicr. %4,%1,%H2,%S3\n-   #\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\n-   && includes_rldicr_lshift_p (operands[2], operands[3])\"\n-  [(set (match_dup 4)\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*ashldi3_internal9\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t    (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_64BIT && includes_rldicr_lshift_p (operands[2], operands[3])\"\n-  \"@\n-   rldicr. %0,%1,%H2,%S3\n-   #\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_POWERPC64 && reload_completed\n-   && includes_rldicr_lshift_p (operands[2], operands[3])\"\n-  [(set (match_dup 0)\n-\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-\n-(define_insn_and_split \"*anddi3_2rld\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"and_2rld_operand\" \"n\")))]\n-  \"TARGET_POWERPC64\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 0)\n-\t(and:DI (rotate:DI (match_dup 1)\n-\t\t\t   (match_dup 4))\n-\t\t(match_dup 5)))\n-   (set (match_dup 0)\n-\t(and:DI (rotate:DI (match_dup 0)\n-\t\t\t   (match_dup 6))\n-\t\t(match_dup 7)))]\n-{\n-  build_mask64_2_operands (operands[2], &operands[4]);\n-}\n-  [(set_attr \"length\" \"8\")])\n-\n-(define_insn_and_split \"*anddi3_2rld_dot\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:DI 2 \"and_2rld_operand\" \"n,n\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r,r\"))]\n-  \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n-  \"@\n-   #\n-   #\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:DI (rotate:DI (match_dup 1)\n-\t\t\t   (match_dup 4))\n-\t\t(match_dup 5)))\n-   (parallel [(set (match_dup 3)\n-\t\t   (compare:CC (and:DI (rotate:DI (match_dup 0)\n-\t\t\t\t\t\t  (match_dup 6))\n-\t\t\t\t       (match_dup 7))\n-\t\t\t       (const_int 0)))\n-\t      (clobber (match_dup 0))])]\n-{\n-  build_mask64_2_operands (operands[2], &operands[4]);\n-}\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_insn_and_split \"*anddi3_2rld_dot2\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n-\t\t\t    (match_operand:DI 2 \"and_2rld_operand\" \"n,n\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(and:DI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"TARGET_64BIT && rs6000_gen_cell_microcode\"\n-  \"@\n-   #\n-   #\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:DI (rotate:DI (match_dup 1)\n-\t\t\t   (match_dup 4))\n-\t\t(match_dup 5)))\n-   (parallel [(set (match_dup 3)\n-\t\t   (compare:CC (and:DI (rotate:DI (match_dup 0)\n-\t\t\t\t\t\t  (match_dup 6))\n-\t\t\t\t       (match_dup 7))\n-\t\t\t       (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (and:DI (rotate:DI (match_dup 0)\n-\t\t\t\t      (match_dup 6))\n-\t\t\t   (match_dup 7)))])]\n-{\n-  build_mask64_2_operands (operands[2], &operands[4]);\n-}\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"dot\" \"yes\")\n-   (set_attr \"length\" \"8,12\")])\n \f\n ;; 128-bit logical operations expanders\n \n@@ -7685,16 +7044,18 @@\n   [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr,vecsimple\")\n    (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4,4,4\")])\n \n-;; Generate all one-bits and clear left or right.\n-;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n+; Some DImode loads are best done as a load of -1 followed by a mask\n+; instruction.\n (define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"mask64_operand\" \"\"))]\n-  \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n-  [(set (match_dup 0) (const_int -1))\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\")\n+\t(match_operand:DI 1 \"const_int_operand\"))]\n+  \"TARGET_POWERPC64\n+   && num_insns_constant (operands[1], DImode) > 1\n+   && rs6000_is_valid_and_mask (operands[1], DImode)\"\n+  [(set (match_dup 0)\n+\t(const_int -1))\n    (set (match_dup 0)\n-\t(and:DI (rotate:DI (match_dup 0)\n-\t\t\t   (const_int 0))\n+\t(and:DI (match_dup 0)\n \t\t(match_dup 1)))]\n   \"\")\n "}, {"sha": "0ec229ff3818d9c536f7288cc24673f77b4624f9", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc5cca3880987199e2a65dfd0b56162711f451d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=7fc5cca3880987199e2a65dfd0b56162711f451d", "patch": "@@ -3173,9 +3173,6 @@ instructions.\n @item h\n @samp{MQ}, @samp{CTR}, or @samp{LINK} register\n \n-@item q\n-@samp{MQ} register\n-\n @item c\n @samp{CTR} register\n \n@@ -3268,18 +3265,9 @@ AIX TOC entry\n Address operand that is an indexed or indirect from a register (@samp{p} is\n preferable for @code{asm} statements)\n \n-@item S\n-Constant suitable as a 64-bit mask operand\n-\n-@item T\n-Constant suitable as a 32-bit mask operand\n-\n @item U\n System V Release 4 small data area reference\n \n-@item t\n-AND masks that can be performed by two rldic@{l, r@} instructions\n-\n @item W\n Vector constant that does not require memory\n "}]}