{"sha": "dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJmODMzZWUxMTA3YWQ5MDE5M2JjMDFjOWIwNzNhNWY1ZGExYTFiNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-03-20T07:13:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-03-20T07:13:38Z"}, "message": "Makefile.in (dojump.o): Depend on $(GGC_H) and dojump.h.\n\n\t* Makefile.in (dojump.o): Depend on $(GGC_H) and dojump.h.\n\t(GTFILES): Add $(srcdir)/dojump.h.\n\t(gt-dojump.h): New dependency.\n\t* dojump.c (and_reg, and_test, shift_test): New static variables.\n\t(prefer_and_bit_test): New function.\n\t(do_jump): Use it to choose between (X & (1 << C)) and (X >> C) & 1.\n\nFrom-SVN: r79732", "tree": {"sha": "e476fa61be9fd061a4ef69e7378ead1fe041dc34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e476fa61be9fd061a4ef69e7378ead1fe041dc34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/comments", "author": null, "committer": null, "parents": [{"sha": "ab16524d6248bc92df21a63a0b5f71ec8cea168f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab16524d6248bc92df21a63a0b5f71ec8cea168f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab16524d6248bc92df21a63a0b5f71ec8cea168f"}], "stats": {"total": 80, "additions": 78, "deletions": 2}, "files": [{"sha": "551e551bd790ba8d25236f964fc6e993289be86f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "patch": "@@ -1,3 +1,12 @@\n+2004-03-20  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* Makefile.in (dojump.o): Depend on $(GGC_H) and dojump.h.\n+\t(GTFILES): Add $(srcdir)/dojump.h.\n+\t(gt-dojump.h): New dependency.\n+\t* dojump.c (and_reg, and_test, shift_test): New static variables.\n+\t(prefer_and_bit_test): New function.\n+\t(do_jump): Use it to choose between (X & (1 << C)) and (X >> C) & 1.\n+\n 2004-03-20  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-common.c, cfgcleanup.c, cgraphunit.c, c-pretty-print.c,"}, {"sha": "2b11c82a71ce499f56e90cfd25607c8629d8f799", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "patch": "@@ -1597,7 +1597,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) f\n    except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H)\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n-   langhooks.h\n+   langhooks.h $(GGC_H) gt-dojump.h\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H)\\\n    flags.h $(TARGET_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n@@ -2086,6 +2086,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n+  $(srcdir)/dojump.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/fold-const.c $(srcdir)/function.c \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n@@ -2105,7 +2106,7 @@ gt-cgraph.h gt-coverage.h gtype-desc.h gtype-desc.c gt-except.h \\\n gt-function.h gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h \\\n gt-emit-rtl.h gt-explow.h gt-stor-layout.h gt-regclass.h \\\n gt-lists.h gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h \\\n-gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h \\\n+gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \\\n gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \\\n gt-c-pragma.h gtype-c.h gt-input.h gt-cfglayout.h \\"}, {"sha": "83af19bb7f3fd25722eae0c6cacbea8496f29e66", "filename": "gcc/dojump.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf833ee1107ad90193bc01c9b073a5f5da1a1b7/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=dbf833ee1107ad90193bc01c9b073a5f5da1a1b7", "patch": "@@ -33,7 +33,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"langhooks.h\"\n+#include \"ggc.h\"\n \n+static bool prefer_and_bit_test (enum machine_mode, int);\n static void do_jump_by_parts_greater (tree, int, rtx, rtx);\n static void do_jump_by_parts_equality (tree, rtx, rtx);\n static void do_compare_and_jump\t(tree, enum rtx_code, enum rtx_code, rtx,\n@@ -101,6 +103,45 @@ jumpif (tree exp, rtx label)\n   do_jump (exp, NULL_RTX, label);\n }\n \n+/* Used internally by prefer_and_bit_test.  */\n+\n+static GTY(()) rtx and_reg;\n+static GTY(()) rtx and_test;\n+static GTY(()) rtx shift_test;\n+\n+/* Compare the relative costs of \"(X & (1 << BITNUM))\" and \"(X >> BITNUM) & 1\",\n+   where X is an arbitrary register of mode MODE.  Return true if the former\n+   is preferred.  */\n+\n+static bool\n+prefer_and_bit_test (enum machine_mode mode, int bitnum)\n+{\n+  if (and_test == 0)\n+    {\n+      /* Set up rtxes for the two variations.  Use NULL as a placeholder\n+\t for the BITNUM-based constants.  */\n+      and_reg = gen_rtx_REG (mode, FIRST_PSEUDO_REGISTER);\n+      and_test = gen_rtx_AND (mode, and_reg, NULL);\n+      shift_test = gen_rtx_AND (mode, gen_rtx_ASHIFTRT (mode, and_reg, NULL),\n+\t\t\t\tconst1_rtx);\n+    }\n+  else\n+    {\n+      /* Change the mode of the previously-created rtxes.  */\n+      PUT_MODE (and_reg, mode);\n+      PUT_MODE (and_test, mode);\n+      PUT_MODE (shift_test, mode);\n+      PUT_MODE (XEXP (shift_test, 0), mode);\n+    }\n+\n+  /* Fill in the integers.  */\n+  XEXP (and_test, 0) = GEN_INT ((unsigned HOST_WIDE_INT) 1 << bitnum);\n+  XEXP (XEXP (shift_test, 0), 1) = GEN_INT (bitnum);\n+\n+  return (rtx_cost (and_test, IF_THEN_ELSE)\n+\t  <= rtx_cost (shift_test, IF_THEN_ELSE));\n+}\n+\n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.\n    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,\n@@ -206,6 +247,29 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       break;\n \n     case BIT_AND_EXPR:\n+      /* fold_single_bit_test() converts (X & (1 << C)) into (X >> C) & 1.\n+\t See if the former is preferred for jump tests and restore it\n+\t if so.  */\n+      if (TREE_CODE (TREE_OPERAND (exp, 0)) == RSHIFT_EXPR\n+\t  && integer_onep (TREE_OPERAND (exp, 1)))\n+\t{\n+\t  tree arg = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\t  tree shift = TREE_OPERAND (TREE_OPERAND (exp, 0), 1);\n+\t  tree one = TREE_OPERAND (exp, 1);\n+\t  tree argtype = TREE_TYPE (arg);\n+\t  if (TREE_CODE (shift) == INTEGER_CST\n+\t      && compare_tree_int (shift, 0) > 0\n+\t      && compare_tree_int (shift, HOST_BITS_PER_WIDE_INT) < 0\n+\t      && prefer_and_bit_test (TYPE_MODE (argtype),\n+\t\t\t\t      TREE_INT_CST_LOW (shift)))\n+\t    {\n+\t      do_jump (build (BIT_AND_EXPR, argtype, arg,\n+\t\t\t      fold (build (LSHIFT_EXPR, argtype, one, shift))),\n+\t\t       if_false_label, if_true_label);\n+\t      break;\n+\t    }\n+\t}\n+\n       /* If we are AND'ing with a small constant, do this comparison in the\n          smallest type that fits.  If the machine doesn't have comparisons\n          that small, it will be converted back to the wider comparison.\n@@ -999,3 +1063,5 @@ do_compare_and_jump (tree exp, enum rtx_code signed_code,\n                             ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n                            if_false_label, if_true_label);\n }\n+\n+#include \"gt-dojump.h\""}]}