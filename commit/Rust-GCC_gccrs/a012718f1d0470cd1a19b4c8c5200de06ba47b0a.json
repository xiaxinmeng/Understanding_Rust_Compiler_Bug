{"sha": "a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxMjcxOGYxZDA0NzBjZDFhMTliNGM4YzUyMDBkZTA2YmE0N2IwYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-07-16T07:51:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-07-16T07:51:31Z"}, "message": "mips-protos.h (gen_int_relational): Delete.\n\n\t* config/mips/mips-protos.h (gen_int_relational): Delete.\n\t(mips_emit_scc): Declare.\n\t* config/mips/mips.c (internal_test): Delete.\n\t(sle_operand, sleu_operand): New functions.\n\t(map_test_to_internal_test, gen_int_relational): Delete.\n\t(mips_emit_binary, mips_relational_operand_ok_p)\n\t(mips_emit_int_relational, mips_zero_if_equal)\n\t(mips_emit_scc): New functions.\n\t(gen_conditional_branch): Rework to use mips_emit_int_relational.\n\t* config/mips/mips.h (PREDICATE_CODES): Add sle_operand and\n\tsleu_operand.\n\t* config/mips/mips.md (seq, sne, sgt, sge, slt, sle, sgtu, sgeu)\n\t(sltu, sleu): Use mips_emit_scc.\n\t(*sge_[sd]i, *sgeu_[sd]i): New patterns.\n\t(*sle_[sd]i, *sle_[sd]i_mips16): Use sle_operand.\n\t(*sleu_[sd]i, *sleu_[sd]i_mips16): Use sleu_operand.\n\nFrom-SVN: r84808", "tree": {"sha": "fdb914921216c412160ce92fdd0c989f530d682f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb914921216c412160ce92fdd0c989f530d682f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/comments", "author": null, "committer": null, "parents": [{"sha": "c03eb5a30599b730d1ae4fb6ec6868b97d6340a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c03eb5a30599b730d1ae4fb6ec6868b97d6340a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c03eb5a30599b730d1ae4fb6ec6868b97d6340a7"}], "stats": {"total": 594, "additions": 226, "deletions": 368}, "files": [{"sha": "a57ee1c7d86408b2b6ebca371d3615360e36b380", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "patch": "@@ -1,3 +1,22 @@\n+2004-07-16  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (gen_int_relational): Delete.\n+\t(mips_emit_scc): Declare.\n+\t* config/mips/mips.c (internal_test): Delete.\n+\t(sle_operand, sleu_operand): New functions.\n+\t(map_test_to_internal_test, gen_int_relational): Delete.\n+\t(mips_emit_binary, mips_relational_operand_ok_p)\n+\t(mips_emit_int_relational, mips_zero_if_equal)\n+\t(mips_emit_scc): New functions.\n+\t(gen_conditional_branch): Rework to use mips_emit_int_relational.\n+\t* config/mips/mips.h (PREDICATE_CODES): Add sle_operand and\n+\tsleu_operand.\n+\t* config/mips/mips.md (seq, sne, sgt, sge, slt, sle, sgtu, sgeu)\n+\t(sltu, sleu): Use mips_emit_scc.\n+\t(*sge_[sd]i, *sgeu_[sd]i): New patterns.\n+\t(*sle_[sd]i, *sle_[sd]i_mips16): Use sle_operand.\n+\t(*sleu_[sd]i, *sleu_[sd]i_mips16): Use sleu_operand.\n+\n 2004-07-16  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (*sgt_di_mips16): Fix destination constraint."}, {"sha": "73a7e75ad9251db1123181bbd835dd70cba3b715", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "patch": "@@ -123,7 +123,7 @@ extern void mips_split_64bit_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n extern rtx mips_gp_save_slot (void);\n #ifdef RTX_CODE\n-extern rtx gen_int_relational (enum rtx_code, rtx, rtx, rtx, int *);\n+extern bool mips_emit_scc (enum rtx_code, rtx);\n extern void gen_conditional_branch (rtx *, enum rtx_code);\n #endif\n extern void gen_conditional_move (rtx *);"}, {"sha": "648abbf00d2bb494b2f9b5eacd132ca2589f357d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 142, "deletions": 281, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "patch": "@@ -57,24 +57,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"sched-int.h\"\n #include \"tree-gimple.h\"\n \n-/* Enumeration for all of the relational tests, so that we can build\n-   arrays indexed by the test type, and not worry about the order\n-   of EQ, NE, etc.  */\n-\n-enum internal_test {\n-  ITEST_EQ,\n-  ITEST_NE,\n-  ITEST_GT,\n-  ITEST_GE,\n-  ITEST_LT,\n-  ITEST_LE,\n-  ITEST_GTU,\n-  ITEST_GEU,\n-  ITEST_LTU,\n-  ITEST_LEU,\n-  ITEST_MAX\n-};\n-\n /* True if X is an unspec wrapper around a SYMBOL_REF or LABEL_REF.  */\n #define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n   (GET_CODE (X) == UNSPEC\t\t\t\t\t\\\n@@ -193,7 +175,6 @@ static void mips_legitimize_const_move (enum machine_mode, rtx, rtx);\n static int m16_check_op (rtx, int, int, int);\n static bool mips_rtx_costs (rtx, int, int, int *);\n static int mips_address_cost (rtx);\n-static enum internal_test map_test_to_internal_test (enum rtx_code);\n static void get_float_compare_codes (enum rtx_code, enum rtx_code *,\n \t\t\t\t     enum rtx_code *);\n static void mips_load_call_address (rtx, rtx, int);\n@@ -1343,6 +1324,24 @@ arith_operand (rtx op, enum machine_mode mode)\n   return const_arith_operand (op, mode) || register_operand (op, mode);\n }\n \n+/* Return true if OP can be used as the second argument to an LE operation.  */\n+\n+int\n+sle_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return GET_CODE (op) == CONST_INT && SMALL_OPERAND (INTVAL (op) + 1);\n+}\n+\n+/* Likewise LEU.  */\n+\n+int\n+sleu_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) + 1 != 0\n+\t  && SMALL_OPERAND (INTVAL (op) + 1));\n+}\n+\n /* Return truth value of whether OP is an integer which fits in 16 bits.  */\n \n int\n@@ -2691,248 +2690,117 @@ mips_gp_save_slot (void)\n   return loc;\n }\n \f\n-/* Make normal rtx_code into something we can index from an array */\n+/* Emit an instruction of the form (set TARGET (CODE OP0 OP1)).  */\n \n-static enum internal_test\n-map_test_to_internal_test (enum rtx_code test_code)\n+static void\n+mips_emit_binary (enum rtx_code code, rtx target, rtx op0, rtx op1)\n {\n-  enum internal_test test = ITEST_MAX;\n-\n-  switch (test_code)\n-    {\n-    case EQ:  test = ITEST_EQ;  break;\n-    case NE:  test = ITEST_NE;  break;\n-    case GT:  test = ITEST_GT;  break;\n-    case GE:  test = ITEST_GE;  break;\n-    case LT:  test = ITEST_LT;  break;\n-    case LE:  test = ITEST_LE;  break;\n-    case GTU: test = ITEST_GTU; break;\n-    case GEU: test = ITEST_GEU; break;\n-    case LTU: test = ITEST_LTU; break;\n-    case LEU: test = ITEST_LEU; break;\n-    default:\t\t\tbreak;\n-    }\n-\n-  return test;\n+  emit_insn (gen_rtx_SET (VOIDmode, target,\n+\t\t\t  gen_rtx_fmt_ee (code, GET_MODE (target), op0, op1)));\n }\n \n-\f\n-/* Generate the code to compare two integer values.  The return value is:\n-   (reg:SI xx)\t\tThe pseudo register the comparison is in\n-   0\t\t       \tNo register, generate a simple branch.\n-\n-   ??? This is called with result nonzero by the Scond patterns in\n-   mips.md.  These patterns are called with a target in the mode of\n-   the Scond instruction pattern.  Since this must be a constant, we\n-   must use SImode.  This means that if RESULT is nonzero, it will\n-   always be an SImode register, even if TARGET_64BIT is true.  We\n-   cope with this by calling convert_move rather than emit_move_insn.\n-   This will sometimes lead to an unnecessary extension of the result;\n-   for example:\n-\n-   long long\n-   foo (long long i)\n-   {\n-     return i < 5;\n-   }\n-\n-   TEST_CODE is the rtx code for the comparison.\n-   CMP0 and CMP1 are the two operands to compare.\n-   RESULT is the register in which the result should be stored (null for\n-     branches).\n-   For branches, P_INVERT points to an integer that is nonzero on return\n-     if the branch should be inverted.  */\n-\n-rtx\n-gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0,\n-\t\t    rtx cmp1, int *p_invert)\n-{\n-  struct cmp_info\n-  {\n-    enum rtx_code test_code;\t/* code to use in instruction (LT vs. LTU) */\n-    int const_low;\t\t/* low bound of constant we can accept */\n-    int const_high;\t\t/* high bound of constant we can accept */\n-    int const_add;\t\t/* constant to add (convert LE -> LT) */\n-    int reverse_regs;\t\t/* reverse registers in test */\n-    int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n-    int invert_reg;\t\t/* != 0 if invert value if cmp1 is register */\n-    int unsignedp;\t\t/* != 0 for unsigned comparisons.  */\n-  };\n-\n-  static const struct cmp_info info[ (int)ITEST_MAX ] = {\n-\n-    { XOR,\t 0,  65535,  0,\t 0,  0,\t 0, 0 },\t/* EQ  */\n-    { XOR,\t 0,  65535,  0,\t 0,  1,\t 1, 0 },\t/* NE  */\n-    { LT,   -32769,  32766,  1,\t 1,  1,\t 0, 0 },\t/* GT  */\n-    { LT,   -32768,  32767,  0,\t 0,  1,\t 1, 0 },\t/* GE  */\n-    { LT,   -32768,  32767,  0,\t 0,  0,\t 0, 0 },\t/* LT  */\n-    { LT,   -32769,  32766,  1,\t 1,  0,\t 1, 0 },\t/* LE  */\n-    { LTU,  -32769,  32766,  1,\t 1,  1,\t 0, 1 },\t/* GTU */\n-    { LTU,  -32768,  32767,  0,\t 0,  1,\t 1, 1 },\t/* GEU */\n-    { LTU,  -32768,  32767,  0,\t 0,  0,\t 0, 1 },\t/* LTU */\n-    { LTU,  -32769,  32766,  1,\t 1,  0,\t 1, 1 },\t/* LEU */\n-  };\n-\n-  enum internal_test test;\n-  enum machine_mode mode;\n-  const struct cmp_info *p_info;\n-  int branch_p;\n-  int eqne_p;\n-  int invert;\n-  rtx reg;\n-  rtx reg2;\n-\n-  test = map_test_to_internal_test (test_code);\n-  if (test == ITEST_MAX)\n-    abort ();\n-\n-  p_info = &info[(int) test];\n-  eqne_p = (p_info->test_code == XOR);\n-\n-  mode = GET_MODE (cmp0);\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (cmp1);\n+/* Return true if CMP1 is a suitable second operand for relational\n+   operator CODE.  See also the *sCC patterns in mips.md.  */\n \n-  /* Eliminate simple branches.  */\n-  branch_p = (result == 0);\n-  if (branch_p)\n+static bool\n+mips_relational_operand_ok_p (enum rtx_code code, rtx cmp1)\n+{\n+  switch (code)\n     {\n-      if (GET_CODE (cmp0) == REG || GET_CODE (cmp0) == SUBREG)\n-\t{\n-\t  /* Comparisons against zero are simple branches.  */\n-\t  if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0\n-\t      && (! TARGET_MIPS16 || eqne_p))\n-\t    return 0;\n-\n-\t  /* Test for beq/bne.  */\n-\t  if (eqne_p && ! TARGET_MIPS16)\n-\t    return 0;\n-\t}\n-\n-      /* Allocate a pseudo to calculate the value in.  */\n-      result = gen_reg_rtx (mode);\n-    }\n+    case GT:\n+    case GTU:\n+      return reg_or_0_operand (cmp1, VOIDmode);\n \n-  /* Make sure we can handle any constants given to us.  */\n-  if (GET_CODE (cmp0) == CONST_INT)\n-    cmp0 = force_reg (mode, cmp0);\n+    case GE:\n+    case GEU:\n+      return !TARGET_MIPS16 && cmp1 == const1_rtx;\n \n-  if (GET_CODE (cmp1) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (cmp1);\n+    case LT:\n+    case LTU:\n+      return arith_operand (cmp1, VOIDmode);\n \n-      if (value < p_info->const_low\n-\t  || value > p_info->const_high\n-\t  /* ??? Why?  And why wasn't the similar code below modified too?  */\n-\t  || (TARGET_64BIT\n-\t      && HOST_BITS_PER_WIDE_INT < 64\n-\t      && p_info->const_add != 0\n-\t      && ((p_info->unsignedp\n-\t\t   ? ((unsigned HOST_WIDE_INT) (value + p_info->const_add)\n-\t\t      > (unsigned HOST_WIDE_INT) INTVAL (cmp1))\n-\t\t   : (value + p_info->const_add) > INTVAL (cmp1))\n-\t\t  != (p_info->const_add > 0))))\n-\tcmp1 = force_reg (mode, cmp1);\n-    }\n+    case LE:\n+      return sle_operand (cmp1, VOIDmode);\n \n-  /* See if we need to invert the result.  */\n-  invert = (GET_CODE (cmp1) == CONST_INT\n-\t    ? p_info->invert_const : p_info->invert_reg);\n+    case LEU:\n+      return sleu_operand (cmp1, VOIDmode);\n \n-  if (p_invert != (int *)0)\n-    {\n-      *p_invert = invert;\n-      invert = 0;\n+    default:\n+      abort ();\n     }\n+}\n \n-  /* Comparison to constants, may involve adding 1 to change a LT into LE.\n-     Comparison between two registers, may involve switching operands.  */\n-  if (GET_CODE (cmp1) == CONST_INT)\n-    {\n-      if (p_info->const_add != 0)\n-\t{\n-\t  HOST_WIDE_INT new = INTVAL (cmp1) + p_info->const_add;\n-\n-\t  /* If modification of cmp1 caused overflow,\n-\t     we would get the wrong answer if we follow the usual path;\n-\t     thus, x > 0xffffffffU would turn into x > 0U.  */\n-\t  if ((p_info->unsignedp\n-\t       ? (unsigned HOST_WIDE_INT) new >\n-\t       (unsigned HOST_WIDE_INT) INTVAL (cmp1)\n-\t       : new > INTVAL (cmp1))\n-\t      != (p_info->const_add > 0))\n-\t    {\n-\t      /* This test is always true, but if INVERT is true then\n-\t\t the result of the test needs to be inverted so 0 should\n-\t\t be returned instead.  */\n-\t      emit_move_insn (result, invert ? const0_rtx : const_true_rtx);\n-\t      return result;\n-\t    }\n-\t  else\n-\t    cmp1 = GEN_INT (new);\n-\t}\n-    }\n+/* Compare CMP0 and CMP1 using relational operator CODE and store the\n+   result in TARGET.  CMP0 and TARGET are register_operands that have\n+   the same integer mode.  If INVERT_PTR is nonnull, it's OK to set\n+   TARGET to the inverse of the result and flip *INVERT_PTR instead.  */\n \n-  else if (p_info->reverse_regs)\n-    {\n-      rtx temp = cmp0;\n-      cmp0 = cmp1;\n-      cmp1 = temp;\n-    }\n-\n-  if (test == ITEST_NE && GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)\n-    reg = cmp0;\n+static void\n+mips_emit_int_relational (enum rtx_code code, bool *invert_ptr,\n+\t\t\t  rtx target, rtx cmp0, rtx cmp1)\n+{\n+  /* First see if there is a MIPS instruction that can do this operation\n+     with CMP1 in its current form.  If not, try doing the same for the\n+     inverse operation.  If that also fails, force CMP1 into a register\n+     and try again.  */\n+  if (mips_relational_operand_ok_p (code, cmp1))\n+    mips_emit_binary (code, target, cmp0, cmp1);\n   else\n     {\n-      reg = (invert || eqne_p) ? gen_reg_rtx (mode) : result;\n-      convert_move (reg, gen_rtx_fmt_ee (p_info->test_code,\n-\t\t\t\t\t mode, cmp0, cmp1), 0);\n-    }\n-\n-  if (test == ITEST_NE)\n-    {\n-      if (! TARGET_MIPS16)\n+      enum rtx_code inv_code = reverse_condition (code);\n+      if (!mips_relational_operand_ok_p (inv_code, cmp1))\n+\t{\n+\t  cmp1 = force_reg (GET_MODE (cmp0), cmp1);\n+\t  mips_emit_int_relational (code, invert_ptr, target, cmp0, cmp1);\n+\t}\n+      else if (invert_ptr == 0)\n \t{\n-\t  convert_move (result, gen_rtx_GTU (mode, reg, const0_rtx), 0);\n-\t  if (p_invert != NULL)\n-\t    *p_invert = 0;\n-\t  invert = 0;\n+\t  rtx inv_target = gen_reg_rtx (GET_MODE (target));\n+\t  mips_emit_binary (inv_code, inv_target, cmp0, cmp1);\n+\t  mips_emit_binary (XOR, target, inv_target, const1_rtx);\n \t}\n       else\n \t{\n-\t  reg2 = invert ? gen_reg_rtx (mode) : result;\n-\t  convert_move (reg2, gen_rtx_LTU (mode, reg, const1_rtx), 0);\n-\t  reg = reg2;\n+\t  *invert_ptr = !*invert_ptr;\n+\t  mips_emit_binary (inv_code, target, cmp0, cmp1);\n \t}\n     }\n+}\n \n-  else if (test == ITEST_EQ)\n-    {\n-      reg2 = invert ? gen_reg_rtx (mode) : result;\n-      convert_move (reg2, gen_rtx_LTU (mode, reg, const1_rtx), 0);\n-      reg = reg2;\n-    }\n+/* Return a register that is zero iff CMP0 and CMP1 are equal.\n+   The register will have the same mode as CMP0.  */\n \n-  if (invert)\n-    {\n-      rtx one;\n+static rtx\n+mips_zero_if_equal (rtx cmp0, rtx cmp1)\n+{\n+  if (cmp1 == const0_rtx)\n+    return cmp0;\n \n-      if (! TARGET_MIPS16)\n-\tone = const1_rtx;\n-      else\n-\t{\n-\t  /* The value is in $24.  Copy it to another register, so\n-             that reload doesn't think it needs to store the $24 and\n-             the input to the XOR in the same location.  */\n-\t  reg2 = gen_reg_rtx (mode);\n-\t  emit_move_insn (reg2, reg);\n-\t  reg = reg2;\n-\t  one = force_reg (mode, const1_rtx);\n-\t}\n-      convert_move (result, gen_rtx_XOR (mode, reg, one), 0);\n-    }\n+  return expand_binop (GET_MODE (cmp0), xor_optab,\n+\t\t       cmp0, cmp1, 0, 0, OPTAB_DIRECT);\n+}\n \n-  return result;\n+/* Try comparing cmp_operands[0] and cmp_operands[1] using rtl code CODE.\n+   Store the result in TARGET and return true if successful.\n+\n+   On 64-bit targets, TARGET may be wider than cmp_operands[0].  */\n+\n+bool\n+mips_emit_scc (enum rtx_code code, rtx target)\n+{\n+  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n+    return false;\n+\n+  target = gen_lowpart (GET_MODE (cmp_operands[0]), target);\n+  if (code == EQ || code == NE)\n+    {\n+      rtx zie = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);\n+      mips_emit_binary (code, target, zie, const0_rtx);\n+    }\n+  else\n+    mips_emit_int_relational (code, 0, target,\n+\t\t\t      cmp_operands[0], cmp_operands[1]);\n+  return true;\n }\n \f\n /* Work out how to check a floating-point condition.  We need a\n@@ -2970,74 +2838,67 @@ get_float_compare_codes (enum rtx_code in_code, enum rtx_code *cmp_code,\n void\n gen_conditional_branch (rtx *operands, enum rtx_code test_code)\n {\n-  rtx cmp0 = cmp_operands[0];\n-  rtx cmp1 = cmp_operands[1];\n+  rtx cmp0, cmp1, target;\n   enum machine_mode mode;\n   enum rtx_code cmp_code;\n-  rtx reg;\n-  int invert;\n-  rtx label1, label2;\n \n-  switch (GET_MODE (cmp0))\n+  switch (GET_MODE (cmp_operands[0]))\n     {\n     case SImode:\n     case DImode:\n-      mode = GET_MODE (cmp0);\n-      invert = 0;\n-      reg = gen_int_relational (test_code, NULL_RTX, cmp0, cmp1, &invert);\n-\n-      if (reg)\n+      mode = GET_MODE (cmp_operands[0]);\n+      if (!TARGET_MIPS16 && cmp_operands[1] == const0_rtx)\n+\t{\n+\t  cmp0 = cmp_operands[0];\n+\t  cmp1 = cmp_operands[1];\n+\t}\n+      else if (test_code == EQ || test_code == NE)\n+\t{\n+\t  if (TARGET_MIPS16)\n+\t    {\n+\t      cmp0 = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);\n+\t      cmp1 = const0_rtx;\n+\t    }\n+\t  else\n+\t    {\n+\t      cmp0 = cmp_operands[0];\n+\t      cmp1 = force_reg (mode, cmp_operands[1]);\n+\t    }\n+\t}\n+      else\n \t{\n-\t  cmp0 = reg;\n+\t  bool invert = false;\n+\t  cmp0 = gen_reg_rtx (mode);\n \t  cmp1 = const0_rtx;\n-\t  test_code = NE;\n+\t  mips_emit_int_relational (test_code, &invert, cmp0,\n+\t\t\t\t    cmp_operands[0], cmp_operands[1]);\n+\t  test_code = (invert ? EQ : NE);\n \t}\n-      else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n-\t/* We don't want to build a comparison against a nonzero\n-\t   constant.  */\n-\tcmp1 = force_reg (mode, cmp1);\n-\n       break;\n \n     case SFmode:\n     case DFmode:\n-      if (! ISA_HAS_8CC)\n-\treg = gen_rtx_REG (CCmode, FPSW_REGNUM);\n+      mode = CCmode;\n+      if (!ISA_HAS_8CC)\n+\tcmp0 = gen_rtx_REG (mode, FPSW_REGNUM);\n       else\n-\treg = gen_reg_rtx (CCmode);\n+\tcmp0 = gen_reg_rtx (mode);\n+      cmp1 = const0_rtx;\n \n       get_float_compare_codes (test_code, &cmp_code, &test_code);\n-      emit_insn (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t      gen_rtx_fmt_ee (cmp_code, CCmode, cmp0, cmp1)));\n-\n-      mode = CCmode;\n-      cmp0 = reg;\n-      cmp1 = const0_rtx;\n-      invert = 0;\n+      mips_emit_binary (cmp_code, cmp0, cmp_operands[0], cmp_operands[1]);\n       break;\n \n     default:\n-      fatal_insn (\"bad test\",\n-\t\t  gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));\n+      abort ();\n     }\n \n   /* Generate the branch.  */\n-\n-  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n-  label2 = pc_rtx;\n-\n-  if (invert)\n-    {\n-      label2 = label1;\n-      label1 = pc_rtx;\n-    }\n-\n-  emit_jump_insn\n-    (gen_rtx_SET (VOIDmode, pc_rtx,\n-\t\t  gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\tgen_rtx_fmt_ee (test_code, mode,\n-\t\t\t\t\t\t\tcmp0, cmp1),\n-\t\t\t\t\tlabel1, label2)));\n+  target = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t gen_rtx_fmt_ee (test_code, mode, cmp0, cmp1),\n+\t\t\t\t gen_rtx_LABEL_REF (VOIDmode, operands[0]),\n+\t\t\t\t pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, target));\n }\n \n /* Emit the common code for conditional moves.  OPERANDS is the array"}, {"sha": "f0f06ada15cf2833d3a61671fe0d45a3f6fd5b67", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "patch": "@@ -2727,6 +2727,8 @@ typedef struct mips_args {\n \t\t\t\t  UNSPEC_VOLATILE }},\t\t\t\\\n   {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG }},\t\\\n   {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG }}, \\\n+  {\"sle_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n+  {\"sleu_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"reg_or_const_float_1_operand\", { CONST_DOUBLE, REG}},               \\"}, {"sha": "08f04f8ded327cd1d3f546b9fd6565cb8014af21", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 62, "deletions": 86, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a012718f1d0470cd1a19b4c8c5200de06ba47b0a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=a012718f1d0470cd1a19b4c8c5200de06ba47b0a", "patch": "@@ -6012,14 +6012,7 @@ dsrl\\t%3,%3,1\\n\\\n \t(eq:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (EQ, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n-\n+  { if (mips_emit_scc (EQ, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*seq_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -6057,20 +6050,15 @@ dsrl\\t%3,%3,1\\n\\\n   [(set_attr \"type\" \"slt\")\n    (set_attr \"mode\" \"DI\")])\n \n-;; On the mips16 the default code is better than using sltu.\n+;; \"sne\" uses sltu instructions in which the first operand is $0.\n+;; This isn't possible in mips16 code.\n \n (define_expand \"sne\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(ne:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"!TARGET_MIPS16\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (NE, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (NE, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sne_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -6095,13 +6083,7 @@ dsrl\\t%3,%3,1\\n\\\n \t(gt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (GT, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (GT, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sgt_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -6144,26 +6126,32 @@ dsrl\\t%3,%3,1\\n\\\n \t(ge:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n+  { if (mips_emit_scc (GE, operands[0])) DONE; else FAIL; })\n \n-  gen_int_relational (GE, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+(define_insn \"*sge_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ge:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (const_int 1)))]\n+  \"!TARGET_MIPS16\"\n+  \"slt\\t%0,%.,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*sge_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ge:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t       (const_int 1)))]\n+  \"TARGET_64BIT && !TARGET_MIPS16\"\n+  \"slt\\t%0,%.,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_expand \"slt\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(lt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (LT, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (LT, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*slt_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -6216,19 +6204,13 @@ dsrl\\t%3,%3,1\\n\\\n \t(le:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (LE, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (LE, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sle_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t       (match_operand:SI 2 \"small_int\" \"I\")))]\n-  \"!TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t       (match_operand:SI 2 \"sle_operand\" \"\")))]\n+  \"!TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"slt\\t%0,%1,%2\";\n@@ -6239,8 +6221,8 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"*sle_si_mips16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=t\")\n \t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t       (match_operand:SI 2 \"small_int\" \"I\")))]\n-  \"TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t       (match_operand:SI 2 \"sle_operand\" \"\")))]\n+  \"TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"slt\\t%1,%2\";\n@@ -6254,8 +6236,8 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"*sle_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(le:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t       (match_operand:DI 2 \"small_int\" \"I\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t       (match_operand:DI 2 \"sle_operand\" \"\")))]\n+  \"TARGET_64BIT && !TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"slt\\t%0,%1,%2\";\n@@ -6266,8 +6248,8 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"*sle_di_mips16\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=t\")\n \t(le:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t       (match_operand:DI 2 \"small_int\" \"I\")))]\n-  \"TARGET_64BIT && TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t       (match_operand:DI 2 \"sle_operand\" \"\")))]\n+  \"TARGET_64BIT && TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"slt\\t%1,%2\";\n@@ -6283,13 +6265,7 @@ dsrl\\t%3,%3,1\\n\\\n \t(gtu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (GTU, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (GTU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sgtu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -6332,26 +6308,32 @@ dsrl\\t%3,%3,1\\n\\\n         (geu:SI (match_dup 1)\n                 (match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n+  { if (mips_emit_scc (GEU, operands[0])) DONE; else FAIL; })\n \n-  gen_int_relational (GEU, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+(define_insn \"*sge_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(geu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t        (const_int 1)))]\n+  \"!TARGET_MIPS16\"\n+  \"sltu\\t%0,%.,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*sge_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(geu:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t        (const_int 1)))]\n+  \"TARGET_64BIT && !TARGET_MIPS16\"\n+  \"sltu\\t%0,%.,%1\"\n+  [(set_attr \"type\" \"slt\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_expand \"sltu\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(ltu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (LTU, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (LTU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sltu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -6404,19 +6386,13 @@ dsrl\\t%3,%3,1\\n\\\n \t(leu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n-    FAIL;\n-\n-  gen_int_relational (LEU, operands[0], cmp_operands[0], cmp_operands[1], NULL);\n-  DONE;\n-})\n+  { if (mips_emit_scc (LEU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sleu_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"small_int\" \"I\")))]\n-  \"!TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t        (match_operand:SI 2 \"sleu_operand\" \"\")))]\n+  \"!TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"sltu\\t%0,%1,%2\";\n@@ -6427,8 +6403,8 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"*sleu_si_mips16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=t\")\n \t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"small_int\" \"I\")))]\n-  \"TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t        (match_operand:SI 2 \"sleu_operand\" \"\")))]\n+  \"TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"sltu\\t%1,%2\";\n@@ -6442,8 +6418,8 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"*sleu_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(leu:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"small_int\" \"I\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t        (match_operand:DI 2 \"sleu_operand\" \"\")))]\n+  \"TARGET_64BIT && !TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"sltu\\t%0,%1,%2\";\n@@ -6454,8 +6430,8 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"*sleu_di_mips16\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=t\")\n \t(leu:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"small_int\" \"I\")))]\n-  \"TARGET_64BIT && TARGET_MIPS16 && INTVAL (operands[2]) < 32767\"\n+\t        (match_operand:DI 2 \"sleu_operand\" \"\")))]\n+  \"TARGET_64BIT && TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"sltu\\t%1,%2\";"}]}