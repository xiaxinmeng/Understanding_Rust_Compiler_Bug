{"sha": "41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEwMjliODg0YWUxNmEyZmMyYjM2Y2VkZmQyMGQ3YTFlNjhjZmRiNg==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2001-04-05T00:14:18Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-04-05T00:14:18Z"}, "message": "finalize.c: - Accomodate finalization requests for static objects.\n\n2001-04-04  Hans Boehm  <hans_boehm@hp.com>\n\n\t* finalize.c:\n\t- Accomodate finalization requests for static objects.\n\t  (Will be required by hash synchronization.  May be needed\n\t  in some configurations now.)\n\n\t* gc_priv.h:\n\t- Define MIN_WORDS.  All allocation requests are rounded\n\t  up to at least this size.  Removes a subtle assumption that\n\t  Java objects have a 2 word header.\n\n\t* gcconfig.h:\n\t- Adjust Linux/IA64 configuration for non-ancient kernels.\n\t  (Necessary fix for IA64.)\n\n\t* linux_threads.c:\n\t- Fix syntax error in currently unused code.  Will be needed\n\t  for Linux/PA-RISC.\n\n\t* malloc.c:\n\t- Handle MIN_WORDS.\n\n\t* misc.c:\n\t- Handle MIN_WORDS.\n\t- Change stack cleaning code to typically clear about one tenth\n\t  the memory it used to in the threads configuration.  Occasionally\n\t  still clear more.  (This is really a fix for a long-standing\n\t  and fairly significant performance bug with threads.)\n\n\t* os_dep.c:\n\t- Fix the code for finding the beginning of the data segment under\n\t  Linux.  I believe this is necessary for some IA64 Linux\n\t  distributions.  It will also helo other platforms, though those\n\t  may additionally require a gcconfig.h adjustment.  (This basically\n\t  works around the absence of a data_start or __data_start\n\t  definition in glibc.)\n\n\t* test.c:\n\t- Handle rounding due to MIN_WORDS.\n\nFrom-SVN: r41102", "tree": {"sha": "88a556f74fb0052ef40f7b32c7dc19756675fe56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88a556f74fb0052ef40f7b32c7dc19756675fe56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/comments", "author": null, "committer": null, "parents": [{"sha": "48f9396dd6166819d204e931b4d2d9d2da704a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f9396dd6166819d204e931b4d2d9d2da704a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f9396dd6166819d204e931b4d2d9d2da704a73"}], "stats": {"total": 161, "additions": 133, "deletions": 28}, "files": [{"sha": "31b8ebe038e7d7d883278e8338ea16a1428ce31b", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -1,3 +1,44 @@\n+2001-04-04  Hans Boehm  <hans_boehm@hp.com>\n+\n+\t* finalize.c:\n+\t- Accomodate finalization requests for static objects.\n+\t  (Will be required by hash synchronization.  May be needed\n+\t  in some configurations now.)\n+\n+\t* gc_priv.h:\n+\t- Define MIN_WORDS.  All allocation requests are rounded\n+\t  up to at least this size.  Removes a subtle assumption that\n+\t  Java objects have a 2 word header.\n+\n+\t* gcconfig.h:\n+\t- Adjust Linux/IA64 configuration for non-ancient kernels.\n+\t  (Necessary fix for IA64.)\n+\n+\t* linux_threads.c:\n+\t- Fix syntax error in currently unused code.  Will be needed\n+\t  for Linux/PA-RISC.\n+\n+\t* malloc.c:\n+\t- Handle MIN_WORDS.\n+\n+\t* misc.c:\n+\t- Handle MIN_WORDS.\n+\t- Change stack cleaning code to typically clear about one tenth\n+\t  the memory it used to in the threads configuration.  Occasionally\n+\t  still clear more.  (This is really a fix for a long-standing\n+\t  and fairly significant performance bug with threads.)\n+\n+\t* os_dep.c:\n+\t- Fix the code for finding the beginning of the data segment under\n+\t  Linux.  I believe this is necessary for some IA64 Linux\n+\t  distributions.  It will also helo other platforms, though those\n+\t  may additionally require a gcconfig.h adjustment.  (This basically\n+\t  works around the absence of a data_start or __data_start\n+\t  definition in glibc.)\n+\n+\t* test.c:\n+\t- Handle rounding due to MIN_WORDS.\n+\n 2001-03-22  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.am (gctest_LDFLAGS): Use -shared-libgcc."}, {"sha": "7ff6798cfa5e51580090712da9eee6ea4a4af7d2", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -324,6 +324,7 @@ finalization_mark_proc * mp;\n     struct finalizable_object * curr_fo, * prev_fo;\n     int index;\n     struct finalizable_object *new_fo;\n+    hdr *hhdr;\n     DCL_LOCK_STATE;\n \n #   ifdef THREADS\n@@ -402,6 +403,19 @@ finalization_mark_proc * mp;\n #\tendif\n         return;\n     }\n+    GET_HDR(base, hhdr);\n+    if (0 == hhdr) {\n+      /* We won't collect it, hence finalizer wouldn't be run. */\n+      /* This is changed for gcj, but it will be in version 6.0 of the\t*/\n+      /* standard collector distribution.  It costs virtually nothing\t*/\n+      /* here, but it's expensive to check in the hash synchronization\t*/\n+      /* code, where it matters.\t\t-HB\t\t\t*/\n+#     ifdef THREADS\n+          UNLOCK();\n+    \t  ENABLE_SIGNALS();\n+#     endif\n+      return;\n+    }\n #   ifdef THREADS\n       new_fo = (struct finalizable_object *)\n     \tGC_generic_malloc_inner(sizeof(struct finalizable_object),NORMAL);\n@@ -413,7 +427,7 @@ finalization_mark_proc * mp;\n         new_fo -> fo_hidden_base = (word)HIDE_POINTER(base);\n \tnew_fo -> fo_fn = fn;\n \tnew_fo -> fo_client_data = (ptr_t)cd;\n-\tnew_fo -> fo_object_size = GC_size(base);\n+\tnew_fo -> fo_object_size = hhdr -> hb_sz;\n \tnew_fo -> fo_mark_proc = mp;\n \tfo_set_next(new_fo, fo_head[index]);\n \tGC_fo_entries++;"}, {"sha": "314eced852566595bb91cc7c42d3b4155de565cd", "filename": "boehm-gc/gc_priv.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_priv.h?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -890,6 +890,18 @@ extern GC_warn_proc GC_current_warn_proc;\n #   define SMALL_OBJ(bytes) ((bytes) <= WORDS_TO_BYTES(MAXOBJSZ))\n #   define ADD_SLOP(bytes) (bytes)\n # endif\n+# ifndef MIN_WORDS\n+    /* MIN_WORDS is the size of the smallest allocated object.\t*/\n+    /* 1 and 2 are the only valid values.\t\t\t*/\n+    /* 2 must be used if:\t\t\t\t\t*/\n+    /* - GC_gcj_malloc can be used for objects of requested\t*/\n+    /*   size smaller than 2 words\t\t\t\t*/\n+#   if defined(GC_GCJ_SUPPORT)\n+#     define MIN_WORDS 2   \t/* Smallest allocated object.\t*/\n+#   else\n+#     define MIN_WORDS 1\n+#   endif\n+# endif\n \n \n /*"}, {"sha": "84a4b3ccc46f4e6ed23c468e4a06372ca700b8b7", "filename": "boehm-gc/gcconfig.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcconfig.h?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -1116,11 +1116,20 @@\n #       define CPP_WORDSZ 64\n \t/* This should really be done through /proc, but that\t*/\n \t/* requires we run on an IA64 kernel.\t\t\t*/\n-#       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\n+\t/* The following works on NUE and older kernels:\t*/\n+/* #       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\t*/\n+\t/* This does not work on NUE:\t\t\t\t*/\n+#       define LINUX_STACKBOTTOM\n \t/* We also need the base address of the register stack\t*/\n-\t/* backing store.  There is probably a better way to\t*/\n-\t/* get that, too ...\t\t\t\t\t*/\n-#\tdefine BACKING_STORE_BASE ((ptr_t) 0x9fffffff80000000l)\n+\t/* backing store.  There should be a better way to get\t*/\n+\t/* this:\t\t\t\t\t\t*/\n+#\tdefine APPROX_BS_BASE ((word)GC_stackbottom-0x80000000)\n+\t/* We round to the next multiple of 1 MB, to compensate\t*/\n+\t/* for the fact that the stack base is displaced by\t*/\n+\t/* the environment, etc.\t\t\t\t*/\n+#\tdefine BACKING_STORE_BASE \\\n+\t\t(ptr_t)((APPROX_BS_BASE + 0xfffff) & ~0xfffff)\n+\n #\tif 1\n #\t    define SEARCH_FOR_DATA_START\n #\t    define DATASTART GC_data_start"}, {"sha": "519c5cb916cc98f8dd40bcef5fe6fff7a508a011", "filename": "boehm-gc/gcj_mlc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -267,7 +267,6 @@ DCL_LOCK_STATE;\n         } else {\n             *opp = obj_link(op);\n             GC_words_allocd += lw;\n-            FASTUNLOCK();\n         }\n \t*(void **)op = ptr_to_struct_containing_descr;\n \tUNLOCK();"}, {"sha": "2c856f567a093f45daa9f9245f64c706b70ef885", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -611,7 +611,7 @@ void * GC_start_routine(void * arg)\n \t/* Needs to be plausible, since an asynchronous stack mark\t*/\n \t/* should not crash.\t\t\t\t\t\t*/\n #   else\n-      me -> stack_end = (ptr_t)(((word)(&dummy) & ~(GC_page_size - 1));\n+      me -> stack_end = (ptr_t)((word)(&dummy) & ~(GC_page_size - 1));\n       me -> stack_ptr = me -> stack_end + 0x10;\n #   endif\n     /* This is dubious, since we may be more than a page into the stack, */"}, {"sha": "c92222453620d538e4ced70a752f6979a70f0b3d", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -52,7 +52,7 @@ register ptr_t *opp;\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n-\t  if (lw == 0) lw = 1;\n+\t  if (lw == 0) lw = MIN_WORDS;\n #       endif\n \topp = &(kind -> ok_freelist[lw]);\n         if( (op = *opp) == 0 ) {"}, {"sha": "1e1ada574578ef7cbd627aa12ada4ba0abf6476a", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -107,13 +107,17 @@ extern signed_word GC_mem_found;\n     {\n \tregister unsigned i;\n \n-\t/* Map size 0 to 1.  This avoids problems at lower levels. */\n-\t  GC_size_map[0] = 1;\n+\t/* Map size 0 to something bigger.\t\t\t   */\n+        /* This avoids problems at lower levels. \t\t   */\n \t/* One word objects don't have to be 2 word aligned.\t   */\n-\t  for (i = 1; i < sizeof(word); i++) {\n-\t      GC_size_map[i] = 1;\n+\t  for (i = 0; i < sizeof(word); i++) {\n+\t      GC_size_map[i] = MIN_WORDS;\n \t  }\n-\t  GC_size_map[sizeof(word)] = ROUNDED_UP_WORDS(sizeof(word));\n+#\t  if MIN_WORDS > 1\n+\t    GC_size_map[sizeof(word)] = MIN_WORDS;\n+#\t  else\n+\t    GC_size_map[sizeof(word)] = ROUNDED_UP_WORDS(sizeof(word));\n+#\t  endif\n \tfor (i = sizeof(word) + 1; i <= 8 * sizeof(word); i++) {\n #           ifdef ALIGN_DOUBLE\n \t      GC_size_map[i] = (ROUNDED_UP_WORDS(i) + 1) & (~1);\n@@ -202,10 +206,10 @@ extern signed_word GC_mem_found;\n  */\n word GC_stack_last_cleared = 0;\t/* GC_no when we last did this */\n # ifdef THREADS\n-#   define CLEAR_SIZE 2048\n-# else\n-#   define CLEAR_SIZE 213\n+#   define BIG_CLEAR_SIZE 2048\t/* Clear this much now and then.\t*/\n+#   define SMALL_CLEAR_SIZE 256 /* Clear this much every time.\t\t*/\n # endif\n+# define CLEAR_SIZE 213  /* Granularity for GC_clear_stack_inner */\n # define DEGRADE_RATE 50\n \n word GC_min_sp;\t\t/* Coolest stack pointer value from which we've */\n@@ -262,10 +266,12 @@ ptr_t arg;\n {\n     register word sp = (word)GC_approx_sp();  /* Hotter than actual sp */\n #   ifdef THREADS\n-        word dummy[CLEAR_SIZE];\n-#   else\n-    \tregister word limit;\n+        word dummy[SMALL_CLEAR_SIZE];\n+\tunsigned random_no = 0;  /* Should be more random than it is ... */\n+\t\t\t\t /* Used to occasionally clear a bigger\t */\n+\t\t\t\t /* chunk.\t\t\t\t */\n #   endif\n+    register word limit;\n     \n #   define SLOP 400\n \t/* Extra bytes we clear every time.  This clears our own\t*/\n@@ -283,7 +289,14 @@ ptr_t arg;\n \t/* thus more junk remains accessible, thus the heap gets\t*/\n \t/* larger ...\t\t\t\t\t\t\t*/\n # ifdef THREADS\n-    BZERO(dummy, CLEAR_SIZE*sizeof(word));\n+    if (++random_no % 13 == 0) {\n+\tlimit = sp;\n+\tMAKE_HOTTER(limit, BIG_CLEAR_SIZE*sizeof(word));\n+\treturn GC_lear_stack_inner(arg, limit);\n+    } else {\n+\tBZERO(dummy, SMALL_CLEAR_SIZE*sizeof(word));\n+\treturn arg;\n+    }\n # else\n     if (GC_gc_no > GC_stack_last_cleared) {\n         /* Start things over, so we clear the entire stack again */"}, {"sha": "a192d35a21ac49d234bf590b38e5d0f9266d3b9e", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -144,20 +144,37 @@\n #endif\n \n #if defined(SEARCH_FOR_DATA_START)\n-  /* The following doesn't work if the GC is in a dynamic library.\t*/\n   /* The I386 case can be handled without a search.  The Alpha case\t*/\n   /* used to be handled differently as well, but the rules changed\t*/\n   /* for recent Linux versions.  This seems to be the easiest way to\t*/\n   /* cover all versions.\t\t\t\t\t\t*/\n-  ptr_t GC_data_start;\n \n-  extern char * GC_copyright[];  /* Any data symbol would do. */\n+# ifdef LINUX\n+#   pragma weak __data_start\n+    extern int __data_start;\n+#   pragma weak data_start\n+    extern int data_start;\n+# endif /* LINUX */\n+  extern int _end;\n+\n+  ptr_t GC_data_start;\n \n   void GC_init_linux_data_start()\n   {\n     extern ptr_t GC_find_limit();\n \n-    GC_data_start = GC_find_limit((ptr_t)GC_copyright, FALSE);\n+#   ifdef LINUX\n+      /* Try the easy approaches first:\t*/\n+      if (&__data_start != 0) {\n+\t  GC_data_start = (ptr_t)(&__data_start);\n+\t  return;\n+      }\n+      if (&data_start != 0) {\n+\t  GC_data_start = (ptr_t)(&data_start);\n+\t  return;\n+      }\n+#   endif /* LINUX */\n+    GC_data_start = GC_find_limit((ptr_t)(&_end), FALSE);\n   }\n #endif\n "}, {"sha": "9254fa8370dd77d21ae49ed210092ffc1af583ca", "filename": "boehm-gc/test.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6/boehm-gc%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftest.c?ref=41029b884ae16a2fc2b36cedfd20d7a1e68cfdb6", "patch": "@@ -958,17 +958,17 @@ void run_one_test()\n \t\t\"This test program is not designed for leak detection mode\\n\");\n \t(void)GC_printf0(\"Expect lots of problems.\\n\");\n #   endif\n-    if (GC_size(GC_malloc(7)) != 8\n+    if (GC_size(GC_malloc(7)) != 8 &&\n+\tGC_size(GC_malloc(7)) != MIN_WORDS * sizeof(GC_word)\n \t|| GC_size(GC_malloc(15)) != 16) {\n \t    (void)GC_printf0(\"GC_size produced unexpected results\\n\");\n \t    FAIL;\n     }\n-    if (GC_size(GC_malloc(0)) != 4 && GC_size(GC_malloc(0)) != 8) {\n+    if (GC_size(GC_malloc(0)) != MIN_WORDS * sizeof(GC_word)) {\n     \t(void)GC_printf0(\"GC_malloc(0) failed\\n\");\n \t    FAIL;\n     }\n-    if (GC_size(GC_malloc_uncollectable(0)) != 4\n-        && GC_size(GC_malloc_uncollectable(0)) != 8) {\n+    if (GC_size(GC_malloc_uncollectable(0)) != MIN_WORDS * sizeof(GC_word)) {\n     \t(void)GC_printf0(\"GC_malloc_uncollectable(0) failed\\n\");\n \t    FAIL;\n     }"}]}