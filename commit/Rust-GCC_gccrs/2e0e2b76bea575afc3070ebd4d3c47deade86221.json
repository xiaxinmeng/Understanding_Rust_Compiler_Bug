{"sha": "2e0e2b76bea575afc3070ebd4d3c47deade86221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUwZTJiNzZiZWE1NzVhZmMzMDcwZWJkNGQzYzQ3ZGVhZGU4NjIyMQ==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-08T10:28:26Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-08T10:28:26Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1515", "tree": {"sha": "d9f060c99cef3dbccb8b5dd3c1cdac5f5af9a002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9f060c99cef3dbccb8b5dd3c1cdac5f5af9a002"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e0e2b76bea575afc3070ebd4d3c47deade86221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0e2b76bea575afc3070ebd4d3c47deade86221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e0e2b76bea575afc3070ebd4d3c47deade86221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0e2b76bea575afc3070ebd4d3c47deade86221/comments", "author": null, "committer": null, "parents": [{"sha": "3b5e8cb62ed7db313c0f75bd4bc722bd95b1d093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5e8cb62ed7db313c0f75bd4bc722bd95b1d093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5e8cb62ed7db313c0f75bd4bc722bd95b1d093"}], "stats": {"total": 32, "additions": 24, "deletions": 8}, "files": [{"sha": "cd5b0d002592747fc3c69e42644047fc6a77eddd", "filename": "gcc/regclass.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0e2b76bea575afc3070ebd4d3c47deade86221/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0e2b76bea575afc3070ebd4d3c47deade86221/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=2e0e2b76bea575afc3070ebd4d3c47deade86221", "patch": "@@ -103,7 +103,17 @@ int reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n \n /* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n \n-HARD_REG_SET reg_class_contents[] = REG_CLASS_CONTENTS;\n+HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n+\n+/* The same information, but as an array of ints.  We copy from these\n+   ints to the table above.  This is done so that the tm.h files do\n+   not have to be aware of the wordsize for machines with <= 64 regs.  */\n+\n+#define N_REG_INTS  \\\n+  ((FIRST_PSEUDO_REGISTER + (HOST_BITS_PER_INT - 1)) / HOST_BITS_PER_INT)\n+\n+static int int_reg_class_contents[N_REG_CLASSES][N_REG_INTS] \n+  = REG_CLASS_CONTENTS;\n \n /* For each reg class, number of regs it contains.  */\n \n@@ -158,6 +168,19 @@ init_reg_sets ()\n {\n   register int i, j;\n \n+  /* First copy the register information from the initial int form into\n+     the regsets.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    {\n+      CLEAR_HARD_REG_SET (reg_class_contents[i]);\n+\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\tif (int_reg_class_contents[i][j / HOST_BITS_PER_INT]\n+\t    & (1 << (j % HOST_BITS_PER_INT)))\n+\t  SET_HARD_REG_BIT (reg_class_contents[i], j);\n+    }\n+\n   bcopy (initial_fixed_regs, fixed_regs, sizeof fixed_regs);\n   bcopy (initial_call_used_regs, call_used_regs, sizeof call_used_regs);\n   bzero (global_regs, sizeof global_regs);"}, {"sha": "b9cea5f976529833d2b62724ff3ef375904fb8a1", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0e2b76bea575afc3070ebd4d3c47deade86221/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0e2b76bea575afc3070ebd4d3c47deade86221/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=2e0e2b76bea575afc3070ebd4d3c47deade86221", "patch": "@@ -3240,9 +3240,6 @@ pushcase (value, label, duplicate)\n   if (index_type == error_mark_node)\n     return 0;\n \n-  /* There may be NOP_EXPR around the value if we got it from an enum.  */\n-  STRIP_NOPS (value);\n-\n   /* Convert VALUE to the type in which the comparisons are nominally done.  */\n   if (value != 0)\n     value = convert (nominal_type, value);\n@@ -3372,10 +3369,6 @@ pushcase_range (value1, value2, label, duplicate)\n     }\n   case_stack->data.case_stmt.seenlabel = 1;\n \n-  /* There may be NOP_EXPR around the value if we got it from an enum.  */\n-  STRIP_NOPS (value1);\n-  STRIP_NOPS (value2);\n-\n   /* Convert VALUEs to type in which the comparisons are nominally done.  */\n   if (value1 == 0)  /* Negative infinity. */\n     value1 = TYPE_MIN_VALUE(index_type);"}]}