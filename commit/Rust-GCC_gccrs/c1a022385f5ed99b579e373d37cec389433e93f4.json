{"sha": "c1a022385f5ed99b579e373d37cec389433e93f4", "node_id": "C_kwDOANBUbNoAKGMxYTAyMjM4NWY1ZWQ5OWI1NzllMzczZDM3Y2VjMzg5NDMzZTkzZjQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-12T09:50:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T09:50:56Z"}, "message": "Merge #1086\n\n1086: Slice support r=philberty a=philberty\n\nPlease see the commit a8de089969cb45199008027cd8d1b80dff25746f for\r\na long explanation of what's going on in the patch. Unfortunately, I have not been\r\nable to split this patch up anymore since supporting slices exposed many bugs\r\nin the implementation of generics in general never main the missing support for\r\ngeneric associated types.\r\n\r\nFixes #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "11d8928918796afb88de93d53c0cf21eb167e990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11d8928918796afb88de93d53c0cf21eb167e990"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1a022385f5ed99b579e373d37cec389433e93f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVUuACRBK7hj4Ov3rIwAAiOcIACLIMiAXuWKVeE349PAmY1M6\nsuOIApaI5wqwz44QLSQfukPgpKREISswnW+/3JD/PArc/9anDmXOMxrsWBpCsz5i\nkXjzip5twDmhJzAec7DjirJO0UVFL0Xq+9sRI+yCO0dl7/bRlXrxwYuJXQgNohkW\ntunfsnghBrOFeVhrC4lL0x6mH4mCv6kh4vz0pt3g1g3Kqh9SDlU1ejZngZ2/TY6R\npaUjOVgEhzC1dPa/CjstUgC2tY7tpatBVvLkkThEpBkWtM05+l6ynMJ8q79x553R\ndEBmnTX91QmdxFqHq84AOkGVYNfOKW85u5N/WKy9avYFiNXnTj19d90qDoOL4CU=\n=5bmc\n-----END PGP SIGNATURE-----\n", "payload": "tree 11d8928918796afb88de93d53c0cf21eb167e990\nparent 68458036c81d141a3899ac4e6ec6ddf0fdfde174\nparent 0e686c0fe01ef29be1c08fb8440caf76c9fb66d9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649757056 +0000\ncommitter GitHub <noreply@github.com> 1649757056 +0000\n\nMerge #1086\n\n1086: Slice support r=philberty a=philberty\n\nPlease see the commit a8de089969cb45199008027cd8d1b80dff25746f for\r\na long explanation of what's going on in the patch. Unfortunately, I have not been\r\nable to split this patch up anymore since supporting slices exposed many bugs\r\nin the implementation of generics in general never main the missing support for\r\ngeneric associated types.\r\n\r\nFixes #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a022385f5ed99b579e373d37cec389433e93f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a022385f5ed99b579e373d37cec389433e93f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a022385f5ed99b579e373d37cec389433e93f4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68458036c81d141a3899ac4e6ec6ddf0fdfde174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68458036c81d141a3899ac4e6ec6ddf0fdfde174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68458036c81d141a3899ac4e6ec6ddf0fdfde174"}, {"sha": "0e686c0fe01ef29be1c08fb8440caf76c9fb66d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e686c0fe01ef29be1c08fb8440caf76c9fb66d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e686c0fe01ef29be1c08fb8440caf76c9fb66d9"}], "stats": {"total": 1140, "additions": 833, "deletions": 307}, "files": [{"sha": "2128f25f2965f338458caa512205656c2ba5c324", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -747,8 +747,9 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \n   auto root = receiver->get_root ();\n   std::vector<Resolver::PathProbeCandidate> candidates\n-    = Resolver::PathProbeType::Probe (root, segment, true, false, true);\n-\n+    = Resolver::PathProbeType::Probe (root, segment, true /* probe_impls */,\n+\t\t\t\t      false /* probe_bounds */,\n+\t\t\t\t      true /* ignore_mandatory_trait_items */);\n   if (candidates.size () == 0)\n     {\n       // this means we are defaulting back to the trait_item if\n@@ -776,12 +777,22 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n       rust_assert (candidates.size () == 1);\n       auto &candidate = candidates.at (0);\n       rust_assert (candidate.is_impl_candidate ());\n+      rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);\n \n       HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n-      if (!fntype->has_subsititions_defined ())\n+      if (!candidate_call->has_subsititions_defined ())\n \treturn CompileInherentImplItem::Compile (impl_item, ctx);\n \n-      return CompileInherentImplItem::Compile (impl_item, ctx, fntype);\n+      TyTy::BaseType *monomorphized = candidate_call;\n+      if (candidate_call->needs_generic_substitutions ())\n+\t{\n+\t  TyTy::BaseType *infer_impl_call\n+\t    = candidate_call->infer_substitions (expr_locus);\n+\t  monomorphized = infer_impl_call->unify (fntype);\n+\t}\n+\n+      return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n     }\n }\n "}, {"sha": "bd782b003905fa334efe264420fff3585c3f5bb4", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -38,7 +38,6 @@ CompileCrate::~CompileCrate () {}\n \n void\n CompileCrate::Compile (HIR::Crate &crate, Context *ctx)\n-\n {\n   CompileCrate c (crate, ctx);\n   c.go ();\n@@ -383,26 +382,11 @@ HIRCompileBase::compute_address_for_trait_item (\n     = self_bound->lookup_associated_item (ref->get_identifier ());\n   rust_assert (!associated_self_item.is_error ());\n \n-  // apply any generic arguments from this predicate\n   TyTy::BaseType *mono1 = associated_self_item.get_tyty_for_receiver (self);\n-  TyTy::BaseType *mono2 = nullptr;\n-  if (predicate->has_generic_args ())\n-    {\n-      mono2 = associated_self_item.get_tyty_for_receiver (\n-\tself, predicate->get_generic_args ());\n-    }\n-  else\n-    {\n-      mono2 = associated_self_item.get_tyty_for_receiver (self);\n-    }\n   rust_assert (mono1 != nullptr);\n   rust_assert (mono1->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *assocated_item_ty1 = static_cast<TyTy::FnType *> (mono1);\n \n-  rust_assert (mono2 != nullptr);\n-  rust_assert (mono2->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *assocated_item_ty2 = static_cast<TyTy::FnType *> (mono2);\n-\n   // Lookup the impl-block for the associated impl_item if it exists\n   HIR::Function *associated_function = nullptr;\n   for (auto &impl_item : associated_impl_block->get_impl_items ())\n@@ -434,7 +418,7 @@ HIRCompileBase::compute_address_for_trait_item (\n \t{\n \t  TyTy::SubstitutionArgumentMappings mappings\n \t    = assocated_item_ty1->solve_missing_mappings_from_this (\n-\t      *assocated_item_ty2, *lookup_fntype);\n+\t      *trait_item_fntype, *lookup_fntype);\n \t  lookup_fntype = lookup_fntype->handle_substitions (mappings);\n \t}\n "}, {"sha": "104bd16080e995928ce4b1f2d046376a5a50a90a", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -126,9 +126,11 @@ MethodResolver::Try (const TyTy::BaseType *r,\n   PathProbeCandidate c = PathProbeCandidate::get_error ();\n   const std::vector<TyTy::TypeBoundPredicate> &specified_bounds\n     = r->get_specified_bounds ();\n+  const std::vector<MethodResolver::predicate_candidate> predicate_items\n+    = get_predicate_items (segment_name, *r, specified_bounds);\n \n   // 1. try raw\n-  MethodResolver raw (*r, segment_name, specified_bounds);\n+  MethodResolver raw (*r, segment_name, predicate_items);\n   c = raw.select ();\n   if (!c.is_error ())\n     {\n@@ -139,7 +141,7 @@ MethodResolver::Try (const TyTy::BaseType *r,\n   TyTy::ReferenceType *r1\n     = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n \t\t\t       Mutability::Imm);\n-  MethodResolver imm_ref (*r1, segment_name, specified_bounds);\n+  MethodResolver imm_ref (*r1, segment_name, predicate_items);\n   c = imm_ref.select ();\n   if (!c.is_error ())\n     {\n@@ -152,7 +154,7 @@ MethodResolver::Try (const TyTy::BaseType *r,\n   TyTy::ReferenceType *r2\n     = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n \t\t\t       Mutability::Mut);\n-  MethodResolver mut_ref (*r2, segment_name, specified_bounds);\n+  MethodResolver mut_ref (*r2, segment_name, predicate_items);\n   c = mut_ref.select ();\n   if (!c.is_error ())\n     {\n@@ -288,27 +290,6 @@ MethodResolver::select ()\n     TyTy::FnType *fntype;\n   };\n \n-  std::vector<precdicate_candidate> predicate_items;\n-  for (auto &bound : specified_bounds)\n-    {\n-      TyTy::TypeBoundPredicateItem lookup\n-\t= bound.lookup_associated_item (segment_name.as_string ());\n-      if (lookup.is_error ())\n-\tcontinue;\n-\n-      bool is_fn = lookup.get_raw_item ()->get_trait_item_type ()\n-\t\t   == TraitItemReference::TraitItemType::FN;\n-      if (!is_fn)\n-\tcontinue;\n-\n-      TyTy::BaseType *ty = lookup.get_raw_item ()->get_tyty ();\n-      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n-      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n-\n-      precdicate_candidate candidate{lookup, fnty};\n-      predicate_items.push_back (candidate);\n-    }\n-\n   for (auto impl_item : inherent_impl_fns)\n     {\n       TyTy::FnType *fn = impl_item.ty;\n@@ -342,9 +323,9 @@ MethodResolver::select ()\n \t}\n     }\n \n-  for (auto predicate : predicate_items)\n+  for (const auto &predicate : predicate_items)\n     {\n-      TyTy::FnType *fn = predicate.fntype;\n+      const TyTy::FnType *fn = predicate.fntype;\n       rust_assert (fn->is_method ());\n \n       TyTy::BaseType *fn_self = fn->get_self_type ();\n@@ -355,20 +336,41 @@ MethodResolver::select ()\n \t  const TraitItemReference *trait_item\n \t    = predicate.lookup.get_raw_item ();\n \n-\t  TyTy::BaseType *subst = predicate.lookup.get_tyty_for_receiver (\n-\t    receiver.get_root (),\n-\t    predicate.lookup.get_parent ()->get_generic_args ());\n-\n \t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n \t\t\t\t\t\t   nullptr};\n \t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, subst,\n+\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, fn->clone (),\n \t    trait_item->get_locus (), c);\n \t}\n     }\n \n   return PathProbeCandidate::get_error ();\n }\n \n+std::vector<MethodResolver::predicate_candidate>\n+MethodResolver::get_predicate_items (\n+  const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n+  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n+{\n+  std::vector<predicate_candidate> predicate_items;\n+  for (auto &bound : specified_bounds)\n+    {\n+      TyTy::TypeBoundPredicateItem lookup\n+\t= bound.lookup_associated_item (segment_name.as_string ());\n+      if (lookup.is_error ())\n+\tcontinue;\n+\n+      TyTy::BaseType *ty = lookup.get_tyty_for_receiver (&receiver);\n+      if (ty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\t  predicate_candidate candidate{lookup, fnty};\n+\t  predicate_items.push_back (candidate);\n+\t}\n+    }\n+\n+  return predicate_items;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "ef1038bd78c3e6c488a5cc878e0908044c2ed629", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -48,22 +48,32 @@ class MethodResolver : public TypeCheckBase\n \t\t\t\tbool autoderef_flag = false);\n \n protected:\n+  struct predicate_candidate\n+  {\n+    TyTy::TypeBoundPredicateItem lookup;\n+    TyTy::FnType *fntype;\n+  };\n+\n   static MethodCandidate Try (const TyTy::BaseType *r,\n \t\t\t      const HIR::PathIdentSegment &segment_name,\n \t\t\t      std::vector<Adjustment> &adjustments);\n \n+  static std::vector<predicate_candidate> get_predicate_items (\n+    const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n+    const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n+\n   PathProbeCandidate select ();\n \n-  MethodResolver (const TyTy::BaseType &receiver,\n-\t\t  const HIR::PathIdentSegment &segment_name,\n-\t\t  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n+  MethodResolver (\n+    const TyTy::BaseType &receiver, const HIR::PathIdentSegment &segment_name,\n+    const std::vector<MethodResolver::predicate_candidate> &predicate_items)\n     : receiver (receiver), segment_name (segment_name),\n-      specified_bounds (specified_bounds)\n+      predicate_items (predicate_items)\n   {}\n \n   const TyTy::BaseType &receiver;\n   const HIR::PathIdentSegment &segment_name;\n-  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds;\n+  const std::vector<MethodResolver::predicate_candidate> &predicate_items;\n };\n \n } // namespace Resolver"}, {"sha": "d8c8a1906cd18517ae1ebce706ef082bae84c294", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -262,6 +262,8 @@ class TraitReference\n     return hir_trait_ref->get_mappings ();\n   }\n \n+  DefId get_defid () const { return get_mappings ().get_defid (); }\n+\n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n \t\t\t      TraitItemReference **ref)\n   {\n@@ -436,6 +438,9 @@ class AssociatedImplTrait\n \n   void setup_associated_types ();\n \n+  void setup_associated_types2 (const TyTy::BaseType *self,\n+\t\t\t\tconst TyTy::TypeBoundPredicate &bound);\n+\n   void reset_associated_types ();\n \n   TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,"}, {"sha": "b4e0efea0fa75c7f0bad00a571e82efabff854b2", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 168, "deletions": 1, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -137,7 +137,7 @@ TraitItemReference::associated_type_set (TyTy::BaseType *ty)\n   TyTy::PlaceholderType *placeholder\n     = static_cast<TyTy::PlaceholderType *> (item_ty);\n \n-  placeholder->set_associated_type (ty->get_ref ());\n+  placeholder->set_associated_type (ty->get_ty_ref ());\n }\n \n void\n@@ -175,6 +175,173 @@ AssociatedImplTrait::setup_associated_types ()\n   iter.go ();\n }\n \n+void\n+AssociatedImplTrait::setup_associated_types2 (\n+  const TyTy::BaseType *self, const TyTy::TypeBoundPredicate &bound)\n+{\n+  // compute the constrained impl block generic arguments based on self and the\n+  // higher ranked trait bound\n+  TyTy::BaseType *receiver = self->clone ();\n+\n+  // impl<Y> SliceIndex<[Y]> for Range<usize>\n+  // vs\n+  // I: SliceIndex<[<integer>]> and Range<<integer>>\n+  //\n+  // we need to figure out what Y is\n+\n+  TyTy::BaseType *associated_self = get_self ();\n+  rust_assert (associated_self->can_eq (self, false));\n+\n+  // grab the parameters\n+  HIR::ImplBlock &impl_block = *get_impl_block ();\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  for (auto &generic_param : impl_block.get_generic_params ())\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\t  // Skipping Lifetime completely until better handling.\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    TyTy::BaseType *l = nullptr;\n+\t    bool ok = context->lookup_type (\n+\t      generic_param->get_mappings ().get_hirid (), &l);\n+\t    if (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n+\t      {\n+\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t  static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t  static_cast<TyTy::ParamType *> (l)));\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  // generate inference variables for these bound arguments so we can compute\n+  // their values\n+  Location locus;\n+  std::vector<TyTy::SubstitutionArg> args;\n+  for (auto &p : substitutions)\n+    {\n+      if (p.needs_substitution ())\n+\t{\n+\t  TyTy::TyVar infer_var = TyTy::TyVar::get_implicit_infer_var (locus);\n+\t  args.push_back (TyTy::SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t}\n+      else\n+\t{\n+\t  args.push_back (\n+\t    TyTy::SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t}\n+    }\n+\n+  // this callback gives us the parameters that get substituted so we can\n+  // compute the constrained type parameters for this impl block\n+  std::map<std::string, HirId> param_mappings;\n+  TyTy::ParamSubstCb param_subst_cb\n+    = [&] (const TyTy::ParamType &p, const TyTy::SubstitutionArg &a) {\n+\tparam_mappings[p.get_symbol ()] = a.get_tyty ()->get_ref ();\n+      };\n+\n+  TyTy::SubstitutionArgumentMappings infer_arguments (std::move (args), locus,\n+\t\t\t\t\t\t      param_subst_cb);\n+  TyTy::BaseType *impl_self_infer\n+    = (associated_self->needs_generic_substitutions ())\n+\t? SubstMapperInternal::Resolve (associated_self, infer_arguments)\n+\t: associated_self;\n+\n+  // FIXME this needs to do a lookup for the trait-reference DefId instead of\n+  // assuming its the first one in the list\n+  rust_assert (associated_self->num_specified_bounds () > 0);\n+  TyTy::TypeBoundPredicate &impl_predicate\n+    = associated_self->get_specified_bounds ().at (0);\n+\n+  // infer the arguments on the predicate\n+  std::vector<TyTy::BaseType *> impl_trait_predicate_args;\n+  for (const auto &arg : impl_predicate.get_substs ())\n+    {\n+      const TyTy::ParamType *p = arg.get_param_ty ();\n+      if (p->get_symbol ().compare (\"Self\") == 0)\n+\tcontinue;\n+\n+      TyTy::BaseType *r = p->resolve ();\n+      r = SubstMapperInternal::Resolve (r, infer_arguments);\n+      impl_trait_predicate_args.push_back (r);\n+    }\n+\n+  // we need to unify the receiver with the impl-block Self so that we compute\n+  // the type correctly as our receiver may be generic and we are inferring its\n+  // generic arguments and this Self might be the concrete version or vice\n+  // versa.\n+  auto result = receiver->unify (impl_self_infer);\n+  rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n+\n+  // unify the bounds arguments\n+  std::vector<TyTy::BaseType *> hrtb_bound_arguments;\n+  for (const auto &arg : bound.get_substs ())\n+    {\n+      const TyTy::ParamType *p = arg.get_param_ty ();\n+      if (p->get_symbol ().compare (\"Self\") == 0)\n+\tcontinue;\n+\n+      TyTy::BaseType *r = p->resolve ();\n+      hrtb_bound_arguments.push_back (r);\n+    }\n+\n+  rust_assert (impl_trait_predicate_args.size ()\n+\t       == hrtb_bound_arguments.size ());\n+  for (size_t i = 0; i < impl_trait_predicate_args.size (); i++)\n+    {\n+      TyTy::BaseType *a = impl_trait_predicate_args.at (i);\n+      TyTy::BaseType *b = hrtb_bound_arguments.at (i);\n+\n+      result = a->unify (b);\n+      rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n+    }\n+\n+  // create the argument list\n+  std::vector<TyTy::SubstitutionArg> associated_arguments;\n+  for (auto &p : substitutions)\n+    {\n+      std::string symbol = p.get_param_ty ()->get_symbol ();\n+      auto it = param_mappings.find (symbol);\n+      rust_assert (it != param_mappings.end ());\n+\n+      HirId id = it->second;\n+      TyTy::BaseType *argument = nullptr;\n+      bool ok = context->lookup_type (id, &argument);\n+      rust_assert (ok);\n+\n+      TyTy::SubstitutionArg arg (&p, argument);\n+      associated_arguments.push_back (arg);\n+    }\n+\n+  TyTy::SubstitutionArgumentMappings associated_type_args (\n+    std::move (associated_arguments), locus);\n+\n+  ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n+    TraitItemReference *resolved_trait_item = nullptr;\n+    bool ok = trait->lookup_trait_item (type.get_new_type_name (),\n+\t\t\t\t\t&resolved_trait_item);\n+    if (!ok)\n+      return;\n+    if (resolved_trait_item->get_trait_item_type ()\n+\t!= TraitItemReference::TraitItemType::TYPE)\n+      return;\n+\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    // this might be generic\n+    TyTy::BaseType *substituted\n+      = SubstMapperInternal::Resolve (lookup, associated_type_args);\n+    resolved_trait_item->associated_type_set (substituted);\n+  });\n+  iter.go ();\n+}\n+\n void\n AssociatedImplTrait::reset_associated_types ()\n {"}, {"sha": "651af9db81a6c6ae93bf873318e8e56cc606a33d", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -141,24 +141,26 @@ class TraitResolver : public TypeCheckBase\n \t    break;\n \t  }\n       }\n-\n     rust_assert (self != nullptr);\n \n     // Check if there is a super-trait, and apply this bound to the Self\n     // TypeParam\n     std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n \n-    // They also inherit themselves as a bound this enables a trait item to\n-    // reference other Self::trait_items\n+    // copy the substitition mappings\n     std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n     for (auto &sub : substitutions)\n       self_subst_copy.push_back (sub.clone ());\n \n-    specified_bounds.push_back (\n-      TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n-\t\t\t\tstd::move (self_subst_copy),\n-\t\t\t\ttrait_reference->get_locus ()));\n+    // They also inherit themselves as a bound this enables a trait item to\n+    // reference other Self::trait_items\n+    auto self_hrtb\n+      = TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n+\t\t\t\t  std::move (self_subst_copy),\n+\t\t\t\t  trait_reference->get_locus ());\n+    specified_bounds.push_back (self_hrtb);\n \n+    // look for any\n     std::vector<const TraitReference *> super_traits;\n     if (trait_reference->has_type_param_bounds ())\n       {\n@@ -171,12 +173,8 @@ class TraitResolver : public TypeCheckBase\n \t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n \n \t\t// FIXME this might be recursive we need a check for that\n-\n-\t\tTraitReference *trait = resolve_trait_path (b->get_path ());\n-\t\tTyTy::TypeBoundPredicate predicate (*trait,\n-\t\t\t\t\t\t    bound->get_locus ());\n-\n-\t\tspecified_bounds.push_back (std::move (predicate));\n+\t\tauto predicate = get_predicate_from_bound (b->get_path ());\n+\t\tspecified_bounds.push_back (predicate);\n \t\tsuper_traits.push_back (predicate.get ());\n \t      }\n \t  }"}, {"sha": "a3d911efd79485ac14111f692dc72b0a4364f06c", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -390,7 +390,6 @@ TypeCheckExpr::resolve_operator_overload (\n   rust_assert (fn->is_method ());\n \n   auto root = lhs->get_root ();\n-  bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n   if (root->get_kind () == TyTy::TypeKind::ADT)\n     {\n       const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n@@ -446,13 +445,8 @@ TypeCheckExpr::resolve_operator_overload (\n     }\n \n   // handle generics\n-  if (!receiver_is_type_param)\n-    {\n-      if (lookup->needs_generic_substitutions ())\n-\t{\n-\t  lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n-\t}\n-    }\n+  if (lookup->needs_generic_substitutions ())\n+    lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n \n   // type check the arguments if required\n   TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n@@ -470,6 +464,10 @@ TypeCheckExpr::resolve_operator_overload (\n       fnparam.second->unify (rhs); // typecheck the rhs\n     }\n \n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  fn = static_cast<TyTy::FnType *> (lookup);\n+  fn->monomorphize ();\n+\n   // get the return type\n   TyTy::BaseType *function_ret_tyty = type->get_return_type ()->clone ();\n "}, {"sha": "560581d588bf4cf7d4ac296d2e3ee794496c5b60", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -291,7 +291,6 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     auto root = receiver_tyty->get_root ();\n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n     if (root->get_kind () == TyTy::TypeKind::ADT)\n       {\n \tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n@@ -346,28 +345,21 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n-    if (!receiver_is_type_param)\n+    // apply any remaining generic arguments\n+    if (expr.get_method_name ().has_generic_args ())\n       {\n-\t// apply any remaining generic arguments\n-\tif (expr.get_method_name ().has_generic_args ())\n-\t  {\n-\t    HIR::GenericArgs &args\n-\t      = expr.get_method_name ().get_generic_args ();\n-\t    lookup = SubstMapper::Resolve (lookup,\n-\t\t\t\t\t   expr.get_method_name ().get_locus (),\n-\t\t\t\t\t   &args);\n-\t    if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-\telse if (lookup->needs_generic_substitutions ())\n-\t  {\n-\t    lookup\n-\t      = SubstMapper::InferSubst (lookup,\n-\t\t\t\t\t expr.get_method_name ().get_locus ());\n-\t  }\n+\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+\tlookup\n+\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n+\t\t\t\t  &args);\n+\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+    else if (lookup->needs_generic_substitutions ())\n+      {\n+\tlookup = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\t  expr.get_method_name ().get_locus ());\n       }\n-\n-    // ADT expected but got PARAM\n \n     TyTy::BaseType *function_ret_tyty\n       = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self,"}, {"sha": "9846ed602f7eb851af5330bb51354dfd183fe25b", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -79,6 +79,8 @@ class TypeCheckItem : public TypeCheckBase\n \trust_assert (!trait_reference->is_error ());\n \n \tspecified_bound = get_predicate_from_bound (*ref.get ());\n+\t// FIXME error out maybe?\n+\t// if specified_Bound == TyTy::TypeBoundPredicate::error() ?\n       }\n \n     TyTy::BaseType *self = nullptr;"}, {"sha": "e2fa7f5e9aca611e035328bf12253651a70b5598", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -45,8 +45,8 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     }\n \n   // Resolve the trait now\n-  TraitReference *trait_ref\n-    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  std::unique_ptr<HIR::TypePath> &trait_path_ref = qual_path_type.get_trait ();\n+  TraitReference *trait_ref = TraitResolver::Resolve (*trait_path_ref.get ());\n   if (trait_ref->is_error ())\n     return;\n \n@@ -59,6 +59,14 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n   if (expr.get_segments ().empty ())\n     return;\n \n+  // get the predicate for the bound\n+  auto specified_bound = get_predicate_from_bound (*trait_path_ref.get ());\n+  if (specified_bound.is_error ())\n+    return;\n+\n+  // inherit the bound\n+  root->inherit_bounds ({specified_bound});\n+\n   // we need resolve to the impl block\n   NodeId impl_resolved_id = UNKNOWN_NODEID;\n   bool ok = resolver->lookup_resolved_name ("}, {"sha": "f80368a0339958c2f2b3362483032cf4373ab59e", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -26,19 +26,31 @@ TyTy::BaseType *\n SubstMapperInternal::Resolve (TyTy::BaseType *base,\n \t\t\t      TyTy::SubstitutionArgumentMappings &mappings)\n {\n+  auto context = TypeCheckContext::get ();\n+\n   SubstMapperInternal mapper (base->get_ref (), mappings);\n   base->accept_vis (mapper);\n   rust_assert (mapper.resolved != nullptr);\n \n   // insert these new implict types into the context\n-  bool is_param = mapper.resolved->get_kind () == TyTy::TypeKind::PARAM;\n-  if (!is_param)\n+  TyTy::BaseType *unused = nullptr;\n+  bool is_ty_available\n+    = context->lookup_type (mapper.resolved->get_ty_ref (), &unused);\n+  if (!is_ty_available)\n     {\n-      auto context = TypeCheckContext::get ();\n       context->insert_type (\n \tAnalysis::NodeMapping (0, 0, mapper.resolved->get_ty_ref (), 0),\n \tmapper.resolved);\n     }\n+  bool is_ref_available\n+    = context->lookup_type (mapper.resolved->get_ref (), &unused);\n+  if (!is_ref_available)\n+    {\n+      context->insert_type (Analysis::NodeMapping (0, 0,\n+\t\t\t\t\t\t   mapper.resolved->get_ref (),\n+\t\t\t\t\t\t   0),\n+\t\t\t    mapper.resolved);\n+    }\n \n   return mapper.resolved;\n }"}, {"sha": "e12432e59ee2cd11a3d8a503f2d92c56b7d3aad6", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -232,19 +232,22 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   }\n \n   // nothing to do for these\n-  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n-  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n-  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n-  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n-  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n-  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n-  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::FnPtr &type) override { resolved = type.clone (); }\n+  void visit (TyTy::BoolType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::IntType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::UintType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::FloatType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::USizeType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::ISizeType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::ErrorType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::CharType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::StrType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::NeverType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::DynamicObjectType &type) override\n+  {\n+    resolved = type.clone ();\n+  }\n \n private:\n   SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)"}, {"sha": "e226400f5d970c330f56febb4deb563ab419a4d3", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 93, "deletions": 59, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -106,46 +106,72 @@ TypeBoundPredicate::TypeBoundPredicate (\n   : SubstitutionRef (trait_reference.get_trait_substs (),\n \t\t     SubstitutionArgumentMappings::error ()),\n     reference (trait_reference.get_mappings ().get_defid ()), locus (locus),\n-    args (HIR::GenericArgs::create_empty ()), error_flag (false)\n-{}\n+    error_flag (false)\n+{\n+  // we setup a dummy implict self argument\n+  SubstitutionArg placeholder_self (&get_substs ().front (), nullptr);\n+  used_arguments.get_mappings ().push_back (placeholder_self);\n+}\n \n TypeBoundPredicate::TypeBoundPredicate (\n   DefId reference, std::vector<SubstitutionParamMapping> substitutions,\n   Location locus)\n   : SubstitutionRef (std::move (substitutions),\n \t\t     SubstitutionArgumentMappings::error ()),\n-    reference (reference), locus (locus),\n-    args (HIR::GenericArgs::create_empty ()), error_flag (false)\n-{}\n+    reference (reference), locus (locus), error_flag (false)\n+{\n+  // we setup a dummy implict self argument\n+  SubstitutionArg placeholder_self (&get_substs ().front (), nullptr);\n+  used_arguments.get_mappings ().push_back (placeholder_self);\n+}\n \n TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n-  : SubstitutionRef ({}, other.used_arguments), reference (other.reference),\n-    locus (other.locus), args (other.args), error_flag (other.error_flag)\n+  : SubstitutionRef ({}, SubstitutionArgumentMappings::error ()),\n+    reference (other.reference), locus (other.locus),\n+    error_flag (other.error_flag)\n {\n   substitutions.clear ();\n-  if (!other.is_error ())\n+\n+  for (const auto &p : other.get_substs ())\n+    substitutions.push_back (p.clone ());\n+\n+  std::vector<SubstitutionArg> mappings;\n+  for (size_t i = 0; i < other.used_arguments.get_mappings ().size (); i++)\n     {\n-      for (const auto &p : other.get_substs ())\n-\tsubstitutions.push_back (p.clone ());\n+      const SubstitutionArg &oa = other.used_arguments.get_mappings ().at (i);\n+      SubstitutionArg arg (oa);\n+      mappings.push_back (std::move (arg));\n     }\n+\n+  used_arguments\n+    = SubstitutionArgumentMappings (mappings,\n+\t\t\t\t    other.used_arguments.get_locus ());\n }\n \n TypeBoundPredicate &\n TypeBoundPredicate::operator= (const TypeBoundPredicate &other)\n {\n   reference = other.reference;\n   locus = other.locus;\n-  args = other.args;\n   error_flag = other.error_flag;\n-  used_arguments = other.used_arguments;\n+  used_arguments = SubstitutionArgumentMappings::error ();\n \n   substitutions.clear ();\n-  if (!other.is_error ())\n+  for (const auto &p : other.get_substs ())\n+    substitutions.push_back (p.clone ());\n+\n+  std::vector<SubstitutionArg> mappings;\n+  for (size_t i = 0; i < other.used_arguments.get_mappings ().size (); i++)\n     {\n-      for (const auto &p : other.get_substs ())\n-\tsubstitutions.push_back (p.clone ());\n+      const SubstitutionArg &oa = other.used_arguments.get_mappings ().at (i);\n+      SubstitutionArg arg (oa);\n+      mappings.push_back (std::move (arg));\n     }\n \n+  used_arguments\n+    = SubstitutionArgumentMappings (mappings,\n+\t\t\t\t    other.used_arguments.get_locus ());\n+\n   return *this;\n }\n \n@@ -203,17 +229,22 @@ TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n {\n   // we need to get the substitutions argument mappings but also remember that\n   // we have an implicit Self argument which we must be careful to respect\n-  rust_assert (used_arguments.is_empty ());\n+  rust_assert (!used_arguments.is_empty ());\n   rust_assert (!substitutions.empty ());\n \n-  // we setup a dummy implict self argument\n-  SubstitutionArg placeholder_self (&substitutions.front (), nullptr);\n-  used_arguments.get_mappings ().push_back (std::move (placeholder_self));\n-\n   // now actually perform a substitution\n   used_arguments = get_mappings_from_generic_args (*generic_args);\n+\n   error_flag |= used_arguments.is_error ();\n-  args = *generic_args;\n+  auto &subst_mappings = used_arguments;\n+  for (auto &sub : get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok && arg.get_tyty () != nullptr)\n+\tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n+    }\n }\n \n bool\n@@ -235,47 +266,34 @@ TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n   return TypeBoundPredicateItem (this, trait_item_ref);\n }\n \n+TypeBoundPredicateItem\n+TypeBoundPredicate::lookup_associated_item (\n+  const Resolver::TraitItemReference *ref) const\n+{\n+  return lookup_associated_item (ref->get_identifier ());\n+}\n+\n BaseType *\n-TypeBoundPredicateItem::get_tyty_for_receiver (\n-  const TyTy::BaseType *receiver, const HIR::GenericArgs *bound_args)\n+TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n {\n   TyTy::BaseType *trait_item_tyty = get_raw_item ()->get_tyty ();\n-  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-    {\n-      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-      TyTy::SubstitutionParamMapping *param = nullptr;\n-      for (auto &param_mapping : fn->get_substs ())\n-\t{\n-\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n-\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t    {\n-\t      param = &param_mapping;\n-\t      break;\n-\t    }\n-\t}\n-      rust_assert (param != nullptr);\n-\n-      std::vector<TyTy::SubstitutionArg> mappings;\n-      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n-\n-      Location locus; // FIXME\n-      TyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n-      trait_item_tyty\n-\t= Resolver::SubstMapperInternal::Resolve (trait_item_tyty, args);\n-    }\n+  if (parent->get_substitution_arguments ().is_empty ())\n+    return trait_item_tyty;\n \n-  if (!parent->has_generic_args ())\n+  const Resolver::TraitItemReference *tref = get_raw_item ();\n+  bool is_associated_type = tref->get_trait_item_type ();\n+  if (is_associated_type)\n     return trait_item_tyty;\n \n-  // FIXME LEAK this should really be const\n-  const HIR::GenericArgs *args\n-    = (bound_args != nullptr) ? bound_args : parent->get_generic_args ();\n-  HIR::GenericArgs *generic_args = new HIR::GenericArgs (*args);\n-  TyTy::BaseType *resolved\n-    = Resolver::SubstMapper::Resolve (trait_item_tyty, parent->get_locus (),\n-\t\t\t\t      generic_args);\n+  SubstitutionArgumentMappings gargs = parent->get_substitution_arguments ();\n+\n+  // set up the self mapping\n+  rust_assert (!gargs.is_empty ());\n+  auto &sarg = gargs.get_mappings ().at (0);\n+  SubstitutionArg self (sarg.get_param_mapping (), receiver->clone ());\n+  gargs.get_mappings ()[0] = self;\n \n-  return resolved;\n+  return Resolver::SubstMapperInternal::Resolve (trait_item_tyty, gargs);\n }\n bool\n TypeBoundPredicate::is_error () const\n@@ -289,9 +307,25 @@ TypeBoundPredicate::is_error () const\n }\n \n BaseType *\n-TypeBoundPredicate::handle_substitions (SubstitutionArgumentMappings mappings)\n+TypeBoundPredicate::handle_substitions (\n+  SubstitutionArgumentMappings subst_mappings)\n {\n-  gcc_unreachable ();\n+  for (auto &sub : get_substs ())\n+    {\n+      if (sub.get_param_ty () == nullptr)\n+\tcontinue;\n+\n+      ParamType *p = sub.get_param_ty ();\n+      BaseType *r = p->resolve ();\n+      BaseType *s = Resolver::SubstMapperInternal::Resolve (r, subst_mappings);\n+\n+      p->set_ty_ref (s->get_ty_ref ());\n+    }\n+\n+  // FIXME more error handling at some point\n+  // used_arguments = subst_mappings;\n+  // error_flag |= used_arguments.is_error ();\n+\n   return nullptr;\n }\n \n@@ -301,7 +335,7 @@ TypeBoundPredicate::requires_generic_args () const\n   if (is_error ())\n     return false;\n \n-  return substitutions.size () > 1 && args.is_empty ();\n+  return substitutions.size () > 1;\n }\n \n // trait item reference\n@@ -351,7 +385,7 @@ TypeBoundsMappings::raw_bounds_as_string () const\n     {\n       const TypeBoundPredicate &b = specified_bounds.at (i);\n       bool has_next = (i + 1) < specified_bounds.size ();\n-      buf += b.get_name () + (has_next ? \" + \" : \"\");\n+      buf += b.as_string () + (has_next ? \" + \" : \"\");\n     }\n   return buf;\n }"}, {"sha": "f3118ba7dbb86b528a626bbca536b14a392c3c35", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -43,16 +43,19 @@ class BaseCmp : public TyConstVisitor\n \t    return ok;\n \t  }\n       }\n-    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+    if (other->get_kind () == TypeKind::PLACEHOLDER)\n       {\n \tconst PlaceholderType *p = static_cast<const PlaceholderType *> (other);\n \tif (p->can_resolve ())\n \t  {\n-\t    const BaseType *resolved = p->resolve ();\n-\t    resolved->accept_vis (*this);\n-\t    return ok;\n+\t    other = p->resolve ();\n \t  }\n       }\n+    if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tconst ProjectionType *p = static_cast<const ProjectionType *> (other);\n+\tother = p->get ();\n+      }\n \n     other->accept_vis (*this);\n     return ok;\n@@ -1268,14 +1271,10 @@ class ParamCmp : public BaseCmp\n   // to handle the typing of the struct\n   bool can_eq (const BaseType *other) override\n   {\n-    if (base->get_ref () == base->get_ty_ref ())\n+    if (!base->can_resolve ())\n       return BaseCmp::can_eq (other);\n \n-    auto context = Resolver::TypeCheckContext::get ();\n-    BaseType *lookup = nullptr;\n-    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n-    rust_assert (ok);\n-\n+    auto lookup = base->resolve ();\n     return lookup->can_eq (other, emit_error_flag);\n   }\n \n@@ -1422,11 +1421,6 @@ class PlaceholderCmp : public BaseCmp\n \n   void visit (const SliceType &) override { ok = true; }\n \n-  void visit (const PlaceholderType &type) override\n-  {\n-    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n-  }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n "}, {"sha": "c24f17e6c945d47ff1db0d0083cfd62ec2a076b6", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -53,12 +53,14 @@ class BaseCoercionRules : public TyVisitor\n \tif (p->can_resolve ())\n \t  {\n \t    other = p->resolve ();\n+\t    return get_base ()->coerce (other);\n \t  }\n       }\n     else if (other->get_kind () == TypeKind::PROJECTION)\n       {\n \tProjectionType *p = static_cast<ProjectionType *> (other);\n \tother = p->get ();\n+\treturn get_base ()->coerce (other);\n       }\n \n     other->accept_vis (*this);\n@@ -1351,14 +1353,10 @@ class ParamCoercionRules : public BaseCoercionRules\n   // to handle the typing of the struct\n   BaseType *coerce (BaseType *other) override final\n   {\n-    if (base->get_ref () == base->get_ty_ref ())\n+    if (!base->can_resolve ())\n       return BaseCoercionRules::coerce (other);\n \n-    auto context = Resolver::TypeCheckContext::get ();\n-    BaseType *lookup = nullptr;\n-    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n-    rust_assert (ok);\n-\n+    auto lookup = base->resolve ();\n     return lookup->unify (other);\n   }\n "}, {"sha": "7c50112db60d42df41bea619e88119bf1305d0d4", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -60,23 +60,22 @@ class BaseRules : public TyVisitor\n     if (other->get_kind () == TypeKind::PARAM)\n       {\n \tParamType *p = static_cast<ParamType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    other = p->resolve ();\n-\t  }\n+\tother = p->resolve ();\n       }\n     else if (other->get_kind () == TypeKind::PLACEHOLDER)\n       {\n \tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n \tif (p->can_resolve ())\n \t  {\n \t    other = p->resolve ();\n+\t    return get_base ()->unify (other);\n \t  }\n       }\n     else if (other->get_kind () == TypeKind::PROJECTION)\n       {\n \tProjectionType *p = static_cast<ProjectionType *> (other);\n \tother = p->get ();\n+\treturn get_base ()->unify (other);\n       }\n \n     other->accept_vis (*this);\n@@ -1328,14 +1327,10 @@ class ParamRules : public BaseRules\n   // to handle the typing of the struct\n   BaseType *unify (BaseType *other) override final\n   {\n-    if (base->get_ref () == base->get_ty_ref ())\n+    if (!base->can_resolve ())\n       return BaseRules::unify (other);\n \n-    auto context = Resolver::TypeCheckContext::get ();\n-    BaseType *lookup = nullptr;\n-    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n-    rust_assert (ok);\n-\n+    auto lookup = base->resolve ();\n     return lookup->unify (other);\n   }\n "}, {"sha": "156cc101c79b5490c42c35fbe1663da71f85fe80", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 121, "deletions": 76, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -266,6 +266,23 @@ TyVar::get_implicit_infer_var (Location locus)\n   return TyVar (infer->get_ref ());\n }\n \n+TyVar\n+TyVar::subst_covariant_var (TyTy::BaseType *orig, TyTy::BaseType *subst)\n+{\n+  if (orig->get_kind () != TyTy::TypeKind::PARAM)\n+    return TyVar (subst->get_ty_ref ());\n+  else if (subst->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (subst);\n+      if (p->resolve ()->get_kind () == TyTy::TypeKind::PARAM)\n+\t{\n+\t  return TyVar (subst->get_ty_ref ());\n+\t}\n+    }\n+\n+  return TyVar (subst->get_ref ());\n+}\n+\n void\n InferType::accept_vis (TyVisitor &vis)\n {\n@@ -442,10 +459,15 @@ SubstitutionParamMapping::need_substitution () const\n }\n \n bool\n-SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n+SubstitutionParamMapping::fill_param_ty (\n+  SubstitutionArgumentMappings &subst_mappings, Location locus)\n {\n-  auto context = Resolver::TypeCheckContext::get ();\n+  SubstitutionArg arg = SubstitutionArg::error ();\n+  bool ok = subst_mappings.get_argument_for_symbol (get_param_ty (), &arg);\n+  if (!ok)\n+    return true;\n \n+  TyTy::BaseType &type = *arg.get_tyty ();\n   if (type.get_kind () == TyTy::TypeKind::INFER)\n     {\n       type.inherit_bounds (*param);\n@@ -467,43 +489,9 @@ SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n       if (!param->bounds_compatible (type, locus, true))\n \treturn false;\n \n-      // setup any associated type mappings for the specified bonds and this\n-      // type\n-      auto candidates = Resolver::TypeBoundsProbe::Probe (&type);\n-      for (auto &specified_bound : param->get_specified_bounds ())\n-\t{\n-\t  const Resolver::TraitReference *specified_bound_ref\n-\t    = specified_bound.get ();\n-\n-\t  // since the bounds_compatible check has occurred we should be able to\n-\t  // assert on finding the trait references\n-\t  HirId associated_impl_block_id = UNKNOWN_HIRID;\n-\t  bool found = false;\n-\t  for (auto &bound : candidates)\n-\t    {\n-\t      const Resolver::TraitReference *bound_trait_ref = bound.first;\n-\t      const HIR::ImplBlock *associated_impl = bound.second;\n-\n-\t      found = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t      if (found)\n-\t\t{\n-\t\t  rust_assert (associated_impl != nullptr);\n-\t\t  associated_impl_block_id\n-\t\t    = associated_impl->get_mappings ().get_hirid ();\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (found && associated_impl_block_id != UNKNOWN_HIRID)\n-\t    {\n-\t      Resolver::AssociatedImplTrait *lookup_associated = nullptr;\n-\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\tassociated_impl_block_id, &lookup_associated);\n-\n-\t      if (found_impl_trait)\n-\t\tlookup_associated->setup_associated_types ();\n-\t    }\n-\t}\n+      // recursively pass this down to all HRTB's\n+      for (auto &bound : param->get_specified_bounds ())\n+\tbound.handle_substitions (subst_mappings);\n \n       param->set_ty_ref (type.get_ref ());\n     }\n@@ -602,6 +590,7 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n \t\t\t\t\t\t\t args.get_locus ());\n \t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n \t\t\t\t\t\t\t\t intermediate);\n+\n \t      if (resolved->get_kind () == TypeKind::ERROR)\n \t\treturn SubstitutionArgumentMappings::error ();\n \t    }\n@@ -773,6 +762,65 @@ SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n   return SubstitutionArgumentMappings (resolved_mappings, locus);\n }\n \n+bool\n+SubstitutionRef::monomorphize ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  for (const auto &subst : get_substs ())\n+    {\n+      const TyTy::ParamType *pty = subst.get_param_ty ();\n+\n+      if (!pty->can_resolve ())\n+\tcontinue;\n+\n+      const TyTy::BaseType *binding = pty->resolve ();\n+      if (binding->get_kind () == TyTy::TypeKind::PARAM)\n+\tcontinue;\n+\n+      for (const auto &bound : pty->get_specified_bounds ())\n+\t{\n+\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n+\n+\t  // setup any associated type mappings for the specified bonds and this\n+\t  // type\n+\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n+\n+\t  Resolver::AssociatedImplTrait *associated_impl_trait = nullptr;\n+\t  for (auto &probed_bound : candidates)\n+\t    {\n+\t      const Resolver::TraitReference *bound_trait_ref\n+\t\t= probed_bound.first;\n+\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+\t      HirId impl_block_id\n+\t\t= associated_impl->get_mappings ().get_hirid ();\n+\t      Resolver::AssociatedImplTrait *associated = nullptr;\n+\t      bool found_impl_trait\n+\t\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t\t &associated);\n+\t      rust_assert (found_impl_trait);\n+\n+\t      bool found_trait\n+\t\t= specified_bound_ref->is_equal (*bound_trait_ref);\n+\t      bool found_self\n+\t\t= associated->get_self ()->can_eq (binding, false);\n+\t      if (found_trait && found_self)\n+\t\t{\n+\t\t  associated_impl_trait = associated;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (associated_impl_trait != nullptr)\n+\t    {\n+\t      associated_impl_trait->setup_associated_types2 (binding, bound);\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -951,7 +999,7 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n-\tsub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n+\tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n     }\n \n   for (auto &variant : adt->get_variants ())\n@@ -1059,6 +1107,7 @@ TupleType::handle_substitions (SubstitutionArgumentMappings mappings)\n   auto mappings_table = Analysis::Mappings::get ();\n \n   TupleType *tuple = static_cast<TupleType *> (clone ());\n+  tuple->set_ref (mappings_table->get_next_hir_id ());\n   tuple->set_ty_ref (mappings_table->get_next_hir_id ());\n \n   for (size_t i = 0; i < tuple->fields.size (); i++)\n@@ -1069,7 +1118,8 @@ TupleType::handle_substitions (SubstitutionArgumentMappings mappings)\n \t  BaseType *concrete\n \t    = Resolver::SubstMapperInternal::Resolve (field.get_tyty (),\n \t\t\t\t\t\t      mappings);\n-\t  tuple->fields[i] = TyVar (concrete->get_ty_ref ());\n+\t  tuple->fields[i]\n+\t    = TyVar::subst_covariant_var (field.get_tyty (), concrete);\n \t}\n     }\n \n@@ -1196,7 +1246,7 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n \t{\n-\t  sub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n+\t  sub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n \t}\n     }\n \n@@ -1538,7 +1588,7 @@ ArrayType::handle_substitions (SubstitutionArgumentMappings mappings)\n   // might be &T or &ADT so this needs to be recursive\n   auto base = ref->get_element_type ();\n   BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n-  ref->element_type = TyVar (concrete->get_ty_ref ());\n+  ref->element_type = TyVar::subst_covariant_var (base, concrete);\n \n   return ref;\n }\n@@ -1627,7 +1677,7 @@ SliceType::handle_substitions (SubstitutionArgumentMappings mappings)\n   // might be &T or &ADT so this needs to be recursive\n   auto base = ref->get_element_type ();\n   BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n-  ref->element_type = TyVar (concrete->get_ty_ref ());\n+  ref->element_type = TyVar::subst_covariant_var (base, concrete);\n \n   return ref;\n }\n@@ -2146,7 +2196,7 @@ ReferenceType::handle_substitions (SubstitutionArgumentMappings mappings)\n   // might be &T or &ADT so this needs to be recursive\n   auto base = ref->get_base ();\n   BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n-  ref->base = TyVar (concrete->get_ty_ref ());\n+  ref->base = TyVar::subst_covariant_var (base, concrete);\n \n   return ref;\n }\n@@ -2232,7 +2282,7 @@ PointerType::handle_substitions (SubstitutionArgumentMappings mappings)\n   // might be &T or &ADT so this needs to be recursive\n   auto base = ref->get_base ();\n   BaseType *concrete = Resolver::SubstMapperInternal::Resolve (base, mappings);\n-  ref->base = TyVar (concrete->get_ty_ref ());\n+  ref->base = TyVar::subst_covariant_var (base, concrete);\n \n   return ref;\n }\n@@ -2252,31 +2302,22 @@ ParamType::accept_vis (TyConstVisitor &vis) const\n std::string\n ParamType::as_string () const\n {\n-  if (get_ref () == get_ty_ref ())\n+  if (!can_resolve ())\n     {\n       return get_symbol () + \" REF: \" + std::to_string (get_ref ());\n     }\n \n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (get_ty_ref (), &lookup);\n-  rust_assert (ok);\n-\n+  BaseType *lookup = resolve ();\n   return get_symbol () + \"=\" + lookup->as_string ();\n }\n \n std::string\n ParamType::get_name () const\n {\n-  if (get_ref () == get_ty_ref ())\n+  if (!can_resolve ())\n     return get_symbol ();\n \n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (get_ty_ref (), &lookup);\n-  rust_assert (ok);\n-\n-  return lookup->get_name ();\n+  return resolve ()->get_name ();\n }\n \n BaseType *\n@@ -2364,14 +2405,27 @@ ParamType::is_equal (const BaseType &other) const\n }\n \n ParamType *\n-ParamType::handle_substitions (SubstitutionArgumentMappings mappings)\n+ParamType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n+  SubstitutionArg arg = SubstitutionArg::error ();\n+  bool ok = subst_mappings.get_argument_for_symbol (this, &arg);\n+  if (!ok || arg.is_error ())\n+    return this;\n+\n   ParamType *p = static_cast<ParamType *> (clone ());\n+  subst_mappings.on_param_subst (*p, arg);\n \n-  SubstitutionArg arg = SubstitutionArg::error ();\n-  bool ok = mappings.get_argument_for_symbol (this, &arg);\n-  if (ok && !arg.is_error ())\n-    p->set_ty_ref (arg.get_tyty ()->get_ref ());\n+  // there are two cases one where we substitute directly to a new PARAM and\n+  // otherwise\n+  if (arg.get_tyty ()->get_kind () == TyTy::TypeKind::PARAM)\n+    {\n+      p->set_ty_ref (arg.get_tyty ()->get_ref ());\n+      return p;\n+    }\n+\n+  // this is the new subst that this needs to pass\n+  p->set_ref (mappings->get_next_hir_id ());\n+  p->set_ty_ref (arg.get_tyty ()->get_ref ());\n \n   return p;\n }\n@@ -2658,7 +2712,7 @@ ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n       if (ok)\n-\tsub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n+\tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n     }\n \n   auto fty = projection->base;\n@@ -2935,17 +2989,7 @@ TypeCheckCallExpr::visit (FnType &type)\n       return;\n     }\n \n-  if (type.get_return_type ()->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n-    {\n-      const TyTy::PlaceholderType *p\n-\t= static_cast<const TyTy::PlaceholderType *> (type.get_return_type ());\n-      if (p->can_resolve ())\n-\t{\n-\t  resolved = p->resolve ()->clone ();\n-\t  return;\n-\t}\n-    }\n-\n+  type.monomorphize ();\n   resolved = type.get_return_type ()->clone ();\n }\n \n@@ -3050,6 +3094,7 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n       return;\n     }\n \n+  type.monomorphize ();\n   resolved = type.get_return_type ()->clone ();\n }\n "}, {"sha": "17ba6554c4a720012f34ed91edacbaaed04c460c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -93,9 +93,7 @@ class TypeBoundPredicateItem\n     return parent == nullptr || trait_item_ref == nullptr;\n   }\n \n-  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver,\n-\t\t\t\t   const HIR::GenericArgs *bound_args\n-\t\t\t\t   = nullptr);\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n \n   const Resolver::TraitItemReference *get_raw_item () const;\n \n@@ -293,6 +291,9 @@ class TyVar\n \n   static TyVar get_implicit_infer_var (Location locus);\n \n+  static TyVar subst_covariant_var (TyTy::BaseType *orig,\n+\t\t\t\t    TyTy::BaseType *subst);\n+\n private:\n   HirId ref;\n };\n@@ -431,10 +432,10 @@ class ParamType : public BaseType\n \n   bool is_concrete () const override final\n   {\n-    if (!can_resolve ())\n+    auto r = resolve ();\n+    if (r == this)\n       return false;\n \n-    auto r = resolve ();\n     return r->is_concrete ();\n   }\n \n@@ -559,14 +560,17 @@ class SubstitutionParamMapping\n     return param->get_name ();\n   }\n \n-  bool fill_param_ty (BaseType &type, Location locus);\n+  bool fill_param_ty (SubstitutionArgumentMappings &subst_mappings,\n+\t\t      Location locus);\n \n   SubstitutionParamMapping clone () const\n   {\n     return SubstitutionParamMapping (generic, static_cast<ParamType *> (\n \t\t\t\t\t\tparam->clone ()));\n   }\n \n+  ParamType *get_param_ty () { return param; }\n+\n   const ParamType *get_param_ty () const { return param; }\n \n   const HIR::TypeParam &get_generic_param () { return generic; };\n@@ -577,11 +581,7 @@ class SubstitutionParamMapping\n \n   bool needs_substitution () const\n   {\n-    auto p = get_param_ty ();\n-    if (!p->can_resolve ())\n-      return true;\n-\n-    return p->resolve ()->get_kind () == TypeKind::PARAM;\n+    return !(get_param_ty ()->is_concrete ());\n   }\n \n   Location get_param_locus () const { return generic.get_locus (); }\n@@ -605,9 +605,12 @@ class SubstitutionArg\n {\n public:\n   SubstitutionArg (const SubstitutionParamMapping *param, BaseType *argument)\n-    : param (std::move (param)), argument (argument)\n+    : param (param), argument (argument)\n   {}\n \n+  // FIXME\n+  // the copy constructors need removed - they are unsafe see\n+  // TypeBoundPredicate\n   SubstitutionArg (const SubstitutionArg &other)\n     : param (other.param), argument (other.argument)\n   {}\n@@ -651,29 +654,35 @@ class SubstitutionArg\n   BaseType *argument;\n };\n \n+typedef std::function<void (const ParamType &, const SubstitutionArg &)>\n+  ParamSubstCb;\n class SubstitutionArgumentMappings\n {\n public:\n   SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n-\t\t\t\tLocation locus)\n-    : mappings (mappings), locus (locus)\n+\t\t\t\tLocation locus,\n+\t\t\t\tParamSubstCb param_subst_cb = nullptr)\n+    : mappings (mappings), locus (locus), param_subst_cb (param_subst_cb)\n   {}\n \n   SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n-    : mappings (other.mappings), locus (other.locus)\n+    : mappings (other.mappings), locus (other.locus),\n+      param_subst_cb (other.param_subst_cb)\n   {}\n \n   SubstitutionArgumentMappings &\n   operator= (const SubstitutionArgumentMappings &other)\n   {\n     mappings = other.mappings;\n     locus = other.locus;\n+    param_subst_cb = other.param_subst_cb;\n+\n     return *this;\n   }\n \n   static SubstitutionArgumentMappings error ()\n   {\n-    return SubstitutionArgumentMappings ({}, Location ());\n+    return SubstitutionArgumentMappings ({}, Location (), nullptr);\n   }\n \n   bool is_error () const { return mappings.size () == 0; }\n@@ -717,7 +726,7 @@ class SubstitutionArgumentMappings\n     return true;\n   }\n \n-  Location get_locus () { return locus; }\n+  Location get_locus () const { return locus; }\n \n   size_t size () const { return mappings.size (); }\n \n@@ -737,9 +746,18 @@ class SubstitutionArgumentMappings\n     return \"<\" + buffer + \">\";\n   }\n \n+  void on_param_subst (const ParamType &p, const SubstitutionArg &a) const\n+  {\n+    if (param_subst_cb == nullptr)\n+      return;\n+\n+    param_subst_cb (p, a);\n+  }\n+\n private:\n   std::vector<SubstitutionArg> mappings;\n   Location locus;\n+  ParamSubstCb param_subst_cb;\n };\n \n class SubstitutionRef\n@@ -944,9 +962,18 @@ class SubstitutionRef\n     return handle_substitions (std::move (infer_arguments));\n   }\n \n+  // TODO comment\n+  bool monomorphize ();\n+\n+  // TODO comment\n   virtual BaseType *handle_substitions (SubstitutionArgumentMappings mappings)\n     = 0;\n \n+  SubstitutionArgumentMappings get_used_arguments () const\n+  {\n+    return used_arguments;\n+  }\n+\n protected:\n   std::vector<SubstitutionParamMapping> substitutions;\n   SubstitutionArgumentMappings used_arguments;\n@@ -987,11 +1014,8 @@ class TypeBoundPredicate : public SubstitutionRef\n   TypeBoundPredicateItem\n   lookup_associated_item (const std::string &search) const;\n \n-  HIR::GenericArgs *get_generic_args () { return &args; }\n-\n-  const HIR::GenericArgs *get_generic_args () const { return &args; }\n-\n-  bool has_generic_args () const { return args.has_generic_args (); }\n+  TypeBoundPredicateItem\n+  lookup_associated_item (const Resolver::TraitItemReference *ref) const;\n \n   // WARNING THIS WILL ALWAYS RETURN NULLPTR\n   BaseType *\n@@ -1004,7 +1028,6 @@ class TypeBoundPredicate : public SubstitutionRef\n private:\n   DefId reference;\n   Location locus;\n-  HIR::GenericArgs args;\n   bool error_flag;\n };\n "}, {"sha": "4412656f5351527e1c4255dec12d77288791b634", "filename": "gcc/testsuite/rust/compile/torture/traits19.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits19.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits19.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits19.rs?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -0,0 +1,33 @@\n+// { dg-additional-options \"-w\" }\n+trait Get {\n+    type Value;\n+    fn get(&self) -> &<Self as Get>::Value;\n+}\n+\n+struct Struct {\n+    x: isize,\n+}\n+\n+impl Get for Struct {\n+    type Value = isize;\n+    fn get(&self) -> &isize {\n+        &self.x\n+    }\n+}\n+\n+trait Grab {\n+    type U;\n+    fn grab(&self) -> &<Self as Grab>::U;\n+}\n+\n+impl<T: Get> Grab for T {\n+    type U = <T as Get>::Value;\n+    fn grab(&self) -> &<T as Get>::Value {\n+        self.get()\n+    }\n+}\n+\n+fn main() {\n+    let s = Struct { x: 100 };\n+    let a = s.grab();\n+}"}, {"sha": "bac8a7803e60854ddad2e42f346a2aad3a2a9716", "filename": "gcc/testsuite/rust/execute/torture/slice-magic.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fslice-magic.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fslice-magic.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fslice-magic.rs?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -0,0 +1,106 @@\n+// { dg-additional-options \"-w\" }\n+extern \"rust-intrinsic\" {\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"const_slice_ptr\"]\n+impl<A> *const [A] {\n+    pub const fn len(self) -> usize {\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const A {\n+        self as *const A\n+    }\n+}\n+\n+#[lang = \"const_ptr\"]\n+impl<B> *const B {\n+    pub const unsafe fn offset(self, count: isize) -> *const B {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const B {\n+        self as *const B\n+    }\n+}\n+\n+const fn slice_from_raw_parts<C>(data: *const C, len: usize) -> *const [C] {\n+    unsafe {\n+        Repr {\n+            raw: FatPtr { data, len },\n+        }\n+        .rust\n+    }\n+}\n+\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+pub unsafe trait SliceIndex<X> {\n+    type Output;\n+\n+    unsafe fn get_unchecked(self, slice: *const X) -> *const Self::Output;\n+\n+    fn index(self, slice: &X) -> &Self::Output;\n+}\n+\n+unsafe impl<Y> SliceIndex<[Y]> for Range<usize> {\n+    type Output = [Y];\n+\n+    unsafe fn get_unchecked(self, slice: *const [Y]) -> *const [Y] {\n+        unsafe {\n+            let a: *const Y = slice.as_ptr();\n+            let b: *const Y = a.add(self.start);\n+            slice_from_raw_parts(b, self.end - self.start)\n+        }\n+    }\n+\n+    fn index(self, slice: &[Y]) -> &[Y] {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+impl<T, I> Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = [1, 2, 3, 4, 5];\n+    let b = &a[1..3];\n+\n+    0\n+}"}, {"sha": "5a89f2ef3dd1414f3a2c3e58d1d3124148ba97f5", "filename": "gcc/testsuite/rust/execute/torture/slice-magic2.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fslice-magic2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a022385f5ed99b579e373d37cec389433e93f4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fslice-magic2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fslice-magic2.rs?ref=c1a022385f5ed99b579e373d37cec389433e93f4", "patch": "@@ -0,0 +1,106 @@\n+// { dg-additional-options \"-w\" }\n+extern \"rust-intrinsic\" {\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"const_slice_ptr\"]\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+#[lang = \"const_ptr\"]\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    unsafe {\n+        Repr {\n+            raw: FatPtr { data, len },\n+        }\n+        .rust\n+    }\n+}\n+\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+pub unsafe trait SliceIndex<T> {\n+    type Output;\n+\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n+\n+    fn index(self, slice: &T) -> &Self::Output;\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for Range<usize> {\n+    type Output = [T];\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        unsafe {\n+            let a: *const T = slice.as_ptr();\n+            let b: *const T = a.add(self.start);\n+            slice_from_raw_parts(b, self.end - self.start)\n+        }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &[T] {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+impl<T, I> Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = [1, 2, 3, 4, 5];\n+    let b = &a[1..3];\n+\n+    0\n+}"}]}