{"sha": "6865f4cd9fcc09aa8166eb1cd18e473d9378ab34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2NWY0Y2Q5ZmNjMDlhYTgxNjZlYjFjZDE4ZTQ3M2Q5Mzc4YWIzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-01-26T08:07:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-01-26T08:07:01Z"}, "message": "mips.c (mips16_optimize_gp): Delete.\n\n\t* config/mips/mips.c (mips16_optimize_gp): Delete.\n\t(mips_reorg): Don't call it.\n\nFrom-SVN: r76623", "tree": {"sha": "0e5bc464aea5dcea69d9bcde09f51d4548fa70e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e5bc464aea5dcea69d9bcde09f51d4548fa70e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34/comments", "author": null, "committer": null, "parents": [{"sha": "f210a0077b30890040da85203e62be4222315b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f210a0077b30890040da85203e62be4222315b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f210a0077b30890040da85203e62be4222315b6c"}], "stats": {"total": 229, "additions": 6, "deletions": 223}, "files": [{"sha": "bbeb017aea476010306e0e6c63b2a85a804a3008", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6865f4cd9fcc09aa8166eb1cd18e473d9378ab34", "patch": "@@ -1,3 +1,8 @@\n+2004-01-26  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips16_optimize_gp): Delete.\n+\t(mips_reorg): Don't call it.\n+\n 2004-01-26  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (addqi3_noclobber): Move up pecking order."}, {"sha": "4663ad478bd2fe077b6c4c1488c32a4d7dd05613", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 223, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6865f4cd9fcc09aa8166eb1cd18e473d9378ab34/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6865f4cd9fcc09aa8166eb1cd18e473d9378ab34", "patch": "@@ -267,7 +267,6 @@ static rtx mips_return_fpr_pair (enum machine_mode mode,\n static rtx mips16_gp_pseudo_reg (void);\n static void mips16_fp_args (FILE *, int, int);\n static void build_mips16_function_stub (FILE *);\n-static void mips16_optimize_gp (void);\n static rtx add_constant\t(struct constant **, rtx, enum machine_mode);\n static void dump_constants (struct constant *, rtx);\n static rtx mips_find_symbol (rtx);\n@@ -8306,223 +8305,6 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n   return 0;\n }\n \n-/* This function looks through the code for a function, and tries to\n-   optimize the usage of the $gp register.  We arrange to copy $gp\n-   into a pseudo-register, and then let gcc's normal reload handling\n-   deal with the pseudo-register.  Unfortunately, if reload choose to\n-   put the pseudo-register into a call-clobbered register, it will\n-   emit saves and restores for that register around any function\n-   calls.  We don't need the saves, and it's faster to copy $gp than\n-   to do an actual restore.  ??? This still means that we waste a\n-   stack slot.\n-\n-   This is an optimization, and the code which gcc has actually\n-   generated is correct, so we do not need to catch all cases.  */\n-\n-static void\n-mips16_optimize_gp (void)\n-{\n-  rtx gpcopy, slot, insn;\n-\n-  /* Look through the instructions.  Set GPCOPY to the register which\n-     holds a copy of $gp.  Set SLOT to the stack slot where it is\n-     saved.  If we find an instruction which sets GPCOPY to anything\n-     other than $gp or SLOT, then we can't use it.  If we find an\n-     instruction which sets SLOT to anything other than GPCOPY, we\n-     can't use it.  */\n-\n-  gpcopy = NULL_RTX;\n-  slot = NULL_RTX;\n-  for (insn = get_insns (); insn != NULL_RTX; insn = next_active_insn (insn))\n-    {\n-      rtx set;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      set = PATTERN (insn);\n-\n-      /* We know that all references to memory will be inside a SET,\n-         because there is no other way to access memory on the mips16.\n-         We don't have to worry about a PARALLEL here, because the\n-         mips.md file will never generate them for memory references.  */\n-      if (GET_CODE (set) != SET)\n-\tcontinue;\n-\n-      if (gpcopy == NULL_RTX\n-\t  && GET_CODE (SET_SRC (set)) == CONST\n-\t  && XEXP (SET_SRC (set), 0) == pic_offset_table_rtx\n-\t  && GET_CODE (SET_DEST (set)) == REG)\n-\tgpcopy = SET_DEST (set);\n-      else if (slot == NULL_RTX\n-\t       && gpcopy != NULL_RTX\n-\t       && GET_CODE (SET_DEST (set)) == MEM\n-\t       && GET_CODE (SET_SRC (set)) == REG\n-\t       && REGNO (SET_SRC (set)) == REGNO (gpcopy))\n-\t{\n-\t  rtx base, offset;\n-\n-\t  offset = const0_rtx;\n-\t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n-\t  if (GET_CODE (base) == REG\n-\t      && (REGNO (base) == STACK_POINTER_REGNUM\n-\t\t  || REGNO (base) == FRAME_POINTER_REGNUM))\n-\t    slot = SET_DEST (set);\n-\t}\n-      else if (gpcopy != NULL_RTX\n-\t       && (GET_CODE (SET_DEST (set)) == REG\n-\t\t   || GET_CODE (SET_DEST (set)) == SUBREG)\n-\t       && reg_overlap_mentioned_p (SET_DEST (set), gpcopy)\n-\t       && (GET_CODE (SET_DEST (set)) != REG\n-\t\t   || REGNO (SET_DEST (set)) != REGNO (gpcopy)\n-\t\t   || ((GET_CODE (SET_SRC (set)) != CONST\n-\t\t\t|| XEXP (SET_SRC (set), 0) != pic_offset_table_rtx)\n-\t\t       && ! rtx_equal_p (SET_SRC (set), slot))))\n-\tbreak;\n-      else if (slot != NULL_RTX\n-\t       && GET_CODE (SET_DEST (set)) == MEM\n-\t       && rtx_equal_p (SET_DEST (set), slot)\n-\t       && (GET_CODE (SET_SRC (set)) != REG\n-\t\t   || REGNO (SET_SRC (set)) != REGNO (gpcopy)))\n-\tbreak;\n-    }\n-\n-  /* If we couldn't find a unique value for GPCOPY or SLOT, then try a\n-     different optimization.  Any time we find a copy of $28 into a\n-     register, followed by an add of a symbol_ref to that register, we\n-     convert it to load the value from the constant table instead.\n-     The copy and add will take six bytes, just as the load and\n-     constant table entry will take six bytes.  However, it is\n-     possible that the constant table entry will be shared.\n-\n-     This could be a peephole optimization, but I don't know if the\n-     peephole code can call force_const_mem.\n-\n-     Using the same register for the copy of $28 and the add of the\n-     symbol_ref is actually pretty likely, since the add instruction\n-     requires the destination and the first addend to be the same\n-     register.  */\n-\n-  if (insn != NULL_RTX || gpcopy == NULL_RTX || slot == NULL_RTX)\n-    {\n-#if 0\n-      /* Used below in #if 0 area.  */\n-      rtx next;\n-#endif\n-      /* This optimization is only reasonable if the constant table\n-         entries are only 4 bytes.  */\n-      if (Pmode != SImode)\n-\treturn;\n-\n-#if 0\n-  /* ??? FIXME.  Rewrite for new UNSPEC_RELOC stuff.  */\n-      for (insn = get_insns (); insn != NULL_RTX; insn = next)\n-\t{\n-\t  rtx set1, set2;\n-\n-\t  next = insn;\n-\t  do\n-\t    {\n-\t      next = NEXT_INSN (next);\n-\t    }\n-\t  while (next != NULL_RTX\n-\t\t && (GET_CODE (next) == NOTE\n-\t\t     || (GET_CODE (next) == INSN\n-\t\t\t && (GET_CODE (PATTERN (next)) == USE\n-\t\t\t     || GET_CODE (PATTERN (next)) == CLOBBER))));\n-\n-\t  if (next == NULL_RTX)\n-\t    break;\n-\n-\t  if (! INSN_P (insn))\n-\t    continue;\n-\n-\t  if (! INSN_P (next))\n-\t    continue;\n-\n-\t  set1 = PATTERN (insn);\n-\t  if (GET_CODE (set1) != SET)\n-\t    continue;\n-\t  set2 = PATTERN (next);\n-\t  if (GET_CODE (set2) != SET)\n-\t    continue;\n-\n-\t  if (GET_CODE (SET_DEST (set1)) == REG\n-\t      && GET_CODE (SET_SRC (set1)) == CONST\n-\t      && XEXP (SET_SRC (set1), 0) == pic_offset_table_rtx\n-\t      && rtx_equal_p (SET_DEST (set1), SET_DEST (set2))\n-\t      && GET_CODE (SET_SRC (set2)) == PLUS\n-\t      && rtx_equal_p (SET_DEST (set1), XEXP (SET_SRC (set2), 0))\n-\t      && mips16_gp_offset_p (XEXP (SET_SRC (set2), 1))\n-\t      && GET_CODE (XEXP (XEXP (SET_SRC (set2), 1), 0)) == MINUS)\n-\t    {\n-\t      rtx sym;\n-\n-\t      /* We've found a case we can change to load from the\n-                 constant table.  */\n-\n-\t      sym = XEXP (XEXP (XEXP (SET_SRC (set2), 1), 0), 0);\n-\t      if (GET_CODE (sym) != SYMBOL_REF)\n-\t\tabort ();\n-\t      emit_insn_after (gen_rtx (SET, VOIDmode, SET_DEST (set1),\n-\t\t\t\t\tforce_const_mem (Pmode, sym)),\n-\t\t\t       next);\n-\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\n-\t      PUT_CODE (next, NOTE);\n-\t      NOTE_LINE_NUMBER (next) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (next) = 0;\n-\t    }\n-\t}\n-#endif\n-\n-      return;\n-    }\n-  /* We can safely remove all assignments to SLOT from GPCOPY, and\n-     replace all assignments from SLOT to GPCOPY with assignments from\n-     $28.  */\n-\n-  for (insn = get_insns (); insn != NULL_RTX; insn = next_active_insn (insn))\n-    {\n-      rtx set;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      set = PATTERN (insn);\n-      if (GET_CODE (set) != SET)\n-\tcontinue;\n-\n-      if (GET_CODE (SET_DEST (set)) == MEM\n-\t  && rtx_equal_p (SET_DEST (set), slot)\n-\t  && GET_CODE (SET_SRC (set)) == REG\n-\t  && REGNO (SET_SRC (set)) == REGNO (gpcopy))\n-\t{\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t}\n-      else if (GET_CODE (SET_DEST (set)) == REG\n-\t       && REGNO (SET_DEST (set)) == REGNO (gpcopy)\n-\t       && GET_CODE (SET_SRC (set)) == MEM\n-\t       && rtx_equal_p (SET_SRC (set), slot))\n-\t{\n-\t  enum machine_mode mode;\n-\t  rtx src;\n-\n-\t  mode = GET_MODE (SET_DEST (set));\n-\t  src = gen_rtx_CONST (mode, pic_offset_table_rtx);\n-\t  emit_insn_after (gen_rtx_SET (VOIDmode, SET_DEST (set), src), insn);\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t}\n-    }\n-}\n-\n /* We keep a list of constants we which we have to add to internal\n    constant tables in the middle of large functions.  */\n \n@@ -8971,11 +8753,7 @@ static void\n mips_reorg (void)\n {\n   if (TARGET_MIPS16)\n-    {\n-      if (optimize)\n-\tmips16_optimize_gp ();\n-      mips16_lay_out_constants ();\n-    }\n+    mips16_lay_out_constants ();\n   else if (TARGET_EXPLICIT_RELOCS)\n     {\n       if (mips_flag_delayed_branch)"}]}