{"sha": "5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUzNTYzMzQwN2EzYzg0YjRmMTliOWMyZjg4YmU5MmNiNTFiYThlMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-01-24T19:06:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-01-24T19:06:38Z"}, "message": "rtl.texi (MEM_IN_STRUCT_P, [...]): Delete.\n\ngcc/\n\t* doc/rtl.texi (MEM_IN_STRUCT_P, MEM_SCALAR_P): Delete.\n\t(in_struct, return_val): Remove MEM documentation.\n\t* rtl.h (rtx_def): Remove MEM meanings from in_struct and return_val.\n\t(MEM_IN_STRUCT_P, MEM_SCALAR_P): Delete.\n\t(MEM_COPY_ATTRIBUTES): Remove references to MEM_IN_STRUCT_P\n\tand MEM_SCALAR.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n\t* cfgexpand.c (add_alias_set_conflicts): Likewise.\n\t* expr.c (store_field): Likewise.\n\t* function.c (assign_stack_temp_for_type): Likewise.\n\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n\t* reload1.c (reload): Likewise.\n\t* config/alpha/alpha.c (alpha_set_memflags_1): Likewise.\n\t(alpha_set_memflags): Likewise.\n\t* config/m32c/m32c.c (m32c_immd_dbl_mov): Nullify.\n\ngcc/testsuite/\n\t* gcc.dg/memcpy-4.c: Don't expect /s on MEMs.\n\nFrom-SVN: r183486", "tree": {"sha": "0437cd6825d81c4a05099372f1111220a0a2e1ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0437cd6825d81c4a05099372f1111220a0a2e1ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53d9622bda42facc4e456033b7a86e7bf102826a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d9622bda42facc4e456033b7a86e7bf102826a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53d9622bda42facc4e456033b7a86e7bf102826a"}], "stats": {"total": 217, "additions": 34, "deletions": 183}, "files": [{"sha": "82ba50f9d65d9c5b597f45bdfa4ab0877211474e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -1,3 +1,21 @@\n+2012-01-24  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* doc/rtl.texi (MEM_IN_STRUCT_P, MEM_SCALAR_P): Delete.\n+\t(in_struct, return_val): Remove MEM documentation.\n+\t* rtl.h (rtx_def): Remove MEM meanings from in_struct and return_val.\n+\t(MEM_IN_STRUCT_P, MEM_SCALAR_P): Delete.\n+\t(MEM_COPY_ATTRIBUTES): Remove references to MEM_IN_STRUCT_P\n+\tand MEM_SCALAR.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n+\t* cfgexpand.c (add_alias_set_conflicts): Likewise.\n+\t* expr.c (store_field): Likewise.\n+\t* function.c (assign_stack_temp_for_type): Likewise.\n+\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n+\t* reload1.c (reload): Likewise.\n+\t* config/alpha/alpha.c (alpha_set_memflags_1): Likewise.\n+\t(alpha_set_memflags): Likewise.\n+\t* config/m32c/m32c.c (m32c_immd_dbl_mov): Nullify.\n+\n 2012-01-24  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* rtl.h (true_dependence, canon_true_dependence): Remove varies"}, {"sha": "6d31e90f08623719a9da37bd68f32b9de9232e6d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -357,8 +357,7 @@ aggregate_contains_union_type (tree type)\n    and due to type based aliasing rules decides that for two overlapping\n    union temporaries { short s; int i; } accesses to the same mem through\n    different types may not alias and happily reorders stores across\n-   life-time boundaries of the temporaries (See PR25654).\n-   We also have to mind MEM_IN_STRUCT_P and MEM_SCALAR_P.  */\n+   life-time boundaries of the temporaries (See PR25654).  */\n \n static void\n add_alias_set_conflicts (void)"}, {"sha": "8e2a5cdf1dd6ed6643c8d916cc7d9b16eef4ffff", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -1489,8 +1489,6 @@ alpha_set_memflags_1 (rtx *xp, void *data)\n     return 0;\n \n   MEM_VOLATILE_P (x) = MEM_VOLATILE_P (orig);\n-  MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (orig);\n-  MEM_SCALAR_P (x) = MEM_SCALAR_P (orig);\n   MEM_NOTRAP_P (x) = MEM_NOTRAP_P (orig);\n   MEM_READONLY_P (x) = MEM_READONLY_P (orig);\n \n@@ -1520,8 +1518,6 @@ alpha_set_memflags (rtx seq, rtx ref)\n      generated from one of the insn patterns.  So if everything is\n      zero, the pattern is already up-to-date.  */\n   if (!MEM_VOLATILE_P (ref)\n-      && !MEM_IN_STRUCT_P (ref)\n-      && !MEM_SCALAR_P (ref)\n       && !MEM_NOTRAP_P (ref)\n       && !MEM_READONLY_P (ref))\n     return;"}, {"sha": "57586474d9cbf45dbe3a305f94484e1493115bbd", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 3, "deletions": 87, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -3475,95 +3475,11 @@ m32c_mov_ok (rtx * operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n    for moving an immediate double data to a double data type variable\n    location, can be combined into single SImode mov instruction.  */\n bool\n-m32c_immd_dbl_mov (rtx * operands, \n+m32c_immd_dbl_mov (rtx * operands ATTRIBUTE_UNUSED,\n \t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  int flag = 0, okflag = 0, offset1 = 0, offset2 = 0, offsetsign = 0;\n-  const char *str1;\n-  const char *str2;\n-\n-  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF\n-      && MEM_SCALAR_P (operands[0])\n-      && !MEM_IN_STRUCT_P (operands[0])\n-      && GET_CODE (XEXP (operands[2], 0)) == CONST\n-      && GET_CODE (XEXP (XEXP (operands[2], 0), 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (XEXP (operands[2], 0), 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (XEXP (operands[2], 0), 0), 1)) == CONST_INT\n-      && MEM_SCALAR_P (operands[2])\n-      && !MEM_IN_STRUCT_P (operands[2]))\n-    flag = 1; \n-\n-  else if (GET_CODE (XEXP (operands[0], 0)) == CONST\n-           && GET_CODE (XEXP (XEXP (operands[0], 0), 0)) == PLUS\n-           && GET_CODE (XEXP (XEXP (XEXP (operands[0], 0), 0), 0)) == SYMBOL_REF\n-           && MEM_SCALAR_P (operands[0])\n-           && !MEM_IN_STRUCT_P (operands[0])\n-           && !(INTVAL (XEXP (XEXP (XEXP (operands[0], 0), 0), 1)) %4)\n-           && GET_CODE (XEXP (operands[2], 0)) == CONST\n-           && GET_CODE (XEXP (XEXP (operands[2], 0), 0)) == PLUS\n-           && GET_CODE (XEXP (XEXP (XEXP (operands[2], 0), 0), 0)) == SYMBOL_REF\n-           && MEM_SCALAR_P (operands[2])\n-           && !MEM_IN_STRUCT_P (operands[2]))\n-    flag = 2; \n-\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PLUS\n-           &&  GET_CODE (XEXP (XEXP (operands[0], 0), 0)) == REG\n-           &&  REGNO (XEXP (XEXP (operands[0], 0), 0)) == FB_REGNO \n-           &&  GET_CODE (XEXP (XEXP (operands[0], 0), 1)) == CONST_INT\n-           &&  MEM_SCALAR_P (operands[0])\n-           &&  !MEM_IN_STRUCT_P (operands[0])\n-           &&  !(INTVAL (XEXP (XEXP (operands[0], 0), 1)) %4)\n-           &&  REGNO (XEXP (XEXP (operands[2], 0), 0)) == FB_REGNO \n-           &&  GET_CODE (XEXP (XEXP (operands[2], 0), 1)) == CONST_INT\n-           &&  MEM_SCALAR_P (operands[2])\n-           &&  !MEM_IN_STRUCT_P (operands[2]))\n-    flag = 3; \n-\n-  else\n-    return false;\n-\n-  switch (flag)\n-    {\n-    case 1:\n-      str1 = XSTR (XEXP (operands[0], 0), 0);\n-      str2 = XSTR (XEXP (XEXP (XEXP (operands[2], 0), 0), 0), 0);\n-      if (strcmp (str1, str2) == 0)\n-\tokflag = 1; \n-      else\n-\tokflag = 0; \n-      break;\n-    case 2:\n-      str1 = XSTR (XEXP (XEXP (XEXP (operands[0], 0), 0), 0), 0);\n-      str2 = XSTR (XEXP (XEXP (XEXP (operands[2], 0), 0), 0), 0);\n-      if (strcmp(str1,str2) == 0)\n-\tokflag = 1; \n-      else\n-\tokflag = 0; \n-      break; \n-    case 3:\n-      offset1 = INTVAL (XEXP (XEXP (operands[0], 0), 1));\n-      offset2 = INTVAL (XEXP (XEXP (operands[2], 0), 1));\n-      offsetsign = offset1 >> ((sizeof (offset1) * 8) -1);\n-      if (((offset2-offset1) == 2) && offsetsign != 0)\n-\tokflag = 1;\n-      else \n-\tokflag = 0; \n-      break; \n-    default:\n-      okflag = 0; \n-    } \n-      \n-  if (okflag == 1)\n-    {\n-      HOST_WIDE_INT val;\n-      operands[4] = gen_rtx_MEM (SImode, XEXP (operands[0], 0));\n-\n-      val = (INTVAL (operands[3]) << 16) + (INTVAL (operands[1]) & 0xFFFF);\n-      operands[5] = gen_rtx_CONST_INT (VOIDmode, val);\n-     \n-      return true;\n-    }\n-\n+  /* ??? This relied on the now-defunct MEM_SCALAR and MEM_IN_STRUCT_P\n+     flags.  */\n   return false;\n }  \n "}, {"sha": "7e9e535abb5452a3014538252b13c2ad62eb9552", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -669,17 +669,6 @@ In @code{label_ref} and @code{reg_label} expressions, nonzero if this is\n a reference to a non-local label.\n Stored in the @code{volatil} field and printed as @samp{/v}.\n \n-@findex MEM_IN_STRUCT_P\n-@cindex @code{mem} and @samp{/s}\n-@cindex @code{in_struct}, in @code{mem}\n-@item MEM_IN_STRUCT_P (@var{x})\n-In @code{mem} expressions, nonzero for reference to an entire structure,\n-union or array, or to a component of one.  Zero for references to a\n-scalar variable or through a pointer to a scalar.  If both this flag and\n-@code{MEM_SCALAR_P} are clear, then we don't know whether this @code{mem}\n-is in a structure or not.  Both flags should never be simultaneously set.\n-Stored in the @code{in_struct} field and printed as @samp{/s}.\n-\n @findex MEM_KEEP_ALIAS_SET_P\n @cindex @code{mem} and @samp{/j}\n @cindex @code{jump}, in @code{mem}\n@@ -689,18 +678,6 @@ mem unchanged when we access a component.  Set to 1, for example, when we\n are already in a non-addressable component of an aggregate.\n Stored in the @code{jump} field and printed as @samp{/j}.\n \n-@findex MEM_SCALAR_P\n-@cindex @code{mem} and @samp{/i}\n-@cindex @code{return_val}, in @code{mem}\n-@item MEM_SCALAR_P (@var{x})\n-In @code{mem} expressions, nonzero for reference to a scalar known not\n-to be a member of a structure, union, or array.  Zero for such\n-references and for indirections through pointers, even pointers pointing\n-to scalar types.  If both this flag and @code{MEM_IN_STRUCT_P} are clear,\n-then we don't know whether this @code{mem} is in a structure or not.\n-Both flags should never be simultaneously set.\n-Stored in the @code{return_val} field and printed as @samp{/i}.\n-\n @findex MEM_VOLATILE_P\n @cindex @code{mem} and @samp{/v}\n @cindex @code{asm_input} and @samp{/v}\n@@ -944,12 +921,6 @@ In an RTL dump, this flag is represented as @samp{/f}.\n @findex in_struct\n @cindex @samp{/s} in RTL dump\n @item in_struct\n-In @code{mem} expressions, it is 1 if the memory datum referred to is\n-all or part of a structure or array; 0 if it is (or might be) a scalar\n-variable.  A reference through a C pointer has 0 because the pointer\n-might point to a scalar variable.  This information allows the compiler\n-to determine something about possible cases of aliasing.\n-\n In @code{reg} expressions, it is 1 if the register has its entire life\n contained within the test expression of some loop.\n \n@@ -986,9 +957,6 @@ machines that pass parameters in registers, the same register number\n may be used for parameters as well, but this flag is not set on such\n uses.\n \n-In @code{mem} expressions, 1 means the memory reference is to a scalar\n-known not to be a member of a structure, union, or array.\n-\n In @code{symbol_ref} expressions, 1 means the referenced symbol is weak.\n \n In @code{call} expressions, 1 means the call is pure."}, {"sha": "765dd942ad015fb27bf644d8426b983405566b76", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -1572,17 +1572,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n   attrs.alias = get_alias_set (t);\n \n   MEM_VOLATILE_P (ref) |= TYPE_VOLATILE (type);\n-  MEM_IN_STRUCT_P (ref)\n-    = AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE;\n   MEM_POINTER (ref) = POINTER_TYPE_P (type);\n \n-  /* If we are making an object of this type, or if this is a DECL, we know\n-     that it is a scalar if the type is not an aggregate.  */\n-  if ((objectp || DECL_P (t))\n-      && ! AGGREGATE_TYPE_P (type)\n-      && TREE_CODE (type) != COMPLEX_TYPE)\n-    MEM_SCALAR_P (ref) = 1;\n-\n   /* Default values from pre-existing memory attributes if present.  */\n   refattrs = MEM_ATTRS (ref);\n   if (refattrs)\n@@ -1854,17 +1845,6 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n   /* Now set the attributes we computed above.  */\n   attrs.addrspace = TYPE_ADDR_SPACE (type);\n   set_mem_attrs (ref, &attrs);\n-\n-  /* If this is already known to be a scalar or aggregate, we are done.  */\n-  if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))\n-    return;\n-\n-  /* If it is a reference into an aggregate, this is part of an aggregate.\n-     Otherwise we don't know.  */\n-  else if (TREE_CODE (t) == COMPONENT_REF || TREE_CODE (t) == ARRAY_REF\n-\t   || TREE_CODE (t) == ARRAY_RANGE_REF\n-\t   || TREE_CODE (t) == BIT_FIELD_REF)\n-    MEM_IN_STRUCT_P (ref) = 1;\n }\n \n void"}, {"sha": "bd2f6b18f7c5a06d32ee1117c0ffedefb8a05386", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -6429,8 +6429,6 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (to_rtx == target)\n \tto_rtx = copy_rtx (to_rtx);\n \n-      if (!MEM_SCALAR_P (to_rtx))\n-\tMEM_IN_STRUCT_P (to_rtx) = 1;\n       if (!MEM_KEEP_ALIAS_SET_P (to_rtx) && MEM_ALIAS_SET (to_rtx) != 0)\n \tset_mem_alias_set (to_rtx, alias_set);\n "}, {"sha": "4508ae22de41af6e17d9f3cac5bb2eb2e569377d", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -939,14 +939,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \n   /* If a type is specified, set the relevant flags.  */\n   if (type != 0)\n-    {\n-      MEM_VOLATILE_P (slot) = TYPE_VOLATILE (type);\n-      gcc_checking_assert (!MEM_SCALAR_P (slot) && !MEM_IN_STRUCT_P (slot));\n-      if (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE)\n-\tMEM_IN_STRUCT_P (slot) = 1;\n-      else\n-\tMEM_SCALAR_P (slot) = 1;\n-    }\n+    MEM_VOLATILE_P (slot) = TYPE_VOLATILE (type);\n   MEM_NOTRAP_P (slot) = 1;\n \n   return slot;"}, {"sha": "8d81c8913da48f024c592475d88cada52a2e59e5", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -1667,10 +1667,6 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n       /* Copy over flags as appropriate.  */\n       if (MEM_VOLATILE_P (if_info->a) || MEM_VOLATILE_P (if_info->b))\n \tMEM_VOLATILE_P (tmp) = 1;\n-      if (MEM_IN_STRUCT_P (if_info->a) && MEM_IN_STRUCT_P (if_info->b))\n-\tMEM_IN_STRUCT_P (tmp) = 1;\n-      if (MEM_SCALAR_P (if_info->a) && MEM_SCALAR_P (if_info->b))\n-\tMEM_SCALAR_P (tmp) = 1;\n       if (MEM_ALIAS_SET (if_info->a) == MEM_ALIAS_SET (if_info->b))\n \tset_mem_alias_set (tmp, MEM_ALIAS_SET (if_info->a));\n       set_mem_align (tmp,"}, {"sha": "f9abf723152d2b9521283e1a522c193e4b5b9269", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -1111,10 +1111,7 @@ reload (rtx first, int global)\n \t      if (reg_equiv_memory_loc (i))\n \t\tMEM_COPY_ATTRIBUTES (reg, reg_equiv_memory_loc (i));\n \t      else\n-\t\t{\n-\t\t  MEM_IN_STRUCT_P (reg) = MEM_SCALAR_P (reg) = 0;\n-\t\t  MEM_ATTRS (reg) = 0;\n-\t\t}\n+\t\tMEM_ATTRS (reg) = 0;\n \t      MEM_NOTRAP_P (reg) = 1;\n \t    }\n \t  else if (reg_equiv_mem (i))"}, {"sha": "b1b681be568261899cd910c0e695a3181ac23b8b", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -296,10 +296,7 @@ struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      barrier.\n      1 in a CONCAT is VAL_NEEDS_RESOLUTION in var-tracking.c.  */\n   unsigned int volatil : 1;\n-  /* 1 in a MEM referring to a field of an aggregate.\n-     0 if the MEM was a variable or the result of a * operator in C;\n-     1 if it was the result of a . or -> operator (on a struct) in C.\n-     1 in a REG if the register is used only in exit code a loop.\n+  /* 1 in a REG if the register is used only in exit code a loop.\n      1 in a SUBREG expression if was generated from a variable with a\n      promoted mode.\n      1 in a CODE_LABEL if the label is used for nonlocal gotos\n@@ -308,7 +305,10 @@ struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      together with the preceding insn.  Valid only within sched.\n      1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n      from the target of a branch.  Valid from reorg until end of compilation;\n-     cleared before used.  */\n+     cleared before used.\n+\n+     The name of the field is historical.  It used to be used in MEMs\n+     to record whether the MEM accessed part of a structure.  */\n   unsigned int in_struct : 1;\n   /* At the end of RTL generation, 1 if this rtx is used.  This is used for\n      copying shared structure.  See `unshare_all_rtl'.\n@@ -328,7 +328,6 @@ struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      1 in a VALUE is VALUE_CHANGED in var-tracking.c.  */\n   unsigned frame_related : 1;\n   /* 1 in a REG or PARALLEL that is the current function's return value.\n-     1 in a MEM if it refers to a scalar.\n      1 in a SYMBOL_REF for a weak symbol.\n      1 in a CALL_INSN logically equivalent to ECF_PURE and DECL_PURE_P.\n      1 in a CONCAT is VAL_EXPR_HAS_REVERSE in var-tracking.c.\n@@ -1335,17 +1334,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK3(\"MEM_VOLATILE_P\", (RTX), MEM, ASM_OPERANDS,\t\t\\\n \t\t   ASM_INPUT)->volatil)\n \n-/* 1 if RTX is a mem that refers to an aggregate, either to the\n-   aggregate itself or to a field of the aggregate.  If zero, RTX may\n-   or may not be such a reference.  */\n-#define MEM_IN_STRUCT_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"MEM_IN_STRUCT_P\", (RTX), MEM)->in_struct)\n-\n-/* 1 if RTX is a MEM that refers to a scalar.  If zero, RTX may or may\n-   not refer to a scalar.  */\n-#define MEM_SCALAR_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"MEM_SCALAR_P\", (RTX), MEM)->return_val)\n-\n /* 1 if RTX is a mem that cannot trap.  */\n #define MEM_NOTRAP_P(RTX) \\\n   (RTL_FLAG_CHECK1(\"MEM_NOTRAP_P\", (RTX), MEM)->call)\n@@ -1404,8 +1392,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Copy the attributes that apply to memory locations from RHS to LHS.  */\n #define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\t\\\n   (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\t\\\n-   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\t\\\n-   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\t\\\n    MEM_NOTRAP_P (LHS) = MEM_NOTRAP_P (RHS),\t\t\t\\\n    MEM_READONLY_P (LHS) = MEM_READONLY_P (RHS),\t\t\t\\\n    MEM_KEEP_ALIAS_SET_P (LHS) = MEM_KEEP_ALIAS_SET_P (RHS),\t\\"}, {"sha": "2fdb6743165185a690bbdf550ce0792111a7d49a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -1,3 +1,7 @@\n+2012-01-24  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.dg/memcpy-4.c: Don't expect /s on MEMs.\n+\n 2012-01-24  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51812"}, {"sha": "cff477a981e3f1893e508f477fa68310d3aa1f78", "filename": "gcc/testsuite/gcc.dg/memcpy-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5535633407a3c84b4f19b9c2f88be92cb51ba8e3/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-4.c?ref=5535633407a3c84b4f19b9c2f88be92cb51ba8e3", "patch": "@@ -10,5 +10,5 @@ f1 (char *p)\n   __builtin_memcpy (p, \"12345\", 5);\n }\n \n-/* { dg-final { scan-rtl-dump \"mem/s/u.*mem/s/u\" \"expand\" { target mips*-*-* } } } */\n+/* { dg-final { scan-rtl-dump \"mem/u.*mem/u\" \"expand\" { target mips*-*-* } } } */\n /* { dg-final { cleanup-rtl-dump \"expand\" } } */"}]}