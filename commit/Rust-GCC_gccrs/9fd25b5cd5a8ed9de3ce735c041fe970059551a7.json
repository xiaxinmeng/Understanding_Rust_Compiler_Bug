{"sha": "9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZkMjViNWNkNWE4ZWQ5ZGUzY2U3MzVjMDQxZmU5NzAwNTk1NTFhNw==", "commit": {"author": {"name": "Christopher D. Rickett", "email": "crickett@lanl.gov", "date": "2007-10-15T19:58:55Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-10-15T19:58:55Z"}, "message": "re PR fortran/32600 ([ISO Bind C] C_F_POINTER w/o SHAPE should not be a library function)\n\n2007-10-15 Christopher D. Rickett <crickett@lanl.gov>\n\n        PR fortran/32600\n        * trans-expr.c (gfc_conv_function_call): Generate code to inline\n        c_associated.\n        * symbol.c (get_iso_c_sym): Preserve from_intmod and\n        * intmod_sym_id\n        attributes in the resolved symbol.\n        * resolve.c (gfc_iso_c_sub_interface): Remove dead code.\n\n\n2007-10-15 Christopher D. Rickett <crickett@lanl.gov>\n\n        PR fortran/32600\n        * libgfortran/intrinsics/iso_c_binding.c: Remove c_associated_1\n        and c_associated_2.\n        * libgfortran/intrinsics/iso_c_binding.h: Ditto.\n        * libgfortran/gfortran.map: Ditto.\n\nFrom-SVN: r129367", "tree": {"sha": "36b79ca0ae8909cbb87feeea48f42fdad9417077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36b79ca0ae8909cbb87feeea48f42fdad9417077"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/comments", "author": null, "committer": null, "parents": [{"sha": "93f238cea15b50c7e069c8b909102bb5b5202e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f238cea15b50c7e069c8b909102bb5b5202e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f238cea15b50c7e069c8b909102bb5b5202e6f"}], "stats": {"total": 134, "additions": 65, "deletions": 69}, "files": [{"sha": "d9885ae7dd0be5cb87acadeb95f251245b674d92", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -1,3 +1,12 @@\n+2007-10-15 Christopher D. Rickett <crickett@lanl.gov>\n+\n+\tPR fortran/32600\n+\t* trans-expr.c (gfc_conv_function_call): Generate code to inline\n+\tc_associated.\n+\t* symbol.c (get_iso_c_sym): Preserve from_intmod and intmod_sym_id\n+\tattributes in the resolved symbol.\n+\t* resolve.c (gfc_iso_c_sub_interface): Remove dead code.\n+\n 2007-10-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/33055"}, {"sha": "65e479fe65fe53249fa7391a0ac5e181dd913df4", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -2479,31 +2479,6 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n \t  new_sym->declared_at = sym->declared_at;\n \t}\n     }\n-  else if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n-    {\n-      /* TODO: Figure out if this is even reachable; this part of the\n-         conditional may not be necessary.  */\n-      int num_args = 0;\n-      if (c->ext.actual->next == NULL)\n-\t{\n-\t  /* The user did not give two args, so resolve to the version\n-\t     of c_associated expecting one arg.\t */\n-\t  num_args = 1;\n-\t  /* get rid of the second arg */\n-\t  /* TODO!! Should free up the memory here!  */\n-\t  sym->formal->next = NULL;\n-\t}\n-      else\n-\t{\n-\t  num_args = 2;\n-\t}\n-\n-      new_sym = sym;\n-      sprintf (name, \"%s_%d\", sym->name, num_args);\n-      sprintf (binding_label, \"%s_%d\", sym->binding_label, num_args);\n-      sym->name = gfc_get_string (name);\n-      strcpy (sym->binding_label, binding_label);\n-    }\n   else\n     {\n       /* no differences for c_loc or c_funloc */"}, {"sha": "ae97a656759435b5e7af886af9c6d8c06910fbb8", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -4029,6 +4029,8 @@ get_iso_c_sym (gfc_symbol *old_sym, char *new_name,\n   new_symtree->n.sym->attr = old_sym->attr;\n   new_symtree->n.sym->ts = old_sym->ts;\n   new_symtree->n.sym->module = gfc_get_string (old_sym->module);\n+  new_symtree->n.sym->from_intmod = old_sym->from_intmod;\n+  new_symtree->n.sym->intmod_sym_id = old_sym->intmod_sym_id;\n   /* Build the formal arg list.  */\n   build_formal_args (new_symtree->n.sym, old_sym, add_optional_arg);\n "}, {"sha": "a1f1ee957db08dc84a7a047e09eb75481f49f83f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -2108,6 +2108,52 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  arg->expr->ts.kind = sym->ts.derived->ts.kind;\n \t  gfc_conv_expr_reference (se, arg->expr);\n       \n+\t  return 0;\n+\t}\n+      else if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n+        {\n+\t  gfc_se arg1se;\n+\t  gfc_se arg2se;\n+\n+\t  /* Build the addr_expr for the first argument.  The argument is\n+\t     already an *address* so we don't need to set want_pointer in\n+\t     the gfc_se.  */\n+\t  gfc_init_se (&arg1se, NULL);\n+\t  gfc_conv_expr (&arg1se, arg->expr);\n+\t  gfc_add_block_to_block (&se->pre, &arg1se.pre);\n+\t  gfc_add_block_to_block (&se->post, &arg1se.post);\n+\n+\t  /* See if we were given two arguments.  */\n+\t  if (arg->next == NULL)\n+\t    /* Only given one arg so generate a null and do a\n+\t       not-equal comparison against the first arg.  */\n+\t    se->expr = build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n+\t\t\t       fold_convert (TREE_TYPE (arg1se.expr),\n+\t\t\t\t\t     null_pointer_node));\n+\t  else\n+\t    {\n+\t      tree eq_expr;\n+\t      tree not_null_expr;\n+\t      \n+\t      /* Given two arguments so build the arg2se from second arg.  */\n+\t      gfc_init_se (&arg2se, NULL);\n+\t      gfc_conv_expr (&arg2se, arg->next->expr);\n+\t      gfc_add_block_to_block (&se->pre, &arg2se.pre);\n+\t      gfc_add_block_to_block (&se->post, &arg2se.post);\n+\n+\t      /* Generate test to compare that the two args are equal.  */\n+\t      eq_expr = build2 (EQ_EXPR, boolean_type_node, arg1se.expr,\n+\t\t\t\targ2se.expr);\n+\t      /* Generate test to ensure that the first arg is not null.  */\n+\t      not_null_expr = build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n+\t\t\t\t      null_pointer_node);\n+\n+\t      /* Finally, the generated test must check that both arg1 is not\n+\t\t NULL and that it is equal to the second arg.  */\n+\t      se->expr = build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t not_null_expr, eq_expr);\n+\t    }\n+\n \t  return 0;\n \t}\n     }"}, {"sha": "d0cecb0167b0a0c2a56db859e89c30ce0d16e2ce", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -1,3 +1,11 @@\n+2007-10-15 Christopher D. Rickett <crickett@lanl.gov>\n+\n+\tPR fortran/32600\n+\t* libgfortran/intrinsics/iso_c_binding.c: Remove c_associated_1\n+\tand c_associated_2.\n+\t* libgfortran/intrinsics/iso_c_binding.h: Ditto.\n+\t* libgfortran/gfortran.map: Ditto.\n+\n 2007-10-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/33055"}, {"sha": "b9f4aa93b73f7b56bb253cb24591187648920eeb", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -1003,8 +1003,6 @@ GFORTRAN_1.0 {\n     _gfortran_unpack0_char;\n     _gfortran_unpack1;\n     _gfortran_unpack1_char;\n-    __iso_c_binding_c_associated_1;\n-    __iso_c_binding_c_associated_2;\n     __iso_c_binding_c_f_pointer;\n     __iso_c_binding_c_f_pointer_d0;\n     __iso_c_binding_c_f_pointer_i1;"}, {"sha": "2a1e994d4d9243e8f4638796de98d4508ae253f0", "filename": "libgfortran/intrinsics/iso_c_binding.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.c?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -193,42 +193,3 @@ ISO_C_BINDING_PREFIX (c_f_procpointer) (void *c_ptr_in,\n }\n \n \n-/* Test if the given c_ptr is associated or not.  This function is\n-   called if the user only supplied one c_ptr parameter to the\n-   c_associated function.  The second argument is optional, and the\n-   Fortran compiler will resolve the function to this version if only\n-   one arg was given.  Associated here simply means whether or not the\n-   c_ptr is NULL or not.  */\n-\n-GFC_LOGICAL_4\n-ISO_C_BINDING_PREFIX (c_associated_1) (void *c_ptr_in_1)\n-{\n-  if (c_ptr_in_1 != NULL)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-\n-/* Test if the two c_ptr arguments are associated with one another.\n-   This version of the c_associated function is called if the user\n-   supplied two c_ptr args in the Fortran source.  According to the\n-   draft standard (J3/04-007), if c_ptr_in_1 is NULL, the two pointers\n-   are NOT associated.  If c_ptr_in_1 is non-NULL and it is not equal\n-   to c_ptr_in_2, then either c_ptr_in_2 is NULL or is associated with\n-   another address; either way, the two pointers are not associated\n-   with each other then.  */\n-\n-GFC_LOGICAL_4\n-ISO_C_BINDING_PREFIX (c_associated_2) (void *c_ptr_in_1, void *c_ptr_in_2)\n-{\n-  /* Since we have the second arg, if it doesn't equal the first,\n-     return false; true otherwise.  However, if the first one is null,\n-     then return false; otherwise compare the two ptrs for equality.  */\n-  if (c_ptr_in_1 == NULL)\n-    return 0;\n-  else if (c_ptr_in_1 != c_ptr_in_2)\n-    return 0;\n-  else\n-    return 1;\n-}"}, {"sha": "4679c2aba02f4be2d771c2415fc504b54d3644ab", "filename": "libgfortran/intrinsics/iso_c_binding.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2Fintrinsics%2Fiso_c_binding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd25b5cd5a8ed9de3ce735c041fe970059551a7/libgfortran%2Fintrinsics%2Fiso_c_binding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.h?ref=9fd25b5cd5a8ed9de3ce735c041fe970059551a7", "patch": "@@ -56,9 +56,6 @@ void ISO_C_BINDING_PREFIX(c_f_pointer)(void *, gfc_array_void *,\n    implemented.  */\n void ISO_C_BINDING_PREFIX(c_f_procpointer) (void *, gfc_array_void *);\n \n-GFC_LOGICAL_4 ISO_C_BINDING_PREFIX(c_associated_1) (void *);\n-GFC_LOGICAL_4 ISO_C_BINDING_PREFIX(c_associated_2) (void *, void *);\n-\n void ISO_C_BINDING_PREFIX(c_f_pointer_u0) (void *, gfc_array_void *,\n \t\t\t\t\t   const array_t *);\n void ISO_C_BINDING_PREFIX(c_f_pointer_d0) (void *, gfc_array_void *,"}]}