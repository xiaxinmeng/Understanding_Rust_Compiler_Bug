{"sha": "a9e64c639ef604bfc2d734b3973dfc0953875877", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTllNjRjNjM5ZWY2MDRiZmMyZDczNGIzOTczZGZjMDk1Mzg3NTg3Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-11-16T21:25:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-11-16T21:25:16Z"}, "message": "re PR middle-end/26306 (ICE on volatile array with non-constant bounds)\n\n\tPR middle-end/26306\n\t* gimplify.c (gimplify_expr): Only force a load for references to\n\tnon-BLKmode volatile values.\n\t* doc/implement-c.texi (Qualifiers implementation): Document the\n\tinterpretation of what a volatile access is.\n\t* doc/extend.texi (C++ Extensions): Rework same documentation.\n\nFrom-SVN: r118900", "tree": {"sha": "3474f1e6d8e5a0484dd9285fb4f30365e230b1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3474f1e6d8e5a0484dd9285fb4f30365e230b1df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9e64c639ef604bfc2d734b3973dfc0953875877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e64c639ef604bfc2d734b3973dfc0953875877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9e64c639ef604bfc2d734b3973dfc0953875877", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e64c639ef604bfc2d734b3973dfc0953875877/comments", "author": null, "committer": null, "parents": [{"sha": "c8cf9f0f27b4bc784419f60976390c6e4111ccae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8cf9f0f27b4bc784419f60976390c6e4111ccae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8cf9f0f27b4bc784419f60976390c6e4111ccae"}], "stats": {"total": 158, "additions": 108, "deletions": 50}, "files": [{"sha": "c0cb879fa9981ac739a569d631653254f657aaea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9e64c639ef604bfc2d734b3973dfc0953875877", "patch": "@@ -1,3 +1,12 @@\n+2006-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/26306\n+\t* gimplify.c (gimplify_expr): Only force a load for references to\n+\tnon-BLKmode volatile values.\n+\t* doc/implement-c.texi (Qualifiers implementation): Document the\n+\tinterpretation of what a volatile access is.\n+\t* doc/extend.texi (C++ Extensions): Rework same documentation.\n+\n 2006-11-16  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/spe.md (frob_di_df_2): Handle non-offsettable"}, {"sha": "3576b71cb7494546d7ff6c842944348ca2576209", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a9e64c639ef604bfc2d734b3973dfc0953875877", "patch": "@@ -10441,11 +10441,10 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n \n Both the C and C++ standard have the concept of volatile objects.  These\n are normally accessed by pointers and used for accessing hardware.  The\n-standards encourage compilers to refrain from optimizations\n-concerning accesses to volatile objects that it might perform on\n-non-volatile objects.  The C standard leaves it implementation defined\n-as to what constitutes a volatile access.  The C++ standard omits to\n-specify this, except to say that C++ should behave in a similar manner\n+standards encourage compilers to refrain from optimizations concerning\n+accesses to volatile objects.  The C standard leaves it implementation\n+defined  as to what constitutes a volatile access.  The C++ standard omits\n+to specify this, except to say that C++ should behave in a similar manner\n to C with respect to volatiles, where possible.  The minimum either\n standard specifies is that at a sequence point all previous accesses to\n volatile objects have stabilized and no subsequent accesses have\n@@ -10455,55 +10454,28 @@ for accesses across a sequence point.  The use of volatiles does not\n allow you to violate the restriction on updating objects multiple times\n within a sequence point.\n \n-In most expressions, it is intuitively obvious what is a read and what is\n-a write.  For instance\n+@xref{Qualifiers implementation, , Volatile qualifier and the C compiler}.\n \n-@smallexample\n-volatile int *dst = @var{somevalue};\n-volatile int *src = @var{someothervalue};\n-*dst = *src;\n-@end smallexample\n-\n-@noindent\n-will cause a read of the volatile object pointed to by @var{src} and stores the\n-value into the volatile object pointed to by @var{dst}.  There is no\n-guarantee that these reads and writes are atomic, especially for objects\n-larger than @code{int}.\n-\n-Less obvious expressions are where something which looks like an access\n-is used in a void context.  An example would be,\n+The behavior differs slightly between C and C++ in the non-obvious cases:\n \n @smallexample\n volatile int *src = @var{somevalue};\n *src;\n @end smallexample\n \n-With C, such expressions are rvalues, and as rvalues cause a read of\n-the object, GCC interprets this as a read of the volatile being pointed\n-to.  The C++ standard specifies that such expressions do not undergo\n-lvalue to rvalue conversion, and that the type of the dereferenced\n+With C, such expressions are rvalues, and GCC interprets this either as a\n+read of the volatile object being pointed to or only as request to evaluate\n+the side-effects.  The C++ standard specifies that such expressions do not\n+undergo lvalue to rvalue conversion, and that the type of the dereferenced\n object may be incomplete.  The C++ standard does not specify explicitly\n-that it is this lvalue to rvalue conversion which is responsible for\n+that it is this lvalue to rvalue conversion which may be responsible for\n causing an access.  However, there is reason to believe that it is,\n because otherwise certain simple expressions become undefined.  However,\n because it would surprise most programmers, G++ treats dereferencing a\n-pointer to volatile object of complete type in a void context as a read\n-of the object.  When the object has incomplete type, G++ issues a\n-warning.\n-\n-@smallexample\n-struct S;\n-struct T @{int m;@};\n-volatile S *ptr1 = @var{somevalue};\n-volatile T *ptr2 = @var{somevalue};\n-*ptr1;\n-*ptr2;\n-@end smallexample\n-\n-In this example, a warning is issued for @code{*ptr1}, and @code{*ptr2}\n-causes a read of the object pointed to.  If you wish to force an error on\n-the first case, you must force a conversion to rvalue with, for instance\n-a static cast, @code{static_cast<S>(*ptr1)}.\n+pointer to volatile object of complete type when the value is unused as\n+GCC would do for an equivalent type in C.  When the object has incomplete\n+type, G++ issues a warning; if you wish to force an error, you must\n+force a conversion to rvalue with, for instance, a static cast.\n \n When using a reference to volatile, G++ does not treat equivalent\n expressions as accesses to volatiles, but instead issues a warning that"}, {"sha": "dc996104ac6fec2bcdd973c8ae5dc74545b9b4d5", "filename": "gcc/doc/implement-c.texi", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Fdoc%2Fimplement-c.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Fdoc%2Fimplement-c.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fimplement-c.texi?ref=a9e64c639ef604bfc2d734b3973dfc0953875877", "patch": "@@ -503,7 +503,42 @@ determined by the ABI@.\n @cite{What constitutes an access to an object that has volatile-qualified\n type (C90 6.5.3, C99 6.7.3).}\n \n-@xref{Volatiles, , When is a Volatile Object Accessed?}.\n+Such an object is normally accessed by pointers and used for accessing\n+hardware.  In most expressions, it is intuitively obvious what is a read\n+and what is a write.  For example\n+\n+@smallexample\n+volatile int *dst = @var{somevalue};\n+volatile int *src = @var{someothervalue};\n+*dst = *src;\n+@end smallexample\n+\n+@noindent\n+will cause a read of the volatile object pointed to by @var{src} and store the\n+value into the volatile object pointed to by @var{dst}.  There is no\n+guarantee that these reads and writes are atomic, especially for objects\n+larger than @code{int}.\n+\n+However, if the volatile storage is not being modified, and the value of\n+the volatile storage is not used, then the situation is less obvious.\n+For example\n+\n+@smallexample\n+volatile int *src = @var{somevalue};\n+*src;\n+@end smallexample\n+\n+According to the C standard, such an expression is an rvalue whose type\n+is the unqualified version of its original type, i.e. @code{int}.  Whether\n+GCC interprets this as a read of the volatile object being pointed to or\n+only as a request to evaluate the expression for its side-effects depends\n+on this type.\n+\n+If it is a scalar type, or on most targets an aggregate type whose only\n+member object is of a scalar type, or a union type whose member objects\n+are of scalar types, the expression is interpreted by GCC as a read of\n+the volatile object; in the other cases, the expression is only evaluated\n+for its side-effects.\n \n @end itemize\n "}, {"sha": "81a18a0ae58eddd7b33b151e64a5176cbf9c5c6b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a9e64c639ef604bfc2d734b3973dfc0953875877", "patch": "@@ -5854,7 +5854,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t\t\t     gimple_test_f, fallback);\n \t      break;\n \n-\t    case ARRAY_REF: case ARRAY_RANGE_REF:\n+\t    case ARRAY_REF:\n+\t    case ARRAY_RANGE_REF:\n \t      gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n \t\t\t     gimple_test_f, fallback);\n \t      gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n@@ -5863,16 +5864,17 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n \t    default:\n \t       /* Anything else with side-effects must be converted to\n-\t       \t  a valid statement before we get here.  */\n+\t\t  a valid statement before we get here.  */\n \t      gcc_unreachable ();\n \t    }\n \n \t  *expr_p = NULL;\n \t}\n-      else if (COMPLETE_TYPE_P (TREE_TYPE (*expr_p)))\n+      else if (COMPLETE_TYPE_P (TREE_TYPE (*expr_p))\n+\t       && TYPE_MODE (TREE_TYPE (*expr_p)) != BLKmode)\n \t{\n-\t  /* Historically, the compiler has treated a bare\n-\t     reference to a volatile lvalue as forcing a load.  */\n+\t  /* Historically, the compiler has treated a bare reference\n+\t     to a non-BLKmode volatile lvalue as forcing a load.  */\n \t  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (*expr_p));\n \t  /* Normally, we do not want to create a temporary for a\n \t     TREE_ADDRESSABLE type because such a type should not be\n@@ -5887,7 +5889,10 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t}\n       else\n \t/* We can't do anything useful with a volatile reference to\n-\t   incomplete type, so just throw it away.  */\n+\t   an incomplete type, so just throw it away.  Likewise for\n+\t   a BLKmode type, since any implicit inner load should\n+\t   already have been turned into an explicit one by the\n+\t   gimplification process.  */\n \t*expr_p = NULL;\n     }\n "}, {"sha": "28da16b0a0a39f6581d53d828890ac64cc3e98c0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9e64c639ef604bfc2d734b3973dfc0953875877", "patch": "@@ -1,3 +1,7 @@\n+2006-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/volatile_aggregate.adb: New test.\n+\n 2006-11-16  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/29391"}, {"sha": "e30e28b09f6cb37d36d4fd84d074add2458de2d5", "filename": "gcc/testsuite/gnat.dg/volatile_aggregate.adb", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile_aggregate.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e64c639ef604bfc2d734b3973dfc0953875877/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile_aggregate.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile_aggregate.adb?ref=a9e64c639ef604bfc2d734b3973dfc0953875877", "patch": "@@ -0,0 +1,33 @@\n+-- { dg-do compile }\n+\n+with System;\n+\n+procedure Volatile_Aggregate is \n+\n+  function GetArrayUpperBound return Integer is \n+  begin\n+    return 2;\n+  end GetArrayUpperBound; \n+\n+  some_value : Integer := GetArrayUpperBound;\n+\n+  type Gp_Element_Type is record\n+    Element : Integer;\n+  end record;\n+\n+  type some_type is array (1 .. some_value) of Gp_Element_Type;\n+\n+  type Aligned_Some_Type is record\n+    Value : aliased some_type;\n+  end record;          \n+\n+  for Aligned_Some_Type'Alignment use 8;          \n+\n+  an_aligned_type : aligned_Some_Type;   \n+  my_address : system.address; \n+\n+  pragma Volatile (an_aligned_type);\n+\n+begin\n+  my_address := an_aligned_type.value(1)'address; \n+end;      "}]}