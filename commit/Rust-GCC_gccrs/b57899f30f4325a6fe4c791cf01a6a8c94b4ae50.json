{"sha": "b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "node_id": "C_kwDOANBUbNoAKGI1Nzg5OWYzMGY0MzI1YTZmZTRjNzkxY2YwMWE2YThjOTRiNGFlNTA", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T11:11:58Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T18:14:50Z"}, "message": "libstdc++: Consolidate duplicate metaprogramming utilities\n\nCurrently std::variant uses __index_of<T, Types...> to find the first\noccurence of a type in a pack, and __exactly_once<T, Types...> to check\nthat there is no other occurrence.\n\nWe can reuse the __find_uniq_type_in_pack<T, Types...>() function for\nboth tasks, and remove the recursive templates used to implement\n__index_of and __exactly_once.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/utility.h (__find_uniq_type_in_pack): Move\n\tdefinition to here, ...\n\t* include/std/tuple (__find_uniq_type_in_pack): ... from here.\n\t* include/std/variant (__detail__variant::__index_of): Remove.\n\t(__detail::__variant::__exactly_once): Define using\n\t__find_uniq_type_in_pack instead of __index_of.\n\t(get<T>, get_if<T>, variant::__index_of): Likewise.", "tree": {"sha": "06adad1edae89f6727b2dec5fcaaac7d05ab80ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06adad1edae89f6727b2dec5fcaaac7d05ab80ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09aab7e699dcbd79fd64959cf259567bdca94022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09aab7e699dcbd79fd64959cf259567bdca94022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09aab7e699dcbd79fd64959cf259567bdca94022"}], "stats": {"total": 113, "additions": 47, "deletions": 66}, "files": [{"sha": "ec5ed04990b826cd4cc13a33ea73f804a0d65e3d", "filename": "libstdc++-v3/include/bits/utility.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/libstdc%2B%2B-v3%2Finclude%2Fbits%2Futility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/libstdc%2B%2B-v3%2Finclude%2Fbits%2Futility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Futility.h?ref=b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "patch": "@@ -102,6 +102,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n #if __cplusplus >= 201402L\n+\n+  // Return the index of _Tp in _Types, if it occurs exactly once.\n+  // Otherwise, return sizeof...(_Types).\n+  template<typename _Tp, typename... _Types>\n+    constexpr size_t\n+    __find_uniq_type_in_pack()\n+    {\n+      constexpr size_t __sz = sizeof...(_Types);\n+      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };\n+      size_t __n = __sz;\n+      for (size_t __i = 0; __i < __sz; ++__i)\n+\t{\n+\t  if (__found[__i])\n+\t    {\n+\t      if (__n < __sz) // more than one _Tp found\n+\t\treturn __sz;\n+\t      __n = __i;\n+\t    }\n+\t}\n+      return __n;\n+    }\n+\n // The standard says this macro and alias template should be in <tuple> but we\n // we define them here, to be available in <array>, <utility> and <ranges> too.\n // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "46173935b648b03301bd7fe3077b611516beee2a", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "patch": "@@ -1419,28 +1419,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #define __cpp_lib_tuples_by_type 201304L\n \n-  // Return the index of _Tp in _Types, if it occurs exactly once.\n-  // Otherwise, return sizeof...(_Types).\n-  // TODO reuse this for __detail::__variant::__exactly_once.\n-  template<typename _Tp, typename... _Types>\n-    constexpr size_t\n-    __find_uniq_type_in_pack()\n-    {\n-      constexpr size_t __sz = sizeof...(_Types);\n-      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };\n-      size_t __n = __sz;\n-      for (size_t __i = 0; __i < __sz; ++__i)\n-\t{\n-\t  if (__found[__i])\n-\t    {\n-\t      if (__n < __sz) // more than one _Tp found\n-\t\treturn __sz;\n-\t      __n = __i;\n-\t    }\n-\t}\n-      return __n;\n-    }\n-\n   /// Return a reference to the unique element of type _Tp of a tuple.\n   template <typename _Tp, typename... _Types>\n     constexpr _Tp&"}, {"sha": "ab4503bc7c16079e26f71ed67e72507b77bead4e", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 25, "deletions": 44, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57899f30f4325a6fe4c791cf01a6a8c94b4ae50/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=b57899f30f4325a6fe4c791cf01a6a8c94b4ae50", "patch": "@@ -161,19 +161,6 @@ namespace __detail\n {\n namespace __variant\n {\n-  // Returns the first appearance of _Tp in _Types.\n-  // Returns sizeof...(_Types) if _Tp is not in _Types.\n-  template<typename _Tp, typename... _Types>\n-    struct __index_of : std::integral_constant<size_t, 0> {};\n-\n-  template<typename _Tp, typename... _Types>\n-    inline constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;\n-\n-  template<typename _Tp, typename _First, typename... _Rest>\n-    struct __index_of<_Tp, _First, _Rest...> :\n-      std::integral_constant<size_t, is_same_v<_Tp, _First>\n-\t? 0 : __index_of_v<_Tp, _Rest...> + 1> {};\n-\n   // used for raw visitation\n   struct __variant_cookie {};\n   // used for raw visitation with indices passed in\n@@ -766,21 +753,9 @@ namespace __variant\n       _Variant_base& operator=(_Variant_base&&) = default;\n     };\n \n-  // How many times does _Tp appear in _Types?\n-  template<typename _Tp, typename... _Types>\n-    inline constexpr size_t __count = 0;\n-\n-  template<typename _Tp, typename _Up, typename... _Types>\n-    inline constexpr size_t __count<_Tp, _Up, _Types...>\n-      = __count<_Tp, _Types...>;\n-\n-  template<typename _Tp, typename... _Types>\n-    inline constexpr size_t __count<_Tp, _Tp, _Types...>\n-      = 1 + __count<_Tp, _Types...>;\n-\n-  // TODO: Reuse this in <tuple> ?\n   template<typename _Tp, typename... _Types>\n-    inline constexpr bool __exactly_once = __count<_Tp, _Types...> == 1;\n+    inline constexpr bool __exactly_once\n+      = std::__find_uniq_type_in_pack<_Tp, _Types...>() < sizeof...(_Types);\n \n   // Helper used to check for valid conversions that don't involve narrowing.\n   template<typename _Ti> struct _Arr { _Ti _M_x[1]; };\n@@ -1139,45 +1114,51 @@ namespace __variant\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n-      return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;\n+      return __v.index() == std::__find_uniq_type_in_pack<_Tp, _Types...>();\n     }\n \n   template<typename _Tp, typename... _Types>\n-    constexpr _Tp& get(variant<_Types...>& __v)\n+    constexpr _Tp&\n+    get(variant<_Types...>& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n       static_assert(!is_void_v<_Tp>, \"_Tp must not be void\");\n-      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);\n+      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n+      return std::get<__n>(__v);\n     }\n \n   template<typename _Tp, typename... _Types>\n-    constexpr _Tp&& get(variant<_Types...>&& __v)\n+    constexpr _Tp&&\n+    get(variant<_Types...>&& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n       static_assert(!is_void_v<_Tp>, \"_Tp must not be void\");\n-      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(\n-\tstd::move(__v));\n+      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n+      return std::get<__n>(std::move(__v));\n     }\n \n   template<typename _Tp, typename... _Types>\n-    constexpr const _Tp& get(const variant<_Types...>& __v)\n+    constexpr const _Tp&\n+    get(const variant<_Types...>& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n       static_assert(!is_void_v<_Tp>, \"_Tp must not be void\");\n-      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);\n+      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n+      return std::get<__n>(__v);\n     }\n \n   template<typename _Tp, typename... _Types>\n-    constexpr const _Tp&& get(const variant<_Types...>&& __v)\n+    constexpr const _Tp&&\n+    get(const variant<_Types...>&& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n       static_assert(!is_void_v<_Tp>, \"_Tp must not be void\");\n-      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(\n-\tstd::move(__v));\n+      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n+      return std::get<__n>(std::move(__v));\n     }\n \n   template<size_t _Np, typename... _Types>\n@@ -1214,8 +1195,8 @@ namespace __variant\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n       static_assert(!is_void_v<_Tp>, \"_Tp must not be void\");\n-      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(\n-\t  __ptr);\n+      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n+      return std::get_if<__n>(__ptr);\n     }\n \n   template<typename _Tp, typename... _Types>\n@@ -1225,8 +1206,8 @@ namespace __variant\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T must occur exactly once in alternatives\");\n       static_assert(!is_void_v<_Tp>, \"_Tp must not be void\");\n-      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(\n-\t  __ptr);\n+      constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n+      return std::get_if<__n>(__ptr);\n     }\n \n   struct monostate { };\n@@ -1402,8 +1383,8 @@ namespace __variant\n \tusing __accepted_type = __to_type<__accepted_index<_Tp>>;\n \n       template<typename _Tp>\n-\tstatic constexpr size_t __index_of =\n-\t  __detail::__variant::__index_of_v<_Tp, _Types...>;\n+\tstatic constexpr size_t __index_of\n+\t  = std::__find_uniq_type_in_pack<_Tp, _Types...>();\n \n       using _Traits = __detail::__variant::_Traits<_Types...>;\n "}]}