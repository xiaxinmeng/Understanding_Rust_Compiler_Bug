{"sha": "c3e8c6b83815b90a3c5e578909205757f2ab170a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNlOGM2YjgzODE1YjkwYTNjNWU1Nzg5MDkyMDU3NTdmMmFiMTcwYQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-05-31T19:31:12Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-05-31T19:31:12Z"}, "message": "* trans-types.c: Fix spelling & layout in comments.\n\nFrom-SVN: r82492", "tree": {"sha": "cd286b45e2e839b61521592028c9b7fb2aa761f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd286b45e2e839b61521592028c9b7fb2aa761f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3e8c6b83815b90a3c5e578909205757f2ab170a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e8c6b83815b90a3c5e578909205757f2ab170a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e8c6b83815b90a3c5e578909205757f2ab170a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e8c6b83815b90a3c5e578909205757f2ab170a/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d98c720ee469390f8114878cfd4f46650cec6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d98c720ee469390f8114878cfd4f46650cec6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09d98c720ee469390f8114878cfd4f46650cec6e"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "2f52f2ea0503f65449b96c6b6d2d84b05b60a028", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e8c6b83815b90a3c5e578909205757f2ab170a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e8c6b83815b90a3c5e578909205757f2ab170a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c3e8c6b83815b90a3c5e578909205757f2ab170a", "patch": "@@ -1,3 +1,7 @@\n+2004-05-31  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* trans-types.c: Fix spelling & layout in comments.\n+\n 2004-05-30  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/14067"}, {"sha": "9a259b6447e47606ba5c65a226151a5d62507d33", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e8c6b83815b90a3c5e578909205757f2ab170a/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e8c6b83815b90a3c5e578909205757f2ab170a/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c3e8c6b83815b90a3c5e578909205757f2ab170a", "patch": "@@ -63,6 +63,7 @@ static GTY(()) tree gfc_max_array_element_size;\n    equivalent C type, at least for now.  We also give\n    names to the types here, and we push them in the\n    global binding level context.*/\n+\n void\n gfc_init_types (void)\n {\n@@ -180,6 +181,7 @@ gfc_init_types (void)\n }\n \n /* Get a type node for an integer kind */\n+\n tree\n gfc_get_int_type (int kind)\n {\n@@ -203,6 +205,7 @@ gfc_get_int_type (int kind)\n }\n \n /* Get a type node for a real kind */\n+\n tree\n gfc_get_real_type (int kind)\n {\n@@ -222,6 +225,7 @@ gfc_get_real_type (int kind)\n }\n \n /* Get a type node for a complex kind */\n+\n tree\n gfc_get_complex_type (int kind)\n {\n@@ -241,6 +245,7 @@ gfc_get_complex_type (int kind)\n }\n \n /* Get a type node for a logical kind */\n+\n tree\n gfc_get_logical_type (int kind)\n {\n@@ -264,6 +269,7 @@ gfc_get_logical_type (int kind)\n }\n \f\n /* Get a type node for a character kind.  */\n+\n tree\n gfc_get_character_type (int kind, gfc_charlen * cl)\n {\n@@ -292,6 +298,7 @@ gfc_get_character_type (int kind, gfc_charlen * cl)\n }\n \f\n /* Covert a basic type.  This will be an array for character types.  */\n+\n tree\n gfc_typenode_for_spec (gfc_typespec * spec)\n {\n@@ -335,6 +342,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n }\n \f\n /* Build an INT_CST for constant expressions, otherwise return NULL_TREE.  */\n+\n static tree\n gfc_conv_array_bound (gfc_expr * expr)\n {\n@@ -374,7 +382,7 @@ gfc_get_element_type (tree type)\n }\n \f\n /* Build an array. This function is called from gfc_sym_type().\n-   Actualy returns array descriptor type.\n+   Actually returns array descriptor type.\n \n    Format of array descriptors is as follows:\n \n@@ -397,7 +405,7 @@ gfc_get_element_type (tree type)\n    the descriptor directly. Any changes to the array descriptor type will\n    require changes in gfc_conv_descriptor_* and gfc_build_array_initializer.\n \n-   This is represented internaly as a RECORD_TYPE. The index nodes are\n+   This is represented internally as a RECORD_TYPE. The index nodes are\n    gfc_array_index_type and the data node is a pointer to the data. See below\n    for the handling of character types.\n \n@@ -406,9 +414,9 @@ gfc_get_element_type (tree type)\n     type = (dtype & GFC_DTYPE_TYPE_MASK) >> GFC_DTYPE_TYPE_SHIFT // 3 bits\n     size = dtype >> GFC_DTYPE_SIZE_SHIFT\n \n-   I originaly used nested ARRAY_TYPE nodes to represent arrays, but this\n+   I originally used nested ARRAY_TYPE nodes to represent arrays, but this\n    generated poor code for assumed/deferred size arrays.  These require\n-   use of PLACEHOLDER_EXPR/WITH_RECORD_EXPR, which isn't part of GIMPLE\n+   use of PLACEHOLDER_EXPR/WITH_RECORD_EXPR, which isn't part of the GENERIC\n    grammar.  Also, there is no way to explicitly set the array stride, so\n    all data must be packed(1).  I've tried to mark all the functions which\n    would require modification with a GCC ARRAYS comment.\n@@ -419,7 +427,7 @@ gfc_get_element_type (tree type)\n \n    An element is accessed by\n    data[offset + index0*stride0 + index1*stride1 + index2*stride2]\n-   This gives good performance as it computation does not involve the\n+   This gives good performance as the computation does not involve the\n    bounds of the array.  For packed arrays, this is optimized further by\n    substituting the known strides.\n \n@@ -495,6 +503,7 @@ gfc_build_array_type (tree type, gfc_array_spec * as)\n }\n \f\n /* Returns the struct descriptor_dimension type.  */\n+\n static tree\n gfc_get_desc_dim_type (void)\n {\n@@ -893,6 +902,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n }\n \f\n /* Build a pointer type. This function is called from gfc_sym_type().  */\n+\n static tree\n gfc_build_pointer_type (gfc_symbol * sym, tree type)\n {\n@@ -906,8 +916,8 @@ gfc_build_pointer_type (gfc_symbol * sym, tree type)\n /* Return the type for a symbol.  Special handling is required for character\n    types to get the correct level of indirection.\n    For functions return the return type.\n-   For subroutines return void_type_node.\n- */\n+   For subroutines return void_type_node.  */\n+\n tree\n gfc_sym_type (gfc_symbol * sym)\n {\n@@ -971,6 +981,7 @@ gfc_sym_type (gfc_symbol * sym)\n }\n \f\n /* Layout and output debug info for a record type.  */\n+\n void\n gfc_finish_type (tree type)\n {\n@@ -988,6 +999,7 @@ gfc_finish_type (tree type)\n    to the fieldlist pointed to by FIELDLIST.\n \n    Returns a pointer to the new field.  */\n+\n tree\n gfc_add_field_to_struct (tree *fieldlist, tree context,\n \t\t\t tree name, tree type)\n@@ -1008,6 +1020,7 @@ gfc_add_field_to_struct (tree *fieldlist, tree context,\n \n \n /* Build a tree node for a derived type.  */\n+\n static tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n@@ -1125,6 +1138,7 @@ gfc_return_by_reference (gfc_symbol * sym)\n   return 0;\n }\n \f\n+\n tree\n gfc_get_function_type (gfc_symbol * sym)\n {\n@@ -1194,12 +1208,11 @@ gfc_get_function_type (gfc_symbol * sym)\n \t     For this reason all parameters to global functions must be\n \t     passed by reference.  Passing by value would potentialy\n \t     generate bad code.  Worse there would be no way of telling that\n-\t     this code wad bad, except that it would give incorrect results.\n+\t     this code was bad, except that it would give incorrect results.\n \n \t     Contained procedures could pass by value as these are never\n \t     used without an explicit interface, and connot be passed as\n-\t     actual parameters for a dummy procedure.\n-\t   */\n+\t     actual parameters for a dummy procedure.  */\n \t  if (arg->ts.type == BT_CHARACTER)\n             nstr++;\n \t  typelist = gfc_chainon_list (typelist, type);\n@@ -1371,6 +1384,7 @@ gfc_type_for_mode (enum machine_mode mode, int unsignedp)\n }\n \n /* Return an unsigned type the same as TYPE in other respects.  */\n+\n tree\n gfc_unsigned_type (tree type)\n {"}]}