{"sha": "417232534c60b32da5f064631974dbcb9c70bf05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3MjMyNTM0YzYwYjMyZGE1ZjA2NDYzMTk3NGRiY2I5YzcwYmYwNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-04T20:04:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-04T20:04:47Z"}, "message": "re PR other/29442 (insn-attrtab has grown too large)\n\n\tPR other/29442\n\t* read-md.c (fprint_md_ptr_loc, fprint_c_condition): New functions.\n\t(print_md_ptr_loc, print_c_condition): Use them.\n\t* read-md.h (fprint_md_ptr_loc, fprint_c_condition): New prototypes.\n\t* genattrtab.c (attr_file_name, dfa_file_name, latency_file_name,\n\tattr_file, dfa_file, latency_file): New global variables.\n\t(write_attr_valueq, write_attr_set, write_attr_case, write_attr_value,\n\twrite_upcase, write_indent, write_length_unit_log, write_test_expr,\n\twrite_attr_get, write_insn_cases, write_eligible_delay,\n\twrite_const_num_delay_slots): Accept FILE pointer and toss it around.\n\tUpdate all callers.\n\t(write_header, open_outfile, handle_arg): New funcions.\n\t(make_automaton_attrs): Write prototypes as extern to the output\n\tfiles.\n\t(main): Use init_rtx_reader_args_cb with handle_arg to take 3 file\n\tnames from the command line.  Open the output files and write out\n\tinternal functions for DFA functions to dfa_file_name, insn latency\n\tfunctions to latency_file_name, and everything else to attr_file.\n\t* Makefile.in (OBJS): Add insn-dfatab.o and insn-latencytab.o.\n\t(BACKEND): Build libbackend first.\n\t(MOSTLYCLEANFILES): Add insn-dfatab.c and insn-latencytab.c.\n\t(.PRECIOUS): Likewise.\n\t(insn-dfatab.o): New rule.\n\t(insn-latencytab.o): New rule.\n\t(simple_rtl_generated_c): Do not include insn-attrtab.c.\n\t(s-attrtab): New rule.\n\nFrom-SVN: r187181", "tree": {"sha": "09c8525eb66f16b480d4594d1433120fadc8ad6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09c8525eb66f16b480d4594d1433120fadc8ad6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/417232534c60b32da5f064631974dbcb9c70bf05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417232534c60b32da5f064631974dbcb9c70bf05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/417232534c60b32da5f064631974dbcb9c70bf05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417232534c60b32da5f064631974dbcb9c70bf05/comments", "author": null, "committer": null, "parents": [{"sha": "81e7aa8e7acb26abcd654c77ee4d088babf45ba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e7aa8e7acb26abcd654c77ee4d088babf45ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81e7aa8e7acb26abcd654c77ee4d088babf45ba1"}], "stats": {"total": 775, "additions": 476, "deletions": 299}, "files": [{"sha": "8dafc82624045243498ce2b0df7605c25a457b45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=417232534c60b32da5f064631974dbcb9c70bf05", "patch": "@@ -1,3 +1,32 @@\n+2012-05-04  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR other/29442\n+\t* read-md.c (fprint_md_ptr_loc, fprint_c_condition): New functions.\n+\t(print_md_ptr_loc, print_c_condition): Use them.\n+\t* read-md.h (fprint_md_ptr_loc, fprint_c_condition): New prototypes.\n+\t* genattrtab.c (attr_file_name, dfa_file_name, latency_file_name,\n+\tattr_file, dfa_file, latency_file): New global variables.\n+\t(write_attr_valueq, write_attr_set, write_attr_case, write_attr_value,\n+\twrite_upcase, write_indent, write_length_unit_log, write_test_expr,\n+\twrite_attr_get, write_insn_cases, write_eligible_delay,\n+\twrite_const_num_delay_slots): Accept FILE pointer and toss it around.\n+\tUpdate all callers.\n+\t(write_header, open_outfile, handle_arg): New funcions.\n+\t(make_automaton_attrs): Write prototypes as extern to the output\n+\tfiles.\n+\t(main): Use init_rtx_reader_args_cb with handle_arg to take 3 file\n+\tnames from the command line.  Open the output files and write out\n+\tinternal functions for DFA functions to dfa_file_name, insn latency\n+\tfunctions to latency_file_name, and everything else to attr_file.\n+\t* Makefile.in (OBJS): Add insn-dfatab.o and insn-latencytab.o.\n+\t(BACKEND): Build libbackend first.\n+\t(MOSTLYCLEANFILES): Add insn-dfatab.c and insn-latencytab.c.\n+\t(.PRECIOUS): Likewise.\n+\t(insn-dfatab.o): New rule.\n+\t(insn-latencytab.o): New rule.\n+\t(simple_rtl_generated_c): Do not include insn-attrtab.c.\n+\t(s-attrtab): New rule.\n+\n 2012-05-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* rtl.def (ATTR_FLAG): Remove probability indicating flags."}, {"sha": "ec27f88c4bd98276c36a4199907502a7a7d8e0b7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=417232534c60b32da5f064631974dbcb9c70bf05", "patch": "@@ -1143,8 +1143,10 @@ C_OBJS = c-lang.o c-family/stub-objc.o $(C_AND_OBJC_OBJS)\n OBJS = \\\n \tinsn-attrtab.o \\\n \tinsn-automata.o \\\n+\tinsn-dfatab.o \\\n \tinsn-emit.o \\\n \tinsn-extract.o \\\n+\tinsn-latencytab.o \\\n \tinsn-modes.o \\\n \tinsn-opinit.o \\\n \tinsn-output.o \\\n@@ -1469,13 +1471,13 @@ ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \\\n # compilation or not.\n ALL_HOST_OBJS = $(ALL_HOST_FRONTEND_OBJS) $(ALL_HOST_BACKEND_OBJS)\n \n-BACKEND = main.o @TREEBROWSER@ libbackend.a libcommon-target.a libcommon.a \\\n+BACKEND = libbackend.a main.o @TREEBROWSER@ libcommon-target.a libcommon.a \\\n \t$(CPPLIB) $(LIBDECNUMBER)\n \n MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n- insn-attr.h insn-attr-common.h insn-attrtab.c insn-opinit.c \\\n- insn-preds.c insn-constants.h \\\n+ insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n+ insn-latencytab.c insn-opinit.c insn-preds.c insn-constants.h \\\n  tm-preds.h tm-constrs.h checksum-options \\\n  tree-check.h min-insn-modes.c insn-modes.c insn-modes.h \\\n  genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-input.list \\\n@@ -3460,7 +3462,8 @@ $(common_out_object_file): $(common_out_file) $(CONFIG_H) $(SYSTEM_H) \\\n \n .PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \\\n   insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \\\n-  insn-attr.h insn-attr-common.h insn-attrtab.c insn-preds.c\n+  insn-attr.h insn-attr-common.h insn-attrtab.c insn-dfatab.c \\\n+  insn-latencytab.c insn-preds.c\n \n # Dependencies for the md file.  The first time through, we just assume\n # the md file itself and the generated dependency file (in order to get\n@@ -3479,7 +3482,11 @@ insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   insn-config.h $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(TM_P_H) $(FLAGS_H)\n insn-automata.o : insn-automata.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(TM_H) $(RTL_H) $(REGS_H) output.h $(INSN_ATTR_H)\t\t\t\\\n-  insn-config.h toplev.h $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(TM_P_H) $(FLAGS_H) $(EMIT_RTL_H)\n+  insn-config.h toplev.h $(DIAGNOSTIC_CORE_H) $(RECOG_H)\t\t\\\n+  $(TM_P_H) $(FLAGS_H) $(EMIT_RTL_H)\n+insn-dfatab.o : insn-dfatab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n+  $(TM_H) $(RTL_H) $(REGS_H) output.h $(INSN_ATTR_H)\t\t\t\\\n+  insn-config.h $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(TM_P_H) $(FLAGS_H)\n insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\\\n   $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) \t\t\\\n   dfp.h $(FLAGS_H) output.h insn-config.h hard-reg-set.h $(RECOG_H)\t\\\n@@ -3488,6 +3495,9 @@ insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\\\n insn-enums.o : insn-enums.c $(CONFIG_H) $(SYSTEM_H) insn-constants.h\n insn-extract.o : insn-extract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(TM_H) $(RTL_H) $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H)\n+insn-latencytab.o : insn-latencytab.c $(CONFIG_H) $(SYSTEM_H) \t\t\\\n+  coretypes.h $(TM_H) $(RTL_H) $(REGS_H) output.h $(INSN_ATTR_H)\t\\\n+  insn-config.h $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(TM_P_H) $(FLAGS_H)\n insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t$(TM_H) \\\n   $(MACHMODE_H)\n insn-opinit.o : insn-opinit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n@@ -3520,7 +3530,7 @@ insn-recog.o : insn-recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n simple_rtl_generated_h\t= insn-attr.h insn-attr-common.h insn-codes.h \\\n \t\t\t  insn-config.h insn-flags.h\n \n-simple_rtl_generated_c\t= insn-attrtab.c insn-automata.c insn-emit.c \\\n+simple_rtl_generated_c\t= insn-automata.c insn-emit.c \\\n \t\t\t  insn-extract.c insn-opinit.c insn-output.c \\\n \t\t\t  insn-peep.c insn-recog.c\n \n@@ -3557,6 +3567,17 @@ s-check : build/gencheck$(build_exeext)\n \t$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h\n \t$(STAMP) s-check\n \n+# genattrtab produces three files: tmp-{attrtab.c,dfatab.c,latencytab.c}\n+insn-attrtab.c insn-dfatab.c insn-latencytab.c: s-attrtab ; @true\n+s-attrtab : $(MD_DEPS) build/genattrtab$(build_exeext) \\\n+  insn-conditions.md\n+\t$(RUN_GEN) build/genattrtab$(build_exeext) $(md_file) insn-conditions.md \\\n+\t\t-Atmp-attrtab.c -Dtmp-dfatab.c -Ltmp-latencytab.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-attrtab.c    insn-attrtab.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-dfatab.c     insn-dfatab.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-latencytab.c insn-latencytab.c\n+\t$(STAMP) s-attrtab\n+\n # gencondmd doesn't use the standard naming convention.\n build/gencondmd.c: s-conditions; @true\n s-conditions: $(MD_DEPS) build/genconditions$(build_exeext)"}, {"sha": "60aa59c49246875926f388af98035b8e0d63a8a1", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 389, "deletions": 279, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=417232534c60b32da5f064631974dbcb9c70bf05", "patch": "@@ -275,16 +275,17 @@ static rtx copy_rtx_unchanging\t   (rtx);\n static bool attr_alt_subset_p      (rtx, rtx);\n static bool attr_alt_subset_of_compl_p (rtx, rtx);\n static void clear_struct_flag      (rtx);\n-static void write_attr_valueq\t   (struct attr_desc *, const char *);\n+static void write_attr_valueq\t   (FILE *, struct attr_desc *, const char *);\n static struct attr_value *find_most_used  (struct attr_desc *);\n-static void write_attr_set\t   (struct attr_desc *, int, rtx,\n+static void write_attr_set\t   (FILE *, struct attr_desc *, int, rtx,\n \t\t\t\t    const char *, const char *, rtx,\n \t\t\t\t    int, int, unsigned int);\n-static void write_attr_case\t   (struct attr_desc *, struct attr_value *,\n+static void write_attr_case\t   (FILE *, struct attr_desc *,\n+\t\t\t\t    struct attr_value *,\n \t\t\t\t    int, const char *, const char *, int, rtx);\n-static void write_attr_value\t   (struct attr_desc *, rtx);\n-static void write_upcase\t   (const char *);\n-static void write_indent\t   (int);\n+static void write_attr_value\t   (FILE *, struct attr_desc *, rtx);\n+static void write_upcase\t   (FILE *, const char *);\n+static void write_indent\t   (FILE *, int);\n static rtx identity_fn\t\t   (rtx);\n static rtx zero_fn\t\t   (rtx);\n static rtx one_fn\t\t   (rtx);\n@@ -294,6 +295,23 @@ static rtx min_fn\t\t   (rtx);\n #define oballoc(T) XOBNEW (hash_obstack, T)\n #define oballocvec(T, N) XOBNEWVEC (hash_obstack, T, (N))\n \n+/* This gen* file is unique, in that it writes out multiple files.\n+\n+   Before GCC 4.8, insn-attrtab.c was written out containing many large\n+   functions and tables.  This made insn-attrtab.c _the_ bottle-neck in\n+   a parallel build, and even made it impossible to build GCC on machines\n+   with relatively small RAM space (PR other/29442).  Therefore, the\n+   atrribute functions/tables are now written out to three separate\n+   files: all \"*insn_default_latency\" functions go to LATENCY_FILE_NAME,\n+   all \"*internal_dfa_insn_code\" functions go to DFA_FILE_NAME, and the\n+   rest goes to ATTR_FILE_NAME.  */\n+\n+static const char *attr_file_name = NULL;\n+static const char *dfa_file_name = NULL;\n+static const char *latency_file_name = NULL;\n+\n+static FILE *attr_file, *dfa_file, *latency_file;\n+\n /* Hash table for sharing RTL and strings.  */\n \n /* Each hash table slot is a bucket containing a chain of these structures.\n@@ -1610,7 +1628,7 @@ min_fn (rtx exp)\n }\n \n static void\n-write_length_unit_log (void)\n+write_length_unit_log (FILE *outf)\n {\n   struct attr_desc *length_attr = find_attr (&length_str, 0);\n   struct attr_value *av;\n@@ -1633,7 +1651,7 @@ write_length_unit_log (void)\n       for (length_unit_log = 0; length_or & 1; length_or >>= 1)\n \tlength_unit_log++;\n     }\n-  printf (\"EXPORTED_CONST int length_unit_log = %u;\\n\", length_unit_log);\n+  fprintf (outf, \"EXPORTED_CONST int length_unit_log = %u;\\n\", length_unit_log);\n }\n \n /* Take a COND expression and see if any of the conditions in it can be\n@@ -3247,7 +3265,7 @@ find_attrs_to_cache (rtx exp, bool create)\n     }\n }\n \n-/* Given a piece of RTX, print a C expression to test its truth value.\n+/* Given a piece of RTX, print a C expression to test its truth value to OUTF.\n    We use AND and IOR both for logical and bit-wise operations, so\n    interpret them as logical unless they are inside a comparison expression.  */\n \n@@ -3265,7 +3283,7 @@ find_attrs_to_cache (rtx exp, bool create)\n #define FLG_OUTSIDE_AND\t\t8\n \n static unsigned int\n-write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n+write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags)\n {\n   int comparison_operator = 0;\n   RTX_CODE code;\n@@ -3274,14 +3292,14 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n   /* In order not to worry about operator precedence, surround our part of\n      the expression with parentheses.  */\n \n-  printf (\"(\");\n+  fprintf (outf, \"(\");\n   code = GET_CODE (exp);\n   switch (code)\n     {\n     /* Binary operators.  */\n     case GEU: case GTU:\n     case LEU: case LTU:\n-      printf (\"(unsigned) \");\n+      fprintf (outf, \"(unsigned) \");\n       /* Fall through.  */\n \n     case EQ: case NE:\n@@ -3295,7 +3313,7 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n       if ((code != AND && code != IOR) || (flags & FLG_BITWISE))\n \t{\n \t  flags &= ~(FLG_AFTER | FLG_INSIDE | FLG_OUTSIDE_AND);\n-\t  write_test_expr (XEXP (exp, 0), attrs_cached,\n+\t  write_test_expr (outf, XEXP (exp, 0), attrs_cached,\n \t\t\t   flags | comparison_operator);\n \t}\n       else\n@@ -3307,78 +3325,78 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t      || (GET_CODE (XEXP (exp, 0)) == NOT\n \t\t  && GET_CODE (XEXP (XEXP (exp, 0), 0)) == EQ_ATTR))\n \t    attrs_cached\n-\t      = write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n+\t      = write_test_expr (outf, XEXP (exp, 0), attrs_cached, flags);\n \t  else\n-\t    write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n+\t    write_test_expr (outf, XEXP (exp, 0), attrs_cached, flags);\n \t}\n       switch (code)\n \t{\n \tcase EQ:\n-\t  printf (\" == \");\n+\t  fprintf (outf, \" == \");\n \t  break;\n \tcase NE:\n-\t  printf (\" != \");\n+\t  fprintf (outf, \" != \");\n \t  break;\n \tcase GE:\n-\t  printf (\" >= \");\n+\t  fprintf (outf, \" >= \");\n \t  break;\n \tcase GT:\n-\t  printf (\" > \");\n+\t  fprintf (outf, \" > \");\n \t  break;\n \tcase GEU:\n-\t  printf (\" >= (unsigned) \");\n+\t  fprintf (outf, \" >= (unsigned) \");\n \t  break;\n \tcase GTU:\n-\t  printf (\" > (unsigned) \");\n+\t  fprintf (outf, \" > (unsigned) \");\n \t  break;\n \tcase LE:\n-\t  printf (\" <= \");\n+\t  fprintf (outf, \" <= \");\n \t  break;\n \tcase LT:\n-\t  printf (\" < \");\n+\t  fprintf (outf, \" < \");\n \t  break;\n \tcase LEU:\n-\t  printf (\" <= (unsigned) \");\n+\t  fprintf (outf, \" <= (unsigned) \");\n \t  break;\n \tcase LTU:\n-\t  printf (\" < (unsigned) \");\n+\t  fprintf (outf, \" < (unsigned) \");\n \t  break;\n \tcase PLUS:\n-\t  printf (\" + \");\n+\t  fprintf (outf, \" + \");\n \t  break;\n \tcase MINUS:\n-\t  printf (\" - \");\n+\t  fprintf (outf, \" - \");\n \t  break;\n \tcase MULT:\n-\t  printf (\" * \");\n+\t  fprintf (outf, \" * \");\n \t  break;\n \tcase DIV:\n-\t  printf (\" / \");\n+\t  fprintf (outf, \" / \");\n \t  break;\n \tcase MOD:\n-\t  printf (\" %% \");\n+\t  fprintf (outf, \" %% \");\n \t  break;\n \tcase AND:\n \t  if (flags & FLG_BITWISE)\n-\t    printf (\" & \");\n+\t    fprintf (outf, \" & \");\n \t  else\n-\t    printf (\" && \");\n+\t    fprintf (outf, \" && \");\n \t  break;\n \tcase IOR:\n \t  if (flags & FLG_BITWISE)\n-\t    printf (\" | \");\n+\t    fprintf (outf, \" | \");\n \t  else\n-\t    printf (\" || \");\n+\t    fprintf (outf, \" || \");\n \t  break;\n \tcase XOR:\n-\t  printf (\" ^ \");\n+\t  fprintf (outf, \" ^ \");\n \t  break;\n \tcase ASHIFT:\n-\t  printf (\" << \");\n+\t  fprintf (outf, \" << \");\n \t  break;\n \tcase LSHIFTRT:\n \tcase ASHIFTRT:\n-\t  printf (\" >> \");\n+\t  fprintf (outf, \" >> \");\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -3409,9 +3427,9 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t      || (GET_CODE (XEXP (exp, 1)) == NOT\n \t\t  && GET_CODE (XEXP (XEXP (exp, 1), 0)) == EQ_ATTR)))\n \tattrs_cached\n-\t  = write_test_expr (XEXP (exp, 1), attrs_cached, flags);\n+\t  = write_test_expr (outf, XEXP (exp, 1), attrs_cached, flags);\n       else\n-\twrite_test_expr (XEXP (exp, 1), attrs_cached,\n+\twrite_test_expr (outf, XEXP (exp, 1), attrs_cached,\n \t\t\t flags | comparison_operator);\n       break;\n \n@@ -3421,12 +3439,14 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t{\n \t  if (XSTR (XEXP (exp, 0), 0) == alternative_name)\n \t    {\n-\t      printf (\"which_alternative != %s\", XSTR (XEXP (exp, 0), 1));\n+\t      fprintf (outf, \"which_alternative != %s\",\n+\t\t       XSTR (XEXP (exp, 0), 1));\n \t      break;\n \t    }\n \n-\t  printf (\"! \");\n-\t  attrs_cached = write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n+\t  fprintf (outf, \"! \");\n+\t  attrs_cached =\n+\t    write_test_expr (outf, XEXP (exp, 0), attrs_cached, flags);\n \t  break;\n \t}\n \n@@ -3438,22 +3458,22 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t{\n \tcase NOT:\n \t  if (flags & FLG_BITWISE)\n-\t    printf (\"~ \");\n+\t    fprintf (outf, \"~ \");\n \t  else\n-\t    printf (\"! \");\n+\t    fprintf (outf, \"! \");\n \t  break;\n \tcase ABS:\n-\t  printf (\"abs \");\n+\t  fprintf (outf, \"abs \");\n \t  break;\n \tcase NEG:\n-\t  printf (\"-\");\n+\t  fprintf (outf, \"-\");\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n       flags &= ~(FLG_AFTER | FLG_INSIDE | FLG_OUTSIDE_AND);\n-      write_test_expr (XEXP (exp, 0), attrs_cached, flags);\n+      write_test_expr (outf, XEXP (exp, 0), attrs_cached, flags);\n       break;\n \n     case EQ_ATTR_ALT:\n@@ -3491,13 +3511,13 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t      if (!(set & 1))\n \t\tbit++;\n \n-\t      printf (\"which_alternative %s= %d\",\n-\t\t      XINT (exp, 1) ? \"!\" : \"=\", bit);\n+\t      fprintf (outf, \"which_alternative %s= %d\",\n+\t\t       XINT (exp, 1) ? \"!\" : \"=\", bit);\n \t    }\n \t  else\n \t    {\n-\t      printf (\"%s((1 << which_alternative) & %#x)\",\n-\t\t      XINT (exp, 1) ? \"!\" : \"\", set);\n+\t      fprintf (outf, \"%s((1 << which_alternative) & %#x)\",\n+\t\t       XINT (exp, 1) ? \"!\" : \"\", set);\n \t    }\n \t}\n       break;\n@@ -3511,7 +3531,7 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \n       if (XSTR (exp, 0) == alternative_name)\n \t{\n-\t  printf (\"which_alternative == %s\", XSTR (exp, 1));\n+\t  fprintf (outf, \"which_alternative == %s\", XSTR (exp, 1));\n \t  break;\n \t}\n \n@@ -3521,8 +3541,10 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n       /* Now is the time to expand the value of a constant attribute.  */\n       if (attr->is_const)\n \t{\n-\t  write_test_expr (evaluate_eq_attr (exp, attr,\n-\t\t\t\t\t     attr->default_val->value, -2, -2),\n+\t  write_test_expr (outf,\n+\t\t\t   evaluate_eq_attr (exp, attr,\n+\t\t\t\t\t     attr->default_val->value,\n+\t\t\t\t\t     -2, -2),\n \t\t\t   attrs_cached, 0);\n \t}\n       else\n@@ -3532,10 +3554,10 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t    if (attr->name == cached_attrs[i])\n \t      break;\n \t  if (i < cached_attr_count && (attrs_cached & (1U << i)) != 0)\n-\t    printf (\"cached_%s\", attr->name);\n+\t    fprintf (outf, \"cached_%s\", attr->name);\n \t  else if (i < cached_attr_count && (attrs_to_cache & (1U << i)) != 0)\n \t    {\n-\t      printf (\"(cached_%s = get_attr_%s (insn))\",\n+\t      fprintf (outf, \"(cached_%s = get_attr_%s (insn))\",\n \t\t      attr->name, attr->name);\n \t      if (flags & FLG_AFTER)\n \t\tattrs_cached_after |= (1U << i);\n@@ -3544,17 +3566,17 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t      attrs_cached |= (1U << i);\n \t    }\n \t  else\n-\t    printf (\"get_attr_%s (insn)\", attr->name);\n-\t  printf (\" == \");\n-\t  write_attr_valueq (attr, XSTR (exp, 1));\n+\t    fprintf (outf, \"get_attr_%s (insn)\", attr->name);\n+\t  fprintf (outf, \" == \");\n+\t  write_attr_valueq (outf, attr, XSTR (exp, 1));\n \t}\n       break;\n \n     /* Comparison test of flags for define_delays.  */\n     case ATTR_FLAG:\n       if (flags & FLG_BITWISE)\n \tfatal (\"ATTR_FLAG not valid inside comparison\");\n-      printf (\"(flags & ATTR_FLAG_%s) != 0\", XSTR (exp, 0));\n+      fprintf (outf, \"(flags & ATTR_FLAG_%s) != 0\", XSTR (exp, 0));\n       break;\n \n     /* See if an operand matches a predicate.  */\n@@ -3566,34 +3588,35 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t  if (GET_MODE (exp) == VOIDmode)\n \t    fatal (\"null MATCH_OPERAND specified as test\");\n \t  else\n-\t    printf (\"GET_MODE (operands[%d]) == %smode\",\n-\t\t    XINT (exp, 0), GET_MODE_NAME (GET_MODE (exp)));\n+\t    fprintf (outf, \"GET_MODE (operands[%d]) == %smode\",\n+\t\t     XINT (exp, 0), GET_MODE_NAME (GET_MODE (exp)));\n \t}\n       else\n-\tprintf (\"%s (operands[%d], %smode)\",\n-\t\tXSTR (exp, 1), XINT (exp, 0), GET_MODE_NAME (GET_MODE (exp)));\n+\tfprintf (outf, \"%s (operands[%d], %smode)\",\n+\t\t XSTR (exp, 1), XINT (exp, 0), GET_MODE_NAME (GET_MODE (exp)));\n       break;\n \n     /* Constant integer.  */\n     case CONST_INT:\n-      printf (HOST_WIDE_INT_PRINT_DEC, XWINT (exp, 0));\n+      fprintf (outf, HOST_WIDE_INT_PRINT_DEC, XWINT (exp, 0));\n       break;\n \n     case MATCH_TEST:\n-      print_c_condition (XSTR (exp, 0));\n+      fprint_c_condition (outf, XSTR (exp, 0));\n       if (flags & FLG_BITWISE)\n-\tprintf (\" != 0\");\n+\tfprintf (outf, \" != 0\");\n       break;\n \n     /* A random C expression.  */\n     case SYMBOL_REF:\n-      print_c_condition (XSTR (exp, 0));\n+      fprint_c_condition (outf, XSTR (exp, 0));\n       break;\n \n     /* The address of the branch target.  */\n     case MATCH_DUP:\n-      printf (\"INSN_ADDRESSES_SET_P () ? INSN_ADDRESSES (INSN_UID (GET_CODE (operands[%d]) == LABEL_REF ? XEXP (operands[%d], 0) : operands[%d])) : 0\",\n-\t      XINT (exp, 0), XINT (exp, 0), XINT (exp, 0));\n+      fprintf (outf,\n+\t       \"INSN_ADDRESSES_SET_P () ? INSN_ADDRESSES (INSN_UID (GET_CODE (operands[%d]) == LABEL_REF ? XEXP (operands[%d], 0) : operands[%d])) : 0\",\n+\t       XINT (exp, 0), XINT (exp, 0), XINT (exp, 0));\n       break;\n \n     case PC:\n@@ -3602,27 +3625,27 @@ write_test_expr (rtx exp, unsigned int attrs_cached, int flags)\n \t address of the next insn for forward branches, and both with\n \t adjustments that account for the worst-case possible stretching of\n \t intervening alignments between this insn and its destination.  */\n-      printf (\"insn_current_reference_address (insn)\");\n+      fprintf (outf, \"insn_current_reference_address (insn)\");\n       break;\n \n     case CONST_STRING:\n-      printf (\"%s\", XSTR (exp, 0));\n+      fprintf (outf, \"%s\", XSTR (exp, 0));\n       break;\n \n     case IF_THEN_ELSE:\n-      write_test_expr (XEXP (exp, 0), attrs_cached, 0);\n-      printf (\" ? \");\n-      write_test_expr (XEXP (exp, 1), attrs_cached, FLG_BITWISE);\n-      printf (\" : \");\n-      write_test_expr (XEXP (exp, 2), attrs_cached, FLG_BITWISE);\n+      write_test_expr (outf, XEXP (exp, 0), attrs_cached, 0);\n+      fprintf (outf, \" ? \");\n+      write_test_expr (outf, XEXP (exp, 1), attrs_cached, FLG_BITWISE);\n+      fprintf (outf, \" : \");\n+      write_test_expr (outf, XEXP (exp, 2), attrs_cached, FLG_BITWISE);\n       break;\n \n     default:\n       fatal (\"bad RTX code `%s' in attribute calculation\\n\",\n \t     GET_RTX_NAME (code));\n     }\n \n-  printf (\")\");\n+  fprintf (outf, \")\");\n   return attrs_cached;\n }\n \n@@ -3826,7 +3849,7 @@ walk_attr_value (rtx exp)\n /* Write out a function to obtain the attribute for a given INSN.  */\n \n static void\n-write_attr_get (struct attr_desc *attr)\n+write_attr_get (FILE *outf, struct attr_desc *attr)\n {\n   struct attr_value *av, *common_av;\n   int i, j;\n@@ -3838,37 +3861,37 @@ write_attr_get (struct attr_desc *attr)\n   /* Write out start of function, then all values with explicit `case' lines,\n      then a `default', then the value with the most uses.  */\n   if (attr->enum_name)\n-    printf (\"enum %s\\n\", attr->enum_name);\n+    fprintf (outf, \"enum %s\\n\", attr->enum_name);\n   else if (!attr->is_numeric)\n-    printf (\"enum attr_%s\\n\", attr->name);\n+    fprintf (outf, \"enum attr_%s\\n\", attr->name);\n   else\n-    printf (\"int\\n\");\n+    fprintf (outf, \"int\\n\");\n \n   /* If the attribute name starts with a star, the remainder is the name of\n      the subroutine to use, instead of `get_attr_...'.  */\n   if (attr->name[0] == '*')\n-    printf (\"%s (rtx insn ATTRIBUTE_UNUSED)\\n\", &attr->name[1]);\n+    fprintf (outf, \"%s (rtx insn ATTRIBUTE_UNUSED)\\n\", &attr->name[1]);\n   else if (attr->is_const == 0)\n-    printf (\"get_attr_%s (rtx insn ATTRIBUTE_UNUSED)\\n\", attr->name);\n+    fprintf (outf, \"get_attr_%s (rtx insn ATTRIBUTE_UNUSED)\\n\", attr->name);\n   else\n     {\n-      printf (\"get_attr_%s (void)\\n\", attr->name);\n-      printf (\"{\\n\");\n+      fprintf (outf, \"get_attr_%s (void)\\n\", attr->name);\n+      fprintf (outf, \"{\\n\");\n \n       for (av = attr->first_value; av; av = av->next)\n \tif (av->num_insns == 1)\n-\t  write_attr_set (attr, 2, av->value, \"return\", \";\",\n+\t  write_attr_set (outf, attr, 2, av->value, \"return\", \";\",\n \t\t\t  true_rtx, av->first_insn->def->insn_code,\n \t\t\t  av->first_insn->def->insn_index, 0);\n \telse if (av->num_insns != 0)\n-\t  write_attr_set (attr, 2, av->value, \"return\", \";\",\n+\t  write_attr_set (outf, attr, 2, av->value, \"return\", \";\",\n \t\t\t  true_rtx, -2, 0, 0);\n \n-      printf (\"}\\n\\n\");\n+      fprintf (outf, \"}\\n\\n\");\n       return;\n     }\n \n-  printf (\"{\\n\");\n+  fprintf (outf, \"{\\n\");\n \n   /* Find attributes that are worth caching in the conditions.  */\n   cached_attr_count = 0;\n@@ -3889,27 +3912,27 @@ write_attr_get (struct attr_desc *attr)\n \tcached_attr = find_attr (&name, 0);\n \tgcc_assert (cached_attr && cached_attr->is_const == 0);\n \tif (cached_attr->enum_name)\n-\t  printf (\"  enum %s\", cached_attr->enum_name);\n+\t  fprintf (outf, \"  enum %s\", cached_attr->enum_name);\n \telse if (!cached_attr->is_numeric)\n-\t  printf (\"  enum attr_%s\", cached_attr->name);\n+\t  fprintf (outf, \"  enum attr_%s\", cached_attr->name);\n \telse\n-\t  printf (\"  int\");\n-\tprintf (\" cached_%s ATTRIBUTE_UNUSED;\\n\", name);\n+\t  fprintf (outf, \"  int\");\n+\tfprintf (outf, \" cached_%s ATTRIBUTE_UNUSED;\\n\", name);\n \tj++;\n       }\n   cached_attr_count = j;\n   if (cached_attr_count)\n-    printf (\"\\n\");\n+    fprintf (outf, \"\\n\");\n \n-  printf (\"  switch (recog_memoized (insn))\\n\");\n-  printf (\"    {\\n\");\n+  fprintf (outf, \"  switch (recog_memoized (insn))\\n\");\n+  fprintf (outf, \"    {\\n\");\n \n   for (av = attr->first_value; av; av = av->next)\n     if (av != common_av)\n-      write_attr_case (attr, av, 1, \"return\", \";\", 4, true_rtx);\n+      write_attr_case (outf, attr, av, 1, \"return\", \";\", 4, true_rtx);\n \n-  write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n-  printf (\"    }\\n}\\n\\n\");\n+  write_attr_case (outf, attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n+  fprintf (outf, \"    }\\n}\\n\\n\");\n   cached_attr_count = 0;\n }\n \n@@ -3947,7 +3970,7 @@ eliminate_known_true (rtx known_true, rtx exp, int insn_code, int insn_index)\n    and \";\").  */\n \n static void\n-write_attr_set (struct attr_desc *attr, int indent, rtx value,\n+write_attr_set (FILE *outf, struct attr_desc *attr, int indent, rtx value,\n \t\tconst char *prefix, const char *suffix, rtx known_true,\n \t\tint insn_code, int insn_index, unsigned int attrs_cached)\n {\n@@ -4002,75 +4025,75 @@ write_attr_set (struct attr_desc *attr, int indent, rtx value,\n \n \t  attrs_cached_inside = attrs_cached;\n \t  attrs_cached_after = attrs_cached;\n-\t  write_indent (indent);\n-\t  printf (\"%sif \", first_if ? \"\" : \"else \");\n+\t  write_indent (outf, indent);\n+\t  fprintf (outf, \"%sif \", first_if ? \"\" : \"else \");\n \t  first_if = 0;\n-\t  write_test_expr (testexp, attrs_cached,\n+\t  write_test_expr (outf, testexp, attrs_cached,\n \t\t\t   (FLG_AFTER | FLG_INSIDE | FLG_OUTSIDE_AND));\n \t  attrs_cached = attrs_cached_after;\n-\t  printf (\"\\n\");\n-\t  write_indent (indent + 2);\n-\t  printf (\"{\\n\");\n+\t  fprintf (outf, \"\\n\");\n+\t  write_indent (outf, indent + 2);\n+\t  fprintf (outf, \"{\\n\");\n \n-\t  write_attr_set (attr, indent + 4,\n+\t  write_attr_set (outf, attr, indent + 4,\n \t\t\t  XVECEXP (value, 0, i + 1), prefix, suffix,\n \t\t\t  inner_true, insn_code, insn_index,\n \t\t\t  attrs_cached_inside);\n-\t  write_indent (indent + 2);\n-\t  printf (\"}\\n\");\n+\t  write_indent (outf, indent + 2);\n+\t  fprintf (outf, \"}\\n\");\n \t  our_known_true = newexp;\n \t}\n \n       if (! first_if)\n \t{\n-\t  write_indent (indent);\n-\t  printf (\"else\\n\");\n-\t  write_indent (indent + 2);\n-\t  printf (\"{\\n\");\n+\t  write_indent (outf, indent);\n+\t  fprintf (outf, \"else\\n\");\n+\t  write_indent (outf, indent + 2);\n+\t  fprintf (outf, \"{\\n\");\n \t}\n \n-      write_attr_set (attr, first_if ? indent : indent + 4, default_val,\n+      write_attr_set (outf, attr, first_if ? indent : indent + 4, default_val,\n \t\t      prefix, suffix, our_known_true, insn_code, insn_index,\n \t\t      attrs_cached);\n \n       if (! first_if)\n \t{\n-\t  write_indent (indent + 2);\n-\t  printf (\"}\\n\");\n+\t  write_indent (outf, indent + 2);\n+\t  fprintf (outf, \"}\\n\");\n \t}\n     }\n   else\n     {\n-      write_indent (indent);\n-      printf (\"%s \", prefix);\n-      write_attr_value (attr, value);\n-      printf (\"%s\\n\", suffix);\n+      write_indent (outf, indent);\n+      fprintf (outf, \"%s \", prefix);\n+      write_attr_value (outf, attr, value);\n+      fprintf (outf, \"%s\\n\", suffix);\n     }\n }\n \n /* Write a series of case statements for every instruction in list IE.\n    INDENT is the amount of indentation to write before each case.  */\n \n static void\n-write_insn_cases (struct insn_ent *ie, int indent)\n+write_insn_cases (FILE *outf, struct insn_ent *ie, int indent)\n {\n   for (; ie != 0; ie = ie->next)\n     if (ie->def->insn_code != -1)\n       {\n-\twrite_indent (indent);\n+\twrite_indent (outf, indent);\n \tif (GET_CODE (ie->def->def) == DEFINE_PEEPHOLE)\n-\t  printf (\"case %d:  /* define_peephole, line %d */\\n\",\n-\t\t  ie->def->insn_code, ie->def->lineno);\n+\t  fprintf (outf, \"case %d:  /* define_peephole, line %d */\\n\",\n+\t\t   ie->def->insn_code, ie->def->lineno);\n \telse\n-\t  printf (\"case %d:  /* %s */\\n\",\n-\t\t  ie->def->insn_code, XSTR (ie->def->def, 0));\n+\t  fprintf (outf, \"case %d:  /* %s */\\n\",\n+\t\t   ie->def->insn_code, XSTR (ie->def->def, 0));\n       }\n }\n \n /* Write out the computation for one attribute value.  */\n \n static void\n-write_attr_case (struct attr_desc *attr, struct attr_value *av,\n+write_attr_case (FILE *outf, struct attr_desc *attr, struct attr_value *av,\n \t\t int write_case_lines, const char *prefix, const char *suffix,\n \t\t int indent, rtx known_true)\n {\n@@ -4079,22 +4102,22 @@ write_attr_case (struct attr_desc *attr, struct attr_value *av,\n \n   if (av->has_asm_insn)\n     {\n-      write_indent (indent);\n-      printf (\"case -1:\\n\");\n-      write_indent (indent + 2);\n-      printf (\"if (GET_CODE (PATTERN (insn)) != ASM_INPUT\\n\");\n-      write_indent (indent + 2);\n-      printf (\"    && asm_noperands (PATTERN (insn)) < 0)\\n\");\n-      write_indent (indent + 2);\n-      printf (\"  fatal_insn_not_found (insn);\\n\");\n+      write_indent (outf, indent);\n+      fprintf (outf, \"case -1:\\n\");\n+      write_indent (outf, indent + 2);\n+      fprintf (outf, \"if (GET_CODE (PATTERN (insn)) != ASM_INPUT\\n\");\n+      write_indent (outf, indent + 2);\n+      fprintf (outf, \"    && asm_noperands (PATTERN (insn)) < 0)\\n\");\n+      write_indent (outf, indent + 2);\n+      fprintf (outf, \"  fatal_insn_not_found (insn);\\n\");\n     }\n \n   if (write_case_lines)\n-    write_insn_cases (av->first_insn, indent);\n+    write_insn_cases (outf, av->first_insn, indent);\n   else\n     {\n-      write_indent (indent);\n-      printf (\"default:\\n\");\n+      write_indent (outf, indent);\n+      fprintf (outf, \"default:\\n\");\n     }\n \n   /* See what we have to do to output this value.  */\n@@ -4103,85 +4126,85 @@ write_attr_case (struct attr_desc *attr, struct attr_value *av,\n \n   if (must_constrain)\n     {\n-      write_indent (indent + 2);\n-      printf (\"extract_constrain_insn_cached (insn);\\n\");\n+      write_indent (outf, indent + 2);\n+      fprintf (outf, \"extract_constrain_insn_cached (insn);\\n\");\n     }\n   else if (must_extract)\n     {\n-      write_indent (indent + 2);\n-      printf (\"extract_insn_cached (insn);\\n\");\n+      write_indent (outf, indent + 2);\n+      fprintf (outf, \"extract_insn_cached (insn);\\n\");\n     }\n \n   attrs_to_cache = 0;\n   if (av->num_insns == 1)\n-    write_attr_set (attr, indent + 2, av->value, prefix, suffix,\n+    write_attr_set (outf, attr, indent + 2, av->value, prefix, suffix,\n \t\t    known_true, av->first_insn->def->insn_code,\n \t\t    av->first_insn->def->insn_index, 0);\n   else\n-    write_attr_set (attr, indent + 2, av->value, prefix, suffix,\n+    write_attr_set (outf, attr, indent + 2, av->value, prefix, suffix,\n \t\t    known_true, -2, 0, 0);\n \n   if (strncmp (prefix, \"return\", 6))\n     {\n-      write_indent (indent + 2);\n-      printf (\"break;\\n\");\n+      write_indent (outf, indent + 2);\n+      fprintf (outf, \"break;\\n\");\n     }\n-  printf (\"\\n\");\n+  fprintf (outf, \"\\n\");\n }\n \n /* Utilities to write in various forms.  */\n \n static void\n-write_attr_valueq (struct attr_desc *attr, const char *s)\n+write_attr_valueq (FILE *outf, struct attr_desc *attr, const char *s)\n {\n   if (attr->is_numeric)\n     {\n       int num = atoi (s);\n \n-      printf (\"%d\", num);\n+      fprintf (outf, \"%d\", num);\n \n       if (num > 9 || num < 0)\n-\tprintf (\" /* %#x */\", num);\n+\tfprintf (outf, \" /* %#x */\", num);\n     }\n   else\n     {\n-      write_upcase (attr->enum_name ? attr->enum_name : attr->name);\n-      printf (\"_\");\n-      write_upcase (s);\n+      write_upcase (outf, attr->enum_name ? attr->enum_name : attr->name);\n+      fprintf (outf, \"_\");\n+      write_upcase (outf, s);\n     }\n }\n \n static void\n-write_attr_value (struct attr_desc *attr, rtx value)\n+write_attr_value (FILE *outf, struct attr_desc *attr, rtx value)\n {\n   int op;\n \n   switch (GET_CODE (value))\n     {\n     case CONST_STRING:\n-      write_attr_valueq (attr, XSTR (value, 0));\n+      write_attr_valueq (outf, attr, XSTR (value, 0));\n       break;\n \n     case CONST_INT:\n-      printf (HOST_WIDE_INT_PRINT_DEC, INTVAL (value));\n+      fprintf (outf, HOST_WIDE_INT_PRINT_DEC, INTVAL (value));\n       break;\n \n     case SYMBOL_REF:\n-      print_c_condition (XSTR (value, 0));\n+      fprint_c_condition (outf, XSTR (value, 0));\n       break;\n \n     case ATTR:\n       {\n \tstruct attr_desc *attr2 = find_attr (&XSTR (value, 0), 0);\n \tif (attr->enum_name)\n-\t  printf (\"(enum %s)\", attr->enum_name);\n+\t  fprintf (outf, \"(enum %s)\", attr->enum_name);\n \telse if (!attr->is_numeric)\n-\t  printf (\"(enum attr_%s)\", attr->name);\n+\t  fprintf (outf, \"(enum attr_%s)\", attr->name);\n \telse if (!attr2->is_numeric)\n-\t  printf (\"(int)\");\n+\t  fprintf (outf, \"(int)\");\n \n-\tprintf (\"get_attr_%s (%s)\", attr2->name,\n-\t\t(attr2->is_const ? \"\" : \"insn\"));\n+\tfprintf (outf, \"get_attr_%s (%s)\", attr2->name,\n+\t\t (attr2->is_const ? \"\" : \"insn\"));\n       }\n       break;\n \n@@ -4202,11 +4225,11 @@ write_attr_value (struct attr_desc *attr, rtx value)\n       goto do_operator;\n \n     do_operator:\n-      write_attr_value (attr, XEXP (value, 0));\n-      putchar (' ');\n-      putchar (op);\n-      putchar (' ');\n-      write_attr_value (attr, XEXP (value, 1));\n+      write_attr_value (outf, attr, XEXP (value, 0));\n+      fputc (' ', outf);\n+      fputc (op,  outf);\n+      fputc (' ', outf);\n+      write_attr_value (outf, attr, XEXP (value, 1));\n       break;\n \n     default:\n@@ -4215,24 +4238,24 @@ write_attr_value (struct attr_desc *attr, rtx value)\n }\n \n static void\n-write_upcase (const char *str)\n+write_upcase (FILE *outf, const char *str)\n {\n   while (*str)\n     {\n       /* The argument of TOUPPER should not have side effects.  */\n-      putchar (TOUPPER(*str));\n+      fputc (TOUPPER(*str), outf);\n       str++;\n     }\n }\n \n static void\n-write_indent (int indent)\n+write_indent (FILE *outf, int indent)\n {\n   for (; indent > 8; indent -= 8)\n-    printf (\"\\t\");\n+    fprintf (outf, \"\\t\");\n \n   for (; indent; indent--)\n-    printf (\" \");\n+    fprintf (outf, \" \");\n }\n \n /* Write a subroutine that is given an insn that requires a delay slot, a\n@@ -4248,7 +4271,7 @@ write_indent (int indent)\n    or \"annul_false\").  */\n \n static void\n-write_eligible_delay (const char *kind)\n+write_eligible_delay (FILE *outf, const char *kind)\n {\n   struct delay_desc *delay;\n   int max_slots;\n@@ -4268,19 +4291,20 @@ write_eligible_delay (const char *kind)\n \n   /* Write function prelude.  */\n \n-  printf (\"int\\n\");\n-  printf (\"eligible_for_%s (rtx delay_insn ATTRIBUTE_UNUSED, int slot, rtx candidate_insn, int flags ATTRIBUTE_UNUSED)\\n\",\n-\t  kind);\n-  printf (\"{\\n\");\n-  printf (\"  rtx insn;\\n\");\n-  printf (\"\\n\");\n-  printf (\"  gcc_assert (slot < %d);\\n\", max_slots);\n-  printf (\"\\n\");\n+  fprintf (outf, \"int\\n\");\n+  fprintf (outf, \"eligible_for_%s (rtx delay_insn ATTRIBUTE_UNUSED, int slot, \\n\"\n+\t\t \"\t\t   rtx candidate_insn, int flags ATTRIBUTE_UNUSED)\\n\",\n+\t   kind);\n+  fprintf (outf, \"{\\n\");\n+  fprintf (outf, \"  rtx insn;\\n\");\n+  fprintf (outf, \"\\n\");\n+  fprintf (outf, \"  gcc_assert (slot < %d);\\n\", max_slots);\n+  fprintf (outf, \"\\n\");\n   /* Allow dbr_schedule to pass labels, etc.  This can happen if try_split\n      converts a compound instruction into a loop.  */\n-  printf (\"  if (!INSN_P (candidate_insn))\\n\");\n-  printf (\"    return 0;\\n\");\n-  printf (\"\\n\");\n+  fprintf (outf, \"  if (!INSN_P (candidate_insn))\\n\");\n+  fprintf (outf, \"    return 0;\\n\");\n+  fprintf (outf, \"\\n\");\n \n   /* If more than one delay type, find out which type the delay insn is.  */\n \n@@ -4290,56 +4314,56 @@ write_eligible_delay (const char *kind)\n       gcc_assert (attr);\n       common_av = find_most_used (attr);\n \n-      printf (\"  insn = delay_insn;\\n\");\n-      printf (\"  switch (recog_memoized (insn))\\n\");\n-      printf (\"    {\\n\");\n+      fprintf (outf, \"  insn = delay_insn;\\n\");\n+      fprintf (outf, \"  switch (recog_memoized (insn))\\n\");\n+      fprintf (outf, \"    {\\n\");\n \n       sprintf (str, \" * %d;\\n      break;\", max_slots);\n       for (av = attr->first_value; av; av = av->next)\n \tif (av != common_av)\n-\t  write_attr_case (attr, av, 1, \"slot +=\", str, 4, true_rtx);\n+\t  write_attr_case (outf, attr, av, 1, \"slot +=\", str, 4, true_rtx);\n \n-      write_attr_case (attr, common_av, 0, \"slot +=\", str, 4, true_rtx);\n-      printf (\"    }\\n\\n\");\n+      write_attr_case (outf, attr, common_av, 0, \"slot +=\", str, 4, true_rtx);\n+      fprintf (outf, \"    }\\n\\n\");\n \n       /* Ensure matched.  Otherwise, shouldn't have been called.  */\n-      printf (\"  gcc_assert (slot >= %d);\\n\\n\", max_slots);\n+      fprintf (outf, \"  gcc_assert (slot >= %d);\\n\\n\", max_slots);\n     }\n \n   /* If just one type of delay slot, write simple switch.  */\n   if (num_delays == 1 && max_slots == 1)\n     {\n-      printf (\"  insn = candidate_insn;\\n\");\n-      printf (\"  switch (recog_memoized (insn))\\n\");\n-      printf (\"    {\\n\");\n+      fprintf (outf, \"  insn = candidate_insn;\\n\");\n+      fprintf (outf, \"  switch (recog_memoized (insn))\\n\");\n+      fprintf (outf, \"    {\\n\");\n \n       attr = find_attr (&delay_1_0_str, 0);\n       gcc_assert (attr);\n       common_av = find_most_used (attr);\n \n       for (av = attr->first_value; av; av = av->next)\n \tif (av != common_av)\n-\t  write_attr_case (attr, av, 1, \"return\", \";\", 4, true_rtx);\n+\t  write_attr_case (outf, attr, av, 1, \"return\", \";\", 4, true_rtx);\n \n-      write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n-      printf (\"    }\\n\");\n+      write_attr_case (outf, attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n+      fprintf (outf, \"    }\\n\");\n     }\n \n   else\n     {\n       /* Write a nested CASE.  The first indicates which condition we need to\n \t test, and the inner CASE tests the condition.  */\n-      printf (\"  insn = candidate_insn;\\n\");\n-      printf (\"  switch (slot)\\n\");\n-      printf (\"    {\\n\");\n+      fprintf (outf, \"  insn = candidate_insn;\\n\");\n+      fprintf (outf, \"  switch (slot)\\n\");\n+      fprintf (outf, \"    {\\n\");\n \n       for (delay = delays; delay; delay = delay->next)\n \tfor (i = 0; i < XVECLEN (delay->def, 1); i += 3)\n \t  {\n-\t    printf (\"    case %d:\\n\",\n-\t\t    (i / 3) + (num_delays == 1 ? 0 : delay->num * max_slots));\n-\t    printf (\"      switch (recog_memoized (insn))\\n\");\n-\t    printf (\"\\t{\\n\");\n+\t    fprintf (outf, \"    case %d:\\n\",\n+\t\t     (i / 3) + (num_delays == 1 ? 0 : delay->num * max_slots));\n+\t    fprintf (outf, \"      switch (recog_memoized (insn))\\n\");\n+\t    fprintf (outf, \"\\t{\\n\");\n \n \t    sprintf (str, \"*%s_%d_%d\", kind, delay->num, i / 3);\n \t    pstr = str;\n@@ -4349,18 +4373,18 @@ write_eligible_delay (const char *kind)\n \n \t    for (av = attr->first_value; av; av = av->next)\n \t      if (av != common_av)\n-\t\twrite_attr_case (attr, av, 1, \"return\", \";\", 8, true_rtx);\n+\t\twrite_attr_case (outf, attr, av, 1, \"return\", \";\", 8, true_rtx);\n \n-\t    write_attr_case (attr, common_av, 0, \"return\", \";\", 8, true_rtx);\n-\t    printf (\"      }\\n\");\n+\t    write_attr_case (outf, attr, common_av, 0, \"return\", \";\", 8, true_rtx);\n+\t    fprintf (outf, \"      }\\n\");\n \t  }\n \n-      printf (\"    default:\\n\");\n-      printf (\"      gcc_unreachable ();\\n\");\n-      printf (\"    }\\n\");\n+      fprintf (outf, \"    default:\\n\");\n+      fprintf (outf, \"      gcc_unreachable ();\\n\");\n+      fprintf (outf, \"    }\\n\");\n     }\n \n-  printf (\"}\\n\\n\");\n+  fprintf (outf, \"}\\n\\n\");\n }\n \n /* This page contains miscellaneous utility routines.  */\n@@ -4499,29 +4523,29 @@ copy_rtx_unchanging (rtx orig)\n    number of delay slots is not a function of the length of the insn.  */\n \n static void\n-write_const_num_delay_slots (void)\n+write_const_num_delay_slots (FILE *outf)\n {\n   struct attr_desc *attr = find_attr (&num_delay_slots_str, 0);\n   struct attr_value *av;\n \n   if (attr)\n     {\n-      printf (\"int\\nconst_num_delay_slots (rtx insn)\\n\");\n-      printf (\"{\\n\");\n-      printf (\"  switch (recog_memoized (insn))\\n\");\n-      printf (\"    {\\n\");\n+      fprintf (outf, \"int\\nconst_num_delay_slots (rtx insn)\\n\");\n+      fprintf (outf, \"{\\n\");\n+      fprintf (outf, \"  switch (recog_memoized (insn))\\n\");\n+      fprintf (outf, \"    {\\n\");\n \n       for (av = attr->first_value; av; av = av->next)\n \t{\n \t  length_used = 0;\n \t  walk_attr_value (av->value);\n \t  if (length_used)\n-\t    write_insn_cases (av->first_insn, 4);\n+\t    write_insn_cases (outf, av->first_insn, 4);\n \t}\n \n-      printf (\"    default:\\n\");\n-      printf (\"      return 1;\\n\");\n-      printf (\"    }\\n}\\n\\n\");\n+      fprintf (outf, \"    default:\\n\");\n+      fprintf (outf, \"      return 1;\\n\");\n+      fprintf (outf, \"    }\\n}\\n\\n\");\n     }\n }\n \f\n@@ -4697,7 +4721,10 @@ find_tune_attr (rtx exp)\n     }\n }\n \n-/* Create all of the attributes that describe automaton properties.  */\n+/* Create all of the attributes that describe automaton properties.\n+   Write the DFA and latency function prototypes to  the files that\n+   need to have them, and write the init_sched_attrs().  */\n+\n static void\n make_automaton_attrs (void)\n {\n@@ -4719,23 +4746,49 @@ make_automaton_attrs (void)\n       gcc_assert (tune_attr->is_const\n \t\t  && !tune_attr->is_special\n \t\t  && !tune_attr->is_numeric);\n+\n+      /* Write the prototypes for all DFA functions.  */\n+      for (val = tune_attr->first_value; val; val = val->next)\n+\t{\n+\t  if (val == tune_attr->default_val)\n+\t    continue;\n+\t  gcc_assert (GET_CODE (val->value) == CONST_STRING);\n+\t  fprintf (dfa_file,\n+\t\t   \"extern int internal_dfa_insn_code_%s (rtx);\\n\",\n+\t\t   XSTR (val->value, 0));\n+\t}\n+      fprintf (dfa_file, \"\\n\");\n+\n+      /* Write the prototypes for all latency functions.  */\n       for (val = tune_attr->first_value; val; val = val->next)\n \t{\n \t  if (val == tune_attr->default_val)\n \t    continue;\n \t  gcc_assert (GET_CODE (val->value) == CONST_STRING);\n-\t  printf (\"static int internal_dfa_insn_code_%s (rtx);\\n\"\n-\t\t  \"static int insn_default_latency_%s (rtx);\\n\",\n-\t\t  XSTR (val->value, 0), XSTR (val->value, 0));\n+\t  fprintf (latency_file,\n+\t\t   \"extern int insn_default_latency_%s (rtx);\\n\",\n+\t\t   XSTR (val->value, 0));\n \t}\n+      fprintf (latency_file, \"\\n\");\n \n-      printf (\"\\n\");\n-      printf (\"int (*internal_dfa_insn_code) (rtx);\\n\");\n-      printf (\"int (*insn_default_latency) (rtx);\\n\");\n-      printf (\"\\n\");\n-      printf (\"void\\n\");\n-      printf (\"init_sched_attrs (void)\\n\");\n-      printf (\"{\\n\");\n+      /* Write the prototypes for all automaton functions.  */\n+      for (val = tune_attr->first_value; val; val = val->next)\n+\t{\n+\t  if (val == tune_attr->default_val)\n+\t    continue;\n+\t  gcc_assert (GET_CODE (val->value) == CONST_STRING);\n+\t  fprintf (attr_file,\n+\t\t   \"extern int internal_dfa_insn_code_%s (rtx);\\n\"\n+\t\t   \"extern int insn_default_latency_%s (rtx);\\n\",\n+\t\t   XSTR (val->value, 0), XSTR (val->value, 0));\n+\t}\n+      fprintf (attr_file, \"\\n\");\n+      fprintf (attr_file, \"int (*internal_dfa_insn_code) (rtx);\\n\");\n+      fprintf (attr_file, \"int (*insn_default_latency) (rtx);\\n\");\n+      fprintf (attr_file, \"\\n\");\n+      fprintf (attr_file, \"void\\n\");\n+      fprintf (attr_file, \"init_sched_attrs (void)\\n\");\n+      fprintf (attr_file, \"{\\n\");\n \n       for (val = tune_attr->first_value; val; val = val->next)\n \t{\n@@ -4804,27 +4857,27 @@ make_automaton_attrs (void)\n \n \t  if (first)\n \t    {\n-\t      printf (\"  if (\");\n+\t      fprintf (attr_file, \"  if (\");\n \t      first = false;\n \t    }\n \t  else\n-\t    printf (\"  else if (\");\n-\t  write_test_expr (test, 0, 0);\n-\t  printf (\")\\n\");\n-\t  printf (\"    {\\n\");\n-\t  printf (\"      internal_dfa_insn_code\\n\");\n-\t  printf (\"        = internal_dfa_insn_code_%s;\\n\",\n-\t\t  XSTR (val->value, 0));\n-\t  printf (\"      insn_default_latency\\n\");\n-\t  printf (\"        = insn_default_latency_%s;\\n\",\n-\t\t  XSTR (val->value, 0));\n-\t  printf (\"    }\\n\");\n+\t    fprintf (attr_file, \"  else if (\");\n+\t  write_test_expr (attr_file, test, 0, 0);\n+\t  fprintf (attr_file, \")\\n\");\n+\t  fprintf (attr_file, \"    {\\n\");\n+\t  fprintf (attr_file, \"      internal_dfa_insn_code\\n\");\n+\t  fprintf (attr_file, \"        = internal_dfa_insn_code_%s;\\n\",\n+\t\t   XSTR (val->value, 0));\n+\t  fprintf (attr_file, \"      insn_default_latency\\n\");\n+\t  fprintf (attr_file, \"        = insn_default_latency_%s;\\n\",\n+\t\t   XSTR (val->value, 0));\n+\t  fprintf (attr_file, \"    }\\n\");\n \t}\n \n-      printf (\"  else\\n\");\n-      printf (\"    gcc_unreachable ();\\n\");\n-      printf (\"}\\n\");\n-      printf (\"\\n\");\n+      fprintf (attr_file, \"  else\\n\");\n+      fprintf (attr_file, \"    gcc_unreachable ();\\n\");\n+      fprintf (attr_file, \"}\\n\");\n+      fprintf (attr_file, \"\\n\");\n \n       XDELETEVEC (condexps);\n     }\n@@ -4874,7 +4927,62 @@ make_automaton_attrs (void)\n \t  }\n     }\n \n-  make_internal_attr (\"*bypass_p\",               byps_exp, ATTR_NONE);\n+  make_internal_attr (\"*bypass_p\", byps_exp, ATTR_NONE);\n+}\n+\n+static void\n+write_header (FILE *outf)\n+{\n+  fprintf (outf, \"/* Generated automatically by the program `genattrtab'\\n\"\n+\t         \"   from the machine description file `md'.  */\\n\\n\");\n+\n+  fprintf (outf, \"#include \\\"config.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"system.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"coretypes.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"tm.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"rtl.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"insn-attr.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"tm_p.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"insn-config.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"recog.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"regs.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"real.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"output.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"toplev.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"flags.h\\\"\\n\");\n+  fprintf (outf, \"#include \\\"function.h\\\"\\n\");\n+  fprintf (outf, \"\\n\");\n+  fprintf (outf, \"#define operands recog_data.operand\\n\\n\");\n+}\n+\n+static FILE *\n+open_outfile (const char *file_name)\n+{\n+  FILE *outf;\n+  outf = fopen (file_name, \"w\");\n+  if (! outf)\n+    fatal (\"cannot open file %s: %s\", file_name, xstrerror (errno));\n+  write_header (outf);\n+  return outf;\n+}\n+\n+static bool\n+handle_arg (const char *arg)\n+{\n+  switch (arg[1])\n+    {\n+    case 'A':\n+      attr_file_name = &arg[2];\n+      return true;\n+    case 'D':\n+      dfa_file_name = &arg[2];\n+      return true;\n+    case 'L':\n+      latency_file_name = &arg[2];\n+      return true;\n+    default:\n+      return false;\n+    }\n }\n \n int\n@@ -4888,8 +4996,12 @@ main (int argc, char **argv)\n \n   progname = \"genattrtab\";\n \n-  if (!init_rtx_reader_args (argc, argv))\n-    return (FATAL_EXIT_CODE);\n+  if (!init_rtx_reader_args_cb (argc, argv, handle_arg))\n+    return FATAL_EXIT_CODE;\n+\n+  attr_file = open_outfile (attr_file_name);\n+  dfa_file = open_outfile (dfa_file_name);\n+  latency_file = open_outfile (latency_file_name);\n \n   obstack_init (hash_obstack);\n   obstack_init (temp_obstack);\n@@ -4908,9 +5020,6 @@ main (int argc, char **argv)\n   delay_1_0_str = DEF_ATTR_STRING (\"*delay_1_0\");\n   num_delay_slots_str = DEF_ATTR_STRING (\"*num_delay_slots\");\n \n-  printf (\"/* Generated automatically by the program `genattrtab'\\n\\\n-from the machine description file `md'.  */\\n\\n\");\n-\n   /* Read the machine description.  */\n \n   while (1)\n@@ -4970,23 +5079,6 @@ from the machine description file `md'.  */\\n\\n\");\n   if (num_delays)\n     expand_delays ();\n \n-  printf (\"#include \\\"config.h\\\"\\n\");\n-  printf (\"#include \\\"system.h\\\"\\n\");\n-  printf (\"#include \\\"coretypes.h\\\"\\n\");\n-  printf (\"#include \\\"tm.h\\\"\\n\");\n-  printf (\"#include \\\"rtl.h\\\"\\n\");\n-  printf (\"#include \\\"insn-attr.h\\\"\\n\");\n-  printf (\"#include \\\"tm_p.h\\\"\\n\");\n-  printf (\"#include \\\"insn-config.h\\\"\\n\");\n-  printf (\"#include \\\"recog.h\\\"\\n\");\n-  printf (\"#include \\\"regs.h\\\"\\n\");\n-  printf (\"#include \\\"output.h\\\"\\n\");\n-  printf (\"#include \\\"diagnostic-core.h\\\"\\n\");\n-  printf (\"#include \\\"flags.h\\\"\\n\");\n-  printf (\"#include \\\"function.h\\\"\\n\");\n-  printf (\"\\n\");\n-  printf (\"#define operands recog_data.operand\\n\\n\");\n-\n   /* Make `insn_alternatives'.  */\n   insn_alternatives = oballocvec (int, insn_code_number);\n   for (id = defs; id; id = id->next)\n@@ -5031,27 +5123,45 @@ from the machine description file `md'.  */\\n\\n\");\n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n       {\n+        FILE *outf;\n+\n+#define IS_ATTR_GROUP(X) (!strncmp(attr->name,X,strlen(X)))\n+\tif (IS_ATTR_GROUP (\"*internal_dfa_insn_code\"))\n+\t  outf = dfa_file;\n+\telse if (IS_ATTR_GROUP (\"*insn_default_latency\"))\n+\t  outf = latency_file;  \n+\telse\n+\t  outf = attr_file;\n+#undef IS_ATTR_GROUP\n+\n \tif (! attr->is_special && ! attr->is_const)\n-\t  write_attr_get (attr);\n+\t  write_attr_get (outf, attr);\n       }\n \n   /* Write out delay eligibility information, if DEFINE_DELAY present.\n      (The function to compute the number of delay slots will be written\n      below.)  */\n   if (num_delays)\n     {\n-      write_eligible_delay (\"delay\");\n+      write_eligible_delay (attr_file, \"delay\");\n       if (have_annul_true)\n-\twrite_eligible_delay (\"annul_true\");\n+\twrite_eligible_delay (attr_file, \"annul_true\");\n       if (have_annul_false)\n-\twrite_eligible_delay (\"annul_false\");\n+\twrite_eligible_delay (attr_file, \"annul_false\");\n     }\n \n   /* Write out constant delay slot info.  */\n-  write_const_num_delay_slots ();\n+  write_const_num_delay_slots (attr_file);\n \n-  write_length_unit_log ();\n+  write_length_unit_log (attr_file);\n \n-  fflush (stdout);\n-  return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  if (fclose (attr_file) != 0)\n+    fatal (\"cannot close file %s: %s\", attr_file_name, xstrerror (errno));\n+  if (fclose (dfa_file) != 0)\n+    fatal (\"cannot close file %s: %s\", dfa_file_name, xstrerror (errno));\n+  if (fclose (latency_file) != 0)\n+    fatal (\"cannot close file %s: %s\", latency_file_name, xstrerror (errno));\n+\n+  return SUCCESS_EXIT_CODE;\n }\n+"}, {"sha": "e5534d75d48d0f2c5f21986e65eb4cfa9812db31", "filename": "gcc/read-md.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=417232534c60b32da5f064631974dbcb9c70bf05", "patch": "@@ -167,14 +167,21 @@ copy_md_ptr_loc (const void *new_ptr, const void *old_ptr)\n }\n \n /* If PTR is associated with a known file position, print a #line\n-   directive for it.  */\n+   directive for it to OUTF.  */\n \n void\n-print_md_ptr_loc (const void *ptr)\n+fprint_md_ptr_loc (FILE *outf, const void *ptr)\n {\n   const struct ptr_loc *loc = get_md_ptr_loc (ptr);\n   if (loc != 0)\n-    printf (\"#line %d \\\"%s\\\"\\n\", loc->lineno, loc->filename);\n+    fprintf (outf, \"#line %d \\\"%s\\\"\\n\", loc->lineno, loc->filename);\n+}\n+\n+/* Special fprint_md_ptr_loc for writing to STDOUT.  */\n+void\n+print_md_ptr_loc (const void *ptr)\n+{\n+  fprint_md_ptr_loc (stdout, ptr);\n }\n \n /* Return a condition that satisfies both COND1 and COND2.  Either string\n@@ -204,31 +211,39 @@ join_c_conditions (const char *cond1, const char *cond2)\n   return result;\n }\n \n-/* Print condition COND, wrapped in brackets.  If COND was created by\n-   join_c_conditions, recursively invoke this function for the original\n+/* Print condition COND to OUTF, wrapped in brackets.  If COND was created\n+   by join_c_conditions, recursively invoke this function for the original\n    conditions and join the result with \"&&\".  Otherwise print a #line\n    directive for COND if its original file position is known.  */\n \n void\n-print_c_condition (const char *cond)\n+fprint_c_condition (FILE *outf, const char *cond)\n {\n   const char **halves = (const char **) htab_find (joined_conditions, &cond);\n   if (halves != 0)\n     {\n-      printf (\"(\");\n-      print_c_condition (halves[1]);\n-      printf (\" && \");\n-      print_c_condition (halves[2]);\n-      printf (\")\");\n+      fprintf (outf, \"(\");\n+      fprint_c_condition (outf, halves[1]);\n+      fprintf (outf, \" && \");\n+      fprint_c_condition (outf, halves[2]);\n+      fprintf (outf, \")\");\n     }\n   else\n     {\n-      putc ('\\n', stdout);\n-      print_md_ptr_loc (cond);\n-      printf (\"(%s)\", cond);\n+      fputc ('\\n', outf);\n+      fprint_md_ptr_loc (outf, cond);\n+      fprintf (outf, \"(%s)\", cond);\n     }\n }\n \n+/* Special fprint_c_condition for writing to STDOUT.  */\n+\n+void\n+print_c_condition (const char *cond)\n+{\n+  fprint_c_condition (stdout, cond);\n+}\n+\n /* A vfprintf-like function for reporting an error against line LINENO\n    of the current MD file.  */\n "}, {"sha": "43dfc44736dff3e2e8d53a69cea3efe4cc9cacb1", "filename": "gcc/read-md.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417232534c60b32da5f064631974dbcb9c70bf05/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=417232534c60b32da5f064631974dbcb9c70bf05", "patch": "@@ -118,8 +118,10 @@ extern hashval_t leading_string_hash (const void *);\n extern int leading_string_eq_p (const void *, const void *);\n extern void copy_md_ptr_loc (const void *, const void *);\n extern void print_md_ptr_loc (const void *);\n+extern void fprint_md_ptr_loc (FILE *, const void *);\n extern const char *join_c_conditions (const char *, const char *);\n extern void print_c_condition (const char *);\n+extern void fprint_c_condition (FILE *, const char *);\n extern void message_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void error_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void fatal_with_file_and_line (const char *, ...)"}]}