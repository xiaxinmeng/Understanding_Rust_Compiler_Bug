{"sha": "2995860f562f4b6344e6ab81cd387d16f769a13a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk5NTg2MGY1NjJmNGI2MzQ0ZTZhYjgxY2QzODdkMTZmNzY5YTEzYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:48:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:48:04Z"}, "message": "[multiple changes]\n\n2013-04-25  Yannick Moy  <moy@adacore.com>\n\n\t* exp_spark.adb (Expand_SPARK_N_In): Remove procedure.\n\t(Expand_SPARK): Remove special expansion for membership tests.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Update all places\n\tthat should use constant Base_Typ. When building an invariant\n\tcheck, account for invariants coming from the base type. Prevent\n\tthe creation of a junk invariant check when the related object\n\tis of an array type and it is initialized with an aggregate.\n\t* exp_util.adb (Make_Invariant_Call): Typ is now a variable. Use\n\tthe base type to create an invariant call when the type of the\n\texpression is a composite subtype.\n\n2013-04-25  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* a-cborse.adb: Fix minor typo.\n\n2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Different_Generic_Profile): A spec and body\n\tmatch in an instance if a subtype declaration that renames a\n\tgeneric actual with the same name appears between spec and body.\n\nFrom-SVN: r198294", "tree": {"sha": "7705ec60d5613197c0b1dccdcb44c85060c0b2c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7705ec60d5613197c0b1dccdcb44c85060c0b2c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2995860f562f4b6344e6ab81cd387d16f769a13a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2995860f562f4b6344e6ab81cd387d16f769a13a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2995860f562f4b6344e6ab81cd387d16f769a13a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2995860f562f4b6344e6ab81cd387d16f769a13a/comments", "author": null, "committer": null, "parents": [{"sha": "49eef89f35bccc18ff2da56be533eb50ea15a988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49eef89f35bccc18ff2da56be533eb50ea15a988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49eef89f35bccc18ff2da56be533eb50ea15a988"}], "stats": {"total": 166, "additions": 105, "deletions": 61}, "files": [{"sha": "35e3d7372bb0ff585e80e6acdbc2f308c0272bbb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2995860f562f4b6344e6ab81cd387d16f769a13a", "patch": "@@ -1,3 +1,29 @@\n+2013-04-25  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_spark.adb (Expand_SPARK_N_In): Remove procedure.\n+\t(Expand_SPARK): Remove special expansion for membership tests.\n+\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Update all places\n+\tthat should use constant Base_Typ. When building an invariant\n+\tcheck, account for invariants coming from the base type. Prevent\n+\tthe creation of a junk invariant check when the related object\n+\tis of an array type and it is initialized with an aggregate.\n+\t* exp_util.adb (Make_Invariant_Call): Typ is now a variable. Use\n+\tthe base type to create an invariant call when the type of the\n+\texpression is a composite subtype.\n+\n+2013-04-25  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* a-cborse.adb: Fix minor typo.\n+\n+2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Different_Generic_Profile): A spec and body\n+\tmatch in an instance if a subtype declaration that renames a\n+\tgeneric actual with the same name appears between spec and body.\n+\n 2013-04-25  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_util.adb: Minor reformatting."}, {"sha": "baeedba6534169df8f12d909e2321ae0d454bf54", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=2995860f562f4b6344e6ab81cd387d16f769a13a", "patch": "@@ -1815,7 +1815,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          end if;\n \n          --  Item is not equivalent to any other element in the tree\n-         --  (specifically, it is less then Nodes (Hint).Element), so it is\n+         --  (specifically, it is less than Nodes (Hint).Element), so it is\n          --  safe to assign the value of Item to Node.Element. This means that\n          --  the node will have to move to a different position in the tree\n          --  (because its element will have a different value)."}, {"sha": "1e500367625fc95484994519909a99419b7995f4", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2995860f562f4b6344e6ab81cd387d16f769a13a", "patch": "@@ -5035,10 +5035,14 @@ package body Exp_Ch3 is\n          --  with invariants, and invariant checks are enabled, then insert an\n          --  invariant check after the object declaration. Note that it is OK\n          --  to clobber the object with an invalid value since if the exception\n-         --  is raised, then the object will go out of scope.\n+         --  is raised, then the object will go out of scope. In the case where\n+         --  an array object is initialized with an aggregate, the expression\n+         --  is removed. Check flag Has_Init_Expression to avoid generating a\n+         --  junk invariant check.\n \n-         if Has_Invariants (Typ)\n-           and then Present (Invariant_Procedure (Typ))\n+         if Has_Invariants (Base_Typ)\n+           and then Present (Invariant_Procedure (Base_Typ))\n+           and then not Has_Init_Expression (N)\n          then\n             Insert_After (N,\n               Make_Invariant_Call (New_Occurrence_Of (Def_Id, Loc)));\n@@ -5052,18 +5056,14 @@ package body Exp_Ch3 is\n          --  Initialize call as it is required but one for each ancestor of\n          --  its type. This processing is suppressed if No_Initialization set.\n \n-         if not Needs_Finalization (Typ)\n-           or else No_Initialization (N)\n-         then\n+         if not Needs_Finalization (Typ) or else No_Initialization (N) then\n             null;\n \n-         elsif not Abort_Allowed\n-           or else not Comes_From_Source (N)\n-         then\n+         elsif not Abort_Allowed or else not Comes_From_Source (N) then\n             Insert_Action_After (Init_After,\n               Make_Init_Call\n                 (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                 Typ     => Base_Type (Typ)));\n+                 Typ     => Base_Typ));\n \n          --  Abort allowed\n \n@@ -5086,7 +5086,7 @@ package body Exp_Ch3 is\n                L   : constant List_Id := New_List (\n                        Make_Init_Call\n                          (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                          Typ     => Base_Type (Typ)));\n+                          Typ     => Base_Typ));\n \n                Blk : constant Node_Id :=\n                        Make_Block_Statement (Loc,\n@@ -5558,7 +5558,7 @@ package body Exp_Ch3 is\n                Insert_Action_After (Init_After,\n                  Make_Adjust_Call (\n                    Obj_Ref => New_Reference_To (Def_Id, Loc),\n-                   Typ     => Base_Type (Typ)));\n+                   Typ     => Base_Typ));\n             end if;\n \n             --  For tagged types, when an init value is given, the tag has to"}, {"sha": "0050799a104283321bb94187e886d40049b1c9fa", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=2995860f562f4b6344e6ab81cd387d16f769a13a", "patch": "@@ -30,7 +30,6 @@ with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Util; use Exp_Util;\n-with Nlists;   use Nlists;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Res;  use Sem_Res;\n@@ -55,9 +54,6 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_N_Attribute_Reference (N : Node_Id);\n    --  Expand attributes 'Old and 'Result only\n \n-   procedure Expand_SPARK_N_In (N : Node_Id);\n-   --  Expand set membership into individual ones\n-\n    procedure Expand_SPARK_N_Object_Renaming_Declaration (N : Node_Id);\n    --  Perform name evaluation for a renamed object\n \n@@ -102,9 +98,6 @@ package body Exp_SPARK is\n               N_Identifier    =>\n             Expand_Potential_Renaming (N);\n \n-         when N_In =>\n-            Expand_SPARK_N_In (N);\n-\n          --  A NOT IN B gets transformed to NOT (A IN B). This is the same\n          --  expansion used in the normal case, so shared the code.\n \n@@ -204,17 +197,6 @@ package body Exp_SPARK is\n       end case;\n    end Expand_SPARK_N_Attribute_Reference;\n \n-   -----------------------\n-   -- Expand_SPARK_N_In --\n-   -----------------------\n-\n-   procedure Expand_SPARK_N_In (N : Node_Id) is\n-   begin\n-      if Present (Alternatives (N)) then\n-         Expand_Set_Membership (N);\n-      end if;\n-   end Expand_SPARK_N_In;\n-\n    ------------------------------------------------\n    -- Expand_SPARK_N_Object_Renaming_Declaration --\n    ------------------------------------------------"}, {"sha": "0473bfafc1dc56977c3fb5c6ba61c38f207c7100", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2995860f562f4b6344e6ab81cd387d16f769a13a", "patch": "@@ -5466,11 +5466,24 @@ package body Exp_Util is\n \n    function Make_Invariant_Call (Expr : Node_Id) return Node_Id is\n       Loc : constant Source_Ptr := Sloc (Expr);\n-      Typ : constant Entity_Id  := Etype (Expr);\n+      Typ : Entity_Id;\n \n    begin\n+      Typ := Etype (Expr);\n+\n+      --  Subtypes may be subject to invariants coming from their respective\n+      --  base types.\n+\n+      if Ekind_In (Typ, E_Array_Subtype,\n+                        E_Private_Subtype,\n+                        E_Record_Subtype)\n+      then\n+         Typ := Base_Type (Typ);\n+      end if;\n+\n       pragma Assert\n         (Has_Invariants (Typ) and then Present (Invariant_Procedure (Typ)));\n+\n       return\n         Make_Procedure_Call_Statement (Loc,\n           Name                   =>"}, {"sha": "68edadfafd7fd0ff761b25a190742f477c45e475", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2995860f562f4b6344e6ab81cd387d16f769a13a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2995860f562f4b6344e6ab81cd387d16f769a13a", "patch": "@@ -7547,8 +7547,8 @@ package body Sem_Ch6 is\n               or else Scope (T1) /= Scope (T2);\n \n          --  If T2 is a generic actual type it is declared as the subtype of\n-         --  the actual.  If that actual is itself a subtype we need to use\n-         --  its own base type to check for compatibility.\n+         --  the actual. If that actual is itself a subtype we need to use its\n+         --  own base type to check for compatibility.\n \n          elsif Ekind (BT2) = Ekind (T2) and then BT1 = Base_Type (BT2) then\n             return True;\n@@ -8304,20 +8304,43 @@ package body Sem_Ch6 is\n       function Different_Generic_Profile (E : Entity_Id) return Boolean is\n          F1, F2 : Entity_Id;\n \n+         function Same_Generic_Actual (T1, T2 : Entity_Id) return Boolean;\n+         --  Check that the types of corresponding formals have the same\n+         --  generic actual if any. We have to account for subtypes of a\n+         --  generic formal, declared between a spec and a body, which may\n+         --  appear distinct in an instance but matched in the generic.\n+\n+         -------------------------\n+         -- Same_Generic_Actual --\n+         -------------------------\n+\n+         function Same_Generic_Actual (T1, T2 : Entity_Id) return Boolean is\n+         begin\n+            return Is_Generic_Actual_Type (T1) = Is_Generic_Actual_Type (T2)\n+              or else\n+                (Present (Parent (T1))\n+                  and then Comes_From_Source (Parent (T1))\n+                  and then Nkind (Parent (T1)) = N_Subtype_Declaration\n+                  and then Is_Entity_Name (Subtype_Indication (Parent (T1)))\n+                  and then Entity (Subtype_Indication (Parent (T1))) = T2);\n+         end Same_Generic_Actual;\n+\n+      --  Start of processing for Different_Generic_Profile\n+\n       begin\n-         if Ekind (E) = E_Function\n-           and then Is_Generic_Actual_Type (Etype (E)) /=\n-                    Is_Generic_Actual_Type (Etype (Designator))\n+         if not In_Instance then\n+            return False;\n+\n+         elsif Ekind (E) = E_Function\n+           and then not Same_Generic_Actual (Etype (E), Etype (Designator))\n          then\n             return True;\n          end if;\n \n          F1 := First_Formal (Designator);\n          F2 := First_Formal (E);\n          while Present (F1) loop\n-            if Is_Generic_Actual_Type (Etype (F1)) /=\n-               Is_Generic_Actual_Type (Etype (F2))\n-            then\n+            if not Same_Generic_Actual (Etype (F1), Etype (F2)) then\n                return True;\n             end if;\n \n@@ -8414,7 +8437,7 @@ package body Sem_Ch6 is\n                --  If E is an internal function with a controlling result that\n                --  was created for an operation inherited by a null extension,\n                --  it may be overridden by a body without a previous spec (one\n-               --  more reason why these should be shunned). In that case\n+               --  more reason why these should be shunned). In that case we\n                --  remove the generated body if present, because the current\n                --  one is the explicit overriding.\n \n@@ -8954,9 +8977,9 @@ package body Sem_Ch6 is\n             --  All other node types cannot appear in this context. Strictly\n             --  we should raise a fatal internal error. Instead we just ignore\n             --  the nodes. This means that if anyone makes a mistake in the\n-            --  expander and mucks an expression tree irretrievably, the\n-            --  result will be a failure to detect a (probably very obscure)\n-            --  case of non-conformance, which is better than bombing on some\n+            --  expander and mucks an expression tree irretrievably, the result\n+            --  will be a failure to detect a (probably very obscure) case\n+            --  of non-conformance, which is better than bombing on some\n             --  case where two expressions do in fact conform.\n \n             when others =>\n@@ -9146,8 +9169,8 @@ package body Sem_Ch6 is\n          return Type_Conformant\n                   (Iface_Prim, Prim, Skip_Controlling_Formals => True);\n \n-      --  Case of a function returning an interface, or an access to one.\n-      --  Check that the return types correspond.\n+      --  Case of a function returning an interface, or an access to one. Check\n+      --  that the return types correspond.\n \n       elsif Implements_Interface (Typ, Iface) then\n          if (Ekind (Etype (Prim)) = E_Anonymous_Access_Type)\n@@ -9368,8 +9391,8 @@ package body Sem_Ch6 is\n                   Next_Elmt (Prim_Elt);\n                end loop;\n \n-               --  If no match found, then the new subprogram does not\n-               --  override in the generic (nor in the instance).\n+               --  If no match found, then the new subprogram does not override\n+               --  in the generic (nor in the instance).\n \n                --  If the type in question is not abstract, and the subprogram\n                --  is, this will be an error if the new operation is in the\n@@ -9494,9 +9517,9 @@ package body Sem_Ch6 is\n \n          --  Insert inequality right after equality if it is explicit or after\n          --  the derived type when implicit. These entities are created only\n-         --  for visibility purposes, and eventually replaced in the course of\n-         --  expansion, so they do not need to be attached to the tree and seen\n-         --  by the back-end. Keeping them internal also avoids spurious\n+         --  for visibility purposes, and eventually replaced in the course\n+         --  of expansion, so they do not need to be attached to the tree and\n+         --  seen by the back-end. Keeping them internal also avoids spurious\n          --  freezing problems. The declaration is inserted in the tree for\n          --  analysis, and removed afterwards. If the equality operator comes\n          --  from an explicit declaration, attach the inequality immediately\n@@ -9605,9 +9628,9 @@ package body Sem_Ch6 is\n          New_E : Entity_Id) return Boolean;\n       --  Check whether new subprogram and old subprogram are both inherited\n       --  from subprograms that have distinct dispatch table entries. This can\n-      --  occur with derivations from instances with accidental homonyms.\n-      --  The function is conservative given that the converse is only true\n-      --  within instances that contain accidental overloadings.\n+      --  occur with derivations from instances with accidental homonyms. The\n+      --  function is conservative given that the converse is only true within\n+      --  instances that contain accidental overloadings.\n \n       ------------------------------------\n       -- Check_For_Primitive_Subprogram --\n@@ -10274,8 +10297,8 @@ package body Sem_Ch6 is\n          Check_Dispatching_Operation (S, Empty);\n          Check_For_Primitive_Subprogram (Is_Primitive_Subp);\n \n-         --  If subprogram has an explicit declaration, check whether it\n-         --  has an overriding indicator.\n+         --  If subprogram has an explicit declaration, check whether it has an\n+         --  overriding indicator.\n \n          if Comes_From_Source (S) then\n             Check_Synchronized_Overriding (S, Overridden_Subp);\n@@ -10366,11 +10389,11 @@ package body Sem_Ch6 is\n             if Scope (E) /= Current_Scope then\n                null;\n \n-            --  Ada 2012 (AI05-0165): For internally generated bodies of\n-            --  null procedures locate the internally generated spec. We\n-            --  enforce mode conformance since a tagged type may inherit\n-            --  from interfaces several null primitives which differ only\n-            --  in the mode of the formals.\n+            --  Ada 2012 (AI05-0165): For internally generated bodies of null\n+            --  procedures locate the internally generated spec. We enforce\n+            --  mode conformance since a tagged type may inherit from\n+            --  interfaces several null primitives which differ only in\n+            --  the mode of the formals.\n \n             elsif not Comes_From_Source (S)\n               and then Is_Null_Procedure (S)"}]}