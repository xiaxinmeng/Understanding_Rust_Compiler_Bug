{"sha": "606f928d3805614e8d2307961198706ed9958a76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA2ZjkyOGQzODA1NjE0ZThkMjMwNzk2MTE5ODcwNmVkOTk1OGE3Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-11-11T16:00:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-11-11T16:00:47Z"}, "message": "gimple-ssa-isolate-paths.c (is_divmod_with_given_divisor): New function.\n\n\t* gimple-ssa-isolate-paths.c (is_divmod_with_given_divisor): New\n\tfunction.\n\t(stmt_uses_name_in_undefined_way): New function, extracted from\n\tfind_implicit_erroneous_behavior and extended for div/mod case.\n\t(stmt_uses_0_or_null_in_undefined_way): New function, extracted from\n\tfind_explicit_erroneous_behavior and extended for div/mod case.\n\t(find_implicit_erroneous_behavior): Use new helper function.\n\t(find_explicit_erroneous_behavior): Use new helper function.\n\n\t* gcc.dg/tree-ssa/isolate-6.c: New test.\n\t* gcc.dg/tree-ssa/isolate-7.c: New test.\n\nFrom-SVN: r242075", "tree": {"sha": "4536e26f7282becf16c143a8e48ebf01f2a07b83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4536e26f7282becf16c143a8e48ebf01f2a07b83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/606f928d3805614e8d2307961198706ed9958a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606f928d3805614e8d2307961198706ed9958a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606f928d3805614e8d2307961198706ed9958a76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606f928d3805614e8d2307961198706ed9958a76/comments", "author": null, "committer": null, "parents": [{"sha": "be2789903f67338ffa89ad26b056aae7571c850b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2789903f67338ffa89ad26b056aae7571c850b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be2789903f67338ffa89ad26b056aae7571c850b"}], "stats": {"total": 221, "additions": 173, "deletions": 48}, "files": [{"sha": "65afc8a0947753a7a396ba336926662a2c65b41f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606f928d3805614e8d2307961198706ed9958a76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606f928d3805614e8d2307961198706ed9958a76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=606f928d3805614e8d2307961198706ed9958a76", "patch": "@@ -1,3 +1,14 @@\n+2016-11-11  Jeff Law  <law@redhat.com>\n+\n+\t* gimple-ssa-isolate-paths.c (is_divmod_with_given_divisor): New\n+\tfunction.\n+\t(stmt_uses_name_in_undefined_way): New function, extracted from\n+\tfind_implicit_erroneous_behavior and extended for div/mod case.\n+\t(stmt_uses_0_or_null_in_undefined_way): New function, extracted from\n+\tfind_explicit_erroneous_behavior and extended for div/mod case.\n+\t(find_implicit_erroneous_behavior): Use new helper function.\n+\t(find_explicit_erroneous_behavior): Use new helper function.\n+\n 2016-11-11  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71575"}, {"sha": "84048d3daf9ec382fd335f671045a19b22b2cb9b", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 123, "deletions": 48, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606f928d3805614e8d2307961198706ed9958a76/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606f928d3805614e8d2307961198706ed9958a76/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=606f928d3805614e8d2307961198706ed9958a76", "patch": "@@ -206,6 +206,124 @@ isolate_path (basic_block bb, basic_block duplicate,\n   return duplicate;\n }\n \n+/* Return TRUE if STMT is a div/mod operation using DIVISOR as the divisor.\n+   FALSE otherwise.  */\n+\n+static bool\n+is_divmod_with_given_divisor (gimple *stmt, tree divisor)\n+{\n+  /* Only assignments matter.  */\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  /* Check for every DIV/MOD expression.  */\n+  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+  if (rhs_code == TRUNC_DIV_EXPR\n+      || rhs_code == FLOOR_DIV_EXPR\n+      || rhs_code == CEIL_DIV_EXPR\n+      || rhs_code == EXACT_DIV_EXPR\n+      || rhs_code == ROUND_DIV_EXPR\n+      || rhs_code == TRUNC_MOD_EXPR\n+      || rhs_code == FLOOR_MOD_EXPR\n+      || rhs_code == CEIL_MOD_EXPR\n+      || rhs_code == ROUND_MOD_EXPR)\n+    {\n+      /* Pointer equality is fine when DIVISOR is an SSA_NAME, but\n+\t not sufficient for constants which may have different types.  */\n+      if (operand_equal_p (gimple_assign_rhs2 (stmt), divisor, 0))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* NAME is an SSA_NAME that we have already determined has the value 0 or NULL.\n+\n+   Return TRUE if USE_STMT uses NAME in a way where a 0 or NULL value results\n+   in undefined behavior, FALSE otherwise\n+\n+   LOC is used for issuing diagnostics.  This case represents potential\n+   undefined behavior exposed by path splitting and that's reflected in\n+   the diagnostic.  */\n+\n+bool\n+stmt_uses_name_in_undefined_way (gimple *use_stmt, tree name, location_t loc)\n+{\n+  /* If we are working with a non pointer type, then see\n+     if this use is a DIV/MOD operation using NAME as the\n+     divisor.  */\n+  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n+    {\n+      if (!flag_non_call_exceptions)\n+\treturn is_divmod_with_given_divisor (use_stmt, name);\n+      return false;\n+    }\n+\n+  /* NAME is a pointer, so see if it's used in a context where it must\n+     be non-NULL.  */\n+  bool by_dereference\n+    = infer_nonnull_range_by_dereference (use_stmt, name);\n+\n+  if (by_dereference\n+      || infer_nonnull_range_by_attribute (use_stmt, name))\n+    {\n+\n+      if (by_dereference)\n+\t{\n+\t  warning_at (loc, OPT_Wnull_dereference,\n+\t\t      \"potential null pointer dereference\");\n+\t  if (!flag_isolate_erroneous_paths_dereference)\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (!flag_isolate_erroneous_paths_attribute)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return TRUE if USE_STMT uses 0 or NULL in a context which results in\n+   undefined behavior, FALSE otherwise.\n+\n+   These cases are explicit in the IL.  */\n+\n+bool\n+stmt_uses_0_or_null_in_undefined_way (gimple *stmt)\n+{\n+  if (!flag_non_call_exceptions\n+      && is_divmod_with_given_divisor (stmt, integer_zero_node))\n+    return true;\n+\n+  /* By passing null_pointer_node, we can use the\n+     infer_nonnull_range functions to detect explicit NULL\n+     pointer dereferences and other uses where a non-NULL\n+     value is required.  */\n+\n+  bool by_dereference\n+    = infer_nonnull_range_by_dereference (stmt, null_pointer_node);\n+  if (by_dereference\n+      || infer_nonnull_range_by_attribute (stmt, null_pointer_node))\n+    {\n+      if (by_dereference)\n+\t{\n+\t  location_t loc = gimple_location (stmt);\n+\t  warning_at (loc, OPT_Wnull_dereference,\n+\t\t      \"null pointer dereference\");\n+\t  if (!flag_isolate_erroneous_paths_dereference)\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (!flag_isolate_erroneous_paths_attribute)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Look for PHI nodes which feed statements in the same block where\n    the value of the PHI node implies the statement is erroneous.\n \n@@ -243,11 +361,6 @@ find_implicit_erroneous_behavior (void)\n \t  gphi *phi = si.phi ();\n \t  tree lhs = gimple_phi_result (phi);\n \n-\t  /* If the result is not a pointer, then there is no need to\n- \t     examine the arguments.  */\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t    continue;\n-\n \t  /* PHI produces a pointer result.  See if any of the PHI's\n \t     arguments are NULL.\n \n@@ -315,29 +428,12 @@ find_implicit_erroneous_behavior (void)\n \t\t  if (gimple_bb (use_stmt) != bb)\n \t\t    continue;\n \n-\t\t  bool by_dereference \n-\t\t    = infer_nonnull_range_by_dereference (use_stmt, lhs);\n+\t\t  location_t loc = gimple_location (use_stmt)\n+\t\t    ? gimple_location (use_stmt)\n+\t\t    : gimple_phi_arg_location (phi, i);\n \n-\t\t  if (by_dereference \n-\t\t      || infer_nonnull_range_by_attribute (use_stmt, lhs))\n+\t\t  if (stmt_uses_name_in_undefined_way (use_stmt, lhs, loc))\n \t\t    {\n-\t\t      location_t loc = gimple_location (use_stmt)\n-\t\t\t? gimple_location (use_stmt)\n-\t\t\t: gimple_phi_arg_location (phi, i);\n-\n-\t\t      if (by_dereference)\n-\t\t\t{\n-\t\t\t  warning_at (loc, OPT_Wnull_dereference,\n-\t\t\t\t      \"potential null pointer dereference\");\n-\t\t\t  if (!flag_isolate_erroneous_paths_dereference)\n-\t\t\t    continue;\n-\t\t\t}\n-\t\t      else \n-\t\t\t{\n-\t\t\t  if (!flag_isolate_erroneous_paths_attribute)\n-\t\t\t    continue;\n-\t\t\t}\n-\n \t\t      duplicate = isolate_path (bb, duplicate, e,\n \t\t\t\t\t\tuse_stmt, lhs, false);\n \n@@ -383,29 +479,8 @@ find_explicit_erroneous_behavior (void)\n \t{\n \t  gimple *stmt = gsi_stmt (si);\n \n-\t  /* By passing null_pointer_node, we can use the\n-\t     infer_nonnull_range functions to detect explicit NULL\n-\t     pointer dereferences and other uses where a non-NULL\n-\t     value is required.  */\n-\t  \n-\t  bool by_dereference\n-\t    = infer_nonnull_range_by_dereference (stmt, null_pointer_node);\n-\t  if (by_dereference\n-\t      || infer_nonnull_range_by_attribute (stmt, null_pointer_node))\n+\t  if (stmt_uses_0_or_null_in_undefined_way (stmt))\n \t    {\n-\t      if (by_dereference)\n-\t\t{\n-\t\t  warning_at (gimple_location (stmt), OPT_Wnull_dereference,\n-\t\t\t      \"null pointer dereference\");\n-\t\t  if (!flag_isolate_erroneous_paths_dereference)\n-\t\t    continue;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (!flag_isolate_erroneous_paths_attribute)\n-\t\t    continue;\n-\t\t}\n-\n \t      insert_trap (&si, null_pointer_node);\n \t      bb = gimple_bb (gsi_stmt (si));\n "}, {"sha": "6da1cd87cc91b24a22a4fc27559b992510c2f5f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606f928d3805614e8d2307961198706ed9958a76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606f928d3805614e8d2307961198706ed9958a76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=606f928d3805614e8d2307961198706ed9958a76", "patch": "@@ -1,3 +1,8 @@\n+2016-11-11  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/isolate-6.c: New test.\n+\t* gcc.dg/tree-ssa/isolate-7.c: New test.\n+\n 2016-11-11  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR testsuite/78292"}, {"sha": "ec7c57ac56cbdbb6cac05212718f398813633ac9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606f928d3805614e8d2307961198706ed9958a76/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606f928d3805614e8d2307961198706ed9958a76/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-6.c?ref=606f928d3805614e8d2307961198706ed9958a76", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-isolate-paths\" } */\n+\n+int x, y;\n+\n+static inline int\n+z ()\n+{\n+  return x ? y : 0;\n+}\n+\n+int\n+lower_for (int j)\n+{\n+  return j % z ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"isolate-paths\"} } */\n+"}, {"sha": "e63d5a032c1d88c1a29abc0f47053bbdded9b3c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-7.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606f928d3805614e8d2307961198706ed9958a76/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606f928d3805614e8d2307961198706ed9958a76/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-7.c?ref=606f928d3805614e8d2307961198706ed9958a76", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-isolate-paths\" } */\n+\n+extern int oof ();\n+extern int x;\n+_Bool\n+gcd_of_steps_may_divide_p ()\n+{\n+  long cd = 0, val;\n+  if (x)\n+    cd = oof ();\n+  return val % cd == 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"isolate-paths\"} } */\n+"}]}