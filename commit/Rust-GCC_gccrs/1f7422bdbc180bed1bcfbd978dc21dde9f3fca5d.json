{"sha": "1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY3NDIyYmRiYzE4MGJlZDFiY2ZiZDk3OGRjMjFkZGU5ZjNmY2E1ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-20T20:11:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-20T20:11:25Z"}, "message": "mips.c (dfhigh, [...]): Remove.\n\n        * config/mips/mips.c (dfhigh, dflow, sfhigh, sflow): Remove.\n        (override_options): Do not initialize them.\n        (mips_const_double_ok): Allow no fp constants except zero,\n        and not even that for mips16.\n        (const_float_1_operand): Use dconst1.\n        * config/mips/mips.md (movsf, movsf_internal1, movsf_internal2,\n        movdf, movdf_internal1, movdf_internal1a, movdf_internal2):\n        Don't allow arbitrary constants; fix predicates and C constraint.\n\nFrom-SVN: r57368", "tree": {"sha": "b6ca836dcfa21c14457388a9fb8b674893d5b152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6ca836dcfa21c14457388a9fb8b674893d5b152"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/comments", "author": null, "committer": null, "parents": [{"sha": "6ba085e708d1838ee72fd30e79ef1ca8493133d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba085e708d1838ee72fd30e79ef1ca8493133d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba085e708d1838ee72fd30e79ef1ca8493133d1"}], "stats": {"total": 141, "additions": 38, "deletions": 103}, "files": [{"sha": "0c971ca69d649e611684c2872df608372d13a24e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "patch": "@@ -1,3 +1,14 @@\n+2002-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/mips/mips.c (dfhigh, dflow, sfhigh, sflow): Remove.\n+\t(override_options): Do not initialize them.\n+\t(mips_const_double_ok): Allow no fp constants except zero,\n+\tand not even that for mips16.\n+\t(const_float_1_operand): Use dconst1.\n+\t* config/mips/mips.md (movsf, movsf_internal1, movsf_internal2,\n+\tmovdf, movdf_internal1, movdf_internal1a, movdf_internal2):\n+ \tDon't allow arbitrary constants; fix predicates and C constraint.\n+\n 2002-09-20  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cppmacro.c: Don't warn about function-like macros without"}, {"sha": "1d7157d8d05ae1debdff612b769f5fd245aea274", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 54, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "patch": "@@ -352,11 +352,6 @@ int mips_split_addresses;\n /* Generating calls to position independent functions?  */\n enum mips_abicalls_type mips_abicalls;\n \n-/* High and low marks for floating point values which we will accept\n-   as legitimate constants for LEGITIMATE_CONSTANT_P.  These are\n-   initialized in override_options.  */\n-REAL_VALUE_TYPE dfhigh, dflow, sfhigh, sflow;\n-\n /* Mode used for saving/restoring general purpose registers.  */\n static enum machine_mode gpr_mode;\n \n@@ -821,37 +816,16 @@ mips_const_double_ok (op, mode)\n   if (mode == VOIDmode)\n     return 1;\n \n+  /* We've no zero register in mips16 mode.  */\n+  if (TARGET_MIPS16)\n+    return 0;\n+\n   if (mode != SFmode && mode != DFmode)\n     return 0;\n \n   if (op == CONST0_RTX (mode))\n     return 1;\n \n-  /* ??? li.s does not work right with SGI's Irix 6 assembler.  */\n-  if (mips_abi != ABI_32 && mips_abi != ABI_O64 && mips_abi != ABI_EABI)\n-    return 0;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-\n-  if (REAL_VALUE_ISNAN (d))\n-    return FALSE;\n-\n-  if (REAL_VALUE_NEGATIVE (d))\n-    d = REAL_VALUE_NEGATE (d);\n-\n-  if (mode == DFmode)\n-    {\n-      if (REAL_VALUES_LESS (d, dfhigh)\n-\t  && REAL_VALUES_LESS (dflow, d))\n-\treturn 1;\n-    }\n-  else\n-    {\n-      if (REAL_VALUES_LESS (d, sfhigh)\n-\t  && REAL_VALUES_LESS (sflow, d))\n-\treturn 1;\n-    }\n-\n   return 0;\n }\n \n@@ -863,9 +837,6 @@ const_float_1_operand (op, mode)\n      enum machine_mode mode;\n {\n   REAL_VALUE_TYPE d;\n-  static REAL_VALUE_TYPE onedf;\n-  static REAL_VALUE_TYPE onesf;\n-  static int one_initialized;\n \n   if (GET_CODE (op) != CONST_DOUBLE\n       || mode != GET_MODE (op)\n@@ -874,19 +845,7 @@ const_float_1_operand (op, mode)\n \n   REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n \n-  /* We only initialize these values if we need them, since we will\n-     never get called unless mips_isa >= 4.  */\n-  if (! one_initialized)\n-    {\n-      onedf = REAL_VALUE_ATOF (\"1.0\", DFmode);\n-      onesf = REAL_VALUE_ATOF (\"1.0\", SFmode);\n-      one_initialized = 1;\n-    }\n-\n-  if (mode == DFmode)\n-    return REAL_VALUES_EQUAL (d, onedf);\n-  else\n-    return REAL_VALUES_EQUAL (d, onesf);\n+  return REAL_VALUES_EQUAL (d, dconst1);\n }\n \n /* Return true if a memory load or store of REG plus OFFSET in MODE\n@@ -5310,14 +5269,6 @@ override_options ()\n   else\n     mips16 = 0;\n \n-  /* Initialize the high and low values for legitimate floating point\n-     constants.  Rather than trying to get the accuracy down to the\n-     last bit, just use approximate ranges.  */\n-  dfhigh = REAL_VALUE_ATOF (\"1.0e300\", DFmode);\n-  dflow = REAL_VALUE_ATOF (\"1.0e-300\", DFmode);\n-  sfhigh = REAL_VALUE_ATOF (\"1.0e38\", SFmode);\n-  sflow = REAL_VALUE_ATOF (\"1.0e-38\", SFmode);\n-\n   mips_print_operand_punct['?'] = 1;\n   mips_print_operand_punct['#'] = 1;\n   mips_print_operand_punct['&'] = 1;"}, {"sha": "9d269f5ee68dab41cc9c034aaed4f3c8d99efe17", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=1f7422bdbc180bed1bcfbd978dc21dde9f3fca5d", "patch": "@@ -6402,47 +6402,35 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   if ((reload_in_progress | reload_completed) == 0\n       && !register_operand (operands[0], SFmode)\n-      && !register_operand (operands[1], SFmode)\n-      && (TARGET_MIPS16\n-\t  || ((GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 0)\n-\t       && operands[1] != CONST0_RTX (SFmode))))\n-    {\n-      rtx temp = force_reg (SFmode, operands[1]);\n-      emit_move_insn (operands[0], temp);\n-      DONE;\n-    }\n+      && !nonmemory_operand (operands[1], SFmode))\n+    operands[1] = force_reg (SFmode, operands[1]);\n }\")\n \n (define_insn \"movsf_internal1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,f,f,R,m,*f,*d,*d,*d,*d,*R,*m\")\n-\t(match_operand:SF 1 \"general_operand\" \"f,G,R,Fm,fG,fG,*d,*f,*G*d,*R,*F*m,*d,*d\"))]\n+\t(match_operand:SF 1 \"general_operand\" \"f,G,R,m,fG,fG,*d,*f,*G*d,*R,*m,*d,*d\"))]\n   \"TARGET_HARD_FLOAT\n    && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n-       || operands[1] == CONST0_RTX (SFmode))\"\n+       || nonmemory_operand (operands[1], SFmode))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n   [(set_attr \"type\"\t\"move,xfer,load,load,store,store,xfer,xfer,move,load,load,store,store\")\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4,8,4,8\")])\n \n-\n (define_insn \"movsf_internal2\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,d,d,R,m\")\n-\t(match_operand:SF 1 \"general_operand\" \"      Gd,R,Fm,d,d\"))]\n+\t(match_operand:SF 1 \"general_operand\" \"      Gd,R,m,d,d\"))]\n   \"TARGET_SOFT_FLOAT && !TARGET_MIPS16\n    && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n-       || operands[1] == CONST0_RTX (SFmode))\"\n+       || nonmemory_operand (operands[1], SFmode))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n   [(set_attr \"type\"\t\"move,load,load,store,store\")\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4,4,8,4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,y,d,d,d,R,m\")\n-\t(match_operand:SF 1 \"general_operand\"      \"d,d,y,R,Fm,d,d\"))]\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"d,d,y,R,m,d,d\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n@@ -6462,63 +6450,48 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   if ((reload_in_progress | reload_completed) == 0\n       && !register_operand (operands[0], DFmode)\n-      && !register_operand (operands[1], DFmode)\n-      && (TARGET_MIPS16\n-\t  || ((GET_CODE (operands[1]) != CONST_INT || INTVAL (operands[1]) != 0)\n-\t       && operands[1] != CONST0_RTX (DFmode))))\n-    {\n-      rtx temp = force_reg (DFmode, operands[1]);\n-      emit_move_insn (operands[0], temp);\n-      DONE;\n-    }\n+      && !nonmemory_operand (operands[1], DFmode))\n+    operands[1] = force_reg (DFmode, operands[1]);\n }\")\n \n (define_insn \"movdf_internal1\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,R,To,f,*f,*d,*d,*d,*d,*R,*T\")\n-\t(match_operand:DF 1 \"general_operand\" \"f,R,To,fG,fG,F,*d,*f,*d*G,*R,*T*F,*d,*d\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,R,To,*f,*d,*d,*d,*d,*R,*T\")\n+\t(match_operand:DF 1 \"general_operand\" \"f,R,To,fG,fG,*d,*f,*d*G,*R,*T,*d,*d\"))]\n   \"TARGET_HARD_FLOAT && !(TARGET_FLOAT64 && !TARGET_64BIT)\n    && TARGET_DOUBLE_FLOAT\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n-       || operands[1] == CONST0_RTX (DFmode))\"\n+       || nonmemory_operand (operands[1], DFmode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,load,load,store,store,load,xfer,xfer,move,load,load,store,store\")\n+  [(set_attr \"type\"\t\"move,load,load,store,store,xfer,xfer,move,load,load,store,store\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,8,16,8,16,16,8,8,8,8,16,8,16\")])\n+   (set_attr \"length\"\t\"4,8,16,8,16,8,8,8,8,16,8,16\")])\n \n (define_insn \"movdf_internal1a\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,R,R,To,To,*d,*d,*d,*To,*R,*d\")\n- \t(match_operand:DF 1 \"general_operand\"      \" f,To,f,G,f,G,*F,*To,*R,*d,*d,*d\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,R,R,To,To,*d,*d,*To,*R,*d\")\n+ \t(match_operand:DF 1 \"general_operand\"      \" f,To,f,G,f,G,*To,*R,*d,*d,*d\"))]\n   \"TARGET_HARD_FLOAT && (TARGET_FLOAT64 && !TARGET_64BIT)\n    && TARGET_DOUBLE_FLOAT\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || (GET_CODE (operands [0]) == MEM\n-\t   && ((GET_CODE (operands[1]) == CONST_INT\n-\t\t&& INTVAL (operands[1]) == 0)\n-\t       || operands[1] == CONST0_RTX (DFmode))))\"\n+       || nonmemory_operand (operands[1], DFmode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,load,store,store,store,store,load,load,load,store,store,move\")\n+  [(set_attr \"type\"\t\"move,load,store,store,store,store,load,load,store,store,move\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,8,4,4,8,8,8,8,4,8,4,4\")])\n+   (set_attr \"length\"\t\"4,8,4,4,8,8,8,4,8,4,4\")])\n \n (define_insn \"movdf_internal2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,d,R,To,d,f,f\")\n-\t(match_operand:DF 1 \"general_operand\" \"dG,R,ToF,d,d,f,d,f\"))]\n+\t(match_operand:DF 1 \"general_operand\" \"dG,R,To,d,d,f,d,f\"))]\n   \"(TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT) && !TARGET_MIPS16\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n-       || operands[1] == CONST0_RTX (DFmode))\"\n+       || nonmemory_operand (operands[1], DFmode))\"\n   \"* return mips_move_2words (operands, insn); \"\n   [(set_attr \"type\"\t\"move,load,load,store,store,xfer,load,move\")\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"8,8,16,8,16,8,8,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,y,d,d,d,R,To\")\n-\t(match_operand:DF 1 \"general_operand\" \"d,d,y,R,ToF,d,d\"))]\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"d,d,y,R,To,d,d\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\""}]}