{"sha": "0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM0MzNjMzFiMzFmMjVlM2YxOGU1OGJkOGQ0MDRjMDI3MjJkN2Y3Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2009-09-14T18:52:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2009-09-14T18:52:16Z"}, "message": "mips-protos.h (mips_cfun_has_cprestore_slot_p): Declare.\n\ngcc/\n\t* config/mips/mips-protos.h (mips_cfun_has_cprestore_slot_p): Declare.\n\t(mips_cprestore_address_p): Likewise.\n\t(mips_save_gp_to_cprestore_slot): Likewise.\n\t(mips_restore_gp): Rename to...\n\t(mips_restore_gp_from_cprestore_slot): ...this.\n\t(mips_must_initialize_gp_p): Declare.\n\t(mips_emit_save_slot_move): Likewise.\n\t(mips_output_load_label): Return nothing.\n\t(mips_eh_uses): Declare.\n\t* config/mips/mips.h (TARGET_SPLIT_CALLS): Require epilogue_completed.\n\t(TARGET_CPRESTORE_DIRECTIVE): New macro.\n\t(TARGET_ABSOLUTE_JUMPS): Likewise.\n\t(EH_USES): Likewise.\n\t(FIRST_PSEUDO_REGISTER): Update comment.\n\t(MIPS_ABSOLUTE_JUMP): New macro, extracted from...\n\t(MIPS_CALL): ...here.\n\t(REGISTER_NAMES): Add $cprestore.\n\t* config/mips/mips.c (machine_function): Remove has_gp_insn_p.\n\tAdd load_label_length, has_inflexible_gp_insn_p,\n\thas_flexible_gp_insn_p, must_initialize_gp_p and\n\tmust_restore_gp_when_clobbered_p.\n\t(mips_expand_call): Don't generate split instructions here.\n\t(mips_split_call): Update the call to mips_restore_gp after\n\tthe above name change.\n\t(mips16_cfun_returns_in_fpr_p): Move earlier in file.\n\t(mips_find_gp_ref): New function.\n\t(mips_insn_has_inflexible_gp_ref_p): Likewise.\n\t(mips_cfun_has_inflexible_gp_ref_p): Likewise.\n\t(mips_insn_has_flexible_gp_ref_p): Likewise.\n\t(mips_cfun_has_flexible_gp_ref_p): Likewise.\n\t(mips_function_has_gp_insn): Delete.\n\t(mips_global_pointer): Drop the df_regs_ever_live_p check.\n\tUse the new functions above.  Only return INVALID_REGNUM\n\tfor TARGET_ABSOLUTE_JUMPS.\n\t(mips_must_initialize_gp_p): New function.\n\t(mips_get_cprestore_base_and_offset): New function, extracted from...\n\t(mips_cprestore_slot): ...here.  Take a bool parameter.\n\t(mips_cfun_has_cprestore_slot_p): New function.\n\t(mips_cprestore_address_p): Likewise.\n\t(mips_save_gp_to_cprestore_slot): Likewise.\n\t(mips_restore_gp): Rename to...\n\t(mips_restore_gp_from_cprestore_slot): ...this.  Assert\n\tepilogue_completed.  Update the call to mips_cprestore_slot.\n\tTest cfun->machine->must_restore_gp_when_clobbered_p.\n\t(mips_direct_save_slot_move_p): New function.\n\t(mips_emit_save_slot_move): Likewise.\n\t(mips_output_cplocal): Test mips_must_initialize_gp_p () instead\n\tof cfun->machine->global_pointer.\n\t(mips_output_function_prologue): Check mips_must_initialize_gp_p ().\n\t(mips_save_reg): Use mips_emit_save_slot_move.\n\t(mips_expand_prologue): Set must_initialize_gp_p.\n\tUse mips_cfun_has_cprestore_slot_p.  Use gen_potential_cprestore\n\tfor all cprestore saves.  Emit a use_cprestore instruction after\n\tsetting up the cprestore slot.\n\t(mips_restore_reg): Use mips_emit_save_slot_move.\n\t(mips_process_load_label): New function.\n\t(mips_load_label_length): Likewise.\n\t(mips_output_load_label): Don't return asm: output it here instead.\n\tUse mips_process_load_label.\n\t(mips_adjust_insn_length): Adjust the length of branch instructions\n\tthat have length MAX_PIC_BRANCH_LENGTH.\n\t(mips_output_conditional_branch): Update the call to\n\tmips_output_load_label.  Assume the branch target is OPERANDS[0]\n\trather than OPERANDS[1].  Use MIPS_ABSOLUTE_JUMP for absolute jumps.\n\t(mips_output_order_conditional_branch): Swap the meaning of\n\tOPERANDS[0] and OPERANDS[1].\n\t(mips_variable_issue): Don't count ghost instructions.\n\t(mips_expand_ghost_gp_insns): New function.\n\t(mips_reorg): Rerun mips_reorg_process_insns if it returns true.\n\t(mips_output_mi_thunk): Set must_initialize_gp_p.\n\t(mips_eh_uses): New function.\n\t* config/mips/predicates.md (cprestore_save_slot_operand)\n\t(cprestore_load_slot_operand): New predicates.\n\t* config/mips/mips.md (UNSPEC_POTENTIAL_CPRESTORE): New unspec.\n\t(UNSPEC_MOVE_GP): Likewise.\n\t(UNSPEC_CPRESTORE, UNSPEC_RESTORE_GP, UNSPEC_EH_RETURN)\n\t(UNSPEC_CONSTTABLE_INT, UNSPEC_CONSTTABLE_FLOAT): Bump to make room.\n\t(CPRESTORE_SLOT_REGNUM): New register.\n\t(MAX_PIC_BRANCH_LENGTH): New constant.\n\t(jal_macro): Use MIPS_ABSOLUTE_JUMPS.\n\t(length): Use MAX_PIC_BRANCH_LENGTH as a placeholder for PIC long\n\tbranches.  Fix commentary.\n\t(loadgp_newabi_<mode>): Change from unspec_volatile to unspec.\n\tOnly split if mips_must_initialize_gp_p; expand to nothing otherwise.\n\tChange type to \"ghost\".\n\t(loadgp_absolute_<mode>): Likewise.\n\t(loadgp_rtp_<mode>): Likewise.\n\t(copygp_mips16): Likewise.\n\t(loadgp_blockage): Remove redundant mode attribute.\n\t(potential_cprestore): New instruction.\n\t(cprestore): Turn into an unspec set.\n\t(use_cprestore): New instruction.\n\t(*branch_fp): Swap operands 0 and 1.  Remove redundant mode attribute.\n\t(*branch_fp_inverted): Likewise.\n\t(*branch_order<mode>): Likewise.\n\t(*branch_order<mode>_inverted): Likewise.\n\t(*branch_equality<mode>): Likewise.\n\t(*branch_equality<mode>_inverted): Likewise.\n\t(*branch_bit<bbv><mode>): Likewise.\n\t(*branch_bit<bbv><mode>_inverted): Likewise.\n\t(*branch_equality<mode>_mips16): Remove redundant mode.\n\t(jump): Turn into a define_expand.\n\t(*jump_absolute): New instruction.\n\t(*jump_pic): Likewise.\n\t(*jump_mips16): Rename previously-unnamed pattern.  Remove\n\tredundant mode attribute.\n\t(restore_gp): Split on epilogue_completed rather than\n\treload_completed.  Change type to \"ghost\".\n\t(move_gp<mode>): New instruction.\n\t* config/mips/mips-dsp.md (mips_bposge): Swap operands 0 and 1.\n\tRemove redundant mode attribute.\n\t* config/mips/mips-ps-3d.md (bc1any4t): Likewise.\n\t(bc1any4f, bc1any2t, bc1any2f): Likewise.\n\t(*branch_upper_lower, *branch_upper_lower_inverted): Likewise.\n\ngcc/testsuite/\n\t* gcc.target/mips/branch-helper.h: New file.\n\t* gcc.target/mips/branch-2.c,\n\t* gcc.target/mips/branch-3.c,\n\t* gcc.target/mips/branch-4.c,\n\t* gcc.target/mips/branch-5.c,\n\t* gcc.target/mips/branch-6.c,\n\t* gcc.target/mips/branch-7.c,\n\t* gcc.target/mips/branch-8.c,\n\t* gcc.target/mips/branch-9.c,\n\t* gcc.target/mips/branch-10.c,\n\t* gcc.target/mips/branch-11.c,\n\t* gcc.target/mips/branch-12.c,\n\t* gcc.target/mips/branch-13.c,\n\t* gcc.target/mips/branch-14.c,\n\t* gcc.target/mips/branch-15.c: New tests.\n\nFrom-SVN: r151695", "tree": {"sha": "55a392adaef788b55ebbabcd2a850c9eeb3bd476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55a392adaef788b55ebbabcd2a850c9eeb3bd476"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af0b8d73e3ca3eb331cef85714085fedf1ce3712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0b8d73e3ca3eb331cef85714085fedf1ce3712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af0b8d73e3ca3eb331cef85714085fedf1ce3712"}], "stats": {"total": 1672, "additions": 1287, "deletions": 385}, "files": [{"sha": "75333c13f38a3bafd4f91deb96a856a1480f0ae9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -1,3 +1,120 @@\n+2009-09-14  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips-protos.h (mips_cfun_has_cprestore_slot_p): Declare.\n+\t(mips_cprestore_address_p): Likewise.\n+\t(mips_save_gp_to_cprestore_slot): Likewise.\n+\t(mips_restore_gp): Rename to...\n+\t(mips_restore_gp_from_cprestore_slot): ...this.\n+\t(mips_must_initialize_gp_p): Declare.\n+\t(mips_emit_save_slot_move): Likewise.\n+\t(mips_output_load_label): Return nothing.\n+\t(mips_eh_uses): Declare.\n+\t* config/mips/mips.h (TARGET_SPLIT_CALLS): Require epilogue_completed.\n+\t(TARGET_CPRESTORE_DIRECTIVE): New macro.\n+\t(TARGET_ABSOLUTE_JUMPS): Likewise.\n+\t(EH_USES): Likewise.\n+\t(FIRST_PSEUDO_REGISTER): Update comment.\n+\t(MIPS_ABSOLUTE_JUMP): New macro, extracted from...\n+\t(MIPS_CALL): ...here.\n+\t(REGISTER_NAMES): Add $cprestore.\n+\t* config/mips/mips.c (machine_function): Remove has_gp_insn_p.\n+\tAdd load_label_length, has_inflexible_gp_insn_p,\n+\thas_flexible_gp_insn_p, must_initialize_gp_p and\n+\tmust_restore_gp_when_clobbered_p.\n+\t(mips_expand_call): Don't generate split instructions here.\n+\t(mips_split_call): Update the call to mips_restore_gp after\n+\tthe above name change.\n+\t(mips16_cfun_returns_in_fpr_p): Move earlier in file.\n+\t(mips_find_gp_ref): New function.\n+\t(mips_insn_has_inflexible_gp_ref_p): Likewise.\n+\t(mips_cfun_has_inflexible_gp_ref_p): Likewise.\n+\t(mips_insn_has_flexible_gp_ref_p): Likewise.\n+\t(mips_cfun_has_flexible_gp_ref_p): Likewise.\n+\t(mips_function_has_gp_insn): Delete.\n+\t(mips_global_pointer): Drop the df_regs_ever_live_p check.\n+\tUse the new functions above.  Only return INVALID_REGNUM\n+\tfor TARGET_ABSOLUTE_JUMPS.\n+\t(mips_must_initialize_gp_p): New function.\n+\t(mips_get_cprestore_base_and_offset): New function, extracted from...\n+\t(mips_cprestore_slot): ...here.  Take a bool parameter.\n+\t(mips_cfun_has_cprestore_slot_p): New function.\n+\t(mips_cprestore_address_p): Likewise.\n+\t(mips_save_gp_to_cprestore_slot): Likewise.\n+\t(mips_restore_gp): Rename to...\n+\t(mips_restore_gp_from_cprestore_slot): ...this.  Assert\n+\tepilogue_completed.  Update the call to mips_cprestore_slot.\n+\tTest cfun->machine->must_restore_gp_when_clobbered_p.\n+\t(mips_direct_save_slot_move_p): New function.\n+\t(mips_emit_save_slot_move): Likewise.\n+\t(mips_output_cplocal): Test mips_must_initialize_gp_p () instead\n+\tof cfun->machine->global_pointer.\n+\t(mips_output_function_prologue): Check mips_must_initialize_gp_p ().\n+\t(mips_save_reg): Use mips_emit_save_slot_move.\n+\t(mips_expand_prologue): Set must_initialize_gp_p.\n+\tUse mips_cfun_has_cprestore_slot_p.  Use gen_potential_cprestore\n+\tfor all cprestore saves.  Emit a use_cprestore instruction after\n+\tsetting up the cprestore slot.\n+\t(mips_restore_reg): Use mips_emit_save_slot_move.\n+\t(mips_process_load_label): New function.\n+\t(mips_load_label_length): Likewise.\n+\t(mips_output_load_label): Don't return asm: output it here instead.\n+\tUse mips_process_load_label.\n+\t(mips_adjust_insn_length): Adjust the length of branch instructions\n+\tthat have length MAX_PIC_BRANCH_LENGTH.\n+\t(mips_output_conditional_branch): Update the call to\n+\tmips_output_load_label.  Assume the branch target is OPERANDS[0]\n+\trather than OPERANDS[1].  Use MIPS_ABSOLUTE_JUMP for absolute jumps.\n+\t(mips_output_order_conditional_branch): Swap the meaning of\n+\tOPERANDS[0] and OPERANDS[1].\n+\t(mips_variable_issue): Don't count ghost instructions.\n+\t(mips_expand_ghost_gp_insns): New function.\n+\t(mips_reorg): Rerun mips_reorg_process_insns if it returns true.\n+\t(mips_output_mi_thunk): Set must_initialize_gp_p.\n+\t(mips_eh_uses): New function.\n+\t* config/mips/predicates.md (cprestore_save_slot_operand)\n+\t(cprestore_load_slot_operand): New predicates.\n+\t* config/mips/mips.md (UNSPEC_POTENTIAL_CPRESTORE): New unspec.\n+\t(UNSPEC_MOVE_GP): Likewise.\n+\t(UNSPEC_CPRESTORE, UNSPEC_RESTORE_GP, UNSPEC_EH_RETURN)\n+\t(UNSPEC_CONSTTABLE_INT, UNSPEC_CONSTTABLE_FLOAT): Bump to make room.\n+\t(CPRESTORE_SLOT_REGNUM): New register.\n+\t(MAX_PIC_BRANCH_LENGTH): New constant.\n+\t(jal_macro): Use MIPS_ABSOLUTE_JUMPS.\n+\t(length): Use MAX_PIC_BRANCH_LENGTH as a placeholder for PIC long\n+\tbranches.  Fix commentary.\n+\t(loadgp_newabi_<mode>): Change from unspec_volatile to unspec.\n+\tOnly split if mips_must_initialize_gp_p; expand to nothing otherwise.\n+\tChange type to \"ghost\".\n+\t(loadgp_absolute_<mode>): Likewise.\n+\t(loadgp_rtp_<mode>): Likewise.\n+\t(copygp_mips16): Likewise.\n+\t(loadgp_blockage): Remove redundant mode attribute.\n+\t(potential_cprestore): New instruction.\n+\t(cprestore): Turn into an unspec set.\n+\t(use_cprestore): New instruction.\n+\t(*branch_fp): Swap operands 0 and 1.  Remove redundant mode attribute.\n+\t(*branch_fp_inverted): Likewise.\n+\t(*branch_order<mode>): Likewise.\n+\t(*branch_order<mode>_inverted): Likewise.\n+\t(*branch_equality<mode>): Likewise.\n+\t(*branch_equality<mode>_inverted): Likewise.\n+\t(*branch_bit<bbv><mode>): Likewise.\n+\t(*branch_bit<bbv><mode>_inverted): Likewise.\n+\t(*branch_equality<mode>_mips16): Remove redundant mode.\n+\t(jump): Turn into a define_expand.\n+\t(*jump_absolute): New instruction.\n+\t(*jump_pic): Likewise.\n+\t(*jump_mips16): Rename previously-unnamed pattern.  Remove\n+\tredundant mode attribute.\n+\t(restore_gp): Split on epilogue_completed rather than\n+\treload_completed.  Change type to \"ghost\".\n+\t(move_gp<mode>): New instruction.\n+\t* config/mips/mips-dsp.md (mips_bposge): Swap operands 0 and 1.\n+\tRemove redundant mode attribute.\n+\t* config/mips/mips-ps-3d.md (bc1any4t): Likewise.\n+\t(bc1any4f, bc1any2t, bc1any2f): Likewise.\n+\t(*branch_upper_lower, *branch_upper_lower_inverted): Likewise.\n+\n 2009-09-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/41210"}, {"sha": "ff2004ccb5470ead5c55f3e5a50949931ac57f96", "filename": "gcc/config/mips/mips-dsp.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-dsp.md?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -1102,11 +1102,10 @@\n (define_insn \"mips_bposge\"\n   [(set (pc)\n \t(if_then_else (ge (reg:CCDSP CCDSP_PO_REGNUM)\n-\t\t\t  (match_operand:SI 0 \"immediate_operand\" \"I\"))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"I\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"ISA_HAS_DSP\"\n-  \"%*bposge%0\\t%1%/\"\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")])\n+  \"%*bposge%1\\t%0%/\"\n+  [(set_attr \"type\"\t\"branch\")])\n "}, {"sha": "91fa72974e84723769428c1238d3f3616ed74fab", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -219,7 +219,10 @@ extern rtx mips_subword (rtx, bool);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n extern void mips_split_doubleword_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n-extern void mips_restore_gp (rtx);\n+extern bool mips_cfun_has_cprestore_slot_p (void);\n+extern bool mips_cprestore_address_p (rtx, bool);\n+extern void mips_save_gp_to_cprestore_slot (rtx, rtx, rtx, rtx);\n+extern void mips_restore_gp_from_cprestore_slot (rtx);\n #ifdef RTX_CODE\n extern void mips_expand_scc (rtx *);\n extern void mips_expand_conditional_branch (rtx *);\n@@ -276,7 +279,9 @@ extern bool mips_small_data_pattern_p (rtx);\n extern rtx mips_rewrite_small_data (rtx);\n extern HOST_WIDE_INT mips_initial_elimination_offset (int, int);\n extern rtx mips_return_addr (int, rtx);\n+extern bool mips_must_initialize_gp_p (void);\n extern enum mips_loadgp_style mips_current_loadgp_style (void);\n+extern void mips_emit_save_slot_move (rtx, rtx, rtx);\n extern void mips_expand_prologue (void);\n extern void mips_expand_before_return (void);\n extern void mips_expand_epilogue (bool);\n@@ -296,7 +301,7 @@ extern int mips_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t    enum reg_class);\n \n extern int mips_adjust_insn_length (rtx, int);\n-extern const char *mips_output_load_label (void);\n+extern void mips_output_load_label (rtx);\n extern const char *mips_output_conditional_branch (rtx, rtx *, const char *,\n \t\t\t\t\t\t   const char *);\n extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);\n@@ -334,6 +339,7 @@ extern void mips_expand_atomic_qihi (union mips_gen_fn_ptrs,\n \n extern void mips_expand_vector_init (rtx, rtx);\n \n+extern bool mips_eh_uses (unsigned int);\n extern bool mips_epilogue_uses (unsigned int);\n extern void mips_final_prescan_insn (rtx, rtx *, int);\n "}, {"sha": "c13c7a69b28902e97702f8c618017a1cf529c7a3", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -439,50 +439,46 @@\n ; Branch on Any of Four Floating Point Condition Codes True\n (define_insn \"bc1any4t\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:CCV4 0 \"register_operand\" \"z\")\n+\t(if_then_else (ne (match_operand:CCV4 1 \"register_operand\" \"z\")\n \t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1any4t\\t%0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  \"%*bc1any4t\\t%1,%0%/\"\n+  [(set_attr \"type\" \"branch\")])\n \n ; Branch on Any of Four Floating Point Condition Codes False\n (define_insn \"bc1any4f\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:CCV4 0 \"register_operand\" \"z\")\n+\t(if_then_else (ne (match_operand:CCV4 1 \"register_operand\" \"z\")\n \t\t\t  (const_int -1))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1any4f\\t%0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  \"%*bc1any4f\\t%1,%0%/\"\n+  [(set_attr \"type\" \"branch\")])\n \n ; Branch on Any of Two Floating Point Condition Codes True\n (define_insn \"bc1any2t\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:CCV2 0 \"register_operand\" \"z\")\n+\t(if_then_else (ne (match_operand:CCV2 1 \"register_operand\" \"z\")\n \t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1any2t\\t%0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  \"%*bc1any2t\\t%1,%0%/\"\n+  [(set_attr \"type\" \"branch\")])\n \n ; Branch on Any of Two Floating Point Condition Codes False\n (define_insn \"bc1any2f\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:CCV2 0 \"register_operand\" \"z\")\n+\t(if_then_else (ne (match_operand:CCV2 1 \"register_operand\" \"z\")\n \t\t\t  (const_int -1))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1any2f\\t%0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  \"%*bc1any2f\\t%1,%0%/\"\n+  [(set_attr \"type\" \"branch\")])\n \n ; Used to access one register in a CCV2 pair.  Operand 0 is the register\n ; pair and operand 1 is the index of the register we want (a CONST_INT).\n@@ -497,45 +493,43 @@\n (define_insn \"*branch_upper_lower\"\n   [(set (pc)\n         (if_then_else\n-\t (match_operator 0 \"equality_operator\"\n+\t (match_operator 1 \"equality_operator\"\n \t    [(unspec:CC [(match_operand:CCV2 2 \"register_operand\" \"z\")\n \t\t\t (match_operand 3 \"const_int_operand\")]\n \t\t\tUNSPEC_SINGLE_CC)\n \t     (const_int 0)])\n-\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))]\n   \"TARGET_HARD_FLOAT\"\n {\n   operands[2]\n     = gen_rtx_REG (CCmode, REGNO (operands[2]) + INTVAL (operands[3]));\n   return mips_output_conditional_branch (insn, operands,\n-\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%2,%1\"),\n-\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%2,%1\"));\n+\t\t\t\t\t MIPS_BRANCH (\"b%F1\", \"%2,%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%W1\", \"%2,%0\"));\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n ; As above, but with the sense of the condition reversed.\n (define_insn \"*branch_upper_lower_inverted\"\n   [(set (pc)\n         (if_then_else\n-\t (match_operator 0 \"equality_operator\"\n+\t (match_operator 1 \"equality_operator\"\n \t    [(unspec:CC [(match_operand:CCV2 2 \"register_operand\" \"z\")\n \t\t\t (match_operand 3 \"const_int_operand\")]\n \t\t\tUNSPEC_SINGLE_CC)\n \t     (const_int 0)])\n \t (pc)\n-\t (label_ref (match_operand 1 \"\" \"\"))))]\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_HARD_FLOAT\"\n {\n   operands[2]\n     = gen_rtx_REG (CCmode, REGNO (operands[2]) + INTVAL (operands[3]));\n   return mips_output_conditional_branch (insn, operands,\n-\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%2,%1\"),\n-\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%2,%1\"));\n+\t\t\t\t\t MIPS_BRANCH (\"b%W1\", \"%2,%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%F1\", \"%2,%0\"));\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n ;----------------------------------------------------------------------------\n ; Floating Point Reduced Precision Reciprocal Square Root Instructions."}, {"sha": "2b0df8f0adf4e55b5bb82156d8c0b337ee27502c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 651, "deletions": 208, "changes": 859, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -307,6 +307,10 @@ struct GTY(())  machine_function {\n      if the function doesn't need one.  */\n   unsigned int global_pointer;\n \n+  /* How many instructions it takes to load a label into $AT, or 0 if\n+     this property hasn't yet been calculated.  */\n+  unsigned int load_label_length;\n+\n   /* True if mips_adjust_insn_length should ignore an instruction's\n      hazard attribute.  */\n   bool ignore_hazard_length_p;\n@@ -315,8 +319,23 @@ struct GTY(())  machine_function {\n      .set nomacro.  */\n   bool all_noreorder_p;\n \n-  /* True if the function is known to have an instruction that needs $gp.  */\n-  bool has_gp_insn_p;\n+  /* True if the function has \"inflexible\" and \"flexible\" references\n+     to the global pointer.  See mips_cfun_has_inflexible_gp_ref_p\n+     and mips_cfun_has_flexible_gp_ref_p for details.  */\n+  bool has_inflexible_gp_insn_p;\n+  bool has_flexible_gp_insn_p;\n+\n+  /* True if the function's prologue must load the global pointer\n+     value into pic_offset_table_rtx and store the same value in\n+     the function's cprestore slot (if any).  Even if this value\n+     is currently false, we may decide to set it to true later;\n+     see mips_must_initialize_gp_p () for details.  */\n+  bool must_initialize_gp_p;\n+\n+  /* True if the current function must restore $gp after any potential\n+     clobber.  This value is only meaningful during the first post-epilogue\n+     split_insns pass; see mips_must_initialize_gp_p () for details.  */\n+  bool must_restore_gp_when_clobbered_p;\n \n   /* True if we have emitted an instruction to initialize\n      mips16_gp_pseudo_rtx.  */\n@@ -6313,9 +6332,7 @@ mips_expand_call (enum mips_call_type type, rtx result, rtx addr,\n     {\n       rtx (*fn) (rtx, rtx);\n \n-      if (type == MIPS_CALL_EPILOGUE && TARGET_SPLIT_CALLS)\n-\tfn = gen_call_split;\n-      else if (type == MIPS_CALL_SIBCALL)\n+      if (type == MIPS_CALL_SIBCALL)\n \tfn = gen_sibcall_internal;\n       else\n \tfn = gen_call_internal;\n@@ -6328,9 +6345,7 @@ mips_expand_call (enum mips_call_type type, rtx result, rtx addr,\n       rtx (*fn) (rtx, rtx, rtx, rtx);\n       rtx reg1, reg2;\n \n-      if (type == MIPS_CALL_EPILOGUE && TARGET_SPLIT_CALLS)\n-\tfn = gen_call_value_multiple_split;\n-      else if (type == MIPS_CALL_SIBCALL)\n+      if (type == MIPS_CALL_SIBCALL)\n \tfn = gen_sibcall_value_multiple_internal;\n       else\n \tfn = gen_call_value_multiple_internal;\n@@ -6343,9 +6358,7 @@ mips_expand_call (enum mips_call_type type, rtx result, rtx addr,\n     {\n       rtx (*fn) (rtx, rtx, rtx);\n \n-      if (type == MIPS_CALL_EPILOGUE && TARGET_SPLIT_CALLS)\n-\tfn = gen_call_value_split;\n-      else if (type == MIPS_CALL_SIBCALL)\n+      if (type == MIPS_CALL_SIBCALL)\n \tfn = gen_sibcall_value_internal;\n       else\n \tfn = gen_call_value_internal;\n@@ -6375,7 +6388,7 @@ mips_split_call (rtx insn, rtx call_pattern)\n     /* Pick a temporary register that is suitable for both MIPS16 and\n        non-MIPS16 code.  $4 and $5 are used for returning complex double\n        values in soft-float code, so $6 is the first suitable candidate.  */\n-    mips_restore_gp (gen_rtx_REG (Pmode, GP_ARG_FIRST + 2));\n+    mips_restore_gp_from_cprestore_slot (gen_rtx_REG (Pmode, GP_ARG_FIRST + 2));\n }\n \n /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n@@ -8566,42 +8579,131 @@ mips16e_output_save_restore (rtx pattern, HOST_WIDE_INT adjust)\n   return buffer;\n }\n \f\n-/* Return true if the current function has an insn that implicitly\n-   refers to $gp.  */\n+/* Return true if the current function returns its value in a floating-point\n+   register in MIPS16 mode.  */\n \n static bool\n-mips_function_has_gp_insn (void)\n+mips16_cfun_returns_in_fpr_p (void)\n {\n-  /* Don't bother rechecking if we found one last time.  */\n-  if (!cfun->machine->has_gp_insn_p)\n-    {\n-      rtx insn;\n+  tree return_type = DECL_RESULT (current_function_decl);\n+  return (TARGET_MIPS16\n+\t  && TARGET_HARD_FLOAT_ABI\n+\t  && !aggregate_value_p (return_type, current_function_decl)\n+ \t  && mips_return_mode_in_fpr_p (DECL_MODE (return_type)));\n+}\n \n+/* Return true if predicate PRED is true for at least one instruction.\n+   Cache the result in *CACHE, and assume that the result is true\n+   if *CACHE is already true.  */\n+\n+static bool\n+mips_find_gp_ref (bool *cache, bool (*pred) (rtx))\n+{\n+  rtx insn;\n+\n+  if (!*cache)\n+    {\n       push_topmost_sequence ();\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tif (USEFUL_INSN_P (insn)\n-\t    && (get_attr_got (insn) != GOT_UNSET\n-\t\t|| mips_small_data_pattern_p (PATTERN (insn))))\n+\tif (USEFUL_INSN_P (insn) && pred (insn))\n \t  {\n-\t    cfun->machine->has_gp_insn_p = true;\n+\t    *cache = true;\n \t    break;\n \t  }\n       pop_topmost_sequence ();\n     }\n-  return cfun->machine->has_gp_insn_p;\n+  return *cache;\n }\n \n-/* Return true if the current function returns its value in a floating-point\n-   register in MIPS16 mode.  */\n+/* Return true if INSN refers to the global pointer in an \"inflexible\" way.\n+   See mips_cfun_has_inflexible_gp_ref_p for details.  */\n \n static bool\n-mips16_cfun_returns_in_fpr_p (void)\n+mips_insn_has_inflexible_gp_ref_p (rtx insn)\n {\n-  tree return_type = DECL_RESULT (current_function_decl);\n-  return (TARGET_MIPS16\n-\t  && TARGET_HARD_FLOAT_ABI\n-\t  && !aggregate_value_p (return_type, current_function_decl)\n- \t  && mips_return_mode_in_fpr_p (DECL_MODE (return_type)));\n+  /* Uses of pic_offset_table_rtx in CALL_INSN_FUNCTION_USAGE\n+     indicate that the target could be a traditional MIPS\n+     lazily-binding stub.  */\n+  return find_reg_fusage (insn, USE, pic_offset_table_rtx);\n+}\n+\n+/* Return true if the current function refers to the global pointer\n+   in a way that forces $28 to be valid.  This means that we can't\n+   change the choice of global pointer, even for NewABI code.\n+\n+   One example of this (and one which needs several checks) is that\n+   $28 must be valid when calling traditional MIPS lazy-binding stubs.\n+   (This restriction does not apply to PLTs.)  */\n+\n+static bool\n+mips_cfun_has_inflexible_gp_ref_p (void)\n+{\n+  /* If the function has a nonlocal goto, $28 must hold the correct\n+     global pointer for the target function.  That is, the target\n+     of the goto implicitly uses $28.  */\n+  if (crtl->has_nonlocal_goto)\n+    return true;\n+\n+  if (TARGET_ABICALLS_PIC2)\n+    {\n+      /* Symbolic accesses implicitly use the global pointer unless\n+\t -mexplicit-relocs is in effect.  JAL macros to symbolic addresses\n+\t might go to traditional MIPS lazy-binding stubs.  */\n+      if (!TARGET_EXPLICIT_RELOCS)\n+\treturn true;\n+\n+      /* FUNCTION_PROFILER includes a JAL to _mcount, which again\n+\t can be lazily-bound.  */\n+      if (crtl->profile)\n+\treturn true;\n+\n+      /* MIPS16 functions that return in FPRs need to call an\n+\t external libgcc routine.  This call is only made explict\n+\t during mips_expand_epilogue, and it too might be lazily bound.  */\n+      if (mips16_cfun_returns_in_fpr_p ())\n+\treturn true;\n+    }\n+\n+  return mips_find_gp_ref (&cfun->machine->has_inflexible_gp_insn_p,\n+\t\t\t   mips_insn_has_inflexible_gp_ref_p);\n+}\n+\n+/* Return true if INSN refers to the global pointer in a \"flexible\" way.\n+   See mips_cfun_has_flexible_gp_ref_p for details.  */\n+\n+static bool\n+mips_insn_has_flexible_gp_ref_p (rtx insn)\n+{\n+  return (get_attr_got (insn) != GOT_UNSET\n+\t  || mips_small_data_pattern_p (PATTERN (insn))\n+\t  || reg_overlap_mentioned_p (pic_offset_table_rtx, PATTERN (insn)));\n+}\n+\n+/* Return true if the current function references the global pointer,\n+   but if those references do not inherently require the global pointer\n+   to be $28.  Assume !mips_cfun_has_inflexible_gp_ref_p ().  */\n+\n+static bool\n+mips_cfun_has_flexible_gp_ref_p (void)\n+{\n+  /* Reload can sometimes introduce constant pool references\n+     into a function that otherwise didn't need them.  For example,\n+     suppose we have an instruction like:\n+\n+\t(set (reg:DF R1) (float:DF (reg:SI R2)))\n+\n+     If R2 turns out to be a constant such as 1, the instruction may\n+     have a REG_EQUAL note saying that R1 == 1.0.  Reload then has\n+     the option of using this constant if R2 doesn't get allocated\n+     to a register.\n+\n+     In cases like these, reload will have added the constant to the\n+     pool but no instruction will yet refer to it.  */\n+  if (TARGET_ABICALLS_PIC2 && !reload_completed && crtl->uses_const_pool)\n+    return true;\n+\n+  return mips_find_gp_ref (&cfun->machine->has_flexible_gp_insn_p,\n+\t\t\t   mips_insn_has_flexible_gp_ref_p);\n }\n \n /* Return the register that should be used as the global pointer\n@@ -8617,57 +8719,18 @@ mips_global_pointer (void)\n   if (!TARGET_USE_GOT)\n     return GLOBAL_POINTER_REGNUM;\n \n-  /* We must always provide $gp when it is used implicitly.  */\n-  if (!TARGET_EXPLICIT_RELOCS)\n-    return GLOBAL_POINTER_REGNUM;\n-\n-  /* FUNCTION_PROFILER includes a jal macro, so we need to give it\n-     a valid gp.  */\n-  if (crtl->profile)\n-    return GLOBAL_POINTER_REGNUM;\n-\n-  /* If the function has a nonlocal goto, $gp must hold the correct\n-     global pointer for the target function.  */\n-  if (crtl->has_nonlocal_goto)\n+  /* If there are inflexible references to $gp, we must use the\n+     standard register.  */\n+  if (mips_cfun_has_inflexible_gp_ref_p ())\n     return GLOBAL_POINTER_REGNUM;\n \n-  /* There's no need to initialize $gp if it isn't referenced now,\n-     and if we can be sure that no new references will be added during\n-     or after reload.  */\n-  if (!df_regs_ever_live_p (GLOBAL_POINTER_REGNUM)\n-      && !mips_function_has_gp_insn ())\n-    {\n-      /* The function doesn't use $gp at the moment.  If we're generating\n-\t -call_nonpic code, no new uses will be introduced during or after\n-\t reload.  */\n-      if (TARGET_ABICALLS_PIC0)\n-\treturn INVALID_REGNUM;\n-\n-      /* We need to handle the following implicit gp references:\n-\n-\t - Reload can sometimes introduce constant pool references\n-\t   into a function that otherwise didn't need them.  For example,\n-\t   suppose we have an instruction like:\n-\n-\t       (set (reg:DF R1) (float:DF (reg:SI R2)))\n-\n-\t   If R2 turns out to be constant such as 1, the instruction may\n-\t   have a REG_EQUAL note saying that R1 == 1.0.  Reload then has\n-\t   the option of using this constant if R2 doesn't get allocated\n-\t   to a register.\n-\n-\t   In cases like these, reload will have added the constant to the\n-\t   pool but no instruction will yet refer to it.\n+  /* If there are no current references to $gp, then the only uses\n+     we can introduce later are those involved in long branches.  */\n+  if (TARGET_ABSOLUTE_JUMPS && !mips_cfun_has_flexible_gp_ref_p ())\n+    return INVALID_REGNUM;\n \n-\t - MIPS16 functions that return in FPRs need to call an\n-\t   external libgcc routine.  */\n-      if (!crtl->uses_const_pool\n-\t  && !mips16_cfun_returns_in_fpr_p ())\n-\treturn INVALID_REGNUM;\n-    }\n-\n-  /* We need a global pointer, but perhaps we can use a call-clobbered\n-     register instead of $gp.  */\n+  /* If the global pointer is call-saved, try to use a call-clobbered\n+     alternative.  */\n   if (TARGET_CALL_SAVED_GP && current_function_is_leaf)\n     for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n       if (!df_regs_ever_live_p (regno)\n@@ -8679,6 +8742,119 @@ mips_global_pointer (void)\n   return GLOBAL_POINTER_REGNUM;\n }\n \n+/* Return true if current function's prologue must load the global\n+   pointer value into pic_offset_table_rtx and store the same value in\n+   the function's cprestore slot (if any).\n+\n+   One problem we have to deal with is that, when emitting GOT-based\n+   position independent code, long-branch sequences will need to load\n+   the address of the branch target from the GOT.  We don't know until\n+   the very end of compilation whether (and where) the function needs\n+   long branches, so we must ensure that _any_ branch can access the\n+   global pointer in some form.  However, we do not want to pessimize\n+   the usual case in which all branches are short.\n+\n+   We handle this as follows:\n+\n+   (1) During reload, we set cfun->machine->global_pointer to\n+       INVALID_REGNUM if we _know_ that the current function\n+       doesn't need a global pointer.  This is only valid if\n+       long branches don't need the GOT.\n+\n+       Otherwise, we assume that we might need a global pointer\n+       and pick an appropriate register.\n+\n+   (2) If cfun->machine->global_pointer != INVALID_REGNUM,\n+       we ensure that the global pointer is available at every\n+       block boundary bar entry and exit.  We do this in one of two ways:\n+\n+       - If the function has a cprestore slot, we ensure that this\n+\t slot is valid at every branch.  However, as explained in\n+\t point (6) below, there is no guarantee that pic_offset_table_rtx\n+\t itself is valid if new uses of the global pointer are introduced\n+\t after the first post-epilogue split.\n+\n+\t We guarantee that the cprestore slot is valid by loading it\n+\t into a fake register, CPRESTORE_SLOT_REGNUM.  We then make\n+\t this register live at every block boundary bar function entry\n+\t and exit.  It is then invalid to move the load (and thus the\n+\t preceding store) across a block boundary.\n+\n+       - If the function has no cprestore slot, we guarantee that\n+\t pic_offset_table_rtx itself is valid at every branch.\n+\n+       See mips_eh_uses for the handling of the register liveness.\n+\n+   (3) During prologue and epilogue generation, we emit \"ghost\"\n+       placeholder instructions to manipulate the global pointer.\n+\n+   (4) During prologue generation, we set cfun->machine->must_initialize_gp_p\n+       and cfun->machine->must_restore_gp_when_clobbered_p if we already know\n+       that the function needs a global pointer.  (There is no need to set\n+       them earlier than this, and doing it as late as possible leads to\n+       fewer false positives.)\n+\n+   (5) If cfun->machine->must_initialize_gp_p is true during a\n+       split_insns pass, we split the ghost instructions into real\n+       instructions.  These split instructions can then be optimized in\n+       the usual way.  Otherwise, we keep the ghost instructions intact,\n+       and optimize for the case where they aren't needed.  We still\n+       have the option of splitting them later, if we need to introduce\n+       new uses of the global pointer.\n+\n+       For example, the scheduler ignores a ghost instruction that\n+       stores $28 to the stack, but it handles the split form of\n+       the ghost instruction as an ordinary store.\n+\n+   (6) [OldABI only.]  If cfun->machine->must_restore_gp_when_clobbered_p\n+       is true during the first post-epilogue split_insns pass, we split\n+       calls and restore_gp patterns into instructions that explicitly\n+       load pic_offset_table_rtx from the cprestore slot.  Otherwise,\n+       we split these patterns into instructions that _don't_ load from\n+       the cprestore slot.\n+\n+       If cfun->machine->must_restore_gp_when_clobbered_p is true at the\n+       time of the split, then any instructions that exist at that time\n+       can make free use of pic_offset_table_rtx.  However, if we want\n+       to introduce new uses of the global pointer after the split,\n+       we must explicitly load the value from the cprestore slot, since\n+       pic_offset_table_rtx itself might not be valid at a given point\n+       in the function.\n+\n+       The idea is that we want to be able to delete redundant\n+       loads from the cprestore slot in the usual case where no\n+       long branches are needed.\n+\n+   (7) If cfun->machine->must_initialize_gp_p is still false at the end\n+       of md_reorg, we decide whether the global pointer is needed for\n+       long branches.  If so, we set cfun->machine->must_initialize_gp_p\n+       to true and split the ghost instructions into real instructions\n+       at that stage.\n+\n+   Note that the ghost instructions must have a zero length for three reasons:\n+\n+   - Giving the length of the underlying $gp sequence might cause\n+     us to use long branches in cases where they aren't really needed.\n+\n+   - They would perturb things like alignment calculations.\n+\n+   - More importantly, the hazard detection in md_reorg relies on\n+     empty instructions having a zero length.\n+\n+   If we find a long branch and split the ghost instructions at the\n+   end of md_reorg, the split could introduce more long branches.\n+   That isn't a problem though, because we still do the split before\n+   the final shorten_branches pass.\n+\n+   This is extremely ugly, but it seems like the best compromise between\n+   correctness and efficiency.  */\n+\n+bool\n+mips_must_initialize_gp_p (void)\n+{\n+  return cfun->machine->must_initialize_gp_p;\n+}\n+\n /* Return true if REGNO is a register that is ordinarily call-clobbered\n    but must nevertheless be preserved by an interrupt handler.  */\n \n@@ -9198,48 +9374,118 @@ mips_set_return_address (rtx address, rtx scratch)\n   mips_emit_move (gen_frame_mem (GET_MODE (address), slot_address), address);\n }\n \n-/* Return a MEM rtx for the cprestore slot, using TEMP as a temporary base\n-   register if need be.  */\n+/* Return true if the current function has a cprestore slot.  */\n \n-static rtx\n-mips_cprestore_slot (rtx temp)\n+bool\n+mips_cfun_has_cprestore_slot_p (void)\n+{\n+  return (cfun->machine->global_pointer != INVALID_REGNUM\n+\t  && cfun->machine->frame.cprestore_size > 0);\n+}\n+\n+/* Fill *BASE and *OFFSET such that *BASE + *OFFSET refers to the\n+   cprestore slot.  LOAD_P is true if the caller wants to load from\n+   the cprestore slot; it is false if the caller wants to store to\n+   the slot.  */\n+\n+static void\n+mips_get_cprestore_base_and_offset (rtx *base, HOST_WIDE_INT *offset,\n+\t\t\t\t    bool load_p)\n {\n   const struct mips_frame_info *frame;\n-  rtx base;\n-  HOST_WIDE_INT offset;\n \n   frame = &cfun->machine->frame;\n-  if (frame_pointer_needed)\n-    {\n-      base = hard_frame_pointer_rtx;\n-      offset = frame->args_size - frame->hard_frame_pointer_offset;\n+  /* .cprestore always uses the stack pointer instead of the frame pointer.\n+     We have a free choice for direct stores for non-MIPS16 functions,\n+     and for MIPS16 functions whose cprestore slot is in range of the\n+     stack pointer.  Using the stack pointer would sometimes give more\n+     (early) scheduling freedom, but using the frame pointer would\n+     sometimes give more (late) scheduling freedom.  It's hard to\n+     predict which applies to a given function, so let's keep things\n+     simple.\n+\n+     Loads must always use the frame pointer in functions that call\n+     alloca, and there's little benefit to using the stack pointer\n+     otherwise.  */\n+  if (frame_pointer_needed && !(TARGET_CPRESTORE_DIRECTIVE && !load_p))\n+    {\n+      *base = hard_frame_pointer_rtx;\n+      *offset = frame->args_size - frame->hard_frame_pointer_offset;\n     }\n   else\n     {\n-      base = stack_pointer_rtx;\n-      offset = frame->args_size;\n+      *base = stack_pointer_rtx;\n+      *offset = frame->args_size;\n     }\n+}\n+\n+/* Return true if X is the load or store address of the cprestore slot;\n+   LOAD_P says which.  */\n+\n+bool\n+mips_cprestore_address_p (rtx x, bool load_p)\n+{\n+  rtx given_base, required_base;\n+  HOST_WIDE_INT given_offset, required_offset;\n+\n+  mips_split_plus (x, &given_base, &given_offset);\n+  mips_get_cprestore_base_and_offset (&required_base, &required_offset, load_p);\n+  return given_base == required_base && given_offset == required_offset;\n+}\n+\n+/* Return a MEM rtx for the cprestore slot.  LOAD_P is true if we are\n+   going to load from it, false if we are going to store to it.\n+   Use TEMP as a temporary register if need be.  */\n+\n+static rtx\n+mips_cprestore_slot (rtx temp, bool load_p)\n+{\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+\n+  mips_get_cprestore_base_and_offset (&base, &offset, load_p);\n   return gen_frame_mem (Pmode, mips_add_offset (temp, base, offset));\n }\n \n+/* Emit instructions to save global pointer value GP into cprestore\n+   slot MEM.  OFFSET is the offset that MEM applies to the base register.\n+\n+   MEM may not be a legitimate address.  If it isn't, TEMP is a\n+   temporary register that can be used, otherwise it is a SCRATCH.  */\n+\n+void\n+mips_save_gp_to_cprestore_slot (rtx mem, rtx offset, rtx gp, rtx temp)\n+{\n+  if (TARGET_CPRESTORE_DIRECTIVE)\n+    {\n+      gcc_assert (gp == pic_offset_table_rtx);\n+      emit_insn (gen_cprestore (mem, offset));\n+    }\n+  else\n+    mips_emit_move (mips_cprestore_slot (temp, false), gp);\n+}\n+\n /* Restore $gp from its save slot, using TEMP as a temporary base register\n-   if need be.  This function is for o32 and o64 abicalls only.  */\n+   if need be.  This function is for o32 and o64 abicalls only.\n+\n+   See mips_must_initialize_gp_p for details about how we manage the\n+   global pointer.  */\n \n void\n-mips_restore_gp (rtx temp)\n+mips_restore_gp_from_cprestore_slot (rtx temp)\n {\n-  gcc_assert (TARGET_ABICALLS && TARGET_OLDABI);\n+  gcc_assert (TARGET_ABICALLS && TARGET_OLDABI && epilogue_completed);\n \n-  if (cfun->machine->global_pointer == INVALID_REGNUM)\n+  if (!cfun->machine->must_restore_gp_when_clobbered_p)\n     return;\n \n   if (TARGET_MIPS16)\n     {\n-      mips_emit_move (temp, mips_cprestore_slot (temp));\n+      mips_emit_move (temp, mips_cprestore_slot (temp, true));\n       mips_emit_move (pic_offset_table_rtx, temp);\n     }\n   else\n-    mips_emit_move (pic_offset_table_rtx, mips_cprestore_slot (temp));\n+    mips_emit_move (pic_offset_table_rtx, mips_cprestore_slot (temp, true));\n   if (!TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n }\n@@ -9327,6 +9573,89 @@ mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,\n \toffset -= GET_MODE_SIZE (fpr_mode);\n       }\n }\n+\n+/* Return true if a move between register REGNO and its save slot (MEM)\n+   can be done in a single move.  LOAD_P is true if we are loading\n+   from the slot, false if we are storing to it.  */\n+\n+static bool\n+mips_direct_save_slot_move_p (unsigned int regno, rtx mem, bool load_p)\n+{\n+  /* There is a specific MIPS16 instruction for saving $31 to the stack.  */\n+  if (TARGET_MIPS16 && !load_p && regno == GP_REG_FIRST + 31)\n+    return false;\n+\n+  return mips_secondary_reload_class (REGNO_REG_CLASS (regno),\n+\t\t\t\t      GET_MODE (mem), mem, load_p) == NO_REGS;\n+}\n+\n+/* Emit a move from SRC to DEST, given that one of them is a register\n+   save slot and that the other is a register.  TEMP is a temporary\n+   GPR of the same mode that is available if need be.  */\n+\n+void\n+mips_emit_save_slot_move (rtx dest, rtx src, rtx temp)\n+{\n+  unsigned int regno;\n+  rtx mem;\n+\n+  if (REG_P (src))\n+    {\n+      regno = REGNO (src);\n+      mem = dest;\n+    }\n+  else\n+    {\n+      regno = REGNO (dest);\n+      mem = src;\n+    }\n+\n+  if (regno == cfun->machine->global_pointer && !mips_must_initialize_gp_p ())\n+    {\n+      /* We don't yet know whether we'll need this instruction or not.\n+\t Postpone the decision by emitting a ghost move.  This move\n+\t is specifically not frame-related; only the split version is.  */\n+      if (TARGET_64BIT)\n+\temit_insn (gen_move_gpdi (dest, src));\n+      else\n+\temit_insn (gen_move_gpsi (dest, src));\n+      return;\n+    }\n+\n+  if (regno == HI_REGNUM)\n+    {\n+      if (REG_P (dest))\n+\t{\n+\t  mips_emit_move (temp, src);\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_mthisi_di (gen_rtx_REG (TImode, MD_REG_FIRST),\n+\t\t\t\t      temp, gen_rtx_REG (DImode, LO_REGNUM)));\n+\t  else\n+\t    emit_insn (gen_mthisi_di (gen_rtx_REG (DImode, MD_REG_FIRST),\n+\t\t\t\t      temp, gen_rtx_REG (SImode, LO_REGNUM)));\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_mfhidi_ti (temp,\n+\t\t\t\t      gen_rtx_REG (TImode, MD_REG_FIRST)));\n+\t  else\n+\t    emit_insn (gen_mfhisi_di (temp,\n+\t\t\t\t      gen_rtx_REG (DImode, MD_REG_FIRST)));\n+\t  mips_emit_move (dest, temp);\n+\t}\n+    }\n+  else if (mips_direct_save_slot_move_p (regno, mem, mem == src))\n+    mips_emit_move (dest, src);\n+  else\n+    {\n+      gcc_assert (!reg_overlap_mentioned_p (dest, temp));\n+      mips_emit_move (temp, src);\n+      mips_emit_move (dest, temp);\n+    }\n+  if (MEM_P (dest))\n+    mips_set_frame_expr (mips_frame_set (dest, src));\n+}\n \f\n /* If we're generating n32 or n64 abicalls, and the current function\n    does not use $28 as its global pointer, emit a cplocal directive.\n@@ -9336,7 +9665,7 @@ static void\n mips_output_cplocal (void)\n {\n   if (!TARGET_EXPLICIT_RELOCS\n-      && cfun->machine->global_pointer != INVALID_REGNUM\n+      && mips_must_initialize_gp_p ()\n       && cfun->machine->global_pointer != GLOBAL_POINTER_REGNUM)\n     output_asm_insn (\".cplocal %+\", 0);\n }\n@@ -9408,7 +9737,8 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n   /* Handle the initialization of $gp for SVR4 PIC, if applicable.\n      Also emit the \".set noreorder; .set nomacro\" sequence for functions\n      that need it.  */\n-  if (mips_current_loadgp_style () == LOADGP_OLDABI)\n+  if (mips_must_initialize_gp_p ()\n+      && mips_current_loadgp_style () == LOADGP_OLDABI)\n     {\n       if (TARGET_MIPS16)\n \t{\n@@ -9490,33 +9820,7 @@ mips_save_reg (rtx reg, rtx mem)\n       mips_set_frame_expr (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x1, x2)));\n     }\n   else\n-    {\n-      if (REGNO (reg) == HI_REGNUM)\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    emit_insn (gen_mfhidi_ti (MIPS_PROLOGUE_TEMP (DImode),\n-\t\t\t\t      gen_rtx_REG (TImode, MD_REG_FIRST)));\n-\t  else\n-\t    emit_insn (gen_mfhisi_di (MIPS_PROLOGUE_TEMP (SImode),\n-\t\t\t\t      gen_rtx_REG (DImode, MD_REG_FIRST)));\n-\t  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n-\t}\n-      else if ((TARGET_MIPS16\n-\t\t&& REGNO (reg) != GP_REG_FIRST + 31\n-\t\t&& !M16_REG_P (REGNO (reg)))\n-\t       || ACC_REG_P (REGNO (reg)))\n-\t{\n-\t  /* If the register has no direct store instruction, move it\n-\t     through a temporary.  Note that there's a special MIPS16\n-\t     instruction to save $31.  */\n-\t  mips_emit_move (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);\n-\t  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n-\t}\n-      else\n-\tmips_emit_move (mem, reg);\n-\n-      mips_set_frame_expr (mips_frame_set (mem, reg));\n-    }\n+    mips_emit_save_slot_move (mem, reg, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n }\n \n /* The __gnu_local_gp symbol.  */\n@@ -9599,7 +9903,19 @@ mips_expand_prologue (void)\n   rtx insn;\n \n   if (cfun->machine->global_pointer != INVALID_REGNUM)\n-    SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n+    {\n+      /* Check whether an insn uses pic_offset_table_rtx, either explicitly\n+\t or implicitly.  If so, we can commit to using a global pointer\n+\t straight away, otherwise we need to defer the decision.  */\n+      if (mips_cfun_has_inflexible_gp_ref_p ()\n+\t  || mips_cfun_has_flexible_gp_ref_p ())\n+\t{\n+\t  cfun->machine->must_initialize_gp_p = true;\n+\t  cfun->machine->must_restore_gp_when_clobbered_p = true;\n+\t}\n+\n+      SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n+    }\n \n   frame = &cfun->machine->frame;\n   size = frame->total_size;\n@@ -9801,17 +10117,22 @@ mips_expand_prologue (void)\n   mips_emit_loadgp ();\n \n   /* Initialize the $gp save slot.  */\n-  if (frame->cprestore_size > 0\n-      && cfun->machine->global_pointer != INVALID_REGNUM)\n+  if (mips_cfun_has_cprestore_slot_p ())\n     {\n-      if (TARGET_MIPS16)\n-\tmips_emit_move (mips_cprestore_slot (MIPS_PROLOGUE_TEMP (Pmode)),\n-\t\t\tMIPS16_PIC_TEMP);\n-      else if (TARGET_ABICALLS_PIC2)\n-\temit_insn (gen_cprestore (GEN_INT (frame->args_size)));\n-      else\n-\temit_move_insn (mips_cprestore_slot (MIPS_PROLOGUE_TEMP (Pmode)),\n-\t\t\tpic_offset_table_rtx);\n+      rtx base, mem, gp, temp;\n+      HOST_WIDE_INT offset;\n+\n+      mips_get_cprestore_base_and_offset (&base, &offset, false);\n+      mem = gen_frame_mem (Pmode, plus_constant (base, offset));\n+      gp = TARGET_MIPS16 ? MIPS16_PIC_TEMP : pic_offset_table_rtx;\n+      temp = (SMALL_OPERAND (offset)\n+\t      ? gen_rtx_SCRATCH (Pmode)\n+\t      : MIPS_PROLOGUE_TEMP (Pmode));\n+      emit_insn (gen_potential_cprestore (mem, GEN_INT (offset), gp, temp));\n+\n+      mips_get_cprestore_base_and_offset (&base, &offset, true);\n+      mem = gen_frame_mem (Pmode, plus_constant (base, offset));\n+      emit_insn (gen_use_cprestore (mem));\n     }\n \n   /* We need to search back to the last use of K0 or K1.  */\n@@ -9844,27 +10165,7 @@ mips_restore_reg (rtx reg, rtx mem)\n   if (TARGET_MIPS16 && REGNO (reg) == GP_REG_FIRST + 31)\n     reg = gen_rtx_REG (GET_MODE (reg), GP_REG_FIRST + 7);\n \n-  if (REGNO (reg) == HI_REGNUM)\n-    {\n-      mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n-      if (TARGET_64BIT)\n-\temit_insn (gen_mthisi_di (gen_rtx_REG (TImode, MD_REG_FIRST),\n-\t\t\t\t  MIPS_EPILOGUE_TEMP (DImode),\n-\t\t\t\t  gen_rtx_REG (DImode, LO_REGNUM)));\n-      else\n-\temit_insn (gen_mthisi_di (gen_rtx_REG (DImode, MD_REG_FIRST),\n-\t\t\t\t  MIPS_EPILOGUE_TEMP (SImode),\n-\t\t\t\t  gen_rtx_REG (SImode, LO_REGNUM)));\n-    }\n-  else if ((TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))\n-\t   || ACC_REG_P (REGNO (reg)))\n-    {\n-      /* Can't restore directly; move through a temporary.  */\n-      mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n-      mips_emit_move (reg, MIPS_EPILOGUE_TEMP (GET_MODE (reg)));\n-    }\n-  else\n-    mips_emit_move (reg, mem);\n+  mips_emit_save_slot_move (reg, mem, MIPS_EPILOGUE_TEMP (GET_MODE (reg)));\n }\n \n /* Emit any instructions needed before a return.  */\n@@ -10732,12 +11033,112 @@ mips_init_libfuncs (void)\n     synchronize_libfunc = init_one_libfunc (\"__sync_synchronize\");\n }\n \n+/* Build up a multi-insn sequence that loads label TARGET into $AT.  */\n+\n+static void\n+mips_process_load_label (rtx target)\n+{\n+  rtx base, gp, intop;\n+  HOST_WIDE_INT offset;\n+\n+  mips_multi_start ();\n+  switch (mips_abi)\n+    {\n+    case ABI_N32:\n+      mips_multi_add_insn (\"lw\\t%@,%%got_page(%0)(%+)\", target, 0);\n+      mips_multi_add_insn (\"addiu\\t%@,%@,%%got_ofst(%0)\", target, 0);\n+      break;\n+\n+    case ABI_64:\n+      mips_multi_add_insn (\"ld\\t%@,%%got_page(%0)(%+)\", target, 0);\n+      mips_multi_add_insn (\"daddiu\\t%@,%@,%%got_ofst(%0)\", target, 0);\n+      break;\n+\n+    default:\n+      gp = pic_offset_table_rtx;\n+      if (mips_cfun_has_cprestore_slot_p ())\n+\t{\n+\t  gp = gen_rtx_REG (Pmode, AT_REGNUM);\n+\t  mips_get_cprestore_base_and_offset (&base, &offset, true);\n+\t  if (!SMALL_OPERAND (offset))\n+\t    {\n+\t      intop = GEN_INT (CONST_HIGH_PART (offset));\n+\t      mips_multi_add_insn (\"lui\\t%0,%1\", gp, intop, 0);\n+\t      mips_multi_add_insn (\"addu\\t%0,%0,%1\", gp, base, 0);\n+\n+\t      base = gp;\n+\t      offset = CONST_LOW_PART (offset);\n+\t    }\n+\t  intop = GEN_INT (offset);\n+\t  if (ISA_HAS_LOAD_DELAY)\n+\t    mips_multi_add_insn (\"lw\\t%0,%1(%2)%#\", gp, intop, base, 0);\n+\t  else\n+\t    mips_multi_add_insn (\"lw\\t%0,%1(%2)\", gp, intop, base, 0);\n+\t}\n+      if (ISA_HAS_LOAD_DELAY)\n+\tmips_multi_add_insn (\"lw\\t%@,%%got(%0)(%1)%#\", target, gp, 0);\n+      else\n+\tmips_multi_add_insn (\"lw\\t%@,%%got(%0)(%1)\", target, gp, 0);\n+      mips_multi_add_insn (\"addiu\\t%@,%@,%%lo(%0)\", target, 0);\n+      break;\n+    }\n+}\n+\n+/* Return the number of instructions needed to load a label into $AT.  */\n+\n+static unsigned int\n+mips_load_label_length (void)\n+{\n+  if (cfun->machine->load_label_length == 0)\n+    {\n+      mips_process_load_label (pc_rtx);\n+      cfun->machine->load_label_length = mips_multi_num_insns;\n+    }\n+  return cfun->machine->load_label_length;\n+}\n+\n+/* Emit an asm sequence to start a noat block and load the address\n+   of a label into $1.  */\n+\n+void\n+mips_output_load_label (rtx target)\n+{\n+  mips_push_asm_switch (&mips_noat);\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      mips_process_load_label (target);\n+      mips_multi_write ();\n+    }\n+  else\n+    {\n+      if (Pmode == DImode)\n+\toutput_asm_insn (\"dla\\t%@,%0\", &target);\n+      else\n+\toutput_asm_insn (\"la\\t%@,%0\", &target);\n+    }\n+}\n+\n /* Return the length of INSN.  LENGTH is the initial length computed by\n    attributes in the machine-description file.  */\n \n int\n mips_adjust_insn_length (rtx insn, int length)\n {\n+  /* mips.md uses MAX_PIC_BRANCH_LENGTH as a placeholder for the length\n+     of a PIC long-branch sequence.  Substitute the correct value.  */\n+  if (length == MAX_PIC_BRANCH_LENGTH\n+      && INSN_CODE (insn) >= 0\n+      && get_attr_type (insn) == TYPE_BRANCH)\n+    {\n+      /* Add the branch-over instruction and its delay slot, if this\n+\t is a conditional branch.  */\n+      length = simplejump_p (insn) ? 0 : 8;\n+\n+      /* Load the label into $AT and jump to it.  Ignore the delay\n+\t slot of the jump.  */\n+      length += mips_load_label_length () + 4;\n+    }\n+\n   /* A unconditional jump has an unfilled delay slot if it is not part\n      of a sequence.  A conditional jump normally has a delay slot, but\n      does not on MIPS16.  */\n@@ -10769,38 +11170,9 @@ mips_adjust_insn_length (rtx insn, int length)\n   return length;\n }\n \n-/* Return an asm sequence to start a noat block and load the address\n-   of a label into $1.  */\n-\n-const char *\n-mips_output_load_label (void)\n-{\n-  if (TARGET_EXPLICIT_RELOCS)\n-    switch (mips_abi)\n-      {\n-      case ABI_N32:\n-\treturn \"%[lw\\t%@,%%got_page(%0)(%+)\\n\\taddiu\\t%@,%@,%%got_ofst(%0)\";\n-\n-      case ABI_64:\n-\treturn \"%[ld\\t%@,%%got_page(%0)(%+)\\n\\tdaddiu\\t%@,%@,%%got_ofst(%0)\";\n-\n-      default:\n-\tif (ISA_HAS_LOAD_DELAY)\n-\t  return \"%[lw\\t%@,%%got(%0)(%+)%#\\n\\taddiu\\t%@,%@,%%lo(%0)\";\n-\treturn \"%[lw\\t%@,%%got(%0)(%+)\\n\\taddiu\\t%@,%@,%%lo(%0)\";\n-      }\n-  else\n-    {\n-      if (Pmode == DImode)\n-\treturn \"%[dla\\t%@,%0\";\n-      else\n-\treturn \"%[la\\t%@,%0\";\n-    }\n-}\n-\n /* Return the assembly code for INSN, which has the operands given by\n-   OPERANDS, and which branches to OPERANDS[1] if some condition is true.\n-   BRANCH_IF_TRUE is the asm template that should be used if OPERANDS[1]\n+   OPERANDS, and which branches to OPERANDS[0] if some condition is true.\n+   BRANCH_IF_TRUE is the asm template that should be used if OPERANDS[0]\n    is in range of a direct branch.  BRANCH_IF_FALSE is an inverted\n    version of BRANCH_IF_TRUE.  */\n \n@@ -10812,7 +11184,7 @@ mips_output_conditional_branch (rtx insn, rtx *operands,\n   unsigned int length;\n   rtx taken, not_taken;\n \n-  gcc_assert (LABEL_P (operands[1]));  \n+  gcc_assert (LABEL_P (operands[0]));\n \n   length = get_attr_length (insn);\n   if (length <= 8)\n@@ -10826,10 +11198,10 @@ mips_output_conditional_branch (rtx insn, rtx *operands,\n      not use branch-likely instructions.  */\n   mips_branch_likely = false;\n   not_taken = gen_label_rtx ();\n-  taken = operands[1];\n+  taken = operands[0];\n \n   /* Generate the reversed branch to NOT_TAKEN.  */\n-  operands[1] = not_taken;\n+  operands[0] = not_taken;\n   output_asm_insn (branch_if_false, operands);\n \n   /* If INSN has a delay slot, we must provide delay slots for both the\n@@ -10851,11 +11223,11 @@ mips_output_conditional_branch (rtx insn, rtx *operands,\n     }\n \n   /* Output the unconditional branch to TAKEN.  */\n-  if (length <= 16)\n-    output_asm_insn (\"j\\t%0%/\", &taken);\n+  if (TARGET_ABSOLUTE_JUMPS)\n+    output_asm_insn (MIPS_ABSOLUTE_JUMP (\"j\\t%0%/\"), &taken);\n   else\n     {\n-      output_asm_insn (mips_output_load_label (), &taken);\n+      mips_output_load_label (taken);\n       output_asm_insn (\"jr\\t%@%]%/\", 0);\n     }\n \n@@ -10881,42 +11253,42 @@ mips_output_conditional_branch (rtx insn, rtx *operands,\n   return \"\";\n }\n \n-/* Return the assembly code for INSN, which branches to OPERANDS[1]\n+/* Return the assembly code for INSN, which branches to OPERANDS[0]\n    if some ordering condition is true.  The condition is given by\n-   OPERANDS[0] if !INVERTED_P, otherwise it is the inverse of\n-   OPERANDS[0].  OPERANDS[2] is the comparison's first operand;\n+   OPERANDS[1] if !INVERTED_P, otherwise it is the inverse of\n+   OPERANDS[1].  OPERANDS[2] is the comparison's first operand;\n    its second is always zero.  */\n \n const char *\n mips_output_order_conditional_branch (rtx insn, rtx *operands, bool inverted_p)\n {\n   const char *branch[2];\n \n-  /* Make BRANCH[1] branch to OPERANDS[1] when the condition is true.\n+  /* Make BRANCH[1] branch to OPERANDS[0] when the condition is true.\n      Make BRANCH[0] branch on the inverse condition.  */\n-  switch (GET_CODE (operands[0]))\n+  switch (GET_CODE (operands[1]))\n     {\n       /* These cases are equivalent to comparisons against zero.  */\n     case LEU:\n       inverted_p = !inverted_p;\n       /* Fall through.  */\n     case GTU:\n-      branch[!inverted_p] = MIPS_BRANCH (\"bne\", \"%2,%.,%1\");\n-      branch[inverted_p] = MIPS_BRANCH (\"beq\", \"%2,%.,%1\");\n+      branch[!inverted_p] = MIPS_BRANCH (\"bne\", \"%2,%.,%0\");\n+      branch[inverted_p] = MIPS_BRANCH (\"beq\", \"%2,%.,%0\");\n       break;\n \n       /* These cases are always true or always false.  */\n     case LTU:\n       inverted_p = !inverted_p;\n       /* Fall through.  */\n     case GEU:\n-      branch[!inverted_p] = MIPS_BRANCH (\"beq\", \"%.,%.,%1\");\n-      branch[inverted_p] = MIPS_BRANCH (\"bne\", \"%.,%.,%1\");\n+      branch[!inverted_p] = MIPS_BRANCH (\"beq\", \"%.,%.,%0\");\n+      branch[inverted_p] = MIPS_BRANCH (\"bne\", \"%.,%.,%0\");\n       break;\n \n     default:\n-      branch[!inverted_p] = MIPS_BRANCH (\"b%C0z\", \"%2,%1\");\n-      branch[inverted_p] = MIPS_BRANCH (\"b%N0z\", \"%2,%1\");\n+      branch[!inverted_p] = MIPS_BRANCH (\"b%C1z\", \"%2,%0\");\n+      branch[inverted_p] = MIPS_BRANCH (\"b%N1z\", \"%2,%0\");\n       break;\n     }\n   return mips_output_conditional_branch (insn, operands, branch[1], branch[0]);\n@@ -11915,7 +12287,8 @@ mips_variable_issue (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n   /* Ignore USEs and CLOBBERs; don't count them against the issue rate.  */\n   if (USEFUL_INSN_P (insn))\n     {\n-      more--;\n+      if (get_attr_type (insn) != TYPE_GHOST)\n+\tmore--;\n       if (!reload_completed && TUNE_MACC_CHAINS)\n \tmips_macc_chains_record (insn);\n       vr4130_last_insn = insn;\n@@ -14173,6 +14546,46 @@ mips_reorg_process_insns (void)\n   htab_delete (htab);\n }\n \n+/* If we are using a GOT, but have not decided to use a global pointer yet,\n+   see whether we need one to implement long branches.  Convert the ghost\n+   global-pointer instructions into real ones if so.  */\n+\n+static bool\n+mips_expand_ghost_gp_insns (void)\n+{\n+  rtx insn;\n+  int normal_length;\n+\n+  /* Quick exit if we already know that we will or won't need a\n+     global pointer.  */\n+  if (!TARGET_USE_GOT\n+      || cfun->machine->global_pointer == INVALID_REGNUM\n+      || mips_must_initialize_gp_p ())\n+    return false;\n+\n+  shorten_branches (get_insns ());\n+\n+  /* Look for a branch that is longer than normal.  The normal length for\n+     non-MIPS16 branches is 8, because the length includes the delay slot.\n+     It is 4 for MIPS16, because MIPS16 branches are extended instructions,\n+     but they have no delay slot.  */\n+  normal_length = (TARGET_MIPS16 ? 4 : 8);\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (JUMP_P (insn)\n+\t&& USEFUL_INSN_P (insn)\n+\t&& get_attr_length (insn) > normal_length)\n+      break;\n+\n+  if (insn == NULL_RTX)\n+    return false;\n+\n+  /* We've now established that we need $gp.  */\n+  cfun->machine->must_initialize_gp_p = true;\n+  split_all_insns_noflow ();\n+\n+  return true;\n+}\n+\n /* Implement TARGET_MACHINE_DEPENDENT_REORG.  */\n \n static void\n@@ -14189,6 +14602,10 @@ mips_reorg (void)\n       && TUNE_MIPS4130\n       && TARGET_VR4130_ALIGN)\n     vr4130_align_insns ();\n+  if (mips_expand_ghost_gp_insns ())\n+    /* The expansion could invalidate some of the VR4130 alignment\n+       optimizations, but this should be an extremely rare case anyhow.  */\n+    mips_reorg_process_insns ();\n }\n \f\n /* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n@@ -14222,6 +14639,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t TARGET_CALL_SAVED_GP.  */\n       cfun->machine->global_pointer\n \t= TARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n+      cfun->machine->must_initialize_gp_p = true;\n       SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n \n       /* Set up the global pointer for n32 or n64 abicalls.  */\n@@ -15137,6 +15555,31 @@ mips_order_regs_for_local_alloc (void)\n     }\n }\n \n+/* Implement EH_USES.  */\n+\n+bool\n+mips_eh_uses (unsigned int regno)\n+{\n+  if (reload_completed && !TARGET_ABSOLUTE_JUMPS)\n+    {\n+      /* We need to force certain registers to be live in order to handle\n+\t PIC long branches correctly.  See mips_must_initialize_gp_p for\n+\t details.  */\n+      if (mips_cfun_has_cprestore_slot_p ())\n+\t{\n+\t  if (regno == CPRESTORE_SLOT_REGNUM)\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  if (cfun->machine->global_pointer == regno)\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* Implement EPILOGUE_USES.  */\n \n bool"}, {"sha": "eda74479ed24e9807f45088d63c9f0dfd91f53a7", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -161,10 +161,13 @@ enum mips_code_readable_setting {\n \n /* True if the call patterns should be split into a jalr followed by\n    an instruction to restore $gp.  It is only safe to split the load\n-   from the call when every use of $gp is explicit.  */\n+   from the call when every use of $gp is explicit.\n+\n+   See mips_must_initialize_gp_p for details about how we manage the\n+   global pointer.  */\n \n #define TARGET_SPLIT_CALLS \\\n-  (TARGET_EXPLICIT_RELOCS && TARGET_CALL_CLOBBERED_GP)\n+  (TARGET_EXPLICIT_RELOCS && TARGET_CALL_CLOBBERED_GP && epilogue_completed)\n \n /* True if we're generating a form of -mabicalls in which we can use\n    operators like %hi and %lo to refer to locally-binding symbols.\n@@ -202,6 +205,17 @@ enum mips_code_readable_setting {\n /* True if TARGET_USE_GOT and if $gp is a call-saved register.  */\n #define TARGET_CALL_SAVED_GP (TARGET_USE_GOT && !TARGET_CALL_CLOBBERED_GP)\n \n+/* True if we should use .cprestore to store to the cprestore slot.\n+\n+   We continue to use .cprestore for explicit-reloc code so that JALs\n+   inside inline asms will work correctly.  */\n+#define TARGET_CPRESTORE_DIRECTIVE \\\n+  (TARGET_ABICALLS_PIC2 && !TARGET_MIPS16)\n+\n+/* True if we can use the J and JAL instructions.  */\n+#define TARGET_ABSOLUTE_JUMPS \\\n+  (!flag_pic || TARGET_ABSOLUTE_ABICALLS)\n+\n /* True if indirect calls must use register class PIC_FN_ADDR_REG.\n    This is true for both the PIC and non-PIC VxWorks RTP modes.  */\n #define TARGET_USE_PIC_FN_ADDR_REG (TARGET_ABICALLS || TARGET_VXWORKS_RTP)\n@@ -1300,6 +1314,8 @@ enum mips_code_readable_setting {\n \n #define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, GP_REG_FIRST + 3)\n \n+#define EH_USES(N) mips_eh_uses (N)\n+\n /* Offsets recorded in opcodes are a multiple of this alignment factor.\n    The default for this in 64-bit mode is 8, which causes problems with\n    SFmode register saves.  */\n@@ -1543,11 +1559,12 @@ enum mips_code_readable_setting {\n    - 8 condition code registers\n    - 2 accumulator registers (hi and lo)\n    - 32 registers each for coprocessors 0, 2 and 3\n-   - 3 fake registers:\n+   - 4 fake registers:\n \t- ARG_POINTER_REGNUM\n \t- FRAME_POINTER_REGNUM\n \t- GOT_VERSION_REGNUM (see the comment above load_call<mode> for details)\n-   - 3 dummy entries that were used at various times in the past.\n+\t- CPRESTORE_SLOT_REGNUM\n+   - 2 dummy entries that were used at various times in the past.\n    - 6 DSP accumulator registers (3 hi-lo pairs) for MIPS DSP ASE\n    - 6 DSP control registers  */\n \n@@ -2661,6 +2678,13 @@ typedef struct mips_args {\n #define MIPS_BRANCH(OPCODE, OPERANDS) \\\n   \"%*\" OPCODE \"%?\\t\" OPERANDS \"%/\"\n \n+/* Return an asm string that forces INSN to be treated as an absolute\n+   J or JAL instruction instead of an assembler macro.  */\n+#define MIPS_ABSOLUTE_JUMP(INSN) \\\n+  (TARGET_ABICALLS_PIC2\t\t\t\t\t\t\\\n+   ? \".option\\tpic0\\n\\t\" INSN \"\\n\\t.option\\tpic2\"\t\t\\\n+   : INSN)\n+\n /* Return the asm template for a call.  INSN is the instruction's mnemonic\n    (\"j\" or \"jal\"), OPERANDS are its operands, and OPNO is the operand number\n    of the target.\n@@ -2675,11 +2699,7 @@ typedef struct mips_args {\n    ? \"%*\" INSN \"\\t%\" #OPNO \"%/\"\t\t\t\t\t\\\n    : REG_P (OPERANDS[OPNO])\t\t\t\t\t\\\n    ? \"%*\" INSN \"r\\t%\" #OPNO \"%/\"\t\t\t\t\\\n-   : TARGET_ABICALLS_PIC2\t\t\t\t\t\\\n-   ? (\".option\\tpic0\\n\\t\"\t\t\t\t\t\\\n-      \"%*\" INSN \"\\t%\" #OPNO \"%/\\n\\t\"\t\t\t\t\\\n-      \".option\\tpic2\")\t\t\t\t\t\t\\\n-   : \"%*\" INSN \"\\t%\" #OPNO \"%/\")\n+   : MIPS_ABSOLUTE_JUMP (\"%*\" INSN \"\\t%\" #OPNO \"%/\"))\n \f\n /* Control the assembler format that we output.  */\n \n@@ -2707,7 +2727,7 @@ typedef struct mips_args {\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t   \\\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t   \\\n   \"hi\",   \"lo\",   \"\",     \"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\t   \\\n-  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"\", \"\", \"$arg\", \"$frame\", \"$fakec\",\t\t   \\\n+  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"\", \"$cprestore\", \"$arg\", \"$frame\", \"$fakec\",\t   \\\n   \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",  \\\n   \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\", \\\n   \"$c0r16\",\"$c0r17\",\"$c0r18\",\"$c0r19\",\"$c0r20\",\"$c0r21\",\"$c0r22\",\"$c0r23\", \\"}, {"sha": "4e1e7852c71038716a784a1751a954805e9f37a7", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 173, "deletions": 128, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -29,11 +29,13 @@\n    (UNSPEC_STORE_WORD\t\t 2)\n    (UNSPEC_GET_FNADDR\t\t 3)\n    (UNSPEC_BLOCKAGE\t\t 4)\n-   (UNSPEC_CPRESTORE\t\t 5)\n-   (UNSPEC_RESTORE_GP\t\t 6)\n-   (UNSPEC_EH_RETURN\t\t 7)\n-   (UNSPEC_CONSTTABLE_INT\t 8)\n-   (UNSPEC_CONSTTABLE_FLOAT\t 9)\n+   (UNSPEC_POTENTIAL_CPRESTORE\t 5)\n+   (UNSPEC_CPRESTORE\t\t 6)\n+   (UNSPEC_RESTORE_GP\t\t 7)\n+   (UNSPEC_MOVE_GP\t\t 8)\n+   (UNSPEC_EH_RETURN\t\t 9)\n+   (UNSPEC_CONSTTABLE_INT\t10)\n+   (UNSPEC_CONSTTABLE_FLOAT\t11)\n    (UNSPEC_ALIGN\t\t14)\n    (UNSPEC_HIGH\t\t\t17)\n    (UNSPEC_LOAD_LEFT\t\t18)\n@@ -77,6 +79,7 @@\n    (UNSPEC_ADDRESS_FIRST\t100)\n \n    (TLS_GET_TP_REGNUM\t\t3)\n+   (CPRESTORE_SLOT_REGNUM\t76)\n    (GOT_VERSION_REGNUM\t\t79)\n \n    ;; For MIPS Paired-Singled Floating Point Instructions.\n@@ -256,6 +259,9 @@\n \n    (UNSPEC_MIPS_CACHE\t\t600)\n    (UNSPEC_R10K_CACHE_BARRIER\t601)\n+\n+   ;; PIC long branch sequences are never longer than 100 bytes.\n+   (MAX_PIC_BRANCH_LENGTH\t100)\n   ]\n )\n \n@@ -281,12 +287,11 @@\n ;;\n ;; jal is always a macro for TARGET_CALL_CLOBBERED_GP because it includes\n ;; an instruction to restore $gp.  Direct jals are also macros for\n-;; flag_pic && !TARGET_ABSOLUTE_ABICALLS because they first load\n-;; the target address into a register.\n+;; !TARGET_ABSOLUTE_JUMPS because they first load the target address\n+;; into a register.\n (define_attr \"jal_macro\" \"no,yes\"\n   (cond [(eq_attr \"jal\" \"direct\")\n-\t (symbol_ref \"((TARGET_CALL_CLOBBERED_GP\n-\t\t\t|| (flag_pic && !TARGET_ABSOLUTE_ABICALLS))\n+\t (symbol_ref \"(TARGET_CALL_CLOBBERED_GP || !TARGET_ABSOLUTE_JUMPS\n \t\t       ? JAL_MACRO_YES : JAL_MACRO_NO)\")\n \t (eq_attr \"jal\" \"indirect\")\n \t (symbol_ref \"(TARGET_CALL_CLOBBERED_GP\n@@ -498,9 +503,10 @@\n \t       (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n \t  (const_int 8)\n \n-\t  ;; Direct branch instructions have a range of [-0x40000,0x3fffc].\n-\t  ;; If a branch is outside this range, we have a choice of two\n-\t  ;; sequences.  For PIC, an out-of-range branch like:\n+\t  ;; Direct branch instructions have a range of [-0x20000,0x1fffc],\n+\t  ;; relative to the address of the delay slot.  If a branch is\n+\t  ;; outside this range, we have a choice of two sequences.\n+\t  ;; For PIC, an out-of-range branch like:\n \t  ;;\n \t  ;;\tbne\tr1,r2,target\n \t  ;;\tdslot\n@@ -514,9 +520,6 @@\n \t  ;;\tnop\n \t  ;; 1:\n \t  ;;\n-\t  ;; where the load address can be up to three instructions long\n-\t  ;; (lw, nop, addiu).\n-\t  ;;\n \t  ;; The non-PIC case is similar except that we use a direct\n \t  ;; jump instead of an la/jr pair.  Since the target of this\n \t  ;; jump is an absolute 28-bit bit address (the other bits\n@@ -531,12 +534,21 @@\n \t  ;; will add the length of the implicit nop.  The values for\n \t  ;; forward and backward branches will be different as well.\n \t  (eq_attr \"type\" \"branch\")\n-\t  (cond [(and (le (minus (match_dup 1) (pc)) (const_int 131064))\n-                      (le (minus (pc) (match_dup 1)) (const_int 131068)))\n-                  (const_int 4)\n-\t\t (ne (symbol_ref \"flag_pic\") (const_int 0))\n-\t\t (const_int 24)\n-\t\t ] (const_int 12))\n+\t  (cond [(and (le (minus (match_dup 0) (pc)) (const_int 131064))\n+\t\t\t  (le (minus (pc) (match_dup 0)) (const_int 131068)))\n+\t\t   (const_int 4)\n+\n+\t\t ;; The non-PIC case: branch, first delay slot, and J.\n+\t\t (ne (symbol_ref \"TARGET_ABSOLUTE_JUMPS\") (const_int 0))\n+\t\t   (const_int 12)]\n+\n+\t\t ;; Use MAX_PIC_BRANCH_LENGTH as a (gross) overestimate.\n+\t\t ;; mips_adjust_insn_length substitutes the correct length.\n+\t\t ;;\n+\t\t ;; Note that we can't simply use (symbol_ref ...) here\n+\t\t ;; because genattrtab needs to know the maximum length\n+\t\t ;; of an insn.\n+\t\t (const_int MAX_PIC_BRANCH_LENGTH))\n \n \t  ;; \"Ghost\" instructions occupy no space.\n \t  (eq_attr \"type\" \"ghost\")\n@@ -4754,12 +4766,12 @@\n ;; function address.\n (define_insn_and_split \"loadgp_newabi_<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n-\t(unspec_volatile:P [(match_operand:P 1)\n-\t\t\t    (match_operand:P 2 \"register_operand\" \"d\")]\n-\t\t\t   UNSPEC_LOADGP))]\n+\t(unspec:P [(match_operand:P 1)\n+\t\t   (match_operand:P 2 \"register_operand\" \"d\")]\n+\t\t  UNSPEC_LOADGP))]\n   \"mips_current_loadgp_style () == LOADGP_NEWABI\"\n-  \"#\"\n-  \"\"\n+  { return mips_must_initialize_gp_p () ? \"#\" : \"\"; }\n+  \"&& mips_must_initialize_gp_p ()\"\n   [(set (match_dup 0) (match_dup 3))\n    (set (match_dup 0) (match_dup 4))\n    (set (match_dup 0) (match_dup 5))]\n@@ -4768,21 +4780,21 @@\n   operands[4] = gen_rtx_PLUS (Pmode, operands[0], operands[2]);\n   operands[5] = gen_rtx_LO_SUM (Pmode, operands[0], operands[1]);\n }\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"ghost\")])\n \n ;; Likewise, for -mno-shared code.  Operand 0 is the __gnu_local_gp symbol.\n (define_insn_and_split \"loadgp_absolute_<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n-\t(unspec_volatile:P [(match_operand:P 1)] UNSPEC_LOADGP))]\n+\t(unspec:P [(match_operand:P 1)] UNSPEC_LOADGP))]\n   \"mips_current_loadgp_style () == LOADGP_ABSOLUTE\"\n-  \"#\"\n-  \"\"\n+  { return mips_must_initialize_gp_p () ? \"#\" : \"\"; }\n+  \"&& mips_must_initialize_gp_p ()\"\n   [(const_int 0)]\n {\n   mips_emit_move (operands[0], operands[1]);\n   DONE;\n }\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"ghost\")])\n \n ;; This blockage instruction prevents the gp load from being\n ;; scheduled after an implicit use of gp.  It also prevents\n@@ -4791,19 +4803,18 @@\n   [(unspec_volatile [(reg:SI 28)] UNSPEC_BLOCKAGE)]\n   \"\"\n   \"\"\n-  [(set_attr \"type\" \"ghost\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"ghost\")])\n \n ;; Initialize $gp for RTP PIC.  Operand 0 is the __GOTT_BASE__ symbol\n ;; and operand 1 is the __GOTT_INDEX__ symbol.\n (define_insn_and_split \"loadgp_rtp_<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n-\t(unspec_volatile:P [(match_operand:P 1 \"symbol_ref_operand\")\n-\t\t\t    (match_operand:P 2 \"symbol_ref_operand\")]\n-\t\t\t   UNSPEC_LOADGP))]\n+\t(unspec:P [(match_operand:P 1 \"symbol_ref_operand\")\n+\t\t   (match_operand:P 2 \"symbol_ref_operand\")]\n+\t\t  UNSPEC_LOADGP))]\n   \"mips_current_loadgp_style () == LOADGP_RTP\"\n-  \"#\"\n-  \"\"\n+  { return mips_must_initialize_gp_p () ? \"#\" : \"\"; }\n+  \"&& mips_must_initialize_gp_p ()\"\n   [(set (match_dup 0) (high:P (match_dup 3)))\n    (set (match_dup 0) (unspec:P [(match_dup 0)\n \t\t\t\t (match_dup 3)] UNSPEC_LOAD_GOT))\n@@ -4813,37 +4824,72 @@\n   operands[3] = mips_unspec_address (operands[1], SYMBOL_ABSOLUTE);\n   operands[4] = mips_unspec_address (operands[2], SYMBOL_HALF);\n }\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"ghost\")])\n \n ;; Initialize the global pointer for MIPS16 code.  Operand 0 is the\n ;; global pointer and operand 1 is the MIPS16 register that holds\n ;; the required value.\n (define_insn_and_split \"copygp_mips16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n-\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"d\")]\n-\t\t\t    UNSPEC_COPYGP))]\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_COPYGP))]\n   \"TARGET_MIPS16\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))])\n+  { return mips_must_initialize_gp_p () ? \"#\" : \"\"; }\n+  \"&& mips_must_initialize_gp_p ()\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\"\n+  [(set_attr \"type\" \"ghost\")])\n+\n+;; A placeholder for where the cprestore instruction should go,\n+;; if we decide we need one.  Operand 0 and operand 1 are as for\n+;; \"cprestore\".  Operand 2 is a register that holds the gp value.\n+;;\n+;; The \"cprestore\" pattern requires operand 2 to be pic_offset_table_rtx,\n+;; otherwise any register that holds the correct value will do.\n+(define_insn_and_split \"potential_cprestore\"\n+  [(set (match_operand:SI 0 \"cprestore_save_slot_operand\" \"=X,X\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"I,i\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"d,d\")]\n+\t\t   UNSPEC_POTENTIAL_CPRESTORE))\n+   (clobber (match_operand:SI 3 \"scratch_operand\" \"=X,&d\"))]\n+  \"!TARGET_CPRESTORE_DIRECTIVE || operands[2] == pic_offset_table_rtx\"\n+  { return mips_must_initialize_gp_p () ? \"#\" : \"\"; }\n+  \"mips_must_initialize_gp_p ()\"\n+  [(const_int 0)]\n+{\n+  mips_save_gp_to_cprestore_slot (operands[0], operands[1],\n+\t\t\t\t  operands[2], operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"ghost\")])\n \n ;; Emit a .cprestore directive, which normally expands to a single store\n-;; instruction.  Note that we continue to use .cprestore for explicit reloc\n-;; code so that jals inside inline asms will work correctly.\n+;; instruction.  Operand 0 is a (possibly illegitimate) sp-based MEM\n+;; for the cprestore slot.  Operand 1 is the offset of the slot from\n+;; the stack pointer.  (This is redundant with operand 0, but it makes\n+;; things a little simpler.)\n (define_insn \"cprestore\"\n-  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"I,i\")\n-                     (use (reg:SI 28))]\n-\t\t    UNSPEC_CPRESTORE)]\n-  \"\"\n+  [(set (match_operand:SI 0 \"cprestore_save_slot_operand\" \"=X,X\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"I,i\")\n+\t\t    (reg:SI 28)]\n+\t\t   UNSPEC_CPRESTORE))]\n+  \"TARGET_CPRESTORE_DIRECTIVE\"\n {\n   if (mips_nomacro.nesting_level > 0 && which_alternative == 1)\n-    return \".set\\tmacro\\;.cprestore\\t%0\\;.set\\tnomacro\";\n+    return \".set\\tmacro\\;.cprestore\\t%1\\;.set\\tnomacro\";\n   else\n-    return \".cprestore\\t%0\";\n+    return \".cprestore\\t%1\";\n }\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4,12\")])\n \n+(define_insn \"use_cprestore\"\n+  [(set (reg:SI CPRESTORE_SLOT_REGNUM)\n+\t(match_operand:SI 0 \"cprestore_load_slot_operand\"))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"ghost\")])\n+\n ;; Expand in-line code to clear the instruction cache between operand[0] and\n ;; operand[1].\n (define_expand \"clear_cache\"\n@@ -5149,100 +5195,94 @@\n (define_insn \"*branch_fp\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator 0 \"equality_operator\"\n+         (match_operator 1 \"equality_operator\"\n                          [(match_operand:CC 2 \"register_operand\" \"z\")\n \t\t\t  (const_int 0)])\n-         (label_ref (match_operand 1 \"\" \"\"))\n+         (label_ref (match_operand 0 \"\" \"\"))\n          (pc)))]\n   \"TARGET_HARD_FLOAT\"\n {\n   return mips_output_conditional_branch (insn, operands,\n-\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%Z2%1\"),\n-\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%Z2%1\"));\n+\t\t\t\t\t MIPS_BRANCH (\"b%F1\", \"%Z2%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%W1\", \"%Z2%0\"));\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n (define_insn \"*branch_fp_inverted\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator 0 \"equality_operator\"\n+         (match_operator 1 \"equality_operator\"\n                          [(match_operand:CC 2 \"register_operand\" \"z\")\n \t\t\t  (const_int 0)])\n          (pc)\n-         (label_ref (match_operand 1 \"\" \"\"))))]\n+         (label_ref (match_operand 0 \"\" \"\"))))]\n   \"TARGET_HARD_FLOAT\"\n {\n   return mips_output_conditional_branch (insn, operands,\n-\t\t\t\t\t MIPS_BRANCH (\"b%W0\", \"%Z2%1\"),\n-\t\t\t\t\t MIPS_BRANCH (\"b%F0\", \"%Z2%1\"));\n+\t\t\t\t\t MIPS_BRANCH (\"b%W1\", \"%Z2%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%F1\", \"%Z2%0\"));\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n ;; Conditional branches on ordered comparisons with zero.\n \n (define_insn \"*branch_order<mode>\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"order_operator\"\n+\t (match_operator 1 \"order_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n \t\t\t  (const_int 0)])\n-\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))]\n   \"!TARGET_MIPS16\"\n   { return mips_output_order_conditional_branch (insn, operands, false); }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n (define_insn \"*branch_order<mode>_inverted\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"order_operator\"\n+\t (match_operator 1 \"order_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n \t\t\t  (const_int 0)])\n \t (pc)\n-\t (label_ref (match_operand 1 \"\" \"\"))))]\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n   \"!TARGET_MIPS16\"\n   { return mips_output_order_conditional_branch (insn, operands, true); }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n ;; Conditional branch on equality comparison.\n \n (define_insn \"*branch_equality<mode>\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"equality_operator\"\n+\t (match_operator 1 \"equality_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n \t\t\t  (match_operand:GPR 3 \"reg_or_0_operand\" \"dJ\")])\n-\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))]\n   \"!TARGET_MIPS16\"\n {\n   return mips_output_conditional_branch (insn, operands,\n-\t\t\t\t\t MIPS_BRANCH (\"b%C0\", \"%2,%z3,%1\"),\n-\t\t\t\t\t MIPS_BRANCH (\"b%N0\", \"%2,%z3,%1\"));\n+\t\t\t\t\t MIPS_BRANCH (\"b%C1\", \"%2,%z3,%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%N1\", \"%2,%z3,%0\"));\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n (define_insn \"*branch_equality<mode>_inverted\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"equality_operator\"\n+\t (match_operator 1 \"equality_operator\"\n \t\t\t [(match_operand:GPR 2 \"register_operand\" \"d\")\n \t\t\t  (match_operand:GPR 3 \"reg_or_0_operand\" \"dJ\")])\n \t (pc)\n-\t (label_ref (match_operand 1 \"\" \"\"))))]\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n   \"!TARGET_MIPS16\"\n {\n   return mips_output_conditional_branch (insn, operands,\n-\t\t\t\t\t MIPS_BRANCH (\"b%N0\", \"%2,%z3,%1\"),\n-\t\t\t\t\t MIPS_BRANCH (\"b%C0\", \"%2,%z3,%1\"));\n+\t\t\t\t\t MIPS_BRANCH (\"b%N1\", \"%2,%z3,%0\"),\n+\t\t\t\t\t MIPS_BRANCH (\"b%C1\", \"%2,%z3,%0\"));\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n ;; MIPS16 branches\n \n@@ -5271,8 +5311,7 @@\n \treturn \"bt%N0z\\t%3\";\n     }\n }\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n (define_expand \"cbranch<mode>4\"\n   [(set (pc)\n@@ -5313,42 +5352,40 @@\n   [(set (pc)\n \t(if_then_else\n \t (equality_op (zero_extract:GPR\n-\t\t       (match_operand:GPR 0 \"register_operand\" \"d\")\n+\t\t       (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t       (const_int 1)\n \t\t       (match_operand 2 \"const_int_operand\" \"\"))\n \t\t      (const_int 0))\n-\t (label_ref (match_operand 1 \"\"))\n+\t (label_ref (match_operand 0 \"\"))\n \t (pc)))]\n   \"ISA_HAS_BBIT && UINTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode)\"\n {\n   return\n     mips_output_conditional_branch (insn, operands,\n-\t\t\t\t    MIPS_BRANCH (\"bbit<bbv>\", \"%0,%2,%1\"),\n-\t\t\t\t    MIPS_BRANCH (\"bbit<bbinv>\", \"%0,%2,%1\"));\n+\t\t\t\t    MIPS_BRANCH (\"bbit<bbv>\", \"%1,%2,%0\"),\n+\t\t\t\t    MIPS_BRANCH (\"bbit<bbinv>\", \"%1,%2,%0\"));\n }\n   [(set_attr \"type\"\t     \"branch\")\n-   (set_attr \"mode\"\t     \"none\")\n    (set_attr \"branch_likely\" \"no\")])\n \n (define_insn \"*branch_bit<bbv><mode>_inverted\"\n   [(set (pc)\n \t(if_then_else\n \t (equality_op (zero_extract:GPR\n-\t\t       (match_operand:GPR 0 \"register_operand\" \"d\")\n+\t\t       (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t       (const_int 1)\n \t\t       (match_operand 2 \"const_int_operand\" \"\"))\n \t\t      (const_int 0))\n \t (pc)\n-\t (label_ref (match_operand 1 \"\"))))]\n+\t (label_ref (match_operand 0 \"\"))))]\n   \"ISA_HAS_BBIT && UINTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode)\"\n {\n   return\n     mips_output_conditional_branch (insn, operands,\n-\t\t\t\t    MIPS_BRANCH (\"bbit<bbinv>\", \"%0,%2,%1\"),\n-\t\t\t\t    MIPS_BRANCH (\"bbit<bbv>\", \"%0,%2,%1\"));\n+\t\t\t\t    MIPS_BRANCH (\"bbit<bbinv>\", \"%1,%2,%0\"),\n+\t\t\t\t    MIPS_BRANCH (\"bbit<bbv>\", \"%1,%2,%0\"));\n }\n   [(set_attr \"type\"\t     \"branch\")\n-   (set_attr \"mode\"\t     \"none\")\n    (set_attr \"branch_likely\" \"no\")])\n \f\n ;;\n@@ -5535,47 +5572,41 @@\n \n ;; Unconditional branches.\n \n-(define_insn \"jump\"\n+(define_expand \"jump\"\n   [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"!TARGET_MIPS16\"\n+\t(label_ref (match_operand 0)))])\n+\n+(define_insn \"*jump_absolute\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0)))]\n+  \"!TARGET_MIPS16 && TARGET_ABSOLUTE_JUMPS\"\n+  { return MIPS_ABSOLUTE_JUMP (\"%*j\\t%l0%/\"); }\n+  [(set_attr \"type\" \"jump\")])\n+\n+(define_insn \"*jump_pic\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0)))]\n+  \"!TARGET_MIPS16 && !TARGET_ABSOLUTE_JUMPS\"\n {\n-  if (flag_pic)\n+  if (get_attr_length (insn) <= 8)\n+    return \"%*b\\t%l0%/\";\n+  else\n     {\n-      if (get_attr_length (insn) <= 8)\n-\treturn \"%*b\\t%l0%/\";\n-      else\n-\t{\n-\t  output_asm_insn (mips_output_load_label (), operands);\n-\t  return \"%*jr\\t%@%/%]\";\n-\t}\n+      mips_output_load_label (operands[0]);\n+      return \"%*jr\\t%@%/%]\";\n     }\n-  else\n-    return \"%*j\\t%l0%/\";\n }\n-  [(set_attr \"type\"\t\"jump\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set (attr \"length\")\n-\t;; We can't use `j' when emitting PIC.  Emit a branch if it's\n-\t;; in range, otherwise load the address of the branch target into\n-\t;; $at and then jump to it.\n-\t(if_then_else\n-\t (ior (eq (symbol_ref \"flag_pic\") (const_int 0))\n-\t      (lt (abs (minus (match_dup 0)\n-\t\t\t      (plus (pc) (const_int 4))))\n-\t\t  (const_int 131072)))\n-\t (const_int 4) (const_int 16)))])\n+  [(set_attr \"type\" \"branch\")])\n \n ;; We need a different insn for the mips16, because a mips16 branch\n ;; does not have a delay slot.\n \n-(define_insn \"\"\n+(define_insn \"*jump_mips16\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"TARGET_MIPS16\"\n   \"b\\t%l0\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n+  [(set_attr \"type\" \"branch\")])\n \n (define_expand \"indirect_jump\"\n   [(set (pc) (match_operand 0 \"register_operand\"))]\n@@ -5876,14 +5907,28 @@\n    (clobber (match_scratch:SI 0 \"=&d\"))]\n   \"TARGET_CALL_CLOBBERED_GP\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"&& epilogue_completed\"\n   [(const_int 0)]\n {\n-  mips_restore_gp (operands[0]);\n+  mips_restore_gp_from_cprestore_slot (operands[0]);\n   DONE;\n }\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"ghost\")])\n+\n+;; Move between $gp and its register save slot.\n+(define_insn_and_split \"move_gp<mode>\"\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d,m\")\n+  \t(unspec:GPR [(match_operand:GPR 1 \"move_operand\" \"m,d\")]\n+\t\t    UNSPEC_MOVE_GP))]\n+  \"\"\n+  { return mips_must_initialize_gp_p () ? \"#\" : \"\"; }\n+  \"mips_must_initialize_gp_p ()\"\n+  [(const_int 0)]\n+{\n+  mips_emit_move (operands[0], operands[1]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"ghost\")])\n \f\n ;;\n ;;  ...................."}, {"sha": "e1cb4573688ff26f26ab71675bf4527a8c292795", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -244,6 +244,14 @@\n     }\n })\n \n+(define_predicate \"cprestore_save_slot_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"mips_cprestore_address_p (XEXP (op, 0), false)\")))\n+\n+(define_predicate \"cprestore_load_slot_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"mips_cprestore_address_p (XEXP (op, 0), true)\")))\n+\n (define_predicate \"consttable_operand\"\n   (match_test \"CONSTANT_P (op)\"))\n "}, {"sha": "23e9dbf5b025f2e843cc1b4a00db8c8b20fad16d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -1,3 +1,21 @@\n+2009-09-14  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/branch-helper.h: New file.\n+\t* gcc.target/mips/branch-2.c,\n+\t* gcc.target/mips/branch-3.c,\n+\t* gcc.target/mips/branch-4.c,\n+\t* gcc.target/mips/branch-5.c,\n+\t* gcc.target/mips/branch-6.c,\n+\t* gcc.target/mips/branch-7.c,\n+\t* gcc.target/mips/branch-8.c,\n+\t* gcc.target/mips/branch-9.c,\n+\t* gcc.target/mips/branch-10.c,\n+\t* gcc.target/mips/branch-11.c,\n+\t* gcc.target/mips/branch-12.c,\n+\t* gcc.target/mips/branch-13.c,\n+\t* gcc.target/mips/branch-14.c,\n+\t* gcc.target/mips/branch-15.c: New tests.\n+\n 2009-09-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/41331"}, {"sha": "7fdebfcc3f62e47de6acd304340b2e3ba16dbaeb", "filename": "gcc/testsuite/gcc.target/mips/branch-10.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-10.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=n32\" } */\n+/* { dg-final { scan-assembler-not \"(\\\\\\$28|%gp_rel|%got)\" } } */\n+/* { dg-final { scan-assembler-not \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (void (*bar) (void), volatile int *x)\n+{\n+  bar ();\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}"}, {"sha": "1c57f82f5330a3c1deb7e98acb16622fa8088041", "filename": "gcc/testsuite/gcc.target/mips/branch-11.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-11.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=n32\" } */\n+/* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$28,\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$28,\" } } */\n+/* { dg-final { scan-assembler \"\\taddiu\\t\\\\\\$28,\\\\\\$28,%lo\\\\(%neg\\\\(%gp_rel\\\\(foo\\\\)\\\\)\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tlw\\t\\\\\\$1,%got_page\\\\(\\[^)\\]*\\\\)\\\\(\\\\\\$28\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\taddiu\\t\\\\\\$1,\\\\\\$1,%got_ofst\\\\(\\[^)\\]*\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (void (*bar) (void), volatile int *x)\n+{\n+  bar ();\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}"}, {"sha": "f1b6f1e82444dbd3362b5947889b9dbfde81c6ff", "filename": "gcc/testsuite/gcc.target/mips/branch-12.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-12.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=64\" } */\n+/* { dg-final { scan-assembler-not \"(\\\\\\$28|%gp_rel|%got)\" } } */\n+/* { dg-final { scan-assembler-not \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (void (*bar) (void), volatile int *x)\n+{\n+  bar ();\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}"}, {"sha": "cc0b607d7281d9311320377469c45871dae511b5", "filename": "gcc/testsuite/gcc.target/mips/branch-13.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-13.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=64\" } */\n+/* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$28,\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$28,\" } } */\n+/* { dg-final { scan-assembler \"\\tdaddiu\\t\\\\\\$28,\\\\\\$28,%lo\\\\(%neg\\\\(%gp_rel\\\\(foo\\\\)\\\\)\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$1,%got_page\\\\(\\[^)\\]*\\\\)\\\\(\\\\\\$28\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdaddiu\\t\\\\\\$1,\\\\\\$1,%got_ofst\\\\(\\[^)\\]*\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (void (*bar) (void), volatile int *x)\n+{\n+  bar ();\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}"}, {"sha": "026417e162b2a382b9c32651b7d1d5355867bb00", "filename": "gcc/testsuite/gcc.target/mips/branch-14.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-14.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,23 @@\n+/* An executable version of branch-2.c.  */\n+/* { dg-do run } */\n+\n+#include \"branch-helper.h\"\n+\n+void __attribute__((noinline))\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}\n+\n+int\n+main (void)\n+{\n+  int x = 0;\n+  int y = 1;\n+\n+  foo (&x);\n+  foo (&y);\n+\n+  return 0;\n+}"}, {"sha": "dee7a0504d6335ecaf1c920a3a3a1e25b2ad2843", "filename": "gcc/testsuite/gcc.target/mips/branch-15.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-15.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,23 @@\n+/* An executable version of branch-3.c.  */\n+/* { dg-do run } */\n+\n+#include \"branch-helper.h\"\n+\n+void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}\n+\n+int\n+main (void)\n+{\n+  int x = 0;\n+  int y = 1;\n+\n+  foo (&x);\n+  foo (&y);\n+\n+  return 0;\n+}"}, {"sha": "845e7481729f1ecd5f4c87f788b9d78042cc660a", "filename": "gcc/testsuite/gcc.target/mips/branch-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-2.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=32\" } */\n+/* { dg-final { scan-assembler-not \"(\\\\\\$25|\\\\\\$28|cpload)\" } } */\n+/* { dg-final { scan-assembler-not \"\\tjr\\t\\\\\\$1\\n\" } } */\n+/* { dg-final { scan-assembler-not \"cprestore\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}"}, {"sha": "0a4ffbba604196abb1139faef8d3e09ceb4e9552", "filename": "gcc/testsuite/gcc.target/mips/branch-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-3.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=32\" } */\n+/* { dg-final { scan-assembler \"\\t\\\\.cpload\\t\\\\\\$25\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tjr\\t\\\\\\$1\\n\" } } */\n+/* { dg-final { scan-assembler-not \"cprestore\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}"}, {"sha": "277bd0af76fce721a6d973fec5f10aead5bc8c04", "filename": "gcc/testsuite/gcc.target/mips/branch-4.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-4.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=n32\" } */\n+/* { dg-final { scan-assembler-not \"(\\\\\\$25|\\\\\\$28|%gp_rel|%got)\" } } */\n+/* { dg-final { scan-assembler-not \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}"}, {"sha": "3d151d824ef87dd7648e17cc66be391470e8029a", "filename": "gcc/testsuite/gcc.target/mips/branch-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-5.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=n32\" } */\n+/* { dg-final { scan-assembler \"\\taddiu\\t\\\\\\$3,\\\\\\$3,%lo\\\\(%neg\\\\(%gp_rel\\\\(foo\\\\)\\\\)\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tlw\\t\\\\\\$1,%got_page\\\\(\\[^)\\]*\\\\)\\\\(\\\\\\$3\\\\)\\\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tjr\\t\\\\\\$1\\n\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$28\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}"}, {"sha": "9bf73f01c9b8c92bda3535f2431b706e0cc82b8f", "filename": "gcc/testsuite/gcc.target/mips/branch-6.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-6.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=64\" } */\n+/* { dg-final { scan-assembler-not \"(\\\\\\$25|\\\\\\$28|%gp_rel|%got)\" } } */\n+/* { dg-final { scan-assembler-not \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}"}, {"sha": "053ec610c3d7c9b47b8f6feba82e73c035fa0db9", "filename": "gcc/testsuite/gcc.target/mips/branch-7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-7.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=64\" } */\n+/* { dg-final { scan-assembler \"\\tdaddiu\\t\\\\\\$3,\\\\\\$3,%lo\\\\(%neg\\\\(%gp_rel\\\\(foo\\\\)\\\\)\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$1,%got_page\\\\(\\[^)\\]*\\\\)\\\\(\\\\\\$3\\\\)\\\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tjr\\t\\\\\\$1\\n\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\\\$28\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (volatile int *x)\n+{\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}"}, {"sha": "c2cbae3690504990c3215337bda894b9feb3cebf", "filename": "gcc/testsuite/gcc.target/mips/branch-8.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-8.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=32\" } */\n+/* { dg-final { scan-assembler-not \"(\\\\\\$28|cpload|cprestore)\" } } */\n+/* { dg-final { scan-assembler-not \"\\tjr\\t\\\\\\$1\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (void (*bar) (void), volatile int *x)\n+{\n+  bar ();\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fff8;\n+}"}, {"sha": "2b83ea5b5910ce385b2503e96844cde044452c2b", "filename": "gcc/testsuite/gcc.target/mips/branch-9.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-9.c?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-mabicalls -mshared -mabi=32\" } */\n+/* { dg-final { scan-assembler \"\\t\\\\.cpload\\t\\\\\\$25\\n\" } } */\n+/* { dg-final { scan-assembler \"\\t\\\\.cprestore\\t16\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tlw\\t\\\\\\$1,16\\\\(\\\\\\$fp\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tlw\\t\\\\\\$1,%got\\\\(\\[^)\\]*\\\\)\\\\(\\\\\\$1\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\taddiu\\t\\\\\\$1,\\\\\\$1,%lo\\\\(\\[^)\\]*\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tjr\\t\\\\\\$1\\n\" } } */\n+/* { dg-final { scan-assembler-not \"\\tlw\\t\\\\\\$28,16\\\\(\\\\\\$sp\\\\)\\n\" } } */\n+\n+#include \"branch-helper.h\"\n+\n+NOMIPS16 void\n+foo (void (*bar) (void), volatile int *x)\n+{\n+  bar ();\n+  if (__builtin_expect (*x == 0, 1))\n+    OCCUPY_0x1fffc;\n+}"}, {"sha": "85399be4c7df5c5330c138c8ee8c958eb50c3596", "filename": "gcc/testsuite/gcc.target/mips/branch-helper.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-helper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c433c31b31f25e3f18e58bd8d404c02722d7f7c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-helper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fbranch-helper.h?ref=0c433c31b31f25e3f18e58bd8d404c02722d7f7c", "patch": "@@ -0,0 +1,37 @@\n+/* DN(X) generates 2**N copies of asm instruction X.  */\n+#define D0(X) X\n+#define D1(X) X \"\\n\\t\" X\n+#define D2(X) D1 (D1 (X))\n+#define D3(X) D2 (D1 (X))\n+#define D4(X) D2 (D2 (X))\n+#define D5(X) D4 (D1 (X))\n+#define D6(X) D4 (D2 (X))\n+#define D7(X) D4 (D2 (D1 (X)))\n+#define D8(X) D4 (D4 (X))\n+#define D9(X) D8 (D1 (X))\n+#define D10(X) D8 (D2 (X))\n+#define D11(X) D8 (D2 (D1 (X)))\n+#define D12(X) D8 (D4 (X))\n+#define D13(X) D8 (D4 (D1 (X)))\n+#define D14(X) D8 (D4 (D2 (X)))\n+\n+/* Emit something that is 0x1fff8 bytes long, which is the largest\n+   permissible range for non-MIPS16 forward branches.  */\n+#define OCCUPY_0x1fff8 \\\n+  asm (D14 (\"nop\") \"\\n\\t\" \\\n+       D13 (\"nop\") \"\\n\\t\" \\\n+       D12 (\"nop\") \"\\n\\t\" \\\n+       D11 (\"nop\") \"\\n\\t\" \\\n+       D10 (\"nop\") \"\\n\\t\" \\\n+       D9 (\"nop\") \"\\n\\t\" \\\n+       D8 (\"nop\") \"\\n\\t\" \\\n+       D7 (\"nop\") \"\\n\\t\" \\\n+       D6 (\"nop\") \"\\n\\t\" \\\n+       D5 (\"nop\") \"\\n\\t\" \\\n+       D4 (\"nop\") \"\\n\\t\" \\\n+       D3 (\"nop\") \"\\n\\t\" \\\n+       D2 (\"nop\") \"\\n\\t\" \\\n+       D1 (\"nop\"))\n+\n+/* Likewise emit something that is 0x1fffc bytes long.  */\n+#define OCCUPY_0x1fffc do { asm (\"nop\"); OCCUPY_0x1fff8; } while (0)"}]}