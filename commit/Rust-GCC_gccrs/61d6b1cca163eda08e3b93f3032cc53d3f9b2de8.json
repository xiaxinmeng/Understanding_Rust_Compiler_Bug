{"sha": "61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFkNmIxY2NhMTYzZWRhMDhlM2I5M2YzMDMyY2M1M2QzZjliMmRlOA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-07-07T03:08:23Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-07-07T03:08:23Z"}, "message": "expr.c (expand_expr, [...]): All cleanups have to be protected by interim exception handling code.\n\n        * expr.c (expand_expr, defer_cleanups_to, expand_cleanups_to): All\n        cleanups have to be protected by interim exception handling code.\n        * stmt.c (expand_decl_cleanup, expand_cleanups): Ditto.\n        * toplev.c (interim_eh_hook): Hook for interim exception handling.\n        * toplev.c (interim_eh): Default implementation for exception\n        handling that does nothing.\n        * toplev.c (main): Set default for interim_eh_hook.\n\nFrom-SVN: r7666", "tree": {"sha": "1c752111fb50bcfb3bc6b07878787a588a0289ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c752111fb50bcfb3bc6b07878787a588a0289ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/comments", "author": null, "committer": null, "parents": [{"sha": "6bc55d0587fca7984aa2aca637803b42126a381f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc55d0587fca7984aa2aca637803b42126a381f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc55d0587fca7984aa2aca637803b42126a381f"}], "stats": {"total": 36, "additions": 35, "deletions": 1}, "files": [{"sha": "b9cd009f7af80fd9955ed477c4880a99d861f615", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "patch": "@@ -180,6 +180,7 @@ static void do_jump_for_compare\tPROTO((rtx, rtx, rtx));\n static rtx compare\t\tPROTO((tree, enum rtx_code, enum rtx_code));\n static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n static tree defer_cleanups_to\tPROTO((tree));\n+extern void (*interim_eh_hook)\tPROTO((tree));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -4616,6 +4617,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2), cleanups_this_call);\n \t  /* That's it for this cleanup.  */\n \t  TREE_OPERAND (exp, 2) = 0;\n+\t  (*interim_eh_hook) (NULL_TREE);\n \t}\n       return RTL_EXPR_RTL (exp);\n \n@@ -5657,12 +5659,14 @@ expand_expr (exp, target, tmode, modifier)\n \t    /* Now add in the conditionalized cleanups. */\n \t    cleanups_this_call\n \t      = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n+\t    (*interim_eh_hook) (NULL_TREE);\n \t  }\n \treturn temp;\n       }\n \n     case TARGET_EXPR:\n       {\n+\tint need_exception_region = 0;\n \t/* Something needs to be initialized, but we didn't know\n \t   where that thing was when building the tree.  For example,\n \t   it could be the return value of a function, or a parameter\n@@ -5674,6 +5678,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \ttree slot = TREE_OPERAND (exp, 0);\n \ttree exp1;\n+\trtx temp;\n \n \tif (TREE_CODE (slot) != VAR_DECL)\n \t  abort ();\n@@ -5709,6 +5714,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t    cleanups_this_call = tree_cons (NULL_TREE,\n \t\t\t\t\t\t    TREE_OPERAND (exp, 2),\n \t\t\t\t\t\t    cleanups_this_call);\n+\t\t    need_exception_region = 1;\n \t\t  }\n \t      }\n \t  }\n@@ -5738,7 +5744,12 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Mark it as expanded.  */\n \tTREE_OPERAND (exp, 1) = NULL_TREE;\n \n-\treturn expand_expr (exp1, target, tmode, modifier);\n+\ttemp = expand_expr (exp1, target, tmode, modifier);\n+\n+\tif (need_exception_region)\n+\t  (*interim_eh_hook) (NULL_TREE);\n+\t\n+\treturn temp;\n       }\n \n     case INIT_EXPR:\n@@ -8279,6 +8290,7 @@ defer_cleanups_to (old_cleanups)\n \n   while (cleanups_this_call != old_cleanups)\n     {\n+      (*interim_eh_hook) (TREE_VALUE (cleanups_this_call));\n       cleanups_this_call = TREE_CHAIN (cleanups_this_call);\n     }      \n \n@@ -8314,6 +8326,7 @@ expand_cleanups_to (old_cleanups)\n {\n   while (cleanups_this_call != old_cleanups)\n     {\n+      (*interim_eh_hook) (TREE_VALUE (cleanups_this_call));\n       expand_expr (TREE_VALUE (cleanups_this_call), const0_rtx, VOIDmode, 0);\n       cleanups_this_call = TREE_CHAIN (cleanups_this_call);\n     }"}, {"sha": "5c472e7095404fca235778e9e2572a256f34f9a6", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "patch": "@@ -137,6 +137,8 @@ extern tree rtl_expr_chain;\n    cleanup list whenever an empty list is required.  */\n static tree empty_cleanup_list;\n #endif\n+\n+extern void (*interim_eh_hook)\tPROTO((tree));\n \f\n /* Functions and data structures for expanding case statements.  */\n \n@@ -3483,6 +3485,7 @@ expand_decl_cleanup (decl, cleanup)\n \t= temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n       /* If this block has a cleanup, it belongs in stack_block_stack.  */\n       stack_block_stack = thisblock;\n+      (*interim_eh_hook) (NULL_TREE);\n     }\n   return 1;\n }\n@@ -3562,6 +3565,8 @@ expand_cleanups (list, dont_do)\n \t  expand_cleanups (TREE_VALUE (tail), dont_do);\n \telse\n \t  {\n+\t    (*interim_eh_hook) (TREE_VALUE (tail));\n+\n \t    /* Cleanups may be run multiple times.  For example,\n \t       when exiting a binding contour, we expand the\n \t       cleanups associated with that contour.  When a goto"}, {"sha": "d4b1043e0d023e74fe29c32088f58f36457c9f3a", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d6b1cca163eda08e3b93f3032cc53d3f9b2de8/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=61d6b1cca163eda08e3b93f3032cc53d3f9b2de8", "patch": "@@ -254,6 +254,12 @@ struct rtx_def *(*lang_expand_expr) ();\n \n void (*incomplete_decl_finalize_hook) () = 0;\n \n+/* Pointer to function for interim exception handling implementation.\n+   This interface will change, and it is only here until a better interface\n+   replaces it.  */\n+\n+void (*interim_eh_hook)\tPROTO((tree));\n+\n /* Nonzero if generating code to do profiling.  */\n \n int profile_flag = 0;\n@@ -996,6 +1002,15 @@ decl_name (decl, kind)\n {\n   return IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n+\n+/* This is the default interim_eh_hook function.  */\n+\n+void\n+interim_eh (finalization)\n+     tree finalization;\n+{\n+  /* Don't do anything by default.  */\n+}\n \f\n static int need_error_newline;\n \n@@ -3341,6 +3356,7 @@ main (argc, argv, envp)\n \n   decl_printable_name = decl_name;\n   lang_expand_expr = (struct rtx_def *(*)()) do_abort;\n+  interim_eh_hook = interim_eh;\n \n   /* Initialize whether `char' is signed.  */\n   flag_signed_char = DEFAULT_SIGNED_CHAR;"}]}