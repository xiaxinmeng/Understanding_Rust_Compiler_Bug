{"sha": "c13c129f8f49b41184f5b1c4b64d76d67db90dae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEzYzEyOWY4ZjQ5YjQxMTg0ZjViMWM0YjY0ZDc2ZDY3ZGI5MGRhZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-21T21:38:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-21T21:38:35Z"}, "message": "tree-vect-data-refs.c (vect_find_stmt_data_reference): Handle even zero DR_OFFSET...\n\n\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Handle\n\teven zero DR_OFFSET, but DR_BASE_ADDRESS of POINTER_PLUS_EXPR\n\tcontaining the offset as possible simd lane access.  Look through\n\twidening conversion.  Move the\n\tTREE_CODE (DR_INIT (newdr)) == INTEGER_CST test earlier and reindent.\n\n\t* g++.dg/vect/simd-2.cc: Don't xfail, instead expect vectorization on\n\tx86.\n\t* g++.dg/vect/simd-5.cc: Likewise.\n\nFrom-SVN: r272575", "tree": {"sha": "3ca866f42a378c7a70ab3a2f98620e7a9d88a692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ca866f42a378c7a70ab3a2f98620e7a9d88a692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c13c129f8f49b41184f5b1c4b64d76d67db90dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13c129f8f49b41184f5b1c4b64d76d67db90dae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13c129f8f49b41184f5b1c4b64d76d67db90dae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13c129f8f49b41184f5b1c4b64d76d67db90dae/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8924e9dd7183b97ab101e09816c88c8c1aac2bf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8924e9dd7183b97ab101e09816c88c8c1aac2bf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8924e9dd7183b97ab101e09816c88c8c1aac2bf0"}], "stats": {"total": 92, "additions": 61, "deletions": 31}, "files": [{"sha": "5cab32825d13fce71c03b9057d1ba763e3e19b0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c13c129f8f49b41184f5b1c4b64d76d67db90dae", "patch": "@@ -1,3 +1,11 @@\n+2019-06-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Handle\n+\teven zero DR_OFFSET, but DR_BASE_ADDRESS of POINTER_PLUS_EXPR\n+\tcontaining the offset as possible simd lane access.  Look through\n+\twidening conversion.  Move the\n+\tTREE_CODE (DR_INIT (newdr)) == INTEGER_CST test earlier and reindent.\n+\n 2019-06-21  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/90930"}, {"sha": "5e94d9a83387e11320044dc479b793ff54e16b39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c13c129f8f49b41184f5b1c4b64d76d67db90dae", "patch": "@@ -1,3 +1,9 @@\n+2019-06-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/vect/simd-2.cc: Don't xfail, instead expect vectorization on\n+\tx86.\n+\t* g++.dg/vect/simd-5.cc: Likewise.\n+\n 2019-06-21  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/90909"}, {"sha": "6f5737b7e40b5c2889f26cb4e4c3445e1c3822dd", "filename": "gcc/testsuite/g++.dg/vect/simd-2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-2.cc?ref=c13c129f8f49b41184f5b1c4b64d76d67db90dae", "patch": "@@ -1,7 +1,7 @@\n // { dg-require-effective-target size32plus }\n // { dg-additional-options \"-fopenmp-simd\" }\n // { dg-additional-options \"-mavx\" { target avx_runtime } }\n-// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { xfail *-*-* } } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } }\n \n #include \"../../gcc.dg/vect/tree-vect.h\"\n "}, {"sha": "dd817b8888b1b17d822f576d6d6b123f338e984f", "filename": "gcc/testsuite/g++.dg/vect/simd-5.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-5.cc?ref=c13c129f8f49b41184f5b1c4b64d76d67db90dae", "patch": "@@ -1,7 +1,7 @@\n // { dg-require-effective-target size32plus }\n // { dg-additional-options \"-fopenmp-simd\" }\n // { dg-additional-options \"-mavx\" { target avx_runtime } }\n-// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { xfail *-*-* } } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } }\n \n #include \"../../gcc.dg/vect/tree-vect.h\"\n "}, {"sha": "20c8815ee935e947667a9310b7b27c89d8c14b84", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13c129f8f49b41184f5b1c4b64d76d67db90dae/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c13c129f8f49b41184f5b1c4b64d76d67db90dae", "patch": "@@ -4072,10 +4072,18 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t  && DR_OFFSET (newdr)\n \t  && DR_INIT (newdr)\n \t  && DR_STEP (newdr)\n+\t  && TREE_CODE (DR_INIT (newdr)) == INTEGER_CST\n \t  && integer_zerop (DR_STEP (newdr)))\n \t{\n+\t  tree base_address = DR_BASE_ADDRESS (newdr);\n \t  tree off = DR_OFFSET (newdr);\n \t  tree step = ssize_int (1);\n+\t  if (integer_zerop (off)\n+\t      && TREE_CODE (base_address) == POINTER_PLUS_EXPR)\n+\t    {\n+\t      off = TREE_OPERAND (base_address, 1);\n+\t      base_address = TREE_OPERAND (base_address, 0);\n+\t    }\n \t  STRIP_NOPS (off);\n \t  if (TREE_CODE (off) == MULT_EXPR\n \t      && tree_fits_uhwi_p (TREE_OPERAND (off, 1)))\n@@ -4084,39 +4092,47 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t      off = TREE_OPERAND (off, 0);\n \t      STRIP_NOPS (off);\n \t    }\n-\t  if (TREE_CODE (DR_INIT (newdr)) == INTEGER_CST)\n+\t  if (CONVERT_EXPR_P (off)\n+\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (off, 0)))\n+\t\t  < TYPE_PRECISION (TREE_TYPE (off))))\n+\t    off = TREE_OPERAND (off, 0);\n+\t  if (TREE_CODE (off) == SSA_NAME)\n \t    {\n-\t      if (CONVERT_EXPR_P (off)\n-\t\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (off, 0)))\n-\t\t      < TYPE_PRECISION (TREE_TYPE (off))))\n-\t\toff = TREE_OPERAND (off, 0);\n-\t      if (TREE_CODE (off) == SSA_NAME)\n+\t      gimple *def = SSA_NAME_DEF_STMT (off);\n+\t      /* Look through widening conversion.  */\n+\t      if (is_gimple_assign (def)\n+\t\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def)))\n+\t\t{\n+\t\t  tree rhs1 = gimple_assign_rhs1 (def);\n+\t\t  if (TREE_CODE (rhs1) == SSA_NAME\n+\t\t      && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n+\t\t      && (TYPE_PRECISION (TREE_TYPE (off))\n+\t\t\t  > TYPE_PRECISION (TREE_TYPE (rhs1))))\n+\t\t    def = SSA_NAME_DEF_STMT (rhs1);\n+\t\t}\n+\t      if (is_gimple_call (def)\n+\t\t  && gimple_call_internal_p (def)\n+\t\t  && (gimple_call_internal_fn (def) == IFN_GOMP_SIMD_LANE))\n \t\t{\n-\t\t  gimple *def = SSA_NAME_DEF_STMT (off);\n+\t\t  tree arg = gimple_call_arg (def, 0);\n \t\t  tree reft = TREE_TYPE (DR_REF (newdr));\n-\t\t  if (is_gimple_call (def)\n-\t\t      && gimple_call_internal_p (def)\n-\t\t      && (gimple_call_internal_fn (def) == IFN_GOMP_SIMD_LANE))\n+\t\t  gcc_assert (TREE_CODE (arg) == SSA_NAME);\n+\t\t  arg = SSA_NAME_VAR (arg);\n+\t\t  if (arg == loop->simduid\n+\t\t      /* For now.  */\n+\t\t      && tree_int_cst_equal (TYPE_SIZE_UNIT (reft), step))\n \t\t    {\n-\t\t      tree arg = gimple_call_arg (def, 0);\n-\t\t      gcc_assert (TREE_CODE (arg) == SSA_NAME);\n-\t\t      arg = SSA_NAME_VAR (arg);\n-\t\t      if (arg == loop->simduid\n-\t\t\t  /* For now.  */\n-\t\t\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (reft), step))\n-\t\t\t{\n-\t\t\t  DR_OFFSET (newdr) = ssize_int (0);\n-\t\t\t  DR_STEP (newdr) = step;\n-\t\t\t  DR_OFFSET_ALIGNMENT (newdr) = BIGGEST_ALIGNMENT;\n-\t\t\t  DR_STEP_ALIGNMENT (newdr)\n-\t\t\t    = highest_pow2_factor (step);\n-\t\t\t  /* Mark as simd-lane access.  */\n-\t\t\t  tree arg2 = gimple_call_arg (def, 1);\n-\t\t\t  newdr->aux = (void *) (-1 - tree_to_uhwi (arg2));\n-\t\t\t  free_data_ref (dr);\n-\t\t\t  datarefs->safe_push (newdr);\n-\t\t\t  return opt_result::success ();\n-\t\t\t}\n+\t\t      DR_BASE_ADDRESS (newdr) = base_address;\n+\t\t      DR_OFFSET (newdr) = ssize_int (0);\n+\t\t      DR_STEP (newdr) = step;\n+\t\t      DR_OFFSET_ALIGNMENT (newdr) = BIGGEST_ALIGNMENT;\n+\t\t      DR_STEP_ALIGNMENT (newdr) = highest_pow2_factor (step);\n+\t\t      /* Mark as simd-lane access.  */\n+\t\t      tree arg2 = gimple_call_arg (def, 1);\n+\t\t      newdr->aux = (void *) (-1 - tree_to_uhwi (arg2));\n+\t\t      free_data_ref (dr);\n+\t\t      datarefs->safe_push (newdr);\n+\t\t      return opt_result::success ();\n \t\t    }\n \t\t}\n \t    }"}]}