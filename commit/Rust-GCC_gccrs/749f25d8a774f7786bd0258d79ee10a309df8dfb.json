{"sha": "749f25d8a774f7786bd0258d79ee10a309df8dfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ5ZjI1ZDhhNzc0Zjc3ODZiZDAyNThkNzllZTEwYTMwOWRmOGRmYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-10T14:57:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-10T14:57:05Z"}, "message": "ipa-cp.c (ipcp_versionable_function_p): Aliases are not versionable.\n\n\t* ipa-cp.c (ipcp_versionable_function_p): Aliases are not versionable.\n\t(ipcp_cloning_candidate_p): Aliases are not clonning candidates.\n\t(ipcp_initialize_node_lattices): We don't propagate through an aliases.\n\t(ipcp_propagate_stage): Skip aliases when propagating.\n\t(ipcp_need_redirect_p): Skip aliases.\n\t(ipcp_insert_stage): Use FOR_EACH_FUNCTION_WITH_GIMPLE_BODY and\n\tcollect_callers_of_node.\n\t* ipa-prop.c (ipa_init_func_list): Do not analyze datastructures\n\tfor aliases.\n\t(ipa_compute_jump_functions): Look through aliases.\n\nFrom-SVN: r174911", "tree": {"sha": "fb7d5174686aae02adc1c28679cbb08b775dee5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb7d5174686aae02adc1c28679cbb08b775dee5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/749f25d8a774f7786bd0258d79ee10a309df8dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749f25d8a774f7786bd0258d79ee10a309df8dfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749f25d8a774f7786bd0258d79ee10a309df8dfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749f25d8a774f7786bd0258d79ee10a309df8dfb/comments", "author": null, "committer": null, "parents": [{"sha": "9c8cf7b70ca74485589349143ba966b8d5251215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8cf7b70ca74485589349143ba966b8d5251215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8cf7b70ca74485589349143ba966b8d5251215"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "398a2d99a73a91c2fe9dd59bcde416cc929c6b54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749f25d8a774f7786bd0258d79ee10a309df8dfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749f25d8a774f7786bd0258d79ee10a309df8dfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=749f25d8a774f7786bd0258d79ee10a309df8dfb", "patch": "@@ -1,3 +1,16 @@\n+2011-06-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_versionable_function_p): Aliases are not versionable.\n+\t(ipcp_cloning_candidate_p): Aliases are not clonning candidates.\n+\t(ipcp_initialize_node_lattices): We don't propagate through an aliases.\n+\t(ipcp_propagate_stage): Skip aliases when propagating.\n+\t(ipcp_need_redirect_p): Skip aliases.\n+\t(ipcp_insert_stage): Use FOR_EACH_FUNCTION_WITH_GIMPLE_BODY and\n+\tcollect_callers_of_node.\n+\t* ipa-prop.c (ipa_init_func_list): Do not analyze datastructures\n+\tfor aliases.\n+\t(ipa_compute_jump_functions): Look through aliases.\n+\n 2011-06-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* doc/sourcebuild.texi (Effective-Target Keywords, pie): Document it."}, {"sha": "94aab5f5f76014fd4221eb3cc62bee8c38a6ba6b", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749f25d8a774f7786bd0258d79ee10a309df8dfb/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749f25d8a774f7786bd0258d79ee10a309df8dfb/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=749f25d8a774f7786bd0258d79ee10a309df8dfb", "patch": "@@ -350,6 +350,10 @@ ipcp_versionable_function_p (struct cgraph_node *node)\n {\n   struct cgraph_edge *edge;\n \n+  /* We always version the actual function and redirect through the aliases.  */\n+  if (node->alias)\n+    return false;\n+\n   /* There are a number of generic reasons functions cannot be versioned.  We\n      also cannot remove parameters if there are type attributes such as fnspec\n      present.  */\n@@ -358,7 +362,8 @@ ipcp_versionable_function_p (struct cgraph_node *node)\n     return false;\n \n   /* Removing arguments doesn't work if the function takes varargs\n-     or use __builtin_apply_args. */\n+     or use __builtin_apply_args. \n+     FIXME: handle this together with can_change_signature flag.  */\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n       tree t = edge->callee->decl;\n@@ -380,6 +385,10 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   gcov_type direct_call_sum = 0;\n   struct cgraph_edge *e;\n \n+  /* We look through aliases, so we clone the aliased function instead.  */\n+  if (node->alias)\n+    return false;\n+\n   /* We never clone functions that are not visible from outside.\n      FIXME: in future we should clone such functions when they are called with\n      different constants, but current ipcp implementation is not good on this.\n@@ -498,7 +507,7 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   enum ipa_lattice_type type;\n \n-  if (ipa_is_called_with_var_arguments (info))\n+  if (ipa_is_called_with_var_arguments (info) || node->alias)\n     type = IPA_BOTTOM;\n   else if (node->local.local)\n     type = IPA_TOP;\n@@ -759,7 +768,8 @@ ipcp_propagate_stage (void)\n \n       for (cs = node->callees; cs; cs = cs->next_callee)\n \t{\n-\t  struct ipa_node_params *callee_info = IPA_NODE_REF (cs->callee);\n+\t  struct cgraph_node *callee = cgraph_function_or_thunk_node (cs->callee, NULL);\n+\t  struct ipa_node_params *callee_info = IPA_NODE_REF (callee);\n \t  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n \n \t  if (ipa_is_called_with_var_arguments (callee_info)\n@@ -778,11 +788,11 @@ ipcp_propagate_stage (void)\n \t\t{\n \t\t  dest_lat->type = new_lat.type;\n \t\t  dest_lat->constant = new_lat.constant;\n-\t\t  ipa_push_func_to_list (&wl, cs->callee);\n+\t\t  ipa_push_func_to_list (&wl, callee);\n \t\t}\n \n \t      if (ipcp_propagate_types (info, callee_info, jump_func, i))\n-\t\tipa_push_func_to_list (&wl, cs->callee);\n+\t\tipa_push_func_to_list (&wl, callee);\n \t    }\n \t}\n     }\n@@ -818,7 +828,7 @@ ipcp_iterate_stage (void)\n     /* Some lattices have changed from IPA_TOP to IPA_BOTTOM.\n        This change should be propagated.  */\n     {\n-      gcc_assert (n_cloning_candidates);\n+      /*gcc_assert (n_cloning_candidates);*/\n       ipcp_propagate_stage ();\n     }\n   if (dump_file)\n@@ -946,7 +956,8 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n {\n   struct ipa_node_params *orig_callee_info;\n   int i, count;\n-  struct cgraph_node *node = cs->callee, *orig;\n+  struct cgraph_node *node = cgraph_function_or_thunk_node (cs->callee, NULL);\n+  struct cgraph_node *orig;\n \n   if (!n_cloning_candidates)\n     return false;\n@@ -1293,7 +1304,7 @@ ipcp_insert_stage (void)\n   int i;\n   VEC (cgraph_edge_p, heap) * redirect_callers;\n   VEC (ipa_replace_map_p,gc)* replace_trees;\n-  int node_callers, count;\n+  int count;\n   tree parm_tree;\n   struct ipa_replace_map *replace_param;\n   fibheap_t heap;\n@@ -1307,13 +1318,12 @@ ipcp_insert_stage (void)\n \n   dead_nodes = BITMAP_ALLOC (NULL);\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      {\n-\tif (node->count > max_count)\n-\t  max_count = node->count;\n-\toverall_size += inline_summary (node)->self_size;\n-      }\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      if (node->count > max_count)\n+\tmax_count = node->count;\n+      overall_size += inline_summary (node)->self_size;\n+    }\n \n   max_new_size = overall_size;\n   if (max_new_size < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n@@ -1413,14 +1423,7 @@ ipcp_insert_stage (void)\n       if (!cs && cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \tbitmap_set_bit (dead_nodes, node->uid);\n \n-      /* Compute how many callers node has.  */\n-      node_callers = 0;\n-      for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n-\tnode_callers++;\n-      redirect_callers = VEC_alloc (cgraph_edge_p, heap, node_callers);\n-      for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n-\tif (!cs->indirect_inlining_edge)\n-\t  VEC_quick_push (cgraph_edge_p, redirect_callers, cs);\n+      redirect_callers = collect_callers_of_node (node);\n \n       /* Redirecting all the callers of the node to the\n          new versioned node.  */\n@@ -1452,13 +1455,16 @@ ipcp_insert_stage (void)\n \tdump_function_to_file (node1->decl, dump_file, dump_flags);\n \n       for (cs = node->callees; cs; cs = cs->next_callee)\n-        if (cs->callee->aux)\n-\t  {\n-\t    fibheap_delete_node (heap, (fibnode_t) cs->callee->aux);\n-\t    cs->callee->aux = fibheap_insert (heap,\n-\t    \t\t\t\t      ipcp_estimate_cloning_cost (cs->callee),\n-\t\t\t\t\t      cs->callee);\n-\t  }\n+\t{\n+\t  struct cgraph_node *callee = cgraph_function_or_thunk_node (cs->callee, NULL);\n+\t  if (callee->aux)\n+\t    {\n+\t      fibheap_delete_node (heap, (fibnode_t) callee->aux);\n+\t      callee->aux = fibheap_insert (heap,\n+\t\t\t\t\t    ipcp_estimate_cloning_cost (callee),\n+\t\t\t\t\t    callee);\n+\t    }\n+\t}\n     }\n \n   while (!fibheap_empty (heap))"}, {"sha": "6450e81ea4bdcb8bcd96d32e7acc96c5c6e62a0d", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749f25d8a774f7786bd0258d79ee10a309df8dfb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749f25d8a774f7786bd0258d79ee10a309df8dfb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=749f25d8a774f7786bd0258d79ee10a309df8dfb", "patch": "@@ -93,7 +93,7 @@ ipa_init_func_list (void)\n \n   wl = NULL;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n+    if (node->analyzed && !node->alias)\n       {\n \tstruct ipa_node_params *info = IPA_NODE_REF (node);\n \t/* Unreachable nodes should have been eliminated before ipcp and\n@@ -1096,18 +1096,19 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n \n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n+      struct cgraph_node *callee = cgraph_function_or_thunk_node (cs->callee, NULL);\n       /* We do not need to bother analyzing calls to unknown\n \t functions unless they may become known during lto/whopr.  */\n       if (!cs->callee->analyzed && !flag_lto)\n \tcontinue;\n       ipa_count_arguments (cs);\n       /* If the descriptor of the callee is not initialized yet, we have to do\n \t it now. */\n-      if (cs->callee->analyzed)\n-\tipa_initialize_node_params (cs->callee);\n+      if (callee->analyzed)\n+\tipa_initialize_node_params (callee);\n       if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n-\t  != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n-\tipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n+\t  != ipa_get_param_count (IPA_NODE_REF (callee)))\n+\tipa_set_called_with_variable_arg (IPA_NODE_REF (callee));\n       ipa_compute_jump_functions_for_edge (parms_info, cs);\n     }\n "}]}