{"sha": "40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "node_id": "C_kwDOANBUbNoAKDQwZDY0M2Q4ZGU3YmIwYjdiZDc1ZTM1ZjQyNzRiZWI5NzkzYmIwZGY", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-03-31T16:08:59Z"}, "committer": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-03-31T16:11:32Z"}, "message": "aarch64: Implement determine_suggested_unroll_factor\n\nThis patch implements the costing function determine_suggested_unroll_factor\nfor aarch64.\nIt determines the unrolling factor by dividing the number of X operations we\ncan do per cycle by the number of X operations, taking this information from\nthe vec_ops analysis during vector costing and the available issue_info\ninformation.\nWe multiply the dividend by a potential reduction_latency, to improve our\npipeline utilization if we are stalled waiting on a particular reduction\noperation.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64.cc (aarch64_vector_costs): Define\n\tdetermine_suggested_unroll_factor and m_has_avg.\n\t(determine_suggested_unroll_factor): New function.\n\t(aarch64_vector_costs::add_stmt_cost): Check for a qualifying pattern\n\tto set m_nosve_pattern.\n\t(aarch64_vector_costs::finish_costs): Use\n\tdetermine_suggested_unroll_factor.\n\t* config/aarch64/aarch64.opt (aarch64-vect-unroll-limit): New.\n\t* doc/invoke.texi: (aarch64-vect-unroll-limit): Document new option.", "tree": {"sha": "a51587381a9c70118164f93e570412d813709a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a51587381a9c70118164f93e570412d813709a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d"}], "stats": {"total": 99, "additions": 97, "deletions": 2}, "files": [{"sha": "18f8049907994316cb60169af7473873f8d911e5", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "patch": "@@ -15637,11 +15637,16 @@ class aarch64_vector_costs : public vector_costs\n   unsigned int adjust_body_cost (loop_vec_info, const aarch64_vector_costs *,\n \t\t\t\t unsigned int);\n   bool prefer_unrolled_loop () const;\n+  unsigned int determine_suggested_unroll_factor ();\n \n   /* True if we have performed one-time initialization based on the\n      vec_info.  */\n   bool m_analyzed_vinfo = false;\n \n+  /* This loop uses an average operation that is not supported by SVE, but is\n+     supported by Advanced SIMD and SVE2.  */\n+  bool m_has_avg = false;\n+\n   /* - If M_VEC_FLAGS is zero then we're costing the original scalar code.\n      - If M_VEC_FLAGS & VEC_ADVSIMD is nonzero then we're costing Advanced\n        SIMD code.\n@@ -16642,6 +16647,21 @@ aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n \t as one iteration of the SVE loop.  */\n       if (where == vect_body && m_unrolled_advsimd_niters)\n \tm_unrolled_advsimd_stmts += count * m_unrolled_advsimd_niters;\n+\n+      /* Detect the use of an averaging operation.  */\n+      gimple *stmt = stmt_info->stmt;\n+      if (is_gimple_call (stmt)\n+\t  && gimple_call_internal_p (stmt))\n+\t{\n+\t  switch (gimple_call_internal_fn (stmt))\n+\t    {\n+\t    case IFN_AVG_FLOOR:\n+\t    case IFN_AVG_CEIL:\n+\t      m_has_avg = true;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n     }\n   return record_stmt_cost (stmt_info, where, (count * stmt_cost).ceil ());\n }\n@@ -16725,6 +16745,68 @@ adjust_body_cost_sve (const aarch64_vec_op_count *ops,\n   return sve_cycles_per_iter;\n }\n \n+unsigned int\n+aarch64_vector_costs::determine_suggested_unroll_factor ()\n+{\n+  bool sve = m_vec_flags & VEC_ANY_SVE;\n+  /* If we are trying to unroll an Advanced SIMD main loop that contains\n+     an averaging operation that we do not support with SVE and we might use a\n+     predicated epilogue, we need to be conservative and block unrolling as\n+     this might lead to a less optimal loop for the first and only epilogue\n+     using the original loop's vectorization factor.\n+     TODO: Remove this constraint when we add support for multiple epilogue\n+     vectorization.  */\n+  if (!sve && !TARGET_SVE2 && m_has_avg)\n+    return 1;\n+\n+  unsigned int max_unroll_factor = 1;\n+  for (auto vec_ops : m_ops)\n+    {\n+      aarch64_simd_vec_issue_info const *vec_issue\n+\t= vec_ops.simd_issue_info ();\n+      if (!vec_issue)\n+\treturn 1;\n+      /* Limit unroll factor to a value adjustable by the user, the default\n+\t value is 4. */\n+      unsigned int unroll_factor = aarch64_vect_unroll_limit;\n+      unsigned int factor\n+       = vec_ops.reduction_latency > 1 ? vec_ops.reduction_latency : 1;\n+      unsigned int temp;\n+\n+      /* Sanity check, this should never happen.  */\n+      if ((vec_ops.stores + vec_ops.loads + vec_ops.general_ops) == 0)\n+\treturn 1;\n+\n+      /* Check stores.  */\n+      if (vec_ops.stores > 0)\n+\t{\n+\t  temp = CEIL (factor * vec_issue->stores_per_cycle,\n+\t\t       vec_ops.stores);\n+\t  unroll_factor = MIN (unroll_factor, temp);\n+\t}\n+\n+      /* Check loads + stores.  */\n+      if (vec_ops.loads > 0)\n+\t{\n+\t  temp = CEIL (factor * vec_issue->loads_stores_per_cycle,\n+\t\t       vec_ops.loads + vec_ops.stores);\n+\t  unroll_factor = MIN (unroll_factor, temp);\n+\t}\n+\n+      /* Check general ops.  */\n+      if (vec_ops.general_ops > 0)\n+\t{\n+\t  temp = CEIL (factor * vec_issue->general_ops_per_cycle,\n+\t\t       vec_ops.general_ops);\n+\t  unroll_factor = MIN (unroll_factor, temp);\n+\t }\n+      max_unroll_factor = MAX (max_unroll_factor, unroll_factor);\n+    }\n+\n+  /* Make sure unroll factor is power of 2.  */\n+  return 1 << ceil_log2 (max_unroll_factor);\n+}\n+\n /* BODY_COST is the cost of a vector loop body.  Adjust the cost as necessary\n    and return the new cost.  */\n unsigned int\n@@ -16861,8 +16943,11 @@ aarch64_vector_costs::finish_cost (const vector_costs *uncast_scalar_costs)\n   if (loop_vinfo\n       && m_vec_flags\n       && aarch64_use_new_vector_costs_p ())\n-    m_costs[vect_body] = adjust_body_cost (loop_vinfo, scalar_costs,\n-\t\t\t\t\t   m_costs[vect_body]);\n+    {\n+      m_costs[vect_body] = adjust_body_cost (loop_vinfo, scalar_costs,\n+\t\t\t\t\t     m_costs[vect_body]);\n+      m_suggested_unroll_factor = determine_suggested_unroll_factor ();\n+    }\n \n   /* Apply the heuristic described above m_stp_sequence_cost.  Prefer\n      the scalar code in the event of a tie, since there is more chance"}, {"sha": "92220b26ee2bf9f95c9a387c3155779596ee5ad5", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "patch": "@@ -292,3 +292,7 @@ Constant memmove size in bytes above which to start using MOPS sequence.\n -param=aarch64-mops-memset-size-threshold=\n Target Joined UInteger Var(aarch64_mops_memset_size_threshold) Init(256) Param\n Constant memset size in bytes from which to start using MOPS sequence.\n+\n+-param=aarch64-vect-unroll-limit=\n+Target Joined UInteger Var(aarch64_vect_unroll_limit) Init(4) Param\n+Limit how much the autovectorizer may unroll a loop."}, {"sha": "3936aef69d0740ee7fdbda343180b553ffaee7d3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d643d8de7bb0b7bd75e35f4274beb9793bb0df/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=40d643d8de7bb0b7bd75e35f4274beb9793bb0df", "patch": "@@ -15239,6 +15239,12 @@ If this parameter is set to @var{n}, GCC will not use this heuristic\n for loops that are known to execute in fewer than @var{n} Advanced\n SIMD iterations.\n \n+@item aarch64-vect-unroll-limit\n+The vectorizer will use available tuning information to determine whether it\n+would be beneficial to unroll the main vectorized loop and by how much.  This\n+parameter set's the upper bound of how much the vectorizer will unroll the main\n+loop.  The default value is four.\n+\n @end table\n \n @end table"}]}