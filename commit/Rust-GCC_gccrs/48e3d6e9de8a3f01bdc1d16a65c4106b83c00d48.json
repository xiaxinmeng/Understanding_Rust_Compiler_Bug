{"sha": "48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhlM2Q2ZTlkZThhM2YwMWJkYzFkMTZhNjVjNDEwNmI4M2MwMGQ0OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-31T05:30:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-31T05:30:19Z"}, "message": "ira.c (init_move_cost): Adjust choice of subclasses to match the current ira_init_register_move_cost choice.\n\ngcc/\n\t* ira.c (init_move_cost): Adjust choice of subclasses to match\n\tthe current ira_init_register_move_cost choice.  Use\n\tira_class_subset_p instead of reg_class_subset_p.\n\t(ira_init_register_move_cost): Assert that move_cost,\n\tmay_move_in_cost and may_move_out_cost already hold the desired\n\tvalues for their ira_* equivalents.  For the latter two,\n\tignore classes that can't store a register of the given mode.\n\nFrom-SVN: r188046", "tree": {"sha": "b22b7ab6c9c1d3f267834c6945b0cd3a53848dbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b22b7ab6c9c1d3f267834c6945b0cd3a53848dbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e575fe22b54b3c5738485f02c6d60c8c30b327e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e575fe22b54b3c5738485f02c6d60c8c30b327e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e575fe22b54b3c5738485f02c6d60c8c30b327e"}], "stats": {"total": 56, "additions": 31, "deletions": 25}, "files": [{"sha": "94f1f527890b84a59466318943ece7e514fda1a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "patch": "@@ -1,3 +1,13 @@\n+2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira.c (init_move_cost): Adjust choice of subclasses to match\n+\tthe current ira_init_register_move_cost choice.  Use\n+\tira_class_subset_p instead of reg_class_subset_p.\n+\t(ira_init_register_move_cost): Assert that move_cost,\n+\tmay_move_in_cost and may_move_out_cost already hold the desired\n+\tvalues for their ira_* equivalents.  For the latter two,\n+\tignore classes that can't store a register of the given mode.\n+\n 2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* ira.c (setup_allocno_and_important_classes): Use"}, {"sha": "c96f5eb32c0d1d872fa5b77293658132b4a14981", "filename": "gcc/ira.c", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "patch": "@@ -1510,25 +1510,27 @@ init_move_cost (enum machine_mode mode)\n \n \t      for (p2 = &reg_class_subclasses[cl2][0];\n \t\t   *p2 != LIM_REG_CLASSES; p2++)\n-\t\tif (*p2 != cl1 && contains_reg_of_mode[*p2][mode])\n+\t\tif (ira_class_hard_regs_num[*p2] > 0\n+\t\t    && (ira_reg_class_max_nregs[*p2][mode]\n+\t\t\t<= ira_class_hard_regs_num[*p2]))\n \t\t  cost = MAX (cost, move_cost[mode][cl1][*p2]);\n \n \t      for (p1 = &reg_class_subclasses[cl1][0];\n \t\t   *p1 != LIM_REG_CLASSES; p1++)\n-\t\tif (*p1 != cl2 && contains_reg_of_mode[*p1][mode])\n+\t\tif (ira_class_hard_regs_num[*p1] > 0\n+\t\t    && (ira_reg_class_max_nregs[*p1][mode]\n+\t\t\t<= ira_class_hard_regs_num[*p1]))\n \t\t  cost = MAX (cost, move_cost[mode][*p1][cl2]);\n \n \t      ira_assert (cost <= 65535);\n \t      move_cost[mode][cl1][cl2] = cost;\n \n-\t      if (reg_class_subset_p ((enum reg_class) cl1,\n-\t\t\t\t      (enum reg_class) cl2))\n+\t      if (ira_class_subset_p[cl1][cl2])\n \t\tmay_move_in_cost[mode][cl1][cl2] = 0;\n \t      else\n \t\tmay_move_in_cost[mode][cl1][cl2] = cost;\n \n-\t      if (reg_class_subset_p ((enum reg_class) cl2,\n-\t\t\t\t      (enum reg_class) cl1))\n+\t      if (ira_class_subset_p[cl2][cl1])\n \t\tmay_move_out_cost[mode][cl1][cl2] = 0;\n \t      else\n \t\tmay_move_out_cost[mode][cl1][cl2] = cost;\n@@ -1577,14 +1579,10 @@ ira_init_register_move_cost (enum machine_mode mode)\n \t\t\t\t   reg_class_contents[cl2]))\n \t  for (cl3 = 0; cl3 < N_REG_CLASSES; cl3++)\n \t    {\n-\t      if (ira_max_register_move_cost[mode][cl2][cl3]\n-\t\t  < ira_register_move_cost[mode][cl1][cl3])\n-\t\tira_max_register_move_cost[mode][cl2][cl3]\n-\t\t  = ira_register_move_cost[mode][cl1][cl3];\n-\t      if (ira_max_register_move_cost[mode][cl3][cl2]\n-\t\t  < ira_register_move_cost[mode][cl3][cl1])\n-\t\tira_max_register_move_cost[mode][cl3][cl2]\n-\t\t  = ira_register_move_cost[mode][cl3][cl1];\n+\t      gcc_assert (ira_register_move_cost[mode][cl2][cl3]\n+\t\t\t  >= ira_register_move_cost[mode][cl1][cl3]);\n+\t      gcc_assert (ira_register_move_cost[mode][cl3][cl2]\n+\t\t\t  >= ira_register_move_cost[mode][cl3][cl1]);\n \t    }\n   ira_may_move_in_cost[mode]\n     = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n@@ -1603,27 +1601,25 @@ ira_init_register_move_cost (enum machine_mode mode)\n   memcpy (ira_max_may_move_out_cost[mode], ira_max_register_move_cost[mode],\n \t  sizeof (move_table) * N_REG_CLASSES);\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n-    {\n+    if (contains_reg_of_mode[cl1][mode])\n       for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n-\t  if (ira_class_hard_regs_num[cl2] == 0)\n+\t  if (!contains_reg_of_mode[cl2][mode]\n+\t      || ira_class_hard_regs_num[cl2] == 0)\n \t    continue;\n \t  if (ira_class_subset_p[cl1][cl2])\n-\t    ira_may_move_in_cost[mode][cl1][cl2] = 0;\n+\t    gcc_assert (ira_may_move_in_cost[mode][cl1][cl2] == 0);\n \t  if (ira_class_subset_p[cl2][cl1])\n-\t    ira_may_move_out_cost[mode][cl1][cl2] = 0;\n+\t    gcc_assert (ira_may_move_out_cost[mode][cl1][cl2] == 0);\n \t  if (ira_class_subset_p[cl1][cl2])\n \t    ira_max_may_move_in_cost[mode][cl1][cl2] = 0;\n \t  if (ira_class_subset_p[cl2][cl1])\n \t    ira_max_may_move_out_cost[mode][cl1][cl2] = 0;\n-\t  ira_register_move_cost[mode][cl1][cl2]\n-\t    = ira_max_register_move_cost[mode][cl1][cl2];\n-\t  ira_may_move_in_cost[mode][cl1][cl2]\n-\t    = ira_max_may_move_in_cost[mode][cl1][cl2];\n-\t  ira_may_move_out_cost[mode][cl1][cl2]\n-\t    = ira_max_may_move_out_cost[mode][cl1][cl2];\n+\t  gcc_assert (ira_may_move_in_cost[mode][cl1][cl2]\n+\t\t      == ira_max_may_move_in_cost[mode][cl1][cl2]);\n+\t  gcc_assert (ira_may_move_out_cost[mode][cl1][cl2]\n+\t\t      == ira_max_may_move_out_cost[mode][cl1][cl2]);\n \t}\n-    }\n }\n \n \f"}]}