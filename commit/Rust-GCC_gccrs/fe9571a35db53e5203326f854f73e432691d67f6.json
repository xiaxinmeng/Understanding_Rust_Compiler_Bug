{"sha": "fe9571a35db53e5203326f854f73e432691d67f6", "node_id": "C_kwDOANBUbNoAKGZlOTU3MWEzNWRiNTNlNTIwMzMyNmY4NTRmNzNlNDMyNjkxZDY3ZjY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-12-01T17:56:23Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-12-09T22:50:10Z"}, "message": "libstdc++: Fix non-reserved name in std::allocator base class [PR64135]\n\nThe possible base classes of std::allocator are new_allocator and\nmalloc_allocator, which both cause a non-reserved name to be declared in\nevery program that includes the definition of std::allocator. This is\nnon-conforming.\n\nThis change replaces __gnu_cxx::new_allocator with std::__new_allocator\nwhich is identical except for using a reserved name. The non-standard\nextension __gnu_cxx::new_allocator is preserved as a thin wrapper over\nstd::__new_allocator. There is no problem with the extension using a\nnon-reserved name now that it's not included by default in other\nheaders.\n\nThe same change could be done to __gnu_cxx::malloc_allocator but as it's\nnot the default configuration it can wait.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/64135\n\t* config/allocator/new_allocator_base.h: Include\n\t<bits/new_allocator.h> instead of <ext/new_allocator.h>.\n\t(__allocator_base): Use std::__new_allocator instead of\n\t__gnu_cxx::new_allocator.\n\t* doc/xml/manual/allocator.xml: Document new default base class\n\tfor std::allocator.\n\t* doc/xml/manual/evolution.xml: Likewise.\n\t* doc/html/*: Regenerate.\n\t* include/Makefile.am: Add bits/new_allocator.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/memory_resource (new_delete_resource):\n\tUse std::__new_allocator instead of __gnu_cxx::new_allocator.\n\t* include/ext/new_allocator.h (new_allocator): Derive from\n\tstd::__new_allocator. Move implementation to ...\n\t* include/bits/new_allocator.h: New file.\n\t* testsuite/20_util/allocator/64135.cc: New test.", "tree": {"sha": "23acac00e45e11c3114e609d1578ff410d93bfaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23acac00e45e11c3114e609d1578ff410d93bfaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe9571a35db53e5203326f854f73e432691d67f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9571a35db53e5203326f854f73e432691d67f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9571a35db53e5203326f854f73e432691d67f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9571a35db53e5203326f854f73e432691d67f6/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f157c5362b4844f7676cae2aba81a4cf75bd68d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f157c5362b4844f7676cae2aba81a4cf75bd68d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f157c5362b4844f7676cae2aba81a4cf75bd68d5"}], "stats": {"total": 460, "additions": 293, "deletions": 167}, "files": [{"sha": "a139f2fb6686f176c63c17ad1a6da34add7ddd81", "filename": "libstdc++-v3/config/allocator/new_allocator_base.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fconfig%2Fallocator%2Fnew_allocator_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fconfig%2Fallocator%2Fnew_allocator_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fallocator%2Fnew_allocator_base.h?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -30,26 +30,25 @@\n #ifndef _GLIBCXX_CXX_ALLOCATOR_H\n #define _GLIBCXX_CXX_ALLOCATOR_H 1\n \n-#include <ext/new_allocator.h>\n+#include <bits/new_allocator.h>\n \n #if __cplusplus >= 201103L\n namespace std\n {\n   /**\n    *  @brief  An alias to the base class for std::allocator.\n    *\n-   *  Used to set the std::allocator base class to\n-   *  __gnu_cxx::new_allocator.\n+   *  Used to set the std::allocator base class to std::__new_allocator.\n    *\n    *  @ingroup allocators\n    *  @tparam  _Tp  Type of allocated object.\n     */\n   template<typename _Tp>\n-    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;\n+    using __allocator_base = __new_allocator<_Tp>;\n }\n #else\n-// Define new_allocator as the base class to std::allocator.\n-# define __allocator_base  __gnu_cxx::new_allocator\n+// Define __new_allocator as the base class to std::allocator.\n+# define __allocator_base  __new_allocator\n #endif\n \n #ifndef _GLIBCXX_SANITIZE_STD_ALLOCATOR"}, {"sha": "00701fa1044c58f7655e67dfebe14a109ea4dffd", "filename": "libstdc++-v3/doc/html/manual/api.html", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fapi.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fapi.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fapi.html?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -447,4 +447,7 @@\n </p><p>\n The <code class=\"literal\">bitmap</code>, <code class=\"literal\">mt</code>, and <code class=\"literal\">pool</code>\n options for <code class=\"option\">--enable-libstdcxx-allocator</code> were removed.\n+For the <code class=\"literal\">new</code> option, <code class=\"classname\">std::allocator</code>\n+no longer derives from <code class=\"classname\">__gnu_cxx::new_allocator</code>;\n+they both derive from <code class=\"classname\">std::__new_allocator</code> instead.\n </p></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"abi.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"appendix_porting.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"backwards.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">ABI Policy and Guidelines\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Backwards Compatibility</td></tr></table></div></body></html>\n\\ No newline at end of file"}, {"sha": "d9abdaf8c88eb5fd5e8bdcf78f6780e71ed9bc45", "filename": "libstdc++-v3/doc/html/manual/memory.html", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fmemory.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fmemory.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fmemory.html?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -140,9 +140,11 @@\n      <a class=\"link\" href=\"http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc++-v3/testsuite/performance/23_containers/producer_consumer/associative.cc?view=markup\" target=\"_top\">associative</a>\n      containers.\n      </p></li></ol></div><p>\n-     The current default choice for\n+     Since GCC 12 the default choice for\n      <code class=\"classname\">allocator</code> is\n-     <code class=\"classname\">__gnu_cxx::new_allocator</code>.\n+     <code class=\"classname\">std::__new_allocator</code>.\n+     Before GCC 12 it was the <code class=\"classname\">__gnu_cxx::new_allocator</code>\n+     extension (which has identical behaviour).\n    </p></div><div class=\"section\"><div class=\"titlepage\"><div><div><h5 class=\"title\"><a id=\"allocator.caching\"></a>Disabling Memory Caching</h5></div></div></div><p>\n       In use, <code class=\"classname\">allocator</code> may allocate and\n       deallocate using implementation-specific strategies and"}, {"sha": "2418539be8dafec5b5ce98e97c58bf15b21dc942", "filename": "libstdc++-v3/doc/xml/manual/allocator.xml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fallocator.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fallocator.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fallocator.xml?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -219,9 +219,11 @@\n    </orderedlist>\n \n    <para>\n-     The current default choice for\n+     Since GCC 12 the default choice for\n      <classname>allocator</classname> is\n-     <classname>__gnu_cxx::new_allocator</classname>.\n+     <classname>std::__new_allocator</classname>.\n+     Before GCC 12 it was the <classname>__gnu_cxx::new_allocator</classname>\n+     extension (which has identical behaviour).\n    </para>\n \n   </section>"}, {"sha": "a169102ef4309d915f2e2eb91e40bd964fbb9213", "filename": "libstdc++-v3/doc/xml/manual/evolution.xml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fevolution.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fevolution.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fevolution.xml?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -1036,6 +1036,9 @@ Dynamic exception specifications should be replaced with <code>noexcept</code>.\n <para>\n The <literal>bitmap</literal>, <literal>mt</literal>, and <literal>pool</literal>\n options for <option>--enable-libstdcxx-allocator</option> were removed.\n+For the <literal>new</literal> option, <classname>std::allocator</classname>\n+no longer derives from <classname>__gnu_cxx::new_allocator</classname>;\n+they both derive from <classname>std::__new_allocator</classname> instead.\n </para>\n \n </section>"}, {"sha": "f1cf79615c84ef42ec473da9b8381cb9083ea696", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -159,6 +159,7 @@ bits_headers = \\\n \t${bits_srcdir}/mofunc_impl.h \\\n \t${bits_srcdir}/move.h \\\n \t${bits_srcdir}/move_only_function.h \\\n+\t${bits_srcdir}/new_allocator.h \\\n \t${bits_srcdir}/node_handle.h \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\"}, {"sha": "4e4a240831a96df419dc2dd330117bc29a28daea", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -509,6 +509,7 @@ bits_headers = \\\n \t${bits_srcdir}/mofunc_impl.h \\\n \t${bits_srcdir}/move.h \\\n \t${bits_srcdir}/move_only_function.h \\\n+\t${bits_srcdir}/new_allocator.h \\\n \t${bits_srcdir}/node_handle.h \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\"}, {"sha": "4d85612720d01614d9666be02bf453744bcf7a28", "filename": "libstdc++-v3/include/bits/new_allocator.h", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnew_allocator.h?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -0,0 +1,223 @@\n+// Allocator that wraps operator new -*- C++ -*-\n+\n+// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/new_allocator.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory}\n+ */\n+\n+#ifndef _STD_NEW_ALLOCATOR_H\n+#define _STD_NEW_ALLOCATOR_H 1\n+\n+#include <bits/c++config.h>\n+#include <new>\n+#include <bits/functexcept.h>\n+#include <bits/move.h>\n+#if __cplusplus >= 201103L\n+#include <type_traits>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n+   *  @ingroup allocators\n+   *\n+   *  This is precisely the allocator defined in the C++ Standard.\n+   *    - all allocation calls operator new\n+   *    - all deallocation calls operator delete\n+   *\n+   *  @tparam  _Tp  Type of allocated object.\n+   */\n+  template<typename _Tp>\n+    class __new_allocator\n+    {\n+    public:\n+      typedef _Tp        value_type;\n+      typedef std::size_t     size_type;\n+      typedef std::ptrdiff_t  difference_type;\n+#if __cplusplus <= 201703L\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef __new_allocator<_Tp1> other; };\n+#endif\n+\n+#if __cplusplus >= 201103L\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2103. propagate_on_container_move_assignment\n+      typedef std::true_type propagate_on_container_move_assignment;\n+#endif\n+\n+      _GLIBCXX20_CONSTEXPR\n+      __new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n+\n+      _GLIBCXX20_CONSTEXPR\n+      __new_allocator(const __new_allocator&) _GLIBCXX_USE_NOEXCEPT { }\n+\n+      template<typename _Tp1>\n+\t_GLIBCXX20_CONSTEXPR\n+\t__new_allocator(const __new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }\n+\n+#if __cplusplus <= 201703L\n+      ~__new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n+\n+      pointer\n+      address(reference __x) const _GLIBCXX_NOEXCEPT\n+      { return std::__addressof(__x); }\n+\n+      const_pointer\n+      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n+      { return std::__addressof(__x); }\n+#endif\n+\n+#if __has_builtin(__builtin_operator_new) >= 201802L\n+# define _GLIBCXX_OPERATOR_NEW __builtin_operator_new\n+# define _GLIBCXX_OPERATOR_DELETE __builtin_operator_delete\n+#else\n+# define _GLIBCXX_OPERATOR_NEW ::operator new\n+# define _GLIBCXX_OPERATOR_DELETE ::operator delete\n+#endif\n+\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n+      _GLIBCXX_NODISCARD _Tp*\n+      allocate(size_type __n, const void* = static_cast<const void*>(0))\n+      {\n+#if __cplusplus >= 201103L\n+\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t // 3308. std::allocator<void>().allocate(n)\n+\t static_assert(sizeof(_Tp) != 0, \"cannot allocate incomplete types\");\n+#endif\n+\n+\tif (__builtin_expect(__n > this->_M_max_size(), false))\n+\t  {\n+\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t    // 3190. allocator::allocate sometimes returns too little storage\n+\t    if (__n > (std::size_t(-1) / sizeof(_Tp)))\n+\t      std::__throw_bad_array_new_length();\n+\t    std::__throw_bad_alloc();\n+\t  }\n+\n+#if __cpp_aligned_new\n+\tif (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n+\t  {\n+\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n+\t    return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp),\n+\t\t\t\t\t\t\t   __al));\n+\t  }\n+#endif\n+\treturn static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp)));\n+      }\n+\n+      // __p is not permitted to be a null pointer.\n+      void\n+      deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))\n+      {\n+#if __cpp_sized_deallocation\n+# define _GLIBCXX_SIZED_DEALLOC(p, n) (p), (n) * sizeof(_Tp)\n+#else\n+# define _GLIBCXX_SIZED_DEALLOC(p, n) (p)\n+#endif\n+\n+#if __cpp_aligned_new\n+\tif (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n+\t  {\n+\t    _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n),\n+\t\t\t\t     std::align_val_t(alignof(_Tp)));\n+\t    return;\n+\t  }\n+#endif\n+\t_GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));\n+      }\n+\n+#undef _GLIBCXX_SIZED_DEALLOC\n+#undef _GLIBCXX_OPERATOR_DELETE\n+#undef _GLIBCXX_OPERATOR_NEW\n+\n+#if __cplusplus <= 201703L\n+      size_type\n+      max_size() const _GLIBCXX_USE_NOEXCEPT\n+      { return _M_max_size(); }\n+\n+#if __cplusplus >= 201103L\n+      template<typename _Up, typename... _Args>\n+\tvoid\n+\tconstruct(_Up* __p, _Args&&... __args)\n+\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+\tvoid\n+\tdestroy(_Up* __p)\n+\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n+\t{ __p->~_Up(); }\n+#else\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void\n+      construct(pointer __p, const _Tp& __val)\n+      { ::new((void *)__p) _Tp(__val); }\n+\n+      void\n+      destroy(pointer __p) { __p->~_Tp(); }\n+#endif\n+#endif // ! C++20\n+\n+      template<typename _Up>\n+\tfriend _GLIBCXX20_CONSTEXPR bool\n+\toperator==(const __new_allocator&, const __new_allocator<_Up>&)\n+\t_GLIBCXX_NOTHROW\n+\t{ return true; }\n+\n+#if __cpp_impl_three_way_comparison < 201907L\n+      template<typename _Up>\n+\tfriend _GLIBCXX20_CONSTEXPR bool\n+\toperator!=(const __new_allocator&, const __new_allocator<_Up>&)\n+\t_GLIBCXX_NOTHROW\n+\t{ return false; }\n+#endif\n+\n+    private:\n+      _GLIBCXX_CONSTEXPR size_type\n+      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n+      {\n+#if __PTRDIFF_MAX__ < __SIZE_MAX__\n+\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n+#else\n+\treturn std::size_t(-1) / sizeof(_Tp);\n+#endif\n+      }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif"}, {"sha": "37ac95fc4b1b09e2b50a13d97e28a80dc1461f38", "filename": "libstdc++-v3/include/experimental/memory_resource", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -40,7 +40,7 @@\n #include <atomic>\t\t\t// atomic\n #include <new>\t\t\t\t// placement new\n #include <cstddef>\t\t\t// max_align_t\n-#include <ext/new_allocator.h>\n+#include <bits/new_allocator.h>\n #include <debug/assertions.h>\n \n /// @cond\n@@ -503,7 +503,7 @@ namespace pmr {\n   inline memory_resource*\n   new_delete_resource() noexcept\n   {\n-    using type = resource_adaptor<__gnu_cxx::new_allocator<char>>;\n+    using type = resource_adaptor<std::__new_allocator<char>>;\n     alignas(type) static unsigned char __buf[sizeof(type)];\n     static type* __r = new(__buf) type;\n     return __r;"}, {"sha": "5cb1b97c2b2b66c65bfae418019291f3325f6a75", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 2, "deletions": 155, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -29,13 +29,7 @@\n #ifndef _NEW_ALLOCATOR_H\n #define _NEW_ALLOCATOR_H 1\n \n-#include <bits/c++config.h>\n-#include <new>\n-#include <bits/functexcept.h>\n-#include <bits/move.h>\n-#if __cplusplus >= 201103L\n-#include <type_traits>\n-#endif\n+#include <bits/new_allocator.h>\n \n namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n {\n@@ -52,168 +46,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @tparam  _Tp  Type of allocated object.\n    */\n   template<typename _Tp>\n-    class new_allocator\n+    class new_allocator : public std::__new_allocator<_Tp>\n     {\n     public:\n-      typedef _Tp        value_type;\n-      typedef std::size_t     size_type;\n-      typedef std::ptrdiff_t  difference_type;\n #if __cplusplus <= 201703L\n-      typedef _Tp*       pointer;\n-      typedef const _Tp* const_pointer;\n-      typedef _Tp&       reference;\n-      typedef const _Tp& const_reference;\n-\n       template<typename _Tp1>\n \tstruct rebind\n \t{ typedef new_allocator<_Tp1> other; };\n #endif\n \n-#if __cplusplus >= 201103L\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 2103. propagate_on_container_move_assignment\n-      typedef std::true_type propagate_on_container_move_assignment;\n-#endif\n-\n-      _GLIBCXX20_CONSTEXPR\n       new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n \n-      _GLIBCXX20_CONSTEXPR\n       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }\n \n       template<typename _Tp1>\n-\t_GLIBCXX20_CONSTEXPR\n \tnew_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }\n-\n-#if __cplusplus <= 201703L\n-      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n-\n-      pointer\n-      address(reference __x) const _GLIBCXX_NOEXCEPT\n-      { return std::__addressof(__x); }\n-\n-      const_pointer\n-      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n-      { return std::__addressof(__x); }\n-#endif\n-\n-#if __has_builtin(__builtin_operator_new) >= 201802L\n-# define _GLIBCXX_OPERATOR_NEW __builtin_operator_new\n-# define _GLIBCXX_OPERATOR_DELETE __builtin_operator_delete\n-#else\n-# define _GLIBCXX_OPERATOR_NEW ::operator new\n-# define _GLIBCXX_OPERATOR_DELETE ::operator delete\n-#endif\n-\n-      // NB: __n is permitted to be 0.  The C++ standard says nothing\n-      // about what the return value is when __n == 0.\n-      _GLIBCXX_NODISCARD _Tp*\n-      allocate(size_type __n, const void* = static_cast<const void*>(0))\n-      {\n-#if __cplusplus >= 201103L\n-\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t // 3308. std::allocator<void>().allocate(n)\n-\t static_assert(sizeof(_Tp) != 0, \"cannot allocate incomplete types\");\n-#endif\n-\n-\tif (__builtin_expect(__n > this->_M_max_size(), false))\n-\t  {\n-\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t    // 3190. allocator::allocate sometimes returns too little storage\n-\t    if (__n > (std::size_t(-1) / sizeof(_Tp)))\n-\t      std::__throw_bad_array_new_length();\n-\t    std::__throw_bad_alloc();\n-\t  }\n-\n-#if __cpp_aligned_new\n-\tif (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n-\t  {\n-\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n-\t    return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp),\n-\t\t\t\t\t\t\t   __al));\n-\t  }\n-#endif\n-\treturn static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp)));\n-      }\n-\n-      // __p is not permitted to be a null pointer.\n-      void\n-      deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))\n-      {\n-#if __cpp_sized_deallocation\n-# define _GLIBCXX_SIZED_DEALLOC(p, n) (p), (n) * sizeof(_Tp)\n-#else\n-# define _GLIBCXX_SIZED_DEALLOC(p, n) (p)\n-#endif\n-\n-#if __cpp_aligned_new\n-\tif (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n-\t  {\n-\t    _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n),\n-\t\t\t\t     std::align_val_t(alignof(_Tp)));\n-\t    return;\n-\t  }\n-#endif\n-\t_GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));\n-      }\n-\n-#undef _GLIBCXX_SIZED_DEALLOC\n-#undef _GLIBCXX_OPERATOR_DELETE\n-#undef _GLIBCXX_OPERATOR_NEW\n-\n-#if __cplusplus <= 201703L\n-      size_type\n-      max_size() const _GLIBCXX_USE_NOEXCEPT\n-      { return _M_max_size(); }\n-\n-#if __cplusplus >= 201103L\n-      template<typename _Up, typename... _Args>\n-\tvoid\n-\tconstruct(_Up* __p, _Args&&... __args)\n-\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n-\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n-\n-      template<typename _Up>\n-\tvoid\n-\tdestroy(_Up* __p)\n-\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n-\t{ __p->~_Up(); }\n-#else\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 402. wrong new expression in [some_] allocator::construct\n-      void\n-      construct(pointer __p, const _Tp& __val)\n-      { ::new((void *)__p) _Tp(__val); }\n-\n-      void\n-      destroy(pointer __p) { __p->~_Tp(); }\n-#endif\n-#endif // ! C++20\n-\n-      template<typename _Up>\n-\tfriend _GLIBCXX20_CONSTEXPR bool\n-\toperator==(const new_allocator&, const new_allocator<_Up>&)\n-\t_GLIBCXX_NOTHROW\n-\t{ return true; }\n-\n-#if __cpp_impl_three_way_comparison < 201907L\n-      template<typename _Up>\n-\tfriend _GLIBCXX20_CONSTEXPR bool\n-\toperator!=(const new_allocator&, const new_allocator<_Up>&)\n-\t_GLIBCXX_NOTHROW\n-\t{ return false; }\n-#endif\n-\n-    private:\n-      _GLIBCXX_CONSTEXPR size_type\n-      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n-      {\n-#if __PTRDIFF_MAX__ < __SIZE_MAX__\n-\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n-#else\n-\treturn std::size_t(-1) / sizeof(_Tp);\n-#endif\n-      }\n     };\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "b0a49e9b3f0dad41d53a734fcf146c0c499e9b06", "filename": "libstdc++-v3/testsuite/20_util/allocator/64135.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F64135.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9571a35db53e5203326f854f73e432691d67f6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F64135.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F64135.cc?ref=fe9571a35db53e5203326f854f73e432691d67f6", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile { target std_allocator_new } }\n+// { dg-add-options no_pch }\n+\n+// PR libstdc++/64135\n+\n+#define new_allocator 1\n+#define malloc_allocator 1\n+#define bitmap_allocator 1\n+#include <memory>\n+\n+#if __cplusplus >= 201103L\n+#define STATIC_ASSERT(X) static_assert((X), #X)\n+#else\n+#define PASTE2(X, Y) X##Y\n+#define PASTE(X, Y) PASTE2(X, Y)\n+#define STATIC_ASSERT(X) char PASTE(_assertion_, __LINE__) [(X) ? 1 : -1]\n+#endif\n+\n+#undef new_allocator\n+#undef malloc_allocator\n+#include <ext/new_allocator.h>\n+#include <ext/malloc_allocator.h>\n+\n+struct N : __gnu_cxx::new_allocator<char> { };\n+\n+struct A : std::allocator<char>, N { };\n+struct B : std::allocator<char> { N n; };\n+\n+// Verify that layout was not changed by removing std::allocator inheritance\n+// from __gnu_cxx::new_allocator:\n+STATIC_ASSERT( sizeof(A) == 2 );\n+STATIC_ASSERT( sizeof(B) == 2 );\n+\n+struct M : __gnu_cxx::malloc_allocator<char> { };\n+struct C : N, M { };\n+\n+// Verify that malloc_allocator can be an overlapping subobject with\n+// __new_allocator:\n+STATIC_ASSERT( sizeof(M) == 1 );\n+STATIC_ASSERT( sizeof(C) == 1 );\n+\n+struct D : std::allocator<char>, M { };\n+\n+// This test uses { target std_allocator_new } so this is true too:\n+STATIC_ASSERT( sizeof(D) == 1 );"}]}