{"sha": "c1ceaaa6f282cfde4ec4ebd91ef3630934da1993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFjZWFhYTZmMjgyY2ZkZTRlYzRlYmQ5MWVmMzYzMDkzNGRhMTk5Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-07-28T19:38:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-07-28T19:38:13Z"}, "message": "(copy_for_inline, case LABEL_REF): Properly copy LABEL_REF with LABEL_REF_NONLOCAL_P set.\n\n(copy_for_inline, case LABEL_REF): Properly copy LABEL_REF\nwith LABEL_REF_NONLOCAL_P set.\nCopy LABEL_OUTSIDE_LOOP_P flag.\n(copy_rtx_and_substitute, case LABEL_REF): Likewise.\n(copy_rtx_and_substitute, case CONST): Make recursive call for a LABEL_REF in\nthe constant pool.\n\nFrom-SVN: r5034", "tree": {"sha": "3b358034763c379821251ba4fa2f68e7d5838778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b358034763c379821251ba4fa2f68e7d5838778"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1ceaaa6f282cfde4ec4ebd91ef3630934da1993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ceaaa6f282cfde4ec4ebd91ef3630934da1993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ceaaa6f282cfde4ec4ebd91ef3630934da1993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ceaaa6f282cfde4ec4ebd91ef3630934da1993/comments", "author": null, "committer": null, "parents": [{"sha": "a0a34f94fa3e47e07d747d4d17fb6198bcc22724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a34f94fa3e47e07d747d4d17fb6198bcc22724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a34f94fa3e47e07d747d4d17fb6198bcc22724"}], "stats": {"total": 41, "additions": 24, "deletions": 17}, "files": [{"sha": "8529e4bae9bdd52281794103ccb052db3d761781", "filename": "gcc/integrate.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1ceaaa6f282cfde4ec4ebd91ef3630934da1993/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1ceaaa6f282cfde4ec4ebd91ef3630934da1993/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c1ceaaa6f282cfde4ec4ebd91ef3630934da1993", "patch": "@@ -988,11 +988,14 @@ copy_for_inline (orig)\n       break;\n \n     case LABEL_REF:\n-      {\n-\t/* Must point to the new insn.  */\n-\treturn gen_rtx (LABEL_REF, GET_MODE (orig),\n-\t\t\tlabel_map[CODE_LABEL_NUMBER (XEXP (orig, 0))]);\n-      }\n+      /* If this is a non-local label, just make a new LABEL_REF.\n+\t Otherwise, use the new label as well.  */\n+      x = gen_rtx (LABEL_REF, GET_MODE (orig),\n+\t\t   LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n+\t\t   : label_map[CODE_LABEL_NUMBER (XEXP (orig, 0))]);\n+      LABEL_REF_NONLOCAL_P (x) = LABEL_REF_NONLOCAL_P (orig);\n+      LABEL_OUTSIDE_LOOP_P (x) = LABEL_OUTSIDE_LOOP_P (orig);\n+      return x;\n \n     case REG:\n       if (REGNO (x) > LAST_VIRTUAL_REGISTER)\n@@ -2037,10 +2040,18 @@ copy_rtx_and_substitute (orig, map)\n       return map->label_map[CODE_LABEL_NUMBER (orig)];\n \n     case LABEL_REF:\n-      copy = rtx_alloc (LABEL_REF);\n-      PUT_MODE (copy, mode);\n-      XEXP (copy, 0) = map->label_map[CODE_LABEL_NUMBER (XEXP (orig, 0))];\n+      copy = gen_rtx (LABEL_REF, mode,\n+\t\t      LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n+\t\t      : map->label_map[CODE_LABEL_NUMBER (XEXP (orig, 0))]);\n       LABEL_OUTSIDE_LOOP_P (copy) = LABEL_OUTSIDE_LOOP_P (orig);\n+\n+      /* The fact that this label was previously nonlocal does not mean\n+\t it still is, so we must check if it is within the range of\n+\t this function's labels.  */\n+      LABEL_REF_NONLOCAL_P (copy)\n+\t= (LABEL_REF_NONLOCAL_P (orig)\n+\t   && ! (CODE_LABEL_NUMBER (XEXP (copy, 0)) >= get_first_label_num ()\n+\t\t && CODE_LABEL_NUMBER (XEXP (copy, 0)) < max_label_num ()));\n       return copy;\n \n     case PC:\n@@ -2056,16 +2067,12 @@ copy_rtx_and_substitute (orig, map)\n \t{\n \t  rtx constant = get_pool_constant (orig);\n \t  if (GET_CODE (constant) == LABEL_REF)\n-\t    {\n-\t      copy = rtx_alloc (LABEL_REF);\n-\t      PUT_MODE (copy, mode);\n-\t      XEXP (copy, 0)\n-\t\t= map->label_map[CODE_LABEL_NUMBER (XEXP (constant, 0))];\n-\t      LABEL_OUTSIDE_LOOP_P (copy) = LABEL_OUTSIDE_LOOP_P (orig);\n-\t      copy = force_const_mem (Pmode, copy);\n-\t      return XEXP (copy, 0);\n-\t    }\n+\t    return XEXP (force_const_mem (Pmode, \n+\t\t\t\t\t  copy_rtx_and_substitute (constant,\n+\t\t\t\t\t\t\t\t   map)),\n+\t\t\t 0);\n \t}\n+\n       return orig;\n \n     case CONST_DOUBLE:"}]}