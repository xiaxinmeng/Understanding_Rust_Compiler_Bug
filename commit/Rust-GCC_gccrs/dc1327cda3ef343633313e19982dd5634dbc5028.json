{"sha": "dc1327cda3ef343633313e19982dd5634dbc5028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxMzI3Y2RhM2VmMzQzNjMzMzEzZTE5OTgyZGQ1NjM0ZGJjNTAyOA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2007-11-26T06:38:30Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-11-26T06:38:30Z"}, "message": "dwarf2asm.c (splay_tree_compare_strings): New function.\n\n* dwarf2asm.c (splay_tree_compare_strings): New function.\n(dw2_force_const_mem): Use it.\n\nFrom-SVN: r130430", "tree": {"sha": "8603c261d78b0df67dcd921e5c5d0bcdd1c7cb45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8603c261d78b0df67dcd921e5c5d0bcdd1c7cb45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc1327cda3ef343633313e19982dd5634dbc5028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1327cda3ef343633313e19982dd5634dbc5028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1327cda3ef343633313e19982dd5634dbc5028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1327cda3ef343633313e19982dd5634dbc5028/comments", "author": null, "committer": null, "parents": [{"sha": "0043f60679c6c6b8b76acb75cf8a7e363aca1d06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0043f60679c6c6b8b76acb75cf8a7e363aca1d06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0043f60679c6c6b8b76acb75cf8a7e363aca1d06"}], "stats": {"total": 34, "additions": 33, "deletions": 1}, "files": [{"sha": "36c1dd8f92a388804b201ea444656ee3993c1ccd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1327cda3ef343633313e19982dd5634dbc5028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1327cda3ef343633313e19982dd5634dbc5028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc1327cda3ef343633313e19982dd5634dbc5028", "patch": "@@ -1,3 +1,8 @@\n+2007-11-26  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* dwarf2asm.c (splay_tree_compare_strings): New function.\n+\t(dw2_force_const_mem): Use it.\n+\n 2007-11-26  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* tree.c (type_hash_add): Don't violate strict aliasing rules."}, {"sha": "11903fe81a9b0921fcb0237986500484168f475d", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1327cda3ef343633313e19982dd5634dbc5028/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1327cda3ef343633313e19982dd5634dbc5028/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=dc1327cda3ef343633313e19982dd5634dbc5028", "patch": "@@ -701,6 +701,31 @@ static GTY(()) int dw2_const_labelno;\n # define USE_LINKONCE_INDIRECT 0\n #endif\n \n+/* Comparison function for a splay tree in which the keys are strings.\n+   K1 and K2 have the dynamic type \"const char *\".  Returns <0, 0, or\n+   >0 to indicate whether K1 is less than, equal to, or greater than\n+   K2, respectively.  */\n+\n+static int\n+splay_tree_compare_strings (splay_tree_key k1, splay_tree_key k2)\n+{\n+  const char *s1 = (const char *)k1;\n+  const char *s2 = (const char *)k2;\n+  int ret;\n+\n+  if (s1 == s2)\n+    return 0;\n+\n+  ret = strcmp (s1, s2);\n+\n+  /* The strings are always those from IDENTIFIER_NODEs, and,\n+     therefore, we should never have two copies of the same\n+     string.  */\n+  gcc_assert (ret);\n+\n+  return ret;\n+}\n+\n /* Put X, a SYMBOL_REF, in memory.  Return a SYMBOL_REF to the allocated\n    memory.  Differs from force_const_mem in that a single pool is used for\n    the entire unit of translation, and the memory is not guaranteed to be\n@@ -715,7 +740,9 @@ dw2_force_const_mem (rtx x, bool public)\n   tree decl;\n \n   if (! indirect_pool)\n-    indirect_pool = splay_tree_new_ggc (splay_tree_compare_pointers);\n+    /* We use strcmp, rather than just comparing pointers, so that the\n+       sort order will not depend on the host system.  */\n+    indirect_pool = splay_tree_new_ggc (splay_tree_compare_strings);\n \n   gcc_assert (GET_CODE (x) == SYMBOL_REF);\n "}]}