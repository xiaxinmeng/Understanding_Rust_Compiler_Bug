{"sha": "ba3f46d0910139e56300a68bc7992c0217b7adb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzZjQ2ZDA5MTAxMzllNTYzMDBhNjhiYzc5OTJjMDIxN2I3YWRiOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-04-08T11:41:59Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-04-08T11:41:59Z"}, "message": "decl.c (gnat_to_gnu_entity): If -gnatd.a and not optimizing alignment for space...\n\n\t* decl.c (gnat_to_gnu_entity) <object>: If -gnatd.a and not optimizing\n\talignment for space, promote the alignment of non-scalar variables with\n\tno size and alignment.\n\t* gigi.h (gnat_types_compatible_p): Declare.\n\t* misc.c (LANG_HOOKS_TYPES_COMPATIBLE_P): Set to above predicate.\n\t* trans.c (gnat_to_gnu): Revert revision 129339 change.  Minor cleanup.\n\t* utils.c (gnat_types_compatible_p) : New predicate.\n\t(convert): Use it throughout to test for cases where a mere view\n\tconversion is sufficient.\n\t* utils2.c (build_binary_op): Minor tweaks.\n\t(build_unary_op): Likewise.\n\nFrom-SVN: r134092", "tree": {"sha": "e039d18b7e69f9b896b96ec52a36f7115dac70fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e039d18b7e69f9b896b96ec52a36f7115dac70fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba3f46d0910139e56300a68bc7992c0217b7adb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3f46d0910139e56300a68bc7992c0217b7adb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3f46d0910139e56300a68bc7992c0217b7adb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3f46d0910139e56300a68bc7992c0217b7adb9/comments", "author": null, "committer": null, "parents": [{"sha": "373140ef746ba530ad7d3ff56c9e6aea4aacdf0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/373140ef746ba530ad7d3ff56c9e6aea4aacdf0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/373140ef746ba530ad7d3ff56c9e6aea4aacdf0f"}], "stats": {"total": 256, "additions": 167, "deletions": 89}, "files": [{"sha": "8a6c4b5069f9eebd249b531005b3515729eea10b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -1,3 +1,17 @@\n+2008-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (gnat_to_gnu_entity) <object>: If -gnatd.a and not optimizing\n+\talignment for space, promote the alignment of non-scalar variables with\n+\tno size and alignment.\n+\t* gigi.h (gnat_types_compatible_p): Declare.\n+\t* misc.c (LANG_HOOKS_TYPES_COMPATIBLE_P): Set to above predicate.\n+\t* trans.c (gnat_to_gnu): Revert revision 129339 change.  Minor cleanup.\n+\t* utils.c (gnat_types_compatible_p) : New predicate.\n+\t(convert): Use it throughout to test for cases where a mere view\n+\tconversion is sufficient.\n+\t* utils2.c (build_binary_op): Minor tweaks.\n+\t(build_unary_op): Likewise.\n+\n 2008-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* decl.c (adjust_packed): Expand comment."}, {"sha": "bc5d42830536e98a6f937dddd7f667e0321cc17b", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -672,19 +672,42 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && !Present (Address_Clause (gnat_entity)))\n \t  gnu_size = bitsize_unit_node;\n \n-\t/* If this is an atomic object with no specified size and alignment,\n-\t   but where the size of the type is a constant, set the alignment to\n-\t   the smallest not less than the size, or to the biggest meaningful\n-\t   alignment, whichever is smaller.  */\n-\tif (Is_Atomic (gnat_entity) && !gnu_size && align == 0\n+\t/* If this is an object with no specified size and alignment, and if\n+\t   either it is atomic or we are not optimizing alignment for space\n+\t   and it is a non-scalar variable, and the size of its type is a\n+\t   constant, set the alignment to the smallest not less than the\n+\t   size, or to the biggest meaningful one, whichever is smaller.  */\n+\tif (!gnu_size && align == 0\n+\t    && (Is_Atomic (gnat_entity)\n+\t\t|| (Debug_Flag_Dot_A\n+\t\t    && !Optimize_Alignment_Space (gnat_entity)\n+\t\t    && kind == E_Variable\n+\t\t    && AGGREGATE_TYPE_P (gnu_type)\n+\t\t    && !const_flag && No (Renamed_Object (gnat_entity))\n+\t\t    && !imported_p && No (Address_Clause (gnat_entity))))\n \t    && TREE_CODE (TYPE_SIZE (gnu_type)) == INTEGER_CST)\n \t  {\n+\t    /* No point in jumping through all the hoops needed in order\n+\t       to support BIGGEST_ALIGNMENT if we don't really have to.  */\n+\t    unsigned int align_cap = Is_Atomic (gnat_entity)\n+\t\t\t\t     ? BIGGEST_ALIGNMENT\n+\t\t\t\t     : MAX_FIXED_MODE_SIZE;\n+\n \t    if (!host_integerp (TYPE_SIZE (gnu_type), 1)\n-\t\t|| 0 <= compare_tree_int (TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  BIGGEST_ALIGNMENT))\n-\t      align = BIGGEST_ALIGNMENT;\n+\t\t|| compare_tree_int (TYPE_SIZE (gnu_type), align_cap) >= 0)\n+\t      align = align_cap;\n \t    else\n \t      align = ceil_alignment (tree_low_cst (TYPE_SIZE (gnu_type), 1));\n+\n+\t    /* But make sure not to under-align the object.  */\n+\t    if (align < TYPE_ALIGN (gnu_type))\n+\t      align = TYPE_ALIGN (gnu_type);\n+\n+\t    /* And honor the minimum valid atomic alignment, if any.  */\n+#ifdef MINIMUM_ATOMIC_ALIGNMENT\n+\t    if (align < MINIMUM_ATOMIC_ALIGNMENT)\n+\t      align = MINIMUM_ATOMIC_ALIGNMENT;\n+#endif\n \t  }\n \n \t/* If the object is set to have atomic components, find the component"}, {"sha": "b35604447e1ecddb2021d7708792c67b21899398", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -468,6 +468,10 @@ extern tree gnat_unsigned_type (tree type_node);\n /* Return the signed version of a TYPE_NODE, a scalar type.  */\n extern tree gnat_signed_type (tree type_node);\n \n+/* Return 1 if the types T1 and T2 are compatible, i.e. if they can be\n+   transparently converted to each other.  */\n+extern int gnat_types_compatible_p (tree t1, tree t2);\n+\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable"}, {"sha": "a4dd99c5c2d61acf23c33e9ed89fcbc9fbc07071", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -151,6 +151,8 @@ static tree gnat_type_max_size\t\t(const_tree);\n #define LANG_HOOKS_TYPE_FOR_MODE\tgnat_type_for_mode\n #undef  LANG_HOOKS_TYPE_FOR_SIZE\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgnat_type_for_size\n+#undef  LANG_HOOKS_TYPES_COMPATIBLE_P\n+#define LANG_HOOKS_TYPES_COMPATIBLE_P\tgnat_types_compatible_p\n #undef  LANG_HOOKS_ATTRIBUTE_TABLE\n #define LANG_HOOKS_ATTRIBUTE_TABLE\tgnat_internal_attribute_table\n #undef  LANG_HOOKS_BUILTIN_FUNCTION"}, {"sha": "82aaa99140c5cfe1d4f72e4ac447d5a10ab1efc1", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -4832,34 +4832,41 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))))\n     gnu_result = gnat_stabilize_reference (gnu_result, false);\n \n-  /* Now convert the result to the proper type.  If the type is void or if\n-     we have no result, return error_mark_node to show we have no result.\n-     If the type of the result is correct or if we have a label (which doesn't\n-     have any well-defined type), return our result.  Also don't do the\n-     conversion if the \"desired\" type involves a PLACEHOLDER_EXPR in its size\n-     since those are the cases where the front end may have the type wrong due\n-     to \"instantiating\" the unconstrained record with discriminant values\n-     or if this is a FIELD_DECL.  If this is the Name of an assignment\n-     statement or a parameter of a procedure call, return what we have since\n-     the RHS has to be converted to our type there in that case, unless\n-     GNU_RESULT_TYPE has a simpler size.  Similarly, if the two types are\n-     record types with the same name and GNU_RESULT_TYPE has BLKmode, don't\n-     convert.  This will be the case when we are converting from a packable\n-     type to its actual type and we need those conversions to be NOPs in\n-     order for assignments into these types to work properly.  Finally,\n-     don't convert integral types that are the operand of an unchecked\n-     conversion since we need to ignore those conversions (for 'Valid).\n-     Otherwise, convert the result to the proper type.  */\n+  /* Now convert the result to the result type, unless we are in one of the\n+     following cases:\n+\n+       1. If this is the Name of an assignment statement or a parameter of\n+\t  a procedure call, return the result almost unmodified since the\n+\t  RHS will have to be converted to our type in that case, unless\n+\t  the result type has a simpler size.   Similarly, don't convert\n+\t  integral types that are the operands of an unchecked conversion\n+\t  since we need to ignore those conversions (for 'Valid).\n+\n+       2. If we have a label (which doesn't have any well-defined type), a\n+\t  field or an error, return the result almost unmodified.  Also don't\n+\t  do the conversion if the result type involves a PLACEHOLDER_EXPR in\n+\t  its size since those are the cases where the front end may have the\n+\t  type wrong due to \"instantiating\" the unconstrained record with\n+\t  discriminant values.  Similarly, if the two types are record types\n+\t  with the same name and the result type has BLKmode, don't convert.\n+\t  This will be the case when we are converting from a packed version\n+\t  of a type to its original type and we need those conversions to be\n+\t  NOPs in order for assignments into these types to work properly.\n+\n+       3. If the type is void or if we have no result, return error_mark_node\n+\t  to show we have no result.\n+\n+       4. Finally, if the type of the result is already correct.  */\n \n   if (Present (Parent (gnat_node))\n       && ((Nkind (Parent (gnat_node)) == N_Assignment_Statement\n \t   && Name (Parent (gnat_node)) == gnat_node)\n \t  || (Nkind (Parent (gnat_node)) == N_Procedure_Call_Statement\n \t      && Name (Parent (gnat_node)) != gnat_node)\n+\t  || Nkind (Parent (gnat_node)) == N_Parameter_Association\n \t  || (Nkind (Parent (gnat_node)) == N_Unchecked_Type_Conversion\n \t      && !AGGREGATE_TYPE_P (gnu_result_type)\n-\t      && !AGGREGATE_TYPE_P (TREE_TYPE (gnu_result)))\n-\t  || Nkind (Parent (gnat_node)) == N_Parameter_Association)\n+\t      && !AGGREGATE_TYPE_P (TREE_TYPE (gnu_result))))\n       && !(TYPE_SIZE (gnu_result_type)\n \t   && TYPE_SIZE (TREE_TYPE (gnu_result))\n \t   && (AGGREGATE_TYPE_P (gnu_result_type)\n@@ -4874,16 +4881,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   && !(TREE_CODE (gnu_result_type) == RECORD_TYPE\n \t\t&& TYPE_JUSTIFIED_MODULAR_P (gnu_result_type))))\n     {\n-      /* In this case remove padding only if the inner object type is the\n-\t same as gnu_result_type or is of self-referential size (in that later\n-\t case it must be an object of unconstrained type with a default\n-\t discriminant).  We want to avoid copying too much data.  */\n+      /* Remove padding only if the inner object is of self-referential\n+\t size: in that case it must be an object of unconstrained type\n+\t with a default discriminant and we want to avoid copying too\n+\t much data.  */\n       if (TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result))\n-\t  && (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result)))\n-                         == gnu_result_type\n-\t      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t\t     (TREE_TYPE (gnu_result)))))))\n+\t  && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n+\t\t\t\t     (TREE_TYPE (gnu_result))))))\n \tgnu_result = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n \t\t\t      gnu_result);\n     }\n@@ -4901,20 +4906,20 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       && TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n \t       && TYPE_MODE (gnu_result_type) == BLKmode))\n     {\n-      /* Remove any padding record, but do nothing more in this case.  */\n+      /* Remove any padding.  */\n       if (TREE_CODE (TREE_TYPE (gnu_result)) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n \tgnu_result = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n \t\t\t      gnu_result);\n     }\n \n-  else if (gnu_result == error_mark_node\n-\t   || gnu_result_type == void_type_node)\n-    gnu_result =  error_mark_node;\n+  else if (gnu_result == error_mark_node || gnu_result_type == void_type_node)\n+    gnu_result = error_mark_node;\n+\n   else if (gnu_result_type != TREE_TYPE (gnu_result))\n     gnu_result = convert (gnu_result_type, gnu_result);\n \n-  /* We don't need any NOP_EXPR or NON_LVALUE_EXPR on GNU_RESULT.  */\n+  /* We don't need any NOP_EXPR or NON_LVALUE_EXPR on the result.  */\n   while ((TREE_CODE (gnu_result) == NOP_EXPR\n \t  || TREE_CODE (gnu_result) == NON_LVALUE_EXPR)\n \t && TREE_TYPE (TREE_OPERAND (gnu_result, 0)) == TREE_TYPE (gnu_result))"}, {"sha": "5186ccb076e8cb11785288fd22f28e521095d160", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -2378,6 +2378,42 @@ gnat_signed_type (tree type_node)\n   return type;\n }\n \n+/* Return 1 if the types T1 and T2 are compatible, i.e. if they can be\n+   transparently converted to each other.  */\n+\n+int\n+gnat_types_compatible_p (tree t1, tree t2)\n+{\n+  enum tree_code code;\n+\n+  /* This is the default criterion.  */\n+  if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+    return 1;\n+\n+  /* We only check structural equivalence here.  */\n+  if ((code = TREE_CODE (t1)) != TREE_CODE (t2))\n+    return 0;\n+\n+  /* Array types are also compatible if they are constrained and have\n+     the same component type and the same domain.  */\n+  if (code == ARRAY_TYPE\n+      && TREE_TYPE (t1) == TREE_TYPE (t2)\n+      && tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (t1)),\n+\t\t\t     TYPE_MIN_VALUE (TYPE_DOMAIN (t2)))\n+      && tree_int_cst_equal (TYPE_MAX_VALUE (TYPE_DOMAIN (t1)),\n+\t\t\t     TYPE_MAX_VALUE (TYPE_DOMAIN (t2))))\n+    return 1;\n+\n+  /* Padding record types are also compatible if they pad the same\n+     type and have the same constant size.  */\n+  if (code == RECORD_TYPE\n+      && TYPE_IS_PADDING_P (t1) && TYPE_IS_PADDING_P (t2)\n+      && TREE_TYPE (TYPE_FIELDS (t1)) == TREE_TYPE (TYPE_FIELDS (t2))\n+      && tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2)))\n+    return 1;\n+\n+  return 0;\n+}\n \f\n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or\n@@ -3368,15 +3404,15 @@ convert (tree type, tree expr)\n   /* If both input and output have padding and are of variable size, do this\n      as an unchecked conversion.  Likewise if one is a mere variant of the\n      other, so we avoid a pointless unpad/repad sequence.  */\n-  else if (ecode == RECORD_TYPE && code == RECORD_TYPE\n+  else if (code == RECORD_TYPE && ecode == RECORD_TYPE\n \t   && TYPE_IS_PADDING_P (type) && TYPE_IS_PADDING_P (etype)\n \t   && (!TREE_CONSTANT (TYPE_SIZE (type))\n \t       || !TREE_CONSTANT (TYPE_SIZE (etype))\n-\t       || TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype)))\n+\t       || gnat_types_compatible_p (type, etype)))\n     ;\n \n-  /* If the output type has padding, make a constructor to build the\n-     record.  */\n+  /* If the output type has padding, convert to the inner type and\n+     make a constructor to build the record.  */\n   else if (code == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n     {\n       /* If we previously converted from another type and our type is\n@@ -3387,12 +3423,15 @@ convert (tree type, tree expr)\n \texpr = TREE_OPERAND (expr, 0);\n \n       /* If we are just removing the padding from expr, convert the original\n-\t object if we have variable size.  That will avoid the need\n-\t for some variable-size temporaries.  */\n+\t object if we have variable size in order to avoid the need for some\n+\t variable-size temporaries.  Likewise if the padding is a mere variant\n+\t of the other, so we avoid a pointless unpad/repad sequence.  */\n       if (TREE_CODE (expr) == COMPONENT_REF\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\t  && !TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  && (!TREE_CONSTANT (TYPE_SIZE (type))\n+\t      || gnat_types_compatible_p (type,\n+\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (expr, 0)))))\n \treturn convert (type, TREE_OPERAND (expr, 0));\n \n       /* If the result type is a padded type with a self-referentially-sized\n@@ -3506,14 +3545,9 @@ convert (tree type, tree expr)\n       break;\n \n     case CONSTRUCTOR:\n-      /* If we are converting a CONSTRUCTOR to another constrained array type\n-\t with the same domain, just make a new one in the proper type.  */\n-      if (code == ecode && code == ARRAY_TYPE\n-\t  && TREE_TYPE (type) == TREE_TYPE (etype)\n-\t  && tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (type)),\n-\t\t\t\t TYPE_MIN_VALUE (TYPE_DOMAIN (etype)))\n-\t  && tree_int_cst_equal (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n-\t\t\t\t TYPE_MAX_VALUE (TYPE_DOMAIN (etype))))\n+      /* If we are converting a CONSTRUCTOR to a mere variant type, just make\n+\t a new one in the proper type.  */\n+      if (gnat_types_compatible_p (type, etype))\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n@@ -3539,7 +3573,6 @@ convert (tree type, tree expr)\n \t   the inner operand to the output type is fine in most cases, it\n \t   might expose unexpected input/output type mismatches in special\n \t   circumstances so we avoid such recursive calls when we can.  */\n-\n \ttree op0 = TREE_OPERAND (expr, 0);\n \n \t/* If we are converting back to the original type, we can just\n@@ -3549,13 +3582,13 @@ convert (tree type, tree expr)\n \t  return op0;\n \n \t/* Otherwise, if we're converting between two aggregate types, we\n-\t   might be allowed to substitute the VIEW_CONVERT target type in\n-\t   place or to just convert the inner expression.  */\n+\t   might be allowed to substitute the VIEW_CONVERT_EXPR target type\n+\t   in place or to just convert the inner expression.  */\n \tif (AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype))\n \t  {\n-\t    /* If we are converting between type variants, we can just\n-\t       substitute the VIEW_CONVERT in place.  */\n-\t    if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n+\t    /* If we are converting between mere variants, we can just\n+\t       substitute the VIEW_CONVERT_EXPR in place.  */\n+\t    if (gnat_types_compatible_p (type, etype))\n \t      return build1 (VIEW_CONVERT_EXPR, type, op0);\n \n \t    /* Otherwise, we may just bypass the input view conversion unless\n@@ -3594,10 +3627,10 @@ convert (tree type, tree expr)\n   if (TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n     return convert_to_fat_pointer (type, expr);\n \n-  /* If we're converting between two aggregate types that have the same main\n-     variant, just make a VIEW_CONVER_EXPR.  */\n+  /* If we're converting between two aggregate types that are mere\n+     variants, just make a VIEW_CONVERT_EXPR.  */\n   else if (AGGREGATE_TYPE_P (type)\n-\t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n+\t   && gnat_types_compatible_p (type, etype))\n     return build1 (VIEW_CONVERT_EXPR, type, expr);\n \n   /* In all other cases of related types, make a NOP_EXPR.  */"}, {"sha": "e680d090ba09ed075ba0095229836c862f7cf649", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3f46d0910139e56300a68bc7992c0217b7adb9/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=ba3f46d0910139e56300a68bc7992c0217b7adb9", "patch": "@@ -633,8 +633,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n   tree right_base_type = get_base_type (right_type);\n   tree operation_type = result_type;\n   tree best_type = NULL_TREE;\n-  tree modulus;\n-  tree result;\n+  tree modulus, result;\n   bool has_side_effects = false;\n \n   if (operation_type\n@@ -647,18 +646,19 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       && TYPE_EXTRA_SUBTYPE_P (operation_type))\n     operation_type = get_base_type (operation_type);\n \n-  modulus = (operation_type && TREE_CODE (operation_type) == INTEGER_TYPE\n+  modulus = (operation_type\n+\t     && TREE_CODE (operation_type) == INTEGER_TYPE\n \t     && TYPE_MODULAR_P (operation_type)\n-\t     ? TYPE_MODULUS (operation_type) : 0);\n+\t     ? TYPE_MODULUS (operation_type) : NULL_TREE);\n \n   switch (op_code)\n     {\n     case MODIFY_EXPR:\n-      /* If there were any integral or pointer conversions on LHS, remove\n+      /* If there were integral or pointer conversions on the LHS, remove\n \t them; we'll be putting them back below if needed.  Likewise for\n-\t conversions between array and record types.  But don't do this if\n-\t the right operand is not BLKmode (for packed arrays)\n-\t unless we are not changing the mode.  */\n+\t conversions between array and record types, except for justified\n+\t modular types.  But don't do this if the right operand is not\n+\t BLKmode (for packed arrays) unless we are not changing the mode.  */\n       while ((TREE_CODE (left_operand) == CONVERT_EXPR\n \t      || TREE_CODE (left_operand) == NOP_EXPR\n \t      || TREE_CODE (left_operand) == VIEW_CONVERT_EXPR)\n@@ -669,8 +669,6 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t      || POINTER_TYPE_P (TREE_TYPE\n \t\t\t\t\t (TREE_OPERAND (left_operand, 0)))))\n \t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n-\t\t       /* Don't remove conversions to justified modular\n-\t\t\t  types. */\n \t\t       && !TYPE_JUSTIFIED_MODULAR_P (left_type))\n \t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n \t\t     && ((TREE_CODE (TREE_TYPE\n@@ -692,8 +690,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       if (!operation_type)\n \toperation_type = left_type;\n \n-      /* If we are copying one array or record to another, find the best type\n-\t to use.  */\n+      /* Find the best type to use for copying between aggregate types.  */\n       if (((TREE_CODE (left_type) == ARRAY_TYPE\n \t    && TREE_CODE (right_type) == ARRAY_TYPE)\n \t   || (TREE_CODE (left_type) == RECORD_TYPE\n@@ -709,11 +706,11 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n       /* Ensure everything on the LHS is valid.  If we have a field reference,\n \t strip anything that get_inner_reference can handle.  Then remove any\n-\t conversions with type types having the same code and mode.  Mark\n+\t conversions between types having the same code and mode.  And mark\n \t VIEW_CONVERT_EXPRs with TREE_ADDRESSABLE.  When done, we must have\n-\t either an INDIRECT_REF or a decl.  */\n+\t either an INDIRECT_REF, a NULL_EXPR or a DECL node.  */\n       result = left_operand;\n-      while (1)\n+      while (true)\n \t{\n \t  tree restype = TREE_TYPE (result);\n \n@@ -744,21 +741,21 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t}\n \n       gcc_assert (TREE_CODE (result) == INDIRECT_REF\n-\t\t  || TREE_CODE (result) == NULL_EXPR || DECL_P (result));\n+\t\t  || TREE_CODE (result) == NULL_EXPR\n+\t\t  || DECL_P (result));\n \n-      /* Convert the right operand to the operation type unless\n-\t it is either already of the correct type or if the type\n-\t involves a placeholder, since the RHS may not have the same\n-\t record type.  */\n+      /* Convert the right operand to the operation type unless it is\n+\t either already of the correct type or if the type involves a\n+\t placeholder, since the RHS may not have the same record type.  */\n       if (operation_type != right_type\n-\t  && (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type))))\n+\t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type)))\n \t{\n \t  right_operand = convert (operation_type, right_operand);\n \t  right_type = operation_type;\n \t}\n \n-      /* If the left operand is not the same type as the operation type,\n-\t surround it in a VIEW_CONVERT_EXPR.  */\n+      /* If the left operand is not of the same type as the operation\n+\t type, wrap it up in a VIEW_CONVERT_EXPR.  */\n       if (left_type != operation_type)\n \tleft_operand = unchecked_convert (operation_type, left_operand, false);\n \n@@ -1286,7 +1283,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \ttree modulus = ((operation_type\n \t\t\t && TREE_CODE (operation_type) == INTEGER_TYPE\n \t\t\t && TYPE_MODULAR_P (operation_type))\n-\t\t\t? TYPE_MODULUS (operation_type) : 0);\n+\t\t\t? TYPE_MODULUS (operation_type) : NULL_TREE);\n \tint mod_pow2 = modulus && integer_pow2p (modulus);\n \n \t/* If this is a modular type, there are various possibilities"}]}