{"sha": "c138eb5ce4f675fe9bdca939b6c43545d0f75691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEzOGViNWNlNGY2NzVmZTliZGNhOTM5YjZjNDM1NDVkMGY3NTY5MQ==", "commit": {"author": {"name": "Charles Baylis", "email": "charles.baylis@linaro.org", "date": "2017-11-23T18:37:18Z"}, "committer": {"name": "Charles Baylis", "email": "cbaylis@gcc.gnu.org", "date": "2017-11-23T18:37:18Z"}, "message": "[ARM] Refactor costs calculation for MEM.\n\nThis patch moves the calculation of costs for MEM into a\nseparate function, and reforms the calculation into two\nparts. Firstly any additional cost of the addressing mode\nis calculated, and then the cost of the memory access itself\nis added.\n\nIn this patch, the calculation of the cost of the addressing\nmode is omitted, to be added in a subsequent patch.\n\ngcc/ChangeLog:\n\n<date>  Charles Baylis  <charles.baylis@linaro.org>\n\n        * config/arm/arm.c (arm_mem_costs): New function.\n        (arm_rtx_costs_internal): Use arm_mem_costs.\n\ngcc/testsuite/ChangeLog:\n\n<date>  Charles Baylis  <charles.baylis@linaro.org>\n\n        * gcc.target/arm/addr-modes-float.c: New test.\n        * gcc.target/arm/addr-modes-int.c: New test.\n        * gcc.target/arm/addr-modes.h: New header.\n\nFrom-SVN: r255111", "tree": {"sha": "ee104dbcec3f3a84e5fc73a8c14a6e9ac646401e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee104dbcec3f3a84e5fc73a8c14a6e9ac646401e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c138eb5ce4f675fe9bdca939b6c43545d0f75691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c138eb5ce4f675fe9bdca939b6c43545d0f75691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c138eb5ce4f675fe9bdca939b6c43545d0f75691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c138eb5ce4f675fe9bdca939b6c43545d0f75691/comments", "author": null, "committer": null, "parents": [{"sha": "207180e159492bd884a37b071bc69a011072e403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207180e159492bd884a37b071bc69a011072e403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207180e159492bd884a37b071bc69a011072e403"}], "stats": {"total": 223, "additions": 198, "deletions": 25}, "files": [{"sha": "e41ae9f2dc40c4c8166a4ea79f25d8acfdeaf8fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c138eb5ce4f675fe9bdca939b6c43545d0f75691", "patch": "@@ -1,3 +1,8 @@\n+2017-11-23  Charles Baylis  <charles.baylis@linaro.org>\n+\n+\t* config/arm/arm.c (arm_mem_costs): New function.\n+\t(arm_rtx_costs_internal): Use arm_mem_costs.\n+\n 2017-11-23  Mark Wielaard  <mark@klomp.org>\n \n \t* dwarf2out.c (init_sections_and_labels): Use generation to create"}, {"sha": "5bdf7ff7e047bc32819221daafb75c075494e136", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c138eb5ce4f675fe9bdca939b6c43545d0f75691", "patch": "@@ -9242,8 +9242,52 @@ arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)\n \t  }\t\t\t\t\t\t\t\t\\\n \twhile (0)\n \n+/* Helper function for arm_rtx_costs_internal.  Calculates the cost of a MEM,\n+   considering the costs of the addressing mode and memory access\n+   separately.  */\n+static bool\n+arm_mem_costs (rtx x, const struct cpu_cost_table *extra_cost,\n+\t       int *cost, bool speed_p)\n+{\n+  machine_mode mode = GET_MODE (x);\n+\n+  *cost = COSTS_N_INSNS (1);\n+\n+  if (flag_pic\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && will_be_in_index_register (XEXP (XEXP (x, 0), 1)))\n+    /* This will be split into two instructions.  Add the cost of the\n+       additional instruction here.  The cost of the memory access is computed\n+       below.  See arm.md:calculate_pic_address.  */\n+    *cost += COSTS_N_INSNS (1);\n+\n+  /* Calculate cost of memory access.  */\n+  if (speed_p)\n+    {\n+      if (FLOAT_MODE_P (mode))\n+\t{\n+\t  if (GET_MODE_SIZE (mode) == 8)\n+\t    *cost += extra_cost->ldst.loadd;\n+\t  else\n+\t    *cost += extra_cost->ldst.loadf;\n+\t}\n+      else if (VECTOR_MODE_P (mode))\n+\t*cost += extra_cost->ldst.loadv;\n+      else\n+\t{\n+\t  /* Integer modes */\n+\t  if (GET_MODE_SIZE (mode) == 8)\n+\t    *cost += extra_cost->ldst.ldrd;\n+\t  else\n+\t    *cost += extra_cost->ldst.load;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* RTX costs.  Make an estimate of the cost of executing the operation\n-   X, which is contained with an operation with code OUTER_CODE.\n+   X, which is contained within an operation with code OUTER_CODE.\n    SPEED_P indicates whether the cost desired is the performance cost,\n    or the size cost.  The estimate is stored in COST and the return\n    value is TRUE if the cost calculation is final, or FALSE if the\n@@ -9322,30 +9366,7 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case MEM:\n-      /* A memory access costs 1 insn if the mode is small, or the address is\n-\t a single register, otherwise it costs one insn per word.  */\n-      if (REG_P (XEXP (x, 0)))\n-\t*cost = COSTS_N_INSNS (1);\n-      else if (flag_pic\n-\t       && GET_CODE (XEXP (x, 0)) == PLUS\n-\t       && will_be_in_index_register (XEXP (XEXP (x, 0), 1)))\n-\t/* This will be split into two instructions.\n-\t   See arm.md:calculate_pic_address.  */\n-\t*cost = COSTS_N_INSNS (2);\n-      else\n-\t*cost = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n-\n-      /* For speed optimizations, add the costs of the address and\n-\t accessing memory.  */\n-      if (speed_p)\n-#ifdef NOT_YET\n-\t*cost += (extra_cost->ldst.load\n-\t\t  + arm_address_cost (XEXP (x, 0), mode,\n-\t\t\t\t      ADDR_SPACE_GENERIC, speed_p));\n-#else\n-        *cost += extra_cost->ldst.load;\n-#endif\n-      return true;\n+      return arm_mem_costs (x, extra_cost, cost, speed_p);\n \n     case PARALLEL:\n     {"}, {"sha": "a89696fe45d32a7c2dfaef8b1663c3d0e71b00dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c138eb5ce4f675fe9bdca939b6c43545d0f75691", "patch": "@@ -1,3 +1,9 @@\n+2017-11-23  Charles Baylis  <charles.baylis@linaro.org>\n+\n+\t* gcc.target/arm/addr-modes-float.c: New test.\n+\t* gcc.target/arm/addr-modes-int.c: New test.\n+\t* gcc.target/arm/addr-modes.h: New header.\n+\n 2017-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* testsuite/gcc.dg/pr64277.c: Adjust scan."}, {"sha": "3b4235c87b917cbc886503a8c9def607e5eb0a35", "filename": "gcc/testsuite/gcc.target/arm/addr-modes-float.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes-float.c?ref=c138eb5ce4f675fe9bdca939b6c43545d0f75691", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options arm_neon } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-do compile } */\n+\n+#include <arm_neon.h>\n+\n+#include \"addr-modes.h\"\n+\n+POST_STORE(float)\n+/* { dg-final { scan-assembler \"vstmia.32\" } } */\n+POST_STORE(double)\n+/* { dg-final { scan-assembler \"vstmia.64\" } } */\n+\n+POST_LOAD(float)\n+/* { dg-final { scan-assembler \"vldmia.32\" } } */\n+POST_LOAD(double)\n+/* { dg-final { scan-assembler \"vldmia.64\" } } */\n+\n+POST_STORE_VEC (int8_t, int8x8_t, vst1_s8)\n+/* { dg-final { scan-assembler \"vst1.8\\t\\{.*\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+POST_STORE_VEC (int8_t, int8x16_t, vst1q_s8)\n+/* { dg-final { scan-assembler \"vst1.8\\t\\{.*\\[-,\\]d.*\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+\n+POST_STORE_VEC (int8_t, int8x8x2_t, vst2_s8)\n+/* { dg-final { scan-assembler \"vst2.8\\t\\{.*\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+POST_STORE_VEC (int8_t, int8x16x2_t, vst2q_s8)\n+/* { dg-final { scan-assembler \"vst2.8\\t\\{.*-d.*\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+\n+POST_STORE_VEC (int8_t, int8x8x3_t, vst3_s8)\n+/* { dg-final { scan-assembler \"vst3.8\\t\\{.*\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+POST_STORE_VEC (int8_t, int8x16x3_t, vst3q_s8)\n+/* { dg-final { scan-assembler \"vst3.8\\t\\{d\\[02468\\], d\\[02468\\], d\\[02468\\]\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+/* { dg-final { scan-assembler \"vst3.8\\t\\{d\\[13579\\], d\\[13579\\], d\\[13579\\]\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" { xfail *-*-* } } } */\n+\n+POST_STORE_VEC (int8_t, int8x8x4_t, vst4_s8)\n+/* { dg-final { scan-assembler \"vst4.8\\t\\{.*\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+POST_STORE_VEC (int8_t, int8x16x4_t, vst4q_s8)\n+/* { dg-final { scan-assembler \"vst4.8\\t\\{d\\[02468\\], d\\[02468\\], d\\[02468\\], d\\[02468\\]\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" } } */\n+/* { dg-final { scan-assembler \"vst4.8\\t\\{d\\[13579\\], d\\[13579\\], d\\[13579\\], d\\[13579\\]\\}, \\\\\\[r\\[0-9\\]+\\\\\\]!\" { xfail *-*-* } } } */\n+\n+/* { dg-final { scan-assembler-not \"add\" { xfail *-*-* } } } */"}, {"sha": "e3e1e6a58da6277ad48f318847f79e3036554aef", "filename": "gcc/testsuite/gcc.target/arm/addr-modes-int.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes-int.c?ref=c138eb5ce4f675fe9bdca939b6c43545d0f75691", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-options \"-O2 -march=armv7-a\" } */\n+/* { dg-add-options arm_neon } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-do compile } */\n+\n+#include \"addr-modes.h\"\n+\n+typedef long long ll;\n+\n+PRE_STORE(char)\n+/* { dg-final { scan-assembler \"strb.*#1]!\" } } */\n+PRE_STORE(short)\n+/* { dg-final { scan-assembler \"strh.*#2]!\" } } */\n+PRE_STORE(int)\n+/* { dg-final { scan-assembler \"str.*#4]!\" } } */\n+PRE_STORE(ll)\n+/* { dg-final { scan-assembler \"strd.*#8]!\" } } */\n+\n+POST_STORE(char)\n+/* { dg-final { scan-assembler \"strb.*], #1\" } } */\n+POST_STORE(short)\n+/* { dg-final { scan-assembler \"strh.*], #2\" } } */\n+POST_STORE(int)\n+/* { dg-final { scan-assembler \"str.*], #4\" } } */\n+POST_STORE(ll)\n+/* { dg-final { scan-assembler \"strd.*], #8\" } } */\n+\n+PRE_LOAD(char)\n+/* { dg-final { scan-assembler \"ldrb.*#1]!\" } } */\n+PRE_LOAD(short)\n+/* { dg-final { scan-assembler \"ldrsh.*#2]!\" } } */\n+PRE_LOAD(int)\n+/* { dg-final { scan-assembler \"ldr.*#4]!\" } } */\n+PRE_LOAD(ll)\n+/* { dg-final { scan-assembler \"ldrd.*#8]!\" } } */\n+\n+POST_LOAD(char)\n+/* { dg-final { scan-assembler \"ldrb.*], #1\" } } */\n+POST_LOAD(short)\n+/* { dg-final { scan-assembler \"ldrsh.*], #2\" } } */\n+POST_LOAD(int)\n+/* { dg-final { scan-assembler \"ldr.*], #4\" } } */\n+POST_LOAD(ll)\n+/* { dg-final { scan-assembler \"ldrd.*], #8\" } } */\n+\n+/* { dg-final { scan-assembler-not \"\\tadd\" } } */"}, {"sha": "eac46786c33b6dc6e96f8bee8eb119ac97ede45a", "filename": "gcc/testsuite/gcc.target/arm/addr-modes.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c138eb5ce4f675fe9bdca939b6c43545d0f75691/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faddr-modes.h?ref=c138eb5ce4f675fe9bdca939b6c43545d0f75691", "patch": "@@ -0,0 +1,53 @@\n+\n+#define PRE_STORE(T)\t\t\t\\\n+  T *\t\t\t\t\t\\\n+  T ## _pre_store (T *p, T v)\t\t\\\n+  {\t\t\t\t\t\\\n+    *++p = v;\t\t\t\t\\\n+    return p;\t\t\t\t\\\n+  }\t\t\t\t\t\\\n+\n+#define POST_STORE(T)\t\t\t\\\n+  T *\t\t\t\t\t\\\n+  T ## _post_store (T *p, T v)\t\t\\\n+  {\t\t\t\t\t\\\n+    *p++ = v;\t\t\t\t\\\n+    return p;\t\t\t\t\\\n+  }\n+\n+#define POST_STORE_VEC(T, VT, OP)\t\\\n+  T *\t\t\t\t\t\\\n+  VT ## _post_store (T * p, VT v)\t\\\n+  {\t\t\t\t\t\\\n+    OP (p, v);\t\t\t\t\\\n+    p += sizeof (VT) / sizeof (T);\t\\\n+    return p;\t\t\t\t\\\n+  }\n+\n+#define PRE_LOAD(T)\t\t\t\\\n+  void\t\t\t\t\t\\\n+  T ## _pre_load (T *p)\t\t\t\\\n+  {\t\t\t\t\t\\\n+    extern void f ## T (T*,T);\t\t\\\n+    T x = *++p;\t\t\t\t\\\n+    f ## T (p, x);\t\t\t\\\n+  }\n+\n+#define POST_LOAD(T)\t\t\t\\\n+  void\t\t\t\t\t\\\n+  T ## _post_load (T *p)\t\t\\\n+  {\t\t\t\t\t\\\n+    extern void f ## T (T*,T);\t\t\\\n+    T x = *p++;\t\t\t\t\\\n+    f ## T (p, x);\t\t\t\\\n+  }\n+\n+#define POST_LOAD_VEC(T, VT, OP)\t\\\n+  void\t\t\t\t\t\\\n+  VT ## _post_load (T * p)\t\t\\\n+  {\t\t\t\t\t\\\n+    extern void f ## T (T*,T);\t\t\\\n+    VT x = OP (p, v);\t\t\t\\\n+    p += sizeof (VT) / sizeof (T);\t\\\n+    f ## T (p, x);\t\t\t\\\n+  }"}]}