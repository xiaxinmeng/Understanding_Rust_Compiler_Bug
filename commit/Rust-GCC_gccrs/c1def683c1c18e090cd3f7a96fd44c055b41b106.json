{"sha": "c1def683c1c18e090cd3f7a96fd44c055b41b106", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFkZWY2ODNjMWMxOGUwOTBjZDNmN2E5NmZkNDRjMDU1YjQxYjEwNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-03T22:11:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-03T22:11:25Z"}, "message": "method.c (set_mangled_name_for_decl): Change return type to void.\n\n\t* method.c (set_mangled_name_for_decl): Change return type to void.\n\t* decl.c (lookup_name_real): A namespace-level decl takes priority\n\tover implicit typename.  Avoid doing the same lookup twice.\n\t* search.c (dependent_base_p): New fn.\n\t(dfs_pushdecls, dfs_compress_decls): Use it.\n\t* typeck.c (get_member_function_from_ptrfunc): Don't try to handle\n\tvirtual functions if the type doesn't have any.\n\nFrom-SVN: r21551", "tree": {"sha": "658df2fa05c67052b68384bdc451e68d4b207eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/658df2fa05c67052b68384bdc451e68d4b207eb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1def683c1c18e090cd3f7a96fd44c055b41b106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1def683c1c18e090cd3f7a96fd44c055b41b106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1def683c1c18e090cd3f7a96fd44c055b41b106", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1def683c1c18e090cd3f7a96fd44c055b41b106/comments", "author": null, "committer": null, "parents": [{"sha": "090f136ad2e8dda2a6ebb0523b26f420f5f9218a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/090f136ad2e8dda2a6ebb0523b26f420f5f9218a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/090f136ad2e8dda2a6ebb0523b26f420f5f9218a"}], "stats": {"total": 193, "additions": 133, "deletions": 60}, "files": [{"sha": "2d2e7dc6be6e8d5697ee06f9cf25d10218df07f8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1def683c1c18e090cd3f7a96fd44c055b41b106", "patch": "@@ -1,3 +1,16 @@\n+1998-08-03  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (set_mangled_name_for_decl): Change return type to void.\n+\n+\t* decl.c (lookup_name_real): A namespace-level decl takes priority\n+\tover implicit typename.  Avoid doing the same lookup twice.\n+\n+\t* search.c (dependent_base_p): New fn.\n+\t(dfs_pushdecls, dfs_compress_decls): Use it.\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Don't try to handle \n+\tvirtual functions if the type doesn't have any.\n+\n 1998-08-03  Mark Mitchell  <mark@markmitchell.com>\n \n \t* decl2.c (grokfield): Don't mangle the name of a TYPE_DECL if it"}, {"sha": "aa84e0fa1d20666546a65ac7f589a431101ec29b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c1def683c1c18e090cd3f7a96fd44c055b41b106", "patch": "@@ -2733,7 +2733,7 @@ extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n extern tree build_decl_overload_real            PROTO((tree, tree, tree, tree,\n \t\t\t\t\t\t       tree, int)); \n-extern tree set_mangled_name_for_decl           PROTO((tree));\n+extern void set_mangled_name_for_decl           PROTO((tree));\n extern tree build_typename_overload\t\tPROTO((tree));\n extern tree build_overload_with_type\t\tPROTO((tree, tree));\n extern tree build_destructor_name\t\tPROTO((tree));"}, {"sha": "68419056fb792b4259b3b6105691a0a209d5bf5f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c1def683c1c18e090cd3f7a96fd44c055b41b106", "patch": "@@ -5074,11 +5074,11 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       /* Add implicit 'typename' to types from template bases.  lookup_field\n          will do this for us.  If classval is actually from an enclosing\n          scope, lookup_nested_field will get it for us.  */\n-      if (processing_template_decl\n-\t  && classval && TREE_CODE (classval) == TYPE_DECL\n-\t  && ! currently_open_class (DECL_CONTEXT (classval))\n-\t  && uses_template_parms (current_class_type)\n-\t  && ! DECL_ARTIFICIAL (classval))\n+      else if (processing_template_decl\n+\t       && classval && TREE_CODE (classval) == TYPE_DECL\n+\t       && ! currently_open_class (DECL_CONTEXT (classval))\n+\t       && uses_template_parms (current_class_type)\n+\t       && ! DECL_ARTIFICIAL (classval))\n \tclassval = lookup_field (current_class_type, name, 0, 1);\n \n       /* yylex() calls this with -2, since we should never start digging for\n@@ -5121,6 +5121,28 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else\n     val = unqualified_namespace_lookup (name, flags);\n \n+  if (classval && TREE_CODE (val) == TYPE_DECL\n+      && TREE_CODE (TREE_TYPE (val)) == TYPENAME_TYPE\n+      && TREE_TYPE (TREE_TYPE (val)))\n+    {\n+      tree nsval = unqualified_namespace_lookup (name, flags);\n+\n+      if (val && nsval && TREE_CODE (nsval) == TYPE_DECL)\n+\t{\n+\t  static int explained;\n+\t  cp_warning (\"namespace-scope type `%#D'\", nsval);\n+\t  cp_warning\n+\t    (\"  is used instead of `%D' from dependent base class\", val);\n+\t  if (! explained)\n+\t    {\n+\t      explained = 1;\n+\t      cp_warning (\"  (use `typename %D' if that's what you meant)\",\n+\t\t\t  val);\n+\t    }\n+\t  val = nsval;\n+\t}\n+    }\n+\n  done:\n   if (val)\n     {"}, {"sha": "69ba1b02ea903e3a89db2308effec2b2cc21f3e8", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c1def683c1c18e090cd3f7a96fd44c055b41b106", "patch": "@@ -1663,7 +1663,7 @@ build_decl_overload (dname, parms, for_method)\n \n /* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */\n \n-tree\n+void\n set_mangled_name_for_decl (decl)\n      tree decl;\n {"}, {"sha": "79042e1a52e05a627a3769b147f980167598db51", "filename": "gcc/cp/search.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c1def683c1c18e090cd3f7a96fd44c055b41b106", "patch": "@@ -3480,6 +3480,23 @@ envelope_add_decl (type, decl, values)\n     }\n }\n \n+/* Returns 1 iff BINFO is a base we shouldn't really be able to see into,\n+   because it (or one of the intermediate bases) depends on template parms.  */\n+\n+static int\n+dependent_base_p (binfo)\n+     tree binfo;\n+{\n+  for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n+    {\n+      if (binfo == current_class_type)\n+\tbreak;\n+      if (uses_template_parms (TREE_TYPE (binfo)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n /* Add the instance variables which this class contributed to the\n    current class binding contour.  When a redefinition occurs, if the\n    redefinition is strictly within a single inheritance path, we just\n@@ -3506,9 +3523,18 @@ dfs_pushdecls (binfo)\n   tree type = BINFO_TYPE (binfo);\n   tree fields, *methods, *end;\n   tree method_vec;\n+  int dummy = 0;\n+\n+  /* Only record types if we're a template base.  */\n+  if (processing_template_decl && type != current_class_type\n+      && dependent_base_p (binfo))\n+    dummy = 1;\n \n   for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n     {\n+      if (dummy && TREE_CODE (fields) != TYPE_DECL)\n+\tcontinue;\n+\n       /* Unmark so that if we are in a constructor, and then find that\n \t this field was initialized by a base initializer,\n \t we can emit an error message.  */\n@@ -3546,7 +3572,7 @@ dfs_pushdecls (binfo)\n     }\n \n   method_vec = CLASSTYPE_METHOD_VEC (type);\n-  if (method_vec)\n+  if (method_vec && ! dummy)\n     {\n       /* Farm out constructors and destructors.  */\n       methods = &TREE_VEC_ELT (method_vec, 2);\n@@ -3598,7 +3624,10 @@ dfs_compress_decls (binfo)\n   tree type = BINFO_TYPE (binfo);\n   tree method_vec = CLASSTYPE_METHOD_VEC (type);\n \n-  if (method_vec != 0)\n+  if (processing_template_decl && type != current_class_type\n+      && dependent_base_p (binfo))\n+    /* We only record types if we're a template base.  */;\n+  else if (method_vec != 0)\n     {\n       /* Farm out constructors and destructors.  */\n       tree *methods = &TREE_VEC_ELT (method_vec, 2);"}, {"sha": "3e4fd0ab7b2d396a264040d3f2e697caa372ed8b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1def683c1c18e090cd3f7a96fd44c055b41b106/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c1def683c1c18e090cd3f7a96fd44c055b41b106", "patch": "@@ -2669,7 +2669,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n       tree fntype, idx, e1, delta, delta2, e2, e3, aref, vtbl;\n-      tree instance;\n+      tree instance, basetype;\n \n       tree instance_ptr = *instance_ptrptr;\n \n@@ -2680,74 +2680,83 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \tfunction = save_expr (function);\n \n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n+      basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n \n-      /* Promoting idx before saving it improves performance on RISC\n-\t targets.  Without promoting, the first compare used\n-\t load-with-sign-extend, while the second used normal load then\n-\t shift to sign-extend.  An optimizer flaw, perhaps, but it's easier\n-\t to make this change.  */\n-      idx = save_expr (default_conversion\n-\t\t       (build_component_ref (function,\n-\t\t\t\t\t     index_identifier,\n-\t\t\t\t\t     NULL_TREE, 0)));\n-      e1 = build_binary_op (GT_EXPR, idx, integer_zero_node, 1);\n       delta = cp_convert (ptrdiff_type_node,\n \t\t\t  build_component_ref (function, delta_identifier,\n \t\t\t\t\t       NULL_TREE, 0));\n-      delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n-\n-      /* Convert down to the right base, before using the instance.  */\n-      instance\n-\t= convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n-\t\t\t\t   instance_ptr);\n-      if (instance == error_mark_node && instance_ptr != error_mark_node)\n-\treturn instance;\n-\n-      vtbl = convert_pointer_to (ptr_type_node, instance);\n-      vtbl\n-\t= build (PLUS_EXPR,\n-\t\t build_pointer_type (build_pointer_type (vtable_entry_type)),\n-\t\t vtbl, cp_convert (ptrdiff_type_node, delta2));\n-      vtbl = build_indirect_ref (vtbl, NULL_PTR);\n-      aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t     idx,\n-\t\t\t\t\t\t     integer_one_node, 1));\n-      if (! flag_vtable_thunks)\n-\t{\n-\t  aref = save_expr (aref);\n-\n-\t  delta = build_binary_op\n+      e3 = PFN_FROM_PTRMEMFUNC (function);\n+\n+      if (TYPE_SIZE (basetype) != NULL_TREE\n+\t  && ! TYPE_VIRTUAL_P (basetype))\n+\t/* If basetype doesn't have virtual functions, don't emit code to\n+\t   handle that case.  */\n+\te1 = e3;\n+      else\n+\t{\n+\t  /* Promoting idx before saving it improves performance on RISC\n+\t     targets.  Without promoting, the first compare used\n+\t     load-with-sign-extend, while the second used normal load then\n+\t     shift to sign-extend.  An optimizer flaw, perhaps, but it's\n+\t     easier to make this change.  */\n+\t  idx = save_expr (default_conversion\n+\t\t\t   (build_component_ref (function,\n+\t\t\t\t\t\t index_identifier,\n+\t\t\t\t\t\t NULL_TREE, 0)));\n+\t  e1 = build_binary_op (GT_EXPR, idx, integer_zero_node, 1);\n+\n+\t  /* Convert down to the right base, before using the instance.  */\n+\t  instance = convert_pointer_to_real (basetype, instance_ptr);\n+\t  if (instance == error_mark_node && instance_ptr != error_mark_node)\n+\t    return instance;\n+\n+\t  vtbl = convert_pointer_to (ptr_type_node, instance);\n+\t  delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n+\t  vtbl = build\n \t    (PLUS_EXPR,\n-\t     build_conditional_expr (e1, build_component_ref (aref,\n+\t     build_pointer_type (build_pointer_type (vtable_entry_type)),\n+\t     vtbl, cp_convert (ptrdiff_type_node, delta2));\n+\t  vtbl = build_indirect_ref (vtbl, NULL_PTR);\n+\t  aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t\t idx,\n+\t\t\t\t\t\t\t integer_one_node, 1));\n+\t  if (! flag_vtable_thunks)\n+\t    {\n+\t      aref = save_expr (aref);\n+\n+\t      delta = build_binary_op\n+\t\t(PLUS_EXPR,\n+\t\t build_conditional_expr (e1,\n+\t\t\t\t\t build_component_ref (aref,\n \t\t\t\t\t\t\t      delta_identifier,\n \t\t\t\t\t\t\t      NULL_TREE, 0),\n-\t\t\t\t     integer_zero_node),\n-\t     delta, 1);\n+\t\t\t\t\t integer_zero_node),\n+\t\t delta, 1);\n+\t    }\n+\n+\t  if (flag_vtable_thunks)\n+\t    e2 = aref;\n+\t  else\n+\t    e2 = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n+\t  TREE_TYPE (e2) = TREE_TYPE (e3);\n+\t  e1 = build_conditional_expr (e1, e2, e3);\n+\n+\t  /* Make sure this doesn't get evaluated first inside one of the\n+\t     branches of the COND_EXPR.  */\n+\t  if (TREE_CODE (instance_ptr) == SAVE_EXPR)\n+\t    e1 = build (COMPOUND_EXPR, TREE_TYPE (e1),\n+\t\t\tinstance_ptr, e1);\n \t}\n \n       *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n \t\t\t\tinstance_ptr, delta);\n-      if (flag_vtable_thunks)\n-\te2 = aref;\n-      else\n-\te2 = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n-\n-      e3 = PFN_FROM_PTRMEMFUNC (function);\n-      TREE_TYPE (e2) = TREE_TYPE (e3);\n-      e1 = build_conditional_expr (e1, e2, e3);\n \n       if (instance_ptr == error_mark_node\n \t  && TREE_CODE (e1) != ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (e1, 0)) != FUNCTION_DECL)\n \tcp_error (\"object missing in `%E'\", function);\n \n       function = e1;\n-\n-      /* Make sure this doesn't get evaluated first inside one of the\n-         branches of the COND_EXPR.  */\n-      if (TREE_CODE (instance_ptr) == SAVE_EXPR)\n-\tfunction = build (COMPOUND_EXPR, TREE_TYPE (function),\n-\t\t\t  instance_ptr, function);\n     }\n   return function;\n }"}]}