{"sha": "eb9a42315387b85e16a9462101f8febe5d2b112f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI5YTQyMzE1Mzg3Yjg1ZTE2YTk0NjIxMDFmOGZlYmU1ZDJiMTEyZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2003-07-05T20:44:17Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-07-05T20:44:17Z"}, "message": "std_complex.h: Fully qualify standard functions with std::, thus avoiding Koenig lookup.\n\n2003-07-05  Paolo Carlini  <pcarlini@unitus.it>\n\n\t* include/std/std_complex.h: Fully qualify standard\n\tfunctions with std::, thus avoiding Koenig lookup.\n\t* include/std/std_memory.h: Likewise.\n\t* include/std/std_valarray.h: Likewise.\n\nFrom-SVN: r68982", "tree": {"sha": "2a58292f317955044ba513cefef345dc295739c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a58292f317955044ba513cefef345dc295739c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb9a42315387b85e16a9462101f8febe5d2b112f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb9a42315387b85e16a9462101f8febe5d2b112f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb9a42315387b85e16a9462101f8febe5d2b112f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb9a42315387b85e16a9462101f8febe5d2b112f/comments", "author": null, "committer": null, "parents": [{"sha": "2c4a71b3022df466a63528e2628d596cd40123f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4a71b3022df466a63528e2628d596cd40123f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4a71b3022df466a63528e2628d596cd40123f0"}], "stats": {"total": 137, "additions": 72, "deletions": 65}, "files": [{"sha": "c55d784010126614ef318260751cef238f1d1b04", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=eb9a42315387b85e16a9462101f8febe5d2b112f", "patch": "@@ -1,3 +1,10 @@\n+2003-07-05  Paolo Carlini  <pcarlini@unitus.it>\n+\n+\t* include/std/std_complex.h: Fully qualify standard\n+\tfunctions with std::, thus avoiding Koenig lookup.\n+\t* include/std/std_memory.h: Likewise.\n+\t* include/std/std_valarray.h: Likewise.\n+\n 2003-07-05  Gawain Bolton  <gp.bolton@computer.org>\n \n \t* include/bits/stl_tree.h: _Rb_tree_rebalance():  Add local"}, {"sha": "fe7dd22f008880207fe92c497fa127858494bafb", "filename": "libstdc++-v3/include/std/std_complex.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h?ref=eb9a42315387b85e16a9462101f8febe5d2b112f", "patch": "@@ -243,7 +243,7 @@ namespace std\n     complex<_Tp>::operator/=(const complex<_Up>& __z)\n     {\n       const _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n-      const _Tp __n = norm(__z);\n+      const _Tp __n = std::norm(__z);\n       _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;\n       _M_real = __r / __n;\n       return *this;\n@@ -411,18 +411,18 @@ namespace std\n     {\n       _Tp __x = __z.real();\n       _Tp __y = __z.imag();\n-      const _Tp __s = std::max(abs(__x), abs(__y));\n+      const _Tp __s = std::max(std::abs(__x), std::abs(__y));\n       if (__s == _Tp())  // well ...\n         return __s;\n       __x /= __s; \n       __y /= __s;\n-      return __s * sqrt(__x * __x + __y * __y);\n+      return __s * std::sqrt(__x * __x + __y * __y);\n     }\n \n   template<typename _Tp>\n     inline _Tp\n     arg(const complex<_Tp>& __z)\n-    { return atan2(__z.imag(), __z.real()); }\n+    { return std::atan2(__z.imag(), __z.real()); }\n \n   // 26.2.7/5: norm(__z) returns the squared magintude of __z.\n   //     As defined, norm() is -not- a norm is the common mathematical\n@@ -447,7 +447,7 @@ namespace std\n       template<typename _Tp>\n         static inline _Tp _S_do_it(const complex<_Tp>& __z)\n         {\n-          _Tp __res = abs(__z);\n+          _Tp __res = std::abs(__z);\n           return __res * __res;\n         }\n     };\n@@ -462,7 +462,7 @@ namespace std\n   template<typename _Tp>\n     inline complex<_Tp>\n     polar(const _Tp& __rho, const _Tp& __theta)\n-    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }\n+    { return complex<_Tp>(__rho * std::cos(__theta), __rho * std::sin(__theta)); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n@@ -476,7 +476,7 @@ namespace std\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n-      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n+      return complex<_Tp>(std::cos(__x) * std::cosh(__y), -std::sin(__x) * std::sinh(__y));\n     }\n \n   template<typename _Tp>\n@@ -485,31 +485,31 @@ namespace std\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n-      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n+      return complex<_Tp>(std::cosh(__x) * std::cos(__y), std::sinh(__x) * std::sin(__y));\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     exp(const complex<_Tp>& __z)\n-    { return polar(exp(__z.real()), __z.imag()); }\n+    { return std::polar(std::exp(__z.real()), __z.imag()); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     log(const complex<_Tp>& __z)\n-    { return complex<_Tp>(log(abs(__z)), arg(__z)); }\n+    { return complex<_Tp>(std::log(std::abs(__z)), std::arg(__z)); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     log10(const complex<_Tp>& __z)\n-    { return log(__z) / log(_Tp(10.0)); }\n+    { return std::log(__z) / std::log(_Tp(10.0)); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     sin(const complex<_Tp>& __z)\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n-      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y)); \n+      return complex<_Tp>(std::sin(__x) * std::cosh(__y), std::cos(__x) * std::sinh(__y)); \n     }\n \n   template<typename _Tp>\n@@ -518,7 +518,7 @@ namespace std\n     {\n       const _Tp __x = __z.real();\n       const _Tp  __y = __z.imag();\n-      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n+      return complex<_Tp>(std::sinh(__x) * std::cos(__y), std::cosh(__x) * std::sin(__y));\n     }\n \n   template<typename _Tp>\n@@ -530,56 +530,56 @@ namespace std\n \n       if (__x == _Tp())\n         {\n-          _Tp __t = sqrt(abs(__y) / 2);\n+          _Tp __t = std::sqrt(std::abs(__y) / 2);\n           return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);\n         }\n       else\n         {\n-          _Tp __t = sqrt(2 * (abs(__z) + abs(__x)));\n+          _Tp __t = std::sqrt(2 * (std::abs(__z) + std::abs(__x)));\n           _Tp __u = __t / 2;\n           return __x > _Tp()\n             ? complex<_Tp>(__u, __y / __t)\n-            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);\n+            : complex<_Tp>(std::abs(__y) / __t, __y < _Tp() ? -__u : __u);\n         }\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     tan(const complex<_Tp>& __z)\n     {\n-      return sin(__z) / cos(__z);\n+      return std::sin(__z) / std::cos(__z);\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     tanh(const complex<_Tp>& __z)\n     {\n-      return sinh(__z) / cosh(__z);\n+      return std::sinh(__z) / std::cosh(__z);\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     pow(const complex<_Tp>& __z, int __n)\n     {\n-      return __pow_helper(__z, __n);\n+      return std::__pow_helper(__z, __n);\n     }\n \n   template<typename _Tp>\n     complex<_Tp>\n     pow(const complex<_Tp>& __x, const _Tp& __y)\n     {\n       if (__x.imag() == _Tp())\n-        return pow(__x.real(), __y);\n+        return std::pow(__x.real(), __y);\n \n-      complex<_Tp> __t = log(__x);\n-      return polar(exp(__y * __t.real()), __y * __t.imag());\n+      complex<_Tp> __t = std::log(__x);\n+      return std::polar(std::exp(__y * __t.real()), __y * __t.imag());\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     {\n-      return __x == _Tp() ? _Tp() : exp(__y * log(__x));\n+      return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x));\n     }\n \n   template<typename _Tp>\n@@ -588,7 +588,7 @@ namespace std\n     {\n       return __x == _Tp()\n         ? _Tp()\n-        : polar(pow(__x, __y.real()), __y.imag() * log(__x));\n+        : std::polar(std::pow(__x, __y.real()), __y.imag() * std::log(__x));\n     }\n \n   // 26.2.3  complex specializations"}, {"sha": "68076897ec61c0c0f271dda308fbbfe1e7bf4d37", "filename": "libstdc++-v3/include/std/std_memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h?ref=eb9a42315387b85e16a9462101f8febe5d2b112f", "patch": "@@ -103,7 +103,7 @@ namespace std\n   template<typename _Tp>\n     inline pair<_Tp*,ptrdiff_t>\n     get_temporary_buffer(ptrdiff_t __len)\n-    { return __get_temporary_buffer(__len, (_Tp*) 0); }\n+    { return std::__get_temporary_buffer(__len, (_Tp*) 0); }\n \n   /**\n    *  @brief The companion to get_temporary_buffer()."}, {"sha": "4656dc3b7530a7d61c2edd939c47bd1db727ed4f", "filename": "libstdc++-v3/include/std/std_valarray.h", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb9a42315387b85e16a9462101f8febe5d2b112f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h?ref=eb9a42315387b85e16a9462101f8febe5d2b112f", "patch": "@@ -248,32 +248,32 @@ namespace std\n     inline \n     valarray<_Tp>::valarray(size_t __n) \n \t: _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-    { __valarray_default_construct(_M_data, _M_data + __n); }\n+    { std::__valarray_default_construct(_M_data, _M_data + __n); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const _Tp& __t, size_t __n)\n       : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-    { __valarray_fill_construct(_M_data, _M_data + __n, __t); }\n+    { std::__valarray_fill_construct(_M_data, _M_data + __n, __t); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const _Tp* __restrict__ __p, size_t __n)\n       : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-    { __valarray_copy_construct(__p, __p + __n, _M_data); }\n+    { std::__valarray_copy_construct(__p, __p + __n, _M_data); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const valarray<_Tp>& __v)\n       : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))\n-    { __valarray_copy_construct(__v._M_data, __v._M_data + _M_size, _M_data); }\n+    { std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size, _M_data); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const slice_array<_Tp>& __sa)\n       : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))\n     {\n-      __valarray_copy\n+      std::__valarray_copy\n \t(__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));\n     }\n \n@@ -283,7 +283,7 @@ namespace std\n       : _M_size(__ga._M_index.size()),\n \t_M_data(__valarray_get_storage<_Tp>(_M_size))\n     {\n-      __valarray_copy\n+      std::__valarray_copy\n \t(__ga._M_array, _Array<size_t>(__ga._M_index),\n \t _Array<_Tp>(_M_data), _M_size);\n     }\n@@ -293,7 +293,7 @@ namespace std\n     valarray<_Tp>::valarray(const mask_array<_Tp>& __ma)\n       : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))\n     {\n-      __valarray_copy\n+      std::__valarray_copy\n \t(__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);\n     }\n \n@@ -302,82 +302,82 @@ namespace std\n     valarray<_Tp>::valarray(const indirect_array<_Tp>& __ia)\n       : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))\n     {\n-      __valarray_copy\n+      std::__valarray_copy\n \t(__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);\n     }\n \n   template<typename _Tp> template<class _Dom>\n     inline\n     valarray<_Tp>::valarray(const _Expr<_Dom, _Tp>& __e)\n       : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(_M_size))\n-    { __valarray_copy(__e, _M_size, _Array<_Tp>(_M_data)); }\n+    { std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data)); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::~valarray()\n     {\n-      __valarray_destroy_elements(_M_data, _M_data + _M_size);\n-      __valarray_release_memory(_M_data);\n+      std::__valarray_destroy_elements(_M_data, _M_data + _M_size);\n+      std::__valarray_release_memory(_M_data);\n     }\n \n   template<typename _Tp>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const valarray<_Tp>& __v)\n     {\n-      __valarray_copy(__v._M_data, _M_size, _M_data);\n+      std::__valarray_copy(__v._M_data, _M_size, _M_data);\n       return *this;\n     }\n \n   template<typename _Tp>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const _Tp& __t)\n     {\n-      __valarray_fill(_M_data, _M_size, __t);\n+      std::__valarray_fill(_M_data, _M_size, __t);\n       return *this;\n     }\n \n   template<typename _Tp>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const slice_array<_Tp>& __sa)\n     {\n-      __valarray_copy(__sa._M_array, __sa._M_sz,\n-\t\t      __sa._M_stride, _Array<_Tp>(_M_data));\n+      std::__valarray_copy(__sa._M_array, __sa._M_sz,\n+\t\t\t   __sa._M_stride, _Array<_Tp>(_M_data));\n       return *this;\n     }\n \n   template<typename _Tp>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const gslice_array<_Tp>& __ga)\n     {\n-      __valarray_copy(__ga._M_array, _Array<size_t>(__ga._M_index),\n-\t\t      _Array<_Tp>(_M_data), _M_size);\n+      std::__valarray_copy(__ga._M_array, _Array<size_t>(__ga._M_index),\n+\t\t\t   _Array<_Tp>(_M_data), _M_size);\n       return *this;\n     }\n \n   template<typename _Tp>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const mask_array<_Tp>& __ma)\n     {\n-      __valarray_copy(__ma._M_array, __ma._M_mask,\n-\t\t      _Array<_Tp>(_M_data), _M_size);\n+      std::__valarray_copy(__ma._M_array, __ma._M_mask,\n+\t\t\t   _Array<_Tp>(_M_data), _M_size);\n       return *this;\n     }\n \n   template<typename _Tp>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const indirect_array<_Tp>& __ia)\n     {\n-      __valarray_copy(__ia._M_array, __ia._M_index,\n-\t\t       _Array<_Tp>(_M_data), _M_size);\n+      std::__valarray_copy(__ia._M_array, __ia._M_index,\n+\t\t\t   _Array<_Tp>(_M_data), _M_size);\n       return *this;\n     }\n \n   template<typename _Tp> template<class _Dom>\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e)\n     {\n-      __valarray_copy(__e, _M_size, _Array<_Tp>(_M_data));\n-\treturn *this;\n+      std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data));\n+      return *this;\n     }\n \n   template<typename _Tp>\n@@ -460,7 +460,7 @@ namespace std\n     inline _Tp\n     valarray<_Tp>::sum() const\n     {\n-      return __valarray_sum(_M_data, _M_data + _M_size);\n+      return std::__valarray_sum(_M_data, _M_data + _M_size);\n     }\n \n //   template<typename _Tp>\n@@ -477,21 +477,21 @@ namespace std\n        _Tp* const __a = static_cast<_Tp*>\n          (__builtin_alloca(sizeof(_Tp) * _M_size));\n        if (__n == 0)                          // no shift\n-         __valarray_copy_construct(_M_data, _M_data + _M_size, __a);\n+         std::__valarray_copy_construct(_M_data, _M_data + _M_size, __a);\n        else if (__n > 0)         // __n > 0: shift left\n          {                 \n            if (size_t(__n) > _M_size)\n-             __valarray_default_construct(__a, __a + __n);\n+             std::__valarray_default_construct(__a, __a + __n);\n            else\n              {\n-               __valarray_copy_construct(_M_data+__n, _M_data + _M_size, __a);\n-               __valarray_default_construct(__a+_M_size-__n, __a + _M_size);\n+               std::__valarray_copy_construct(_M_data+__n, _M_data + _M_size, __a);\n+               std::__valarray_default_construct(__a+_M_size-__n, __a + _M_size);\n              }\n          }\n        else                        // __n < 0: shift right\n          {                          \n-           __valarray_copy_construct (_M_data, _M_data+_M_size+__n, __a-__n);\n-           __valarray_default_construct(__a, __a - __n);\n+           std::__valarray_copy_construct (_M_data, _M_data+_M_size+__n, __a-__n);\n+           std::__valarray_default_construct(__a, __a - __n);\n          }\n        return valarray<_Tp> (__a, _M_size);\n      }\n@@ -503,17 +503,17 @@ namespace std\n        _Tp* const __a = static_cast<_Tp*>\n          (__builtin_alloca (sizeof(_Tp) * _M_size));\n        if (__n == 0)               // no cshift\n-         __valarray_copy_construct(_M_data, _M_data + _M_size, __a);\n+         std::__valarray_copy_construct(_M_data, _M_data + _M_size, __a);\n        else if (__n > 0)           // cshift left\n          {               \n-           __valarray_copy_construct(_M_data, _M_data+__n, __a+_M_size-__n);\n-           __valarray_copy_construct(_M_data+__n, _M_data + _M_size, __a);\n+           std::__valarray_copy_construct(_M_data, _M_data+__n, __a+_M_size-__n);\n+           std::__valarray_copy_construct(_M_data+__n, _M_data + _M_size, __a);\n          }\n        else                        // cshift right\n          {                       \n-           __valarray_copy_construct\n+           std::__valarray_copy_construct\n              (_M_data + _M_size+__n, _M_data + _M_size, __a);\n-           __valarray_copy_construct\n+           std::__valarray_copy_construct\n              (_M_data, _M_data + _M_size+__n, __a - __n);\n          }\n        return valarray<_Tp>(__a, _M_size);\n@@ -526,28 +526,28 @@ namespace std\n       // This complication is so to make valarray<valarray<T> > work\n       // even though it is not required by the standard.  Nobody should\n       // be saying valarray<valarray<T> > anyway.  See the specs.\n-      __valarray_destroy_elements(_M_data, _M_data + _M_size);\n+      std::__valarray_destroy_elements(_M_data, _M_data + _M_size);\n       if (_M_size != __n)\n \t{\n-\t  __valarray_release_memory(_M_data);\n+\t  std::__valarray_release_memory(_M_data);\n \t  _M_size = __n;\n \t  _M_data = __valarray_get_storage<_Tp>(__n);\n \t}\n-      __valarray_fill_construct(_M_data, _M_data + __n, __c);\n+      std::__valarray_fill_construct(_M_data, _M_data + __n, __c);\n     }\n     \n   template<typename _Tp>\n     inline _Tp\n     valarray<_Tp>::min() const\n     {\n-      return *min_element (_M_data, _M_data+_M_size);\n+      return *std::min_element (_M_data, _M_data+_M_size);\n     }\n \n   template<typename _Tp>\n     inline _Tp\n     valarray<_Tp>::max() const\n     {\n-      return *max_element (_M_data, _M_data+_M_size);\n+      return *std::max_element (_M_data, _M_data+_M_size);\n     }\n   \n   template<class _Tp>"}]}