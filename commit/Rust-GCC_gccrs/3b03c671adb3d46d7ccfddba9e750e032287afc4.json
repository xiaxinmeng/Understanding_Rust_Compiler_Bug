{"sha": "3b03c671adb3d46d7ccfddba9e750e032287afc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IwM2M2NzFhZGIzZDQ2ZDdjY2ZkZGJhOWU3NTBlMDMyMjg3YWZjNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-03T12:07:30Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-03T12:07:30Z"}, "message": "regrename.c: Fix formatting.\n\n\t* regrename.c: Fix formatting.\n\t* tree.c: Likewise.\n\nFrom-SVN: r53088", "tree": {"sha": "e13170f35df08dc4b99183e1868ce3bd1b4ce700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e13170f35df08dc4b99183e1868ce3bd1b4ce700"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b03c671adb3d46d7ccfddba9e750e032287afc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b03c671adb3d46d7ccfddba9e750e032287afc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b03c671adb3d46d7ccfddba9e750e032287afc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b03c671adb3d46d7ccfddba9e750e032287afc4/comments", "author": null, "committer": null, "parents": [{"sha": "3b4961bd97dc75a6d80a6f26503a8b759f9eb557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4961bd97dc75a6d80a6f26503a8b759f9eb557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b4961bd97dc75a6d80a6f26503a8b759f9eb557"}], "stats": {"total": 127, "additions": 66, "deletions": 61}, "files": [{"sha": "827bd7a017f303843802599037f51fe37fd09957", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b03c671adb3d46d7ccfddba9e750e032287afc4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b03c671adb3d46d7ccfddba9e750e032287afc4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b03c671adb3d46d7ccfddba9e750e032287afc4", "patch": "@@ -1,3 +1,8 @@\n+2002-05-03  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* regrename.c: Fix formatting.\n+\t* tree.c: Likewise.\n+\n Fri May  3 13:34:43 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (attribute memory): Handle compares properly."}, {"sha": "4297da7f32756cf8f4ee5f394dc0926c8d263f80", "filename": "gcc/regrename.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b03c671adb3d46d7ccfddba9e750e032287afc4/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b03c671adb3d46d7ccfddba9e750e032287afc4/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=3b03c671adb3d46d7ccfddba9e750e032287afc4", "patch": "@@ -177,7 +177,7 @@ merge_overlapping_regs (b, pset, chain)\n \t\t reg's live range.  */\n \t      if (t != chain)\n \t\tIOR_HARD_REG_SET (*pset, live);\n-\t      clear_dead_regs (&live, REG_UNUSED, REG_NOTES (insn));  \n+\t      clear_dead_regs (&live, REG_UNUSED, REG_NOTES (insn));\n \t    }\n \t  insn = NEXT_INSN (insn);\n \t}\n@@ -231,10 +231,10 @@ regrename_optimize ()\n       if (frame_pointer_needed)\n \t{\n \t  int i;\n-\t  \n+\n \t  for (i = HARD_REGNO_NREGS (FRAME_POINTER_REGNUM, Pmode); i--;)\n \t    SET_HARD_REG_BIT (unavailable, FRAME_POINTER_REGNUM + i);\n-\t  \n+\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n \t  for (i = HARD_REGNO_NREGS (HARD_FRAME_POINTER_REGNUM, Pmode); i--;)\n \t    SET_HARD_REG_BIT (unavailable, HARD_FRAME_POINTER_REGNUM + i);\n@@ -253,7 +253,7 @@ regrename_optimize ()\n \t  int i;\n \n \t  all_chains = this->next_chain;\n-\t  \n+\n #if 0 /* This just disables optimization opportunities.  */\n \t  /* Only rename once we've seen the reg more than once.  */\n \t  if (! TEST_HARD_REG_BIT (regs_seen, reg))\n@@ -309,9 +309,9 @@ regrename_optimize ()\n \t\t    || (! regs_ever_live[new_reg + i]\n \t\t\t&& ! call_used_regs[new_reg + i])\n #ifdef LEAF_REGISTERS\n-\t\t    /* We can't use a non-leaf register if we're in a \n+\t\t    /* We can't use a non-leaf register if we're in a\n \t\t       leaf function.  */\n-\t\t    || (current_function_is_leaf \n+\t\t    || (current_function_is_leaf\n \t\t\t&& !LEAF_REGISTERS[new_reg + i])\n #endif\n #ifdef HARD_REGNO_RENAME_OK\n@@ -346,7 +346,7 @@ regrename_optimize ()\n \t\t       reg_names[reg], INSN_UID (last->insn));\n \t      if (last->need_caller_save_reg)\n \t\tfprintf (rtl_dump_file, \" crosses a call\");\n-\t      }\n+\t    }\n \n \t  if (best_new_reg == -1)\n \t    {\n@@ -445,7 +445,7 @@ scan_rtx_reg (insn, loc, class, action, type, earlyclobber)\n       if (*this->loc == cc0_rtx)\n \tp = &this->next_chain;\n       else\n-        {\n+\t{\n \t  int regno = REGNO (*this->loc);\n \t  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (*this->loc));\n \t  int exact_match = (regno == this_regno && nregs == this_nregs);\n@@ -462,7 +462,7 @@ scan_rtx_reg (insn, loc, class, action, type, earlyclobber)\n \t      if (! exact_match)\n \t\tabort ();\n \n-\t      /* ??? Class NO_REGS can happen if the md file makes use of \n+\t      /* ??? Class NO_REGS can happen if the md file makes use of\n \t\t EXTRA_CONSTRAINTS to match registers.  Which is arguably\n \t\t wrong, but there we are.  Since we know not what this may\n \t\t be replaced with, terminate the chain.  */\n@@ -705,7 +705,7 @@ scan_rtx (insn, loc, class, action, type, earlyclobber)\n       return;\n \n     case ZERO_EXTRACT:\n-    case SIGN_EXTRACT: \n+    case SIGN_EXTRACT:\n       scan_rtx (insn, &XEXP (x, 0), class, action,\n \t\ttype == OP_IN ? OP_IN : OP_INOUT, earlyclobber);\n       scan_rtx (insn, &XEXP (x, 1), class, action, OP_IN, 0);\n@@ -787,7 +787,7 @@ build_def_use (bb)\n \t  icode = recog_memoized (insn);\n \t  extract_insn (insn);\n \t  if (! constrain_operands (1))\n-\t    fatal_insn_not_found (insn);\t\n+\t    fatal_insn_not_found (insn);\n \t  preprocess_constraints ();\n \t  alt = which_alternative;\n \t  n_ops = recog_data.n_operands;\n@@ -814,14 +814,14 @@ build_def_use (bb)\n \t\t      recog_data.operand_type[i], 0);\n \n \t  /* Step 2: Close chains for which we have reads outside operands.\n-\t     We do this by munging all operands into CC0, and closing \n+\t     We do this by munging all operands into CC0, and closing\n \t     everything remaining.  */\n \n \t  for (i = 0; i < n_ops; i++)\n \t    {\n \t      old_operands[i] = recog_data.operand[i];\n \t      /* Don't squash match_operator or match_parallel here, since\n-\t\t we don't know that all of the contained registers are \n+\t\t we don't know that all of the contained registers are\n \t\t reachable by proper operands.  */\n \t      if (recog_data.constraints[i][0] == '\\0')\n \t\tcontinue;\n@@ -953,7 +953,7 @@ build_def_use (bb)\n \t\t    enum reg_class class = recog_op_alt[i][alt].class;\n \n \t\t    if (GET_CODE (op) == REG\n-\t\t        && REGNO (op) == ORIGINAL_REGNO (op))\n+\t\t\t&& REGNO (op) == ORIGINAL_REGNO (op))\n \t\t      continue;\n \n \t\t    scan_rtx (insn, loc, class, mark_write, OP_OUT,\n@@ -1017,11 +1017,11 @@ dump_def_use_chain (chains)\n /* The following code does forward propagation of hard register copies.\n    The object is to eliminate as many dependencies as possible, so that\n    we have the most scheduling freedom.  As a side effect, we also clean\n-   up some silly register allocation decisions made by reload.  This \n+   up some silly register allocation decisions made by reload.  This\n    code may be obsoleted by a new register allocator.  */\n \n /* For each register, we have a list of registers that contain the same\n-   value.  The OLDEST_REGNO field points to the head of the list, and \n+   value.  The OLDEST_REGNO field points to the head of the list, and\n    the NEXT_REGNO field runs through the list.  The MODE field indicates\n    what mode the data is known to be in; this field is VOIDmode when the\n    register is not known to contain valid data.  */\n@@ -1059,7 +1059,7 @@ static bool replace_oldest_value_addr PARAMS ((rtx *, enum reg_class,\n \t\t\t\t\t       struct value_data *));\n static bool replace_oldest_value_mem PARAMS ((rtx, rtx, struct value_data *));\n static bool copyprop_hardreg_forward_1 PARAMS ((basic_block,\n-\t\t\t\t\t\t struct value_data *));\n+\t\t\t\t\t\tstruct value_data *));\n extern void debug_value_data PARAMS ((struct value_data *));\n #ifdef ENABLE_CHECKING\n static void validate_value_data PARAMS ((struct value_data *));\n@@ -1086,7 +1086,7 @@ kill_value_regno (regno, vd)\n   else if ((next = vd->e[regno].next_regno) != INVALID_REGNUM)\n     {\n       for (i = next; i != INVALID_REGNUM; i = vd->e[i].next_regno)\n-        vd->e[i].oldest_regno = next;\n+\tvd->e[i].oldest_regno = next;\n     }\n \n   vd->e[regno].mode = VOIDmode;\n@@ -1187,7 +1187,7 @@ kill_clobbered_value (x, set, data)\n     kill_value (x, vd);\n }\n \n-/* Called through note_stores.  If X is set, not clobbered, kill its \n+/* Called through note_stores.  If X is set, not clobbered, kill its\n    current value and install it as the root of its own value list.  */\n \n static void\n@@ -1201,7 +1201,7 @@ kill_set_value (x, set, data)\n     {\n       kill_value (x, vd);\n       if (REG_P (x))\n-        set_value_regno (REGNO (x), GET_MODE (x), vd);\n+\tset_value_regno (REGNO (x), GET_MODE (x), vd);\n     }\n }\n \n@@ -1467,7 +1467,7 @@ replace_oldest_value_addr (loc, class, mode, insn, vd)\n \n \tif (locI)\n \t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n-\t\t\t\t\t        insn, vd);\n+\t\t\t\t\t\tinsn, vd);\n \tif (locB)\n \t  changed |= replace_oldest_value_addr (locB,\n \t\t\t\t\t\tMODE_BASE_REG_CLASS (mode),\n@@ -1502,7 +1502,7 @@ replace_oldest_value_addr (loc, class, mode, insn, vd)\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), class,\n-\t\t\t\t\t        mode, insn, vd);\n+\t\t\t\t\t\tmode, insn, vd);\n     }\n \n   return changed;\n@@ -1548,7 +1548,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n       set = single_set (insn);\n       extract_insn (insn);\n       if (! constrain_operands (1))\n-\tfatal_insn_not_found (insn);\t\n+\tfatal_insn_not_found (insn);\n       preprocess_constraints ();\n       alt = which_alternative;\n       n_ops = recog_data.n_operands;\n@@ -1618,7 +1618,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t\t    fprintf (rtl_dump_file,\n \t\t\t     \"insn %u: replaced reg %u with %u\\n\",\n \t\t\t     INSN_UID (insn), regno, REGNO (new));\n-\t          changed = true;\n+\t\t  changed = true;\n \t\t  goto did_replacement;\n \t\t}\n \t    }\n@@ -1680,7 +1680,7 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t    }\n \t  else if (GET_CODE (recog_data.operand[i]) == MEM)\n \t    replaced = replace_oldest_value_mem (recog_data.operand[i],\n-\t\t\t\t\t         insn, vd);\n+\t\t\t\t\t\t insn, vd);\n \n \t  /* If we performed any replacement, update match_dups.  */\n \t  if (replaced)\n@@ -1741,13 +1741,13 @@ copyprop_hardreg_forward ()\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queueing of blocks.  */\n       if (bb->pred\n-\t  && ! bb->pred->pred_next \n+\t  && ! bb->pred->pred_next\n \t  && ! (bb->pred->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n \t  && bb->pred->src->index != ENTRY_BLOCK\n \t  && bb->pred->src->index < b)\n \tall_vd[b] = all_vd[bb->pred->src->index];\n       else\n-        init_value_data (all_vd + b);\n+\tinit_value_data (all_vd + b);\n \n       if (copyprop_hardreg_forward_1 (bb, all_vd + b))\n \tneed_refresh = true;"}, {"sha": "945f3a15eca873884ff82a2aaaa5afab71c083b7", "filename": "gcc/tree.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b03c671adb3d46d7ccfddba9e750e032287afc4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b03c671adb3d46d7ccfddba9e750e032287afc4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3b03c671adb3d46d7ccfddba9e750e032287afc4", "patch": "@@ -124,8 +124,8 @@ htab_t type_hash_table;\n \n static void set_type_quals PARAMS ((tree, int));\n static void append_random_chars PARAMS ((char *));\n-static int type_hash_eq PARAMS ((const void*, const void*));\n-static unsigned int type_hash_hash PARAMS ((const void*));\n+static int type_hash_eq PARAMS ((const void *, const void *));\n+static unsigned int type_hash_hash PARAMS ((const void *));\n static void print_type_hash_statistics PARAMS((void));\n static void finish_vector_type PARAMS((tree));\n static tree make_vector PARAMS ((enum machine_mode, tree, int));\n@@ -233,12 +233,12 @@ tree_size (node)\n \n     case 'x':  /* something random, like an identifier.  */\n       {\n-\t  size_t length;\n-\t  length = (sizeof (struct tree_common)\n-\t\t    + TREE_CODE_LENGTH (code) * sizeof (char *));\n-\t  if (code == TREE_VEC)\n-\t    length += (TREE_VEC_LENGTH (node) - 1) * sizeof (char *);\n-\t  return length;\n+\tsize_t length;\n+\tlength = (sizeof (struct tree_common)\n+\t\t  + TREE_CODE_LENGTH (code) * sizeof (char *));\n+\tif (code == TREE_VEC)\n+\t  length += (TREE_VEC_LENGTH (node) - 1) * sizeof (char *);\n+\treturn length;\n       }\n \n     default:\n@@ -263,12 +263,12 @@ make_node (code)\n   tree_node_kind kind;\n #endif\n   struct tree_common ttmp;\n-  \n+\n   /* We can't allocate a TREE_VEC without knowing how many elements\n      it will have.  */\n   if (code == TREE_VEC)\n     abort ();\n-  \n+\n   TREE_SET_CODE ((tree)&ttmp, code);\n   length = tree_size ((tree)&ttmp);\n \n@@ -494,7 +494,7 @@ build_vector (type, vals)\n       over1 |= TREE_OVERFLOW (value);\n       over2 |= TREE_CONSTANT_OVERFLOW (value);\n     }\n-  \n+\n   TREE_OVERFLOW (v) = over1;\n   TREE_CONSTANT_OVERFLOW (v) = over2;\n \n@@ -618,11 +618,11 @@ make_tree_vec (len)\n      int len;\n {\n   tree t;\n-  int length = (len-1) * sizeof (tree) + sizeof (struct tree_vec);\n+  int length = (len - 1) * sizeof (tree) + sizeof (struct tree_vec);\n \n #ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)vec_kind]++;\n-  tree_node_sizes[(int)vec_kind] += length;\n+  tree_node_counts[(int) vec_kind]++;\n+  tree_node_sizes[(int) vec_kind] += length;\n #endif\n \n   t = ggc_alloc_tree (length);\n@@ -1063,8 +1063,8 @@ chainon (op1, op2)\n       TREE_CHAIN (t1) = op2;\n #ifdef ENABLE_TREE_CHECKING\n       for (t2 = op2; t2; t2 = TREE_CHAIN (t2))\n-        if (t2 == t1)\n-          abort ();  /* Circularity created.  */\n+\tif (t2 == t1)\n+\t  abort ();  /* Circularity created.  */\n #endif\n       return op1;\n     }\n@@ -2313,7 +2313,7 @@ build1 (code, type, node)\n #endif\n \n #ifdef ENABLE_CHECKING\n-  if (TREE_CODE_CLASS (code) == '2' \n+  if (TREE_CODE_CLASS (code) == '2'\n       || TREE_CODE_CLASS (code) == '<'\n       || TREE_CODE_LENGTH (code) != 1)\n     abort ();\n@@ -2498,7 +2498,7 @@ tree\n build_type_attribute_variant (ttype, attribute)\n      tree ttype, attribute;\n {\n-  if ( ! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n+  if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n       unsigned int hashcode;\n       tree ntype;\n@@ -3055,7 +3055,7 @@ mark_tree_hashtable_entry (entry, data)\n   return 1;\n }\n \n-/* Mark ARG (which is really a htab_t whose slots are trees) for \n+/* Mark ARG (which is really a htab_t whose slots are trees) for\n    GC.  */\n \n void\n@@ -3099,8 +3099,8 @@ int\n attribute_list_equal (l1, l2)\n      tree l1, l2;\n {\n-   return attribute_list_contained (l1, l2)\n-\t  && attribute_list_contained (l2, l1);\n+  return attribute_list_contained (l1, l2)\n+\t && attribute_list_contained (l2, l1);\n }\n \n /* Given two lists of attributes, return true if list L2 is\n@@ -3260,7 +3260,7 @@ tree_int_cst_compare (t1, t2)\n     return -1;\n   else if (tree_int_cst_lt (t2, t1))\n     return 1;\n-  else \n+  else\n     return 0;\n }\n \n@@ -4407,7 +4407,7 @@ clean_symbol_name (p)\n \t   ))\n       *p = '_';\n }\n-  \n+\n /* Generate a name for a function unique to this translation unit.\n    TYPE is some string to identify the purpose of this function to the\n    linker or collect2.  */\n@@ -4832,17 +4832,17 @@ initializer_zerop (init)\n     case CONSTRUCTOR:\n       {\n \tif (AGGREGATE_TYPE_P (TREE_TYPE (init)))\n-\t{\n-\t  tree aggr_init = TREE_OPERAND (init, 1);\n-\t  \n-\t  while (aggr_init)\n-\t    {\n-\t      if (! initializer_zerop (TREE_VALUE (aggr_init)))\n-\t\treturn false;\n-\t      aggr_init = TREE_CHAIN (aggr_init);\n-\t    }\n-\t  return true;\n-\t}\n+\t  {\n+\t    tree aggr_init = TREE_OPERAND (init, 1);\n+\n+\t    while (aggr_init)\n+\t      {\n+\t\tif (! initializer_zerop (TREE_VALUE (aggr_init)))\n+\t\t  return false;\n+\t\taggr_init = TREE_CHAIN (aggr_init);\n+\t      }\n+\t    return true;\n+\t  }\n \treturn false;\n       }\n     default:"}]}