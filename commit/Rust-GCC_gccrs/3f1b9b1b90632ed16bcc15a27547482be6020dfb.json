{"sha": "3f1b9b1b90632ed16bcc15a27547482be6020dfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxYjliMWI5MDYzMmVkMTZiY2MxNWEyNzU0NzQ4MmJlNjAyMGRmYg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-04-10T02:55:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-10T02:55:36Z"}, "message": "rtl.h (local_alloc): Returns an integer now.\n\n        * rtl.h (local_alloc): Returns an integer now.\n        * local-alloc.c (recorded_label_ref): New file scoped variable.\n        (local_alloc): Initialize recorded_label_ref to zero.  Return its\n        value when local allocation has completed.\n        (update_equiv_regs); If we create an equivalence for a LABEL_REF,\n        set recorded_label_ref.\n        * toplev.c (rest_of_compilation): Run the loop optimizer after\n        register allocation and reloading if needed.\n\nFrom-SVN: r26324", "tree": {"sha": "224a58188d16a5c87219ebe17fc74ad7dc836b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/224a58188d16a5c87219ebe17fc74ad7dc836b76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f1b9b1b90632ed16bcc15a27547482be6020dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1b9b1b90632ed16bcc15a27547482be6020dfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1b9b1b90632ed16bcc15a27547482be6020dfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1b9b1b90632ed16bcc15a27547482be6020dfb/comments", "author": null, "committer": null, "parents": [{"sha": "d1c13bdab5e3a7bcb037ae9e3c73e0d6ff0a180f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c13bdab5e3a7bcb037ae9e3c73e0d6ff0a180f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1c13bdab5e3a7bcb037ae9e3c73e0d6ff0a180f"}], "stats": {"total": 56, "additions": 52, "deletions": 4}, "files": [{"sha": "8637a8cf6dd28fd35fee34b0386ea20eb39234fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f1b9b1b90632ed16bcc15a27547482be6020dfb", "patch": "@@ -1,3 +1,14 @@\n+Sat Apr 10 03:50:12 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* rtl.h (local_alloc): Returns an integer now.\n+\t* local-alloc.c (recorded_label_ref): New file scoped variable.\n+\t(local_alloc): Initialize recorded_label_ref to zero.  Return its\n+\tvalue when local allocation has completed.\n+\t(update_equiv_regs); If we create an equivalence for a LABEL_REF,\n+\tset recorded_label_ref.\n+\t* toplev.c (rest_of_compilation): Run the loop optimizer after\n+\tregister allocation and reloading if needed.\n+\n Fri Apr  9 21:02:57 1999  Krister Walfridsson (cato@df.lth.se)\n \n         * i386/gas.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Fix typo."}, {"sha": "d1df595c4c1110d5acf444ca1448dc38a159a951", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=3f1b9b1b90632ed16bcc15a27547482be6020dfb", "patch": "@@ -237,6 +237,9 @@ static rtx *reg_equiv_replacement;\n /* Used for communication between update_equiv_regs and no_equiv.  */\n static rtx *reg_equiv_init_insns;\n \n+/* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n+static int recorded_label_ref;\n+\n static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n static void validate_equiv_mem_from_store PROTO((rtx, rtx));\n static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n@@ -292,12 +295,16 @@ alloc_qty (regno, mode, size, birth)\n \f\n /* Main entry point of this file.  */\n \n-void\n+int\n local_alloc ()\n {\n   register int b, i;\n   int max_qty;\n \n+  /* We need to keep track of whether or not we recorded a LABEL_REF so\n+     that we know if the jump optimizer needs to be rerun.  */\n+  recorded_label_ref = 0;\n+\n   /* Leaf functions and non-leaf functions have different needs.\n      If defined, let the machine say what kind of ordering we\n      should use.  */\n@@ -410,6 +417,7 @@ local_alloc ()\n   free (reg_qty);\n   free (reg_offset);\n   free (reg_next_in_qty);\n+  return recorded_label_ref;\n }\n \f\n /* Depth of loops we are in while in update_equiv_regs.  */\n@@ -842,6 +850,19 @@ update_equiv_regs ()\n \t{\n \t  int regno = REGNO (dest);\n \n+\t  /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n+\t     We might end up substituting the LABEL_REF for uses of the\n+\t     pseudo here or later.  That kind of transformation may turn an\n+\t     indirect jump into a direct jump, in which case we must rerun the\n+\t     jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n+\t  if (GET_CODE (XEXP (note, 0)) == LABEL_REF\n+\t      || (GET_CODE (XEXP (note, 0)) == CONST\n+\t\t  && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS\n+\t\t  && (GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0))\n+\t\t      == LABEL_REF)))\n+\t    recorded_label_ref = 1;\n+\t  \n+\t \n \t  reg_equiv_replacement[regno] = XEXP (note, 0);\n \n \t  /* Don't mess with things live during setjmp.  */"}, {"sha": "eee7473cd336a13594be04edcac23f1b68e5e2e8", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3f1b9b1b90632ed16bcc15a27547482be6020dfb", "patch": "@@ -1539,7 +1539,7 @@ extern void init_optabs\t\t\tPROTO ((void));\n #ifdef BUFSIZ\n extern void dump_local_alloc\t\tPROTO ((FILE *));\n #endif\n-extern void local_alloc\t\t\tPROTO ((void));\n+extern int local_alloc\t\t\tPROTO ((void));\n extern int function_invariant_p\t\tPROTO ((rtx));\n \n /* In reload1.c */"}, {"sha": "3847c5dcd7b6b9c4484867e1ff76613d28c9dcbb", "filename": "gcc/toplev.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1b9b1b90632ed16bcc15a27547482be6020dfb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3f1b9b1b90632ed16bcc15a27547482be6020dfb", "patch": "@@ -3526,6 +3526,7 @@ rest_of_compilation (decl)\n   /* Likewise, for DECL_ARGUMENTS.  */\n   tree saved_arguments = 0;\n   int failure = 0;\n+  int run_jump_after_reload;\n \n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n@@ -4063,15 +4064,20 @@ rest_of_compilation (decl)\n     }\n \n   /* Unless we did stupid register allocation,\n-     allocate pseudo-regs that are used only within 1 basic block.  */\n+     allocate pseudo-regs that are used only within 1 basic block. \n+\n+     RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the\n+     jump optimizer after register allocation and reloading are finished.  */\n \n   if (!obey_regdecls)\n     TIMEVAR (local_alloc_time,\n \t     {\n \t       recompute_reg_usage (insns, ! optimize_size);\n \t       regclass (insns, max_reg_num ());\n-\t       local_alloc ();\n+\t       run_jump_after_reload = local_alloc ();\n \t     });\n+  else\n+    run_jump_after_reload = 0;\n \n   /* Dump rtl code after allocating regs within basic blocks.  */\n \n@@ -4106,6 +4112,16 @@ rest_of_compilation (decl)\n   if (failure)\n     goto exit_rest_of_compilation;\n \n+  /* Register allocation and reloading may have turned an indirect jump into\n+     a direct jump.  If so, we must rerun the jump optimizer to ensure that\n+     the JUMP_LABEL of any jump changed by that transformation is valid.\n+\n+     We do this before reload_cse_regs since it may allow reload_cse to do\n+     a better job.  */\n+  if (run_jump_after_reload)\n+    TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t\t       !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN));\n+\n   /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n     reload_cse_regs (insns);"}]}