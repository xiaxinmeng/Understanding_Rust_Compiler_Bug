{"sha": "4704f28e7a59c82fab92109ac6f22e3b14a0344b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcwNGYyOGU3YTU5YzgyZmFiOTIxMDlhYzZmMjJlM2IxNGEwMzQ0Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-01-12T14:28:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-01-12T14:28:38Z"}, "message": "PR66284 remove std::function special case for reference_wrapper\n\n\tPR libstdc++/66284\n\t* doc/xml/manual/intro.xml: Document LWG 2781 change.\n\t* doc/html/*: Regenerate.\n\t* include/std/functional (_Function_base::_Ref_manager): Remove.\n\t(_Function_handler): Remove partial specializations for\n\treference_wrapper.\n\t(function::target): Remove special case for const qualification.\n\t* testsuite/20_util/function/6.cc: Adjust tests for target type.\n\t* testsuite/20_util/function/7.cc: Likewise.\n\t* testsuite/20_util/function/8.cc: Likewise.\n\nFrom-SVN: r244364", "tree": {"sha": "d66b26bae166881b8425aeef3d95bc46531aab1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d66b26bae166881b8425aeef3d95bc46531aab1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4704f28e7a59c82fab92109ac6f22e3b14a0344b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4704f28e7a59c82fab92109ac6f22e3b14a0344b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4704f28e7a59c82fab92109ac6f22e3b14a0344b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4704f28e7a59c82fab92109ac6f22e3b14a0344b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "872fc7b53d4b2540b50c905fcfca78dcd9bf2ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872fc7b53d4b2540b50c905fcfca78dcd9bf2ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/872fc7b53d4b2540b50c905fcfca78dcd9bf2ccb"}], "stats": {"total": 274, "additions": 132, "deletions": 142}, "files": [{"sha": "7a70e250bf7fcbc12e12a948cd0a61e639684034", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -1,3 +1,16 @@\n+2017-01-12  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/66284\n+\t* doc/xml/manual/intro.xml: Document LWG 2781 change.\n+\t* doc/html/*: Regenerate.\n+\t* include/std/functional (_Function_base::_Ref_manager): Remove.\n+\t(_Function_handler): Remove partial specializations for\n+\treference_wrapper.\n+\t(function::target): Remove special case for const qualification.\n+\t* testsuite/20_util/function/6.cc: Adjust tests for target type.\n+\t* testsuite/20_util/function/7.cc: Likewise.\n+\t* testsuite/20_util/function/8.cc: Likewise.\n+\n 2017-01-11  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/78134"}, {"sha": "439df7dc6fe7ec88cda8d6ef5bf92c71520a41eb", "filename": "libstdc++-v3/doc/html/manual/bugs.html", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fbugs.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fbugs.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fbugs.html?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -509,4 +509,10 @@\n        </em></span>\n     </span></dt><dd><p>Safely detect <code class=\"code\">tuple_size&lt;T&gt;::value</code> and\n       only use it if valid.\n+    </p></dd><dt><span class=\"term\"><a class=\"link\" href=\"../ext/lwg-defects.html#2781\" target=\"_top\">2781</a>:\n+       <span class=\"emphasis\"><em>Contradictory requirements for <code class=\"code\">std::function</code>\n+         and <code class=\"code\">std::reference_wrapper</code>\n+       </em></span>\n+    </span></dt><dd><p>Remove special handling for <code class=\"code\">reference_wrapper</code>\n+      arguments and store them directly as the target object.\n     </p></dd></dl></div></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"license.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"status.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"setup.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">License\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Chapter\u00a02.\u00a0Setup</td></tr></table></div></body></html>\n\\ No newline at end of file"}, {"sha": "7325cbee444419e679a8cf83e26d2672f0109efd", "filename": "libstdc++-v3/doc/html/manual/documentation_hacking.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdocumentation_hacking.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdocumentation_hacking.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fdocumentation_hacking.html?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -368,7 +368,7 @@\n \tFor Texinfo output, something that transforms valid Docbook\n \tXML to Texinfo is required. The default choice is <a class=\"link\" href=\"http://docbook2x.sourceforge.net/\" target=\"_top\">docbook2X</a>.\n       </p><p>\n-\tFor epub output, the <a class=\"link\" href=\"http://sourceforge.net/projects/docbook/files/epub3/\" target=\"_top\">stylesheets</a> for EPUB3 are required. These stylesheets are still in development. To validate the created file, <a class=\"link\" href=\"https://code.google.com/p/epubcheck/\" target=\"_top\">epubcheck</a> is necessary.\n+\tFor epub output, the <a class=\"link\" href=\"https://sourceforge.net/projects/docbook/files/epub3/\" target=\"_top\">stylesheets</a> for EPUB3 are required. These stylesheets are still in development. To validate the created file, <a class=\"link\" href=\"https://code.google.com/p/epubcheck/\" target=\"_top\">epubcheck</a> is necessary.\n       </p></div><div class=\"section\"><div class=\"titlepage\"><div><div><h4 class=\"title\"><a id=\"docbook.rules\"></a>Generating the DocBook Files</h4></div></div></div><p>\n \tThe following Makefile rules generate (in order): an HTML\n \tversion of all the DocBook documentation, a PDF version of the"}, {"sha": "db6e09a7793c0cde8c21567ddabc348f91c00863", "filename": "libstdc++-v3/doc/xml/manual/intro.xml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -1116,6 +1116,15 @@ requirements of the license of GCC.\n       only use it if valid.\n     </para></listitem></varlistentry>\n \n+    <varlistentry><term><link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"../ext/lwg-defects.html#2781\">2781</link>:\n+       <emphasis>Contradictory requirements for <code>std::function</code>\n+         and <code>std::reference_wrapper</code>\n+       </emphasis>\n+    </term>\n+    <listitem><para>Remove special handling for <code>reference_wrapper</code>\n+      arguments and store them directly as the target object.\n+    </para></listitem></varlistentry>\n+\n   </variablelist>\n \n  </section>"}, {"sha": "7d77e213b502aadab683f92948ee241ec0666b89", "filename": "libstdc++-v3/include/bits/std_function.h", "status": "modified", "additions": 9, "deletions": 81, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -268,41 +268,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }\n       };\n \n-    template<typename _Functor>\n-      class _Ref_manager : public _Base_manager<_Functor*>\n-      {\n-\ttypedef _Function_base::_Base_manager<_Functor*> _Base;\n-\n-      public:\n-\tstatic bool\n-\t_M_manager(_Any_data& __dest, const _Any_data& __source,\n-\t\t   _Manager_operation __op)\n-\t{\n-\t  switch (__op)\n-\t    {\n-#if __cpp_rtti\n-\t    case __get_type_info:\n-\t      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-\t      break;\n-#endif\n-\t    case __get_functor_ptr:\n-\t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n-\t      return is_const<_Functor>::value;\n-\t      break;\n-\n-\t    default:\n-\t      _Base::_M_manager(__dest, __source, __op);\n-\t    }\n-\t  return false;\n-\t}\n-\n-\tstatic void\n-\t_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)\n-\t{\n-\t  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));\n-\t}\n-      };\n-\n     _Function_base() : _M_manager(nullptr) { }\n \n     ~_Function_base()\n@@ -311,7 +276,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_manager(_M_functor, _M_functor, __destroy_functor);\n     }\n \n-\n     bool _M_empty() const { return !_M_manager; }\n \n     typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n@@ -354,36 +318,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-  template<typename _Res, typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static _Res\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\treturn std::__invoke(**_Base::_M_get_pointer(__functor),\n-\t\t\t     std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n-    : public _Function_base::_Ref_manager<_Functor>\n-    {\n-      typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n-     public:\n-      static void\n-      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)\n-      {\n-\tstd::__invoke(**_Base::_M_get_pointer(__functor),\n-\t\t      std::forward<_ArgTypes>(__args)...);\n-      }\n-    };\n-\n   template<typename _Class, typename _Member, typename _Res,\n \t   typename... _ArgTypes>\n     class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n@@ -677,15 +611,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *  @brief Access the stored target function object.\n        *\n        *  @return Returns a pointer to the stored target function object,\n-       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+       *  if @c typeid(_Functor).equals(target_type()); otherwise, a NULL\n        *  pointer.\n        *\n-       * This function will not throw an %exception.\n+       * This function does not throw exceptions.\n+       *\n+       * @{\n        */\n       template<typename _Functor>       _Functor* target() noexcept;\n \n-      /// @overload\n       template<typename _Functor> const _Functor* target() const noexcept;\n+      // @}\n #endif\n \n     private:\n@@ -755,17 +691,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       function<_Res(_ArgTypes...)>::\n       target() noexcept\n       {\n-\tif (typeid(_Functor) == target_type() && _M_manager)\n-\t  {\n-\t    _Any_data __ptr;\n-\t    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n-\t\t&& !is_const<_Functor>::value)\n-\t      return 0;\n-\t    else\n-\t      return __ptr._M_access<_Functor*>();\n-\t  }\n-\telse\n-\t  return 0;\n+\tconst function* __const_this = this;\n+\tconst _Functor* __func = __const_this->template target<_Functor>();\n+\treturn const_cast<_Functor*>(__func);\n       }\n \n   template<typename _Res, typename... _ArgTypes>\n@@ -781,7 +709,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return __ptr._M_access<const _Functor*>();\n \t  }\n \telse\n-\t  return 0;\n+\t  return nullptr;\n       }\n #endif\n "}, {"sha": "c224ec5412dd24581cdf4f0bb6a8a5edebf5d156", "filename": "libstdc++-v3/testsuite/20_util/function/6.cc", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F6.cc?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -22,7 +22,20 @@\n #include <functional>\n #include <testsuite_hooks.h>\n \n-using namespace __gnu_test;\n+template<typename T>\n+  const T&\n+  as_const(T& t)\n+  { return t; }\n+\n+// Check that f's target is a reference_wrapper bound to obj.\n+template<typename Function, typename T>\n+  bool\n+  wraps(Function& f, T& obj)\n+  {\n+    using ref_wrapper_type = std::reference_wrapper<T>;\n+    auto* p = f.template target<ref_wrapper_type>();\n+    return std::addressof(p->get()) == std::addressof(obj);\n+  }\n \n struct secret {};\n \n@@ -52,25 +65,24 @@ void test06()\n   function<int()> f(ref(x));\n   VERIFY( f );\n   VERIFY( f() == 17 );\n-  VERIFY( f.target_type() == typeid(noncopyable_function_object_type) );\n-  VERIFY( f.target<noncopyable_function_object_type>() == &x );\n+  VERIFY( f.target_type() == typeid(std::ref(x)) ); // LWG 2781\n+  VERIFY( wraps(f, x) );\n \n   function<int()> g = f;\n   VERIFY( g );\n   VERIFY( g() == 17 );\n-  VERIFY( g.target_type() == typeid(noncopyable_function_object_type) );\n-  VERIFY( g.target<noncopyable_function_object_type>() == &x );\n+  VERIFY( g.target_type() == f.target_type() );\n+  VERIFY( wraps(g, x) );\n \n   function<int()> h = cref(x);\n   VERIFY( h );\n   VERIFY( h() == 42 );\n-  VERIFY( h.target_type() == typeid(noncopyable_function_object_type) );\n-  VERIFY( h.target<const noncopyable_function_object_type>() == &x );\n-  VERIFY( h.target<const noncopyable_function_object_type>() == &x );\n+  VERIFY( h.target_type() == typeid(std::cref(x)) );\n+  VERIFY( wraps(h, as_const(x)) );\n \n   const function<int()>& hc = h;\n-  VERIFY( h.target<noncopyable_function_object_type>() == 0 );\n-  VERIFY( hc.target<noncopyable_function_object_type>() == &x );\n+  VERIFY( hc.target_type() == h.target_type() );\n+  VERIFY( wraps(hc, as_const(x)) );\n }\n \n int main()"}, {"sha": "b10ecb8a161aaf6a406491d0d0e22a24a3a31607", "filename": "libstdc++-v3/testsuite/20_util/function/7.cc", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F7.cc?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -23,16 +23,30 @@\n #include <testsuite_hooks.h>\n #include <testsuite_tr1.h>\n \n-using namespace __gnu_test;\n+template<typename T>\n+  const T&\n+  as_const(T& t)\n+  { return t; }\n+\n+// Check that f's target is a reference_wrapper bound to obj.\n+template<typename Function, typename T>\n+  bool\n+  wraps(Function& f, T& obj)\n+  {\n+    using ref_wrapper_type = std::reference_wrapper<T>;\n+    auto* p = f.template target<ref_wrapper_type>();\n+    return std::addressof(p->get()) == std::addressof(obj);\n+  }\n \n // Put reference_wrappers to function pointers into function<> wrappers\n void test07()\n {\n   using std::function;\n   using std::ref;\n   using std::cref;\n+  using std::reference_wrapper;\n \n-  int (*fptr)(float) = truncate_float;\n+  int (*fptr)(float) = __gnu_test::truncate_float;\n \n   function<int(float)> f1(ref(fptr));\n   VERIFY( f1 );\n@@ -47,11 +61,11 @@ void test07()\n \n   // target_type and target() functions\n   const function<int(float)>& f1c = f1;\n-  VERIFY( typeid(int(*)(float)) == f1.target_type() );\n-  VERIFY( f1.target<int(*)(float)>() != 0 );\n-  VERIFY( f1.target<int(*)(float)>() == &fptr );\n-  VERIFY( f1c.target<int(*)(float)>() != 0 );\n-  VERIFY( f1c.target<int(*)(float)>() == &fptr );\n+  using ref_wrapper_type = reference_wrapper<int(*)(float)>;\n+  VERIFY( typeid(ref_wrapper_type) == f1.target_type() );\n+  VERIFY( f1.target<ref_wrapper_type>() != nullptr );\n+  VERIFY( wraps(f1, fptr) );\n+  VERIFY( wraps(f1c, fptr) );\n \n   function<int(float)> f2(cref(fptr));\n   VERIFY( f2 );\n@@ -66,11 +80,11 @@ void test07()\n \n   // target_type and target() functions\n   const function<int(float)>& f2c = f2;\n-  VERIFY( typeid(int(*)(float)) == f2.target_type() );\n-  VERIFY( f2.target<int(*)(float)>() == 0 );\n-  VERIFY( f2.target<int(* const)(float)>() == &fptr );\n-  VERIFY( f2c.target<int(*)(float)>() != 0 );\n-  VERIFY( f2c.target<int(*)(float)>() == &fptr );\n+  using cref_wrapper_type = reference_wrapper<int(* const)(float)>;\n+  VERIFY( typeid(cref_wrapper_type) == f2.target_type() );\n+  VERIFY( wraps(f2, as_const(fptr)) );\n+  VERIFY( f2c.target_type() == f2.target_type() );\n+  VERIFY( wraps(f2c, as_const(fptr)) );\n }\n \n int main()"}, {"sha": "e641057d1511d1fa0386cd1c225a0c71c5dba992", "filename": "libstdc++-v3/testsuite/20_util/function/8.cc", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4704f28e7a59c82fab92109ac6f22e3b14a0344b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction%2F8.cc?ref=4704f28e7a59c82fab92109ac6f22e3b14a0344b", "patch": "@@ -23,14 +23,29 @@\n #include <testsuite_hooks.h>\n #include <testsuite_tr1.h>\n \n-using namespace __gnu_test;\n+template<typename T>\n+  const T&\n+  as_const(T& t)\n+  { return t; }\n+\n+// Check that f's target is a reference_wrapper bound to obj.\n+template<typename Function, typename T>\n+  bool\n+  wraps(Function& f, T& obj)\n+  {\n+    using ref_wrapper_type = std::reference_wrapper<T>;\n+    auto* p = f.template target<ref_wrapper_type>();\n+    return std::addressof(p->get()) == std::addressof(obj);\n+  }\n \n // Put reference_wrappers to member pointers\n void test08()\n {\n   using std::function;\n   using std::ref;\n   using std::cref;\n+  using std::reference_wrapper;\n+  using __gnu_test::X;\n \n   int X::* X_bar = &X::bar;\n   int (X::* X_foo)() = &X::foo;\n@@ -44,99 +59,92 @@ void test08()\n   function<int(X&)> frm(ref(X_bar));\n   VERIFY( frm );\n   VERIFY( frm(x) == 17 );\n-  VERIFY( typeid(int X::*) == frm.target_type() );\n-  VERIFY( frm.target<int X::*>() == &X_bar );\n+  VERIFY( typeid(ref(X_bar)) == frm.target_type() );\n+  VERIFY( wraps(frm, X_bar) );\n \n   function<int(X&)> fr(ref(X_foo));\n   VERIFY( fr );\n   VERIFY( fr(x) == 1 );\n-  VERIFY( typeid(int (X::*)()) == fr.target_type() );\n-  VERIFY( fr.target<int (X::*)()>() == &X_foo );\n+  VERIFY( typeid(ref(X_foo)) == fr.target_type() );\n+  VERIFY( wraps(fr, X_foo) );\n \n   function<int(const X&)> frc(ref(X_foo_c));\n   VERIFY( frc );\n   VERIFY( frc(x) == 2 );\n-  VERIFY( typeid(int (X::*)() const) == frc.target_type() );\n-  VERIFY( frc.target<int (X::*)() const >() == &X_foo_c );\n+  VERIFY( typeid(ref(X_foo_c)) == frc.target_type() );\n+  VERIFY( wraps(frc, X_foo_c) );\n \n   function<int(volatile X&)> frv(ref(X_foo_v));\n   VERIFY( frv );\n   VERIFY( frv(x) == 3 );\n-  VERIFY( typeid(int (X::*)() volatile) == frv.target_type() );\n-  VERIFY( *frv.target<int (X::*)() volatile >() == X_foo_v );\n-  VERIFY( frv.target<int (X::*)() const volatile>() == 0 );\n+  VERIFY( typeid(ref(X_foo_v)) == frv.target_type() );\n+  VERIFY( wraps(frv, X_foo_v) );\n \n   function<int(const volatile X&)> frcv(ref(X_foo_cv));\n   VERIFY( frcv );\n   VERIFY( frcv(x) == 4 );\n-  VERIFY( typeid(int (X::*)() const volatile) == frcv.target_type() );\n-  VERIFY( *frcv.target<int (X::*)() const volatile >() == X_foo_cv );\n-  VERIFY( frcv.target<int (X::*)() const>() == 0 );\n+  VERIFY( typeid(ref(X_foo_cv)) == frcv.target_type() );\n+  VERIFY( wraps(frcv, X_foo_cv) );\n \n   function<int(X*)> grm(ref(X_bar));\n   VERIFY( grm );\n   VERIFY( grm(&x) == 17 );\n-  VERIFY( typeid(int X::*) == grm.target_type() );\n-  VERIFY( *grm.target<int X::*>() == X_bar );\n+  VERIFY( typeid(ref(X_bar)) == grm.target_type() );\n+  VERIFY( wraps(grm, X_bar) );\n \n   function<int(X*)> gr(ref(X_foo));\n   VERIFY( gr );\n   VERIFY( gr(&x) == 1 );\n-  VERIFY( typeid(int (X::*)()) == gr.target_type() );\n-  VERIFY( *gr.target<int (X::*)()>() == X_foo );\n+  VERIFY( typeid(ref(X_foo)) == gr.target_type() );\n+  VERIFY( wraps(gr, X_foo) );\n \n   function<int(const X*)> grc(ref(X_foo_c));\n   VERIFY( grc );\n   VERIFY( grc(&x) == 2 );\n-  VERIFY( typeid(int (X::*)() const) == grc.target_type() );\n-  VERIFY( *grc.target<int (X::*)() const >() == X_foo_c );\n+  VERIFY( typeid(ref(X_foo_c)) == grc.target_type() );\n+  VERIFY( wraps(grc, X_foo_c) );\n \n   function<int(volatile X*)> grv(ref(X_foo_v));\n   VERIFY( grv );\n   VERIFY( grv(&x) == 3 );\n-  VERIFY( typeid(int (X::*)() volatile) == grv.target_type() );\n-  VERIFY( *grv.target<int (X::*)() volatile >() == X_foo_v );\n-  VERIFY( grv.target<int (X::*)() const volatile>() == 0 );\n+  VERIFY( typeid(ref(X_foo_v)) == grv.target_type() );\n+  VERIFY( wraps(grv, X_foo_v) );\n \n   function<int(const volatile X*)> grcv(ref(X_foo_cv));\n   VERIFY( grcv );\n   VERIFY( grcv(&x) == 4 );\n-  VERIFY( typeid(int (X::*)() const volatile) == grcv.target_type() );\n-  VERIFY( *grcv.target<int (X::*)() const volatile >() == X_foo_cv );\n-  VERIFY( grcv.target<int (X::*)() const>() == 0 );\n+  VERIFY( typeid(ref(X_foo_cv)) == grcv.target_type() );\n+  VERIFY( wraps(grcv, X_foo_cv) );\n \n   function<int(X&)> hrm(cref(X_bar));\n   VERIFY( hrm );\n   VERIFY( hrm(x) == 17 );\n-  VERIFY( typeid(int X::*) == hrm.target_type() );\n-  VERIFY( hrm.target<int X::*>() == 0 );\n-  VERIFY( hrm.target<int X::* const>() == &X_bar );\n+  VERIFY( typeid(cref(X_bar)) == hrm.target_type() );\n+  VERIFY( wraps(hrm, as_const(X_bar)) );\n \n   function<int(X&)> hr(cref(X_foo));\n   VERIFY( hr );\n   VERIFY( hr(x) == 1 );\n-  VERIFY( typeid(int (X::*)()) == hr.target_type() );\n-  VERIFY( hr.target<int (X::* const)()>() == &X_foo );\n+  VERIFY( typeid(cref(X_foo)) == hr.target_type() );\n+  VERIFY( wraps(hr, as_const(X_foo)) );\n \n   function<int(const X&)> hrc(cref(X_foo_c));\n   VERIFY( hrc );\n   VERIFY( hrc(x) == 2 );\n-  VERIFY( typeid(int (X::*)() const) == hrc.target_type() );\n-  VERIFY( hrc.target<int (X::* const)() const >() == &X_foo_c );\n+  VERIFY( typeid(cref(X_foo_c)) == hrc.target_type() );\n+  VERIFY( wraps(hrc, as_const(X_foo_c)) );\n \n   function<int(volatile X&)> hrv(cref(X_foo_v));\n   VERIFY( hrv );\n   VERIFY( hrv(x) == 3 );\n-  VERIFY( typeid(int (X::*)() volatile) == hrv.target_type() );\n-  VERIFY( hrv.target<int (X::* const)() volatile >() == &X_foo_v );\n-  VERIFY( hrv.target<int (X::* const)() const volatile>() == 0 );\n+  VERIFY( typeid(cref(X_foo_v)) == hrv.target_type() );\n+  VERIFY( wraps(hrv, as_const(X_foo_v)) );\n \n   function<int(const volatile X&)> hrcv(cref(X_foo_cv));\n   VERIFY( hrcv );\n   VERIFY( hrcv(x) == 4 );\n-  VERIFY( typeid(int (X::*)() const volatile) == hrcv.target_type() );\n-  VERIFY( hrcv.target<int (X::* const)() const volatile >() == &X_foo_cv );\n-  VERIFY( hrcv.target<int (X::* const)() const>() == 0 );\n+  VERIFY( typeid(cref(X_foo_cv)) == hrcv.target_type() );\n+  VERIFY( wraps(hrcv, as_const(X_foo_cv)) );\n }\n \n int main()"}]}