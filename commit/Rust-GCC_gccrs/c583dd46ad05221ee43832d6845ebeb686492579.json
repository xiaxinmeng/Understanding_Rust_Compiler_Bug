{"sha": "c583dd46ad05221ee43832d6845ebeb686492579", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU4M2RkNDZhZDA1MjIxZWU0MzgzMmQ2ODQ1ZWJlYjY4NjQ5MjU3OQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-10-16T19:36:39Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-10-16T19:36:39Z"}, "message": "lex.c (setjmp.h): No longer included.\n\nFri Oct 16 10:59:01 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* lex.c (setjmp.h): No longer included.\n\t* lex.h (setjmp.h): Included.\n\t* parse.h (SET_TYPE_FOR_RESOLUTION): New macro.\n\t(duplicate_declaration_error_p): Renamed from\n \tduplicate_declaration_error.\n\t(build_array_from_name): New function prototype.\n\t* parse.y (setjmp.h): No longer included.\n\t(variable_declarator_id): Define action.\n\t(build_array_from_name): New function.\n\t(duplicate_declaration_error_p): Renamed from\n \tduplicate_declaration_error.  Fixed leading comment.\n\t(register_fields): Main `for' loop reorganized. Uses\n \tSET_TYPE_FOR_RESOLUTION and build_array_from_name.\n\t(method_declarator): Uses SET_TYPE_FOR_RESOLUTION and call\n \tbuild_array_from_name.\n\t(resolve_class): Set CLASS_LOADED_P on newly build array dimension\n \ttypes.\n\t(read_import_dir): Don't try to skip `.' and `..'.\n\t(declare_local_variables): Uses SET_TYPE_FOR_RESOLUTION and\n \tbuild_array_from_name. Main `for' loop reorganized.\n\t(resolve_qualified_expression_name): When building access to a\n \tfield, use the type where the field was found, not its own type.\n\t(maybe_access_field): Use field DECL_CONTEXT if the type where the\n \tfield was found is null.\n\t(qualify_ambiguous_name): Sweep through all successive array\n \tdimensions.\nImplements the alternate form `T a[]' of array declarations. Fixes a\nbug when building access to certain fields. Fixed a compilation\nwarning when lex.h is included from somewhere else than parse.y\n\nFrom-SVN: r23142", "tree": {"sha": "0f92c4b1856c87f2362d17e61e9bd4187423ba40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f92c4b1856c87f2362d17e61e9bd4187423ba40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c583dd46ad05221ee43832d6845ebeb686492579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c583dd46ad05221ee43832d6845ebeb686492579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c583dd46ad05221ee43832d6845ebeb686492579", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c583dd46ad05221ee43832d6845ebeb686492579/comments", "author": null, "committer": null, "parents": [{"sha": "8e52e063afdb17d8d92e5ceb1c03dc915a5a17a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e52e063afdb17d8d92e5ceb1c03dc915a5a17a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e52e063afdb17d8d92e5ceb1c03dc915a5a17a3"}], "stats": {"total": 365, "additions": 245, "deletions": 120}, "files": [{"sha": "d2ce1fcc1ac930aaca83acd5bca102b1d5693a78", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c583dd46ad05221ee43832d6845ebeb686492579", "patch": "@@ -1,3 +1,32 @@\n+Fri Oct 16 10:59:01 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* lex.c (setjmp.h): No longer included.\n+\t* lex.h (setjmp.h): Included.\n+\t* parse.h (SET_TYPE_FOR_RESOLUTION): New macro.\n+\t(duplicate_declaration_error_p): Renamed from\n+ \tduplicate_declaration_error.\n+\t(build_array_from_name): New function prototype.\n+\t* parse.y (setjmp.h): No longer included.\n+\t(variable_declarator_id): Define action.\n+\t(build_array_from_name): New function.\n+\t(duplicate_declaration_error_p): Renamed from\n+ \tduplicate_declaration_error.  Fixed leading comment.\n+\t(register_fields): Main `for' loop reorganized. Uses\n+ \tSET_TYPE_FOR_RESOLUTION and build_array_from_name.\n+\t(method_declarator): Uses SET_TYPE_FOR_RESOLUTION and call\n+ \tbuild_array_from_name.\n+\t(resolve_class): Set CLASS_LOADED_P on newly build array dimension\n+ \ttypes.\n+\t(read_import_dir): Don't try to skip `.' and `..'.\n+\t(declare_local_variables): Uses SET_TYPE_FOR_RESOLUTION and\n+ \tbuild_array_from_name. Main `for' loop reorganized.\n+\t(resolve_qualified_expression_name): When building access to a\n+ \tfield, use the type where the field was found, not its own type.\n+\t(maybe_access_field): Use field DECL_CONTEXT if the type where the\n+ \tfield was found is null.\n+\t(qualify_ambiguous_name): Sweep through all successive array\n+ \tdimensions.\n+\t\n Wed Oct 14 18:21:29 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* java-tree.h (pop_labeled_block, lang_printable_name,"}, {"sha": "1c103e131cd61a63ded885f94e75ac85853790a9", "filename": "gcc/java/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=c583dd46ad05221ee43832d6845ebeb686492579", "patch": "@@ -37,7 +37,6 @@ Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html)  */\n #include <stdio.h>\n #include <string.h>\n #include <strings.h>\n-#include <setjmp.h>\n \n #ifdef JAVA_LEX_DEBUG\n #include <ctype.h>"}, {"sha": "fdee404c0a904d604703625e2f68ecf48ed7c2d4", "filename": "gcc/java/lex.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=c583dd46ad05221ee43832d6845ebeb686492579", "patch": "@@ -26,6 +26,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #ifndef JV_LEX_H\n #define JV_LEX_H\n \n+#include <setjmp.h>\t\t/* set_float_handler argument uses it */\n+\n /* Extern global variables declarations  */\n extern FILE *finput;\n extern int   lineno;"}, {"sha": "7c2b99da8103292f925fc1a7ae054ff16cd9e34b", "filename": "gcc/java/parse.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=c583dd46ad05221ee43832d6845ebeb686492579", "patch": "@@ -399,6 +399,27 @@ static jdeplist *reverse_jdep_list ();\n       }\t\t\t\t\t\t\\\n   }\n \n+/* if TYPE can't be resolved, obtain something suitable for its\n+   resolution (TYPE is saved in SAVE before being changed). and set\n+   CHAIN to 1. Otherwise, type is set to something usable. CHAIN is\n+   usually used to determine that a new DEP must be installed on TYPE.  */\n+#define SET_TYPE_FOR_RESOLUTION(TYPE, SAVE, CHAIN)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    tree returned_type;\t\t\t\t\t\\\n+    (CHAIN) = 0;\t\t\t\t\t\\\n+    if (unresolved_type_p (type, &returned_type))\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (returned_type)\t\t\t\t\\\n+\t  (TYPE) = returned_type;\t\t\t\\\n+\telse\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    (SAVE) = (TYPE);\t\t\t\t\\\n+\t    (TYPE) = obtain_incomplete_type (TYPE);\t\\\n+\t    CHAIN = 1;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n /* Insert a DECL in the current block */\n #define BLOCK_CHAIN_DECL(NODE)\t\t\t\t\t\t    \\\n   {\t\t \t\t\t\t\t\t\t    \\\n@@ -560,7 +581,7 @@ static tree  create_class PROTO ((int, tree, tree, tree));\n static tree  create_interface PROTO ((int, tree, tree));\n static tree  find_field PROTO ((tree, tree));\n static tree lookup_field_wrapper PROTO ((tree, tree));\n-static int   duplicate_declaration_error PROTO ((tree, tree, tree));\n+static int   duplicate_declaration_error_p PROTO ((tree, tree, tree));\n static void  register_fields PROTO ((int, tree, tree));\n static tree parser_qualified_classname PROTO ((tree));\n static int  parser_check_super PROTO ((tree, tree, tree));\n@@ -631,6 +652,7 @@ static int valid_method_invocation_conversion_p PROTO ((tree, tree));\n static tree try_builtin_assignconv PROTO ((tree, tree, tree));\n static tree try_reference_assignconv PROTO ((tree, tree));\n static tree build_unresolved_array_type PROTO ((tree));\n+static tree build_array_from_name PROTO ((tree, tree, tree, tree *));\n static tree build_array_ref PROTO ((int, tree, tree));\n static tree patch_array_ref PROTO ((tree, tree, tree));\n static tree make_qualified_name PROTO ((tree, tree, int));"}, {"sha": "93d1f811dee43a6774589fe5902e1bc9f75e3ac1", "filename": "gcc/java/parse.y", "status": "modified", "additions": 191, "deletions": 118, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c583dd46ad05221ee43832d6845ebeb686492579/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c583dd46ad05221ee43832d6845ebeb686492579", "patch": "@@ -51,7 +51,6 @@ definitions and other extensions.  */\n #include <stdlib.h>\n #include <string.h>\n #include <dirent.h>\n-#include <setjmp.h>\t\t/* set_float_handler argument uses it */\n #ifdef __STDC__\n #include <stdarg.h>\n #else\n@@ -619,9 +618,7 @@ variable_declarator:\n variable_declarator_id:\n \tidentifier\n |\tvariable_declarator_id OSB_TK CSB_TK\n-\t\t{\n-\t\t  $$ = NULL;\t/* FIXME */\n-\t\t}\n+\t\t{ $$ = build_unresolved_array_type ($1); }\n |\tidentifier error\n \t\t{yyerror (\"Invalid declaration\"); DRECOVER(vdi);}\n |\tvariable_declarator_id OSB_TK error\n@@ -2341,6 +2338,54 @@ variable_redefinition_error (context, name, type, line)\n \t\t       type_name, IDENTIFIER_POINTER (name), line);\n }\n \n+static tree\n+build_array_from_name (type, type_wfl, name, ret_name)\n+     tree type, type_wfl, name, *ret_name;\n+{\n+  int more_dims = 0;\n+  char *string;\n+\n+  /* Eventually get more dims */\n+  string = IDENTIFIER_POINTER (name);\n+  while (string [more_dims] == '[')\n+    more_dims++;\n+  \n+  /* If we have, then craft a new type for this variable */\n+  if (more_dims)\n+    {\n+      name = get_identifier (&more_dims [string]);\n+\n+      /* If type already is a reference on an array, get the base type */\n+      if ((TREE_CODE (type) == POINTER_TYPE) && \n+\t  TYPE_ARRAY_P (TREE_TYPE (type)))\n+\ttype = TREE_TYPE (type);\n+\n+      /* Building the first dimension of a primitive type uses this\n+         function */\n+      if (JPRIMITIVE_TYPE_P (type))\n+\t{\n+\t  type = build_java_array_type (type, -1);\n+\t  more_dims--;\n+\t}\n+      /* Otherwise, if we have a WFL for this type, use it (the type\n+         is already an array on an unresolved type, and we just keep\n+         on adding dimensions) */\n+      else if (type_wfl)\n+\ttype = type_wfl;\n+\n+      /* Add all the dimensions */\n+      while (more_dims--)\n+\ttype = build_unresolved_array_type (type);\n+\n+      /* The type may have been incomplete in the first place */\n+      if (type_wfl)\n+\ttype = obtain_incomplete_type (type);\n+    }\n+\n+  *ret_name = name;\n+  return type;\n+}\n+\n /* Build something that the type identifier resolver will identify as\n    being an array to an unresolved type. TYPE_WFL is a WFL on a\n    identifier. */\n@@ -2661,10 +2706,11 @@ lookup_field_wrapper (class, name)\n }\n \n /* Find duplicate field within the same class declarations and report\n-   the error */\n+   the error. Returns 1 if a duplicated field was found, 0\n+   otherwise.  */\n \n static int\n-duplicate_declaration_error (new_field_name, new_type, cl)\n+duplicate_declaration_error_p (new_field_name, new_type, cl)\n      tree new_field_name, new_type, cl;\n {\n   /* This might be modified to work with method decl as well */\n@@ -2685,9 +2731,9 @@ duplicate_declaration_error (new_field_name, new_type, cl)\n \t DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n       free (t1);\n       free (t2);\n-      return 0;\n+      return 1;\n     }\n-  return 1;\n+  return 0;\n }\n \n /* Field registration routine. If TYPE doesn't exist, field\n@@ -2699,7 +2745,7 @@ register_fields (flags, type, variable_list)\n      int flags;\n      tree type, variable_list;\n {\n-  tree current, returned_type;\n+  tree current, saved_type;\n   tree class_type = TREE_TYPE (ctxp->current_parsed_class);\n   int saved_lineno = lineno;\n   int must_chain = 0;\n@@ -2722,70 +2768,77 @@ register_fields (flags, type, variable_list)\n       flags |= (ACC_PUBLIC | ACC_STATIC | ACC_FINAL);\n     }\n \n-  if (unresolved_type_p (type, &returned_type))\n-    {\n-      if (returned_type)\n-\ttype = returned_type;\n-      else\n-\t{\n-\t  wfl = type;\n-\t  type = obtain_incomplete_type (type);\n-\t  must_chain = 1;\n-\t}\n-    }\n+  /* Obtain a suitable type for resolution, if necessary */\n+  SET_TYPE_FOR_RESOLUTION (type, wfl, must_chain);\n+\n+  /* If TYPE is fully resolved and we don't have a reference, make one */\n   if (!must_chain && TREE_CODE (type) == RECORD_TYPE)\n     type = promote_type (type);\n \n-  for (current = variable_list; current; current = TREE_CHAIN (current))\n+  for (current = variable_list, saved_type = type; current; \n+       current = TREE_CHAIN (current), type = saved_type)\n     {\n+      tree field_decl;\n       tree cl = TREE_PURPOSE (current);\n       tree init = TREE_VALUE (current);\n       tree current_name = EXPR_WFL_NODE (cl);\n \n-      if (duplicate_declaration_error (current_name, type, cl))\n-        {\n-\t  tree field_decl;\n-\t  lineno = EXPR_WFL_LINENO (cl);\n-\t  field_decl = add_field (class_type, current_name, type, flags);\n+      /* Process NAME, as it may specify extra dimension(s) for it */\n+      type = build_array_from_name (type, wfl, current_name, &current_name);\n \n-\t  /* Check if we must chain. */\n-\t  if (must_chain)\n-\t    register_incomplete_type (JDEP_FIELD, wfl, field_decl, type);\n+      /* Check for redeclarations */\n+      if (duplicate_declaration_error_p (current_name, type, cl))\n+\tcontinue;\n+\n+      /* Type adjustment. We may have just readjusted TYPE because\n+\t the variable specified more dimensions. Make sure we have\n+\t a reference if we can and don't have one already. */\n+      if (type != saved_type && !must_chain \n+\t  && (TREE_CODE (type) == RECORD_TYPE))\n+\ttype = promote_type (type);\n+\n+      /* Set lineno to the line the field was found and create a\n+         declaration for it */\n+      lineno = EXPR_WFL_LINENO (cl);\n+      field_decl = add_field (class_type, current_name, type, flags);\n+      \n+      /* Check if we must chain. */\n+      if (must_chain)\n+\tregister_incomplete_type (JDEP_FIELD, wfl, field_decl, type);\n \t  \n-\t  /* Default value of a static field is 0 and it is considered\n-             initialized. */\n+      /* Default value of a static field is 0 and it is considered\n+\t initialized. */\n+      if (flags & ACC_STATIC)\n+\tINITIALIZED_P (field_decl) = 1;\n+      \n+      /* If we have an initialization value tied to the field */\n+      if (init)\n+\t{\n+\t  /* The field is declared static */\n \t  if (flags & ACC_STATIC)\n-\t    INITIALIZED_P (field_decl) = 1;\n-\n-\t  /* If we have an initialization value tied to the field */\n-\t  if (init)\n \t    {\n-\t      /* The field is declared static */\n-\t      if (flags & ACC_STATIC)\n-\t\t{\n-\t\t  /* FIXME */\n-\t\t  if (flags & ACC_FINAL)\n-\t\t    ;\t\t\n-\t\t  /* Otherwise, the field should be initialized in\n-\t\t     <clinit>. This field is remembered so we can\n-\t\t     generate <clinit> later. */\n-\t\t  else\n-\t\t    {\n-\t\t      INITIALIZED_P (field_decl) = 1;\n-\t\t      TREE_CHAIN (init) = ctxp->static_initialized;\n-\t\t      ctxp->static_initialized = init;\n-\t\t    }\n-\t\t}\n-\t      /* A non-static field declared with an immediate\n-\t\t initialization is to be initialized in <init>, if\n-\t\t any.  This field is remembered to be processed at the\n-\t\t time of the generation of <init>. */\n+\t      /* FIXME */\n+\t      if (flags & ACC_FINAL)\n+\t\t;\t\t\n+\t      /* Otherwise, the field should be initialized in\n+\t\t <clinit>. This field is remembered so we can\n+\t\t generate <clinit> later. */\n \t      else\n \t\t{\n-\t\t  TREE_CHAIN (init) = ctxp->non_static_initialized;\n-\t\t  ctxp->non_static_initialized = init;\n+\t\t  INITIALIZED_P (field_decl) = 1;\n+\t\t  TREE_CHAIN (init) = ctxp->static_initialized;\n+\t\t  ctxp->static_initialized = init;\n \t\t}\n \t    }\n+\t  /* A non-static field declared with an immediate\n+\t     initialization is to be initialized in <init>, if\n+\t     any.  This field is remembered to be processed at the\n+\t     time of the generation of <init>. */\n+\t  else\n+\t    {\n+\t      TREE_CHAIN (init) = ctxp->non_static_initialized;\n+\t      ctxp->non_static_initialized = init;\n+\t    }\n \t}\n     }\n   lineno = saved_lineno;\n@@ -3053,10 +3106,19 @@ method_declarator (id, list)\n   \n   for (current = list; current; current = TREE_CHAIN (current))\n     {\n+      int must_chain = 0;\n       tree wfl_name = TREE_PURPOSE (current);\n       tree type = TREE_VALUE (current);\n       tree name = EXPR_WFL_NODE (wfl_name);\n-      tree already, arg_node, returned_type;\n+      tree already, arg_node;\n+      tree type_wfl = NULL_TREE;\n+\n+      /* Obtain a suitable type for resolution, if necessary */\n+      SET_TYPE_FOR_RESOLUTION (type, type_wfl, must_chain);\n+\n+      /* Process NAME, as it may specify extra dimension(s) for it */\n+      type = build_array_from_name (type, type_wfl, name, &name);\n+      EXPR_WFL_NODE (wfl_name) = name;\n \n       /* Check redefinition */\n       for (already = arg_types; already; already = TREE_CHAIN (already))\n@@ -3072,19 +3134,15 @@ method_declarator (id, list)\n       /* If we've an incomplete argument type, we know there is a location\n \t to patch when the type get resolved, later.  */\n       jdep = NULL;\n-      if (unresolved_type_p (type, &returned_type))\n+      if (must_chain)\n \t{\n-\t  if (returned_type)\n-\t    type = returned_type;\n-\t  else\n-\t    {\n-\t      patch_stage = JDEP_METHOD;\n-\t      type = register_incomplete_type (patch_stage, type, \n-\t\t\t\t\t       wfl_name, NULL_TREE);\n-\t      jdep = CLASSD_LAST (ctxp->classd_list);\n-\t      JDEP_MISC (jdep) = id;\n-\t    }\n+\t  patch_stage = JDEP_METHOD;\n+\t  type = register_incomplete_type (patch_stage, \n+\t\t\t\t\t   type_wfl, wfl_name, type);\n+\t  jdep = CLASSD_LAST (ctxp->classd_list);\n+\t  JDEP_MISC (jdep) = id;\n \t}\n+\n       /* The argument node: a name and a (possibly) incomplete type */\n       arg_node = build_tree_list (name, type);\n       if (jdep)\n@@ -3539,6 +3597,7 @@ resolve_class (class_type, decl, cl)\n \t  if (TREE_CODE (resolved_type) == RECORD_TYPE)\n \t    resolved_type  = promote_type (resolved_type);\n \t  resolved_type = build_java_array_type (resolved_type, -1);\n+\t  CLASS_LOADED_P (resolved_type) = 1;\n \t  name--;\n \t}\n       /* Build a fake decl for this, since this is what is expected to\n@@ -4260,10 +4319,8 @@ read_import_dir (wfl)\n   if (jcf->seen_in_zip)\n     jcf->zipd = ZIPDIR_NEXT ((ZipDirectory *)jcf->zipd);\n \n-  else if (founddirname && (dirp = opendir (founddirname)))\n-    {\n-      readdir (dirp); readdir (dirp);\n-    }\n+  else if (founddirname)\n+    dirp = opendir (founddirname);\n \n   if (!founddirname && !dirp)\n     {\n@@ -4429,7 +4486,8 @@ declare_local_variables (modifier, type, vlist)\n      tree type;\n      tree vlist;\n {\n-  tree decl, current, returned_type, type_wfl;\n+  tree decl, current, saved_type;\n+  tree type_wfl = NULL_TREE;\n   int must_chain = 0;\n \n   /* Push a new block if statement were seen between the last time we\n@@ -4453,57 +4511,69 @@ declare_local_variables (modifier, type, vlist)\n       return;\n     }\n \n-  if (unresolved_type_p (type, &returned_type))\n-    {\n-      if (returned_type)\n-        type = returned_type;\n-      else \n-\t{\n-\t  type_wfl = type;\n-\t  type = obtain_incomplete_type (type);\n-\t  must_chain = 1;\n-\t}\n-    }\n+  /* Obtain an incomplete type if TYPE is not complete. TYPE_WFL will\n+     hold the TYPE value if a new incomplete has to be created (as\n+     opposed to being found already existing and reused). */\n+  SET_TYPE_FOR_RESOLUTION (type, type_wfl, must_chain);\n+\n+  /* If TYPE is fully resolved and we don't have a reference, make one */\n   if (!must_chain && TREE_CODE (type) == RECORD_TYPE)\n     type = promote_type (type);\n-  \n-  for (current = vlist; current; current = TREE_CHAIN (current))\n+\n+  /* Go through all the declared variables */\n+  for (current = vlist, saved_type = type; current;\n+       current = TREE_CHAIN (current), type = saved_type)\n     {\n+      tree other;\n       tree wfl  = TREE_PURPOSE (current);\n       tree name = EXPR_WFL_NODE (wfl);\n       tree init = TREE_VALUE (current);\n-      tree other = lookup_name_in_blocks (name);\n \n+      /* Process NAME, as it may specify extra dimension(s) for it */\n+      type = build_array_from_name (type, type_wfl, name, &name);\n+\n+      /* Variable redefinition check */\n+      if ((other = lookup_name_in_blocks (name)))\n+\t{\n+\t  variable_redefinition_error (wfl, name, TREE_TYPE (other),\n+\t\t\t\t       DECL_SOURCE_LINE (other));\n+\t  continue;\n+\t}\n+\n+      /* Type adjustment. We may have just readjusted TYPE because\n+\t the variable specified more dimensions. Make sure we have\n+\t a reference if we can and don't have one already. */\n+      if (type != saved_type && !must_chain \n+\t  && (TREE_CODE (type) == RECORD_TYPE))\n+\ttype = promote_type (type);\n+      \n+      /* Never layout this decl. This will be done when its scope\n+\t will be entered */\n+      decl = build_decl_no_layout (VAR_DECL, name, type);\n+      BLOCK_CHAIN_DECL (decl);\n+      \n       /* Don't try to use an INIT statement when an error was found */\n       if (init && java_error_count)\n \tinit = NULL_TREE;\n-\n-      if (other)\n-\tvariable_redefinition_error (wfl, name, TREE_TYPE (other),\n-\t\t\t\t     DECL_SOURCE_LINE (other));\n-      else\n+      \n+      /* Add the initialization function to the current function's code */\n+      if (init)\n \t{\n-\t  /* Never layout this decl. This will be done when its scope\n-             will be entered */\n-\t  decl = build_decl_no_layout (VAR_DECL, name, type);\n-\t  BLOCK_CHAIN_DECL (decl);\n-\n-\t  /* Add the initialization function to the current function's code */\n-\t  if (init)\n-\t    {\n-\t      MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n-\t      java_method_add_stmt \n-\t\t(current_function_decl,\n-\t\t build_debugable_stmt (EXPR_WFL_LINECOL (init), init));\n-\t    }\n-\n-\t  if (must_chain)\n-\t    {\n-\t      jdep *dep;\n-\t      register_incomplete_type (JDEP_VARIABLE, type_wfl, decl, type);\n-\t      dep = CLASSD_LAST (ctxp->classd_list);\n-\t      JDEP_GET_PATCH (dep) = &TREE_TYPE (decl);\n-\t    }\n+\t  /* Name might have been readjusted */\n+\t  EXPR_WFL_NODE (TREE_OPERAND (init, 0)) = name;\n+\t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n+\t  java_method_add_stmt (current_function_decl,\n+\t\t\t\tbuild_debugable_stmt (EXPR_WFL_LINECOL (init),\n+\t\t\t\t\t\t      init));\n+\t}\n+    \n+      /* Setup dependency the type of the decl */\n+      if (must_chain)\n+\t{\n+\t  jdep *dep;\n+\t  register_incomplete_type (JDEP_VARIABLE, type_wfl, decl, type);\n+\t  dep = CLASSD_LAST (ctxp->classd_list);\n+\t  JDEP_GET_PATCH (dep) = &TREE_TYPE (decl);\n \t}\n     }\n   SOURCE_FRONTEND_DEBUG ((\"Defined locals\"));\n@@ -5319,7 +5389,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t on what this field is accessed from, do it now. */\n \t      if (!is_static)\n \t\t{\n-\t\t  decl = maybe_access_field (decl, *where_found, type);\n+\t\t  decl = maybe_access_field (decl, *where_found, *type_found);\n \t\t  if (decl == error_mark_node)\n \t\t    return 1;\n \t\t}\n@@ -5451,7 +5521,8 @@ maybe_access_field (decl, where, type)\n \t    && FIELD_STATIC (decl)))\n       && !IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)))\n     decl = build_field_ref (where ? where : current_this, \n-\t\t\t    type, DECL_NAME (decl));\n+\t\t\t    (type ? type : DECL_CONTEXT (decl)),\n+\t\t\t    DECL_NAME (decl));\n   return decl;\n }\n \n@@ -6027,10 +6098,12 @@ qualify_ambiguous_name (id)\n \tbreak;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n-      case ARRAY_REF:\n \tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n \tbreak;\n-\n+      case ARRAY_REF:\n+\twhile (TREE_CODE (qual_wfl) == ARRAY_REF)\n+\t  qual_wfl = TREE_OPERAND (qual_wfl, 0);\n+\tbreak;\n       default:\n \t/* Fix for -Wall. Just break doing nothing */\n \tbreak;"}]}