{"sha": "f6919d2011ed694971f54a9e3bfe63ff0fcb864c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY5MTlkMjAxMWVkNjk0OTcxZjU0YTllM2JmZTYzZmYwZmNiODY0Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-09-25T07:30:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-09-25T07:30:56Z"}, "message": "re PR debug/83941 (Debug info generated with -flto contains useless forwarders)\n\n2018-09-25  Richard Biener  <rguenther@suse.de>\n\n\tPR debug/83941\n\t* dwarf2out.c (struct sym_off_pair): New.\n\t(external_die_map): New global.\n\t(lookup_decl_die): When in LTO create DIEs lazily from the\n\texternal_die_map.\n\t(lookup_block_die): New function, create DIEs lazily in LTO.\n\t(equate_block_to_die): New function.\n\t(dwarf2out_die_ref_for_decl): During WPA get the association\n\tfrom the external DIE map.\n\t(dwarf2out_register_external_die): Record mapping into the\n\texternal DIE map.\n\t(maybe_create_die_with_external_ref): New function split out from\n\tDIE generation part of old dwarf2out_register_external_die.\n\t(add_abstract_origin_attribute): Do not return the DIE.  When\n\tin LTO reference externals directly.\n\t(dwarf2out_abstract_function): When in LTO ignore calls for\n\tdecls with external DIEs (already present abstract instances).\n\t(gen_call_site_die): Adjust.\n\t(add_high_low_attributes): Likewise.\n\t(gen_lexical_block_die): Likewise.\n\t(gen_inlined_subroutine_die): Likewie.\n\t(gen_block_die): Likewise.\n\t(dwarf2out_inline_entry): Likewise.\n\t(dwarf2out_early_finish): In LTRANS phase create DW_TAG_imported_unit\n\tDIEs.\n\nFrom-SVN: r264564", "tree": {"sha": "f883dd5aadd59a51a70d9a87975ac982538cb873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f883dd5aadd59a51a70d9a87975ac982538cb873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6919d2011ed694971f54a9e3bfe63ff0fcb864c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6919d2011ed694971f54a9e3bfe63ff0fcb864c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6919d2011ed694971f54a9e3bfe63ff0fcb864c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6919d2011ed694971f54a9e3bfe63ff0fcb864c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59d2702625fc7012c8f89511443b3318fa55dc70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d2702625fc7012c8f89511443b3318fa55dc70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59d2702625fc7012c8f89511443b3318fa55dc70"}], "stats": {"total": 213, "additions": 153, "deletions": 60}, "files": [{"sha": "61422ada6f1383452ec362231bc2bca2224cfe33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6919d2011ed694971f54a9e3bfe63ff0fcb864c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6919d2011ed694971f54a9e3bfe63ff0fcb864c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6919d2011ed694971f54a9e3bfe63ff0fcb864c", "patch": "@@ -1,3 +1,31 @@\n+2018-09-25  Richard Biener  <rguenther@suse.de>\n+\n+\tPR debug/83941\n+\t* dwarf2out.c (struct sym_off_pair): New.\n+\t(external_die_map): New global.\n+\t(lookup_decl_die): When in LTO create DIEs lazily from the\n+\texternal_die_map.\n+\t(lookup_block_die): New function, create DIEs lazily in LTO.\n+\t(equate_block_to_die): New function.\n+\t(dwarf2out_die_ref_for_decl): During WPA get the association\n+\tfrom the external DIE map.\n+\t(dwarf2out_register_external_die): Record mapping into the\n+\texternal DIE map.\n+\t(maybe_create_die_with_external_ref): New function split out from\n+\tDIE generation part of old dwarf2out_register_external_die.\n+\t(add_abstract_origin_attribute): Do not return the DIE.  When\n+\tin LTO reference externals directly.\n+\t(dwarf2out_abstract_function): When in LTO ignore calls for\n+\tdecls with external DIEs (already present abstract instances).\n+\t(gen_call_site_die): Adjust.\n+\t(add_high_low_attributes): Likewise.\n+\t(gen_lexical_block_die): Likewise.\n+\t(gen_inlined_subroutine_die): Likewie.\n+\t(gen_block_die): Likewise.\n+\t(dwarf2out_inline_entry): Likewise.\n+\t(dwarf2out_early_finish): In LTRANS phase create DW_TAG_imported_unit\n+\tDIEs.\n+\n 2018-09-25  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-fnsummary.c (estimate_node_size_and_time): Scale by two"}, {"sha": "6f45794caf6f10e5d5249333dffb3596fed286b8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 125, "deletions": 60, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6919d2011ed694971f54a9e3bfe63ff0fcb864c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6919d2011ed694971f54a9e3bfe63ff0fcb864c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f6919d2011ed694971f54a9e3bfe63ff0fcb864c", "patch": "@@ -3822,7 +3822,7 @@ static inline void add_bit_offset_attribute (dw_die_ref, tree,\n \t\t\t\t\t     struct vlr_context *);\n static void add_bit_size_attribute (dw_die_ref, tree);\n static void add_prototyped_attribute (dw_die_ref, tree);\n-static dw_die_ref add_abstract_origin_attribute (dw_die_ref, tree);\n+static void add_abstract_origin_attribute (dw_die_ref, tree);\n static void add_pure_or_virtual_attribute (dw_die_ref, tree);\n static void add_src_coords_attributes (dw_die_ref, tree);\n static void add_name_and_src_coords_attributes (dw_die_ref, tree, bool = false);\n@@ -5746,6 +5746,14 @@ equate_type_number_to_die (tree type, dw_die_ref type_die)\n   TYPE_SYMTAB_DIE (type) = type_die;\n }\n \n+static dw_die_ref maybe_create_die_with_external_ref (tree);\n+struct GTY(()) sym_off_pair \n+{\n+  const char * GTY((skip)) sym;\n+  unsigned HOST_WIDE_INT off;\n+};\n+static GTY(()) hash_map<tree, sym_off_pair> *external_die_map;\n+\n /* Returns a hash value for X (which really is a die_struct).  */\n \n inline hashval_t\n@@ -5770,7 +5778,11 @@ lookup_decl_die (tree decl)\n   dw_die_ref *die = decl_die_table->find_slot_with_hash (decl, DECL_UID (decl),\n \t\t\t\t\t\t\t NO_INSERT);\n   if (!die)\n-    return NULL;\n+    {\n+      if (in_lto_p)\n+\treturn maybe_create_die_with_external_ref (decl);\n+      return NULL;\n+    }\n   if ((*die)->removed)\n     {\n       decl_die_table->clear_slot (die);\n@@ -5780,6 +5792,27 @@ lookup_decl_die (tree decl)\n }\n \n \n+/* Return the DIE associated with BLOCK.  */\n+\n+static inline dw_die_ref\n+lookup_block_die (tree block)\n+{\n+  dw_die_ref die = BLOCK_DIE (block);\n+  if (!die && in_lto_p)\n+    return maybe_create_die_with_external_ref (block);\n+  return die;\n+}\n+\n+/* Associate DIE with BLOCK.  */\n+\n+static inline void\n+equate_block_to_die (tree block, dw_die_ref die)\n+{\n+  BLOCK_DIE (block) = die;\n+}\n+#undef BLOCK_DIE\n+\n+\n /* For DECL which might have early dwarf output query a SYMBOL + OFFSET\n    style reference.  Return true if we found one refering to a DIE for\n    DECL, otherwise return false.  */\n@@ -5790,32 +5823,27 @@ dwarf2out_die_ref_for_decl (tree decl, const char **sym,\n {\n   dw_die_ref die;\n \n-  if (in_lto_p && !decl_die_table)\n-    return false;\n+  if (in_lto_p)\n+    {\n+      /* During WPA stage and incremental linking we use a hash-map\n+\t to store the decl <-> label + offset map.  */\n+      if (!external_die_map)\n+\treturn false;\n+      sym_off_pair *desc = external_die_map->get (decl);\n+      if (!desc)\n+\treturn false;\n+      *sym = desc->sym;\n+      *off = desc->off;\n+      return true;\n+    }\n \n   if (TREE_CODE (decl) == BLOCK)\n-    die = BLOCK_DIE (decl);\n+    die = lookup_block_die (decl);\n   else\n     die = lookup_decl_die (decl);\n   if (!die)\n     return false;\n \n-  /* During WPA stage and incremental linking we currently use DIEs\n-     to store the decl <-> label + offset map.  That's quite inefficient\n-     but it works for now.  */\n-  if (in_lto_p)\n-    {\n-      dw_die_ref ref = get_AT_ref (die, DW_AT_abstract_origin);\n-      if (!ref)\n-\t{\n-\t  gcc_assert (die == comp_unit_die ());\n-\t  return false;\n-\t}\n-      *off = ref->die_offset;\n-      *sym = ref->die_id.die_symbol;\n-      return true;\n-    }\n-\n   /* Similar to get_ref_die_offset_label, but using the \"correct\"\n      label.  */\n   *off = die->die_offset;\n@@ -5837,6 +5865,8 @@ add_AT_external_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind,\n {\n   /* Create a fake DIE that contains the reference.  Don't use\n      new_die because we don't want to end up in the limbo list.  */\n+  /* ???  We probably want to share these, thus put a ref to the DIE\n+     we create here to the external_die_map entry.  */\n   dw_die_ref ref = new_die_raw (die->die_tag);\n   ref->die_id.die_symbol = IDENTIFIER_POINTER (get_identifier (symbol));\n   ref->die_offset = offset;\n@@ -5854,13 +5884,33 @@ dwarf2out_register_external_die (tree decl, const char *sym,\n   if (debug_info_level == DINFO_LEVEL_NONE)\n     return;\n \n-  if ((flag_wpa\n-       || flag_incremental_link == INCREMENTAL_LINK_LTO) && !decl_die_table)\n-    decl_die_table = hash_table<decl_die_hasher>::create_ggc (1000);\n+  if (!external_die_map)\n+    external_die_map = hash_map<tree, sym_off_pair>::create_ggc (1000);\n+  gcc_checking_assert (!external_die_map->get (decl));\n+  sym_off_pair p = { IDENTIFIER_POINTER (get_identifier (sym)), off };\n+  external_die_map->put (decl, p);\n+}\n+\n+/* If we have a registered external DIE for DECL return a new DIE for\n+   the concrete instance with an appropriate abstract origin.  */\n+\n+static dw_die_ref\n+maybe_create_die_with_external_ref (tree decl)\n+{\n+  if (!external_die_map)\n+    return NULL;\n+  sym_off_pair *desc = external_die_map->get (decl);\n+  if (!desc)\n+    return NULL;\n+\n+  const char *sym = desc->sym;\n+  unsigned HOST_WIDE_INT off = desc->off;\n \n-  dw_die_ref die\n-    = TREE_CODE (decl) == BLOCK ? BLOCK_DIE (decl) : lookup_decl_die (decl);\n+  in_lto_p = false;\n+  dw_die_ref die = (TREE_CODE (decl) == BLOCK\n+\t\t    ? lookup_block_die (decl) : lookup_decl_die (decl));\n   gcc_assert (!die);\n+  in_lto_p = true;\n \n   tree ctx;\n   dw_die_ref parent = NULL;\n@@ -5872,7 +5922,7 @@ dwarf2out_register_external_die (tree decl, const char *sym,\n       /* ???  We do not output DIEs for all scopes thus skip as\n \t many DIEs as needed.  */\n       while (TREE_CODE (ctx) == BLOCK\n-\t     && !BLOCK_DIE (ctx))\n+\t     && !lookup_block_die (ctx))\n \tctx = BLOCK_SUPERCONTEXT (ctx);\n     }\n   else\n@@ -5887,7 +5937,7 @@ dwarf2out_register_external_die (tree decl, const char *sym,\n   if (ctx)\n     {\n       if (TREE_CODE (ctx) == BLOCK)\n-\tparent = BLOCK_DIE (ctx);\n+\tparent = lookup_block_die (ctx);\n       else if (TREE_CODE (ctx) == TRANSLATION_UNIT_DECL\n \t       /* Keep the 1:1 association during WPA.  */\n \t       && !flag_wpa\n@@ -5914,18 +5964,14 @@ dwarf2out_register_external_die (tree decl, const char *sym,\n   switch (TREE_CODE (decl))\n     {\n     case TRANSLATION_UNIT_DECL:\n-      if (! flag_wpa && flag_incremental_link != INCREMENTAL_LINK_LTO)\n-\t{\n-\t  die = comp_unit_die ();\n-\t  dw_die_ref import = new_die (DW_TAG_imported_unit, die, NULL_TREE);\n-\t  add_AT_external_die_ref (import, DW_AT_import, sym, off);\n-\t  /* We re-target all CU decls to the LTRANS CU DIE, so no need\n-\t     to create a DIE for the original CUs.  */\n-\t  return;\n-\t}\n-      /* Keep the 1:1 association during WPA.  */\n-      die = new_die (DW_TAG_compile_unit, NULL, decl);\n-      break;\n+      {\n+\tdie = comp_unit_die ();\n+\tdw_die_ref import = new_die (DW_TAG_imported_unit, die, NULL_TREE);\n+\tadd_AT_external_die_ref (import, DW_AT_import, sym, off);\n+\t/* We re-target all CU decls to the LTRANS CU DIE, so no need\n+\t   to create a DIE for the original CUs.  */\n+\treturn die;\n+      }\n     case NAMESPACE_DECL:\n       if (is_fortran (decl))\n \tdie = new_die (DW_TAG_module, parent, decl);\n@@ -5957,14 +6003,16 @@ dwarf2out_register_external_die (tree decl, const char *sym,\n       gcc_unreachable ();\n     }\n   if (TREE_CODE (decl) == BLOCK)\n-    BLOCK_DIE (decl) = die;\n+    equate_block_to_die (decl, die);\n   else\n     equate_decl_number_to_die (decl, die);\n \n   add_desc_attribute (die, decl);\n \n   /* Add a reference to the DIE providing early debug at $sym + off.  */\n   add_AT_external_die_ref (die, DW_AT_abstract_origin, sym, off);\n+\n+  return die;\n }\n \n /* Returns a hash value for X (which really is a var_loc_list).  */\n@@ -21081,28 +21129,28 @@ add_prototyped_attribute (dw_die_ref die, tree func_type)\n    by looking in the type declaration, the object declaration equate table or\n    the block mapping.  */\n \n-static inline dw_die_ref\n+static inline void\n add_abstract_origin_attribute (dw_die_ref die, tree origin)\n {\n   dw_die_ref origin_die = NULL;\n \n   if (DECL_P (origin))\n     {\n-      dw_die_ref c;\n-      origin_die = lookup_decl_die (origin);\n-      /* \"Unwrap\" the decls DIE which we put in the imported unit context.\n-         We are looking for the abstract copy here.  */\n+      sym_off_pair *desc;\n       if (in_lto_p\n-\t  && origin_die\n-\t  && (c = get_AT_ref (origin_die, DW_AT_abstract_origin))\n-\t  /* ???  Identify this better.  */\n-\t  && c->with_offset)\n-\torigin_die = c;\n+\t  && external_die_map\n+\t  && (desc = external_die_map->get (origin)))\n+\t{\n+\t  add_AT_external_die_ref (die, DW_AT_abstract_origin,\n+\t\t\t\t   desc->sym, desc->off);\n+\t  return;\n+\t}\n+      origin_die = lookup_decl_die (origin);\n     }\n   else if (TYPE_P (origin))\n     origin_die = lookup_type_die (origin);\n   else if (TREE_CODE (origin) == BLOCK)\n-    origin_die = BLOCK_DIE (origin);\n+    origin_die = lookup_block_die (origin);\n \n   /* XXX: Functions that are never lowered don't always have correct block\n      trees (in the case of java, they simply have no block tree, in some other\n@@ -21115,7 +21163,6 @@ add_abstract_origin_attribute (dw_die_ref die, tree origin)\n \n   if (origin_die)\n     add_AT_die_ref (die, DW_AT_abstract_origin, origin_die);\n-  return origin_die;\n }\n \n /* We do not currently support the pure_virtual attribute.  */\n@@ -22411,6 +22458,13 @@ dwarf2out_abstract_function (tree decl)\n   if (DECL_IGNORED_P (decl))\n     return;\n \n+  /* Do not lazily create a DIE for decl here just because we\n+     got called via debug_hooks->outlining_inline_function.  */\n+  if (in_lto_p\n+      && external_die_map\n+      && external_die_map->get (decl))\n+    return;\n+\n   old_die = lookup_decl_die (decl);\n   /* With early debug we always have an old DIE unless we are in LTO\n      and the user did not compile but only link with debug.  */\n@@ -22529,7 +22583,7 @@ gen_call_site_die (tree decl, dw_die_ref subr_die,\n \t && block != DECL_INITIAL (decl)\n \t && TREE_CODE (block) == BLOCK)\n     {\n-      stmt_die = BLOCK_DIE (block);\n+      stmt_die = lookup_block_die (block);\n       if (stmt_die)\n \tbreak;\n       block = BLOCK_SUPERCONTEXT (block);\n@@ -24011,12 +24065,12 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n static void\n gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n {\n-  dw_die_ref old_die = BLOCK_DIE (stmt);\n+  dw_die_ref old_die = lookup_block_die (stmt);\n   dw_die_ref stmt_die = NULL;\n   if (!old_die)\n     {\n       stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n-      BLOCK_DIE (stmt) = stmt_die;\n+      equate_block_to_die (stmt, stmt_die);\n     }\n \n   if (BLOCK_ABSTRACT (stmt))\n@@ -24044,7 +24098,7 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n       if (old_die)\n \t{\n \t  stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n-\t  BLOCK_DIE (stmt) = stmt_die;\n+\t  equate_block_to_die (stmt, stmt_die);\n \t  old_die = NULL;\n \t}\n \n@@ -24091,7 +24145,7 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die)\n \t= new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n \n       if (call_arg_locations || debug_inline_points)\n-\tBLOCK_DIE (stmt) = subr_die;\n+\tequate_block_to_die (stmt, subr_die);\n       add_abstract_origin_attribute (subr_die, decl);\n       if (TREE_ASM_WRITTEN (stmt))\n         add_high_low_attributes (stmt, subr_die);\n@@ -25591,7 +25645,7 @@ gen_block_die (tree stmt, dw_die_ref context_die)\n     /* The outer scopes for inlinings *must* always be represented.  We\n        generate DW_TAG_inlined_subroutine DIEs for them.  (See below.) */\n     must_output_die = 1;\n-  else if (BLOCK_DIE (stmt))\n+  else if (lookup_block_die (stmt))\n     /* If we already have a DIE then it was filled early.  Meanwhile\n        we might have pruned all BLOCK_VARS as optimized out but we\n        still want to generate high/low PC attributes so output it.  */\n@@ -27422,7 +27476,7 @@ dwarf2out_inline_entry (tree block)\n \t\t\t\t      true));\n \n   gcc_assert (inlined_function_outer_scope_p (block));\n-  gcc_assert (!BLOCK_DIE (block));\n+  gcc_assert (!lookup_block_die (block));\n \n   if (BLOCK_FRAGMENT_ORIGIN (block))\n     block = BLOCK_FRAGMENT_ORIGIN (block);\n@@ -31846,6 +31900,17 @@ dwarf2out_early_finish (const char *filename)\n      sure to adjust the phase after annotating the LTRANS CU DIE.  */\n   if (in_lto_p)\n     {\n+      /* Force DW_TAG_imported_unit to be created now, otherwise\n+\t we might end up without it or ordered after DW_TAG_inlined_subroutine\n+\t referencing DIEs from it.  */\n+      if (! flag_wpa && flag_incremental_link != INCREMENTAL_LINK_LTO)\n+\t{\n+\t  unsigned i;\n+\t  tree tu;\n+\t  FOR_EACH_VEC_SAFE_ELT (all_translation_units, i, tu)\n+\t    maybe_create_die_with_external_ref (tu);\n+\t}\n+\n       early_dwarf_finished = true;\n       if (dump_file)\n \t{"}]}