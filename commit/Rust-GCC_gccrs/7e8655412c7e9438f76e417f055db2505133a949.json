{"sha": "7e8655412c7e9438f76e417f055db2505133a949", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4NjU1NDEyYzdlOTQzOGY3NmU0MTdmMDU1ZGIyNTA1MTMzYTk0OQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2015-05-16T16:50:30Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2015-05-16T16:50:30Z"}, "message": "d-demangle.c (dlang_symbol_kinds): New enum.\n\nlibiberty/ChangeLog:\n\n2015-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* d-demangle.c (dlang_symbol_kinds): New enum.\n\t(dlang_parse_symbol): Update signature.  Handle an ambiguity between\n\tpascal functions and template value arguments.  Only check for a type\n\tif parsing a function, or at the top level.  Return failure if the\n\tentire symbol was not successfully demangled.\n\t(dlang_identifier): Update signature.  Handle an ambiguity between two\n\tadjacent digits in a mangled symbol string.\n\t(dlang_type): Update call to dlang_parse_symbol.\n\t(dlang_template_args): Likewise.\n\t(dlang_parse_template): Likewise.\n\t(dlang_demangle): Likewise.\n\t* testsuite/d-demangle-expected: Fix bad tests found, and add problematic\n\texamples to the unittests.\n\nFrom-SVN: r223247", "tree": {"sha": "6c4ad6555ca0523a18e5f1e64bfc11529480e27a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c4ad6555ca0523a18e5f1e64bfc11529480e27a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e8655412c7e9438f76e417f055db2505133a949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8655412c7e9438f76e417f055db2505133a949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8655412c7e9438f76e417f055db2505133a949", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8655412c7e9438f76e417f055db2505133a949/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed4cdb8502c67b7cafa4d939a52d4ac6ac1db65d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed4cdb8502c67b7cafa4d939a52d4ac6ac1db65d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed4cdb8502c67b7cafa4d939a52d4ac6ac1db65d"}], "stats": {"total": 247, "additions": 190, "deletions": 57}, "files": [{"sha": "d5ba3d437605c4b640c753ec1ab3c814b4551957", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8655412c7e9438f76e417f055db2505133a949/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8655412c7e9438f76e417f055db2505133a949/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=7e8655412c7e9438f76e417f055db2505133a949", "patch": "@@ -1,3 +1,19 @@\n+2015-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* d-demangle.c (dlang_symbol_kinds): New enum.\n+\t(dlang_parse_symbol): Update signature.  Handle an ambiguity between\n+\tpascal functions and template value arguments.  Only check for a type\n+\tif parsing a function, or at the top level.  Return failure if the\n+\tentire symbol was not successfully demangled.\n+\t(dlang_identifier): Update signature.  Handle an ambiguity between two\n+\tadjacent digits in a mangled symbol string.\n+\t(dlang_type): Update call to dlang_parse_symbol.\n+\t(dlang_template_args): Likewise.\n+\t(dlang_parse_template): Likewise.\n+\t(dlang_demangle): Likewise.\n+\t* testsuite/d-demangle-expected: Fix bad tests found, and add problematic\n+\texamples to the unittests.\n+\n 2015-05-16  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* d-demangle.c (dlang_template_args): Skip over specialized template"}, {"sha": "a2a3b32af6a91a9be7eed56a511ca714314645ac", "filename": "libiberty/d-demangle.c", "status": "modified", "additions": 141, "deletions": 44, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8655412c7e9438f76e417f055db2505133a949/libiberty%2Fd-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8655412c7e9438f76e417f055db2505133a949/libiberty%2Fd-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fd-demangle.c?ref=7e8655412c7e9438f76e417f055db2505133a949", "patch": "@@ -165,14 +165,30 @@ string_prepend (string *p, const char *s)\n     }\n }\n \n+/* What kinds of symbol we could be parsing.  */\n+enum dlang_symbol_kinds\n+{\n+  /* Top-level symbol, needs it's type checked.  */\n+  dlang_top_level,\n+  /* Function symbol, needs it's type checked.   */\n+  dlang_function,\n+  /* Strongly typed name, such as for classes, structs and enums.  */\n+  dlang_type_name,\n+  /* Template identifier.  */\n+  dlang_template_ident,\n+  /* Template symbol parameter.  */\n+  dlang_template_param\n+};\n+\n /* Prototypes for forward referenced functions */\n static const char *dlang_function_args (string *, const char *);\n \n static const char *dlang_type (string *, const char *);\n \n static const char *dlang_value (string *, const char *, const char *, char);\n \n-static const char *dlang_parse_symbol (string *, const char *);\n+static const char *dlang_parse_symbol (string *, const char *,\n+\t\t\t\t       enum dlang_symbol_kinds);\n \n static const char *dlang_parse_tuple (string *, const char *);\n \n@@ -527,7 +543,7 @@ dlang_type (string *decl, const char *mangled)\n     case 'E': /* enum T */\n     case 'T': /* typedef T */\n       mangled++;\n-      return dlang_parse_symbol (decl, mangled);\n+      return dlang_parse_symbol (decl, mangled, dlang_type_name);\n     case 'D': /* delegate T */\n     {\n       string mods;\n@@ -676,114 +692,162 @@ dlang_type (string *decl, const char *mangled)\n /* Extract the identifier from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_identifier (string *decl, const char *mangled)\n+dlang_identifier (string *decl, const char *mangled,\n+\t\t  enum dlang_symbol_kinds kind)\n {\n+  char *endptr;\n+  long len;\n+\n   if (mangled == NULL || *mangled == '\\0')\n     return NULL;\n \n-  if (ISDIGIT (*mangled))\n+  len = strtol (mangled, &endptr, 10);\n+\n+  if (endptr == NULL || len <= 0)\n+    return NULL;\n+\n+  /* In template parameter symbols, the first character of the mangled\n+     name can be a digit.  This causes ambiguity issues because the\n+     digits of the two numbers are adjacent.  */\n+  if (kind == dlang_template_param)\n     {\n-      char *endptr;\n-      long i = strtol (mangled, &endptr, 10);\n+      long psize = len;\n+      char *pend;\n+      int saved = string_length (decl);\n+\n+      /* Work backwards until a match is found.  */\n+      for (pend = endptr; endptr != NULL; pend--)\n+\t{\n+\t  mangled = pend;\n \n-      if (endptr == NULL || i <= 0 || strlen (endptr) < (size_t) i)\n+\t  /* Reached the beginning of the pointer to the name length,\n+\t     try parsing the entire symbol.  */\n+\t  if (psize == 0)\n+\t    {\n+\t      psize = len;\n+\t      pend = endptr;\n+\t      endptr = NULL;\n+\t    }\n+\n+\t  /* Check whether template parameter is a function with a valid\n+\t     return type or an untyped identifier.  */\n+\t  if (ISDIGIT (*mangled))\n+\t    mangled = dlang_parse_symbol (decl, mangled, dlang_template_ident);\n+\t  else if (strncmp (mangled, \"_D\", 2) == 0)\n+\t    {\n+\t      mangled += 2;\n+\t      mangled = dlang_parse_symbol (decl, mangled, dlang_function);\n+\t    }\n+\n+\t  /* Check for name length mismatch.  */\n+\t  if (mangled && (mangled - pend) == psize)\n+\t    return mangled;\n+\n+\t  psize /= 10;\n+\t  string_setlength (decl, saved);\n+\t}\n+\n+      /* No match on any combinations.  */\n+      return NULL;\n+    }\n+  else\n+    {\n+      if (strlen (endptr) < (size_t) len)\n \treturn NULL;\n \n       mangled = endptr;\n \n       /* May be a template instance.  */\n-      if (i >= 5 && strncmp (mangled, \"__T\", 3) == 0)\n+      if (len >= 5 && strncmp (mangled, \"__T\", 3) == 0)\n \t{\n \t  /* Template symbol.  */\n \t  if (ISDIGIT (mangled[3]) && mangled[3] != '0')\n-\t    return dlang_parse_template (decl, mangled, i);\n+\t    return dlang_parse_template (decl, mangled, len);\n \n \t  return NULL;\n \t}\n \n-      switch (i)\n+      switch (len)\n \t{\n \tcase 6:\n-\t  if (strncmp (mangled, \"__ctor\", i) == 0)\n+\t  if (strncmp (mangled, \"__ctor\", len) == 0)\n \t    {\n \t      /* Constructor symbol for a class/struct.  */\n \t      string_append (decl, \"this\");\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n-\t  else if (strncmp (mangled, \"__dtor\", i) == 0)\n+\t  else if (strncmp (mangled, \"__dtor\", len) == 0)\n \t    {\n \t      /* Destructor symbol for a class/struct.  */\n \t      string_append (decl, \"~this\");\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n-\t  else if (strncmp (mangled, \"__initZ\", i+1) == 0)\n+\t  else if (strncmp (mangled, \"__initZ\", len+1) == 0)\n \t    {\n \t      /* The static initialiser for a given symbol.  */\n \t      string_append (decl, \"init$\");\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n-\t  else if (strncmp (mangled, \"__vtblZ\", i+1) == 0)\n+\t  else if (strncmp (mangled, \"__vtblZ\", len+1) == 0)\n \t    {\n \t      /* The vtable symbol for a given class.  */\n \t      string_prepend (decl, \"vtable for \");\n \t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n \t  break;\n \n \tcase 7:\n-\t  if (strncmp (mangled, \"__ClassZ\", i+1) == 0)\n+\t  if (strncmp (mangled, \"__ClassZ\", len+1) == 0)\n \t    {\n \t      /* The classinfo symbol for a given class.  */\n \t      string_prepend (decl, \"ClassInfo for \");\n \t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n \t  break;\n \n \tcase 10:\n-\t  if (strncmp (mangled, \"__postblitMFZ\", i+3) == 0)\n+\t  if (strncmp (mangled, \"__postblitMFZ\", len+3) == 0)\n \t    {\n \t      /* Postblit symbol for a struct.  */\n \t      string_append (decl, \"this(this)\");\n-\t      mangled += i + 3;\n+\t      mangled += len + 3;\n \t      return mangled;\n \t    }\n \t  break;\n \n \tcase 11:\n-\t  if (strncmp (mangled, \"__InterfaceZ\", i+1) == 0)\n+\t  if (strncmp (mangled, \"__InterfaceZ\", len+1) == 0)\n \t    {\n \t      /* The interface symbol for a given class.  */\n \t      string_prepend (decl, \"Interface for \");\n \t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n \t  break;\n \n \tcase 12:\n-\t  if (strncmp (mangled, \"__ModuleInfoZ\", i+1) == 0)\n+\t  if (strncmp (mangled, \"__ModuleInfoZ\", len+1) == 0)\n \t    {\n \t      /* The ModuleInfo symbol for a given module.  */\n \t      string_prepend (decl, \"ModuleInfo for \");\n \t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += i;\n+\t      mangled += len;\n \t      return mangled;\n \t    }\n \t  break;\n \t}\n \n-      string_appendn (decl, mangled, i);\n-      mangled += i;\n+      string_appendn (decl, mangled, len);\n+      mangled += len;\n     }\n-  else\n-    return NULL;\n \n   return mangled;\n }\n@@ -1288,25 +1352,38 @@ dlang_call_convention_p (const char *mangled)\n /* Extract and demangle the symbol in MANGLED and append it to DECL.\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n-dlang_parse_symbol (string *decl, const char *mangled)\n+dlang_parse_symbol (string *decl, const char *mangled,\n+\t\t    enum dlang_symbol_kinds kind)\n {\n+  int saved;\n   size_t n = 0;\n   do\n     {\n       if (n++)\n \tstring_append (decl, \".\");\n \n-      mangled = dlang_identifier (decl, mangled);\n+      mangled = dlang_identifier (decl, mangled, kind);\n \n       if (mangled && dlang_call_convention_p (mangled))\n \t{\n \t  string mods;\n-\t  int saved;\n+\t  const char *start = NULL;\n+\t  int checkpoint = 0;\n \n \t  /* Skip over 'this' parameter.  */\n \t  if (*mangled == 'M')\n \t    mangled++;\n \n+\t  /* We have reached here because we expect an extern(Pascal) function.\n+\t     However this is so rare, that it is more likely a template value\n+\t     parameter.  Since this can't be assumed, first attempt parsing\n+\t     the symbol as a function, and then back out on failure.  */\n+\t  if (*mangled == 'V')\n+\t    {\n+\t      start = mangled;\n+\t      checkpoint = string_length (decl);\n+\t    }\n+\n \t  /* Save the type modifiers for appending at the end.  */\n \t  string_init (&mods);\n \t  mangled = dlang_type_modifiers (&mods, mangled);\n@@ -1321,21 +1398,41 @@ dlang_parse_symbol (string *decl, const char *mangled)\n \t  mangled = dlang_function_args (decl, mangled);\n \t  string_append (decl, \")\");\n \n-\t  /* Demangle the function return type as a kind of sanity test.  */\n-\t  if (mangled && !ISDIGIT (*mangled))\n-\t    {\n-\t      saved = string_length (decl);\n-\t      mangled = dlang_type (decl, mangled);\n-\t      string_setlength (decl, saved);\n-\t    }\n-\n \t  /* Add any const/immutable/shared modifier. */\n \t  string_appendn (decl, mods.b, string_length (&mods));\n \t  string_delete (&mods);\n+\n+\t  if (mangled == NULL && checkpoint != 0)\n+\t    {\n+\t      mangled = start;\n+\t      string_setlength (decl, checkpoint);\n+\t    }\n \t}\n     }\n   while (mangled && ISDIGIT (*mangled));\n \n+  /* Only top-level symbols or function template parameters have\n+     a type that needs checking.  */\n+  if (kind == dlang_top_level || kind == dlang_function)\n+    {\n+      /* Artificial symbols end with 'Z' and have no type.  */\n+      if (mangled && *mangled == 'Z')\n+\tmangled++;\n+      else\n+\t{\n+\t  saved = string_length (decl);\n+\t  mangled = dlang_type (decl, mangled);\n+\t  string_setlength (decl, saved);\n+\t}\n+\n+      /* Check that the entire symbol was successfully demangled.  */\n+      if (kind == dlang_top_level)\n+\t{\n+\t  if (mangled == NULL || *mangled != '\\0')\n+\t    return NULL;\n+\t}\n+    }\n+\n   return mangled;\n }\n \n@@ -1391,7 +1488,7 @@ dlang_template_args (string *decl, const char *mangled)\n \t{\n \tcase 'S': /* Symbol parameter.  */\n \t  mangled++;\n-\t  mangled = dlang_parse_symbol (decl, mangled);\n+\t  mangled = dlang_parse_symbol (decl, mangled, dlang_template_param);\n \t  break;\n \tcase 'T': /* Type parameter.  */\n \t  mangled++;\n@@ -1449,7 +1546,7 @@ dlang_parse_template (string *decl, const char *mangled, long len)\n   mangled += 3;\n \n   /* Template identifier.  */\n-  mangled = dlang_identifier (decl, mangled);\n+  mangled = dlang_identifier (decl, mangled, dlang_template_ident);\n \n   /* Template arguments.  */\n   string_append (decl, \"!(\");\n@@ -1488,7 +1585,7 @@ dlang_demangle (const char *mangled, int option ATTRIBUTE_UNUSED)\n     {\n       mangled += 2;\n \n-      if (dlang_parse_symbol (&decl, mangled) == NULL)\n+      if (dlang_parse_symbol (&decl, mangled, dlang_top_level) == NULL)\n \tstring_delete (&decl);\n     }\n "}, {"sha": "6c8ccdff4b539c43f296ce48ffb6f1b72b4f1d94", "filename": "libiberty/testsuite/d-demangle-expected", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8655412c7e9438f76e417f055db2505133a949/libiberty%2Ftestsuite%2Fd-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8655412c7e9438f76e417f055db2505133a949/libiberty%2Ftestsuite%2Fd-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fd-demangle-expected?ref=7e8655412c7e9438f76e417f055db2505133a949", "patch": "@@ -614,12 +614,12 @@ _D8demangle17__T4testS6symbolZv\n demangle.test!(symbol)\n #\n --format=dlang\n-_D8demangle21__T4testS6symbol3fooZv\n+_D8demangle23__T4testS116symbol3fooZv\n demangle.test!(symbol.foo)\n #\n --format=dlang\n-_D8demangle25__T4testS6symbol3foo3barZv\n-demangle.test!(symbol.foo.bar)\n+_D8demangle32__T4testS20_D6symbol3foo3barFZvZv\n+demangle.test!(symbol.foo.bar())\n #\n --format=dlang\n _D8demangle19__T4testTaS6symbolZv\n@@ -932,19 +932,19 @@ _D6plugin8generateFiiZAOa\n plugin.generate(int, int)\n #\n --format=dlang\n-_D8demangle3fnAFZv3fnBMFZv\n+_D8demangle3fnAFZ3fnBMFZv\n demangle.fnA().fnB()\n #\n --format=dlang\n-_D8demangle4mainFZv1S3fnCFZv\n+_D8demangle4mainFZ1S3fnCMFZv\n demangle.main().S.fnC()\n #\n --format=dlang\n-_D8demangle4mainFZv1S3fnDMFZv\n+_D8demangle4mainFZ1S3fnDMFZv\n demangle.main().S.fnD()\n #\n --format=dlang\n-_D8demangle4mainFZv5localMFZi\n+_D8demangle4mainFZ5localMFZi\n demangle.main().local()\n #\n --format=dlang\n@@ -988,7 +988,7 @@ _D6object14TypeInfo_Array8argTypesMFNbNfJC8TypeInfoJC8TypeInfoZi\n object.TypeInfo_Array.argTypes(out TypeInfo, out TypeInfo)\n #\n --format=dlang\n-_D2rt6dmain211_d_run_mainUiPPaPUAAaZiZi7tryExecMFMDFZvZv\n+_D2rt6dmain211_d_run_mainUiPPaPUAAaZiZ7tryExecMFMDFZvZv\n rt.dmain2._d_run_main(int, char**, extern(C) int(char[][]) function*).tryExec(scope void() delegate)\n #\n --format=dlang\n@@ -1044,17 +1044,37 @@ _D2gc11gctemplates56__T8mkBitmapTS3std5range13__T4iotaTiTiZ4iotaFiiZ6ResultZ8mkB\n gc.gctemplates.mkBitmap!(std.range.iota!(int, int).iota(int, int).Result).mkBitmap(ulong*, ulong)\n #\n --format=dlang\n-_D8serenity9persister6Sqlite70__T15SqlitePersisterTS8serenity9persister6Sqlite11__unittest6FZv4TestZ15SqlitePersister12__T7opIndexZ7opIndexMFmZS8serenity9persister6Sqlite11__unittest6FZv4Test\n+_D8serenity9persister6Sqlite69__T15SqlitePersisterTS8serenity9persister6Sqlite11__unittest6FZ4TestZ15SqlitePersister12__T7opIndexZ7opIndexMFmZS8serenity9persister6Sqlite11__unittest6FZ4Test\n serenity.persister.Sqlite.SqlitePersister!(serenity.persister.Sqlite.__unittest6().Test).SqlitePersister.opIndex!().opIndex(ulong)\n #\n --format=dlang\n-_D4test4mainFZv5localMFZi\n-test.main().local()\n-#\n---format=dlang\n _D3std6socket12InternetHost221__T13getHostNoSyncVAyaa96_0a09202020206175746f2078203d2068746f6e6c28706172616d293b0a09202020206175746f206865203d20676574686f73746279616464722826782c20342c206361737428696e74294164647265737346616d696c792e494e4554293b0a09TkZ13getHostNoSyncMFkZb\n std.socket.InternetHost.getHostNoSync!(\"\\n\\t    auto x = htonl(param);\\n\\t    auto he = gethostbyaddr(&x, 4, cast(int)AddressFamily.INET);\\n\\t\", uint).getHostNoSync(uint)\n #\n --format=dlang\n _D2gc6config13__T5parseHTfZ5parseFNbNiAxaKAxaKfZb\n gc.config.parse!(float).parse(const(char)[], ref const(char)[], ref float)\n+#\n+--format=dlang\n+_D3std11parallelism273__T4TaskS213std11parallelism3runTDFS3std9algorithm87__T9MapResultS27_D4test4mainFZ7getTermMFiZeTS3std5range13__T4iotaTiTiZ4iotaFiiZ6ResultZ9MapResultmmZeTS3std9algorithm87__T9MapResultS27_D4test4mainFZ7getTermMFiZeTS3std5range13__T4iotaTiTiZ4iotaFiiZ6ResultZ9MapResultTmTmZ4Task4implFPvZv\n+std.parallelism.Task!(std.parallelism.run, real(std.algorithm.MapResult!(test.main().getTerm(int), std.range.iota!(int, int).iota(int, int).Result).MapResult, ulong, ulong) delegate, std.algorithm.MapResult!(test.main().getTerm(int), std.range.iota!(int, int).iota(int, int).Result).MapResult, ulong, ulong).Task.impl(void*)\n+#\n+--format=dlang\n+_D2rt5minfo16__unittestL518_6FZ12UTModuleInfo6__ctorMFNckZS2rt5minfo16__unittestL518_6FZ12UTModuleInfo\n+rt.minfo.__unittestL518_6().UTModuleInfo.this(uint)\n+#\n+--format=dlang\n+_D3std6traits37__T7fqnTypeTC6ObjectVbi0Vbi0Vbi0Vbi0Z13addQualifiersFAyabbbbZAya\n+std.traits.fqnType!(Object, false, false, false, false).addQualifiers(immutable(char)[], bool, bool, bool, bool)\n+#\n+--format=dlang\n+_D3std9algorithm117__T9MapResultS153std5range4onlyTS3std9algorithm53__T12FilterResultS28_D3std3uni7isUpperFNaNbNfwZbTAyaZ12FilterResultZ9MapResult5frontMFNaNdNfZS3std5range22__T10OnlyResultTwVmi1Z10OnlyResult\n+std.algorithm.MapResult!(std.range.only, std.algorithm.FilterResult!(std.uni.isUpper(dchar), immutable(char)[]).FilterResult).MapResult.front()\n+#\n+--format=dlang\n+_D3std6traits17__T6fqnSymS43stdZ11adjustIdentFAyaZAya\n+std.traits.fqnSym!(std).adjustIdent(immutable(char)[])\n+#\n+--format=dlang\n+_D2rt8lifetime36__T14_d_newarrayOpTS13_d_newarrayiTZ14_d_newarrayOpTFNaNbxC8TypeInfomPmZAv\n+rt.lifetime._d_newarrayOpT!(_d_newarrayiT)._d_newarrayOpT(const(TypeInfo), ulong, ulong*)"}]}