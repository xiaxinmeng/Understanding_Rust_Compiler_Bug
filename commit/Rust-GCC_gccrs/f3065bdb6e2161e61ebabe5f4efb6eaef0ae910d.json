{"sha": "f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMwNjViZGI2ZTIxNjFlNjFlYmFiZTVmNGVmYjZlYWVmMGFlOTEwZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-04-12T06:20:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-04-12T06:20:36Z"}, "message": "opts.c: Include diagnostic-color.h.\n\n\t* opts.c: Include diagnostic-color.h.\n\t(common_handle_option): Handle OPT_fdiagnostics_color_.\n\t* Makefile.in (OBJS-libcommon): Add diagnostic-color.o.\n\t(diagnostic.o, opts.o, pretty-print.o): Depend on diagnostic-color.h.\n\t(diagnostic-color.o): New.\n\t* common.opt (fdiagnostics-color, fdiagnostics-color=): New options.\n\t(diagnostic_color_rule): New enum.\n\t* dwarf2out.c (gen_producer_string): Don't print -fdiagnostics-color*.\n\t* langhooks.c (lhd_print_error_function): Add %r \"locus\" and %R around\n\tthe location string.\n\t* diagnostic.def: Add 3rd argument to DEFINE_DIAGNOSTIC_KIND macros,\n\teither NULL, or color kind.\n\t* diagnostic-color.c: New file.\n\t* diagnostic-color.h: New file.\n\t* diagnostic-core.h (DEFINE_DIAGNOSTIC_KIND): Adjust macro for 3\n\targuments.\n\t* doc/invoke.texi (-fdiagnostics-color): Document.\n\t* pretty-print.h (pp_show_color): Define.\n\t(struct pretty_print_info): Add show_color field.\n\t* diagnostic.c: Include diagnostic-color.h.\n\t(diagnostic_build_prefix): Adjust for 3 argument DEFINE_DIAGNOSTIC_KIND\n\tmacros.  Colorize error:, warning: etc. strings and also the location\n\tstring.\n\t(diagnostic_show_locus): Colorize the caret line.\n\t* pretty-print.c: Include diagnostic-color.h.\n\t(pp_base_format): Handle %r and %R format specifiers.  Colorize strings\n\tinside of %< %> quotes or quoted through q format modifier.\nc-family/\n\t* c-format.c (gcc_diag_char_table, gcc_tdiag_char_table,\n\tgcc_cdiag_char_table, gcc_cxxdiag_char_table): Add %r and %R format\n\tspecifiers.\ncp/\n\t* error.c (cp_print_error_function,\n\tprint_instantiation_partial_context_line,\n\tmaybe_print_constexpr_context): Colorize locus strings.\n\nFrom-SVN: r197842", "tree": {"sha": "ab5a7c6ce0bc1945a5d6a869ec16bae2b8848b7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab5a7c6ce0bc1945a5d6a869ec16bae2b8848b7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d/comments", "author": null, "committer": null, "parents": [{"sha": "4b84d650e82e29bd3ff901a1e34b08435ee99871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b84d650e82e29bd3ff901a1e34b08435ee99871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b84d650e82e29bd3ff901a1e34b08435ee99871"}], "stats": {"total": 373, "additions": 373, "deletions": 0}, "files": [{"sha": "8680b504af52a5af70dc57fd4f540d5f0adca61d", "filename": "gcc/diagnostic-color.c", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d", "patch": "@@ -0,0 +1,307 @@\n+/* Output colorization.\n+   Copyright 2011-2013 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"diagnostic-color.h\"\n+\n+/* Select Graphic Rendition (SGR, \"\\33[...m\") strings.  */\n+/* Also Erase in Line (EL) to Right (\"\\33[K\") by default.  */\n+/*    Why have EL to Right after SGR?\n+\t -- The behavior of line-wrapping when at the bottom of the\n+\t    terminal screen and at the end of the current line is often\n+\t    such that a new line is introduced, entirely cleared with\n+\t    the current background color which may be different from the\n+\t    default one (see the boolean back_color_erase terminfo(5)\n+\t    capability), thus scrolling the display by one line.\n+\t    The end of this new line will stay in this background color\n+\t    even after reverting to the default background color with\n+\t    \"\\33[m', unless it is explicitly cleared again with \"\\33[K\"\n+\t    (which is the behavior the user would instinctively expect\n+\t    from the whole thing).  There may be some unavoidable\n+\t    background-color flicker at the end of this new line because\n+\t    of this (when timing with the monitor's redraw is just right).\n+\t -- The behavior of HT (tab, \"\\t\") is usually the same as that of\n+\t    Cursor Forward Tabulation (CHT) with a default parameter\n+\t    of 1 (\"\\33[I\"), i.e., it performs pure movement to the next\n+\t    tab stop, without any clearing of either content or screen\n+\t    attributes (including background color); try\n+\t       printf 'asdfqwerzxcv\\rASDF\\tZXCV\\n'\n+\t    in a bash(1) shell to demonstrate this.  This is not what the\n+\t    user would instinctively expect of HT (but is ok for CHT).\n+\t    The instinctive behavior would include clearing the terminal\n+\t    cells that are skipped over by HT with blank cells in the\n+\t    current screen attributes, including background color;\n+\t    the boolean dest_tabs_magic_smso terminfo(5) capability\n+\t    indicates this saner behavior for HT, but only some rare\n+\t    terminals have it (although it also indicates a special\n+\t    glitch with standout mode in the Teleray terminal for which\n+\t    it was initially introduced).  The remedy is to add \"\\33K\"\n+\t    after each SGR sequence, be it START (to fix the behavior\n+\t    of any HT after that before another SGR) or END (to fix the\n+\t    behavior of an HT in default background color that would\n+\t    follow a line-wrapping at the bottom of the screen in another\n+\t    background color, and to complement doing it after START).\n+\t    Piping GCC's output through a pager such as less(1) avoids\n+\t    any HT problems since the pager performs tab expansion.\n+\n+      Generic disadvantages of this remedy are:\n+\t -- Some very rare terminals might support SGR but not EL (nobody\n+\t    will use \"gcc -fdiagnostics-color\" on a terminal that does not\n+\t    support SGR in the first place).\n+\t -- Having these extra control sequences might somewhat complicate\n+\t    the task of any program trying to parse \"gcc -fdiagnostics-color\"\n+\t    output in order to extract structuring information from it.\n+      A specific disadvantage to doing it after SGR START is:\n+\t -- Even more possible background color flicker (when timing\n+\t    with the monitor's redraw is just right), even when not at the\n+\t    bottom of the screen.\n+      There are no additional disadvantages specific to doing it after\n+      SGR END.\n+\n+      It would be impractical for GCC to become a full-fledged\n+      terminal program linked against ncurses or the like, so it will\n+      not detect terminfo(5) capabilities.  */\n+#define COLOR_SEPARATOR\t\t\";\"\n+#define COLOR_NONE\t\t\"00\"\n+#define COLOR_BOLD\t\t\"01\"\n+#define COLOR_UNDERSCORE\t\"04\"\n+#define COLOR_BLINK\t\t\"05\"\n+#define COLOR_REVERSE\t\t\"07\"\n+#define COLOR_FG_BLACK\t\t\"30\"\n+#define COLOR_FG_RED\t\t\"31\"\n+#define COLOR_FG_GREEN\t\t\"32\"\n+#define COLOR_FG_YELLOW\t\t\"33\"\n+#define COLOR_FG_BLUE\t\t\"34\"\n+#define COLOR_FG_MAGENTA\t\"35\"\n+#define COLOR_FG_CYAN\t\t\"36\"\n+#define COLOR_FG_WHITE\t\t\"37\"\n+#define COLOR_BG_BLACK\t\t\"40\"\n+#define COLOR_BG_RED\t\t\"41\"\n+#define COLOR_BG_GREEN\t\t\"42\"\n+#define COLOR_BG_YELLOW\t\t\"43\"\n+#define COLOR_BG_BLUE\t\t\"44\"\n+#define COLOR_BG_MAGENTA\t\"45\"\n+#define COLOR_BG_CYAN\t\t\"46\"\n+#define COLOR_BG_WHITE\t\t\"47\"\n+#define SGR_START\t\t\"\\33[\"\n+#define SGR_END\t\t\t\"m\\33[K\"\n+#define SGR_SEQ(str)\t\tSGR_START str SGR_END\n+#define SGR_RESET\t\tSGR_SEQ(\"\")\n+\n+\n+/* The context and logic for choosing default --color screen attributes\n+   (foreground and background colors, etc.) are the following.\n+      -- There are eight basic colors available, each with its own\n+\t nominal luminosity to the human eye and foreground/background\n+\t codes (black [0 %, 30/40], blue [11 %, 34/44], red [30 %, 31/41],\n+\t magenta [41 %, 35/45], green [59 %, 32/42], cyan [70 %, 36/46],\n+\t yellow [89 %, 33/43], and white [100 %, 37/47]).\n+      -- Sometimes, white as a background is actually implemented using\n+\t a shade of light gray, so that a foreground white can be visible\n+\t on top of it (but most often not).\n+      -- Sometimes, black as a foreground is actually implemented using\n+\t a shade of dark gray, so that it can be visible on top of a\n+\t background black (but most often not).\n+      -- Sometimes, more colors are available, as extensions.\n+      -- Other attributes can be selected/deselected (bold [1/22],\n+\t underline [4/24], standout/inverse [7/27], blink [5/25], and\n+\t invisible/hidden [8/28]).  They are sometimes implemented by\n+\t using colors instead of what their names imply; e.g., bold is\n+\t often achieved by using brighter colors.  In practice, only bold\n+\t is really available to us, underline sometimes being mapped by\n+\t the terminal to some strange color choice, and standout best\n+\t being left for use by downstream programs such as less(1).\n+      -- We cannot assume that any of the extensions or special features\n+\t are available for the purpose of choosing defaults for everyone.\n+      -- The most prevalent default terminal backgrounds are pure black\n+\t and pure white, and are not necessarily the same shades of\n+\t those as if they were selected explicitly with SGR sequences.\n+\t Some terminals use dark or light pictures as default background,\n+\t but those are covered over by an explicit selection of background\n+\t color with an SGR sequence; their users will appreciate their\n+\t background pictures not be covered like this, if possible.\n+      -- Some uses of colors attributes is to make some output items\n+\t more understated (e.g., context lines); this cannot be achieved\n+\t by changing the background color.\n+      -- For these reasons, the GCC color defaults should strive not\n+\t to change the background color from its default, unless it's\n+\t for a short item that should be highlighted, not understated.\n+      -- The GCC foreground color defaults (without an explicitly set\n+\t background) should provide enough contrast to be readable on any\n+\t terminal with either a black (dark) or white (light) background.\n+\t This only leaves red, magenta, green, and cyan (and their bold\n+\t counterparts) and possibly bold blue.  */\n+/* Default colors. The user can overwrite them using environment\n+   variable GCC_COLORS.  */\n+struct color_cap\n+{\n+  const char *name;\n+  const char *val;\n+  unsigned char name_len;\n+  bool free_val;\n+};\n+\n+/* For GCC_COLORS.  */\n+static struct color_cap color_dict[] =\n+{\n+  { \"error\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_RED), 5, false },\n+  { \"warning\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_MAGENTA),\n+\t       7, false },\n+  { \"note\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_CYAN), 4, false },\n+  { \"caret\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_GREEN), 5, false },\n+  { \"locus\", SGR_SEQ (COLOR_BOLD), 5, false },\n+  { \"quote\", SGR_SEQ (COLOR_BOLD), 5, false },\n+  { NULL, NULL, 0, false }\n+};\n+\n+const char *\n+colorize_start (bool show_color, const char *name, size_t name_len)\n+{\n+  struct color_cap const *cap;\n+\n+  if (!show_color)\n+    return \"\";\n+\n+  for (cap = color_dict; cap->name; cap++)\n+    if (cap->name_len == name_len\n+\t&& memcmp (cap->name, name, name_len) == 0)\n+      break;\n+  if (cap->name == NULL)\n+    return \"\";\n+\n+  return cap->val;\n+}\n+\n+const char *\n+colorize_stop (bool show_color)\n+{\n+  return show_color ? SGR_RESET : \"\";\n+}\n+\n+/* Parse GCC_COLORS.  The default would look like:\n+   GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'\n+   No character escaping is needed or supported.  */\n+static bool\n+parse_gcc_colors (void)\n+{\n+  const char *p, *q, *name, *val;\n+  char *b;\n+  size_t name_len = 0, val_len = 0;\n+\n+  p = getenv (\"GCC_COLORS\"); /* Plural! */\n+  if (p == NULL)\n+    return true;\n+  if (*p == '\\0')\n+    return false;\n+\n+  name = q = p;\n+  val = NULL;\n+  /* From now on, be well-formed or you're gone.  */\n+  for (;;)\n+    if (*q == ':' || *q == '\\0')\n+      {\n+\tstruct color_cap *cap;\n+\n+\tif (val)\n+\t  val_len = q - val;\n+\telse\n+\t  name_len = q - name;\n+\t/* Empty name without val (empty cap)\n+\t   won't match and will be ignored.  */\n+\tfor (cap = color_dict; cap->name; cap++)\n+\t  if (cap->name_len == name_len\n+\t      && memcmp (cap->name, name, name_len) == 0)\n+\t    break;\n+\t/* If name unknown, go on for forward compatibility.  */\n+\tif (cap->val && val)\n+\t  {\n+\t    if (cap->free_val)\n+\t      free (CONST_CAST (char *, cap->val));\n+\t    b = XNEWVEC (char, val_len + sizeof (SGR_SEQ (\"\")));\n+\t    memcpy (b, SGR_START, strlen (SGR_START));\n+\t    memcpy (b + strlen (SGR_START), val, val_len);\n+\t    memcpy (b + strlen (SGR_START) + val_len, SGR_END,\n+\t\t    sizeof (SGR_END));\n+\t    cap->val = (const char *) b;\n+\t    cap->free_val = true;\n+\t  }\n+\tif (*q == '\\0')\n+\t  return true;\n+\tname = ++q;\n+\tval = NULL;\n+      }\n+    else if (*q == '=')\n+      {\n+\tif (q == name || val)\n+\t  return true;\n+\n+\tname_len = q - name;\n+\tval = ++q; /* Can be the empty string.  */\n+      }\n+    else if (val == NULL)\n+      q++; /* Accumulate name.  */\n+    else if (*q == ';' || (*q >= '0' && *q <= '9'))\n+      q++; /* Accumulate val.  Protect the terminal from being sent\n+\t      garbage.  */\n+    else\n+      return true;\n+}\n+\n+#if defined(_WIN32)\n+static bool\n+should_colorize (void)\n+{\n+  return false;\n+}\n+\n+bool\n+colorize_init (void)\n+{\n+  return false;\n+}\n+#else\n+\n+/* Return true if we should use color when in auto mode, false otherwise. */\n+static bool\n+should_colorize (void)\n+{\n+  char const *t = getenv (\"TERM\");\n+  return t && strcmp (t, \"dumb\") != 0 && isatty (STDERR_FILENO);\n+}\n+\n+\n+bool\n+colorize_init (diagnostic_color_rule_t rule)\n+{\n+  switch (rule)\n+    {\n+    case DIAGNOSTICS_COLOR_NO:\n+      return false;\n+    case DIAGNOSTICS_COLOR_YES:\n+      return parse_gcc_colors ();\n+    case DIAGNOSTICS_COLOR_AUTO:\n+      if (should_colorize ())\n+\treturn parse_gcc_colors ();\n+      else\n+\treturn false;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+#endif"}, {"sha": "e643e5188c011eab2e376cb3177112dd88251940", "filename": "gcc/diagnostic-color.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d/gcc%2Fdiagnostic-color.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d/gcc%2Fdiagnostic-color.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.h?ref=f3065bdb6e2161e61ebabe5f4efb6eaef0ae910d", "patch": "@@ -0,0 +1,66 @@\n+/* Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Manuel Lopez-Ibanez <manu@gcc.gnu.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Based on code from: */\n+/* grep.c - main driver file for grep.\n+   Copyright (C) 1992, 1997-2002, 2004-2013 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n+   02110-1301, USA.\n+\n+   Written July 1992 by Mike Haertel.  */\n+\n+#ifndef GCC_DIAGNOSTIC_COLOR_H\n+#define GCC_DIAGNOSTIC_COLOR_H\n+\n+/* How often diagnostics are prefixed by their locations:\n+   o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;\n+   o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit only once;\n+   o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit each time a physical\n+   line is started.  */\n+typedef enum\n+{\n+  DIAGNOSTICS_COLOR_NO       = 0,\n+  DIAGNOSTICS_COLOR_YES      = 1,\n+  DIAGNOSTICS_COLOR_AUTO     = 2\n+} diagnostic_color_rule_t;\n+\n+const char *colorize_start (bool, const char *, size_t);\n+const char *colorize_stop (bool);\n+bool colorize_init (diagnostic_color_rule_t);\n+\n+inline const char *\n+colorize_start (bool show_color, const char *name)\n+{\n+  return colorize_start (show_color, name, strlen (name));\n+}\n+\n+#endif /* ! GCC_DIAGNOSTIC_COLOR_H */"}]}