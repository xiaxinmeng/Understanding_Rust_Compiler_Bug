{"sha": "f5470689a761487ff8e93d4854de75fbcf78bf9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0NzA2ODlhNzYxNDg3ZmY4ZTkzZDQ4NTRkZTc1ZmJjZjc4YmY5ZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-06-03T12:03:35Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-06-03T12:03:35Z"}, "message": "reload1.c (reload_reg_free_for_value_p): New arguments out and reloadnum.\n\n\t* reload1.c (reload_reg_free_for_value_p): New arguments out and\n\treloadnum.  Changed all callers.\n\nFrom-SVN: r20210", "tree": {"sha": "567ef0897f2384be15e59659261e3c2fb37dc665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/567ef0897f2384be15e59659261e3c2fb37dc665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5470689a761487ff8e93d4854de75fbcf78bf9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5470689a761487ff8e93d4854de75fbcf78bf9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5470689a761487ff8e93d4854de75fbcf78bf9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5470689a761487ff8e93d4854de75fbcf78bf9d/comments", "author": null, "committer": null, "parents": [{"sha": "9b91d8f4edce9c408af910863eac6a4ab106a7fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b91d8f4edce9c408af910863eac6a4ab106a7fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b91d8f4edce9c408af910863eac6a4ab106a7fc"}], "stats": {"total": 109, "additions": 70, "deletions": 39}, "files": [{"sha": "2091e02b399063684d647e6ef83c9a2a650b605e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5470689a761487ff8e93d4854de75fbcf78bf9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5470689a761487ff8e93d4854de75fbcf78bf9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5470689a761487ff8e93d4854de75fbcf78bf9d", "patch": "@@ -1,3 +1,8 @@\n+Wed Jun  3 20:00:04 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload1.c (reload_reg_free_for_value_p): New arguments out and\n+\treloadnum.  Changed all callers.\n+\n 1998-06-03  Ulrich Drepper  <drepper@cygnus.com>\n \n \t* system.h: Add _() and N_() macros in preparation for gettext."}, {"sha": "b1a13faa3e143e1aeba40d2d3e25d5df155ab118", "filename": "gcc/reload1.c", "status": "modified", "additions": 65, "deletions": 39, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5470689a761487ff8e93d4854de75fbcf78bf9d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5470689a761487ff8e93d4854de75fbcf78bf9d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f5470689a761487ff8e93d4854de75fbcf78bf9d", "patch": "@@ -378,7 +378,7 @@ static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type));\n-static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx));\n+static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx, rtx, int));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n static int allocate_reload_reg\t\tPROTO((int, rtx, int, int));\n static void choose_reload_regs\t\tPROTO((rtx, rtx));\n@@ -4983,15 +4983,23 @@ int reload_spill_index[MAX_RELOADS];\n /* Return 1 if the value in reload reg REGNO, as used by a reload\n    needed for the part of the insn specified by OPNUM and TYPE,\n    may be used to load VALUE into it.\n-   Other read-only reloads with the same value do not conflict.\n+\n+   Other read-only reloads with the same value do not conflict\n+   unless OUT is non-zero and these other reloads have to live while\n+   output reloads live.\n+\n+   RELOADNUM is the number of the reload we want to load this value for;\n+   a reload does not conflict with itself.\n+\n    The caller has to make sure that there is no conflict with the return\n    register.  */\n static int\n-reload_reg_free_for_value_p (regno, opnum, type, value)\n+reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n      int regno;\n      int opnum;\n      enum reload_type type;\n-     rtx value;\n+     rtx value, out;\n+     int reloadnum;\n {\n   int time1;\n   int i;\n@@ -5048,39 +5056,53 @@ reload_reg_free_for_value_p (regno, opnum, type, value)\n       if (reg && GET_CODE (reg) == REG\n \t  && ((unsigned) regno - true_regnum (reg)\n \t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - 1U)\n-\t  && (! reload_in[i] || ! rtx_equal_p (reload_in[i], value)\n-\t      || reload_out[i]))\n+\t  && i != reloadnum)\n \t{\n-\t  int time2;\n-\t  switch (reload_when_needed[i])\n+\t  if (out\n+\t      && reload_when_needed[i] != RELOAD_FOR_INPUT\n+\t      && reload_when_needed[i] != RELOAD_FOR_INPUT_ADDRESS\n+\t      && reload_when_needed[i] != RELOAD_FOR_INPADDR_ADDRESS)\n+\t    return 0;\n+\t  if (! reload_in[i] || ! rtx_equal_p (reload_in[i], value)\n+\t      || reload_out[i])\n \t    {\n-\t    case RELOAD_FOR_OTHER_ADDRESS:\n-\t      time2 = 0;\n-\t      break;\n-\t    case RELOAD_FOR_INPADDR_ADDRESS:\n-\t      time2 = reload_opnum[i] * 4 + 1;\n-\t      break;\n-\t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t      time2 = reload_opnum[i] * 4 + 2;\n-\t      break;\n-\t    case RELOAD_FOR_INPUT:\n-\t      time2 = reload_opnum[i] * 4 + 3;\n-\t      break;\n-\t    case RELOAD_FOR_OUTPUT:\n-\t    /* All RELOAD_FOR_OUTPUT reloads become live just after the\n-\t       instruction is executed.  */\n-\t      time2 = MAX_RECOG_OPERANDS * 4;\n-\t      break;\n-\t    /* The first RELOAD_FOR_OUTPUT_ADDRESS reload conflicts with the\n-\t       RELOAD_FOR_OUTPUT reloads, so assign it the same time value.  */\n-\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t      time2 = MAX_RECOG_OPERANDS * 4 + reload_opnum[i];\n-\t      break;\n-\t    default:\n-\t      time2 = 0;\n+\t      int time2;\n+\t      switch (reload_when_needed[i])\n+\t\t{\n+\t\tcase RELOAD_FOR_OTHER_ADDRESS:\n+\t\t  time2 = 0;\n+\t\t  break;\n+\t\tcase RELOAD_FOR_INPADDR_ADDRESS:\n+\t\t  time2 = reload_opnum[i] * 4 + 1;\n+\t\t  break;\n+\t\tcase RELOAD_FOR_INPUT_ADDRESS:\n+\t\t  time2 = reload_opnum[i] * 4 + 2;\n+\t\t  break;\n+\t\tcase RELOAD_FOR_INPUT:\n+\t\t  time2 = reload_opnum[i] * 4 + 3;\n+\t\t  break;\n+\t\tcase RELOAD_FOR_OUTPUT:\n+\t\t/* All RELOAD_FOR_OUTPUT reloads become live just after the\n+\t\t   instruction is executed.  */\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4;\n+\t\t  break;\n+\t\t/* The first RELOAD_FOR_OUTPUT_ADDRESS reload conflicts with the\n+\t\t   RELOAD_FOR_OUTPUT reloads, so assign it the same time value.  */\n+\t\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + reload_opnum[i];\n+\t\t  break;\n+\t\tcase RELOAD_OTHER:\n+\t\t  if (! reload_in[i] || rtx_equal_p (reload_in[i], value))\n+\t\t    {\n+\t\t      time2 = MAX_RECOG_OPERANDS * 4;\n+\t\t      break;\n+\t\t    }\n+\t\tdefault:\n+\t\t  time2 = 0;\n+\t\t}\n+\t      if (time1 >= time2)\n+\t\treturn 0;\n \t    }\n-\t  if (time1 >= time2)\n-\t    return 0;\n \t}\n     }\n   return 1;\n@@ -5160,14 +5182,15 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \n \t  if ((reload_reg_free_p (spill_regs[i], reload_opnum[r],\n \t\t\t\t  reload_when_needed[r])\n-\t       || (reload_in[r] && ! reload_out[r]\n+\t       || (reload_in[r]\n \t\t      /* We check reload_reg_used to make sure we\n \t\t\t don't clobber the return register.  */\n \t\t   && ! TEST_HARD_REG_BIT (reload_reg_used, spill_regs[i])\n \t\t   && reload_reg_free_for_value_p (spill_regs[i],\n \t\t\t\t\t\t  reload_opnum[r],\n \t\t\t\t\t\t  reload_when_needed[r],\n-\t\t\t\t\t\t  reload_in[r])))\n+\t\t\t\t\t\t  reload_in[r],\n+\t\t\t\t\t\t  reload_out[r], r)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], spill_regs[i])\n \t      && HARD_REGNO_MODE_OK (spill_regs[i], reload_mode[r])\n \t      /* Look first for regs to share, then for unshared.  But\n@@ -5634,7 +5657,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t\t\t\t\treload_when_needed[r]))\n \t\t\t  || reload_reg_free_for_value_p (i, reload_opnum[r],\n \t\t\t\t\t\t\t  reload_when_needed[r],\n-\t\t\t\t\t\t\t  reload_in[r])))\n+\t\t\t\t\t\t\t  reload_in[r],\n+\t\t\t\t\t\t\t  reload_out[r], r)))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n@@ -5741,7 +5765,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t     || reload_reg_free_for_value_p (regno,\n \t\t\t\t\t\t\t     reload_opnum[r],\n \t\t\t\t\t\t\t     reload_when_needed[r],\n-\t\t\t\t\t\t\t     reload_in[r])))\n+\t\t\t\t\t\t\t     reload_in[r],\n+\t\t\t\t\t\t\t     reload_out[r], r)))\n \t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n@@ -5924,7 +5949,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t|| reload_reg_free_for_value_p (true_regnum (reload_reg_rtx[r]),\n \t\t\t\t\t\treload_opnum[r],\n \t\t\t\t\t\treload_when_needed[r],\n-\t\t\t\t\t\treload_in[r])))\n+\t\t\t\t\t\treload_in[r],\n+\t\t\t\t\t\treload_out[r], r)))\n \treload_inherited[r] = 0;\n       /* If we can inherit a RELOAD_FOR_INPUT, then we do not need its related\n \t RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads."}]}