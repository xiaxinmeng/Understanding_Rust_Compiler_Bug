{"sha": "ca072a31b75eacb8292cfa91fb779020ee5f6118", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EwNzJhMzFiNzVlYWNiODI5MmNmYTkxZmI3NzkwMjBlZTVmNjExOA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-06-17T12:53:33Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-06-17T12:53:33Z"}, "message": "tree-ssa-pre.c: Update comments.\n\n2004-06-17  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-pre.c:  Update comments.\n\t(val_expr_pair_eq): Factor code from here.\n\t(expr_pred_trans_eq): and here.\n\t(expressions_equal_p): To here.\n\t(print_value_set): Print value for expression.\n\t(phi_trans_lookup): Rename some variables.\n\t(lookup): Ditto.\n\t(value_exists_in_set_bitmap): Ditto.\n\t(value_remove_from_set_bitmap): Ditto.\n\t(value_insert_into_set_bitmap): Ditto.\n\nFrom-SVN: r83290", "tree": {"sha": "3e5d992a3f10289c5513ed8c03d83abe435f47cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e5d992a3f10289c5513ed8c03d83abe435f47cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca072a31b75eacb8292cfa91fb779020ee5f6118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca072a31b75eacb8292cfa91fb779020ee5f6118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca072a31b75eacb8292cfa91fb779020ee5f6118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca072a31b75eacb8292cfa91fb779020ee5f6118/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bed2809676ce7157817b42b1c6555c073fa0d6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bed2809676ce7157817b42b1c6555c073fa0d6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bed2809676ce7157817b42b1c6555c073fa0d6e"}], "stats": {"total": 235, "additions": 165, "deletions": 70}, "files": [{"sha": "551a2ec879209419b2160ceb54409ddde6102f54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca072a31b75eacb8292cfa91fb779020ee5f6118/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca072a31b75eacb8292cfa91fb779020ee5f6118/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca072a31b75eacb8292cfa91fb779020ee5f6118", "patch": "@@ -1,3 +1,16 @@\n+2004-06-17  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-pre.c:  Update comments.\n+\t(val_expr_pair_eq): Factor code from here.\n+\t(expr_pred_trans_eq): and here.\n+\t(expressions_equal_p): To here.\n+\t(print_value_set): Print value for expression.\n+\t(phi_trans_lookup): Rename some variables.\n+\t(lookup): Ditto.\n+\t(value_exists_in_set_bitmap): Ditto.\n+\t(value_remove_from_set_bitmap): Ditto.\n+\t(value_insert_into_set_bitmap): Ditto.\n+\n 2004-06-17  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390-modes.def (CCL3mode): New machine mode."}, {"sha": "e98fbfc60253e7b2e447ac92a5d6a784804a7d60", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 152, "deletions": 70, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca072a31b75eacb8292cfa91fb779020ee5f6118/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca072a31b75eacb8292cfa91fb779020ee5f6118/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ca072a31b75eacb8292cfa91fb779020ee5f6118", "patch": "@@ -182,33 +182,71 @@ Boston, MA 02111-1307, USA.  */\n    expressions/constants/values.  */\n typedef struct value_set_node\n {\n+  /* An expression.  */\n   tree expr;\n+\n+  /* A pointer to the next element of the value set.  */\n   struct value_set_node *next;\n } *value_set_node_t;\n \n \n-/* A value set, which is the head of the linked list, and we also keep\n-   the tail because we have to append for the topolofical sort.  */\n+/* A value set.  This is a singly linked list of value_set_node\n+   elements with a possible bitmap that tells us what values exist in\n+   the set.  This set must be kept in topologically sorted order.  */\n typedef struct value_set\n {\n+  /* The head of the list.  Used for iterating over the list in\n+     order.  */\n   value_set_node_t head;\n+\n+  /* The tail of the list.  Used for tail insertions, which are\n+     necessary to keep the set in topologically sorted order because\n+     of how the set is built.  */\n   value_set_node_t tail;\n+  \n+  /* The length of the list.  */\n   size_t length;\n+  \n+  /* True if the set is indexed, which means it contains a backing\n+     bitmap for quick determination of whether certain values exist in the\n+     set.  */\n   bool indexed;\n+  \n+  /* The bitmap of values that exist in the set.  May be NULL in an\n+     empty or non-indexed set.  */\n   bitmap values;\n   \n } *value_set_t;\n \n /* All of the following sets, except for TMP_GEN, are indexed.\n    TMP_GEN is only ever iterated over, we never check what values\n    exist in it.  */\n+\n typedef struct bb_value_sets\n {\n+  /* The EXP_GEN set, which represents expressions/values generated in\n+     a basic block.  */\n   value_set_t exp_gen;\n+\n+  /* The PHI_GEN set, which represents PHI results generated in a\n+     basic block.  */\n   value_set_t phi_gen;\n+\n+  /* The TMP_GEN set, which represents results/temporaries genererated\n+     in a basic block. IE the LHS of an expression.  */\n   value_set_t tmp_gen;\n+\n+  /* The AVAIL_OUT set, which represents which values are available in\n+     a given basic block.  */\n   value_set_t avail_out;\n+\n+  /* The ANTIC_IN set, which represents which values are anticiptable\n+     in a given basic block.  */\n   value_set_t antic_in;\n+\n+  /* The NEW_SETS set, which is used during insertion to augment the\n+     AVAIL_OUT set of blocks with the new insertions performed during\n+     the current iteration.  */\n   value_set_t new_sets;\n } *bb_value_sets_t;\n \n@@ -219,10 +257,17 @@ typedef struct bb_value_sets\n #define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n #define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n \n+/* This structure is used to keep track of statistics on what\n+   optimization PRE was able to perform.  */\n static struct\n {\n+  /* The number of RHS computations eliminated by PRE.  */\n   int eliminations;\n+\n+  /* The number of new expressions/temporaries generated by PRE.  */\n   int insertions;\n+\n+  /* The number of new PHI nodes added by PRE.  */\n   int phis;\n } pre_stats;\n \n@@ -232,6 +277,7 @@ static void insert_into_set (value_set_t, tree);\n static void add_to_value (tree, tree);\n static value_set_t set_new  (bool);\n static bool is_undefined_value (tree);\n+static bool expressions_equal_p (tree, tree);\n \n /* We can add and remove elements and entries to and from sets\n    and hash tables, so we use alloc pools for them.  */\n@@ -242,12 +288,34 @@ static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n \n /* The value table that maps expressions to values.  */\n+\n static htab_t value_table;\n \n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n+\n static htab_t phi_translate_table;\n \n+/* Compare two expressions E1 and E2 and return true if they are\n+   equal.  */\n+\n+static bool\n+expressions_equal_p (tree e1, tree e2)\n+{\n+  tree te1, te2;\n+  \n+  if (e1 == e2)\n+    return true;\n+  \n+  te1 = TREE_TYPE (e1);\n+  te2 = TREE_TYPE (e2);\n+\n+  if (TREE_CODE (e1) == TREE_CODE (e2) \n+      && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n+      && operand_equal_p (e1, e2, 0))\n+    return true;\n+  return false;\n+}\n \n /* Map expressions to values.  These are simple pairs of expressions\n    and the values they represent.  To find the value represented by\n@@ -261,7 +329,9 @@ typedef struct val_expr_pair_d\n } *val_expr_pair_t;\n \n \n-/* Hash a {v,e} pair.  We really only hash the expression.  */\n+/* Hash a {v,e} pair that is pointed to by P.\n+   The hashcode is cached in the val_expr_pair, so we just return\n+   that.  */\n \n static hashval_t\n val_expr_pair_hash (const void *p)\n@@ -271,34 +341,26 @@ val_expr_pair_hash (const void *p)\n }\n \n \n-/* Are {e2,v2} and {e1,v1} the same?  Again, only the expression\n-   matters.  */\n+/* Given two val_expr_pair_t's, return true if they represent the same\n+   expression, false otherwise.\n+   P1 and P2 should point to the val_expr_pair_t's to be compared.  */\n \n static int\n val_expr_pair_expr_eq (const void *p1, const void *p2)\n {\n   const val_expr_pair_t ve1 = (val_expr_pair_t) p1;\n   const val_expr_pair_t ve2 = (val_expr_pair_t) p2;\n-  tree e1 = ve1->e;\n-  tree e2 = ve2->e;\n-  tree te1;\n-  tree te2;\n-  if (e1 == e2)\n-    return true;\n \n-  te1 = TREE_TYPE (e1);\n-  te2 = TREE_TYPE (e2);\n-  if (TREE_CODE (e1) == TREE_CODE (e2) \n-      && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n-      && operand_equal_p (e1, e2, 0))\n+  if (expressions_equal_p (ve1->e, ve2->e))\n     return true;\n-\n+  \n   return false;\n }\n \n \n /* Get the value handle of EXPR.  This is the only correct way to get\n-   the value handle for a \"thing\".  */\n+   the value handle for a \"thing\". \n+   Returns NULL if the value handle does not exist.  */\n \n tree\n get_value_handle (tree expr)\n@@ -328,7 +390,7 @@ get_value_handle (tree expr)\n }\n \n \n-/* Set the value handle for E to V */\n+/* Set the value handle for expression E to value V */\n    \n void\n set_value_handle (tree e, tree v)\n@@ -348,9 +410,17 @@ set_value_handle (tree e, tree v)\n \n typedef struct expr_pred_trans_d\n {\n+  /* The expression. */\n   tree e;\n+\n+  /* The predecessor block along which we translated the expression.  */\n   basic_block pred;\n+\n+  /* The value that resulted from the translation.  */\n   tree v;\n+\n+  /* The hashcode for the expression, pred pair. This is cached for\n+     speed reasons.  */\n   hashval_t hashcode;\n } *expr_pred_trans_t;\n \n@@ -363,49 +433,44 @@ expr_pred_trans_hash (const void *p)\n   return ve->hashcode;\n }\n \n-/* Return true if two phi translation table entries are the same.  */\n+/* Return true if two phi translation table entries are the same.\n+   P1 and P2 should point to the expr_pred_trans_t's to be compared.*/\n \n static int\n expr_pred_trans_eq (const void *p1, const void *p2)\n {\n   const expr_pred_trans_t ve1 = (expr_pred_trans_t) p1;\n   const expr_pred_trans_t ve2 = (expr_pred_trans_t) p2;\n-  tree e1 = ve1->e;\n-  tree e2 = ve2->e;\n   basic_block b1 = ve1->pred;\n   basic_block b2 = ve2->pred;\n-  tree te1;\n-  tree te2;\n \n+  \n+  /* If they are not translations for the same basic block, they can't\n+     be equal.  */\n   if (b1 != b2)\n     return false;\n \n-  if (e1 == e2)\n-    return true;\n-  \n-  te1 = TREE_TYPE (e1);\n-  te2 = TREE_TYPE (e2);\n-\n-  if (TREE_CODE (e1) == TREE_CODE (e2) \n-      && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n-      && operand_equal_p (e1, e2, 0))\n+  /* If they are for the same basic block, determine if the\n+     expressions are equal.   */  \n+  if (expressions_equal_p (ve1->e, ve2->e))\n     return true;\n   \n   return false;\n }\n \n-/* Search in the phi translation table for the translation of E in\n-   PRED. Return the translated value, if found, NULL otherwise.  */\n+/* Search in the phi translation table for the translation of\n+   expression E in basic block PRED. Return the translated value, if\n+   found, NULL otherwise. */ \n \n static inline tree\n phi_trans_lookup (tree e, basic_block pred)\n {\n   void **slot;\n-  struct expr_pred_trans_d ugly;\n-  ugly.e = e;\n-  ugly.pred = pred;\n-  ugly.hashcode = iterative_hash_expr (e, (unsigned long) pred);\n-  slot = htab_find_slot_with_hash (phi_translate_table, &ugly, ugly.hashcode,\n+  struct expr_pred_trans_d ept;\n+  ept.e = e;\n+  ept.pred = pred;\n+  ept.hashcode = iterative_hash_expr (e, (unsigned long) pred);\n+  slot = htab_find_slot_with_hash (phi_translate_table, &ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n     return NULL;\n@@ -414,7 +479,8 @@ phi_trans_lookup (tree e, basic_block pred)\n }\n \n \n-/* Add the tuple mapping {e, pred}->v to the phi translation table.  */\n+/* Add the tuple mapping from {expression E, basic block PRED} to\n+   value V, to the phi translation table.  */\n \n static inline void\n phi_trans_add (tree e, tree v, basic_block pred)\n@@ -439,17 +505,17 @@ static inline tree\n lookup (htab_t table, tree e)\n {\n   void **slot;\n-  struct val_expr_pair_d ugly = {NULL, NULL, 0};\n-  ugly.e = e;\n-  ugly.hashcode = iterative_hash_expr (e,0); \n-  slot = htab_find_slot_with_hash (table, &ugly, ugly.hashcode, NO_INSERT);\n+  struct val_expr_pair_d vep = {NULL, NULL, 0};\n+  vep.e = e;\n+  vep.hashcode = iterative_hash_expr (e,0); \n+  slot = htab_find_slot_with_hash (table, &vep, vep.hashcode, NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n   else\n     return ((val_expr_pair_t) *slot)->v;\n }\n \n-/* Add E to the expression set of V.  */\n+/* Add expression E to the expression set of value V.  */\n \n static inline void\n add_to_value (tree v, tree e)\n@@ -480,7 +546,8 @@ add_to_value (tree v, tree e)\n #endif\n }\n \n-/* Insert E into TABLE with value V, and add E to the value set for V.  */\n+/* Insert E into TABLE with value V, and add expression E to the value\n+   set for value V.  */\n \n static inline void\n add (htab_t table, tree e, tree v)\n@@ -502,9 +569,12 @@ add (htab_t table, tree e, tree v)\n  \n }\n \n+/* A unique counter that is incremented every time we create a new\n+   value.  */\n static int pre_uid;\n \n-/* Create a new value handle for EXPR.  */\n+/* Create a new value handle for expression EXPR.  */\n+\n static tree\n create_new_value (tree expr)\n {\n@@ -523,7 +593,10 @@ create_new_value (tree expr)\n   return a;\n }\n \n-/* Like lookup, but adds V as the value for E if E does not have a value.  */\n+/* Like lookup, but creates a new value for expression E if E doesn't\n+   already have a value.\n+   Return the existing/created value for E.  */\n+\n static inline tree\n lookup_or_add (htab_t table, tree e)\n {\n@@ -540,43 +613,43 @@ lookup_or_add (htab_t table, tree e)\n }\n \n   \n-/* Search in the bitmap for SET to see if E exists.  */\n+/* Return true if value V exists in the bitmap for SET.  */\n \n static inline bool\n-value_exists_in_set_bitmap (value_set_t set, tree e)\n+value_exists_in_set_bitmap (value_set_t set, tree v)\n {\n-  if (TREE_CODE (e) != VAR_DECL)\n+  if (TREE_CODE (v) != VAR_DECL)\n     abort ();\n \n   if (!set->values)\n     return false;\n-  return bitmap_bit_p (set->values, get_var_ann (e)->uid);\n+  return bitmap_bit_p (set->values, get_var_ann (v)->uid);\n }\n \n-/* Remove E from the bitmap for SET.  */\n+/* Remove value V from the bitmap for SET.  */\n \n static void\n-value_remove_from_set_bitmap (value_set_t set, tree e)\n+value_remove_from_set_bitmap (value_set_t set, tree v)\n {\n-  if (TREE_CODE (e) != VAR_DECL)\n+  if (TREE_CODE (v) != VAR_DECL)\n     abort ();\n #ifdef ENABLE_CHECKING\n   if (!set->indexed)\n     abort ();\n #endif\n   if (!set->values)\n     return;\n-  bitmap_clear_bit (set->values, get_var_ann (e)->uid);\n+  bitmap_clear_bit (set->values, get_var_ann (v)->uid);\n }\n \n \n-/* Insert the value number E into the bitmap of values existing in\n+/* Insert the value number V into the bitmap of values existing in\n    SET.  */\n \n static inline void\n-value_insert_into_set_bitmap (value_set_t set, tree e)\n+value_insert_into_set_bitmap (value_set_t set, tree v)\n {\n-  if (TREE_CODE (e) != VAR_DECL)\n+  if (TREE_CODE (v) != VAR_DECL)\n     abort ();  \n #ifdef ENABLE_CHECKING\n   if (!set->indexed)\n@@ -587,7 +660,7 @@ value_insert_into_set_bitmap (value_set_t set, tree e)\n       set->values = BITMAP_GGC_ALLOC ();\n       bitmap_clear (set->values);\n     }\n-  bitmap_set_bit (set->values, get_var_ann (e)->uid);\n+  bitmap_set_bit (set->values, get_var_ann (v)->uid);\n }\n \n /* Create a new set.  */\n@@ -824,6 +897,11 @@ print_value_set (FILE *outfile, value_set_t set,\n \t   node = node->next)\n \t{\n \t  print_generic_expr (outfile, node->expr, 0);\n+\t  \n+\t  fprintf (outfile, \" (\");\n+\t  print_generic_expr (outfile, get_value_handle (node->expr), 0);\n+\t  fprintf (outfile, \") \");\n+\t\t     \n \t  if (node->next)\n \t    fprintf (outfile, \", \");\n \t}\n@@ -921,9 +999,9 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t  return NULL;\n \tif (newop1 != oldop1)\n \t  {\n-\t    newexpr = pool_alloc (unary_node_pool);\t   \n+\t    newexpr = pool_alloc (unary_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n-\t    create_expr_ann (newexpr);\n+\t    create_expr_ann (newexpr);\t \n \t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n \t    lookup_or_add (value_table, newexpr);\n \t    expr = newexpr;\n@@ -1047,9 +1125,9 @@ valid_in_set (value_set_t set, tree expr)\n   return false;\n }\n \n-/* Clean the set of expressions that are no longer valid in the\n-   specified set.  This means expressions that are made up of values\n-   we have no leaders for in the current set, etc.  */\n+/* Clean the set of expressions that are no longer valid in SET.  This\n+   means expressions that are made up of values we have no leaders for\n+   in SET.  */\n \n static void\n clean (value_set_t set)\n@@ -1179,6 +1257,7 @@ compute_antic_aux (basic_block block)\n       value_insert_into_set (ANTIC_IN (block), node->expr);\n     }\n   clean (ANTIC_IN (block));\n+  \n \n   if (!set_equal (old, ANTIC_IN (block)))\n     changed = true;\n@@ -1274,12 +1353,12 @@ insert_aux (basic_block block)\n \t\t      tree *avail;\n \t\t      tree val;\n \t\t      bool by_some = false;\n+\t\t      bool cant_insert = false;\n \t\t      bool all_same = true;\n \t\t      tree first_s = NULL;\n \t\t      edge pred;\n \t\t      basic_block bprime;\n \t\t      tree eprime;\n-\t\t      bool cant_insert = false;\n \n \t\t      val = get_value_handle (node->expr);\n \t\t      if (set_contains_value (PHI_GEN (block), val))\n@@ -1331,7 +1410,7 @@ insert_aux (basic_block block)\n \t\t\t  else\n \t\t\t    {\n \t\t\t      avail[bprime->index] = edoubleprime;\n-\t\t\t      by_some = true;\n+\t\t\t      by_some = true; \n \t\t\t      if (first_s == NULL)\n \t\t\t\tfirst_s = edoubleprime;\n \t\t\t      else if (first_s != edoubleprime)\n@@ -1341,11 +1420,14 @@ insert_aux (basic_block block)\n \t\t\t\tabort ();\n \t\t\t    }\n \t\t\t}\n-\n+\t\t      /* If we can insert it, it's not the same value\n+\t\t\t already existing along every predecessor, and\n+\t\t\t it's defined by some predecessor, it is\n+\t\t\t partially redundant.  */\n \t\t      if (!cant_insert && !all_same && by_some)\n \t\t\t{\n-\t\t\t  tree temp;\n \t\t\t  tree type = TREE_TYPE (avail[block->pred->src->index]);\n+\t\t\t  tree temp;\n \t\t\t  tree v;\n \n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))"}]}