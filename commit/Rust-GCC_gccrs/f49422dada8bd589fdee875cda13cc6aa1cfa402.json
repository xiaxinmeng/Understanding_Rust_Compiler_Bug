{"sha": "f49422dada8bd589fdee875cda13cc6aa1cfa402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ5NDIyZGFkYThiZDU4OWZkZWU4NzVjZGExM2NjNmFhMWNmYTQwMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-18T18:33:44Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-18T18:33:44Z"}, "message": "89th Cygnus<->FSF quick merge\n\nFrom-SVN: r12978", "tree": {"sha": "278b38bac5e3f8eb74005bba54609dcaef8ab0ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/278b38bac5e3f8eb74005bba54609dcaef8ab0ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f49422dada8bd589fdee875cda13cc6aa1cfa402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f49422dada8bd589fdee875cda13cc6aa1cfa402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f49422dada8bd589fdee875cda13cc6aa1cfa402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f49422dada8bd589fdee875cda13cc6aa1cfa402/comments", "author": null, "committer": null, "parents": [{"sha": "170e0690ee57c42c1805f5d7e31f29c94b97ea91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170e0690ee57c42c1805f5d7e31f29c94b97ea91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170e0690ee57c42c1805f5d7e31f29c94b97ea91"}], "stats": {"total": 139, "additions": 126, "deletions": 13}, "files": [{"sha": "1c95b3b45c34393fb54942eb2b90a5f82a61e478", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -1,3 +1,33 @@\n+Thu Oct 17 11:31:59 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (convert_to_pointer_force): Add code to support pointer to\n+ \tmember function to pointer to function conversions.\n+\t* init.c (resolve_offset_ref): Add code to allow faked up objects,\n+ \tignoring them if they are not used, and giving an error, if they\n+ \tare needed.\n+\t* typeck.c (get_member_function_from_ptrfunc): Fold e1 to improve\n+ \tcode, and so that we can give an error, if we needed an object,\n+ \tand one was not provided.\n+\t(build_c_cast): Don't call default_conversion when we want to\n+ \tconvert to pointer to function from a METHOD_TYPE.\n+\n+Mon Oct 14 00:28:51 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* Make-lang.in (cplib2.ready): Fix logic.\n+\n+\t* decl.c (shadow_tag): Only complain about non-artificial function\n+ \tmembers.\n+\n+\t* class.c (finish_struct_1): Add synthesized methods to TYPE_METHODS.\n+\n+Fri Oct 11 16:12:40 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* expr.c (cplus_expand_expr): Pre-tweak call_target like\n+ \texpand_inline_function would.\n+\n+\t* pt.c (mark_decl_instantiated): If extern_p, call\n+ \tmark_inline_for_output.\n+\n Thu Oct 10 15:58:08 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* typeck.c (unary_complex_lvalue): Add code to handle intermediate"}, {"sha": "b6b0105857c5e2ef5990822ad12b1a1b5d26845a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -146,7 +146,7 @@ cplib2.ready: $(GCC_PASSES) $(LIBGCC2_DEPS) stmp-int-hdrs\n \t  else \\\n \t    echo \"\" > cplib2.new; \\\n \t  fi; \\\n-\t  if cmp -s cplib2.new cplib2.txt; then \\\n+\t  if cmp -s cplib2.new cplib2.txt; then true; else \\\n \t    touch cplib2.ready; \\\n \t  fi; \\\n \t  rm -f cplib2.new; \\"}, {"sha": "60b2cffea7304961c2233870667f80770f8bcd14", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -3635,6 +3635,7 @@ finish_struct_1 (t, warn_anon)\n \n   if (fn_fields)\n     {\n+      TYPE_METHODS (t) = fn_fields;\n       method_vec = finish_struct_methods (t, fn_fields, nonprivate_method);\n \n       if (TYPE_HAS_CONSTRUCTOR (t)"}, {"sha": "cd40b9a0cec65782df7f775cdd22eaf1cc594d10", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -282,6 +282,44 @@ convert_to_pointer_force (type, expr)\n       form = TREE_CODE (intype);\n     }\n \n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    {\n+      /* Allow an implicit this pointer for pointer to member\n+         functions.  */\n+      if (TYPE_PTRMEMFUNC_P (intype))\n+\t{\n+\t  tree decl, basebinfo;\n+\t  tree fntype = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (intype));\n+\t  tree t = TYPE_METHOD_BASETYPE (fntype);\n+\n+\t  if (current_class_type == 0\n+\t      || get_base_distance (t, current_class_type, 0, &basebinfo) == -1)\n+\t    {\n+\t      decl = build1 (NOP_EXPR, t, error_mark_node);\n+\t    }\n+\t  else if (current_class_ptr == 0)\n+\t    decl = build1 (NOP_EXPR, t, error_mark_node);\n+\t  else\n+\t    decl = current_class_ref;\n+\n+\t  expr = build (OFFSET_REF, fntype, decl, expr);\n+\t  intype = TREE_TYPE (expr);\n+\t}\n+\n+      if (TREE_CODE (expr) == OFFSET_REF && TREE_CODE (intype) == METHOD_TYPE)\n+\texpr = resolve_offset_ref (expr);\n+      if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n+\texpr = build_addr_func (expr);\n+      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+\t{\n+\t  if (pedantic\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == METHOD_TYPE)\n+\t    cp_pedwarn (\"cannot convert `%T' to `%T'\", intype, type);\n+\t  return build1 (NOP_EXPR, type, expr);\n+\t}\n+    }\n+\n   if (form == POINTER_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);"}, {"sha": "7c8c28bda78e98dd59c199ced1d020072ae114a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -5647,10 +5647,16 @@ shadow_tag (declspecs)\n \t  || (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))))\n     {\n+      tree fn;\n+\n       /* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have\n \t function members.  */\n-      if (TYPE_METHODS (t))\n-\terror (\"an anonymous union cannot have function members\");\n+      for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n+\tif (! DECL_ARTIFICIAL (fn))\n+\t  {\n+\t    error (\"an anonymous union cannot have function members\");\n+\t    break;\n+\t  }\n \n       if (TYPE_FIELDS (t))\n \t{"}, {"sha": "3351ccba7708b52eb5cb39aacfc0fdd36a5c341b", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -137,6 +137,18 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t       result.  The assumptions are true only if the address was\n \t       valid to begin with.  */\n \t    call_target = validize_mem (call_target);\n+\n+\t    /* If this is a reference to a symbol, expand_inline_function\n+\t       will do this transformation and return a different target\n+\t       than the one we gave it, though functionally equivalent.  Do\n+\t       the transformation here to avoid confusion.  */\n+\t    if (! cse_not_expected && GET_CODE (call_target) == MEM\n+\t\t&& GET_CODE (XEXP (call_target, 0)) == SYMBOL_REF)\n+\t      {\n+\t\tcall_target = gen_rtx\n+\t\t  (MEM, mode, memory_address (mode, XEXP (call_target, 0)));\n+\t\tMEM_IN_STRUCT_P (call_target) = 1;\n+\t      }\n \t  }\n \n \tcall_exp = build (CALL_EXPR, type, func, args, NULL_TREE);"}, {"sha": "84fd6a223658f285c20564f20eeced70d8ce9a42", "filename": "gcc/cp/init.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -2082,14 +2082,27 @@ resolve_offset_ref (exp)\n       my_friendly_abort (55);\n     }\n \n-  /* If this is a reference to a member function, then return\n-     the address of the member function (which may involve going\n-     through the object's vtable), otherwise, return an expression\n-     for the dereferenced pointer-to-member construct.  */\n-  addr = build_unary_op (ADDR_EXPR, base, 0);\n+  /* Ensure that we have an object.  */\n+  if (TREE_CODE (base) == NOP_EXPR\n+      && TREE_OPERAND (base, 0) == error_mark_node)\n+    addr = error_mark_node;\n+  else\n+    {\n+      /* If this is a reference to a member function, then return the\n+\t address of the member function (which may involve going\n+\t through the object's vtable), otherwise, return an expression\n+\t for the dereferenced pointer-to-member construct.  */\n+      addr = build_unary_op (ADDR_EXPR, base, 0);\n+    }\n \n   if (TREE_CODE (TREE_TYPE (member)) == OFFSET_TYPE)\n     {\n+      if (addr == error_mark_node)\n+\t{\n+\t  cp_error (\"object missing in `%E'\", exp);\n+\t  return error_mark_node;\n+\t}\n+\n       basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (member));\n       addr = convert_pointer_to (basetype, addr);\n       member = convert (ptrdiff_type_node,"}, {"sha": "f5f502dbfd0b3ecb5ad60ba9dc9bcf8e1e7d91d6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -2858,6 +2858,8 @@ mark_decl_instantiated (result, extern_p)\n       DECL_INTERFACE_KNOWN (result) = 1;\n       DECL_NOT_REALLY_EXTERN (result) = 1;\n     }\n+  else if (TREE_CODE (result) == FUNCTION_DECL)\n+    mark_inline_for_output (result);\n }\n \n /* Given two function templates PAT1 and PAT2, return:"}, {"sha": "1e09c28e0aa1e032bbc5822390ffa93f4fb857b9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49422dada8bd589fdee875cda13cc6aa1cfa402/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f49422dada8bd589fdee875cda13cc6aa1cfa402", "patch": "@@ -2463,8 +2463,8 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       idx = save_expr (build_component_ref (function,\n \t\t\t\t\t    index_identifier,\n \t\t\t\t\t    NULL_TREE, 0));\n-      e1 = build (GT_EXPR, boolean_type_node, idx,\n-\t\t  convert (delta_type_node, integer_zero_node));\n+      e1 = fold (build (GT_EXPR, boolean_type_node, idx,\n+\t\t\tconvert (delta_type_node, integer_zero_node)));\n       delta = convert (ptrdiff_type_node,\n \t\t       build_component_ref (function, delta_identifier, NULL_TREE, 0));\n       delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n@@ -2473,7 +2473,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       instance\n \t= convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n \t\t\t\t   instance_ptr);\n-      if (instance == error_mark_node)\n+      if (instance == error_mark_node && instance_ptr != error_mark_node)\n \treturn instance;\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n@@ -2503,7 +2503,14 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n       e3 = PFN_FROM_PTRMEMFUNC (function);\n       TREE_TYPE (e2) = TREE_TYPE (e3);\n-      function = build_conditional_expr (e1, e2, e3);\n+      e1 = build_conditional_expr (e1, e2, e3);\n+\n+      if (instance_ptr == error_mark_node\n+\t  && TREE_CODE (e1) != ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (e1, 0)) != FUNCTION_DECL)\n+\tcp_error (\"object missing in `%E'\", function);\n+\n+      function = e1;\n \n       /* Make sure this doesn't get evaluated first inside one of the\n          branches of the COND_EXPR.  */\n@@ -5408,7 +5415,11 @@ build_c_cast (type, expr, allow_nonconverting)\n \t convert references to their expanded types,\n \t but don't convert any other types.  */\n       if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE\n+\t  || (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE\n+\t      /* Don't do the default conversion if we want a\n+\t\t pointer to a function.  */\n+\t      && TREE_CODE (type) != POINTER_TYPE\n+\t      && TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE)\n \t  || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n \tvalue = default_conversion (value);"}]}