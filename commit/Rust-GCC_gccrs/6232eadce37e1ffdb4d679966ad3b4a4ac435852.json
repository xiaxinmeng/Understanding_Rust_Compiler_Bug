{"sha": "6232eadce37e1ffdb4d679966ad3b4a4ac435852", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIzMmVhZGNlMzdlMWZmZGI0ZDY3OTk2NmFkM2I0YTRhYzQzNTg1Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-07-23T23:07:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-07-23T23:07:46Z"}, "message": "i386.c (ix86_secondary_memory_needed): Break out to...\n\n\t* i386.c (ix86_secondary_memory_needed): Break out to...\n\t(inline_secondary_memory_needed): ... here.\n\t(ix86_memory_move_cost): Break out to ...\n\t(inline_memory_move_cost): ... here; add support for IN value of 2 for\n\tmaximum of input and output; fix handling of Q_REGS on 64bit.\n\t(ix86_secondary_memory_needed): Microoptimize.\n\nFrom-SVN: r126861", "tree": {"sha": "fe0154806e03bb034ce13b05e3c4e6cd32b956ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe0154806e03bb034ce13b05e3c4e6cd32b956ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6232eadce37e1ffdb4d679966ad3b4a4ac435852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6232eadce37e1ffdb4d679966ad3b4a4ac435852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6232eadce37e1ffdb4d679966ad3b4a4ac435852", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6232eadce37e1ffdb4d679966ad3b4a4ac435852/comments", "author": null, "committer": null, "parents": [{"sha": "3a796c6fc089ab1d0db461a0c102d6d823cff34a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a796c6fc089ab1d0db461a0c102d6d823cff34a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a796c6fc089ab1d0db461a0c102d6d823cff34a"}], "stats": {"total": 257, "additions": 160, "deletions": 97}, "files": [{"sha": "cff3c0b81af9039719db24dc632dd2128fea19f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6232eadce37e1ffdb4d679966ad3b4a4ac435852/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6232eadce37e1ffdb4d679966ad3b4a4ac435852/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6232eadce37e1ffdb4d679966ad3b4a4ac435852", "patch": "@@ -1,3 +1,12 @@\n+2007-07-23  Jan Hubicka  <jH@suse.cz>\n+\n+\t* i386.c (ix86_secondary_memory_needed): Break out to...\n+\t(inline_secondary_memory_needed): ... here.\n+\t(ix86_memory_move_cost): Break out to ...\n+\t(inline_memory_move_cost): ... here; add support for IN value of 2 for\n+\tmaximum of input and output; fix handling of Q_REGS on 64bit.\n+\t(ix86_secondary_memory_needed): Microoptimize.\n+\n 2007-07-23  Sebastian Pop  <sebpop@gmail.com>\n \n \t* tree-data-ref.c (find_vertex_for_stmt, create_rdg_edge_for_ddr,"}, {"sha": "2ad01df373ffa9c7c946e18bbee3784fe49b21ef", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 151, "deletions": 97, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6232eadce37e1ffdb4d679966ad3b4a4ac435852/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6232eadce37e1ffdb4d679966ad3b4a4ac435852/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6232eadce37e1ffdb4d679966ad3b4a4ac435852", "patch": "@@ -20156,6 +20156,8 @@ ix86_preferred_output_reload_class (rtx x, enum reg_class regclass)\n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.\n \n+   To optimize register_move_cost performance, allow inline variant.\n+\n    The macro can't work reliably when one of the CLASSES is class containing\n    registers from multiple units (SSE, MMX, integer).  We avoid this by never\n    combining those units in single alternative in the machine description.\n@@ -20164,8 +20166,8 @@ ix86_preferred_output_reload_class (rtx x, enum reg_class regclass)\n    When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not\n    enforce these sanity checks.  */\n \n-int\n-ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n+static inline int\n+inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n \t\t\t      enum machine_mode mode, int strict)\n {\n   if (MAYBE_FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class1)\n@@ -20207,6 +20209,13 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n   return false;\n }\n \n+int\n+ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n+\t\t\t      enum machine_mode mode, int strict)\n+{\n+  return inline_secondary_memory_needed (class1, class2, mode, strict);\n+}\n+\n /* Return true if the registers in CLASS cannot represent the change from\n    modes FROM to TO.  */\n \n@@ -20242,6 +20251,137 @@ ix86_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n   return false;\n }\n \n+/* Return the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   This function is used extensively by register_move_cost that is used to\n+   build tables at startup.  Make it inline in this case.\n+   When IN is 2, return maximum of in and out move cost.\n+\n+   If moving between registers and memory is more expensive than\n+   between two registers, you should define this macro to express the\n+   relative cost.\n+\n+   Model also increased moving costs of QImode registers in non\n+   Q_REGS classes.\n+ */\n+static inline int\n+inline_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n+\t\t\t int in)\n+{\n+  int cost;\n+  if (FLOAT_CLASS_P (regclass))\n+    {\n+      int index;\n+      switch (mode)\n+\t{\n+\t  case SFmode:\n+\t    index = 0;\n+\t    break;\n+\t  case DFmode:\n+\t    index = 1;\n+\t    break;\n+\t  case XFmode:\n+\t    index = 2;\n+\t    break;\n+\t  default:\n+\t    return 100;\n+\t}\n+      if (in == 2)\n+        return MAX (ix86_cost->fp_load [index], ix86_cost->fp_store [index]);\n+      return in ? ix86_cost->fp_load [index] : ix86_cost->fp_store [index];\n+    }\n+  if (SSE_CLASS_P (regclass))\n+    {\n+      int index;\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\t  case 4:\n+\t    index = 0;\n+\t    break;\n+\t  case 8:\n+\t    index = 1;\n+\t    break;\n+\t  case 16:\n+\t    index = 2;\n+\t    break;\n+\t  default:\n+\t    return 100;\n+\t}\n+      if (in == 2)\n+        return MAX (ix86_cost->sse_load [index], ix86_cost->sse_store [index]);\n+      return in ? ix86_cost->sse_load [index] : ix86_cost->sse_store [index];\n+    }\n+  if (MMX_CLASS_P (regclass))\n+    {\n+      int index;\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\t  case 4:\n+\t    index = 0;\n+\t    break;\n+\t  case 8:\n+\t    index = 1;\n+\t    break;\n+\t  default:\n+\t    return 100;\n+\t}\n+      if (in)\n+        return MAX (ix86_cost->mmx_load [index], ix86_cost->mmx_store [index]);\n+      return in ? ix86_cost->mmx_load [index] : ix86_cost->mmx_store [index];\n+    }\n+  switch (GET_MODE_SIZE (mode))\n+    {\n+      case 1:\n+\tif (Q_CLASS_P (regclass) || TARGET_64BIT)\n+\t  {\n+\t    if (!in)\n+\t      return ix86_cost->int_store[0];\n+\t    if (TARGET_PARTIAL_REG_DEPENDENCY && !optimize_size)\n+\t      cost = ix86_cost->movzbl_load;\n+\t    else\n+\t      cost = ix86_cost->int_load[0];\n+\t    if (in == 2)\n+\t      return MAX (cost, ix86_cost->int_store[0]);\n+\t    return cost;\n+\t  }\n+\telse\n+\t  {\n+\t   if (in == 2)\n+\t     return MAX (ix86_cost->movzbl_load, ix86_cost->int_store[0] + 4);\n+\t   if (in)\n+\t     return ix86_cost->movzbl_load;\n+\t   else\n+\t     return ix86_cost->int_store[0] + 4;\n+\t  }\n+\tbreak;\n+      case 2:\n+\tif (in == 2)\n+\t  return MAX (ix86_cost->int_load[1], ix86_cost->int_store[1]);\n+\treturn in ? ix86_cost->int_load[1] : ix86_cost->int_store[1];\n+      default:\n+\t/* Compute number of 32bit moves needed.  TFmode is moved as XFmode.  */\n+\tif (mode == TFmode)\n+\t  mode = XFmode;\n+\tif (in == 2)\n+\t  cost = MAX (ix86_cost->int_load[2] , ix86_cost->int_store[2]);\n+\telse if (in)\n+\t  cost = ix86_cost->int_load[2];\n+\telse\n+\t  cost = ix86_cost->int_store[2];\n+\treturn (cost * (((int) GET_MODE_SIZE (mode)\n+\t\t        + UNITS_PER_WORD - 1) / UNITS_PER_WORD));\n+    }\n+}\n+\n+int\n+ix86_memory_move_cost (enum machine_mode mode, enum reg_class regclass, int in)\n+{\n+  return inline_memory_move_cost (mode, regclass, in);\n+}\n+\n+\n /* Return the cost of moving data from a register in class CLASS1 to\n    one in class CLASS2.\n \n@@ -20257,14 +20397,18 @@ ix86_register_move_cost (enum machine_mode mode, enum reg_class class1,\n      by load.  In order to avoid bad register allocation choices, we need\n      for this to be *at least* as high as the symmetric MEMORY_MOVE_COST.  */\n \n-  if (ix86_secondary_memory_needed (class1, class2, mode, 0))\n+  if (inline_secondary_memory_needed (class1, class2, mode, 0))\n     {\n       int cost = 1;\n \n-      cost += MAX (MEMORY_MOVE_COST (mode, class1, 0),\n-\t\t   MEMORY_MOVE_COST (mode, class1, 1));\n-      cost += MAX (MEMORY_MOVE_COST (mode, class2, 0),\n-\t\t   MEMORY_MOVE_COST (mode, class2, 1));\n+#if 0\n+      cost += MAX (inline_memory_move_cost (mode, class1, 0),\n+\t\t   inline_memory_move_cost (mode, class1, 1));\n+      cost += MAX (inline_memory_move_cost (mode, class2, 0),\n+\t\t   inline_memory_move_cost (mode, class2, 1));\n+#endif\n+      cost += inline_memory_move_cost (mode, class1, 2);\n+      cost += inline_memory_move_cost (mode, class2, 2);\n \n       /* In case of copying from general_purpose_register we may emit multiple\n          stores followed by single load causing memory size mismatch stall.\n@@ -20425,96 +20569,6 @@ ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n   return false;\n }\n \n-/* Return the cost of moving data of mode M between a\n-   register and memory.  A value of 2 is the default; this cost is\n-   relative to those in `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than\n-   between two registers, you should define this macro to express the\n-   relative cost.\n-\n-   Model also increased moving costs of QImode registers in non\n-   Q_REGS classes.\n- */\n-int\n-ix86_memory_move_cost (enum machine_mode mode, enum reg_class regclass, int in)\n-{\n-  if (FLOAT_CLASS_P (regclass))\n-    {\n-      int index;\n-      switch (mode)\n-\t{\n-\t  case SFmode:\n-\t    index = 0;\n-\t    break;\n-\t  case DFmode:\n-\t    index = 1;\n-\t    break;\n-\t  case XFmode:\n-\t    index = 2;\n-\t    break;\n-\t  default:\n-\t    return 100;\n-\t}\n-      return in ? ix86_cost->fp_load [index] : ix86_cost->fp_store [index];\n-    }\n-  if (SSE_CLASS_P (regclass))\n-    {\n-      int index;\n-      switch (GET_MODE_SIZE (mode))\n-\t{\n-\t  case 4:\n-\t    index = 0;\n-\t    break;\n-\t  case 8:\n-\t    index = 1;\n-\t    break;\n-\t  case 16:\n-\t    index = 2;\n-\t    break;\n-\t  default:\n-\t    return 100;\n-\t}\n-      return in ? ix86_cost->sse_load [index] : ix86_cost->sse_store [index];\n-    }\n-  if (MMX_CLASS_P (regclass))\n-    {\n-      int index;\n-      switch (GET_MODE_SIZE (mode))\n-\t{\n-\t  case 4:\n-\t    index = 0;\n-\t    break;\n-\t  case 8:\n-\t    index = 1;\n-\t    break;\n-\t  default:\n-\t    return 100;\n-\t}\n-      return in ? ix86_cost->mmx_load [index] : ix86_cost->mmx_store [index];\n-    }\n-  switch (GET_MODE_SIZE (mode))\n-    {\n-      case 1:\n-\tif (in)\n-\t  return (Q_CLASS_P (regclass) ? ix86_cost->int_load[0]\n-\t\t  : ix86_cost->movzbl_load);\n-\telse\n-\t  return (Q_CLASS_P (regclass) ? ix86_cost->int_store[0]\n-\t\t  : ix86_cost->int_store[0] + 4);\n-\tbreak;\n-      case 2:\n-\treturn in ? ix86_cost->int_load[1] : ix86_cost->int_store[1];\n-      default:\n-\t/* Compute number of 32bit moves needed.  TFmode is moved as XFmode.  */\n-\tif (mode == TFmode)\n-\t  mode = XFmode;\n-\treturn ((in ? ix86_cost->int_load[2] : ix86_cost->int_store[2])\n-\t\t* (((int) GET_MODE_SIZE (mode)\n-\t\t    + UNITS_PER_WORD - 1) / UNITS_PER_WORD));\n-    }\n-}\n-\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */"}]}