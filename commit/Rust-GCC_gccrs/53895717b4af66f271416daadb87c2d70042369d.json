{"sha": "53895717b4af66f271416daadb87c2d70042369d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM4OTU3MTdiNGFmNjZmMjcxNDE2ZGFhZGI4N2MyZDcwMDQyMzY5ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-01T12:45:00Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-01T12:45:00Z"}, "message": "Further tweak cant_combine_insn_p\n\nFrom-SVN: r37915", "tree": {"sha": "87148dc233f929b38746f0cfc16b6afb5cc15def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87148dc233f929b38746f0cfc16b6afb5cc15def"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53895717b4af66f271416daadb87c2d70042369d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53895717b4af66f271416daadb87c2d70042369d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53895717b4af66f271416daadb87c2d70042369d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53895717b4af66f271416daadb87c2d70042369d/comments", "author": null, "committer": null, "parents": [{"sha": "13f9714bb6a00a628ed654f3863cb7ed7b7d9eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f9714bb6a00a628ed654f3863cb7ed7b7d9eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f9714bb6a00a628ed654f3863cb7ed7b7d9eee"}], "stats": {"total": 58, "additions": 20, "deletions": 38}, "files": [{"sha": "bc366e2db4ae147ee47690117e834a9e24611b98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53895717b4af66f271416daadb87c2d70042369d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53895717b4af66f271416daadb87c2d70042369d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53895717b4af66f271416daadb87c2d70042369d", "patch": "@@ -1,3 +1,10 @@\n+2000-12-01  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* combine.c (cant_combine_insn_p): Only disallow insns involving\n+\thard regs if they are reg-reg moves.\n+\t(try_combine, can_combine_p, combinable_i3pat): Delete old\n+\tSMALL_REGISTER_CLASSES tests.\n+\n 2000-12-01  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.c (shiftcosts): Don't get INTVAL before testing"}, {"sha": "7fa23793cbddad1b1ef0eaf2fd203f477d2db13c", "filename": "gcc/combine.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53895717b4af66f271416daadb87c2d70042369d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53895717b4af66f271416daadb87c2d70042369d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=53895717b4af66f271416daadb87c2d70042369d", "patch": "@@ -1117,12 +1117,7 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t insns.  Eliminate this problem by not combining with such an insn.\n \n \t Also, on some machines we don't want to extend the life of a hard\n-\t register.\n-\n-\t This is the same test done in can_combine except that we don't test\n-\t if SRC is a CALL operation to permit a hard register with\n-\t SMALL_REGISTER_CLASSES, and that we have to take all_adjacent\n-\t into account.  */\n+\t register.  */\n \n       if (GET_CODE (src) == REG\n \t  && ((REGNO (dest) < FIRST_PSEUDO_REGISTER\n@@ -1135,11 +1130,7 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t\t reload can't handle a conflict with constraints of other\n \t\t inputs.  */\n \t      || (REGNO (src) < FIRST_PSEUDO_REGISTER\n-\t\t  && (! HARD_REGNO_MODE_OK (REGNO (src), GET_MODE (src))\n-\t\t      || (SMALL_REGISTER_CLASSES\n-\t\t\t  && ((! all_adjacent && ! REG_USERVAR_P (src))\n-\t\t\t      || (FUNCTION_VALUE_REGNO_P (REGNO (src))\n-\t\t\t\t  && ! REG_USERVAR_P (src))))))))\n+\t\t  && ! HARD_REGNO_MODE_OK (REGNO (src), GET_MODE (src)))))\n \treturn 0;\n     }\n   else if (GET_CODE (dest) != CC0)\n@@ -1292,10 +1283,6 @@ sets_function_arg_p (pat)\n    If I1_NOT_IN_SRC is non-zero, it means that finding I1 in the source\n    of a SET must prevent combination from occurring.\n \n-   On machines where SMALL_REGISTER_CLASSES is non-zero, we don't combine\n-   if the destination of a SET is a hard register that isn't a user\n-   variable.\n-\n    Before doing the above check, we first try to expand a field assignment\n    into a set of logical operations.\n \n@@ -1364,11 +1351,10 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n \t   && (reg_overlap_mentioned_p (i2dest, inner_dest)\n \t       || (i1dest && reg_overlap_mentioned_p (i1dest, inner_dest))))\n \n-\t  /* This is the same test done in can_combine_p except that we\n-\t     allow a hard register with SMALL_REGISTER_CLASSES if SRC is a\n-\t     CALL operation. Moreover, we can't test all_adjacent; we don't\n-\t     have to, since this instruction will stay in place, thus we are\n-\t     not considering increasing the lifetime of INNER_DEST.\n+\t  /* This is the same test done in can_combine_p except we can't test\n+\t     all_adjacent; we don't have to, since this instruction will stay\n+\t     in place, thus we are not considering increasing the lifetime of\n+\t     INNER_DEST.\n \n \t     Also, if this insn sets a function argument, combining it with\n \t     something that might need a spill could clobber a previous\n@@ -1378,13 +1364,7 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n \t  || (GET_CODE (inner_dest) == REG\n \t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n \t      && (! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n-\t\t\t\t\tGET_MODE (inner_dest))\n-\t\t || (SMALL_REGISTER_CLASSES && GET_CODE (src) != CALL\n-\t\t     && ! REG_USERVAR_P (inner_dest)\n-\t\t     && (FUNCTION_VALUE_REGNO_P (REGNO (inner_dest))\n-\t\t\t || (FUNCTION_ARG_REGNO_P (REGNO (inner_dest))\n-\t\t\t     && i3 != 0\n-\t\t\t     && sets_function_arg_p (prev_nonnote_insn (i3)))))))\n+\t\t\t\t\tGET_MODE (inner_dest))))\n \t  || (i1_not_in_src && reg_overlap_mentioned_p (i1dest, src)))\n \treturn 0;\n \n@@ -1485,14 +1465,13 @@ cant_combine_insn_p (insn)\n     return 0;\n   src = SET_SRC (set);\n   dest = SET_DEST (set);\n-  if (REG_P (src)\n-      && REGNO (src) < FIRST_PSEUDO_REGISTER\n-      && ! fixed_regs[REGNO (src)])\n-    return 1;\n-  if (REG_P (dest)\n-      && REGNO (dest) < FIRST_PSEUDO_REGISTER\n-      && ! fixed_regs[REGNO (dest)])\n+  if (REG_P (src) && REG_P (dest)\n+      && ((REGNO (src) < FIRST_PSEUDO_REGISTER\n+\t   && ! fixed_regs[REGNO (src)])\n+\t  || (REGNO (dest) < FIRST_PSEUDO_REGISTER\n+\t      && ! fixed_regs[REGNO (dest)])))\n     return 1;\n+\n   return 0;\n }\n \n@@ -1595,10 +1574,6 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n   if (i1 == 0 && GET_CODE (i3) == INSN && GET_CODE (PATTERN (i3)) == SET\n       && GET_CODE (SET_SRC (PATTERN (i3))) == REG\n       && REGNO (SET_SRC (PATTERN (i3))) >= FIRST_PSEUDO_REGISTER\n-      && (! SMALL_REGISTER_CLASSES\n-\t  || (GET_CODE (SET_DEST (PATTERN (i3))) != REG\n-\t      || REGNO (SET_DEST (PATTERN (i3))) >= FIRST_PSEUDO_REGISTER\n-\t      || REG_USERVAR_P (SET_DEST (PATTERN (i3)))))\n       && find_reg_note (i3, REG_DEAD, SET_SRC (PATTERN (i3)))\n       && GET_CODE (PATTERN (i2)) == PARALLEL\n       && ! side_effects_p (SET_DEST (PATTERN (i3)))"}]}