{"sha": "244a4af0453aa14bf60ae753edf6f88992d8c5e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ0YTRhZjA0NTNhYTE0YmY2MGFlNzUzZWRmNmY4ODk5MmQ4YzVlMA==", "commit": {"author": {"name": "Tim Freeman", "email": "tim@fungibole.com", "date": "2001-09-10T18:09:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-10T18:09:27Z"}, "message": "dwarf2out.c (incomplete_types, [...]): Make them into varray's and register them as roots with the garbage collector...\n\n        * dwarf2out.c (incomplete_types, decl_scope_table): Make them\n        into varray's and register them as roots with the garbage\n        collector so they are not collected too soon.\n\nFrom-SVN: r45513", "tree": {"sha": "80b0f844a5ff1cde1645f44b46cabce57b10314e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80b0f844a5ff1cde1645f44b46cabce57b10314e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/244a4af0453aa14bf60ae753edf6f88992d8c5e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244a4af0453aa14bf60ae753edf6f88992d8c5e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/244a4af0453aa14bf60ae753edf6f88992d8c5e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244a4af0453aa14bf60ae753edf6f88992d8c5e0/comments", "author": null, "committer": null, "parents": [{"sha": "71a18acf34505b8996ee91679cc7edc5758accb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a18acf34505b8996ee91679cc7edc5758accb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a18acf34505b8996ee91679cc7edc5758accb3"}], "stats": {"total": 86, "additions": 26, "deletions": 60}, "files": [{"sha": "c5ae29961469e6f4cfb024cafac05fec9640c1fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244a4af0453aa14bf60ae753edf6f88992d8c5e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244a4af0453aa14bf60ae753edf6f88992d8c5e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=244a4af0453aa14bf60ae753edf6f88992d8c5e0", "patch": "@@ -1,3 +1,9 @@\n+2001-09-10  Tim Freeman <tim@fungibole.com>\n+\n+\t* dwarf2out.c (incomplete_types, decl_scope_table): Make them\n+\tinto varray's and register them as roots with the garbage\n+\tcollector so they are not collected too soon.  \n+\n Mon Sep 10 14:21:26 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* Makefile.in (cfg.o, cfganal.o, cfgloop.o, cfgbuild.o, cfgcleanup.o):"}, {"sha": "b366ecf5a4e8ae5d3ef0320381b17e1e11670efc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 20, "deletions": 60, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/244a4af0453aa14bf60ae753edf6f88992d8c5e0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/244a4af0453aa14bf60ae753edf6f88992d8c5e0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=244a4af0453aa14bf60ae753edf6f88992d8c5e0", "patch": "@@ -3273,17 +3273,7 @@ static unsigned decl_die_table_in_use;\n    of declaration scopes at the current scope and containing\n    scopes.  This table is used to find the proper place to\n    define type declaration DIE's.  */\n-static tree *decl_scope_table;\n-\n-/* Number of elements currently allocated for the decl_scope_table.  */\n-static int decl_scope_table_allocated;\n-\n-/* Current level of nesting of declaration scopes.  */\n-static int decl_scope_depth;\n-\n-/* Size (in elements) of increments by which we may expand the\n-   decl_scope_table.  */\n-#define DECL_SCOPE_TABLE_INCREMENT 64\n+varray_type decl_scope_table;\n \n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n@@ -3368,20 +3358,11 @@ static unsigned ranges_table_in_use;\n static unsigned have_location_lists;\n \n /* A pointer to the base of a list of incomplete types which might be\n-   completed at some later time.  */\n-\n-static tree *incomplete_types_list;\n-\n-/* Number of elements currently allocated for the incomplete_types_list.  */\n-static unsigned incomplete_types_allocated;\n-\n-/* Number of elements of incomplete_types_list currently in use.  */\n-static unsigned incomplete_types;\n-\n-/* Size (in elements) of increments by which we may expand the incomplete\n-   types list.  Actually, a single hunk of space of this size should\n-   be enough for most typical programs.\t */\n-#define INCOMPLETE_TYPES_INCREMENT 64\n+   completed at some later time.  incomplete_types_list needs to be a VARRAY\n+   because we want to tell the garbage collector about it.  If we don't tell\n+   the garbage collector about it, we can garbage collect live data.\n+   Bug 4215.*/\n+varray_type incomplete_types;\n \n /* Record whether the function being analyzed contains inlined functions.  */\n static int current_function_has_inlines;\n@@ -9166,26 +9147,16 @@ static void\n push_decl_scope (scope)\n      tree scope;\n {\n-  /* Make room in the decl_scope_table, if necessary.  */\n-  if (decl_scope_table_allocated == decl_scope_depth)\n-    {\n-      decl_scope_table_allocated += DECL_SCOPE_TABLE_INCREMENT;\n-      decl_scope_table\n-\t= (tree *) xrealloc (decl_scope_table,\n-\t\t\t     decl_scope_table_allocated * sizeof (tree));\n-    }\n-\n-  decl_scope_table[decl_scope_depth] = scope;\n-  decl_scope_depth++;\n+  VARRAY_PUSH_TREE (decl_scope_table, scope);\n }\n \n /* Pop a declaration scope.  */\n static inline void\n pop_decl_scope ()\n {\n-  if (decl_scope_depth <= 0)\n+  if (VARRAY_ACTIVE_SIZE (decl_scope_table) <= 0)\n     abort ();\n-  --decl_scope_depth;\n+  VARRAY_POP (decl_scope_table);\n }\n \n /* Return the DIE for the scope that immediately contains this type.\n@@ -9227,8 +9198,8 @@ scope_die_for (t, context_die)\n \t first we check to see if we're in the middle of emitting it\n \t so we know where the new DIE should go.  */\n \n-      for (i = decl_scope_depth - 1; i >= 0; --i)\n-\tif (decl_scope_table[i] == containing_scope)\n+      for (i = VARRAY_ACTIVE_SIZE (decl_scope_table) - 1; i >= 0; --i)\n+\tif (VARRAY_TREE (decl_scope_table, i) == containing_scope)\n \t  break;\n \n       if (i < 0)\n@@ -9482,20 +9453,11 @@ gen_entry_point_die (decl, context_die)\n #endif\n \n /* Remember a type in the incomplete_types_list.  */\n-\n static void\n add_incomplete_type (type)\n      tree type;\n {\n-  if (incomplete_types == incomplete_types_allocated)\n-    {\n-      incomplete_types_allocated += INCOMPLETE_TYPES_INCREMENT;\n-      incomplete_types_list\n-\t= (tree *) xrealloc (incomplete_types_list,\n-\t\t\t     sizeof (tree) * incomplete_types_allocated);\n-    }\n-\n-  incomplete_types_list[incomplete_types++] = type;\n+  VARRAY_PUSH_TREE (incomplete_types, type);\n }\n \n /* Walk through the list of incomplete types again, trying once more to\n@@ -9504,13 +9466,10 @@ add_incomplete_type (type)\n static void\n retry_incomplete_types ()\n {\n-  register tree type;\n-\n-  while (incomplete_types)\n+  int i;\n+  for (i = VARRAY_ACTIVE_SIZE (incomplete_types) - 1; i >= 0; i--)\n     {\n-      --incomplete_types;\n-      type = incomplete_types_list[incomplete_types];\n-      gen_type_die (type, comp_unit_die);\n+      gen_type_die (VARRAY_TREE (incomplete_types, i), comp_unit_die);\n     }\n }\n \n@@ -11645,10 +11604,8 @@ dwarf2out_init (main_input_filename)\n   decl_die_table_in_use = 0;\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n-  decl_scope_table\n-    = (tree *) xcalloc (DECL_SCOPE_TABLE_INCREMENT, sizeof (tree));\n-  decl_scope_table_allocated = DECL_SCOPE_TABLE_INCREMENT;\n-  decl_scope_depth = 0;\n+  VARRAY_TREE_INIT (decl_scope_table, 256, \"decl_scope_table\");\n+  ggc_add_tree_varray_root (&decl_scope_table, 1);\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n   abbrev_die_table\n@@ -11673,6 +11630,9 @@ dwarf2out_init (main_input_filename)\n      invoked when the given (base) source file was compiled.  */\n   comp_unit_die = gen_compile_unit_die (main_input_filename);\n \n+  VARRAY_TREE_INIT (incomplete_types, 64, \"incomplete_types\");\n+  ggc_add_tree_varray_root (&incomplete_types, 1);\n+\n   VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n   ggc_add_rtx_varray_root (&used_rtx_varray, 1);\n "}]}