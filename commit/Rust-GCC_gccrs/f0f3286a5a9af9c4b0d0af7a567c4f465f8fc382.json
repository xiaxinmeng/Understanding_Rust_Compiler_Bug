{"sha": "f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBmMzI4NmE1YTlhZjljNGIwZDBhZjdhNTY3YzRmNDY1ZjhmYzM4Mg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2011-12-12T12:05:37Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2011-12-12T12:05:37Z"}, "message": "Support noexcept-specifications for transaction statements and expressions.\n\n\tgcc/cp/\n\t* semantics.c (finish_transaction_stmt, build_transaction_expr):\n\tAccept new noexcept parameter and handle it.\n\t* cp-tree.h (finish_transaction_stmt, build_transaction_expr): Adapt\n\tdeclarations.\n\t* parser.c (cp_parser_exception_specification_opt): Extract\n\tnoexcept-specification parsing to ...\n\t(cp_parser_noexcept_specification_opt): ...here.  Allow for parsing\n\tnon-constexpr noexcept arguments.\n\t(cp_parser_transaction, cp_parser_transaction_expression): Parse\n\tand handle noexcept-specifications.\n\t(cp_parser_function_transaction): Adapt to finish_transaction_stmt\n\tchange.\n\t* pt.c (tsubst_expr): Adapt to new noexcept parameters when\n\tbuilding transactions.\n\n\tgcc/testsuite/\n\t* g++.dg/tm/noexcept-1.C: New test.\n\t* g++.dg/tm/noexcept-2.C: New test.\n\t* g++.dg/tm/noexcept-3.C: New test.\n\t* g++.dg/tm/noexcept-4.C: New test.\n\t* g++.dg/tm/noexcept-5.C: New test.\n\nFrom-SVN: r182234", "tree": {"sha": "b258a4e01b1d5c494d1ec5b230e7af9499701e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b258a4e01b1d5c494d1ec5b230e7af9499701e88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2162c3daa351c9ceeceaea0f033595f90f858ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2162c3daa351c9ceeceaea0f033595f90f858ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2162c3daa351c9ceeceaea0f033595f90f858ca"}], "stats": {"total": 364, "additions": 322, "deletions": 42}, "files": [{"sha": "7db2598b3f3fe2d1c8f8adcacdc6b2b5c0bf5438", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -1,3 +1,20 @@\n+2011-12-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* semantics.c (finish_transaction_stmt, build_transaction_expr):\n+\tAccept new noexcept parameter and handle it.\n+\t* cp-tree.h (finish_transaction_stmt, build_transaction_expr): Adapt\n+\tdeclarations.\n+\t* parser.c (cp_parser_exception_specification_opt): Extract\n+\tnoexcept-specification parsing to ...\n+\t(cp_parser_noexcept_specification_opt): ...here.  Allow for parsing\n+\tnon-constexpr noexcept arguments.\n+\t(cp_parser_transaction, cp_parser_transaction_expression): Parse\n+    and handle noexcept-specifications.\n+\t(cp_parser_function_transaction): Adapt to finish_transaction_stmt\n+\tchange.\n+\t* pt.c (tsubst_expr): Adapt to new noexcept parameters when\n+\tbuilding transactions.\n+\n 2011-12-12  Torvald Riegel  <triegel@redhat.com>\n \n \t* cp-tree.def (MUST_NOT_THROW_EXPR): Add condition parameter."}, {"sha": "f4438165b4bbde622330a5025d9f482422a74e32", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -5587,8 +5587,8 @@ extern void finish_omp_barrier\t\t\t(void);\n extern void finish_omp_flush\t\t\t(void);\n extern void finish_omp_taskwait\t\t\t(void);\n extern tree begin_transaction_stmt\t\t(location_t, tree *, int);\n-extern void finish_transaction_stmt\t\t(tree, tree, int);\n-extern tree build_transaction_expr\t\t(location_t, tree, int);\n+extern void finish_transaction_stmt\t\t(tree, tree, int, tree);\n+extern tree build_transaction_expr\t\t(location_t, tree, int, tree);\n extern void finish_omp_taskyield\t\t(void);\n extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool, bool);\n extern tree baselink_for_fns                    (tree);"}, {"sha": "a0aa2a1a4f7c6535b7a4c634e4668fed404aca75", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 105, "deletions": 33, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -19564,19 +19564,25 @@ cp_parser_base_specifier (cp_parser* parser)\n \n /* Exception handling [gram.exception] */\n \n-/* Parse an (optional) exception-specification.\n+/* Parse an (optional) noexcept-specification.\n \n-   exception-specification:\n-     throw ( type-id-list [opt] )\n+   noexcept-specification:\n+     noexcept ( constant-expression ) [opt]\n \n-   Returns a TREE_LIST representing the exception-specification.  The\n-   TREE_VALUE of each node is a type.  */\n+   If no noexcept-specification is present, returns NULL_TREE.\n+   Otherwise, if REQUIRE_CONSTEXPR is false, then either parse and return any\n+   expression if parentheses follow noexcept, or return BOOLEAN_TRUE_NODE if\n+   there are no parentheses.  CONSUMED_EXPR will be set accordingly.\n+   Otherwise, returns a noexcept specification unless RETURN_COND is true,\n+   in which case a boolean condition is returned instead.  */\n \n static tree\n-cp_parser_exception_specification_opt (cp_parser* parser)\n+cp_parser_noexcept_specification_opt (cp_parser* parser,\n+\t\t\t\t      bool require_constexpr,\n+\t\t\t\t      bool* consumed_expr,\n+\t\t\t\t      bool return_cond)\n {\n   cp_token *token;\n-  tree type_id_list;\n   const char *saved_message;\n \n   /* Peek at the next token.  */\n@@ -19592,23 +19598,67 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \n-\t  /* Types may not be defined in an exception-specification.  */\n-\t  saved_message = parser->type_definition_forbidden_message;\n-\t  parser->type_definition_forbidden_message\n-\t    = G_(\"types may not be defined in an exception-specification\");\n+\t  if (require_constexpr)\n+\t    {\n+\t      /* Types may not be defined in an exception-specification.  */\n+\t      saved_message = parser->type_definition_forbidden_message;\n+\t      parser->type_definition_forbidden_message\n+\t      = G_(\"types may not be defined in an exception-specification\");\n \n-\t  expr = cp_parser_constant_expression (parser, false, NULL);\n+\t      expr = cp_parser_constant_expression (parser, false, NULL);\n \n-\t  /* Restore the saved message.  */\n-\t  parser->type_definition_forbidden_message = saved_message;\n+\t      /* Restore the saved message.  */\n+\t      parser->type_definition_forbidden_message = saved_message;\n+\t    }\n+\t  else\n+\t    {\n+\t      expr = cp_parser_expression (parser, false, NULL);\n+\t      *consumed_expr = true;\n+\t    }\n \n \t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t}\n       else\n-\texpr = boolean_true_node;\n+\t{\n+\t  expr = boolean_true_node;\n+\t  if (!require_constexpr)\n+\t    *consumed_expr = false;\n+\t}\n \n-      return build_noexcept_spec (expr, tf_warning_or_error);\n+      /* We cannot build a noexcept-spec right away because this will check\n+\t that expr is a constexpr.  */\n+      if (!return_cond)\n+\treturn build_noexcept_spec (expr, tf_warning_or_error);\n+      else\n+\treturn expr;\n     }\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Parse an (optional) exception-specification.\n+\n+   exception-specification:\n+     throw ( type-id-list [opt] )\n+\n+   Returns a TREE_LIST representing the exception-specification.  The\n+   TREE_VALUE of each node is a type.  */\n+\n+static tree\n+cp_parser_exception_specification_opt (cp_parser* parser)\n+{\n+  cp_token *token;\n+  tree type_id_list;\n+  const char *saved_message;\n+\n+  /* Peek at the next token.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  /* Is it a noexcept-specification?  */\n+  type_id_list = cp_parser_noexcept_specification_opt(parser, true, NULL,\n+\t\t\t\t\t\t      false);\n+  if (type_id_list != NULL_TREE)\n+    return type_id_list;\n \n   /* If it's not `throw', then there's no exception-specification.  */\n   if (!cp_parser_is_keyword (token, RID_THROW))\n@@ -26837,11 +26887,9 @@ cp_parser_txn_attribute_opt (cp_parser *parser)\n /* Parse a __transaction_atomic or __transaction_relaxed statement.\n \n    transaction-statement:\n-     __transaction_atomic txn-attribute[opt] txn-exception-spec[opt]\n+     __transaction_atomic txn-attribute[opt] txn-noexcept-spec[opt]\n        compound-statement\n-     __transaction_relaxed txn-exception-spec[opt] compound-statement\n-\n-   ??? The exception specification is not yet implemented.\n+     __transaction_relaxed txn-noexcept-spec[opt] compound-statement\n */\n \n static tree\n@@ -26850,7 +26898,7 @@ cp_parser_transaction (cp_parser *parser, enum rid keyword)\n   unsigned char old_in = parser->in_transaction;\n   unsigned char this_in = 1, new_in;\n   cp_token *token;\n-  tree stmt, attrs;\n+  tree stmt, attrs, noex;\n \n   gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n       || keyword == RID_TRANSACTION_RELAXED);\n@@ -26868,6 +26916,9 @@ cp_parser_transaction (cp_parser *parser, enum rid keyword)\n \tthis_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);\n     }\n \n+  /* Parse a noexcept specification.  */\n+  noex = cp_parser_noexcept_specification_opt (parser, true, NULL, true);\n+\n   /* Keep track if we're in the lexical scope of an outer transaction.  */\n   new_in = this_in | (old_in & TM_STMT_ATTR_OUTER);\n \n@@ -26877,18 +26928,16 @@ cp_parser_transaction (cp_parser *parser, enum rid keyword)\n   cp_parser_compound_statement (parser, NULL, false, false);\n   parser->in_transaction = old_in;\n \n-  finish_transaction_stmt (stmt, NULL, this_in);\n+  finish_transaction_stmt (stmt, NULL, this_in, noex);\n \n   return stmt;\n }\n \n /* Parse a __transaction_atomic or __transaction_relaxed expression.\n \n    transaction-expression:\n-     __transaction_atomic txn-exception-spec[opt] ( expression )\n-     __transaction_relaxed txn-exception-spec[opt] ( expression )\n-\n-   ??? The exception specification is not yet implemented.\n+     __transaction_atomic txn-noexcept-spec[opt] ( expression )\n+     __transaction_relaxed txn-noexcept-spec[opt] ( expression )\n */\n \n static tree\n@@ -26897,7 +26946,8 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n   unsigned char old_in = parser->in_transaction;\n   unsigned char this_in = 1;\n   cp_token *token;\n-  tree expr;\n+  tree expr, noex;\n+  bool noex_expr;\n \n   gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n       || keyword == RID_TRANSACTION_RELAXED);\n@@ -26917,14 +26967,36 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n   if (keyword == RID_TRANSACTION_RELAXED)\n     this_in |= TM_STMT_ATTR_RELAXED;\n \n+  /* Set this early.  This might mean that we allow transaction_cancel in\n+     an expression that we find out later actually has to be a constexpr.\n+     However, we expect that cxx_constant_value will be able to deal with\n+     this; also, if the noexcept has no constexpr, then what we parse next\n+     really is a transaction's body.  */\n   parser->in_transaction = this_in;\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n-  expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-  finish_parenthesized_expr (expr);\n-  expr = build_transaction_expr (token->location, expr, this_in);\n+  /* Parse a noexcept specification.  */\n+  noex = cp_parser_noexcept_specification_opt (parser, false, &noex_expr,\n+\t\t\t\t\t       true);\n \n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  if (!noex || !noex_expr\n+      || cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n+    {\n+      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\n+      expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      finish_parenthesized_expr (expr);\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+    }\n+  else\n+    {\n+      /* The only expression that is available got parsed for the noexcept\n+         already.  noexcept is true then.  */\n+      expr = noex;\n+      noex = boolean_true_node;\n+    }\n+\n+  expr = build_transaction_expr (token->location, expr, this_in, noex);\n   parser->in_transaction = old_in;\n \n   if (cp_parser_non_integral_constant_expression (parser, NIC_TRANSACTION))\n@@ -26980,7 +27052,7 @@ cp_parser_function_transaction (cp_parser *parser, enum rid keyword)\n \n   parser->in_transaction = old_in;\n \n-  finish_transaction_stmt (stmt, compound_stmt, new_in);\n+  finish_transaction_stmt (stmt, compound_stmt, new_in, NULL_TREE);\n \n   return ctor_initializer_p;\n }"}, {"sha": "3b0cb236dfaa30e2494973629c8560ea32fa2ea9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -13246,15 +13246,24 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n         if (TRANSACTION_EXPR_IS_STMT (t))\n           {\n+\t    tree body = TRANSACTION_EXPR_BODY (t);\n+\t    tree noex = NULL_TREE;\n+\t    if (TREE_CODE (body) == MUST_NOT_THROW_EXPR)\n+\t      {\n+\t\tnoex = MUST_NOT_THROW_COND (body);\n+\t\tif (noex == NULL_TREE)\n+\t\t  noex = boolean_true_node;\n+\t\tbody = TREE_OPERAND (body, 0);\n+\t      }\n             stmt = begin_transaction_stmt (input_location, NULL, flags);\n-            RECUR (TRANSACTION_EXPR_BODY (t));\n-            finish_transaction_stmt (stmt, NULL, flags);\n+            RECUR (body);\n+            finish_transaction_stmt (stmt, NULL, flags, RECUR (noex));\n           }\n         else\n           {\n             stmt = build_transaction_expr (EXPR_LOCATION (t),\n \t\t\t\t\t   RECUR (TRANSACTION_EXPR_BODY (t)),\n-\t\t\t\t\t   flags);\n+\t\t\t\t\t   flags, NULL_TREE);\n             return stmt;\n           }\n       }"}, {"sha": "4b1ec46cb9837c1aeaa2e55ac68f6fa3c0678c18", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -5020,27 +5020,47 @@ begin_transaction_stmt (location_t loc, tree *pcompound, int flags)\n \n /* End a __transaction_atomic or __transaction_relaxed statement.\n    If COMPOUND_STMT is non-null, this is for a function-transaction-block,\n-   and we should end the compound.  */\n+   and we should end the compound.  If NOEX is non-NULL, we wrap the body in\n+   a MUST_NOT_THROW_EXPR with NOEX as condition.  */\n \n void\n-finish_transaction_stmt (tree stmt, tree compound_stmt, int flags)\n+finish_transaction_stmt (tree stmt, tree compound_stmt, int flags, tree noex)\n {\n   TRANSACTION_EXPR_BODY (stmt) = pop_stmt_list (TRANSACTION_EXPR_BODY (stmt));\n   TRANSACTION_EXPR_OUTER (stmt) = (flags & TM_STMT_ATTR_OUTER) != 0;\n   TRANSACTION_EXPR_RELAXED (stmt) = (flags & TM_STMT_ATTR_RELAXED) != 0;\n   TRANSACTION_EXPR_IS_STMT (stmt) = 1;\n \n+  /* noexcept specifications are not allowed for function transactions.  */\n+  gcc_assert (!(noex && compound_stmt));\n+  if (noex)\n+    {\n+      tree body = build_must_not_throw_expr (TRANSACTION_EXPR_BODY (stmt),\n+\t\t\t\t\t     noex);\n+      SET_EXPR_LOCATION (body, EXPR_LOCATION (TRANSACTION_EXPR_BODY (stmt)));\n+      TREE_SIDE_EFFECTS (body) = 1;\n+      TRANSACTION_EXPR_BODY (stmt) = body;\n+    }\n+\n   if (compound_stmt)\n     finish_compound_stmt (compound_stmt);\n   finish_stmt ();\n }\n \n-/* Build a __transaction_atomic or __transaction_relaxed expression.  */\n+/* Build a __transaction_atomic or __transaction_relaxed expression.  If\n+   NOEX is non-NULL, we wrap the body in a MUST_NOT_THROW_EXPR with NOEX as\n+   condition.  */\n \n tree\n-build_transaction_expr (location_t loc, tree expr, int flags)\n+build_transaction_expr (location_t loc, tree expr, int flags, tree noex)\n {\n   tree ret;\n+  if (noex)\n+    {\n+      expr = build_must_not_throw_expr (expr, noex);\n+      SET_EXPR_LOCATION (expr, loc);\n+      TREE_SIDE_EFFECTS (expr) = 1;\n+    }\n   ret = build1 (TRANSACTION_EXPR, TREE_TYPE (expr), expr);\n   if (flags & TM_STMT_ATTR_RELAXED)\n \tTRANSACTION_EXPR_RELAXED (ret) = 1;"}, {"sha": "e09e96dd434dcad6e2ed831df198a6c8cad86762", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -1,3 +1,11 @@\n+2011-12-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* g++.dg/tm/noexcept-1.C: New test.\n+\t* g++.dg/tm/noexcept-2.C: New test.\n+\t* g++.dg/tm/noexcept-3.C: New test.\n+\t* g++.dg/tm/noexcept-4.C: New test.\n+\t* g++.dg/tm/noexcept-5.C: New test.\n+\n 2011-12-12  Torvald Riegel  <triegel@redhat.com>\n \n \t* c-c++-common/tm/20111206.c: New test."}, {"sha": "9b1a8c65ffe1f25eaff8266cccb135f00217e481", "filename": "gcc/testsuite/g++.dg/tm/noexcept-1.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-1.C?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O -std=c++0x -fdump-tree-tmmark -fdump-tree-tmlower\" }\n+\n+struct TrueFalse\n+{\n+  static constexpr bool v() { return true; }\n+};\n+\n+int global;\n+\n+template<typename T> int foo()\n+{\n+  __transaction_atomic noexcept(T::v()) { global += 1; }\n+  return __transaction_atomic noexcept(T::v()) (global + 2);\n+}\n+\n+int f1()\n+{\n+  return foo<TrueFalse>();\n+}\n+\n+int f2()\n+{\n+  return __transaction_atomic noexcept(true) (global + 3)\n+         + __transaction_atomic noexcept(TrueFalse::v()) (global + 4);\n+}\n+\n+int f3()\n+{\n+  __transaction_atomic noexcept(true) { global += 5; }\n+  __transaction_atomic noexcept(TrueFalse::v()) { global += 6; }\n+  return global;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"eh_must_not_throw\" 6 \"tmlower\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_RU\" 6 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmlower\" } } */"}, {"sha": "f9cbbb6123564c3f4198e4fdfb1139c1067250fc", "filename": "gcc/testsuite/g++.dg/tm/noexcept-2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-2.C?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -std=c++0x\" }\n+\n+// All of these must fail, because they are not constant expressions.\n+template<typename T> int foo(int x, T t)\n+{\n+  __transaction_atomic noexcept(t) { x++; }      /* { dg-error \"not a constant\" } */\n+  return __transaction_atomic noexcept(t) (x+1); /* { dg-error \"not a constant\" } */\n+}\n+\n+int bar(int x)\n+{\n+  __transaction_atomic noexcept(x == 23) { x++; }      /* { dg-error \"not a constant\" } */\n+  return __transaction_atomic noexcept(x == 42) (x+1); /* { dg-error \"not a constant\" } */\n+}\n+\n+int f(int x)\n+{\n+  return foo<bool>(x, true);\n+}"}, {"sha": "958290ef6a01641332c9d5146376eca16ebaad39", "filename": "gcc/testsuite/g++.dg/tm/noexcept-3.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-3.C?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O -std=c++0x -fdump-tree-tmmark -fdump-tree-tmlower\" }\n+\n+// Same as noexcept-1.C but all noexcepts are false.\n+\n+struct TrueFalse\n+{\n+  static constexpr bool v() { return false; }\n+};\n+\n+int global;\n+\n+template<typename T> int foo()\n+{\n+  __transaction_atomic noexcept(T::v()) { global += 1; }\n+  return __transaction_atomic noexcept(T::v()) (global + 2);\n+}\n+\n+int f1()\n+{\n+  return foo<TrueFalse>();\n+}\n+\n+int f2()\n+{\n+  return __transaction_atomic noexcept(false) (global + 3)\n+         + __transaction_atomic noexcept(TrueFalse::v()) (global + 4);\n+}\n+\n+int f3()\n+{\n+  __transaction_atomic noexcept(false) { global += 5; }\n+  __transaction_atomic noexcept(TrueFalse::v()) { global += 6; }\n+  return global;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"eh_must_not_throw\" 0 \"tmlower\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_RU\" 6 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmlower\" } } */"}, {"sha": "1166a159886e29d3704d626845c102518edd6de3", "filename": "gcc/testsuite/g++.dg/tm/noexcept-4.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-4.C?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O -std=c++0x -fdump-tree-tmmark -fdump-tree-tmlower\" }\n+\n+// Similar to noexcept-1.C but without an explicit (true) for noexcept.\n+\n+struct TrueFalse\n+{\n+  static constexpr bool v() { return true; }\n+};\n+\n+int global;\n+\n+template<typename T> int foo()\n+{\n+  __transaction_atomic noexcept { global += 1; }\n+  return __transaction_atomic noexcept (global + 2)\n+         + __transaction_atomic noexcept (global + 3);\n+}\n+\n+int f1()\n+{\n+  return foo<TrueFalse>();\n+}\n+\n+int f3()\n+{\n+  __transaction_atomic noexcept { global += 4; }\n+  return __transaction_atomic noexcept (global + 5)\n+         + __transaction_atomic noexcept (global + 6);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"eh_must_not_throw\" 6 \"tmlower\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_RU\" 6 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmlower\" } } */"}, {"sha": "44ef6177e6f2159738351e190f9cb94b4443dc37", "filename": "gcc/testsuite/g++.dg/tm/noexcept-5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnoexcept-5.C?ref=f0f3286a5a9af9c4b0d0af7a567c4f465f8fc382", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O -std=c++0x -fdump-tree-tmmark -fdump-tree-tmlower\" }\n+\n+int global;\n+\n+void f2(int x)\n+{\n+  __transaction_atomic\n+    {\n+      __transaction_atomic noexcept(true)\n+        {\n+\t  global += 1;\n+\t  if (x)\n+\t      throw 23;\n+        }\n+    }\n+}\n+/* { dg-final { scan-tree-dump-times \"eh_must_not_throw\" 1 \"tmlower\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_RU\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmlower\" } } */"}]}