{"sha": "51a24e4a984536371eaf146a922124af4a6982da", "node_id": "C_kwDOANBUbNoAKDUxYTI0ZTRhOTg0NTM2MzcxZWFmMTQ2YTkyMjEyNGFmNGE2OTgyZGE", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-12-08T01:24:35Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-12-21T03:12:50Z"}, "message": "Don't move cold code out of loop by checking bb count\n\nv8 changes:\n1. Use hotter_than_inner_loop instead of colder to store a hotter loop\nnearest to loop.\n2. Update the logic in fill_coldest_and_hotter_out_loop and\nget_coldest_out_loop to make common case O(1).\n3. Update function argument bb_colder_than_loop_preheader.\n4. Make cached array to vec<class *loop> for index checking.\n\nv7 changes:\n1. Refine get_coldest_out_loop to replace loop with checking\npre-computed coldest_outermost_loop and colder_than_inner_loop.\n2. Add function fill_cold_out_loop, compute coldest_outermost_loop and\ncolder_than_inner_loop recursively without loop.\n\nv6 changes:\n1. Add function fill_coldest_out_loop to pre compute the coldest\noutermost loop for each loop.\n2. Rename find_coldest_out_loop to get_coldest_out_loop.\n3. Add testcase ssa-lim-22.c to differentiate with ssa-lim-19.c.\n\nv5 changes:\n1. Refine comments for new functions.\n2. Use basic_block instead of count in bb_colder_than_loop_preheader\nto align with function name.\n3. Refine with simpler implementation for get_coldest_out_loop and\nref_in_loop_hot_body::operator for better understanding.\n\nv4 changes:\n1. Sort out profile_count comparision to function bb_cold_than_loop_preheader.\n2. Update ref_in_loop_hot_body::operator () to find cold_loop before compare.\n3. Split RTL invariant motion part out.\n4. Remove aux changes.\n\nv3 changes:\n1. Handle max_loop in determine_max_movement instead of outermost_invariant_loop.\n2. Remove unnecessary changes.\n3. Add for_all_locs_in_loop (loop, ref, ref_in_loop_hot_body) in can_sm_ref_p.\n4. \"gsi_next (&bsi);\" in move_computations_worker is kept since it caused\ninfinite loop when implementing v1 and the iteration is missed to be\nupdated actually.\n\nv1: https://gcc.gnu.org/pipermail/gcc-patches/2021-August/576488.html\nv2: https://gcc.gnu.org/pipermail/gcc-patches/2021-September/579086.html\nv3: https://gcc.gnu.org/pipermail/gcc-patches/2021-September/580211.html\nv4: https://gcc.gnu.org/pipermail/gcc-patches/2021-October/581231.html\nv5: https://gcc.gnu.org/pipermail/gcc-patches/2021-October/581961.html\n...\nv8: https://gcc.gnu.org/pipermail/gcc-patches/2021-December/586209.html\n\nThere was a patch trying to avoid move cold block out of loop:\n\nhttps://gcc.gnu.org/pipermail/gcc/2014-November/215551.html\n\nRichard suggested to \"never hoist anything from a bb with lower execution\nfrequency to a bb with higher one in LIM invariantness_dom_walker\nbefore_dom_children\".\n\nIn gimple LIM analysis, add get_coldest_out_loop to move invariants to\nexpected target loop, if profile count of the loop bb is colder\nthan target loop preheader, it won't be hoisted out of loop.\nLikely for store motion, if all locations of the REF in loop is cold,\ndon't do store motion of it.\n\nSPEC2017 performance evaluation shows 1% performance improvement for\nintrate GEOMEAN and no obvious regression for others.  Especially,\n500.perlbench_r +7.52% (Perf shows function S_regtry of perlbench is\nlargely improved.), and 548.exchange2_r+1.98%, 526.blender_r +1.00%\non P8LE.\n\ngcc/ChangeLog:\n\n2021-12-21  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\t* tree-ssa-loop-im.c (bb_colder_than_loop_preheader): New\n\tfunction.\n\t(get_coldest_out_loop): New function.\n\t(determine_max_movement): Use get_coldest_out_loop.\n\t(move_computations_worker): Adjust and fix iteration udpate.\n\t(class ref_in_loop_hot_body): New functor.\n\t(ref_in_loop_hot_body::operator): New.\n\t(can_sm_ref_p): Use for_all_locs_in_loop.\n\t(fill_coldest_and_hotter_out_loop): New.\n\t(tree_ssa_lim_finalize): Free coldest_outermost_loop and\n\thotter_than_inner_loop.\n\t(loop_invariant_motion_in_fun): Call fill_coldest_and_hotter_out_loop.\n\ngcc/testsuite/ChangeLog:\n\n2021-12-21  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\t* gcc.dg/tree-ssa/recip-3.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-lim-19.c: New test.\n\t* gcc.dg/tree-ssa/ssa-lim-20.c: New test.\n\t* gcc.dg/tree-ssa/ssa-lim-21.c: New test.\n\t* gcc.dg/tree-ssa/ssa-lim-22.c: New test.\n\t* gcc.dg/tree-ssa/ssa-lim-23.c: New test.", "tree": {"sha": "6fc2b374b66619b3c50106ed2c6fe4c486f7a57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fc2b374b66619b3c50106ed2c6fe4c486f7a57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51a24e4a984536371eaf146a922124af4a6982da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a24e4a984536371eaf146a922124af4a6982da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a24e4a984536371eaf146a922124af4a6982da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a24e4a984536371eaf146a922124af4a6982da/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd5ae148c47c6dee05adb19acd6a523f7187be7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5ae148c47c6dee05adb19acd6a523f7187be7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5ae148c47c6dee05adb19acd6a523f7187be7f"}], "stats": {"total": 296, "additions": 293, "deletions": 3}, "files": [{"sha": "641c91e719e25668fbf6768397b7b30abccad661", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -23,4 +23,4 @@ float h ()\n \tF[0] += E / d;\n }\n \n-/* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */\n+/* { dg-final { scan-tree-dump-times \" / \" 5 \"recip\" } } */"}, {"sha": "51c1913d003a8f651170c1f77aa22fc2b2d24a91", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-19.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-19.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+volatile int x;\n+void\n+bar (int, char *, char *);\n+void\n+foo (int *a, int n, int m, int s, int t)\n+{\n+  int i;\n+  int j;\n+  int k;\n+\n+  for (i = 0; i < m; i++) // Loop 1\n+    {\n+      if (__builtin_expect (x, 0))\n+\tfor (j = 0; j < n; j++) // Loop 2\n+\t  for (k = 0; k < n; k++) // Loop 3\n+\t    {\n+\t      bar (s / 5, \"one\", \"two\");\n+\t      a[t] = s;\n+\t    }\n+      a[t] = t;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"out of loop 2\" 4 \"lim2\" } } */\n+/* { dg-final { scan-tree-dump-times \"out of loop 1\" 3 \"lim2\" } } */\n+"}, {"sha": "bc60a040a70ac031d1ffb4b677591b8174d4aab6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-20.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-20.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile  } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+/* Test that `count' is not hoisted out of loop when bb is cold.  */\n+\n+int count;\n+volatile int x;\n+\n+struct obj {\n+  int data;\n+  struct obj *next;\n+\n+} *q;\n+\n+void\n+func (int m)\n+{\n+  struct obj *p;\n+  for (int i = 0; i < m; i++)\n+    if (__builtin_expect (x, 0))\n+      count++;\n+\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Executing store motion of\" \"lim2\"  }  } */"}, {"sha": "ffe6f8f699d70c2e6afc73fde2f4f84b7369e113", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-21.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-21.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile  } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+/* Test that `data' and 'data1' is not hoisted out of inner loop and outer loop\n+   when it is in cold loop.  */\n+\n+int count;\n+volatile int x;\n+\n+struct obj {\n+  int data;\n+  int data1;\n+  struct obj *next;\n+};\n+\n+void\n+func (int m, int n, int k, struct obj *a)\n+{\n+  struct obj *q = a;\n+  for (int j = 0; j < m; j++)\n+    if (__builtin_expect (m, 0))\n+      for (int i = 0; i < m; i++)\n+\t{\n+\t  if (__builtin_expect (x, 0))\n+\t    {\n+\t      count++;\n+\t      q->data += 3; /* Not hoisted out to inner loop. */\n+\t    }\n+\t  count += n;\n+\t  q->data1 += k; /* Not hoisted out to outer loop. */\n+\t}\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Executing store motion of\" \"lim2\"  }  } */\n+"}, {"sha": "16ba4ceb8ab478ff460efadd77a3946909b5acb8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-22.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-22.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+volatile int x;\n+volatile int y;\n+void\n+bar (int, char *, char *);\n+void\n+foo (int *a, int n, int m, int s, int t)\n+{\n+  int i;\n+  int j;\n+  int k;\n+\n+  for (i = 0; i < m; i++) // Loop 1\n+    {\n+      if (__builtin_expect (x, 0))\n+\tfor (j = 0; j < n; j++) // Loop 2\n+\t  if (__builtin_expect (y, 0))\n+\t    for (k = 0; k < n; k++) // Loop 3\n+\t      {\n+\t\tbar (s / 5, \"one\", \"two\");\n+\t\ta[t] = s;\n+\t      }\n+      a[t] = t;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"out of loop 3\" 4 \"lim2\" } } */\n+/* { dg-final { scan-tree-dump-times \"out of loop 1\" 3 \"lim2\" } } */\n+\n+"}, {"sha": "e7880746422b28f6450103075929e6f90d13dcef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-23.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-23.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+volatile int x;\n+void\n+bar (int, char *, char *);\n+void\n+foo (int *a, int n, int k)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      if (__builtin_expect (x, 0))\n+\tbar (k / 5, \"one\", \"two\");\n+      a[i] = k;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"out of loop 1\" \"lim2\" } } */\n+"}, {"sha": "b952386a9b175129828161452f9531258e18eb9e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 150, "deletions": 2, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a24e4a984536371eaf146a922124af4a6982da/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=51a24e4a984536371eaf146a922124af4a6982da", "patch": "@@ -146,6 +146,11 @@ class im_mem_ref\n enum dep_kind { lim_raw, sm_war, sm_waw };\n enum dep_state { dep_unknown, dep_independent, dep_dependent };\n \n+/* coldest outermost loop for given loop.  */\n+vec<class loop *> coldest_outermost_loop;\n+/* hotter outer loop nearest to given loop.  */\n+vec<class loop *> hotter_than_inner_loop;\n+\n /* Populate the loop dependence cache of REF for LOOP, KIND with STATE.  */\n \n static void\n@@ -417,6 +422,63 @@ movement_possibility (gimple *stmt)\n   return ret;\n }\n \n+/* Compare the profile count inequality of bb and loop's preheader, it is\n+   three-state as stated in profile-count.h, FALSE is returned if inequality\n+   cannot be decided.  */\n+bool\n+bb_colder_than_loop_preheader (basic_block bb, class loop *loop)\n+{\n+  gcc_assert (bb && loop);\n+  return bb->count < loop_preheader_edge (loop)->src->count;\n+}\n+\n+/* Check coldest loop between OUTERMOST_LOOP and LOOP by comparing profile\n+   count.\n+  It does three steps check:\n+  1) Check whether CURR_BB is cold in it's own loop_father, if it is cold, just\n+  return NULL which means it should not be moved out at all;\n+  2) CURR_BB is NOT cold, check if pre-computed COLDEST_LOOP is outside of\n+  OUTERMOST_LOOP, if it is inside of OUTERMOST_LOOP, return the COLDEST_LOOP;\n+  3) If COLDEST_LOOP is outside of OUTERMOST_LOOP, check whether there is a\n+  hotter loop between OUTERMOST_LOOP and loop in pre-computed\n+  HOTTER_THAN_INNER_LOOP, return it's nested inner loop, otherwise return\n+  OUTERMOST_LOOP.\n+  At last, the coldest_loop is inside of OUTERMOST_LOOP, just return it as\n+  the hoist target.  */\n+\n+static class loop *\n+get_coldest_out_loop (class loop *outermost_loop, class loop *loop,\n+\t\t      basic_block curr_bb)\n+{\n+  gcc_assert (outermost_loop == loop\n+\t      || flow_loop_nested_p (outermost_loop, loop));\n+\n+  /* If bb_colder_than_loop_preheader returns false due to three-state\n+    comparision, OUTERMOST_LOOP is returned finally to preserve the behavior.\n+    Otherwise, return the coldest loop between OUTERMOST_LOOP and LOOP.  */\n+  if (curr_bb && bb_colder_than_loop_preheader (curr_bb, loop))\n+    return NULL;\n+\n+  class loop *coldest_loop = coldest_outermost_loop[loop->num];\n+  if (loop_depth (coldest_loop) < loop_depth (outermost_loop))\n+    {\n+      class loop *hotter_loop = hotter_than_inner_loop[loop->num];\n+      if (!hotter_loop\n+\t  || loop_depth (hotter_loop) < loop_depth (outermost_loop))\n+\treturn outermost_loop;\n+\n+      /*  hotter_loop is between OUTERMOST_LOOP and LOOP like:\n+\t[loop tree root, ..., coldest_loop, ..., outermost_loop, ...,\n+\thotter_loop, second_coldest_loop, ..., loop]\n+\treturn second_coldest_loop to be the hoist target.  */\n+      class loop *aloop;\n+      for (aloop = hotter_loop->inner; aloop; aloop = aloop->next)\n+\tif (aloop == loop || flow_loop_nested_p (aloop, loop))\n+\t  return aloop;\n+    }\n+  return coldest_loop;\n+}\n+\n /* Suppose that operand DEF is used inside the LOOP.  Returns the outermost\n    loop to that we could move the expression using DEF if it did not have\n    other operands, i.e. the outermost loop enclosing LOOP in that the value\n@@ -685,7 +747,9 @@ determine_max_movement (gimple *stmt, bool must_preserve_exec)\n     level = ALWAYS_EXECUTED_IN (bb);\n   else\n     level = superloop_at_depth (loop, 1);\n-  lim_data->max_loop = level;\n+  lim_data->max_loop = get_coldest_out_loop (level, loop, bb);\n+  if (!lim_data->max_loop)\n+    return false;\n \n   if (gphi *phi = dyn_cast <gphi *> (stmt))\n     {\n@@ -1217,7 +1281,10 @@ move_computations_worker (basic_block bb)\n       /* We do not really want to move conditionals out of the loop; we just\n \t placed it here to force its operands to be moved if necessary.  */\n       if (gimple_code (stmt) == GIMPLE_COND)\n-\tcontinue;\n+\t{\n+\t  gsi_next (&bsi);\n+\t  continue;\n+\t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -3023,6 +3090,26 @@ ref_indep_loop_p (class loop *loop, im_mem_ref *ref, dep_kind kind)\n   return indep_p;\n }\n \n+class ref_in_loop_hot_body\n+{\n+public:\n+  ref_in_loop_hot_body (class loop *loop_) : l (loop_) {}\n+  bool operator () (mem_ref_loc *loc);\n+  class loop *l;\n+};\n+\n+/* Check the coldest loop between loop L and innermost loop.  If there is one\n+   cold loop between L and INNER_LOOP, store motion can be performed, otherwise\n+   no cold loop means no store motion.  get_coldest_out_loop also handles cases\n+   when l is inner_loop.  */\n+bool\n+ref_in_loop_hot_body::operator () (mem_ref_loc *loc)\n+{\n+  basic_block curr_bb = gimple_bb (loc->stmt);\n+  class loop *inner_loop = curr_bb->loop_father;\n+  return get_coldest_out_loop (l, inner_loop, curr_bb);\n+}\n+\n \n /* Returns true if we can perform store motion of REF from LOOP.  */\n \n@@ -3077,6 +3164,12 @@ can_sm_ref_p (class loop *loop, im_mem_ref *ref)\n   if (!ref_indep_loop_p (loop, ref, sm_war))\n     return false;\n \n+  /* Verify whether the candidate is hot for LOOP.  Only do store motion if the\n+    candidate's profile count is hot.  Statement in cold BB shouldn't be moved\n+    out of it's loop_father.  */\n+  if (!for_all_locs_in_loop (loop, ref, ref_in_loop_hot_body (loop)))\n+    return false;\n+\n   return true;\n }\n \n@@ -3289,6 +3382,48 @@ fill_always_executed_in (void)\n     fill_always_executed_in_1 (loop, contains_call);\n }\n \n+/* Find the coldest loop preheader for LOOP, also find the nearest hotter loop\n+   to LOOP.  Then recursively iterate each inner loop.  */\n+\n+void\n+fill_coldest_and_hotter_out_loop (class loop *coldest_loop,\n+\t\t\t\t  class loop *hotter_loop, class loop *loop)\n+{\n+  if (bb_colder_than_loop_preheader (loop_preheader_edge (loop)->src,\n+\t\t\t\t     coldest_loop))\n+    coldest_loop = loop;\n+\n+  coldest_outermost_loop[loop->num] = coldest_loop;\n+\n+  hotter_than_inner_loop[loop->num] = NULL;\n+  class loop *outer_loop = loop_outer (loop);\n+  if (hotter_loop\n+      && bb_colder_than_loop_preheader (loop_preheader_edge (loop)->src,\n+\t\t\t\t\thotter_loop))\n+    hotter_than_inner_loop[loop->num] = hotter_loop;\n+\n+  if (outer_loop && outer_loop != current_loops->tree_root\n+      && bb_colder_than_loop_preheader (loop_preheader_edge (loop)->src,\n+\t\t\t\t\touter_loop))\n+    hotter_than_inner_loop[loop->num] = outer_loop;\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf (MSG_NOTE, \"loop %d's coldest_outermost_loop is %d, \",\n+\t\t   loop->num, coldest_loop->num);\n+      if (hotter_than_inner_loop[loop->num])\n+\tdump_printf (MSG_NOTE, \"hotter_than_inner_loop is %d\\n\",\n+\t\t     hotter_than_inner_loop[loop->num]->num);\n+      else\n+\tdump_printf (MSG_NOTE, \"hotter_than_inner_loop is NULL\\n\");\n+    }\n+\n+  class loop *inner_loop;\n+  for (inner_loop = loop->inner; inner_loop; inner_loop = inner_loop->next)\n+    fill_coldest_and_hotter_out_loop (coldest_loop,\n+\t\t\t\t      hotter_than_inner_loop[loop->num],\n+\t\t\t\t      inner_loop);\n+}\n \n /* Compute the global information needed by the loop invariant motion pass.  */\n \n@@ -3373,6 +3508,9 @@ tree_ssa_lim_finalize (void)\n     free_affine_expand_cache (&memory_accesses.ttae_cache);\n \n   free (bb_loop_postorder);\n+\n+  coldest_outermost_loop.release ();\n+  hotter_than_inner_loop.release ();\n }\n \n /* Moves invariants from loops.  Only \"expensive\" invariants are moved out --\n@@ -3392,6 +3530,16 @@ loop_invariant_motion_in_fun (function *fun, bool store_motion)\n   /* Fills ALWAYS_EXECUTED_IN information for basic blocks.  */\n   fill_always_executed_in ();\n \n+  /* Pre-compute coldest outermost loop and nearest hotter loop of each loop.\n+   */\n+  class loop *loop;\n+  coldest_outermost_loop.create (number_of_loops (cfun));\n+  coldest_outermost_loop.safe_grow_cleared (number_of_loops (cfun));\n+  hotter_than_inner_loop.create (number_of_loops (cfun));\n+  hotter_than_inner_loop.safe_grow_cleared (number_of_loops (cfun));\n+  for (loop = current_loops->tree_root->inner; loop != NULL; loop = loop->next)\n+    fill_coldest_and_hotter_out_loop (loop, NULL, loop);\n+\n   int *rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n   int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n "}]}