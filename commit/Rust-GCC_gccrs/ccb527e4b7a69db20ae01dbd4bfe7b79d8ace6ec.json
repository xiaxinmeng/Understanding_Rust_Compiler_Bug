{"sha": "ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NiNTI3ZTRiN2E2OWRiMjBhZTAxZGJkNGJmZTdiNzlkOGFjZTZlYw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2005-03-25T17:54:59Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-03-25T17:54:59Z"}, "message": "re PR target/15491 (ICE (Internal compiler error) while compiling glibc to vax-linux target)\n\n\tPR target/15491\n        * vax.c (vax_rtx_costs_1): Merge with vax_rtx_costs.\n\t(vax_rtx_costs): Return false when passed unsupported rtx's.  Handle\n\tFLOAT_EXTEND, FLOAT_TRUNCATE and TRUNCATE.  Fix costs for POST_INC,\n\tPRE_DEC, NEG and NOT.\n\nFrom-SVN: r97050", "tree": {"sha": "2f98af8b256d8766bcb9dd5ec92759432d64a1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f98af8b256d8766bcb9dd5ec92759432d64a1b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec/comments", "author": null, "committer": null, "parents": [{"sha": "c3861e7ad196b2a58346699e54f8dc532bf693af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3861e7ad196b2a58346699e54f8dc532bf693af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3861e7ad196b2a58346699e54f8dc532bf693af"}], "stats": {"total": 209, "additions": 129, "deletions": 80}, "files": [{"sha": "1559b19431214a62c2a11431496942c1eb8d57d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec", "patch": "@@ -1,3 +1,11 @@\n+2005-03-25  John David Anglin  <dave.anglin@nrc-crnc.gc.ca>\n+\n+\tPR target/15491\n+        * vax.c (vax_rtx_costs_1): Merge with vax_rtx_costs.\n+\t(vax_rtx_costs): Return false when passed unsupported rtx's.  Handle\n+\tFLOAT_EXTEND, FLOAT_TRUNCATE and TRUNCATE.  Fix costs for POST_INC,\n+\tPRE_DEC, NEG and NOT.\n+\n 2005-03-25  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c: Convert uses of fold (build (...)) to"}, {"sha": "38dd8155487ed42c383d752ce68d2e649415ef15", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 121, "deletions": 80, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=ccb527e4b7a69db20ae01dbd4bfe7b79d8ace6ec", "patch": "@@ -50,7 +50,6 @@ static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, tree);\n static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx);\n-static int vax_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n static bool vax_rtx_costs (rtx, int, int, int *);\n static rtx vax_struct_value_rtx (tree, int);\n \f\n@@ -529,179 +528,228 @@ vax_address_cost (rtx x)\n \n /* Cost of an expression on a VAX.  This version has costs tuned for the\n    CVAX chip (found in the VAX 3 series) with comments for variations on\n-   other models.  */\n+   other models.\n \n-static int\n-vax_rtx_costs_1 (register rtx x, enum rtx_code code, enum rtx_code outer_code)\n+   FIXME: The costs need review, particularly for TRUNCATE, FLOAT_EXTEND\n+   and FLOAT_TRUNCATE.  We need a -mcpu option to allow provision of\n+   costs on a per cpu basis.  */\n+\n+static bool\n+vax_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n-  register int c;\n-  int i = 0;\t\t\t\t/* may be modified in switch */\n+  int i = 0;\t\t\t\t   /* may be modified in switch */\n   const char *fmt = GET_RTX_FORMAT (code); /* may be modified in switch */\n \n   switch (code)\n     {\n       /* On a VAX, constants from 0..63 are cheap because they can use the\n-         1 byte literal constant format.  compare to -1 should be made cheap\n-         so that decrement-and-branch insns can be formed more easily (if\n-         the value -1 is copied to a register some decrement-and-branch\n+\t 1 byte literal constant format.  Compare to -1 should be made cheap\n+\t so that decrement-and-branch insns can be formed more easily (if\n+\t the value -1 is copied to a register some decrement-and-branch\n \t patterns will not match).  */\n     case CONST_INT:\n       if (INTVAL (x) == 0)\n-\treturn 0;\n+\treturn true;\n       if (outer_code == AND)\n-        return ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077) ? 1 : 2;\n-      if ((unsigned HOST_WIDE_INT) INTVAL (x) <= 077)\n-\treturn 1;\n-      if (outer_code == COMPARE && INTVAL (x) == -1)\n-        return 1;\n-      if (outer_code == PLUS && (unsigned HOST_WIDE_INT) -INTVAL (x) <= 077)\n-        return 1;\n+\t{\n+          *total = ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077) ? 1 : 2;\n+\t  return true;\n+\t}\n+      if ((unsigned HOST_WIDE_INT) INTVAL (x) <= 077\n+\t  || (outer_code == COMPARE\n+\t      && INTVAL (x) == -1)\n+\t  || ((outer_code == PLUS || outer_code == MINUS)\n+\t      && (unsigned HOST_WIDE_INT) -INTVAL (x) <= 077))\n+\t{\n+\t  *total = 1;\n+\t  return true;\n+\t}\n       /* FALLTHRU */\n \n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      return 3;\n+      *total = 3;\n+      return true;\n \n     case CONST_DOUBLE:\n       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-        return vax_float_literal (x) ? 5 : 8;\n+\t*total = vax_float_literal (x) ? 5 : 8;\n       else\n-        return (((CONST_DOUBLE_HIGH (x) == 0\n-\t\t  && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x) < 64)\n-\t         || (outer_code == PLUS\n-\t\t     && CONST_DOUBLE_HIGH (x) == -1\t\t\\\n-\t\t     && (unsigned HOST_WIDE_INT)-CONST_DOUBLE_LOW (x) < 64))\n-\t        ? 2 : 5);\n+        *total = ((CONST_DOUBLE_HIGH (x) == 0\n+\t\t   && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x) < 64)\n+\t\t  || (outer_code == PLUS\n+\t\t      && CONST_DOUBLE_HIGH (x) == -1\n+\t\t      && (unsigned HOST_WIDE_INT)-CONST_DOUBLE_LOW (x) < 64))\n+\t\t ? 2 : 5;\n+      return true;\n  \n     case POST_INC:\n-      return 2;\n+      *total = 2;\n+      return true;\t\t/* Implies register operand.  */\n+\n     case PRE_DEC:\n-      return 3;\n+      *total = 3;\n+      return true;\t\t/* Implies register operand.  */\n+\n     case MULT:\n       switch (mode)\n \t{\n \tcase DFmode:\n-\t  c = 16;\t\t/* 4 on VAX 9000 */\n+\t  *total = 16;\t\t/* 4 on VAX 9000 */\n \t  break;\n \tcase SFmode:\n-\t  c = 9;\t\t/* 4 on VAX 9000, 12 on VAX 2 */\n+\t  *total = 9;\t\t/* 4 on VAX 9000, 12 on VAX 2 */\n \t  break;\n \tcase DImode:\n-\t  c = 16;\t\t/* 6 on VAX 9000, 28 on VAX 2 */\n+\t  *total = 16;\t\t/* 6 on VAX 9000, 28 on VAX 2 */\n \t  break;\n \tcase SImode:\n \tcase HImode:\n \tcase QImode:\n-\t  c = 10;\t\t/* 3-4 on VAX 9000, 20-28 on VAX 2 */\n+\t  *total = 10;\t\t/* 3-4 on VAX 9000, 20-28 on VAX 2 */\n \t  break;\n \tdefault:\n-\t  return MAX_COST;\t/* Mode is not supported.  */\n+\t  *total = MAX_COST;\t/* Mode is not supported.  */\n+\t  return true;\n \t}\n       break;\n+\n     case UDIV:\n       if (mode != SImode)\n-\treturn MAX_COST;\t/* Mode is not supported.  */\n-      c = 17;\n+\t{\n+\t  *total = MAX_COST;\t/* Mode is not supported.  */\n+\t  return true;\n+\t}\n+      *total = 17;\n       break;\n+\n     case DIV:\n       if (mode == DImode)\n-\tc = 30;\t/* highly variable */\n+\t*total = 30;\t\t/* Highly variable.  */\n       else if (mode == DFmode)\n \t/* divide takes 28 cycles if the result is not zero, 13 otherwise */\n-\tc = 24;\n+\t*total = 24;\n       else\n-\tc = 11;\t\t\t/* 25 on VAX 2 */\n+\t*total = 11;\t\t/* 25 on VAX 2 */\n       break;\n+\n     case MOD:\n-      c = 23;\n+      *total = 23;\n       break;\n+\n     case UMOD:\n       if (mode != SImode)\n-\treturn MAX_COST;\t/* Mode is not supported.  */\n-      c = 29;\n+\t{\n+\t  *total = MAX_COST;\t/* Mode is not supported.  */\n+\t  return true;\n+\t}\n+      *total = 29;\n       break;\n+\n     case FLOAT:\n-      c = 6 + (mode == DFmode) + (GET_MODE (XEXP (x, 0)) != SImode);\n-      /* 4 on VAX 9000 */\n+      *total = (6\t\t/* 4 on VAX 9000 */\n+\t\t+ (mode == DFmode) + (GET_MODE (XEXP (x, 0)) != SImode));\n       break;\n+\n     case FIX:\n-      c = 7;\t\t\t/* 17 on VAX 2 */\n+      *total = 7;\t\t/* 17 on VAX 2 */\n       break;\n+\n     case ASHIFT:\n     case LSHIFTRT:\n     case ASHIFTRT:\n       if (mode == DImode)\n-\tc = 12;\n+\t*total = 12;\n       else\n-\tc = 10;\t\t\t/* 6 on VAX 9000 */\n+\t*total = 10;\t\t/* 6 on VAX 9000 */\n       break;\n+\n     case ROTATE:\n     case ROTATERT:\n-      c = 6;\t\t\t/* 5 on VAX 2, 4 on VAX 9000 */\n+      *total = 6;\t\t/* 5 on VAX 2, 4 on VAX 9000 */\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\tfmt = \"e\";\t/* all constant rotate counts are short */\n+\tfmt = \"e\"; \t\t/* all constant rotate counts are short */\n       break;\n+\n     case PLUS:\n     case MINUS:\n-      c = (mode == DFmode) ? 13 : 8;\t/* 6/8 on VAX 9000, 16/15 on VAX 2 */\n+      *total = (mode == DFmode) ? 13 : 8; /* 6/8 on VAX 9000, 16/15 on VAX 2 */\n       /* Small integer operands can use subl2 and addl2.  */\n       if ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t  && (unsigned HOST_WIDE_INT)(INTVAL (XEXP (x, 1)) + 63) < 127)\n \tfmt = \"e\";\n       break;\n+\n     case IOR:\n     case XOR:\n-      c = 3;\n+      *total = 3;\n       break;\n+\n     case AND:\n       /* AND is special because the first operand is complemented.  */\n-      c = 3;\n+      *total = 3;\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \t{\n \t  if ((unsigned HOST_WIDE_INT)~INTVAL (XEXP (x, 0)) > 63)\n-\t    c = 4;\n+\t    *total = 4;\n \t  fmt = \"e\";\n \t  i = 1;\n \t}\n       break;\n+\n     case NEG:\n       if (mode == DFmode)\n-\treturn 9;\n+\t*total = 9;\n       else if (mode == SFmode)\n-\treturn 6;\n+\t*total = 6;\n       else if (mode == DImode)\n-\treturn 4;\n+\t*total = 4;\n+      else\n+\t*total = 2;\n+      break;\n+\n     case NOT:\n-      return 2;\n+      *total = 2;\n+      break;\n+\n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n-      c = 15;\n+      *total = 15;\n       break;\n+\n     case MEM:\n       if (mode == DImode || mode == DFmode)\n-\tc = 5;\t\t\t\t/* 7 on VAX 2 */\n+\t*total = 5;\t\t/* 7 on VAX 2 */\n       else\n-\tc = 3;\t\t\t\t/* 4 on VAX 2 */\n+\t*total = 3;\t\t/* 4 on VAX 2 */\n       x = XEXP (x, 0);\n-      if (GET_CODE (x) == REG || GET_CODE (x) == POST_INC)\n-\treturn c;\n-      return c + vax_address_cost_1 (x);\n-    default:\n-      c = 3;\n+      if (GET_CODE (x) != REG && GET_CODE (x) != POST_INC)\n+\t*total += vax_address_cost_1 (x);\n+      return true;\n+\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case TRUNCATE:\n+      *total = 3;\t\t/* FIXME: Costs need to be checked  */\n       break;\n+\n+    default:\n+      return false;\n     }\n \n   /* Now look inside the expression.  Operands which are not registers or\n      short constants add to the cost.\n \n      FMT and I may have been adjusted in the switch above for instructions\n-     which require special handling */\n+     which require special handling.  */\n \n   while (*fmt++ == 'e')\n     {\n-      register rtx op = XEXP (x, i++);\n+      rtx op = XEXP (x, i);\n+\n+      i += 1;\n       code = GET_CODE (op);\n \n       /* A NOT is likely to be found as the first operand of an AND\n@@ -715,50 +763,43 @@ vax_rtx_costs_1 (register rtx x, enum rtx_code code, enum rtx_code outer_code)\n \tcase CONST_INT:\n \t  if ((unsigned HOST_WIDE_INT)INTVAL (op) > 63\n \t      && GET_MODE (x) != QImode)\n-\t    c += 1;\t\t/* 2 on VAX 2 */\n+\t    *total += 1;\t/* 2 on VAX 2 */\n \t  break;\n \tcase CONST:\n \tcase LABEL_REF:\n \tcase SYMBOL_REF:\n-\t  c += 1;\t\t/* 2 on VAX 2 */\n+\t  *total += 1;\t\t/* 2 on VAX 2 */\n \t  break;\n \tcase CONST_DOUBLE:\n \t  if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT)\n \t    {\n \t      /* Registers are faster than floating point constants -- even\n \t\t those constants which can be encoded in a single byte.  */\n \t      if (vax_float_literal (op))\n-\t\tc++;\n+\t\t*total += 1;\n \t      else\n-\t\tc += (GET_MODE (x) == DFmode) ? 3 : 2;\n+\t\t*total += (GET_MODE (x) == DFmode) ? 3 : 2;\n \t    }\n \t  else\n \t    {\n \t      if (CONST_DOUBLE_HIGH (op) != 0\n \t\t  || (unsigned)CONST_DOUBLE_LOW (op) > 63)\n-\t\tc += 2;\n+\t\t*total += 2;\n \t    }\n \t  break;\n \tcase MEM:\n-\t  c += 1;\t\t/* 2 on VAX 2 */\n+\t  *total += 1;\t\t/* 2 on VAX 2 */\n \t  if (GET_CODE (XEXP (op, 0)) != REG)\n-\t    c += vax_address_cost_1 (XEXP (op, 0));\n+\t    *total += vax_address_cost_1 (XEXP (op, 0));\n \t  break;\n \tcase REG:\n \tcase SUBREG:\n \t  break;\n \tdefault:\n-\t  c += 1;\n+\t  *total += 1;\n \t  break;\n \t}\n     }\n-  return c;\n-}\n-\n-static bool\n-vax_rtx_costs (rtx x, int code, int outer_code, int * total)\n-{\n-  *total = vax_rtx_costs_1 (x, code, outer_code);\n   return true;\n }\n \f"}]}