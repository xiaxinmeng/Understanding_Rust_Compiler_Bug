{"sha": "bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwMjI5ZjlmNjkyOWUwMDBiYzYzOGUyNmZjZDI1ZmYwZTk1YjJlZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-08-14T18:39:15Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-08-14T18:39:15Z"}, "message": "gfortran.texi (caf_register_t): Add CAF_REGTYPE_CRITICAL.\n\ngcc/fortran/\n2014-08-14  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.texi (caf_register_t): Add CAF_REGTYPE_CRITICAL.\n        (_gfortran_caf_register): Update for locking/critical.\n        (_gfortran_caf_lock, _gfortran_caf_unlock): Add.\n        * resolve.c (resolve_critical): New.\n        (gfc_resolve_code): Call it.\n        * trans-decl.c (gfor_fndecl_caf_critical,\n        gfor_fndecl_caf_end_critical): Remove.\n        (gfor_fndecl_caf_lock, gfor_fndecl_caf_unlock): Add.\n        (gfc_build_builtin_function_decls): Remove critical,\n        assign locking declarations.\n        (generate_coarray_sym_init): Handle locking and\n        critical variables.\n        * trans-stmt.c (gfc_trans_critical): Add calls to\n        lock/unlock libcaf functions.\n        * trans.h (gfc_coarray_type): Update locking, add\n        critical enum values.\n        (gfor_fndecl_caf_critical, gfor_fndecl_caf_end_critical): Remove.\n        (gfor_fndecl_caf_lock, gfor_fndecl_caf_unlock): Add.\n\nlibgfortran/\n2014-08-14  Tobias Burnus  <burnus@net-b.de>\n\n        * caf/libcaf.h (caf_register_t): Update for critical.\n        (_gfortran_caf_critical, _gfortran_caf_end_critical): Remove.\n        (_gfortran_caf_lock, _gfortran_caf_unlock): Add.\n        * caf/single.c (_gfortran_caf_register): Handle locking\n        variables.\n        (_gfortran_caf_sendget): Re-name args for consistency.\n        (_gfortran_caf_lock, _gfortran_caf_unlock): Add.\n\nFrom-SVN: r213979", "tree": {"sha": "f112e8c0d52e17d8eda54ec7f00375059153f751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f112e8c0d52e17d8eda54ec7f00375059153f751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c194537c63180722ea6977000451174f5da1b40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c194537c63180722ea6977000451174f5da1b40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c194537c63180722ea6977000451174f5da1b40b"}], "stats": {"total": 378, "additions": 327, "deletions": 51}, "files": [{"sha": "4a37198a82a2c55566327cdb2559e64384759426", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -1,3 +1,24 @@\n+2014-08-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.texi (caf_register_t): Add CAF_REGTYPE_CRITICAL.\n+\t(_gfortran_caf_register): Update for locking/critical.\n+\t(_gfortran_caf_lock, _gfortran_caf_unlock): Add.\n+\t* resolve.c (resolve_critical): New.\n+\t(gfc_resolve_code): Call it.\n+\t* trans-decl.c (gfor_fndecl_caf_critical,\n+\tgfor_fndecl_caf_end_critical): Remove.\n+\t(gfor_fndecl_caf_lock, gfor_fndecl_caf_unlock): Add.\n+\t(gfc_build_builtin_function_decls): Remove critical,\n+\tassign locking declarations.\n+\t(generate_coarray_sym_init): Handle locking and\n+\tcritical variables.\n+\t* trans-stmt.c (gfc_trans_critical): Add calls to\n+\tlock/unlock libcaf functions.\n+\t* trans.h (gfc_coarray_type): Update locking, add\n+\tcritical enum values.\n+\t(gfor_fndecl_caf_critical, gfor_fndecl_caf_end_critical): Remove.\n+\t(gfor_fndecl_caf_lock, gfor_fndecl_caf_unlock): Add.\n+\n 2014-08-14  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.texi (Coarray Programming): Add first ABI"}, {"sha": "0ce722640925d7f9405bdd0704afa34346366693", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 108, "deletions": 13, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -157,7 +157,7 @@ Boston, MA 02110-1301, USA@*\n @top Introduction\n @cindex Introduction\n \n-This manual documents the use of @command{gfortran}, \n+This manual documents the use of @command{gfortran},\n the GNU Fortran compiler.  You can find in this manual how to invoke\n @command{gfortran}, as well as its features and incompatibilities.\n \n@@ -290,13 +290,13 @@ It also helps developers to find bugs in the compiler itself.\n @item\n Provide information in the generated machine code that can\n make it easier to find bugs in the program (using a debugging tool,\n-called a @dfn{debugger}, such as the GNU Debugger @command{gdb}). \n+called a @dfn{debugger}, such as the GNU Debugger @command{gdb}).\n \n @item\n Locate and gather machine code already generated to\n perform actions requested by statements in the user's program.\n This machine code is organized into @dfn{modules} and is located\n-and @dfn{linked} to the user program. \n+and @dfn{linked} to the user program.\n @end itemize\n \n The GNU Fortran compiler consists of several components:\n@@ -2714,7 +2714,8 @@ are in a shared library.  The following attributes are available:\n \n @itemize\n @item @code{DLLEXPORT} -- provide a global pointer to a pointer in the DLL\n-@item @code{DLLIMPORT} -- reference the function or variable using a global pointer \n+@item @code{DLLIMPORT} -- reference the function or variable using a\n+global pointer\n @end itemize\n \n For dummy arguments, the @code{NO_ARG_CHECK} attribute can be used; in\n@@ -2864,7 +2865,7 @@ if e.g. an input-output edit descriptor is invalid in a given standard.\n Possible values are (bitwise or-ed) @code{GFC_STD_F77} (1),\n @code{GFC_STD_F95_OBS} (2), @code{GFC_STD_F95_DEL} (4), @code{GFC_STD_F95}\n (8), @code{GFC_STD_F2003} (16), @code{GFC_STD_GNU} (32),\n-@code{GFC_STD_LEGACY} (64), @code{GFC_STD_F2008} (128), \n+@code{GFC_STD_LEGACY} (64), @code{GFC_STD_F2008} (128),\n @code{GFC_STD_F2008_OBS} (256) and GFC_STD_F2008_TS (512). Default:\n @code{GFC_STD_F95_OBS | GFC_STD_F95_DEL | GFC_STD_F95 | GFC_STD_F2003\n | GFC_STD_F2008 | GFC_STD_F2008_TS | GFC_STD_F2008_OBS | GFC_STD_F77\n@@ -3103,7 +3104,7 @@ by-reference argument.  Note that with the @option{-ff2c} option,\n the argument passing is modified and no longer completely matches\n the platform ABI.  Some other Fortran compilers use @code{f2c}\n semantic by default; this might cause problems with\n-interoperablility. \n+interoperablility.\n \n GNU Fortran passes most arguments by reference, i.e. by passing a\n pointer to the data.  Note that the compiler might use a temporary\n@@ -3215,7 +3216,8 @@ typedef enum caf_register_t {\n   CAF_REGTYPE_COARRAY_STATIC,\n   CAF_REGTYPE_COARRAY_ALLOC,\n   CAF_REGTYPE_LOCK_STATIC,\n-  CAF_REGTYPE_LOCK_ALLOC\n+  CAF_REGTYPE_LOCK_ALLOC,\n+  CAF_REGTYPE_CRITICAL\n }\n caf_register_t;\n @end verbatim\n@@ -3234,6 +3236,8 @@ caf_register_t;\n * _gfortran_caf_send:: Sending data from a local image to a remote image\n * _gfortran_caf_get:: Getting data from a remote image\n * _gfortran_caf_sendget:: Sending data between remote images\n+* _gfortran_caf_lock:: Locking a lock variable\n+* _gfortran_caf_unlock:: Unlocking a lock variable\n @end menu\n \n \n@@ -3360,17 +3364,26 @@ value and, if not-@code{NULL}, @var{ERRMSG} shall be set to a string describing\n the failure. The function shall return a pointer to the requested memory\n for the local image as a call to @code{malloc} would do.\n \n+For @code{CAF_REGTYPE_COARRAY_STATIC} and @code{CAF_REGTYPE_COARRAY_ALLOC},\n+the passed size is the byte size requested.  For @code{CAF_REGTYPE_LOCK_STATIC},\n+@code{CAF_REGTYPE_LOCK_ALLOC} and @code{CAF_REGTYPE_CRITICAL} it is the array\n+size or one for a scalar.\n+\n+\n @item @emph{Syntax}:\n @code{void *caf_register (size_t size, caf_register_t type, caf_token_t *token,\n int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{size} @tab byte size of the coarray to be allocated\n+@item @var{size} @tab For normal coarrays, the byte size of the coarray to be\n+allocated; for lock types, the number of elements.\n @item @var{type} @tab one of the caf_register_t types.\n @item @var{token} @tab intent(out) An opaque pointer identifying the coarray.\n-@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=; may be NULL\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to an error message; may be NULL\n+@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n+may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n @item @var{errmsg_len} @tab the buffer size of errmsg.\n @end multitable\n \n@@ -3383,6 +3396,13 @@ static memory is used.  The token permits to identify the coarray; to the\n processor, the token is a nonaliasing pointer. The library can, for instance,\n store the base address of the coarray in the token, some handle or a more\n complicated struct.\n+\n+For normal coarrays, the returned pointer is used for accesses on the local\n+image. For lock types, the value shall only used for checking the allocation\n+status. Note that for critical blocks, the locking is only required on one\n+image; in the locking statement, the processor shall always pass always an\n+image index of one for critical-block lock variables\n+(@code{CAF_REGTYPE_CRITICAL}).\n @end table\n \n \n@@ -3402,8 +3422,10 @@ int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=; may be NULL\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to an error message; may be NULL\n+@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n+may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set\n+to an error message; may be NULL\n @item @var{errmsg_len} @tab the buffer size of errmsg.\n @end multitable\n \n@@ -3549,6 +3571,79 @@ character kinds.\n @end table\n \n \n+@node _gfortran_caf_lock\n+@subsection @code{_gfortran_caf_lock} --- Locking a lock variable\n+@cindex Coarray, _gfortran_caf_lock\n+\n+@table @asis\n+@item @emph{Description}:\n+Acquire a lock on the given image on a scalar locking variable or for the\n+given array element for an array-valued variable. If the @var{aquired_lock}\n+is @code{NULL}, the function return after having obtained the lock. If it is\n+nonnull, the result is is assigned the value true (one) when the lock could be\n+obtained and false (zero) otherwise.  Locking a lock variable which has already\n+been locked by the same image is an error.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_lock (caf_token_t token, size_t index, int image_index,\n+int *aquired_lock, int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n+always 0.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{aquired_lock} @tab intent(out) If not NULL, it returns whether lock\n+could be obtained\n+@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n+may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function is also called for critical blocks; for those, the array index\n+is always zero and the image index is one.  Libraries are permitted to use other\n+images for critical-block locking variables.\n+@end table\n+\n+\n+@node _gfortran_caf_unlock\n+@subsection @code{_gfortran_caf_lock} --- Unlocking a lock variable\n+@cindex Coarray, _gfortran_caf_unlock\n+\n+@table @asis\n+@item @emph{Description}:\n+Release a lock on the given image on a scalar locking variable or for the\n+given array element for an array-valued variable. Unlocking a lock variable\n+which is unlocked or has been locked by a different image is an error.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_unlock (caf_token_t token, size_t index, int image_index,\n+int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n+always 0.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n+may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function is also called for critical block; for those, the array index\n+is always zero and the image index is one.  Libraries are permitted to use other\n+images for critical-block locking variables.\n+@end table\n \n \n \n@@ -3693,7 +3788,7 @@ order.  Most of these are necessary to be fully compatible with\n existing Fortran compilers, but they are not part of the official\n J3 Fortran 95 standard.\n \n-@subsection Compiler extensions: \n+@subsection Compiler extensions:\n @itemize @bullet\n @item\n User-specified alignment rules for structures."}, {"sha": "b6ce022165c0c022d18f16ab1395df24def03a27", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -8474,6 +8474,52 @@ resolve_lock_unlock (gfc_code *code)\n }\n \n \n+static void\n+resolve_critical (gfc_code *code)\n+{\n+  gfc_symtree *symtree;\n+  gfc_symbol *lock_type;\n+  char name[GFC_MAX_SYMBOL_LEN];\n+  static int serial = 0;\n+\n+  if (gfc_option.coarray != GFC_FCOARRAY_LIB)\n+    return;\n+\n+  symtree = gfc_find_symtree (gfc_current_ns->sym_root, \"__lock_type@0\");\n+  if (symtree)\n+    lock_type = symtree->n.sym;\n+  else\n+    {\n+      if (gfc_get_sym_tree (\"__lock_type@0\", gfc_current_ns, &symtree,\n+\t  false) != 0)\n+\tgcc_unreachable ();\n+      lock_type = symtree->n.sym;\n+      lock_type->attr.flavor = FL_DERIVED;\n+      lock_type->attr.zero_comp = 1;\n+      lock_type->from_intmod = INTMOD_ISO_FORTRAN_ENV;\n+      lock_type->intmod_sym_id = ISOFORTRAN_LOCK_TYPE;\n+    }\n+\n+  sprintf(name, \"__lock_var@%d\",serial++);\n+  if (gfc_get_sym_tree (name, gfc_current_ns, &symtree, false) != 0)\n+    gcc_unreachable ();\n+\n+  code->resolved_sym = symtree->n.sym;\n+  symtree->n.sym->attr.flavor = FL_VARIABLE;\n+  symtree->n.sym->attr.referenced = 1;\n+  symtree->n.sym->attr.artificial = 1;\n+  symtree->n.sym->attr.codimension = 1;\n+  symtree->n.sym->ts.type = BT_DERIVED;\n+  symtree->n.sym->ts.u.derived = lock_type;\n+  symtree->n.sym->as = gfc_get_array_spec ();\n+  symtree->n.sym->as->corank = 1;\n+  symtree->n.sym->as->type = AS_EXPLICIT;\n+  symtree->n.sym->as->cotype = AS_EXPLICIT;\n+  symtree->n.sym->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t   NULL, 1);\n+}\n+\n+\n static void\n resolve_sync (gfc_code *code)\n {\n@@ -9913,7 +9959,10 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_CONTINUE:\n \tcase EXEC_DT_END:\n \tcase EXEC_ASSIGN_CALL:\n+\t  break;\n+\n \tcase EXEC_CRITICAL:\n+\t  resolve_critical (code);\n \t  break;\n \n \tcase EXEC_SYNC_ALL:"}, {"sha": "bf91413ba99ef3a6009083f7dd925c561cd05cd9", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -135,8 +135,6 @@ tree gfor_fndecl_caf_deregister;\n tree gfor_fndecl_caf_get;\n tree gfor_fndecl_caf_send;\n tree gfor_fndecl_caf_sendget;\n-tree gfor_fndecl_caf_critical;\n-tree gfor_fndecl_caf_end_critical;\n tree gfor_fndecl_caf_sync_all;\n tree gfor_fndecl_caf_sync_images;\n tree gfor_fndecl_caf_error_stop;\n@@ -145,6 +143,8 @@ tree gfor_fndecl_caf_atomic_def;\n tree gfor_fndecl_caf_atomic_ref;\n tree gfor_fndecl_caf_atomic_cas;\n tree gfor_fndecl_caf_atomic_op;\n+tree gfor_fndecl_caf_lock;\n+tree gfor_fndecl_caf_unlock;\n tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n tree gfor_fndecl_co_sum;\n@@ -3368,12 +3368,6 @@ gfc_build_builtin_function_decls (void)\n \tpvoid_type_node, pvoid_type_node, size_type_node, integer_type_node,\n \tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n \n-      gfor_fndecl_caf_critical = gfc_build_library_function_decl (\n-\tget_identifier (PREFIX(\"caf_critical\")), void_type_node, 0);\n-\n-      gfor_fndecl_caf_end_critical = gfc_build_library_function_decl (\n-\tget_identifier (PREFIX(\"caf_end_critical\")), void_type_node, 0);\n-\n       gfor_fndecl_caf_sync_all = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_sync_all\")), \".WW\", void_type_node,\n \t3, pint_type, pchar_type_node, integer_type_node);\n@@ -3417,6 +3411,16 @@ gfc_build_builtin_function_decls (void)\n \tinteger_type_node, pvoid_type_node, pvoid_type_node, pint_type,\n \tinteger_type_node, integer_type_node);\n \n+      gfor_fndecl_caf_lock = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_lock\")), \"R..WWW\",\n+\tvoid_type_node, 7, pvoid_type_node, size_type_node, integer_type_node,\n+\tpint_type, pint_type, pchar_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_unlock = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_unlock\")), \"R..WW\",\n+\tvoid_type_node, 7, pvoid_type_node, size_type_node, integer_type_node,\n+\tpint_type, pchar_type_node, integer_type_node);\n+\n       gfor_fndecl_co_max = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_co_max\")), \"W.WW\",\n \tvoid_type_node, 6, pvoid_type_node, integer_type_node,\n@@ -4694,6 +4698,8 @@ static void\n generate_coarray_sym_init (gfc_symbol *sym)\n {\n   tree tmp, size, decl, token;\n+  bool is_lock_type;\n+  int reg_type;\n \n   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension\n       || sym->attr.use_assoc || !sym->attr.referenced\n@@ -4704,11 +4710,20 @@ generate_coarray_sym_init (gfc_symbol *sym)\n   TREE_USED(decl) = 1;\n   gcc_assert (GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n \n+  is_lock_type = sym->ts.type == BT_DERIVED\n+\t\t && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t\t && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE;\n+\n   /* FIXME: Workaround for PR middle-end/49106, cf. also PR middle-end/49108\n      to make sure the variable is not optimized away.  */\n   DECL_PRESERVE_P (DECL_CONTEXT (decl)) = 1;\n \n-  size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (decl)));\n+  /* For lock types, we pass the array size as only the library knows the\n+     size of the variable.  */\n+  if (is_lock_type)\n+    size = gfc_index_one_node;\n+  else\n+    size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (decl)));\n \n   /* Ensure that we do not have size=0 for zero-sized arrays.  */\n   size = fold_build2_loc (input_location, MAX_EXPR, size_type_node,\n@@ -4725,17 +4740,17 @@ generate_coarray_sym_init (gfc_symbol *sym)\n   gcc_assert (GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (decl)) != NULL_TREE);\n   token = gfc_build_addr_expr (ppvoid_type_node,\n \t\t\t       GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE(decl)));\n-\n+  if (is_lock_type)\n+    reg_type = sym->attr.artificial ? GFC_CAF_CRITICAL : GFC_CAF_LOCK_STATIC;\n+  else\n+    reg_type = GFC_CAF_COARRAY_STATIC;\n   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_register, 6, size,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    GFC_CAF_COARRAY_STATIC), /* type.  */\n+\t\t\t     build_int_cst (integer_type_node, reg_type),\n \t\t\t     token, null_pointer_node, /* token, stat.  */\n \t\t\t     null_pointer_node, /* errgmsg, errmsg_len.  */\n \t\t\t     build_int_cst (integer_type_node, 0));\n-\n   gfc_add_modify (&caf_init_block, decl, fold_convert (TREE_TYPE (decl), tmp));\n \n-\n   /* Handle \"static\" initializer.  */\n   if (sym->value)\n     {"}, {"sha": "abd80e768a78e148782bdd36ca4b66cf1b0feb4a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -1111,13 +1111,18 @@ tree\n gfc_trans_critical (gfc_code *code)\n {\n   stmtblock_t block;\n-  tree tmp;\n+  tree tmp, token = NULL_TREE;\n \n   gfc_start_block (&block);\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n     {\n-      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_critical, 0);\n+      token = gfc_get_symbol_decl (code->resolved_sym);\n+      token = GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (token));\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_lock, 7,\n+\t\t\t\t token, integer_zero_node, integer_one_node,\n+\t\t\t\t boolean_true_node, null_pointer_node,\n+\t\t\t\t null_pointer_node, integer_zero_node);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n@@ -1126,8 +1131,10 @@ gfc_trans_critical (gfc_code *code)\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n     {\n-      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_end_critical,\n-\t\t\t\t 0);\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_unlock, 6,\n+\t\t\t\t token, integer_zero_node, integer_one_node,\n+\t\t\t\t null_pointer_node, null_pointer_node,\n+\t\t\t\t integer_zero_node);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n "}, {"sha": "47037046b778371ac900694c61888ea6bedfef55", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -107,8 +107,9 @@ typedef enum\n {\n   GFC_CAF_COARRAY_STATIC,\n   GFC_CAF_COARRAY_ALLOC,\n-  GFC_CAF_LOCK,\n-  GFC_CAF_LOCK_COMP\n+  GFC_CAF_LOCK_STATIC,\n+  GFC_CAF_LOCK_ALLOC,\n+  GFC_CAF_CRITICAL\n }\n gfc_coarray_type;\n \n@@ -714,8 +715,6 @@ extern GTY(()) tree gfor_fndecl_caf_deregister;\n extern GTY(()) tree gfor_fndecl_caf_get;\n extern GTY(()) tree gfor_fndecl_caf_send;\n extern GTY(()) tree gfor_fndecl_caf_sendget;\n-extern GTY(()) tree gfor_fndecl_caf_critical;\n-extern GTY(()) tree gfor_fndecl_caf_end_critical;\n extern GTY(()) tree gfor_fndecl_caf_sync_all;\n extern GTY(()) tree gfor_fndecl_caf_sync_images;\n extern GTY(()) tree gfor_fndecl_caf_error_stop;\n@@ -724,6 +723,8 @@ extern GTY(()) tree gfor_fndecl_caf_atomic_def;\n extern GTY(()) tree gfor_fndecl_caf_atomic_ref;\n extern GTY(()) tree gfor_fndecl_caf_atomic_cas;\n extern GTY(()) tree gfor_fndecl_caf_atomic_op;\n+extern GTY(()) tree gfor_fndecl_caf_lock;\n+extern GTY(()) tree gfor_fndecl_caf_unlock;\n extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;\n extern GTY(()) tree gfor_fndecl_co_sum;"}, {"sha": "965b71ad57ec7c234f7a8cd335c965b4391a8bfd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -1,3 +1,13 @@\n+2014-08-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* caf/libcaf.h (caf_register_t): Update for critical.\n+\t(_gfortran_caf_critical, _gfortran_caf_end_critical): Remove.\n+\t(_gfortran_caf_lock, _gfortran_caf_unlock): Add.\n+\t* caf/single.c (_gfortran_caf_register): Handle locking\n+\tvariables.\n+\t(_gfortran_caf_sendget): Re-name args for consistency.\n+\t(_gfortran_caf_lock, _gfortran_caf_unlock): Add.\n+\n 2014-08-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* runtime/memory.c (xmallocarray): Avoid division for the common case."}, {"sha": "85d6811facf22967034d012c7a906e82ecf877cd", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -55,8 +55,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef enum caf_register_t {\n   CAF_REGTYPE_COARRAY_STATIC,\n   CAF_REGTYPE_COARRAY_ALLOC,\n-  CAF_REGTYPE_LOCK,\n-  CAF_REGTYPE_LOCK_COMP\n+  CAF_REGTYPE_LOCK_STATIC,\n+  CAF_REGTYPE_LOCK_ALLOC,\n+  CAF_REGTYPE_CRITICAL\n }\n caf_register_t;\n \n@@ -101,15 +102,6 @@ void _gfortran_caf_deregister (caf_token_t *, int *, char *, int);\n void _gfortran_caf_sync_all (int *, char *, int);\n void _gfortran_caf_sync_images (int, int[], int *, char *, int);\n \n-/* FIXME: The CRITICAL functions should be removed;\n-   the functionality is better represented using Coarray's lock feature.  */\n-void _gfortran_caf_critical (void);\n-void _gfortran_caf_critical (void)  { }\n-\n-void _gfortran_caf_end_critical (void);\n-void _gfortran_caf_end_critical (void)  { }\n-\n-\n void _gfortran_caf_error_stop_str (const char *, int32_t)\n      __attribute__ ((noreturn));\n void _gfortran_caf_error_stop (int32_t) __attribute__ ((noreturn));\n@@ -137,4 +129,8 @@ void _gfortran_caf_atomic_cas (caf_token_t, size_t, int, void *, void *,\n \t\t\t       void *, int *, int, int);\n void _gfortran_caf_atomic_op (int, caf_token_t, size_t, int, void *, void *,\n \t\t\t      int *, int, int);\n+\n+void _gfortran_caf_lock (caf_token_t, size_t, int, int *, int *, char *, int);\n+void _gfortran_caf_unlock (caf_token_t, size_t, int, int *, char *, int);\n+\n #endif  /* LIBCAF_H  */"}, {"sha": "990953ae4dbb5c44fb8ce4b7ebccaa0d893b5942", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0229f9f6929e000bc638e26fcd25ff0e95b2ed/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=bc0229f9f6929e000bc638e26fcd25ff0e95b2ed", "patch": "@@ -100,7 +100,11 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n {\n   void *local;\n \n-  local = malloc (size);\n+  if (type == CAF_REGTYPE_LOCK_STATIC || type == CAF_REGTYPE_LOCK_ALLOC\n+      || type == CAF_REGTYPE_CRITICAL)\n+    local = calloc (size, sizeof (bool));\n+  else\n+    local = malloc (size);\n   *token = malloc (sizeof (single_token_t));\n \n   if (unlikely (local == NULL || token == NULL))\n@@ -128,7 +132,8 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n   if (stat)\n     *stat = 0;\n \n-  if (type == CAF_REGTYPE_COARRAY_STATIC)\n+  if (type == CAF_REGTYPE_COARRAY_STATIC || type == CAF_REGTYPE_LOCK_STATIC\n+      || type == CAF_REGTYPE_CRITICAL)\n     {\n       caf_static_t *tmp = malloc (sizeof (caf_static_t));\n       tmp->prev  = caf_static_list;\n@@ -526,7 +531,7 @@ convert_type (void *dst, int dst_type, int dst_kind, void *src, int src_type,\n void\n _gfortran_caf_get (caf_token_t token, size_t offset,\n \t\t   int image_index __attribute__ ((unused)),\n-\t\t   gfc_descriptor_t *src ,\n+\t\t   gfc_descriptor_t *src,\n \t\t   caf_vector_t *src_vector __attribute__ ((unused)),\n \t\t   gfc_descriptor_t *dest, int src_kind, int dst_kind)\n {\n@@ -764,15 +769,15 @@ _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n \t\t       int src_image_index __attribute__ ((unused)),\n \t\t       gfc_descriptor_t *src,\n \t\t       caf_vector_t *src_vector __attribute__ ((unused)),\n-\t\t       int dst_len, int src_len)\n+\t\t       int dst_kind, int src_kind)\n {\n   /* FIXME: Handle vector subscript of 'src_vector'.  */\n   /* For a single image, src->base_addr should be the same as src_token + offset\n      but to play save, we do it properly.  */\n   void *src_base = GFC_DESCRIPTOR_DATA (src);\n   GFC_DESCRIPTOR_DATA (src) = (void *) ((char *) TOKEN (src_token) + src_offset);\n   _gfortran_caf_send (dst_token, dst_offset, dst_image_index, dest, dst_vector,\n-\t\t      src, dst_len, src_len);\n+\t\t      src, dst_kind, src_kind);\n   GFC_DESCRIPTOR_DATA (src) = src_base;\n }\n \n@@ -864,3 +869,80 @@ _gfortran_caf_atomic_op (int op, caf_token_t token, size_t offset,\n   if (stat)\n     *stat = 0;\n }\n+\n+\n+void\n+_gfortran_caf_lock (caf_token_t token, size_t index,\n+\t\t    int image_index __attribute__ ((unused)),\n+\t\t    int *aquired_lock, int *stat, char *errmsg, int errmsg_len)\n+{\n+  const char *msg = \"Already locked\";\n+  bool *lock = &((bool *) TOKEN (token))[index];\n+\n+  if (!*lock)\n+    {\n+      *lock = true;\n+      if (aquired_lock)\n+\t*aquired_lock = (int) true;\n+      if (stat)\n+\t*stat = 0;\n+      return;\n+    }\n+\n+  if (aquired_lock)\n+    {\n+      *aquired_lock = (int) false;\n+      if (stat)\n+\t*stat = 0;\n+    return;\n+    }\n+\n+\n+  if (stat)\n+    {\n+      *stat = 1;\n+      if (errmsg_len > 0)\n+\t{\n+\t  int len = ((int) sizeof (msg) > errmsg_len) ? errmsg_len\n+\t\t\t\t\t\t      : (int) sizeof (msg);\n+\t  memcpy (errmsg, msg, len);\n+\t  if (errmsg_len > len)\n+\t    memset (&errmsg[len], ' ', errmsg_len-len);\n+\t}\n+      return;\n+    }\n+  _gfortran_caf_error_stop_str (msg, (int32_t) strlen (msg));\n+}\n+\n+\n+void\n+_gfortran_caf_unlock (caf_token_t token, size_t index,\n+\t\t      int image_index __attribute__ ((unused)),\n+\t\t      int *stat, char *errmsg, int errmsg_len)\n+{\n+  const char *msg = \"Variable is not locked\";\n+  bool *lock = &((bool *) TOKEN (token))[index];\n+\n+  if (*lock)\n+    {\n+      *lock = false;\n+      if (stat)\n+\t*stat = 0;\n+      return;\n+    }\n+\n+  if (stat)\n+    {\n+      *stat = 1;\n+      if (errmsg_len > 0)\n+\t{\n+\t  int len = ((int) sizeof (msg) > errmsg_len) ? errmsg_len\n+\t\t\t\t\t\t      : (int) sizeof (msg);\n+\t  memcpy (errmsg, msg, len);\n+\t  if (errmsg_len > len)\n+\t    memset (&errmsg[len], ' ', errmsg_len-len);\n+\t}\n+      return;\n+    }\n+  _gfortran_caf_error_stop_str (msg, (int32_t) strlen (msg));\n+}"}]}