{"sha": "e5bde68ae031fcd4a8664d291dcd33a64088761b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTViZGU2OGFlMDMxZmNkNGE4NjY0ZDI5MWRjZDMzYTY0MDg4NzYxYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-07T01:56:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-07T01:56:25Z"}, "message": "ia64.c (predicate_operator): New.\n\n        * config/ia64/ia64.c (predicate_operator): New.\n        (ia64_print_operand): Handle 'J'.\n        (rtx_needs_barrier): Handle COND_EXEC.\n        * config/ia64/ia64.h (BRANCH_COST): Define.\n        (PREDICATE_CODES): Update.\n        * config/ia64/ia64.md: Docuement used unspec values.\n        (attr predicable): New.\n        (movxf, movxf_internal): New.\n        (extendsfdf2): Don't comment out nop.\n        (floatdidf2): Remove.\n        (truncxfsf2, truncxfdf2, floatdixf2): New.\n        (abssi2, absdi2): Put the neg in the \"true\" slot.\n        (conditional branch instructions): Mark not predicable.\n        (cmov*_internal): Use predicate_operator.  Split to cond_exec.\n        (abs*_internal): Likewise.\n        (alloc, set_bsp): Mark not predicable.\n        (barrier, insn_group_barrier, flush_cache): Likewise.\n        (define_cond_exec): New.\n\nFrom-SVN: r33754", "tree": {"sha": "b9a41bab39184b3d5e8bc1f86974ab14cb2949e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9a41bab39184b3d5e8bc1f86974ab14cb2949e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5bde68ae031fcd4a8664d291dcd33a64088761b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bde68ae031fcd4a8664d291dcd33a64088761b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5bde68ae031fcd4a8664d291dcd33a64088761b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bde68ae031fcd4a8664d291dcd33a64088761b/comments", "author": null, "committer": null, "parents": [{"sha": "fd7c34b081fd765e7ba6c7108b4ac9ac46b47d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7c34b081fd765e7ba6c7108b4ac9ac46b47d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7c34b081fd765e7ba6c7108b4ac9ac46b47d61"}], "stats": {"total": 533, "additions": 355, "deletions": 178}, "files": [{"sha": "f8c954d170efa74de49e995fe5aa2b7d6a8f57c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5bde68ae031fcd4a8664d291dcd33a64088761b", "patch": "@@ -1,3 +1,24 @@\n+2000-05-06  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64.c (predicate_operator): New.\n+\t(ia64_print_operand): Handle 'J'.\n+\t(rtx_needs_barrier): Handle COND_EXEC.\n+\t* config/ia64/ia64.h (BRANCH_COST): Define.\n+\t(PREDICATE_CODES): Update.\n+\t* config/ia64/ia64.md: Docuement used unspec values.\n+\t(attr predicable): New.\n+\t(movxf, movxf_internal): New.\n+\t(extendsfdf2): Don't comment out nop.\n+\t(floatdidf2): Remove.\n+\t(truncxfsf2, truncxfdf2, floatdixf2): New.\n+\t(abssi2, absdi2): Put the neg in the \"true\" slot.\n+\t(conditional branch instructions): Mark not predicable.\n+\t(cmov*_internal): Use predicate_operator.  Split to cond_exec.\n+\t(abs*_internal): Likewise.\n+\t(alloc, set_bsp): Mark not predicable.\n+\t(barrier, insn_group_barrier, flush_cache): Likewise.\n+\t(define_cond_exec): New.\n+\n 2000-05-06  Richard Henderson  <rth@cygnus.com>\n \n \t* c-decl.c: Include \"tm_p.h\"."}, {"sha": "81ae2e6fa5f11b311690cf876cee8784bdfd2000", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e5bde68ae031fcd4a8664d291dcd33a64088761b", "patch": "@@ -468,6 +468,17 @@ call_multiple_values_operation (op, mode)\n   return 1;\n }\n \n+/* Return 1 if this operator is valid for predication.  */\n+\n+int\n+predicate_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  return ((GET_MODE (op) == mode || mode == VOIDmode)\n+\t  && (code == EQ || code == NE));\n+}\n \f\n /* Structure to be filled in by ia64_compute_frame_size with register\n    save masks and offsets for the current function.  */\n@@ -1683,6 +1694,7 @@ ia64_print_operand_address (stream, address)\n    F\tA floating point constant 0.0 emitted as f0, or 1.0 emitted as f1, or\n         a floating point register emitted normally.\n    I\tInvert a predicate register by adding 1.\n+   J    Select the proper predicate register for a condition.\n    O\tAppend .acq for volatile load.\n    P\tPostincrement of a MEM.\n    Q\tAppend .rel for volatile store.\n@@ -1742,6 +1754,10 @@ ia64_print_operand (file, x, code)\n       fputs (reg_names [REGNO (x) + 1], file);\n       return;\n \n+    case 'J':\n+      fputs (reg_names [REGNO (XEXP (x, 0)) + (GET_CODE (x) == EQ)], file);\n+      return;\n+\n     case 'O':\n       if (MEM_VOLATILE_P (x))\n \tfputs(\".acq\", file);\n@@ -2382,6 +2398,27 @@ rtx_needs_barrier (x, flags, pred)\n \t}\n       break;\n \n+    case COND_EXEC:\n+      /* X is a predicated instruction.  */\n+\n+      cond = COND_EXEC_TEST (x);\n+      if (pred)\n+\tabort ();\n+      need_barrier = rtx_needs_barrier (cond, flags, 0);\n+\n+      if (GET_CODE (cond) == EQ)\n+\tis_complemented = 1;\n+      cond = XEXP (cond, 0);\n+      if (GET_CODE (cond) != REG\n+\t  && REGNO_REG_CLASS (REGNO (cond)) != PR_REGS)\n+\tabort ();\n+      pred = REGNO (cond);\n+      if (is_complemented)\n+\t++pred;\n+\n+      need_barrier |= rtx_needs_barrier (COND_EXEC_CODE (x), flags, pred);\n+      return need_barrier;\n+\n     case CLOBBER:\n #if 0\n     case USE:"}, {"sha": "686f728516c3f3e671c0addb179bf5c8fbf20d1c", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=e5bde68ae031fcd4a8664d291dcd33a64088761b", "patch": "@@ -1922,9 +1922,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* #define MEMORY_MOVE_COST(M,C,I) */\n \n /* A C expression for the cost of a branch instruction.  A value of 1 is the\n-   default; other values are interpreted relative to that.  */\n-/* ??? Investigate.  Might get better code by defining this.  */\n-/* #define BRANCH_COST */\n+   default; other values are interpreted relative to that.  Used by the \n+   if-conversion code as max instruction count.  */\n+/* ??? This requires investigation.  The primary effect might be how\n+   many additional insn groups we run into, vs how good the dynamic\n+   branch predictor is.  */\n+\n+#define BRANCH_COST 6\n \n /* Define this macro as a C expression which is nonzero if accessing less than\n    a word of memory (i.e. a `char' or a `short') is no faster than accessing a\n@@ -2726,7 +2730,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"reg_or_fp01_operand\", {SUBREG, REG, CONST_DOUBLE, CONSTANT_P_RTX}},\t\\\n { \"normal_comparison_operator\", {EQ, NE, GT, LE, GTU, LEU}},\t\t\\\n { \"adjusted_comparison_operator\", {LT, GE, LTU, GEU}},\t\t\t\\\n-{ \"call_multiple_values_operation\", {PARALLEL}},\n+{ \"call_multiple_values_operation\", {PARALLEL}},\t\t\t\\\n+{ \"predicate_operator\", {NE, EQ}},\n \n /* An alias for a machine mode name.  This is the machine mode that elements of\n    a jump-table should have.  */"}, {"sha": "6b7eb159bfe8d5ef0c600652402dec5333a1789d", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 288, "deletions": 174, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5bde68ae031fcd4a8664d291dcd33a64088761b/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=e5bde68ae031fcd4a8664d291dcd33a64088761b", "patch": "@@ -48,6 +48,33 @@\n \n ;; ??? Add function unit scheduling info for Itanium (TM) processor.\n \n+;; Unspec usage:\n+;;\n+;; unspec:\n+;;\t1\tgr_spill\n+;;\t2\tgr_restore\n+;;\t3\tfr_spill\n+;;\t4\tfr_restore\n+;;\t5\tpr_spill\n+;;\t8\tpopcnt\n+;;\t9\tunat_spill\n+;;\t10\tunat_restore\n+;;\t13\tcmpxchg_acq\n+;;\t14\tval_compare_and_swap\n+;;\t16\tlock_test_and_set\n+;;\t17\top_and_fetch\n+;;\t18\tfetch_and_op\n+;;\t19\tfetchadd_acq\n+;;\t20\tbsp_value\n+;;\n+;; unspec_volatile:\n+;;\t0\talloc\n+;;\t1\tblockage\n+;;\t2\tinsn_group_barrier\n+;;\t3\tflush_cache\n+;;\t4\tpfs_restore\n+;;\t5\tset_bsp\n+;;\t6\tpr_restore\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -73,6 +100,10 @@\n \n (define_attr \"type\" \"unknown,A,I,M,F,B,L,S\" (const_string \"unknown\"))\n \n+;; Predication.  True iff this instruction can be predicated.\n+\n+(define_attr \"predicable\" \"no,yes\" (const_string \"yes\"))\n+\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -402,6 +433,29 @@\n   mov %0 = %1\"\n   [(set_attr \"type\" \"F,M,M,M,M,A\")])\n \n+(define_expand \"movxf\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (! reload_in_progress && ! reload_completed\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n+}\")\n+\n+(define_insn \"*movxf_internal\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f,m\")\n+\t(match_operand:XF 1 \"general_operand\" \"fG,m,fG\"))]\n+  \"! memory_operand (operands[0], XFmode)\n+   || ! memory_operand (operands[1], XFmode)\"\n+  \"@\n+  mov %0 = %F1\n+  ldf %0 = %1%P1\n+  stf %0 = %F1%P0\"\n+  [(set_attr \"type\" \"F,M,M\")])\n+\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -473,8 +527,8 @@\n \t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"0,f\")))]\n   \"\"\n   \"@\n-  //nop\n-  mov %0 = %1\"\n+   nop 0\n+   mov %0 = %1\"\n   [(set_attr \"type\" \"unknown,F\")])\n \n (define_insn \"truncdfsf2\"\n@@ -484,17 +538,28 @@\n   \"fnorm.s %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-;; Convert between signed integer types and floating point.\n-\n-;; ??? Instead of having floatdidf2, we should have a floatditf2 pattern,\n-;; and then add conversions from tf to df and sf.\n+(define_insn \"truncxfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF (match_operand:XF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fnorm.s %0 = %1%B0\"\n+  [(set_attr \"type\" \"F\")])\n \n-(define_insn \"floatdidf2\"\n+(define_insn \"truncxfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+\t(float_truncate:DF (match_operand:XF 1 \"register_operand\" \"f\")))]\n   \"\"\n-  \"fcvt.xf %0 = %1\\;;;\\;fnorm.d %0 = %0%B0\"\n-  [(set_attr \"type\" \"unknown\")])\n+  \"fnorm.d %0 = %1%B0\"\n+  [(set_attr \"type\" \"F\")])\n+\n+;; Convert between signed integer types and floating point.\n+\n+(define_insn \"floatdixf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(float:XF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+  \"\"\n+  \"fcvt.xf %0 = %1\"\n+  [(set_attr \"type\" \"F\")])\n \n (define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n@@ -871,9 +936,9 @@\n   [(set (match_dup 2)\n \t(ge:CC (match_operand:SI 1 \"register_operand\" \"\") (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_dup 2) (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (neg:SI (match_dup 1))))]\n+\t(if_then_else:SI (eq:CC (match_dup 2) (const_int 0))\n+\t\t\t (neg:SI (match_dup 1))\n+\t\t\t (match_dup 1)))]\n   \"\"\n   \"\n {\n@@ -1079,9 +1144,9 @@\n   [(set (match_dup 2)\n \t(ge:CC (match_operand:DI 1 \"register_operand\" \"\") (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_dup 2) (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (neg:DI (match_dup 1))))]\n+\t(if_then_else:DI (eq:CC (match_dup 2) (const_int 0))\n+\t\t\t (neg:DI (match_dup 1))\n+\t\t\t (match_dup 1)))]\n   \"\"\n   \"\n {\n@@ -2076,7 +2141,8 @@\n \t\t      (pc)))]\n   \"\"\n   \"(%I0) br.cond.dpnt %l1\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*beq_false\"\n   [(set (pc)\n@@ -2086,7 +2152,8 @@\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n   \"(%0) br.cond.dptk %l1\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*bne_true\"\n   [(set (pc)\n@@ -2096,7 +2163,8 @@\n \t\t      (pc)))]\n   \"\"\n   \"(%0) br.cond.dptk %l1\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*bne_false\"\n   [(set (pc)\n@@ -2106,7 +2174,8 @@\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n   \"(%I0) br.cond.dpnt %l1\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n \f\n ;; ::::::::::::::::::::\n@@ -2326,195 +2395,222 @@\n ;; DImode if_then_else patterns.\n ;;\n \n-(define_insn \"*cmovne_internal\"\n+(define_insn \"*cmovdi_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,m,r,r,m,r\")\n-\t(if_then_else:DI (ne:CC (match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:DI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n-\t\t\t (match_operand:DI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n+\t(if_then_else:DI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n+\t     (const_int 0)])\n+\t  (match_operand:DI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n+\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n   \"\"\n-  \"@\n-   (%I1) mov %0 = %3\n-   (%I1) ld8%O3 %0 = %3\n-   (%I1) st8%Q0 %0 = %3\n-   (%1) mov %0 = %2\n-   (%1) ld8%O2 %0 = %2\n-   (%1) st8%Q0 %0 = %2\n-   #\"\n+  \"#\"\n   [(set_attr \"type\" \"A,M,M,A,M,M,unknown\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_operand:CC 1 \"register_operand\" \"\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n+\t(if_then_else:DI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"\")\n+\t     (const_int 0)])\n+\t  (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n+\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n   \"(reload_completed\n-    && ! rtx_equal_p (operands[0], operands[2])\n-    && ! rtx_equal_p (operands[0], operands[3]))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (match_dup 3)))]\n-  \"\")\n-\n-;; ??? Unknown if this can be matched.\n-\n-(define_insn \"*cmoveq_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,m,r,r,m,r\")\n-\t(if_then_else:DI (eq:CC (match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:DI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n-\t\t\t (match_operand:DI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n-  \"\"\n-  \"@\n-   (%1) mov %0 = %3\n-   (%1) ld8%O3 %0 = %3\n-   (%1) st8%Q0 %0 = %3\n-   (%I1) mov %0 = %2\n-   (%I1) ld8%O2 %0 = %2\n-   (%I1) st8%Q0 %0 = %2\n-   #\"\n-  [(set_attr \"type\" \"A,M,M,A,M,M,unknown\")])\n-\n-;; ??? Unknown if this can be matched.\n+    && (rtx_equal_p (operands[0], operands[2])\n+        || rtx_equal_p (operands[0], operands[3])))\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0) (match_dup 2)))]\n+  \"\n+{\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    {\n+      operands[2] = operands[3];\n+      operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t\t    CCmode, operands[1], const0_rtx);\n+    }\n+}\")\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI (eq:CC (match_operand:CC 1 \"register_operand\" \"\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n-  \"(reload_completed\n-    && ! rtx_equal_p (operands[0], operands[2])\n-    && ! rtx_equal_p (operands[0], operands[3]))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DI (eq:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:DI (eq:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (match_dup 3)))]\n-  \"\")\n+\t(if_then_else:DI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"\")\n+\t     (const_int 0)])\n+\t  (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n+\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0) (match_dup 2)))\n+   (cond_exec\n+     (match_dup 5)\n+     (set (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t\tCCmode, operands[1], const0_rtx);\n+}\")\n \n ;; Absolute value pattern.\n \n (define_insn \"*absdi2_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:DI (ne:CC (match_operand:CC 1 \"register_operand\" \"c,c\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:DI 2 \"reg_or_22bit_operand\" \"0,rI\")\n-\t\t\t (neg:DI (match_operand:DI 3 \"reg_or_22bit_operand\" \"rI,rI\"))))]\n+\t(if_then_else:DI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t     (const_int 0)])\n+\t  (neg:DI (match_operand:DI 2 \"reg_or_22bit_operand\" \"rI,rI\"))\n+\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"0,rI\")))]\n   \"\"\n-  \"@\n-   (%I1) sub %0 = r0, %3\n-   #\"\n+  \"#\"\n   [(set_attr \"type\" \"A,unknown\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI (ne:CC (match_operand:CC 1 \"register_operand\" \"\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n-\t\t\t (neg:DI (match_operand:DI 3 \"reg_or_22bit_operand\" \"\"))))]\n-  \"reload_completed && ! rtx_equal_p (operands[0], operands[2])\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:DI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (neg:DI (match_dup 3))))]\n+\t(if_then_else:DI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t     (const_int 0)])\n+\t  (neg:DI (match_operand:DI 2 \"reg_or_22bit_operand\" \"\"))\n+\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n+  \"reload_completed && rtx_equal_p (operands[0], operands[3])\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0)\n+\t  (neg:DI (match_dup 2))))]\n   \"\")\n \n-;; ??? Unknown if this can be generated.  If so, then add a define_split as\n-;; above.\n-\n-(define_insn \"*absdi2_not_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:DI (ne:CC (match_operand:CC 1 \"register_operand\" \"c,c\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (neg:DI (match_operand:DI 2 \"reg_or_22bit_operand\" \"rI,rI\"))\n-\t\t\t (match_operand:DI 3 \"reg_or_22bit_operand\" \"0,rI\")))]\n-  \"\"\n-  \"*abort ();\"\n-  [(set_attr \"type\" \"unknown\")])\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else:DI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t     (const_int 0)])\n+\t  (neg:DI (match_operand:DI 2 \"reg_or_22bit_operand\" \"\"))\n+\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0) (neg:DI (match_dup 2))))\n+   (cond_exec\n+     (match_dup 5)\n+     (set (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t\tCCmode, operands[1], const0_rtx);\n+}\")\n \n ;;\n ;; SImode if_then_else patterns.\n ;;\n \n-(define_insn \"*cmovnesi_internal\"\n+(define_insn \"*cmovsi_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,m,r,r,m,r\")\n-\t(if_then_else:SI (ne:CC (match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:SI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n-\t\t\t (match_operand:SI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n+\t(if_then_else:SI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n+\t     (const_int 0)])\n+\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n+\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n   \"\"\n-  \"@\n-   (%I1) mov %0 = %3\n-   (%I1) ld4%O3 %0 = %3\n-   (%I1) st4%Q0 %0 = %3\n-   (%1) mov %0 = %2\n-   (%1) ld4%O2 %0 = %2\n-   (%1) st4%Q0 %0 = %2\n-   #\"\n+  \"#\"\n   [(set_attr \"type\" \"A,M,M,A,M,M,unknown\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_operand:CC 1 \"register_operand\" \"\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:SI 2 \"reg_or_22bit_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n+\t(if_then_else:SI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"\")\n+\t     (const_int 0)])\n+\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"\")\n+\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n   \"(reload_completed\n-    && ! rtx_equal_p (operands[0], operands[2])\n-    && ! rtx_equal_p (operands[0], operands[3]))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:SI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:SI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (match_dup 3)))]\n-  \"\")\n+    && (rtx_equal_p (operands[0], operands[2])\n+        || rtx_equal_p (operands[0], operands[3])))\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0) (match_dup 2)))]\n+  \"\n+{\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    {\n+      operands[2] = operands[3];\n+      operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t\t    CCmode, operands[1], const0_rtx);\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:SI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"\")\n+\t     (const_int 0)])\n+\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"\")\n+\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0) (match_dup 2)))\n+   (cond_exec\n+     (match_dup 5)\n+     (set (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t\tCCmode, operands[1], const0_rtx);\n+}\")\n \n (define_insn \"*abssi2_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (ne:CC (match_operand:CC 1 \"register_operand\" \"c,c\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:SI 2 \"reg_or_22bit_operand\" \"0,rI\")\n-\t\t\t (neg:SI (match_operand:SI 3 \"reg_or_22bit_operand\" \"rI,rI\"))))]\n+\t(if_then_else:SI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t     (const_int 0)])\n+\t  (neg:SI (match_operand:SI 3 \"reg_or_22bit_operand\" \"rI,rI\"))\n+\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"0,rI\")))]\n   \"\"\n-  \"@\n-   (%I1) sub %0 = r0, %3\n-   #\"\n+  \"#\"\n   [(set_attr \"type\" \"A,unknown\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI (ne:CC (match_operand:CC 1 \"register_operand\" \"\")\n-\t\t\t\t(const_int 0))\n-\t\t\t (match_operand:SI 2 \"reg_or_22bit_operand\" \"\")\n-\t\t\t (neg:SI (match_operand:SI 3 \"reg_or_22bit_operand\" \"\"))))]\n-  \"reload_completed && ! rtx_equal_p (operands[0], operands[2])\"\n-  [(set (match_dup 0)\n-\t(if_then_else:SI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 2)\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 0)\n-\t(if_then_else:SI (ne:CC (match_dup 1) (const_int 0))\n-\t\t\t (match_dup 0)\n-\t\t\t (neg:SI (match_dup 3))))]\n+\t(if_then_else:SI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t     (const_int 0)])\n+\t  (neg:SI (match_operand:SI 2 \"reg_or_22bit_operand\" \"\"))\n+\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n+  \"reload_completed && rtx_equal_p (operands[0], operands[3])\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0)\n+\t  (neg:SI (match_dup 2))))]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:SI\n+\t  (match_operator:CC 4 \"predicate_operator\"\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c\")\n+\t     (const_int 0)])\n+\t  (neg:SI (match_operand:SI 2 \"reg_or_22bit_operand\" \"\"))\n+\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(cond_exec\n+     (match_dup 4)\n+     (set (match_dup 0) (neg:SI (match_dup 2))))\n+   (cond_exec\n+     (match_dup 5)\n+     (set (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t\tCCmode, operands[1], const0_rtx);\n+}\")\n+\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -2912,7 +3008,8 @@\n \t\t      (pc)))]\n   \"ia64_direct_return ()\"\n   \"(%I0) br.ret.sptk.many rp\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*eq_not_return\"\n   [(set (pc)\n@@ -2922,7 +3019,8 @@\n \t\t      (return)))]\n   \"ia64_direct_return ()\"\n   \"(%0) br.ret.sptk.many rp\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*ne_return\"\n   [(set (pc)\n@@ -2932,7 +3030,8 @@\n \t\t      (pc)))]\n   \"ia64_direct_return ()\"\n   \"(%0) br.ret.sptk.many rp\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*ne_not_return\"\n   [(set (pc)\n@@ -2942,7 +3041,8 @@\n \t\t      (return)))]\n   \"ia64_direct_return ()\"\n   \"(%I0) br.ret.sptk.many rp\"\n-  [(set_attr \"type\" \"B\")])\n+  [(set_attr \"type\" \"B\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"jump\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n@@ -3041,7 +3141,8 @@\n    (use (match_operand:DI 4 \"const_int_operand\" \"i\"))]\n   \"\"\n   \"alloc %0 = ar.pfs, %1, %2, %3, %4\"\n-  [(set_attr \"type\" \"M\")])\n+  [(set_attr \"type\" \"M\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"gr_spill\"\n   [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n@@ -3138,7 +3239,8 @@\n    invala\\;\t\t\t\\\n    ;;\\;\t\t\t\t\\\n    mov ar.rsc=r19\\;\"\n-  [(set_attr \"type\" \"I\")])\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3162,13 +3264,15 @@\n   [(unspec_volatile [(const_int 0)] 1)]\n   \"\"\n   \"\"\n-  [(set_attr \"type\" \"unknown\")])\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_insn \"insn_group_barrier\"\n   [(unspec_volatile [(const_int 0)] 2)]\n   \"\"\n   \";;\"\n-  [(set_attr \"type\" \"S\")])\n+  [(set_attr \"type\" \"S\")\n+   (set_attr \"predicable\" \"no\")])\n \n \f\n ;; Non-local goto support.\n@@ -3259,7 +3363,8 @@\n   [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"=&r\")] 3)]\n   \"\"\n   \"fc %0\\;;;\\;adds %0=31,%0\\;;;\\;fc %0\\;;;\\;sync.i\\;srlz.i\"\n-  [(set_attr \"type\" \"unknown\")])\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"predicable\" \"no\")])\n \f\n ;; Builtin apply support.\n \n@@ -3694,3 +3799,12 @@\n   ia64_expand_op_and_fetch (IA64_NAND_OP, SImode, operands);\n   DONE;\n }\")\n+\f\n+;; Predication.\n+\n+(define_cond_exec\n+  [(match_operator 0 \"predicate_operator\"\n+     [(match_operand:CC 1 \"register_operand\" \"c\")\n+      (const_int 0)])]\n+  \"\"\n+  \"(%J0)\")"}]}