{"sha": "41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFiYTdlZDc0YzdjMmY4YzRlZGU3ZGQ5OGY5ZTU1NTA4NjlkZjQ1Yw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-11-01T00:59:53Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-11-01T00:59:53Z"}, "message": "re PR middle-end/11968 (Array reference is incorrectly computed for POINTERS_EXTEND_UNSIGNED)\n\n\n\tPR middle-end/11968\n\t* expr.c (expand_expr <MULT_EXPR>): Remove inappropriate and\n\tconfusing comment; distributivity isn't handled in expand_expr.\n\t* fold-const.c (extract_muldiv_1 <PLUS_EXPR>):  Allow overflow\n\tin distributivity, if wrap-around semantics are specified with\n\t-fwrapv.\n\nFrom-SVN: r73166", "tree": {"sha": "487ce678894b4aacf864a61333bbb21317e63e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/487ce678894b4aacf864a61333bbb21317e63e95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/comments", "author": null, "committer": null, "parents": [{"sha": "3d63de248f683be76a1ea4a81646813ff7d4b085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d63de248f683be76a1ea4a81646813ff7d4b085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d63de248f683be76a1ea4a81646813ff7d4b085"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "7a217083737eeecaa7a7cd01422cea7d9c97dbe4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "patch": "@@ -1,3 +1,12 @@\n+2003-10-31  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/11968\n+\t* expr.c (expand_expr <MULT_EXPR>): Remove inappropriate and\n+\tconfusing comment; distributivity isn't handled in expand_expr.\n+\t* fold-const.c (extract_muldiv_1 <PLUS_EXPR>):  Allow overflow\n+\tin distributivity, if wrap-around semantics are specified with\n+\t-fwrapv.\n+\n 2003-11-01  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR 12315"}, {"sha": "347edb31bd2306725e9811cd02498b64fb17b519", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "patch": "@@ -7854,16 +7854,6 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode,\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n \t\t\t     EXPAND_SUM);\n \n-\t  /* If we knew for certain that this is arithmetic for an array\n-\t     reference, and we knew the bounds of the array, then we could\n-\t     apply the distributive law across (PLUS X C) for constant C.\n-\t     Without such knowledge, we risk overflowing the computation\n-\t     when both X and C are large, but X+C isn't.  */\n-\t  /* ??? Could perhaps special-case EXP being unsigned and C being\n-\t     positive.  In that case we are certain that X+C is no smaller\n-\t     than X and so the transformed expression will overflow iff the\n-\t     original would have.  */\n-\n \t  if (GET_CODE (op0) != REG)\n \t    op0 = force_operand (op0, NULL_RTX);\n \t  if (GET_CODE (op0) != REG)"}, {"sha": "3787915021e3c99b25c73fcdc347b1695175060f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=41ba7ed74c7c2f8c4ede7dd98f9e5550869df45c", "patch": "@@ -4433,8 +4433,11 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       if (code == MULT_EXPR\n \t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n \t{\n-\t  op1 = const_binop (code, convert (ctype, op1), convert (ctype, c), 0);\n-\t  if (op1 == 0 || TREE_OVERFLOW (op1))\n+\t  op1 = const_binop (code, convert (ctype, op1),\n+\t\t\t     convert (ctype, c), 0);\n+\t  /* We allow the constant to overflow with wrapping semantics.  */\n+\t  if (op1 == 0\n+\t      || (TREE_OVERFLOW (op1) && ! flag_wrapv))\n \t    break;\n \t}\n       else"}]}