{"sha": "b269f47786ffff084e874cd09ac8d87f895a1db6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI2OWY0Nzc4NmZmZmYwODRlODc0Y2QwOWFjOGQ4N2Y4OTVhMWRiNg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2016-04-18T10:53:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:53:32Z"}, "message": "sem_ch6.adb (Is_Inline_Pragma): The pragma argument can be a selected component...\n\n2016-04-18  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch6.adb (Is_Inline_Pragma): The pragma\n\targument can be a selected component, which has no Chars field,\n\tso we need to deal with that case (use the Selector_Name).\n\t(Check_Inline_Pragma): We need to test Is_List_Member before\n\tcalling In_Same_List, because in case of a library unit, they're\n\tnot in lists, so In_Same_List fails an assertion.\n\n2016-04-18  Bob Duff  <duff@adacore.com>\n\n\t* namet.ads, namet.adb: Add an Append that appends a\n\tBounded_String onto a Bounded_String. Probably a little more\n\tefficient than \"Append(X, +Y);\". Also minor cleanup.\n\t(Append_Decoded, Append_Decoded_With_Brackets, Append_Unqualified,\n\tAppend_Unqualified_Decoded): Make sure these work with non-empty\n\tbuffers.\n\t* casing.ads, casing.adb (Set_Casing): Pass a Bounded_String\n\tparameter, defaulting to Global_Name_Buffer.\n\t* errout.ads, errout.adb (Adjust_Name_Case): Pass a\n\tBounded_String parameter, no default.\n\t* exp_ch11.adb (Expand_N_Raise_Statement): Use local\n\tBounded_String instead of Global_Name_Buffer.\n\t* exp_intr.ads, exp_intr.adb (Write_Entity_Name): Rename it\n\tto Append_Entity_Name, and pass a Bounded_String parameter,\n\tinstead of using globals.\n\t(Add_Source_Info): Pass a Bounded_String parameter, instead of\n\tusing globals.\n\t(Expand_Source_Info): Use local instead of globals.\n\t* stringt.ads, stringt.adb (Append): Add an Append procedure\n\tfor appending a String_Id onto a Bounded_String.\n\t(String_To_Name_Buffer, Add_String_To_Name_Buffer): Rewrite in\n\tterms of Append.\n\t* sem_prag.adb (Set_Error_Msg_To_Profile_Name): Adjust for new\n\tAdjust_Name_Case parameter.\n\t* erroutc.adb, uname.adb: Don't pass D => Mixed_Case to\n\tSet_Casing; that's the default.\n\t* lib-xref-spark_specific.adb (Add_SPARK_Scope): Pretend that calls to\n\tprotected subprograms are entry calls; otherwise it is not possible to\n\tdistinguish them from regular subprogram calls.\n\nFrom-SVN: r235129", "tree": {"sha": "c8485ab31d9fcb70d60bce25c2bf64496590d01f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8485ab31d9fcb70d60bce25c2bf64496590d01f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b269f47786ffff084e874cd09ac8d87f895a1db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b269f47786ffff084e874cd09ac8d87f895a1db6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b269f47786ffff084e874cd09ac8d87f895a1db6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b269f47786ffff084e874cd09ac8d87f895a1db6/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "876f16240d138e8efdb47939f906d4fcfa234fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876f16240d138e8efdb47939f906d4fcfa234fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876f16240d138e8efdb47939f906d4fcfa234fdb"}], "stats": {"total": 749, "additions": 421, "deletions": 328}, "files": [{"sha": "4dd3d36a5f62869d506815b5c0c30f089bfe3519", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -1,3 +1,44 @@\n+2016-04-18  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch6.adb (Is_Inline_Pragma): The pragma\n+\targument can be a selected component, which has no Chars field,\n+\tso we need to deal with that case (use the Selector_Name).\n+\t(Check_Inline_Pragma): We need to test Is_List_Member before\n+\tcalling In_Same_List, because in case of a library unit, they're\n+\tnot in lists, so In_Same_List fails an assertion.\n+\n+2016-04-18  Bob Duff  <duff@adacore.com>\n+\n+\t* namet.ads, namet.adb: Add an Append that appends a\n+\tBounded_String onto a Bounded_String. Probably a little more\n+\tefficient than \"Append(X, +Y);\". Also minor cleanup.\n+\t(Append_Decoded, Append_Decoded_With_Brackets, Append_Unqualified,\n+\tAppend_Unqualified_Decoded): Make sure these work with non-empty\n+\tbuffers.\n+\t* casing.ads, casing.adb (Set_Casing): Pass a Bounded_String\n+\tparameter, defaulting to Global_Name_Buffer.\n+\t* errout.ads, errout.adb (Adjust_Name_Case): Pass a\n+\tBounded_String parameter, no default.\n+\t* exp_ch11.adb (Expand_N_Raise_Statement): Use local\n+\tBounded_String instead of Global_Name_Buffer.\n+\t* exp_intr.ads, exp_intr.adb (Write_Entity_Name): Rename it\n+\tto Append_Entity_Name, and pass a Bounded_String parameter,\n+\tinstead of using globals.\n+\t(Add_Source_Info): Pass a Bounded_String parameter, instead of\n+\tusing globals.\n+\t(Expand_Source_Info): Use local instead of globals.\n+\t* stringt.ads, stringt.adb (Append): Add an Append procedure\n+\tfor appending a String_Id onto a Bounded_String.\n+\t(String_To_Name_Buffer, Add_String_To_Name_Buffer): Rewrite in\n+\tterms of Append.\n+\t* sem_prag.adb (Set_Error_Msg_To_Profile_Name): Adjust for new\n+\tAdjust_Name_Case parameter.\n+\t* erroutc.adb, uname.adb: Don't pass D => Mixed_Case to\n+\tSet_Casing; that's the default.\n+\t* lib-xref-spark_specific.adb (Add_SPARK_Scope): Pretend that calls to\n+\tprotected subprograms are entry calls; otherwise it is not possible to\n+\tdistinguish them from regular subprogram calls.\n+\n 2016-04-18  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch13.adb (Has_Good_Profile): Improvement"}, {"sha": "d61112e1edf8859833f382382411b928e632e2f9", "filename": "gcc/ada/casing.adb", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fcasing.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fcasing.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcasing.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,6 @@\n ------------------------------------------------------------------------------\n \n with Csets;    use Csets;\n-with Namet;    use Namet;\n with Opt;      use Opt;\n with Widechar; use Widechar;\n \n@@ -125,7 +124,11 @@ package body Casing is\n    -- Set_Casing --\n    ----------------\n \n-   procedure Set_Casing (C : Casing_Type; D : Casing_Type := Mixed_Case) is\n+   procedure Set_Casing\n+     (Buf : in out Bounded_String;\n+      C   : Casing_Type;\n+      D   : Casing_Type := Mixed_Case)\n+   is\n       Ptr : Natural;\n \n       Actual_Casing : Casing_Type;\n@@ -144,7 +147,7 @@ package body Casing is\n \n       Ptr := 1;\n \n-      while Ptr <= Name_Len loop\n+      while Ptr <= Buf.Length loop\n \n          --  Wide character. Note that we do nothing with casing in this case.\n          --  In Ada 2005 mode, required folding of lower case letters happened\n@@ -156,41 +159,41 @@ package body Casing is\n          --  the requested casing operation, beyond folding to upper case\n          --  when it is mandatory, which does not involve underscores.\n \n-         if Name_Buffer (Ptr) = ASCII.ESC\n-           or else Name_Buffer (Ptr) = '['\n+         if Buf.Chars (Ptr) = ASCII.ESC\n+           or else Buf.Chars (Ptr) = '['\n            or else (Upper_Half_Encoding\n-                     and then Name_Buffer (Ptr) in Upper_Half_Character)\n+                     and then Buf.Chars (Ptr) in Upper_Half_Character)\n          then\n-            Skip_Wide (Name_Buffer, Ptr);\n+            Skip_Wide (Buf.Chars, Ptr);\n             After_Und := False;\n \n          --  Underscore, or non-identifer character (error case)\n \n-         elsif Name_Buffer (Ptr) = '_'\n-            or else not Identifier_Char (Name_Buffer (Ptr))\n+         elsif Buf.Chars (Ptr) = '_'\n+           or else not Identifier_Char (Buf.Chars (Ptr))\n          then\n             After_Und := True;\n             Ptr := Ptr + 1;\n \n          --  Lower case letter\n \n-         elsif Is_Lower_Case_Letter (Name_Buffer (Ptr)) then\n+         elsif Is_Lower_Case_Letter (Buf.Chars (Ptr)) then\n             if Actual_Casing = All_Upper_Case\n               or else (After_Und and then Actual_Casing = Mixed_Case)\n             then\n-               Name_Buffer (Ptr) := Fold_Upper (Name_Buffer (Ptr));\n+               Buf.Chars (Ptr) := Fold_Upper (Buf.Chars (Ptr));\n             end if;\n \n             After_Und := False;\n             Ptr := Ptr + 1;\n \n          --  Upper case letter\n \n-         elsif Is_Upper_Case_Letter (Name_Buffer (Ptr)) then\n+         elsif Is_Upper_Case_Letter (Buf.Chars (Ptr)) then\n             if Actual_Casing = All_Lower_Case\n               or else (not After_Und and then Actual_Casing = Mixed_Case)\n             then\n-               Name_Buffer (Ptr) := Fold_Lower (Name_Buffer (Ptr));\n+               Buf.Chars (Ptr) := Fold_Lower (Buf.Chars (Ptr));\n             end if;\n \n             After_Und := False;\n@@ -205,4 +208,9 @@ package body Casing is\n       end loop;\n    end Set_Casing;\n \n+   procedure Set_Casing (C : Casing_Type; D : Casing_Type := Mixed_Case) is\n+   begin\n+      Set_Casing (Global_Name_Buffer, C, D);\n+   end Set_Casing;\n+\n end Casing;"}, {"sha": "e3f7a3a192707a09806d9b0b4e755f80f2ee5a91", "filename": "gcc/ada/casing.ads", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fcasing.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fcasing.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcasing.ads?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Namet; use Namet;\n with Types; use Types;\n \n package Casing is\n@@ -68,14 +69,20 @@ package Casing is\n    -- Case Control Subprograms --\n    ------------------------------\n \n+   procedure Set_Casing\n+     (Buf : in out Bounded_String;\n+      C   : Casing_Type;\n+      D   : Casing_Type := Mixed_Case);\n+   --  Takes the name stored in Buf and modifies it to be consistent with the\n+   --  casing given by C, or if C = Unknown, then with the casing given by\n+   --  D. The name is basically treated as an identifier, except that special\n+   --  separator characters other than underline are permitted and treated like\n+   --  underlines (this handles cases like minus and period in unit names,\n+   --  apostrophes in error messages, angle brackets in names like <any_type>,\n+   --  etc).\n+\n    procedure Set_Casing (C : Casing_Type; D : Casing_Type := Mixed_Case);\n-   --  Takes the name stored in the first Name_Len positions of Name_Buffer\n-   --  and modifies it to be consistent with the casing given by C, or if\n-   --  C = Unknown, then with the casing given by D. The name is basically\n-   --  treated as an identifier, except that special separator characters\n-   --  other than underline are permitted and treated like underlines (this\n-   --  handles cases like minus and period in unit names, apostrophes in error\n-   --  messages, angle brackets in names like <any_type>, etc).\n+   --  Uses Buf => Global_Name_Buffer\n \n    procedure Set_All_Upper_Case;\n    pragma Inline (Set_All_Upper_Case);"}, {"sha": "db558ebacf9e6dcacbbfa9345d79bf959c4f35da", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -2358,7 +2358,10 @@ package body Errout is\n    -- Adjust_Name_Case --\n    ----------------------\n \n-   procedure Adjust_Name_Case (Loc : Source_Ptr) is\n+   procedure Adjust_Name_Case\n+     (Buf : in out Bounded_String;\n+      Loc : Source_Ptr)\n+   is\n    begin\n       --  We have an all lower case name from Namet, and now we want to set\n       --  the appropriate case. If possible we copy the actual casing from\n@@ -2387,34 +2390,39 @@ package body Errout is\n \n             Sbuffer := Source_Text (Src_Ind);\n \n-            while Ref_Ptr <= Name_Len loop\n+            while Ref_Ptr <= Buf.Length loop\n                exit when\n                  Fold_Lower (Sbuffer (Src_Ptr)) /=\n-                   Fold_Lower (Name_Buffer (Ref_Ptr));\n+                   Fold_Lower (Buf.Chars (Ref_Ptr));\n                Ref_Ptr := Ref_Ptr + 1;\n                Src_Ptr := Src_Ptr + 1;\n             end loop;\n \n             --  If we get through the loop without a mismatch, then output the\n             --  name the way it is cased in the source program\n \n-            if Ref_Ptr > Name_Len then\n+            if Ref_Ptr > Buf.Length then\n                Src_Ptr := Loc;\n \n-               for J in 1 .. Name_Len loop\n-                  Name_Buffer (J) := Sbuffer (Src_Ptr);\n+               for J in 1 .. Buf.Length loop\n+                  Buf.Chars (J) := Sbuffer (Src_Ptr);\n                   Src_Ptr := Src_Ptr + 1;\n                end loop;\n \n             --  Otherwise set the casing using the default identifier casing\n \n             else\n-               Set_Casing (Identifier_Casing (Src_Ind), Mixed_Case);\n+               Set_Casing (Buf, Identifier_Casing (Src_Ind));\n             end if;\n          end if;\n       end;\n    end Adjust_Name_Case;\n \n+   procedure Adjust_Name_Case (Loc : Source_Ptr) is\n+   begin\n+      Adjust_Name_Case (Global_Name_Buffer, Loc);\n+   end Adjust_Name_Case;\n+\n    ---------------------------\n    -- Set_Identifier_Casing --\n    ---------------------------\n@@ -2874,7 +2882,7 @@ package body Errout is\n       end if;\n       --  Remaining step is to adjust casing and possibly add 'Class\n \n-      Adjust_Name_Case (Loc);\n+      Adjust_Name_Case (Global_Name_Buffer, Loc);\n       Set_Msg_Name_Buffer;\n       Add_Class;\n    end Set_Msg_Node;"}, {"sha": "70988b96bd9a30575d2d7dbea32a5583be3a1b8e", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -904,11 +904,17 @@ package Errout is\n    -- Utility Interface for Casing Control --\n    ------------------------------------------\n \n+   procedure Adjust_Name_Case\n+     (Buf : in out Bounded_String;\n+      Loc : Source_Ptr);\n+   --  Given a name stored in Buf, set proper casing.  Loc is an associated\n+   --  source position, if we can find a match between the name in Buf and the\n+   --  name at that source location, we copy the casing from the source,\n+   --  otherwise we set appropriate default casing.\n+\n    procedure Adjust_Name_Case (Loc : Source_Ptr);\n-   --  Given a name stored in Name_Buffer (1 .. Name_Len), set proper casing.\n-   --  Loc is an associated source position, if we can find a match between\n-   --  the name in Name_Buffer and the name at that source location, we copy\n-   --  the casing from the source, otherwise we set appropriate default casing.\n+   --  Uses Buf => Global_Name_Buffer. There are no calls to this in the\n+   --  compiler, but it is called in SPARK2014.\n \n    procedure Set_Identifier_Casing\n      (Identifier_Name : System.Address;"}, {"sha": "5376aecfa141e1391f973a09382eafa5538d9bd0", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -66,7 +66,7 @@ package body Erroutc is\n          Class_Flag := False;\n          Set_Msg_Char (''');\n          Get_Name_String (Name_Class);\n-         Set_Casing (Identifier_Casing (Flag_Source), Mixed_Case);\n+         Set_Casing (Identifier_Casing (Flag_Source));\n          Set_Msg_Name_Buffer;\n       end if;\n    end Add_Class;\n@@ -1187,7 +1187,7 @@ package body Erroutc is\n          --  Else output with surrounding quotes in proper casing mode\n \n          else\n-            Set_Casing (Identifier_Casing (Flag_Source), Mixed_Case);\n+            Set_Casing (Identifier_Casing (Flag_Source));\n             Set_Msg_Quote;\n             Set_Msg_Name_Buffer;\n             Set_Msg_Quote;"}, {"sha": "0c788de6b5560f15f39f1b0653321e66e3a69300", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -1565,13 +1565,15 @@ package body Exp_Ch11 is\n          if Prefix_Exception_Messages\n            and then Nkind (Expression (N)) = N_String_Literal\n          then\n-            Name_Len := 0;\n-            Add_Source_Info (Loc, Name_Enclosing_Entity);\n-            Add_Str_To_Name_Buffer (\": \");\n-            Add_String_To_Name_Buffer (Strval (Expression (N)));\n-            Rewrite (Expression (N),\n-              Make_String_Literal (Loc, Name_Buffer (1 .. Name_Len)));\n-            Analyze_And_Resolve (Expression (N), Standard_String);\n+            declare\n+               Buf : Bounded_String;\n+            begin\n+               Add_Source_Info (Buf, Loc, Name_Enclosing_Entity);\n+               Append (Buf, \": \");\n+               Append (Buf, Strval (Expression (N)));\n+               Rewrite (Expression (N), Make_String_Literal (Loc, +Buf));\n+               Analyze_And_Resolve (Expression (N), Standard_String);\n+            end;\n          end if;\n \n          --  Avoid passing exception-name'identity in runtimes in which this"}, {"sha": "63f6ccbbeb3ee320daa557c7270b7ad83dba4530", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 126, "deletions": 155, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -54,7 +54,6 @@ with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -112,58 +111,51 @@ package body Exp_Intr is\n    --  GNAT.Source_Info; see g-souinf.ads for documentation of these\n    --  intrinsics.\n \n-   procedure Write_Entity_Name (E : Entity_Id);\n+   procedure Append_Entity_Name (Buf : in out Bounded_String; E : Entity_Id);\n    --  Recursive procedure to construct string for qualified name of enclosing\n    --  program unit. The qualification stops at an enclosing scope has no\n    --  source name (block or loop). If entity is a subprogram instance, skip\n-   --  enclosing wrapper package. The name is appended to the current contents\n-   --  of Name_Buffer, incrementing Name_Len.\n+   --  enclosing wrapper package. The name is appended to Buf.\n \n    ---------------------\n    -- Add_Source_Info --\n    ---------------------\n \n-   procedure Add_Source_Info (Loc : Source_Ptr; Nam : Name_Id) is\n-      Ent : Entity_Id;\n-\n-      Save_NB : constant String  := Name_Buffer (1 .. Name_Len);\n-      Save_NL : constant Natural := Name_Len;\n-      --  Save current Name_Buffer contents\n-\n+   procedure Add_Source_Info\n+     (Buf : in out Bounded_String;\n+      Loc : Source_Ptr;\n+      Nam : Name_Id)\n+   is\n    begin\n-      Name_Len := 0;\n-\n-      --  Line\n-\n       case Nam is\n-\n          when Name_Line =>\n-            Add_Nat_To_Name_Buffer (Nat (Get_Logical_Line_Number (Loc)));\n+            Append (Buf, Nat (Get_Logical_Line_Number (Loc)));\n \n          when Name_File =>\n-            Get_Decoded_Name_String\n-              (Reference_Name (Get_Source_File_Index (Loc)));\n+            Append_Decoded (Buf, Reference_Name (Get_Source_File_Index (Loc)));\n \n          when Name_Source_Location =>\n-            Build_Location_String (Global_Name_Buffer, Loc);\n+            Build_Location_String (Buf, Loc);\n \n          when Name_Enclosing_Entity =>\n \n             --  Skip enclosing blocks to reach enclosing unit\n \n-            Ent := Current_Scope;\n-            while Present (Ent) loop\n-               exit when not Ekind_In (Ent, E_Block, E_Loop);\n-               Ent := Scope (Ent);\n-            end loop;\n+            declare\n+               Ent : Entity_Id := Current_Scope;\n+            begin\n+               while Present (Ent) loop\n+                  exit when not Ekind_In (Ent, E_Block, E_Loop);\n+                  Ent := Scope (Ent);\n+               end loop;\n \n-            --  Ent now points to the relevant defining entity\n+               --  Ent now points to the relevant defining entity\n \n-            Write_Entity_Name (Ent);\n+               Append_Entity_Name (Buf, Ent);\n+            end;\n \n          when Name_Compilation_ISO_Date =>\n-            Name_Buffer (1 .. 10) := Opt.Compilation_Time (1 .. 10);\n-            Name_Len := 10;\n+            Append (Buf, Opt.Compilation_Time (1 .. 10));\n \n          when Name_Compilation_Date =>\n             declare\n@@ -177,34 +169,117 @@ package body Exp_Intr is\n \n                MM : constant Natural range 1 .. 12 :=\n                       (Character'Pos (M1) - Character'Pos ('0')) * 10 +\n-                 (Character'Pos (M2) - Character'Pos ('0'));\n+                      (Character'Pos (M2) - Character'Pos ('0'));\n \n             begin\n                --  Reformat ISO date into MMM DD YYYY (__DATE__) format\n \n-               Name_Buffer (1 .. 3)  := Months (MM);\n-               Name_Buffer (4)       := ' ';\n-               Name_Buffer (5 .. 6)  := Opt.Compilation_Time (9 .. 10);\n-               Name_Buffer (7)       := ' ';\n-               Name_Buffer (8 .. 11) := Opt.Compilation_Time (1 .. 4);\n-               Name_Len := 11;\n+               Append (Buf, Months (MM));\n+               Append (Buf, ' ');\n+               Append (Buf, Opt.Compilation_Time (9 .. 10));\n+               Append (Buf, ' ');\n+               Append (Buf, Opt.Compilation_Time (1 .. 4));\n             end;\n \n          when Name_Compilation_Time =>\n-            Name_Buffer (1 .. 8) := Opt.Compilation_Time (12 .. 19);\n-            Name_Len := 8;\n+            Append (Buf, Opt.Compilation_Time (12 .. 19));\n \n          when others =>\n             raise Program_Error;\n       end case;\n+   end Add_Source_Info;\n \n-      --  Prepend original Name_Buffer contents\n+   -----------------------\n+   -- Append_Entity_Name --\n+   -----------------------\n \n-      Name_Buffer (Save_NL + 1 .. Save_NL + Name_Len) :=\n-        Name_Buffer (1 .. Name_Len);\n-      Name_Buffer (1 .. Save_NL) := Save_NB;\n-      Name_Len := Name_Len + Save_NL;\n-   end Add_Source_Info;\n+   procedure Append_Entity_Name (Buf : in out Bounded_String; E : Entity_Id) is\n+      Temp : Bounded_String;\n+\n+      procedure Inner (E : Entity_Id);\n+      --  Inner recursive routine, keep outer routine non-recursive to ease\n+      --  debugging when we get strange results from this routine.\n+\n+      -----------\n+      -- Inner --\n+      -----------\n+\n+      procedure Inner (E : Entity_Id) is\n+      begin\n+         --  If entity has an internal name, skip by it, and print its scope.\n+         --  Note that we strip a final R from the name before the test, this\n+         --  is needed for some cases of instantiations.\n+\n+         declare\n+            E_Name : Bounded_String;\n+\n+         begin\n+            Append (E_Name, Chars (E));\n+\n+            if E_Name.Chars (E_Name.Length) = 'R' then\n+               E_Name.Length := E_Name.Length - 1;\n+            end if;\n+\n+            if Is_Internal_Name (E_Name) then\n+               Inner (Scope (E));\n+               return;\n+            end if;\n+         end;\n+\n+         --  Just print entity name if its scope is at the outer level\n+\n+         if Scope (E) = Standard_Standard then\n+            null;\n+\n+         --  If scope comes from source, write scope and entity\n+\n+         elsif Comes_From_Source (Scope (E)) then\n+            Append_Entity_Name (Temp, Scope (E));\n+            Append (Temp, '.');\n+\n+         --  If in wrapper package skip past it\n+\n+         elsif Is_Wrapper_Package (Scope (E)) then\n+            Append_Entity_Name (Temp, Scope (Scope (E)));\n+            Append (Temp, '.');\n+\n+         --  Otherwise nothing to output (happens in unnamed block statements)\n+\n+         else\n+            null;\n+         end if;\n+\n+         --  Output the name\n+\n+         declare\n+            E_Name : Bounded_String;\n+\n+         begin\n+            Append_Unqualified_Decoded (E_Name, Chars (E));\n+\n+            --  Remove trailing upper case letters from the name (useful for\n+            --  dealing with some cases of internal names generated in the case\n+            --  of references from within a generic.\n+\n+            while E_Name.Length > 1\n+              and then E_Name.Chars (E_Name.Length) in 'A' .. 'Z'\n+            loop\n+               E_Name.Length := E_Name.Length - 1;\n+            end loop;\n+\n+            --  Adjust casing appropriately (gets name from source if possible)\n+\n+            Adjust_Name_Case (E_Name, Sloc (E));\n+            Append (Temp, E_Name);\n+         end;\n+      end Inner;\n+\n+   --  Start of processing for Append_Entity_Name\n+\n+   begin\n+      Inner (E);\n+      Append (Buf, Temp);\n+   end Append_Entity_Name;\n \n    ---------------------------------\n    -- Expand_Binary_Operator_Call --\n@@ -865,12 +940,13 @@ package body Exp_Intr is\n       --  String cases\n \n       else\n-         Name_Len := 0;\n-         Add_Source_Info (Loc, Nam);\n-         Rewrite (N,\n-           Make_String_Literal (Loc,\n-             Strval => String_From_Name_Buffer));\n-         Analyze_And_Resolve (N, Standard_String);\n+         declare\n+            Buf : Bounded_String;\n+         begin\n+            Add_Source_Info (Buf, Loc, Nam);\n+            Rewrite (N, Make_String_Literal (Loc, Strval => +Buf));\n+            Analyze_And_Resolve (N, Standard_String);\n+         end;\n       end if;\n \n       Set_Is_Static_Expression (N);\n@@ -1401,109 +1477,4 @@ package body Exp_Intr is\n       Analyze (N);\n    end Expand_To_Pointer;\n \n-   -----------------------\n-   -- Write_Entity_Name --\n-   -----------------------\n-\n-   procedure Write_Entity_Name (E : Entity_Id) is\n-\n-      procedure Write_Entity_Name_Inner (E : Entity_Id);\n-      --  Inner recursive routine, keep outer routine non-recursive to ease\n-      --  debugging when we get strange results from this routine.\n-\n-      -----------------------------\n-      -- Write_Entity_Name_Inner --\n-      -----------------------------\n-\n-      procedure Write_Entity_Name_Inner (E : Entity_Id) is\n-      begin\n-         --  If entity has an internal name, skip by it, and print its scope.\n-         --  Note that Is_Internal_Name destroys Name_Buffer, hence the save\n-         --  and restore since we depend on its current contents. Note that\n-         --  we strip a final R from the name before the test, this is needed\n-         --  for some cases of instantiations.\n-\n-         declare\n-            Save_NB : constant String  := Name_Buffer (1 .. Name_Len);\n-            Save_NL : constant Natural := Name_Len;\n-            Iname   : Boolean;\n-\n-         begin\n-            Get_Name_String (Chars (E));\n-\n-            if Name_Buffer (Name_Len) = 'R' then\n-               Name_Len := Name_Len - 1;\n-            end if;\n-\n-            Iname := Is_Internal_Name;\n-\n-            Name_Buffer (1 .. Save_NL) := Save_NB;\n-            Name_Len := Save_NL;\n-\n-            if Iname then\n-               Write_Entity_Name_Inner (Scope (E));\n-               return;\n-            end if;\n-         end;\n-\n-         --  Just print entity name if its scope is at the outer level\n-\n-         if Scope (E) = Standard_Standard then\n-            null;\n-\n-         --  If scope comes from source, write scope and entity\n-\n-         elsif Comes_From_Source (Scope (E)) then\n-            Write_Entity_Name (Scope (E));\n-            Add_Char_To_Name_Buffer ('.');\n-\n-         --  If in wrapper package skip past it\n-\n-         elsif Is_Wrapper_Package (Scope (E)) then\n-            Write_Entity_Name (Scope (Scope (E)));\n-            Add_Char_To_Name_Buffer ('.');\n-\n-         --  Otherwise nothing to output (happens in unnamed block statements)\n-\n-         else\n-            null;\n-         end if;\n-\n-         --  Output the name\n-\n-         declare\n-            Save_NB : constant String  := Name_Buffer (1 .. Name_Len);\n-            Save_NL : constant Natural := Name_Len;\n-\n-         begin\n-            Get_Unqualified_Decoded_Name_String (Chars (E));\n-\n-            --  Remove trailing upper case letters from the name (useful for\n-            --  dealing with some cases of internal names generated in the case\n-            --  of references from within a generic.\n-\n-            while Name_Len > 1\n-              and then Name_Buffer (Name_Len) in 'A' .. 'Z'\n-            loop\n-               Name_Len := Name_Len  - 1;\n-            end loop;\n-\n-            --  Adjust casing appropriately (gets name from source if possible)\n-\n-            Adjust_Name_Case (Sloc (E));\n-\n-            --  Append to original entry value of Name_Buffer\n-\n-            Name_Buffer (Save_NL + 1 ..  Save_NL + Name_Len) :=\n-              Name_Buffer (1 .. Name_Len);\n-            Name_Buffer (1 .. Save_NL) := Save_NB;\n-            Name_Len := Save_NL + Name_Len;\n-         end;\n-      end Write_Entity_Name_Inner;\n-\n-   --  Start of processing for Write_Entity_Name\n-\n-   begin\n-      Write_Entity_Name_Inner (E);\n-   end Write_Entity_Name;\n end Exp_Intr;"}, {"sha": "693ed5f986a7a935d101715a7292e8a231cb3d4a", "filename": "gcc/ada/exp_intr.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fexp_intr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fexp_intr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.ads?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -30,12 +30,14 @@ with Types; use Types;\n \n package Exp_Intr is\n \n-   procedure Add_Source_Info (Loc : Source_Ptr; Nam : Name_Id);\n-   --  Append a string to Name_Buffer depending on Nam, which is the name of\n-   --  one of the intrinsics declared in GNAT.Source_Info; see g-souinf.ads for\n-   --  documentation of these intrinsics. The caller must set Name_Buffer and\n-   --  Name_Len before the call. Loc is passed to provide location information\n-   --  where it is needed.\n+   procedure Add_Source_Info\n+     (Buf : in out Bounded_String;\n+      Loc : Source_Ptr;\n+      Nam : Name_Id);\n+   --  Append a string to Buf depending on Nam, which is the name of one of the\n+   --  intrinsics declared in GNAT.Source_Info; see g-souinf.ads for\n+   --  documentation of these intrinsics. Loc is passed to provide location\n+   --  information where it is needed.\n \n    procedure Expand_Intrinsic_Call (N : Node_Id; E : Entity_Id);\n    --  N is either a function call node, a procedure call statement node, or"}, {"sha": "67e0879ee01533b4a0057c645d7ea28d806e72cb", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -261,15 +261,28 @@ package body SPARK_Specific is\n       case Ekind (E) is\n          when E_Entry\n             | E_Entry_Family\n-            | E_Function\n             | E_Generic_Function\n             | E_Generic_Package\n             | E_Generic_Procedure\n             | E_Package\n-            | E_Procedure\n          =>\n             Typ := Xref_Entity_Letters (Ekind (E));\n \n+         when E_Function\n+            | E_Procedure\n+         =>\n+            --  In in SPARK we need to distinguish protected functions and\n+            --  procedures from ordinary subprograms, but there are no special\n+            --  Xref letters for them. Since this distiction is only needed\n+            --  to detect protected calls we pretent that such calls are entry\n+            --  calls.\n+\n+            if Ekind (Scope (E)) = E_Protected_Type then\n+               Typ := Xref_Entity_Letters (E_Entry);\n+            else\n+               Typ := Xref_Entity_Letters (Ekind (E));\n+            end if;\n+\n          when E_Package_Body | E_Subprogram_Body | E_Task_Body =>\n             Typ := Xref_Entity_Letters (Ekind (Unique_Entity (E)));\n "}, {"sha": "9972aa9b8c404dee992597e01be307b7705a7d17", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 113, "deletions": 94, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -137,6 +137,11 @@ package body Namet is\n       end loop;\n    end Append;\n \n+   procedure Append (Buf : in out Bounded_String; Buf2 : Bounded_String) is\n+   begin\n+      Append (Buf, Buf2.Chars (1 .. Buf2.Length));\n+   end Append;\n+\n    procedure Append (Buf : in out Bounded_String; Id : Name_Id) is\n       pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n       S : constant Int := Name_Entries.Table (Id).Name_Chars_Index;\n@@ -154,26 +159,27 @@ package body Namet is\n    procedure Append_Decoded (Buf : in out Bounded_String; Id : Name_Id) is\n       C : Character;\n       P : Natural;\n+      Temp : Bounded_String;\n \n    begin\n-      Append (Buf, Id);\n+      Append (Temp, Id);\n \n       --  Skip scan if we already know there are no encodings\n \n       if Name_Entries.Table (Id).Name_Has_No_Encodings then\n-         return;\n+         goto Done;\n       end if;\n \n       --  Quick loop to see if there is anything special to do\n \n       P := 1;\n       loop\n-         if P = Buf.Length then\n+         if P = Temp.Length then\n             Name_Entries.Table (Id).Name_Has_No_Encodings := True;\n-            return;\n+            goto Done;\n \n          else\n-            C := Buf.Chars (P);\n+            C := Temp.Chars (P);\n \n             exit when\n               C = 'U' or else\n@@ -190,10 +196,10 @@ package body Namet is\n       Decode : declare\n          New_Len : Natural;\n          Old     : Positive;\n-         New_Buf : String (1 .. Buf.Chars'Last);\n+         New_Buf : String (1 .. Temp.Chars'Last);\n \n          procedure Copy_One_Character;\n-         --  Copy a character from Buf.Chars to New_Buf. Includes case\n+         --  Copy a character from Temp.Chars to New_Buf. Includes case\n          --  of copying a Uhh,Whhhh,WWhhhhhhhh sequence and decoding it.\n \n          function Hex (N : Natural) return Word;\n@@ -210,14 +216,14 @@ package body Namet is\n             C : Character;\n \n          begin\n-            C := Buf.Chars (Old);\n+            C := Temp.Chars (Old);\n \n             --  U (upper half insertion case)\n \n             if C = 'U'\n-              and then Old < Buf.Length\n-              and then Buf.Chars (Old + 1) not in 'A' .. 'Z'\n-              and then Buf.Chars (Old + 1) /= '_'\n+              and then Old < Temp.Length\n+              and then Temp.Chars (Old + 1) not in 'A' .. 'Z'\n+              and then Temp.Chars (Old + 1) /= '_'\n             then\n                Old := Old + 1;\n \n@@ -237,18 +243,18 @@ package body Namet is\n             --  WW (wide wide character insertion)\n \n             elsif C = 'W'\n-              and then Old < Buf.Length\n-              and then Buf.Chars (Old + 1) = 'W'\n+              and then Old < Temp.Length\n+              and then Temp.Chars (Old + 1) = 'W'\n             then\n                Old := Old + 2;\n                Widechar.Set_Wide (Char_Code (Hex (8)), New_Buf, New_Len);\n \n             --  W (wide character insertion)\n \n             elsif C = 'W'\n-              and then Old < Buf.Length\n-              and then Buf.Chars (Old + 1) not in 'A' .. 'Z'\n-              and then Buf.Chars (Old + 1) /= '_'\n+              and then Old < Temp.Length\n+              and then Temp.Chars (Old + 1) not in 'A' .. 'Z'\n+              and then Temp.Chars (Old + 1) /= '_'\n             then\n                Old := Old + 1;\n                Widechar.Set_Wide (Char_Code (Hex (4)), New_Buf, New_Len);\n@@ -271,7 +277,7 @@ package body Namet is\n \n          begin\n             for J in 1 .. N loop\n-               C := Buf.Chars (Old);\n+               C := Temp.Chars (Old);\n                Old := Old + 1;\n \n                pragma Assert (C in '0' .. '9' or else C in 'a' .. 'f');\n@@ -304,12 +310,12 @@ package body Namet is\n \n          --  Loop through characters of name\n \n-         while Old <= Buf.Length loop\n+         while Old <= Temp.Length loop\n \n             --  Case of character literal, put apostrophes around character\n \n-            if Buf.Chars (Old) = 'Q'\n-              and then Old < Buf.Length\n+            if Temp.Chars (Old) = 'Q'\n+              and then Old < Temp.Length\n             then\n                Old := Old + 1;\n                Insert_Character (''');\n@@ -318,10 +324,10 @@ package body Namet is\n \n             --  Case of operator name\n \n-            elsif Buf.Chars (Old) = 'O'\n-              and then Old < Buf.Length\n-              and then Buf.Chars (Old + 1) not in 'A' .. 'Z'\n-              and then Buf.Chars (Old + 1) /= '_'\n+            elsif Temp.Chars (Old) = 'O'\n+              and then Old < Temp.Length\n+              and then Temp.Chars (Old + 1) not in 'A' .. 'Z'\n+              and then Temp.Chars (Old + 1) /= '_'\n             then\n                Old := Old + 1;\n \n@@ -362,8 +368,8 @@ package body Namet is\n \n                   J := Map'First;\n                   loop\n-                     exit when Buf.Chars (Old) = Map (J)\n-                       and then Buf.Chars (Old + 1) = Map (J + 1);\n+                     exit when Temp.Chars (Old) = Map (J)\n+                       and then Temp.Chars (Old + 1) = Map (J + 1);\n                      J := J + 4;\n                   end loop;\n \n@@ -380,8 +386,8 @@ package body Namet is\n \n                      --  Skip past original operator name in input\n \n-                     while Old <= Buf.Length\n-                       and then Buf.Chars (Old) in 'a' .. 'z'\n+                     while Old <= Temp.Length\n+                       and then Temp.Chars (Old) in 'a' .. 'z'\n                      loop\n                         Old := Old + 1;\n                      end loop;\n@@ -392,8 +398,8 @@ package body Namet is\n                   else\n                      --  Copy original operator name from input to output\n \n-                     while Old <= Buf.Length\n-                        and then Buf.Chars (Old) in 'a' .. 'z'\n+                     while Old <= Temp.Length\n+                        and then Temp.Chars (Old) in 'a' .. 'z'\n                      loop\n                         Copy_One_Character;\n                      end loop;\n@@ -411,9 +417,12 @@ package body Namet is\n \n          --  Copy new buffer as result\n \n-         Buf.Length := New_Len;\n-         Buf.Chars (1 .. New_Len) := New_Buf (1 .. New_Len);\n+         Temp.Length := New_Len;\n+         Temp.Chars (1 .. New_Len) := New_Buf (1 .. New_Len);\n       end Decode;\n+\n+      <<Done>>\n+      Append (Buf, Temp);\n    end Append_Decoded;\n \n    ----------------------------------\n@@ -440,67 +449,73 @@ package body Namet is\n       --  Only remaining issue is U/W/WW sequences\n \n       else\n-         Append (Buf, Id);\n+         declare\n+            Temp : Bounded_String;\n+         begin\n+            Append (Temp, Id);\n \n-         P := 1;\n-         while P < Buf.Length loop\n-            if Buf.Chars (P + 1) in 'A' .. 'Z' then\n-               P := P + 1;\n+            P := 1;\n+            while P < Temp.Length loop\n+               if Temp.Chars (P + 1) in 'A' .. 'Z' then\n+                  P := P + 1;\n \n-            --  Uhh encoding\n+               --  Uhh encoding\n \n-            elsif Buf.Chars (P) = 'U' then\n-               for J in reverse P + 3 .. P + Buf.Length loop\n-                  Buf.Chars (J + 3) := Buf.Chars (J);\n-               end loop;\n+               elsif Temp.Chars (P) = 'U' then\n+                  for J in reverse P + 3 .. P + Temp.Length loop\n+                     Temp.Chars (J + 3) := Temp.Chars (J);\n+                  end loop;\n \n-               Buf.Length := Buf.Length + 3;\n-               Buf.Chars (P + 3) := Buf.Chars (P + 2);\n-               Buf.Chars (P + 2) := Buf.Chars (P + 1);\n-               Buf.Chars (P)     := '[';\n-               Buf.Chars (P + 1) := '\"';\n-               Buf.Chars (P + 4) := '\"';\n-               Buf.Chars (P + 5) := ']';\n-               P := P + 6;\n-\n-            --  WWhhhhhhhh encoding\n-\n-            elsif Buf.Chars (P) = 'W'\n-              and then P + 9 <= Buf.Length\n-              and then Buf.Chars (P + 1) = 'W'\n-              and then Buf.Chars (P + 2) not in 'A' .. 'Z'\n-              and then Buf.Chars (P + 2) /= '_'\n-            then\n-               Buf.Chars (P + 12 .. Buf.Length + 2) :=\n-                 Buf.Chars (P + 10 .. Buf.Length);\n-               Buf.Chars (P)     := '[';\n-               Buf.Chars (P + 1) := '\"';\n-               Buf.Chars (P + 10) := '\"';\n-               Buf.Chars (P + 11) := ']';\n-               Buf.Length := Buf.Length + 2;\n-               P := P + 12;\n-\n-            --  Whhhh encoding\n-\n-            elsif Buf.Chars (P) = 'W'\n-              and then P < Buf.Length\n-              and then Buf.Chars (P + 1) not in 'A' .. 'Z'\n-              and then Buf.Chars (P + 1) /= '_'\n-            then\n-               Buf.Chars (P + 8 .. P + Buf.Length + 3) :=\n-                 Buf.Chars (P + 5 .. Buf.Length);\n-               Buf.Chars (P + 2 .. P + 5) := Buf.Chars (P + 1 .. P + 4);\n-               Buf.Chars (P)     := '[';\n-               Buf.Chars (P + 1) := '\"';\n-               Buf.Chars (P + 6) := '\"';\n-               Buf.Chars (P + 7) := ']';\n-               Buf.Length := Buf.Length + 3;\n-               P := P + 8;\n+                  Temp.Length := Temp.Length + 3;\n+                  Temp.Chars (P + 3) := Temp.Chars (P + 2);\n+                  Temp.Chars (P + 2) := Temp.Chars (P + 1);\n+                  Temp.Chars (P)     := '[';\n+                  Temp.Chars (P + 1) := '\"';\n+                  Temp.Chars (P + 4) := '\"';\n+                  Temp.Chars (P + 5) := ']';\n+                  P := P + 6;\n+\n+               --  WWhhhhhhhh encoding\n+\n+               elsif Temp.Chars (P) = 'W'\n+                 and then P + 9 <= Temp.Length\n+                 and then Temp.Chars (P + 1) = 'W'\n+                 and then Temp.Chars (P + 2) not in 'A' .. 'Z'\n+                 and then Temp.Chars (P + 2) /= '_'\n+               then\n+                  Temp.Chars (P + 12 .. Temp.Length + 2) :=\n+                    Temp.Chars (P + 10 .. Temp.Length);\n+                  Temp.Chars (P)     := '[';\n+                  Temp.Chars (P + 1) := '\"';\n+                  Temp.Chars (P + 10) := '\"';\n+                  Temp.Chars (P + 11) := ']';\n+                  Temp.Length := Temp.Length + 2;\n+                  P := P + 12;\n+\n+               --  Whhhh encoding\n+\n+               elsif Temp.Chars (P) = 'W'\n+                 and then P < Temp.Length\n+                 and then Temp.Chars (P + 1) not in 'A' .. 'Z'\n+                 and then Temp.Chars (P + 1) /= '_'\n+               then\n+                  Temp.Chars (P + 8 .. P + Temp.Length + 3) :=\n+                    Temp.Chars (P + 5 .. Temp.Length);\n+                  Temp.Chars (P + 2 .. P + 5) := Temp.Chars (P + 1 .. P + 4);\n+                  Temp.Chars (P)     := '[';\n+                  Temp.Chars (P + 1) := '\"';\n+                  Temp.Chars (P + 6) := '\"';\n+                  Temp.Chars (P + 7) := ']';\n+                  Temp.Length := Temp.Length + 3;\n+                  P := P + 8;\n \n-            else\n-               P := P + 1;\n-            end if;\n-         end loop;\n+               else\n+                  P := P + 1;\n+               end if;\n+            end loop;\n+\n+            Append (Buf, Temp);\n+         end;\n       end if;\n    end Append_Decoded_With_Brackets;\n \n@@ -564,9 +579,11 @@ package body Namet is\n    ------------------------\n \n    procedure Append_Unqualified (Buf : in out Bounded_String; Id : Name_Id) is\n+      Temp : Bounded_String;\n    begin\n-      Append (Buf, Id);\n-      Strip_Qualification_And_Suffixes (Buf);\n+      Append (Temp, Id);\n+      Strip_Qualification_And_Suffixes (Temp);\n+      Append (Buf, Temp);\n    end Append_Unqualified;\n \n    --------------------------------\n@@ -577,9 +594,11 @@ package body Namet is\n      (Buf : in out Bounded_String;\n       Id  : Name_Id)\n    is\n+      Temp : Bounded_String;\n    begin\n-      Append_Decoded (Buf, Id);\n-      Strip_Qualification_And_Suffixes (Buf);\n+      Append_Decoded (Temp, Id);\n+      Strip_Qualification_And_Suffixes (Temp);\n+      Append (Buf, Temp);\n    end Append_Unqualified_Decoded;\n \n    --------------\n@@ -1625,9 +1644,9 @@ package body Namet is\n    -- To_String --\n    ---------------\n \n-   function To_String (X : Bounded_String) return String is\n+   function To_String (Buf : Bounded_String) return String is\n    begin\n-      return X.Chars (1 .. X.Length);\n+      return Buf.Chars (1 .. Buf.Length);\n    end To_String;\n \n    ---------------"}, {"sha": "88063644070ad6baeb9474bf95ce52da03cd8fc6", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -318,8 +318,9 @@ package Namet is\n    -- Subprograms --\n    -----------------\n \n-   function To_String (X : Bounded_String) return String;\n-   function \"+\" (X : Bounded_String) return String renames To_String;\n+   function To_String (Buf : Bounded_String) return String;\n+   pragma Inline (To_String);\n+   function \"+\" (Buf : Bounded_String) return String renames To_String;\n \n    function Name_Find\n      (Buf : Bounded_String := Global_Name_Buffer) return Name_Id;\n@@ -361,6 +362,9 @@ package Namet is\n    procedure Append (Buf : in out Bounded_String; S : String);\n    --  Append S onto Buf\n \n+   procedure Append (Buf : in out Bounded_String; Buf2 : Bounded_String);\n+   --  Append Buf2 onto Buf\n+\n    procedure Append (Buf : in out Bounded_String; Id : Name_Id);\n    --  Append the characters of Id onto Buf. It is an error to call this with\n    --  one of the special name Id values (No_Name or Error_Name)."}, {"sha": "6f086bf958ab7476b0b194657ddba7f3c4c8b6f2", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -2550,17 +2550,27 @@ package body Sem_Ch6 is\n \n          function Is_Inline_Pragma (N : Node_Id) return Boolean is\n          begin\n-            return\n-              Nkind (N) = N_Pragma\n+            if Nkind (N) = N_Pragma\n                 and then\n                   (Pragma_Name (N) = Name_Inline_Always\n                     or else (Pragma_Name (N) = Name_Inline\n                       and then\n                         (Front_End_Inlining or else Optimization_Level > 0)))\n-                and then\n-                  Chars\n-                    (Expression (First (Pragma_Argument_Associations (N)))) =\n-                                                              Chars (Body_Id);\n+            then\n+               declare\n+                  Pragma_Arg : Node_Id :=\n+                    Expression (First (Pragma_Argument_Associations (N)));\n+               begin\n+                  if Nkind (Pragma_Arg) = N_Selected_Component then\n+                     Pragma_Arg := Selector_Name (Pragma_Arg);\n+                  end if;\n+\n+                  return Chars (Pragma_Arg) = Chars (Body_Id);\n+               end;\n+\n+            else\n+               return False;\n+            end if;\n          end Is_Inline_Pragma;\n \n       --  Start of processing for Check_Inline_Pragma\n@@ -2588,7 +2598,10 @@ package body Sem_Ch6 is\n \n          if Present (Prag) then\n             if Present (Spec_Id) then\n-               if In_Same_List (N, Unit_Declaration_Node (Spec_Id)) then\n+               if Is_List_Member (N)\n+                 and then Is_List_Member (Unit_Declaration_Node (Spec_Id))\n+                 and then In_Same_List (N, Unit_Declaration_Node (Spec_Id))\n+               then\n                   Analyze (Prag);\n                end if;\n "}, {"sha": "52c73c3f5844f1b45a7263665749ec913943ae55", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -9863,7 +9863,7 @@ package body Sem_Prag is\n \n          begin\n             Get_Name_String (Chars (Prof_Nam));\n-            Adjust_Name_Case (Sloc (Prof_Nam));\n+            Adjust_Name_Case (Global_Name_Buffer, Sloc (Prof_Nam));\n             Error_Msg_Strlen := Name_Len;\n             Error_Msg_String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n          end Set_Error_Msg_To_Profile_Name;"}, {"sha": "5be78732cae06356d340721567ff52016f6cdf65", "filename": "gcc/ada/stringt.adb", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fstringt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fstringt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -80,16 +80,16 @@ package body Stringt is\n    -------------------------------\n \n    procedure Add_String_To_Name_Buffer (S : String_Id) is\n-      Len : constant Natural := Natural (String_Length (S));\n+   begin\n+      Append (Global_Name_Buffer, S);\n+   end Add_String_To_Name_Buffer;\n \n+   procedure Append (Buf : in out Bounded_String; S : String_Id) is\n    begin\n-      for J in 1 .. Len loop\n-         Name_Buffer (Name_Len + J) :=\n-           Get_Character (Get_String_Char (S, Int (J)));\n+      for X in 1 .. String_Length (S) loop\n+         Append (Buf, Get_Character (Get_String_Char (S, X)));\n       end loop;\n-\n-      Name_Len := Name_Len + Len;\n-   end Add_String_To_Name_Buffer;\n+   end Append;\n \n    ----------------\n    -- End_String --\n@@ -330,12 +330,8 @@ package body Stringt is\n \n    procedure String_To_Name_Buffer (S : String_Id) is\n    begin\n-      Name_Len := Natural (String_Length (S));\n-\n-      for J in 1 .. Name_Len loop\n-         Name_Buffer (J) :=\n-           Get_Character (Get_String_Char (S, Int (J)));\n-      end loop;\n+      Name_Len := 0;\n+      Append (Global_Name_Buffer, S);\n    end String_To_Name_Buffer;\n \n    ---------------------"}, {"sha": "4b7c0e5ad50edf8292e085231c99bd621a2b6818", "filename": "gcc/ada/stringt.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fstringt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Fstringt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.ads?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -124,10 +124,13 @@ package Stringt is\n    --  Error if any characters are out of Character range. Does not attempt\n    --  to do any encoding of any characters.\n \n+   procedure Append (Buf : in out Bounded_String; S : String_Id);\n+   --  Append characters of given string to Buf. Error if any characters are\n+   --  out of Character range. Does not attempt to do any encoding of any\n+   --  characters.\n+\n    procedure Add_String_To_Name_Buffer (S : String_Id);\n-   --  Append characters of given string to Name_Buffer, updating Name_Len.\n-   --  Error if any characters are out of Character range. Does not attempt\n-   --  to do any encoding of any characters.\n+   --  Same as Append (Global_Name_Buffer, S)\n \n    function String_Chars_Address return System.Address;\n    --  Return address of String_Chars table (used by Back_End call to Gigi)"}, {"sha": "84518017698114a6b147ab6cbb641738e591c0b3", "filename": "gcc/ada/uname.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Funame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b269f47786ffff084e874cd09ac8d87f895a1db6/gcc%2Fada%2Funame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.adb?ref=b269f47786ffff084e874cd09ac8d87f895a1db6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -429,7 +429,7 @@ package body Uname is\n    begin\n       Get_Decoded_Name_String (N);\n       Unit_Is_Body := Name_Buffer (Name_Len) = 'b';\n-      Set_Casing (Identifier_Casing (Source_Index (Main_Unit)), Mixed_Case);\n+      Set_Casing (Identifier_Casing (Source_Index (Main_Unit)));\n \n       --  A special fudge, normally we don't have operator symbols present,\n       --  since it is always an error to do so. However, if we do, at this"}]}