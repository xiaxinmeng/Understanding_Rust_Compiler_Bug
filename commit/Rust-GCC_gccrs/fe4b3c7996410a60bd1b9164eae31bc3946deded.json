{"sha": "fe4b3c7996410a60bd1b9164eae31bc3946deded", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU0YjNjNzk5NjQxMGE2MGJkMWI5MTY0ZWFlMzFiYzM5NDZkZWRlZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-05-14T04:15:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-05-14T04:15:57Z"}, "message": "flow.c (invalidate_mems_from_autoinc): Rewrite to use for_each_rtx.\n\n        * flow.c (invalidate_mems_from_autoinc): Rewrite to use for_each_rtx.\n        Update prototype and callers.\n        (propagate_one_insn): Stack pointer adjustments kill MEMs on\n        the mem_set_list which reference the stack pointer, as do\n        calls to constant functions as they may clobber outgoing\n        argument space.\n\nFrom-SVN: r53442", "tree": {"sha": "ae31909c2478ff0944567441bd154b38631a8b6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae31909c2478ff0944567441bd154b38631a8b6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe4b3c7996410a60bd1b9164eae31bc3946deded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe4b3c7996410a60bd1b9164eae31bc3946deded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe4b3c7996410a60bd1b9164eae31bc3946deded", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe4b3c7996410a60bd1b9164eae31bc3946deded/comments", "author": null, "committer": null, "parents": [{"sha": "c297b7649ce38bda7fd136bcda476009313e4610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c297b7649ce38bda7fd136bcda476009313e4610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c297b7649ce38bda7fd136bcda476009313e4610"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "95760b39a7db393e8be618264fcf4f6f6829aa6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4b3c7996410a60bd1b9164eae31bc3946deded/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4b3c7996410a60bd1b9164eae31bc3946deded/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe4b3c7996410a60bd1b9164eae31bc3946deded", "patch": "@@ -23,6 +23,13 @@\n \n 2002-05-13  Jeffrey A Law  (law@redhat.com)\n \n+\t* flow.c (invalidate_mems_from_autoinc): Rewrite to use for_each_rtx.\n+\tUpdate prototype and callers.\n+\t(propagate_one_insn): Stack pointer adjustments kill MEMs on\n+\tthe mem_set_list which reference the stack pointer, as do\n+\tcalls to constant functions as they may clobber outgoing\n+\targument space.\n+\n \t* i386.c (ia32_multipass_dfa_lookahead): Prototype.\n \n \t* i386.c (TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD): Define."}, {"sha": "8a9a9db1a454c0cdc5c3bb7cb127701a7cc3f456", "filename": "gcc/flow.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4b3c7996410a60bd1b9164eae31bc3946deded/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4b3c7996410a60bd1b9164eae31bc3946deded/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=fe4b3c7996410a60bd1b9164eae31bc3946deded", "patch": "@@ -338,8 +338,7 @@ void dump_flow_info\t\t\tPARAMS ((FILE *));\n void debug_flow_info\t\t\tPARAMS ((void));\n static void add_to_mem_set_list\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx));\n-static void invalidate_mems_from_autoinc PARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t  rtx));\n+static int invalidate_mems_from_autoinc PARAMS ((rtx *, void *));\n static void invalidate_mems_from_set\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx));\n static void clear_log_links\t\tPARAMS ((sbitmap));\n@@ -1715,8 +1714,9 @@ propagate_one_insn (pbi, insn)\n     /* We have an insn to pop a constant amount off the stack.\n        (Such insns use PLUS regardless of the direction of the stack,\n        and any insn to adjust the stack by a constant is always a pop.)\n-       These insns, if not dead stores, have no effect on life.  */\n-    ;\n+       These insns, if not dead stores, have no effect on life, though\n+       they do have an effect on the memory stores we are tracking.  */\n+    invalidate_mems_from_set (pbi, stack_pointer_rtx);\n   else\n     {\n       rtx note;\n@@ -1741,12 +1741,16 @@ propagate_one_insn (pbi, insn)\n \t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t    cond = COND_EXEC_TEST (PATTERN (insn));\n \n-\t  /* Non-constant calls clobber memory.  */\n+\t  /* Non-constant calls clobber memory, constant calls do not\n+\t     clobber memory, though they may clobber outgoing arguments\n+\t     on the stack.  */\n \t  if (! CONST_OR_PURE_CALL_P (insn))\n \t    {\n \t      free_EXPR_LIST_list (&pbi->mem_set_list);\n \t      pbi->mem_set_list_len = 0;\n \t    }\n+          else\n+\t    invalidate_mems_from_set (pbi, stack_pointer_rtx);\n \n \t  /* There may be extra registers to be clobbered.  */\n \t  for (note = CALL_INSN_FUNCTION_USAGE (insn);\n@@ -2415,15 +2419,21 @@ add_to_mem_set_list (pbi, mem)\n    Find any entries on the mem_set_list that need to be invalidated due\n    to an address change.  */\n \n-static void\n-invalidate_mems_from_autoinc (pbi, insn)\n-     struct propagate_block_info *pbi;\n-     rtx insn;\n+static int\n+invalidate_mems_from_autoinc (px, data)\n+     rtx *px;\n+     void *data;\n {\n-  rtx note = REG_NOTES (insn);\n-  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-    if (REG_NOTE_KIND (note) == REG_INC)\n-      invalidate_mems_from_set (pbi, XEXP (note, 0));\n+  rtx x = *px;\n+  struct propagate_block_info *pbi = data;\n+\n+  if (GET_RTX_CLASS (GET_CODE (x)) == 'a')\n+    {\n+      invalidate_mems_from_set (pbi, XEXP (x, 0));\n+      return -1;\n+    }\n+\n+  return 0;\n }\n \n /* EXP is a REG.  Remove any dependent entries from pbi->mem_set_list.  */\n@@ -2645,15 +2655,11 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t address modes.  Then we may need to kill some entries on the\n \t memory set list.  */\n       if (insn && GET_CODE (reg) == MEM)\n-\tinvalidate_mems_from_autoinc (pbi, insn);\n+\tfor_each_rtx (&PATTERN (insn), invalidate_mems_from_autoinc, pbi);\n \n       if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n \t  /* ??? With more effort we could track conditional memory life.  */\n-\t  && ! cond\n-\t  /* There are no REG_INC notes for SP, so we can't assume we'll see\n-\t     everything that invalidates it.  To be safe, don't eliminate any\n-\t     stores though SP; none of them should be redundant anyway.  */\n-\t  && ! reg_mentioned_p (stack_pointer_rtx, reg))\n+\t  && ! cond)\n         add_to_mem_set_list (pbi, canon_rtx (reg));\n     }\n \n@@ -3780,7 +3786,7 @@ mark_used_regs (pbi, x, cond, insn)\n \t     address modes.  Then we may need to kill some entries on the\n \t     memory set list.  */\n \t  if (insn)\n-\t    invalidate_mems_from_autoinc (pbi, insn);\n+\t    for_each_rtx (&PATTERN (insn), invalidate_mems_from_autoinc, pbi);\n \t}\n \n #ifdef AUTO_INC_DEC"}]}