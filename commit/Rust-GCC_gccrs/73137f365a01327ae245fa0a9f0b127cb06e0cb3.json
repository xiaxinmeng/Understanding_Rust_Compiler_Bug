{"sha": "73137f365a01327ae245fa0a9f0b127cb06e0cb3", "node_id": "C_kwDOANBUbNoAKDczMTM3ZjM2NWEwMTMyN2FlMjQ1ZmEwYTlmMGIxMjdjYjA2ZTBjYjM", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-09-22T20:08:43Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-10-09T11:38:34Z"}, "message": "pru: Optimize DI shifts\n\nIf the number of shift positions is a constant, then the DI shift\noperation is expanded to a sequence of 2 to 4 machine instructions.\nThat is more efficient than the default action to call libgcc.\n\ngcc/ChangeLog:\n\n\t* config/pru/pru.md (lshrdi3): New expand pattern.\n\t(ashldi3): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/pru/ashiftdi-1.c: New test.\n\t* gcc.target/pru/lshiftrtdi-1.c: New test.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "aa5f20dc7b5d3565ae5534a8fbe541c2f6f7f7c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa5f20dc7b5d3565ae5534a8fbe541c2f6f7f7c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73137f365a01327ae245fa0a9f0b127cb06e0cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73137f365a01327ae245fa0a9f0b127cb06e0cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73137f365a01327ae245fa0a9f0b127cb06e0cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73137f365a01327ae245fa0a9f0b127cb06e0cb3/comments", "author": null, "committer": null, "parents": [{"sha": "66c48be23e0fa5ee7474b4b078e013f901c71eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66c48be23e0fa5ee7474b4b078e013f901c71eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66c48be23e0fa5ee7474b4b078e013f901c71eed"}], "stats": {"total": 302, "additions": 302, "deletions": 0}, "files": [{"sha": "53ffff07708708264723810cea0d38c176b52f42", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73137f365a01327ae245fa0a9f0b127cb06e0cb3/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73137f365a01327ae245fa0a9f0b127cb06e0cb3/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=73137f365a01327ae245fa0a9f0b127cb06e0cb3", "patch": "@@ -703,6 +703,202 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length\" \"12\")])\n \n+\n+; 64-bit LSHIFTRT with a constant shift count can be expanded into\n+; more efficient code sequence than a variable register shift.\n+;\n+; 1. For shift >= 32:\n+;    dst_lo = (src_hi >> (shift - 32))\n+;    dst_hi = 0\n+;\n+; 2. For shift==1 there is no need for a temporary:\n+;    dst_lo = (src_lo >> 1)\n+;    if (src_hi & 1)\n+;       dst_lo |= (1 << 31)\n+;    dst_hi = (src_hi >> 1)\n+;\n+; 3. For shift < 32:\n+;    dst_lo = (src_lo >> shift)\n+;    tmp = (src_hi << (32 - shift)\n+;    dst_lo |= tmp\n+;    dst_hi = (src_hi >> shift)\n+;\n+; 4. For shift in a register:\n+;    Fall back to calling libgcc.\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t  (lshiftrt:DI\n+\t    (match_operand:DI 1 \"register_operand\")\n+\t    (match_operand:QI 2 \"const_int_operand\")))]\n+  \"\"\n+{\n+  gcc_assert (CONST_INT_P (operands[2]));\n+\n+  const int nshifts = INTVAL (operands[2]);\n+  rtx dst_lo = simplify_gen_subreg (SImode, operands[0], DImode, 0);\n+  rtx dst_hi = simplify_gen_subreg (SImode, operands[0], DImode, 4);\n+  rtx src_lo = simplify_gen_subreg (SImode, operands[1], DImode, 0);\n+  rtx src_hi = simplify_gen_subreg (SImode, operands[1], DImode, 4);\n+\n+  if (nshifts >= 32)\n+    {\n+      emit_insn (gen_rtx_SET (dst_lo,\n+\t\t\t      gen_rtx_LSHIFTRT (SImode,\n+\t\t\t\t\t\tsrc_hi,\n+\t\t\t\t\t\tGEN_INT (nshifts - 32))));\n+      emit_insn (gen_rtx_SET (dst_hi, const0_rtx));\n+      DONE;\n+    }\n+\n+  gcc_assert (can_create_pseudo_p ());\n+\n+  /* The expansions which follow are safe only if DST_LO and SRC_HI\n+     do not overlap.  If they do, then fix by using a temporary register.\n+     Overlapping of DST_HI and SRC_LO is safe because by the time DST_HI\n+     is set, SRC_LO is no longer live.  */\n+  if (reg_overlap_mentioned_p (dst_lo, src_hi))\n+    {\n+      rtx new_src_hi = gen_reg_rtx (SImode);\n+\n+      emit_move_insn (new_src_hi, src_hi);\n+      src_hi = new_src_hi;\n+    }\n+\n+  if (nshifts == 1)\n+    {\n+      rtx_code_label *skip_hiset_label;\n+      rtx j;\n+\n+      emit_insn (gen_rtx_SET (dst_lo,\n+\t\t\t      gen_rtx_LSHIFTRT (SImode, src_lo, const1_rtx)));\n+\n+      /* The code generated by `genemit' would create a LABEL_REF.  */\n+      skip_hiset_label = gen_label_rtx ();\n+      j = emit_jump_insn (gen_cbranch_qbbx_const (EQ,\n+\t\t\t\t\t\t  SImode,\n+\t\t\t\t\t\t  src_hi,\n+\t\t\t\t\t\t  GEN_INT (0),\n+\t\t\t\t\t\t  skip_hiset_label));\n+      JUMP_LABEL (j) = skip_hiset_label;\n+      LABEL_NUSES (skip_hiset_label)++;\n+\n+      emit_insn (gen_iorsi3 (dst_lo, dst_lo, GEN_INT (1 << 31)));\n+      emit_label (skip_hiset_label);\n+      emit_insn (gen_rtx_SET (dst_hi,\n+\t\t\t      gen_rtx_LSHIFTRT (SImode, src_hi, const1_rtx)));\n+      DONE;\n+    }\n+\n+  if (nshifts < 32)\n+    {\n+      rtx tmpval = gen_reg_rtx (SImode);\n+\n+      emit_insn (gen_rtx_SET (dst_lo,\n+\t\t\t      gen_rtx_LSHIFTRT (SImode,\n+\t\t\t\t\t\tsrc_lo,\n+\t\t\t\t\t\tGEN_INT (nshifts))));\n+      emit_insn (gen_rtx_SET (tmpval,\n+\t\t\t      gen_rtx_ASHIFT (SImode,\n+\t\t\t\t\t      src_hi,\n+\t\t\t\t\t      GEN_INT (32 - nshifts))));\n+      emit_insn (gen_iorsi3 (dst_lo, dst_lo, tmpval));\n+      emit_insn (gen_rtx_SET (dst_hi,\n+\t\t\t      gen_rtx_LSHIFTRT (SImode,\n+\t\t\t\t\t\tsrc_hi,\n+\t\t\t\t\t\tGEN_INT (nshifts))));\n+      DONE;\n+    }\n+  gcc_unreachable ();\n+})\n+\n+; 64-bit ASHIFT with a constant shift count can be expanded into\n+; more efficient code sequence than the libgcc call required by\n+; a variable shift in a register.\n+\n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t  (ashift:DI\n+\t    (match_operand:DI 1 \"register_operand\")\n+\t    (match_operand:QI 2 \"const_int_operand\")))]\n+  \"\"\n+{\n+  gcc_assert (CONST_INT_P (operands[2]));\n+\n+  const int nshifts = INTVAL (operands[2]);\n+  rtx dst_lo = simplify_gen_subreg (SImode, operands[0], DImode, 0);\n+  rtx dst_hi = simplify_gen_subreg (SImode, operands[0], DImode, 4);\n+  rtx src_lo = simplify_gen_subreg (SImode, operands[1], DImode, 0);\n+  rtx src_hi = simplify_gen_subreg (SImode, operands[1], DImode, 4);\n+\n+  if (nshifts >= 32)\n+    {\n+      emit_insn (gen_rtx_SET (dst_hi,\n+\t\t\t      gen_rtx_ASHIFT (SImode,\n+\t\t\t\t\t      src_lo,\n+\t\t\t\t\t      GEN_INT (nshifts - 32))));\n+      emit_insn (gen_rtx_SET (dst_lo, const0_rtx));\n+      DONE;\n+    }\n+\n+  gcc_assert (can_create_pseudo_p ());\n+\n+  /* The expansions which follow are safe only if DST_HI and SRC_LO\n+     do not overlap.  If they do, then fix by using a temporary register.\n+     Overlapping of DST_LO and SRC_HI is safe because by the time DST_LO\n+     is set, SRC_HI is no longer live.  */\n+  if (reg_overlap_mentioned_p (dst_hi, src_lo))\n+    {\n+      rtx new_src_lo = gen_reg_rtx (SImode);\n+\n+      emit_move_insn (new_src_lo, src_lo);\n+      src_lo = new_src_lo;\n+    }\n+\n+  if (nshifts == 1)\n+    {\n+      rtx_code_label *skip_hiset_label;\n+      rtx j;\n+\n+      emit_insn (gen_rtx_SET (dst_hi,\n+\t\t\t      gen_rtx_ASHIFT (SImode, src_hi, const1_rtx)));\n+\n+      skip_hiset_label = gen_label_rtx ();\n+      j = emit_jump_insn (gen_cbranch_qbbx_const (EQ,\n+\t\t\t\t\t\t  SImode,\n+\t\t\t\t\t\t  src_lo,\n+\t\t\t\t\t\t  GEN_INT (31),\n+\t\t\t\t\t\t  skip_hiset_label));\n+      JUMP_LABEL (j) = skip_hiset_label;\n+      LABEL_NUSES (skip_hiset_label)++;\n+\n+      emit_insn (gen_iorsi3 (dst_hi, dst_hi, GEN_INT (1 << 0)));\n+      emit_label (skip_hiset_label);\n+      emit_insn (gen_rtx_SET (dst_lo,\n+\t\t\t      gen_rtx_ASHIFT (SImode, src_lo, const1_rtx)));\n+      DONE;\n+    }\n+\n+  if (nshifts < 32)\n+    {\n+      rtx tmpval = gen_reg_rtx (SImode);\n+\n+      emit_insn (gen_rtx_SET (dst_hi,\n+\t\t\t      gen_rtx_ASHIFT (SImode,\n+\t\t\t\t\t      src_hi,\n+\t\t\t\t\t      GEN_INT (nshifts))));\n+      emit_insn (gen_rtx_SET (tmpval,\n+\t\t\t      gen_rtx_LSHIFTRT (SImode,\n+\t\t\t\t\t\tsrc_lo,\n+\t\t\t\t\t\tGEN_INT (32 - nshifts))));\n+      emit_insn (gen_iorsi3 (dst_hi, dst_hi, tmpval));\n+      emit_insn (gen_rtx_SET (dst_lo,\n+\t\t\t      gen_rtx_ASHIFT (SImode,\n+\t\t\t\t\t      src_lo,\n+\t\t\t\t\t      GEN_INT (nshifts))));\n+      DONE;\n+    }\n+  gcc_unreachable ();\n+})\n \f\n ;; Include ALU patterns with zero-extension of operands.  That's where\n ;; the real insns are defined."}, {"sha": "516e5a86102e40a08059ccfc31572bea814b29a8", "filename": "gcc/testsuite/gcc.target/pru/ashiftdi-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73137f365a01327ae245fa0a9f0b127cb06e0cb3/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fashiftdi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73137f365a01327ae245fa0a9f0b127cb06e0cb3/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fashiftdi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fashiftdi-1.c?ref=73137f365a01327ae245fa0a9f0b127cb06e0cb3", "patch": "@@ -0,0 +1,53 @@\n+/* Functional test for DI left shift.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+extern void abort (void);\n+\n+uint64_t __attribute__((noinline)) ashift_1 (uint64_t a)\n+{\n+  return a << 1;\n+}\n+\n+uint64_t __attribute__((noinline)) ashift_10 (uint64_t a)\n+{\n+  return a << 10;\n+}\n+\n+uint64_t __attribute__((noinline)) ashift_32 (uint64_t a)\n+{\n+  return a << 32;\n+}\n+\n+uint64_t __attribute__((noinline)) ashift_36 (uint64_t a)\n+{\n+  return a << 36;\n+}\n+\n+int\n+main (int argc, char** argv)\n+{\n+  if (ashift_1 (0xaaaa5555aaaa5555ull) != 0x5554aaab5554aaaaull)\n+    abort();\n+  if (ashift_10 (0xaaaa5555aaaa5555ull) != 0xa95556aaa9555400ull)\n+    abort();\n+  if (ashift_32 (0xaaaa5555aaaa5555ull) != 0xaaaa555500000000ull)\n+    abort();\n+  if (ashift_36 (0xaaaa5555aaaa5555ull) != 0xaaa5555000000000ull)\n+    abort();\n+\n+  if (ashift_1 (0x1234567822334455ull) != 0x2468acf0446688aaull)\n+    abort();\n+  if (ashift_10 (0x1234567822334455ull) != 0xd159e088cd115400ull)\n+    abort();\n+  if (ashift_32 (0x1234567822334455ull) != 0x2233445500000000ull)\n+    abort();\n+  if (ashift_36 (0x1234567822334455ull) != 0x2334455000000000ull)\n+    abort();\n+\n+  return 0;\n+}"}, {"sha": "7adae6ccc131f9fa92672de75308dc93de300de6", "filename": "gcc/testsuite/gcc.target/pru/lshiftrtdi-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73137f365a01327ae245fa0a9f0b127cb06e0cb3/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Flshiftrtdi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73137f365a01327ae245fa0a9f0b127cb06e0cb3/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Flshiftrtdi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Flshiftrtdi-1.c?ref=73137f365a01327ae245fa0a9f0b127cb06e0cb3", "patch": "@@ -0,0 +1,53 @@\n+/* Functional test for DI right shift.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+extern void abort (void);\n+\n+uint64_t __attribute__((noinline)) lshift_1 (uint64_t a)\n+{\n+  return a >> 1;\n+}\n+\n+uint64_t __attribute__((noinline)) lshift_10 (uint64_t a)\n+{\n+  return a >> 10;\n+}\n+\n+uint64_t __attribute__((noinline)) lshift_32 (uint64_t a)\n+{\n+  return a >> 32;\n+}\n+\n+uint64_t __attribute__((noinline)) lshift_36 (uint64_t a)\n+{\n+  return a >> 36;\n+}\n+\n+int\n+main (int argc, char** argv)\n+{\n+  if (lshift_1 (0xaaaa5555aaaa5555ull) != 0x55552aaad5552aaaull)\n+    abort();\n+  if (lshift_10 (0xaaaa5555aaaa5555ull) != 0x002aaa95556aaa95ull)\n+    abort();\n+  if (lshift_32 (0xaaaa5555aaaa5555ull) != 0x00000000aaaa5555ull)\n+    abort();\n+  if (lshift_36 (0xaaaa5555aaaa5555ull) != 0x000000000aaaa555ull)\n+    abort();\n+\n+  if (lshift_1 (0x1234567822334455ull) != 0x091a2b3c1119a22aull)\n+    abort();\n+  if (lshift_10 (0x1234567822334455ull) != 0x00048d159e088cd1ull)\n+    abort();\n+  if (lshift_32 (0x1234567822334455ull) != 0x0000000012345678ull)\n+    abort();\n+  if (lshift_36 (0x1234567822334455ull) != 0x0000000001234567ull)\n+    abort();\n+\n+  return 0;\n+}"}]}