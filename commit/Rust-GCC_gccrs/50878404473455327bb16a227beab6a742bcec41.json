{"sha": "50878404473455327bb16a227beab6a742bcec41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA4Nzg0MDQ0NzM0NTUzMjdiYjE2YTIyN2JlYWI2YTc0MmJjZWM0MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-23T08:19:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-23T08:19:53Z"}, "message": "[multiple changes]\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch6.adb (P_Mode): in Ada 2005, a mode indicator can apply\n\tto a formal object of an anonymous access type.\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Container_Indexing): A user-defined indexing\n\taspect can have more than one index, e.g. to describe indexing\n\tof a multidimensional object.\n\n2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Apply_Accessibility_Check): Reimplemented. The check is\n\tnow more complex and contains optional finalization part and mandatory\n\tdeallocation part.\n\n2012-07-23  Gary Dismukes  <dismukes@adacore.com>\n\n\t* a-cihama.adb, a-cihase.adb, a-cimutr.adb, a-ciorma.adb, a-ciormu.adb,\n\ta-ciorse.adb, a-coinho.adb, a-coinve.adb, a-cidlli.adb: Unsuppress\n\tAccessibility_Check for Element_Type allocators.\n\n2012-07-23  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* projects.texi: Fix typo.\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Explicit_Derenference): If prefix is\n\toverloaded, remove those interpretations whose designated type\n\tdoes not match the context, to avoid spurious ambiguities that\n\tmay be caused by the Ada 2012 conversion rule for anonymous\n\taccess types.\n\nFrom-SVN: r189774", "tree": {"sha": "c423732a807b7aef4ba67bc5ebfea36f4fe50f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c423732a807b7aef4ba67bc5ebfea36f4fe50f04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50878404473455327bb16a227beab6a742bcec41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50878404473455327bb16a227beab6a742bcec41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50878404473455327bb16a227beab6a742bcec41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50878404473455327bb16a227beab6a742bcec41/comments", "author": null, "committer": null, "parents": [{"sha": "473e20df28ec46b084ea6a965ab07c3e4f11288d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473e20df28ec46b084ea6a965ab07c3e4f11288d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473e20df28ec46b084ea6a965ab07c3e4f11288d"}], "stats": {"total": 504, "additions": 438, "deletions": 66}, "files": [{"sha": "c504dea1af2f0c94dc624ce6712f6650fc0a501e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -1,3 +1,38 @@\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch6.adb (P_Mode): in Ada 2005, a mode indicator can apply\n+\tto a formal object of an anonymous access type.\n+\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Container_Indexing): A user-defined indexing\n+\taspect can have more than one index, e.g. to describe indexing\n+\tof a multidimensional object.\n+\n+2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Apply_Accessibility_Check): Reimplemented. The check is\n+\tnow more complex and contains optional finalization part and mandatory\n+\tdeallocation part.\n+\n+2012-07-23  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* a-cihama.adb, a-cihase.adb, a-cimutr.adb, a-ciorma.adb, a-ciormu.adb,\n+\ta-ciorse.adb, a-coinho.adb, a-coinve.adb, a-cidlli.adb: Unsuppress\n+\tAccessibility_Check for Element_Type allocators.\n+\n+2012-07-23  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* projects.texi: Fix typo.\n+\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Explicit_Derenference): If prefix is\n+\toverloaded, remove those interpretations whose designated type\n+\tdoes not match the context, to avoid spurious ambiguities that\n+\tmay be caused by the Ada 2012 conversion rule for anonymous\n+\taccess types.\n+\n 2012-07-23  Vincent Celier  <celier@adacore.com>\n \n \t* g-spitbo.adb (Substr (String)): Return full string and do not"}, {"sha": "12a825a8d214b2382c0e4d7af8585cc1eb38d9ca", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -888,6 +888,13 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n+         --  allocator in the loop below, because the one in this block would\n+         --  have failed already.\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n       begin\n          New_Node := new Node_Type'(Element, null, null);\n@@ -1461,8 +1468,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       declare\n-         X : Element_Access := Position.Node.Element;\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n \n+         X : Element_Access := Position.Node.Element;\n       begin\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free (X);"}, {"sha": "3f5b7ec5bd8421bd1a12b2b8c58bec6e2ddefa8d", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -694,6 +694,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n          Position.Node.Key := new Key_Type'(Key);\n \n+         declare\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n          begin\n             Position.Node.Element := new Element_Type'(New_Item);\n          exception\n@@ -731,6 +736,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          K  : Key_Access := new Key_Type'(Key);\n          E  : Element_Access;\n \n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+\n       begin\n          E := new Element_Type'(New_Item);\n          return new Node_Type'(K, E, Next);\n@@ -1166,6 +1176,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n       Node.Key := new Key_Type'(Key);\n \n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n       begin\n          Node.Element := new Element_Type'(New_Item);\n       exception\n@@ -1215,6 +1230,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          X : Element_Access := Position.Node.Element;\n \n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n       begin\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free_Element (X);"}, {"sha": "034cfce67ec89c59ceaaaa9c03b0dced71cc7b46", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -185,6 +185,11 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    procedure Assign (Node : Node_Access; Item : Element_Type) is\n       X : Element_Access := Node.Element;\n+\n+      pragma Unsuppress (Accessibility_Check);\n+      --  The element allocator may need an accessibility check in the case the\n+      --  actual type is class-wide or has access discriminants (RM 4.8(10.1)\n+      --  and AI12-0035).\n    begin\n       Node.Element := new Element_Type'(Item);\n       Free_Element (X);\n@@ -807,7 +812,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          X := Position.Node.Element;\n \n-         Position.Node.Element := new Element_Type'(New_Item);\n+         declare\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n+         begin\n+            Position.Node.Element := new Element_Type'(New_Item);\n+         end;\n \n          Free_Element (X);\n       end if;\n@@ -863,6 +875,11 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       --------------\n \n       function New_Node (Next : Node_Access) return Node_Access is\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n       begin\n          return new Node_Type'(Element, Next);\n@@ -1317,7 +1334,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       X := Node.Element;\n \n-      Node.Element := new Element_Type'(New_Item);\n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+      begin\n+         Node.Element := new Element_Type'(New_Item);\n+      end;\n \n       Free_Element (X);\n    end Replace;"}, {"sha": "4ca89ca11abd4cf97efdcd8b779b17f2663d8eb5", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -291,7 +291,17 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n            with \"attempt to tamper with cursors (tree is busy)\";\n       end if;\n \n-      Element := new Element_Type'(New_Item);\n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n+         --  allocator in the loop below, because the one in this block would\n+         --  have failed already.\n+      begin\n+         Element := new Element_Type'(New_Item);\n+      end;\n+\n       First := new Tree_Node_Type'(Parent  => Parent.Node,\n                                    Element => Element,\n                                    others  => <>);\n@@ -1240,7 +1250,17 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n       Position.Container := Parent.Container;\n \n-      Element := new Element_Type'(New_Item);\n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n+         --  allocator in the loop below, because the one in this block would\n+         --  have failed already.\n+      begin\n+         Element := new Element_Type'(New_Item);\n+      end;\n+\n       Position.Node := new Tree_Node_Type'(Parent  => Parent.Node,\n                                            Element => Element,\n                                            others  => <>);\n@@ -1805,7 +1825,17 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n            with \"attempt to tamper with cursors (tree is busy)\";\n       end if;\n \n-      Element := new Element_Type'(New_Item);\n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035). We don't unsuppress the check on the\n+         --  allocator in the loop below, because the one in this block would\n+         --  have failed already.\n+      begin\n+         Element := new Element_Type'(New_Item);\n+      end;\n+\n       First := new Tree_Node_Type'(Parent  => Parent.Node,\n                                    Element => Element,\n                                    others  => <>);\n@@ -2163,7 +2193,14 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n            with \"attempt to tamper with elements (tree is locked)\";\n       end if;\n \n-      E := new Element_Type'(New_Item);\n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+      begin\n+         E := new Element_Type'(New_Item);\n+      end;\n \n       X := Position.Node.Element;\n       Position.Node.Element := E;"}, {"sha": "15e0835db442e5cb3c7c4d1a5f3eeb4f742b1e7f", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -812,6 +812,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n          Position.Node.Key := new Key_Type'(Key);\n \n+         declare\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n          begin\n             Position.Node.Element := new Element_Type'(New_Item);\n          exception\n@@ -852,6 +857,10 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       function New_Node return Node_Access is\n          Node : Node_Access := new Node_Type;\n \n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n       begin\n          Node.Key := new Key_Type'(Key);\n          Node.Element := new Element_Type'(New_Item);\n@@ -1492,6 +1501,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       Node.Key := new Key_Type'(Key);\n \n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n       begin\n          Node.Element := new Element_Type'(New_Item);\n       exception\n@@ -1542,6 +1556,10 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       declare\n          X : Element_Access := Position.Node.Element;\n \n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n       begin\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free_Element (X);"}, {"sha": "b7dd81a752abb5f3178b1d2f461f8d3c55dc423c", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1167,6 +1167,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       --------------\n \n       function New_Node return Node_Access is\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n \n       begin\n@@ -1768,6 +1773,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n          declare\n             X : Element_Access := Node.Element;\n+\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n          begin\n             Node.Element := new Element_Type'(Item);\n             Free_Element (X);\n@@ -1793,6 +1803,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          --------------\n \n          function New_Node return Node_Access is\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n          begin\n             Node.Element := new Element_Type'(Item);  -- OK if fails\n             Node.Color := Red_Black_Trees.Red;"}, {"sha": "3eca4c7984231c3c4c2a27cc44df6f337d0460e4", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -1173,9 +1173,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n               \"attempt to tamper with elements (set is locked)\";\n          end if;\n \n-         X := Position.Node.Element;\n-         Position.Node.Element := new Element_Type'(New_Item);\n-         Free_Element (X);\n+         declare\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n+         begin\n+            X := Position.Node.Element;\n+            Position.Node.Element := new Element_Type'(New_Item);\n+            Free_Element (X);\n+         end;\n       end if;\n    end Include;\n \n@@ -1238,6 +1245,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --------------\n \n       function New_Node return Node_Access is\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+\n          Element : Element_Access := new Element_Type'(New_Item);\n \n       begin\n@@ -1818,9 +1830,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n            \"attempt to tamper with elements (set is locked)\";\n       end if;\n \n-      X := Node.Element;\n-      Node.Element := new Element_Type'(New_Item);\n-      Free_Element (X);\n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n+      begin\n+         X := Node.Element;\n+         Node.Element := new Element_Type'(New_Item);\n+         Free_Element (X);\n+      end;\n    end Replace;\n \n    ---------------------\n@@ -1854,6 +1873,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       --------------\n \n       function New_Node return Node_Access is\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  the actual type is class-wide or has access discriminants (see\n+         --  RM 4.8(10.1) and AI12-0035).\n       begin\n          Node.Element := new Element_Type'(Item);  -- OK if fails\n          Node.Color := Red;\n@@ -1883,8 +1906,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n               \"attempt to tamper with elements (set is locked)\";\n          end if;\n \n-         Node.Element := new Element_Type'(Item);\n-         Free_Element (X);\n+         declare\n+            pragma Unsuppress (Accessibility_Check);\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n+         begin\n+            Node.Element := new Element_Type'(Item);\n+            Free_Element (X);\n+         end;\n \n          return;\n       end if;\n@@ -1901,8 +1931,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n                  \"attempt to tamper with elements (set is locked)\";\n             end if;\n \n-            Node.Element := new Element_Type'(Item);\n-            Free_Element (X);\n+            declare\n+               pragma Unsuppress (Accessibility_Check);\n+               --  The element allocator may need an accessibility check in the\n+               --  case actual type is class-wide or has access discriminants\n+               --  (see RM 4.8(10.1) and AI12-0035).\n+            begin\n+               Node.Element := new Element_Type'(Item);\n+               Free_Element (X);\n+            end;\n \n             return;\n          end if;"}, {"sha": "16334e28d170b3ba324763c13e345eea0cd4632d", "filename": "gcc/ada/a-coinho.adb", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-coinho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-coinho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinho.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---       A D A . C O N T A I N E R S . B O U N D E D _ V E C T O R S        --\n+--     A D A . C O N T A I N E R S . I N D E F I N I T E _ H O L D E R S    --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--             Copyright (C) 2012, Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -220,15 +220,28 @@ package body Ada.Containers.Indefinite_Holders is\n          raise Program_Error with \"attempt to tamper with elements\";\n       end if;\n \n-      Free (Container.Element);\n-      Container.Element := new Element_Type'(New_Item);\n+      declare\n+         X : Element_Access := Container.Element;\n+\n+         pragma Unsuppress (Accessibility_Check);\n+         --  Element allocator may need an accessibility check in case actual\n+         --  type is class-wide or has access discriminants (RM 4.8(10.1) and\n+         --  AI12-0035).\n+      begin\n+         Container.Element := new Element_Type'(New_Item);\n+         Free (X);\n+      end;\n    end Replace_Element;\n \n    ---------------\n    -- To_Holder --\n    ---------------\n \n    function To_Holder (New_Item : Element_Type) return Holder is\n+      pragma Unsuppress (Accessibility_Check);\n+      --  The element allocator may need an accessibility check in the case the\n+      --  actual type is class-wide or has access discriminants (RM 4.8(10.1)\n+      --  and AI12-0035).\n    begin\n       return (AF.Controlled with new Element_Type'(New_Item), 0);\n    end To_Holder;"}, {"sha": "750b5b0540e1d3be83cae2c399780caa3d679fef", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -1698,7 +1698,14 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  value, in case the allocation fails (either because there is no\n             --  storage available, or because element initialization fails).\n \n-            Container.Elements.EA (Idx) := new Element_Type'(New_Item);\n+            declare\n+               pragma Unsuppress (Accessibility_Check);\n+               --  The element allocator may need an accessibility check in the\n+               --  case actual type is class-wide or has access discriminants\n+               --  (see RM 4.8(10.1) and AI12-0035).\n+            begin\n+               Container.Elements.EA (Idx) := new Element_Type'(New_Item);\n+            end;\n \n             --  The allocation of the element succeeded, so it is now safe to\n             --  update the Last index, restoring container invariants.\n@@ -1744,7 +1751,14 @@ package body Ada.Containers.Indefinite_Vectors is\n                   --  because there is no storage available, or because element\n                   --  initialization fails).\n \n-                  E (Idx) := new Element_Type'(New_Item);\n+                  declare\n+                     pragma Unsuppress (Accessibility_Check);\n+                     --  The element allocator may need an accessibility check\n+                     --  in case the actual type is class-wide or has access\n+                     --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+                  begin\n+                     E (Idx) := new Element_Type'(New_Item);\n+                  end;\n \n                   --  The allocation of the element succeeded, so it is now\n                   --  safe to update the Last index, restoring container\n@@ -1780,6 +1794,11 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  K always has a value if the exception handler triggers.\n \n                K := Before;\n+               declare\n+                  pragma Unsuppress (Accessibility_Check);\n+                  --  The element allocator may need an accessibility check in\n+                  --  the case the actual type is class-wide or has access\n+                  --  discriminants (see RM 4.8(10.1) and AI12-0035).\n                begin\n                   while K < Index loop\n                      E (K) := new Element_Type'(New_Item);\n@@ -1885,7 +1904,14 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  because there is no storage available, or because element\n                --  initialization fails).\n \n-               Dst.EA (Idx) := new Element_Type'(New_Item);\n+               declare\n+                  pragma Unsuppress (Accessibility_Check);\n+                  --  The element allocator may need an accessibility check in\n+                  --  the case the actual type is class-wide or has access\n+                  --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+               begin\n+                  Dst.EA (Idx) := new Element_Type'(New_Item);\n+               end;\n \n                --  The allocation of the element succeeded, so it is now safe\n                --  to update the Last index, restoring container invariants.\n@@ -1925,7 +1951,14 @@ package body Ada.Containers.Indefinite_Vectors is\n                --  already been updated), so if this allocation fails we simply\n                --  let it propagate.\n \n-               Dst.EA (Idx) := new Element_Type'(New_Item);\n+               declare\n+                  pragma Unsuppress (Accessibility_Check);\n+                  --  The element allocator may need an accessibility check in\n+                  --  the case the actual type is class-wide or has access\n+                  --  discriminants (see RM 4.8(10.1) and AI12-0035).\n+               begin\n+                  Dst.EA (Idx) := new Element_Type'(New_Item);\n+               end;\n             end loop;\n          end if;\n       end;\n@@ -3174,6 +3207,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       declare\n          X : Element_Access := Container.Elements.EA (Index);\n+\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  where the actual type is class-wide or has access discriminants\n+         --  (see RM 4.8(10.1) and AI12-0035).\n       begin\n          Container.Elements.EA (Index) := new Element_Type'(New_Item);\n          Free (X);\n@@ -3205,6 +3243,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       declare\n          X : Element_Access := Container.Elements.EA (Position.Index);\n+\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  where the actual type is class-wide or has access discriminants\n+         --  (see RM 4.8(10.1) and AI12-0035).\n       begin\n          Container.Elements.EA (Position.Index) := new Element_Type'(New_Item);\n          Free (X);\n@@ -3949,6 +3992,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       Last := Index_Type'First;\n \n+      declare\n+         pragma Unsuppress (Accessibility_Check);\n+         --  The element allocator may need an accessibility check in the case\n+         --  where the actual type is class-wide or has access discriminants\n+         --  (see RM 4.8(10.1) and AI12-0035).\n       begin\n          loop\n             Elements.EA (Last) := new Element_Type'(New_Item);"}, {"sha": "e0b344164bfc933d8158ebd2d77042a7a7600f29", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -659,7 +659,7 @@ package body Exp_Ch4 is\n       --  Ada 2005 (AI-344): For an allocator with a class-wide designated\n       --  type, generate an accessibility check to verify that the level of the\n       --  type of the created object is not deeper than the level of the access\n-      --  type. If the type of the qualified expression is class- wide, then\n+      --  type. If the type of the qualified expression is class-wide, then\n       --  always generate the check (except in the case where it is known to be\n       --  unnecessary, see comment below). Otherwise, only generate the check\n       --  if the level of the qualified expression type is statically deeper\n@@ -690,7 +690,11 @@ package body Exp_Ch4 is\n         (Ref            : Node_Id;\n          Built_In_Place : Boolean := False)\n       is\n-         New_Node : Node_Id;\n+         Pool_Id   : constant Entity_Id := Associated_Storage_Pool (PtrT);\n+         Cond      : Node_Id;\n+         Free_Stmt : Node_Id;\n+         Obj_Ref   : Node_Id;\n+         Stmts     : List_Id;\n \n       begin\n          if Ada_Version >= Ada_2005\n@@ -701,6 +705,8 @@ package body Exp_Ch4 is\n                or else\n                  (Is_Class_Wide_Type (Etype (Exp))\n                    and then Scope (PtrT) /= Current_Scope))\n+           and then\n+             (Tagged_Type_Expansion or else VM_Target /= No_VM)\n          then\n             --  If the allocator was built in place, Ref is already a reference\n             --  to the access object initialized to the result of the allocator\n@@ -712,39 +718,109 @@ package body Exp_Ch4 is\n \n             if Built_In_Place then\n                Remove_Side_Effects (Ref);\n-               New_Node := New_Copy (Ref);\n+               Obj_Ref := New_Copy (Ref);\n             else\n-               New_Node := New_Reference_To (Ref, Loc);\n+               Obj_Ref := New_Reference_To (Ref, Loc);\n+            end if;\n+\n+            --  Step 1: Create the object clean up code\n+\n+            Stmts := New_List;\n+\n+            --  Create an explicit free statement to clean up the allocated\n+            --  object in case the accessibility check fails. Generate:\n+\n+            --    Free (Obj_Ref);\n+\n+            Free_Stmt := Make_Free_Statement (Loc, New_Copy (Obj_Ref));\n+            Set_Storage_Pool (Free_Stmt, Pool_Id);\n+\n+            Append_To (Stmts, Free_Stmt);\n+\n+            --  Finalize the object (if applicable), but wrap the call inside\n+            --  a block to ensure that the object would still be deallocated in\n+            --  case the finalization fails. Generate:\n+\n+            --    begin\n+            --       [Deep_]Finalize (Obj_Ref.all);\n+            --    exception\n+            --       when others =>\n+            --          Free (Obj_Ref);\n+            --          raise;\n+            --    end;\n+\n+            if Needs_Finalization (DesigT) then\n+               Prepend_To (Stmts,\n+                 Make_Block_Statement (Loc,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (\n+                         Make_Final_Call (\n+                           Obj_Ref =>\n+                             Make_Explicit_Dereference (Loc,\n+                               Prefix => New_Copy (Obj_Ref)),\n+                           Typ     => DesigT)),\n+\n+                     Exception_Handlers => New_List (\n+                       Make_Exception_Handler (Loc,\n+                         Exception_Choices => New_List (\n+                           Make_Others_Choice (Loc)),\n+                         Statements        => New_List (\n+                           New_Copy_Tree (Free_Stmt),\n+                           Make_Raise_Statement (Loc)))))));\n             end if;\n \n-            New_Node :=\n+            --  Signal the accessibility failure through a Program_Error\n+\n+            Append_To (Stmts,\n+              Make_Raise_Program_Error (Loc,\n+                Condition => New_Reference_To (Standard_True, Loc),\n+                Reason    => PE_Accessibility_Check_Failed));\n+\n+            --  Step 2: Create the accessibility comparison\n+\n+            --  Generate:\n+            --    Ref'Tag\n+\n+            Obj_Ref :=\n               Make_Attribute_Reference (Loc,\n-                Prefix         => New_Node,\n+                Prefix         => Obj_Ref,\n                 Attribute_Name => Name_Tag);\n \n+            --  For tagged types, determine the accessibility level by looking\n+            --  at the type specific data of the dispatch table. Generate:\n+\n+            --    Type_Specific_Data (Address (Ref'Tag)).Access_Level\n+\n             if Tagged_Type_Expansion then\n-               New_Node := Build_Get_Access_Level (Loc, New_Node);\n+               Cond := Build_Get_Access_Level (Loc, Obj_Ref);\n \n-            elsif VM_Target /= No_VM then\n-               New_Node :=\n-                 Make_Function_Call (Loc,\n-                   Name => New_Reference_To (RTE (RE_Get_Access_Level), Loc),\n-                   Parameter_Associations => New_List (New_Node));\n+            --  Use a runtime call to determine the accessibility level when\n+            --  compiling on virtual machine targets. Generate:\n \n-            --  Cannot generate the runtime check\n+            --    Get_Access_Level (Ref'Tag)\n \n             else\n-               return;\n+               Cond :=\n+                 Make_Function_Call (Loc,\n+                   Name                   =>\n+                     New_Reference_To (RTE (RE_Get_Access_Level), Loc),\n+                   Parameter_Associations => New_List (Obj_Ref));\n             end if;\n \n+            Cond :=\n+              Make_Op_Gt (Loc,\n+                Left_Opnd  => Cond,\n+                Right_Opnd =>\n+                  Make_Integer_Literal (Loc, Type_Access_Level (PtrT)));\n+\n+            --  Due to the complexity and side effects of the check, utilize an\n+            --  if statement instead of the regular Program_Error circuitry.\n+\n             Insert_Action (N,\n-              Make_Raise_Program_Error (Loc,\n-                Condition =>\n-                  Make_Op_Gt (Loc,\n-                    Left_Opnd  => New_Node,\n-                    Right_Opnd =>\n-                      Make_Integer_Literal (Loc, Type_Access_Level (PtrT))),\n-                Reason => PE_Accessibility_Check_Failed));\n+              Make_If_Statement (Loc,\n+                Condition       => Cond,\n+                Then_Statements => Stmts));\n          end if;\n       end Apply_Accessibility_Check;\n "}, {"sha": "4f6ccb52339ff938076b7eed4b0d8770780c8cbb", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -1562,7 +1562,12 @@ package body Ch6 is\n               (\"(style) IN should be omitted\");\n          end if;\n \n-         if Token = Tok_Access then\n+         --  Since Ada 2005, formal objects can have an anonymous access type,\n+         --  and of course carry a mode indicator.\n+\n+         if Token = Tok_Access\n+           and then Nkind (Node) /= N_Formal_Object_Declaration\n+         then\n             Error_Msg_SP (\"IN not allowed together with ACCESS\");\n             Scan; -- past ACCESS\n          end if;"}, {"sha": "2fff4eb1fab037841db656211943b72a8986e332", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -342,8 +342,8 @@ locating the specified source files in the specified source directories.\n   is explicitly specified.\n   @xref{Naming Schemes}.\n \n-@item @code{Source Files}\n-  @cindex @code{Source_Files}\n+@item @code{Source_Files}\n+@cindex @code{Source_Files}\n   In some cases, source directories might contain files that should not be\n   included in a project. One can specify the explicit list of file names to\n   be considered through the @b{Source_Files} attribute."}, {"sha": "843f67bc0d1899fb5a0f7ad7d6b700d3a95c2d8e", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -253,7 +253,7 @@ package body Sem_Ch4 is\n    function Try_Container_Indexing\n      (N      : Node_Id;\n       Prefix : Node_Id;\n-      Expr   : Node_Id) return Boolean;\n+      Exprs  : List_Id) return Boolean;\n    --  AI05-0139: Generalized indexing to support iterators over containers\n \n    function Try_Indexed_Call\n@@ -2114,7 +2114,7 @@ package body Sem_Ch4 is\n             then\n                return;\n \n-            elsif Try_Container_Indexing (N, P, Exp) then\n+            elsif Try_Container_Indexing (N, P, Exprs) then\n                return;\n \n             elsif Array_Type = Any_Type then\n@@ -2276,7 +2276,7 @@ package body Sem_Ch4 is\n                   end;\n                end if;\n \n-            elsif Try_Container_Indexing (N, P, First (Exprs)) then\n+            elsif Try_Container_Indexing (N, P, Exprs) then\n                return;\n \n             end if;\n@@ -6475,9 +6475,10 @@ package body Sem_Ch4 is\n    function Try_Container_Indexing\n      (N      : Node_Id;\n       Prefix : Node_Id;\n-      Expr   : Node_Id) return Boolean\n+      Exprs  : List_Id) return Boolean\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n+      Assoc     : List_Id;\n       Disc      : Entity_Id;\n       Func      : Entity_Id;\n       Func_Name : Node_Id;\n@@ -6508,19 +6509,34 @@ package body Sem_Ch4 is\n          if Has_Implicit_Dereference (Etype (Prefix)) then\n             Build_Explicit_Dereference\n               (Prefix, First_Discriminant (Etype (Prefix)));\n-            return Try_Container_Indexing (N, Prefix, Expr);\n+            return Try_Container_Indexing (N, Prefix, Exprs);\n \n          else\n             return False;\n          end if;\n       end if;\n \n+      Assoc := New_List (Relocate_Node (Prefix));\n+\n+      --  A generalized iterator may have nore than one index expression, so\n+      --  transfer all of them to the argument list to be used in the call.\n+\n+      declare\n+         Arg : Node_Id;\n+\n+      begin\n+         Arg := First (Exprs);\n+         while Present (Arg) loop\n+            Append (Relocate_Node (Arg), Assoc);\n+            Next (Arg);\n+         end loop;\n+      end;\n+\n       if not Is_Overloaded (Func_Name) then\n          Func := Entity (Func_Name);\n          Indexing := Make_Function_Call (Loc,\n            Name => New_Occurrence_Of (Func, Loc),\n-           Parameter_Associations =>\n-             New_List (Relocate_Node (Prefix), Relocate_Node (Expr)));\n+           Parameter_Associations => Assoc);\n          Rewrite (N, Indexing);\n          Analyze (N);\n \n@@ -6544,8 +6560,7 @@ package body Sem_Ch4 is\n       else\n          Indexing := Make_Function_Call (Loc,\n            Name => Make_Identifier (Loc, Chars (Func_Name)),\n-           Parameter_Associations =>\n-             New_List (Relocate_Node (Prefix), Relocate_Node (Expr)));\n+           Parameter_Associations => Assoc);\n \n          Rewrite (N, Indexing);\n \n@@ -6586,7 +6601,8 @@ package body Sem_Ch4 is\n       end if;\n \n       if Etype (N) = Any_Type then\n-         Error_Msg_NE (\"container cannot be indexed with&\", N, Etype (Expr));\n+         Error_Msg_NE (\"container cannot be indexed with&\",\n+           N, Etype (First (Exprs)));\n          Rewrite (N, New_Occurrence_Of (Any_Id, Loc));\n       else\n          Analyze (N);"}, {"sha": "5f25a862c16e9e0a878beb57ff0f521593a7a022", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50878404473455327bb16a227beab6a742bcec41/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=50878404473455327bb16a227beab6a742bcec41", "patch": "@@ -7057,26 +7057,45 @@ package body Sem_Res is\n       Loc   : constant Source_Ptr := Sloc (N);\n       New_N : Node_Id;\n       P     : constant Node_Id := Prefix (N);\n+\n+      P_Typ : Entity_Id;\n+      --  The candidate prefix type, if overloaded\n+\n       I     : Interp_Index;\n       It    : Interp;\n \n    begin\n       Check_Fully_Declared_Prefix (Typ, P);\n+      P_Typ := Empty;\n \n       if Is_Overloaded (P) then\n \n          --  Use the context type to select the prefix that has the correct\n          --  designated type.\n \n          Get_First_Interp (P, I, It);\n+\n          while Present (It.Typ) loop\n-            exit when Is_Access_Type (It.Typ)\n-              and then Covers (Typ, Designated_Type (It.Typ));\n+            if Is_Access_Type (It.Typ)\n+              and then Covers (Typ, Designated_Type (It.Typ))\n+            then\n+               P_Typ := It.Typ;\n+\n+            --  Remove access types that do not match, but preserve access\n+            --  to subprogram interpretations, in case a further dereference\n+            --  is needed (see below).\n+\n+            elsif Ekind (It.Typ) /= E_Access_Subprogram_Type then\n+               Remove_Interp (I);\n+            end if;\n+\n             Get_Next_Interp (I, It);\n          end loop;\n \n-         if Present (It.Typ) then\n-            Resolve (P, It.Typ);\n+         if Present (P_Typ) then\n+            Resolve (P, P_Typ);\n+            Set_Etype (N, Designated_Type (P_Typ));\n+\n          else\n             --  If no interpretation covers the designated type of the prefix,\n             --  this is the pathological case where not all implementations of\n@@ -7107,9 +7126,9 @@ package body Sem_Res is\n             return;\n          end if;\n \n-         Set_Etype (N, Designated_Type (It.Typ));\n-\n       else\n+         --  If not overloaded, resolve P with its own type\n+\n          Resolve (P);\n       end if;\n "}]}