{"sha": "7a81008bb0ae776406d9e7131da869250ffc5d11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4MTAwOGJiMGFlNzc2NDA2ZDllNzEzMWRhODY5MjUwZmZjNWQxMQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-03-29T16:36:54Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-03-29T16:36:54Z"}, "message": "alpha.c (alpha_sr_alias_set): Don't define.\n\n\t* config/alpha/alpha.c (alpha_sr_alias_set): Don't define.\n\t(alpha_option_override): Don't set alpha_sr_alias_set.\n\t(emit_frame_store_1): Use gen_frame_mem rather than calling\n\tset_mem_alias_set.\n\t(alpha_expand_epilogue): Ditto.\n\nFrom-SVN: r171682", "tree": {"sha": "9207fee498c555d128e4905d62ddc974aefb70ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9207fee498c555d128e4905d62ddc974aefb70ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a81008bb0ae776406d9e7131da869250ffc5d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a81008bb0ae776406d9e7131da869250ffc5d11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a81008bb0ae776406d9e7131da869250ffc5d11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a81008bb0ae776406d9e7131da869250ffc5d11/comments", "author": null, "committer": null, "parents": [{"sha": "76d61ab83c67242de55d6af6cea2f2ebf8fd06ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76d61ab83c67242de55d6af6cea2f2ebf8fd06ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76d61ab83c67242de55d6af6cea2f2ebf8fd06ce"}], "stats": {"total": 112, "additions": 42, "deletions": 70}, "files": [{"sha": "41d1e6f6e147c5d9816297234d2f780843d4ea89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a81008bb0ae776406d9e7131da869250ffc5d11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a81008bb0ae776406d9e7131da869250ffc5d11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a81008bb0ae776406d9e7131da869250ffc5d11", "patch": "@@ -1,3 +1,11 @@\n+2011-03-29  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/alpha/alpha.c (alpha_sr_alias_set): Don't define.\n+\t(alpha_option_override): Don't set alpha_sr_alias_set.\n+\t(emit_frame_store_1): Use gen_frame_mem rather than calling\n+\tset_mem_alias_set.\n+\t(alpha_expand_epilogue): Ditto.\n+\n 2011-03-29  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/48290\n@@ -30,7 +38,7 @@\n \n \t* ira-color.c (update_left_conflict_sizes_p): Don't assume that\n \tconflict object hard regset nodes have intersecting hard reg sets.\n-\t\n+\n \t* regmove.c (regmove_optimize): Move ira_set_pseudo_classes call\n \tafter regstat_init_n_sets_and_refs.\n \n@@ -86,8 +94,7 @@\n \tinstead of OBJECT_PROFITABLE_HARD_REGS, OBJECT_HARD_REGS_NODE,\n \tOBJECT_HARD_REGS_SUBNODES_START, OBJECT_HARD_REGS_SUBNODES_NUM.\n \tFix formatting.\n-\t(object_hard_regs_t, object_hard_regs_node_t): Move from\n-\tira-int.h.\n+\t(object_hard_regs_t, object_hard_regs_node_t): Move from ira-int.h.\n \t(struct object_hard_regs, struct object_hard_regs_node): Ditto.\n \t(struct allocno_color_data): New.\n \t(allocno_color_data_t): New typedef.\n@@ -102,8 +109,7 @@\n \tira_register_move_cost instead of ira_get_register_move_cost.\n \t(move_spill_restore, update_curr_costs): Ditto.\n \t(allocno_spill_priority): Make it inline.\n-\t(color_pass): Allocate and free allocno_color_dat and\n-\tobject_color_data.\n+\t(color_pass): Allocate and free allocno_color_dat and object_color_data.\n \t(struct coalesce_data, coalesce_data_t): New.\n \t(allocno_coalesce_data): New definition.\n \t(ALLOCNO_COALESCE_DATA): New macro.\n@@ -144,16 +150,13 @@\n \tdefinitions.\n \t(ira_initiate_emit_data, ira_finish_emit_data)\n \t(create_new_allocno): New functions.\n-\t(modify_move_list): Call create_new_alloc instead of\n-\tira_create_allocno.\n+\t(modify_move_list): Call create_new_alloc instead of ira_create_allocno.\n \t(emit_move_list): Call ira_init_register_move_cost_if_necessary.\n \tUse ira_register_move_cost instead of ira_get_register_move_cost.\n \n \t* ira-int.h: Fix some comments.\n-\t(object_hard_regs_t, object_hard_regs_node_t): Move\n-\tto ira-color.c.\n-\t(struct object_hard_regs, struct object_hard_regs_node):\n-\tDitto.\n+\t(object_hard_regs_t, object_hard_regs_node_t): Move to ira-color.c.\n+\t(struct object_hard_regs, struct object_hard_regs_node): Ditto.\n \t(struct ira_object): Remove profitable_hard_regs, hard_regs_node,\n \thard_regs_subnodes_start, hard_regs_subnodes_num.  Add new member\n \tadd_data.\n@@ -178,17 +181,15 @@\n \t(ALLOCNO_EMIT_DATA): New macro.\n \t(ira_allocno_emit_data, allocno_emit_reg): New.\n \t(ALLOCNO_PROFITABLE_HARD_REGS, OBJECT_HARD_REGS_NODE): Remove.\n-\t(OBJECT_HARD_REGS_SUBNODES_STAR, OBJECT_HARD_REGS_SUBNODES_NUM):\n-\tRemove.\n+\t(OBJECT_HARD_REGS_SUBNODES_STAR, OBJECT_HARD_REGS_SUBNODES_NUM): Remove.\n \t(OBJECT_ADD_DATA): New macro.\n \t(ira_reallocate): Remove.\n \t(ira_initiate_emit_data, ira_finish_emit_data): New.\n \t(ira_get_register_move_cost, ira_get_may_move_cost): Remove.\n \t(ira_init_register_move_cost_if_necessary): New.\n \t(ira_object_conflict_iter_next): Merge into\n \tira_object_conflict_iter_cond.\n-\t(FOR_EACH_OBJECT_CONFLICT): Don't use\n-\tira_object_conflict_iter_next.\n+\t(FOR_EACH_OBJECT_CONFLICT): Don't use ira_object_conflict_iter_next.\n \n \t* ira-live.c: (process_single_reg_class_operands): Call\n \tira_init_register_move_cost_if_necessary.  Use\n@@ -206,8 +207,7 @@\n \t(cost_classes_aclass_cache, cost_classes_mode_cache): New.\n \t(initiate_regno_cost_classes, setup_cost_classes): New.\n \t(setup_regno_cost_classes_by_aclass): New.\n-\t(setup_regno_cost_classes_by_mode, finish_regno_cost_classes):\n-\tNew.\n+\t(setup_regno_cost_classes_by_mode, finish_regno_cost_classes): New.\n \t(record_reg_classes): Use regno_cost_classes instead of\n \tcost_classes.  Move checking opposite operand up.\n \t(record_address_regs): Use regno_cost_classes\n@@ -231,15 +231,13 @@\n \n \t* target.def (ira_cover_classes): Remove.\n \n-\t* doc/tm.texi: Remove TARGET_IRA_COVER_CLASSES and\n-\tIRA_COVER_CLASSES.\n+\t* doc/tm.texi: Remove TARGET_IRA_COVER_CLASSES and IRA_COVER_CLASSES.\n \n \t* doc/tm.texi.in: Ditto.\n \n \t* ira-conflicts.c: Remove mentioning cover classes from the file.\n \tUse ALLOCNO_CLASS instead of ALLOCNO_COVER_CLASS.  Use\n-\tALLOCNO_COVER_CLASS_COST instead of ALLOCNO_CLASS_COST.  Fix\n-\tformatting.\n+\tALLOCNO_COVER_CLASS_COST instead of ALLOCNO_CLASS_COST.  Fix formatting.\n \n \t* targhooks.c (default_ira_cover_classes): Remove.\n \n@@ -283,8 +281,7 @@\n \t(ira_max_may_move_in_cost, ira_max_may_move_out_cost)\n \t(ira_reg_allocno_class_p, ira_reg_pressure_class_p)\n \t(ira_important_class_nums, ira_reg_class_superunion): New macros.\n-\t(prohibited_class_mode_regs): Rename to\n-\tira_prohibited_class_mode_regs.\n+\t(prohibited_class_mode_regs): Rename to ira_prohibited_class_mode_regs.\n \t(ira_reg_class_union): Rename to ira_reg_class_subunion.\n \t(ira_debug_class_cover): Rename to ira_debug_allocno_classes.\n \t(ira_set_allocno_cover_class): Rename to ira_set_allocno_class.\n@@ -293,8 +290,7 @@\n \t(ira_debug_hard_regs_forest): New.\n \t(ira_object_conflict_iter_init, ira_object_conflict_iter_cond)\n \t(ira_object_conflict_iter_next): Fix comments.\n-\t(ira_hard_reg_set_intersection_p, hard_reg_set_size): New\n-\tfunctions.\n+\t(ira_hard_reg_set_intersection_p, hard_reg_set_size): New functions.\n \t(ira_allocate_and_set_costs, ira_allocate_and_copy_costs): Rename\n \tcover_class to aclass.\n \t(ira_allocate_and_accumulate_costs): Ditto.\n@@ -318,8 +314,7 @@\n \t(finish_object_hard_regs, object_hard_regs_compare): Ditto.\n \t(create_new_object_hard_regs_node): Ditto.\n \t(add_new_object_hard_regs_node_to_forest): Ditto.\n-\t(add_object_hard_regs_to_forest, collect_object_hard_regs_cover):\n-\tDitto.\n+\t(add_object_hard_regs_to_forest, collect_object_hard_regs_cover): Ditto.\n \t(setup_object_hard_regs_nodes_parent, first_common_ancestor_node):\n \tDitto.\n \t(print_hard_reg_set, print_hard_regs_subforest): Ditto.\n@@ -336,8 +331,7 @@\n \t(finish_object_hard_regs_nodes_tree): Ditto.\n \t(finish_object_hard_regs_nodes_forest): Ditto.\n \t(allocnos_have_intersected_live_ranges_p): Rename to\n-\tallocnos_conflict_by_live_ranges_p.  Move before\n-\tcopy_freq_compare_func.\n+\tallocnos_conflict_by_live_ranges_p.  Move before copy_freq_compare_func.\n \t(pseudos_have_intersected_live_ranges_p): Rename to\n \tconflict_by_live_ranges_p.  Move before copy_freq_compare_func.\n \t(setup_left_conflict_sizes_p, update_left_conflict_sizes_p): Ditto.\n@@ -355,8 +349,7 @@\n \t(uncolorable_allocnos_splay_tree, USE_SPLAY_P): Remove.\n \t(push_allocno_to_stack): Rewrite for checking new allocno\n \tcolorability.\n-\t(remove_allocno_from_bucket_and_push): Print cost too.  Remove\n-\tassert.\n+\t(remove_allocno_from_bucket_and_push): Print cost too.  Remove assert.\n \t(push_only_colorable): Pass new parameter to sort_bucket.\n \t(push_allocno_to_spill): Remove.\n \t(allocno_spill_priority_compare): Make it inline and rewrite.\n@@ -370,8 +363,7 @@\n \tregs.  Print info about hard regs nodes.\n \t(setup_allocno_left_conflicts_size): Remove.\n \t(put_allocno_into_bucket): Don't call\n-\tsetup_allocno_left_conflicts_size.  Use\n-\tsetup_left_conflict_sizes_p.\n+\tsetup_allocno_left_conflicts_size.  Use setup_left_conflict_sizes_p.\n \t(improve_allocation): New.\n \t(color_allocnos): Call setup_profitable_hard_regs,\n \tform_object_hard_regs_nodes_forest, improve_allocation,\n@@ -429,10 +421,9 @@\n \t* loop-invariant.c: Remove mentioning cover classes from the file.\n \tUse ira_pressure_classes and ira_pressure_classes_num instead of\n \tira_reg_class_cover_size and ira_reg_class_cover.  Fix formatting.\n-\t(get_cover_class_and_nregs): Rename to\n-\tget_cover_pressure_and_nregs.  Use ira_reg_class_max_nregs instead\n-\tof ira_reg_class_nregs.  Use reg_allocno_class instead of\n-\treg_cover_class.\n+\t(get_cover_class_and_nregs): Rename to get_cover_pressure_and_nregs.\n+\tUse ira_reg_class_max_nregs instead of ira_reg_class_nregs.\n+\tUse reg_allocno_class instead of reg_cover_class.\n \t(get_inv_cost): Use instead ira_stack_reg_pressure_class of\n \tSTACK_REG_COVER_CLASS.\n \t(get_regno_cover_class): Rename to get_regno_pressure_class.\n@@ -458,12 +449,10 @@\n \tPrint pressure classes too.\n \t(find_reg_class_closure): Rename to find_reg_classes.  Don't call\n \tsetup_reg_subclasses.\n-\t(ira_hard_regno_cover_class): Rename to\n-\tira_hard_regno_allocno_class.\n+\t(ira_hard_regno_cover_class): Rename to ira_hard_regno_allocno_class.\n \t(ira_reg_class_nregs): Rename to ira_reg_class_max_nregs.\n \t(setup_prohibited_class_mode_regs): Use\n-\tira_prohibited_class_mode_regs instead of\n-\tprohibited_class_mode_regs.\n+\tira_prohibited_class_mode_regs instead of prohibited_class_mode_regs.\n \t(clarify_prohibited_class_mode_regs): New function.\n \t(ira_init_register_move_cost): Set up ira_max_register_move_cost,\n \tira_max_may_move_in_cost, and ira_max_may_move_out_cost.\n@@ -495,8 +484,7 @@\n \tx_ira_stack_reg_pressure_class.  Rename x_ira_reg_class_nregs to\n \tx_ira_reg_class_max_nregs.  Add x_ira_reg_class_min_nregs and\n \tx_ira_no_alloc_regs.\n-\t(ira_hard_regno_cover_class): Rename to\n-\tira_hard_regno_allocno_class.\n+\t(ira_hard_regno_cover_class): Rename to ira_hard_regno_allocno_class.\n \t(ira_reg_class_cover_size, ira_reg_class_cover): Rename to\n \tira_allocno_classes_num and ira_allocno_classes.\n \t(ira_class_translate): Rename to ira_allocno_class_translate.\n@@ -515,8 +503,7 @@\n \tira_reg_class_union.\n \t(record_address_regs): Check overflow.\n \t(scan_one_insn): Ditto.\n-\t(print_allocno_costs): Print total mem cost fore regional\n-\tallocation.\n+\t(print_allocno_costs): Print total mem cost fore regional allocation.\n \t(print_pseudo_costs): Use REG_N_REFS.\n \t(find_costs_and_classes): Use classes intersected with them on the\n \t1st pass. Check overflow.  Use ira_reg_class_subunion instead of\n@@ -547,8 +534,7 @@\n \t(struct reg_pref): Rename coverclass into allocnoclass.\n \t(reg_cover_class): Rename to reg_allocno_class.\n \n-\t* Makefile.in (ira-color.o): Remove SPLAY_TREE_H from\n-\tdependencies.\n+\t* Makefile.in (ira-color.o): Remove SPLAY_TREE_H from dependencies.\n \n \t* config/alpha/alpha.h (IRA_COVER_CLASSES): Remove.\n \n@@ -655,8 +641,7 @@\n \t!second_in_std_section.\n \t(dw_loc_list): Break ranges crossing section switch.\n \t(convert_cfa_to_fb_loc_list): Likewise.  If switched sections,\n-\tuse dw_fde_second_end instead of dw_fde_end as end of last\n-\trange.\n+\tuse dw_fde_second_end instead of dw_fde_end as end of last range.\n \t(gen_subprogram_die): Don't call add_arange.  Use\n \tdw_fde_{begin,end} for first partition and if switched\n \tsection dw_fde_second_{begin,end} for the second.\n@@ -713,7 +698,7 @@\n \t(one_pre_gcse_pass, one_code_hoisting_pass): Likewise.\n \t(hash_set, insert_set_in_table, gcse_constant_p, lookup_set,\n \tnext_set, reset_opr_set_tables, oprs_not_set_p, mark_call, mark_set,\n-\tmark_clobber, mark_oprs_set, alloc_cprop_mem, free_cprop_mem, \n+\tmark_clobber, mark_oprs_set, alloc_cprop_mem, free_cprop_mem,\n \tcompute_cprop_data, find_used_regs, try_replace_reg,\n \tfind_avail_set, cprop_jump, constprop_register, cprop_insn,\n \tlocal_cprop_find_used_regs, do_local_cprop, local_cprop_pass,\n@@ -6588,8 +6573,7 @@\n 2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/47318\n-\t* config/i386/avxintrin.h (_mm_maskload_pd): Change mask to\n-\t__m128i.\n+\t* config/i386/avxintrin.h (_mm_maskload_pd): Change mask to __m128i.\n \t(_mm_maskstore_pd): Likewise.\n \t(_mm_maskload_ps): Likewise.\n \t(_mm_maskstore_ps): Likewise."}, {"sha": "d6caa27bb1e6999b63d2a3ac31b771ebe9889dcc", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a81008bb0ae776406d9e7131da869250ffc5d11/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a81008bb0ae776406d9e7131da869250ffc5d11/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=7a81008bb0ae776406d9e7131da869250ffc5d11", "patch": "@@ -95,10 +95,6 @@ int alpha_memory_latency = 3;\n \n static int alpha_function_needs_gp;\n \n-/* The alias set for prologue/epilogue register save/restore.  */\n-\n-static GTY(()) alias_set_type alpha_sr_alias_set;\n-\n /* The assembler name of the current function.  */\n \n static const char *alpha_fnname;\n@@ -476,9 +472,6 @@ alpha_option_override (void)\n   if (align_functions <= 0)\n     align_functions = 16;\n \n-  /* Acquire a unique set number for our register saves and restores.  */\n-  alpha_sr_alias_set = new_alias_set ();\n-\n   /* Register variables and functions with the garbage collector.  */\n \n   /* Set up function hooks.  */\n@@ -7448,8 +7441,7 @@ emit_frame_store_1 (rtx value, rtx base_reg, HOST_WIDE_INT frame_bias,\n   rtx addr, mem, insn;\n \n   addr = plus_constant (base_reg, base_ofs);\n-  mem = gen_rtx_MEM (DImode, addr);\n-  set_mem_alias_set (mem, alpha_sr_alias_set);\n+  mem = gen_frame_mem (DImode, addr);\n \n   insn = emit_move_insn (mem, value);\n   RTX_FRAME_RELATED_P (insn) = 1;\n@@ -8056,9 +8048,7 @@ alpha_expand_epilogue (void)\n \n       /* Restore registers in order, excepting a true frame pointer.  */\n \n-      mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-      if (! eh_ofs)\n-        set_mem_alias_set (mem, alpha_sr_alias_set);\n+      mem = gen_frame_mem (DImode, plus_constant (sa_reg, reg_offset));\n       reg = gen_rtx_REG (DImode, REG_RA);\n       emit_move_insn (reg, mem);\n       cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n@@ -8073,8 +8063,8 @@ alpha_expand_epilogue (void)\n \t      fp_offset = reg_offset;\n \t    else\n \t      {\n-\t\tmem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n-\t\tset_mem_alias_set (mem, alpha_sr_alias_set);\n+\t\tmem = gen_frame_mem (DImode,\n+\t\t\t\t     plus_constant (sa_reg, reg_offset));\n \t\treg = gen_rtx_REG (DImode, i);\n \t\temit_move_insn (reg, mem);\n \t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n@@ -8086,8 +8076,7 @@ alpha_expand_epilogue (void)\n       for (i = 0; i < 31; ++i)\n \tif (fmask & (1UL << i))\n \t  {\n-\t    mem = gen_rtx_MEM (DFmode, plus_constant(sa_reg, reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    mem = gen_frame_mem (DFmode, plus_constant (sa_reg, reg_offset));\n \t    reg = gen_rtx_REG (DFmode, i+32);\n \t    emit_move_insn (reg, mem);\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n@@ -8145,8 +8134,7 @@ alpha_expand_epilogue (void)\n       if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n-\t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, fp_offset));\n-\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t  mem = gen_frame_mem (DImode, plus_constant (sa_reg, fp_offset));\n \t  emit_move_insn (hard_frame_pointer_rtx, mem);\n \t  cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n \t\t\t\t\t hard_frame_pointer_rtx, cfa_restores);"}]}