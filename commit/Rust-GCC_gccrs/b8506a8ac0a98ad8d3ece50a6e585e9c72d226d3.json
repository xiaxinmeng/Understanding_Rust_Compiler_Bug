{"sha": "b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg1MDZhOGFjMGE5OGFkOGQzZWNlNTBhNmU1ODVlOWM3MmQyMjZkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-05T15:29:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-05T15:29:27Z"}, "message": "Remove enum before machine_mode\n\nr216834 did a mass removal of \"enum\" before \"machine_mode\".  This patch\nremoves some new uses that have been added since then.\n\n2017-07-05  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (simplify_if_then_else): Remove \"enum\" before\n\t\"machine_mode\".\n\t* compare-elim.c (can_eliminate_compare): Likewise.\n\t* config/aarch64/aarch64-builtins.c (aarch64_simd_builtin_std_type):\n\tLikewise.\n\t(aarch64_lookup_simd_builtin_type): Likewise.\n\t(aarch64_simd_builtin_type): Likewise.\n\t(aarch64_init_simd_builtin_types): Likewise.\n\t(aarch64_simd_expand_args): Likewise.\n\t* config/aarch64/aarch64-protos.h (aarch64_simd_attr_length_rglist):\n\tLikewise.\n\t(aarch64_reverse_mask): Likewise.\n\t(aarch64_simd_emit_reg_reg_move): Likewise.\n\t(aarch64_gen_adjusted_ldpstp): Likewise.\n\t(aarch64_ccmp_mode_to_code): Likewise.\n\t(aarch64_operands_ok_for_ldpstp): Likewise.\n\t(aarch64_operands_adjust_ok_for_ldpstp): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_ira_change_pseudo_allocno_class):\n\tLikewise.\n\t(aarch64_min_divisions_for_recip_mul): Likewise.\n\t(aarch64_reassociation_width): Likewise.\n\t(aarch64_get_condition_code_1): Likewise.\n\t(aarch64_simd_emit_reg_reg_move): Likewise.\n\t(aarch64_simd_attr_length_rglist): Likewise.\n\t(aarch64_reverse_mask): Likewise.\n\t(aarch64_operands_ok_for_ldpstp): Likewise.\n\t(aarch64_operands_adjust_ok_for_ldpstp): Likewise.\n\t(aarch64_gen_adjusted_ldpstp): Likewise.\n\t* config/aarch64/cortex-a57-fma-steering.c (fma_node::rename):\n\tLikewise.\n\t* config/arc/arc.c (legitimate_offset_address_p): Likewise.\n\t* config/arm/arm-builtins.c (arm_simd_builtin_std_type): Likewise.\n\t(arm_lookup_simd_builtin_type): Likewise.\n\t(arm_simd_builtin_type): Likewise.\n\t(arm_init_simd_builtin_types): Likewise.\n\t(arm_expand_builtin_args): Likewise.\n\t* config/arm/arm-protos.h (arm_expand_builtin): Likewise.\n\t* config/ft32/ft32.c (ft32_libcall_value): Likewise.\n\t(ft32_setup_incoming_varargs): Likewise.\n\t(ft32_function_arg): Likewise.\n\t(ft32_function_arg_advance): Likewise.\n\t(ft32_pass_by_reference): Likewise.\n\t(ft32_arg_partial_bytes): Likewise.\n\t(ft32_valid_pointer_mode): Likewise.\n\t(ft32_addr_space_pointer_mode): Likewise.\n\t(ft32_addr_space_legitimate_address_p): Likewise.\n\t* config/i386/i386-protos.h (ix86_operands_ok_for_move_multiple):\n\tLikewise.\n\t* config/i386/i386.c (ix86_setup_incoming_vararg_bounds): Likewise.\n\t(ix86_emit_outlined_ms2sysv_restore): Likewise.\n\t(iamcu_alignment): Likewise.\n\t(canonicalize_vector_int_perm): Likewise.\n\t(ix86_noce_conversion_profitable_p): Likewise.\n\t(ix86_mpx_bound_mode): Likewise.\n\t(ix86_operands_ok_for_move_multiple): Likewise.\n\t* config/microblaze/microblaze-protos.h\n\t(microblaze_expand_conditional_branch_reg): Likewise.\n\t* config/microblaze/microblaze.c\n\t(microblaze_expand_conditional_branch_reg): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_init_hard_regno_mode_ok):\n\tLikewise.\n\t(rs6000_reassociation_width): Likewise.\n\t(rs6000_invalid_binary_op): Likewise.\n\t(fusion_p9_p): Likewise.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\t* config/riscv/riscv-protos.h (riscv_regno_mode_ok_for_base_p):\n\tLikewise.\n\t(riscv_hard_regno_mode_ok_p): Likewise.\n\t(riscv_address_insns): Likewise.\n\t(riscv_split_symbol): Likewise.\n\t(riscv_legitimize_move): Likewise.\n\t(riscv_function_value): Likewise.\n\t(riscv_hard_regno_nregs): Likewise.\n\t(riscv_expand_builtin): Likewise.\n\t* config/riscv/riscv.c (riscv_build_integer_1): Likewise.\n\t(riscv_build_integer): Likewise.\n\t(riscv_split_integer): Likewise.\n\t(riscv_legitimate_constant_p): Likewise.\n\t(riscv_cannot_force_const_mem): Likewise.\n\t(riscv_regno_mode_ok_for_base_p): Likewise.\n\t(riscv_valid_base_register_p): Likewise.\n\t(riscv_valid_offset_p): Likewise.\n\t(riscv_valid_lo_sum_p): Likewise.\n\t(riscv_classify_address): Likewise.\n\t(riscv_legitimate_address_p): Likewise.\n\t(riscv_address_insns): Likewise.\n\t(riscv_load_store_insns): Likewise.\n\t(riscv_force_binary): Likewise.\n\t(riscv_split_symbol): Likewise.\n\t(riscv_force_address): Likewise.\n\t(riscv_legitimize_address): Likewise.\n\t(riscv_move_integer): Likewise.\n\t(riscv_legitimize_const_move): Likewise.\n\t(riscv_legitimize_move): Likewise.\n\t(riscv_address_cost): Likewise.\n\t(riscv_subword): Likewise.\n\t(riscv_output_move): Likewise.\n\t(riscv_canonicalize_int_order_test): Likewise.\n\t(riscv_emit_int_order_test): Likewise.\n\t(riscv_function_arg_boundary): Likewise.\n\t(riscv_pass_mode_in_fpr_p): Likewise.\n\t(riscv_pass_fpr_single): Likewise.\n\t(riscv_pass_fpr_pair): Likewise.\n\t(riscv_get_arg_info): Likewise.\n\t(riscv_function_arg): Likewise.\n\t(riscv_function_arg_advance): Likewise.\n\t(riscv_arg_partial_bytes): Likewise.\n\t(riscv_function_value): Likewise.\n\t(riscv_pass_by_reference): Likewise.\n\t(riscv_setup_incoming_varargs): Likewise.\n\t(riscv_print_operand): Likewise.\n\t(riscv_elf_select_rtx_section): Likewise.\n\t(riscv_save_restore_reg): Likewise.\n\t(riscv_for_each_saved_reg): Likewise.\n\t(riscv_register_move_cost): Likewise.\n\t(riscv_hard_regno_mode_ok_p): Likewise.\n\t(riscv_hard_regno_nregs): Likewise.\n\t(riscv_class_max_nregs): Likewise.\n\t(riscv_memory_move_cost): Likewise.\n\t* config/rl78/rl78-protos.h (rl78_split_movsi): Likewise.\n\t* config/rl78/rl78.c (rl78_split_movsi): Likewise.\n\t(rl78_addr_space_address_mode): Likewise.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tLikewise.\n\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Likewise.\n\t(rs6000_reassociation_width): Likewise.\n\t(rs6000_invalid_binary_op): Likewise.\n\t(fusion_p9_p): Likewise.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\t* config/visium/visium-protos.h (prepare_move_operands): Likewise.\n\t(ok_for_simple_move_operands): Likewise.\n\t(ok_for_simple_move_strict_operands): Likewise.\n\t(ok_for_simple_arith_logic_operands): Likewise.\n\t(visium_legitimize_reload_address): Likewise.\n\t(visium_select_cc_mode): Likewise.\n\t(output_cbranch): Likewise.\n\t(visium_split_double_move): Likewise.\n\t(visium_expand_copysign): Likewise.\n\t(visium_expand_int_cstore): Likewise.\n\t(visium_expand_fp_cstore): Likewise.\n\t* config/visium/visium.c (visium_pass_by_reference): Likewise.\n\t(visium_function_arg): Likewise.\n\t(visium_function_arg_advance): Likewise.\n\t(visium_libcall_value): Likewise.\n\t(visium_setup_incoming_varargs): Likewise.\n\t(visium_legitimate_constant_p): Likewise.\n\t(visium_legitimate_address_p): Likewise.\n\t(visium_legitimize_address): Likewise.\n\t(visium_secondary_reload): Likewise.\n\t(visium_register_move_cost): Likewise.\n\t(visium_memory_move_cost): Likewise.\n\t(prepare_move_operands): Likewise.\n\t(ok_for_simple_move_operands): Likewise.\n\t(ok_for_simple_move_strict_operands): Likewise.\n\t(ok_for_simple_arith_logic_operands): Likewise.\n\t(visium_function_value_1): Likewise.\n\t(rtx_ok_for_offset_p): Likewise.\n\t(visium_legitimize_reload_address): Likewise.\n\t(visium_split_double_move): Likewise.\n\t(visium_expand_copysign): Likewise.\n\t(visium_expand_int_cstore): Likewise.\n\t(visium_expand_fp_cstore): Likewise.\n\t(visium_split_cstore): Likewise.\n\t(visium_select_cc_mode): Likewise.\n\t(visium_split_cbranch): Likewise.\n\t(output_cbranch): Likewise.\n\t(visium_print_operand_address): Likewise.\n\t* expmed.c (flip_storage_order): Likewise.\n\t* expmed.h (emit_cstore): Likewise.\n\t(flip_storage_order): Likewise.\n\t* genrecog.c (validate_pattern): Likewise.\n\t* hsa-gen.c (gen_hsa_addr): Likewise.\n\t* internal-fn.c (expand_arith_overflow): Likewise.\n\t* ira-color.c (allocno_copy_cost_saving): Likewise.\n\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n\t* lra-constraints.c (prohibited_class_reg_set_mode_p): Likewise.\n\t(process_invariant_for_inheritance): Likewise.\n\t* lra-eliminations.c (move_plus_up): Likewise.\n\t* omp-low.c (lower_oacc_reductions): Likewise.\n\t* simplify-rtx.c (simplify_subreg): Likewise.\n\t* target.def (TARGET_SETUP_INCOMING_VARARG_BOUNDS): Likewise.\n\t(TARGET_CHKP_BOUND_MODE): Likewise..\n\t* targhooks.c (default_chkp_bound_mode): Likewise.\n\t(default_setup_incoming_vararg_bounds): Likewise.\n\t* targhooks.h (default_chkp_bound_mode): Likewise.\n\t(default_setup_incoming_vararg_bounds): Likewise.\n\t* tree-ssa-math-opts.c (divmod_candidate_p): Likewise.\n\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Likewise.\n\t(have_whole_vector_shift): Likewise.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\t* doc/tm.texi: Regenerate.\n\ngcc/brig/\n\t* brig-c.h (brig_type_for_mode): Remove \"enum\" before \"machine_mode\".\n\t* brig-lang.c (brig_langhook_type_for_mode): Likewise.\n\ngcc/jit/\n\t* dummy-frontend.c (jit_langhook_type_for_mode): Remove \"enum\" before\n\t\"machine_mode\".\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r250003", "tree": {"sha": "50df6d385f4060e2be884fe3024a2bf688c3aec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50df6d385f4060e2be884fe3024a2bf688c3aec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/comments", "author": null, "committer": null, "parents": [{"sha": "98f9d0ca902c48b58d3d9adee53c3a1800fd3e6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f9d0ca902c48b58d3d9adee53c3a1800fd3e6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f9d0ca902c48b58d3d9adee53c3a1800fd3e6d"}], "stats": {"total": 648, "additions": 428, "deletions": 220}, "files": [{"sha": "2a6a66ff59262c69b1a1bb24bb585a7d1d169439", "filename": "gcc/ChangeLog", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -1,3 +1,201 @@\n+2017-07-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (simplify_if_then_else): Remove \"enum\" before\n+\t\"machine_mode\".\n+\t* compare-elim.c (can_eliminate_compare): Likewise.\n+\t* config/aarch64/aarch64-builtins.c (aarch64_simd_builtin_std_type):\n+\tLikewise.\n+\t(aarch64_lookup_simd_builtin_type): Likewise.\n+\t(aarch64_simd_builtin_type): Likewise.\n+\t(aarch64_init_simd_builtin_types): Likewise.\n+\t(aarch64_simd_expand_args): Likewise.\n+\t* config/aarch64/aarch64-protos.h (aarch64_simd_attr_length_rglist):\n+\tLikewise.\n+\t(aarch64_reverse_mask): Likewise.\n+\t(aarch64_simd_emit_reg_reg_move): Likewise.\n+\t(aarch64_gen_adjusted_ldpstp): Likewise.\n+\t(aarch64_ccmp_mode_to_code): Likewise.\n+\t(aarch64_operands_ok_for_ldpstp): Likewise.\n+\t(aarch64_operands_adjust_ok_for_ldpstp): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_ira_change_pseudo_allocno_class):\n+\tLikewise.\n+\t(aarch64_min_divisions_for_recip_mul): Likewise.\n+\t(aarch64_reassociation_width): Likewise.\n+\t(aarch64_get_condition_code_1): Likewise.\n+\t(aarch64_simd_emit_reg_reg_move): Likewise.\n+\t(aarch64_simd_attr_length_rglist): Likewise.\n+\t(aarch64_reverse_mask): Likewise.\n+\t(aarch64_operands_ok_for_ldpstp): Likewise.\n+\t(aarch64_operands_adjust_ok_for_ldpstp): Likewise.\n+\t(aarch64_gen_adjusted_ldpstp): Likewise.\n+\t* config/aarch64/cortex-a57-fma-steering.c (fma_node::rename):\n+\tLikewise.\n+\t* config/arc/arc.c (legitimate_offset_address_p): Likewise.\n+\t* config/arm/arm-builtins.c (arm_simd_builtin_std_type): Likewise.\n+\t(arm_lookup_simd_builtin_type): Likewise.\n+\t(arm_simd_builtin_type): Likewise.\n+\t(arm_init_simd_builtin_types): Likewise.\n+\t(arm_expand_builtin_args): Likewise.\n+\t* config/arm/arm-protos.h (arm_expand_builtin): Likewise.\n+\t* config/ft32/ft32.c (ft32_libcall_value): Likewise.\n+\t(ft32_setup_incoming_varargs): Likewise.\n+\t(ft32_function_arg): Likewise.\n+\t(ft32_function_arg_advance): Likewise.\n+\t(ft32_pass_by_reference): Likewise.\n+\t(ft32_arg_partial_bytes): Likewise.\n+\t(ft32_valid_pointer_mode): Likewise.\n+\t(ft32_addr_space_pointer_mode): Likewise.\n+\t(ft32_addr_space_legitimate_address_p): Likewise.\n+\t* config/i386/i386-protos.h (ix86_operands_ok_for_move_multiple):\n+\tLikewise.\n+\t* config/i386/i386.c (ix86_setup_incoming_vararg_bounds): Likewise.\n+\t(ix86_emit_outlined_ms2sysv_restore): Likewise.\n+\t(iamcu_alignment): Likewise.\n+\t(canonicalize_vector_int_perm): Likewise.\n+\t(ix86_noce_conversion_profitable_p): Likewise.\n+\t(ix86_mpx_bound_mode): Likewise.\n+\t(ix86_operands_ok_for_move_multiple): Likewise.\n+\t* config/microblaze/microblaze-protos.h\n+\t(microblaze_expand_conditional_branch_reg): Likewise.\n+\t* config/microblaze/microblaze.c\n+\t(microblaze_expand_conditional_branch_reg): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_init_hard_regno_mode_ok):\n+\tLikewise.\n+\t(rs6000_reassociation_width): Likewise.\n+\t(rs6000_invalid_binary_op): Likewise.\n+\t(fusion_p9_p): Likewise.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\t* config/riscv/riscv-protos.h (riscv_regno_mode_ok_for_base_p):\n+\tLikewise.\n+\t(riscv_hard_regno_mode_ok_p): Likewise.\n+\t(riscv_address_insns): Likewise.\n+\t(riscv_split_symbol): Likewise.\n+\t(riscv_legitimize_move): Likewise.\n+\t(riscv_function_value): Likewise.\n+\t(riscv_hard_regno_nregs): Likewise.\n+\t(riscv_expand_builtin): Likewise.\n+\t* config/riscv/riscv.c (riscv_build_integer_1): Likewise.\n+\t(riscv_build_integer): Likewise.\n+\t(riscv_split_integer): Likewise.\n+\t(riscv_legitimate_constant_p): Likewise.\n+\t(riscv_cannot_force_const_mem): Likewise.\n+\t(riscv_regno_mode_ok_for_base_p): Likewise.\n+\t(riscv_valid_base_register_p): Likewise.\n+\t(riscv_valid_offset_p): Likewise.\n+\t(riscv_valid_lo_sum_p): Likewise.\n+\t(riscv_classify_address): Likewise.\n+\t(riscv_legitimate_address_p): Likewise.\n+\t(riscv_address_insns): Likewise.\n+\t(riscv_load_store_insns): Likewise.\n+\t(riscv_force_binary): Likewise.\n+\t(riscv_split_symbol): Likewise.\n+\t(riscv_force_address): Likewise.\n+\t(riscv_legitimize_address): Likewise.\n+\t(riscv_move_integer): Likewise.\n+\t(riscv_legitimize_const_move): Likewise.\n+\t(riscv_legitimize_move): Likewise.\n+\t(riscv_address_cost): Likewise.\n+\t(riscv_subword): Likewise.\n+\t(riscv_output_move): Likewise.\n+\t(riscv_canonicalize_int_order_test): Likewise.\n+\t(riscv_emit_int_order_test): Likewise.\n+\t(riscv_function_arg_boundary): Likewise.\n+\t(riscv_pass_mode_in_fpr_p): Likewise.\n+\t(riscv_pass_fpr_single): Likewise.\n+\t(riscv_pass_fpr_pair): Likewise.\n+\t(riscv_get_arg_info): Likewise.\n+\t(riscv_function_arg): Likewise.\n+\t(riscv_function_arg_advance): Likewise.\n+\t(riscv_arg_partial_bytes): Likewise.\n+\t(riscv_function_value): Likewise.\n+\t(riscv_pass_by_reference): Likewise.\n+\t(riscv_setup_incoming_varargs): Likewise.\n+\t(riscv_print_operand): Likewise.\n+\t(riscv_elf_select_rtx_section): Likewise.\n+\t(riscv_save_restore_reg): Likewise.\n+\t(riscv_for_each_saved_reg): Likewise.\n+\t(riscv_register_move_cost): Likewise.\n+\t(riscv_hard_regno_mode_ok_p): Likewise.\n+\t(riscv_hard_regno_nregs): Likewise.\n+\t(riscv_class_max_nregs): Likewise.\n+\t(riscv_memory_move_cost): Likewise.\n+\t* config/rl78/rl78-protos.h (rl78_split_movsi): Likewise.\n+\t* config/rl78/rl78.c (rl78_split_movsi): Likewise.\n+\t(rl78_addr_space_address_mode): Likewise.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tLikewise.\n+\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Likewise.\n+\t(rs6000_reassociation_width): Likewise.\n+\t(rs6000_invalid_binary_op): Likewise.\n+\t(fusion_p9_p): Likewise.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\t* config/visium/visium-protos.h (prepare_move_operands): Likewise.\n+\t(ok_for_simple_move_operands): Likewise.\n+\t(ok_for_simple_move_strict_operands): Likewise.\n+\t(ok_for_simple_arith_logic_operands): Likewise.\n+\t(visium_legitimize_reload_address): Likewise.\n+\t(visium_select_cc_mode): Likewise.\n+\t(output_cbranch): Likewise.\n+\t(visium_split_double_move): Likewise.\n+\t(visium_expand_copysign): Likewise.\n+\t(visium_expand_int_cstore): Likewise.\n+\t(visium_expand_fp_cstore): Likewise.\n+\t* config/visium/visium.c (visium_pass_by_reference): Likewise.\n+\t(visium_function_arg): Likewise.\n+\t(visium_function_arg_advance): Likewise.\n+\t(visium_libcall_value): Likewise.\n+\t(visium_setup_incoming_varargs): Likewise.\n+\t(visium_legitimate_constant_p): Likewise.\n+\t(visium_legitimate_address_p): Likewise.\n+\t(visium_legitimize_address): Likewise.\n+\t(visium_secondary_reload): Likewise.\n+\t(visium_register_move_cost): Likewise.\n+\t(visium_memory_move_cost): Likewise.\n+\t(prepare_move_operands): Likewise.\n+\t(ok_for_simple_move_operands): Likewise.\n+\t(ok_for_simple_move_strict_operands): Likewise.\n+\t(ok_for_simple_arith_logic_operands): Likewise.\n+\t(visium_function_value_1): Likewise.\n+\t(rtx_ok_for_offset_p): Likewise.\n+\t(visium_legitimize_reload_address): Likewise.\n+\t(visium_split_double_move): Likewise.\n+\t(visium_expand_copysign): Likewise.\n+\t(visium_expand_int_cstore): Likewise.\n+\t(visium_expand_fp_cstore): Likewise.\n+\t(visium_split_cstore): Likewise.\n+\t(visium_select_cc_mode): Likewise.\n+\t(visium_split_cbranch): Likewise.\n+\t(output_cbranch): Likewise.\n+\t(visium_print_operand_address): Likewise.\n+\t* expmed.c (flip_storage_order): Likewise.\n+\t* expmed.h (emit_cstore): Likewise.\n+\t(flip_storage_order): Likewise.\n+\t* genrecog.c (validate_pattern): Likewise.\n+\t* hsa-gen.c (gen_hsa_addr): Likewise.\n+\t* internal-fn.c (expand_arith_overflow): Likewise.\n+\t* ira-color.c (allocno_copy_cost_saving): Likewise.\n+\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n+\t* lra-constraints.c (prohibited_class_reg_set_mode_p): Likewise.\n+\t(process_invariant_for_inheritance): Likewise.\n+\t* lra-eliminations.c (move_plus_up): Likewise.\n+\t* omp-low.c (lower_oacc_reductions): Likewise.\n+\t* simplify-rtx.c (simplify_subreg): Likewise.\n+\t* target.def (TARGET_SETUP_INCOMING_VARARG_BOUNDS): Likewise.\n+\t(TARGET_CHKP_BOUND_MODE): Likewise..\n+\t* targhooks.c (default_chkp_bound_mode): Likewise.\n+\t(default_setup_incoming_vararg_bounds): Likewise.\n+\t* targhooks.h (default_chkp_bound_mode): Likewise.\n+\t(default_setup_incoming_vararg_bounds): Likewise.\n+\t* tree-ssa-math-opts.c (divmod_candidate_p): Likewise.\n+\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Likewise.\n+\t(have_whole_vector_shift): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\n 2017-07-05  Georg-Johann Lay  <avr@gjlay.de>\n \n \tGraceful degrade if Binutils PR21472 is not available."}, {"sha": "f7c82f4410749ed8c4f7273adb629d39a2f5d28e", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -1,3 +1,10 @@\n+2017-07-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* brig-c.h (brig_type_for_mode): Remove \"enum\" before \"machine_mode\".\n+\t* brig-lang.c (brig_langhook_type_for_mode): Likewise.\n+\n 2017-07-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* brigfrontend/brig-function.cc: Include profile-count.h."}, {"sha": "ae7eefe03cebb4175956cd7522981d7db05e54ba", "filename": "gcc/brig/brig-c.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fbrig%2Fbrig-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fbrig%2Fbrig-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-c.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -44,7 +44,7 @@ extern void brig_parse_input_files (const char **, unsigned int,\n extern void brig_write_globals (void);\n \n extern tree brig_type_for_size (unsigned int bits, int unsignedp);\n-extern tree brig_type_for_mode (enum machine_mode, int unsignedp);\n+extern tree brig_type_for_mode (machine_mode, int unsignedp);\n \n /* Functions defined in the GCC interface called by the Brig frontend\n    proper.  */"}, {"sha": "13e738e1937269eadba1594bfd3f9d85ea58d136", "filename": "gcc/brig/brig-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fbrig%2Fbrig-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fbrig%2Fbrig-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-lang.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -241,7 +241,7 @@ brig_langhook_type_for_size (unsigned int bits,\n }\n \n static tree\n-brig_langhook_type_for_mode (enum machine_mode mode, int unsignedp)\n+brig_langhook_type_for_mode (machine_mode mode, int unsignedp)\n {\n   if (mode == TYPE_MODE (void_type_node))\n     return void_type_node;"}, {"sha": "c1eec91a5d1ee9f9d1a877d6771b1d8f614d86da", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -6584,7 +6584,7 @@ simplify_if_then_else (rtx x)\n       && (i = exact_log2 (UINTVAL (true_rtx) & GET_MODE_MASK (mode))) >= 0)\n     {\n       rtx val = XEXP (cond, 0);\n-      enum machine_mode val_mode = GET_MODE (val);\n+      machine_mode val_mode = GET_MODE (val);\n       if (val_mode == mode)\n         return val;\n       else if (GET_MODE_PRECISION (val_mode) < GET_MODE_PRECISION (mode))"}, {"sha": "7e557a245b5b9ca522d850aa758fe07e361e0faf", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -279,7 +279,7 @@ can_eliminate_compare (rtx compare, rtx eh_note, struct comparison *cmp)\n     return false;\n \n   /* New mode must be compatible with the previous compare mode.  */\n-  enum machine_mode new_mode\n+  machine_mode new_mode\n     = targetm.cc_modes_compatible (GET_MODE (compare), cmp->orig_mode);\n \n   if (new_mode == VOIDmode)"}, {"sha": "d30009ba441cabc511ddbc821379daae6de09fa2", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -530,7 +530,7 @@ aarch64_mangle_builtin_type (const_tree type)\n }\n \n static tree\n-aarch64_simd_builtin_std_type (enum machine_mode mode,\n+aarch64_simd_builtin_std_type (machine_mode mode,\n \t\t\t       enum aarch64_type_qualifiers q)\n {\n #define QUAL_TYPE(M)  \\\n@@ -566,7 +566,7 @@ aarch64_simd_builtin_std_type (enum machine_mode mode,\n }\n \n static tree\n-aarch64_lookup_simd_builtin_type (enum machine_mode mode,\n+aarch64_lookup_simd_builtin_type (machine_mode mode,\n \t\t\t\t  enum aarch64_type_qualifiers q)\n {\n   int i;\n@@ -585,7 +585,7 @@ aarch64_lookup_simd_builtin_type (enum machine_mode mode,\n }\n \n static tree\n-aarch64_simd_builtin_type (enum machine_mode mode,\n+aarch64_simd_builtin_type (machine_mode mode,\n \t\t\t   bool unsigned_p, bool poly_p)\n {\n   if (poly_p)\n@@ -649,7 +649,7 @@ aarch64_init_simd_builtin_types (void)\n   for (i = 0; i < nelts; i++)\n     {\n       tree eltype = aarch64_simd_types[i].eltype;\n-      enum machine_mode mode = aarch64_simd_types[i].mode;\n+      machine_mode mode = aarch64_simd_types[i].mode;\n \n       if (aarch64_simd_types[i].itype == NULL)\n \t{\n@@ -1015,7 +1015,7 @@ typedef enum\n static rtx\n aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n \t\t\t  tree exp, builtin_simd_arg *args,\n-\t\t\t  enum machine_mode builtin_mode)\n+\t\t\t  machine_mode builtin_mode)\n {\n   rtx pat;\n   rtx op[SIMD_MAX_BUILTIN_ARGS + 1]; /* First element for result operand.  */\n@@ -1040,7 +1040,7 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n       else\n \t{\n \t  tree arg = CALL_EXPR_ARG (exp, opc - have_retval);\n-\t  enum machine_mode mode = insn_data[icode].operand[opc].mode;\n+\t  machine_mode mode = insn_data[icode].operand[opc].mode;\n \t  op[opc] = expand_normal (arg);\n \n \t  switch (thisarg)"}, {"sha": "e397ff4afa73cfbc7e192fd5686b1beff9bbbadf", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -342,8 +342,8 @@ bool aarch64_modes_tieable_p (machine_mode mode1,\n bool aarch64_zero_extend_const_eq (machine_mode, rtx, machine_mode, rtx);\n bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);\n bool aarch64_mov_operand_p (rtx, machine_mode);\n-int aarch64_simd_attr_length_rglist (enum machine_mode);\n-rtx aarch64_reverse_mask (enum machine_mode);\n+int aarch64_simd_attr_length_rglist (machine_mode);\n+rtx aarch64_reverse_mask (machine_mode);\n bool aarch64_offset_7bit_signed_scaled_p (machine_mode, HOST_WIDE_INT);\n char *aarch64_output_scalar_simd_mov_immediate (rtx, machine_mode);\n char *aarch64_output_simd_mov_immediate (rtx, machine_mode, unsigned);\n@@ -411,7 +411,7 @@ void aarch64_save_restore_target_globals (tree);\n /* Initialize builtins for SIMD intrinsics.  */\n void init_aarch64_simd_builtins (void);\n \n-void aarch64_simd_emit_reg_reg_move (rtx *, enum machine_mode, unsigned int);\n+void aarch64_simd_emit_reg_reg_move (rtx *, machine_mode, unsigned int);\n \n /* Expand builtins for SIMD intrinsics.  */\n rtx aarch64_simd_expand_builtin (int, tree, rtx);\n@@ -444,7 +444,7 @@ bool aarch64_atomic_ldop_supported_p (enum rtx_code);\n void aarch64_gen_atomic_ldop (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n void aarch64_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx, rtx);\n \n-bool aarch64_gen_adjusted_ldpstp (rtx *, bool, enum machine_mode, RTX_CODE);\n+bool aarch64_gen_adjusted_ldpstp (rtx *, bool, machine_mode, RTX_CODE);\n #endif /* RTX_CODE */\n \n void aarch64_init_builtins (void);\n@@ -468,11 +468,11 @@ extern void aarch64_final_prescan_insn (rtx_insn *);\n extern bool\n aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n void aarch64_atomic_assign_expand_fenv (tree *, tree *, tree *);\n-int aarch64_ccmp_mode_to_code (enum machine_mode mode);\n+int aarch64_ccmp_mode_to_code (machine_mode mode);\n \n bool extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset);\n-bool aarch64_operands_ok_for_ldpstp (rtx *, bool, enum machine_mode);\n-bool aarch64_operands_adjust_ok_for_ldpstp (rtx *, bool, enum machine_mode);\n+bool aarch64_operands_ok_for_ldpstp (rtx *, bool, machine_mode);\n+bool aarch64_operands_adjust_ok_for_ldpstp (rtx *, bool, machine_mode);\n \n extern void aarch64_asm_output_pool_epilogue (FILE *, const char *,\n \t\t\t\t\t      tree, HOST_WIDE_INT);"}, {"sha": "ef1b5a8e2153eb9079a650dd8406335430c2c04a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -1032,7 +1032,7 @@ static reg_class_t\n aarch64_ira_change_pseudo_allocno_class (int regno, reg_class_t allocno_class,\n \t\t\t\t\t reg_class_t best_class)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (allocno_class != ALL_REGS)\n     return allocno_class;\n@@ -1045,7 +1045,7 @@ aarch64_ira_change_pseudo_allocno_class (int regno, reg_class_t allocno_class,\n }\n \n static unsigned int\n-aarch64_min_divisions_for_recip_mul (enum machine_mode mode)\n+aarch64_min_divisions_for_recip_mul (machine_mode mode)\n {\n   if (GET_MODE_UNIT_SIZE (mode) == 4)\n     return aarch64_tune_params.min_div_recip_mul_sf;\n@@ -1054,7 +1054,7 @@ aarch64_min_divisions_for_recip_mul (enum machine_mode mode)\n \n static int\n aarch64_reassociation_width (unsigned opc ATTRIBUTE_UNUSED,\n-\t\t\t     enum machine_mode mode)\n+\t\t\t     machine_mode mode)\n {\n   if (VECTOR_MODE_P (mode))\n     return aarch64_tune_params.vec_reassoc_width;\n@@ -4887,7 +4887,7 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n }\n \n static int\n-aarch64_get_condition_code_1 (enum machine_mode, enum rtx_code);\n+aarch64_get_condition_code_1 (machine_mode, enum rtx_code);\n \n int\n aarch64_get_condition_code (rtx x)\n@@ -4901,7 +4901,7 @@ aarch64_get_condition_code (rtx x)\n }\n \n static int\n-aarch64_get_condition_code_1 (enum machine_mode mode, enum rtx_code comp_code)\n+aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n {\n   switch (mode)\n     {\n@@ -11693,7 +11693,7 @@ aarch64_simd_mem_operand_p (rtx op)\n    COUNT is the number of components into which the copy needs to be\n    decomposed.  */\n void\n-aarch64_simd_emit_reg_reg_move (rtx *operands, enum machine_mode mode,\n+aarch64_simd_emit_reg_reg_move (rtx *operands, machine_mode mode,\n \t\t\t\tunsigned int count)\n {\n   unsigned int i;\n@@ -11714,7 +11714,7 @@ aarch64_simd_emit_reg_reg_move (rtx *operands, enum machine_mode mode,\n /* Compute and return the length of aarch64_simd_reglist<mode>, where <mode> is\n    one of VSTRUCT modes: OI, CI, or XI.  */\n int\n-aarch64_simd_attr_length_rglist (enum machine_mode mode)\n+aarch64_simd_attr_length_rglist (machine_mode mode)\n {\n   return (GET_MODE_SIZE (mode) / UNITS_PER_VREG) * 4;\n }\n@@ -13705,7 +13705,7 @@ aarch64_vectorize_vec_perm_const_ok (machine_mode vmode,\n }\n \n rtx\n-aarch64_reverse_mask (enum machine_mode mode)\n+aarch64_reverse_mask (machine_mode mode)\n {\n   /* We have to reverse each vector because we dont have\n      a permuted load that can reverse-load according to ABI rules.  */\n@@ -14548,7 +14548,7 @@ aarch64_sched_adjust_priority (rtx_insn *insn, int priority)\n \n bool\n aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n-\t\t\t\tenum machine_mode mode)\n+\t\t\t\tmachine_mode mode)\n {\n   HOST_WIDE_INT offval_1, offval_2, msize;\n   enum reg_class rclass_1, rclass_2;\n@@ -14655,7 +14655,7 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n \n bool\n aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n-\t\t\t\t       enum machine_mode mode)\n+\t\t\t\t       machine_mode mode)\n {\n   enum reg_class rclass_1, rclass_2, rclass_3, rclass_4;\n   HOST_WIDE_INT offval_1, offval_2, offval_3, offval_4, msize;\n@@ -14789,7 +14789,7 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n \n bool\n aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,\n-\t\t\t     enum machine_mode mode, RTX_CODE code)\n+\t\t\t     machine_mode mode, RTX_CODE code)\n {\n   rtx base, offset, t1, t2;\n   rtx mem_1, mem_2, mem_3, mem_4;"}, {"sha": "6d90acdd4a21175df72e9958729d451ed12562be", "filename": "gcc/config/aarch64/cortex-a57-fma-steering.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -603,7 +603,7 @@ fma_node::rename (fma_forest *forest)\n     {\n       rtx_insn *insn = this->m_insn;\n       HARD_REG_SET unavailable;\n-      enum machine_mode mode;\n+      machine_mode mode;\n       int reg;\n \n       if (dump_file)"}, {"sha": "ed8fd8e756ff29410becebd8071e7bbc2119f742", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -276,8 +276,7 @@ const arc_cpu_t *arc_selected_cpu;\n    register, an immediate or an long immediate. */\n \n static bool\n-legitimate_offset_address_p (enum machine_mode mode, rtx x, bool index,\n-\t\t\t     bool strict)\n+legitimate_offset_address_p (machine_mode mode, rtx x, bool index, bool strict)\n {\n   if (GET_CODE (x) != PLUS)\n     return false;"}, {"sha": "63ee880822c17eda55dd58438d61cbbba333b2c6", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -808,7 +808,7 @@ arm_mangle_builtin_type (const_tree type)\n }\n \n static tree\n-arm_simd_builtin_std_type (enum machine_mode mode,\n+arm_simd_builtin_std_type (machine_mode mode,\n \t\t\t   enum arm_type_qualifiers q)\n {\n #define QUAL_TYPE(M)  \\\n@@ -846,7 +846,7 @@ arm_simd_builtin_std_type (enum machine_mode mode,\n }\n \n static tree\n-arm_lookup_simd_builtin_type (enum machine_mode mode,\n+arm_lookup_simd_builtin_type (machine_mode mode,\n \t\t\t      enum arm_type_qualifiers q)\n {\n   int i;\n@@ -868,8 +868,7 @@ arm_lookup_simd_builtin_type (enum machine_mode mode,\n }\n \n static tree\n-arm_simd_builtin_type (enum machine_mode mode,\n-\t\t\t   bool unsigned_p, bool poly_p)\n+arm_simd_builtin_type (machine_mode mode, bool unsigned_p, bool poly_p)\n {\n   if (poly_p)\n     return arm_lookup_simd_builtin_type (mode, qualifier_poly);\n@@ -943,7 +942,7 @@ arm_init_simd_builtin_types (void)\n   for (i = 0; i < nelts; i++)\n     {\n       tree eltype = arm_simd_types[i].eltype;\n-      enum machine_mode mode = arm_simd_types[i].mode;\n+      machine_mode mode = arm_simd_types[i].mode;\n \n       if (arm_simd_types[i].itype == NULL)\n \tarm_simd_types[i].itype =\n@@ -2233,7 +2232,7 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n \t      gcc_assert (argc > 0);\n \t      if (CONST_INT_P (op[argc]))\n \t\t{\n-\t\t  enum machine_mode vmode = mode[argc - 1];\n+\t\t  machine_mode vmode = mode[argc - 1];\n \t\t  neon_lane_bounds (op[argc], 0, GET_MODE_NUNITS (vmode), exp);\n \t\t}\n \t      /* If the lane index isn't a constant then the next"}, {"sha": "25fb10c32d1e227c5089c893460c54daf3e51de9", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -47,7 +47,7 @@ extern unsigned int arm_dbx_register_number (unsigned int);\n extern void arm_output_fn_unwind (FILE *, bool);\n \n extern rtx arm_expand_builtin (tree exp, rtx target, rtx subtarget\n-\t\t\t       ATTRIBUTE_UNUSED, enum machine_mode mode\n+\t\t\t       ATTRIBUTE_UNUSED, machine_mode mode\n \t\t\t       ATTRIBUTE_UNUSED, int ignore ATTRIBUTE_UNUSED);\n extern tree arm_builtin_decl (unsigned code, bool initialize_p\n \t\t\t      ATTRIBUTE_UNUSED);"}, {"sha": "db0365e92c1fadc9c1f272f701bc21a9c71a31dd", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -79,7 +79,7 @@ ft32_function_value (const_tree valtype,\n    We always return values in register $r0 for ft32.  */\n \n static rtx\n-ft32_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+ft32_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, FT32_R0);\n }\n@@ -625,7 +625,7 @@ ft32_initial_elimination_offset (int from, int to)\n \n static void\n ft32_setup_incoming_varargs (cumulative_args_t cum_v,\n-\t\t\t     enum machine_mode mode,\n+\t\t\t     machine_mode mode,\n \t\t\t     tree type ATTRIBUTE_UNUSED,\n \t\t\t     int *pretend_size, int no_rtl ATTRIBUTE_UNUSED)\n {\n@@ -653,7 +653,7 @@ ft32_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    NULL_RTX if there's no more space.  */\n \n static rtx\n-ft32_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+ft32_function_arg (cumulative_args_t cum_v, machine_mode mode,\n                    const_tree type ATTRIBUTE_UNUSED,\n                    bool named ATTRIBUTE_UNUSED)\n {\n@@ -670,7 +670,7 @@ ft32_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n    : (unsigned) int_size_in_bytes (TYPE))\n \n static void\n-ft32_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+ft32_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n                            const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -684,7 +684,7 @@ ft32_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \n static bool\n ft32_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-                        enum machine_mode mode, const_tree type,\n+                        machine_mode mode, const_tree type,\n                         bool named ATTRIBUTE_UNUSED)\n {\n   unsigned HOST_WIDE_INT size;\n@@ -707,7 +707,7 @@ ft32_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \n static int\n ft32_arg_partial_bytes (cumulative_args_t cum_v,\n-                        enum machine_mode mode, tree type, bool named)\n+                        machine_mode mode, tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes_left, size;\n@@ -790,7 +790,7 @@ ft32_is_mem_pm (rtx o)\n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE ft32_valid_pointer_mode\n static bool\n-ft32_valid_pointer_mode (enum machine_mode mode)\n+ft32_valid_pointer_mode (machine_mode mode)\n {\n   if (mode == SImode)\n     return 1;\n@@ -799,15 +799,15 @@ ft32_valid_pointer_mode (enum machine_mode mode)\n \n #undef TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE ft32_addr_space_pointer_mode\n-static enum machine_mode\n+static machine_mode\n ft32_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n {\n   return Pmode;\n }\n \n #undef TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE ft32_addr_space_address_mode\n-static enum machine_mode\n+static machine_mode\n ft32_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n {\n   return Pmode;\n@@ -861,8 +861,7 @@ reg_ok_for_base_p (rtx r, bool strict)\n }\n \n static bool\n-ft32_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n-                                      bool strict,\n+ft32_addr_space_legitimate_address_p (machine_mode mode, rtx x, bool strict,\n                                       addr_space_t as ATTRIBUTE_UNUSED)\n {\n   if (mode != BLKmode)"}, {"sha": "bf8a0492592d71f8306ac24122a7b90a59e4ac7b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -316,7 +316,7 @@ extern enum attr_cpu ix86_schedule;\n \n extern const char * ix86_output_call_insn (rtx_insn *insn, rtx call_op);\n extern bool ix86_operands_ok_for_move_multiple (rtx *operands, bool load,\n-\t\t\t\t\t\tenum machine_mode mode);\n+\t\t\t\t\t\tmachine_mode mode);\n \n #ifdef RTX_CODE\n /* Target data for multipass lookahead scheduling."}, {"sha": "1a8a3a380008c763c76ad953e1c7310a1be45e20", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -11363,7 +11363,7 @@ ix86_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n \n static void\n ix86_setup_incoming_vararg_bounds (cumulative_args_t cum_v,\n-\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   machine_mode mode,\n \t\t\t\t   tree type,\n \t\t\t\t   int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t\t   int no_rtl)\n@@ -15084,7 +15084,7 @@ ix86_emit_outlined_ms2sysv_restore (const struct ix86_frame &frame,\n   for (i = 0; i < ncregs; ++i)\n     {\n       const xlogue_layout::reginfo &r = xlogue.get_reginfo (i);\n-      enum machine_mode mode = SSE_REGNO_P (r.regno) ? V4SFmode : word_mode;\n+      machine_mode mode = SSE_REGNO_P (r.regno) ? V4SFmode : word_mode;\n       rtx reg, frame_load;\n \n       reg = gen_rtx_REG (mode, r.regno);\n@@ -31160,7 +31160,7 @@ ix86_constant_alignment (tree exp, int align)\n static int\n iamcu_alignment (tree type, int align)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   if (align < 32 || TYPE_USER_ALIGN (type))\n     return align;\n@@ -47168,7 +47168,7 @@ canonicalize_vector_int_perm (const struct expand_vec_perm_d *d,\n \t\t\t      struct expand_vec_perm_d *nd)\n {\n   int i;\n-  enum machine_mode mode = VOIDmode;\n+  machine_mode mode = VOIDmode;\n \n   switch (d->vmode)\n     {\n@@ -51418,7 +51418,7 @@ ix86_noce_conversion_profitable_p (rtx_insn *seq, struct noce_if_info *if_info)\n \t  if (GET_CODE (SET_SRC (set)) != IF_THEN_ELSE)\n \t    continue;\n \t  rtx src = SET_SRC (set);\n-\t  enum machine_mode mode = GET_MODE (src);\n+\t  machine_mode mode = GET_MODE (src);\n \t  if (GET_MODE_CLASS (mode) != MODE_INT\n \t      && GET_MODE_CLASS (mode) != MODE_FLOAT)\n \t    continue;\n@@ -51914,7 +51914,7 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n /* Return mode to be used for bounds or VOIDmode\n    if bounds are not supported.  */\n \n-static enum machine_mode\n+static machine_mode\n ix86_mpx_bound_mode ()\n {\n   /* Do not support pointer checker if MPX\n@@ -52034,7 +52034,7 @@ extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset)\n \n bool\n ix86_operands_ok_for_move_multiple (rtx *operands, bool load,\n-\t\t\t\t    enum machine_mode mode)\n+\t\t\t\t    machine_mode mode)\n {\n   HOST_WIDE_INT offval_1, offval_2, msize;\n   rtx mem_1, mem_2, reg_1, reg_2, base_1, base_2, offset_1, offset_2;"}, {"sha": "747ef359719f77eecb6f424f93d6632b3dceddeb", "filename": "gcc/config/microblaze/microblaze-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -33,7 +33,7 @@ extern bool microblaze_expand_move (machine_mode, rtx *);\n extern bool microblaze_expand_block_move (rtx, rtx, rtx, rtx);\n extern void microblaze_expand_divide (rtx *);\n extern void microblaze_expand_conditional_branch (machine_mode, rtx *);\n-extern void microblaze_expand_conditional_branch_reg (enum machine_mode, rtx *);\n+extern void microblaze_expand_conditional_branch_reg (machine_mode, rtx *);\n extern void microblaze_expand_conditional_branch_sf (rtx *); \n extern int microblaze_can_use_return_insn (void);\n extern void print_operand (FILE *, rtx, int);"}, {"sha": "15ceac0b346ddc756155fcb868593102dc557692", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -3453,8 +3453,7 @@ microblaze_expand_conditional_branch (machine_mode mode, rtx operands[])\n }\n \n void\n-microblaze_expand_conditional_branch_reg (enum machine_mode mode,\n-                                          rtx operands[])\n+microblaze_expand_conditional_branch_reg (machine_mode mode, rtx operands[])\n {\n   enum rtx_code code = GET_CODE (operands[0]);\n   rtx cmp_op0 = operands[1];"}, {"sha": "06d66d7e4cd610812f1c9c43252d96397ea2c766", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -3608,12 +3608,12 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  CODE_FOR_fusion_gpr_di_df_store },\n       };\n \n-      enum machine_mode cur_pmode = Pmode;\n+      machine_mode cur_pmode = Pmode;\n       size_t i;\n \n       for (i = 0; i < ARRAY_SIZE (addis_insns); i++)\n \t{\n-\t  enum machine_mode xmode = addis_insns[i].mode;\n+\t  machine_mode xmode = addis_insns[i].mode;\n \t  enum rs6000_reload_reg_type rtype = addis_insns[i].rtype;\n \n \t  if (addis_insns[i].pmode != cur_pmode)\n@@ -10399,7 +10399,7 @@ rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)\n  \n static int\n rs6000_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n-                            enum machine_mode mode)\n+                            machine_mode mode)\n {\n   switch (rs6000_cpu)\n     {\n@@ -24860,8 +24860,8 @@ rs6000_invalid_binary_op (int op ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type1,\n \t\t\t  const_tree type2)\n {\n-  enum machine_mode mode1 = TYPE_MODE (type1);\n-  enum machine_mode mode2 = TYPE_MODE (type2);\n+  machine_mode mode1 = TYPE_MODE (type1);\n+  machine_mode mode2 = TYPE_MODE (type2);\n \n   /* For complex modes, use the inner type.  */\n   if (COMPLEX_MODE_P (mode1))\n@@ -41284,7 +41284,7 @@ fusion_p9_p (rtx addis_reg,\t\t/* register set via addis.  */\n \t     rtx src)\t\t\t/* source (register or memory).  */\n {\n   rtx addr, mem, offset;\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n \n   /* Validate arguments.  */\n   if (!base_reg_operand (addis_reg, GET_MODE (addis_reg)))\n@@ -41458,7 +41458,7 @@ expand_fusion_p9_store (rtx *operands)\n const char *\n emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n {\n-  enum machine_mode mode = GET_MODE (reg);\n+  machine_mode mode = GET_MODE (reg);\n   rtx hi;\n   rtx lo;\n   rtx addr;\n@@ -41551,7 +41551,7 @@ emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n const char *\n emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n {\n-  enum machine_mode mode = GET_MODE (reg);\n+  machine_mode mode = GET_MODE (reg);\n   rtx hi;\n   rtx lo;\n   rtx addr;"}, {"sha": "aa57d1a71529983060225c0e7beb496cd84dd3ba", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -38,18 +38,18 @@ enum riscv_symbol_type {\n /* Routines implemented in riscv.c.  */\n extern enum riscv_symbol_type riscv_classify_symbolic_expression (rtx);\n extern bool riscv_symbolic_constant_p (rtx, enum riscv_symbol_type *);\n-extern int riscv_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n-extern bool riscv_hard_regno_mode_ok_p (unsigned int, enum machine_mode);\n-extern int riscv_address_insns (rtx, enum machine_mode, bool);\n+extern int riscv_regno_mode_ok_for_base_p (int, machine_mode, bool);\n+extern bool riscv_hard_regno_mode_ok_p (unsigned int, machine_mode);\n+extern int riscv_address_insns (rtx, machine_mode, bool);\n extern int riscv_const_insns (rtx);\n extern int riscv_split_const_insns (rtx);\n extern int riscv_load_store_insns (rtx, rtx_insn *);\n extern rtx riscv_emit_move (rtx, rtx);\n-extern bool riscv_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n+extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *);\n extern bool riscv_split_symbol_type (enum riscv_symbol_type);\n extern rtx riscv_unspec_address (rtx, enum riscv_symbol_type);\n extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT);\n-extern bool riscv_legitimize_move (enum machine_mode, rtx, rtx);\n+extern bool riscv_legitimize_move (machine_mode, rtx, rtx);\n extern rtx riscv_subword (rtx, bool);\n extern bool riscv_split_64bit_move_p (rtx, rtx);\n extern void riscv_split_doubleword_move (rtx, rtx);\n@@ -68,15 +68,15 @@ extern HOST_WIDE_INT riscv_initial_elimination_offset (int, int);\n extern void riscv_expand_prologue (void);\n extern void riscv_expand_epilogue (bool);\n extern bool riscv_can_use_return_insn (void);\n-extern rtx riscv_function_value (const_tree, const_tree, enum machine_mode);\n-extern unsigned int riscv_hard_regno_nregs (int, enum machine_mode);\n+extern rtx riscv_function_value (const_tree, const_tree, machine_mode);\n+extern unsigned int riscv_hard_regno_nregs (int, machine_mode);\n \n /* Routines implemented in riscv-c.c.  */\n void riscv_cpu_cpp_builtins (cpp_reader *);\n \n /* Routines implemented in riscv-builtins.c.  */\n extern void riscv_atomic_assign_expand_fenv (tree *, tree *, tree *);\n-extern rtx riscv_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+extern rtx riscv_expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern tree riscv_builtin_decl (unsigned int, bool);\n extern void riscv_init_builtins (void);\n "}, {"sha": "220de4b2cbae72daacf825b6d4f6c6d5c00cf42d", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -347,7 +347,7 @@ riscv_parse_cpu (const char *cpu_string)\n \n static int\n riscv_build_integer_1 (struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS],\n-\t\t       HOST_WIDE_INT value, enum machine_mode mode)\n+\t\t       HOST_WIDE_INT value, machine_mode mode)\n {\n   HOST_WIDE_INT low_part = CONST_LOW_PART (value);\n   int cost = RISCV_MAX_INTEGER_OPS + 1, alt_cost;\n@@ -421,7 +421,7 @@ riscv_build_integer_1 (struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS],\n \n static int\n riscv_build_integer (struct riscv_integer_op *codes, HOST_WIDE_INT value,\n-\t\t     enum machine_mode mode)\n+\t\t     machine_mode mode)\n {\n   int cost = riscv_build_integer_1 (codes, value, mode);\n \n@@ -489,7 +489,7 @@ riscv_integer_cost (HOST_WIDE_INT val)\n /* Try to split a 64b integer into 32b parts, then reassemble.  */\n \n static rtx\n-riscv_split_integer (HOST_WIDE_INT val, enum machine_mode mode)\n+riscv_split_integer (HOST_WIDE_INT val, machine_mode mode)\n {\n   unsigned HOST_WIDE_INT loval = sext_hwi (val, 32);\n   unsigned HOST_WIDE_INT hival = sext_hwi ((val - loval) >> 32, 32);\n@@ -608,15 +608,15 @@ static int riscv_symbol_insns (enum riscv_symbol_type type)\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n static bool\n-riscv_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+riscv_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return riscv_const_insns (x) > 0;\n }\n \n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n-riscv_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+riscv_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   enum riscv_symbol_type type;\n   rtx base, offset;\n@@ -651,7 +651,7 @@ riscv_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \n int\n riscv_regno_mode_ok_for_base_p (int regno,\n-\t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\tbool strict_p)\n {\n   if (!HARD_REGISTER_NUM_P (regno))\n@@ -674,7 +674,7 @@ riscv_regno_mode_ok_for_base_p (int regno,\n    STRICT_P is true if REG_OK_STRICT is in effect.  */\n \n static bool\n-riscv_valid_base_register_p (rtx x, enum machine_mode mode, bool strict_p)\n+riscv_valid_base_register_p (rtx x, machine_mode mode, bool strict_p)\n {\n   if (!strict_p && GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n@@ -687,7 +687,7 @@ riscv_valid_base_register_p (rtx x, enum machine_mode mode, bool strict_p)\n    can address a value of mode MODE.  */\n \n static bool\n-riscv_valid_offset_p (rtx x, enum machine_mode mode)\n+riscv_valid_offset_p (rtx x, machine_mode mode)\n {\n   /* Check that X is a signed 12-bit number.  */\n   if (!const_arith_operand (x, Pmode))\n@@ -720,7 +720,7 @@ riscv_split_symbol_type (enum riscv_symbol_type symbol_type)\n    LO_SUM symbol has type SYM_TYPE.  */\n \n static bool\n-riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, enum machine_mode mode)\n+riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode)\n {\n   /* Check that symbols of type SYMBOL_TYPE can be used to access values\n      of mode MODE.  */\n@@ -747,7 +747,7 @@ riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, enum machine_mode mode)\n \n static bool\n riscv_classify_address (struct riscv_address_info *info, rtx x,\n-\t\t       enum machine_mode mode, bool strict_p)\n+\t\t\tmachine_mode mode, bool strict_p)\n {\n   switch (GET_CODE (x))\n     {\n@@ -797,7 +797,7 @@ riscv_classify_address (struct riscv_address_info *info, rtx x,\n /* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n \n static bool\n-riscv_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+riscv_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n {\n   struct riscv_address_info addr;\n \n@@ -811,7 +811,7 @@ riscv_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n    enough. */\n \n int\n-riscv_address_insns (rtx x, enum machine_mode mode, bool might_split_p)\n+riscv_address_insns (rtx x, machine_mode mode, bool might_split_p)\n {\n   struct riscv_address_info addr;\n   int n = 1;\n@@ -906,7 +906,7 @@ riscv_split_const_insns (rtx x)\n int\n riscv_load_store_insns (rtx mem, rtx_insn *insn)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool might_split_p;\n   rtx set;\n \n@@ -962,7 +962,7 @@ riscv_emit_binary (enum rtx_code code, rtx dest, rtx x, rtx y)\n    of mode MODE.  Return that new register.  */\n \n static rtx\n-riscv_force_binary (enum machine_mode mode, enum rtx_code code, rtx x, rtx y)\n+riscv_force_binary (machine_mode mode, enum rtx_code code, rtx x, rtx y)\n {\n   return riscv_emit_binary (code, gen_reg_rtx (mode), x, y);\n }\n@@ -1080,7 +1080,7 @@ static rtx riscv_tls_add_tp_le (rtx dest, rtx base, rtx sym)\n    is guaranteed to be a legitimate address for mode MODE.  */\n \n bool\n-riscv_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *low_out)\n+riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)\n {\n   enum riscv_symbol_type symbol_type;\n \n@@ -1238,7 +1238,7 @@ riscv_legitimize_tls_address (rtx loc)\n /* If X is not a valid address for mode MODE, force it into a register.  */\n \n static rtx\n-riscv_force_address (rtx x, enum machine_mode mode)\n+riscv_force_address (rtx x, machine_mode mode)\n {\n   if (!riscv_legitimate_address_p (mode, x, false))\n     x = force_reg (Pmode, x);\n@@ -1252,7 +1252,7 @@ riscv_force_address (rtx x, enum machine_mode mode)\n \n static rtx\n riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode)\n+\t\t\t  machine_mode mode)\n {\n   rtx addr;\n \n@@ -1285,7 +1285,7 @@ void\n riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value)\n {\n   struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS];\n-  enum machine_mode mode;\n+  machine_mode mode;\n   int i, num_ops;\n   rtx x;\n \n@@ -1319,7 +1319,7 @@ riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value)\n    move_operand.  */\n \n static void\n-riscv_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n+riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n {\n   rtx base, offset;\n \n@@ -1369,7 +1369,7 @@ riscv_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n    sequence that is valid.  */\n \n bool\n-riscv_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n+riscv_legitimize_move (machine_mode mode, rtx dest, rtx src)\n {\n   if (!register_operand (dest, mode) && !reg_or_0_operand (src, mode))\n     {\n@@ -1675,7 +1675,7 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN\n /* Implement TARGET_ADDRESS_COST.  */\n \n static int\n-riscv_address_cost (rtx addr, enum machine_mode mode,\n+riscv_address_cost (rtx addr, machine_mode mode,\n \t\t    addr_space_t as ATTRIBUTE_UNUSED,\n \t\t    bool speed ATTRIBUTE_UNUSED)\n {\n@@ -1689,7 +1689,7 @@ rtx\n riscv_subword (rtx op, bool high_p)\n {\n   unsigned int byte = high_p ? UNITS_PER_WORD : 0;\n-  enum machine_mode mode = GET_MODE (op);\n+  machine_mode mode = GET_MODE (op);\n \n   if (mode == VOIDmode)\n     mode = TARGET_64BIT ? TImode : DImode;\n@@ -1754,7 +1754,7 @@ const char *\n riscv_output_move (rtx dest, rtx src)\n {\n   enum rtx_code dest_code, src_code;\n-  enum machine_mode mode;\n+  machine_mode mode;\n   bool dbl_p;\n \n   dest_code = GET_CODE (dest);\n@@ -1877,7 +1877,7 @@ riscv_int_order_operand_ok_p (enum rtx_code code, rtx cmp1)\n \n static bool\n riscv_canonicalize_int_order_test (enum rtx_code *code, rtx *cmp1,\n-\t\t\t\t  enum machine_mode mode)\n+\t\t\t\t   machine_mode mode)\n {\n   HOST_WIDE_INT plus_one;\n \n@@ -1922,7 +1922,7 @@ static void\n riscv_emit_int_order_test (enum rtx_code code, bool *invert_ptr,\n \t\t\t  rtx target, rtx cmp0, rtx cmp1)\n {\n-  enum machine_mode mode;\n+  machine_mode mode;\n \n   /* First see if there is a RISCV instruction that can do this operation.\n      If not, try doing the same for the inverse operation.  If that also\n@@ -2176,7 +2176,7 @@ riscv_expand_conditional_branch (rtx label, rtx_code code, rtx op0, rtx op1)\n    to STACK_BOUNDARY bits if the type requires it.  */\n \n static unsigned int\n-riscv_function_arg_boundary (enum machine_mode mode, const_tree type)\n+riscv_function_arg_boundary (machine_mode mode, const_tree type)\n {\n   unsigned int alignment;\n \n@@ -2193,7 +2193,7 @@ riscv_function_arg_boundary (enum machine_mode mode, const_tree type)\n    floating-point registers, return the number of registers, else 0.  */\n \n static unsigned\n-riscv_pass_mode_in_fpr_p (enum machine_mode mode)\n+riscv_pass_mode_in_fpr_p (machine_mode mode)\n {\n   if (GET_MODE_UNIT_SIZE (mode) <= UNITS_PER_FP_ARG)\n     {\n@@ -2376,8 +2376,8 @@ riscv_pass_aggregate_in_fpr_and_gpr_p (const_tree type,\n   has mode BLKmode.  */\n \n static rtx\n-riscv_pass_fpr_single (enum machine_mode type_mode, unsigned regno,\n-\t\t       enum machine_mode value_mode)\n+riscv_pass_fpr_single (machine_mode type_mode, unsigned regno,\n+\t\t       machine_mode value_mode)\n {\n   rtx x = gen_rtx_REG (value_mode, regno);\n \n@@ -2395,9 +2395,9 @@ riscv_pass_fpr_single (enum machine_mode type_mode, unsigned regno,\n    second value.  */\n \n static rtx\n-riscv_pass_fpr_pair (enum machine_mode mode, unsigned regno1,\n-\t\t     enum machine_mode mode1, HOST_WIDE_INT offset1,\n-\t\t     unsigned regno2, enum machine_mode mode2,\n+riscv_pass_fpr_pair (machine_mode mode, unsigned regno1,\n+\t\t     machine_mode mode1, HOST_WIDE_INT offset1,\n+\t\t     unsigned regno2, machine_mode mode2,\n \t\t     HOST_WIDE_INT offset2)\n {\n   return gen_rtx_PARALLEL\n@@ -2420,7 +2420,7 @@ riscv_pass_fpr_pair (enum machine_mode mode, unsigned regno1,\n \n static rtx\n riscv_get_arg_info (struct riscv_arg_info *info, const CUMULATIVE_ARGS *cum,\n-\t\t    enum machine_mode mode, const_tree type, bool named,\n+\t\t    machine_mode mode, const_tree type, bool named,\n \t\t    bool return_p)\n {\n   unsigned num_bytes, num_words;\n@@ -2516,7 +2516,7 @@ riscv_get_arg_info (struct riscv_arg_info *info, const CUMULATIVE_ARGS *cum,\n /* Implement TARGET_FUNCTION_ARG.  */\n \n static rtx\n-riscv_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+riscv_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2531,7 +2531,7 @@ riscv_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-riscv_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+riscv_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n@@ -2551,7 +2551,7 @@ riscv_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n \n static int\n riscv_arg_partial_bytes (cumulative_args_t cum,\n-\t\t\t enum machine_mode mode, tree type, bool named)\n+\t\t\t machine_mode mode, tree type, bool named)\n {\n   struct riscv_arg_info arg;\n \n@@ -2564,7 +2564,7 @@ riscv_arg_partial_bytes (cumulative_args_t cum,\n    VALTYPE is null and MODE is the mode of the return value.  */\n \n rtx\n-riscv_function_value (const_tree type, const_tree func, enum machine_mode mode)\n+riscv_function_value (const_tree type, const_tree func, machine_mode mode)\n {\n   struct riscv_arg_info info;\n   CUMULATIVE_ARGS args;\n@@ -2587,7 +2587,7 @@ riscv_function_value (const_tree type, const_tree func, enum machine_mode mode)\n /* Implement TARGET_PASS_BY_REFERENCE. */\n \n static bool\n-riscv_pass_by_reference (cumulative_args_t cum_v, enum machine_mode mode,\n+riscv_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t const_tree type, bool named)\n {\n   HOST_WIDE_INT size = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n@@ -2626,7 +2626,7 @@ riscv_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-riscv_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n+riscv_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t     int no_rtl)\n {\n@@ -2776,7 +2776,7 @@ riscv_memmodel_needs_release_fence (enum memmodel model)\n static void\n riscv_print_operand (FILE *file, rtx op, int letter)\n {\n-  enum machine_mode mode = GET_MODE (op);\n+  machine_mode mode = GET_MODE (op);\n   enum rtx_code code = GET_CODE (op);\n \n   switch (letter)\n@@ -2892,7 +2892,7 @@ riscv_in_small_data_p (const_tree x)\n /* Return a section for X, handling small data. */\n \n static section *\n-riscv_elf_select_rtx_section (enum machine_mode mode, rtx x,\n+riscv_elf_select_rtx_section (machine_mode mode, rtx x,\n \t\t\t      unsigned HOST_WIDE_INT align)\n {\n   section *s = default_elf_select_rtx_section (mode, x, align);\n@@ -3163,7 +3163,7 @@ typedef void (*riscv_save_restore_fn) (rtx, rtx);\n    stack pointer.  */\n \n static void\n-riscv_save_restore_reg (enum machine_mode mode, int regno,\n+riscv_save_restore_reg (machine_mode mode, int regno,\n \t\t       HOST_WIDE_INT offset, riscv_save_restore_fn fn)\n {\n   rtx mem;\n@@ -3196,7 +3196,7 @@ riscv_for_each_saved_reg (HOST_WIDE_INT sp_offset, riscv_save_restore_fn fn)\n   for (int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n     if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n       {\n-\tenum machine_mode mode = TARGET_DOUBLE_FLOAT ? DFmode : SFmode;\n+\tmachine_mode mode = TARGET_DOUBLE_FLOAT ? DFmode : SFmode;\n \n \triscv_save_restore_reg (mode, regno, offset, fn);\n \toffset -= GET_MODE_SIZE (mode);\n@@ -3567,7 +3567,7 @@ riscv_can_use_return_insn (void)\n /* Implement TARGET_REGISTER_MOVE_COST.  */\n \n static int\n-riscv_register_move_cost (enum machine_mode mode,\n+riscv_register_move_cost (machine_mode mode,\n \t\t\t  reg_class_t from, reg_class_t to)\n {\n   return SECONDARY_MEMORY_NEEDED (from, to, mode) ? 8 : 2;\n@@ -3576,7 +3576,7 @@ riscv_register_move_cost (enum machine_mode mode,\n /* Return true if register REGNO can store a value of mode MODE.  */\n \n bool\n-riscv_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n+riscv_hard_regno_mode_ok_p (unsigned int regno, machine_mode mode)\n {\n   unsigned int nregs = riscv_hard_regno_nregs (regno, mode);\n \n@@ -3615,7 +3615,7 @@ riscv_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n /* Implement HARD_REGNO_NREGS.  */\n \n unsigned int\n-riscv_hard_regno_nregs (int regno, enum machine_mode mode)\n+riscv_hard_regno_nregs (int regno, machine_mode mode)\n {\n   if (FP_REG_P (regno))\n     return (GET_MODE_SIZE (mode) + UNITS_PER_FP_REG - 1) / UNITS_PER_FP_REG;\n@@ -3627,7 +3627,7 @@ riscv_hard_regno_nregs (int regno, enum machine_mode mode)\n /* Implement CLASS_MAX_NREGS.  */\n \n static unsigned char\n-riscv_class_max_nregs (reg_class_t rclass, enum machine_mode mode)\n+riscv_class_max_nregs (reg_class_t rclass, machine_mode mode)\n {\n   if (reg_class_subset_p (FP_REGS, rclass))\n     return riscv_hard_regno_nregs (FP_REG_FIRST, mode);\n@@ -3641,7 +3641,7 @@ riscv_class_max_nregs (reg_class_t rclass, enum machine_mode mode)\n /* Implement TARGET_MEMORY_MOVE_COST.  */\n \n static int\n-riscv_memory_move_cost (enum machine_mode mode, reg_class_t rclass, bool in)\n+riscv_memory_move_cost (machine_mode mode, reg_class_t rclass, bool in)\n {\n   return (tune_info->memory_cost\n \t  + memory_move_secondary_cost (mode, rclass, in));"}, {"sha": "256198417172a5befaa588e5246b9a76c8891aa6", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -22,7 +22,7 @@ const char *    rl78_addsi3_internal (rtx *, unsigned int);\n void\t\trl78_emit_eh_epilogue (rtx);\n void\t\trl78_expand_compare (rtx *);\n void\t\trl78_expand_movsi (rtx *);\n-void\t\trl78_split_movsi (rtx *, enum machine_mode);\n+void\t\trl78_split_movsi (rtx *, machine_mode);\n int\t\trl78_force_nonfar_2 (rtx *, rtx (*gen)(rtx,rtx));\n int\t\trl78_force_nonfar_3 (rtx *, rtx (*gen)(rtx,rtx,rtx));\n void\t\trl78_expand_eh_epilogue (rtx);"}, {"sha": "460775cb995902ac2202c88947fd953537a44b11", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -539,7 +539,7 @@ rl78_expand_movsi (rtx *operands)\n \n /* Generate code to move an SImode value.  */\n void\n-rl78_split_movsi (rtx *operands, enum machine_mode omode)\n+rl78_split_movsi (rtx *operands, machine_mode omode)\n {\n   rtx op00, op02, op10, op12;\n \n@@ -997,7 +997,7 @@ rl78_hl_b_c_addr_p (rtx op)\n #undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n \n-static enum machine_mode\n+static machine_mode\n rl78_addr_space_address_mode (addr_space_t addrspace)\n {\n   switch (addrspace)"}, {"sha": "29a8ef90ee6c4f538a802d35b153d4b4dbfea93c", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -6603,8 +6603,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n     if (fcode == P6_OV_BUILTIN_CMPB)\n       {\n \tint overloaded_code;\n-\tint arg1_mode = TYPE_MODE (types[0]);\n-\tint arg2_mode = TYPE_MODE (types[1]);\n+\tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n+\tmachine_mode arg2_mode = TYPE_MODE (types[1]);\n \n \tif (nargs != 2)\n \t  {"}, {"sha": "63a6c80b2a49114c9c679e0ce2181854e71cabc5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -3564,12 +3564,12 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  CODE_FOR_fusion_gpr_di_df_store },\n       };\n \n-      enum machine_mode cur_pmode = Pmode;\n+      machine_mode cur_pmode = Pmode;\n       size_t i;\n \n       for (i = 0; i < ARRAY_SIZE (addis_insns); i++)\n \t{\n-\t  enum machine_mode xmode = addis_insns[i].mode;\n+\t  machine_mode xmode = addis_insns[i].mode;\n \t  enum rs6000_reload_reg_type rtype = addis_insns[i].rtype;\n \n \t  if (addis_insns[i].pmode != cur_pmode)\n@@ -10191,7 +10191,7 @@ rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)\n  \n static int\n rs6000_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n-                            enum machine_mode mode)\n+                            machine_mode mode)\n {\n   switch (rs6000_cpu)\n     {\n@@ -22309,8 +22309,8 @@ rs6000_invalid_binary_op (int op ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type1,\n \t\t\t  const_tree type2)\n {\n-  enum machine_mode mode1 = TYPE_MODE (type1);\n-  enum machine_mode mode2 = TYPE_MODE (type2);\n+  machine_mode mode1 = TYPE_MODE (type1);\n+  machine_mode mode2 = TYPE_MODE (type2);\n \n   /* For complex modes, use the inner type.  */\n   if (COMPLEX_MODE_P (mode1))\n@@ -38682,7 +38682,7 @@ fusion_p9_p (rtx addis_reg,\t\t/* register set via addis.  */\n \t     rtx src)\t\t\t/* source (register or memory).  */\n {\n   rtx addr, mem, offset;\n-  enum machine_mode mode = GET_MODE (src);\n+  machine_mode mode = GET_MODE (src);\n \n   /* Validate arguments.  */\n   if (!base_reg_operand (addis_reg, GET_MODE (addis_reg)))\n@@ -38856,7 +38856,7 @@ expand_fusion_p9_store (rtx *operands)\n const char *\n emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n {\n-  enum machine_mode mode = GET_MODE (reg);\n+  machine_mode mode = GET_MODE (reg);\n   rtx hi;\n   rtx lo;\n   rtx addr;\n@@ -38949,7 +38949,7 @@ emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n const char *\n emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n {\n-  enum machine_mode mode = GET_MODE (reg);\n+  machine_mode mode = GET_MODE (reg);\n   rtx hi;\n   rtx lo;\n   rtx addr;"}, {"sha": "d4aa17678baf973ddfe2def8d305599d33ebbc06", "filename": "gcc/config/visium/visium-protos.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -32,28 +32,28 @@ extern void visium_profile_hook (void);\n extern int visium_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int visium_initial_elimination_offset (int from, int to);\n #ifdef RTX_CODE\n-extern void prepare_move_operands (rtx *, enum machine_mode);\n-extern bool ok_for_simple_move_operands (rtx *, enum machine_mode);\n-extern bool ok_for_simple_move_strict_operands (rtx *, enum machine_mode);\n-extern bool ok_for_simple_arith_logic_operands (rtx *, enum machine_mode);\n+extern void prepare_move_operands (rtx *, machine_mode);\n+extern bool ok_for_simple_move_operands (rtx *, machine_mode);\n+extern bool ok_for_simple_move_strict_operands (rtx *, machine_mode);\n+extern bool ok_for_simple_arith_logic_operands (rtx *, machine_mode);\n extern void visium_initialize_trampoline (rtx, rtx, rtx);\n extern int empty_delay_slot (rtx_insn *);\n extern int gr5_hazard_bypass_p (rtx_insn *, rtx_insn *);\n extern rtx visium_return_addr_rtx (int, rtx);\n extern rtx visium_eh_return_handler_rtx (void);\n extern rtx visium_dynamic_chain_address (rtx);\n-extern rtx visium_legitimize_reload_address (rtx, enum machine_mode, int, int,\n+extern rtx visium_legitimize_reload_address (rtx, machine_mode, int, int,\n \t\t\t\t\t     int);\n-extern enum machine_mode visium_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern machine_mode visium_select_cc_mode (enum rtx_code, rtx, rtx);\n extern void visium_split_cbranch (enum rtx_code, rtx, rtx, rtx);\n extern const char *output_ubranch (rtx, rtx_insn *);\n-extern const char *output_cbranch (rtx, enum rtx_code, enum machine_mode, int,\n+extern const char *output_cbranch (rtx, enum rtx_code, machine_mode, int,\n \t\t\t\t   rtx_insn *);\n-extern void visium_split_double_move (rtx *, enum machine_mode);\n+extern void visium_split_double_move (rtx *, machine_mode);\n extern void visium_split_double_add (enum rtx_code, rtx, rtx, rtx);\n-extern void visium_expand_copysign (rtx *, enum machine_mode);\n-extern void visium_expand_int_cstore (rtx *, enum machine_mode);\n-extern void visium_expand_fp_cstore (rtx *, enum machine_mode);\n+extern void visium_expand_copysign (rtx *, machine_mode);\n+extern void visium_expand_int_cstore (rtx *, machine_mode);\n+extern void visium_expand_fp_cstore (rtx *, machine_mode);\n extern void visium_split_cstore (enum rtx_code, rtx, rtx,\n \t\t\t\t enum rtx_code, rtx, rtx);\n extern int visium_expand_block_move (rtx *);"}, {"sha": "e5d843e8d4c1e2bbac5d580546e78d9244103509", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -154,24 +154,24 @@ static struct machine_function *visium_init_machine_status (void);\n \n /* Target hooks and TARGET_INITIALIZER  */\n \n-static bool visium_pass_by_reference (cumulative_args_t, enum machine_mode,\n+static bool visium_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t      const_tree, bool);\n \n-static rtx visium_function_arg (cumulative_args_t, enum machine_mode,\n+static rtx visium_function_arg (cumulative_args_t, machine_mode,\n \t\t\t\tconst_tree, bool);\n \n-static void visium_function_arg_advance (cumulative_args_t, enum machine_mode,\n+static void visium_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t\t const_tree, bool);\n \n static bool visium_return_in_memory (const_tree, const_tree fntype);\n \n static rtx visium_function_value (const_tree, const_tree fn_decl_or_type,\n \t\t\t\t  bool);\n \n-static rtx visium_libcall_value (enum machine_mode, const_rtx);\n+static rtx visium_libcall_value (machine_mode, const_rtx);\n \n static void visium_setup_incoming_varargs (cumulative_args_t,\n-\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t   machine_mode,\n \t\t\t\t\t   tree, int *, int);\n \n static void visium_va_start (tree valist, rtx nextarg);\n@@ -188,20 +188,20 @@ static rtx_insn *visium_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n \t\t\t\t       vec<const char *> &,\n \t\t\t\t       vec<rtx> &, HARD_REG_SET &);\n \n-static bool visium_legitimate_constant_p (enum machine_mode, rtx);\n+static bool visium_legitimate_constant_p (machine_mode, rtx);\n \n-static bool visium_legitimate_address_p (enum machine_mode, rtx, bool);\n+static bool visium_legitimate_address_p (machine_mode, rtx, bool);\n \n static bool visium_print_operand_punct_valid_p (unsigned char);\n static void visium_print_operand (FILE *, rtx, int);\n static void visium_print_operand_address (FILE *, machine_mode, rtx);\n \n static void visium_conditional_register_usage (void);\n \n-static rtx visium_legitimize_address (rtx, rtx, enum machine_mode);\n+static rtx visium_legitimize_address (rtx, rtx, machine_mode);\n \n static reg_class_t visium_secondary_reload (bool, rtx, reg_class_t,\n-\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t    machine_mode,\n \t\t\t\t\t    secondary_reload_info *);\n \n static bool visium_class_likely_spilled_p (reg_class_t);\n@@ -214,10 +214,10 @@ static int visium_adjust_priority (rtx_insn *, int);\n \n static int visium_adjust_cost (rtx_insn *, int, rtx_insn *, int, unsigned int);\n \n-static int visium_register_move_cost (enum machine_mode, reg_class_t,\n+static int visium_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t      reg_class_t);\n \n-static int visium_memory_move_cost (enum machine_mode, reg_class_t, bool);\n+static int visium_memory_move_cost (machine_mode, reg_class_t, bool);\n \n static bool visium_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n \n@@ -786,7 +786,7 @@ visium_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n    X is guaranteed to satisfy the CONSTANT_P predicate.  */\n \n static bool\n-visium_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+visium_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t      rtx x ATTRIBUTE_UNUSED)\n {\n   return true;\n@@ -849,7 +849,7 @@ visium_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n /* Prepare operands for a move define_expand in MODE.  */\n \n void\n-prepare_move_operands (rtx *operands, enum machine_mode mode)\n+prepare_move_operands (rtx *operands, machine_mode mode)\n {\n   /* If the output is not a register, the input must be.  */\n   if (GET_CODE (operands[0]) == MEM && !reg_or_0_operand (operands[1], mode))\n@@ -859,7 +859,7 @@ prepare_move_operands (rtx *operands, enum machine_mode mode)\n /* Return true if the operands are valid for a simple move insn.  */\n \n bool\n-ok_for_simple_move_operands (rtx *operands, enum machine_mode mode)\n+ok_for_simple_move_operands (rtx *operands, machine_mode mode)\n {\n   /* One of the operands must be a register.  */\n   if (!register_operand (operands[0], mode)\n@@ -878,7 +878,7 @@ ok_for_simple_move_operands (rtx *operands, enum machine_mode mode)\n /* Return true if the operands are valid for a simple move strict insn.  */\n \n bool\n-ok_for_simple_move_strict_operands (rtx *operands, enum machine_mode mode)\n+ok_for_simple_move_strict_operands (rtx *operands, machine_mode mode)\n {\n   /* Once the flags are exposed, no simple moves between integer registers.\n      Note that, in QImode only, a zero source counts as an integer register\n@@ -896,7 +896,7 @@ ok_for_simple_move_strict_operands (rtx *operands, enum machine_mode mode)\n    insn.  */\n \n bool\n-ok_for_simple_arith_logic_operands (rtx *, enum machine_mode)\n+ok_for_simple_arith_logic_operands (rtx *, machine_mode)\n {\n   /* Once the flags are exposed, no simple arithmetic or logical operations\n      between integer registers.  */\n@@ -1244,7 +1244,7 @@ visium_reorg (void)\n \n static bool\n visium_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type,\n \t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n@@ -1265,7 +1265,7 @@ visium_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n    in general registers.  */\n \n static rtx\n-visium_function_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n+visium_function_arg (cumulative_args_t pcum_v, machine_mode mode,\n \t\t     const_tree type ATTRIBUTE_UNUSED,\n \t\t     bool named ATTRIBUTE_UNUSED)\n {\n@@ -1303,7 +1303,7 @@ visium_function_arg (cumulative_args_t pcum_v, enum machine_mode mode,\n \n static void\n visium_function_arg_advance (cumulative_args_t pcum_v,\n-\t\t\t     enum machine_mode mode,\n+\t\t\t     machine_mode mode,\n \t\t\t     const_tree type ATTRIBUTE_UNUSED,\n \t\t\t     bool named)\n {\n@@ -1355,7 +1355,7 @@ visium_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n /* Define how scalar values are returned.  */\n \n static rtx\n-visium_function_value_1 (enum machine_mode mode)\n+visium_function_value_1 (machine_mode mode)\n {\n   /* Scalar or complex single precision floating point values\n      are returned in floating register f1.  */\n@@ -1385,7 +1385,7 @@ visium_function_value (const_tree ret_type,\n    be returned.  */\n \n static rtx\n-visium_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+visium_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return visium_function_value_1 (mode);\n }\n@@ -1395,7 +1395,7 @@ visium_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n \n static void\n visium_setup_incoming_varargs (cumulative_args_t pcum_v,\n-\t\t\t       enum machine_mode mode,\n+\t\t\t       machine_mode mode,\n \t\t\t       tree type,\n \t\t\t       int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t       int no_rtl)\n@@ -1711,7 +1711,7 @@ visium_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n    address of a memory access in mode MODE.  */\n \n static bool\n-rtx_ok_for_offset_p (enum machine_mode mode, rtx op)\n+rtx_ok_for_offset_p (machine_mode mode, rtx op)\n {\n   if (!CONST_INT_P (op) || INTVAL (op) < 0)\n     return false;\n@@ -1759,7 +1759,7 @@ rtx_ok_for_offset_p (enum machine_mode mode, rtx op)\n    kind of register is required.  */\n \n static bool\n-visium_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+visium_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n   rtx base;\n   unsigned int regno;\n@@ -1832,7 +1832,7 @@ visium_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \n static rtx\n visium_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode)\n+\t\t\t   machine_mode mode)\n {\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n@@ -1866,7 +1866,7 @@ visium_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n    that need reloading are indicated by calling push_reload.  */\n \n rtx\n-visium_legitimize_reload_address (rtx x, enum machine_mode mode, int opnum,\n+visium_legitimize_reload_address (rtx x, machine_mode mode, int opnum,\n \t\t\t\t  int type, int ind ATTRIBUTE_UNUSED)\n {\n   rtx newrtx, tem = NULL_RTX;\n@@ -1915,7 +1915,7 @@ visium_legitimize_reload_address (rtx x, enum machine_mode mode, int opnum,\n    relative to that.  */\n \n static int\n-visium_register_move_cost (enum machine_mode mode, reg_class_t from,\n+visium_register_move_cost (machine_mode mode, reg_class_t from,\n \t\t\t   reg_class_t to)\n {\n   const int numwords = (GET_MODE_SIZE (mode) <= UNITS_PER_WORD) ? 1 : 2;\n@@ -1934,7 +1934,7 @@ visium_register_move_cost (enum machine_mode mode, reg_class_t from,\n    visium_register_move_cost.  */\n \n static int\n-visium_memory_move_cost (enum machine_mode mode,\n+visium_memory_move_cost (machine_mode mode,\n \t\t\t reg_class_t to ATTRIBUTE_UNUSED,\n \t\t\t bool in)\n {\n@@ -2042,7 +2042,7 @@ visium_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n /* Split a double move of OPERANDS in MODE.  */\n \n void\n-visium_split_double_move (rtx *operands, enum machine_mode mode)\n+visium_split_double_move (rtx *operands, machine_mode mode)\n {\n   bool swap = false;\n \n@@ -2152,7 +2152,7 @@ visium_split_double_add (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n /* Expand a copysign of OPERANDS in MODE.  */\n \n void\n-visium_expand_copysign (rtx *operands, enum machine_mode mode)\n+visium_expand_copysign (rtx *operands, machine_mode mode)\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -2206,7 +2206,7 @@ visium_expand_copysign (rtx *operands, enum machine_mode mode)\n    generated code.  */\n \n void\n-visium_expand_int_cstore (rtx *operands, enum machine_mode mode)\n+visium_expand_int_cstore (rtx *operands, machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n   rtx op0 = operands[0], op1 = operands[2], op2 = operands[3], sltu;\n@@ -2265,7 +2265,7 @@ visium_expand_int_cstore (rtx *operands, enum machine_mode mode)\n \n void\n visium_expand_fp_cstore (rtx *operands,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n   rtx op0 = operands[0], op1 = operands[2], op2 = operands[3], slt;\n@@ -2314,7 +2314,7 @@ void\n visium_split_cstore (enum rtx_code op_code, rtx op0, rtx op1,\n \t\t     enum rtx_code code, rtx op2, rtx op3)\n {\n-  enum machine_mode cc_mode = visium_select_cc_mode (code, op2, op3);\n+  machine_mode cc_mode = visium_select_cc_mode (code, op2, op3);\n \n   /* If a FP cstore was reversed, then it was originally UNGE/UNLE.  */\n   if (cc_mode == CCFPEmode && (op_code == NEG || op_code == MINUS))\n@@ -2792,7 +2792,7 @@ visium_init_expanders (void)\n /* Given a comparison code (EQ, NE, etc.) and the operands of a COMPARE,\n    return the mode to be used for the comparison.  */\n \n-enum machine_mode\n+machine_mode\n visium_select_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n {\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n@@ -2896,7 +2896,7 @@ visium_select_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n void\n visium_split_cbranch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n {\n-  enum machine_mode cc_mode = visium_select_cc_mode (code, op0, op1);\n+  machine_mode cc_mode = visium_select_cc_mode (code, op0, op1);\n   rtx flags = gen_rtx_REG (cc_mode, FLAGS_REGNUM);\n \n   rtx x = gen_rtx_COMPARE (cc_mode, op0, op1);\n@@ -3091,7 +3091,7 @@ output_ubranch (rtx label, rtx_insn *insn)\n    should reverse the sense of the comparison.  INSN is the instruction.  */\n \n const char *\n-output_cbranch (rtx label, enum rtx_code code, enum machine_mode cc_mode,\n+output_cbranch (rtx label, enum rtx_code code, machine_mode cc_mode,\n \t\tint reversed, rtx_insn *insn)\n {\n   const char *cond;\n@@ -3299,7 +3299,7 @@ visium_print_operand (FILE *file, rtx op, int letter)\n    whose address is ADDR.  */\n \n static void\n-visium_print_operand_address (FILE *file, enum machine_mode mode, rtx addr)\n+visium_print_operand_address (FILE *file, machine_mode mode, rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -4180,7 +4180,7 @@ visium_can_use_return_insn_p (void)\n static reg_class_t\n visium_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t reg_class_t rclass,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t secondary_reload_info *sri ATTRIBUTE_UNUSED)\n {\n   int regno = true_regnum (x);"}, {"sha": "795e49246af54e1353cf02983e5a262396eaf2ad", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -5172,7 +5172,7 @@ returns bounds for returned pointers.  Arguments meaning is similar to\n @code{TARGET_FUNCTION_VALUE}.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARG_BOUNDS (cumulative_args_t @var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n+@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARG_BOUNDS (cumulative_args_t @var{args_so_far}, machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n Use it to store bounds for anonymous register arguments stored\n into the stack.  Arguments meaning is similar to\n @code{TARGET_SETUP_INCOMING_VARARGS}.\n@@ -11346,7 +11346,7 @@ returns upper bound of bounds @var{b}.\n @deftypefn {Target Hook} tree TARGET_CHKP_BOUND_TYPE (void)\n Return type to be used for bounds\n @end deftypefn\n-@deftypefn {Target Hook} {enum machine_mode} TARGET_CHKP_BOUND_MODE (void)\n+@deftypefn {Target Hook} machine_mode TARGET_CHKP_BOUND_MODE (void)\n Return mode to be used for bounds.\n @end deftypefn\n @deftypefn {Target Hook} tree TARGET_CHKP_MAKE_BOUNDS_CONSTANT (HOST_WIDE_INT @var{lb}, HOST_WIDE_INT @var{ub})"}, {"sha": "9026472724c4086bd3771538fcbe07f0afb848e1", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -363,9 +363,9 @@ check_reverse_float_storage_order_support (void)\n    useful if X is a CONST_INT.  */\n \n rtx\n-flip_storage_order (enum machine_mode mode, rtx x)\n+flip_storage_order (machine_mode mode, rtx x)\n {\n-  enum machine_mode int_mode;\n+  machine_mode int_mode;\n   rtx result;\n \n   if (mode == QImode)"}, {"sha": "985becb22c1b059eaa21fe02d7da505fd263f82f", "filename": "gcc/expmed.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -679,17 +679,17 @@ convert_cost (machine_mode to_mode, machine_mode from_mode,\n \n extern int mult_by_coeff_cost (HOST_WIDE_INT, machine_mode, bool);\n extern rtx emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n-\t\t\tenum machine_mode mode, enum machine_mode compare_mode,\n+\t\t\tmachine_mode mode, machine_mode compare_mode,\n \t\t\tint unsignedp, rtx x, rtx y, int normalizep,\n-\t\t\tenum machine_mode target_mode);\n+\t\t\tmachine_mode target_mode);\n \n /* Arguments MODE, RTX: return an rtx for the negation of that value.\n    May emit insns.  */\n extern rtx negate_rtx (machine_mode, rtx);\n \n /* Arguments MODE, RTX: return an rtx for the flipping of that value.\n    May emit insns.  */\n-extern rtx flip_storage_order (enum machine_mode, rtx);\n+extern rtx flip_storage_order (machine_mode, rtx);\n \n /* Expand a logical AND operation.  */\n extern rtx expand_and (machine_mode, rtx, rtx, rtx);"}, {"sha": "966405038d19950bce41d5d0dd82f94a11200d1e", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -740,9 +740,9 @@ validate_pattern (rtx pattern, md_rtx_info *info, rtx set, int set_code)\n     case VEC_SELECT:\n       if (GET_MODE (pattern) != VOIDmode)\n \t{\n-\t  enum machine_mode mode = GET_MODE (pattern);\n-\t  enum machine_mode imode = GET_MODE (XEXP (pattern, 0));\n-\t  enum machine_mode emode\n+\t  machine_mode mode = GET_MODE (pattern);\n+\t  machine_mode imode = GET_MODE (XEXP (pattern, 0));\n+\t  machine_mode emode\n \t    = VECTOR_MODE_P (mode) ? GET_MODE_INNER (mode) : mode;\n \t  if (GET_CODE (XEXP (pattern, 1)) == PARALLEL)\n \t    {"}, {"sha": "6ec8c348eb453393d2c30a6221d8ceb5a1c0afe1", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -1929,7 +1929,7 @@ gen_hsa_addr (tree ref, hsa_bb *hbb, HOST_WIDE_INT *output_bitsize = NULL,\n \n   if (handled_component_p (ref))\n     {\n-      enum machine_mode mode;\n+      machine_mode mode;\n       int unsignedp, volatilep, preversep;\n \n       ref = get_inner_reference (ref, &bitsize, &bitpos, &varoffset, &mode,"}, {"sha": "d8dadcaa70adae704d2722c69e8abced32c1ec53", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -2104,7 +2104,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n \t  /* The infinity precision result will always fit into result.  */\n \t  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \t  write_complex_part (target, const0_rtx, true);\n-\t  enum machine_mode mode = TYPE_MODE (type);\n+\t  machine_mode mode = TYPE_MODE (type);\n \t  struct separate_ops ops;\n \t  ops.code = code;\n \t  ops.type = type;\n@@ -2157,7 +2157,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n       if (orig_precres == precres && precop <= BITS_PER_WORD)\n \t{\n \t  int p = MAX (min_precision, precop);\n-\t  enum machine_mode m = smallest_mode_for_size (p, MODE_INT);\n+\t  machine_mode m = smallest_mode_for_size (p, MODE_INT);\n \t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n \t\t\t\t\t\t\tuns0_p && uns1_p\n \t\t\t\t\t\t\t&& unsr_p);\n@@ -2199,7 +2199,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n       if (orig_precres == precres)\n \t{\n \t  int p = MAX (prec0, prec1);\n-\t  enum machine_mode m = smallest_mode_for_size (p, MODE_INT);\n+\t  machine_mode m = smallest_mode_for_size (p, MODE_INT);\n \t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n \t\t\t\t\t\t\tuns0_p && uns1_p\n \t\t\t\t\t\t\t&& unsr_p);"}, {"sha": "f08bf37b4c56f282e8d6abb5411a53740f8954b9", "filename": "gcc/ira-color.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -2745,7 +2745,7 @@ static int\n allocno_copy_cost_saving (ira_allocno_t allocno, int hard_regno)\n {\n   int cost = 0;\n-  enum machine_mode allocno_mode = ALLOCNO_MODE (allocno);\n+  machine_mode allocno_mode = ALLOCNO_MODE (allocno);\n   enum reg_class rclass;\n   ira_copy_t cp, next_cp;\n "}, {"sha": "8fd2fd43dc07ae0be6edbd11b9816252d4ac5d38", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -1,3 +1,10 @@\n+2017-07-05  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* dummy-frontend.c (jit_langhook_type_for_mode): Remove \"enum\" before\n+\t\"machine_mode\".\n+\n 2017-04-24  David Malcolm  <dmalcolm@redhat.com>\n \n \t* docs/cp/topics/types.rst (gccjit::type::get_const): Remove"}, {"sha": "d7d21728358af8d1d28454138444e39c740c6244", "filename": "gcc/jit/dummy-frontend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fjit%2Fdummy-frontend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fjit%2Fdummy-frontend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdummy-frontend.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -163,7 +163,7 @@ jit_langhook_parse_file (void)\n }\n \n static tree\n-jit_langhook_type_for_mode (enum machine_mode mode, int unsignedp)\n+jit_langhook_type_for_mode (machine_mode mode, int unsignedp)\n {\n   if (mode == TYPE_MODE (float_type_node))\n     return float_type_node;"}, {"sha": "42556d3a65ec0686cf6f029bcf2fe10eb0678f99", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -585,7 +585,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t}\n       else\n \t{\n-\t  enum machine_mode biggest_conflict_mode\n+\t  machine_mode biggest_conflict_mode\n \t    = lra_reg_info[conflict_regno].biggest_mode;\n \t  int biggest_conflict_nregs\n \t    = hard_regno_nregs[conflict_hr][biggest_conflict_mode];"}, {"sha": "b1d864fb9742020c0bc7256d47a5add66c2cd1a0", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -1841,7 +1841,7 @@ reg_in_class_p (rtx reg, enum reg_class cl)\n static bool\n prohibited_class_reg_set_mode_p (enum reg_class rclass,\n \t\t\t\t HARD_REG_SET &set,\n-\t\t\t\t enum machine_mode mode)\n+\t\t\t\t machine_mode mode)\n {\n   HARD_REG_SET temp;\n   \n@@ -5725,7 +5725,7 @@ process_invariant_for_inheritance (rtx dst_reg, rtx invariant_rtx)\n   int insn_regno;\n   bool succ_p = false;\n   int dst_regno = REGNO (dst_reg);\n-  enum machine_mode dst_mode = GET_MODE (dst_reg);\n+  machine_mode dst_mode = GET_MODE (dst_reg);\n   enum reg_class cl = lra_get_allocno_class (dst_regno), insn_reg_cl;\n \n   invariant_ptr = insert_invariant (invariant_rtx);"}, {"sha": "900e4d462b9573cc046ca24c5774547775f239f0", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -279,7 +279,7 @@ static rtx\n move_plus_up (rtx x)\n {\n   rtx subreg_reg;\n-  enum machine_mode x_mode, subreg_reg_mode;\n+  machine_mode x_mode, subreg_reg_mode;\n   \n   if (GET_CODE (x) != SUBREG || !subreg_lowpart_p (x))\n     return x;"}, {"sha": "bf3fc53b07a6779f17e64102bf24937fb9be1f0e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -5056,7 +5056,7 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n \n \t/* Determine position in reduction buffer, which may be used\n \t   by target.  */\n-\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (var));\n+\tmachine_mode mode = TYPE_MODE (TREE_TYPE (var));\n \tunsigned align = GET_MODE_ALIGNMENT (mode) /  BITS_PER_UNIT;\n \toffset = (offset + align - 1) & ~(align - 1);\n \ttree off = build_int_cst (sizetype, offset);"}, {"sha": "3bce329924fc30ee81d697bb25d34848ca68f06e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -6186,7 +6186,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n       unsigned int part_size, final_offset;\n       rtx part, res;\n \n-      enum machine_mode part_mode = GET_MODE (XEXP (op, 0));\n+      machine_mode part_mode = GET_MODE (XEXP (op, 0));\n       if (part_mode == VOIDmode)\n \tpart_mode = GET_MODE_INNER (GET_MODE (op));\n       part_size = GET_MODE_SIZE (part_mode);"}, {"sha": "bbd9c0151894ea43f8588b52297e21a1cb8576a0", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -2369,7 +2369,7 @@ DEFHOOK\n DEFHOOK\n (chkp_bound_mode,\n  \"Return mode to be used for bounds.\",\n- enum machine_mode, (void),\n+ machine_mode, (void),\n  default_chkp_bound_mode)\n \n DEFHOOK\n@@ -4370,7 +4370,7 @@ DEFHOOK\n  \"Use it to store bounds for anonymous register arguments stored\\n\\\n into the stack.  Arguments meaning is similar to\\n\\\n @code{TARGET_SETUP_INCOMING_VARARGS}.\",\n- void, (cumulative_args_t args_so_far, enum machine_mode mode, tree type,\n+ void, (cumulative_args_t args_so_far, machine_mode mode, tree type,\n \tint *pretend_args_size, int second_time),\n  default_setup_incoming_vararg_bounds)\n "}, {"sha": "940deec67f9aa2cf5f60024373b7be4fb34140c9", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -2009,7 +2009,7 @@ default_chkp_bound_type (void)\n   return res;\n }\n \n-enum machine_mode\n+machine_mode\n default_chkp_bound_mode (void)\n {\n   return VOIDmode;\n@@ -2047,7 +2047,7 @@ default_chkp_initialize_bounds (tree var ATTRIBUTE_UNUSED,\n \n void\n default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t      tree type ATTRIBUTE_UNUSED,\n \t\t\t\t      int *pretend_arg_size ATTRIBUTE_UNUSED,\n \t\t\t\t      int second_time ATTRIBUTE_UNUSED)"}, {"sha": "1ddb8891fe4a60249945651592ce4463e74714e0", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -243,14 +243,14 @@ extern void default_store_bounds_for_arg (rtx, rtx, rtx, rtx);\n extern rtx default_load_returned_bounds (rtx);\n extern void default_store_returned_bounds (rtx,rtx);\n extern tree default_chkp_bound_type (void);\n-extern enum machine_mode default_chkp_bound_mode (void);\n+extern machine_mode default_chkp_bound_mode (void);\n extern tree default_builtin_chkp_function (unsigned int);\n extern rtx default_chkp_function_value_bounds (const_tree, const_tree, bool);\n extern tree default_chkp_make_bounds_constant (HOST_WIDE_INT lb, HOST_WIDE_INT ub);\n extern int default_chkp_initialize_bounds (tree var, tree lb, tree ub,\n \t\t\t\t\t   tree *stmts);\n extern void default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  int *pretend_arg_size ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  int second_time ATTRIBUTE_UNUSED);"}, {"sha": "c59dce08f449d8f68e1a134a31f7849506c3a41e", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -3842,7 +3842,7 @@ static bool\n divmod_candidate_p (gassign *stmt)\n {\n   tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n-  enum machine_mode mode = TYPE_MODE (type);\n+  machine_mode mode = TYPE_MODE (type);\n   optab divmod_optab, div_optab;\n \n   if (TYPE_UNSIGNED (type))"}, {"sha": "8168f27080e59d8205e3bebeff325123ed89258b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -3623,7 +3623,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n /* Writes into SEL a mask for a vec_perm, equivalent to a vec_shr by OFFSET\n    vector elements (not bits) for a vector of mode MODE.  */\n static void\n-calc_vec_perm_mask_for_shift (enum machine_mode mode, unsigned int offset,\n+calc_vec_perm_mask_for_shift (machine_mode mode, unsigned int offset,\n \t\t\t      unsigned char *sel)\n {\n   unsigned int i, nelt = GET_MODE_NUNITS (mode);\n@@ -3636,7 +3636,7 @@ calc_vec_perm_mask_for_shift (enum machine_mode mode, unsigned int offset,\n    MODE.  This is the case if _either_ the platform handles vec_shr_optab, _or_\n    it supports vec_perm_const with masks for all necessary shift amounts.  */\n static bool\n-have_whole_vector_shift (enum machine_mode mode)\n+have_whole_vector_shift (machine_mode mode)\n {\n   if (optab_handler (vec_shr_optab, mode) != CODE_FOR_nothing)\n     return true;"}, {"sha": "90770a35af1adee8e14ef907efcc2b5339677753", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b8506a8ac0a98ad8d3ece50a6e585e9c72d226d3", "patch": "@@ -7007,9 +7007,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t to a larger load.  */\n \t      unsigned lsize\n \t\t= group_size * TYPE_PRECISION (TREE_TYPE (vectype));\n-\t      enum machine_mode elmode = mode_for_size (lsize, MODE_INT, 0);\n-\t      enum machine_mode vmode = mode_for_vector (elmode,\n-\t\t\t\t\t\t\t nunits / group_size);\n+\t      machine_mode elmode = mode_for_size (lsize, MODE_INT, 0);\n+\t      machine_mode vmode = mode_for_vector (elmode,\n+\t\t\t\t\t\t    nunits / group_size);\n \t      /* If we can't construct such a vector fall back to\n \t\t element loads of the original vector type.  */\n \t      if (VECTOR_MODE_P (vmode)"}]}