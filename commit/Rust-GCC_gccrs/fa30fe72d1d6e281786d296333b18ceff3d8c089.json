{"sha": "fa30fe72d1d6e281786d296333b18ceff3d8c089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEzMGZlNzJkMWQ2ZTI4MTc4NmQyOTYzMzNiMThjZWZmM2Q4YzA4OQ==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2003-12-09T04:31:53Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-12-09T04:31:53Z"}, "message": "algorithm, [...]: Remove trailing whitespace.\n\n\t* include/ext/algorithm, include/ext/debug_allocator.h,\n\tinclude/ext/enc_filebuf.h, include/ext/functional,\n\tinclude/ext/hash_fun.h, include/ext/hash_map, include/ext/hash_set,\n\tinclude/ext/hashtable.h, include/ext/iterator,\n\tinclude/ext/malloc_allocator.h, include/ext/memory,\n\tinclude/ext/mt_allocator.h, include/ext/numeric,\n\tinclude/ext/pod_char_traits.h, include/ext/pool_allocator.h,\n\tinclude/ext/rb_tree, include/ext/rope, include/ext/ropeimpl.h,\n\tinclude/ext/slist, include/ext/stdio_filebuf.h,\n\tinclude/ext/stdio_sync_filebuf.h: Remove trailing whitespace.\n\nFrom-SVN: r74464", "tree": {"sha": "e7baac8d46bd354909d55bcc6367f5ced6fd5f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7baac8d46bd354909d55bcc6367f5ced6fd5f03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa30fe72d1d6e281786d296333b18ceff3d8c089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa30fe72d1d6e281786d296333b18ceff3d8c089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa30fe72d1d6e281786d296333b18ceff3d8c089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa30fe72d1d6e281786d296333b18ceff3d8c089/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "526da49cc7dea9f6022612320eb980535b91eecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526da49cc7dea9f6022612320eb980535b91eecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/526da49cc7dea9f6022612320eb980535b91eecb"}], "stats": {"total": 937, "additions": 475, "deletions": 462}, "files": [{"sha": "ba57e35b8e8ffef0ebc5d706f52c8dc35a3e7e89", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -1,3 +1,16 @@\n+2003-12-09  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* include/ext/algorithm, include/ext/debug_allocator.h,\n+\tinclude/ext/enc_filebuf.h, include/ext/functional,\n+\tinclude/ext/hash_fun.h, include/ext/hash_map, include/ext/hash_set,\n+\tinclude/ext/hashtable.h, include/ext/iterator,\n+\tinclude/ext/malloc_allocator.h, include/ext/memory,\n+\tinclude/ext/mt_allocator.h, include/ext/numeric,\n+\tinclude/ext/pod_char_traits.h, include/ext/pool_allocator.h,\n+\tinclude/ext/rb_tree, include/ext/rope, include/ext/ropeimpl.h,\n+\tinclude/ext/slist, include/ext/stdio_filebuf.h,\n+\tinclude/ext/stdio_sync_filebuf.h: Remove trailing whitespace.\n+\n 2003-12-09  Bernardo Innocenti  <bernie@develer.com>\n \n \t* include/debug/bitset, include/debug/debug.h, include/debug/deque,"}, {"sha": "07ac4cbe4d31ee8bf25dfe600cd5d305bd5c27bb", "filename": "libstdc++-v3/include/ext/algorithm", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -160,11 +160,11 @@ namespace __gnu_cxx\n     const ptrdiff_t __len1 = __last1 - __first1;\n     const ptrdiff_t __len2 = __last2 - __first2;\n     const int __result = std::memcmp(__first1, __first2, min(__len1, __len2));\n-    return __result != 0 ? __result \n+    return __result != 0 ? __result\n \t\t\t : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));\n   }\n \n-  inline int \n+  inline int\n   __lexicographical_compare_3way(const char* __first1, const char* __last1,\n \t\t\t\t const char* __first2, const char* __last2)\n   {\n@@ -295,7 +295,7 @@ namespace __gnu_cxx\n \t   typename _RandomNumberGenerator>\n     _OutputIterator\n     random_sample_n(_ForwardIterator __first, _ForwardIterator __last,\n-                   _OutputIterator __out, const _Distance __n, \n+                   _OutputIterator __out, const _Distance __n,\n \t\t   _RandomNumberGenerator& __rand)\n     {\n       // concept requirements\n@@ -330,7 +330,7 @@ namespace __gnu_cxx\n     {\n       _Distance __m = 0;\n       _Distance __t = __n;\n-      for ( ; __first != __last && __m < __n; ++__m, ++__first) \n+      for ( ; __first != __last && __m < __n; ++__m, ++__first)\n \t__out[__m] = *__first;\n \n       while (__first != __last) {\n@@ -380,7 +380,7 @@ namespace __gnu_cxx\n   template<typename _InputIterator, typename _RandomAccessIterator>\n     inline _RandomAccessIterator\n     random_sample(_InputIterator __first, _InputIterator __last,\n-\t\t  _RandomAccessIterator __out_first, _RandomAccessIterator __out_last) \n+\t\t  _RandomAccessIterator __out_first, _RandomAccessIterator __out_last)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n@@ -398,12 +398,12 @@ namespace __gnu_cxx\n    *  @ingroup SGIextensions\n    *  @doctodo\n   */\n-  template<typename _InputIterator, typename _RandomAccessIterator, \n+  template<typename _InputIterator, typename _RandomAccessIterator,\n \t   typename _RandomNumberGenerator>\n     inline _RandomAccessIterator\n     random_sample(_InputIterator __first, _InputIterator __last,\n \t\t  _RandomAccessIterator __out_first, _RandomAccessIterator __out_last,\n-\t\t  _RandomNumberGenerator& __rand) \n+\t\t  _RandomNumberGenerator& __rand)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n@@ -416,7 +416,7 @@ namespace __gnu_cxx\n \t\t\t     __out_first, __rand,\n \t\t\t     __out_last - __out_first);\n     }\n-  \n+\n   /**\n    *  This is an SGI extension.\n    *  @ingroup SGIextensions\n@@ -448,7 +448,7 @@ namespace __gnu_cxx\n       // concept requirements\n       __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n-\t    typename iterator_traits<_RandomAccessIterator>::value_type, \n+\t    typename iterator_traits<_RandomAccessIterator>::value_type,\n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n@@ -498,7 +498,7 @@ namespace __gnu_cxx\n       // concept requirements\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n-\t    typename iterator_traits<_ForwardIterator>::value_type, \n+\t    typename iterator_traits<_ForwardIterator>::value_type,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n "}, {"sha": "7bab02ebb31b81d1382f790a6aa4d8369d19384f", "filename": "libstdc++-v3/include/ext/debug_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -41,7 +41,7 @@\n  */\n \n /** @file ext/debug_allocator.h\n- *  This file is a GNU extension to the Standard C++ Library. \n+ *  This file is a GNU extension to the Standard C++ Library.\n  *  You should only include this header if you are using GCC 3 or later.\n  */\n \n@@ -125,7 +125,7 @@ namespace std\n   /// Versions for the __allocator adaptor used with the predefined\n   /// \"SGI\" style allocators.\n   template<typename _Tp, typename _Tp1, typename _Alloc>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1, \n+    struct _Alloc_traits<_Tp, __allocator<_Tp1,\n \t\t\t\t\t  __gnu_cxx::__debug_alloc<_Alloc> > >\n     {\n       static const bool _S_instanceless = true;"}, {"sha": "80c3b5a15be0c2faf100d372e14436c9d4b75eec", "filename": "libstdc++-v3/include/ext/enc_filebuf.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fenc_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fenc_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fenc_filebuf.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -39,21 +39,21 @@ namespace __gnu_cxx\n     struct enc_char_traits: public std::char_traits<_CharT>\n     {\n       typedef std::__enc_traits\t\t\tstate_type;\n-      typedef typename std::fpos<state_type> \tpos_type;\n+      typedef typename std::fpos<state_type>\tpos_type;\n     };\n \n   template<typename _CharT>\n     class enc_filebuf\n     : public std::basic_filebuf<_CharT, enc_char_traits<_CharT> >\n     {\n     public:\n-      typedef enc_char_traits<_CharT> \t\ttraits_type;\n-      typedef typename traits_type::state_type \tstate_type;\n-      typedef typename traits_type::pos_type \tpos_type;\n-      \n+      typedef enc_char_traits<_CharT>\t\ttraits_type;\n+      typedef typename traits_type::state_type\tstate_type;\n+      typedef typename traits_type::pos_type\tpos_type;\n+\n       enc_filebuf(state_type& __state)\n       : std::basic_filebuf<_CharT, enc_char_traits<_CharT> >()\n-      { \n+      {\n \t// Set state type to something useful.\n \t// Something more than copyconstructible is needed here, so\n \t// require default and copy constructible + assignment operator."}, {"sha": "1a378173177a4d6da6198a0c21e96f343dd1d30b", "filename": "libstdc++-v3/include/ext/functional", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ffunctional?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -100,7 +100,7 @@ template <class _Tp> inline _Tp identity_element(std::multiplies<_Tp>) {\n  *  Calling @c operator() with a single argument @c x returns @c f(g(x)).\n  *  The function @c compose1 takes the two functions and constructs a\n  *  @c unary_compose variable for you.\n- *  \n+ *\n  *  @c binary_compose is constructed from three functors, @c f, @c g1,\n  *  and @c g2.  Its @c operator() returns @c f(g1(x),g2(x)).  The function\n  *  @compose2 takes f, g1, and g2, and constructs the @c binary_compose\n@@ -124,13 +124,13 @@ template <class _Tp> inline _Tp identity_element(std::multiplies<_Tp>) {\n template <class _Operation1, class _Operation2>\n class unary_compose\n   : public unary_function<typename _Operation2::argument_type,\n-\t\t       typename _Operation1::result_type> \n+\t\t       typename _Operation1::result_type>\n {\n protected:\n   _Operation1 _M_fn1;\n   _Operation2 _M_fn2;\n public:\n-  unary_compose(const _Operation1& __x, const _Operation2& __y) \n+  unary_compose(const _Operation1& __x, const _Operation2& __y)\n     : _M_fn1(__x), _M_fn2(__y) {}\n   typename _Operation1::result_type\n   operator()(const typename _Operation2::argument_type& __x) const {\n@@ -140,7 +140,7 @@ public:\n \n /// An \\link SGIextensions SGI extension \\endlink.\n template <class _Operation1, class _Operation2>\n-inline unary_compose<_Operation1,_Operation2> \n+inline unary_compose<_Operation1,_Operation2>\n compose1(const _Operation1& __fn1, const _Operation2& __fn2)\n {\n   return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);\n@@ -156,8 +156,8 @@ protected:\n   _Operation2 _M_fn2;\n   _Operation3 _M_fn3;\n public:\n-  binary_compose(const _Operation1& __x, const _Operation2& __y, \n-                 const _Operation3& __z) \n+  binary_compose(const _Operation1& __x, const _Operation2& __y,\n+                 const _Operation3& __z)\n     : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }\n   typename _Operation1::result_type\n   operator()(const typename _Operation2::argument_type& __x) const {\n@@ -167,8 +167,8 @@ public:\n \n /// An \\link SGIextensions SGI extension \\endlink.\n template <class _Operation1, class _Operation2, class _Operation3>\n-inline binary_compose<_Operation1, _Operation2, _Operation3> \n-compose2(const _Operation1& __fn1, const _Operation2& __fn2, \n+inline binary_compose<_Operation1, _Operation2, _Operation3>\n+compose2(const _Operation1& __fn1, const _Operation2& __fn2,\n          const _Operation3& __fn3)\n {\n   return binary_compose<_Operation1,_Operation2,_Operation3>\n@@ -220,7 +220,7 @@ struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {\n */\n \n /// An \\link SGIextensions SGI extension \\endlink.\n-template <class _Arg1, class _Arg2> \n+template <class _Arg1, class _Arg2>\n struct project1st : public _Project1st<_Arg1, _Arg2> {};\n \n /// An \\link SGIextensions SGI extension \\endlink.\n@@ -236,7 +236,7 @@ struct _Constant_void_fun {\n \n   _Constant_void_fun(const result_type& __v) : _M_val(__v) {}\n   const result_type& operator()() const { return _M_val; }\n-};  \n+};\n \n template <class _Result, class _Argument>\n struct _Constant_unary_fun {\n@@ -279,7 +279,7 @@ struct _Constant_binary_fun {\n template <class _Result>\n struct constant_void_fun : public _Constant_void_fun<_Result> {\n   constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}\n-};  \n+};\n \n /// An \\link SGIextensions SGI extension \\endlink.\n template <class _Result,\n@@ -317,7 +317,7 @@ inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)\n \n /// An \\link SGIextensions SGI extension \\endlink.\n template <class _Result>\n-inline constant_binary_fun<_Result,_Result,_Result> \n+inline constant_binary_fun<_Result,_Result,_Result>\n constant2(const _Result& __val)\n {\n   return constant_binary_fun<_Result,_Result,_Result>(__val);\n@@ -369,7 +369,7 @@ public:\n   subtractive_rng() { _M_initialize(161803398u); }\n };\n \n-// Mem_fun adaptor helper functions mem_fun1 and mem_fun1_ref, \n+// Mem_fun adaptor helper functions mem_fun1 and mem_fun1_ref,\n // provided for backward compatibility, they are no longer part of\n // the C++ standard.\n \n@@ -391,5 +391,5 @@ mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)\n   { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }\n } // namespace __gnu_cxx\n \n-#endif \n+#endif\n "}, {"sha": "27453a6b006b9a5267923d3d21f6c8fadcb4e505", "filename": "libstdc++-v3/include/ext/hash_fun.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_fun.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -70,53 +70,53 @@ namespace __gnu_cxx\n \n   template <class _Key> struct hash { };\n \n-  inline size_t \n+  inline size_t\n   __stl_hash_string(const char* __s)\n   {\n-    unsigned long __h = 0; \n+    unsigned long __h = 0;\n     for ( ; *__s; ++__s)\n-      __h = 5*__h + *__s;    \n+      __h = 5*__h + *__s;\n     return size_t(__h);\n   }\n \n   template<> struct hash<char*>\n   {\n-    size_t operator()(const char* __s) const \n+    size_t operator()(const char* __s) const\n     { return __stl_hash_string(__s); }\n   };\n-  \n+\n   template<> struct hash<const char*>\n   {\n-    size_t operator()(const char* __s) const \n+    size_t operator()(const char* __s) const\n     { return __stl_hash_string(__s); }\n   };\n \n-  template<> struct hash<char> \n+  template<> struct hash<char>\n   { size_t operator()(char __x) const { return __x; } };\n \n-  template<> struct hash<unsigned char> \n+  template<> struct hash<unsigned char>\n   { size_t operator()(unsigned char __x) const { return __x; } };\n \n-  template<> struct hash<signed char> \n+  template<> struct hash<signed char>\n   { size_t operator()(unsigned char __x) const { return __x; } };\n \n-  template<> struct hash<short> \n+  template<> struct hash<short>\n   { size_t operator()(short __x) const { return __x; } };\n \n-  template<> struct hash<unsigned short> \n+  template<> struct hash<unsigned short>\n   { size_t operator()(unsigned short __x) const { return __x; } };\n \n-  template<> struct hash<int> \n+  template<> struct hash<int>\n   { size_t operator()(int __x) const { return __x; } };\n \n-  template<> struct hash<unsigned int> \n+  template<> struct hash<unsigned int>\n   { size_t operator()(unsigned int __x) const { return __x; } };\n \n-  template<> struct hash<long> \n+  template<> struct hash<long>\n   { size_t operator()(long __x) const { return __x; } };\n \n-  template<> struct hash<unsigned long> \n+  template<> struct hash<unsigned long>\n   { size_t operator()(unsigned long __x) const { return __x; } };\n } // namespace __gnu_cxx\n \n-#endif \n+#endif"}, {"sha": "5032c7b3f21fbb414cb23294834fecdf43c78378", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -59,7 +59,7 @@\n  *  include this header if you are using GCC 3 or later.\n  */\n \n-#ifndef _HASH_MAP \n+#ifndef _HASH_MAP\n #define _HASH_MAP 1\n \n #include <ext/hashtable.h>\n@@ -102,7 +102,7 @@ public:\n   typedef typename _Ht::value_type value_type;\n   typedef typename _Ht::hasher hasher;\n   typedef typename _Ht::key_equal key_equal;\n-  \n+\n   typedef typename _Ht::size_type size_type;\n   typedef typename _Ht::difference_type difference_type;\n   typedef typename _Ht::pointer pointer;\n@@ -171,18 +171,18 @@ public:\n   void insert(_InputIterator __f, _InputIterator __l)\n     { _M_ht.insert_unique(__f,__l); }\n   pair<iterator,bool> insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_unique_noresize(__obj); }    \n+    { return _M_ht.insert_unique_noresize(__obj); }\n \n   iterator find(const key_type& __key) { return _M_ht.find(__key); }\n-  const_iterator find(const key_type& __key) const \n+  const_iterator find(const key_type& __key) const\n     { return _M_ht.find(__key); }\n \n   _Tp& operator[](const key_type& __key) {\n     return _M_ht.find_or_insert(value_type(__key, _Tp())).second;\n   }\n \n   size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n+\n   pair<iterator, iterator> equal_range(const key_type& __key)\n     { return _M_ht.equal_range(__key); }\n   pair<const_iterator, const_iterator>\n@@ -202,22 +202,22 @@ public:\n };\n \n template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline bool \n+inline bool\n operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n            const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n {\n   return __hm1._M_ht == __hm2._M_ht;\n }\n \n template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline bool \n+inline bool\n operator!=(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n            const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {\n   return !(__hm1 == __hm2);\n }\n \n template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline void \n+inline void\n swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n      hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n {\n@@ -233,7 +233,7 @@ template <class _Key, class _Tp,\n class hash_multimap;\n \n template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool \n+inline bool\n operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n            const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2);\n \n@@ -253,7 +253,7 @@ class hash_multimap\n \n private:\n   typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,\n-                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc> \n+                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc>\n           _Ht;\n   _Ht _M_ht;\n \n@@ -327,20 +327,20 @@ public:\n   const_iterator end() const { return _M_ht.end(); }\n \n public:\n-  iterator insert(const value_type& __obj) \n+  iterator insert(const value_type& __obj)\n     { return _M_ht.insert_equal(__obj); }\n   template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l) \n+  void insert(_InputIterator __f, _InputIterator __l)\n     { _M_ht.insert_equal(__f,__l); }\n   iterator insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_equal_noresize(__obj); }    \n+    { return _M_ht.insert_equal_noresize(__obj); }\n \n   iterator find(const key_type& __key) { return _M_ht.find(__key); }\n-  const_iterator find(const key_type& __key) const \n+  const_iterator find(const key_type& __key) const\n     { return _M_ht.find(__key); }\n \n   size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n+\n   pair<iterator, iterator> equal_range(const key_type& __key)\n     { return _M_ht.equal_range(__key); }\n   pair<const_iterator, const_iterator>\n@@ -361,22 +361,22 @@ public:\n };\n \n template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool \n+inline bool\n operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n            const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2)\n {\n   return __hm1._M_ht == __hm2._M_ht;\n }\n \n template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool \n+inline bool\n operator!=(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n            const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2) {\n   return !(__hm1 == __hm2);\n }\n \n template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline void \n+inline void\n swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n      hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n {\n@@ -407,7 +407,7 @@ public:\n   insert_iterator(_Container& __x, typename _Container::iterator)\n     : container(&__x) {}\n   insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n+  operator=(const typename _Container::value_type& __value) {\n     container->insert(__value);\n     return *this;\n   }\n@@ -434,7 +434,7 @@ public:\n   insert_iterator(_Container& __x, typename _Container::iterator)\n     : container(&__x) {}\n   insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n+  operator=(const typename _Container::value_type& __value) {\n     container->insert(__value);\n     return *this;\n   }"}, {"sha": "3151ee626f4e28aa5977b97a82ae2cb3523c8dc5", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -75,12 +75,12 @@ namespace __gnu_cxx\n   // Forward declaration of equality operator; needed for friend\n   // declaration.\n   template <class _Value, class _HashFcn  = hash<_Value>,\n-\t    class _EqualKey = equal_to<_Value>, \n+\t    class _EqualKey = equal_to<_Value>,\n \t    class _Alloc =  allocator<_Value> >\n   class hash_set;\n \n   template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-    inline bool \n+    inline bool\n     operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n \t       const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2);\n \n@@ -98,7 +98,7 @@ class hash_set\n   __glibcxx_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept)\n \n private:\n-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n+  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>,\n                     _EqualKey, _Alloc> _Ht;\n   _Ht _M_ht;\n \n@@ -161,7 +161,7 @@ public:\n   bool empty() const { return _M_ht.empty(); }\n   void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); }\n \n-  template <class _Val, class _HF, class _EqK, class _Al>  \n+  template <class _Val, class _HF, class _EqK, class _Al>\n   friend bool operator== (const hash_set<_Val, _HF, _EqK, _Al>&,\n                           const hash_set<_Val, _HF, _EqK, _Al>&);\n \n@@ -175,19 +175,19 @@ public:\n       return pair<iterator,bool>(__p.first, __p.second);\n     }\n   template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l) \n+  void insert(_InputIterator __f, _InputIterator __l)\n     { _M_ht.insert_unique(__f,__l); }\n   pair<iterator, bool> insert_noresize(const value_type& __obj)\n   {\n-    pair<typename _Ht::iterator, bool> __p = \n+    pair<typename _Ht::iterator, bool> __p =\n       _M_ht.insert_unique_noresize(__obj);\n     return pair<iterator, bool>(__p.first, __p.second);\n   }\n \n   iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n \n   size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n+\n   pair<iterator, iterator> equal_range(const key_type& __key) const\n     { return _M_ht.equal_range(__key); }\n \n@@ -205,22 +205,22 @@ public:\n };\n \n template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n+inline bool\n operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n            const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2)\n {\n   return __hs1._M_ht == __hs2._M_ht;\n }\n \n template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n+inline bool\n operator!=(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n            const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n   return !(__hs1 == __hs2);\n }\n \n template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline void \n+inline void\n swap(hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n      hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n {\n@@ -235,7 +235,7 @@ template <class _Value,\n class hash_multiset;\n \n template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n+inline bool\n operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n            const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2);\n \n@@ -254,7 +254,7 @@ class hash_multiset\n   __glibcxx_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept)\n \n private:\n-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n+  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>,\n                     _EqualKey, _Alloc> _Ht;\n   _Ht _M_ht;\n \n@@ -317,7 +317,7 @@ public:\n   bool empty() const { return _M_ht.empty(); }\n   void swap(hash_multiset& hs) { _M_ht.swap(hs._M_ht); }\n \n-  template <class _Val, class _HF, class _EqK, class _Al>  \n+  template <class _Val, class _HF, class _EqK, class _Al>\n   friend bool operator== (const hash_multiset<_Val, _HF, _EqK, _Al>&,\n                           const hash_multiset<_Val, _HF, _EqK, _Al>&);\n \n@@ -328,15 +328,15 @@ public:\n   iterator insert(const value_type& __obj)\n     { return _M_ht.insert_equal(__obj); }\n   template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l) \n+  void insert(_InputIterator __f, _InputIterator __l)\n     { _M_ht.insert_equal(__f,__l); }\n   iterator insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_equal_noresize(__obj); }    \n+    { return _M_ht.insert_equal_noresize(__obj); }\n \n   iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n \n   size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n+\n   pair<iterator, iterator> equal_range(const key_type& __key) const\n     { return _M_ht.equal_range(__key); }\n \n@@ -354,22 +354,22 @@ public:\n };\n \n template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n+inline bool\n operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n            const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n {\n   return __hs1._M_ht == __hs2._M_ht;\n }\n \n template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n+inline bool\n operator!=(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n            const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n   return !(__hs1 == __hs2);\n }\n \n template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline void \n+inline void\n swap(hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n      hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n   __hs1.swap(__hs2);\n@@ -399,7 +399,7 @@ public:\n   insert_iterator(_Container& __x, typename _Container::iterator)\n     : container(&__x) {}\n   insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n+  operator=(const typename _Container::value_type& __value) {\n     container->insert(__value);\n     return *this;\n   }\n@@ -426,7 +426,7 @@ public:\n   insert_iterator(_Container& __x, typename _Container::iterator)\n     : container(&__x) {}\n   insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n+  operator=(const typename _Container::value_type& __value) {\n     container->insert(__value);\n     return *this;\n   }\n@@ -436,4 +436,4 @@ public:\n };\n } // namespace std\n \n-#endif \n+#endif"}, {"sha": "4e5ea097ab789367710f886c0a29c19bda6466d3", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -90,7 +90,7 @@ struct _Hashtable_node\n {\n   _Hashtable_node* _M_next;\n   _Val _M_val;\n-};  \n+};\n \n template <class _Val, class _Key, class _HashFcn,\n           class _ExtractKey, class _EqualKey, class _Alloc = std::__alloc>\n@@ -109,10 +109,10 @@ template <class _Val, class _Key, class _HashFcn,\n struct _Hashtable_iterator {\n   typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n           _Hashtable;\n-  typedef _Hashtable_iterator<_Val, _Key, _HashFcn, \n+  typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n                               _ExtractKey, _EqualKey, _Alloc>\n           iterator;\n-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, \n+  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n                                     _ExtractKey, _EqualKey, _Alloc>\n           const_iterator;\n   typedef _Hashtable_node<_Val> _Node;\n@@ -127,7 +127,7 @@ struct _Hashtable_iterator {\n   _Node* _M_cur;\n   _Hashtable* _M_ht;\n \n-  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) \n+  _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n     : _M_cur(__n), _M_ht(__tab) {}\n   _Hashtable_iterator() {}\n   reference operator*() const { return _M_cur->_M_val; }\n@@ -146,10 +146,10 @@ template <class _Val, class _Key, class _HashFcn,\n struct _Hashtable_const_iterator {\n   typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n           _Hashtable;\n-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn, \n+  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n                               _ExtractKey,_EqualKey,_Alloc>\n           iterator;\n-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, \n+  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n                                     _ExtractKey, _EqualKey, _Alloc>\n           const_iterator;\n   typedef _Hashtable_node<_Val> _Node;\n@@ -167,15 +167,15 @@ struct _Hashtable_const_iterator {\n   _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n     : _M_cur(__n), _M_ht(__tab) {}\n   _Hashtable_const_iterator() {}\n-  _Hashtable_const_iterator(const iterator& __it) \n+  _Hashtable_const_iterator(const iterator& __it)\n     : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}\n   reference operator*() const { return _M_cur->_M_val; }\n   pointer operator->() const { return &(operator*()); }\n   const_iterator& operator++();\n   const_iterator operator++(int);\n-  bool operator==(const const_iterator& __it) const \n+  bool operator==(const const_iterator& __it) const\n     { return _M_cur == __it._M_cur; }\n-  bool operator!=(const const_iterator& __it) const \n+  bool operator!=(const const_iterator& __it) const\n     { return _M_cur != __it._M_cur; }\n };\n \n@@ -188,7 +188,7 @@ static const unsigned long __stl_prime_list[_S_num_primes] =\n   1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n   49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n   1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n-  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, \n+  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n   1610612741ul, 3221225473ul, 4294967291ul\n };\n \n@@ -337,7 +337,7 @@ class hashtable {\n   }\n \n   iterator begin()\n-  { \n+  {\n     for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n       if (_M_buckets[__n])\n         return iterator(_M_buckets[__n], this);\n@@ -364,7 +364,7 @@ class hashtable {\n   size_type bucket_count() const { return _M_buckets.size(); }\n \n   size_type max_bucket_count() const\n-    { return __stl_prime_list[(int)_S_num_primes - 1]; } \n+    { return __stl_prime_list[(int)_S_num_primes - 1]; }\n \n   size_type elems_in_bucket(size_type __bucket) const\n   {\n@@ -388,7 +388,7 @@ class hashtable {\n \n   pair<iterator, bool> insert_unique_noresize(const value_type& __obj);\n   iterator insert_equal_noresize(const value_type& __obj);\n- \n+\n   template <class _InputIterator>\n   void insert_unique(_InputIterator __f, _InputIterator __l)\n   {\n@@ -439,7 +439,7 @@ class hashtable {\n \n   reference find_or_insert(const value_type& __obj);\n \n-  iterator find(const key_type& __key) \n+  iterator find(const key_type& __key)\n   {\n     size_type __n = _M_bkt_num_key(__key);\n     _Node* __first;\n@@ -448,7 +448,7 @@ class hashtable {\n           __first = __first->_M_next)\n       {}\n     return iterator(__first, this);\n-  } \n+  }\n \n   const_iterator find(const key_type& __key) const\n   {\n@@ -459,7 +459,7 @@ class hashtable {\n           __first = __first->_M_next)\n       {}\n     return const_iterator(__first, this);\n-  } \n+  }\n \n   size_type count(const key_type& __key) const\n   {\n@@ -472,10 +472,10 @@ class hashtable {\n     return __result;\n   }\n \n-  pair<iterator, iterator> \n+  pair<iterator, iterator>\n   equal_range(const key_type& __key);\n \n-  pair<const_iterator, const_iterator> \n+  pair<const_iterator, const_iterator>\n   equal_range(const key_type& __key) const;\n \n   size_type erase(const key_type& __key);\n@@ -534,7 +534,7 @@ class hashtable {\n \t__throw_exception_again;\n       }\n   }\n-  \n+\n   void _M_delete_node(_Node* __n)\n   {\n     _Destroy(&__n->_M_val);\n@@ -548,7 +548,7 @@ class hashtable {\n \n };\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n           class _All>\n _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n@@ -563,7 +563,7 @@ _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n   return *this;\n }\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n           class _All>\n inline _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n@@ -573,7 +573,7 @@ _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n   return __tmp;\n }\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n           class _All>\n _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n@@ -588,7 +588,7 @@ _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n   return *this;\n }\n \n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n+template <class _Val, class _Key, class _HF, class _ExK, class _EqK,\n           class _All>\n inline _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n@@ -632,15 +632,15 @@ bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n     }\n   }\n   return true;\n-}  \n+}\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n                        const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {\n   return !(__ht1 == __ht2);\n }\n \n-template <class _Val, class _Key, class _HF, class _Extract, class _EqKey, \n+template <class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n           class _All>\n inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n                  hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2) {\n@@ -649,14 +649,14 @@ inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n \n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool> \n+pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool>\n hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   ::insert_unique_noresize(const value_type& __obj)\n {\n   const size_type __n = _M_bkt_num(__obj);\n   _Node* __first = _M_buckets[__n];\n \n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) \n+  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n     if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n       return pair<iterator, bool>(iterator(__cur, this), false);\n \n@@ -668,14 +668,14 @@ hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n }\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator \n+typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator\n hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   ::insert_equal_noresize(const value_type& __obj)\n {\n   const size_type __n = _M_bkt_num(__obj);\n   _Node* __first = _M_buckets[__n];\n \n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) \n+  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n     if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {\n       _Node* __tmp = _M_new_node(__obj);\n       __tmp->_M_next = __cur->_M_next;\n@@ -692,7 +692,7 @@ hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n }\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference \n+typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference\n hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)\n {\n   resize(_M_num_elements + 1);\n@@ -713,7 +713,7 @@ hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator,\n-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator> \n+     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator>\n hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)\n {\n   typedef pair<iterator, iterator> _Pii;\n@@ -734,16 +734,16 @@ hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)\n }\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator, \n-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator> \n+pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator,\n+     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator>\n hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   ::equal_range(const key_type& __key) const\n {\n   typedef pair<const_iterator, const_iterator> _Pii;\n   const size_type __n = _M_bkt_num_key(__key);\n \n   for (const _Node* __first = _M_buckets[__n] ;\n-       __first; \n+       __first;\n        __first = __first->_M_next) {\n     if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n       for (const _Node* __cur = __first->_M_next;\n@@ -763,7 +763,7 @@ hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n }\n \n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type \n+typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type\n hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)\n {\n   const size_type __n = _M_bkt_num_key(__key);\n@@ -831,9 +831,9 @@ template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   ::erase(iterator __first, iterator __last)\n {\n-  size_type __f_bucket = __first._M_cur ? \n+  size_type __f_bucket = __first._M_cur ?\n     _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();\n-  size_type __l_bucket = __last._M_cur ? \n+  size_type __l_bucket = __last._M_cur ?\n     _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();\n \n   if (__first._M_cur == __last._M_cur)\n@@ -886,7 +886,7 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n             _M_buckets[__bucket] = __first->_M_next;\n             __first->_M_next = __tmp[__new_bucket];\n             __tmp[__new_bucket] = __first;\n-            __first = _M_buckets[__bucket];          \n+            __first = _M_buckets[__bucket];\n           }\n         }\n         _M_buckets.swap(__tmp);\n@@ -914,8 +914,8 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n     _M_erase_bucket(__n, __last);\n   else {\n     _Node* __next;\n-    for (__next = __cur->_M_next; \n-         __next != __first; \n+    for (__next = __cur->_M_next;\n+         __next != __first;\n          __cur = __next, __next = __cur->_M_next)\n       ;\n     while (__next != __last) {\n@@ -956,7 +956,7 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()\n   _M_num_elements = 0;\n }\n \n-    \n+\n template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   ::_M_copy_from(const hashtable& __ht)\n@@ -971,8 +971,8 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n         _Node* __local_copy = _M_new_node(__cur->_M_val);\n         _M_buckets[__i] = __local_copy;\n \n-        for (_Node* __next = __cur->_M_next; \n-             __next; \n+        for (_Node* __next = __cur->_M_next;\n+             __next;\n              __cur = __next, __next = __cur->_M_next) {\n           __local_copy->_M_next = _M_new_node(__next->_M_val);\n           __local_copy = __local_copy->_M_next;"}, {"sha": "094313c76e47efc2c2cdecb9732365c5a84d316c", "filename": "libstdc++-v3/include/ext/iterator", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fiterator?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -72,7 +72,7 @@ namespace __gnu_cxx\n   // There are two signatures for distance.  In addition to the one\n   // taking two iterators and returning a result, there is another\n   // taking two iterators and a reference-to-result variable, and\n-  // returning nothing.  The latter seems to be an SGI extension.  \n+  // returning nothing.  The latter seems to be an SGI extension.\n   // -- pedwards\n   template<typename _InputIterator, typename _Distance>\n     inline void\n@@ -86,7 +86,7 @@ namespace __gnu_cxx\n \n   template<typename _RandomAccessIterator, typename _Distance>\n     inline void\n-    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, \n+    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t       _Distance& __n, std::random_access_iterator_tag)\n     {\n       // concept requirements\n@@ -109,5 +109,5 @@ namespace __gnu_cxx\n     }\n } // namespace __gnu_cxx\n \n-#endif \n+#endif\n "}, {"sha": "b0a837bfd212736b021f72111367f5b397150a6d", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -41,7 +41,7 @@\n  */\n \n /** @file ext/debug_allocator.h\n- *  This file is a GNU extension to the Standard C++ Library. \n+ *  This file is a GNU extension to the Standard C++ Library.\n  *  You should only include this header if you are using GCC 3 or later.\n  */\n \n@@ -149,7 +149,7 @@ namespace std\n   /// Versions for the __allocator adaptor used with the predefined\n   /// \"SGI\" style allocators.\n   template<typename _Tp, typename _Tp1, int __inst>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1, \n+    struct _Alloc_traits<_Tp, __allocator<_Tp1,\n \t\t\t\t\t  __gnu_cxx::__malloc_alloc<__inst> > >\n     {\n       static const bool _S_instanceless = true;"}, {"sha": "1d93f90ac7abf5431347fae31c81138fbbb0ad25", "filename": "libstdc++-v3/include/ext/memory", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -73,30 +73,30 @@ namespace __gnu_cxx\n   using std::pair;\n   using std::__iterator_category;\n   using std::_Temporary_buffer;\n-  \n+\n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     pair<_InputIter, _ForwardIter>\n     __uninitialized_copy_n(_InputIter __first, _Size __count,\n \t\t\t   _ForwardIter __result, std::input_iterator_tag)\n     {\n       _ForwardIter __cur = __result;\n-      try \n+      try\n \t{\n-\t  for ( ; __count > 0 ; --__count, ++__first, ++__cur) \n+\t  for ( ; __count > 0 ; --__count, ++__first, ++__cur)\n \t    std::_Construct(&*__cur, *__first);\n \t  return pair<_InputIter, _ForwardIter>(__first, __cur);\n \t}\n       catch(...)\n \t{\n \t  std::_Destroy(__result, __cur);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n-  \n+\n   template<typename _RandomAccessIter, typename _Size, typename _ForwardIter>\n     inline pair<_RandomAccessIter, _ForwardIter>\n     __uninitialized_copy_n(_RandomAccessIter __first, _Size __count,\n-\t\t\t   _ForwardIter __result, \n+\t\t\t   _ForwardIter __result,\n \t\t\t   std::random_access_iterator_tag)\n     {\n       _RandomAccessIter __last = __first + __count;\n@@ -108,7 +108,7 @@ namespace __gnu_cxx\n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     inline pair<_InputIter, _ForwardIter>\n     __uninitialized_copy_n(_InputIter __first, _Size __count,\n-\t\t\t _ForwardIter __result) \n+\t\t\t _ForwardIter __result)\n     {\n       return __uninitialized_copy_n(__first, __count, __result,\n \t\t\t\t    __iterator_category(__first));\n@@ -127,7 +127,7 @@ namespace __gnu_cxx\n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     inline pair<_InputIter, _ForwardIter>\n     uninitialized_copy_n(_InputIter __first, _Size __count,\n-\t\t\t _ForwardIter __result) \n+\t\t\t _ForwardIter __result)\n     {\n       return __uninitialized_copy_n(__first, __count, __result,\n \t\t\t\t    __iterator_category(__first));\n@@ -154,7 +154,7 @@ namespace __gnu_cxx\n    *\n    *  @ingroup SGIextensions\n   */\n-  template <class _ForwardIterator, class _Tp \n+  template <class _ForwardIterator, class _Tp\n \t      = typename std::iterator_traits<_ForwardIterator>::value_type >\n   struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>\n   {"}, {"sha": "42c804f610c328f71822f2e6e384f087c183026d", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -28,15 +28,15 @@\n // the GNU General Public License.\n \n /** @file ext/mt_allocator.h\n- *  This file is a GNU extension to the Standard C++ Library. \n+ *  This file is a GNU extension to the Standard C++ Library.\n  *  You should only include this header if you are using GCC 3 or later.\n  */\n \n #ifndef _MT_ALLOCATOR_H\n #define _MT_ALLOCATOR_H 1\n \n #include <cstdlib>\n-#include <bits/functexcept.h> \n+#include <bits/functexcept.h>\n #include <bits/gthr.h>\n #include <bits/atomicity.h>\n #include <bits/allocator_traits.h>\n@@ -64,8 +64,8 @@ namespace __gnu_cxx\n     private:\n       /*\n        * We need to create the initial lists and set up some variables\n-       * before we can answer to the first request for memory. \n-       * The initialization of these variables is done at file scope \n+       * before we can answer to the first request for memory.\n+       * The initialization of these variables is done at file scope\n        * below class declaration.\n        */\n #ifdef __GTHREADS\n@@ -93,7 +93,7 @@ namespace __gnu_cxx\n       static size_t _S_freelist_headroom;\n \n       /*\n-       * Each requesting thread is assigned an id ranging from 1 to \n+       * Each requesting thread is assigned an id ranging from 1 to\n        * _S_max_threads. Thread id 0 is used as a global memory pool.\n        * In order to get constant performance on the thread assignment\n        * routine, we keep a list of free ids. When a thread first requests\n@@ -141,8 +141,8 @@ namespace __gnu_cxx\n       struct bin_record\n       {\n         /*\n-         * An \"array\" of pointers to the first/last free block for each \n-         * thread id. Memory to these \"arrays\" is allocated in _S_init() \n+         * An \"array\" of pointers to the first/last free block for each\n+         * thread id. Memory to these \"arrays\" is allocated in _S_init()\n          * for _S_max_threads + global pool 0.\n          */\n         block_record** first;\n@@ -151,24 +151,24 @@ namespace __gnu_cxx\n         /*\n          * An \"array\" of counters used to keep track of the amount of blocks\n          * that are on the freelist/used for each thread id.\n-         * Memory to these \"arrays\" is allocated in _S_init() \n+         * Memory to these \"arrays\" is allocated in _S_init()\n          * for _S_max_threads + global pool 0.\n          */\n         size_t* free;\n         size_t* used;\n \n         /*\n-         * Each bin has its own mutex which is used to ensure data integrity \n+         * Each bin has its own mutex which is used to ensure data integrity\n          * while changing \"ownership\" on a block.\n          * The mutex is initialized in _S_init().\n          */\n #ifdef __GTHREADS\n-        __gthread_mutex_t* mutex; \n+        __gthread_mutex_t* mutex;\n #endif\n       };\n \n       /*\n-       * An \"array\" of bin_records each of which represents a specific \n+       * An \"array\" of bin_records each of which represents a specific\n        * power of 2 size. Memory to this \"array\" is allocated in _S_init().\n        */\n       static bin_record* _S_bin;\n@@ -185,7 +185,7 @@ namespace __gnu_cxx\n         if (__n > _S_max_bytes)\n           {\n             void* __ret = malloc(__n);\n-            if (!__ret) \n+            if (!__ret)\n               __throw_bad_alloc();\n \n             return __ret;\n@@ -233,12 +233,12 @@ namespace __gnu_cxx\n           {\n             /*\n              * Are we using threads?\n-             * - Yes, lock and check if there are free blocks on the global \n-             *   list (and if not add new ones), get the first one \n+             * - Yes, lock and check if there are free blocks on the global\n+             *   list (and if not add new ones), get the first one\n              *   and change owner.\n-             * - No, all operations are made directly to global pool 0 \n-             *   no need to lock or change ownership but check for free \n-             *   blocks on global list (and if not add new ones) and \n+             * - No, all operations are made directly to global pool 0\n+             *   no need to lock or change ownership but check for free\n+             *   blocks on global list (and if not add new ones) and\n              *   get the first one.\n              */\n #ifdef __GTHREADS\n@@ -248,7 +248,7 @@ namespace __gnu_cxx\n \n                 if (_S_bin[bin].first[0] == NULL)\n                   {\n-                    _S_bin[bin].first[0] = \n+                    _S_bin[bin].first[0] =\n                       (block_record*)malloc(_S_chunk_size);\n \n                     if (!_S_bin[bin].first[0])\n@@ -258,7 +258,7 @@ namespace __gnu_cxx\n                       }\n \n                     size_t bin_t = 1 << bin;\n-                    size_t block_count = \n+                    size_t block_count =\n                       _S_chunk_size /(bin_t + sizeof(block_record));\n \n                     _S_bin[bin].free[0] = block_count;\n@@ -268,7 +268,7 @@ namespace __gnu_cxx\n \n                     while (block_count > 0)\n                       {\n-                        block->next = (block_record*)((char*)block + \n+                        block->next = (block_record*)((char*)block +\n                                       (bin_t + sizeof(block_record)));\n                         block = block->next;\n                         block_count--;\n@@ -302,11 +302,11 @@ namespace __gnu_cxx\n               {\n                 _S_bin[bin].first[0] = (block_record*)malloc(_S_chunk_size);\n \n-                if (!_S_bin[bin].first[0]) \n+                if (!_S_bin[bin].first[0])\n                   __throw_bad_alloc();\n \n                 size_t bin_t = 1 << bin;\n-                size_t block_count = \n+                size_t block_count =\n                   _S_chunk_size / (bin_t + sizeof(block_record));\n \n                 _S_bin[bin].free[0] = block_count;\n@@ -316,7 +316,7 @@ namespace __gnu_cxx\n \n                 while (block_count > 0)\n                   {\n-                    block->next = (block_record*)((char*)block + \n+                    block->next = (block_record*)((char*)block +\n                                   (bin_t + sizeof(block_record)));\n                     block = block->next;\n                     block_count--;\n@@ -335,7 +335,7 @@ namespace __gnu_cxx\n                 _S_bin[bin].free[0]--;\n                 _S_bin[bin].used[0]++;\n               }\n-          }  \n+          }\n         else\n           {\n             /*\n@@ -376,7 +376,7 @@ namespace __gnu_cxx\n         size_t thread_id = 0;\n #endif\n \n-        block_record* block = (block_record*)((char*)__p \n+        block_record* block = (block_record*)((char*)__p\n \t\t\t\t\t      - sizeof(block_record));\n \n         /*\n@@ -391,7 +391,7 @@ namespace __gnu_cxx\n             /*\n              * Calculate the number of records to remove from our freelist\n              */\n-            int remove = _S_bin[bin].free[thread_id] - \n+            int remove = _S_bin[bin].free[thread_id] -\n                          (_S_bin[bin].used[thread_id] / _S_freelist_headroom);\n \n             /*\n@@ -400,8 +400,8 @@ namespace __gnu_cxx\n              * too much contention when locking and therefore we\n              * wait until the number of records is \"high enough\".\n              */\n-            if (remove > (int)(100 * (_S_no_of_bins - bin)) && \n-                remove > (int)(_S_bin[bin].free[thread_id] / \n+            if (remove > (int)(100 * (_S_no_of_bins - bin)) &&\n+                remove > (int)(_S_bin[bin].free[thread_id] /\n                                _S_freelist_headroom))\n               {\n                 __gthread_mutex_lock(_S_bin[bin].mutex);\n@@ -415,7 +415,7 @@ namespace __gnu_cxx\n \n                     _S_bin[bin].last[0] = _S_bin[bin].first[thread_id];\n \n-                    _S_bin[bin].first[thread_id] = \n+                    _S_bin[bin].first[thread_id] =\n                       _S_bin[bin].first[thread_id]->next;\n \n                     _S_bin[bin].free[0]++;\n@@ -506,7 +506,7 @@ namespace __gnu_cxx\n       _S_binmap = (binmap_type*)\n         malloc ((_S_max_bytes + 1) * sizeof(binmap_type));\n \n-      if (!_S_binmap) \n+      if (!_S_binmap)\n         __throw_bad_alloc();\n \n       binmap_type* bp_t = _S_binmap;\n@@ -530,20 +530,20 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n       if (__gthread_active_p())\n         {\n-          _S_thread_freelist_first = \n+          _S_thread_freelist_first =\n             (thread_record*)malloc(sizeof(thread_record) * _S_max_threads);\n \n-          if (!_S_thread_freelist_first) \n+          if (!_S_thread_freelist_first)\n             __throw_bad_alloc();\n \n           /*\n-           * NOTE! The first assignable thread id is 1 since the global \n+           * NOTE! The first assignable thread id is 1 since the global\n            * pool uses id 0\n            */\n           size_t i;\n           for (i = 1; i < _S_max_threads; i++)\n             {\n-              _S_thread_freelist_first[i - 1].next = \n+              _S_thread_freelist_first[i - 1].next =\n                 &_S_thread_freelist_first[i];\n \n               _S_thread_freelist_first[i - 1].id = i;\n@@ -575,44 +575,44 @@ namespace __gnu_cxx\n        */\n       _S_bin = (bin_record*)malloc(sizeof(bin_record) * _S_no_of_bins);\n \n-      if (!_S_bin) \n+      if (!_S_bin)\n         __throw_bad_alloc();\n \n       for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n         {\n           _S_bin[bin].first = (block_record**)\n             malloc(sizeof(block_record*) * (_S_max_threads + 1));\n \n-          if (!_S_bin[bin].first) \n+          if (!_S_bin[bin].first)\n             __throw_bad_alloc();\n \n           _S_bin[bin].last = (block_record**)\n             malloc(sizeof(block_record*) * (_S_max_threads + 1));\n \n-          if (!_S_bin[bin].last) \n+          if (!_S_bin[bin].last)\n             __throw_bad_alloc();\n \n           _S_bin[bin].free = (size_t*)\n             malloc(sizeof(size_t) * (_S_max_threads + 1));\n \n-          if (!_S_bin[bin].free) \n+          if (!_S_bin[bin].free)\n             __throw_bad_alloc();\n \n           _S_bin[bin].used = (size_t*)\n             malloc(sizeof(size_t) * (_S_max_threads + 1));\n \n-          if (!_S_bin[bin].used) \n+          if (!_S_bin[bin].used)\n             __throw_bad_alloc();\n \n           /*\n            * Ugly workaround of what at the time of writing seems to be\n            * a parser problem - see PR c++/9779 for more info.\n            */\n #ifdef __GTHREADS\n-          size_t s = sizeof(__gthread_mutex_t); \n+          size_t s = sizeof(__gthread_mutex_t);\n           _S_bin[bin].mutex = (__gthread_mutex_t*)malloc(s);\n \n-          if (!_S_bin[bin].mutex) \n+          if (!_S_bin[bin].mutex)\n             __throw_bad_alloc();\n \n #ifdef __GTHREAD_MUTEX_INIT\n@@ -656,7 +656,7 @@ namespace __gnu_cxx\n        */\n       for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n         {\n-          block_record* block = \n+          block_record* block =\n             _S_bin[bin].first[((thread_record*)freelist_pos)->id];\n \n           if (block != NULL)\n@@ -711,7 +711,7 @@ namespace __gnu_cxx\n         {\n           thread_record* freelist_pos;\n \n-          if ((freelist_pos = \n+          if ((freelist_pos =\n               (thread_record*)__gthread_getspecific(_S_thread_key)) == NULL)\n             {\n               __gthread_mutex_lock(&_S_thread_freelist_mutex);\n@@ -742,7 +742,7 @@ namespace __gnu_cxx\n                   _S_bin[bin].last[freelist_pos->id] = NULL;\n                   _S_bin[bin].free[freelist_pos->id] = 0;\n                 }\n-            } \n+            }\n \n           return freelist_pos->id;\n         }\n@@ -851,7 +851,7 @@ namespace std\n     };\n \n   template<typename _Tp, typename _Tp1, int __inst>\n-    struct _Alloc_traits<_Tp, \n+    struct _Alloc_traits<_Tp,\n                          __allocator<_Tp1, __gnu_cxx::__mt_alloc<__inst> > >\n     {\n       static const bool _S_instanceless = true;"}, {"sha": "40edf07fe3da7174c558a29f61a711e30a2a9970", "filename": "libstdc++-v3/include/ext/numeric", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -72,7 +72,7 @@\n namespace __gnu_cxx\n {\n   // Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n-  // is required to be associative, but not necessarily commutative.   \n+  // is required to be associative, but not necessarily commutative.\n   template<typename _Tp, typename _Integer, typename _MonoidOperation>\n     _Tp\n     __power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n@@ -131,7 +131,7 @@ namespace __gnu_cxx\n   */\n   // iota is not part of the C++ standard.  It is an extension.\n   template<typename _ForwardIter, typename _Tp>\n-    void \n+    void\n     iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n     {\n       // concept requirements"}, {"sha": "c69025e005d268a5abefb8b52cb99e5d7b1008f9", "filename": "libstdc++-v3/include/ext/pod_char_traits.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpod_char_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpod_char_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpod_char_traits.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -32,27 +32,27 @@\n \n #ifndef _POD_CHAR_TRAITS_H\n #define _POD_CHAR_TRAITS_H 1\n- \n+\n #include <string>\n \n namespace __gnu_cxx\n {\n   template<typename V, typename I, typename S = mbstate_t>\n     struct character\n     {\n-      typedef V \tvalue_type;\n-      typedef I \tint_type;\n-      typedef S \tstate_type;\n-      value_type \tvalue;\n+      typedef V\t\tvalue_type;\n+      typedef I\t\tint_type;\n+      typedef S\t\tstate_type;\n+      value_type\tvalue;\n     };\n-  \n+\n   template<typename V, typename I>\n-    inline bool \n+    inline bool\n     operator==(const character<V, I>& lhs, const character<V, I>& rhs)\n     { return lhs.value == rhs.value; }\n-  \n+\n   template<typename V, typename I>\n-    inline bool \n+    inline bool\n     operator<(const character<V, I>& lhs, const character<V, I>& rhs)\n     { return lhs.value < rhs.value; }\n } // namespace __gnu_cxx\n@@ -63,93 +63,93 @@ namespace std\n   template<typename V, typename I, typename S>\n     struct char_traits<__gnu_cxx::character<V, I, S> >\n     {\n-      typedef __gnu_cxx::character<V, I, S> \tchar_type;\n+      typedef __gnu_cxx::character<V, I, S>\tchar_type;\n \n       // NB: This type should be bigger than char_type, so as to\n       // properly hold EOF values in addition to the full range of\n       // char_type values.\n-      // Also, assumes \n+      // Also, assumes\n       // int_type(value_type) is valid.\n       // int_type(-1) is possible.\n       typedef typename char_type::int_type\tint_type;\n       typedef typename char_type::state_type\tstate_type;\n       typedef fpos<state_type>\t\t\tpos_type;\n-      typedef streamoff \t\t\toff_type;\n-      \n-      static void \n+      typedef streamoff\t\t\t\toff_type;\n+\n+      static void\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool \n+      static bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool \n+      static bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n-      static int \n+      static int\n       compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { \n+      {\n \tfor (size_t __i = 0; __i < __n; ++__i)\n \t  if (!eq(__s1[__i], __s2[__i]))\n \t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n-\treturn 0; \n+\treturn 0;\n       }\n \n       static size_t\n       length(const char_type* __s)\n-      { \n-\tconst char_type* __p = __s; \n-\twhile (__p->value) \n-\t  ++__p; \n-\treturn (__p - __s); \n+      {\n+\tconst char_type* __p = __s;\n+\twhile (__p->value)\n+\t  ++__p;\n+\treturn (__p - __s);\n       }\n \n-      static const char_type* \n+      static const char_type*\n       find(const char_type* __s, size_t __n, const char_type& __a)\n-      { \n+      {\n \tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n-\t  if (*__p == __a) \n+\t  if (*__p == __a)\n \t    return __p;\n \treturn 0;\n       }\n \n-      static char_type* \n+      static char_type*\n       move(char_type* __s1, const char_type* __s2, size_t __n)\n       { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n \n-      static char_type* \n+      static char_type*\n       copy(char_type* __s1, const char_type* __s2, size_t __n)\n       { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n \n-      static char_type* \n+      static char_type*\n       assign(char_type* __s, size_t __n, char_type __a)\n-      { \n-\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n+      {\n+\tfor (char_type* __p = __s; __p < __s + __n; ++__p)\n \t  assign(*__p, __a);\n-        return __s; \n+        return __s;\n       }\n \n-      static char_type \n+      static char_type\n       to_char_type(const int_type& __c)\n       {\n \tchar_type __r = { __c };\n \treturn __r;\n       }\n \n-      static int_type \n-      to_int_type(const char_type& __c) \n+      static int_type\n+      to_int_type(const char_type& __c)\n       { return int_type(__c.value); }\n \n-      static bool \n+      static bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type \n+      static int_type\n       eof() { return static_cast<int_type>(-1); }\n \n-      static int_type \n+      static int_type\n       not_eof(const int_type& __c)\n       { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n     };"}, {"sha": "15e1eb45763beb0fcaa3887c92c4fee188c6f7a6", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -41,14 +41,14 @@\n  */\n \n /** @file ext/debug_allocator.h\n- *  This file is a GNU extension to the Standard C++ Library. \n+ *  This file is a GNU extension to the Standard C++ Library.\n  *  You should only include this header if you are using GCC 3 or later.\n  */\n \n #ifndef _POOL_ALLOCATOR_H\n #define _POOL_ALLOCATOR_H 1\n \n-#include <bits/functexcept.h> \n+#include <bits/functexcept.h>\n #include <bits/stl_threads.h>\n #include <bits/atomicity.h>\n #include <bits/allocator_traits.h>\n@@ -111,7 +111,7 @@ namespace __gnu_cxx\n       static size_t                 _S_heap_size;\n \n       static _STL_mutex_lock        _S_lock;\n-      static _Atomic_word \t    _S_force_new;\n+      static _Atomic_word\t    _S_force_new;\n \n       static size_t\n       _S_round_up(size_t __bytes)\n@@ -152,7 +152,7 @@ namespace __gnu_cxx\n \n   template<bool __threads, int __inst>\n     inline bool\n-    operator==(const __pool_alloc<__threads,__inst>&, \n+    operator==(const __pool_alloc<__threads,__inst>&,\n \t       const __pool_alloc<__threads,__inst>&)\n     { return true; }\n \n@@ -289,7 +289,7 @@ namespace __gnu_cxx\n \t  else\n \t    __atomic_add(&_S_force_new, -1);\n \t}\n-      \n+\n       if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n \t__ret = __new_alloc::allocate(__n);\n       else\n@@ -306,13 +306,13 @@ namespace __gnu_cxx\n \t    {\n \t      *__free_list = __result -> _M_free_list_link;\n \t      __ret = __result;\n-\t    }\t    \n+\t    }\n \t  if (__builtin_expect(__ret == 0, 0))\n \t    __throw_bad_alloc();\n \t}\n       return __ret;\n     }\n-  \n+\n   template<bool __threads, int __inst>\n     void\n     __pool_alloc<__threads, __inst>::deallocate(void* __p, size_t __n)\n@@ -323,7 +323,7 @@ namespace __gnu_cxx\n \t{\n \t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);\n \t  _Obj* __q = (_Obj*)__p;\n-\t  \n+\n \t  // Acquire the lock here with a constructor call.  This\n \t  // ensures that it is released in exit or during stack\n \t  // unwinding.\n@@ -368,9 +368,9 @@ namespace std\n   template<typename _Tp, bool __thr, int __inst>\n     struct _Alloc_traits<_Tp, __gnu_cxx::__pool_alloc<__thr, __inst> >\n     {\n-      static const bool _S_instanceless = true;      \n-      typedef __gnu_cxx::__pool_alloc<__thr, __inst> \tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>  \t_Alloc_type;\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx::__pool_alloc<__thr, __inst>\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n       typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n     };\n   //@}\n@@ -379,11 +379,11 @@ namespace std\n   /// Versions for the __allocator adaptor used with the predefined\n   /// \"SGI\" style allocators.\n   template<typename _Tp, typename _Tp1, bool __thr, int __inst>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1, \n+    struct _Alloc_traits<_Tp, __allocator<_Tp1,\n \t\t\t\t     __gnu_cxx::__pool_alloc<__thr, __inst> > >\n     {\n       static const bool _S_instanceless = true;\n-      typedef __gnu_cxx::__pool_alloc<__thr, __inst> \tbase_alloc_type;\n+      typedef __gnu_cxx::__pool_alloc<__thr, __inst>\tbase_alloc_type;\n       typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n       typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n     };"}, {"sha": "2c38b39706e2e6a1620a9131e6544318c019a5cb", "filename": "libstdc++-v3/include/ext/rb_tree", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frb_tree?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -70,7 +70,7 @@ namespace __gnu_cxx\n {\n   using std::_Rb_tree;\n   using std::allocator;\n-  \n+\n   // Class rb_tree is not part of the C++ standard.  It is provided for\n   // compatibility with the HP STL.\n \n@@ -85,13 +85,13 @@ namespace __gnu_cxx\n   {\n     typedef _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc> _Base;\n     typedef typename _Base::allocator_type allocator_type;\n-    \n+\n     rb_tree(const _Compare& __comp = _Compare(),\n \t    const allocator_type& __a = allocator_type())\n       : _Base(__comp, __a) { }\n-    \n+\n     ~rb_tree() { }\n   };\n } // namespace __gnu_cxx\n \n-#endif \n+#endif"}, {"sha": "4323e19c2b96a3cf9ff2aa5ffa5130bb1696381b", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -112,7 +112,7 @@ template <class _CharT>\n class char_producer {\n     public:\n         virtual ~char_producer() {};\n-        virtual void operator()(size_t __start_pos, size_t __len, \n+        virtual void operator()(size_t __start_pos, size_t __len,\n                                 _CharT* __buffer) = 0;\n         // Buffer should really be an arbitrary output iterator.\n         // That way we could flatten directly into an ostream, etc.\n@@ -265,17 +265,17 @@ _Rope_const_iterator<_CharT,_Alloc> operator+\n          const _Rope_const_iterator<_CharT,_Alloc>& __x);\n \n template<class _CharT, class _Alloc>\n-bool operator== \n+bool operator==\n         (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n          const _Rope_const_iterator<_CharT,_Alloc>& __y);\n \n template<class _CharT, class _Alloc>\n-bool operator< \n+bool operator<\n         (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n          const _Rope_const_iterator<_CharT,_Alloc>& __y);\n \n template<class _CharT, class _Alloc>\n-ptrdiff_t operator- \n+ptrdiff_t operator-\n         (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n          const _Rope_const_iterator<_CharT,_Alloc>& __y);\n \n@@ -295,32 +295,32 @@ _Rope_iterator<_CharT,_Alloc> operator+\n          const _Rope_iterator<_CharT,_Alloc>& __x);\n \n template<class _CharT, class _Alloc>\n-bool operator== \n+bool operator==\n         (const _Rope_iterator<_CharT,_Alloc>& __x,\n          const _Rope_iterator<_CharT,_Alloc>& __y);\n \n template<class _CharT, class _Alloc>\n-bool operator< \n+bool operator<\n         (const _Rope_iterator<_CharT,_Alloc>& __x,\n          const _Rope_iterator<_CharT,_Alloc>& __y);\n \n template<class _CharT, class _Alloc>\n-ptrdiff_t operator- \n+ptrdiff_t operator-\n         (const _Rope_iterator<_CharT,_Alloc>& __x,\n          const _Rope_iterator<_CharT,_Alloc>& __y);\n \n template<class _CharT, class _Alloc>\n rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n                                const rope<_CharT,_Alloc>& __right);\n-        \n+\n template<class _CharT, class _Alloc>\n rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n                                const _CharT* __right);\n-        \n+\n template<class _CharT, class _Alloc>\n rope<_CharT,_Alloc> operator+ (const rope<_CharT,_Alloc>& __left,\n                                _CharT __right);\n-        \n+\n // Some helpers, so we can use power on ropes.\n // See below for why this isn't local to the implementation.\n \n@@ -347,16 +347,16 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n \n   // Class _Refcount_Base provides a type, _RC_t, a data member,\n   // _M_ref_count, and member functions _M_incr and _M_decr, which perform\n-  // atomic preincrement/predecrement.  The constructor initializes \n+  // atomic preincrement/predecrement.  The constructor initializes\n   // _M_ref_count.\n   struct _Refcount_Base\n   {\n     // The type _RC_t\n     typedef size_t _RC_t;\n-    \n+\n     // The data member _M_ref_count\n     volatile _RC_t _M_ref_count;\n-    \n+\n     // Constructor\n     __gthread_mutex_t _M_ref_count_lock;\n \n@@ -372,16 +372,16 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n #endif\n     }\n \n-    void \n-    _M_incr() \n+    void\n+    _M_incr()\n     {\n       __gthread_mutex_lock(&_M_ref_count_lock);\n       ++_M_ref_count;\n       __gthread_mutex_unlock(&_M_ref_count_lock);\n     }\n \n-    _RC_t \n-    _M_decr() \n+    _RC_t\n+    _M_decr()\n     {\n       __gthread_mutex_lock(&_M_ref_count_lock);\n       volatile _RC_t __tmp = --_M_ref_count;\n@@ -420,7 +420,7 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n // we are using standard conforming allocators, and whether the allocator\n // instances have real state.  Thus this macro is invoked repeatedly\n // with different definitions of __ROPE_DEFINE_ALLOC.\n-// __ROPE_DEFINE_ALLOC(type,name) defines \n+// __ROPE_DEFINE_ALLOC(type,name) defines\n //   type * name_allocate(size_t) and\n //   void name_deallocate(tipe *, size_t)\n // Both functions may or may not be static.\n@@ -460,7 +460,7 @@ public:\n   size_t _M_size;       // This is here only to avoid wasting space\n                 // for an otherwise empty base class.\n \n-  \n+\n protected:\n     allocator_type _M_data_allocator;\n \n@@ -476,7 +476,7 @@ protected:\n };\n \n // Specialization for allocators that have the property that we don't\n-//  actually have to store an allocator object.  \n+//  actually have to store an allocator object.\n template <class _CharT, class _Allocator>\n class _Rope_rep_alloc_base<_CharT,_Allocator,true> {\n public:\n@@ -486,7 +486,7 @@ public:\n   _Rope_rep_alloc_base(size_t __size, const allocator_type&)\n                 : _M_size(__size) {}\n   size_t _M_size;\n-  \n+\n protected:\n \n # define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n@@ -513,7 +513,7 @@ struct _Rope_rep_base\n   typedef typename _Base::allocator_type allocator_type;\n   _Rope_rep_base(size_t __size, const allocator_type& __a)\n     : _Base(__size, __a) {}\n-};    \n+};\n \n \n template<class _CharT, class _Alloc>\n@@ -612,7 +612,7 @@ struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {\n     enum { _S_alloc_granularity = 8 };\n     static size_t _S_rounded_up_size(size_t __n) {\n         size_t __size_with_eos;\n-             \n+\n         if (_S_is_basic_char_type((_CharT*)0)) {\n             __size_with_eos = __n + 1;\n         } else {\n@@ -780,7 +780,7 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n         this->_M_tag = _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn;\n     }\n     virtual ~_Rope_RopeSubstring()\n-      { \n+      {\n #       ifndef __GC\n           _M_base->_M_unref_nonnil();\n           // _M_free_c_string();  -- done by parent class\n@@ -802,7 +802,7 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n   template<class _CharT, class _Alloc>\n   struct _Rope_self_destruct_ptr {\n     _Rope_RopeRep<_CharT,_Alloc>* _M_ptr;\n-    ~_Rope_self_destruct_ptr() \n+    ~_Rope_self_destruct_ptr()\n       { _Rope_RopeRep<_CharT,_Alloc>::_S_unref(_M_ptr); }\n #ifdef __EXCEPTIONS\n         _Rope_self_destruct_ptr() : _M_ptr(0) {};\n@@ -854,7 +854,7 @@ class _Rope_char_ref_proxy {\n     _Rope_char_ref_proxy& operator= (_CharT __c);\n     _Rope_char_ptr_proxy<_CharT,_Alloc> operator& () const;\n     _Rope_char_ref_proxy& operator= (const _Rope_char_ref_proxy& __c) {\n-        return operator=((_CharT)__c); \n+        return operator=((_CharT)__c);\n     }\n };\n \n@@ -873,14 +873,14 @@ class _Rope_char_ptr_proxy {\n     size_t _M_pos;\n     rope<_CharT,_Alloc>* _M_root;     // The whole rope.\n   public:\n-    _Rope_char_ptr_proxy(const _Rope_char_ref_proxy<_CharT,_Alloc>& __x) \n+    _Rope_char_ptr_proxy(const _Rope_char_ref_proxy<_CharT,_Alloc>& __x)\n       : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n     _Rope_char_ptr_proxy(const _Rope_char_ptr_proxy& __x)\n       : _M_pos(__x._M_pos), _M_root(__x._M_root) {}\n     _Rope_char_ptr_proxy() {}\n     _Rope_char_ptr_proxy(_CharT* __x) : _M_root(0), _M_pos(0) {\n     }\n-    _Rope_char_ptr_proxy& \n+    _Rope_char_ptr_proxy&\n     operator= (const _Rope_char_ptr_proxy& __x) {\n         _M_pos = __x._M_pos;\n         _M_root = __x._M_root;\n@@ -942,7 +942,7 @@ class _Rope_iterator_base\n                           // __right. Assumes path_cache_len <= 9.\n     _CharT _M_tmp_buf[_S_iterator_buf_len];\n                         // Short buffer for surrounding chars.\n-                        // This is useful primarily for \n+                        // This is useful primarily for\n                         // RopeFunctions.  We put the buffer\n                         // here to avoid locking in the\n                         // multithreaded case.\n@@ -1081,7 +1081,7 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n          const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n     template<class _CharT2, class _Alloc2>\n-    friend bool operator< \n+    friend bool operator<\n         (const _Rope_const_iterator<_CharT2,_Alloc2>& __x,\n          const _Rope_const_iterator<_CharT2,_Alloc2>& __y);\n     template<class _CharT2, class _Alloc2>\n@@ -1105,7 +1105,7 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         // nonGC case.\n     _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)\n       : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr, __pos),\n-        _M_root_rope(__r) \n+        _M_root_rope(__r)\n       { _RopeRep::_S_ref(this->_M_root);\n         if (!(__r -> empty()))_S_setcache(*this); }\n \n@@ -1235,7 +1235,7 @@ public:\n         : _M_tree_ptr(__t), _M_data_allocator(__a) {}\n   _Rope_alloc_base(const allocator_type& __a)\n         : _M_data_allocator(__a) {}\n-  \n+\n protected:\n   // The only data members of a rope:\n     allocator_type _M_data_allocator;\n@@ -1253,7 +1253,7 @@ protected:\n };\n \n // Specialization for allocators that have the property that we don't\n-//  actually have to store an allocator object.  \n+//  actually have to store an allocator object.\n template <class _CharT, class _Allocator>\n class _Rope_alloc_base<_CharT,_Allocator,true> {\n public:\n@@ -1264,7 +1264,7 @@ public:\n   _Rope_alloc_base(_RopeRep *__t, const allocator_type&)\n                 : _M_tree_ptr(__t) {}\n   _Rope_alloc_base(const allocator_type&) {}\n-  \n+\n protected:\n   // The only data member of a rope:\n     _RopeRep *_M_tree_ptr;\n@@ -1283,7 +1283,7 @@ protected:\n };\n \n template <class _CharT, class _Alloc>\n-struct _Rope_base \n+struct _Rope_base\n   : public _Rope_alloc_base<_CharT,_Alloc,\n                             _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n {\n@@ -1295,7 +1295,7 @@ struct _Rope_base\n         // The one in _Base may not be visible due to template rules.\n   _Rope_base(_RopeRep* __t, const allocator_type& __a) : _Base(__t, __a) {}\n   _Rope_base(const allocator_type& __a) : _Base(__a) {}\n-};    \n+};\n \n \n /**\n@@ -1429,7 +1429,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n                 return _S_rounded_up_size(__n);\n             }\n         }\n-                \n+\n         // Allocate and construct a RopeLeaf using the supplied allocator\n         // Takes ownership of s instead of copying.\n         static _RopeLeaf* _S_new_RopeLeaf(__GC_CONST _CharT *__s,\n@@ -1466,7 +1466,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n           _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr(const _CharT *__s,\n                        size_t __size, allocator_type __a)\n #         define __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __size, __a) \\\n-                _S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)     \n+                _S_RopeLeaf_from_unowned_char_ptr(__s, __size, __a)\n         {\n             if (0 == __size) return 0;\n             _CharT* __buf = __a.allocate(_S_rounded_up_size(__size));\n@@ -1482,7 +1482,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \t\t__throw_exception_again;\n \t      }\n         }\n-            \n+\n \n         // Concatenation of nonempty strings.\n         // Always builds a concatenation node.\n@@ -1526,7 +1526,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n                                   size_t __start, size_t __len,\n                                   _CharT* __buffer);\n \n-        static const unsigned long \n+        static const unsigned long\n           _S_min_len[_RopeRep::_S_max_rope_depth + 1];\n \n         static bool _S_is_balanced(_RopeRep* __r)\n@@ -1559,7 +1559,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // Add all unbalanced subtrees to the forest of balanceed trees.\n         // Used only by balance.\n         static void _S_add_to_forest(_RopeRep*__r, _RopeRep** __forest);\n-        \n+\n         // Add __r to forest, assuming __r is already balanced.\n         static void _S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest);\n \n@@ -1677,7 +1677,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         void pop_back()\n         {\n             _RopeRep* __old = this->_M_tree_ptr;\n-            this->_M_tree_ptr = \n+            this->_M_tree_ptr =\n               _S_substring(this->_M_tree_ptr,\n \t\t\t   0,\n \t\t\t   this->_M_tree_ptr->_M_size - 1);\n@@ -1736,7 +1736,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // rest of the interface.\n         // Note that this guaranteed not to compile if the draft standard\n         // order is assumed.\n-        size_type copy(size_type __pos, size_type __n, _CharT* __buffer) const \n+        size_type copy(size_type __pos, size_type __n, _CharT* __buffer) const\n         {\n             size_t __size = size();\n             size_t __len = (__pos + __n > __size? __size - __pos : __n);\n@@ -1765,8 +1765,8 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // is safe for multiple threads.\n         void delete_c_str () {\n             if (0 == this->_M_tree_ptr) return;\n-            if (_RopeRep::_S_leaf == this->_M_tree_ptr->_M_tag && \n-                ((_RopeLeaf*)this->_M_tree_ptr)->_M_data == \n+            if (_RopeRep::_S_leaf == this->_M_tree_ptr->_M_tag &&\n+                ((_RopeLeaf*)this->_M_tree_ptr)->_M_data ==\n                       this->_M_tree_ptr->_M_c_string) {\n                 // Representation shared\n                 return;\n@@ -1803,7 +1803,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             return(const_iterator(this->_M_tree_ptr, size()));\n         }\n \n-        size_type size() const { \n+        size_type size() const {\n             return(0 == this->_M_tree_ptr? 0 : this->_M_tree_ptr->_M_size);\n         }\n \n@@ -1840,12 +1840,12 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         friend rope<_CharT2,_Alloc2>\n         operator+ (const rope<_CharT2,_Alloc2>& __left,\n                    const rope<_CharT2,_Alloc2>& __right);\n-        \n+\n         template<class _CharT2, class _Alloc2>\n         friend rope<_CharT2,_Alloc2>\n         operator+ (const rope<_CharT2,_Alloc2>& __left,\n                    const _CharT2* __right);\n-        \n+\n         template<class _CharT2, class _Alloc2>\n         friend rope<_CharT2,_Alloc2>\n         operator+ (const rope<_CharT2,_Alloc2>& __left, _CharT2 __right);\n@@ -1856,7 +1856,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // The first argument should be an input iterator or\n         // forward iterator with value_type _CharT.\n         rope& append(const _CharT* __iter, size_t __n) {\n-            _RopeRep* __result = \n+            _RopeRep* __result =\n               _S_destr_concat_char_iter(this->_M_tree_ptr, __iter, __n);\n             _S_unref(this->_M_tree_ptr);\n             this->_M_tree_ptr = __result;\n@@ -1880,15 +1880,15 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         rope& append(const_iterator __s, const_iterator __e) {\n             _Self_destruct_ptr __appendee(_S_substring(\n               __s._M_root, __s._M_current_pos, __e._M_current_pos));\n-            _RopeRep* __result = \n+            _RopeRep* __result =\n               _S_concat(this->_M_tree_ptr, (_RopeRep*)__appendee);\n             _S_unref(this->_M_tree_ptr);\n             this->_M_tree_ptr = __result;\n             return *this;\n         }\n \n         rope& append(_CharT __c) {\n-            _RopeRep* __result = \n+            _RopeRep* __result =\n               _S_destr_concat_char_iter(this->_M_tree_ptr, &__c, 1);\n             _S_unref(this->_M_tree_ptr);\n             this->_M_tree_ptr = __result;\n@@ -1938,7 +1938,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n     public:\n         void insert(size_t __p, const rope& __r) {\n-            _RopeRep* __result = \n+            _RopeRep* __result =\n               replace(this->_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n             _S_unref(this->_M_tree_ptr);\n             this->_M_tree_ptr = __result;\n@@ -1996,13 +1996,13 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // (position, length) versions of replace operations:\n \n         void replace(size_t __p, size_t __n, const rope& __r) {\n-            _RopeRep* __result = \n+            _RopeRep* __result =\n               replace(this->_M_tree_ptr, __p, __p + __n, __r._M_tree_ptr);\n             _S_unref(this->_M_tree_ptr);\n             this->_M_tree_ptr = __result;\n         }\n \n-        void replace(size_t __p, size_t __n, \n+        void replace(size_t __p, size_t __n,\n                      const _CharT* __i, size_t __i_len) {\n             rope __r(__i, __i_len);\n             replace(__p, __n, __r);\n@@ -2018,7 +2018,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             replace(__p, __n, __r);\n         }\n \n-        void replace(size_t __p, size_t __n, \n+        void replace(size_t __p, size_t __n,\n                      const _CharT* __i, const _CharT* __j) {\n             rope __r(__i, __j);\n             replace(__p, __n, __r);\n@@ -2080,20 +2080,20 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             erase(__p, __p + 1);\n         }\n \n-        // Insert, iterator variants.  \n+        // Insert, iterator variants.\n         iterator insert(const iterator& __p, const rope& __r)\n                 { insert(__p.index(), __r); return __p; }\n         iterator insert(const iterator& __p, size_t __n, _CharT __c)\n                 { insert(__p.index(), __n, __c); return __p; }\n-        iterator insert(const iterator& __p, _CharT __c) \n+        iterator insert(const iterator& __p, _CharT __c)\n                 { insert(__p.index(), __c); return __p; }\n-        iterator insert(const iterator& __p ) \n+        iterator insert(const iterator& __p )\n                 { insert(__p.index()); return __p; }\n-        iterator insert(const iterator& __p, const _CharT* c_string) \n+        iterator insert(const iterator& __p, const _CharT* c_string)\n                 { insert(__p.index(), c_string); return __p; }\n         iterator insert(const iterator& __p, const _CharT* __i, size_t __n)\n                 { insert(__p.index(), __i, __n); return __p; }\n-        iterator insert(const iterator& __p, const _CharT* __i, \n+        iterator insert(const iterator& __p, const _CharT* __i,\n                         const _CharT* __j)\n                 { insert(__p.index(), __i, __j);  return __p; }\n         iterator insert(const iterator& __p,\n@@ -2136,7 +2136,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n                 { replace(__p.index(), __i, __n); }\n         void replace(const iterator& __p, const _CharT* __i, const _CharT* __j)\n                 { replace(__p.index(), __i, __j); }\n-        void replace(const iterator& __p, const_iterator __i, \n+        void replace(const iterator& __p, const_iterator __i,\n                      const_iterator __j)\n                 { replace(__p.index(), __i, __j); }\n         void replace(const iterator& __p, iterator __i, iterator __j)\n@@ -2167,13 +2167,13 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \t\t\t     __start.index(),\n \t\t\t     __end.index()));\n         }\n-        \n+\n         rope substr(iterator __start) const {\n             size_t __pos = __start.index();\n             return rope<_CharT,_Alloc>(\n                         _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n         }\n-        \n+\n         rope substr(const_iterator __start, const_iterator __end) const {\n             // This might eventually take advantage of the cache in the\n             // iterator.\n@@ -2244,7 +2244,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n           // Stuff below this line is dangerous because it's error prone.\n           // I would really like to get rid of it.\n             // copy function with funny arg ordering.\n-              size_type copy(_CharT* __buffer, size_type __n, \n+              size_type copy(_CharT* __buffer, size_type __n,\n                              size_type __pos = 0) const {\n                 return copy(__pos, __n, __buffer);\n               }\n@@ -2264,11 +2264,11 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             const_iterator begin() { return const_begin(); }\n \n             const_reverse_iterator rend() { return const_rend(); }\n-  \n+\n             const_reverse_iterator rbegin() { return const_rbegin(); }\n \n #       endif\n-        \n+\n };\n \n template <class _CharT, class _Alloc>\n@@ -2278,7 +2278,7 @@ const typename rope<_CharT, _Alloc>::size_type rope<_CharT, _Alloc>::npos =\n template <class _CharT, class _Alloc>\n inline bool operator== (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n                         const _Rope_const_iterator<_CharT,_Alloc>& __y) {\n-  return (__x._M_current_pos == __y._M_current_pos && \n+  return (__x._M_current_pos == __y._M_current_pos &&\n           __x._M_root == __y._M_root);\n }\n \n@@ -2342,7 +2342,7 @@ operator+(ptrdiff_t __n, const _Rope_const_iterator<_CharT,_Alloc>& __x) {\n template <class _CharT, class _Alloc>\n inline bool operator== (const _Rope_iterator<_CharT,_Alloc>& __x,\n                         const _Rope_iterator<_CharT,_Alloc>& __y) {\n-  return (__x._M_current_pos == __y._M_current_pos && \n+  return (__x._M_current_pos == __y._M_current_pos &&\n           __x._M_root_rope == __y._M_root_rope);\n }\n \n@@ -2420,7 +2420,7 @@ operator+ (const rope<_CharT,_Alloc>& __left,\n template <class _CharT, class _Alloc>\n inline\n rope<_CharT,_Alloc>&\n-operator+= (rope<_CharT,_Alloc>& __left, \n+operator+= (rope<_CharT,_Alloc>& __left,\n       const rope<_CharT,_Alloc>& __right)\n {\n     __left.append(__right);\n@@ -2435,7 +2435,7 @@ operator+ (const rope<_CharT,_Alloc>& __left,\n     size_t __rlen = rope<_CharT,_Alloc>::_S_char_ptr_len(__right);\n     return rope<_CharT,_Alloc>(\n       rope<_CharT,_Alloc>::_S_concat_char_iter(\n-        __left._M_tree_ptr, __right, __rlen)); \n+        __left._M_tree_ptr, __right, __rlen));\n }\n \n template <class _CharT, class _Alloc>\n@@ -2466,14 +2466,14 @@ operator+= (rope<_CharT,_Alloc>& __left, _CharT __right) {\n \n template <class _CharT, class _Alloc>\n bool\n-operator< (const rope<_CharT,_Alloc>& __left, \n+operator< (const rope<_CharT,_Alloc>& __left,\n            const rope<_CharT,_Alloc>& __right) {\n     return __left.compare(__right) < 0;\n }\n-        \n+\n template <class _CharT, class _Alloc>\n bool\n-operator== (const rope<_CharT,_Alloc>& __left, \n+operator== (const rope<_CharT,_Alloc>& __left,\n             const rope<_CharT,_Alloc>& __right) {\n     return __left.compare(__right) == 0;\n }"}, {"sha": "b8357ee2d4573dfbdd2412779586c748ee6cb132", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -45,7 +45,7 @@\n  *  You should not attempt to use it directly.\n  */\n \n-#include <cstdio>     \n+#include <cstdio>\n #include <ostream>\n #include <bits/functexcept.h>\n \n@@ -57,7 +57,7 @@ namespace __gnu_cxx\n {\n   using std::size_t;\n   using std::printf;\n-  using std::basic_ostream;  \n+  using std::basic_ostream;\n   using std::__throw_length_error;\n   using std::__alloc;\n   using std::_Destroy;\n@@ -68,7 +68,7 @@ namespace __gnu_cxx\n // Results in a valid buf_ptr if the iterator can be legitimately\n // dereferenced.\n template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf( \n+void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf(\n   _Rope_iterator_base<_CharT,_Alloc>& __x)\n {\n     const _RopeRep* __leaf = __x._M_path_end[__x._M_leaf_index];\n@@ -77,7 +77,7 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf(\n \n     switch(__leaf->_M_tag) {\n \tcase _RopeRep::_S_leaf:\n-\t    __x._M_buf_start = \n+\t    __x._M_buf_start =\n \t      ((_Rope_RopeLeaf<_CharT,_Alloc>*)__leaf)->_M_data;\n \t    __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);\n \t    __x._M_buf_end = __x._M_buf_start + __leaf->_M_size;\n@@ -111,7 +111,7 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf(\n     }\n }\n \n-// Set path and buffer inside a rope iterator.  We assume that \n+// Set path and buffer inside a rope iterator.  We assume that\n // pos and root are already set.\n template <class _CharT, class _Alloc>\n void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n@@ -154,7 +154,7 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n \t\t\t(_Rope_RopeConcatenation<_CharT,_Alloc>*)__curr_rope;\n \t\t_RopeRep* __left = __c->_M_left;\n \t\tsize_t __left_len = __left->_M_size;\n-\t\t\n+\n \t\t__dirns <<= 1;\n \t\tif (__pos >= __curr_start_pos + __left_len) {\n \t\t    __dirns |= 1;\n@@ -203,7 +203,7 @@ void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache_for_incr\n     }\n     //  node_start_pos is starting position of last_node.\n     while (--__current_index >= 0) {\n-\tif (!(__dirns & 1) /* Path turned left */) \n+\tif (!(__dirns & 1) /* Path turned left */)\n \t  break;\n \t__current_node = __x._M_path_end[__current_index];\n \t__c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n@@ -288,23 +288,23 @@ void _Rope_iterator<_CharT,_Alloc>::_M_check() {\n }\n \n template <class _CharT, class _Alloc>\n-inline \n+inline\n _Rope_const_iterator<_CharT, _Alloc>::_Rope_const_iterator(\n   const _Rope_iterator<_CharT,_Alloc>& __x)\n-: _Rope_iterator_base<_CharT,_Alloc>(__x) \n+: _Rope_iterator_base<_CharT,_Alloc>(__x)\n { }\n \n template <class _CharT, class _Alloc>\n inline _Rope_iterator<_CharT,_Alloc>::_Rope_iterator(\n   rope<_CharT,_Alloc>& __r, size_t __pos)\n-: _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos), \n+: _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos),\n   _M_root_rope(&__r)\n {\n     _RopeRep::_S_ref(this->_M_root);\n }\n \n template <class _CharT, class _Alloc>\n-inline size_t \n+inline size_t\n rope<_CharT,_Alloc>::_S_char_ptr_len(const _CharT* __s)\n {\n     const _CharT* __p = __s;\n@@ -409,7 +409,7 @@ rope<_CharT,_Alloc>::_S_leaf_concat_char_iter\n     _CharT* __new_data = (_CharT*)\n \t_Data_allocate(_S_rounded_up_size(__old_len + __len));\n     _RopeLeaf* __result;\n-    \n+\n     uninitialized_copy_n(__r->_M_data, __old_len, __new_data);\n     uninitialized_copy_n(__iter, __len, __new_data + __old_len);\n     _S_cond_store_eos(__new_data[__old_len + __len]);\n@@ -463,22 +463,22 @@ template <class _CharT, class _Alloc>\n typename rope<_CharT,_Alloc>::_RopeRep*\n rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n {\n-  _RopeConcatenation* __result = _S_new_RopeConcatenation(__left, __right, \n+  _RopeConcatenation* __result = _S_new_RopeConcatenation(__left, __right,\n \t\t\t\t\t\t      __left->get_allocator());\n   size_t __depth = __result->_M_depth;\n-    \n+\n   if (__depth > 20 && (__result->_M_size < 1000 ||\n-\t\t       __depth > _RopeRep::_S_max_rope_depth)) \n+\t\t       __depth > _RopeRep::_S_max_rope_depth))\n     {\n       _RopeRep* __balanced;\n-      \n-      try \n+\n+      try\n \t{\n \t  __balanced = _S_balance(__result);\n \t  __result->_M_unref_nonnil();\n         }\n       catch(...)\n-\t{ \n+\t{\n \t  _C_deallocate(__result,1);\n \t  __throw_exception_again;\n \t}\n@@ -487,8 +487,8 @@ rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n       // still owns its children.  Thus unref is\n       // inappropriate.\n       return __balanced;\n-    } \n-  else \n+    }\n+  else\n     return __result;\n }\n \n@@ -505,26 +505,26 @@ rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n     if (0 == __r)\n       return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n \t\t\t\t\t      __r->get_allocator());\n-    if (_RopeRep::_S_leaf == __r->_M_tag && \n+    if (_RopeRep::_S_leaf == __r->_M_tag &&\n           __r->_M_size + __slen <= _S_copy_max) {\n \t__result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n \treturn __result;\n     }\n     if (_RopeRep::_S_concat == __r->_M_tag\n \t&& _RopeRep::_S_leaf == ((_RopeConcatenation*)__r)->_M_right->_M_tag) {\n-\t_RopeLeaf* __right = \n+\t_RopeLeaf* __right =\n \t  (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);\n \tif (__right->_M_size + __slen <= _S_copy_max) {\n \t  _RopeRep* __left = ((_RopeConcatenation*)__r)->_M_left;\n-\t  _RopeRep* __nright = \n+\t  _RopeRep* __nright =\n \t    _S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);\n \t  __left->_M_ref_nonnil();\n \t  try {\n \t    __result = _S_tree_concat(__left, __nright);\n           }\n \t  catch(...)\n \t    {\n-\t      _S_unref(__left); \n+\t      _S_unref(__left);\n \t      _S_unref(__nright);\n \t      __throw_exception_again;\n \t    }\n@@ -539,7 +539,7 @@ rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n     }\n     catch(...)\n       {\n-\t_S_unref(__r); \n+\t_S_unref(__r);\n \t_S_unref(__nright);\n \t__throw_exception_again;\n       }\n@@ -548,7 +548,7 @@ rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n \n #ifndef __GC\n template <class _CharT, class _Alloc>\n-typename rope<_CharT,_Alloc>::_RopeRep* \n+typename rope<_CharT,_Alloc>::_RopeRep*\n rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n   _RopeRep* __r, const _CharT* __s, size_t __slen)\n {\n@@ -563,7 +563,7 @@ rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n \t__r->_M_ref_count = 2;      // One more than before\n \treturn __r;\n     }\n-    if (__orig_size + __slen <= _S_copy_max && \n+    if (__orig_size + __slen <= _S_copy_max &&\n           _RopeRep::_S_leaf == __r->_M_tag) {\n \t__result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n \treturn __result;\n@@ -572,11 +572,11 @@ rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n \t_RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)__r)->_M_right);\n \tif (_RopeRep::_S_leaf == __right->_M_tag\n \t    && __right->_M_size + __slen <= _S_copy_max) {\n-\t  _RopeRep* __new_right = \n+\t  _RopeRep* __new_right =\n \t    _S_destr_leaf_concat_char_iter(__right, __s, __slen);\n-\t  if (__right == __new_right) \n+\t  if (__right == __new_right)\n \t    __new_right->_M_ref_count = 1;\n-\t  else \n+\t  else\n \t    __right->_M_unref_nonnil();\n \t  __r->_M_ref_count = 2;    // One more than before.\n \t  ((_RopeConcatenation*)__r)->_M_right = __new_right;\n@@ -596,7 +596,7 @@ rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n     }\n     catch(...)\n       {\n-\t_S_unref(__r); \n+\t_S_unref(__r);\n \t_S_unref(__right);\n \t__throw_exception_again;\n       }\n@@ -627,7 +627,7 @@ rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n \t\t   && _RopeRep::_S_leaf ==\n \t\t      ((_RopeConcatenation*)__left)->_M_right->_M_tag) {\n \t  _RopeLeaf* __leftright =\n-\t\t    (_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right); \n+\t\t    (_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right);\n \t  if (__leftright->_M_size + __right->_M_size <= _S_copy_max) {\n \t    _RopeRep* __leftleft = ((_RopeConcatenation*)__left)->_M_left;\n \t    _RopeRep* __rest = _S_leaf_concat_char_iter(__leftright,\n@@ -639,7 +639,7 @@ rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n             }\n \t    catch(...)\n \t      {\n-\t\t_S_unref(__leftleft); \n+\t\t_S_unref(__leftleft);\n \t\t_S_unref(__rest);\n \t\t__throw_exception_again;\n \t      }\n@@ -653,22 +653,22 @@ rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n     }\n     catch(...)\n       {\n-\t_S_unref(__left); \n+\t_S_unref(__left);\n \t_S_unref(__right);\n \t__throw_exception_again;\n       }\t\n }\n \n template <class _CharT, class _Alloc>\n typename rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base, \n+rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base,\n                                size_t __start, size_t __endp1)\n {\n     if (0 == __base) return 0;\n     size_t __len = __base->_M_size;\n     size_t __adj_endp1;\n     const size_t __lazy_threshold = 128;\n-    \n+\n     if (__endp1 >= __len) {\n \tif (0 == __start) {\n \t    __base->_M_ref_nonnil();\n@@ -788,14 +788,14 @@ class _Rope_flatten_char_consumer : public _Rope_char_consumer<_CharT> {\n \t    return true;\n \t}\n };\n-\t    \n+\n template<class _CharT>\n class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {\n     private:\n \t_CharT _M_pattern;\n     public:\n \tsize_t _M_count;  // Number of nonmatching characters\n-\t_Rope_find_char_char_consumer(_CharT __p) \n+\t_Rope_find_char_char_consumer(_CharT __p)\n \t  : _M_pattern(__p), _M_count(0) {}\n \t~_Rope_find_char_char_consumer() {}\n \tbool operator() (const _CharT* __leaf, size_t __n) {\n@@ -808,22 +808,22 @@ class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {\n \t    _M_count += __n; return true;\n \t}\n };\n-\t    \n+\n   template<class _CharT, class _Traits>\n   // Here _CharT is both the stream and rope character type.\n class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {\n     private:\n \t  typedef basic_ostream<_CharT,_Traits> _Insert_ostream;\n \t_Insert_ostream& _M_o;\n     public:\n-\t_Rope_insert_char_consumer(_Insert_ostream& __writer) \n+\t_Rope_insert_char_consumer(_Insert_ostream& __writer)\n \t  : _M_o(__writer) {};\n \t~_Rope_insert_char_consumer() { };\n \t\t// Caller is presumed to own the ostream\n \tbool operator() (const _CharT* __leaf, size_t __n);\n \t\t// Returns true to continue traversal.\n };\n-\t    \n+\n template<class _CharT, class _Traits>\n bool _Rope_insert_char_consumer<_CharT, _Traits>::operator()\n                                       (const _CharT* __leaf, size_t __n)\n@@ -901,7 +901,7 @@ bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n \n     for (__i = 0; __i < __n; __i++) __o.put(__f);\n }\n-    \n+\n \n template <class _CharT> inline bool _Rope_is_simple(_CharT*) { return false; }\n inline bool _Rope_is_simple(char*) { return true; }\n@@ -917,7 +917,7 @@ basic_ostream<_CharT, _Traits>& operator<< (basic_ostream<_CharT, _Traits>& __o,\n     size_t __rope_len = __r.size();\n       _Rope_insert_char_consumer<_CharT, _Traits> __c(__o);\n     bool __is_simple = _Rope_is_simple((_CharT*)0);\n-    \n+\n     if (__rope_len < __w) {\n \t__pad_len = __w - __rope_len;\n     } else {\n@@ -937,7 +937,7 @@ basic_ostream<_CharT, _Traits>& operator<< (basic_ostream<_CharT, _Traits>& __o,\n     }\n     catch(...)\n       {\n-\tif (!__is_simple) \n+\tif (!__is_simple)\n \t  __o.width(__w);\n \t__throw_exception_again;\n       }\n@@ -1058,8 +1058,8 @@ rope<_CharT,_Alloc>::_S_dump(_RopeRep* __r, int __indent)\n \t    bool __too_big = __r->_M_size > __prefix->_M_size;\n \n \t    _S_flatten(__prefix, __buffer);\n-\t    __buffer[__prefix->_M_size] = _S_eos((_CharT*)0); \n-\t    printf(\"%s%s\\n\", \n+\t    __buffer[__prefix->_M_size] = _S_eos((_CharT*)0);\n+\t    printf(\"%s%s\\n\",\n \t           (char*)__buffer, __too_big? \"...\\n\" : \"\\n\");\n \t} else {\n \t    printf(\"\\n\");\n@@ -1097,11 +1097,11 @@ rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)\n     // __forest[__i]._M_depth = __i\n     // References from forest are included in refcount.\n \n-    for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n+    for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i)\n       __forest[__i] = 0;\n     try {\n       _S_add_to_forest(__r, __forest);\n-      for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n+      for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i)\n         if (0 != __forest[__i]) {\n #\tifndef __GC\n \t  _Self_destruct_ptr __old(__result);\n@@ -1148,9 +1148,9 @@ template <class _CharT, class _Alloc>\n void\n rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n {\n-    _RopeRep* __insertee;   \t\t// included in refcount\n-    _RopeRep* __too_tiny = 0;    \t// included in refcount\n-    int __i;  \t\t\t\t// forest[0..__i-1] is empty\n+    _RopeRep* __insertee;\t\t// included in refcount\n+    _RopeRep* __too_tiny = 0;\t\t// included in refcount\n+    int __i;\t\t\t\t// forest[0..__i-1] is empty\n     size_t __s = __r->_M_size;\n \n     for (__i = 0; __s >= _S_min_len[__i+1]/* not this bucket */; ++__i) {\n@@ -1180,7 +1180,7 @@ rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n \t    __forest[__i]->_M_unref_nonnil();\n \t    __forest[__i] = 0;\n \t}\n-\tif (__i == _RopeRep::_S_max_rope_depth || \n+\tif (__i == _RopeRep::_S_max_rope_depth ||\n \t      __insertee->_M_size < _S_min_len[__i+1]) {\n \t    __forest[__i] = __insertee;\n \t    // refcount is OK since __insertee is now dead.\n@@ -1195,7 +1195,7 @@ rope<_CharT,_Alloc>::_S_fetch(_RopeRep* __r, size_type __i)\n {\n     __GC_CONST _CharT* __cstr = __r->_M_c_string;\n \n-    if (0 != __cstr) return __cstr[__i]; \n+    if (0 != __cstr) return __cstr[__i];\n     for(;;) {\n       switch(__r->_M_tag) {\n \tcase _RopeRep::_S_concat:\n@@ -1285,7 +1285,7 @@ rope<_CharT,_Alloc>::_S_fetch_ptr(_RopeRep* __r, size_type __i)\n // flat strings.\n template <class _CharT, class _Alloc>\n int\n-rope<_CharT,_Alloc>::_S_compare (const _RopeRep* __left, \n+rope<_CharT,_Alloc>::_S_compare (const _RopeRep* __left,\n                                  const _RopeRep* __right)\n {\n     size_t __left_len;\n@@ -1387,7 +1387,7 @@ rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n \n     if (0 == __n)\n       return;\n-    \n+\n     __exponent = __n / __exponentiate_threshold;\n     __rest = __n % __exponentiate_threshold;\n     if (0 == __rest) {\n@@ -1419,12 +1419,12 @@ rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n         }\n \tcatch(...)\n \t  {\n-\t    _RopeRep::__STL_FREE_STRING(__base_buffer, \n+\t    _RopeRep::__STL_FREE_STRING(__base_buffer,\n \t\t\t\t\t__exponentiate_threshold, __a);\n \t    __throw_exception_again;\n \t  }\n \t__base_rope._M_tree_ptr = __base_leaf;\n- \tif (1 == __exponent) {\n+\tif (1 == __exponent) {\n \t  __result = __base_rope;\n \t} else {\n \t  __result = power(__base_rope, __exponent,\n@@ -1494,14 +1494,14 @@ _Rope_rotate(_Rope_iterator __first,\n {\n   typedef typename _Rope_iterator::value_type _CharT;\n   typedef typename _Rope_iterator::_allocator_type _Alloc;\n-  \n+\n   rope<_CharT,_Alloc>& __r(__first.container());\n   rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n-  rope<_CharT,_Alloc> __suffix = \n+  rope<_CharT,_Alloc> __suffix =\n     __r.substr(__last.index(), __r.size() - __last.index());\n-  rope<_CharT,_Alloc> __part1 = \n+  rope<_CharT,_Alloc> __part1 =\n     __r.substr(__middle.index(), __last.index() - __middle.index());\n-  rope<_CharT,_Alloc> __part2 = \n+  rope<_CharT,_Alloc> __part2 =\n     __r.substr(__first.index(), __middle.index() - __first.index());\n   __r = __prefix;\n   __r += __part1;"}, {"sha": "5a6e250ba5002e1947cddfefac8c8658d700bf60", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -57,7 +57,7 @@\n #include <bits/concept_check.h>\n \n namespace __gnu_cxx\n-{ \n+{\n using std::size_t;\n using std::ptrdiff_t;\n using std::_Alloc_traits;\n@@ -79,7 +79,7 @@ __slist_make_link(_Slist_node_base* __prev_node,\n   return __new_node;\n }\n \n-inline _Slist_node_base* \n+inline _Slist_node_base*\n __slist_previous(_Slist_node_base* __head,\n                  const _Slist_node_base* __node)\n {\n@@ -88,7 +88,7 @@ __slist_previous(_Slist_node_base* __head,\n   return __head;\n }\n \n-inline const _Slist_node_base* \n+inline const _Slist_node_base*\n __slist_previous(const _Slist_node_base* __head,\n                  const _Slist_node_base* __node)\n {\n@@ -206,7 +206,7 @@ struct _Slist_iterator : public _Slist_iterator_base\n // an ordinary standard-conforming allocator, a standard-conforming\n // allocator with no non-static data, and an SGI-style allocator.\n // This complexity is necessary only because we're worrying about backward\n-// compatibility and because we want to avoid wasting storage on an \n+// compatibility and because we want to avoid wasting storage on an\n // allocator instance if it isn't necessary.\n \n // Base for general standard-conforming allocators.\n@@ -220,9 +220,9 @@ public:\n   _Slist_alloc_base(const allocator_type& __a) : _M_node_allocator(__a) {}\n \n protected:\n-  _Slist_node<_Tp>* _M_get_node() \n+  _Slist_node<_Tp>* _M_get_node()\n     { return _M_node_allocator.allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) \n+  void _M_put_node(_Slist_node<_Tp>* __p)\n     { _M_node_allocator.deallocate(__p, 1); }\n \n protected:\n@@ -280,7 +280,7 @@ protected:\n   _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n };\n \n-template <class _Tp, class _Alloc> \n+template <class _Tp, class _Alloc>\n _Slist_node_base*\n _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n                                         _Slist_node_base* __last_node) {\n@@ -341,7 +341,7 @@ private:\n       }\n     return __node;\n   }\n-  \n+\n   _Node* _M_create_node() {\n     _Node* __node = this->_M_get_node();\n     try {\n@@ -408,7 +408,7 @@ public:\n public:\n \n   iterator begin() { return iterator((_Node*)this->_M_head._M_next); }\n-  const_iterator begin() const \n+  const_iterator begin() const\n     { return const_iterator((_Node*)this->_M_head._M_next);}\n \n   iterator end() { return iterator(0); }\n@@ -417,16 +417,16 @@ public:\n   // Experimental new feature: before_begin() returns a\n   // non-dereferenceable iterator that, when incremented, yields\n   // begin().  This iterator may be used as the argument to\n-  // insert_after, erase_after, etc.  Note that even for an empty \n-  // slist, before_begin() is not the same iterator as end().  It \n+  // insert_after, erase_after, etc.  Note that even for an empty\n+  // slist, before_begin() is not the same iterator as end().  It\n   // is always necessary to increment before_begin() at least once to\n   // obtain end().\n   iterator before_begin() { return iterator((_Node*) &this->_M_head); }\n   const_iterator before_begin() const\n     { return const_iterator((_Node*) &this->_M_head); }\n \n   size_type size() const { return __slist_size(this->_M_head._M_next); }\n-  \n+\n   size_type max_size() const { return size_type(-1); }\n \n   bool empty() const { return this->_M_head._M_next == 0; }\n@@ -437,7 +437,7 @@ public:\n public:\n \n   reference front() { return ((_Node*) this->_M_head._M_next)->_M_data; }\n-  const_reference front() const \n+  const_reference front() const\n     { return ((_Node*) this->_M_head._M_next)->_M_data; }\n   void push_front(const value_type& __x)   {\n     __slist_make_link(&this->_M_head, _M_create_node(__x));\n@@ -475,7 +475,7 @@ private:\n \n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InIterator>\n-  void _M_insert_after_range(_Node_base* __pos, \n+  void _M_insert_after_range(_Node_base* __pos,\n                              _InIterator __first, _InIterator __last) {\n     typedef typename _Is_integer<_InIterator>::_Integral _Integral;\n     _M_insert_after_range(__pos, __first, __last, _Integral());\n@@ -533,13 +533,13 @@ public:\n   void insert(iterator __pos, size_type __n, const value_type& __x) {\n     _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),\n                          __n, __x);\n-  } \n-    \n+  }\n+\n   // We don't need any dispatching tricks here, because _M_insert_after_range\n   // already does them.\n   template <class _InIterator>\n   void insert(iterator __pos, _InIterator __first, _InIterator __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n+    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node),\n                           __first, __last);\n   }\n \n@@ -548,12 +548,12 @@ public:\n     return iterator((_Node*) this->_M_erase_after(__pos._M_node));\n   }\n   iterator erase_after(iterator __before_first, iterator __last) {\n-    return iterator((_Node*) this->_M_erase_after(__before_first._M_node, \n+    return iterator((_Node*) this->_M_erase_after(__before_first._M_node,\n                                                   __last._M_node));\n-  } \n+  }\n \n   iterator erase(iterator __pos) {\n-    return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head, \n+    return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head,\n                                                           __pos._M_node));\n   }\n   iterator erase(iterator __first, iterator __last) {\n@@ -568,11 +568,11 @@ public:\n public:\n   // Moves the range [__before_first + 1, __before_last + 1) to *this,\n   //  inserting it immediately after __pos.  This is constant time.\n-  void splice_after(iterator __pos, \n+  void splice_after(iterator __pos,\n                     iterator __before_first, iterator __before_last)\n   {\n-    if (__before_first != __before_last) \n-      __slist_splice_after(__pos._M_node, __before_first._M_node, \n+    if (__before_first != __before_last)\n+      __slist_splice_after(__pos._M_node, __before_first._M_node,\n                            __before_last._M_node);\n   }\n \n@@ -618,27 +618,27 @@ public:\n   }\n \n public:\n-  void reverse() { \n+  void reverse() {\n     if (this->_M_head._M_next)\n       this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);\n   }\n \n-  void remove(const _Tp& __val); \n-  void unique(); \n+  void remove(const _Tp& __val);\n+  void unique();\n   void merge(slist& __x);\n-  void sort();     \n+  void sort();\n \n-  template <class _Predicate> \n+  template <class _Predicate>\n   void remove_if(_Predicate __pred);\n \n-  template <class _BinaryPredicate> \n-  void unique(_BinaryPredicate __pred); \n+  template <class _BinaryPredicate>\n+  void unique(_BinaryPredicate __pred);\n \n-  template <class _StrictWeakOrdering> \n+  template <class _StrictWeakOrdering>\n   void merge(slist&, _StrictWeakOrdering);\n \n-  template <class _StrictWeakOrdering> \n-  void sort(_StrictWeakOrdering __comp); \n+  template <class _StrictWeakOrdering>\n+  void sort(_StrictWeakOrdering __comp);\n };\n \n template <class _Tp, class _Alloc>\n@@ -657,7 +657,7 @@ slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)\n     if (__n2 == 0)\n       this->_M_erase_after(__p1, 0);\n     else\n-      _M_insert_after_range(__p1, const_iterator((_Node*)__n2), \n+      _M_insert_after_range(__p1, const_iterator((_Node*)__n2),\n                                   const_iterator(0));\n   }\n   return *this;\n@@ -698,7 +698,7 @@ slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIterator __first, _InputIterator __\n }\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator==(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n {\n   typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;\n@@ -719,30 +719,30 @@ template <class _Tp, class _Alloc>\n inline bool\n operator<(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n {\n-  return std::lexicographical_compare(_SL1.begin(), _SL1.end(), \n+  return std::lexicographical_compare(_SL1.begin(), _SL1.end(),\n \t\t\t\t      _SL2.begin(), _SL2.end());\n }\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator!=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n   return !(_SL1 == _SL2);\n }\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator>(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n   return _SL2 < _SL1;\n }\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator<=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n   return !(_SL2 < _SL1);\n }\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator>=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n   return !(_SL1 < _SL2);\n }\n@@ -761,7 +761,7 @@ void slist<_Tp,_Alloc>::resize(size_type __len, const _Tp& __x)\n     --__len;\n     __cur = __cur->_M_next;\n   }\n-  if (__cur->_M_next) \n+  if (__cur->_M_next)\n     this->_M_erase_after(__cur, 0);\n   else\n     _M_insert_after_fill(__cur, __len, __x);\n@@ -779,13 +779,13 @@ void slist<_Tp,_Alloc>::remove(const _Tp& __val)\n   }\n }\n \n-template <class _Tp, class _Alloc> \n+template <class _Tp, class _Alloc>\n void slist<_Tp,_Alloc>::unique()\n {\n   _Node_base* __cur = this->_M_head._M_next;\n   if (__cur) {\n     while (__cur->_M_next) {\n-      if (((_Node*)__cur)->_M_data == \n+      if (((_Node*)__cur)->_M_data ==\n           ((_Node*)(__cur->_M_next))->_M_data)\n         this->_M_erase_after(__cur);\n       else\n@@ -799,8 +799,8 @@ void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x)\n {\n   _Node_base* __n1 = &this->_M_head;\n   while (__n1->_M_next && __x._M_head._M_next) {\n-    if (((_Node*) __x._M_head._M_next)->_M_data < \n-        ((_Node*)       __n1->_M_next)->_M_data) \n+    if (((_Node*) __x._M_head._M_next)->_M_data <\n+        ((_Node*)       __n1->_M_next)->_M_data)\n       __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n     __n1 = __n1->_M_next;\n   }\n@@ -837,7 +837,7 @@ void slist<_Tp,_Alloc>::sort()\n   }\n }\n \n-template <class _Tp, class _Alloc> \n+template <class _Tp, class _Alloc>\n template <class _Predicate>\n void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n {\n@@ -850,13 +850,13 @@ void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n   }\n }\n \n-template <class _Tp, class _Alloc> template <class _BinaryPredicate> \n+template <class _Tp, class _Alloc> template <class _BinaryPredicate>\n void slist<_Tp,_Alloc>::unique(_BinaryPredicate __pred)\n {\n   _Node* __cur = (_Node*) this->_M_head._M_next;\n   if (__cur) {\n     while (__cur->_M_next) {\n-      if (__pred(((_Node*)__cur)->_M_data, \n+      if (__pred(((_Node*)__cur)->_M_data,\n                  ((_Node*)(__cur->_M_next))->_M_data))\n         this->_M_erase_after(__cur);\n       else\n@@ -882,7 +882,7 @@ void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x,\n   }\n }\n \n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering> \n+template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n void slist<_Tp,_Alloc>::sort(_StrictWeakOrdering __comp)\n {\n   if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n@@ -930,7 +930,7 @@ public:\n   typedef void                pointer;\n   typedef void                reference;\n \n-  insert_iterator(_Container& __x, typename _Container::iterator __i) \n+  insert_iterator(_Container& __x, typename _Container::iterator __i)\n     : container(&__x) {\n     if (__i == __x.begin())\n       iter = __x.before_begin();\n@@ -939,7 +939,7 @@ public:\n   }\n \n   insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n+  operator=(const typename _Container::value_type& __value) {\n     iter = container->insert_after(iter, __value);\n     return *this;\n   }\n@@ -950,4 +950,4 @@ public:\n \n } // namespace std\n \n-#endif \n+#endif"}, {"sha": "196492969b5a0835cb534b74174d2015b081d309", "filename": "libstdc++-v3/include/ext/stdio_filebuf.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -54,13 +54,13 @@ namespace __gnu_cxx\n     {\n     public:\n       // Types:\n-      typedef _CharT                     \t        char_type;\n-      typedef _Traits                    \t        traits_type;\n-      typedef typename traits_type::int_type \t\tint_type;\n-      typedef typename traits_type::pos_type \t\tpos_type;\n-      typedef typename traits_type::off_type \t\toff_type;\n+      typedef _CharT\t\t\t\t        char_type;\n+      typedef _Traits\t\t\t\t        traits_type;\n+      typedef typename traits_type::int_type\t\tint_type;\n+      typedef typename traits_type::pos_type\t\tpos_type;\n+      typedef typename traits_type::off_type\t\toff_type;\n       typedef std::size_t                               size_t;\n-      \n+\n     public:\n       /**\n        *  @param  fd  An open file descriptor.\n@@ -70,20 +70,20 @@ namespace __gnu_cxx\n        *  This constructor associates a file stream buffer with an open\n        *  POSIX file descriptor.\n       */\n-      stdio_filebuf(int __fd, std::ios_base::openmode __mode, \n+      stdio_filebuf(int __fd, std::ios_base::openmode __mode,\n \t\t    size_t __size = static_cast<size_t>(BUFSIZ));\n \n       /**\n        *  @param  f  An open @c FILE*.\n        *  @param  mode  Same meaning as in a standard filebuf.\n        *  @param  size  Optimal or preferred size of internal buffer, in chars.\n-       *                Defaults to system's @c BUFSIZ. \n+       *                Defaults to system's @c BUFSIZ.\n        *\n        *  This constructor associates a file stream buffer with an open\n        *  C @c FILE*.  The @c FILE* will not be automatically closed when the\n        *  stdio_filebuf is closed/destroyed.\n       */\n-      stdio_filebuf(std::__c_file* __f, std::ios_base::openmode __mode, \n+      stdio_filebuf(std::__c_file* __f, std::ios_base::openmode __mode,\n \t\t    size_t __size = static_cast<size_t>(BUFSIZ));\n \n       /**\n@@ -128,7 +128,7 @@ namespace __gnu_cxx\n \n   template<typename _CharT, typename _Traits>\n     stdio_filebuf<_CharT, _Traits>::\n-    stdio_filebuf(std::__c_file* __f, std::ios_base::openmode __mode, \n+    stdio_filebuf(std::__c_file* __f, std::ios_base::openmode __mode,\n \t\t  size_t __size)\n     {\n       this->_M_file.sys_open(__f, __mode);\n@@ -144,4 +144,4 @@ namespace __gnu_cxx\n     }\n } // namespace __gnu_cxx\n \n-#endif \n+#endif"}, {"sha": "2076ca5e30738b477515852dfbb4e23d6637addf", "filename": "libstdc++-v3/include/ext/stdio_sync_filebuf.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_sync_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa30fe72d1d6e281786d296333b18ceff3d8c089/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_sync_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_sync_filebuf.h?ref=fa30fe72d1d6e281786d296333b18ceff3d8c089", "patch": "@@ -61,22 +61,22 @@ namespace __gnu_cxx\n     {\n     public:\n       // Types:\n-      typedef _CharT                  \t        \tchar_type;\n-      typedef _Traits\t\t                    \ttraits_type;\n-      typedef typename traits_type::int_type \t\tint_type;\n-      typedef typename traits_type::pos_type \t\tpos_type;\n-      typedef typename traits_type::off_type \t\toff_type;\n+      typedef _CharT\t\t\t\t\tchar_type;\n+      typedef _Traits\t\t\t\t\ttraits_type;\n+      typedef typename traits_type::int_type\t\tint_type;\n+      typedef typename traits_type::pos_type\t\tpos_type;\n+      typedef typename traits_type::off_type\t\toff_type;\n \n     private:\n       // Underlying stdio FILE\n       std::__c_file* const _M_file;\n-      \n+\n       // Last character gotten. This is used when pbackfail is\n       // called from basic_streambuf::sungetc()\n       int_type _M_unget_buf;\n \n     public:\n-      explicit \n+      explicit\n       stdio_sync_filebuf(std::__c_file* __f)\n       : _M_file(__f), _M_unget_buf(traits_type::eof())\n       { }\n@@ -131,18 +131,18 @@ namespace __gnu_cxx\n \n       virtual std::streamsize\n       xsgetn(char_type* __s, std::streamsize __n);\n-      \n+\n       virtual std::streamsize\n       showmanyc()\n-      { \n+      {\n #if defined(_GLIBCXX_HAVE_S_ISREG) || defined(_GLIBCXX_HAVE_S_IFREG)\n \t// Regular files.\n \tstruct stat __buffer;\n \tint __ret = fstat(fileno(_M_file), &__buffer);\n \tif (!__ret && _GLIBCXX_ISREG(__buffer.st_mode))\n \t  return __buffer.st_size - ftell(_M_file);\n #endif\n-\treturn 0; \n+\treturn 0;\n       }\n \n       virtual int_type\n@@ -183,7 +183,7 @@ namespace __gnu_cxx\n #ifdef _GLIBCXX_USE_LFS\n \tif (!fseeko64(_M_file, __off, __whence))\n \t  __ret = std::streampos(ftello64(_M_file));\n-#else\t\n+#else\n \tif (!fseek(_M_file, __off, __whence))\n \t  __ret = std::streampos(std::ftell(_M_file));\n #endif\n@@ -248,7 +248,7 @@ namespace __gnu_cxx\n   template<>\n     inline std::streamsize\n     stdio_sync_filebuf<wchar_t>::xsgetn(wchar_t* __s, std::streamsize __n)\n-    {  \n+    {\n       std::streamsize __ret = 0;\n       const int_type __eof = traits_type::eof();\n       while (__n--)\n@@ -266,10 +266,10 @@ namespace __gnu_cxx\n \t_M_unget_buf = traits_type::eof();\n       return __ret;\n     }\n-      \n+\n   template<>\n     inline std::streamsize\n-    stdio_sync_filebuf<wchar_t>::xsputn(const wchar_t* __s, \n+    stdio_sync_filebuf<wchar_t>::xsputn(const wchar_t* __s,\n \t\t\t\t\tstd::streamsize __n)\n     {\n       std::streamsize __ret = 0;\n@@ -292,4 +292,4 @@ namespace __gnu_cxx\n #endif\n } // namespace __gnu_cxx\n \n-#endif \n+#endif"}]}