{"sha": "46c07df8a17da325bab22f5f900e37fc2118e446", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjMDdkZjhhMTdkYTMyNWJhYjIyZjVmOTAwZTM3ZmMyMTE4ZTQ0Ng==", "commit": {"author": {"name": "Hartmut Penner", "email": "hpenner@de.ibm.com", "date": "2003-06-30T13:30:45Z"}, "committer": {"name": "Hartmut Penner", "email": "hpenner@gcc.gnu.org", "date": "2003-06-30T13:30:45Z"}, "message": "rs6000.c (rs6000_split_altivec_in_gprs): New function.\n\n2003-06-30 Hartmut Penner  <hpenner@de.ibm.com>\n\n        * config/rs6000/rs6000.c (rs6000_split_altivec_in_gprs): New function.\n        (altivec_in_gprs_p): New function.\n\n\t* config/rs6000/rs6000-protos (rs6000_split_altivec_in_gprs): New\n\tprototype.\n\t(altivec_in_gprs_p): New prototype.\n\n\t* config/rs6000/altivec.md (*movv4si_internal): Change\n\tmulti-assembler alternative to '#'. Add postreload splitter to\n\thandle this cases.\n\t(*movv4hi_internal): Likewise.\n\t(*movv4qi_internal): Likewise.\n\t(*movv4sf_internal): Likewise.\n\nFrom-SVN: r68704", "tree": {"sha": "52ab0108b953bee6751dd6f9ef466762f1ae4dcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ab0108b953bee6751dd6f9ef466762f1ae4dcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46c07df8a17da325bab22f5f900e37fc2118e446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c07df8a17da325bab22f5f900e37fc2118e446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c07df8a17da325bab22f5f900e37fc2118e446", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c07df8a17da325bab22f5f900e37fc2118e446/comments", "author": null, "committer": null, "parents": [{"sha": "8fca31a21e9b6c1bfae0bd267b3a325d51155c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fca31a21e9b6c1bfae0bd267b3a325d51155c53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fca31a21e9b6c1bfae0bd267b3a325d51155c53"}], "stats": {"total": 242, "additions": 222, "deletions": 20}, "files": [{"sha": "b78d3d8aa9492bdaf3e3f399683f3d01a75a8837", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46c07df8a17da325bab22f5f900e37fc2118e446", "patch": "@@ -1,3 +1,19 @@\n+2003-06-30 Hartmut Penner  <hpenner@de.ibm.com>\n+\n+        * config/rs6000/rs6000.c (rs6000_split_altivec_in_gprs): New function.\n+        (altivec_in_gprs_p): New function.\n+\n+\t* config/rs6000/rs6000-protos (rs6000_split_altivec_in_gprs): New \n+\tprototype.\n+\t(altivec_in_gprs_p): New prototype.\n+\n+\t* config/rs6000/altivec.md (*movv4si_internal): Change\n+\tmulti-assembler alternative to '#'. Add postreload splitter to\n+\thandle this cases.\n+\t(*movv4hi_internal): Likewise.\n+\t(*movv4qi_internal): Likewise.\n+\t(*movv4sf_internal): Likewise.\n+\n 2003-06-30  Jason Merrill  <jason@redhat.com>\n \n \t* defaults.h (PUSH_ARGS_REVERSED): Define default here."}, {"sha": "5b1dc3692929e1a82cba3361b8226f481959ffe9", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 112, "deletions": 20, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=46c07df8a17da325bab22f5f900e37fc2118e446", "patch": "@@ -101,15 +101,38 @@\n     case 0: return \\\"stvx %1,%y0\\\";\n     case 1: return \\\"lvx %0,%y1\\\";\n     case 2: return \\\"vor %0,%1,%1\\\";\n-    case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n-    case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n-    case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 3: return \\\"#\\\";\n+    case 4: return \\\"#\\\";\n+    case 5: return \\\"#\\\";\n     case 6: return output_vec_const_move (operands);\n     default: abort();\n     }\n }\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")])\n+\n+(define_split\n+  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V4SI 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V4SI 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 6))\n+   (set (match_dup 3) (match_dup 7))\n+   (set (match_dup 4) (match_dup 8))\n+   (set (match_dup 5) (match_dup 9))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n \n (define_split\n   [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"\")\n@@ -140,15 +163,38 @@\n      case 0: return \\\"stvx %1,%y0\\\";\n      case 1: return \\\"lvx %0,%y1\\\";\n      case 2: return \\\"vor %0,%1,%1\\\";\n-     case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n-     case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n-     case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+     case 3: return \\\"#\\\";\n+     case 4: return \\\"#\\\";\n+     case 5: return \\\"#\\\";\n      case 6: return output_vec_const_move (operands);\n      default: abort ();\n      }\n }\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")])\n+\n+(define_split\n+  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V8HI 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V8HI 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 6))\n+   (set (match_dup 3) (match_dup 7))\n+   (set (match_dup 4) (match_dup 8))\n+   (set (match_dup 5) (match_dup 9))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n \n (define_split\n   [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"\")\n@@ -179,15 +225,38 @@\n     case 0: return \\\"stvx %1,%y0\\\";\n     case 1: return \\\"lvx %0,%y1\\\";\n     case 2: return \\\"vor %0,%1,%1\\\";\n-    case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n-    case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n-    case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 3: return \\\"#\\\";\n+    case 4: return \\\"#\\\";\n+    case 5: return \\\"#\\\";\n     case 6: return output_vec_const_move (operands);\n     default: abort ();\n     }\n }\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")])\n+\n+(define_split\n+  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V16QI 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V16QI 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 6))\n+   (set (match_dup 3) (match_dup 7))\n+   (set (match_dup 4) (match_dup 8))\n+   (set (match_dup 5) (match_dup 9))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n \n (define_split\n   [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"\")\n@@ -218,15 +287,38 @@\n     case 0: return \\\"stvx %1,%y0\\\";\n     case 1: return \\\"lvx %0,%y1\\\";\n     case 2: return \\\"vor %0,%1,%1\\\";\n-    case 3: return \\\"stw%U0 %1,%0\\;stw %L1,%L0\\;stw %Y1,%Y0\\;stw %Z1,%Z0\\\";\n-    case 4: return \\\"lwz%U1 %0,%1\\;lwz %L0,%L1\\;lwz %Y0,%Y1\\;lwz %Z0,%Z1\\\";\n-    case 5: return \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 3: return \\\"#\\\";\n+    case 4: return \\\"#\\\";\n+    case 5: return \\\"#\\\";\n     case 6: return output_vec_const_move (operands);\n     default: abort ();\n     }\n }\"\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")\n-   (set_attr \"length\" \"*,*,*,16,16,16,*\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,*\")])\n+\n+(define_split\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V4SF 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V4SF 1 \"input_operand\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n+   && altivec_in_gprs_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 6))\n+   (set (match_dup 3) (match_dup 7))\n+   (set (match_dup 4) (match_dup 8))\n+   (set (match_dup 5) (match_dup 9))]\n+\"{\n+     rs6000_split_altivec_in_gprs (operands);\n+}\")\n \n (define_insn \"get_vrsave_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}, {"sha": "327ab1fa216caab3551104d659bedebec13eff6c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=46c07df8a17da325bab22f5f900e37fc2118e446", "patch": "@@ -101,6 +101,7 @@ extern int includes_rldic_lshift_p PARAMS ((rtx, rtx));\n extern int includes_rldicr_lshift_p PARAMS ((rtx, rtx));\n extern int registers_ok_for_quad_peep PARAMS ((rtx, rtx));\n extern int addrs_ok_for_quad_peep PARAMS ((rtx, rtx));\n+extern int altivec_in_gprs_p (rtx, rtx);\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode, rtx));\n extern int ccr_bit PARAMS ((rtx, int));\n@@ -125,6 +126,7 @@ extern int mtcrf_operation PARAMS ((rtx, enum machine_mode));\n extern int lmw_operation PARAMS ((rtx, enum machine_mode));\n extern struct rtx_def *create_TOC_reference PARAMS ((rtx));\n extern void rs6000_emit_eh_toc_restore PARAMS ((rtx));\n+extern void rs6000_split_altivec_in_gprs (rtx *);\n extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_reload_address PARAMS ((rtx, enum machine_mode,"}, {"sha": "df5d775ee16ab38ec344c424a9d099393dcd487b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c07df8a17da325bab22f5f900e37fc2118e446/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=46c07df8a17da325bab22f5f900e37fc2118e446", "patch": "@@ -2308,6 +2308,21 @@ small_data_operand (op, mode)\n   return 0;\n #endif\n }\n+\n+/* Return 1 for all valid move insn operand combination involving altivec      \n+   vectors in gprs.  */\n+\n+int\n+altivec_in_gprs_p (rtx op0, rtx op1)\n+{\n+  if (REG_P (op0) && REGNO_REG_CLASS (REGNO (op0)) == GENERAL_REGS)\n+    return 1;\n+\n+  if (REG_P (op1) && REGNO_REG_CLASS (REGNO (op1)) == GENERAL_REGS) \n+    return 1;\n+  return 0;\n+}\n+\n \f\n /* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */\n \n@@ -9640,6 +9655,83 @@ rs6000_emit_minmax (dest, code, op0, op1)\n   if (target != dest)\n     emit_move_insn (dest, target);\n }\n+\n+/* Called by altivec splitter.\n+   Input: \n+          operands[0] : Destination of move\n+          operands[1] : Source of move\n+\t  noperands   : Size of operands vector\n+   Output:\n+\t  operands[2-5] ([2-3] in 64 bit) : Destination slots\n+\t  operands[6-9] ([4-5] in 64 bit) : Source slots\n+\n+   Splits the move of operands[1] to operands[0].\n+   This is done, if GPRs are one of the operands.  In this case\n+   a sequence of simple move insns has to be issued.  The sequence of these\n+   move insns has to be done in correct order to avoid early clobber of the\n+   base register or destructive overlap of registers. \n+*/\n+\t  \n+void\n+rs6000_split_altivec_in_gprs (rtx *operands)\n+{\n+    int nregs, reg, i, j;\n+  enum machine_mode mode; \n+\n+  /* Calculate number to move (2/4 for 32/64 bit mode).  */ \n+\n+  reg = REG_P (operands[0]) ? REGNO (operands[0]) : REGNO (operands[1]); \n+  mode = GET_MODE (operands[0]);\n+  nregs = HARD_REGNO_NREGS (reg, mode);                                  \n+  \n+  if (REG_P (operands[1]) \n+      && REG_P (operands[0]) \n+      && (REGNO (operands[1]) < REGNO (operands[0])))\n+    {  \n+      /* Move register range backwards, if we have destructive overlap.  */\n+\n+      j = nregs;\n+      for (i = 0; i < nregs; i++)\n+        {\n+          j--;\n+          operands[i + 2] = operand_subword (operands[0], j, 0, mode);\n+          operands[i + 2 + nregs] = \n+            operand_subword (operands[1], j, 0, mode);   \n+        }\n+    }     \n+  else\n+    {\n+      j = -1;\n+\n+      if (GET_CODE (operands[1]) == MEM)\n+        {\n+          rtx breg;\n+          /* We have offsettable addresses only. If we use one of the\n+             registers to address memory, we have change that register last.  */            \n+          breg = GET_CODE (XEXP (operands[1], 0)) == PLUS ?\n+              XEXP (XEXP (operands[1], 0), 0) :\n+              XEXP (operands[1], 0);\n+\n+          if (REGNO (breg) >= REGNO (operands[0]) \n+              && REGNO (breg) < REGNO (operands[0]) + nregs)\n+              j = REGNO (breg) - REGNO (operands[0]);\n+        }\n+\n+      for (i = 0; i < nregs; i++)\n+        { \n+          /* Calculate index to next subword.  */\n+          j++;\n+          if (j == nregs) \n+            j = 0;\n+\n+          operands[i + 2] = operand_subword (operands[0], j, 0, mode);\n+          operands[i + 2 + nregs] = \n+            operand_subword (operands[1], j, 0, mode);\n+\n+        }\n+    }\n+}\n+\n \f\n /* This page contains routines that are used to determine what the\n    function prologue and epilogue code will do and write them out.  */"}]}