{"sha": "3232f0521cda16efeff012f65bc4d0b15d02a7e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIzMmYwNTIxY2RhMTZlZmVmZjAxMmY2NWJjNGQwYjE1ZDAyYTdlMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-06T08:59:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-06T08:59:09Z"}, "message": "Rework vrp_int_const_binop interface\n\n...to avoid a warning about uninitialised wide_ints.\n\n2017-11-06  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vrp.c (vrp_int_const_binop): Return true on success and\n\treturn the value by pointer.\n\t(extract_range_from_multiplicative_op_1): Update accordingly.\n\tReturn as soon as an operation fails.\n\nFrom-SVN: r254436", "tree": {"sha": "d0e0ad8e413d11a70432ed1718dd2f1565fa370c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0e0ad8e413d11a70432ed1718dd2f1565fa370c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3232f0521cda16efeff012f65bc4d0b15d02a7e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3232f0521cda16efeff012f65bc4d0b15d02a7e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3232f0521cda16efeff012f65bc4d0b15d02a7e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3232f0521cda16efeff012f65bc4d0b15d02a7e2/comments", "author": null, "committer": null, "parents": [{"sha": "469f5da70ac58d731bc510ba0e5e29fd2fc72f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469f5da70ac58d731bc510ba0e5e29fd2fc72f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469f5da70ac58d731bc510ba0e5e29fd2fc72f54"}], "stats": {"total": 150, "additions": 67, "deletions": 83}, "files": [{"sha": "5556e296bd6eebe42b26628ac4b0668825368ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3232f0521cda16efeff012f65bc4d0b15d02a7e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3232f0521cda16efeff012f65bc4d0b15d02a7e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3232f0521cda16efeff012f65bc4d0b15d02a7e2", "patch": "@@ -1,3 +1,10 @@\n+2017-11-06  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vrp.c (vrp_int_const_binop): Return true on success and\n+\treturn the value by pointer.\n+\t(extract_range_from_multiplicative_op_1): Update accordingly.\n+\tReturn as soon as an operation fails.\n+\n 2017-11-05  Tom de Vries  <tom@codesourcery.com>\n \n \tPR other/82784"}, {"sha": "2b7d9622f691226739e2cc3da6e5d927fe584013", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 60, "deletions": 83, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3232f0521cda16efeff012f65bc4d0b15d02a7e2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3232f0521cda16efeff012f65bc4d0b15d02a7e2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=3232f0521cda16efeff012f65bc4d0b15d02a7e2", "patch": "@@ -1602,21 +1602,20 @@ extract_range_from_ssa_name (value_range *vr, tree var)\n }\n \n \n-/* Wrapper around int_const_binop.  If the operation overflows and\n-   overflow is undefined, then adjust the result to be\n-   -INF or +INF depending on CODE, VAL1 and VAL2.  Sets *OVERFLOW_P\n-   to whether the operation overflowed.  For division by zero\n-   the result is indeterminate but *OVERFLOW_P is set.  */\n+/* Wrapper around int_const_binop.  Return true if we can compute the\n+   result; i.e. if the operation doesn't overflow or if the overflow is\n+   undefined.  In the latter case (if the operation overflows and\n+   overflow is undefined), then adjust the result to be -INF or +INF\n+   depending on CODE, VAL1 and VAL2.  Return the value in *RES.\n \n-static wide_int\n-vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n-\t\t     bool *overflow_p)\n+   Return false for division by zero, for which the result is\n+   indeterminate.  */\n+\n+static bool\n+vrp_int_const_binop (enum tree_code code, tree val1, tree val2, wide_int *res)\n {\n   bool overflow = false;\n   signop sign = TYPE_SIGN (TREE_TYPE (val1));\n-  wide_int res;\n-\n-  *overflow_p = false;\n \n   switch (code)\n     {\n@@ -1637,57 +1636,45 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  /* It's unclear from the C standard whether shifts can overflow.\n \t     The following code ignores overflow; perhaps a C standard\n \t     interpretation ruling is needed.  */\n-\t  res = wi::rshift (wi::to_wide (val1), wval2, sign);\n+\t  *res = wi::rshift (wi::to_wide (val1), wval2, sign);\n \telse\n-\t  res = wi::lshift (wi::to_wide (val1), wval2);\n+\t  *res = wi::lshift (wi::to_wide (val1), wval2);\n \tbreak;\n       }\n \n     case MULT_EXPR:\n-      res = wi::mul (wi::to_wide (val1),\n-\t\t     wi::to_wide (val2), sign, &overflow);\n+      *res = wi::mul (wi::to_wide (val1),\n+\t\t      wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case TRUNC_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       if (val2 == 0)\n-\t{\n-\t  *overflow_p = true;\n-\t  return res;\n-\t}\n+\treturn false;\n       else\n-\tres = wi::div_trunc (wi::to_wide (val1),\n-\t\t\t     wi::to_wide (val2), sign, &overflow);\n+\t*res = wi::div_trunc (wi::to_wide (val1),\n+\t\t\t      wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case FLOOR_DIV_EXPR:\n       if (val2 == 0)\n-\t{\n-\t  *overflow_p = true;\n-\t  return res;\n-\t}\n-      res = wi::div_floor (wi::to_wide (val1),\n-\t\t\t   wi::to_wide (val2), sign, &overflow);\n+\treturn false;\n+      *res = wi::div_floor (wi::to_wide (val1),\n+\t\t\t    wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case CEIL_DIV_EXPR:\n       if (val2 == 0)\n-\t{\n-\t  *overflow_p = true;\n-\t  return res;\n-\t}\n-      res = wi::div_ceil (wi::to_wide (val1),\n-\t\t\t  wi::to_wide (val2), sign, &overflow);\n+\treturn false;\n+      *res = wi::div_ceil (wi::to_wide (val1),\n+\t\t\t   wi::to_wide (val2), sign, &overflow);\n       break;\n \n     case ROUND_DIV_EXPR:\n       if (val2 == 0)\n-\t{\n-\t  *overflow_p = 0;\n-\t  return res;\n-\t}\n-      res = wi::div_round (wi::to_wide (val1),\n-\t\t\t   wi::to_wide (val2), sign, &overflow);\n+\treturn false;\n+      *res = wi::div_round (wi::to_wide (val1),\n+\t\t\t    wi::to_wide (val2), sign, &overflow);\n       break;\n \n     default:\n@@ -1730,16 +1717,15 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t  || code == CEIL_DIV_EXPR\n \t  || code == EXACT_DIV_EXPR\n \t  || code == ROUND_DIV_EXPR)\n-\treturn wi::max_value (TYPE_PRECISION (TREE_TYPE (val1)),\n+\t*res = wi::max_value (TYPE_PRECISION (TREE_TYPE (val1)),\n \t\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n       else\n-\treturn wi::min_value (TYPE_PRECISION (TREE_TYPE (val1)),\n+\t*res = wi::min_value (TYPE_PRECISION (TREE_TYPE (val1)),\n \t\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n+      return true;\n     }\n \n-  *overflow_p = overflow;\n-\n-  return res;\n+  return !overflow;\n }\n \n \n@@ -1835,7 +1821,6 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n {\n   enum value_range_type rtype;\n   wide_int val, min, max;\n-  bool sop;\n   tree type;\n \n   /* Multiplications, divisions and shifts are a bit tricky to handle,\n@@ -1866,58 +1851,50 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n   signop sgn = TYPE_SIGN (type);\n \n   /* Compute the 4 cross operations and their minimum and maximum value.  */\n-  sop = false;\n-  val = vrp_int_const_binop (code, vr0->min, vr1->min, &sop);\n-  if (! sop)\n-    min = max = val;\n-\n-  if (vr1->max == vr1->min)\n-    ;\n-  else if (! sop)\n+  if (!vrp_int_const_binop (code, vr0->min, vr1->min, &val))\n     {\n-      val = vrp_int_const_binop (code, vr0->min, vr1->max, &sop);\n-      if (! sop)\n-\t{\n-\t  if (wi::lt_p (val, min, sgn))\n-\t    min = val;\n-\t  else if (wi::gt_p (val, max, sgn))\n-\t    max = val;\n-\t}\n+      set_value_range_to_varying (vr);\n+      return;\n     }\n+  min = max = val;\n \n-  if (vr0->max == vr0->min)\n-    ;\n-  else if (! sop)\n+  if (vr1->max != vr1->min)\n     {\n-      val = vrp_int_const_binop (code, vr0->max, vr1->min, &sop);\n-      if (! sop)\n+      if (!vrp_int_const_binop (code, vr0->min, vr1->max, &val))\n \t{\n-\t  if (wi::lt_p (val, min, sgn))\n-\t    min = val;\n-\t  else if (wi::gt_p (val, max, sgn))\n-\t    max = val;\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n \t}\n+      if (wi::lt_p (val, min, sgn))\n+\tmin = val;\n+      else if (wi::gt_p (val, max, sgn))\n+\tmax = val;\n     }\n \n-  if (vr0->min == vr0->max || vr1->min == vr1->max)\n-    ;\n-  else if (! sop)\n+  if (vr0->max != vr0->min)\n     {\n-      val = vrp_int_const_binop (code, vr0->max, vr1->max, &sop);\n-      if (! sop)\n+      if (!vrp_int_const_binop (code, vr0->max, vr1->min, &val))\n \t{\n-\t  if (wi::lt_p (val, min, sgn))\n-\t    min = val;\n-\t  else if (wi::gt_p (val, max, sgn))\n-\t    max = val;\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n \t}\n+      if (wi::lt_p (val, min, sgn))\n+\tmin = val;\n+      else if (wi::gt_p (val, max, sgn))\n+\tmax = val;\n     }\n \n-  /* If either operation overflowed, drop to VARYING.  */\n-  if (sop)\n+  if (vr0->min != vr0->max && vr1->min != vr1->max)\n     {\n-      set_value_range_to_varying (vr);\n-      return;\n+      if (!vrp_int_const_binop (code, vr0->max, vr1->max, &val))\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+      if (wi::lt_p (val, min, sgn))\n+\tmin = val;\n+      else if (wi::gt_p (val, max, sgn))\n+\tmax = val;\n     }\n \n   /* If the new range has its limits swapped around (MIN > MAX),"}]}