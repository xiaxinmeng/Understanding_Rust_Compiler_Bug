{"sha": "c4b8f3730a80025192fdb485ad2535c165340e41", "node_id": "C_kwDOANBUbNoAKGM0YjhmMzczMGE4MDAyNTE5MmZkYjQ4NWFkMjUzNWMxNjUzNDBlNDE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-20T14:51:50Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-20T23:43:28Z"}, "message": "analyzer: reject ((i + 1 > 0) && (i < 0)) for integers [PR94362]\n\nPR analyzer/94362 reports a false positive from\n-Wanalyzer-null-dereference seen when analyzing OpenSSL.\n\nThe root cause is that the analyzer's path feasibility checker\nerroneously considers this to be feasible:\n  (R + 1 > 0) && (R < 0)\nfor int R (the return value from sk_EVP_PKEY_ASN1_METHOD_num),\nwhereas it's not satisfiable for any int R.\n\nThis patch makes the constraint manager try harder to reject\nsuch combinations of conditions, fixing the false positive;\nperhaps in the longer term we ought to use an SMT solver.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/94362\n\t* constraint-manager.cc (bound::ensure_closed): Convert param to\n\tenum bound_kind.\n\t(range::constrained_to_single_element): Likewise.\n\t(range::add_bound): New.\n\t(constraint_manager::add_constraint): Handle SVAL + OFFSET\n\tcompared to a constant.\n\t(constraint_manager::get_ec_bounds): Rewrite in terms of\n\trange::add_bound.\n\t(constraint_manager::eval_condition): Reject if range::add_bound\n\tfails.\n\t(selftest::test_constant_comparisons): Add test coverage for\n\tvarious impossible combinations of integer comparisons.\n\t* constraint-manager.h (enum bound_kind): New.\n\t(struct bound): Likewise.\n\t(bound::ensure_closed): Convert to param to enum bound_kind.\n\t(struct range): Convert to...\n\t(class range): ...this, making fields private.\n\t(range::add_bound): New decls.\n\t* region-model.cc (region_model::add_constraint): Fail if\n\tconstraint_manager::add_constraint fails.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/94362\n\t* gcc.dg/analyzer/pr94362-1.c: New test.\n\t* gcc.dg/analyzer/pr94362-2.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "2d29566a6086c67b898b8c61ec63f3bf1516dd7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d29566a6086c67b898b8c61ec63f3bf1516dd7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4b8f3730a80025192fdb485ad2535c165340e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b8f3730a80025192fdb485ad2535c165340e41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b8f3730a80025192fdb485ad2535c165340e41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b8f3730a80025192fdb485ad2535c165340e41/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5a9d76be849b4cf20b1b687febc34a937381dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a9d76be849b4cf20b1b687febc34a937381dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a9d76be849b4cf20b1b687febc34a937381dc3"}], "stats": {"total": 294, "additions": 281, "deletions": 13}, "files": [{"sha": "7c4a85bbb245addf7b8902ba3b019fbb7dcbb020", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 163, "deletions": 9, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=c4b8f3730a80025192fdb485ad2535c165340e41", "patch": "@@ -117,15 +117,15 @@ minus_one (tree cst)\n    closed one.  */\n \n void\n-bound::ensure_closed (bool is_upper)\n+bound::ensure_closed (enum bound_kind bound_kind)\n {\n   if (!m_closed)\n     {\n       /* Offset by 1 in the appropriate direction.\n \t For example, convert 3 < x into 4 <= x,\n \t and convert x < 5 into x <= 4.  */\n       gcc_assert (CONSTANT_CLASS_P (m_constant));\n-      m_constant = fold_build2 (is_upper ? MINUS_EXPR : PLUS_EXPR,\n+      m_constant = fold_build2 (bound_kind == BK_UPPER ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\tTREE_TYPE (m_constant),\n \t\t\t\tm_constant, integer_one_node);\n       gcc_assert (CONSTANT_CLASS_P (m_constant));\n@@ -205,8 +205,8 @@ range::constrained_to_single_element ()\n     return NULL_TREE;\n \n   /* Convert any open bounds to closed bounds.  */\n-  m_lower_bound.ensure_closed (false);\n-  m_upper_bound.ensure_closed (true);\n+  m_lower_bound.ensure_closed (BK_LOWER);\n+  m_upper_bound.ensure_closed (BK_UPPER);\n \n   // Are they equal?\n   tree comparison = fold_binary (EQ_EXPR, boolean_type_node,\n@@ -301,6 +301,80 @@ range::above_upper_bound (tree rhs_const) const\n \t\t\t    m_upper_bound.m_constant).is_true ();\n }\n \n+/* Attempt to add B to the bound of the given kind of this range.\n+   Return true if feasible; false if infeasible.  */\n+\n+bool\n+range::add_bound (bound b, enum bound_kind bound_kind)\n+{\n+  b.ensure_closed (bound_kind);\n+\n+  switch (bound_kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case BK_LOWER:\n+      /* Discard redundant bounds.  */\n+      if (m_lower_bound.m_constant)\n+\t{\n+\t  m_lower_bound.ensure_closed (BK_LOWER);\n+\t  if (!tree_int_cst_lt (b.m_constant,\n+\t\t\t\tm_lower_bound.m_constant))\n+\t    return true;\n+\t}\n+      m_lower_bound = b;\n+      break;\n+    case BK_UPPER:\n+      /* Discard redundant bounds.  */\n+      if (m_upper_bound.m_constant)\n+\t{\n+\t  m_upper_bound.ensure_closed (BK_UPPER);\n+\t  if (tree_int_cst_le (b.m_constant,\n+\t\t\t       m_upper_bound.m_constant))\n+\t    return true;\n+\t}\n+      m_upper_bound = b;\n+      break;\n+    }\n+  if (m_lower_bound.m_constant\n+      && m_upper_bound.m_constant)\n+    {\n+      m_lower_bound.ensure_closed (BK_LOWER);\n+      m_upper_bound.ensure_closed (BK_UPPER);\n+\n+      /* Reject LOWER <= V <= UPPER when LOWER > UPPER.  */\n+      if (!tree_int_cst_le (m_lower_bound.m_constant,\n+\t\t\t    m_upper_bound.m_constant))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Attempt to add (RANGE OP RHS_CONST) as a bound to this range.\n+   Return true if feasible; false if infeasible.  */\n+\n+bool\n+range::add_bound (enum tree_code op, tree rhs_const)\n+{\n+  switch (op)\n+    {\n+    default:\n+      return true;\n+    case LT_EXPR:\n+      /* \"V < RHS_CONST\"  */\n+      return add_bound (bound (rhs_const, false), BK_UPPER);\n+    case LE_EXPR:\n+      /* \"V <= RHS_CONST\"  */\n+      return add_bound (bound (rhs_const, true), BK_UPPER);\n+    case GE_EXPR:\n+      /* \"V >= RHS_CONST\"  */\n+      return add_bound (bound (rhs_const, true), BK_LOWER);\n+    case GT_EXPR:\n+      /* \"V > RHS_CONST\"  */\n+      return add_bound (bound (rhs_const, false), BK_LOWER);\n+    }\n+}\n+\n /* struct bounded_range.  */\n \n bounded_range::bounded_range (const_tree lower, const_tree upper)\n@@ -1718,6 +1792,27 @@ constraint_manager::add_constraint (const svalue *lhs,\n       return false;\n   }\n \n+  /* If adding\n+       (SVAL + OFFSET) > CST,\n+     then that can imply:\n+       SVAL > (CST - OFFSET).  */\n+  if (const binop_svalue *lhs_binop = lhs->dyn_cast_binop_svalue ())\n+    if (tree rhs_cst = rhs->maybe_get_constant ())\n+      if (tree offset = lhs_binop->get_arg1 ()->maybe_get_constant ())\n+\tif ((op == GT_EXPR || op == LT_EXPR\n+\t     || op == GE_EXPR || op == LE_EXPR)\n+\t    && lhs_binop->get_op () == PLUS_EXPR)\n+\t  {\n+\t    tree offset_of_cst = fold_build2 (MINUS_EXPR, TREE_TYPE (rhs_cst),\n+\t\t\t\t\t      rhs_cst, offset);\n+\t    const svalue *implied_lhs = lhs_binop->get_arg0 ();\n+\t    enum tree_code implied_op = op;\n+\t    const svalue *implied_rhs\n+\t      = m_mgr->get_or_create_constant_svalue (offset_of_cst);\n+\t    if (!add_constraint (implied_lhs, implied_op, implied_rhs))\n+\t      return false;\n+\t  }\n+\n   add_unknown_constraint (lhs_ec_id, op, rhs_ec_id);\n   return true;\n }\n@@ -2241,12 +2336,12 @@ constraint_manager::get_ec_bounds (equiv_class_id ec_id) const\n \n \t      case CONSTRAINT_LT:\n \t\t/* We have \"EC_ID < OTHER_CST\".  */\n-\t\tresult.m_upper_bound = bound (other_cst, false);\n+\t\tresult.add_bound (bound (other_cst, false), BK_UPPER);\n \t\tbreak;\n \n \t      case CONSTRAINT_LE:\n \t\t/* We have \"EC_ID <= OTHER_CST\".  */\n-\t\tresult.m_upper_bound = bound (other_cst, true);\n+\t\tresult.add_bound (bound (other_cst, true), BK_UPPER);\n \t\tbreak;\n \t      }\n \t}\n@@ -2263,13 +2358,13 @@ constraint_manager::get_ec_bounds (equiv_class_id ec_id) const\n \t      case CONSTRAINT_LT:\n \t\t/* We have \"OTHER_CST < EC_ID\"\n \t\t   i.e. \"EC_ID > OTHER_CST\".  */\n-\t\tresult.m_lower_bound = bound (other_cst, false);\n+\t\tresult.add_bound (bound (other_cst, false), BK_LOWER);\n \t\tbreak;\n \n \t      case CONSTRAINT_LE:\n \t\t/* We have \"OTHER_CST <= EC_ID\"\n \t\t   i.e. \"EC_ID >= OTHER_CST\".  */\n-\t\tresult.m_lower_bound = bound (other_cst, true);\n+\t\tresult.add_bound (bound (other_cst, true), BK_LOWER);\n \t\tbreak;\n \t      }\n \t}\n@@ -2350,7 +2445,15 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n \n   /* Look at existing bounds on LHS_EC.  */\n   range lhs_bounds = get_ec_bounds (lhs_ec);\n-  return lhs_bounds.eval_condition (op, rhs_const);\n+  tristate result = lhs_bounds.eval_condition (op, rhs_const);\n+  if (result.is_known ())\n+    return result;\n+\n+  /* Also reject if range::add_bound fails.  */\n+  if (!lhs_bounds.add_bound (op, rhs_const))\n+    return tristate (false);\n+\n+  return tristate::unknown ();\n }\n \n /* Evaluate the condition LHS OP RHS, without modifying this\n@@ -3452,6 +3555,7 @@ test_transitivity ()\n static void\n test_constant_comparisons ()\n {\n+  tree int_1 = build_int_cst (integer_type_node, 1);\n   tree int_3 = build_int_cst (integer_type_node, 3);\n   tree int_4 = build_int_cst (integer_type_node, 4);\n   tree int_5 = build_int_cst (integer_type_node, 5);\n@@ -3462,6 +3566,8 @@ test_constant_comparisons ()\n   tree a = build_global_decl (\"a\", integer_type_node);\n   tree b = build_global_decl (\"b\", integer_type_node);\n \n+  tree a_plus_one = build2 (PLUS_EXPR, integer_type_node, a, int_1);\n+\n   /* Given a >= 1024, then a <= 1023 should be impossible.  */\n   {\n     region_model_manager mgr;\n@@ -3562,6 +3668,54 @@ test_constant_comparisons ()\n     ASSERT_CONDITION_UNKNOWN (model, f, EQ_EXPR, float_4);\n     ASSERT_CONDITION_UNKNOWN (model, f, EQ_EXPR, int_4);\n   }\n+\n+  /* \"a > 3 && a <= 3\" should be impossible.  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n+    ADD_UNSAT_CONSTRAINT (model, a, LE_EXPR, int_3);\n+  }\n+\n+  /* \"(a + 1) > 3 && a < 3\" should be impossible.  */\n+  {\n+    region_model_manager mgr;\n+    {\n+      region_model model (&mgr);\n+      ADD_SAT_CONSTRAINT (model, a_plus_one, GT_EXPR, int_3);\n+      ADD_UNSAT_CONSTRAINT (model, a, LT_EXPR, int_3);\n+    }\n+    {\n+      region_model model (&mgr);\n+      ADD_SAT_CONSTRAINT (model, a, LT_EXPR, int_3);\n+      ADD_UNSAT_CONSTRAINT (model, a_plus_one, GT_EXPR, int_3);\n+    }\n+  }\n+\n+  /* \"3 < a < 4\" should be impossible for integer a.  */\n+  {\n+    region_model_manager mgr;\n+    {\n+      region_model model (&mgr);\n+      ADD_SAT_CONSTRAINT (model, int_3, LT_EXPR, a);\n+      ADD_UNSAT_CONSTRAINT (model, a, LT_EXPR, int_4);\n+    }\n+    {\n+      region_model model (&mgr);\n+      ADD_SAT_CONSTRAINT (model, a, LT_EXPR, int_4);\n+      ADD_UNSAT_CONSTRAINT (model, int_3, LT_EXPR, a);\n+    }\n+    {\n+      region_model model (&mgr);\n+      ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n+      ADD_UNSAT_CONSTRAINT (model, int_4, GT_EXPR, a);\n+    }\n+    {\n+      region_model model (&mgr);\n+      ADD_SAT_CONSTRAINT (model, int_4, GT_EXPR, a);\n+      ADD_UNSAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n+    }\n+  }\n }\n \n /* Verify various lower-level implementation details about"}, {"sha": "f67c764749742b629f6dff0fdf9f072b1c59db4a", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=c4b8f3730a80025192fdb485ad2535c165340e41", "patch": "@@ -25,6 +25,12 @@ namespace ana {\n \n class constraint_manager;\n \n+enum bound_kind\n+{\n+  BK_LOWER,\n+  BK_UPPER\n+};\n+\n /* One of the end-points of a range.  */\n \n struct bound\n@@ -33,7 +39,7 @@ struct bound\n   bound (tree constant, bool closed)\n   : m_constant (constant), m_closed (closed) {}\n \n-  void ensure_closed (bool is_upper);\n+  void ensure_closed (enum bound_kind bound_kind);\n \n   const char * get_relation_as_str () const;\n \n@@ -44,8 +50,9 @@ struct bound\n /* A range of values, used for determining if a value has been\n    constrained to just one possible constant value.  */\n \n-struct range\n+class range\n {\n+public:\n   range () : m_lower_bound (), m_upper_bound () {}\n   range (const bound &lower, const bound &upper)\n   : m_lower_bound (lower), m_upper_bound (upper) {}\n@@ -60,6 +67,10 @@ struct range\n   bool below_lower_bound (tree rhs_const) const;\n   bool above_upper_bound (tree rhs_const) const;\n \n+  bool add_bound (bound b, enum bound_kind bound_kind);\n+  bool add_bound (enum tree_code op, tree rhs_const);\n+\n+private:\n   bound m_lower_bound;\n   bound m_upper_bound;\n };"}, {"sha": "f6b7f986a398cd79845ac0d30658c8ddafc10960", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=c4b8f3730a80025192fdb485ad2535c165340e41", "patch": "@@ -2801,8 +2801,9 @@ region_model::add_constraint (const svalue *lhs,\n   if (add_constraints_from_binop (lhs, op, rhs, &out, ctxt))\n     return out;\n \n-  /* Store the constraint.  */\n-  m_constraints->add_constraint (lhs, op, rhs);\n+  /* Attempt to store the constraint.  */\n+  if (!m_constraints->add_constraint (lhs, op, rhs))\n+    return false;\n \n   /* Notify the context, if any.  This exists so that the state machines\n      in a program_state can be notified about the condition, and so can"}, {"sha": "1302cedb856ee51be1cd07b83b381d4106765716", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94362-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94362-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94362-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94362-1.c?ref=c4b8f3730a80025192fdb485ad2535c165340e41", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+/* TODO: remove the need for -Wno-analyzer-too-complex.  */\n+\n+typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;\n+typedef struct engine_st ENGINE;\n+struct stack_st_EVP_PKEY_ASN1_METHOD;\n+struct evp_pkey_asn1_method_st {\n+  unsigned long pkey_flags;\n+};\n+\n+const EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,\n+                                                      const char *str, int len);\n+extern int\n+sk_EVP_PKEY_ASN1_METHOD_num(const struct stack_st_EVP_PKEY_ASN1_METHOD *sk);\n+extern const EVP_PKEY_ASN1_METHOD *\n+sk_EVP_PKEY_ASN1_METHOD_value(const struct stack_st_EVP_PKEY_ASN1_METHOD *sk,\n+                              int idx);\n+extern const EVP_PKEY_ASN1_METHOD hmac_asn1_meth;\n+static const EVP_PKEY_ASN1_METHOD *standard_methods[] = {&hmac_asn1_meth};\n+static struct stack_st_EVP_PKEY_ASN1_METHOD *app_methods = ((void *)0);\n+\n+int EVP_PKEY_asn1_get_count(void) {\n+  int num = (sizeof(standard_methods) / sizeof((standard_methods)[0]));\n+  if (app_methods)\n+    num += sk_EVP_PKEY_ASN1_METHOD_num(app_methods);\n+  return num;\n+}\n+\n+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx) {\n+  int num = (sizeof(standard_methods) / sizeof((standard_methods)[0]));\n+  if (idx < 0)\n+    return ((void *)0);\n+  if (idx < num)\n+    return standard_methods[idx];\n+  idx -= num;\n+  return sk_EVP_PKEY_ASN1_METHOD_value(app_methods, idx);\n+}\n+\n+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe, const char *str,\n+                                                   int len) {\n+  int i;\n+  const EVP_PKEY_ASN1_METHOD *ameth = ((void *)0);\n+\n+  if (pe) {\n+    ENGINE *e;\n+    ameth = ENGINE_pkey_asn1_find_str(&e, str, len);\n+    if (ameth) {\n+      *pe = e;\n+      return ameth;\n+    }\n+    *pe = ((void *)0);\n+  }\n+  for (i = EVP_PKEY_asn1_get_count(); i-- > 0;) {\n+    ameth = EVP_PKEY_asn1_get0(i);\n+    if (ameth->pkey_flags & 0x1)\n+      continue;\n+    return ameth;\n+  }\n+  return ((void *)0);\n+}"}, {"sha": "301d2ed6063ba17be80f54d7693d48789be8635f", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94362-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94362-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b8f3730a80025192fdb485ad2535c165340e41/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94362-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94362-2.c?ref=c4b8f3730a80025192fdb485ad2535c165340e41", "patch": "@@ -0,0 +1,42 @@\n+/* Verify that we consider various paths to be impossible,\n+   using functions to thwart early optimizations.  */\n+\n+#include \"analyzer-decls.h\"\n+\n+void test_1 (int idx)\n+{\n+  if (idx > 0)\n+    if (idx - 1 < 0)\n+      __analyzer_dump_path (); /* { dg-bogus \"\" } */\n+}\n+\n+static int called_by_test_1a (int idx)\n+{\n+  return idx - 1;\n+}\n+\n+void test_1a (int idx)\n+{\n+  if (idx > 0)\n+    if (called_by_test_1a (idx) < 0)\n+      __analyzer_dump_path (); /* { dg-bogus \"\" } */\n+}\n+\n+void test_2 (int idx)\n+{\n+  if (idx + 1 > 0)\n+    if (idx < 0)\n+      __analyzer_dump_path (); /* { dg-bogus \"\" } */\n+}\n+\n+static int called_by_test_2a (int idx)\n+{\n+  return idx + 1;\n+}\n+\n+void test_2a (int idx)\n+{\n+  if (called_by_test_2a (idx) > 0)\n+    if (idx < 0)\n+      __analyzer_dump_path (); /* { dg-bogus \"\" } */\n+}"}]}