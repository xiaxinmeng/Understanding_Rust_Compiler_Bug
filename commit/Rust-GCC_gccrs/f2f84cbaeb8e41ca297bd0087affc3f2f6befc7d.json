{"sha": "f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJmODRjYmFlYjhlNDFjYTI5N2JkMDA4N2FmZmMzZjJmNmJlZmM3ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-07T15:32:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-07T15:32:16Z"}, "message": "v850.c (print_operand): Use gcc_assert and gcc_unreachable, as appropriate.\n\n\t* config/v850/v850.c (print_operand): Use gcc_assert and\n\tgcc_unreachable, as appropriate.\n\t(print_operand_address, v850_handle_data_area_attribute,\n\tv850_encode_data_area, construct_restore_jr, construct_save_jarl,\n\tv850_insert_attributes, construct_prepare_instruction): Likewise.\n\t* config/v850/v850.h (INITIAL_ELIMINATION_OFFSET): Likewise.\n\t* config/v850/v850.md (movsicc, *sasf_1): Likewise.\n\nFrom-SVN: r99351", "tree": {"sha": "6bfb605d839bf5fe26d60522b3aa46964992283c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bfb605d839bf5fe26d60522b3aa46964992283c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/comments", "author": null, "committer": null, "parents": [{"sha": "bb22512c9f2a6e96e1b97b417f58b7d42b121912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb22512c9f2a6e96e1b97b417f58b7d42b121912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb22512c9f2a6e96e1b97b417f58b7d42b121912"}], "stats": {"total": 284, "additions": 132, "deletions": 152}, "files": [{"sha": "cea5099f57740115e2de66f48929c64536903ad4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "patch": "@@ -1,3 +1,13 @@\n+2005-05-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/v850/v850.c (print_operand): Use gcc_assert and\n+\tgcc_unreachable, as appropriate.\n+\t(print_operand_address, v850_handle_data_area_attribute,\n+\tv850_encode_data_area, construct_restore_jr, construct_save_jarl,\n+\tv850_insert_attributes, construct_prepare_instruction): Likewise.\n+\t* config/v850/v850.h (INITIAL_ELIMINATION_OFFSET): Likewise.\n+\t* config/v850/v850.md (movsicc, *sasf_1): Likewise.\n+\n 2005-05-07  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-loop-ivcanon.c, config/i386/i386.c,"}, {"sha": "06e26db0e1e66995c5547ce64c4b3a47f0c6dd4a", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 99, "deletions": 130, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "patch": "@@ -518,30 +518,40 @@ print_operand (FILE * file, rtx x, int code)\n \t    fprintf (file, \"l\");\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n       break;\n     case 'F':\t\t\t/* high word of CONST_DOUBLE */\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"%d\", (INTVAL (x) >= 0) ? 0 : -1);\n-      else if (GET_CODE (x) == CONST_DOUBLE)\n+      switch (GET_CODE (x))\n \t{\n+\tcase CONST_INT:\n+\t  fprintf (file, \"%d\", (INTVAL (x) >= 0) ? 0 : -1);\n+\t  break;\n+\t  \n+\tcase CONST_DOUBLE:\n \t  const_double_split (x, &high, &low);\n \t  fprintf (file, \"%ld\", (long) high);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n       break;\n     case 'G':\t\t\t/* low word of CONST_DOUBLE */\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"%ld\", (long) INTVAL (x));\n-      else if (GET_CODE (x) == CONST_DOUBLE)\n+      switch (GET_CODE (x))\n \t{\n+\tcase CONST_INT:\n+\t  fprintf (file, \"%ld\", (long) INTVAL (x));\n+\t  break;\n+\t  \n+\tcase CONST_DOUBLE:\n \t  const_double_split (x, &high, &low);\n \t  fprintf (file, \"%ld\", (long) low);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n       break;\n     case 'L':\n       fprintf (file, \"%d\\n\", (int)(INTVAL (x) & 0xffff));\n@@ -550,54 +560,42 @@ print_operand (FILE * file, rtx x, int code)\n       fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n       break;\n     case 'O':\n-      if (special_symbolref_operand (x, VOIDmode))\n-        {\n-\t  if (GET_CODE (x) == SYMBOL_REF)\n-\t    ;\n-\t  else if (GET_CODE (x) == CONST)\n-\t    x = XEXP (XEXP (x, 0), 0);\n-\t  else\n-\t    abort ();\n-\n-          if (SYMBOL_REF_ZDA_P (x))\n-            fprintf (file, \"zdaoff\");\n-          else if (SYMBOL_REF_SDA_P (x))\n-            fprintf (file, \"sdaoff\");\n-          else if (SYMBOL_REF_TDA_P (x))\n-            fprintf (file, \"tdaoff\");\n-          else\n-            abort ();\n-        }\n+      gcc_assert (special_symbolref_operand (x, VOIDmode));\n+      \n+      if (GET_CODE (x) == CONST)\n+\tx = XEXP (XEXP (x, 0), 0);\n+      else\n+\tgcc_assert (GET_CODE (x) == SYMBOL_REF);\n+      \n+      if (SYMBOL_REF_ZDA_P (x))\n+\tfprintf (file, \"zdaoff\");\n+      else if (SYMBOL_REF_SDA_P (x))\n+\tfprintf (file, \"sdaoff\");\n+      else if (SYMBOL_REF_TDA_P (x))\n+\tfprintf (file, \"tdaoff\");\n       else\n-        abort ();\n+\tgcc_unreachable ();\n       break;\n     case 'P':\n-      if (special_symbolref_operand (x, VOIDmode))\n-        output_addr_const (file, x);\n-      else\n-        abort ();\n+      gcc_assert (special_symbolref_operand (x, VOIDmode));\n+      output_addr_const (file, x);\n       break;\n     case 'Q':\n-      if (special_symbolref_operand (x, VOIDmode))\n-        {\n-\t  if (GET_CODE (x) == SYMBOL_REF)\n-\t    ;\n-\t  else if (GET_CODE (x) == CONST)\n-\t    x = XEXP (XEXP (x, 0), 0);\n-\t  else\n-\t    abort ();\n-\n-          if (SYMBOL_REF_ZDA_P (x))\n-            fprintf (file, \"r0\");\n-          else if (SYMBOL_REF_SDA_P (x))\n-            fprintf (file, \"gp\");\n-          else if (SYMBOL_REF_TDA_P (x))\n-            fprintf (file, \"ep\");\n-          else\n-            abort ();\n-        }\n+      gcc_assert (special_symbolref_operand (x, VOIDmode));\n+      \n+      if (GET_CODE (x) == CONST)\n+\tx = XEXP (XEXP (x, 0), 0);\n       else\n-        abort ();\n+\tgcc_assert (GET_CODE (x) == SYMBOL_REF);\n+      \n+      if (SYMBOL_REF_ZDA_P (x))\n+\tfprintf (file, \"r0\");\n+      else if (SYMBOL_REF_SDA_P (x))\n+\tfprintf (file, \"gp\");\n+      else if (SYMBOL_REF_TDA_P (x))\n+\tfprintf (file, \"ep\");\n+      else\n+\tgcc_unreachable ();\n       break;\n     case 'R':\t\t/* 2nd word of a double.  */\n       switch (GET_CODE (x))\n@@ -636,7 +634,7 @@ print_operand (FILE * file, rtx x, int code)\n       switch (GET_MODE (x))\n \t{\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tcase QImode: fputs (\".b\", file); break;\n \tcase HImode: fputs (\".h\", file); break;\n@@ -648,12 +646,13 @@ print_operand (FILE * file, rtx x, int code)\n       fputs (reg_names[0], file);\n       break;\n     case 'z':\t\t\t/* reg or zero */\n-      if (x == const0_rtx)\n-\tfputs (reg_names[0], file);\n-      else if (GET_CODE (x) == REG)\n+      if (GET_CODE (x) == REG)\n \tfputs (reg_names[REGNO (x)], file);\n       else\n-\tabort ();\n+\t{\n+\t  gcc_assert (x == const0_rtx);\n+\t  fputs (reg_names[0], file);\n+\t}\n       break;\n     default:\n       switch (GET_CODE (x))\n@@ -680,7 +679,7 @@ print_operand (FILE * file, rtx x, int code)\n \t  print_operand_address (file, x);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -779,7 +778,7 @@ print_operand_address (FILE * file, rtx addr)\n               reg_name = \"ep\";\n             }\n           else\n-            abort ();\n+            gcc_unreachable ();\n \n           fprintf (file, \"%s(\", off_name);\n           output_addr_const (file, addr);\n@@ -2131,7 +2130,7 @@ v850_handle_data_area_attribute (tree* node,\n   else if (is_attribute_p (\"zda\", name))\n     data_area = DATA_AREA_ZDA;\n   else\n-    abort ();\n+    gcc_unreachable ();\n   \n   switch (TREE_CODE (decl))\n     {\n@@ -2246,7 +2245,7 @@ v850_encode_data_area (tree decl, rtx symbol)\n     case DATA_AREA_ZDA: flags |= SYMBOL_FLAG_ZDA; break;\n     case DATA_AREA_TDA: flags |= SYMBOL_FLAG_TDA; break;\n     case DATA_AREA_SDA: flags |= SYMBOL_FLAG_SDA; break;\n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n   SYMBOL_REF_FLAGS (symbol) = flags;\n }\n@@ -2285,12 +2284,9 @@ construct_restore_jr (rtx op)\n \n   /* Work out how many bytes to pop off the stack before retrieving\n      registers.  */\n-  if (GET_CODE (XVECEXP (op, 0, 1)) != SET)\n-    abort ();\n-  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) != PLUS)\n-    abort ();\n-  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (XVECEXP (op, 0, 1)) == SET);\n+  gcc_assert (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS);\n+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) == CONST_INT);\n     \n   stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1));\n \n@@ -2310,12 +2306,10 @@ construct_restore_jr (rtx op)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       \n-      if (GET_CODE (vector_element) != SET)\n-\tabort ();\n-      if (GET_CODE (SET_DEST (vector_element)) != REG)\n-\tabort ();\n-      if (! register_is_ok_for_epilogue (SET_DEST (vector_element), SImode))\n-\tabort ();\n+      gcc_assert (GET_CODE (vector_element) == SET);\n+      gcc_assert (GET_CODE (SET_DEST (vector_element)) == REG);\n+      gcc_assert (register_is_ok_for_epilogue (SET_DEST (vector_element),\n+\t\t\t\t\t       SImode));\n       \n       mask |= 1 << REGNO (SET_DEST (vector_element));\n     }\n@@ -2327,24 +2321,19 @@ construct_restore_jr (rtx op)\n \tbreak;\n     }\n \n-  if (first >= 32)\n-    abort ();\n+  gcc_assert (first < 32);\n \n   /* Discover the last register to pop.  */\n   if (mask & (1 << LINK_POINTER_REGNUM))\n     {\n-      if (stack_bytes != 16)\n-\tabort ();\n+      gcc_assert (stack_bytes == 16);\n       \n       last = LINK_POINTER_REGNUM;\n     }\n   else\n     {\n-      if (stack_bytes != 0)\n-\tabort ();\n-      \n-      if ((mask & (1 << 29)) == 0)\n-\tabort ();\n+      gcc_assert (!stack_bytes);\n+      gcc_assert (mask & (1 << 29));\n       \n       last = 29;\n     }\n@@ -2401,14 +2390,10 @@ construct_save_jarl (rtx op)\n     }\n \n   /* Paranoia.  */\n-  if (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n-    abort ();\n-  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != PLUS)\n-    abort ();\n-  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0)) != REG)\n-    abort ();\n-  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (XVECEXP (op, 0, 0)) == SET);\n+  gcc_assert (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) == PLUS);\n+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0)) == REG);\n+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) == CONST_INT);\n     \n   /* Work out how many bytes to push onto the stack after storing the\n      registers.  */\n@@ -2430,12 +2415,10 @@ construct_save_jarl (rtx op)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       \n-      if (GET_CODE (vector_element) != SET)\n-\tabort ();\n-      if (GET_CODE (SET_SRC (vector_element)) != REG)\n-\tabort ();\n-      if (! register_is_ok_for_epilogue (SET_SRC (vector_element), SImode))\n-\tabort ();\n+      gcc_assert (GET_CODE (vector_element) == SET);\n+      gcc_assert (GET_CODE (SET_SRC (vector_element)) == REG);\n+      gcc_assert (register_is_ok_for_epilogue (SET_SRC (vector_element),\n+\t\t\t\t\t       SImode));\n       \n       mask |= 1 << REGNO (SET_SRC (vector_element));\n     }\n@@ -2447,23 +2430,19 @@ construct_save_jarl (rtx op)\n \tbreak;\n     }\n \n-  if (first >= 32)\n-    abort ();\n+  gcc_assert (first < 32);\n \n   /* Discover the last register to push.  */\n   if (mask & (1 << LINK_POINTER_REGNUM))\n     {\n-      if (stack_bytes != -16)\n-\tabort ();\n+      gcc_assert (stack_bytes == -16);\n       \n       last = LINK_POINTER_REGNUM;\n     }\n   else\n     {\n-      if (stack_bytes != 0)\n-\tabort ();\n-      if ((mask & (1 << 29)) == 0)\n-\tabort ();\n+      gcc_assert (!stack_bytes);\n+      gcc_assert (mask & (1 << 29));\n       \n       last = 29;\n     }\n@@ -2642,7 +2621,7 @@ v850_insert_attributes (tree decl, tree * attr_ptr ATTRIBUTE_UNUSED )\n \t  switch (v850_get_data_area (decl))\n \t    {\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t      \n \t    case DATA_AREA_SDA:\n \t      kind = ((TREE_READONLY (decl))\n@@ -2711,12 +2690,9 @@ construct_dispose_instruction (rtx op)\n \n   /* Work out how many bytes to pop off the\n      stack before retrieving registers.  */\n-  if (GET_CODE (XVECEXP (op, 0, 1)) != SET)\n-    abort ();\n-  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) != PLUS)\n-    abort ();\n-  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (XVECEXP (op, 0, 1)) == SET);\n+  gcc_assert (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS);\n+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) == CONST_INT);\n     \n   stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1));\n \n@@ -2738,12 +2714,10 @@ construct_dispose_instruction (rtx op)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       \n-      if (GET_CODE (vector_element) != SET)\n-\tabort ();\n-      if (GET_CODE (SET_DEST (vector_element)) != REG)\n-\tabort ();\n-      if (! register_is_ok_for_epilogue (SET_DEST (vector_element), SImode))\n-\tabort ();\n+      gcc_assert (GET_CODE (vector_element) == SET);\n+      gcc_assert (GET_CODE (SET_DEST (vector_element)) == REG);\n+      gcc_assert (register_is_ok_for_epilogue (SET_DEST (vector_element),\n+\t\t\t\t\t       SImode));\n \n       if (REGNO (SET_DEST (vector_element)) == 2)\n \tuse_callt = 1;\n@@ -2837,12 +2811,9 @@ construct_prepare_instruction (rtx op)\n \n   /* Work out how many bytes to push onto\n      the stack after storing the registers.  */\n-  if (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n-    abort ();\n-  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != PLUS)\n-    abort ();\n-  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (XVECEXP (op, 0, 0)) == SET);\n+  gcc_assert (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) == PLUS);\n+  gcc_assert (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) == CONST_INT);\n     \n   stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1));\n \n@@ -2863,12 +2834,10 @@ construct_prepare_instruction (rtx op)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       \n-      if (GET_CODE (vector_element) != SET)\n-\tabort ();\n-      if (GET_CODE (SET_SRC (vector_element)) != REG)\n-\tabort ();\n-      if (! register_is_ok_for_epilogue (SET_SRC (vector_element), SImode))\n-\tabort ();\n+      gcc_assert (GET_CODE (vector_element) == SET);\n+      gcc_assert (GET_CODE (SET_SRC (vector_element)) == REG);\n+      gcc_assert (register_is_ok_for_epilogue (SET_SRC (vector_element),\n+\t\t\t\t\t       SImode));\n \n       if (REGNO (SET_SRC (vector_element)) == 2)\n \tuse_callt = 1;"}, {"sha": "00b542bc77fc13b4f8120c19fd75ee508109c1bd", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "patch": "@@ -554,7 +554,7 @@ enum reg_class\n   else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n    (OFFSET) = compute_frame_size (get_frame_size (), (long *)0);\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n+    gcc_unreachable ();\t\t\t\t\t\t\t\\\n }\n \n /* Keep the stack pointer constant throughout the function.  */"}, {"sha": "7a3e9d2652cac8c2bf894bdfd3e20fc7b0473f80", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=f2f84cbaeb8e41ca297bd0087affc3f2f6befc7d", "patch": "@@ -876,6 +876,7 @@\n   \"\n {\n   rtx insn = get_last_insn_anywhere ();\n+  rtx src;\n \n   if (   (GET_CODE (operands[2]) == CONST_INT\n        && GET_CODE (operands[3]) == CONST_INT))\n@@ -903,28 +904,28 @@\n       if (GET_CODE (operands[3]) != REG)\n \toperands[3] = copy_to_mode_reg (SImode, operands[3]);\n     }\n-  if (GET_CODE (insn) == INSN\n-      && GET_CODE (PATTERN (insn)) == SET\n-      && SET_DEST (PATTERN (insn)) == cc0_rtx)\n+  gcc_assert (GET_CODE (insn) == INSN\n+\t      && GET_CODE (PATTERN (insn)) == SET\n+\t      && SET_DEST (PATTERN (insn)) == cc0_rtx);\n+    \n+  src = SET_SRC (PATTERN (insn));\n+\n+  switch (GET_CODE (src))\n     {\n-      rtx src = SET_SRC (PATTERN (insn));\n-\n-      if (GET_CODE (src) == COMPARE)\n-\t{\n-\t  operands[4] = XEXP (src, 0);\n-\t  operands[5] = XEXP (src, 1);\n-\t}\n-      else if (GET_CODE (src) == REG\n-               || GET_CODE (src) == SUBREG)\n-\t{\n-\t  operands[4] = src;\n-\t  operands[5] = const0_rtx;\n-\t}\n-      else\n-\tabort ();\n+    case COMPARE:\n+      operands[4] = XEXP (src, 0);\n+      operands[5] = XEXP (src, 1);\n+      break;\n+\n+    case REG:\n+    case SUBREG:\n+      operands[4] = src;\n+      operands[5] = const0_rtx;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n }\")\n \n ;; ??? Clobbering the condition codes is overkill.\n@@ -1002,7 +1003,7 @@\n \t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"\")\n \t\t\t   (const_int 1))))]\n   \"TARGET_V850E\"\n-  \"* abort ();\")\n+  \"* gcc_unreachable ();\")\n \n (define_insn \"*sasf_2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}]}